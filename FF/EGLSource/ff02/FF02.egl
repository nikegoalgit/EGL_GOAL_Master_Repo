package ff02;
import corpcom1.*;
import corpcom2.*;
import corpcom3.*;
import corpcom4.*;
import corpcom5.*;
import corpcom6.*;
import corpcom7.*;
import corpx1.*;
import corpx2.*;
import corpy2.*;
import corpz3.*;
import ff.common.*;
import fg.common.*;
import sy.common.*;
import ta.common.*;
//*** PROGRAM=FF02 ****
// This application displays information concerning the com-
// pany's production targets.  The 'co. target', 'NIL target',
// and 'mkups trgt' fields are enterable.  If the user changes
// these fields, several fields will be re-calculated using the
// new values.
// 
// The user must specify the 'range'.  The program will calcu-
// late the 'dom target', 's/buy mkups', 'inline trgt', 's/buy
// inlne', 'variance', 'sug end inv', 'sug inv trn', 'tgt end
// inv', and 'tgt inv trn'.  Also, data for the 's/buy NIL',
// 'dom fcst', 'inline fcst', and 'sales fcst' will be retriev-
// ed fpr display.  The program will allow the user to clear
// the 'target' by use of a PF key.  Another feature of the
// program will allow the user to calculate the 'co. target' by
// use of a PF key.  By use of another PF key, the user can
// save any updated information by putting it out on the data
// base.
// 
// The user may exit to any allowed application, via FAST PATH
// or PF key, at any time.
// 
// -------  --------  ------  ---------------------------------
// CONTROL    DATE     NAME   DESCRIPTION OF CHANGE
// -------  --------  ------  ---------------------------------
//          07/18/89  RHETRI  New application.
// FF2033   09/04/90  RHETRI  Chg date edit to allow any date.
// Fix      09/10/90  RHETRI  Fix re-calc for trgt end inv.
//  FIX     03/13/91  LDELUH  Insert of VMONTH01 was not
//                            initializing buy flag to 'N'.
// Fix      09/05/91  KSANFO  Modified Variance to include only
//                            Inline qtys.
// Fix      10/28/92  MDANGE  Limit begin month to current mon
//                            and greater.  Dont use suggested
//                            buy quantity to calculate ending
//                            inventory when LE buy month.
// FF-404   06/30/93  KGRAHA  Remove Suggested Inventory Turns,
//                            Target Inventory Turns lines and
//                            processing in program.  Also
//                            added blank lines between Makeup
//                            Target Forecast and Inline Target
//                            Forecast, and Variance and
//                            Suggested Ending Inventory.
// FF175    12/11/96  DSMITH  Changed the date range fill
//                            character to '0'.
// *********************
Program FF02 type textUIProgram //VAGen Info - main text program
  {
  includeReferencedFunctions = yes, allowUnqualifiedItemReferences = yes, 
  throwNrfEofExceptions = yes, handleHardIOErrors = no, V60ExceptionCompatibility = yes, 
  I4GLItemsNullable = no, textLiteralDefaultIsString = no, localSQLScope = yes, 
  msgTablePrefix = "FF00", inputRecord = COMMAREA, segmented = yes
  }

  // Data Declarations
  COMMAREA COMMAREA ; // record
  FF02W00 FF02W00; // record
  FF02W01 FF02W01; // record
  FF1REC FF1REC; // record
  FF4REC FF4REC; // record
  FF6REC FF6REC; // record
  FFFREC FFFREC; // record
  FFWREC FFWREC; // record
  FFXREC FFXREC; // record
  FFZREC FFZREC; // record
  SQLCA SQLCA; // record
  TA1REC TA1REC; // record
  TA2REC TA2REC; // record
  TAEREC TAEREC; // record
  XX0XW01 XX0XW01; // record

  // VAGen Info - items needed for migration
  VAGen_EZESYS char(8);
  VAGen_EZEREPLY num(1);
  VAGen_EZE_WAIT_TIME bin(9,2);
  VAGen_EZE_ITEMLEN int;

  // Use Declarations
  use FF02M.FF02M001 // form
   {
    pfKeyEquate = no
  };

  function main()
    // VAGen Info - initialization needed for migration
    VAGen_EZESYS = VGLib.getVAGSysType();
    XPFF001: XPFF001();
     /* ------------------------------------------------------------*/
     /* Initialize working storage and display storage areas.*/
     /* ------------------------------------------------------------*/

    set FF02M001 initial; /* M001 input/output*/
    set FF02W00 empty; /* Working storage*/
    set FF02W01 empty; /* M001 display storage*/
    set SQLCA empty; /* SQL communication area*/
    set TAEREC empty; /* Error diagnosis information*/
    set TA1REC empty; /* Error diagnosis parameters*/
    set XX0XW01 empty; /* Date/time subroutine parameters*/

    FF02W00.FF02WSWF = "Y"; /* Format the map switch*/

     /* ------------------------------------------------------------*/
     /* If key exists, request data.*/
     /* ------------------------------------------------------------*/

    if (FFWREC.FFABEGMO != 0 /* Range exits*/
     && FFWREC.FFAENDMO != 0) /* Range exits*/

      /* ------------------------------------------------------------*/
       /* These fields are used to expand the range.*/
      /* ------------------------------------------------------------*/

      FF02W00.FF02WCBG = FFWREC.FFABEGMO; /* date routines*/
      FF02W00.FF02WCEG = FFWREC.FFAENDMO; /* date routines*/

      /* ------------------------------------------------------------*/
       /* Save range.*/
      /* ------------------------------------------------------------*/

      FF02M001.FFABEGMO = FFWREC.FFABEGMO; /* Beginning month*/
      FF02M001.FFAENDMO = FFWREC.FFAENDMO; /* Ending month*/

      FF02W00.FF02WSWR = "Y"; /* Data requested*/

    else

      FF02W00.FF02WSWR = "N"; /* No data requested*/

    end

     /* ------------------------------------------------------------*/
     /* Flow to converse the main process used to display a map.*/
     /* ------------------------------------------------------------*/

    goto FF02001; /* Converse the main process*/


    FF02001: FF02001();
     /* ------------------------------------------------------------*/
     /* Flow to converse the main process used to display a map.*/
     /* ------------------------------------------------------------*/

    goto FF02001; /* Converse the main process*/


  end // end main
end // end FF02

// Inquire/maintain a table row
Function FF02001()
   /* ------------------------------------------------------------*/
   /* This is the main process used to display a map.  Processing*/
   /* always returns to the top of this process and falls through*/
   /* subordinate processes until an error is found or a valid*/
   /* request is processed.  Processing sequence is as follows:*/

   /* 1) Obtain the data to display.*/
   /* 2) Format the map output area and display the map.*/
   /* 3) Check the attention identifier used to respond.*/
   /* 4) Reset highlighted fields to normal intensity.*/
   /* 5) Verify the data that was entered.*/
   /* 6) Process a valid input request.*/

   /* In all subordinate processes, "EZEFLO" is used to exit to*/
   /* redisplay the map when an error is found.  This is done to*/
   /* minimize the coding effort required to skip subsequent*/
   /* processing under error conditions.*/
   /* ------------------------------------------------------------*/

  FF02100(); /* Obtain the data to display*/

  FF02200(); /* Format and display the map*/

  FF02300(); /* Check attention identifier*/

  FF02400(); /* Reset fields to normal intensity*/

  FF02500(); /* Verify the entered data*/

  FF02600(); /* Process valid input request*/


end // end FF02001

// Obtain the data to display
Function FF02100()
   /* ------------------------------------------------------------*/
   /* If data was not requested or an error was found, return to*/
   /* the previous process.*/
   /* ------------------------------------------------------------*/

  if (FF02W00.FF02WSWR != "Y" /* Data was not requested*/
   || converseVar.validationMsgNum != 0) /* or an error was found*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* Clear the map display storage area*/
   /* ------------------------------------------------------------*/

  set FF02W01 empty; /* M001 display storage*/

   /* ------------------------------------------------------------*/
   /* Save key storage values.*/
   /* ------------------------------------------------------------*/

  FF02W01.FFABEGMO = FF02M001.FFABEGMO; /* Begin month*/
  FF02W01.FFAENDMO = FF02M001.FFAENDMO; /* End month*/

   /* ------------------------------------------------------------*/
   /* Initialize the working storage area.*/
   /* ------------------------------------------------------------*/

  FF02W00.FF02WTTA = 0; /* Zero fill totals*/
  FF02W00.FF02WTTB = 0; /* Zero fill totals*/
  FF02W00.FF02WTTC = 0; /* Zero fill totals*/
  FF02W00.FF02WTTD = 0; /* Zero fill totals*/
  FF02W00.FF02WTTE = 0; /* Zero fill totals*/
  FF02W00.FF02WTTF = 0; /* Zero fill totals*/
  FF02W00.FF02WTTG = 0; /* Zero fill totals*/
  FF02W00.FF02WTTH = 0; /* Zero fill totals*/
  FF02W00.FF02WTTI = 0; /* Zero fill totals*/
  FF02W00.FF02WTTJ = 0; /* Zero fill totals*/
  FF02W00.FF02WTTK = 0; /* Zero fill totals*/
  FF02W00.FF02WTTL = 0; /* Zero fill totals*/
  FF02W00.FF02WTTM = 0; /* Zero fill totals*/
  FF02W00.FF02WTTN = 0; /* Zero fill totals*/
  FF02W00.FF02WTTO = 0; /* Zero fill totals*/
  FF02W00.FF02WTTP = 0; /* Zero fill totals*/

  FF02W00.FF02WRTN = "N"; /* clear return code switch*/
  FF02W00.FF02WDSW = "N"; /* clear data found switch*/
  FF02W00.FF02WSUB = 0; /* clear "tot" position pointer*/

  move 0 to FF02W00.FF02WHCT[1] for all; /* clear hold co trgt*/
  move 0 to FF02W00.FF02WHNT[1] for all; /* clear hold nil trgt*/
  move 0 to FF02W00.FF02WHMT[1] for all; /* clear hold mkp trgt*/

   /* ------------------------------------------------------------*/
   /* calculate the buy month*/
   /* ------------------------------------------------------------*/

  FF02105(); /* calculate the buy month*/

   /* ------------------------------------------------------------*/
   /* Expand date range.*/
   /* ------------------------------------------------------------*/

  FF02110(); /* expand range to set of yymm*/

   /* ------------------------------------------------------------*/
   /* Obtain data for INV TRN  calculations*/
   /* ------------------------------------------------------------*/

  FF02120(); /* Obtain data for calcs*/

   /* ------------------------------------------------------------*/
   /* Obtain data for display and calculations.  FF02WRTN refers*/
   /* to a particular call.  FF02WDSW refers to all the calls*/
   /* for the screen.*/
   /* ------------------------------------------------------------*/

  FF02W00.FF02WCNT = 0; /* initialize subscript*/
  while (FF02W00.FF02WCNT < FF02W00.FF02WNBR)

    FF02W00.FF02WCNT = FF02W00.FF02WCNT + 1; /* add one to counter*/

    FF02130(); /* Call DFCAST.VMONTH01*/

    FF02140(); /* Save trgts for compare*/

    FF02150(); /* Obtain DFCAST.VMLTYP01*/

    if (FF02W00.FF02WRTN == "Y") /* Normal return codes*/

      FF02160(); /* Calculate the data*/

      FF02W00.FF02WDSW = "Y"; /* data found*/
      FF02W00.FF02WRTN = " "; /* clear switch*/

    end

  end

  FF02W00.FF02WST0 = 0; /* clear set-to-zero switch*/
  FF02W00.FF02WCAL = 0; /* clear calculation switch*/

   /* ------------------------------------------------------------*/
   /* Check to see if data was found to display.*/
   /* ------------------------------------------------------------*/

  if (FF02W00.FF02WDSW == "Y") /* data was found*/

    FF02170(); /* Translate and store totals*/

    /* ELSE ;*/

    /* MOVE '100' TO FFWREC.XXXMODID ; Module identification*/
    /* MOVE 18 TO FFWREC.XXXMSGNO    ; Indicate no data found*/

    /* EZERTN                        ; Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* Indicate request for data complete.*/
   /* ------------------------------------------------------------*/

  FF02W00.FF02WSWR = "N"; /* Request for data switch*/


end // end FF02100

// Calculate the buy month
Function FF02105()
   /* ------------------------------------------------------------*/
     /* Buy month calculation , stored in ff02W00.ff02Wbuy*/
   /* ------------------------------------------------------------*/

  FF02S04(); /* get futures cutoff date*/
  FF02W00.FF02WXDT = FF1REC.FF1FUTDT;

  FF02W00.FF02WXMM = FF02W00.FF02WXMM + 5;
  if (FF02W00.FF02WXMM > 12)
    FF02W00.FF02WXMM = FF02W00.FF02WXMM - 12;
    if (FF02W00.FF02WXYY == 99)
      FF02W00.FF02WXYY = 00;
      FF02W00.FF02WXCC = FF02W00.FF02WXCC + 1;
    else
      FF02W00.FF02WXYY = FF02W00.FF02WXYY + 1;
    end
  end

  FF02W00.FF02WBUY = FF02W00.FF02WXYM; /* store CCYYMM*/
end // end FF02105

// Expand range to set of YYMM
Function FF02110()
   /* ------------------------------------------------------------*/
   /* Clear all fields used to expand range.*/
   /* ------------------------------------------------------------*/

  FF02W00.FF02WHDT = 0; /* clear 'x' date*/
  FF02W00.FF02WBDT = 0; /* clear 'y' date*/
  FF02W00.FF02WEDT = 0; /* clear 'z' date*/
  FF02W00.FF02WNBR = 0; /* clear nbr of months*/
  FF02W00.FF02WNMO = 0; /* clear num month*/
  FF02W00.FF02WNCC = 0; /* clear cc*/
  move " " to FF02W01.FF02WRMO[1] for all; /* clear alpha month*/

   /* ------------------------------------------------------------*/
   /* Expand range to a set of YYMM and store in array.*/
   /* ------------------------------------------------------------*/

  FF02W00.FF02WBDT = FF02M001.FFABEGMO; /* load beg mo mask*/
  FF02W00.FF02WHDT = FF02M001.FFABEGMO; /* load hold mo mask*/
  FF02W00.FF02WEDT = FF02M001.FFAENDMO; /* load end mo mask*/
  FF02W00.FF02WNBR = 1; /* set subscript to 1*/

  FF02W01.FF02WRMO[1] = FF02W00.FF02WHDT;
                                   /* load alpha month 1st time*/
  FF02W00.FF02WNCC[1] = FF02W00.FF02WCBC;
                                   /* load hold cc to 1st occur*/
  FF02W00.FF02WNMO[1] = FF02W00.FF02WHDT; /* load num mo to 1st occur*/

  if (FF02W00.FF02WBDT == FF02W00.FF02WEDT)
                                   /* if range is only one month long*/
       /* NEXT SENTENCE*/
  else
    if (FF02W00.FF02WBYY == FF02W00.FF02WEYY) /* if begin year = end year*/

      FF02W00.FF02WHCC = FF02W00.FF02WCBC; /* load hold cc with b cc*/
      while (FF02W00.FF02WHMM < FF02W00.FF02WEMM) /* if hold mo ^LT end mo*/
        FF02111();
      end

    else
      FF02W00.FF02WHCC = FF02W00.FF02WCBC; /* load hold cc with b cc*/
      while (FF02W00.FF02WHMM < 12) /* until hold month not less 12*/
        FF02111();
      end
      FF02W00.FF02WHCC = FF02W00.FF02WCEC; /* load hold cc with e cc*/
      FF02W00.FF02WHYY = FF02W00.FF02WEYY; /* move end YY to hold*/
      FF02W00.FF02WHMM = 0; /* load 0 in hold MM*/
      while (FF02W00.FF02WHMM < FF02W00.FF02WEMM) /* if hold MM LT end MM*/
        FF02111();
      end
    end
  end

  FF02W00.FF02WCNT = FF02W00.FF02WNBR;
  FF02W00.FF02WCNT = FF02W00.FF02WCNT + 1; /* add one to subscript*/
  FF02W01.FF02WRMO[FF02WCNT] = "TOTL"; /* load 'tot' to header line*/

   /* ------------------------------------------------------------*/
   /* Expland range three more months for use in calculations.*/
   /* ------------------------------------------------------------*/

  FF02112();


end // end FF02110

// Load YYMM array with range
Function FF02111()
   /* ------------------------------------------------------------*/
   /* load array with the set of YYMM from the range.*/
   /* ------------------------------------------------------------*/

  FF02WNBR = FF02WNBR + 1; /* add one to subscript*/
  FF02WHMM = FF02WHMM + 1; /* add one to month*/

  FF02W01.FF02WRMO[FF02WNBR] = FF02W00.FF02WHDT; /* load alpha yymm*/
  FF02W00.FF02WNMO[FF02WNBR] = FF02W00.FF02WHDT; /* load num yymm*/
  FF02W00.FF02WNCC[FF02WNBR] = FF02W00.FF02WHCC; /* load cc*/


end // end FF02111

// Expand range 3 more months
Function FF02112()
   /* ------------------------------------------------------------*/
   /* Expand range three more months for "SUG INV TRN" and*/
   /* "TGT IN TRN" calculations.*/
   /* ------------------------------------------------------------*/

  FF02W00.FF02WAVG = FF02W00.FF02WNBR; /* move nbr to avg sub*/

  if (FF02W00.FF02WEMM < 10) /* if end month less than 10*/
    /* ------------------------------------------------------------*/
     /* If the month is less than 10, adding three to it will not*/
     /* take you into the next year.*/
    /* ------------------------------------------------------------*/

    FF02W00.FF02WHMM = FF02W00.FF02WHMM + 1; /* add 1 to hold month*/
    FF02W00.FF02WAVG = FF02W00.FF02WAVG + 1; /* add 1 to sub*/
    FF02W00.FF02WNMO[FF02WAVG] = FF02W00.FF02WHDT; /* yymm*/
    FF02W00.FF02WNCC[FF02WAVG] = FF02W00.FF02WCBC; /* cc*/

    FF02W00.FF02WHMM = FF02W00.FF02WHMM + 1; /* add 1 to hold month*/
    FF02W00.FF02WAVG = FF02W00.FF02WAVG + 1; /* add 1 to sub*/
    FF02W00.FF02WNMO[FF02WAVG] = FF02W00.FF02WHDT; /* yymm*/
    FF02W00.FF02WNCC[FF02WAVG] = FF02W00.FF02WCBC; /* cc*/

    FF02W00.FF02WHMM = FF02W00.FF02WHMM + 1; /* add 1 to hold month*/
    FF02W00.FF02WAVG = FF02W00.FF02WAVG + 1; /* add 1 to sub*/
    FF02W00.FF02WNMO[FF02WAVG] = FF02W00.FF02WHDT; /* yymm*/
    FF02W00.FF02WNCC[FF02WAVG] = FF02W00.FF02WCBC; /* cc*/

  end

  if (FF02W00.FF02WEMM == 10) /* if end month equal 10*/
    /* ------------------------------------------------------------*/
     /* If the month is equal 10, then the next three months will*/
     /* be 11, 12, and 01 of the next year.*/
    /* ------------------------------------------------------------*/

    FF02W00.FF02WHMM = FF02W00.FF02WHMM + 1; /* add 1 to hold month*/
    FF02W00.FF02WAVG = FF02W00.FF02WAVG + 1; /* add 1 to sub*/
    FF02W00.FF02WNMO[FF02WAVG] = FF02W00.FF02WHDT; /* yymm*/
    FF02W00.FF02WNCC[FF02WAVG] = FF02W00.FF02WCBC; /* cc*/

    FF02W00.FF02WHMM = FF02W00.FF02WHMM + 1; /* add 1 to hold month*/
    FF02W00.FF02WAVG = FF02W00.FF02WAVG + 1; /* add 1 to sub*/
    FF02W00.FF02WNMO[FF02WAVG] = FF02W00.FF02WHDT; /* yymm*/
    FF02W00.FF02WNCC[FF02WAVG] = FF02W00.FF02WCBC; /* cc*/

    FF02W00.FF02WHYY = FF02W00.FF02WHYY + 1; /* add 1 to hold year*/
    FF02W00.FF02WHMM = 1; /* move 1 to hold month*/
    FF02W00.FF02WAVG = FF02W00.FF02WAVG + 1; /* add 1 to sub*/
    FF02W00.FF02WNMO[FF02WAVG] = FF02W00.FF02WHDT; /* yymm*/
    FF02W00.FF02WNCC[FF02WAVG] = FF02W00.FF02WCEC; /* cc*/

  end

  if (FF02W00.FF02WEMM == 11) /* if end month equal 11*/
    /* ------------------------------------------------------------*/
     /* If the month is equal 11, then the next three months will*/
     /* be 12, and 01 and 02 of the next year.*/
    /* ------------------------------------------------------------*/

    FF02W00.FF02WHMM = FF02W00.FF02WHMM + 1; /* add 1 to hold month*/
    FF02W00.FF02WAVG = FF02W00.FF02WAVG + 1; /* add 1 to sub*/
    FF02W00.FF02WNMO[FF02WAVG] = FF02W00.FF02WHDT; /* yymm*/
    FF02W00.FF02WNCC[FF02WAVG] = FF02W00.FF02WCBC; /* cc*/

    FF02W00.FF02WHYY = FF02W00.FF02WHYY + 1; /* add 1 to hold year*/
    FF02W00.FF02WHMM = 1; /* move 1 to hold month*/
    FF02W00.FF02WAVG = FF02W00.FF02WAVG + 1; /* add 1 to sub*/
    FF02W00.FF02WNMO[FF02WAVG] = FF02W00.FF02WHDT; /* yymm*/
    FF02W00.FF02WNCC[FF02WAVG] = FF02W00.FF02WCEC; /* cc*/

    FF02W00.FF02WHMM = FF02W00.FF02WHMM + 1; /* add 1 to hold month*/
    FF02W00.FF02WAVG = FF02W00.FF02WAVG + 1; /* add 1 to sub*/
    FF02W00.FF02WNMO[FF02WAVG] = FF02W00.FF02WHDT; /* yymm*/
    FF02W00.FF02WNCC[FF02WAVG] = FF02W00.FF02WCBC; /* cc*/

  end

  if (FF02W00.FF02WEMM == 12) /* if end month equal 12*/
    /* ------------------------------------------------------------*/
     /* If the month is equal 12, then the next three months will*/
     /* be 01, 02, and 03 of the next year.*/
    /* ------------------------------------------------------------*/

    FF02W00.FF02WHYY = FF02W00.FF02WHYY + 1; /* add 1 to hold year*/
    FF02W00.FF02WHMM = 1; /* move 1 to hold month*/
    FF02W00.FF02WAVG = FF02W00.FF02WAVG + 1; /* add 1 to sub*/
    FF02W00.FF02WNMO[FF02WAVG] = FF02W00.FF02WHDT; /* yymm*/
    FF02W00.FF02WNCC[FF02WAVG] = FF02W00.FF02WCEC; /* cc*/

    FF02W00.FF02WHMM = FF02W00.FF02WHMM + 1; /* add 1 to hold month*/
    FF02W00.FF02WAVG = FF02W00.FF02WAVG + 1; /* add 1 to sub*/
    FF02W00.FF02WNMO[FF02WAVG] = FF02W00.FF02WHDT; /* yymm*/
    FF02W00.FF02WNCC[FF02WAVG] = FF02W00.FF02WCEC; /* cc*/

    FF02W00.FF02WHMM = FF02W00.FF02WHMM + 1; /* add 1 to hold month*/
    FF02W00.FF02WAVG = FF02W00.FF02WAVG + 1; /* add 1 to sub*/
    FF02W00.FF02WNMO[FF02WAVG] = FF02W00.FF02WHDT; /* yymm*/
    FF02W00.FF02WNCC[FF02WAVG] = FF02W00.FF02WCBC; /* cc*/

  end
end // end FF02112

// Obtain data for INV TRN calc
Function FF02120()
   /* ------------------------------------------------------------*/
   /* Format fffrec for call.*/
   /* ------------------------------------------------------------*/

  FF02W00.FF02WMCC = FF02W00.FF02WNCC[1]; /* cc to mask*/
  FF02W00.FF02WMMO = FF02W00.FF02WNMO[1]; /* yymm to mask*/
  FFFREC.FFFBEGMO = FF02W00.FF02WMDT; /* beg month*/

  FF02W00.FF02WMCC = FF02W00.FF02WNCC[FF02WAVG]; /* cc to mask*/
  FF02W00.FF02WMMO = FF02W00.FF02WNMO[FF02WAVG]; /* yymm to mask*/
  FFFREC.FFFENDMO = FF02W00.FF02WMDT; /* end month*/

   /* ------------------------------------------------------------*/
   /* Clear working storage fields.*/
   /* ------------------------------------------------------------*/

  move 0 to FF02W00.FF02WSLS[1] for all; /* initialize sales fcst*/

   /* ------------------------------------------------------------*/
   /* Clear row storage area.*/
   /* ------------------------------------------------------------*/

  set FF6REC empty; /* Clear DFCAST.VMLTYP01 record.*/

   /* ------------------------------------------------------------*/
   /* Format keys for call.*/
   /* ------------------------------------------------------------*/

  FF6REC.XPLCD = "*"; /* line*/
  FF6REC.YPGCD = "*"; /* type*/

   /* ------------------------------------------------------------*/
   /* OPEN CURSOR FOR DFCAST.VMLTYP01.*/
   /* ------------------------------------------------------------*/

  FFFREC.FFFFUNCD = "S2"; /* function code*/
  FF02S01(); /* Open MLTYP*/

   /* ------------------------------------------------------------*/
   /* Fetch data into table.*/
   /* ------------------------------------------------------------*/

  FFFREC.FFFFUNCD = "N2"; /* Fetch next function code*/

  FF02W00.FF02WCNT = 1; /* set counter*/

  while (FF02W00.FF02WCNT <= FF02W00.FF02WAVG)
    /* ------------------------------------------------------------*/
     /* Clear row storage area.*/
    /* ------------------------------------------------------------*/

    set FF6REC empty; /* Clear DFCAST.VMLTYP01 record.*/

    /* ------------------------------------------------------------*/
     /* Format keys for call.*/
    /* ------------------------------------------------------------*/

    FF6REC.XPLCD = "*"; /* line*/
    FF6REC.YPGCD = "*"; /* type*/


    FF02S02(); /* Fetch MLTYP*/

    /* ------------------------------------------------------------*/
     /* Store data in working storage.*/
    /* ------------------------------------------------------------*/

    FF02W00.FF02WTOO[FF02WCNT] = FF6REC.FG4ONORD; /* on order*/
    FF02W00.FF02WSLS[FF02WCNT] = FF6REC.FF6SLFCT; /* sales forecast*/
    FF02W00.FF02WINV[FF02WCNT] = FF6REC.FF6BEINV; /* beg inventory*/

    FF02W00.FF02WCNT = FF02W00.FF02WCNT + 1; /* add one to counter*/

  end
   /* ------------------------------------------------------------*/
   /* Close cursor for DFCAST.VMLTYP01.*/
   /* ------------------------------------------------------------*/

  FFFREC.FFFFUNCD = "C2"; /* function code*/
  FF02S03(); /* Close MLTYP*/


end // end FF02120

// Select DFCAST.VMONTH01
Function FF02130()
   /* ------------------------------------------------------------*/
   /* Clear the row storage area.*/
   /* ------------------------------------------------------------*/

  set FF4REC empty; /* clear DFCAST.VMONTH01 record.*/

   /* ------------------------------------------------------------*/
   /* Format keys for call to DFCAST.VMONTH01.*/
   /* ------------------------------------------------------------*/

  FF02W00.FF02WMCC = FF02W00.FF02WNCC[FF02WCNT]; /* cc to mask*/
  FF02W00.FF02WMMO = FF02W00.FF02WNMO[FF02WCNT]; /* yymm to mask*/
  FF4REC.FF4FCTMO = FF02W00.FF02WMDT;

   /* ------------------------------------------------------------*/
   /* Select the row to display from the table.*/
   /* ------------------------------------------------------------*/

  try
    call "IO3720" ("S ", SQLCA, FF4REC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

   /* ------------------------------------------------------------*/
   /* If successful or not found, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/

    if (SQLCA.VAGen_SQLCODE == 0 /* Normal return code*/
     || SQLCA.VAGen_SQLCODE == 100) /* or row not found*/

      if (SQLCA.VAGen_SQLCODE == 0) /* Normal return code*/
        FF02W00.FF02WRTN = "Y"; /* Row was returned*/
      end

      return; /* Return to previous process*/

    end

  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL Commarea*/

  FFWREC.XXXMODID = "130"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(47); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(01); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    converseLib.clearScreen();
     /* Clear screen before display*/

  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "SELECT THE TABLE ROW";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FFWREC.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFCAST  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VMONTH01"; /* Table view name*/
  TA1REC.TA1TBLKE = FF4REC.FF4KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end FF02130

// Save trgts for updt compare
Function FF02140()
   /* ------------------------------------------------------------*/
   /* Save Co. trgt for compare.*/
   /* ------------------------------------------------------------*/

  FFXREC.FFXNUMB = FF4REC.FF4RTRGT; /* send to translate*/

  XSFFS12();

  FF02W00.FF02WHCT[FF02WCNT] = FFXREC.FFXCHAR; /* hold for compare*/

   /* ------------------------------------------------------------*/
   /* Save NIL trgt for compare.*/
   /* ------------------------------------------------------------*/

  FFXREC.FFXNUMB = FF4REC.FF4NLTGT; /* send to translate*/

  XSFFS12();

  FF02W00.FF02WHNT[FF02WCNT] = FFXREC.FFXCHAR; /* hold for compare*/

   /* ------------------------------------------------------------*/
   /* Save MKP trgt for compare.*/
   /* ------------------------------------------------------------*/

  FFXREC.FFXNUMB = FF4REC.FF4MKTGT; /* send to translate*/

  XSFFS12();

  FF02W00.FF02WHMT[FF02WCNT] = FFXREC.FFXCHAR; /* hold for compare*/

end // end FF02140

// Format VMLTYP01 calls
Function FF02150()
   /* ------------------------------------------------------------*/
   /* Format fffrec for call. Only one month is retrieved at a*/
   /* time.*/
   /* ------------------------------------------------------------*/

  FF02W00.FF02WMCC = FF02W00.FF02WNCC[FF02WCNT]; /* cc to mask*/
  FF02W00.FF02WMMO = FF02W00.FF02WNMO[FF02WCNT]; /* yymm to mask*/
  FFFREC.FFFBEGMO = FF02W00.FF02WMDT; /* beg month*/
  FFFREC.FFFENDMO = FF02W00.FF02WMDT; /* end month*/

   /* ------------------------------------------------------------*/
   /* Clear working storage fields.*/
   /* ------------------------------------------------------------*/

  move 0 to FF02W00.FF02WHSF[1] for all; /* initialize sales fcst*/
  move 0 to FF02W00.FF02WHPF[1] for all; /* initialize prdctn fcst*/
  move 0 to FF02W00.FF02WHPT[1] for all; /* initialize prdctn trgt*/
  move 0 to FF02W00.FF02WHBI[1] for all; /* initialize beginning inv*/
  move 0 to FF02W00.FF02WHSB[1] for all; /* initialize s/buy*/
  move 0 to FF02W00.FF02WHOO[1] for all; /* initialize on order*/
  move 0 to FF02W00.FF02WHSS[1] for all; /* initialize safety stock*/

   /* ------------------------------------------------------------*/
   /* Clear row storage area for INLINE.*/
   /* ------------------------------------------------------------*/

  set FF6REC empty; /* Clear DFCAST.VMLTYP01 record.*/

   /* ------------------------------------------------------------*/
   /* Format keys for INLINE data.*/
   /* ------------------------------------------------------------*/

  FF6REC.XPLCD = "*"; /* line*/
  FF6REC.YPGCD = "01"; /* inline type*/

   /* ------------------------------------------------------------*/
   /* Call for INLINE data.*/
   /* ------------------------------------------------------------*/

  FFFREC.FFFFUNCD = "S2"; /* Format function cd*/
  FF02151(); /* Open MLTYP*/

  FFFREC.FFFFUNCD = "N2"; /* Format function cd*/
  FF02152(); /* Fetch MLTYP*/

   /* ------------------------------------------------------------*/
   /* Store INLINE data in working storage.*/
   /* ------------------------------------------------------------*/

  FF02W00.FF02WHSF[1] = FF6REC.FF6SLFCT; /* sales forecast*/
  FF02W00.FF02WHPF[1] = FF6REC.FF6PRFCT; /* production fcst*/
  FF02W00.FF02WHPT[1] = FF6REC.FF4RTRGT; /* production trgt*/
  FF02W00.FF02WHBI[1] = FF6REC.FF6BEINV; /* beginning inv*/
  FF02W00.FF02WHSB[1] = FF6REC.FF6SUGBY; /* suggested buy*/
  FF02W00.FF02WHOO[1] = FF6REC.FG4ONORD; /* on order*/
  FF02W00.FF02WHSS[1] = FF6REC.FF6SFSTK; /* safety stock*/

   /* ------------------------------------------------------------*/
   /* Close cursor for DFCAST.VMLTYP01.*/
   /* ------------------------------------------------------------*/

  FFFREC.FFFFUNCD = "C2"; /* Format function cd*/
  FF02153(); /* Close MLTYP*/

   /* ------------------------------------------------------------*/
   /* Clear row storage area for MAKEUPS.*/
   /* ------------------------------------------------------------*/

  set FF6REC empty; /* Clear DFCAST.VMLTYP01 record.*/

   /* ------------------------------------------------------------*/
   /* Format keys for call.*/
   /* ------------------------------------------------------------*/

  FF6REC.XPLCD = "*"; /* line*/
  FF6REC.YPGCD = "02"; /* MKUPS type*/

   /* ------------------------------------------------------------*/
   /* Make call for MAKEUPS data.*/
   /* ------------------------------------------------------------*/

  FFFREC.FFFFUNCD = "S2"; /* function code*/
  FF02151(); /* Open MLTYP*/

  FFFREC.FFFFUNCD = "N2"; /* Fetch next function code*/
  FF02152(); /* Fetch MLTYP*/

   /* ------------------------------------------------------------*/
   /* Store MAKEUPS data in working storage.*/
   /* ------------------------------------------------------------*/

  FF02W00.FF02WHSF[2] = FF6REC.FF6SLFCT; /* sales forecast*/
  FF02W00.FF02WHPF[2] = FF6REC.FF6PRFCT; /* production fcst*/
  FF02W00.FF02WHPT[2] = FF6REC.FF4RTRGT; /* production trgt*/
  FF02W00.FF02WHBI[2] = FF6REC.FF6BEINV; /* beginning inv*/
  FF02W00.FF02WHSB[2] = FF6REC.FF6SUGBY; /* suggested buy*/
  FF02W00.FF02WHOO[2] = FF6REC.FG4ONORD; /* on order*/
  FF02W00.FF02WHSS[2] = FF6REC.FF6SFSTK; /* safety stock*/

   /* ------------------------------------------------------------*/
   /* Close cursor for DFCAST.VMLTYP01.*/
   /* ------------------------------------------------------------*/

  FFFREC.FFFFUNCD = "C2"; /* function code*/
  FF02153(); /* Close MLTYP*/

end // end FF02150

// Open  DFCAST.VMLTYP01
Function FF02151()
   /* ------------------------------------------------------------*/
   /* Open VMLTYP01.*/
   /* ------------------------------------------------------------*/

  try
    call "IO3750" (FFFREC, SQLCA, FF6REC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/

    if (SQLCA.VAGen_SQLCODE == 0) /* Normal return code*/

      return; /* Return to previous process*/

    end

  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL Commarea*/

  FFWREC.XXXMODID = "151"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(47); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(01); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    converseLib.clearScreen();
     /* Clear screen before display*/

  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "OPEN DFCAST.VMLTYP01";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FFWREC.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFCAST  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VMLTYP01"; /* Table view name*/
  TA1REC.TA1TBLKE = FF6REC.FF6KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end FF02151

// Fetch DFCAST.VMLTYP01
Function FF02152()
   /* ------------------------------------------------------------*/
   /* Fetch VMLTYP01.*/
   /* ------------------------------------------------------------*/

  try
    call "IO3750" (FFFREC, SQLCA, FF6REC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

   /* ------------------------------------------------------------*/
   /* If successful or not found, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/

    if (SQLCA.VAGen_SQLCODE == 0 /* Normal return code*/
     || SQLCA.VAGen_SQLCODE == 100) /* or row not found*/

      if (SQLCA.VAGen_SQLCODE == 0) /* Normal return code*/
        FF02W00.FF02WRTN = "Y"; /* Row was returned*/
      end

      return; /* Return to previous process*/

    end

  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL Commarea*/

  FFWREC.XXXMODID = "152"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(47); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(01); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    converseLib.clearScreen();
     /* Clear screen before display*/

  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "FETCH DFCAST.VMLTYP01";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FFWREC.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFCAST  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VMLTYP01"; /* Table view name*/
  TA1REC.TA1TBLKE = FF6REC.FF6KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end FF02152

// Close DFCAST.VMLTYP01
Function FF02153()
   /* ------------------------------------------------------------*/
   /* Close VMLTYP01.*/
   /* ------------------------------------------------------------*/

  try
    call "IO3750" (FFFREC, SQLCA, FF6REC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/

    if (SQLCA.VAGen_SQLCODE == 0) /* Normal return code*/

      return; /* Return to previous process*/

    end

  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL Commarea*/

  FFWREC.XXXMODID = "153"; /* Module identification*/

  converseLib.validationFailed(01); /* Indicate system error*/
  TA1REC.TA1FUNC = "RETN"; /* Termination function*/

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "CLOSE DFCAST.VMLTYP01";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FFWREC.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFCAST  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VMLTYP01"; /* Table view name*/
  TA1REC.TA1TBLKE = FF6REC.FF6KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end FF02153

// Calculate fields
Function FF02160()
   /* ------------------------------------------------------------*/
   /* Indicate modifiable data.*/
   /* ------------------------------------------------------------*/

  FF02W01.CACHGFL = "Y"; /* Indicate modifiable data*/

   /* ------------------------------------------------------------*/
   /* Co. Trgt can be the amount from the D/B, be set to zero.  |*/
   /* per request by user, or a calculated field (if requested).|*/
                                                             /* |*/
   /* FF4REC.FF4RTRGT     -- PRODUCTION TARGET CO.              |*/
                                                             /* |*/
   /* FF02W00.FF02WHSB(1) -- S/BUY INLINE                       |*/
   /* FF02W00.FF02WHSB(2) -- S/BUY MKUP                         |*/
   /* FF4REC.FF4NSBUY     -- S/BUY NIL                          |*/
   /* ------------------------------------------------------------*/

  if (FF02W00.FF02WST0 == "Y") /* if set-to-zero requested*/

    FF02W01.FF02WCOT[FF02WCNT] = 0; /* disp storage*/

  else

    if (FF02W00.FF02WCAL == "Y") /* if calulation requested*/

      /* --------------------------------------------------*/
       /* Co. trgt = s/buy inline + s/buy mkups + s/buy NIL*/
      /* --------------------------------------------------*/
      FF02W00.FF02WFDA = FF02W00.FF02WHSB[1] + FF02W00.FF02WHSB[2];
      FF02W00.FF02WFDA = FF02W00.FF02WFDA + FF4REC.FF4NSBUY;

      FF02W01.FF02WCOT[FF02WCNT] = FF02W00.FF02WFDA; /* disp storage*/
      FF02W00.FF02WTTA = FF02W00.FF02WTTA + FF02W00.FF02WFDA; /* totals*/

    else /* This is the 'normal' routine*/

      FF02W01.FF02WCOT[FF02WCNT] = FF4REC.FF4RTRGT; /* disp storage*/
      FF02W00.FF02WTTA = FF02W00.FF02WTTA + FF4REC.FF4RTRGT; /* totals*/

    end

  end

   /* ------------------------------------------------------------*/
   /* Move S/BUY NIL to display storage and add to total.       |*/
                                                             /* |*/
   /* FF4REC.FF4NSBUY     -- S/BUY NIL                          |*/
   /* ------------------------------------------------------------*/

  FF02W01.FF02WSBN[FF02WCNT] = FF4REC.FF4NSBUY; /* disp storage*/
  FF02W00.FF02WTTB = FF02W00.FF02WTTB + FF4REC.FF4NSBUY; /* totals*/

   /* ------------------------------------------------------------*/
   /* Move NIL Target to display storage and add to total.      |*/
   /* If set-to-zero requested by user, move zero to storage.|*/
                                                             /* |*/
   /* FF4REC.FF4NLTGT     -- NIL TRGT                           |*/
   /* ------------------------------------------------------------*/

  if (FF02W00.FF02WST0 == "Y") /* if set-to-zero requested*/

    FF02W01.FF02WNLT[FF02WCNT] = 0; /* disp storage*/

  else

    FF02W01.FF02WNLT[FF02WCNT] = FF4REC.FF4NLTGT; /* disp storage*/
    FF02W00.FF02WTTC = FF02W00.FF02WTTC + FF4REC.FF4NLTGT; /* totals*/

  end

   /* ------------------------------------------------------------*/
   /* Calculate Dom target & move to display storage.           |*/
                                                             /* |*/
   /* Dom trgt = Co. trgt  -  NIl trgt                          |*/
                                                             /* |*/
   /* FF02W01.FF02WCOT(FF02WCNT) -- Co. trgt                    |*/
   /* FF02W01.FF02WNLT(FF02WCNT) -- Nil trgt                    |*/
   /* ------------------------------------------------------------*/

  FF02W00.FF02WFDA = 0; /* clear work fields*/
  FF02W00.FF02WFDA = FF02W00.FF02WFDA + FF02W01.FF02WCOT[FF02WCNT];
  FF02W00.FF02WFDA = FF02W00.FF02WFDA - FF02W01.FF02WNLT[FF02WCNT];

  FF02W01.FF02WDTG[FF02WCNT] = FF02W00.FF02WFDA; /* disp storage*/
  FF02W00.FF02WTTD = FF02W00.FF02WTTD + FF02W00.FF02WFDA; /* totals*/

   /* ------------------------------------------------------------*/
   /* Calculate Dom FCST & move to display storage.             |*/
                                                             /* |*/
   /* FF02W00.FF02WHPF(1) -- prdcnt fcst inline                 |*/
   /* FF02W00.FF02WHPF(2) -- prdcnt fcst mkup                   |*/
   /* ------------------------------------------------------------*/

  FF02W00.FF02WFDA = FF02W00.FF02WHPF[1] + FF02W00.FF02WHPF[2];

  FF02W01.FF02WPFC[FF02WCNT] = FF02W00.FF02WFDA; /* disp storage*/
  FF02W00.FF02WTTE = FF02W00.FF02WTTE + FF02W00.FF02WFDA; /* totals*/

   /* ------------------------------------------------------------*/
   /* Move S/BUY MKUP to display storage and add to total.      |*/
                                                             /* |*/
   /* FF02W00.FF02WHSB(2) -- s/buy mkup                         |*/
   /* ------------------------------------------------------------*/

  FF02W01.FF02WSBM[FF02WCNT] = FF02W00.FF02WHSB[2]; /* s/buy mkup*/
  FF02W00.FF02WTTF = FF02W00.FF02WTTF + FF02W00.FF02WHSB[2]; /* totals*/

   /* ------------------------------------------------------------*/
   /* Move MKUP Target to display storage and add to total.     |*/
   /* If set-to-zero requested by user, move zero to storage.   |*/
                                                             /* |*/
   /* FF4REC.FF4MKTGT     -- MKUP TRGT                          |*/
   /* ------------------------------------------------------------*/

  if (FF02W00.FF02WST0 == "Y") /* if set-to-zero requested*/

    FF02W01.FF02WMTG[FF02WCNT] = 0; /* disp storage*/

  else

    FF02W01.FF02WMTG[FF02WCNT] = FF4REC.FF4MKTGT; /* disp storage*/
    FF02W00.FF02WTTG = FF02W00.FF02WTTG + FF4REC.FF4MKTGT; /* totals*/

  end

   /* ------------------------------------------------------------*/
   /* Calculate INLINE target & move to display storage.        |*/
                                                             /* |*/
   /* INLINE TRGT = DOMESTIC trgt  -  MKUP trgt                 |*/
   /* ------------------------------------------------------------*/

  FF02W00.FF02WFDA = 0; /* clear field*/

  FF02W00.FF02WFDA = FF02W00.FF02WFDA + FF02W01.FF02WDTG[FF02WCNT];
  FF02W00.FF02WFDA = FF02W00.FF02WFDA - FF02W01.FF02WMTG[FF02WCNT];

  FF02W01.FF02WILT[FF02WCNT] = FF02W00.FF02WFDA; /* disp storage*/
  FF02W00.FF02WTTH = FF02W00.FF02WTTH + FF02W00.FF02WFDA; /* totals*/

   /* ------------------------------------------------------------*/
   /* Move INLINE fcst to display storage and add to total.     |*/
                                                             /* |*/
   /* FF02W00.FF02WHPF(1) -- PRDCTN FCST INLINE                 |*/
   /* ------------------------------------------------------------*/

  FF02W01.FF02WILF[FF02WCNT] = FF02W00.FF02WHPF[1]; /* disp str*/
  FF02W00.FF02WTTI = FF02W00.FF02WTTI + FF02W00.FF02WHPF[1]; /* totals*/

   /* ------------------------------------------------------------*/
   /* Move S/BUY INLINE to display storage and add to total.    |*/
                                                             /* |*/
   /* FF02W00.FF02WHSB(1) -- S/BUY INLINE                       |*/
   /* ------------------------------------------------------------*/

  FF02W01.FF02WSBI[FF02WCNT] = FF02W00.FF02WHSB[1]; /* s/buy mkup*/
  FF02W00.FF02WTTJ = FF02W00.FF02WTTJ + FF02W00.FF02WHSB[1]; /* totals*/

   /* ------------------------------------------------------------*/
   /* Calculate variance & move to display storage.             |*/
                                                             /* |*/
   /* VARIANCE = S/BUY IL  -  IL target                         |*/
   /* ------------------------------------------------------------*/

  FF02W00.FF02WFDA = 0; /* clear field*/

  FF02W00.FF02WFDA = FF02W00.FF02WFDA + FF02W01.FF02WSBI[FF02WCNT];
  FF02W00.FF02WFDA = FF02W00.FF02WFDA - FF02W01.FF02WILT[FF02WCNT];

  FF02W01.FF02WVAR[FF02WCNT] = FF02W00.FF02WFDA; /* disp storage*/
  FF02W00.FF02WTTK = FF02W00.FF02WTTK + FF02W00.FF02WFDA; /* totals*/

   /* ------------------------------------------------------------*/
   /* Calculate SUG END INV & move to display storage.          |*/
                                                             /* |*/
   /* If less than or equal to buy month:                       /* |*/
     /* SUG END INV =  beg inv + on order - sales fcst          |*/
   /* else                                                         |*/
     /* SUG END INV =  s/buy + beg inv + on order - sales fcst  |*/
                                                             /* |*/
   /* FF02W00.FF02WHSB(1) - suggested buy INLINE                |*/
   /* FF02W00.FF02WHSB(2) - suggested buy MKUP                  |*/
   /* FF02W00.FF02WINV    - adj beg inv for inline and mkup     |*/
   /* FF02W00.FF02WHOO(1) - on order inline                     |*/
   /* FF02W00.FF02WHOO(2) - on order mkup                       |*/
   /* FF02W00.FF02WHSF(1) - sales fcst inline                   |*/
   /* FF02W00.FF02WHSF(2) - sales fcst mkup                     |*/
   /* ------------------------------------------------------------*/

  if (FF02W00.FF02WMDT <= FF02W00.FF02WBUY) /* LE the buy month*/
    FF02W00.FF02WFDA = 0; /* Sugg buy*/
  else
    FF02W00.FF02WFDA = FF02W00.FF02WHSB[1] + FF02W00.FF02WHSB[2];
                                                                /* Sugg buy*/
  end

  if (FF02W00.FF02WCNT == 1) /* If first month of range*/
    FF02W00.FF02WFDB = FF02W00.FF02WINV[FF02WCNT]; /* beg inv*/
  else
    FF02W00.FF02WSUB = FF02W00.FF02WCNT - 1; /* count minus one*/
    FF02W00.FF02WFDB = FF02W01.FF02WSEI[FF02WSUB]; /* ending inv*/
  end

  FF02W00.FF02WFDC = FF02W00.FF02WHOO[1] + FF02W00.FF02WHOO[2]; /* on order*/
  FF02W00.FF02WFDD = FF02W00.FF02WHSF[1] + FF02W00.FF02WHSF[2]; /* sls fcst*/
  FF02W00.FF02WFDA = FF02W00.FF02WFDA + FF02W00.FF02WFDB; /* sb + bi*/
  FF02W00.FF02WFDA = FF02W00.FF02WFDA + FF02W00.FF02WFDC; /* + oo*/
  FF02W00.FF02WFDA = FF02W00.FF02WFDA - FF02W00.FF02WFDD; /* - sf*/

  FF02W01.FF02WSEI[FF02WCNT] = FF02W00.FF02WFDA; /* disp storage*/
  FF02W00.FF02WTTL = FF02W00.FF02WTTL + FF02W00.FF02WFDA; /* totals*/

   /* ------------------------------------------------------------*/
   /* Calculate SUG INV TRN & move to display storage.          |*/
   /* ------------------------------------------------------------*/

  FF02161(); /* Calculate Sug Inv Trn*/

  FF02W00.FF02WTTM = FF02W00.FF02WTTM + FF02W00.FF02WFDC; /* totals*/

   /* ------------------------------------------------------------*/
   /* Calculate TGT END INV & move to display storage.          |*/
                                                             /* |*/
   /* TGT END INV =  domest trgt + beg inv + on order - sls fcst|*/
                                                             /* |*/
   /* ff02w01.ff02wdtg    - domestic target                     |*/
   /* FF02W00.FF02WINV    - adj beg inv for inline and mkup     |*/
   /* FF02W00.FF02WHOO(1) - on order inline                     |*/
   /* FF02W00.FF02WHOO(2) - on order mkup                       |*/
   /* FF02W00.FF02WHSF(1) - sales fcst inline                   |*/
   /* FF02W00.FF02WHSF(2) - sales fcst mkup                     |*/
   /* ------------------------------------------------------------*/
  FF02W00.FF02WFDA = FF02W01.FF02WDTG[FF02WCNT]; /* domest trgt*/

  if (FF02W00.FF02WCNT == 1) /* If first month of range*/
    FF02W00.FF02WFDB = FF02W00.FF02WINV[FF02WCNT]; /* beg inv*/
  else
    FF02W00.FF02WSUB = FF02W00.FF02WCNT - 1; /* count minus one*/
    FF02W00.FF02WFDB = FF02W01.FF02WTEI[FF02WSUB]; /* ending inv*/
  end

  FF02W00.FF02WFDC = FF02W00.FF02WHOO[1] + FF02W00.FF02WHOO[2]; /* on order*/
  FF02W00.FF02WFDD = FF02W00.FF02WHSF[1] + FF02W00.FF02WHSF[2];
                                   /* sales fcst*/

  FF02W00.FF02WFDA = FF02W00.FF02WFDA + FF02W00.FF02WFDB; /* pt + bi*/
  FF02W00.FF02WFDA = FF02W00.FF02WFDA + FF02W00.FF02WFDC; /* + oo*/
  FF02W00.FF02WFDA = FF02W00.FF02WFDA - FF02W00.FF02WFDD; /* - sf*/

  FF02W01.FF02WTEI[FF02WCNT] = FF02W00.FF02WFDA; /* disp storage*/
  FF02W00.FF02WTTN = FF02W00.FF02WTTN + FF02W00.FF02WFDA; /* totals*/

   /* ------------------------------------------------------------*/
   /* Calculate TGT INV TRN & move to display storage.          |*/
   /* ------------------------------------------------------------*/

  FF02162(); /* Calculate Trg Inv Trn*/

  FF02W00.FF02WTTO = FF02W00.FF02WTTO + FF02W00.FF02WFDC; /* totals*/

   /* ------------------------------------------------------------*/
   /* Calculate SALES FCST & move to display storage.           |*/
   /* Use both INLINE AND MKUPS.                                |*/
   /* ------------------------------------------------------------*/

  FF02W00.FF02WFDA = FF02W00.FF02WHSF[1] + FF02W00.FF02WHSF[2];

  FF02W01.FF02WSLF[FF02WCNT] = FF02W00.FF02WFDA; /* disp storage*/
  FF02W00.FF02WTTP = FF02W00.FF02WTTP + FF02W00.FF02WFDA; /* totals*/


end // end FF02160

// Calculate Sug Inv Turns
Function FF02161()
   /* ------------------------------------------------------------*/
   /* Calculate:*/
             /* Sales Average = Sales Fcst for next 3 months * 12*/
   /* ------------------------------------------------------------*/

  FF02W00.FF02WNNN = FF02W00.FF02WCNT + 1; /* set counter*/
  FF02W00.FF02WSAV = 0; /* clear field*/
  FF02W00.FF02WFDA = 0; /* clear work field*/
  FF02W00.FF02WFDB = 0; /* clear work field*/
  FF02W00.FF02WFDC = 0; /* clear work field*/

  FF02W00.FF02WSAV = FF02W00.FF02WSAV + FF02W00.FF02WSLS[FF02WNNN];

  FF02W00.FF02WNNN = FF02W00.FF02WNNN + 1; /* add 1 to counter*/
  FF02W00.FF02WSAV = FF02W00.FF02WSAV + FF02W00.FF02WSLS[FF02WNNN];

  FF02W00.FF02WNNN = FF02W00.FF02WNNN + 1; /* add 1 to counter*/
  FF02W00.FF02WSAV = FF02W00.FF02WSAV + FF02W00.FF02WSLS[FF02WNNN];

  FF02W00.FF02WFDA = FF02W00.FF02WSAV * 12; /* Avg sales*/

   /* ------------------------------------------------------------*/
   /* Calculate:*/
        /* Average Inventory  =  Ending inventory  *  3*/
   /* ------------------------------------------------------------*/

  FF02W00.FF02WFDB = FF02W01.FF02WSEI[FF02WCNT] * 3; /* Avg Inv*/

   /* ------------------------------------------------------------*/
   /* Calculate:*/
              /* INV TURNS  =  Avg sales  /  Avg inv*/
   /* ------------------------------------------------------------*/

  if (FF02W00.FF02WFDB > 0) /* if number is greater than zero*/
    FF02W00.FF02WFDC = mathLib.round(FF02W00.FF02WFDA / FF02W00.FF02WFDB, -mathLib.decimals(FF02W00.FF02WFDC));
  end

  FF02W01.FF02WSIT[FF02WCNT] = FF02W00.FF02WFDC; /* storage*/


end // end FF02161

// Calculate Trg Inv Turns
Function FF02162()
   /* ------------------------------------------------------------*/
   /* Calculate:*/
             /* Sales Average = Sales Fcst for next 3 months * 12*/
   /* ------------------------------------------------------------*/

  FF02W00.FF02WFDA = 0; /* clear work field*/
  FF02W00.FF02WFDB = 0; /* clear work field*/
  FF02W00.FF02WFDC = 0; /* clear work field*/

  FF02W00.FF02WFDA = FF02W00.FF02WSAV * 12; /* Avg sales*/

   /* ------------------------------------------------------------*/
   /* Calculate:*/
        /* Average Inventory  =  Ending inventory  *  3*/
   /* ------------------------------------------------------------*/

  FF02W00.FF02WFDB = FF02W01.FF02WTEI[FF02WCNT] * 3; /* Avg Inv*/

   /* ------------------------------------------------------------*/
   /* Calculate:*/
              /* INV TURNS  =  Avg sales  /  Avg inv*/
   /* ------------------------------------------------------------*/

  if (FF02W00.FF02WFDB > 0) /* if number is greater than zero*/
    FF02W00.FF02WFDC = mathLib.round(FF02W00.FF02WFDA / FF02W00.FF02WFDB, -mathLib.decimals(FF02W00.FF02WFDC));
  end

  FF02W01.FF02WTVT[FF02WCNT] = FF02W00.FF02WFDC; /* storage*/


end // end FF02162

// Move totals to storage
Function FF02170()
   /* ------------------------------------------------------------*/
   /* Add one to last count, to be in position for totals.*/
   /* ------------------------------------------------------------*/

  FF02W00.FF02WSUB = FF02W00.FF02WCNT + 1; /* get tot position*/

   /* ------------------------------------------------------------*/
   /* Move Co. trgt total to display storage.*/
   /* ------------------------------------------------------------*/

  FF02W01.FF02WCOT[FF02WSUB] = FF02W00.FF02WTTA; /* disp storage*/

   /* ------------------------------------------------------------*/
   /* Move s/buy NIL total to display storage.                  |*/
   /* ------------------------------------------------------------*/

  FF02W01.FF02WSBN[FF02WSUB] = FF02W00.FF02WTTB; /* disp storage*/

   /* ------------------------------------------------------------*/
   /* Move NIL trgt total to display storage.                   |*/
   /* ------------------------------------------------------------*/

  FF02W01.FF02WNLT[FF02WSUB] = FF02W00.FF02WTTC; /* disp storage*/

   /* ------------------------------------------------------------*/
   /* Move Dom trgt total to display storage.                   |*/
   /* ------------------------------------------------------------*/

  FF02W01.FF02WDTG[FF02WSUB] = FF02W00.FF02WTTD; /* disp storage*/

   /* ------------------------------------------------------------*/
   /* Move Dom fcst total to display storage.                   |*/
   /* ------------------------------------------------------------*/

  FF02W01.FF02WPFC[FF02WSUB] = FF02W00.FF02WTTE; /* disp storage*/

   /* ------------------------------------------------------------*/
   /* Move s/buy mkup total to display storage.                 |*/
   /* ------------------------------------------------------------*/

  FF02W01.FF02WSBM[FF02WSUB] = FF02W00.FF02WTTF; /* disp storage*/

   /* ------------------------------------------------------------*/
   /* Move MKUP trgt total to display storage.                  |*/
   /* ------------------------------------------------------------*/

  FF02W01.FF02WMTG[FF02WSUB] = FF02W00.FF02WTTG; /* disp storage*/

   /* ------------------------------------------------------------*/
   /* Move INLINE trgt total to display storage.                |*/
   /* ------------------------------------------------------------*/

  FF02W01.FF02WILT[FF02WSUB] = FF02W00.FF02WTTH; /* disp storage*/

   /* ------------------------------------------------------------*/
   /* Move INLINE fcst total to display storage.                |*/
   /* ------------------------------------------------------------*/

  FF02W01.FF02WILF[FF02WSUB] = FF02W00.FF02WTTI; /* disp storage*/

   /* ------------------------------------------------------------*/
   /* Move s/buy inline total to display storage.               |*/
   /* ------------------------------------------------------------*/

  FF02W01.FF02WSBI[FF02WSUB] = FF02W00.FF02WTTJ; /* disp storage*/

   /* ------------------------------------------------------------*/
   /* Move variance total to display storage.                   |*/
   /* ------------------------------------------------------------*/

  FF02W01.FF02WVAR[FF02WSUB] = FF02W00.FF02WTTK; /* disp storage*/

   /* ------------------------------------------------------------*/
   /* Move SUG END INV total to display storage.                |*/
   /* ------------------------------------------------------------*/

  FF02W01.FF02WSEI[FF02WSUB] = FF02W00.FF02WTTL; /* disp storage*/

   /* ------------------------------------------------------------*/
   /* Move TGT END INV total to display storage.                |*/
   /* ------------------------------------------------------------*/

  FF02W01.FF02WTEI[FF02WSUB] = FF02W00.FF02WTTN; /* disp storage*/

   /* ------------------------------------------------------------*/
   /* Move sales fcst total to display storage.                 |*/
   /* ------------------------------------------------------------*/

  FF02W01.FF02WSLF[FF02WSUB] = FF02W00.FF02WTTP; /* disp storage*/

end // end FF02170

// Format and converse the map
Function FF02200()
   /* ------------------------------------------------------------*/
   /* If an error was found, save the error message number.*/
   /* ------------------------------------------------------------*/

  if (converseVar.validationMsgNum != 0) /* Error was found*/

    FFWREC.XXXMSGNO = converseVar.validationMsgNum; /* Message number*/

  end

   /* ------------------------------------------------------------*/
   /* If data requested or no error, format the data to display.*/
   /* ------------------------------------------------------------*/

  if (FF02W00.FF02WSWR == "Y" /* If data was requested*/
   || converseVar.validationMsgNum == 0) /* or no error found*/

    if (FF02W00.FF02WSWF == "Y") /* If map must be formatted*/

      FF02210(); /* load header*/

      FF02WCNT = 1; /* set counter to zero*/

      if (FF02W00.FF02WNBR > 0) /* If range exists*/
        set FF02M001.FF02MCOT[1] cursor; /* Place cursor*/
      end

      while (FF02W00.FF02WCNT <= FF02W00.FF02WNBR /* if cnt LT nbr of mos*/
       && FF02W00.FF02WNBR > 0) /* if nbr greater than zero*/

        FF02220(); /* load fields*/

        set FF02M001.FF02MCOT[FF02WCNT] normal; /* make field visable*/
        set FF02M001.FF02MNLT[FF02WCNT] normal; /* make field visable*/
        set FF02M001.FF02MMTG[FF02WCNT] normal; /* make field visable*/

        FF02W00.FF02WCNT = FF02W00.FF02WCNT + 1; /* add to counter*/

      end

      if (FF02W00.FF02WNBR > 0) /* if there are totals to load*/

        FF02220(); /* load totals*/
        set FF02M001.FF02MCOT[FF02WCNT] skip; /* make field visable*/
        set FF02M001.FF02MNLT[FF02WCNT] skip; /* make field visable*/
        set FF02M001.FF02MMTG[FF02WCNT] skip; /* make field visable*/

      end

    end

  end

   /* ------------------------------------------------------------*/
   /* Format the current date and any FAST PATH information.*/
   /* ------------------------------------------------------------*/

  FF02M001.XXXCURDT = VGVar.currentShortGregorianDate; /* Current date*/

  FF02M001.CATOAP = COMMAREA.CATOAP; /* TO application*/
  FF02M001.CAITEM = COMMAREA.CAITEM; /* Application data*/

   /* ------------------------------------------------------------*/
   /* If a message to display, indicate sound audible alarm.*/
   /* ------------------------------------------------------------*/

  if (FFWREC.XXXMSGNO != 0) /* Message to display*/

    FF02M001.XXXMODID = FFWREC.XXXMODID; /* Module identification*/
    if (FFWREC.XXXMSGNO == 9999)
      converseLib.validationFailed();
    else
      converseLib.validationFailed(FFWREC.XXXMSGNO);
    end /* Message number*/

    set FF02M001 alarm; /* Indicate sound alarm*/

  end

  converse FF02M001 ;

   /* ------------------------------------------------------------*/
   /* Clear the message fields and save FAST PATH information.*/
   /* ------------------------------------------------------------*/

  FFWREC.XXXMODID = "    "; /* Module identification*/
  FFWREC.XXXMSGNO = 0; /* Message number*/

  COMMAREA.CATOAP = FF02M001.CATOAP; /* TO application*/
  COMMAREA.CAITEM = FF02M001.CAITEM; /* Application data*/


end // end FF02200

// Load the header info
Function FF02210()
   /* ------------------------------------------------------------*/
   /* Clear the map.*/
   /* ------------------------------------------------------------*/

  set FF02M001 initial; /* Clear map*/
  FF02W00.FF02WSWF = "N"; /* Format map switch*/

   /* ------------------------------------------------------------*/
   /* Load header information.*/
   /* ------------------------------------------------------------*/

  FF02M001.FFABEGMO = FF02W01.FFABEGMO; /* begin month*/
  FF02M001.FFAENDMO = FF02W01.FFAENDMO; /* end month*/

  FF02W00.FF02WCNT = 0; /* set sub to zero*/

  while (FF02W00.FF02WCNT < FF02W00.FF02WNBR) /* until cnt ^LT nbr months*/

    FF02W00.FF02WCNT = FF02W00.FF02WCNT + 1; /* add 1 to sub*/

    FF02M001.FF02MRMO[FF02WCNT] = FF02W01.FF02WRMO[FF02WCNT];
    /* SET FF02M001.FF02MRMO(FF02WCNT) AUTOSKIP;*/

  end

  FF02W00.FF02WCNT = FF02W00.FF02WCNT + 1; /* add one to sub to load tot*/
  FF02M001.FF02MRMO[FF02WCNT] = FF02W01.FF02WRMO[FF02WCNT];

end // end FF02210

// Translate and load fields
Function FF02220()
   /* ------------------------------------------------------------*/
   /* translate Co. trgt to millions and move to display storage.*/
   /* ------------------------------------------------------------*/

  FFXREC.FFXNUMB = FF02W01.FF02WCOT[FF02WCNT];

  XSFFS12();

  FF02M001.FF02MCOT[FF02WCNT] = FFXREC.FFXCHAR; /* map*/
  FF02W01.FF02MCOT[FF02WCNT] = FFXREC.FFXCHAR; /* storage*/

   /* ------------------------------------------------------------*/
   /* Translate S/BUY NIL & move to display storage.*/
   /* ------------------------------------------------------------*/

  FFXREC.FFXNUMB = FF02W01.FF02WSBN[FF02WCNT];

  XSFFS12();

  FF02M001.FF02MSBN[FF02WCNT] = FFXREC.FFXCHAR; /* map*/
  FF02W01.FF02MSBN[FF02WCNT] = FFXREC.FFXCHAR; /* storage*/

   /* ------------------------------------------------------------*/
   /* Translate NIL target to millions & move to display storage.*/
   /* ------------------------------------------------------------*/

  FFXREC.FFXNUMB = FF02W01.FF02WNLT[FF02WCNT];

  XSFFS12();

  FF02M001.FF02MNLT[FF02WCNT] = FFXREC.FFXCHAR; /* map*/
  FF02W01.FF02MNLT[FF02WCNT] = FFXREC.FFXCHAR; /* storage*/

   /* ------------------------------------------------------------*/
   /* Translate Dom trgt & move to display storage.*/
   /* ------------------------------------------------------------*/

  FFXREC.FFXNUMB = FF02W01.FF02WDTG[FF02WCNT];

  XSFFS12();

  FF02M001.FF02MDTG[FF02WCNT] = FFXREC.FFXCHAR; /* disp storage*/
  FF02W01.FF02MDTG[FF02WCNT] = FFXREC.FFXCHAR; /* storage*/

   /* ------------------------------------------------------------*/
   /* Translate Dom fcst & move to display storage.*/
   /* ------------------------------------------------------------*/

  FFXREC.FFXNUMB = FF02W01.FF02WPFC[FF02WCNT];

  XSFFS12();

  FF02M001.FF02MPFC[FF02WCNT] = FFXREC.FFXCHAR; /* map*/
  FF02W01.FF02MPFC[FF02WCNT] = FFXREC.FFXCHAR; /* storage*/

   /* ------------------------------------------------------------*/
   /* Translate s/buy mkup & move to display storage.*/
   /* ------------------------------------------------------------*/

  FFXREC.FFXNUMB = FF02W01.FF02WSBM[FF02WCNT];

  XSFFS12();

  FF02M001.FF02MSBM[FF02WCNT] = FFXREC.FFXCHAR; /* map*/
  FF02W01.FF02MSBM[FF02WCNT] = FFXREC.FFXCHAR; /* storage*/

   /* ------------------------------------------------------------*/
   /* Translate MKUP trgt & move to display storage.*/
   /* ------------------------------------------------------------*/

  FFXREC.FFXNUMB = FF02W01.FF02WMTG[FF02WCNT];

  XSFFS12();

  FF02M001.FF02MMTG[FF02WCNT] = FFXREC.FFXCHAR; /* map*/
  FF02W01.FF02MMTG[FF02WCNT] = FFXREC.FFXCHAR; /* storage*/

   /* ------------------------------------------------------------*/
   /* Translate INLINE trgt & move to disp storage.*/
   /* ------------------------------------------------------------*/

  FFXREC.FFXNUMB = FF02W01.FF02WILT[FF02WCNT];

  XSFFS12();

  FF02M001.FF02MILT[FF02WCNT] = FFXREC.FFXCHAR; /* map*/
  FF02W01.FF02MILT[FF02WCNT] = FFXREC.FFXCHAR; /* storage*/

   /* ------------------------------------------------------------*/
   /* Translate INLINE fcst & move to display storage.*/
   /* ------------------------------------------------------------*/

  FFXREC.FFXNUMB = FF02W01.FF02WILF[FF02WCNT];

  XSFFS12();

  FF02M001.FF02MILF[FF02WCNT] = FFXREC.FFXCHAR; /* map*/
  FF02W01.FF02MILF[FF02WCNT] = FFXREC.FFXCHAR; /* storage*/

   /* ------------------------------------------------------------*/
   /* Translate s/buy INLINE & move to display storage.*/
   /* ------------------------------------------------------------*/

  FFXREC.FFXNUMB = FF02W01.FF02WSBI[FF02WCNT];

  XSFFS12();

  FF02M001.FF02MSBI[FF02WCNT] = FFXREC.FFXCHAR; /* map*/
  FF02W01.FF02MSBI[FF02WCNT] = FFXREC.FFXCHAR; /* storage*/

   /* ------------------------------------------------------------*/
   /* Translate VARIANCE & move to display storage.*/
   /* ------------------------------------------------------------*/

  FFXREC.FFXNUMB = FF02W01.FF02WVAR[FF02WCNT];

  XSFFS12();

  FF02M001.FF02MVAR[FF02WCNT] = FFXREC.FFXCHAR; /* map*/
  FF02W01.FF02MVAR[FF02WCNT] = FFXREC.FFXCHAR; /* storage*/

   /* ------------------------------------------------------------*/
   /* Translate SUG END INV & move to display storage.*/
   /* ------------------------------------------------------------*/

  FFXREC.FFXNUMB = FF02W01.FF02WSEI[FF02WCNT];

  XSFFS12();

  FF02M001.FF02MSEI[FF02WCNT] = FFXREC.FFXCHAR; /* map*/
  FF02W01.FF02MSEI[FF02WCNT] = FFXREC.FFXCHAR; /* storage*/

   /* ------------------------------------------------------------*/
   /* Translate TGT END INV & move to display storage.*/
   /* ------------------------------------------------------------*/

  FFXREC.FFXNUMB = FF02W01.FF02WTEI[FF02WCNT];

  XSFFS12();

  FF02M001.FF02MTEI[FF02WCNT] = FFXREC.FFXCHAR; /* map*/
  FF02W01.FF02MTEI[FF02WCNT] = FFXREC.FFXCHAR; /* storage*/

   /* ------------------------------------------------------------*/
   /* Translate SALES FCST & move to display storage.*/
   /* ------------------------------------------------------------*/

  FFXREC.FFXNUMB = FF02W01.FF02WSLF[FF02WCNT];

  XSFFS12();

  FF02M001.FF02MSLF[FF02WCNT] = FFXREC.FFXCHAR; /* map*/
  FF02W01.FF02MSLF[FF02WCNT] = FFXREC.FFXCHAR; /* storage*/


end // end FF02220

// Check attention identifier
Function FF02300()
   /* ------------------------------------------------------------*/
   /* If CANCEL was requested, clear the map fields and exit.*/
   /* If a request for data is pending, reset that request.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pa2) /* PA2 was pressed*/

    if (FF02W00.FF02WSWR == "Y") /* Data was requested*/
      set FF02W01 empty; /* clear display storage*/
    end

    FF02W00.FF02WSWF = "Y"; /* Format the map switch*/
    FF02W00.FF02WSWR = "N"; /* Request for data switch*/

    COMMAREA.CATOAP = " "; /* TO application*/
    COMMAREA.CAITEM = " "; /* Application data*/

    exit stack; /* Exit to display map*/

  end

   /* ------------------------------------------------------------*/
   /* If FAST PATH was requested, transfer to the application.*/
   /* ------------------------------------------------------------*/

  if (COMMAREA.CATOAP > " ") /* FAST PATH was requested*/

    if (converseVar.eventKey is enter) /* ENTER was pressed*/

      XSFFS01(); /* Exit to another application*/

      set FF02M001.CATOAP cursor, bold; /* Highlight*/

    else

      FFWREC.XXXMODID = "300"; /* Module identification*/
      converseLib.validationFailed(36); /* Indicate PF key not valid*/

    end

    exit stack; /* Exit to display map*/

  end

   /* ------------------------------------------------------------*/
   /* If HELP, exit to the previous level or exit to the Master*/
   /* Menu was requested, exit to another application.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf1  /* PF1 was pressed*/
   || converseVar.eventKey is pf3  /* or PF3 was pressed*/
   || converseVar.eventKey is pf5  /* or PF5 was pressed*/
   || converseVar.eventKey is pf13 /* or PF13 was pressed*/
   || converseVar.eventKey is pf14 /* or PF14 was pressed*/
   || converseVar.eventKey is pf17) /* or PF17 was pressed*/

    if (converseVar.eventKey is pf1) /* PF1 was pressed*/
      COMMAREA.CAITEM = "FF02M001"; /* Application find code*/
    end

    if (converseVar.eventKey is pf3) /* PF3 was pressed*/
      COMMAREA.CATOAP = "FF03"; /* TO application*/
    end

    if (converseVar.eventKey is pf13) /* PF13 was pressed*/
      COMMAREA.CATOAP = "FF0U"; /* TO application*/
    end

    if (converseVar.eventKey is pf14) /* PF14 was pressed*/
      COMMAREA.CATOAP = "FF00"; /* TO application*/
    end

    if (converseVar.eventKey is pf17) /* PF17 was pressed*/
      COMMAREA.CATOAP = "FF01"; /* TO application*/
    end

    XSFFS01(); /* Exit to another application*/

    exit stack; /* Exit to display map*/

  end

   /* ------------------------------------------------------------*/
   /* Determine whether a valid attention identifier was used to*/
   /* invoke the transaction.  Display an error message to the*/
   /* user if the PF key used is not supported.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey not enter /* ENTER was not pressed*/
   && converseVar.eventKey not pf19  /* and PF19 was not pressed*/
   && converseVar.eventKey not pf20  /* and PF20 was not pressed*/
   && converseVar.eventKey not pf21) /* and PF21 was not pressed*/

    FFWREC.XXXMODID = "300"; /* Module identification*/
    converseLib.validationFailed(3); /* Indicate invalid attention key*/

    if (converseVar.eventKey is pakey) /* PA was pressed*/

      converseLib.clearScreen();
       /* Clear screen before display*/

    end

    exit stack; /* Exit to display map*/

  end

end // end FF02300

// Reset highlighted fields
Function FF02400()
   /* ------------------------------------------------------------*/
   /* Reset field attributes to normal intensity.*/
   /* ------------------------------------------------------------*/

  set FF02M001.FFABEGMO initialAttributes; /* beginning month*/
  set FF02M001.FFAENDMO initialAttributes; /* ending month*/

  FF02WCNT = 0; /* set counter to zero*/
  while (FF02WCNT < FF02WNBR) /* if counter is less than nbr of mos*/

    FF02WCNT = FF02WCNT + 1; /* add one to sub*/

    set FF02M001.FF02MCOT[FF02WCNT] normal; /* co. target*/
    set FF02M001.FF02MNLT[FF02WCNT] normal; /* nil target*/
    set FF02M001.FF02MMTG[FF02WCNT] normal; /* mkup target*/

  end

  set FF02M001.CATOAP initialAttributes; /* Commarea TO application*/
  set FF02M001.CAITEM initialAttributes; /* Commarea application data*/
end // end FF02400

// Verify the entered data
Function FF02500()
   /* ------------------------------------------------------------*/
   /* If fast path item data was entered.*/
   /* ------------------------------------------------------------*/

  if (COMMAREA.CAITEM > " ") /* Application data was entered*/

    FFWREC.XXXMODID = "500"; /* Module identification*/
    set FF02M001.CAITEM cursor, bold; /* Highlight*/
    converseLib.validationFailed(40); /* Enter only with FAST PATH*/

  end

   /* ------------------------------------------------------------*/
   /* Verify target fields, if changed.*/
   /* ------------------------------------------------------------*/

  if (FF02W01.CACHGFL == "Y") /* if there is any data*/

    FF02W00.FF02WCNT = FF02W00.FF02WNBR; /* initalize subscript*/
    while (FF02W00.FF02WCNT > 0) /* count greater than zero*/

      FF02510(); /* Check for changes*/

      FF02W00.FF02WCNT = FF02W00.FF02WCNT - 1; /* subtract from counter*/

    end

  end

   /* ------------------------------------------------------------*/
   /* If any of the key fields changed, determine if any of the*/
   /* modifiable fields were changed.*/
   /* ------------------------------------------------------------*/

  if (FF02W01.CACHGFL == "Y") /* if there is any data*/

    FF02W00.FF02WCNT = FF02W00.FF02WNBR; /* initalize subscript*/
    while (FF02W00.FF02WCNT > 0) /* count greater than zero*/

      FF02520(); /* Check for changes*/

      FF02W00.FF02WCNT = FF02W00.FF02WCNT - 1; /* subtract from counter*/

    end

  end

  if (FF02M001.FFAENDMO != FF02W01.FFAENDMO /* range changed*/
   || FF02M001.FFABEGMO != FF02W01.FFABEGMO /* range changed*/
                                            
   || FF02M001.FFAENDMO == 0                /* range missing*/
   || FF02M001.FFABEGMO == 0)               /* range missing*/

    FF02530(); /* Verify range*/

  end

   /* ------------------------------------------------------------*/
   /* If an update was requested, check for key change.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf21) /* If update is requested*/
    FF02540(); /* Check for key changes*/
  end

   /* ------------------------------------------------------------*/
   /* If an error was found in this process, exit to display map.*/
   /* ------------------------------------------------------------*/

  if (converseVar.validationMsgNum != 0) /* Message to display*/
    exit stack;
  end


end // end FF02500

// Verify modified fields
Function FF02510()
   /* ------------------------------------------------------------*/
   /* If a mkup trgt field was changed, verify field.*/
   /* ------------------------------------------------------------*/

  if (FF02M001.FF02MMTG[FF02WCNT] != FF02W01.FF02MMTG[FF02WCNT])

    FFWREC.FFWMODSW = "Y"; /* modified data exit switch*/

    /* ------------------------------------------------------------*/
     /* Verify MKUP trgt.*/
    /* ------------------------------------------------------------*/

    FFXREC.FFXCHAR = FF02M001.FF02MMTG[FF02WCNT]; /* translate*/

    XSFFS13();

    if (FFXREC.FFXRTNCD != 0) /* If error was found*/

      set FF02M001.FF02MMTG[FF02WCNT] cursor, bold; /* highlight*/
      FFWREC.XXXMODID = "510"; /* Module identification*/
      converseLib.validationFailed(118); /* indicate field is invalid*/

    end
  end

   /* ------------------------------------------------------------*/
   /* If a NIL trgt field was changed, verify field.*/
   /* ------------------------------------------------------------*/

  if (FF02M001.FF02MNLT[FF02WCNT] != FF02W01.FF02MNLT[FF02WCNT])

    FFWREC.FFWMODSW = "Y"; /* modified data exit switch*/

    /* ------------------------------------------------------------*/
     /* Verify NIL target.*/
    /* ------------------------------------------------------------*/

    FFXREC.FFXCHAR = FF02M001.FF02MNLT[FF02WCNT]; /* translate*/

    XSFFS13();

    if (FFXREC.FFXRTNCD != 0) /* If error was found*/

      set FF02M001.FF02MNLT[FF02WCNT] cursor, bold; /* highlight*/
      FFWREC.XXXMODID = "510"; /* Module identification*/
      converseLib.validationFailed(118); /* indicate field is invalid*/

    end

  end

   /* ------------------------------------------------------------*/
   /* If a Co. trgt field was changed, verify field.*/
   /* ------------------------------------------------------------*/

  if (FF02M001.FF02MCOT[FF02WCNT] != FF02W01.FF02MCOT[FF02WCNT])

    FFWREC.FFWMODSW = "Y"; /* modified data exit switch*/

    /* ------------------------------------------------------------*/
     /* Verify Co. trgt.*/
    /* ------------------------------------------------------------*/

    FFXREC.FFXCHAR = FF02M001.FF02MCOT[FF02WCNT];
                                   /* send to translate*/

    XSFFS13();

    if (FFXREC.FFXRTNCD != 0) /* If error was found*/

      set FF02M001.FF02MCOT[FF02WCNT] cursor, bold; /* highlight*/
      FFWREC.XXXMODID = "510"; /* Module identification*/
      converseLib.validationFailed(118); /* indicate field is invalid*/

    end

  end

end // end FF02510

// Check target fields
Function FF02520()
   /* ------------------------------------------------------------*/
   /* If a mkup trgt field was changed and the key changed,*/
   /* indicate that the key cannot change when data is changed.*/
   /* ------------------------------------------------------------*/

  if (FF02M001.FF02MMTG[FF02WCNT] != FF02W01.FF02MMTG[FF02WCNT])

    FFWREC.FFWMODSW = "Y"; /* modified data exit switch*/

    if (FF02M001.FFABEGMO != FF02W01.FFABEGMO /* range changed*/
     || FF02M001.FFAENDMO != FF02W01.FFAENDMO) /* range changed*/

      set FF02M001.FF02MMTG[FF02WCNT] cursor, bold; /* highlight*/

      FFWREC.XXXMODID = "510"; /* Module identification*/
      converseLib.validationFailed(130); /* Can't chg key & data together*/

      if (FF02M001.FFAENDMO != FF02W01.FFAENDMO) /* range changed*/
        set FF02M001.FFAENDMO cursor, bold; /* highlight*/
      end

      if (FF02M001.FFABEGMO != FF02W01.FFABEGMO) /* range changed*/
        set FF02M001.FFABEGMO cursor, bold; /* highlight*/
      end

    end

  end

   /* ------------------------------------------------------------*/
   /* If a nil trgt field was changed and the key changed,*/
   /* indicate that the key cannot change when data is changed.*/
   /* ------------------------------------------------------------*/

  if (FF02M001.FF02MNLT[FF02WCNT] != FF02W01.FF02MNLT[FF02WCNT])

    FFWREC.FFWMODSW = "Y"; /* modified data exit switch*/

    if (FF02M001.FFABEGMO != FF02W01.FFABEGMO /* range changed*/
     || FF02M001.FFAENDMO != FF02W01.FFAENDMO) /* range changed*/

      set FF02M001.FF02MNLT[FF02WCNT] cursor, bold; /* highlight*/

      FFWREC.XXXMODID = "510"; /* Module identification*/
      converseLib.validationFailed(130); /* Can't chg key & data together*/

      if (FF02M001.FFAENDMO != FF02W01.FFAENDMO) /* range changed*/
        set FF02M001.FFAENDMO cursor, bold; /* highlight*/
      end

      if (FF02M001.FFABEGMO != FF02W01.FFABEGMO) /* range changed*/
        set FF02M001.FFABEGMO cursor, bold; /* highlight*/
      end

    end

  end

   /* ------------------------------------------------------------*/
   /* If a Co. trgt field was changed and the key changed,*/
   /* indicate that the key cannot change when data is changed.*/
   /* ------------------------------------------------------------*/

  if (FF02M001.FF02MCOT[FF02WCNT] != FF02W01.FF02MCOT[FF02WCNT])

    FFWREC.FFWMODSW = "Y"; /* modified data exit switch*/

    if (FF02M001.FFABEGMO != FF02W01.FFABEGMO /* range changed*/
     || FF02M001.FFAENDMO != FF02W01.FFAENDMO) /* range changed*/

      set FF02M001.FF02MCOT[FF02WCNT] cursor, bold; /* highlight*/

      FFWREC.XXXMODID = "510"; /* Module identification*/
      converseLib.validationFailed(130); /* Can't chg key & data together*/

      if (FF02M001.FFAENDMO != FF02W01.FFAENDMO) /* range changed*/
        set FF02M001.FFAENDMO cursor, bold; /* highlight*/
      end

      if (FF02M001.FFABEGMO != FF02W01.FFABEGMO) /* range changed*/
        set FF02M001.FFABEGMO cursor, bold; /* highlight*/
      end

    end

  end

end // end FF02520

// Verify range
Function FF02530()
   /* ------------------------------------------------------------*/
   /* Initialize record for calls to date routine.*/
   /* ------------------------------------------------------------*/

  set FFZREC empty; /* clear date edit record*/

  FFZREC.FFZBYYMM = FF02M001.FFABEGMO; /* Beg date*/
  FFZREC.FFZEYYMM = FF02M001.FFAENDMO; /* end date*/
  FFZREC.FFZMONTH = 1;

   /* ------------------------------------------------------------*/
   /* Edit range.  Send YYMM - receive back CCYYMM.*/
   /* ------------------------------------------------------------*/

  XSFFS30();

  if (FFZREC.FFZENDRC == 0) /* end date was valid*/
    FF02W00.FF02WCEG = FFZREC.FFZENDMO; /* end month*/
  else
    if (FFZREC.FFZENDRC == 1) /* end date was missing*/
      FFWREC.XXXMODID = "530"; /* Module identification*/
      set FF02M001.FFAENDMO cursor, bold; /* Highlight*/
      converseLib.validationFailed(8); /* Indicate missing*/
    else
      if (FFZREC.FFZENDRC == 2) /* end date was invalid*/
        FFWREC.XXXMODID = "530"; /* Module identification*/
        set FF02M001.FFAENDMO cursor, bold; /* Highlight*/
        converseLib.validationFailed(17); /* Indicate invalid*/
      else
        FFWREC.XXXMODID = "530"; /* Module identification*/
        set FF02M001.FFAENDMO cursor, bold; /* Highlight*/
        converseLib.validationFailed(151); /* Indicate out of range*/
      end
    end
  end

  if (FFZREC.FFZBEGRC == 0) /* beg date was valid*/
    FF02W00.FF02WCBG = FFZREC.FFZBEGMO; /* end month*/
  else
    if (FFZREC.FFZBEGRC == 1) /* beg date was missing*/
      FFWREC.XXXMODID = "530"; /* Module identification*/
      set FF02M001.FFABEGMO cursor, bold; /* Highlight*/
      converseLib.validationFailed(8); /* Indicate missing*/
    else
      if (FFZREC.FFZBEGRC == 2) /* beg date was invalid*/
        FFWREC.XXXMODID = "530"; /* Module identification*/
        set FF02M001.FFABEGMO cursor, bold; /* Highlight*/
        converseLib.validationFailed(17); /* Indicate invalid*/
      else
        FFWREC.XXXMODID = "530"; /* Module identification*/
        set FF02M001.FFABEGMO cursor, bold; /* Highlight*/
        converseLib.validationFailed(151); /* Indicate out of range*/
      end
    end
  end

end // end FF02530

// Check for key changes
Function FF02540()
   /* ------------------------------------------------------------*/
   /* If key field changed, return message to user.*/
   /* ------------------------------------------------------------*/

  if (FF02M001.FFABEGMO != FF02W01.FFABEGMO /* range changed*/
   || FF02M001.FFAENDMO != FF02W01.FFAENDMO) /* range changed*/

    FFWREC.XXXMODID = "530"; /* Module identification*/
    converseLib.validationFailed(128); /* Indicate key chg & updt requested*/

    if (FF02M001.FFAENDMO != FF02W01.FFAENDMO) /* end changed*/
      set FF02M001.FFAENDMO cursor, bold; /* Highlight*/
    end

    if (FF02M001.FFABEGMO != FF02W01.FFABEGMO) /* begin changed*/
      set FF02M001.FFAENDMO cursor, bold; /* Highlight*/
    end

  end


end // end FF02540

// Process valid input request
Function FF02600()
   /* ------------------------------------------------------------*/
   /* indicate that the map must be formated.*/
   /* ------------------------------------------------------------*/

  FF02W00.FF02WSWF = "Y"; /* Format the map switch*/

   /* ------------------------------------------------------------*/
   /* If key was changed, update FFWREC, and request data.*/
   /* ------------------------------------------------------------*/

  if (FF02M001.FFABEGMO != FF02W01.FFABEGMO /* range changed*/
   || FF02M001.FFAENDMO != FF02W01.FFAENDMO) /* range changed*/

    /* ------------------------------------------------------------*/
     /* Update the modifiable data in the FF system commarea.*/
    /* ------------------------------------------------------------*/

    FFWREC.FFABEGMO = FFZREC.FFZBEGMO; /* begin month*/
    FFWREC.FFAENDMO = FFZREC.FFZENDMO; /* end month*/

    /* ------------------------------------------------------------*/
     /* Request data.*/
    /* ------------------------------------------------------------*/

    FF02W00.FF02WSWR = "Y"; /* indicate that data requested*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* If PF19 was pressed,*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf19)

    FF02W00.FF02WSWR = "Y"; /* indicate that data requested*/
    FF02W00.FF02WST0 = "Y"; /* indicate set-to-zero request*/

    /* ------------------------------------------------------------*/
     /* Indicate to user that targets were set to zero.*/
    /* ------------------------------------------------------------*/

    FFWREC.XXXMODID = "600"; /* Module identification*/
    FFWREC.XXXMSGNO = 165; /* Indicate update completed*/

    exit stack; /* exit to display map*/
  end
   /* ------------------------------------------------------------*/
   /* If PF20 was pressed,*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf20)

    FF02W00.FF02WSWR = "Y"; /* indicate that data requested*/
    FF02W00.FF02WCAL = "Y"; /* indicate calculation request*/

    /* ------------------------------------------------------------*/
     /* Indicate to user that Co. trgt was calculated.*/
    /* ------------------------------------------------------------*/

    FFWREC.XXXMODID = "600"; /* Module identification*/
    FFWREC.XXXMSGNO = 164; /* Indicate update completed*/

    exit stack; /* exit to display map*/
  end
   /* ------------------------------------------------------------*/
   /* If PF21 was pressed,*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf21)

    /* ------------------------------------------------------------*/
     /* Obtain the current date and time.*/
    /* ------------------------------------------------------------*/

    XX0XS01(); /* Obtain date and time*/

    /* ------------------------------------------------------------*/
     /* Update the changed data in the table row.*/
    /* ------------------------------------------------------------*/

    FF02W00.FF02WCNT = 1; /* set subscript*/

    while (FF02W00.FF02WCNT <= FF02W00.FF02WNBR) /* sub LE nbr mos*/

      if (FF02M001.FF02MCOT[FF02WCNT] != FF02W00.FF02WHCT[FF02WCNT]
       || FF02M001.FF02MNLT[FF02WCNT] != FF02W00.FF02WHNT[FF02WCNT]
       || FF02M001.FF02MMTG[FF02WCNT] != FF02W00.FF02WHMT[FF02WCNT])

        FF02610(); /* Select MONTH*/

        FF02620(); /* Format target fields*/

        if (SQLCA.VAGen_SQLCODE == 0) /* row was found for update*/
          FF02630(); /* Update MONTH*/
        else
          FF02640(); /* Add MONTH*/
        end

      end

      FF02W00.FF02WCNT = FF02W00.FF02WCNT + 1; /* add to subscript*/

    end

    /* ------------------------------------------------------------*/
     /* Indicate that the updates were successfully completed.*/
    /* ------------------------------------------------------------*/

    FFWREC.FFWMODSW = "N"; /* modified data exit switch*/

    FFWREC.XXXMODID = "600"; /* Module identification*/
    FFWREC.XXXMSGNO = 32; /* Indicate update completed*/

  end

   /* ------------------------------------------------------------*/
   /* Update  Display Storage area.*/
   /* ------------------------------------------------------------*/

  FF02W00.FF02WTSW = "N"; /* clear re-totaling switch*/

  FF02W00.FF02WCNT = 1; /* set subscript*/
  while (FF02W00.FF02WCNT <= FF02W00.FF02WNBR) /* until ^le nbr month*/

    FF02650(); /* Update display storage*/

    FF02W00.FF02WCNT = FF02W00.FF02WCNT + 1;

  end

  FF02660(); /* Check for re-totaling*/

   /* ------------------------------------------------------------*/
   /* Commit all changes to protected resources.*/
   /* ------------------------------------------------------------*/

  VGVar.handleSysLibraryErrors = 0;
  sysLib.commit(); /* Commit all changes*/

end // end FF02600

// Select DFCAST.VMONTH01
Function FF02610()
   /* ------------------------------------------------------------*/
   /* Clear the row storage area.*/
   /* ------------------------------------------------------------*/

  set FF4REC empty; /* clear DFCAST.VMONTH01 record.*/

   /* ------------------------------------------------------------*/
   /* Format keys for call to DFCAST.VMONTH01.*/
   /* ------------------------------------------------------------*/

  FF02W00.FF02WMCC = FF02W00.FF02WNCC[FF02WCNT]; /* cc to mask*/
  FF02W00.FF02WMMO = FF02W00.FF02WNMO[FF02WCNT]; /* yymm to mask*/
  FF4REC.FF4FCTMO = FF02W00.FF02WMDT;

   /* ------------------------------------------------------------*/
   /* Select the row to display from the table.*/
   /* ------------------------------------------------------------*/

  try
    call "IO3720" ("S ", SQLCA, FF4REC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

   /* ------------------------------------------------------------*/
   /* If successful or not found, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/

    if (SQLCA.VAGen_SQLCODE == 0 /* Normal return code*/
     || SQLCA.VAGen_SQLCODE == 100) /* or row not found*/

      return; /* Return to previous process*/

    end

  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL Commarea*/

  FFWREC.XXXMODID = "610"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(47); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(01); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    converseLib.clearScreen();
     /* Clear screen before display*/

  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "SELECT THE TABLE ROW";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FFWREC.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFCAST  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VMONTH01"; /* Table view name*/
  TA1REC.TA1TBLKE = FF4REC.FF4KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end FF02610

// Format targets for data base
Function FF02620()
   /* ------------------------------------------------------------*/
   /* Format NIL trgt field.*/
   /* ------------------------------------------------------------*/

  FFXREC.FFXCHAR = FF02M001.FF02MNLT[FF02WCNT]; /* send to translate*/

  XSFFS13();

  FF4REC.FF4NLTGT = FFXREC.FFXNUMB; /* NIL trgt (bin)*/

   /* ------------------------------------------------------------*/
   /* Format MKUP trgt field.*/
   /* ------------------------------------------------------------*/

  FFXREC.FFXCHAR = FF02M001.FF02MMTG[FF02WCNT]; /* send to translate*/

  XSFFS13();

  FF4REC.FF4MKTGT = FFXREC.FFXNUMB; /* MKUP trgt (bin)*/

   /* ------------------------------------------------------------*/
   /* Format Co. trgt field.*/
   /* ------------------------------------------------------------*/

  FFXREC.FFXCHAR = FF02M001.FF02MCOT[FF02WCNT]; /* send to translate*/

  XSFFS13();

  FF4REC.FF4RTRGT = FFXREC.FFXNUMB; /* Co. trgt (bin)*/

end // end FF02620

// Update DFCAST.VMONTH01
Function FF02630()
   /* ------------------------------------------------------------*/
   /* Format the key.*/
   /* ------------------------------------------------------------*/

  FF02W00.FF02WMCC = FF02W00.FF02WNCC[FF02WCNT]; /* cc to mask*/
  FF02W00.FF02WMMO = FF02W00.FF02WNMO[FF02WCNT]; /* yymm to mask*/
  FF4REC.FF4FCTMO = FF02W00.FF02WMDT;

  FF4REC.ZZZCHGDT = XX0XW01.XX0XWDAT; /* Change date*/
  FF4REC.ZZZCHGTM = XX0XW01.XX0XWTIM; /* Change time*/

   /* ------------------------------------------------------------*/
   /* Update the changed row in the table.*/
   /* ------------------------------------------------------------*/

  try
    call "IO3720" ("U ", SQLCA, FF4REC) {isNoRefresh = yes, isExternal = yes};
  end /* Update row*/

   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/

    if (SQLCA.VAGen_SQLCODE == 0) /* Normal return code*/
      return; /* Return to previous process*/
    end

    /* ------------------------------------------------------------*/
     /* If row not found, indicate the data was updated by another.*/
    /* ------------------------------------------------------------*/

    if (SQLCA.VAGen_SQLCODE == 100) /* Row not found*/

      FF02W00.FF02WSWR = "Y"; /* Request for data switch*/

      FFWREC.XXXMODID = "630"; /* Module identification*/
      FFWREC.XXXMSGNO = 46; /* Indicate updated by another*/

      exit stack; /* Exit to display map*/

    end

  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  FFWREC.XXXMODID = "630"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(47); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback(); /* Roll back all changes*/

    converseLib.validationFailed(1); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    converseLib.clearScreen();
     /* Clear screen before display*/

  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "UPDATE THE TABLE ROW";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FFWREC.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFCAST  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VMONTH01"; /* Table view name*/
  TA1REC.TA1TBLKE = FF4REC.FF4KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end FF02630

// Add DFCAST.VMONTH01
Function FF02640()
   /* ------------------------------------------------------------*/
   /* Format data.*/
   /* ------------------------------------------------------------*/

  FF4REC.FF4BPFFL = "N"; /* Buy flag*/
  FF4REC.ZZZSDT = XX0XW01.XX0XWDAT; /* Setup date*/
  FF4REC.ZZZCHGDT = XX0XW01.XX0XWDAT; /* Change date*/
  FF4REC.ZZZCHGTM = XX0XW01.XX0XWTIM; /* Change time*/

   /* ------------------------------------------------------------*/
   /* Add DFCAST.VMONTH01.*/
   /* ------------------------------------------------------------*/

  try
    call "IO3720" ("A ", SQLCA, FF4REC) {isNoRefresh = yes, isExternal = yes};
  end /* Update row*/

   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/

    if (SQLCA.VAGen_SQLCODE == 0) /* Normal return code*/
      return; /* Return to previous process*/
    end

  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  FFWREC.XXXMODID = "640"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(47); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback(); /* Roll back all changes*/

    converseLib.validationFailed(1); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    converseLib.clearScreen();
     /* Clear screen before display*/

  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "ADD TABLE ROW";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FFWREC.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFCAST  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VMONTH01"; /* Table view name*/
  TA1REC.TA1TBLKE = FF4REC.FF4KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end FF02640

// Update Display storage
Function FF02650()
   /* ------------------------------------------------------------*/
   /* Check if NIL trgt field changed.*/
   /* ------------------------------------------------------------*/

  if (FF02M001.FF02MNLT[FF02WCNT] != FF02W01.FF02MNLT[FF02WCNT])

    FF02W01.FF02MNLT[FF02WCNT] = FF02M001.FF02MNLT[FF02WCNT];

    FFXREC.FFXCHAR = FF02M001.FF02MNLT[FF02WCNT];
                                   /* send to translate*/
    XSFFS13();
    FF02W01.FF02WNLT[FF02WCNT] = FFXREC.FFXNUMB; /* NIL trgt (bin)*/

    FF02W00.FF02WTSW = "Y"; /* turn the re-totaling switch on*/

  end

   /* ------------------------------------------------------------*/
   /* Check if MKUP trgt field changed.*/
   /* ------------------------------------------------------------*/

  if (FF02M001.FF02MMTG[FF02WCNT] != FF02W01.FF02MMTG[FF02WCNT])

    FF02W01.FF02MMTG[FF02WCNT] = FF02M001.FF02MMTG[FF02WCNT];

    FFXREC.FFXCHAR = FF02M001.FF02MMTG[FF02WCNT];
                                   /* send to translate*/
    XSFFS13();
    FF02W01.FF02WMTG[FF02WCNT] = FFXREC.FFXNUMB; /* mkup trgt (bin)*/

    FF02W00.FF02WTSW = "Y"; /* turn the re-totaling switch on*/

  end
   /* ------------------------------------------------------------*/
   /* Check if Co. trgt field changed.*/
   /* ------------------------------------------------------------*/

  if (FF02M001.FF02MCOT[FF02WCNT] != FF02W01.FF02MCOT[FF02WCNT])

    FF02W01.FF02MCOT[FF02WCNT] = FF02M001.FF02MCOT[FF02WCNT];

    FFXREC.FFXCHAR = FF02M001.FF02MCOT[FF02WCNT];
                                   /* send to translate*/
    XSFFS13();
    FF02W01.FF02WCOT[FF02WCNT] = FFXREC.FFXNUMB; /* Co. trgt (bin)*/

    FF02W00.FF02WTSW = "Y"; /* turn the re-totaling switch on*/

  end

   /* ------------------------------------------------------------*/
   /* If re-totaling is required, re-calculate fields.*/
   /* ------------------------------------------------------------*/

  if (FF02W00.FF02WTSW == "Y") /* if re-totaling required*/

    FF02651(); /* Re-total fields*/

  end

end // end FF02650

// Re-calculate fields
Function FF02651()
   /* ------------------------------------------------------------*/
   /* Re-calculate Dom target.*/
   /* Dom target = Co. trgt - NIL trgt*/
   /* ------------------------------------------------------------*/

  FF02W00.FF02WFDA = 0; /* clear work field*/

  FF02W00.FF02WFDA = FF02W00.FF02WFDA + FF02W01.FF02WCOT[FF02WCNT];
  FF02W00.FF02WFDA = FF02W00.FF02WFDA - FF02W01.FF02WNLT[FF02WCNT];

  FF02W01.FF02WDTG[FF02WCNT] = FF02W00.FF02WFDA; /* bin store*/

   /* MOVE FF02W00.FF02WFDA TO FFXREC.FFXNUMB; send to translate*/
   /* XSFFS12;*/
   /* MOVE FFXREC.FFXCHAR TO FF02W01.FF02MDTG(FF02WCNT); storage*/
   /* MOVE FFXREC.FFXCHAR TO FF02M001.FF02MDTG(FF02WCNT); map*/

   /* ------------------------------------------------------------*/
   /* Re-calculate Inline target.*/
   /* Inline trgt = Dom. trgt - MKUP trgt*/
   /* ------------------------------------------------------------*/

  FF02W00.FF02WFDA = 0; /* clear work field*/

  FF02W00.FF02WFDA = FF02W00.FF02WFDA + FF02W01.FF02WDTG[FF02WCNT];
  FF02W00.FF02WFDA = FF02W00.FF02WFDA - FF02W01.FF02WMTG[FF02WCNT];

  FF02W01.FF02WILT[FF02WCNT] = FF02W00.FF02WFDA; /* bin store*/

   /* MOVE FF02W00.FF02WFDA TO FFXREC.FFXNUMB; send to translate*/
   /* XSFFS12;*/
   /* MOVE FFXREC.FFXCHAR TO FF02W01.FF02MILT(FF02WCNT); storage*/
   /* MOVE FFXREC.FFXCHAR TO FF02M001.FF02MILT(FF02WCNT); map*/

   /* ------------------------------------------------------------*/
   /* Re-calculate Variance.*/
   /* Variance = s/buy IL - IL target*/
   /* ------------------------------------------------------------*/

  FF02W00.FF02WFDA = 0; /* clear work field*/

  FF02W00.FF02WFDA = FF02W00.FF02WFDA + FF02W01.FF02WSBI[FF02WCNT];
  FF02W00.FF02WFDA = FF02W00.FF02WFDA - FF02W01.FF02WILT[FF02WCNT];

  FF02W01.FF02WVAR[FF02WCNT] = FF02W00.FF02WFDA; /* bin store*/

   /* MOVE FF02W00.FF02WFDA TO FFXREC.FFXNUMB; send to translate*/
   /* XSFFS12;*/
   /* MOVE FFXREC.FFXCHAR TO FF02W01.FF02MVAR(FF02WCNT); storage*/
   /* MOVE FFXREC.FFXCHAR TO FF02M001.FF02MVAR(FF02WCNT); map*/

   /* ------------------------------------------------------------*/
   /* Re-Calculate TGT END INV & move to display storage.       |*/
                                                             /* |*/
   /* TGT END INV =  domest trgt + beg inv + on order - sls fcst|*/
                                                             /* |*/
   /* ff02w00.ff02wdtg    - domestic target                     |*/
   /* FF02W00.FF02Winv    - beg inv for inline and mkup         |*/
                         /* (last mo's ending inv, after 1st mo)|*/
   /* FF02W00.FF02WTOO    - on order inline & mkups             |*/
   /* FF02W01.FF02WSLF    - sales fcst inline & mkups           |*/
   /* ------------------------------------------------------------*/

  FF02W00.FF02WFDA = FF02W01.FF02WDTG[FF02WCNT]; /* domest target*/

  if (FF02W00.FF02WCNT == 1) /* If first month of range*/
    FF02W00.FF02WFDA = FF02W00.FF02WFDA + FF02W00.FF02WINV[FF02WCNT];
  else
    FF02W00.FF02WSUB = FF02W00.FF02WCNT - 1; /* count minus one*/
    FF02W00.FF02WFDA = FF02W00.FF02WFDA + FF02W01.FF02WTEI[FF02WSUB];
  end
  FF02W00.FF02WFDA = FF02W00.FF02WFDA + FF02W00.FF02WTOO[FF02WCNT];
  FF02W00.FF02WFDA = FF02W00.FF02WFDA - FF02W01.FF02WSLF[FF02WCNT];

  FF02W01.FF02WTEI[FF02WCNT] = FF02W00.FF02WFDA; /* disp storage*/

   /* ------------------------------------------------------------*/
   /* Re-Calculate:*/
             /* Sales Average = Sales Fcst for next 3 months * 12*/
   /* ------------------------------------------------------------*/

  FF02W00.FF02WFDA = 0; /* clear work field*/
  FF02W00.FF02WFDB = 0; /* clear work field*/
  FF02W00.FF02WFDC = 0; /* clear work field*/

  FF02W00.FF02WFDA = FF02W00.FF02WSAV * 12; /* Avg sales*/

   /* ------------------------------------------------------------*/
   /* Re-Calculate:*/
        /* Average Inventory  =  Ending inventory  *  3*/
   /* ------------------------------------------------------------*/

  FF02W00.FF02WFDB = FF02W01.FF02WTEI[FF02WCNT] * 3; /* Avg Inv*/


end // end FF02651

// Check if re-totaling required
Function FF02660()
   /* ------------------------------------------------------------*/
   /* Check if re-totaling is required.*/
   /* ------------------------------------------------------------*/

  if (FF02W00.FF02WTSW == "Y") /* re-totaling required*/

    FF02W00.FF02WCNT = 1;
    FF02W00.FF02WTTA = 0;
    FF02W00.FF02WTTC = 0;
    FF02W00.FF02WTTD = 0;
    FF02W00.FF02WTTG = 0;
    FF02W00.FF02WTTH = 0;
    FF02W00.FF02WTTK = 0;
    FF02W00.FF02WTTN = 0;
    FF02W00.FF02WTTO = 0;

    /* ---------------------------------------------------*/
     /* Add up Dom TRGT, MKUP trgt, NIL trgt, and Co. trgt*/
    /* ---------------------------------------------------*/
    while (FF02W00.FF02WCNT <= FF02W00.FF02WNBR) /* until ^le nbr month*/

      FF02W00.FF02WTTA = FF02W00.FF02WTTA + FF02W01.FF02WCOT[FF02WCNT];
      FF02W00.FF02WTTC = FF02W00.FF02WTTC + FF02W01.FF02WNLT[FF02WCNT];
      FF02W00.FF02WTTD = FF02W00.FF02WTTD + FF02W01.FF02WDTG[FF02WCNT];
      FF02W00.FF02WTTG = FF02W00.FF02WTTG + FF02W01.FF02WMTG[FF02WCNT];
      FF02W00.FF02WTTH = FF02W00.FF02WTTH + FF02W01.FF02WILT[FF02WCNT];
      FF02W00.FF02WTTK = FF02W00.FF02WTTK + FF02W01.FF02WVAR[FF02WCNT];
      FF02W00.FF02WTTN = FF02W00.FF02WTTN + FF02W01.FF02WTEI[FF02WCNT];
      FF02W00.FF02WTTO = FF02W00.FF02WTTO + FF02W01.FF02WTVT[FF02WCNT];

      FF02W00.FF02WCNT = FF02W00.FF02WCNT + 1;

    end

    /* --------------------------------------------------*/
     /* Co. target*/
    /* --------------------------------------------------*/

    FF02W01.FF02WCOT[FF02WCNT] = FF02W00.FF02WTTA; /* bin store*/

    /* --------------------------------------------------*/
     /* NIL target*/
    /* --------------------------------------------------*/

    FF02W01.FF02WNLT[FF02WCNT] = FF02W00.FF02WTTC; /* bin store*/

    /* --------------------------------------------------*/
     /* DOM target*/
    /* --------------------------------------------------*/

    FF02W01.FF02WDTG[FF02WCNT] = FF02W00.FF02WTTD; /* bin store*/

    /* --------------------------------------------------*/
     /* MKUPS Target*/
    /* --------------------------------------------------*/

    FF02W01.FF02WMTG[FF02WCNT] = FF02W00.FF02WTTG; /* bin store*/

    /* --------------------------------------------------*/
     /* INline target.*/
    /* --------------------------------------------------*/

    FF02W01.FF02WILT[FF02WCNT] = FF02W00.FF02WTTH; /* bin store*/

    /* --------------------------------------------------*/
     /* Variance.*/
    /* --------------------------------------------------*/

    FF02W01.FF02WVAR[FF02WCNT] = FF02W00.FF02WTTK; /* bin store*/

    /* --------------------------------------------------*/
     /* Target ending inventory.*/
    /* --------------------------------------------------*/

    FF02W01.FF02WTEI[FF02WCNT] = FF02W00.FF02WTTN; /* bin store*/

  end

end // end FF02660

// Open MLTYP
Function FF02S01()
   /* ------------------------------------------------------------*/
   /* Open VMLTYP01.*/
   /* ------------------------------------------------------------*/

  try
    call "IO3750" (FFFREC, SQLCA, FF6REC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/

    if (SQLCA.VAGen_SQLCODE == 0) /* Normal return code*/

      return; /* Return to previous process*/

    end

  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL Commarea*/

  FFWREC.XXXMODID = "S01"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(47); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(01); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    converseLib.clearScreen();
     /* Clear screen before display*/

  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "OPEN DFCAST.VMLTYP01";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FFWREC.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFCAST  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VMLTYP01"; /* Table view name*/
  TA1REC.TA1TBLKE = FF6REC.FF6KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/



end // end FF02S01

// Fetch MLTYP
Function FF02S02()
   /* ------------------------------------------------------------*/
   /* Fetch VMLTYP01.*/
   /* ------------------------------------------------------------*/

  try
    call "IO3750" (FFFREC, SQLCA, FF6REC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

   /* ------------------------------------------------------------*/
   /* If successful or not found, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/

    if (SQLCA.VAGen_SQLCODE == 0 /* Normal return code*/
     || SQLCA.VAGen_SQLCODE == 100) /* or row not found*/

      if (SQLCA.VAGen_SQLCODE == 0) /* Normal return code*/
        FF02W00.FF02WRTN = "Y"; /* Row was returned*/
      end

      return; /* Return to previous process*/

    end

  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL Commarea*/

  FFWREC.XXXMODID = "S02"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(47); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(01); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    converseLib.clearScreen();
     /* Clear screen before display*/

  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "FETCH DFCAST.VMLTYP01";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FFWREC.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFCAST  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VMLTYP01"; /* Table view name*/
  TA1REC.TA1TBLKE = FF6REC.FF6KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/



end // end FF02S02

// Close MLTYP
Function FF02S03()
   /* ------------------------------------------------------------*/
   /* Select the row to display from the table.*/
   /* ------------------------------------------------------------*/

  try
    call "IO3750" (FFFREC, SQLCA, FF6REC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/

    if (SQLCA.VAGen_SQLCODE == 0) /* Normal return code*/

      return; /* Return to previous process*/

    end

  end

   /* ------------------------------------------------------------*/
   /* Indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL Commarea*/

  FFWREC.XXXMODID = "S03"; /* Module identification*/

  converseLib.validationFailed(01); /* Indicate system error*/
  TA1REC.TA1FUNC = "RETN"; /* Termination function*/

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "CLOSE DFCAST.VMLTYP01";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FFWREC.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFCAST  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VMLTYP01"; /* Table view name*/
  TA1REC.TA1TBLKE = FF6REC.FF6KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/



end // end FF02S03

// Get futures cutoff date
Function FF02S04()

  set FF1REC empty; /* Clear up the storage row*/

  try
    call "IO3660" ("S ", SQLCA, FF1REC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

   /* ------------------------------------------------------------*/
   /* If successful or not found, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/
    if (SQLCA.VAGen_SQLCODE == 0 /* Normal return code*/
     || SQLCA.VAGen_SQLCODE == 100) /* Row not found*/
      return; /* Return to previous process*/
    end
  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL Commarea*/

  FFWREC.XXXMODID = "S04"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/
    converseLib.validationFailed(47); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(01); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
     /* Clear screen before display*/
  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "GET FUTURES CUTOFF D";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FFWREC.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFCAST  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VFFCTL01"; /* Table view name*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end FF02S04

// Translate millions to units
Function XSFFS13()

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* This subroutine translates a four-byte character field in*/
   /* millions representation to a nine-byte numeric field in*/
   /* exact units.*/

   /* The number to be translated is passed in FFXREC.FFXCHAR.*/
   /* The number is verified for acceptable numeric syntax.  Any*/
   /* sign (+ or -), decimal point (.) or space is resolved and*/
   /* the result is converted to millions.  The number is*/
   /* returned to the calling process in FFXREC.FFXNUMB.*/

   /* If any error is found during translation, it is indicated*/
   /* by the completion code in FFXREC.FFXRTNCD.*/

   /* *** Code the following before this is executed:         ****/
   /* ***                                                     ****/
   /* ***   FFXREC.FFXCHAR: The number to be translated.      ****/
   /* ***                   A maximum of one decimal place    ****/
   /* ***                   may be specified in this number.  ****/

   /* The subroutine will return the completion code in FFXRTNCD.*/

   /* ***   FFXREC.FFXRTNCD                                   ****/
   /* ***   ---------------                                   ****/
   /* ***   '0' = Normal return                               ****/
   /* ***   '1' = Imbedded space was found                    ****/
   /* ***   '2' = Too many decimal places                     ****/
   /* ***   '3' = Field is not numeric                        ****/
   /* ***   '4' = Number is too large                         ****/

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* ------------------------------------------------------------*/
   /* Initialize the return code, index and counter to be used.*/
   /* ------------------------------------------------------------*/

  FFXREC.FFXRTNCD = "0"; /* Subroutine return code*/

  FFXREC.FFXINPIX = 1; /* Input byte index*/
  FFXREC.FFXDIGCT = 0; /* Digits count*/

   /* ------------------------------------------------------------*/
   /* Find any decimal point that was entered.*/
   /* ------------------------------------------------------------*/

  while (FFXREC.FFXINPIX <= 4 /* Until end of input*/
   && FFXREC.XXXCHAR[FFXINPIX] != ".") /* or decimal point found*/

    FFXREC.FFXINPIX = FFXREC.FFXINPIX + 1; /* Input byte index*/

  end

   /* ------------------------------------------------------------*/
   /* Bypass any decimal point that was entered.*/
   /* ------------------------------------------------------------*/

  if (FFXREC.FFXINPIX <= 4 /* Not end of input*/
   && FFXREC.XXXCHAR[FFXINPIX] == ".") /* and decimal point found*/

    FFXREC.FFXINPIX = FFXREC.FFXINPIX + 1; /* Input byte index*/

  end

   /* ------------------------------------------------------------*/
   /* Count the number of decimals following the decimal point.*/
   /* ------------------------------------------------------------*/

  while (FFXREC.FFXINPIX <= 4 /* Until end of input*/
   && FFXREC.XXXCHAR[FFXINPIX] != " ") /* or trailing space found*/

    FFXREC.FFXDIGCT = FFXREC.FFXDIGCT + 1; /* Digits count*/

    FFXREC.FFXINPIX = FFXREC.FFXINPIX + 1; /* Input byte index*/

  end

   /* ------------------------------------------------------------*/
   /* Indicate error if trailing positions are not spaces.*/
   /* ------------------------------------------------------------*/

  while (FFXREC.FFXINPIX <= 4) /* Until end of input*/

    if (FFXREC.XXXCHAR[FFXINPIX] == " ") /* Trailing space*/

      FFXREC.FFXINPIX = FFXREC.FFXINPIX + 1; /* Input byte index*/

    else

      FFXREC.FFXRTNCD = "1"; /* Indicate imbedded space*/

      return; /* Return to previous process*/

    end

  end

   /* ------------------------------------------------------------*/
   /* Indicate error if more than one decimal place was entered.*/
   /* ------------------------------------------------------------*/

  if (FFXREC.FFXDIGCT > 1) /* Too many decimal places*/

    FFXREC.FFXRTNCD = "2"; /* Indicate too many decimals*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* Initialize the work field, index and counter to be used.*/
   /* ------------------------------------------------------------*/

  FFXREC.FFXROUND = 0; /* Translation work field*/

  FFXREC.FFXINPIX = 4; /* Input byte index*/
  FFXREC.FFXOUTIX = 6; /* Output byte index*/
  FFXREC.FFXDECCT = 3; /* Decimals count*/
  FFXREC.FFXSIGN = 1; /* Result field sign*/

   /* ------------------------------------------------------------*/
   /* Move any decimal positions entered to the output area.*/
   /* ------------------------------------------------------------*/

  while (FFXREC.FFXINPIX > 0 /* Until end of input*/
   && FFXREC.FFXDECCT > 0) /* or end of decimals*/

    if (FFXREC.XXXCHAR[FFXINPIX] == " ") /* Blank character*/

      FFXREC.FFXINPIX = FFXREC.FFXINPIX - 1; /* Input byte index*/

    else

      if (FFXREC.FFXDECCT > FFXREC.FFXDIGCT) /* Position not entered*/

        FFXREC.XXXEDN2[FFXOUTIX] = 0; /* Default decimal position*/

      else

        if (FFXREC.XXXCHAR[FFXINPIX] < "0" /* Less than 0*/
         || FFXREC.XXXCHAR[FFXINPIX] > "9") /* or greater than 9*/

          FFXREC.FFXRTNCD = "3"; /* Indicate field not numeric*/

          return; /* Return to previous process*/

        end

        FFXREC.XXXEDN2[FFXOUTIX] = FFXREC.XXXEDN1[FFXINPIX];

        FFXREC.FFXINPIX = FFXREC.FFXINPIX - 1; /* Input byte index*/

      end

      FFXREC.FFXDECCT = FFXREC.FFXDECCT - 1; /* Decimals count*/
      FFXREC.FFXOUTIX = FFXREC.FFXOUTIX - 1; /* Output byte index*/

    end

  end

   /* ------------------------------------------------------------*/
   /* Bypass any decimal point that was entered.*/
   /* ------------------------------------------------------------*/

  if (FFXREC.FFXINPIX > 0 /* Not end of input*/
   && FFXREC.XXXCHAR[FFXINPIX] == ".") /* and decimal point found*/

    FFXREC.FFXINPIX = FFXREC.FFXINPIX - 1; /* Input byte index*/

  end

   /* ------------------------------------------------------------*/
   /* Move any units positions entered to the output area.*/
   /* ------------------------------------------------------------*/

  while (FFXREC.FFXINPIX > 0             /* Until end of input*/
   && FFXREC.XXXCHAR[FFXINPIX] != " " /* or leading space found*/
   && FFXREC.XXXCHAR[FFXINPIX] != "+" /* or positive sign found*/
   && FFXREC.XXXCHAR[FFXINPIX] != "-") /* or negative sign found*/

    if (FFXREC.XXXCHAR[FFXINPIX] < "0" /* Less than 0*/
     || FFXREC.XXXCHAR[FFXINPIX] > "9") /* or greater than 9*/

      FFXREC.FFXRTNCD = "3"; /* Indicate field not numeric*/

      return; /* Return to previous process*/

    end

    if (FFXREC.FFXOUTIX > 0) /* Not end of output*/

      FFXREC.XXXEDN2[FFXOUTIX] = FFXREC.XXXEDN1[FFXINPIX];

      FFXREC.FFXOUTIX = FFXREC.FFXOUTIX - 1; /* Output byte index*/

    else

      if (FFXREC.XXXCHAR[FFXINPIX] > "0") /* Non-zero character*/

        FFXREC.FFXRTNCD = "4"; /* Indicate number too large*/

        return; /* Return to previous process*/

      end

    end

    FFXREC.FFXINPIX = FFXREC.FFXINPIX - 1; /* Input byte index*/

  end

   /* ------------------------------------------------------------*/
   /* Indicate a negative number if a negative sign was found.*/
   /* ------------------------------------------------------------*/

  if (FFXREC.FFXINPIX > 0) /* Not end of input*/

    if (FFXREC.XXXCHAR[FFXINPIX] == "-") /* Negative sign found*/
      FFXREC.FFXSIGN = -1; /* Result field sign*/
    end

    FFXREC.FFXINPIX = FFXREC.FFXINPIX - 1; /* Input byte index*/

  end

   /* ------------------------------------------------------------*/
   /* Indicate error if leading positions are not spaces.*/
   /* ------------------------------------------------------------*/

  while (FFXREC.FFXINPIX > 0) /* Until end of input*/

    if (FFXREC.XXXCHAR[FFXINPIX] == " ") /* Leading space*/

      FFXREC.FFXINPIX = FFXREC.FFXINPIX - 1; /* Input byte index*/

    else

      FFXREC.FFXRTNCD = "1"; /* Indicate imbedded space*/

      return; /* Return to previous process*/

    end

  end

   /* ------------------------------------------------------------*/
   /* Calculate the resulting number into the return field.*/
   /* ------------------------------------------------------------*/

  FFXREC.FFXNUMB = FFXREC.FFXROUND * FFXREC.FFXSIGN;


end // end XSFFS13

//*** RECORD=FF02W00 ****
// ----------------------------
// Application working storage.
// ----------------------------
// ***********************
Record FF02W00 type basicRecord
  10 FF02WSWR FF02WSWR ; 
  10 FF02WSWF FF02WSWF ; 
  10 FF02WRTN FF02WRTN ; 
  10 FF02WDSW FF02WDSW ; 
  10 FF02WTSW FF02WTSW ; 
  10 FF02WST0 FF02WST0 ; 
  10 FF02WCAL FF02WCAL ; 
  10 * char(1) ; 
  10 FF02WNBR FF02WNBR ; 
  10 FF02WAVG FF02WAVG ; 
  10 FF02WCNT FF02WCNT ; 
  10 FF02WSUB FF02WSUB ; 
  10 FF02WNNN FF02WNNN ; 
  10 * char(1) ; 
  10 FF02WHCT FF02WHCT [12] ; 
  10 FF02WHNT FF02WHNT [12] ; 
  10 FF02WHMT FF02WHMT [12] ; 
  10 * char(1) ; 
  10 FF02WNCC FF02WNCC [15] ; 
  10 FF02WNMO FF02WNMO [15] ; 
  10 * char(1) ; 
  10 FF02WMDT FF02WMDT ; 
    15 FF02WMCC FF02WMCC ; 
    15 FF02WMMO FF02WMMO ; 
  10 * char(1) ; 
  10 FF02WCBG FF02WCBG ; 
    15 * char(2) ; 
    15 FF02WCBC FF02WCBC ; 
    15 FF02WCBD FF02WCBD ; 
  10 * char(1) ; 
  10 FF02WCEG FF02WCEG ; 
    15 * char(2) ; 
    15 FF02WCEC FF02WCEC ; 
    15 FF02WCED FF02WCED ; 
  10 * char(1) ; 
  10 FF02WHCC FF02WHCC ; 
  10 FF02WHDT FF02WHDT ; 
    15 FF02WHYY FF02WHYY ; 
    15 FF02WHMM FF02WHMM ; 
  10 * char(1) ; 
  10 FF02WXDT FF02WXDT ; 
    15 * num(1) ; 
    15 FF02WXYM FF02WXYM ; 
      20 FF02WXCC FF02WXCC ; 
      20 FF02WXYY FF02WXYY ; 
      20 FF02WXMM FF02WXMM ; 
    15 FF02WXDD FF02WXDD ; 
  10 * char(1) ; 
  10 FF02WBUY FF02WBUY ; 
  10 * char(1) ; 
  10 FF02WBDT FF02WBDT ; 
    15 FF02WBYY FF02WBYY ; 
    15 FF02WBMM FF02WBMM ; 
  10 * char(1) ; 
  10 FF02WEDT FF02WEDT ; 
    15 FF02WEYY FF02WEYY ; 
    15 FF02WEMM FF02WEMM ; 
  10 * char(1) ; 
  10 FF02WFDA FF02WFDA ; 
  10 FF02WFDB FF02WFDB ; 
  10 FF02WFDC FF02WFDC ; 
  10 FF02WFDD FF02WFDD ; 
  10 * char(1) ; 
  10 FF02WCIT FF02WCIT ; 
  10 * char(1) ; 
  10 FF02WTTA FF02WTTA ; 
  10 FF02WTTB FF02WTTB ; 
  10 FF02WTTC FF02WTTC ; 
  10 FF02WTTD FF02WTTD ; 
  10 FF02WTTE FF02WTTE ; 
  10 FF02WTTF FF02WTTF ; 
  10 FF02WTTG FF02WTTG ; 
  10 FF02WTTH FF02WTTH ; 
  10 FF02WTTI FF02WTTI ; 
  10 FF02WTTJ FF02WTTJ ; 
  10 FF02WTTK FF02WTTK ; 
  10 FF02WTTL FF02WTTL ; 
  10 FF02WTTM FF02WTTM ; 
  10 FF02WTTN FF02WTTN ; 
  10 FF02WTTO FF02WTTO ; 
  10 FF02WTTP FF02WTTP ; 
  10 * char(1) ; 
  10 FF02WHSF FF02WHSF [2] ; 
  10 FF02WHPF FF02WHPF [2] ; 
  10 FF02WHPT FF02WHPT [2] ; 
  10 FF02WHBI FF02WHBI [2] ; 
  10 FF02WHSB FF02WHSB [2] ; 
  10 FF02WHOO FF02WHOO [2] ; 
  10 FF02WHSS FF02WHSS [2] ; 
  10 * char(1) ; 
  10 ZZZCHGCT ZZZCHGCT [2] ; 
  10 * char(1) ; 
  10 FF02WTOO FF02WTOO [15] ; 
  10 FF02WSLS FF02WSLS [15] ; 
  10 FF02WINV FF02WINV [15] ; 
  10 FF02WSAV FF02WSAV ; 
  10 * char(1) ; 
  10 FF02WNUM FF02WNUM ; 
end // end FF02W00

//*** RECORD=FF02W01 ****
// ------------------------
// Map 001 display storage.
// ------------------------
// ***********************
Record FF02W01 type basicRecord
  10 CACHGFL CACHGFL ; 
  10 * char(1) ; 
  10 FFABEGMO FFABEGMO [13] ; 
  10 FFAENDMO FFAENDMO [13] ; 
  10 * char(1) ; 
  10 FF02WRMO FF02WRMO [13] ; 
  10 * char(1) ; 
  10 FF02MCOT FF02MCOT [13] ; 
  10 FF02MSBN FF02MSBN [13] ; 
  10 FF02MNLT FF02MNLT [13] ; 
  10 FF02MDTG FF02MDTG [13] ; 
  10 FF02MPFC FF02MPFC [13] ; 
  10 FF02MSBM FF02MSBM [13] ; 
  10 FF02MMTG FF02MMTG [13] ; 
  10 FF02MILT FF02MILT [13] ; 
  10 FF02MILF FF02MILF [13] ; 
  10 FF02MSBI FF02MSBI [13] ; 
  10 FF02MVAR FF02MVAR [13] ; 
  10 FF02MSEI FF02MSEI [13] ; 
  10 FF02MSIT FF02MSIT [13] ; 
  10 FF02MTEI FF02MTEI [13] ; 
  10 FF02MTVT FF02MTVT [13] ; 
  10 FF02MSLF FF02MSLF [13] ; 
  10 * char(1) ; 
  10 FF02WCOT FF02WCOT [13] ; 
  10 FF02WSBN FF02WSBN [13] ; 
  10 FF02WNLT FF02WNLT [13] ; 
  10 FF02WDTG FF02WDTG [13] ; 
  10 FF02WPFC FF02WPFC [13] ; 
  10 FF02WSBM FF02WSBM [13] ; 
  10 FF02WMTG FF02WMTG [13] ; 
  10 FF02WILT FF02WILT [13] ; 
  10 FF02WILF FF02WILF [13] ; 
  10 FF02WSBI FF02WSBI [13] ; 
  10 FF02WVAR FF02WVAR [13] ; 
  10 FF02WSEI FF02WSEI [13] ; 
  10 FF02WSIT FF02WSIT [13] ; 
  10 FF02WTEI FF02WTEI [13] ; 
  10 FF02WTVT FF02WTVT [13] ; 
  10 FF02WSLF FF02WSLF [13] ; 
  10 * char(1) ; 
end // end FF02W01

// FF_PRDCTN_TRGT
DataItem FF02MCOT char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem FF02MDTG char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem FF02MILF char(4)  {
  align = right, fillCharacter = nullFill, inputRequired = no
}
end

DataItem FF02MILT char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// FF_MK_PRDCTN_TRGT
DataItem FF02MMTG char(4)  {
  align = right, fillCharacter = nullFill, inputRequired = no
}
end

// FF_NIL_PRDCTN_TRGT
DataItem FF02MNLT char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// FF_PRDCTN_FCST
DataItem FF02MPFC char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem FF02MSBI char(4)  {
  align = right, fillCharacter = nullFill, inputRequired = no
}
end

DataItem FF02MSBM char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// FF_NIL_PRDCTN_BUY
DataItem FF02MSBN char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem FF02MSEI char(4)  {
  align = right, fillCharacter = nullFill, inputRequired = no
}
end

DataItem FF02MSIT num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Sales forecast
DataItem FF02MSLF char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem FF02MTEI char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem FF02MTVT num(4)  {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

DataItem FF02MVAR char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Sub for 3 mos past range
DataItem FF02WAVG num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = "0", inputRequired = no
}
end

// begin date
DataItem FF02WBDT num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = "0", inputRequired = no
}
end

// begin month
DataItem FF02WBMM num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = "0", inputRequired = no
}
end

// buy date CCYYMM
DataItem FF02WBUY num(6)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// begin year
DataItem FF02WBYY num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = "0", inputRequired = no
}
end

// Request calculation
DataItem FF02WCAL char(1)  {
  align = right, fillCharacter = "0", inputRequired = no
}
end

// converted beg cc
DataItem FF02WCBC num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = "0", inputRequired = no
}
end

// converted beg date yymm
DataItem FF02WCBD num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = "0", inputRequired = no
}
end

// converted beg group
DataItem FF02WCBG num(8)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = "0", dateFormat = "yy-MM-dd", inputRequired = no
}
end

// converted end cc
DataItem FF02WCEC num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = "0", inputRequired = no
}
end

// converted end date yymm
DataItem FF02WCED num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = "0", inputRequired = no
}
end

// converted end group
DataItem FF02WCEG num(8)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = "0", dateFormat = "yy-MM-dd", inputRequired = no
}
end

// Hold for INLINE trgt
DataItem FF02WCIT int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Counter for loops
DataItem FF02WCNT num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = "0", inputRequired = no
}
end

// FF_PRDCTN_TRGT
DataItem FF02WCOT int {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Data found switch
DataItem FF02WDSW char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// domestic target
DataItem FF02WDTG int {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// ending date
DataItem FF02WEDT num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = "0", inputRequired = no
}
end

// ending month
DataItem FF02WEMM num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = "0", inputRequired = no
}
end

// ending year
DataItem FF02WEYY num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = "0", inputRequired = no
}
end

// units to millions
DataItem FF02WFDA bin(18,1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// use for calulations
DataItem FF02WFDB bin(18,1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// use for calulations
DataItem FF02WFDC bin(18,1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// use for calulations
DataItem FF02WFDD bin(18,1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// beginning inv
DataItem FF02WHBI int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// hold century
DataItem FF02WHCC num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// hold co trgt for compare
DataItem FF02WHCT char(4)  {
  align = right, fillCharacter = "0", inputRequired = no
}
end

// hold date
DataItem FF02WHDT num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// hold month
DataItem FF02WHMM num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = "0", inputRequired = no
}
end

// hold mkp trgt for compare
DataItem FF02WHMT char(4)  {
  align = right, fillCharacter = "0", inputRequired = no
}
end

// hold NIL trgt for compare
DataItem FF02WHNT char(4)  {
  align = right, fillCharacter = "0", inputRequired = no
}
end

// on order
DataItem FF02WHOO int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// production fcst
DataItem FF02WHPF int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// production trgt
DataItem FF02WHPT int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// suggested buy
DataItem FF02WHSB int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// sales fcst
DataItem FF02WHSF int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// safety stock
DataItem FF02WHSS int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// hold year
DataItem FF02WHYY num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = "0", inputRequired = no
}
end

// Inline target
DataItem FF02WILF int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Inline target
DataItem FF02WILT int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = nullFill, inputRequired = no
}
end

// begin inventory
DataItem FF02WINV int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// mask cc
DataItem FF02WMCC num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = "0", inputRequired = no
}
end

// mask for calls
DataItem FF02WMDT num(6)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = "0", dateFormat = "yy-MM-dd", inputRequired = no
}
end

// mask yymm
DataItem FF02WMMO num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = "0", inputRequired = no
}
end

// FF_MK_PRDCTN_TRGT
DataItem FF02WMTG int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = nullFill, inputRequired = no
}
end

// True nbr of mos in range
DataItem FF02WNBR num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = "0", inputRequired = no
}
end

// CC for dates
DataItem FF02WNCC num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = "0", inputRequired = no
}
end

// FF_NIL_PRDCTN_TRGT
DataItem FF02WNLT int {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// YYMMs for dates
DataItem FF02WNMO num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = "0", inputRequired = no
}
end

// generic subcript
DataItem FF02WNNN num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = "0", inputRequired = no
}
end

// number mask
DataItem FF02WNUM num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// FF_PRDCTN_FCST
DataItem FF02WPFC int {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// YYMMs for dates
DataItem FF02WRMO char(4)  {
  align = right, fillCharacter = "0", inputRequired = no
}
end

// Return code switch
DataItem FF02WRTN char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// calc sales avg
DataItem FF02WSAV int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// S/buy inline
DataItem FF02WSBI int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = nullFill, inputRequired = no
}
end

// S/buy makeups
DataItem FF02WSBM int {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// FF_NIL_PRDCTN_BUY
DataItem FF02WSBN int {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Sug end inv
DataItem FF02WSEI int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Sug inv trn
DataItem FF02WSIT bin(9,1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Sales forecast
DataItem FF02WSLF int {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// sales fcst
DataItem FF02WSLS int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Request set-to-zero
DataItem FF02WST0 char(1)  {
  align = right, fillCharacter = "0", inputRequired = no
}
end

// Pointer for tot position
DataItem FF02WSUB num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = "0", inputRequired = no
}
end

// Format the map switch
DataItem FF02WSWF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Request for data switch
DataItem FF02WSWR char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Tgt end inv
DataItem FF02WTEI int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = nullFill, inputRequired = no
}
end

// on order mkup & inl
DataItem FF02WTOO int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Re-totaling switch
DataItem FF02WTSW char(1)  {
  align = right, fillCharacter = "0", inputRequired = no
}
end

// Tot Co.target
DataItem FF02WTTA int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Tot s/buy NIL
DataItem FF02WTTB int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Tot NIL target
DataItem FF02WTTC int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Tot dom target
DataItem FF02WTTD int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Tot dom forecast
DataItem FF02WTTE int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Tot s/buy mkups
DataItem FF02WTTF int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Tot mkup trgts
DataItem FF02WTTG int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Tot inline trgts
DataItem FF02WTTH int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Tot inline fcst
DataItem FF02WTTI int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Tot s/buy inline
DataItem FF02WTTJ int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Tot variance
DataItem FF02WTTK int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Tot sug end inv
DataItem FF02WTTL int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Tot sug inv trn
DataItem FF02WTTM bin(9,1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Tot tgt end inv
DataItem FF02WTTN int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Tot tgt inv trn
DataItem FF02WTTO bin(9,1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Tot sales fcst
DataItem FF02WTTP int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Tgt inv trn
DataItem FF02WTVT bin(9,1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Variance
DataItem FF02WVAR int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = nullFill, inputRequired = no
}
end

// buy century
DataItem FF02WXCC num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// buy day
DataItem FF02WXDD num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = "0", inputRequired = no
}
end

// buy date
DataItem FF02WXDT num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// buy month
DataItem FF02WXMM num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = "0", inputRequired = no
}
end

// buy CCYYMM
DataItem FF02WXYM char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// buy year
DataItem FF02WXYY num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = "0", inputRequired = no
}
end

