package fg0m;

import corpcom1.CACHGFL;
import corpcom2.XPCREC;
import corpcom2.XX0XW01;
import corpcom2.XX0XW02;
import corpcom3.XPFF001;
import corpcom3.XPXPC01;
import corpcom3.XPXX001;
import corpcom3.XPYPG01;
import corpcom4.XSFFS-FF5570;
import corpcom4.XSFFS01;
import corpcom4.XSFFS10;
import corpcom4.XSFFS30;
import corpcom4.XSFFS54;
import corpcom4.XX0XS01;
import corpcom5.COMMAREA;
import corpcom6.SQLCA;
import corpcom7.XXXTSLEN;
import corpcom7.XXXTSPAG;
import corpx1.XPCTBL;
import corpy2.YPGTBL;
import ff.common.*;
import fh.common.FH1REC;
import fh.common.FH5REC;
import pg.common.PG7REC;
import sy.common.SYBSTGNB;
import sy.common.SYBSTGNM;
import ta.common.TA1REC;
import ta.common.TA2REC;
import ta.common.TA3REC;
import ta.common.TA5REC;
import ta.common.TA5TSQIX;
import ta.common.TA6REC;
import ta.common.TAEREC;
//*** PROGRAM=FG0M ****
// This application allows a user to inquire the monthly long
// range sales forecast by product style grp for a given range
// of months. The required range could be any period of time,
// past, current or furtur. The user may inquire the forecast
// by type grp, category, and need/ship month based.
// 
// All quanitites on the screen are in thousands.
// 
// The user can specify the number of months in the season and
// he has the flexibility to view 4 months, or 6 month seasons
// with varying subtotals.
// 
// The user may use appropriate attention key to scroll the
// screen backwards, forwards, left and right.
// 
// The user may exit to any allowed application, via FAST PATH
// or PF key, from either of the screens.
// 
// -------  --------  ------  ---------------------------------
// CONTROL    DATE     NAME   DESCRIPTION OF CHANGE
// -------  --------  ------  ---------------------------------
//          02/10/90  RGILLI  New application.
// FF#134   08/21/90  SFORD   Set job completed msg flag = 'y'
// Fix      08/23/90  JJUCH   Zero out the qtys which are after
//                            the closeout month.
// ff1037   09/25/90  RHETRI  Chg cursor call FFSTY to MXPRC
// Fix      10/03/90  JJUCH   - Skip historical stygrps with no
//                              actual qtys.
//                            - Fixed the problem of dropping
//                              style groups.
// Fix      10/15/90  JJUCH   Qualify category code when access
//                            DFHIST.VSYSHP01 with 'SG' func.
// Fix      10/25/90  MDANG   Added new select to Max price
//                            table for NIL to make sure the
//                            proper max price and close out
//                            month are used.
// Fix      03/28/91  JJUCH   Stop reporting sales qty in the
//                            actual closeout month.
// Fix      04/04/91  JJUCH   fixed the problem of showing
//                            apperal categories in pop-up
//                            window.
// FF1106   02/06/92  LDELUH  Allow combined countries & div.
// FFMAINT  02/21/92  LDELUH  Remove sales region logic.
// FF1111   04/23/92  JJUCH   Chng to allow varying len season.
// FF301    05/19/92  JJUCH   Remove proj clsout mo restriction
// Fix      06/26/92  JJUCH   Fixed fast path data not showing
//                            problem.
// FF394    03/23/93  JJUCH   Change to send report to BUNDLE.
// FF367    03/29/93  JJUCH   Change to accommdate the NIL
//                            management region process.
//          09/10/93  JJUCH   Convert to CSP V4.1 version.
// ff-409   04/04/94  mwalke  Enhancement for dmnd based sales.
//                            Deleted print function.
//                            Deleted ctry cd and desc and
//                            summary division cd and desc.
//                            Added need/ship month indicator.
// FF175    12/10/96  DSMITH  Changed the date range fill
//                            character to '0'.
// *********************
Program FG0M type textUIProgram //VAGen Info - main text program
  {
  includeReferencedFunctions = yes, allowUnqualifiedItemReferences = yes, 
  throwNrfEofExceptions = yes, handleHardIOErrors = no, V60ExceptionCompatibility = yes, 
  I4GLItemsNullable = no, textLiteralDefaultIsString = no, localSQLScope = yes, 
  msgTablePrefix = "FF00", inputRecord = COMMAREA, segmented = yes
  }

  // Data Declarations
  COMMAREA COMMAREA ; // record
  FF1REC FF1REC; // record
  FF2REC FF2REC; // record
  FF3REC FF3REC; // record
  FF8REC FF8REC; // record
  FFFREC FFFREC; // record
  FFWREC FFWREC; // record
  FFXREC FFXREC; // record
  FFZREC FFZREC; // record
  FG0MW00 FG0MW00; // record
  FG0MW01 FG0MW01; // record
  FG0MW02 FG0MW02; // record
  FG0MW03 FG0MW03; // record
  FH1REC FH1REC; // record
  FH5REC FH5REC; // record
  PG7REC PG7REC; // record
  SQLCA SQLCA; // record
  TA1REC TA1REC; // record
  TA2REC TA2REC; // record
  TA3REC TA3REC; // record
  TA5REC TA5REC; // record
  TA6REC TA6REC; // record
  TAEREC TAEREC; // record
  XPCREC XPCREC; // record
  XX0XW01 XX0XW01; // record
  XX0XW02 XX0XW02; // record

  // VAGen Info - items needed for migration
  VAGen_EZESYS char(8);
  VAGen_EZEREPLY num(1);
  VAGen_EZE_WAIT_TIME bin(9,2);
  VAGen_EZE_ITEMLEN int;

  // Use Declarations
  use XPCTBL; // table
  use YPGTBL; // table
  use FG0MM.FG0MM001, // form
  		FG0MM.XX0XM001
   {
    pfKeyEquate = no
  };

  function main()
    // VAGen Info - initialization needed for migration
    VAGen_EZESYS = VGLib.getVAGSysType();
    XPFF001: XPFF001();
     /* ------------------------------------------------------------*/
     /* Initialize working storage and display storage areas.*/
     /* ------------------------------------------------------------*/

    set FFFREC empty; /* Special function parameters*/
    set FG0MM001 initial; /* M001 input/output*/
    set FG0MW00 empty; /* Working storage*/
    set FG0MW01 empty; /* M001 display storage*/
    set FG0MW02 empty; /* M001 temporary storage*/
    set FG0MW03 empty; /* M001 totals display storage*/
    set SQLCA empty; /* SQL communication area*/
    set TAEREC empty; /* Error diagnosis information*/
    set TA1REC empty; /* Error diagnosis parameters*/
    set TA2REC empty; /* date routine work area*/
    set TA5REC empty; /* temp storage queue area*/
    set TA6REC empty; /* jcl submit work area*/
    set XX0XW01 empty; /* Date/time subroutine parameters*/

    FG0MW00.XXXTSLEN = 2027; /* temp storage length*/

    FG0MW00.FG0MWSWR = "N"; /* Request for data switch*/
    FG0MW00.FG0MWSWF = "Y"; /* format screen data switch*/
    FG0MW00.FG0MW-NEXT = "N"; /* Next season flag*/
    move "N" to FG0MW00.FG0MW-PMON[1] for all; /* Print remaining month flag*/
    FG0MW00.FG0MWSWD = "1"; /* map switch*/
    FG0MW00.FG0MWSIX = 1; /* save index*/
    FG0MW00.FG0MWSNX = 1; /* season index*/
    FG0MW00.FG0MWPGX = 1; /* page index*/
    FG0MW00.XXXTSPAG = 1; /* page number*/

     /* ---------------------------------------------------*/
     /* Clear unused fields*/
     /* ---------------------------------------------------*/

    FFWREC.XPLCD = " "; /* Clear product line code*/
    FFWREC.XPLABRV = " "; /* Clear product line abrv*/
    FFWREC.SYBSTGNB = " "; /* Clear style group number*/
    FFWREC.SYBSTGNM = " "; /* Clear style group name*/
    FFWREC.SY1STNBR = " "; /* Clear style number*/
    FFWREC.SY2CLRID = " "; /* Clear color id*/
    FFWREC.XDMCD = " "; /* Clear dimension code*/
    FFWREC.SY1SSTNM = " "; /* Clear short style name*/
    FFWREC.SY2CLRAB = " "; /* Clear color abrv*/
    FFWREC.XDMABRV = " "; /* Clear dimension abrv*/

     /* ------------------------------------------------------------*/
     /* determine default data to be loaded*/
     /* ------------------------------------------------------------*/

    if (FFWREC.FFW-ND-SHP-IND == " ")
      FFWREC.FFW-ND-SHP-IND = "N";
    end

     /* ------------------------------------------------------------*/
     /* product type group*/
     /* ------------------------------------------------------------*/

    if (FFWREC.YPGCD == " ")
      FFWREC.YPGCD = "01";
      if (FFWREC.YPGCD in YPGTBL.YPGCD)
        FFWREC.YPGABRV = YPGTBL.YPGABRV[sysVar.arrayIndex];
      end
    end

     /* ------------------------------------------------------------*/
     /* determine if data is to be loaded*/
     /* ------------------------------------------------------------*/

    if (FFWREC.FFABEGMO != 0
     && FFWREC.FFAENDMO != 0
     && FFWREC.XPCCD != " "
     && FFWREC.FFWENDM1 != 0)
      FG0MW00.FG0MWSWR = "Y"; /* set data request flag*/
    end

     /* ------------------------------------------------------------*/
     /* Flow to first time through date validation*/
     /* ------------------------------------------------------------*/

    goto FG0M000; /* Converse the main process*/

    FG0M000: FG0M000();
     /* ------------------------------------------------------------*/
     /* Flow to converse the main process used to display a map.*/
     /* ------------------------------------------------------------*/

    goto FG0M001; /* Converse the main process*/

    FG0M001: FG0M001();
     /* ------------------------------------------------------------*/
     /* flow to converse the main process used to display a map*/
     /* ------------------------------------------------------------*/

    goto FG0M001; /* converse the main process*/

  end // end main
end // end FG0M

// get need mo sls from vsyshp01
Function FG0M-141()
   /* ------------------------------------------------------------*/
   /* Obtain historical need month based sales quantities.*/
   /* Load fh5rec record - dfhist.vsyshp01, note:  ffabegmo and*/
   /* ffaendmo loaded in fg0m100.*/
   /* ------------------------------------------------------------*/

  set FH5REC empty;

  FH5REC.XLCCD = "10"; /* life cycle code*/
  FH5REC.XQACD = "01"; /* quality code*/
  FH5REC.YSMXOT = "*"; /* sum code*/
  FH5REC.FH1PNAC = "*"; /* national account flag*/
  FH5REC.XPRCD = FFWREC.YPGCD; /* product code*/

   /* sty grp nbr is passed to subroutine through style number*/
  FH5REC.SY1STNBR = PG7REC.SYBSTGNB;

   /* catg cd is passed to subroutine through division code*/
  FH5REC.XDVCD = FFWREC.XPCCD;

  TA1PGMNM = "FG0M141"; /* calling process*/

   /* --------------------------------------------------*/
   /* select on dfhist.vsyshp01 table*/
   /* --------------------------------------------------*/

  FFFREC.FFFFUNCD = "SN";

  XSFFS54();


end // end FG0M-141

// get open qty from voqsty01
Function FG0M-143()
   /* ------------------------------------------------------------*/
   /* Obtain carryover quantities from dfhist.voqcat01*/
   /* Beginning and ending dates are set in fg0m100.*/
   /* ------------------------------------------------------------*/

   /* use sty nbr to pass the sty grp nbr to the subroutine*/
  FH1REC.SY1STNBR = PG7REC.SYBSTGNB; /* style number*/

   /* use div cd to pass the catg cd to the subroutine*/
  FH1REC.XDVCD = FFWREC.XPCCD; /* category code*/

   /* use dim cd to pass the type group cd to the subroutine*/
  FH1REC.XDMCD = FFWREC.YPGCD; /* product type group code*/

  FH1REC.XLCCD = "10"; /* life cycle code*/
  FH1REC.XQACD = "01"; /* quality code*/
  FH1REC.FH1PNAC = "*"; /* product national acct fl*/

  TA1REC.TA1PGMNM = "FG0M143"; /* calling process*/

  FFFREC.FFFFUNCD = "SG"; /* Summarize by style group*/

  XSFFS-FF5570();


end // end FG0M-143

// 's1' on dfcast.vffsty01
Function FG0M-161()
   /* ------------------------------------------------------------*/
   /* Format keys.*/
   /* ------------------------------------------------------------*/

  FF3REC.YPGCD = FFWREC.YPGCD; /* type group code*/
  FF3REC.XLCCD = "10"; /* life cycle code*/
  FF3REC.YSMXDV = "10"; /* Dom*/

   /* ------------------------------------------------------------*/
   /* Open DFCAST.VFFSTY01.*/
   /* ------------------------------------------------------------*/

  try
    call "IO3990" ("S1", SQLCA, FF3REC) {isNoRefresh = yes, isExternal = yes};
  end /* Select set*/

   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* Normal return code*/

    return;

  end
   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL Commarea*/

  FFWREC.XXXMODID = "161"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(47); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(1); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    converseLib.clearScreen();
     /* Clear screen before display*/

  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "SELECT S1 ON DFCAST.VFFSTY01";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FFWREC.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFCAST  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VFFSTY01"; /* Table view name*/
  TA1REC.TA1TBLKE = FF3REC.FF3KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/
end // end FG0M-161

// 'n1' on dfcast.vffsty01
Function FG0M-162()
   /* ------------------------------------------------------------*/
   /* Fetch dfcast.vFFSTY01 record.*/
   /* ------------------------------------------------------------*/

  try
    call "IO3990" ("N1", SQLCA, FF3REC) {isNoRefresh = yes, isExternal = yes};
  end /* Select set*/

   /* ------------------------------------------------------------*/
   /* If successful or not found, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/
    if (SQLCA.VAGen_SQLCODE == 0 /* Normal return code*/
     || SQLCA.VAGen_SQLCODE == 100) /* not found*/
      return;
    end
  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL Commarea*/

  FFWREC.XXXMODID = "162"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(47); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(1); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    converseLib.clearScreen();
     /* Clear screen before display*/

  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "FETCH N1 DFCAST.VFFSTY01 ROW  ";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FFWREC.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFCAST  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VFFSTY01"; /* Table view name*/
  TA1REC.TA1TBLKE = FF3REC.FF3KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/

end // end FG0M-162

// 'c1' on dfcast.vffsty01
Function FG0M-163()
   /* ------------------------------------------------------------*/
   /* Close dfcast.vFFSTY01 cursor.*/
   /* ------------------------------------------------------------*/

  try
    call "IO3990" ("C1", SQLCA, FF3REC) {isNoRefresh = yes, isExternal = yes};
  end /* Select set*/

   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* Normal return code*/

    return;
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL Commarea*/
  converseLib.validationFailed(1); /* error message*/
  FFWREC.XXXMODID = "163"; /* Module identification*/

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "CLOSE S1 DFCAST.VFFSTY01";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FFWREC.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFCAST  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VFFSTY01"; /* Table view name*/
  TA1REC.TA1TBLKE = FF3REC.FF3KEY; /* table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/

end // end FG0M-163

// fetch vmsgrp01 sls fcst
Function FG0M-171()
   /* ------------------------------------------------------------*/
   /* Select sum on dfcast.vmsgrp01 table.*/
   /* ------------------------------------------------------------*/

  FFFREC.FFFFUNCD = "SS"; /* function code*/

   /* ------------------------------------------------------------*/
   /* load ff8rec record - dfcast.vmsgrp001*/
   /* ------------------------------------------------------------*/

  set FF8REC empty; /* Clear row storage area*/

  FF8REC.YSMXDV = "10";
  FF8REC.XCTCD = "*";
  FF8REC.YPGCD = FFWREC.YPGCD; /* type group code*/
  FF8REC.SYBSTGNB = PG7REC.SYBSTGNB; /* style grp nbr*/

   /* ------------------------------------------------------------*/
   /* select sum dfcast.vmsgrp001*/
   /* ------------------------------------------------------------*/

  try
    call "IO3730" (FFFREC, SQLCA, FF8REC) {isNoRefresh = yes, isExternal = yes};
  end /* Select set*/

   /* ------------------------------------------------------------*/
   /* If successful or zero total, return to the previous process*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/
    if (SQLCA.VAGen_SQLCODE == 0 /* Normal return code*/
     || SQLCA.VAGen_SQLCODE == -305) /* zero total returned*/

      return;

    end
  end
   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indisgrpe that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL Commarea*/

  FFWREC.XXXMODID = "171"; /* Module identifisgrpion*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(47); /* Indisgrpe not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(1); /* Indisgrpe system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    converseLib.clearScreen();
     /* Clear screen before display*/

  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "SELECT SUM TABLE DFCAST.VMSGRP01";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FFWREC.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFCAST  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VMSGRP01"; /* Table view name*/
  TA1REC.TA1TBLKE = FF8REC.FF8KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end FG0M-171

// add page to temp storage
Function FG0M-1851()
   /* ------------------------------------------------------------*/
   /* Add the next page to temporary storage.*/
   /* ------------------------------------------------------------*/
   /*  */
  FG0MW02.XXXTSLEN = FG0MW00.XXXTSLEN;
  TA5REC.TA5APPID = COMMAREA.CACURRAP; /* Application identification*/
  TA5REC.TA5FNCCD = "A"; /* Function code*/

  try
    call "TA0050" (FG0MW02, TA5REC) {isNoRefresh = yes, isExternal = yes};
  end /* Temporary storage*/

   /* ------------------------------------------------------------*/
   /* If successful, initialize the storage area and indicators*/
   /* to be used.  Return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && TA5REC.TA5RTNCD == 0)          /* and normal return code*/

    set FG0MW02 empty; /* M001 display storage*/

    FG0MW00.FG0MWIDX = 1; /* Display line index*/

    FG0MW00.TA5TSQIX = TA5REC.TA5TSQIX; /* Highest page number*/
    TA5REC.TA5TSQIX = 0; /* Current page number*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TAEREC.TAEDESC1 = sysVar.errorCode; /* CSP return code*/
  TAEREC.TAEDESC2 = TA5REC.TA5DATA; /* Subroutine parameters*/

  FFWREC.XXXMODID = "185"; /* Module identification*/
  converseLib.validationFailed(10); /* Indicate system error*/

  TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  TA1REC.TA1TYPE = "APPL"; /* Type of error*/
  TA1REC.TA1LOC = "ADD PAGE TO TEMPORARY STORAGE";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FFWREC.XXXMODID; /* Program number*/
  TA1REC.TA1MAPAP = COMMAREA.CACURRAP; /* Map application*/
  TA1REC.TA1MAPNO = "M001"; /* Map number*/

  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end FG0M-1851

// one time validation process
Function FG0M000()

   /* ------------------------------------------------------------*/
   /* validate begin and end dates if request for data switch*/
   /* has been set to yes*/
   /* ------------------------------------------------------------*/

  if (FG0MW00.FG0MWSWR != "Y")

    return;

  end

   /* ------------------------------------------------------------*/
   /* verify begin and end dates passed using xsffs30*/
   /* ------------------------------------------------------------*/

  set FFZREC empty;
  FFZREC.FFZMONTH = 1;
  FFZREC.FFZSRANG = "Y";
  FFZREC.FFZBEGMO = FFWREC.FFABEGMO;
  FFZREC.FFZENDMO = FFWREC.FFAENDMO;

  XSFFS30();

  if (FFZREC.FFZENDRC == "1")
    set FG0MM001.FG0MMERG cursor, bold; /* Highlight*/
    converseLib.validationFailed(8); /* Indicate missing or invalid*/
    FFWREC.XXXMODID = "000";
  else
    if (FFZREC.FFZENDRC == "2")
      set FG0MM001.FG0MMERG cursor, bold; /* Highlight*/
      converseLib.validationFailed(17); /* Indicate missing or invalid*/
      FFWREC.XXXMODID = "000";
    else
      if (FFZREC.FFZENDRC == "3")
        set FG0MM001.FG0MMERG cursor, bold; /* Highlight*/
        converseLib.validationFailed(151); /* out of range*/
        FFWREC.XXXMODID = "000";
      end
    end
  end

  if (FFZREC.FFZBEGRC == "1")
    set FG0MM001.FG0MMBRG cursor, bold; /* Highlight*/
    converseLib.validationFailed(8); /* Indicate missing or invalid*/
    FFWREC.XXXMODID = "000";
  else
    if (FFZREC.FFZBEGRC == "2")
      set FG0MM001.FG0MMBRG cursor, bold; /* Highlight*/
      converseLib.validationFailed(17); /* Indicate missing or invalid*/
      FFWREC.XXXMODID = "000";
    else
      if (FFZREC.FFZBEGRC == "3")
        set FG0MM001.FG0MMBRG cursor, bold; /* Highlight*/
        converseLib.validationFailed(151); /* out of range*/
        FFWREC.XXXMODID = "000";
      end
    end
  end

   /* ------------------------------------------------------------*/
   /* if date range is in error load default field values*/
   /* ------------------------------------------------------------*/

  if (converseVar.validationMsgNum != 0)
    FG0MM001.YPGCD = FFWREC.YPGCD;
    FG0MM001.YPGABRV = FFWREC.YPGABRV;
    FG0MM001.XPCCD = FFWREC.XPCCD;
    FG0MM001.XPCABRV = FFWREC.XPCABRV;
    FG0MM001.FFW-ND-SHP-IND = FFWREC.FFW-ND-SHP-IND;
    FG0MW00.FG0MWPIX = 1;
    while (FG0MW00.FG0MWPIX <= 4)
      FG0MM001.FG0MMSEM[FG0MWPIX] = FG0MW00.FG0MWSEM[FG0MWPIX];
      FG0MW00.FG0MWPIX = FG0MW00.FG0MWPIX + 1;
    end
  end


end // end FG0M000

// L.R. forecast style grp inq
Function FG0M001()
   /* ------------------------------------------------------------*/
   /* This is the main process used to display a map.  Processing*/
   /* always returns to the top of this process and falls through*/
   /* subordinate processes until an error is found or a valid*/
   /* request is processed.  Processing sequence is as follows:*/

   /* 1) Obtain the data to display.*/
   /* 2) Format the map output area and display the map.*/
   /* 3) Check the attention identifier used to respond.*/
   /* 4) Reset highlighted fields to normal intensity.*/
   /* 5) Verify the data that was entered.*/
   /* 6) Process a valid input request.*/

   /* In all subordinate processes, "EZEFLO" is used to exit to*/
   /* redisplay the map when an error is found.  This is done to*/
   /* minimize the coding effort required to skip subsequent*/
   /* processing under error conditions.*/
   /* ------------------------------------------------------------*/

  FG0M100(); /* Obtain the data to display*/

  FG0M200(); /* Format and display the map*/

  FG0M300(); /* Check attention identifier*/

  FG0M400(); /* Reset fields to normal intensity*/

  FG0M500(); /* Verify the entered data*/

  FG0M600(); /* Process valid input request*/


end // end FG0M001

// obtain data for display
Function FG0M100()
   /* ------------------------------------------------------------*/
   /* If data was not requested or an error was found, return to*/
   /* the previous process.*/
   /* ------------------------------------------------------------*/

  if (FG0MW00.FG0MWSWR != "Y" /* Data was not requested*/
   || converseVar.validationMsgNum != 0) /* or an error was found*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* Calculate the no of season and no of months in eqch season.*/
   /* ------------------------------------------------------------*/

  FG0MS33();

   /* ------------------------------------------------------------*/
   /* Purge any existing pages from the temporary storage queue.*/
   /* ------------------------------------------------------------*/

  FG0MS01(); /* Purge any temporary storage*/

   /* ------------------------------------------------------------*/
   /* Obtain current date using routine xx0xs01.*/
   /* Obtain invoice date from dfcast.vffctl01.*/
   /* Calculate program dates.*/
   /* ------------------------------------------------------------*/

  FG0M110();

   /* ------------------------------------------------------------*/
   /* Select carryover percentages from dfcast.vffxrf01 if requested*/
   /* date range within current minus one month or current minus*/
   /* two months.*/
   /* ------------------------------------------------------------*/

  if (FG0MW00.FG0MW-CURR-MO-MINUS1 >= FFWREC.FFABEGMO
   && FG0MW00.FG0MW-CURR-MO-MINUS1 <= FFWREC.FFAENDMO)
    FG0M115();
  else
    if (FG0MW00.FG0MW-CURR-MO-MINUS2 >= FFWREC.FFABEGMO
     && FG0MW00.FG0MW-CURR-MO-MINUS2 <= FFWREC.FFAENDMO)
      FG0M115();
    end
  end
   /* ------------------------------------------------------------*/
   /* Select all style groups for requested type group and catg.*/
   /* ------------------------------------------------------------*/

  FG0MW00.FG0MWIDX = 1; /* init index*/
  FG0MW00.FG0MWTIX = FFZREC.FFZNUMMO + 1; /* load total index*/

  FG0M120(); /* select 's1' on dprodg.vmxprc01*/
  FG0M130(); /* fetch 'n1' dfcast.vmxprc01 row*/

  while (SQLCA.VAGen_SQLCODE == 0) /* process unitl end of mxprc*/

    FG0MW02.SYBSTGNB[FG0MWIDX] = PG7REC.SYBSTGNB;
    FG0MW02.SYBSTGNM[FG0MWIDX] = PG7REC.SYBSTGNM;

      /* ------------------------------------------------------------*/
      /* Obtain sales quanitites for all months within the requested*/
      /* date range*/
      /* ------------------------------------------------------------*/

    FG0MW00.FG0MWUTQ = 0; /* init w/s product line total*/
    FG0MW00.FG0MWPIX = 1; /* init process index*/

    while (FG0MW00.FG0MWPIX <= FFZREC.FFZNUMMO)

      FFFREC.FFFBEGMO = FFZREC.FFZINDMO[FG0MWPIX];
      FFFREC.FFFENDMO = FFZREC.FFZINDMO[FG0MWPIX];

      FG0MW00.FG0MWUHS = 0;

      /* ------------------------------------------------------------*/
      /* If the month within the requested range is an actual month*/
      /* process for either need or business month based sales*/
      /* accumulate and save monthly quantities*/
      /* Otherwise, the month is forecasted*/
      /* check dfcast.vffsty01 to see if style group is active*/
      /* if it is, fetch sales forecast*/
      /* accumulate and save monthly quantities*/
      /* ------------------------------------------------------------*/
      if (FFZREC.FFZINDMO[FG0MWPIX] < FG0MW00.FG0MW-CURR-MO)

        if (FFWREC.FFW-ND-SHP-IND == "N") /* need month sales requested*/
          FG0M140();
        else
          FG0M150();
        end

        FG0M180();
      else

        FG0M160(); /* dfcast.vffsty01 call*/

        if (FG0MW00.FG0MWGRP == "Y") /* sty grp is active*/
          FG0M170(); /* get sls fcst*/
          FG0M180(); /* save sty grp*/
        end
      end
      FG0MW00.FG0MWPIX = FG0MW00.FG0MWPIX + 1;

    end

      /* ------------------------------------------------------------*/
      /* If the total qty = 0*/
      /* If it is an all forecast range*/
      /* and if the first sales month < or = the ending month in the*/
      /* requested range*/
      /* save this style group in temp storage*/
      /* Else*/
      /* total quantity is not equal to zero, save this style*/
      /* group in temp storage*/
      /* ------------------------------------------------------------*/
    if (FG0MW00.FG0MWUTQ == 0)
      if (FFWREC.FFABEGMO >= FG0MW00.FG0MW-CURR-MO) /* all fcst rng*/
        if (FG0MW00.FG0MWGRP == "Y" /* sty grp is active*/
         && PG7REC.PG7MINSM <= FFWREC.FFAENDMO) /* 1st sls mo*/
          FG0M185(); /* save sty grp info in ts*/
        end
      end
    else
      FG0M185(); /* save sty grp info in ts*/
    end

    FG0M130(); /* fetch 'n1' dfcast.vmxprc01 row*/

  end

  FG0M190(); /* close 'c1' dprodg.vmxprc01 set*/

   /* ------------------------------------------------------------*/
   /* Add any partially formatted last page to the queue.*/
   /* ------------------------------------------------------------*/

  if (FG0MW00.FG0MWIDX > 1) /* Page was formatted*/
    FG0MW02.FG0MWNLD = FG0MW00.FG0MWIDX - 1;
    FG0M-1851(); /* Add page to temp storage*/
  end

   /* ------------------------------------------------------------*/
   /* If no pages were formatted, indicate no data to display.*/
   /* ------------------------------------------------------------*/

  if (FG0MW00.TA5TSQIX == 0) /* No pages formatted*/

    FFWREC.XXXMODID = "100"; /* Module identification*/
    FFWREC.XXXMSGNO = 18; /* Indicate no data to display*/

    return; /* Exit to continue processing*/

  end

   /* ------------------------------------------------------------*/
   /* Calculate monthly percents (column percents)*/
   /* ------------------------------------------------------------*/

  if (FG0MW03.FG0MWUMT[FG0MWTIX] != 0)

    FG0MW00.FG0MWNM1 = FG0MW03.FG0MWUMT[FG0MWTIX];
    FG0MW00.FG0MWIDX = 1;
    while (FG0MW00.FG0MWIDX <= FFZREC.FFZNUMMO) /* nbr months loaded*/

      FG0MW00.FG0MWNM2 = FG0MW03.FG0MWUMT[FG0MWIDX] * 100;
      FG0MW03.FG0MWMPT[FG0MWIDX] = mathLib.round(FG0MW00.FG0MWNM2 / FG0MW00.FG0MWNM1, -mathLib.decimals(FG0MW03.FG0MWMPT[FG0MWIDX]));

      FG0MW00.FG0MWIDX = FG0MW00.FG0MWIDX + 1;

    end
  end

   /* ------------------------------------------------------------*/
   /* Indicate that the request for data is complete.*/
   /* ------------------------------------------------------------*/

  FG0MW00.XXXTSPAG = 1; /* Desired page number*/
  FG0MW00.FG0MWPGX = 1; /* Page index*/
  FG0MW00.FG0MW-PAGP[1] = 1; /* Starting point of the page*/
  FG0MW00.FG0MW-PAGS[1] = 1; /* Season of the page*/
  FG0MW00.FG0MWSWR = "N"; /* Request for data switch*/
  FG0MW01.CACHGFL = "Y"; /* data is available for change*/

end // end FG0M100

// Calc program dates
Function FG0M110()
   /* ------------------------------------------------------------*/
   /* Obtain current date using routine xx0xs01.*/
   /* Obtain invoice cutoff date from dfcast.vffctl01.*/
   /* Calculate:*/
   /* - current month*/
   /* - current month minus 1 month*/
   /* - current month minus 2 months*/
   /* - current month minus 3 months*/
   /* - current month minus 4 months*/
   /* ------------------------------------------------------------*/

   /* ------------------------*/
   /* Get current date*/
   /* ------------------------*/

  XX0XS01();

   /* ------------------------------------------------------------*/
   /* Obtain invoice date from dfcast.vffctl01.*/
   /* ------------------------------------------------------------*/

  FG0M111();

   /* ------------------------------------------------------------*/
   /* Calculate current month.*/
   /* ------------------------------------------------------------*/

  FG0MW00.FG0MWCWD = FF1REC.FF1IVCDT; /* work date*/

  if (XX0XW01.XX0XWDAT < FF1REC.FF1IVCDT)
    if (FG0MW00.FG0MWCMM == 1)
      FG0MW00.FG0MWCMM = 12;
      if (FG0MW00.FG0MWCYY == 00)
        FG0MW00.FG0MWCYY = 99;
        FG0MW00.FG0MWCCC = FG0MW00.FG0MWCCC - 1;
      else
        FG0MW00.FG0MWCYY = FG0MW00.FG0MWCYY - 1;
      end
    else
      FG0MW00.FG0MWCMM = FG0MW00.FG0MWCMM - 1;
    end
  end

  FG0MW00.FG0MW-CURR-MO = FG0MW00.FG0MWCYM; /* curr date ccyymm*/

   /* ------------------------------------------------------------*/
   /* Calculate current month minus 1 month*/
   /* ------------------------------------------------------------*/

  FG0MW00.FG0MWWDT = FG0MW00.FG0MW-CURR-MO;

  if (FG0MW00.FG0MWWMM == 1)
    FG0MW00.FG0MWWMM = 12;
    if (FG0MW00.FG0MWWYY == 00)
      FG0MW00.FG0MWWYY = 99;
      FG0MW00.FG0MWWCC = FG0MW00.FG0MWWCC - 1;
    else
      FG0MW00.FG0MWWYY = FG0MW00.FG0MWWYY - 1;
    end
  else
    FG0MW00.FG0MWWMM = FG0MW00.FG0MWWMM - 1;
  end

  FG0MW00.FG0MW-CURR-MO-MINUS1 = FG0MW00.FG0MWWDT;


  if (FFWREC.FFW-ND-SHP-IND == "N")
    /* ------------------------------------------------------------*/
    /* Calculate current month minus 2 months*/
    /* ------------------------------------------------------------*/

    FG0MW00.FG0MWWDT = FG0MW00.FG0MW-CURR-MO-MINUS1;

    if (FG0MW00.FG0MWWMM == 1)
      FG0MW00.FG0MWWMM = 12;
      if (FG0MW00.FG0MWWYY == 00)
        FG0MW00.FG0MWWYY = 99;
        FG0MW00.FG0MWWCC = FG0MW00.FG0MWWCC - 1;
      else
        FG0MW00.FG0MWWYY = FG0MW00.FG0MWWYY - 1;
      end
    else
      FG0MW00.FG0MWWMM = FG0MW00.FG0MWWMM - 1;
    end

    FG0MW00.FG0MW-CURR-MO-MINUS2 = FG0MW00.FG0MWWDT;

    /* ------------------------------------------------------------*/
    /* Calculate current month minus 3 months*/
    /* ------------------------------------------------------------*/

    FG0MW00.FG0MWWDT = FG0MW00.FG0MW-CURR-MO-MINUS2;

    if (FG0MW00.FG0MWWMM == 1)
      FG0MW00.FG0MWWMM = 12;
      if (FG0MW00.FG0MWWYY == 00)
        FG0MW00.FG0MWWYY = 99;
        FG0MW00.FG0MWWCC = FG0MW00.FG0MWWCC - 1;
      else
        FG0MW00.FG0MWWYY = FG0MW00.FG0MWWYY - 1;
      end
    else
      FG0MW00.FG0MWWMM = FG0MW00.FG0MWWMM - 1;
    end

    FG0MW00.FG0MW-CURR-MO-MINUS3 = FG0MW00.FG0MWWDT;

    /* ------------------------------------------------------------*/
    /* Calculate current month minus 4 months*/
    /* ------------------------------------------------------------*/

    FG0MW00.FG0MWWDT = FG0MW00.FG0MW-CURR-MO-MINUS3;

    if (FG0MW00.FG0MWWMM == 1)
      FG0MW00.FG0MWWMM = 12;
      if (FG0MW00.FG0MWWYY == 00)
        FG0MW00.FG0MWWYY = 99;
        FG0MW00.FG0MWWCC = FG0MW00.FG0MWWCC - 1;
      else
        FG0MW00.FG0MWWYY = FG0MW00.FG0MWWYY - 1;
      end
    else
      FG0MW00.FG0MWWMM = FG0MW00.FG0MWWMM - 1;
    end

    FG0MW00.FG0MW-CURR-MO-MINUS4 = FG0MW00.FG0MWWDT;

  end


end // end FG0M110

// get ivc cutoff dt frm vffctl01
Function FG0M111()
   /* ------------------------------------------------------------*/
   /* Obtain invoice cutoff date from dfcast.vffctl01.*/
   /* ------------------------------------------------------------*/

  set FF1REC empty; /* Clear row storage area*/

  FF1REC.ZZZCHGDT = XX0XW01.XX0XWDAT;
  FF1REC.ZZZCHGTM = XX0XW01.XX0XWTIM;

  try
    call "IO3660" ("S ", SQLCA, FF1REC) {isNoRefresh = yes, isExternal = yes};
  end /* Select set*/

   /* ------------------------------------------------------------*/
   /* If successful return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Normal return code*/

      return;

    end
  end

   /* ------------------------------------------------------------*/
   /* indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL Commarea*/

  FFWREC.XXXMODID = "111"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(47); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(1); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    converseLib.clearScreen();
     /* Clear screen before display*/

  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "SELECT DFCAST.VFFCTL01 ROW";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FFWREC.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFCAST  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VFFCTL01"; /* Table view name*/
  TA1REC.TA1TBLKE = FF1REC.FF1GROUP; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/

end // end FG0M111

// fetch dfcast.vffxrf01 record
Function FG0M115()
   /* ------------------------------------------------------------*/
   /* Select unique on dfcast.vffxrf01 table.*/
   /* Load ff2rec record - dfcast.vffxrf01*/
   /* ------------------------------------------------------------*/

  set FF2REC empty; /* Clear row storage area*/

  FF2REC.YSMXDV = "10"; /* div grp code*/
  FF2REC.XPCCD = FFWREC.XPCCD; /* product catg cd*/
  FF2REC.YPGCD = FFWREC.YPGCD; /* product type group*/

  try
    call "IO4000" ("S ", SQLCA, FF2REC) {isNoRefresh = yes, isExternal = yes};
  end /* Select set*/

   /* ------------------------------------------------------------*/
   /* If successful return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* Normal return code*/

    return;

  end
   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL Commarea*/

  FFWREC.XXXMODID = "115"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(47); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(1); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    converseLib.clearScreen();
     /* Clear screen before display*/

  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "SELECT S  ON DFCAST.VFFXRF01";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FFWREC.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFCAST  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VFFXRF01"; /* Table view name*/
  TA1REC.TA1TBLKE = FF2REC.FF2KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/

end // end FG0M115

// Open  DPRODG.VMXPRC01
Function FG0M120()
   /* ------------------------------------------------------------*/
   /* Clear copybook.*/
   /* ------------------------------------------------------------*/

  set PG7REC empty; /* Clear copybook.*/

   /* ------------------------------------------------------------*/
   /* Format FFFREC.*/
   /* ------------------------------------------------------------*/

  FFFREC.FFFBEGMO = 000000000; /* Beg month*/
  FFFREC.FFFENDMO = 999999999; /* End month*/

   /* ------------------------------------------------------------*/
   /* Format DPRODG.VMXPRC01.*/
   /* ------------------------------------------------------------*/

  FFFREC.FFFFUNCD = "S1"; /* Function code*/

  PG7REC.XPCCD = FFWREC.XPCCD; /* product line*/
  PG7REC.YPGCD = FFWREC.YPGCD; /* product type group*/
  PG7REC.YSMXDV = "10"; /* Domestic*/
  PG7REC.PG7MAXPR = 99999.99; /* max price*/

   /* ------------------------------------------------------------*/
   /* select set dprodg.vmxprc01*/
   /* ------------------------------------------------------------*/

  try
    call "IO5100" (FFFREC, SQLCA, PG7REC) {isNoRefresh = yes, isExternal = yes};
  end /* Select set*/

   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* Normal return code*/

    return;

  end
   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL Commarea*/

  FFWREC.XXXMODID = "120"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(47); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(1); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    converseLib.clearScreen();
     /* Clear screen before display*/

  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "SELECT S1 ON DPRODG.VMXPRC01";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FFWREC.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DPRODG  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VMXPRC01"; /* Table view name*/
  TA1REC.TA1TBLKE = PG7REC.PG7KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end FG0M120

// Fetch DPRODG.VMXPRC01
Function FG0M130()
   /* ------------------------------------------------------------*/
   /* Fetch dprodg.vmxprc01 row.*/
   /* ------------------------------------------------------------*/

  try
    call "IO5100" ("N1", SQLCA, PG7REC) {isNoRefresh = yes, isExternal = yes};
  end /* Select set*/

   /* ------------------------------------------------------------*/
   /* If successful or not found, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/
    if (SQLCA.VAGen_SQLCODE == 0 /* Normal return code*/
     || SQLCA.VAGen_SQLCODE == 100) /* not found*/
      return;
    end
  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL Commarea*/

  FFWREC.XXXMODID = "130"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(47); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(1); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    converseLib.clearScreen();
     /* Clear screen before display*/

  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "FETCH N1 DPRODG.VMXPRC01 ROW  ";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FFWREC.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DPRODG  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VMXPRC01"; /* Table view name*/
  TA1REC.TA1TBLKE = PG7REC.PG7KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/

end // end FG0M130

// Process actual need mo sales
Function FG0M140()
   /* ------------------------------------------------------------*/
   /* Obtain historical need month based sales quantities.*/
   /* Load FH5REC record - dfhist.vsyshp01, note:  ffabegmo and*/
   /* ffaendmo loaded in fg0m100.*/
   /* ------------------------------------------------------------*/

  FG0M-141();

  FG0MW00.FG0MWUHS = FG0MW00.FG0MWUHS + FH5REC.FH5MSHQT;

   /* --------------------------------------------------------*/
   /* check for carryover*/
   /* --------------------------------------------------------*/

  if (FFZREC.FFZINDMO[FG0MWPIX] <= FG0MW00.FG0MW-CURR-MO-MINUS1
   && FFZREC.FFZINDMO[FG0MWPIX] >= FG0MW00.FG0MW-CURR-MO-MINUS4)


    if (FFZREC.FFZINDMO[FG0MWPIX] == FG0MW00.FG0MW-CURR-MO-MINUS3
     || FFZREC.FFZINDMO[FG0MWPIX] == FG0MW00.FG0MW-CURR-MO-MINUS4)
      set FH1REC empty;
      FH1REC.YSMXOT = "*";
      FG0M-143(); /* get open qtys from voqsty01*/
      FH1REC.FH1PAQTY = FH1REC.FH1ALQTY + FH1REC.FH1PAQTY;
      FH1REC.FH1PAQTY = mathLib.round(FH1REC.FH1PAQTY * .5, -mathLib.decimals(FH1REC.FH1PAQTY));
      FG0MW00.FG0MWUHS = FG0MW00.FG0MWUHS + FH1REC.FH1PAQTY;
    end


    if (FFZREC.FFZINDMO[FG0MWPIX] == FG0MW00.FG0MW-CURR-MO-MINUS2)
      set FH1REC empty;
      FH1REC.YSMXOT = "FT";
      FG0M-143(); /* get open qtys from voqsty01*/
      FH1REC.FH1PAQTY = mathLib.round((FH1REC.FH1PAQTY + FH1REC.FH1ALQTY)       * FF2REC.FFQOCOFP / 100, -mathLib.decimals(FH1REC.FH1PAQTY));
      FG0MW00.FG0MWUHS = FG0MW00.FG0MWUHS + FH1REC.FH1PAQTY;

      set FH1REC empty;
      FH1REC.YSMXOT = "PR";
      FG0M-143(); /* get open qtys from voqsty01*/
      FH1REC.FH1PAQTY = mathLib.round((FH1REC.FH1PAQTY + FH1REC.FH1ALQTY)       * FF2REC.FFQOCOPP / 100, -mathLib.decimals(FH1REC.FH1PAQTY));
      FG0MW00.FG0MWUHS = FG0MW00.FG0MWUHS + FH1REC.FH1PAQTY;

    end


    if (FFZREC.FFZINDMO[FG0MWPIX] == FG0MW00.FG0MW-CURR-MO-MINUS1)
      set FH1REC empty;
      FH1REC.YSMXOT = "FT";
      FG0M-143(); /* get open qtys from voqsty01*/
      FH1REC.FH1PAQTY = mathLib.round((FH1REC.FH1PAQTY + FH1REC.FH1ALQTY)       * FF2REC.FFQLCOFP / 100, -mathLib.decimals(FH1REC.FH1PAQTY));
      FG0MW00.FG0MWUHS = FG0MW00.FG0MWUHS + FH1REC.FH1PAQTY;

      set FH1REC empty;
      FH1REC.YSMXOT = "PR";
      FG0M-143(); /* get open qtys from voqsty01*/
      FH1REC.FH1PAQTY = mathLib.round((FH1REC.FH1PAQTY + FH1REC.FH1ALQTY)       * FF2REC.FFQLCOPP / 100, -mathLib.decimals(FH1REC.FH1PAQTY));
      FG0MW00.FG0MWUHS = FG0MW00.FG0MWUHS + FH1REC.FH1PAQTY;

    end
  end


end // end FG0M140

// get bus mo sls from vsyshp01
Function FG0M150()
   /* ------------------------------------------------------------*/
   /* Obtain actual business month sales from dfhist.vsyshp01.*/
   /* Load fh5rec record - dfhist.vsyshp01, note:  ffabegmo and*/
   /* ffaendmo loaded in fg0m100.*/
   /* ------------------------------------------------------------*/

  set FH5REC empty;

  FH5REC.XLCCD = "10"; /* life cycle code*/
  FH5REC.XQACD = "01"; /* quality code*/
  FH5REC.YSMXOT = "*"; /* sum code*/
  FH5REC.FH1PNAC = "*"; /* national account flag*/
  FH5REC.XPRCD = FFWREC.YPGCD; /* product code*/

   /* sty grp nbr is passed to subroutine through style number*/
  FH5REC.SY1STNBR = PG7REC.SYBSTGNB;

   /* catg cd is passed to subroutine through division code*/
  FH5REC.XDVCD = FFWREC.XPCCD;

  TA1PGMNM = "FG0M150"; /* calling process*/

   /* --------------------------------------------------*/
   /* select on dfhist.vsyshp01 table*/
   /* --------------------------------------------------*/

  FFFREC.FFFFUNCD = "SG";

  XSFFS54();

  FG0MW00.FG0MWUHS = FG0MW00.FG0MWUHS + FH5REC.FH5MSHQT - FH5REC.FH5RTSQT;


end // end FG0M150

// deter if prod is active
Function FG0M160()
   /* -----------------------------------------------------*/
   /* If sty grp nbr from VMXPRC01 is not in vffsty01*/
   /* then this style group has been closed out.*/
   /* -----------------------------------------------------*/

  FG0MW00.FG0MWGRP = "N";

  set FF3REC empty;

  FF3REC.SYBSTGNB = PG7REC.SYBSTGNB;

  FG0M-161(); /* open ffsty*/

  FG0M-162(); /* fetch ffsty*/
  if (SQLCA.VAGen_SQLCODE == 0)
    FG0MW00.FG0MWGRP = "Y";
  end

  FG0M-163(); /* close ffsty*/

end // end FG0M160

// calc sls fcst qty
Function FG0M170()
   /* --------------------------------------------------------*/
   /* obtain domestic forecast sale quantities*/
   /* --------------------------------------------------------*/

  FG0M-171(); /* obtain msgrp sales qty*/

  FG0MW00.FG0MWUHS = FF8REC.FF6SLFCT;

    /* --------------------------------------------------------*/
    /* If need month sales requested and processing current mo*/
    /* Back out carryover.*/
    /* --------------------------------------------------------*/
  if (FFWREC.FFW-ND-SHP-IND == "N"
   && FG0MW00.FG0MW-CURR-MO == FFFREC.FFFBEGMO)

    FFFREC.FFFBEGMO = FG0MW00.FG0MW-CURR-MO-MINUS1;
    FFFREC.FFFENDMO = FG0MW00.FG0MW-CURR-MO-MINUS1;
    FG0M-171(); /* obtain msgrp sales qty*/
    FG0MW00.FG0MWUHS = FG0MW00.FG0MWUHS - FF8REC.FF6SLFCT;
    FFFREC.FFFBEGMO = FFZREC.FFZINDMO[FG0MWPIX];
    FFFREC.FFFENDMO = FFZREC.FFZINDMO[FG0MWPIX];
  end


end // end FG0M170

// Accum & Load monthly info
Function FG0M180()
   /* ------------------------------------------------------------*/
   /* Load style group detail sales quantities.*/
   /* Accumulate and load style group sales quantity totals.*/
   /* ------------------------------------------------------------*/

   /* ---------------------------------------------------*/
   /* Load style group detail lines.*/
   /* ---------------------------------------------------*/

  FG0MW00.FG0MWUQT[FG0MWPIX] = FG0MW00.FG0MWUHS;
  FFXREC.FFXNUMB = FG0MW00.FG0MWUHS;
  XSFFS10();
  FG0MW00.FG0MWQTY[FG0MWPIX] = FFXREC.FFXCHAR;

   /* ---------------------------------------------------*/
   /* Accumulate style group sales quantity totals.*/
   /* ---------------------------------------------------*/

  FG0MW00.FG0MWUTQ = FG0MW00.FG0MWUHS + FG0MW00.FG0MWUTQ;

   /* ---------------------------------------------------------*/
   /* Accumulate monthly sales quantity totals (column totals)*/
   /* ---------------------------------------------------------*/

  FG0MW00.FG0MWNM1 = FG0MW03.FG0MWUMT[FG0MWPIX];
  FG0MW03.FG0MWUMT[FG0MWPIX] = FG0MW00.FG0MWUHS + FG0MW00.FG0MWNM1;
  FFXREC.FFXNUMB = FG0MW03.FG0MWUMT[FG0MWPIX];
  XSFFS10();
  FG0MW03.FG0MWMTQ[FG0MWPIX] = FFXREC.FFXCHAR;


end // end FG0M180

// save entry in temp stor
Function FG0M185()
   /* ------------------------------------------------------------*/
   /* Save style group total sales qty (last entry in t/s)*/
   /* ------------------------------------------------------------*/

  FG0MW00.FG0MWUQT[FG0MWTIX] = FG0MW00.FG0MWUTQ;
  FFXREC.FFXNUMB = FG0MW00.FG0MWUTQ;
  XSFFS10();
  FG0MW00.FG0MWQTY[FG0MWTIX] = FFXREC.FFXCHAR;

   /* ------------------------------------------------------------*/
   /* Load temp storage record with style group detail and total*/
   /* quantity.*/
   /* ------------------------------------------------------------*/

  FG0MW02.FG0MWQTS[FG0MWIDX] = FG0MW00.FG0MWLQT;

   /* ------------------------------------------------------------*/
   /* Accumulate monthly sales quantity total (last entry in w/s)*/
   /* ------------------------------------------------------------*/

  FG0MW00.FG0MWNM1 = FG0MW03.FG0MWUMT[FG0MWTIX];
  FG0MW03.FG0MWUMT[FG0MWTIX] = FG0MW00.FG0MWNM1 + FG0MW00.FG0MWUTQ;
  FFXREC.FFXNUMB = FG0MW03.FG0MWUMT[FG0MWTIX];
  XSFFS10();
  FG0MW03.FG0MWMTQ[FG0MWTIX] = FFXREC.FFXCHAR;

   /* ------------------------------------------------------------*/
   /* Check if page is full.*/
   /* ------------------------------------------------------------*/

  if (FG0MW00.FG0MWIDX > 12) /* Page is full*/
    FG0MW02.FG0MWNLD = FG0MW00.FG0MWIDX;
    FG0M-1851(); /* add page to temp storage*/
  else
    FG0MW00.FG0MWIDX = FG0MW00.FG0MWIDX + 1;
  end


end // end FG0M185

// close vmxprc01 cursor
Function FG0M190()
   /* ------------------------------------------------------------*/
   /* Close DPRODG.VMXPRC01 table.*/
   /* ------------------------------------------------------------*/
   /*  */
  try
    call "IO5100" ("C1", SQLCA, PG7REC) {isNoRefresh = yes, isExternal = yes};
  end /* Select set*/

   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* Normal return code*/

    return;
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL Commarea*/
  converseLib.validationFailed(1); /* error message*/
  FFWREC.XXXMODID = "190"; /* Module identification*/

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "CLOSE S1 DPRODG.VMXPRC01";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FFWREC.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DPRODG  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VMXPRC01"; /* Table view name*/
  TA1REC.TA1TBLKE = PG7REC.PG7KEY; /* table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end FG0M190

// Format and converse the map
Function FG0M200()
   /* ------------------------------------------------------------*/
   /* If no error was found, format the data to be displayed.*/
   /* ------------------------------------------------------------*/

  if (converseVar.validationMsgNum == 0) /* if no errors format map*/

    set FG0MM001 initial; /* m001 input/ouput area*/

    /* ------------------------------------------------------------*/
     /* Format fg0mm001 using passed data*/
    /* ------------------------------------------------------------*/

    FG0MW00.FG0MWWDT = FFWREC.FFABEGMO; /* w/s date field*/
    FG0MM001.FG0MMBRG = FG0MW00.FG0MWWYM; /* begin month range*/
    FG0MW00.FG0MWWDT = FFWREC.FFAENDMO; /* w/s date field*/
    FG0MM001.FG0MMERG = FG0MW00.FG0MWWYM; /* end month range*/

    FG0MM001.YPGCD = FFWREC.YPGCD; /* product type group*/
    FG0MM001.YPGABRV = FFWREC.YPGABRV; /* product type group abrv*/

    FG0MM001.XPCCD = FFWREC.XPCCD; /* product line code*/
    FG0MM001.XPCABRV = FFWREC.XPCABRV; /* product line abrv*/

    FG0MM001.FFW-ND-SHP-IND = FFWREC.FFW-ND-SHP-IND;

    FG0MM001.FG0MMSEM[1] = FFWREC.FFWENDM1; /* season end month*/
    FG0MM001.FG0MMSEM[2] = FFWREC.FFWENDM2; /* season end month*/
    FG0MM001.FG0MMSEM[3] = FFWREC.FFWENDM3; /* season end month*/
    FG0MM001.FG0MMSEM[4] = FFWREC.FFWENDM4; /* season end month*/

    /* ------------------------------------------------------------*/
     /* format screen*/
    /* ------------------------------------------------------------*/

    if (FG0MW00.FG0MWSWF == "Y") /* map must be formatted*/
      FG0M210(); /* Format the data on the map*/
    end

  else
    FFWREC.XXXMSGNO = converseVar.validationMsgNum; /* load message number*/

  end

   /* ------------------------------------------------------------*/
   /* Format page, date, and FAST PATH information.*/
   /* ------------------------------------------------------------*/

  if (FG0MW00.TA5TSQIX > 0)
    set FG0MM001.XXXLITPG skip;
    FG0MM001.XXXTSPAG = FG0MW00.XXXTSPAG; /* Current page*/
    set FG0MM001.XXXLITOF skip;
    FG0MM001.TA5TSQIX = FG0MW00.TA5TSQIX; /* max pages*/
  end

  FG0MM001.XXXCURDT = VGVar.currentShortGregorianDate; /* Current date*/

  FG0MM001.CATOAP = COMMAREA.CATOAP; /* TO application*/
  FG0MM001.CAITEM = COMMAREA.CAITEM; /* Application data*/

   /* ------------------------------------------------------------*/
   /* If a message to display, indicate sound audible alarm.*/
   /* ------------------------------------------------------------*/

  if (FFWREC.XXXMSGNO != 0) /* Message to display*/
    if (FFWREC.XXXMSGNO == 9999)
      converseLib.validationFailed();
    else
      converseLib.validationFailed(FFWREC.XXXMSGNO);
    end /* error message number*/
    FG0MM001.XXXMODID = FFWREC.XXXMODID; /* Module identification*/
    set FG0MM001 alarm; /* Indicate sound alarm*/
  end

  converse FG0MM001 ;

   /* ------------------------------------------------------------*/
   /* Clear the message fields and save FAST PATH information.*/
   /* ------------------------------------------------------------*/

  FFWREC.XXXMODID = " "; /* Module identification*/
  FFWREC.XXXMSGNO = 0;

  COMMAREA.CATOAP = FG0MM001.CATOAP; /* TO application*/
  COMMAREA.CAITEM = FG0MM001.CAITEM; /* Application data*/


end // end FG0M200

// Format the display data
Function FG0M210()

  FG0MW00.FG0MWSWF = "N"; /* init map switch*/

   /* ------------------------------------------------------------*/
   /* if data has not been loaded bypass load map fiecds*/
   /* ------------------------------------------------------------*/

  if (FG0MW01.CACHGFL != "Y")
    return;
  end

   /* ------------------------------------------------------------*/
   /* load monthly headings yymm*/
   /* ------------------------------------------------------------*/
  set FG0MM001.FG0MMSH1 skip;
  set FG0MM001.FG0MMSH2 skip;

  FG0MW00.FG0MWLIX = 1;
  FG0MW00.FG0MWIDX = FG0MW00.FG0MW-PAGP[FG0MWPGX];

  if (FG0MW00.FG0MW-PMON[FG0MWPGX] == "Y") /* print remaining month check*/
    FG0M211();
  else
    FG0M212();
    FG0M213();
  end

   /* ------------------------------------------------------------*/
   /* obtain style grp sale qtys from temporary storage*/
   /* ------------------------------------------------------------*/

  FG0MS04(); /* read temporary storage*/

  FG0MW00.FG0MWPIX = 1;
  while (FG0MW00.FG0MWPIX <= FG0MW02.FG0MWNLD) /* process temp storage*/

    FG0MM001.FG0MMSDS[FG0MWPIX] = FG0MW02.SYBSTGNM[FG0MWPIX];

    FG0MW00.FG0MWLQT = FG0MW02.FG0MWQTS[FG0MWPIX];

    /* ----------------------------------------------------------*/
     /* reformat style grp quantities using working storage*/
     /* and calculate style grp subtotal*/
    /* ----------------------------------------------------------*/

    FG0MW00.FG0MWLIX = 1; /* load index*/
    move 0 to FG0MW00.FG0MWUST[1] for all; /* product line subtotal*/
    FG0MW00.FG0MWIDX = FG0MW00.FG0MW-PAGP[FG0MWPGX];
    move " " to FG0MW00.FG0MWWQT[1] for all; /* clear w/s display table*/

    if (FG0MW00.FG0MW-PMON[FG0MWPGX] == "Y") /* print remaining month check*/
      FG0M214();
    else
      FG0M215();
      FG0M216();
    end

    /* ----------------------------------------------------------*/
     /* load style grp quantities to m001*/
    /* ----------------------------------------------------------*/

    FG0MM001.FG0MMQ01[FG0MWPIX] = FG0MW00.FG0MWWQT[1];
    FG0MM001.FG0MMQ02[FG0MWPIX] = FG0MW00.FG0MWWQT[2];
    FG0MM001.FG0MMQ03[FG0MWPIX] = FG0MW00.FG0MWWQT[3];
    FG0MM001.FG0MMQ04[FG0MWPIX] = FG0MW00.FG0MWWQT[4];
    FG0MM001.FG0MMQ05[FG0MWPIX] = FG0MW00.FG0MWWQT[5];
    FG0MM001.FG0MMQ06[FG0MWPIX] = FG0MW00.FG0MWWQT[6];
    FG0MM001.FG0MMQ07[FG0MWPIX] = FG0MW00.FG0MWWQT[7];
    FG0MM001.FG0MMQ08[FG0MWPIX] = FG0MW00.FG0MWWQT[8];
    FG0MM001.FG0MMQ09[FG0MWPIX] = FG0MW00.FG0MWWQT[9];
    FG0MM001.FG0MMQ10[FG0MWPIX] = FG0MW00.FG0MWWQT[10];

    FG0MW00.FG0MWPIX = FG0MW00.FG0MWPIX + 1;

  end

   /* ------------------------------------------------------------*/
   /* load style grp line monthly totals*/
   /* ------------------------------------------------------------*/

  FG0MM001.FG0MMSDS[FG0MWPIX] = "TOTAL QTY   ";

  FG0MW00.FG0MWUMT = 0;
  move " " to FG0MW00.FG0MWWQT[1] for all; /* clear w/s display table*/
  FG0MW00.FG0MWLIX = 1; /* load index*/
  FG0MW00.FG0MWIDX = FG0MW00.FG0MW-PAGP[FG0MWPGX];

  if (FG0MW00.FG0MW-PMON[FG0MWPGX] == "Y") /* print remaining month check*/
    FG0M217();
  else
    FG0M218();
    FG0M219();
  end

   /* ----------------------------------------------------------*/
   /* load style grp monthly total quantities to m001*/
   /* ----------------------------------------------------------*/

  FG0MM001.FG0MMQ01[FG0MWPIX] = FG0MW00.FG0MWWQT[1];
  FG0MM001.FG0MMQ02[FG0MWPIX] = FG0MW00.FG0MWWQT[2];
  FG0MM001.FG0MMQ03[FG0MWPIX] = FG0MW00.FG0MWWQT[3];
  FG0MM001.FG0MMQ04[FG0MWPIX] = FG0MW00.FG0MWWQT[4];
  FG0MM001.FG0MMQ05[FG0MWPIX] = FG0MW00.FG0MWWQT[5];
  FG0MM001.FG0MMQ06[FG0MWPIX] = FG0MW00.FG0MWWQT[6];
  FG0MM001.FG0MMQ07[FG0MWPIX] = FG0MW00.FG0MWWQT[7];
  FG0MM001.FG0MMQ08[FG0MWPIX] = FG0MW00.FG0MWWQT[8];
  FG0MM001.FG0MMQ09[FG0MWPIX] = FG0MW00.FG0MWWQT[9];
  FG0MM001.FG0MMQ10[FG0MWPIX] = FG0MW00.FG0MWWQT[10];

  FG0MW00.FG0MWPIX = FG0MW00.FG0MWPIX + 1;

   /* ------------------------------------------------------------*/
   /* load style grp monthly percents*/
   /* ------------------------------------------------------------*/

  FG0MM001.FG0MMSDS[FG0MWPIX] = "TOTAL PCT   ";

  move " " to FG0MW00.FG0MWWQT[1] for all; /* clear w/s display table*/
  FG0MW00.FG0MWLIX = 1; /* load index*/
  FG0MW00.FG0MWIDX = FG0MW00.FG0MW-PAGP[FG0MWPGX];

  if (FG0MW00.FG0MW-PMON[FG0MWPGX] == "Y") /* print remaining month check*/
    FG0M220();
  else
    FG0M221();
    FG0M222();
  end

   /* ----------------------------------------------------------*/
   /* load style grp monthly total percents*/
   /* ----------------------------------------------------------*/

  FG0MM001.FG0MMQ01[FG0MWPIX] = FG0MW00.FG0MWWQT[1];
  FG0MM001.FG0MMQ02[FG0MWPIX] = FG0MW00.FG0MWWQT[2];
  FG0MM001.FG0MMQ03[FG0MWPIX] = FG0MW00.FG0MWWQT[3];
  FG0MM001.FG0MMQ04[FG0MWPIX] = FG0MW00.FG0MWWQT[4];
  FG0MM001.FG0MMQ05[FG0MWPIX] = FG0MW00.FG0MWWQT[5];
  FG0MM001.FG0MMQ06[FG0MWPIX] = FG0MW00.FG0MWWQT[6];
  FG0MM001.FG0MMQ07[FG0MWPIX] = FG0MW00.FG0MWWQT[7];
  FG0MM001.FG0MMQ08[FG0MWPIX] = FG0MW00.FG0MWWQT[8];
  FG0MM001.FG0MMQ09[FG0MWPIX] = FG0MW00.FG0MWWQT[9];
  FG0MM001.FG0MMQ10[FG0MWPIX] = FG0MW00.FG0MWWQT[10];


end // end FG0M210

// Print remaining month heading
Function FG0M211()
   /* ----------------------------------------------------------------------*/
   /* Print whatever are left from the previous page.*/
   /* (Month headings, Percent, Range total and Percent or subtotal,*/
   /* Range total and percent)*/
   /*  */
   /* load subtotal/total/percent literals*/
   /*  */
   /* ----------------------------------------------------------------------*/

  FG0MW00.FG0MWREM = FG0MW00.FG0MWSIN[FG0MWSNX] - 6; /* remaining mos*/

  while (FG0MW00.FG0MWIDX <= FFZREC.FFZNUMMO /* nbr of mos loaded*/
   && FG0MW00.FG0MWLIX <= FG0MW00.FG0MWREM) /* nbr of mos left*/

    FG0MM001.FG0MMHD2[FG0MWLIX] = FFZREC.FFZIYYMM[FG0MWIDX];
    set FG0MM001.FG0MMHD2[FG0MWLIX] skip;

    FG0MW00.FG0MWIDX = FG0MW00.FG0MWIDX + 1; /* increment index*/
    FG0MW00.FG0MWLIX = FG0MW00.FG0MWLIX + 1; /* increment load index*/

  end

  FG0MS20(); /* load heading literals*/

end // end FG0M211

// Move the monthly heading
Function FG0M212()

  while (FG0MW00.FG0MWIDX <= FFZREC.FFZNUMMO /* nbr of mos loaded*/
   && FG0MW00.FG0MWLIX <= FG0MW00.FG0MWSIN[FG0MWSNX]
   /* no of mos in sesn*/
   && FG0MW00.FG0MWLIX <= 6)

    FG0MM001.FG0MMHD2[FG0MWLIX] = FFZREC.FFZIYYMM[FG0MWIDX];
    set FG0MM001.FG0MMHD2[FG0MWLIX] skip;

    FG0MW00.FG0MWIDX = FG0MW00.FG0MWIDX + 1; /* increment index*/
    FG0MW00.FG0MWLIX = FG0MW00.FG0MWLIX + 1; /* increment load index*/

  end

end // end FG0M212

// Move total and pct heading
Function FG0M213()
   /* --------------------------------------------------------*/
   /* move the totals and pct headings*/
   /* --------------------------------------------------------*/

  if (FG0MW00.FG0MWLIX > FG0MW00.FG0MWSIN[FG0MWSNX]) /* load the whole sesn*/

    FG0MS20(); /* load heading literals*/

  end

end // end FG0M213

// Move the remaining month
Function FG0M214()

   /* ----------------------------------------------------------------------*/
   /* Print whatever are left from the previous page.*/
   /* (Month, Percent, Range total and Percent or subtotal, Range total*/
   /* percent)*/
   /*  */
   /* load subtotal/total/percent*/
   /*  */
   /* ----------------------------------------------------------------------*/

   /* --------------------------------------------------------------*/
   /* print remaining months, subtotal, range total and pct fields*/
   /* --------------------------------------------------------------*/


  FG0MW00.FG0MWSIX = FG0MW00.FG0MWIDX - 6;
  while (FG0MW00.FG0MWSIX < FG0MW00.FG0MWIDX)
    FG0MW00.FG0MWUST[FG0MWPIX] = FG0MW00.FG0MWUQT[FG0MWSIX] +                                 FG0MW00.FG0MWUST[FG0MWPIX];
    FG0MW00.FG0MWSIX = FG0MW00.FG0MWSIX + 1;
  end

   /* remaining mos*/
  FG0MW00.FG0MWREM = FG0MW00.FG0MWSIN[FG0MWSNX] - 6;
  while (FG0MW00.FG0MWIDX <= FFZREC.FFZNUMMO  /* nbr of mos loaded*/
   && FG0MW00.FG0MWLIX <= FG0MW00.FG0MWREM /* nbr of mos left*/
   && FG0MW00.FG0MWLIX <= 6) /* right end*/

    FG0MW00.FG0MWWQT[FG0MWLIX] = FG0MW00.FG0MWQTY[FG0MWIDX];

    FG0MW00.FG0MWUST[FG0MWPIX] = FG0MW00.FG0MWUQT[FG0MWIDX] +                                FG0MW00.FG0MWUST[FG0MWPIX];

    FG0MW00.FG0MWIDX = FG0MW00.FG0MWIDX + 1; /* increment work index*/
    FG0MW00.FG0MWLIX = FG0MW00.FG0MWLIX + 1; /* increment load index*/

  end

  FG0MS30(); /* subtotal and range total*/

end // end FG0M214

// Move the monthly qty
Function FG0M215()
  while (FG0MW00.FG0MWIDX <= FFZREC.FFZNUMMO            /* nbr mos loaded*/
   && FG0MW00.FG0MWLIX <= FG0MW00.FG0MWSIN[FG0MWSNX] /* no of mo in sesn*/
   && FG0MW00.FG0MWLIX <= 6)

    FG0MW00.FG0MWWQT[FG0MWLIX] = FG0MW00.FG0MWQTY[FG0MWIDX];

    FG0MW00.FG0MWUST[FG0MWPIX] = FG0MW00.FG0MWUQT[FG0MWIDX] +                                FG0MW00.FG0MWUST[FG0MWPIX];

    FG0MW00.FG0MWIDX = FG0MW00.FG0MWIDX + 1; /* increment save index*/
    FG0MW00.FG0MWLIX = FG0MW00.FG0MWLIX + 1; /* increment load index*/

  end

end // end FG0M215

// Move the total line
Function FG0M216()
  if (FG0MW00.FG0MWLIX > FG0MW00.FG0MWSIN[FG0MWSNX]) /* load the whole sesn*/

    FG0MS30(); /* move subtotal, total and pcts*/

  end
end // end FG0M216

// Move the remaining month total
Function FG0M217()

   /* ----------------------------------------------------------------------*/
   /* Print whatever are left from the previous page.*/
   /* (Month, Percent, Range total and Percent or subtotal, Range total*/
   /* percent)*/
   /*  */
   /* load subtotal/total/percent for the total line*/
   /*  */
   /* ----------------------------------------------------------------------*/

   /* --------------------------------------------------------------*/
   /* print remaining months, subtotal, range total and pct fields*/
   /* --------------------------------------------------------------*/


   /* ---------------------------------------------------------------*/
   /* since pf10 is going backward to the 1st page and subtotal*/
   /* will still be 0. So if pf10 and the 2nd (right) page is*/
   /* reached, then the calculation of subtotal in the 1st*/
   /* page is necessary.*/
   /* ---------------------------------------------------------------*/

  FG0MW00.FG0MWSIX = FG0MW00.FG0MWIDX - 6;
  while (FG0MW00.FG0MWSIX < FG0MW00.FG0MWIDX)
    FG0MW00.FG0MWUMT = FG0MW03.FG0MWUMT[FG0MWSIX] +                      FG0MW00.FG0MWUMT;
    FG0MW00.FG0MWSIX = FG0MW00.FG0MWSIX + 1;
  end

  FG0MW00.FG0MWREM = FG0MW00.FG0MWSIN[FG0MWSNX] - 6; /* remaining mos*/

  while (FG0MW00.FG0MWIDX <= FFZREC.FFZNUMMO  /* nbr of mos loaded*/
   && FG0MW00.FG0MWLIX <= FG0MW00.FG0MWREM /* nbr of mos left*/
   && FG0MW00.FG0MWLIX <= 6) /* right end*/

    FG0MW00.FG0MWWQT[FG0MWLIX] = FG0MW03.FG0MWMTQ[FG0MWIDX];
    FG0MW00.FG0MWUMT = FG0MW03.FG0MWUMT[FG0MWIDX] + FG0MW00.FG0MWUMT;

    FG0MW00.FG0MWIDX = FG0MW00.FG0MWIDX + 1; /* increment work index*/
    FG0MW00.FG0MWLIX = FG0MW00.FG0MWLIX + 1; /* increment load index*/

  end

  FG0MS40(); /* process tots for total line*/

end // end FG0M217

// Move the monthly total
Function FG0M218()

  while (FG0MW00.FG0MWIDX <= FFZREC.FFZNUMMO            /* nbr mos loaded*/
   && FG0MW00.FG0MWLIX <= FG0MW00.FG0MWSIN[FG0MWSNX] /* no of mo in sesn*/
   && FG0MW00.FG0MWLIX <= 6)

    FG0MW00.FG0MWWQT[FG0MWLIX] = FG0MW03.FG0MWMTQ[FG0MWIDX];
    FG0MW00.FG0MWUMT = FG0MW03.FG0MWUMT[FG0MWIDX] + FG0MW00.FG0MWUMT;

    FG0MW00.FG0MWIDX = FG0MW00.FG0MWIDX + 1; /* increment save index*/
    FG0MW00.FG0MWLIX = FG0MW00.FG0MWLIX + 1; /* increment load index*/

  end

end // end FG0M218

// Move subtot & tot for tot line
Function FG0M219()
   /* --------------------------------------------------------*/
   /* move the totals and pct*/
   /* --------------------------------------------------------*/

  if (FG0MW00.FG0MWLIX > FG0MW00.FG0MWSIN[FG0MWSNX]) /* load the whole sesn*/

    FG0MS40(); /* translate and load subtotal and total*/

  end
end // end FG0M219

// Move the remaining month pct
Function FG0M220()

   /* ----------------------------------------------------------------------*/
   /* Print whatever are left from the previous page.*/
   /* (Monthly percent or subtotal percent)*/
   /*  */
   /* load subtotal percent for the percent line*/
   /*  */
   /* ----------------------------------------------------------------------*/

   /* --------------------------------------------------------------*/
   /* print remaining months and subtotal*/
   /* --------------------------------------------------------------*/

  FG0MW00.FG0MWREM = FG0MW00.FG0MWSIN[FG0MWSNX] - 6; /* remaining mos*/

  while (FG0MW00.FG0MWIDX <= FFZREC.FFZNUMMO  /* nbr of mos loaded*/
   && FG0MW00.FG0MWLIX <= FG0MW00.FG0MWREM /* nbr of mos left*/
   && FG0MW00.FG0MWLIX <= 6) /* right end*/

    if (FG0MW03.FG0MWUMT[FG0MWTIX] != 0)
      FG0MW00.FG0MWNM1 = FG0MW03.FG0MWUMT[FG0MWIDX] * 100;
      FG0MW00.FG0MWNPT = mathLib.round(FG0MW00.FG0MWNM1 /       FG0MW03.FG0MWUMT[FG0MWTIX], -mathLib.decimals(FG0MW00.FG0MWNPT));

      /* ----------------------------------------------------------*/
      /* zero suppress the percent field*/
      /* ----------------------------------------------------------*/

      if (FG0MW00.FG0MWNPT != 0)
        if (FG0MW00.FG0MWNPT < 0) /* percent is negative*/
          FG0MW00.FG0MWNPT = FG0MW00.FG0MWNPT * -1;
        end

        FG0MW00.FG0MWPTW = FG0MW00.FG0MWNP1;
        FG0MW00.FG0MWPTP = ".";
        FG0MW00.FG0MWPTD = FG0MW00.FG0MWNP2;

        if (FG0MW00.FG0MWPT1 == "0")
          FG0MW00.FG0MWPT1 = " ";
          if (FG0MW00.FG0MWPT2 == "0")
            FG0MW00.FG0MWPT2 = " ";
          end
        end

        if (FG0MW03.FG0MWUMT[FG0MWTIX] < 0
         && FG0MW03.FG0MWUMT[FG0MWIDX] < 0)

          /* both quantities are negative; positive percent*/

        else /* one or the other qty are negative*/
          if (FG0MW03.FG0MWUMT[FG0MWTIX] < 0
           || FG0MW03.FG0MWUMT[FG0MWIDX] < 0)

            if (FG0MW00.FG0MWNPT > 99.9) /* reformat pct w/o fraction*/
              FG0MW00.FG0MWPTD = FG0MW00.FG0MWPT3;
              FG0MW00.FG0MWPTP = FG0MW00.FG0MWPT2;
              FG0MW00.FG0MWPT3 = FG0MW00.FG0MWPT1;
              FG0MW00.FG0MWPT2 = "-";
              FG0MW00.FG0MWPT1 = " ";
            else /* percent < or = -99.9*/
              if (FG0MW00.FG0MWPT2 == "0")
                FG0MW00.FG0MWPT2 = "-";
              else
                if (FG0MW00.FG0MWPT1 == "0")
                  FG0MW00.FG0MWPT1 = "-";
                end
              end
            end
          end
        end

        FG0MW00.FG0MWWQT[FG0MWLIX] = FG0MW00.FG0MWPCT;

      end
    end

    FG0MW00.FG0MWIDX = FG0MW00.FG0MWIDX + 1; /* increment work index*/
    FG0MW00.FG0MWLIX = FG0MW00.FG0MWLIX + 1; /* increment load index*/

  end

  FG0MS50(); /* translate and load subtotal*/

  FG0MW00.FG0MW-NEXT = "Y"; /* next season*/

end // end FG0M220

// Move the monthly pct
Function FG0M221()

  while (FG0MW00.FG0MWIDX <= FFZREC.FFZNUMMO            /* nbr mos loaded*/
   && FG0MW00.FG0MWLIX <= FG0MW00.FG0MWSIN[FG0MWSNX] /* no of mo in sesn*/
   && FG0MW00.FG0MWLIX <= 6)

    /* ----------------------------------------------------------*/
     /* calculate/load style grp monthly percents*/
    /* ----------------------------------------------------------*/

    if (FG0MW03.FG0MWUMT[FG0MWTIX] != 0)
      FG0MW00.FG0MWNM1 = FG0MW03.FG0MWUMT[FG0MWIDX] * 100;
      FG0MW00.FG0MWNPT = mathLib.round(FG0MW00.FG0MWNM1 / FG0MW03.FG0MWUMT[FG0MWTIX], -mathLib.decimals(FG0MW00.FG0MWNPT));

      /* ----------------------------------------------------------*/
       /* zero suppress the percent field*/
      /* ----------------------------------------------------------*/

      if (FG0MW00.FG0MWNPT != 0)
        if (FG0MW00.FG0MWNPT < 0) /* percent is negative*/
          FG0MW00.FG0MWNPT = FG0MW00.FG0MWNPT * -1;
        end

        FG0MW00.FG0MWPTW = FG0MW00.FG0MWNP1;
        FG0MW00.FG0MWPTP = ".";
        FG0MW00.FG0MWPTD = FG0MW00.FG0MWNP2;

        if (FG0MW00.FG0MWPT1 == "0")
          FG0MW00.FG0MWPT1 = " ";
          if (FG0MW00.FG0MWPT2 == "0")
            FG0MW00.FG0MWPT2 = " ";
          end
        end

        if (FG0MW03.FG0MWUMT[FG0MWTIX] < 0
         && FG0MW03.FG0MWUMT[FG0MWIDX] < 0)

          /* both quantities are negative; positive percent*/

        else /* one or the other qty are negative*/
          if (FG0MW03.FG0MWUMT[FG0MWTIX] < 0
           || FG0MW03.FG0MWUMT[FG0MWIDX] < 0)

            if (FG0MW00.FG0MWNPT > 99.9) /* reformat pct w/o fraction*/
              FG0MW00.FG0MWPTD = FG0MW00.FG0MWPT3;
              FG0MW00.FG0MWPTP = FG0MW00.FG0MWPT2;
              FG0MW00.FG0MWPT3 = FG0MW00.FG0MWPT1;
              FG0MW00.FG0MWPT2 = "-";
              FG0MW00.FG0MWPT1 = " ";
            else /* percent < or = -99.9*/
              if (FG0MW00.FG0MWPT2 == " ")
                FG0MW00.FG0MWPT2 = "-";
              else
                if (FG0MW00.FG0MWPT1 == " ")
                  FG0MW00.FG0MWPT1 = "-";
                end
              end
            end
          end
        end

        FG0MW00.FG0MWWQT[FG0MWLIX] = FG0MW00.FG0MWPCT;

      end
    end

    FG0MW00.FG0MWIDX = FG0MW00.FG0MWIDX + 1; /* increment save index*/
    FG0MW00.FG0MWLIX = FG0MW00.FG0MWLIX + 1; /* increment load index*/

  end

end // end FG0M221

// Move the total pct
Function FG0M222()

   /* --------------------------------------------------------*/
   /* move the totals and pct*/
   /* --------------------------------------------------------*/

  if (FG0MW00.FG0MWLIX > FG0MW00.FG0MWSIN[FG0MWSNX]) /* load the whole sesn*/

    FG0MS50(); /* translate and load subtotal*/

    if (FG0MW00.FG0MWIDX > FFZREC.FFZNUMMO) /* Reach the no of mo reqstd*/

    else
      FG0MW00.FG0MW-NEXT = "Y"; /* next season*/
    end

  else

    FG0MW00.FG0MWSIX = FG0MW00.FG0MWPGX + 1;
    FG0MW00.FG0MW-PMON[FG0MWSIX] = "Y";

  end
end // end FG0M222

// Check attention identifier
Function FG0M300()
   /* ------------------------------------------------------------*/
   /* If CANCEL was requested, clear the map fields and exit.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pa2) /* PA2 was pressed*/

    converseLib.clearScreen();
     /* refresh map*/

    FG0MW00.FG0MWSWF = "Y"; /* format screen m001*/
    FG0MW00.FG0MWSWR = "N"; /* request for data*/

    COMMAREA.CATOAP = " "; /* to application*/
    COMMAREA.CAITEM = " "; /* passed data*/

    exit stack; /* Exit to display map*/

  end

   /* ------------------------------------------------------------*/
   /* If FAST PATH was requested, transfer to the application.*/
   /* ------------------------------------------------------------*/

  if (FG0MM001.CATOAP > " ") /* FAST PATH was requested*/

    if (converseVar.eventKey is enter) /* ENTER was pressed*/

      FG0MS01(); /* purge temp storage*/

      XSFFS01(); /* Exit to another application*/

      FG0MW00.FG0MWSWF = "Y"; /* format screen m001*/
      FG0MW00.FG0MWSWR = "N"; /* request for data*/

      set FG0MM001.CATOAP cursor, bold; /* Highlight*/

    else

      FFWREC.XXXMODID = "300"; /* Module identification*/
      converseLib.validationFailed(36); /* Indicate PF key not valid*/

    end

    exit stack; /* Exit to display map*/

  end

   /* ------------------------------------------------------------*/
   /* If HELP, exit to the previous level or exit to the Master*/
   /* Menu was requested, exit to another application.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf1  /* PF1 was pressed*/
   || converseVar.eventKey is pf3  /* or PF3 was pressed*/
   || converseVar.eventKey is pf5  /* or PF5 was pressed*/
   || converseVar.eventKey is pf13 /* or PF13 was pressed*/
   || converseVar.eventKey is pf14 /* or PF14 was pressed*/
   || converseVar.eventKey is pf15) /* or PF15 was pressed*/

    if (converseVar.eventKey is pf1) /* PF1 was pressed*/
      COMMAREA.CAITEM = "FG0MM001"; /* Application find code*/
    end

    if (converseVar.eventKey is pf3) /* PF3 was pressed*/
      COMMAREA.CATOAP = "FG0A"; /* TO application*/
    end

    if (converseVar.eventKey is pf13) /* PF13 was pressed*/
      COMMAREA.CATOAP = "FG0K"; /* TO application*/
    end

    if (converseVar.eventKey is pf14) /* PF14 was pressed*/
      COMMAREA.CATOAP = "FG0L"; /* TO application*/
    end

    if (converseVar.eventKey is pf15) /* PF15 was pressed*/
      COMMAREA.CATOAP = "FG0N"; /* TO application*/
    end

    XSFFS01(); /* Exit to another application*/

    FG0MW00.FG0MWSWF = "Y"; /* format screen m001*/
    FG0MW00.FG0MWSWR = "N"; /* request for data*/

    exit stack; /* Exit to display map*/

  end

   /* ------------------------------------------------------------*/
   /* Determine whether a valid attention identifier was used to*/
   /* invoke the transaction.  Display an error message to the*/
   /* user if the PF key used is not supported.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey not enter /* ENTER was not pressed*/
   && converseVar.eventKey not pf7   /* pf7 was not pressed*/
   && converseVar.eventKey not pf8   /* pf8 was not pressed*/
   && converseVar.eventKey not pf10  /* pf10 was not pressed*/
   && converseVar.eventKey not pf11  /* pf11 was not pressed*/
  )                                 
    FFWREC.XXXMODID = "300"; /* Module identification*/
    converseLib.validationFailed(3); /* Indicate invalid attention key*/

    if (converseVar.eventKey is pakey) /* PA key was pressed*/
      converseLib.clearScreen();
       /* Clear screen before display*/
    end

    exit stack; /* Exit to display map*/

  end


end // end FG0M300

// Reset highlighted fields
Function FG0M400()
   /* ------------------------------------------------------------*/
   /* Reset field attributes to normal intensity.*/
   /* ------------------------------------------------------------*/

  set FG0MM001.FG0MMBRG initialAttributes; /* begin range*/
  set FG0MM001.FG0MMERG initialAttributes; /* end range*/
  set FG0MM001.YPGCD initialAttributes; /* product type group*/
  set FG0MM001.XPCCD initialAttributes; /* product line code*/
  set FG0MM001.FFW-ND-SHP-IND initialAttributes; /* need/ship month indicator*/
  set FG0MM001.FG0MMSEM[1] initialAttributes; /* season end month*/
  set FG0MM001.FG0MMSEM[2] initialAttributes; /* season end month*/
  set FG0MM001.FG0MMSEM[3] initialAttributes; /* season end month*/
  set FG0MM001.FG0MMSEM[4] initialAttributes; /* season end month*/

  set FG0MM001.CATOAP initialAttributes;
  set FG0MM001.CAITEM initialAttributes;

   /* ------------------------------------------------------------*/
   /* If no lists were requested, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (FG0MM001.XPCCD == "?" /* product category*/
   || FG0MM001.YPGCD == "?") /* product type group*/

    if (converseVar.eventKey not enter) /* ENTER was not pressed*/

      FFWREC.XXXMODID = "400"; /* Module identification*/
      converseLib.validationFailed(19); /* Indicate PF key not valid*/

      exit stack; /* Exit to display map*/

    end

  else

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* If requested, display the list of product type group codes*/
   /* ------------------------------------------------------------*/

  if (FG0MM001.XPCCD == "?") /* product type grp list*/

    XPXX001(); /* window initialization*/
    XX0XW02.XX0XWHDR = "PRODUCT CATEGORY CODES"; /* Heading*/
    XX0XW02.XGPCD = COMMAREA.XGPCD; /* gpc*/

    while (XX0XW02.XX0XWEND == "N") /* Until end of request*/
      XPXPC01(); /* Display the list*/
    end

    if (XX0XW02.XX0XWPIX == 0) /* No selection made*/

      XPCREC.XPCCD = FFWREC.XPCCD; /* product line code*/
      XPCREC.XGPCD = COMMAREA.XGPCD; /* gpc code*/
      if (XPCREC.XPCKEY in XPCTBL.XPCKEY)
        FG0MM001.XPCABRV = XPCTBL.XPCABRV[sysVar.arrayIndex];
      end
    else
      FG0MM001.XPCCD = XPCTBL.XPCCD[XX0XWPIX]; /* Selected code*/
      FG0MM001.XPCABRV = XPCTBL.XPCABRV[XX0XWPIX]; /* Selected code*/

    end

    set FG0MM001.XPCCD cursor; /* Establish cursor position*/

  end
   /* ------------------------------------------------------------*/
   /* If requested, display the list of product type group codes*/
   /* ------------------------------------------------------------*/

  if (FG0MM001.YPGCD == "?") /* product type grp list*/

    XPXX001(); /* window initialization*/
    XX0XW02.XX0XWHDR = "PRODUCT TYPE GROUP"; /* Heading*/

    XX0XW02.YPGFFFL = "Y"; /* init flag*/
    while (XX0XW02.XX0XWEND == "N") /* Until end of request*/
      XPYPG01(); /* Display the list*/
    end

    if (XX0XW02.XX0XWPIX == 0) /* No selection made*/

      FG0MM001.YPGCD = FFWREC.YPGCD; /* Restore prior code*/
      FG0MM001.YPGABRV = FFWREC.YPGABRV; /* Restore prior code*/
    else
      FG0MM001.YPGCD = YPGTBL.YPGCD[XX0XWPIX]; /* Selected code*/
      FG0MM001.YPGABRV = YPGTBL.YPGABRV[XX0XWPIX]; /* Selected code*/

    end

    set FG0MM001.YPGCD cursor; /* Establish cursor position*/

  end

   /* ------------------------------------------------------------*/
   /* Indicate that the requested lists have been displayed and*/
   /* that ENTER must be pressed to process any changes.*/
   /* ------------------------------------------------------------*/

  converseLib.clearScreen();
   /* Clear screen before display*/

  FFWREC.XXXMODID = "400"; /* Module identification*/
  converseLib.validationFailed(97); /* Indicate press ENTER*/

  exit stack; /* Exit to display map*/


end // end FG0M400

// Verify the entered data
Function FG0M500()
   /* ------------------------------------------------------------*/
   /* Highlight any application data that was entered.*/
   /* ------------------------------------------------------------*/

  if (COMMAREA.CAITEM > " ") /* Application data was entered*/

    FFWREC.XXXMODID = "500"; /* Module identification*/
    set FG0MM001.CAITEM cursor, bold; /* Highlight*/
    converseLib.validationFailed(40); /* Enter only with FAST PATH*/

  end

   /* ------------------------------------------------------------*/
   /* verify request to scroll forward(pf7) or backwards(pf8)*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf7
   || converseVar.eventKey is pf8)

    FG0M510(); /* verify scroll fwrd/back request*/

  end

   /* ------------------------------------------------------------*/
   /* verify request to scroll right(pf11) or left(pf10)*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf10
   || converseVar.eventKey is pf11)

    FG0M520(); /* verify scroll left/right*/

  end

   /* ------------------------------------------------------------*/
   /* if ezeaid not enter verify modifiable data*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey not enter)

    FG0MS05(); /* verify modifiable data*/

  end

   /* ------------------------------------------------------------*/
   /* validate entry fields*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is enter)

    FG0MW00.FG0MWWYM = FFWREC.FFABEGMO;
    FG0MW00.FG0MW-WYM1 = FFWREC.FFAENDMO;

    if (FG0MM001.FG0MMSEM[1] != FG0MW00.FG0MWSEM[1]       /* sesn end mo chgd*/
     || FG0MM001.FG0MMSEM[1] == 0                         
     || FG0MM001.FG0MMSEM[2] != FG0MW00.FG0MWSEM[2]       
     || FG0MM001.FG0MMSEM[2] == 0                         
     || FG0MM001.FG0MMSEM[3] != FG0MW00.FG0MWSEM[3]       
     || FG0MM001.FG0MMSEM[3] == 0                         
     || FG0MM001.FG0MMSEM[4] != FG0MW00.FG0MWSEM[4]       
     || FG0MM001.FG0MMSEM[4] == 0                         
     || FG0MM001.FFW-ND-SHP-IND != FG0MW00.FFW-ND-SHP-IND /* nd/shp mo ind*/
     || FG0MM001.FFW-ND-SHP-IND == " "                    /* nd/shp mo ind*/
     || FG0MM001.YPGCD != FFWREC.YPGCD                    /* product type grp chg*/
     || FG0MM001.YPGCD == " "                             /* product type grp chg*/
     || FG0MM001.XPCCD != FFWREC.XPCCD                    /* product category chg*/
     || FG0MM001.XPCCD == " "                             /* product category changed*/
     || FG0MM001.FG0MMBRG != FG0MW00.FG0MWWYM             /* beg range changed*/
     || FG0MM001.FG0MMBRG == 0                            /* beg range changed*/
     || FG0MM001.FG0MMERG != FG0MW00.FG0MW-WYM1           /* end range changed*/
     || FG0MM001.FG0MMERG == 0)                           /* end range changed*/

      FG0MW00.FG0MWSNX = 1; /* season index*/
      FG0MW00.FG0MWPGX = 1; /* page index*/
      FG0MW00.XXXTSPAG = 1; /* page no*/
      FG0MW00.FG0MW-NEXT = "N"; /* next season flag*/
      move "N" to FG0MW00.FG0MW-PMON[1] for all; /* print remaining month flag*/
      FG0MW00.FG0MWUMT = 0;
      move 0 to FG0MW00.FG0MWUST[1] for all;

    end

    FG0M530(); /* validate entry fields*/

    /* ------------------------------------------------------*/
     /* if key data changed check modifiable fields*/
    /* ------------------------------------------------------*/

    FG0MW00.FG0MWWYM = FFWREC.FFABEGMO;
    FG0MW00.FG0MW-WYM1 = FFWREC.FFAENDMO;

    if (FG0MM001.FFW-ND-SHP-IND != FG0MW00.FFW-ND-SHP-IND /* nd/shp mo ind*/
     || FG0MM001.FFW-ND-SHP-IND == " "                    /* nd/shp mo ind*/
     || FG0MM001.YPGCD != FFWREC.YPGCD                    /* product type grp chg*/
     || FG0MM001.YPGCD == " "                             /* product type grp chg*/
     || FG0MM001.XPCCD != FFWREC.XPCCD                    /* product category chg*/
     || FG0MM001.XPCCD == " "                             /* product category changed*/
     || FG0MM001.FG0MMBRG != FG0MW00.FG0MWWYM             /* beg range changed*/
     || FG0MM001.FG0MMBRG == 0                            /* beg range changed*/
     || FG0MM001.FG0MMERG != FG0MW00.FG0MW-WYM1           /* end range changed*/
     || FG0MM001.FG0MMERG == 0)                           /* end range changed*/

      if (converseVar.validationMsgNum == 0)
        FG0MW00.FG0MWSWR = "Y"; /* request data request*/
      end

    end
  end

  if (converseVar.validationMsgNum != 0)
    exit stack; /* display error message*/
  end


end // end FG0M500

// verify scroll fwrd/back
Function FG0M510()
   /* ------------------------------------------------------------*/
   /* If scroll back was requested, ensure that pages exist.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf7 /* Scroll back request*/
   && FG0MW00.XXXTSPAG < 2)       /* and no previous pages*/

    FFWREC.XXXMODID = "510"; /* Module identification*/
    converseLib.validationFailed(6); /* No previous page to display*/

  end

   /* ------------------------------------------------------------*/
   /* If scroll forward was requested, ensure that pages exist.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf8 /* Scroll forward request*/
   && FG0MW00.XXXTSPAG >= FG0MW00.TA5TSQIX) /* and no more pages*/

    FFWREC.XXXMODID = "510"; /* Module identification*/
    converseLib.validationFailed(7); /* No more pages to display*/

  end


end // end FG0M510

// verify scroll left/right
Function FG0M520()
   /* ------------------------------------------------------------*/
   /* If scroll left was requested, ensure that pages exist.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf10) /* Scroll left request*/
    if (FG0MW00.FG0MWPGX == 1) /* and no previous pages*/

      FFWREC.XXXMODID = "520"; /* Module identification*/
      converseLib.validationFailed(23); /* No previous page to display*/
    end

  end

   /* ------------------------------------------------------------*/
   /* If scroll right was requested, ensure that pages exist.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf11 /* Scroll right request*/
   && FG0MW00.FG0MWIDX > FFZREC.FFZNUMMO) /* and no more pages*/

    FFWREC.XXXMODID = "520"; /* Module identification*/
    converseLib.validationFailed(24); /* No more pages to display*/

  end


end // end FG0M520

// validate modifiable data
Function FG0M530()

  set FFZREC empty;

  FFZREC.FFZMONTH = 1;
  FFZREC.FFZSRANG = "Y";
  FFZREC.FFZBYYMM = FG0MM001.FG0MMBRG;
  FFZREC.FFZEYYMM = FG0MM001.FG0MMERG;

  XSFFS30(); /* edit date range*/

   /* ------------------------------------------------------------*/
   /* validate number of months in season entry*/
   /* ------------------------------------------------------------*/

  XPCREC.XGPCD = COMMAREA.XGPCD;
  XPCREC.XPCCD = FG0MM001.XPCCD;
  if (FG0MM001.XPCCD != "  "
   && XPCREC.XPCKEY in XPCTBL.XPCKEY
   && XPCTBL.XXXSTAT[sysVar.arrayIndex] == "A")
    FG0M531();
  end

   /* ------------------------------------------------------------*/
   /* validate product category code*/
   /* ------------------------------------------------------------*/

  XPCREC.XGPCD = COMMAREA.XGPCD;
  XPCREC.XPCCD = FG0MM001.XPCCD;
  if (XPCREC.XPCKEY in XPCTBL.XPCKEY
   && XPCTBL.XXXSTAT[sysVar.arrayIndex] == "A")
    FG0MM001.XPCABRV = XPCTBL.XPCABRV[sysVar.arrayIndex];
  else
    FG0MM001.XPCABRV = " ";
    converseLib.validationFailed(118);
    FFWREC.XXXMODID = "530";
    set FG0MM001.XPCCD cursor, bold;
  end

   /* ------------------------------------------------------------*/
   /* validate product type group*/
   /* ------------------------------------------------------------*/

  if (FG0MM001.YPGCD in YPGTBL.YPGCD
   && YPGTBL.XXXSTAT[sysVar.arrayIndex] == "A")
    FG0MM001.YPGABRV = YPGTBL.YPGABRV[sysVar.arrayIndex];
  else
    FG0MM001.YPGABRV = " ";
    converseLib.validationFailed(118);
    FFWREC.XXXMODID = "530";
    set FG0MM001.YPGCD cursor, bold;
  end

   /* ------------------------------------------------------------*/
   /* validate need/ship month indicator*/
   /* ------------------------------------------------------------*/

  if (FG0MM001.FFW-ND-SHP-IND == "N"
   || FG0MM001.FFW-ND-SHP-IND == "S"
  )
     /* valid entry*/

  else
    converseLib.validationFailed(10);
    FFWREC.XXXMODID = "530";
    set FG0MM001.FFW-ND-SHP-IND cursor, bold;
  end

   /* ------------------------------------------------------------*/
   /* validate end yymm range and begin yymm range*/
   /* ------------------------------------------------------------*/

  if (FFZREC.FFZENDRC == "1")
    set FG0MM001.FG0MMERG cursor, bold; /* Highlight*/
    converseLib.validationFailed(8); /* Indicate missing or invalid*/
    FFWREC.XXXMODID = "530";
  else
    if (FFZREC.FFZENDRC == "2")
      set FG0MM001.FG0MMERG cursor, bold; /* Highlight*/
      converseLib.validationFailed(17); /* Indicate missing or invalid*/
      FFWREC.XXXMODID = "530";
    else
      if (FFZREC.FFZENDRC == "3")
        set FG0MM001.FG0MMERG cursor, bold; /* Highlight*/
        converseLib.validationFailed(151); /* out of range*/
        FFWREC.XXXMODID = "530";
      end
    end
  end

  if (FFZREC.FFZBEGRC == "1")
    set FG0MM001.FG0MMBRG cursor, bold; /* Highlight*/
    converseLib.validationFailed(8); /* Indicate missing or invalid*/
    FFWREC.XXXMODID = "530";
  else
    if (FFZREC.FFZBEGRC == "2")
      set FG0MM001.FG0MMBRG cursor, bold; /* Highlight*/
      converseLib.validationFailed(17); /* Indicate missing or invalid*/
      FFWREC.XXXMODID = "530";
    else
      if (FFZREC.FFZBEGRC == "3")
        set FG0MM001.FG0MMBRG cursor, bold; /* Highlight*/
        converseLib.validationFailed(151); /* out of range*/
        FFWREC.XXXMODID = "530";
      end
    end
  end


end // end FG0M530

// Verify season end month
Function FG0M531()

   /* ------------------------------------------------------------*/
   /* validate season end months*/
   /* ------------------------------------------------------------*/

  if (FFZREC.FFZENDMO == 0) /* passed from other application*/
    FG0MW00.FG0MWWBD = FFWREC.FFABEGMO; /* beginning date*/
    FG0MW00.FG0MWWED = FFWREC.FFAENDMO; /* ending date*/
  else
    FG0MW00.FG0MWWBD = FFZREC.FFZBEGMO; /* beginning date*/
    FG0MW00.FG0MWWED = FFZREC.FFZENDMO; /* ending date*/
  end

   /* figure out number of seasons*/

  FG0MW00.FG0MWPIX = 4; /* index*/
  while (FG0MW00.FG0MWPIX > 0)

    FG0MW00.FG0MWSEM[FG0MWPIX] = 0;
    FG0MW00.FG0MWSMO[FG0MWPIX] = 0;
    FG0MW00.FG0MWSIN[FG0MWPIX] = 0;

    FG0MW00.FG0MWPIX = FG0MW00.FG0MWPIX - 1;
    /*  */
  end

  FG0MW00.FG0MWNSS = 0; /* reset number of seasons*/
  FG0MW00.FG0MWPIX = 4; /* index*/
  while (FG0MW00.FG0MWPIX > 0)
    if (FG0MM001.FG0MMSEM[FG0MWPIX] > 0)
      FG0MW00.FG0MWNSS = FG0MW00.FG0MWPIX; /* number of seasons*/
      FG0MW00.FG0MWPIX = FG0MW00.FG0MWPIX - 4; /* force out of loop*/

    else

      FG0MW00.FG0MWPIX = FG0MW00.FG0MWPIX - 1;
    end

  end

   /* check for no seasons entered*/

  if (FG0MW00.FG0MWNSS == 0) /* no season lengths found*/
    FG0MS60(); /* obtain default season end months*/
  end

   /* If no season end month entered then check the length of the range,*/
   /* if <= 6 months use default (end month of the range)*/

  if (FG0MW00.FG0MWNSS == 0) /* no season lengths found*/
    if (FG0MW00.FG0MWBYY == FG0MW00.FG0MWEYY) /* same year*/
      FG0MW00.FG0MWNM1 = FG0MW00.FG0MWEMM - FG0MW00.FG0MWBMM + 1;
    else
      FG0MW00.FG0MWNM1 = FG0MW00.FG0MWEMM + 12 - FG0MW00.FG0MWBMM + 1;
    end

    if (FG0MW00.FG0MWNM1 <= 6)
      FG0MW00.FG0MWNSS = 1;
      FG0MM001.FG0MMSEM[1] = FG0MW00.FG0MWEMM; /* range end month*/
    end
  end

  if (FG0MW00.FG0MWNSS == 0)
    FFWREC.XXXMODID = "531"; /* Module identification*/
    set FG0MM001.FG0MMSEM[1] cursor, bold; /* Highlight*/
    converseLib.validationFailed(442); /* required field*/
    return;
  end

   /* check for embedded zeros*/

  FG0MW00.FG0MWPIX = FG0MW00.FG0MWNSS; /* index*/
  while (FG0MW00.FG0MWPIX > 0)
    if (FG0MM001.FG0MMSEM[FG0MWPIX] == 0) /* check for embedded zeros*/
      FFWREC.XXXMODID = "531"; /* Module identification*/
      set FG0MM001.FG0MMSEM[FG0MWPIX] cursor, bold; /* Highlight*/
      converseLib.validationFailed(440); /* required field*/
    end
    FG0MW00.FG0MWPIX = FG0MW00.FG0MWPIX - 1;
  end

  if (converseVar.validationMsgNum > 0)
    return;
  end

   /* check for invalid season end months*/

  FG0MW00.FG0MWPIX = FG0MW00.FG0MWNSS; /* index*/
  while (FG0MW00.FG0MWPIX > 0)

    if (FG0MM001.FG0MMSEM[FG0MWPIX] < 1 /* check for month error*/
     || FG0MM001.FG0MMSEM[FG0MWPIX] > 12)
      FFWREC.XXXMODID = "531"; /* Module identification*/
      set FG0MM001.FG0MMSEM[FG0MWPIX] cursor, bold; /* Highlight*/
      converseLib.validationFailed(010); /* required field*/
      return;
    end

    if (FG0MM001.FG0MMSEM[FG0MWPIX] != FG0MW00.FG0MWEMM
     && FG0MW00.FG0MWPIX == FG0MW00.FG0MWNSS) /* last end month*/
      FFWREC.XXXMODID = "531"; /* Module identification*/
      set FG0MM001.FG0MMSEM[FG0MWPIX] cursor, bold; /* Highlight*/
      converseLib.validationFailed(447); /* required field*/
      return;

    else

      FG0MS70(); /* check for invalid entry*/

    end

    FG0MW00.FG0MWPIX = FG0MW00.FG0MWPIX - 1;

  end

  FG0MW00.FG0MWPIX = FG0MW00.FG0MWNSS;
  while (FG0MW00.FG0MWPIX > 0) /* nbr of seasons*/
    FG0MW00.FG0MWLIX = FG0MW00.FG0MWPIX - 1;
    if (FG0MW00.FG0MWLIX != 0)
      if (FG0MW00.FG0MWSMO[FG0MWLIX] >= FG0MW00.FG0MWSMO[FG0MWPIX])
        FFWREC.XXXMODID = "531"; /* Module identification*/
        set FG0MM001.FG0MMSEM[FG0MWLIX] cursor, bold; /* Highlight*/
        converseLib.validationFailed(444); /* sesn end mo > next sesn end mo*/
      end
    end
    FG0MW00.FG0MWPIX = FG0MW00.FG0MWPIX - 1;
  end

  FG0MW00.FG0MWPIX = FG0MW00.FG0MWNSS;
  FG0MW00.FG0MWNM1 = 0; /* clear total months work area*/
  while (FG0MW00.FG0MWPIX > 0) /* nbr of seasons*/
    FG0MW00.FG0MWSEM[FG0MWPIX] = FG0MM001.FG0MMSEM[FG0MWPIX];
    FG0MS80(); /* calculate no of mos in each sesn*/
    FG0MW00.FG0MWPIX = FG0MW00.FG0MWPIX - 1;
  end


end // end FG0M531

// Process valid input request
Function FG0M600()
   /* ------------------------------------------------------------*/
   /* indicate map must be reformatted before display*/
   /* ------------------------------------------------------------*/

  FG0MW00.FG0MWSWF = "Y"; /* set format map switch*/

   /* ------------------------------------------------------------*/
   /* Update the modifiable data in the COMMAREA/ffwrec*/
   /* ------------------------------------------------------------*/

  FFWREC.FFW-ND-SHP-IND = FG0MM001.FFW-ND-SHP-IND;
  FG0MW00.FFW-ND-SHP-IND = FG0MM001.FFW-ND-SHP-IND;

  FFWREC.XPCCD = FG0MM001.XPCCD; /* product category*/
  FFWREC.XPCABRV = FG0MM001.XPCABRV; /* product category abrv desc*/

  FFWREC.YPGCD = FG0MM001.YPGCD; /* product type grp code*/
  FFWREC.YPGABRV = FG0MM001.YPGABRV; /* product type grp abrv desc*/

   /* ------------------------------------------------------------*/
   /* Request for data when season end month 1st entered.*/
   /* ------------------------------------------------------------*/

  if (FFWREC.FFWENDM1 != FG0MW00.FG0MWSMO[1]
   && FFWREC.FFWENDM1 == 0)
    FG0MW00.FG0MWSWR = "Y";
  end

  FFWREC.FFWENDM1 = FG0MW00.FG0MWSMO[1]; /* season end month*/
  FFWREC.FFWENDM2 = FG0MW00.FG0MWSMO[2]; /* season end month*/
  FFWREC.FFWENDM3 = FG0MW00.FG0MWSMO[3]; /* season end month*/
  FFWREC.FFWENDM4 = FG0MW00.FG0MWSMO[4]; /* season end month*/

  FFWREC.FFABEGMO = FFZREC.FFZBEGMO;
  FFWREC.FFAENDMO = FFZREC.FFZENDMO;

  if (converseVar.eventKey is enter
   && FG0MW00.FG0MWSWR == "Y") /* KEY DATA MODIFIED*/
    return;
  end

   /* ------------------------------------------------------------*/
   /* request to scroll backwards*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf7) /* display next season*/
    FG0MW00.XXXTSPAG = FG0MW00.XXXTSPAG - 1;
    return;
  end

   /* ------------------------------------------------------------*/
   /* request to scroll foward*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf8) /* display next season*/
    FG0MW00.XXXTSPAG = FG0MW00.XXXTSPAG + 1;
    return;
  end

   /* ------------------------------------------------------------*/
   /* request to scroll left*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf10) /* display prior season*/

    FG0MW00.FG0MWPGX = FG0MW00.FG0MWPGX - 1;
    FG0MW00.FG0MWSNX = FG0MW00.FG0MW-PAGS[FG0MWPGX];
    FG0MW00.FG0MW-NEXT = "N";
    return;

  end

   /* ------------------------------------------------------------*/
   /* request to scroll right*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf11) /* display next season*/

    FG0MW00.FG0MWPGX = FG0MW00.FG0MWPGX + 1;
    FG0MW00.FG0MW-PAGP[FG0MWPGX] = FG0MW00.FG0MWIDX;
                                   /* start point  of*/
                                  /* next page*/
    if (FG0MW00.FG0MW-NEXT == "Y") /* next season*/
      FG0MW00.FG0MWSNX = FG0MW00.FG0MWSNX + 1;
      FG0MW00.FG0MW-NEXT = "N";
    end

    FG0MW00.FG0MW-PAGS[FG0MWPGX] = FG0MW00.FG0MWSNX;
                                   /* sesn of the pag*/

    return;
  end


end // end FG0M600

// purge temporary storage
Function FG0MS01()
   /* ------------------------------------------------------------*/
   /* Initialize the storage areas and indicators to be used.*/
   /* ------------------------------------------------------------*/

  set FG0MW01 empty; /* header data*/
  set FG0MW02 empty; /* M001 temporary storage detail*/
  set FG0MW03 empty; /* columns totals*/

  TA5REC.TA5TSQIX = 0; /* Current page number*/
  FG0MW00.TA5TSQIX = 0; /* Highest page number*/

   /* ------------------------------------------------------------*/
   /* Purge any temporary storage for this application.*/
   /* ------------------------------------------------------------*/

  TA5REC.TA5APPID = COMMAREA.CACURRAP; /* Application identification*/
  TA5REC.TA5FNCCD = "P"; /* Function code*/

  try
    call "TA0050" (FG0MW02, TA5REC) {isNoRefresh = yes, isExternal = yes};
  end /* Temporary storage*/

   /* ------------------------------------------------------------*/
   /* If successful, return to previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && TA5REC.TA5RTNCD == 0)          /* and normal return code*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that a system error occurred.*/
   /* ------------------------------------------------------------*/

  TAEREC.TAEDESC1 = sysVar.errorCode; /* CSP return code*/
  TAEREC.TAEDESC2 = TA5REC.TA5DATA; /* Subroutine parameters*/

  FFWREC.XXXMODID = "S01"; /* Module identification*/
  converseLib.validationFailed(10); /* Indicate system error*/

  TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  TA1REC.TA1TYPE = "APPL"; /* Type of error*/
  TA1REC.TA1LOC = "PURGE ANY TEMPORARY STORAGE";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FFWREC.XXXMODID; /* Program number*/
  TA1REC.TA1MAPAP = COMMAREA.CACURRAP; /* Map application*/
  TA1REC.TA1MAPNO = "M001"; /* Map number*/

  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end FG0MS01

// read temporary storage
Function FG0MS04()
   /* ------------------------------------------------------------*/
   /* Obtain the next page of data to display.*/
   /* ------------------------------------------------------------*/

  TA5REC.TA5APPID = COMMAREA.CACURRAP; /* Application identification*/
  FG0MW02.XXXTSLEN = FG0MW00.XXXTSLEN;
  TA5REC.TA5TSQIX = FG0MW00.XXXTSPAG; /* Page number*/
  TA5REC.TA5FNCCD = "R"; /* Function code*/

  try
    call "TA0050" (FG0MW02, TA5REC) {isNoRefresh = yes, isExternal = yes};
  end /* Temporary storage*/

   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && TA5REC.TA5RTNCD == 0)          /* and normal return code*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TAEREC.TAEDESC1 = sysVar.errorCode; /* CSP return code*/
  TAEREC.TAEDESC2 = TA5REC.TA5DATA; /* Subroutine parameters*/

  FFWREC.XXXMODID = "S04"; /* Module identification*/
  converseLib.validationFailed(10); /* Indicate system error*/

  TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  TA1REC.TA1TYPE = "APPL"; /* Type of error*/
  TA1REC.TA1LOC = "READ PAGE FROM TEMPORARY STORAGE";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FFWREC.XXXMODID; /* Program number*/
  TA1REC.TA1MAPAP = COMMAREA.CACURRAP; /* Map application*/
  TA1REC.TA1MAPNO = "M001"; /* Map number*/

  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end FG0MS04

// verify modifiable fields
Function FG0MS05()
   /* -----------------------------------------------------*/
   /* verify header modifiable fields*/
   /* -----------------------------------------------------*/

  if (converseVar.eventKey not enter)
    FG0MW00.FG0MWPIX = 1;
    while (FG0MW00.FG0MWPIX <= 4)
      if (FG0MM001.FG0MMSEM[FG0MWPIX] != FG0MW00.FG0MWSEM[FG0MWPIX])
        set FG0MM001.FG0MMSEM[FG0MWPIX] cursor, bold;
        converseLib.validationFailed(111);
        FFWREC.XXXMODID = "S05";
      end
      FG0MW00.FG0MWPIX = FG0MW00.FG0MWPIX + 1;
    end
  end

  if (FG0MM001.FFW-ND-SHP-IND != FFWREC.FFW-ND-SHP-IND)
    set FG0MM001.FFW-ND-SHP-IND cursor, bold;
    converseLib.validationFailed(10);
    FFWREC.XXXMODID = "S05";
  end

  if (FG0MM001.XPCCD != FFWREC.XPCCD)
    set FG0MM001.XPCCD cursor, bold;
    converseLib.validationFailed(130);
    FFWREC.XXXMODID = "S05";
  end

  if (FG0MM001.YPGCD != FFWREC.YPGCD)
    set FG0MM001.YPGCD cursor, bold;
    converseLib.validationFailed(130);
    FFWREC.XXXMODID = "S05";
  end

  FG0MW00.FG0MWWED = FFWREC.FFAENDMO;
  if (FG0MM001.FG0MMERG != FG0MW00.FG0MWEYM)
    set FG0MM001.FG0MMERG cursor, bold;
    converseLib.validationFailed(130);
    FFWREC.XXXMODID = "S05";
  end

  FG0MW00.FG0MWWBD = FFWREC.FFABEGMO;
  if (FG0MM001.FG0MMBRG != FG0MW00.FG0MWBYM)
    set FG0MM001.FG0MMBRG cursor, bold;
    converseLib.validationFailed(130);
    FFWREC.XXXMODID = "S05";
  end

end // end FG0MS05

// Load heading literals
Function FG0MS20()
   /* ------------------------------------------------------------*/
   /* load heading literals*/
   /* ------------------------------------------------------------*/

   /* subtotal*/

  FG0MM001.FG0MMHD1[7] = " SUB ";
  set FG0MM001.FG0MMHD1[7] skip;
  FG0MM001.FG0MMHD2[7] = "TOTAL";
  set FG0MM001.FG0MMHD2[7] skip;

   /* subtotal percent*/

  FG0MM001.FG0MMHD1[8] = "% OF ";
  set FG0MM001.FG0MMHD1[8] skip;
  FG0MM001.FG0MMHD2[8] = "TOTAL";
  set FG0MM001.FG0MMHD2[8] skip;

   /* range total*/

  FG0MM001.FG0MMHD1[9] = "RANGE";
  set FG0MM001.FG0MMHD1[9] skip;
  FG0MM001.FG0MMHD2[9] = "TOTAL";
  set FG0MM001.FG0MMHD2[9] skip;

   /* range total percent*/

  FG0MM001.FG0MMHD1[10] = "% FOR";
  set FG0MM001.FG0MMHD1[10] skip;
  FG0MM001.FG0MMHD2[10] = "R-TOT";
  set FG0MM001.FG0MMHD2[10] skip;

end // end FG0MS20

// Load subtotal and total
Function FG0MS30()
    /* ----------------------------------------------------------*/
     /* translate/load style grp subtotal*/
    /* ----------------------------------------------------------*/

  FFXREC.FFXNUMB = FG0MW00.FG0MWUST[FG0MWPIX];
  XSFFS10();
  FG0MW00.FG0MWWQT[7] = FFXREC.FFXCHAR;

  FG0MW00.FG0MWSTX[FG0MWPIX] = FG0MW00.FG0MWLIX;
                                   /* Save subtot pos.*/
  FG0MW00.FG0MWSTQ[FG0MWPIX] = FG0MW00.FG0MWUST[FG0MWPIX]; /* Save subtot qty*/

    /* ----------------------------------------------------------*/
     /* load style group range total*/
    /* ----------------------------------------------------------*/

  FG0MW00.FG0MWWQT[9] = FG0MW00.FG0MWQTY[FG0MWTIX];

    /* ----------------------------------------------------------*/
     /* calculate/load style grp range total percent*/
    /* ----------------------------------------------------------*/

  if (FG0MW03.FG0MWUMT[FG0MWTIX] != 0)
    FG0MW00.FG0MWNM1 = FG0MW00.FG0MWUQT[FG0MWTIX] * 100;
    FG0MW00.FG0MWNPT = mathLib.round(FG0MW00.FG0MWNM1 / FG0MW03.FG0MWUMT[FG0MWTIX], -mathLib.decimals(FG0MW00.FG0MWNPT));

      /* --------------------------------------------------------*/
       /* zero suppress the percent field*/
      /* --------------------------------------------------------*/

    if (FG0MW00.FG0MWNPT != 0)
      if (FG0MW00.FG0MWNPT < 0) /* percent is negative*/
        FG0MW00.FG0MWNPT = FG0MW00.FG0MWNPT * -1;
      end

      FG0MW00.FG0MWPTW = FG0MW00.FG0MWNP1;
      FG0MW00.FG0MWPTP = ".";
      FG0MW00.FG0MWPTD = FG0MW00.FG0MWNP2;

      if (FG0MW00.FG0MWPT1 == "0")
        FG0MW00.FG0MWPT1 = " ";
        if (FG0MW00.FG0MWPT2 == "0")
          FG0MW00.FG0MWPT2 = " ";
        end
      end

      if (FG0MW03.FG0MWUMT[FG0MWTIX] < 0
       && FG0MW00.FG0MWUQT[FG0MWTIX] < 0)

        /* both quantities are negative; positive percent*/

      else /* one or the other qty are negative*/
        if (FG0MW03.FG0MWUMT[FG0MWTIX] < 0
         || FG0MW00.FG0MWUQT[FG0MWTIX] < 0)

          if (FG0MW00.FG0MWNPT > 99.9) /* reformat pct w/o fraction*/
            FG0MW00.FG0MWPTD = FG0MW00.FG0MWPT3;
            FG0MW00.FG0MWPTP = FG0MW00.FG0MWPT2;
            FG0MW00.FG0MWPT3 = FG0MW00.FG0MWPT1;
            FG0MW00.FG0MWPT2 = "-";
            FG0MW00.FG0MWPT1 = " ";
          else /* percent < or = -99.9*/
            if (FG0MW00.FG0MWPT2 == " ")
              FG0MW00.FG0MWPT2 = "-";
            else
              if (FG0MW00.FG0MWPT1 == " ")
                FG0MW00.FG0MWPT1 = "-";
              end
            end
          end
        end
      end

      FG0MW00.FG0MWWQT[10] = FG0MW00.FG0MWPCT;
      FG0MW00.FG0MWNPT = 0; /* Clear percent*/
      FG0MW00.FG0MWPCT = 0; /* Clear percent*/

    end
  end

end // end FG0MS30

// Cal no of sesn and mos in sesn
Function FG0MS33()

   /* ------------------------------------------------------------*/
   /* validate season end months*/
   /* ------------------------------------------------------------*/

  FG0MW00.FG0MWWBD = FFWREC.FFABEGMO; /* beginning date*/
  FG0MW00.FG0MWWED = FFWREC.FFAENDMO; /* ending date*/

  FG0MW00.FG0MWSMO[1] = FFWREC.FFWENDM1;
  FG0MW00.FG0MWWDT = FFWREC.FFWENDM1;
  FG0MW00.FG0MWSEM[1] = FG0MW00.FG0MWWMM;

  FG0MW00.FG0MWSMO[2] = FFWREC.FFWENDM2;
  FG0MW00.FG0MWWDT = FFWREC.FFWENDM2;
  FG0MW00.FG0MWSEM[2] = FG0MW00.FG0MWWMM;

  FG0MW00.FG0MWSMO[3] = FFWREC.FFWENDM3;
  FG0MW00.FG0MWWDT = FFWREC.FFWENDM3;
  FG0MW00.FG0MWSEM[3] = FG0MW00.FG0MWWMM;

  FG0MW00.FG0MWSMO[4] = FFWREC.FFWENDM4;
  FG0MW00.FG0MWWDT = FFWREC.FFWENDM4;
  FG0MW00.FG0MWSEM[4] = FG0MW00.FG0MWWMM;

   /* figure out number of seasons*/

  FG0MW00.FG0MWPIX = 4; /* index*/
  while (FG0MW00.FG0MWPIX > 0)

    FG0MW00.FG0MWSIN[FG0MWPIX] = 0;

    FG0MW00.FG0MWPIX = FG0MW00.FG0MWPIX - 1;
    /*  */
  end

  FG0MW00.FG0MWNSS = 0; /* reset number of seasons*/
  FG0MW00.FG0MWPIX = 4; /* index*/
  while (FG0MW00.FG0MWPIX > 0)
    if (FG0MW00.FG0MWSEM[FG0MWPIX] > 0)
      FG0MW00.FG0MWNSS = FG0MW00.FG0MWPIX; /* number of seasons*/
      FG0MW00.FG0MWPIX = FG0MW00.FG0MWPIX - 4; /* force out of loop*/

    else

      FG0MW00.FG0MWPIX = FG0MW00.FG0MWPIX - 1;
    end

  end

  FG0MW00.FG0MWPIX = FG0MW00.FG0MWNSS;
  while (FG0MW00.FG0MWPIX > 0) /* nbr of seasons*/
    FG0MS80(); /* calculate no of mos in each sesn*/
    FG0MW00.FG0MWPIX = FG0MW00.FG0MWPIX - 1;
  end


end // end FG0MS33

// Load subtot & tot for tot line
Function FG0MS40()

   /* ----------------------------------------------------------*/
   /* translate/load style grp monthly subtotal/total*/
   /* ----------------------------------------------------------*/

  FFXREC.FFXNUMB = FG0MW00.FG0MWUMT;
  XSFFS10();
  FG0MW00.FG0MWWQT[7] = FFXREC.FFXCHAR;

   /* ----------------------------------------------------------*/
   /* calculate/load style grp subtotal percent*/
   /* ----------------------------------------------------------*/

  FG0MW00.FG0MWNPT = 0; /* Clear percent*/
  FG0MW00.FG0MWPCT = 0; /* Clear percent*/

  if (FG0MW00.FG0MWUMT != 0)
    FG0MW00.FG0MWNM1 = FG0MW00.FG0MWUMT * 100;
    FG0MW00.FG0MWNPT = mathLib.round(FG0MW00.FG0MWNM1 / FG0MW00.FG0MWUMT, -mathLib.decimals(FG0MW00.FG0MWNPT));

    /* --------------------------------------------------------*/
    /* Zero suppress the percent field*/
    /* Will never have a negative percent; quantity is divided*/
    /* by itself.*/
    /* --------------------------------------------------------*/

    if (FG0MW00.FG0MWNPT != 0)

      FG0MW00.FG0MWPTW = FG0MW00.FG0MWNP1;
      FG0MW00.FG0MWPTP = ".";
      FG0MW00.FG0MWPTD = FG0MW00.FG0MWNP2;

      if (FG0MW00.FG0MWPT1 == "0")
        FG0MW00.FG0MWPT1 = " ";
        if (FG0MW00.FG0MWPT2 == "0")
          FG0MW00.FG0MWPT2 = " ";
        end
      end

      FG0MW00.FG0MWWQT[8] = FG0MW00.FG0MWPCT;
      FG0MW00.FG0MWNPT = 0; /* Clear percent*/
      FG0MW00.FG0MWPCT = 0; /* Clear percent*/

    end
  end

   /* ----------------------------------------------------------*/
   /* calculate/load style grp subtotal percent*/
   /* ----------------------------------------------------------*/

  FG0MW00.FG0MWPIX = 1; /* Init process index*/
  FG0MW00.FG0MWNPT = 0; /* Clear percent*/
  FG0MW00.FG0MWPCT = 0; /* Clear percent*/

  while (FG0MW00.FG0MWPIX <= FG0MW02.FG0MWNLD)

    if (FG0MW00.FG0MWUMT != 0)
      FG0MW00.FG0MWNM1 = FG0MW00.FG0MWSTQ[FG0MWPIX] * 100;
      FG0MW00.FG0MWNPT = mathLib.round(FG0MW00.FG0MWNM1 / FG0MW00.FG0MWUMT, -mathLib.decimals(FG0MW00.FG0MWNPT));

      /* --------------------------------------------------------*/
       /* zero suppress the percent field*/
      /* --------------------------------------------------------*/

      if (FG0MW00.FG0MWNPT != 0)
        if (FG0MW00.FG0MWNPT < 0)
          FG0MW00.FG0MWNPT = FG0MW00.FG0MWNPT * -1; /* percent is negative*/
        end

        FG0MW00.FG0MWPTW = FG0MW00.FG0MWNP1;
        FG0MW00.FG0MWPTP = ".";
        FG0MW00.FG0MWPTD = FG0MW00.FG0MWNP2;

        if (FG0MW00.FG0MWPT1 == "0")
          FG0MW00.FG0MWPT1 = " ";
          if (FG0MW00.FG0MWPT2 == "0")
            FG0MW00.FG0MWPT2 = " ";
          end
        end

        if (FG0MW00.FG0MWUMT < 0
         && FG0MW00.FG0MWSTQ[FG0MWPIX] < 0)

          /* both quantities are negative; positive percent*/

        else /* one or the other qty are negative*/
          if (FG0MW00.FG0MWUMT < 0
           || FG0MW00.FG0MWSTQ[FG0MWPIX] < 0)

            if (FG0MW00.FG0MWNPT > 99.9)
              FG0MW00.FG0MWPTD = FG0MW00.FG0MWPT3;
              FG0MW00.FG0MWPTP = FG0MW00.FG0MWPT2;
              FG0MW00.FG0MWPT3 = FG0MW00.FG0MWPT1;
              FG0MW00.FG0MWPT2 = "-";
              FG0MW00.FG0MWPT1 = " ";
            else /* percent < or = -99.9*/
              if (FG0MW00.FG0MWPT2 == " ")
                FG0MW00.FG0MWPT2 = "-";
              else
                if (FG0MW00.FG0MWPT1 == " ")
                  FG0MW00.FG0MWPT1 = "-";
                end
              end
            end
          end
        end

        FG0MM001.FG0MMQ08[FG0MWPIX] = FG0MW00.FG0MWPCT;

      end
    end

    FG0MW00.FG0MWPIX = FG0MW00.FG0MWPIX + 1;

  end

  move 0 to FG0MW00.FG0MWSTX[1] for all; /* Clear subtot col position*/
  move 0 to FG0MW00.FG0MWSTQ[1] for all; /* Clear subtot qty*/
  FG0MW00.FG0MWNPT = 0; /* Clear percent*/
  FG0MW00.FG0MWPCT = 0; /* Clear percent*/

   /* --------------------------------------------------------*/
   /* load style grp monthly range total*/
   /* --------------------------------------------------------*/

  FG0MW00.FG0MWWQT[9] = FG0MW03.FG0MWMTQ[FG0MWTIX];

end // end FG0MS40

// Load subtot for pct line
Function FG0MS50()
   /* ----------------------------------------------------------*/
   /* calculate/load style grp monthly total percent*/
   /* ----------------------------------------------------------*/

  if (FG0MW03.FG0MWUMT[FG0MWTIX] != 0)
    FG0MW00.FG0MWNM1 = FG0MW00.FG0MWUMT * 100;
    FG0MW00.FG0MWNPT = mathLib.round(FG0MW00.FG0MWNM1 / FG0MW03.FG0MWUMT[FG0MWTIX], -mathLib.decimals(FG0MW00.FG0MWNPT));

    /* ----------------------------------------------------------*/
    /* Zero suppress the percent field*/
    /* ----------------------------------------------------------*/

    if (FG0MW00.FG0MWNPT != 0)
      if (FG0MW00.FG0MWNPT < 0) /* percent is negative*/
        FG0MW00.FG0MWNPT = FG0MW00.FG0MWNPT * -1;
      end

      FG0MW00.FG0MWPTW = FG0MW00.FG0MWNP1;
      FG0MW00.FG0MWPTP = ".";
      FG0MW00.FG0MWPTD = FG0MW00.FG0MWNP2;

      if (FG0MW00.FG0MWPT1 == "0")
        FG0MW00.FG0MWPT1 = " ";
        if (FG0MW00.FG0MWPT2 == "0")
          FG0MW00.FG0MWPT2 = " ";
        end
      end

      if (FG0MW03.FG0MWUMT[FG0MWTIX] < 0
       && FG0MW00.FG0MWUMT < 0)

        /* both quantities are negative; positive percent*/

      else /* one or the other qty are negative*/
        if (FG0MW03.FG0MWUMT[FG0MWTIX] < 0
         || FG0MW00.FG0MWUMT < 0)

          if (FG0MW00.FG0MWNPT > 99.9) /* reformat pct w/o fraction*/
            FG0MW00.FG0MWPTD = FG0MW00.FG0MWPT3;
            FG0MW00.FG0MWPTP = FG0MW00.FG0MWPT2;
            FG0MW00.FG0MWPT3 = FG0MW00.FG0MWPT1;
            FG0MW00.FG0MWPT2 = "-";
            FG0MW00.FG0MWPT1 = " ";
          else
            if (FG0MW00.FG0MWPT2 == " ")
              FG0MW00.FG0MWPT2 = "-";
            else
              if (FG0MW00.FG0MWPT1 == " ")
                FG0MW00.FG0MWPT1 = "-";
              end
            end
          end
        end
      end

      FG0MW00.FG0MWWQT[7] = FG0MW00.FG0MWPCT;

    end
  end

end // end FG0MS50

// Obtain default seasn end month
Function FG0MS60()
  if (FFZREC.FFZNUMMO == 12) /* check if 12 months in the reqstd range*/

    FG0MS61(); /* obtain season begin month*/
    FG0MW00.FG0MWWDT = FF2REC.FF2SEASN[1]; /* season begin month*/

    if (FG0MW00.FG0MWBYM == FG0MW00.FG0MWWYM) /* begin month yymm match*/

      FG0MS62(); /* calculate season end month*/

    else
      if (FG0MW00.FG0MWBMM == FG0MW00.FG0MWWMM) /* begin month mm match*/

        FG0MS64(); /* calculate season end mo*/

      end
    end
  end

end // end FG0MS60

// Obtain sesn beg mo from FFXRF
Function FG0MS61()
   /* ------------------------------------------------------------*/
   /* Select set on dfcast.vffxrf01 table.*/
   /* ------------------------------------------------------------*/

   /* ------------------------------------------------------------*/
   /* load ff2rec record - dfcast.vffxrf01*/
   /* ------------------------------------------------------------*/

  set FF2REC empty; /* Clear row storage area*/

  FF2REC.YSMXDV = "10"; /* div grp code*/
  FF2REC.YPGCD = FFWREC.YPGCD; /* product type group*/
  FF2REC.XPCCD = FG0MM001.XPCCD; /* product category*/

   /* ------------------------------------------------------------*/
   /* select set dfcast.vffxrf01*/
   /* ------------------------------------------------------------*/

  try
    call "IO4000" ("S ", SQLCA, FF2REC) {isNoRefresh = yes, isExternal = yes};
  end /* Select set*/

   /* ------------------------------------------------------------*/
   /* If successful return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* Normal return code*/

    return;

  end
   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL Commarea*/

  FFWREC.XXXMODID = "S61"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(47); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(1); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    converseLib.clearScreen();
     /* Clear screen before display*/

  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "SELECT S2 ON DFCAST.VFFXRF01";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FFWREC.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFCAST  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VFFXRF01"; /* Table view name*/
  TA1REC.TA1TBLKE = FF2REC.FF2KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/

end // end FG0MS61

// Calc sesn end mo for same year
Function FG0MS62()

   /* --------------------------------------*/
   /* calculate no of season*/
   /* --------------------------------------*/

  FG0MW00.FG0MWPIX = 4;

  while (FG0MW00.FG0MWPIX > 0)

    if (FF2REC.FF2SEASN[FG0MWPIX] == 0)
      FG0MW00.FG0MWPIX = FG0MW00.FG0MWPIX - 1;
    else
      FG0MW00.FG0MWSMO[FG0MWPIX] = FG0MW00.FG0MWEYM; /* sesn end mo*/
      FG0MM001.FG0MMSEM[FG0MWPIX] = FG0MW00.FG0MWEMM;
      FG0MW00.FG0MWNSS = FG0MW00.FG0MWPIX; /* no. of seasons*/
      FG0MW00.FG0MWPIX = 0; /* force out the loop*/
    end

  end

   /* --------------------------------------*/
   /* calculate season end month*/
   /* --------------------------------------*/

  FG0MW00.FG0MWPIX = FG0MW00.FG0MWNSS;

  while (FG0MW00.FG0MWPIX > 1)

    FG0MW00.FG0MW-WDT1 = FF2REC.FF2SEASN[FG0MWPIX];
    FG0MS63(); /* get end month of the season*/
    FG0MW00.FG0MWSIX = FG0MW00.FG0MWPIX - 1;
    FG0MW00.FG0MWSMO[FG0MWSIX] = FG0MW00.FG0MW-WDT1;
    FG0MM001.FG0MMSEM[FG0MWSIX] = FG0MW00.FG0MW-WMM1;
    FG0MW00.FG0MWPIX = FG0MW00.FG0MWPIX - 1;

  end
end // end FG0MS62

// Get end mo of the sesn-same yr
Function FG0MS63()
  if (FG0MW00.FG0MW-WMM1 == 1)
    FG0MW00.FG0MW-WMM1 = 12;
    if (FG0MW00.FG0MW-WYY1 == 0)
      FG0MW00.FG0MW-WYY1 = 99;
      FG0MW00.FG0MW-WCC1 = FG0MW-WCC1 - 1;
    else
      FG0MW00.FG0MW-WYY1 = FG0MW00.FG0MW-WYY1 - 1;
    end
  else
    FG0MW00.FG0MW-WMM1 = FG0MW00.FG0MW-WMM1 - 1;
  end
end // end FG0MS63

// Calc sesn end mo for diff year
Function FG0MS64()

   /* --------------------------------------*/
   /* calculate no of season*/
   /* --------------------------------------*/

  FG0MW00.FG0MWPIX = 4;

  while (FG0MW00.FG0MWPIX > 0)

    if (FF2REC.FF2SEASN[FG0MWPIX] == 0)
      FG0MW00.FG0MWPIX = FG0MW00.FG0MWPIX - 1;
    else
      FG0MW00.FG0MWSMO[FG0MWPIX] = FG0MW00.FG0MWEYM; /* sesn end mo*/
      FG0MM001.FG0MMSEM[FG0MWPIX] = FG0MW00.FG0MWEMM;
      FG0MW00.FG0MWNSS = FG0MW00.FG0MWPIX; /* no. of seasons*/
      FG0MW00.FG0MWPIX = 0; /* force out the loop*/
    end

  end

   /* --------------------------------------*/
   /* calculate season end month*/
   /* --------------------------------------*/

  FG0MW00.FG0MWPIX = FG0MW00.FG0MWNSS;

  while (FG0MW00.FG0MWPIX > 1)

    FG0MW00.FG0MW-WDT1 = FF2REC.FF2SEASN[FG0MWPIX];
    FG0MS65(); /* get end month of the season*/
    FG0MW00.FG0MWSIX = FG0MW00.FG0MWPIX - 1;
    FG0MW00.FG0MWSMO[FG0MWSIX] = FG0MW00.FG0MW-WDT1;
    FG0MM001.FG0MMSEM[FG0MWSIX] = FG0MW00.FG0MW-WMM1;
    FG0MW00.FG0MWPIX = FG0MW00.FG0MWPIX - 1;

  end
end // end FG0MS64

// Get end mo of the sesn-diff yr
Function FG0MS65()
   /* -------------------------------------------------------------------*/
   /* Plug in the ccyy from requested range and use the same month from*/
   /* the dfcast.vffxrf01 table.*/
   /* -------------------------------------------------------------------*/

  if (FG0MW00.FG0MWBMM <= FG0MW00.FG0MW-WMM1) /* same year*/

    FG0MW00.FG0MW-WYY1 = FG0MW00.FG0MWBYY; /* year*/
    FG0MW00.FG0MW-WCC1 = FG0MW00.FG0MWBCC; /* century*/

  else /* different year*/

    if (FG0MW00.FG0MWBYY == 99)
      FG0MW00.FG0MW-WYY1 = 0; /* year*/
      FG0MW00.FG0MW-WCC1 = FG0MW00.FG0MWBCC + 1; /* century*/
    else
      FG0MW00.FG0MW-WYY1 = FG0MW00.FG0MWBYY + 1; /* year*/
      FG0MW00.FG0MW-WCC1 = FG0MW00.FG0MWBCC; /* century*/
    end

  end

  if (FG0MW00.FG0MW-WMM1 == 1)
    FG0MW00.FG0MW-WMM1 = 12;
    if (FG0MW00.FG0MW-WYY1 == 0)
      FG0MW00.FG0MW-WYY1 = 99;
      FG0MW00.FG0MW-WCC1 = FG0MW-WCC1 - 1;
    else
      FG0MW00.FG0MW-WYY1 = FG0MW00.FG0MW-WYY1 - 1;
    end
  else
    FG0MW00.FG0MW-WMM1 = FG0MW00.FG0MW-WMM1 - 1;
  end
end // end FG0MS65

// Verify entered end month
Function FG0MS70()

   /* --------------------------------------------------------*/
   /* beginning date and ending date are in the same year*/
   /* --------------------------------------------------------*/

  if (FG0MW00.FG0MWBYY == FG0MW00.FG0MWEYY) /* beg year = end year*/

    if (FG0MM001.FG0MMSEM[FG0MWPIX] >= FG0MW00.FG0MWBMM /* >= beg month*/
     && FG0MM001.FG0MMSEM[FG0MWPIX] <= FG0MW00.FG0MWEMM) /* <= end month*/

      FG0MW00.FG0MWWCC = FG0MW00.FG0MWBCC; /* plug in centry*/
      FG0MW00.FG0MWWYY = FG0MW00.FG0MWBYY; /* plug in year*/
      FG0MW00.FG0MWWMM = FG0MM001.FG0MMSEM[FG0MWPIX]; /* plug in month*/

    else

      FFWREC.XXXMODID = "S70"; /* module identification*/
      converseLib.validationFailed(010); /* invalid data*/
      set FG0MM001.FG0MMSEM[FG0MWPIX] cursor, bold;

    end

  else

      /* --------------------------------------------------------*/
      /* beginning date and ending date are in the different years*/
      /* --------------------------------------------------------*/

      /* season end month falls in the same year as begin month*/

    if (FG0MM001.FG0MMSEM[FG0MWPIX] >= FG0MW00.FG0MWBMM) /* >= beg mo*/

      FG0MW00.FG0MWWCC = FG0MW00.FG0MWBCC; /* plug in centry*/
      FG0MW00.FG0MWWYY = FG0MW00.FG0MWBYY; /* plug in year*/
      FG0MW00.FG0MWWMM = FG0MM001.FG0MMSEM[FG0MWPIX]; /* plug in month*/
    else

        /* * season end month falls in the same year as end month*/

      if (FG0MM001.FG0MMSEM[FG0MWPIX] <= FG0MW00.FG0MWEMM) /* <= end mo*/
        FG0MW00.FG0MWWCC = FG0MW00.FG0MWECC; /* plug in centry*/
        FG0MW00.FG0MWWYY = FG0MW00.FG0MWEYY; /* plug in year*/
        FG0MW00.FG0MWWMM = FG0MM001.FG0MMSEM[FG0MWPIX]; /* plug in month*/
      else

        FFWREC.XXXMODID = "S70"; /* module identification*/
        converseLib.validationFailed(010); /* invalid data*/
        set FG0MM001.FG0MMSEM[FG0MWPIX] cursor, bold;

      end

    end

  end

  if (converseVar.validationMsgNum == 0)
    FG0MW00.FG0MWSMO[FG0MWPIX] = FG0MW00.FG0MWWDT; /* save ccyymm*/
  end

end // end FG0MS70

// Calculate no of mos in season
Function FG0MS80()
  FG0MW00.FG0MWWDT = FG0MW00.FG0MWSMO[FG0MWPIX]; /* sesn end mo*/

  if (FG0MW00.FG0MWPIX == 1) /* 1st season*/

    if (FG0MW00.FG0MWWMM >= FG0MW00.FG0MWBMM) /* in the same year*/
      FG0MW00.FG0MWSIN[FG0MWPIX] = FG0MW00.FG0MWWDT -                                    FG0MW00.FG0MWWBD + 1;
    else /* in the different year*/
      FG0MW00.FG0MWSIN[FG0MWPIX] = FG0MW00.FG0MWWMM + 12 -                                    FG0MW00.FG0MWBMM + 1;
    end

  else /* other season*/

    FG0MW00.FG0MWLIX = FG0MW00.FG0MWPIX - 1;
    FG0MW00.FG0MW-WDT1 = FG0MW00.FG0MWSMO[FG0MWLIX]; /* prev sesn mo*/
    if (FG0MW00.FG0MWWMM > FG0MW00.FG0MW-WMM1) /* in the same year*/
      FG0MW00.FG0MWSIN[FG0MWPIX] = FG0MW00.FG0MWWMM - FG0MW00.FG0MW-WMM1;
    else /* in the different year*/
      FG0MW00.FG0MWSIN[FG0MWPIX] = FG0MW00.FG0MWWMM + 12 -                                    FG0MW00.FG0MW-WMM1;
    end

  end

end // end FG0MS80

//*** RECORD=FG0MW00 ****
// ----------------------------
// Application working storage.
// ----------------------------
// ***********************
Record FG0MW00 type basicRecord
  10 FG0MWNSS FG0MWNSS ; 
  10 FG0MWSIN FG0MWSIN [4] ; 
  10 FG0MWSEM FG0MWSEM [4] ; 
  10 FG0MWSMO FG0MWSMO [4] ; 
  10 FG0MWSWR FG0MWSWR ; 
  10 FG0MWSWF FG0MWSWF ; 
  10 FG0MWGRP FG0MWGRP ; 
  10 FG0MWSWD FG0MWSWD ; 
  10 FG0MWNM1 FG0MWNM1 ; 
  10 FG0MWNM2 FG0MWNM2 ; 
  10 FG0MWNPT FG0MWNPT ; 
    15 FG0MWNP1 FG0MWNP1 ; 
    15 FG0MWNP2 FG0MWNP2 ; 
  10 FG0MWPCT FG0MWPCT ; 
    15 FG0MWPTW FG0MWPTW ; 
      20 FG0MWPT1 FG0MWPT1 ; 
      20 FG0MWPT2 FG0MWPT2 ; 
      20 FG0MWPT3 FG0MWPT3 ; 
    15 FG0MWPTP FG0MWPTP ; 
    15 FG0MWPTD FG0MWPTD ; 
  10 FG0MWUTQ FG0MWUTQ ; 
  10 FG0MWUMT FG0MWUMT ; 
  10 FG0MWUST FG0MWUST [13] ; 
  10 FG0MWUHS FG0MWUHS ; 
  10 FG0MWWQT FG0MWWQT [10] ; 
  10 FG0MWLQT FG0MWLQT ; 
    15 FG0MWUQT FG0MWUQT [13] ; 
    15 FG0MWQTY FG0MWQTY [13] ; 
  10 FG0MWSTX FG0MWSTX [15] ; 
  10 FG0MWSTQ FG0MWSTQ [15] ; 
  10 FG0MWIDX FG0MWIDX ; 
  10 FG0MWTIX FG0MWTIX ; 
  10 FG0MWSIX FG0MWSIX ; 
  10 FG0MWLIX FG0MWLIX ; 
  10 FG0MWPIX FG0MWPIX ; 
  10 FG0MWPGX FG0MWPGX ; 
  10 FG0MWSNX FG0MWSNX ; 
  10 FG0MWCWD FG0MWCWD ; 
    15 FG0MWCYM FG0MWCYM ; 
      20 FG0MWCCC FG0MWCCC ; 
      20 FG0MWCYY FG0MWCYY ; 
      20 FG0MWCMM FG0MWCMM ; 
    15 FG0MWCDD FG0MWCDD ; 
  10 FG0MWWDT FG0MWWDT ; 
    15 * num(3) ; 
    15 FG0MWWCC FG0MWWCC ; 
    15 FG0MWWYM FG0MWWYM ; 
      20 FG0MWWYY FG0MWWYY ; 
      20 FG0MWWMM FG0MWWMM ; 
  10 FG0MW-WDT1 FG0MW-WDT1 ; 
    15 * num(3) ; 
    15 FG0MW-WCC1 FG0MW-WCC1 ; 
    15 FG0MW-WYM1 FG0MW-WYM1 ; 
      20 FG0MW-WYY1 FG0MW-WYY1 ; 
      20 FG0MW-WMM1 FG0MW-WMM1 ; 
  10 FG0MWWBD FG0MWWBD ; 
    15 * num(3) ; 
    15 FG0MWBCC FG0MWBCC ; 
    15 FG0MWBYM FG0MWBYM ; 
      20 FG0MWBYY FG0MWBYY ; 
      20 FG0MWBMM FG0MWBMM ; 
  10 FG0MWWED FG0MWWED ; 
    15 * num(3) ; 
    15 FG0MWECC FG0MWECC ; 
    15 FG0MWEYM FG0MWEYM ; 
      20 FG0MWEYY FG0MWEYY ; 
      20 FG0MWEMM FG0MWEMM ; 
  10 FG0MW-CURR-MO FG0MW-CURR-MO ; 
  10 FG0MW-CURR-MO-MINUS1 FG0MW-CURR-MO-MINUS1 ; 
  10 FG0MW-CURR-MO-MINUS2 FG0MW-CURR-MO-MINUS2 ; 
  10 FG0MW-CURR-MO-MINUS3 FG0MW-CURR-MO-MINUS3 ; 
  10 FG0MW-CURR-MO-MINUS4 FG0MW-CURR-MO-MINUS4 ; 
  10 XXXTSLEN XXXTSLEN ; 
  10 XXXTSPAG XXXTSPAG ; 
  10 TA5TSQIX TA5TSQIX ; 
  10 FG0MW-PAGP FG0MW-PAGP [10] ; 
  10 FG0MW-PAGS FG0MW-PAGS [10] ; 
  10 FG0MW-PMON FG0MW-PMON [10] ; 
  10 FG0MWREM FG0MWREM ; 
  10 FG0MW-NEXT FG0MW-NEXT ; 
  10 FFW-ND-SHP-IND FFW-ND-SHP-IND ; 
end // end FG0MW00

//*** RECORD=FG0MW01 ****
// ------------------------
// Map 001 display storage
// ------------------------
// ***********************
Record FG0MW01 type basicRecord
  10 CACHGFL CACHGFL ; 
end // end FG0MW01

//*** RECORD=FG0MW02 ****
// -------------------------
// map 001 temporary storage
// -------------------------
// ***********************
Record FG0MW02 type basicRecord
  5 XXXTSLEN XXXTSLEN ; 
  5 * char(2027) ; 
    10 FG0MWNLD FG0MWNLD ; 
    10 SYBSTGNB SYBSTGNB [15] ; 
    10 SYBSTGNM SYBSTGNM [15] ; 
    10 FG0MWQTS FG0MWQTS [15] ; 
      15 FG0MWU01 FG0MWU01 ; 
      15 FG0MWQ01 FG0MWQ01 ; 
      15 FG0MWU02 FG0MWU02 ; 
      15 FG0MWQ02 FG0MWQ02 ; 
      15 FG0MWU03 FG0MWU03 ; 
      15 FG0MWQ03 FG0MWQ03 ; 
      15 FG0MWU04 FG0MWU04 ; 
      15 FG0MWQ04 FG0MWQ04 ; 
      15 FG0MWU05 FG0MWU05 ; 
      15 FG0MWQ05 FG0MWQ05 ; 
      15 FG0MWU06 FG0MWU06 ; 
      15 FG0MWQ06 FG0MWQ06 ; 
      15 FG0MWU07 FG0MWU07 ; 
      15 FG0MWQ07 FG0MWQ07 ; 
      15 FG0MWU08 FG0MWU08 ; 
      15 FG0MWQ08 FG0MWQ08 ; 
      15 FG0MWU09 FG0MWU09 ; 
      15 FG0MWQ09 FG0MWQ09 ; 
      15 FG0MWU10 FG0MWU10 ; 
      15 FG0MWQ10 FG0MWQ10 ; 
      15 FG0MWU11 FG0MWU11 ; 
      15 FG0MWQ11 FG0MWQ11 ; 
      15 FG0MWU12 FG0MWU12 ; 
      15 FG0MWQ12 FG0MWQ12 ; 
      15 FG0MWU13 FG0MWU13 ; 
      15 FG0MWQ13 FG0MWQ13 ; 
end // end FG0MW02

//*** RECORD=FG0MW03 ****
// ------------------------------
// map 001 totals display storage
// ------------------------------
// ***********************
Record FG0MW03 type basicRecord
  5 FG0MWGP3 FG0MWGP3 ; 
    10 FG0MWUMT FG0MWUMT [13] ; 
    10 FG0MWMTQ FG0MWMTQ [13] ; 
    10 FG0MWMPT FG0MWMPT [13] ; 
end // end FG0MW03

// current month
DataItem FG0MW-CURR-MO int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// current month minus 1 month
DataItem FG0MW-CURR-MO-MINUS1 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// current month minus 2 months
DataItem FG0MW-CURR-MO-MINUS2 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// current month minus 3 months
DataItem FG0MW-CURR-MO-MINUS3 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// current month minus 4 months
DataItem FG0MW-CURR-MO-MINUS4 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Next season flag
DataItem FG0MW-NEXT char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Starting point of the page
DataItem FG0MW-PAGP num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Processing season of the page
DataItem FG0MW-PAGS num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Print remaining month flag
DataItem FG0MW-PMON char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// work century
DataItem FG0MW-WCC1 num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// work date
DataItem FG0MW-WDT1 num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = "0", dateFormat = "yy-MM-dd", inputRequired = no
}
end

// work month
DataItem FG0MW-WMM1 num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// work year and month
DataItem FG0MW-WYM1 num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// work year
DataItem FG0MW-WYY1 num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// begin century
DataItem FG0MWBCC num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// begin range month
DataItem FG0MWBMM num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// begin year and month
DataItem FG0MWBYM num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// begin range year
DataItem FG0MWBYY num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// current work century
DataItem FG0MWCCC num(3)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// current work day
DataItem FG0MWCDD num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// current work month
DataItem FG0MWCMM num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// current work ccyymmdd
DataItem FG0MWCWD num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = "0", dateFormat = "yy-MM-dd", inputRequired = no
}
end

// current work ccyymm
DataItem FG0MWCYM num(7)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// current work year
DataItem FG0MWCYY num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// end century
DataItem FG0MWECC num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// end range month
DataItem FG0MWEMM num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// end year and month
DataItem FG0MWEYM num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// end range year
DataItem FG0MWEYY num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// fg0mw03 group level
DataItem FG0MWGP3 char(169)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// style group active flag
DataItem FG0MWGRP char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// index
DataItem FG0MWIDX num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// load  index
DataItem FG0MWLIX num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// product line qtys
DataItem FG0MWLQT char(117)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// monthly percent
DataItem FG0MWMPT bin(9,1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// monthly sale qtys
DataItem FG0MWMTQ char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// number of lines per page
DataItem FG0MWNLD smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// numeric work field 1
DataItem FG0MWNM1 num(15)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// numeric work field 2
DataItem FG0MWNM2 num(15)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

DataItem FG0MWNP1 num(3)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

DataItem FG0MWNP2 num(1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// numeric percent field
DataItem FG0MWNPT num(4,1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// no of seasons
DataItem FG0MWNSS num(1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// char percent field
DataItem FG0MWPCT char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// page index
DataItem FG0MWPGX num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// process index
DataItem FG0MWPIX num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

DataItem FG0MWPT1 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem FG0MWPT2 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem FG0MWPT3 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem FG0MWPTD char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem FG0MWPTP char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem FG0MWPTW char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// fcst qty char column 1
DataItem FG0MWQ01 char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// fcst qty char column 2
DataItem FG0MWQ02 char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// fcst qty char column 3
DataItem FG0MWQ03 char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// fcst qty char column 4
DataItem FG0MWQ04 char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// fcst qty char column 5
DataItem FG0MWQ05 char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// fcst qty char column 6
DataItem FG0MWQ06 char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// fcst qty char column 7
DataItem FG0MWQ07 char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// fcst qty char column 8
DataItem FG0MWQ08 char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// fcst qty char column 9
DataItem FG0MWQ09 char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// fcst qty char column 10
DataItem FG0MWQ10 char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// fcst qty char column 11
DataItem FG0MWQ11 char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// fcst qty char column 12
DataItem FG0MWQ12 char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// fcst qty char column 13
DataItem FG0MWQ13 char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// product line monthly qtys
DataItem FG0MWQTS char(117)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// sale qty 1000
DataItem FG0MWQTY char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Remaining month
DataItem FG0MWREM num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// season end month - mm
DataItem FG0MWSEM num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// nbr of months in season
DataItem FG0MWSIN num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// save index
DataItem FG0MWSIX num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// season end month - ccyymm
DataItem FG0MWSMO num(6)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// season index
DataItem FG0MWSNX num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// subtotal qty
DataItem FG0MWSTQ int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// subtotal col posititon
DataItem FG0MWSTX num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// display map switch
DataItem FG0MWSWD char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Format the map switch
DataItem FG0MWSWF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Request for data switch
DataItem FG0MWSWR char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// total index
DataItem FG0MWTIX num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// fcst qty units column 1
DataItem FG0MWU01 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// fcst qty units column 2
DataItem FG0MWU02 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// fcst qty units column 3
DataItem FG0MWU03 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// fcst qty units column 4
DataItem FG0MWU04 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// fcst qty units column 5
DataItem FG0MWU05 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// fcst qty units column 6
DataItem FG0MWU06 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// fcst qty units column 7
DataItem FG0MWU07 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// fcst qty units column 8
DataItem FG0MWU08 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// fcst qty units column 9
DataItem FG0MWU09 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// fcst qty units column 10
DataItem FG0MWU10 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// fcst qty units column 11
DataItem FG0MWU11 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// fcst qty units column 12
DataItem FG0MWU12 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// fcst qty units column 13
DataItem FG0MWU13 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// history sales units
DataItem FG0MWUHS int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// unit monthly sale qty
DataItem FG0MWUMT int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// sale qty units
DataItem FG0MWUQT int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// unit sale qty sub total
DataItem FG0MWUST int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// w/s product range total
DataItem FG0MWUTQ int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// work begin date
DataItem FG0MWWBD num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = "0", dateFormat = "yy-MM-dd", inputRequired = no
}
end

// work century
DataItem FG0MWWCC num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// work date
DataItem FG0MWWDT num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = "0", dateFormat = "yy-MM-dd", inputRequired = no
}
end

// work begin date
DataItem FG0MWWED num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = "0", dateFormat = "yy-MM-dd", inputRequired = no
}
end

// work month
DataItem FG0MWWMM num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// w/s product line qtys
DataItem FG0MWWQT char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// work year and month
DataItem FG0MWWYM num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// work year
DataItem FG0MWWYY num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

