package pk0n;
import corpcom1.*;
import corpcom2.*;
import corpcom3.*;
import corpcom4.*;
import corpcom5.*;
import corpcom6.*;
import corpcom7.*;
import corpx1.*;
import corpx2.*;
import corpy2.*;
import corpz3.*;
import in1.common.*;
import ku.common.*;
import op.common.*;
import os.common.*;
import pc.common.*;
import pg.common.*;
import pk.common.*;
import pw.common.*;
import sm.common.*;
import sp.common.*;
import sy.common.*;
import ta.common.*;
import tf.common.*;
import ts.common.*;
import ww.common.*;
//*** PROGRAM=PK0N ****
// ************************************************************
// picking customer specified prepacks
// 
// overview:  add and maintain the prepack table. this screen
//            is used to specify how many units for each size
//            will appear on a pick ticket for the order or
//            customer entered.  there are two tables thah this
//            application is maintaining: the customer
//            specified prepack table and the order specified
//            prepack table
// 
// maintence history:
// date       by     rev description of change
// --------   ------ --- --------------------------------------
// 09/30/87   lholco  0  create application
// 11/29/88   JWOOD   1  ADDED NONCSP OPTION TO CALLS
// 11/29/88   JWOOD   1  ADDED XSSEGTR LOGIC
// 07/21/89   Jcampb  2  changed xfer from pk0i to pk09
//                       also added pwirec for io1720
//                       added pk0n935(close) of poolhdr
// 03/06/91   SBEAUC  3  Changed reference from SY2PRDES to
//                       SY1SSTNM on PKNREC for table changes.
// 04/17/91   SBEAUC  4  Allow purge of t/s queues upon exit.
// 05/23/91   rchini  5  For all GPC codes other than '02' or
//                       '03', the color and dimension will be
//                       defaulted to '00' and '00'
//                       respectively.  This change has been
//                       made in PK0N122.
// 07/02/91   esmith  6  Exclude whse '51'...this transaction
//                          is no longer valid for this whse
//                          ...validation in PK0N120
// 09/27/91   esmith  7  Turn on screen for '51' temporarily
//                          to rectify some transfer problems
//                          ...per Linda Rosenthal
// 09/30/91   esmith  8  Turn off screen for '51'
// 03/18/92   SHENDE  9  Rename reference of SY2PRDES to
//                       SY1SSTNM, which is the value being
//                       moved into the field.
// 05/12/92   tglenn 10  Change logic to display EZEMNO002 when
//                       whse 04 is entered.
// 03/04/93   gray       Add code to update pool header when
//                       prepack add chgs or deletes occur.
// 03/18/93   RMORGA 12  Move zero to full case, and move
//                       total quantity to repack quantity for
//                       both pool header and pool item updates
//                       when adding to prepack table.  Reverse
//                       procedure when orders are removed from
//                       the prepack table.  PK0N151, PK0N153,
//                       and PK0N971 ( update ).  Move line
//                       item number to OSNPKGNB so that it
//                       will be unique within order.
// 04/19/93   RMORGA 13  Allow prepak's at product level,
//                       instead of forcing entire orders to be
//                       all prepak.  Fix initial save to edit
//                       sizes before saving.
// 05/10/93   RMORGA 14  Allow prepak's of partial sizes,
//                       instead of forcing all sizes to have
//                       values greater than zero.  Fix edits
//                       to recognize prepacks not including
//                       all sizes or product are OK.  No
//                       changes to customer proccessing.
// 05/20/93   RMORGA 15  Call PK4420 to get carton types.
//                       Autoskip warehouse description.
//                       Update XPA field only when adding
//                       or deleting orders, not items.
// 08/11/95   CBRINE 16  CANADA - call SY2000 (PK0N932)
//                       Added XCTCD to PKWREC.
// 
// ************************************************************
// *********************
Program PK0N type textUIProgram //VAGen Info - main text program
  {
  includeReferencedFunctions = yes, allowUnqualifiedItemReferences = yes, 
  throwNrfEofExceptions = yes, handleHardIOErrors = no, V60ExceptionCompatibility = yes, 
  I4GLItemsNullable = no, textLiteralDefaultIsString = no, localSQLScope = yes, 
  msgTablePrefix = "PK00", inputRecord = COMMAREA, segmented = yes
  }

  // Data Declarations
  COMMAREA COMMAREA ; // record
  ERRSQLCA ERRSQLCA; // record
  PK0NW01 PK0NW01; // record
  PK0NW02 PK0NW02; // record
  PK0NW03 PK0NW03; // record
  PK0NW04 PK0NW04; // record
  PK0NW05 PK0NW05; // record
  PK0NW06 PK0NW06; // record
  PK4REC PK4REC; // record
  PK5REC PK5REC; // record
  PK6REC PK6REC; // record
  PKNREC PKNREC; // record
  PKSREC PKSREC; // record
  PKTREC PKTREC; // record
  PKWREC PKWREC; // record
  PKYREC PKYREC; // record
  PWIREC PWIREC; // record
  PWSREC PWSREC; // record
  SQLCA SQLCA; // record
  SYPREC SYPREC; // record
  TA1REC TA1REC; // record
  TA2REC TA2REC; // record
  TA5REC TA5REC; // record
  TAEREC TAEREC; // record
  WSY2000 WSY2000; // record
  XSPKW01 XSPKW01; // record

  // VAGen Info - items needed for migration
  VAGen_EZESYS char(8);
  VAGen_EZEREPLY num(1);
  VAGen_EZE_WAIT_TIME bin(9,2);
  VAGen_EZE_ITEMLEN int;

  // Use Declarations
  use YNTTBL {deleteAfterUse = yes}; // table
  use XWHTBL {deleteAfterUse = yes}; // table
  use XBCTBL {deleteAfterUse = yes}; // table
  use PK0NM.PK0NM001 // form
   {
    pfKeyEquate = no
  };

  function main()
    // VAGen Info - initialization needed for migration
    VAGen_EZESYS = VGLib.getVAGSysType();
    XPPK001: XPPK001();
     /* ------------------------------------------------------------*/
     /* initialize working storage areas.*/
     /* if an inquiry keys array exists, see if it was orders from*/
     /* this application that were selected for inquiry.  save the*/
     /* information so that the display may be reestablished.*/
     /* ------------------------------------------------------------*/

    if (PKWREC.PKWINDEX > 0) /* INQUIRY KEYS ARRAY PROVIDED*/

      if (PKWREC.PKWSLTYP[PKWINDEX] == "M") /* have key from menu*/
         /* format key array*/
        PKYREC.PKWARRAY = PKWREC.PKWARRAY[PKWINDEX];
        PKWREC.XWHCD = PKYREC.XWHCD;
        PKWREC.XWHABRV = PKYREC.XWHABRV;
         /* clear inquiry selections*/
        PKWREC.PKWSLECT[PKWINDEX] = " ";
        /* decrement inquiry index*/
        PKWREC.PKWINDEX = PKWREC.PKWINDEX - 1;
      end
    end

    PK0N000: PK0N000();
    exit program;
  end // end main
end // end PK0N

// application main logic
Function PK0N000()
   /* ************************************************************/
   /* *   this is the "main logic" for the application.         **/
   /* *                                                         **/
   /* *                                                         **/
   /* ************************************************************/

  COMMAREA.CACURRAP = "PK0N";

  PK0N001(); /* initilize the application*/

  PK0NW01.PK0NWEOA = "N";
   /* set end-of-application flag to 'no'*/

  while (PK0NW01.PK0NWEOA == "N") /* while not end-of-application*/
    PK0N050(); /* process the application screen(s)*/
  end

  PK0N060(); /* exit this application*/
end // end PK0N000

// initialize application
Function PK0N001()
   /* ************************************************************/
   /* *      initialize the application working storage         **/
   /* *                                                         **/
   /* ************************************************************/

  set SQLCA empty;
  PK0N950(); /* clear temp storage*/
  PK0N960(); /* clear temp storage*/
  set PK0NW01 empty; /* clear out storage for pk0nw01*/
  set PK0NW02 empty; /* clear out storage for pk0nw02*/
  set PK0NW03 empty; /* clear out storage for pk0nw03*/

  PK0NW01.XWHCD = PKWREC.XWHCD; /* inital warehouse code*/
  PK0NW01.XWHABRV = PKWREC.XWHABRV; /* and warehouse abbreviation*/

  PK0NW01.PK0NWFST = "Y"; /* first time thru flag*/
  PK0NW01.PK0NWUPD = "N"; /* not okay to update database*/
  PK0NW01.PK0NWBEG = "Y"; /* if this is the very first time*/
  PK0NW01.PK0NWBLA = "N"; /* don't want to build array*/
  PK0NW01.PK0NWBLS = "Y"; /* want to build screen*/
  PK0NW01.PK0NWERR = "N"; /* no error on screen yet*/
  PK0NW01.PK0NWSNR = "N"; /* not showing new records in error*/
  PK0NW01.PK0NWSRS = "N"; /* not showing remaining sizes*/
  PK0NW01.PK0NW-POOL-CHANGE = "N"; /* order updated since prepacked*/
end // end PK0N001

// main pk0g branch control
Function PK0N050()
   /* ************************************************************/
   /* *    process the application screen(s)                    **/
   /* *                                                         **/
   /* *  note that this process being performed in a            **/
   /* *  "while loop" until the end-of-application flag is set  **/
   /* *  to 'y'.                                                **/
   /* *                                                         **/
   /* ************************************************************/

  PK0NW01.PK0NWEOS = "N"; /* set end-of-screen flag to 'no'*/

  while (PK0NW01.PK0NWEOS == "N") /* while not end-of-screen*/
    PK0N100(); /* process screen pk0%m001*/
  end

   /* at this point;*/
       /* if the end-of-application flag (pk0%weoa) = 'n'*/
           /* we go back to the top of pk0%050...*/
       /* if the end-of-application flag (pk0%weoa) = 'y'*/
           /* we return to pk0%000.*/

end // end PK0N050

// exit application
Function PK0N060()
   /* ************************************************************/
   /* *    exit application*/
   /* *                                                         **/
   /* ************************************************************/

  COMMAREA.CAUSERA = PKWREC.PKWGRPLV; /* commarea user area*/

  PK0N950(); /* clear t/s*/
  PK0N960(); /* clear t/s*/

  XSEXIT();

  PK0NM001.VAGen_EZEMSG = COMMAREA.CAMSG; /* returned error message*/

  converseLib.validationFailed(); /* force alarm to sound*/
  PK0NM001.XXXERRID = "PK0N060"; /* error location*/

  PK0N100(); /* display screen to show error*/

end // end PK0N060

// converse screen m001
Function PK0N100()
   /* ************************************************************/
   /* *    process screen m001                                  **/
   /* *                                                         **/
   /* *  note that this process is being performed in a         **/
   /* *     "while loop" from pk0%050 until the end-of-screen   **/
   /* *     flag (pk0%weos) is set to 'y'.                      **/
   /* *                                                         **/
   /* ************************************************************/

  if (PK0NW01.PK0NWERR == "N"
   && PK0NW01.PK0NWBLA == "Y") /* need to build database array*/
    PK0N101(); /* fill it with data*/
  end
  PK0NW01.PK0NWBLA = "N";

  if (PK0NW01.PK0NWERR == "N")
    PK0N112(); /* hold values from screen*/
  end

  VGVar.handleSysLibraryErrors = 0;
  sysLib.commit(); /* test only*/

  if (PK0NW01.PK0NWERR == "N"
   && PK0NW01.PK0NWBLS == "Y") /* screen has no data in its body*/
    PK0N105(); /* fill it with data*/
  end
  PK0NW01.PK0NWBLS = "N";

  PK0N109(); /* truncate Cole-Haan cust nbrs*/

  PK0N111(); /* set fields protected*/
   /* ***********************************************************/
  converse PK0NM001 ;
   /* ***********************************************************/

  PK0NW01.PK0NWERR = "N"; /* reset error flag*/
  PK0NW01.PK0NWUPD = "N"; /* reset update flag*/

  PK0N110(); /* handle any special entries*/
       /* may exit appl from this process*/

  PK0N108(); /* reset Cole-Haan cust nbrs*/

  if (PK0NW01.PK0NWERR == "N")
    PK0N120(); /* go edit screen entries*/
  end

  if (PK0NW01.PK0NWERR == "N")
    PK0N130(); /* process entries*/
  end

    /* update database*/

  if (PK0NW01.PK0NWERR == "N" /* if there were no map errors*/
   && PK0NW01.PK0NWUPD == "Y") /* okay to do updates*/
    PK0N140(); /* update database*/
  end

       /* may exit appl from this process*/

  if (PK0NW01.PK0NWERR == "N")
    PK0N115(); /* process pfkeys*/
  end

   /* at this point;*/
     /* if the end-of-screen flag (pk0%weos) is 'n'*/
        /* we go back to top of process pk0%100.*/
     /* if the end-of-screen flag (pk0%weos) is 'y'*/
        /* we return to pk0%050.*/
end // end PK0N100

// build array
Function PK0N101()
   /* **************************************************/
     /* build array for processing*/
   /* **************************************************/

  PK0NM001.XXXERRID = "PK0N101";

  if (PK0NW01.PK0NWTYP == " " /* signifies first time thru*/
   || PK0NW01.PK0NMRJT == "Y") /* reject entire order*/
    return; /* have no data to build array from*/
  end

  if (PK0NW01.PK0NWTYP == "O") /* order data*/
    PK0N165(); /* create prepack array*/
    if (PK0NW01.PK0NWERR == "Y"
     || PK0NW01.PK0NMRJT == "Y")
      return;
    end

     /* priming read*/

    PK0NW01.PK0NWCP2 = 1; /* init current page*/
    PK0NW01.PK0NWBLS = "Y";
     /* need to rebuild screen to show new data*/

    if (PK0NW01.PK0NWCP2 > PK0NW01.PK0NWLP2)
      converseLib.validationFailed(38); /* no more pages to display*/
      PK0NM001.XXXERRID = "PK0N101";
      return;
    end

    PK0N963(); /* read temp storage page*/
    if (PK0NW01.PK0NWERR == "Y")
      PK0NW01.PK0NWERR = "Y";
      return;
    end

     /* find correct record to show to user*/

    if (PK0NM001.XGPCD == " ")
       /* next sentence - show first record in temp storage*/
    else
      while (PK0NM001.XGPCD != PK0NW02.XGPCD
       || PK0NM001.SY1STNBR != PK0NW02.SY1STNBR
       || PK0NM001.SY2CLRID != PK0NW02.SY2CLRID
       || PK0NM001.XDMCD != PK0NW02.XDMCD)

        PK0NW01.PK0NWCP2 = PK0NW01.PK0NWCP2 + 1; /* look at next page*/
        if (PK0NW01.PK0NWCP2 > PK0NW01.PK0NWLP2)
          converseLib.validationFailed(185); /* prd doesn't exist on order*/
          PK0NW01.PK0NWERR = "Y";
          set PK0NM001.XGPCD cursor, bold;
          set PK0NM001.SY1STNBR bold;
          set PK0NM001.SY2CLRID bold;
          set PK0NM001.XDMCD bold;
          PK0NM001.XXXERRID = "PK0N101";
          return;
        end
        PK0N963(); /* read temp storage page*/
        if (PK0NW01.PK0NWERR == "Y")
          PK0NW01.PK0NWERR = "Y";
          return;
        end

      end

       /* found correct product*/

      if (PK0NM001.XGPCD == PK0NW02.XGPCD
       && PK0NM001.SY1STNBR == PK0NW02.SY1STNBR
       && PK0NM001.SY2CLRID == PK0NW02.SY2CLRID
       && PK0NM001.XDMCD == PK0NW02.XDMCD)

        if (PK0NM001.PK0NMSTR == " ")
           /* next sentence - found record we need*/
        else

           /* convert sizes to internal sizes*/

          PK0NW01.PKTBACTI = 0; /* hold internal start size*/
          PK0NW01.PK0NWIED = 0; /* hold internal end size*/
          /* MOVE PK0NW02.PK0NMSTR TO PK0NM001.PK0NMSTR;*/
          /* MOVE PK0NW02.PK0NMEND TO PK0NM001.PK0NMEND;*/
          set SYPREC empty;

          if (PK0NM001.PK0NMSTR != " ")
            PK0NS31(); /* convert sizes*/
          end

          PK0NW01.PKTBACTI = SYPREC.SY5SZID[1]; /* internal start size id*/
          PK0NW01.PK0NWEND = SYPREC.SY5SZID[2]; /* internal end size id*/

          while (PK0NW01.PKTBACTI != PK0NW02.PKTBACTI
           || PK0NM001.XGPCD != PK0NW02.XGPCD
           || PK0NM001.SY1STNBR != PK0NW02.SY1STNBR
           || PK0NM001.SY2CLRID != PK0NW02.SY2CLRID
           || PK0NM001.XDMCD != PK0NW02.XDMCD)

            PK0NW01.PK0NWCP2 = PK0NW01.PK0NWCP2 + 1; /* look at next page*/
            if (PK0NW01.PK0NWCP2 > PK0NW01.PK0NWLP2)
              converseLib.validationFailed(188); /* start size does not exist*/
              PK0NS51(); /* clear detail lines*/
              PK0NW01.PK0NWERR = "Y";
              set PK0NM001.XGPCD bold;
              set PK0NM001.SY1STNBR bold;
              set PK0NM001.SY2CLRID bold;
              set PK0NM001.XDMCD bold;
              set PK0NM001.PK0NMSTR cursor, bold;
              PK0NM001.XXXERRID = "PK0N101";
              return;
            end
            PK0N963(); /* read temp storage page*/
            if (PK0NW01.PK0NWERR == "Y")
              PK0NW01.PK0NWERR = "Y";
              return;
            end

          end
        end
      end
    end
  end

  if (PK0NW01.PK0NWTYP == "C") /* customer data*/
    PK0N170();
  end

end // end PK0N101

// build screen for m001
Function PK0N105()
   /* ************************************************************/
   /* *      this process builds the screen for m001*/
   /* ************************************************************/

  if (converseVar.eventKey is pf12)
    return;
  end

   /* clear map*/

  set PK0NM001 initial;

  if (PK0NW01.PK0NWANO == "Y")
    PK0NM001.PK0NMACT = "A";
    set PK0NM001.PKTPPQTY cursor;
  else
    if (PK0NM001.PK0NMACT == "C"
     && PK0NW01.PK0NWFST == "Y")
      PK0NM001.PK0NMACT = "C";
    else
      PK0NM001.PK0NMACT = " ";
      set PK0NM001.PK0NMACT cursor;
    end
  end

  PK0NM001.XXXERRID = "PK0NM";
  PK0NM001.XXXCURDT = VGVar.currentShortGregorianDate;
  PK0NM001.XXXRVNBR = "00";
  set PK0NM001.PK0NMACT cursor;

  PK0NM001.XWHCD = PK0NW01.XWHCD;
  PKWREC.XWHCD = PK0NW01.XWHCD;

  if (PK0NW01.XWHABRV == " ") /* if no abreviation*/
    if (PK0NM001.XWHCD in XWHTBL.XWHCD /* if code is in the table*/
     && XWHTBL.XXXSTAT[sysVar.arrayIndex] == "A") /* and it is active*/
      PK0NW01.XWHABRV = XWHTBL.XWHABRV[sysVar.arrayIndex];
      PK0NM001.XWHABRV = XWHTBL.XWHABRV[sysVar.arrayIndex];
    else
      PK0NM001.XWHABRV = " ";
    end
  end
  PK0NM001.XWHABRV = PK0NW01.XWHABRV;
  PKWREC.XWHABRV = PK0NW01.XWHABRV;

  PK0NM001.XBCCD = PK0NW01.XBCCD;
  PK0NM001.XBCABRV = PK0NW01.XBCABRV;

    /* move customer data to screen*/

  if (PK0NW01.PK0NWTYP == "C")
    PK0NS40(); /* set map fields protected*/
    PK0NM001.KUCCOID = PKSREC.KUCCOID;
    PK0NM001.KUMSTRID = PKSREC.KUMSTRID;
    PK0NM001.XNXCD = PKSREC.XNXCD;
    if (PKSREC.PKSSSZFL == "Y")
      PK0NM001.PK0NMPSS = "Y";
    else
      if (PKSREC.PKSSSZFL == "N")
        PK0NM001.PK0NMPBS = "Y";
      end
    end
    return;
  end

   /* current page has already been read*/
    /* move order data to screen*/

  if (PK0NW01.PK0NWLP2 == 0) /* if no prepack records*/
    PK0NM001.PK1CUOID = PK0NW01.PK1CUOID;
    PK0NM001.PK1NORID = PK0NW01.PK1NORID;
    PK0NM001.XGPCD = PK0NW01.XGPCD;
    PK0NM001.SY1STNBR = PK0NW01.SY1STNBR;
    PK0NM001.SY2CLRID = PK0NW01.SY2CLRID;
    PK0NM001.XDMCD = PK0NW01.XDMCD;
  else
    PK0NM001.PK1CUOID = PK0NW02.PK1CUOID;
    PK0NM001.PK1NORID = PK0NW02.PK1NORID;
    PK0NM001.XGPCD = PK0NW02.XGPCD;
    PK0NM001.SY1STNBR = PK0NW02.SY1STNBR;
    PK0NM001.SY2CLRID = PK0NW02.SY2CLRID;
    PK0NM001.XDMCD = PK0NW02.XDMCD;
    PK0NM001.SY1SSTNM = PK0NW02.SY1SSTNM;
    PK0NM001.PKTNBRPP = PK0NW02.PKTNBRPP;
    PK0NM001.PK0NMSTR = PK0NW02.PK0NMSTR;
    PK0NM001.PK0NMEND = PK0NW02.PK0NMEND;

    if (PK0NW02.PKSSSZFL == " ")
      PK0NM001.YNTCD = PK0NW02.YNTCD;
    else
      PK0NM001.YNTCD = " ";
    end

    if (PK0NM001.YNTCD in YNTTBL.YNTCD /* if code is in the table*/
     && YNTTBL.XXXSTAT[sysVar.arrayIndex] == "A") /* and it is active*/
      PK0NM001.YNTDESC = YNTTBL.YNTDESC[sysVar.arrayIndex];
    else
      PK0NM001.YNTDESC = " ";
    end

    if (PK0NW02.PKSSSZFL == "Y")
      PK0NM001.PK0NMPSS = "Y";
      return; /* no sizes to be shown*/
    else
      if (PK0NW02.PKSSSZFL == "N")
        PK0NM001.PK0NMPBS = "Y";
        return; /* no sizes to be shown*/
      end
    end

  end

  PK0NS61(); /* see if error msg should be shown*/

  PK0NW01.PK0NWCT1 = 1;
  PK0NW01.PK0NWCT2 = 1;

  while (PK0NW01.PK0NWCT1 <= 40
   && PK0NW01.PK0NWCT2 <= 20)
    PK0N106(); /* build each screen line*/
    PK0NW01.PK0NWCT1 = PK0NW01.PK0NWCT1 + 1;
  end

   /* if browsing thru already created prepack records*/
   /* calculate remaining quantities*/

  if (PK0NM001.PK0NMREM[1] == 0)
    PK0NS30(); /* calculate remaining quantities*/
    if (converseVar.validationMsgNum != 0)
      return;
    end
  end
end // end PK0N105

// build screen lines for m001
Function PK0N106()
   /* ************************************************************/
   /* *   take data from the database array and place           **/
   /* *   onto the screen one line at a time.                   **/
   /* ************************************************************/

  if (PK0NW02.SY4IDDSC[PK0NWCT1] == " ")
     /* next sentence - dont put anything on screen*/
  else
    PK0NM001.SY4IDDSC[PK0NWCT2] = PK0NW02.SY4IDDSC[PK0NWCT1];
    PK0NM001.PKTPPQTY[PK0NWCT2] = PK0NW02.PKTPPQTY[PK0NWCT1];
    PK0NM001.PK1QTY[PK0NWCT2] = PK0NW02.PK1QTY[PK0NWCT1];
    PK0NW01.PK0NWCT2 = PK0NW01.PK0NWCT2 + 1;
  end
end // end PK0N106

// reset Cole-Haan cust nbrs
Function PK0N108()
   /* ************************************************************/
   /* *  add '80' prefix to Cole-Haan customer nbrs before*/
   /* *  processing*/
   /* ************************************************************/

  if (PK0NM001.XBCCD == "08")
    if (PK0NM001.KUCCOID > 7900000
     && PK0NM001.KUCCOID < 9000000)
       /* next sentence                /* it's already c-h*/
    else
      PK0NM001.KUCCOID = PK0NM001.KUCCOID + 8000000;
    end
  end

end // end PK0N108

// truncate Cole-Haan cust nbrs
Function PK0N109()
   /* ************************************************************/
   /* *  remove '80' prefix from Cole-Haan customer nbrs*/
   /* ************************************************************/

  if (PK0NM001.KUCCOID > 7999999
   && PK0NM001.KUCCOID < 9000000)
    PK0NM001.KUCCOID = PK0NM001.KUCCOID - 8000000;
  end

end // end PK0N109

// handle screen m001 pfkeys
Function PK0N110()
   /* ***********************************************************/
   /* *  check pf keys*/
   /* ***********************************************************/

  PK0NM001.XXXERRID = "PK0N110"; /* show place of error*/

  if (converseVar.eventKey is enter
   || converseVar.eventKey is pf7
   || converseVar.eventKey is pf8
   || converseVar.eventKey is pf12)
    return;
  end

  if (converseVar.eventKey is pf1)
    PK0N950(); /* clear t/s*/
    PK0N960(); /* clear t/s*/
    XSPF1();
    return;
  end

  if (converseVar.eventKey is pf3)
    COMMAREA.CATOAP = "PK0A";
    PK0NW01.PK0NWERR = "Y";
    PK0NW01.PK0NWEOS = "Y";
    PK0NW01.PK0NWEOA = "Y";
    return;
  end

  if (converseVar.eventKey is pf4)
    PK0N950(); /* clear t/s*/
    PK0N960(); /* clear t/s*/
    XSPF4();
    return;
  end

  if (converseVar.eventKey is pf13)
    COMMAREA.CATOAP = "PK0B";
    PK0NW01.PK0NWERR = "Y";
    PK0NW01.PK0NWEOS = "Y";
    PK0NW01.PK0NWEOA = "Y";
    return;
  end

  if (converseVar.eventKey is pf14)
    COMMAREA.CATOAP = "PK0C";
    PK0NW01.PK0NWERR = "Y";
    PK0NW01.PK0NWEOS = "Y";
    PK0NW01.PK0NWEOA = "Y";
    return;
  end

  if (converseVar.eventKey is pf15)
    COMMAREA.CATOAP = "PK0D";
    PK0NW01.PK0NWERR = "Y";
    PK0NW01.PK0NWEOS = "Y";
    PK0NW01.PK0NWEOA = "Y";
    return;
  end

  if (converseVar.eventKey is pf16)
    COMMAREA.CATOAP = "PK0Z";
    PK0NW01.PK0NWERR = "Y";
    PK0NW01.PK0NWEOS = "Y";
    PK0NW01.PK0NWEOA = "Y";
    return;
  end

  if (converseVar.eventKey is pf18)
    COMMAREA.CATOAP = "PK09";
    PK0NW01.PK0NWERR = "Y";
    PK0NW01.PK0NWEOS = "Y";
    PK0NW01.PK0NWEOA = "Y";
    return;
  end

  if (converseVar.eventKey is pf19)
    COMMAREA.CATOAP = "PK0S";
    PK0NW01.PK0NWERR = "Y";
    PK0NW01.PK0NWEOS = "Y";
    PK0NW01.PK0NWEOA = "Y";
    return;
  end

  if (converseVar.eventKey is pf20)
    COMMAREA.CATOAP = "PK07";
    PK0NW01.PK0NWERR = "Y";
    PK0NW01.PK0NWEOS = "Y";
    PK0NW01.PK0NWEOA = "Y";
    return;
  end

  if (converseVar.eventKey is pa2)
    PK0N001(); /* initialize application*/
    set PK0NM001 initial;
    PK0NW01.PK0NWBLS = "Y";
    PK0NW01.PK0NWEOA = "N";
    PK0NW01.PK0NWEOS = "N";
    PK0N950(); /* purge temp storage*/
    PK0N960(); /* purge temp storage*/
    return;
  end

   /* if no other condition was met, show message*/

  converseLib.validationFailed(12); /* invalid pfkey*/
  PK0NM001.XXXERRID = "PK0N110";
  PK0NW01.PK0NWERR = "Y";
end // end PK0N110

// set fields protected
Function PK0N111()
   /* ************************************************************/
   /* *  set fields protected*/
   /* ************************************************************/

  if (PK0NW01.PK0NWTYP == "O")
    PK0NS41(); /* protect/unprotect fields/also move cursor*/
  else
    if (PK0NW01.PK0NWTYP == "C")
      PK0NS40();
    end
  end
end // end PK0N111

// hold values from screen
Function PK0N112()
   /* ************************************************************/
   /* *  hold values from screen*/
   /* ************************************************************/

   /* save fields on screen*/

  PK0NW01.XWHCD = PK0NM001.XWHCD;
  PK0NW01.XBCCD = PK0NM001.XBCCD;

  if (PK0NW01.PK0NWBEG == "Y")
    PK0NW01.PK0NWBEG = "N";
    return;
  end

  if (PK0NW01.PK0NWERR == "N")
    PK0NW01.XWHCD = PK0NM001.XWHCD;
    PK0NW01.XBCCD = PK0NM001.XBCCD;
    PK0NW01.XBCABRV = PK0NM001.XBCABRV;
    PK0NW01.PK0NMACT = PK0NM001.PK0NMACT;
    PK0NW01.KUCCOID = PK0NM001.KUCCOID;
    PK0NW01.KUMSTRID = PK0NM001.KUMSTRID;
    PK0NW01.XNXCD = PK0NM001.XNXCD;
    PK0NW01.PK1CUOID = PK0NM001.PK1CUOID;
    PK0NW01.PK1NORID = PK0NM001.PK1NORID;
    PK0NW01.XGPCD = PK0NM001.XGPCD;
    PK0NW01.SY1STNBR = PK0NM001.SY1STNBR;
    PK0NW01.SY2CLRID = PK0NM001.SY2CLRID;
    PK0NW01.XDMCD = PK0NM001.XDMCD;
    PK0NW01.YNTCD = PK0NM001.YNTCD;
    PK0NW01.PK0NMSTR = PK0NM001.PK0NMSTR;
    PK0NW01.PK0NMEND = PK0NM001.PK0NMEND;
    PK0NW01.PK0NMRJT = PK0NM001.PK0NMRJT;
  end
end // end PK0N112

// handle p7/8 and enter
Function PK0N115()
   /* ************************************************/
    /* handle pfkeys after all other processing has*/
    /* been done*/
   /* ************************************************/

  if (PK0NW01.PK0NWLP2 < 1) /* if no prepack records to scroll*/
    return;
  end

  if (converseVar.eventKey is pf7
   || converseVar.eventKey is pf8)
    if (PK0NW01.PK0NWSRS == "Y") /* if need to show remaining sizes*/
      return;
    else
       /* next sentence*/
    end
  else
    return;
  end

  if (converseVar.eventKey is pf7)
    PK0NS07();
  else
    if (converseVar.eventKey is pf8)
      PK0NS08();
    end
  end

  PK0N963(); /* read temp storage page*/
  if (converseVar.validationMsgNum != 0)
    PK0NW01.PK0NWERR = "Y";
    return;
  end
end // end PK0N115

// handle screen m001 pfkeys
Function PK0N120()
   /* ***********************************************************/
   /* *  edit fields*/
   /* ***********************************************************/

  PK0NM001.XXXERRID = "PK0N120"; /* show place of error*/

   /* set all fields normal, if there is an error they will be*/
   /* set bright*/

  set PK0NM001.XWHCD normal;
  set PK0NM001.XBCCD normal;
  set PK0NM001.PK0NMACT normal;
  set PK0NM001.PK0NMRJT normal;
  set PK0NM001.KUCCOID normal;
  set PK0NM001.KUMSTRID normal;
  set PK0NM001.XNXCD normal;
  set PK0NM001.PK0NMPBS normal;
  set PK0NM001.PK1CUOID normal;
  set PK0NM001.PK1NORID normal;
  set PK0NM001.PK0NMPSS normal;
  set PK0NM001.XWHCD normal;
  set PK0NM001.SY1STNBR normal;
  set PK0NM001.SY2CLRID normal;
  set PK0NM001.XDMCD normal;
  set PK0NM001.YNTCD normal;
  set PK0NM001.PK0NMSTR normal;
  set PK0NM001.PK0NMEND normal;
  set PK0NM001.PKTNBRPP normal;
  set PK0NM001.PK0NMACT cursor;

  if (PK0NW-POOL-CHANGE == "Y") /* order must be rebuilt*/
    if (PK0NM001.PK0NMRJT != "Y")
      PK0NW01.PK0NWERR = "Y";
      converseLib.validationFailed(460); /* order changed, reject prepack*/
      return;
    else
      PK0NW01.PK0NW-POOL-CHANGE = "N"; /* reset flag*/
    end
  end

   /* reject any warehouse except 02*/

  if (PK0NM001.XWHCD == "02") /* if greenland*/
    /* next sentence                   /*  go on*/
  else
    converseLib.validationFailed(422); /* else*/
    PK0NM001.XXXERRID = "PK0N120"; /* invalid warehouse*/
    PK0NW01.PK0NWERR = "Y";
    set PK0NM001.XWHCD cursor, bold;
    return;
  end

  if (PK0NM001.XWHCD is modified)
    if (PK0NM001.XWHCD in XWHTBL.XWHCD /* if code is in the table*/
     && XWHTBL.XXXSTAT[sysVar.arrayIndex] == "A") /* and it is active*/
      PK0NM001.XWHABRV = XWHTBL.XWHABRV[sysVar.arrayIndex];
    else
      converseLib.validationFailed(2); /* invalid warehouse*/
      PK0NM001.XXXERRID = "PK0N120";
      PK0NW01.PK0NWERR = "Y";
      set PK0NM001.XWHCD cursor, bold;
      return;
    end
  end

   /* validate brand code*/

  PK0NM001.XBCABRV = " "; /* clear brand desc*/

  if (PK0NM001.XBCCD == "  ") /* brand not entered*/
    converseLib.validationFailed(341); /* required field*/
    PK0NM001.XXXERRID = "PK0N120";
    PK0NW01.PK0NWERR = "Y";
    set PK0NM001.XBCCD cursor, bold;
    return;
  else
    if (PK0NM001.XBCCD in XBCTBL.XBCCD)
      PK0NM001.XBCABRV = XBCTBL.XBCABRV[sysVar.arrayIndex];
    end
    if (PK0NM001.XBCCD != "08") /* brand not Cole-Haan*/
      converseLib.validationFailed(422); /* cole-haan only*/
      PK0NM001.XXXERRID = "PK0N120";
      PK0NW01.PK0NWERR = "Y";
      set PK0NM001.XBCCD cursor, bold;
      return;
    end
  end

  if (PK0NW01.PK0NWTYP == "O")

     /* set detail quantity fields normal*/

    PK0NW01.PK0NWCT1 = 1;
    while (PK0NW01.PK0NWCT1 <= 20)
      set PK0NM001.PKTPPQTY[PK0NWCT1] normal;
      PK0NW01.PK0NWCT1 = PK0NW01.PK0NWCT1 + 1;
    end

     /* if user tried to pf outa here and not all sizes*/
     /* were done, then don't edit data,just show*/
     /* records in error.*/

    if (converseVar.eventKey is pf1
     || converseVar.eventKey is pf3
     || converseVar.eventKey is pf4
     || converseVar.eventKey is pf13
     || converseVar.eventKey is pf14
     || converseVar.eventKey is pf15
     || converseVar.eventKey is pf16
     || converseVar.eventKey is pf19
     || converseVar.eventKey is pa2)
      if (PK0NW01.PK0NWRHY == "N"
       && PK0NW01.PK0NWCT1 < 40) /* sizes in error*/
        PK0NW01.PK0NWBLS = "Y"; /* show error msg*/
        PK0NW01.PK0NWBLA = "N"; /* have array needed*/
        PK0NW01.PK0NWFST = "Y"; /* first time thru*/
        return;
      end
    end
  end

  if (converseVar.eventKey is pa2)
    return;
  end
  if (converseVar.eventKey is pf7
   || converseVar.eventKey is pf8)
    if (PK0NW01.PK0NWTYP == "O")
      PK0N127();
      return;
    end
  end

   /* either pack by style or pack by style/size, but not both*/

  if (PK0NM001.PK0NMPBS != " "
   && PK0NM001.PK0NMPSS != " ")
    set PK0NM001.PK0NMPBS cursor, bold;
    set PK0NM001.PK0NMPSS bold;
    PK0NW01.PK0NWERR = "Y";
    converseLib.validationFailed(176); /* cannot enter pack by style flag and*/
                                  /* pack by style/size*/
  end

   /* edit action field*/

  if (PK0NM001.PK0NMACT == " "
   || PK0NM001.PK0NMACT == "A"
   || PK0NM001.PK0NMACT == "C"
   || PK0NM001.PK0NMACT == "D")
     /* next sentence*/
  else
    set PK0NM001.PK0NMACT cursor, bold;
    PK0NW01.PK0NWERR = "Y";
    converseLib.validationFailed(35); /* invalid action code*/
  end

   /* validate fields used with customer*/

  if (PK0NM001.KUCCOID == 0)
     /* next sentence*/
  else
    if (PK0NM001.KUCCOID != 0
     && PK0NM001.KUMSTRID >= 0
     && PK0NM001.XNXCD >= 0
     && PK0NM001.XWHCD != " ")
      PK0NW01.PK0NWTYP = "C"; /* processing customer data*/
    else
      set PK0NM001.KUCCOID cursor, bold;
      set PK0NM001.KUMSTRID bold;
      set PK0NM001.XNXCD bold;
      set PK0NM001.XWHCD bold;
      PK0NW01.PK0NWERR = "Y";
      converseLib.validationFailed(177); /* enter xwh and cust nbr to access cust*/
                                   /* data*/
      PK0NS50(); /* clear detail lines*/
    end
  end

   /* validate fields used with order nbr*/

  if (PK0NM001.PK1CUOID == 0)
     /* next sentence*/
  else
    if (PK0NM001.PK1CUOID > 0
     && PK0NM001.PK1NORID >= 0
     && PK0NM001.XWHCD != " ")
      PK0NW01.PK0NWTYP = "O"; /* processing order data*/
    else
      set PK0NM001.PK1CUOID cursor, bold;
      set PK0NM001.PK1NORID bold;
      set PK0NM001.XWHCD bold;
      PK0NW01.PK0NWERR = "Y";
      converseLib.validationFailed(178); /* enter xwh,and order nbr to access*/
                                   /* order data*/
      PK0NS50(); /* clear detail lines*/
    end
  end

  if (PK0NW01.PK0NWERR == "Y")
    return;
                                   /* no need to go on if there is an error*/
  end

   /* edit customer data different than order data*/

  if (PK0NW01.PK0NWTYP == "C")
    PK0N121();
  else
    if (PK0NW01.PK0NWTYP == "O")
      PK0N122();
    else
      return;
      PK0NW01.PK0NWERR = "Y";
    end
  end
end // end PK0N120

// edit customer data
Function PK0N121()
   /* ***********************************************************/
   /* *  edit customer data*/
   /* ***********************************************************/

  PK0NM001.XXXERRID = "PK0N121"; /* show place of error*/

   /* set non-usable fields protected*/

  PK0NS40(); /* protect fields*/
  if (converseVar.validationMsgNum != 0)
    return;
  end

   /* validate warehouse code*/

  if (PK0NM001.XWHCD in XWHTBL.XWHCD /* if code is in the table*/
   && XWHTBL.XXXSTAT[sysVar.arrayIndex] == "A") /* and it is active*/
    PK0NW01.XWHABRV = XWHTBL.XWHABRV[sysVar.arrayIndex];
  else
    PK0NW01.XWHABRV = " ";
  end
  PK0NM001.XWHABRV = PK0NW01.XWHABRV;
  PKWREC.XWHABRV = PK0NW01.XWHABRV;

   /* validate pack by flags*/

  if (PK0NM001.PK0NMACT == "A")
    if (PK0NM001.PK0NMPBS == "Y"
     || PK0NM001.PK0NMPSS == "Y")
       /* next sentence*/
    else
      converseLib.validationFailed(203); /* must enter either pack by flag*/
      PK0NW01.PK0NWERR = "Y";
      set PK0NM001.PK0NMPBS cursor, bold;
      set PK0NM001.PK0NMPSS bold;
      return;
    end
  end

   /* set first time thru flag*/

  PK0NW01.PK0NWFST = "N";

  if (PK0NM001.KUCCOID != PK0NW01.KUCCOID
   || PK0NM001.KUMSTRID != PK0NW01.KUMSTRID)
    PK0NW01.PK0NWFST = "Y";
    PK0NW01.PK0NWBLA = "Y";
    PK0NW01.PK0NWBLS = "Y";
  end

end // end PK0N121

// edit order number data
Function PK0N122()
   /* ***************************************************/
     /* edit order number entry*/
   /* ***************************************************/

  PK0NM001.XXXERRID = "PK0N122";

        /* #####################*/
      /* set first time thru flag*/
        /* #####################*/

  PK0NW01.PK0NWFST = "N";
  PK0NW01.PK0NWBLA = "N";

  if (PK0NM001.PK0NMACT != PK0NW01.PK0NMACT
   || PK0NM001.XWHCD != PK0NW01.XWHCD
   || PK0NM001.PK1CUOID != PK0NW01.PK1CUOID
   || PK0NM001.PK1NORID != PK0NW01.PK1NORID
   || PK0NM001.SY1STNBR != PK0NW01.SY1STNBR
   || PK0NM001.SY2CLRID != PK0NW01.SY2CLRID
   || PK0NM001.XDMCD != PK0NW01.XDMCD
   || PK0NM001.PK0NMEND != PK0NW01.PK0NMEND
   || PK0NM001.PK0NMSTR != PK0NW01.PK0NMSTR
   || PK0NM001.PK0NMRJT != PK0NW01.PK0NMRJT)
    PK0NW01.PK0NWFST = "Y"; /* have new data on screen*/
    PK0NW01.PK0NWBLA = "Y"; /* need to build array*/
    PK0N124();
  end

        /* #####################*/
           /* validate fields*/
        /* #####################*/

  PK0N123();
                                   /* validate map fields*/
  if (PK0NW01.PK0NWERR == "Y"
   || PK0NW01.PK0NWPSS == "Y") /* process by flag*/
    return;
  end

         /* ##########################*/
      /* set flags for special processing*/
         /* ##########################*/

   /* need to validate existing prepack table against*/
   /* pool detail*/

  if (PK0NW01.PK0NWSNR == "N") /* if not showing new records in errors*/
    if (PK0NW01.PK1CUOID != PK0NM001.PK1CUOID
     || PK0NW01.PK1NORID != PK0NM001.PK1NORID)
      if (PK0NM001.PK0NMACT == " "
       || PK0NM001.PK0NMACT == "C"
       || PK0NM001.PK0NMACT == "A")

         /* validate that data exists on pool header/detail*/

        PK0N125();
        if (converseVar.validationMsgNum != 0)
          return;
        end

        PK0N190(); /* validate prepack table*/
        if (PK0NW01.PK0NWERR == "Y")
          return;
        end
      end
    end
  end

   /* set flag for adding new order*/

  if (PK0NW01.PK0NWSNR == "Y")
     /* next sentence*/
  else
    if (PK0NW01.PK0NWANO == "N" /* don't already have a new order*/
     || PK0NW01.PK0NWANO == " ") /* being processed*/
      if (PK0NM001.PK0NMACT == "A")

         /* validate that data exists on pool header/detail*/

        PK0N125();
        if (converseVar.validationMsgNum != 0)
          return;
        end

        PK0NW01.PK0NWANO = "Y"; /* adding new order*/
        PK0N160(); /* build array of flags*/
        if (converseVar.validationMsgNum != 0)
          return;
        end
      end

       /* if deleting records*/

      if (PK0NM001.PK0NMACT == "D")

        PK0N160(); /* build array of flags*/
        if (converseVar.validationMsgNum != 0)
          return;
        end

        if (PK0NW01.PK0NWLP1 > 0)
                                   /* if there are records in prepack table*/
          PK0NW01.PK0NWANO = "Y"; /* adding new order*/
        end
      end
    else

       /* if already have array for new orders but are adding*/
       /* or deleting different products*/

      if (PK0NW01.PK0NWFST == "Y")

         /* validate that data exists on pool header/detail*/

        PK0N125();
        if (converseVar.validationMsgNum != 0)
          return;
        end
      end
    end
  end

         /* ##########################*/
          /* convert size to internal*/
         /* ##########################*/

  if (PK0NW01.PK0NWPRD == "N") /* no product data entered*/
     /* next sentence*/
  else
    if (PK0NW01.PK0NMSTR != PK0NM001.PK0NMSTR
     || PK0NW01.PK0NMEND != PK0NM001.PK0NMEND)

       /* convert sizes to internal sizes*/

      PK0NW01.PKTBACTI = 0; /* hold internal start size*/
      PK0NW01.PK0NWEND = 0; /* hold internal end size*/
      set SYPREC empty;

      if (PK0NM001.PK0NMSTR != " ")
        PK0NS31(); /* convert sizes*/
      end

      PK0NW01.PKTBACTI = SYPREC.SY5SZID[1]; /* internal start size id*/
      PK0NW01.PK0NWEND = SYPREC.SY5SZID[2]; /* internal end size id*/

    else
      if (PK0NW01.PK0NWANO == "Y"
       && PK0NW01.PK0NWFST == "Y")
        return; /* don't want size for current data on*/
                                   /* scn*/
      end

       /* find internal size for first size on screen*/

      PK0NW01.PK0NWCT1 = 1;
      PK0NW01.PK0NWCT2 = 1;

       /* find first size on screen within the screen array*/

      while (PK0NW01.PK0NWCT1 <= 19
       && PK0NW01.PK0NWCT2 <= 39
       && PK0NM001.SY4IDDSC[PK0NWCT1] != PK0NW02.SY4IDDSC[PK0NWCT2])

        PK0NW01.PK0NWCT2 = PK0NW01.PK0NWCT2 + 1;

      end

      if (PK0NM001.SY4IDDSC[PK0NWCT1] == PK0NW02.SY4IDDSC[PK0NWCT2])
        PK0NW01.PKTBACTI = PK0NW02.SY5SZID[PK0NWCT2];
      end

    end
  end
end // end PK0N122

// validate map fields
Function PK0N123()
   /* ***************************************************/
     /* validate map fields*/
     /* This proc made out of PK0N122*/
   /* ***************************************************/

  PK0NM001.XXXERRID = "PK0N123";

        /* #####################*/
           /* validate fields*/
        /* #####################*/

  if (PK0NM001.PK0NMRJT == " ")
     /* next sentence*/
  else
    if (PK0NM001.PK0NMRJT == "Y")
      if (PK0NM001.PK0NMACT != " ")
        converseLib.validationFailed(230); /* enter either reject all flag or*/
                                   /* action code*/
        set PK0NM001.PK0NMRJT bold;
        set PK0NM001.PK0NMACT cursor, bold;
        PK0NW01.PK0NWERR = "Y";
        PK0NM001.XXXERRID = "PK0N123";
        return;
      end
      PK0NW01.PK0NWBLA = "N"; /* no need to build array*/
      PK0NW01.PK0NWANO = "N";
      return;
    else
      set PK0NM001.PK0NMRJT cursor, bold;
      PK0NW01.PK0NWERR = "Y";
      PK0NM001.XXXERRID = "PK0N123";
      converseLib.validationFailed(234); /* invalid reject all flag*/
      return;
    end
  end

   /* see if product data was entered*/

  PK0NW01.PK0NWPRD = "N"; /* init product entered flag*/

  if (PK0NM001.XGPCD != " "
   || PK0NM001.SY1STNBR != " "
   || PK0NM001.SY2CLRID != " "
   || PK0NM001.XDMCD != " ")
    PK0NW01.PK0NWPRD = "Y"; /* product data was entered*/
  end

   /* if apparel or footwear order, then color and dim aren't*/
   /* defaulted.  other gpc defaults to zeros for color and dim.*/

  if (PK0NM001.XGPCD == "03"
   || PK0NM001.XGPCD == "02"
   || PK0NM001.XGPCD == " ")
     /* next sentence*/
  else
    PK0NM001.SY2CLRID = "00";
    PK0NM001.XDMCD = "00";
  end

   /* make sure all product data was entered if any was*/

  if (PK0NW01.PK0NWPRD == "Y")
    if (PK0NM001.XDMCD == " ")
      set PK0NM001.XDMCD cursor, bold;
      PK0NW01.PK0NWERR = "Y";
    end

    if (PK0NM001.SY2CLRID == " ")
      set PK0NM001.SY2CLRID cursor, bold;
      PK0NW01.PK0NWERR = "Y";
    end

    if (PK0NM001.SY1STNBR == " ")
      set PK0NM001.SY1STNBR cursor, bold;
      PK0NW01.PK0NWERR = "Y";
    end

    if (PK0NM001.XGPCD == " ")
      set PK0NM001.XGPCD cursor, bold;
      PK0NW01.PK0NWERR = "Y";
    end

    if (PK0NW01.PK0NWERR == "Y")
      converseLib.validationFailed(196); /* NEED TO ENTER all product info or*/
                                   /* none of it*/
      PK0NS51(); /* clear detail lines*/
      PK0NM001.XXXERRID = "PK0N122";
      return;
    end
  end

   /* if user enters either pack by flag then can't*/
   /* enter much else*/

  PK0NW01.PK0NWPSS = "N"; /* init processing pack by flags*/
  if (PK0NM001.PK0NMPBS == "Y"
   || PK0NM001.PK0NMPSS == "Y")
    PK0N128(); /* check fields*/
    if (PK0NW01.PK0NWERR == "Y")
      return;
    end
    PK0N125(); /* validate data does exist on pool*/
                                   /* header/detail*/
    if (PK0NW01.PK0NWERR == "Y")
      return;
    end

    PK0NW01.PK0NWFST = "N";
    PK0NW01.PK0NWANO = "N";
    PK0NW01.PK0NWPSS = "Y"; /* processing pack by flags*/
    return;
  end

   /* see if user can change key fields*/

  PK0N127();
  if (PK0NW01.PK0NWERR == "Y")
    return;
  end

   /* validate quantity fields*/

  if (PK0NM001.PK0NMACT == "A"
   || PK0NM001.PK0NMACT == "C")

    if (PK0NM001.PK0NMSTR is modified
     && PK0NM001.PK0NMSTR != PK0NW01.PK0NMSTR)
         /* next sentence*/
    else
      if (PK0NM001.PK0NMEND is modified
       && PK0NM001.PK0NMEND != PK0NW01.PK0NMEND)
           /* next sentence*/
      else

        PK0NW01.PK0NWCT1 = 20;

        while (PK0NW01.PK0NWCT1 > 0)

          if (PK0NM001.SY4IDDSC[PK0NWCT1] != " ")
                 /* user entered qty must be less than allocated qty*/

            if (PK0NM001.PKTPPQTY[PK0NWCT1] > PK0NM001.PK1QTY[PK0NWCT1])
              converseLib.validationFailed(225);
                                   /* entered qty must be < aloc qty*/
              set PK0NM001.PKTPPQTY[PK0NWCT1] cursor, bold;
              PK0NW01.PK0NWERR = "Y";
            end
          else

               /* not allowed to enter qtys on non valid sizes*/

            if (PK0NM001.SY4IDDSC[PK0NWCT1] == " "
             && PK0NM001.PKTPPQTY[PK0NWCT1] > 0)
              converseLib.validationFailed(233); /* non valid sizes can not have qtys*/
              set PK0NM001.PKTPPQTY[PK0NWCT1] cursor, bold;
              PK0NW01.PK0NWERR = "Y";
            end
          end

          PK0NW01.PK0NWCT1 = PK0NW01.PK0NWCT1 - 1;
        end

        if (PK0NW01.PK0NWERR == "Y")
          return;
        end

      end
    end
  end

   /* validate whether start/end size should be entered*/

  if (PK0NM001.PK0NMACT == "A")
    if (PK0NM001.PK0NMSTR != " "
     && PK0NM001.PK0NMEND == " ")
      converseLib.validationFailed(219); /* need to enter ending size*/
      PK0NW01.PK0NWERR = "Y";
      set PK0NM001.PK0NMEND cursor, bold;
      return;
    end
  end

   /* validate deleting of records*/

  if (PK0NM001.PK0NMACT == "D")
    if (PK0NW01.PK0NWPRD == "N")
      converseLib.validationFailed(245); /* to delete order use reject field*/
      set PK0NM001.PK0NMACT cursor, bold;
      PK0NW01.PK0NWERR = "Y";
      PK0NS51(); /* clear detail lines*/
      return;
    end
  end

   /* validate starting and ending size*/

  if (PK0NM001.PK0NMSTR == " "
   && PK0NM001.PK0NMEND != " ")
    converseLib.validationFailed(186); /* please enter starting size*/
    PK0NS50(); /* clear detail lines*/
    PK0NW01.PK0NWERR = "Y";
    PK0NM001.XXXERRID = "PK0N123";
    return;
  end

end // end PK0N123

// set first time thru flag
Function PK0N124()
   /* ***********************************************************/
   /* *  decide if this is first time thru*/
   /* ***********************************************************/

  PK0NM001.XXXERRID = "PK0N124";

   /* if action code is delete and size was only field to*/
   /* change then this isn't considered first time thru*/

  if (PK0NM001.PK0NMACT == "D")
    if (PK0NW01.PK0NWLP1 == 0) /* haven't built array yet*/
      PK0NW01.PK0NWFST = "Y"; /* first time thru*/
      PK0NW01.PK0NWBLA = "Y"; /* need to build array*/
    else
      PK0NW01.PK0NWFST = "N"; /* not really first time thru*/
      PK0NW01.PK0NWBLA = "N"; /* already have array built*/
      return;
    end
  end

  if (PK0NM001.XWHCD is modified
   || PK0NM001.PK1CUOID is modified
   || PK0NM001.PK1NORID is modified
   || PK0NM001.XGPCD is modified
   || PK0NM001.SY1STNBR is modified
   || PK0NM001.SY2CLRID is modified
   || PK0NM001.XDMCD is modified
   || PK0NM001.PK0NMSTR is modified
   || PK0NM001.PK0NMEND is modified)
    if (PK0NM001.PK1CUOID is modified
     || PK0NM001.PK1NORID is modified)
      PK0NM001.XGPCD = " ";
      PK0NM001.SY1STNBR = " ";
      PK0NM001.SY2CLRID = " ";
      PK0NM001.XDMCD = " ";
      PK0NM001.PK0NMSTR = " ";
      PK0NM001.PK0NMEND = " ";
    end
    PK0NW01.PK0NWBLA = "Y";
    return;
  end

   /* if adding record*/

  if (PK0NM001.PK0NMACT == "A"
   && PK0NM001.XWHCD == PK0NW02.XWHCD
   && PK0NM001.PK1CUOID == PK0NW02.PK1CUOID
   && PK0NM001.PK1NORID == PK0NW02.PK1NORID
   && PK0NM001.XGPCD == PK0NW02.XGPCD
   && PK0NM001.SY1STNBR == PK0NW02.SY1STNBR
   && PK0NM001.SY2CLRID == PK0NW02.SY2CLRID
   && PK0NM001.XDMCD == PK0NW02.XDMCD
   && PK0NM001.PK0NMSTR == PK0NW02.PK0NMSTR
   && PK0NM001.PK0NMEND == PK0NW02.PK0NMEND)
    PK0NW01.PK0NWBLA = "N";
    PK0NW01.PK0NWFST = "N";
    return;
  end

   /* if adding records and user is adding multiple records*/
   /* per line item, then need to show sizes for the record*/
   /* before updating database.*/

  if (PK0NM001.PK0NMACT == "A"
   && PK0NM001.XWHCD == PK0NW02.XWHCD
   && PK0NM001.PK1CUOID == PK0NW02.PK1CUOID
   && PK0NM001.PK1NORID == PK0NW02.PK1NORID
   && PK0NM001.XGPCD == PK0NW02.XGPCD
   && PK0NM001.SY1STNBR == PK0NW02.SY1STNBR
   && PK0NM001.SY2CLRID == PK0NW02.SY2CLRID
   && PK0NM001.XDMCD == PK0NW02.XDMCD)
    if (PK0NM001.PK0NMSTR != PK0NW01.PK0NMSTR
     || PK0NM001.PK0NMEND != PK0NW01.PK0NMEND)
      PK0NW01.PK0NWFST = "Y"; /* first time thru*/
      PK0NW01.PK0NWBLA = "Y"; /* need to build new array*/
      return;
    else
      PK0NW01.PK0NWFST = "N"; /* not really first time thru*/
      PK0NW01.PK0NWBLA = "N"; /* already have array built*/
      return;
    end
  end

   /* if adding records and user only enters order number,*/
   /* when the screen reappears, data is in the product field.*/
   /* this looks like a first time thru but it isn't.*/

  if (PK0NM001.PK0NMACT == "A"
   && PK0NM001.XWHCD == PK0NW02.XWHCD
   && PK0NM001.PK1CUOID == PK0NW02.PK1CUOID
   && PK0NM001.PK1NORID == PK0NW02.PK1NORID
   && PK0NM001.XGPCD != " "
   && PK0NM001.SY1STNBR != " "
   && PK0NM001.SY2CLRID != " "
   && PK0NM001.XDMCD != " "
   && PK0NW01.XGPCD == " "
   && PK0NW01.SY1STNBR == " "
   && PK0NW01.SY2CLRID == " "
   && PK0NW01.XDMCD == " ")
    PK0NW01.PK0NWFST = "N"; /* not really first time thru*/
    PK0NW01.PK0NWBLA = "N"; /* already have array built*/
  end

   /* if user changes data to be browsed then*/
     /* need to build array for new set of line items to be shown*/
   /* also if user deletes data then wants to see the same*/
     /* data (even thought the record doesn't exist)*/
     /* need to try and build prepack array.*/
   /* else if browsing an array of records then don't want to*/
     /* rebuild array.*/

  if (PK0NM001.PK0NMACT == " ")
    if (PK0NM001.PK0NMRJT == "Y")
      PK0NW01.PK0NWFST = "Y";
      PK0NW01.PK0NWBLA = "N";
    else
      if (PK0NM001.PK0NMACT is modified /* if screen was changed by user*/
       || PK0NM001.XWHCD is modified    
       || PK0NM001.PK1CUOID is modified 
       || PK0NM001.PK1NORID is modified 
       || PK0NM001.XGPCD is modified    
       || PK0NM001.SY1STNBR is modified 
       || PK0NM001.SY2CLRID is modified 
       || PK0NM001.XDMCD is modified    
       || PK0NM001.PK0NMSTR is modified)
        PK0NW01.PK0NWFST = "Y"; /* first time thru*/
        PK0NW01.PK0NWBLA = "Y"; /* need to build array*/
      else
        if (PK0NM001.XWHCD != PK0NW02.XWHCD
         /* if screen was changed by user*/
         || PK0NM001.PK1CUOID != PK0NW02.PK1CUOID
         || PK0NM001.PK1NORID != PK0NW02.PK1NORID
         || PK0NM001.XGPCD != PK0NW02.XGPCD
         || PK0NM001.SY1STNBR != PK0NW02.SY1STNBR
         || PK0NM001.SY2CLRID != PK0NW02.SY2CLRID
         || PK0NM001.XDMCD != PK0NW02.XDMCD)
          PK0NW01.PK0NWFST = "Y"; /* first time thru*/
          PK0NW01.PK0NWBLA = "Y"; /* need to build array*/
        else
          if (PK0NM001.PK0NMEND != PK0NW01.PK0NMEND)
            PK0NW01.PK0NWFST = "Y"; /* first time thru*/
            PK0NW01.PK0NWBLA = "Y"; /* need to build array*/
          else
            PK0NW01.PK0NWFST = "N"; /* not first time thru*/
            PK0NW01.PK0NWBLA = "N"; /* already have array built*/
          end
        end
      end
    end
  end

   /* if user was browsing records then decides to change the*/
   /* one that is currently on the screen, don't have to show*/
   /* record again, just update with changes*/

  if (PK0NM001.PK0NMACT == "C")
    if (PK0NM001.XWHCD == PK0NW02.XWHCD
     && PK0NM001.PK1CUOID == PK0NW02.PK1CUOID
     && PK0NM001.PK1NORID == PK0NW02.PK1NORID
     && PK0NM001.XGPCD == PK0NW02.XGPCD
     && PK0NM001.SY1STNBR == PK0NW02.SY1STNBR
     && PK0NM001.SY2CLRID == PK0NW02.SY2CLRID
     && PK0NM001.XDMCD == PK0NW02.XDMCD
     && PK0NM001.PK0NMSTR == PK0NW02.PK0NMSTR
     && PK0NM001.PK0NMEND == PK0NW02.PK0NMEND)
      PK0NW01.PK0NWFST = "N"; /* not first time thru*/
      PK0NW01.PK0NWBLA = "N"; /* already have array built*/
    end
  end
end // end PK0N124

// validate order data
Function PK0N125()
   /* ***************************************************/
     /* validate order data with data on pool*/
   /* ***************************************************/

  PK0NM001.XXXERRID = "PK0N125";

  set PK4REC empty;
  PK4REC.XWHCD = PK0NM001.XWHCD;
  PK0NW01.PK0NWCUI = PK0NM001.PK1CUOID;
  PK4REC.PK1PRTN = PK0NW01.PK1PRTN;
  PK4REC.PK1CUOID = PK0NM001.PK1CUOID;
  PK4REC.PK1NORID = PK0NM001.PK1NORID;

  PK0N910(); /* select unique from pool header*/
  if (converseVar.validationMsgNum != 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == 100)
    converseLib.validationFailed(184); /* order does not exist*/
    PK0NS53(); /* clear detail lines*/
    set PK0NM001.PK1CUOID cursor, bold;
    set PK0NM001.PK1NORID bold;
    PK0NW01.PK1CUOID = 0; /* init customer number*/
    PK0NW01.PK0NWERR = "Y";
    return;
  end

   /* validate starting and ending size*/

  if (PK0NM001.PK0NMSTR == " "
   && PK0NM001.PK0NMEND != " ")
    converseLib.validationFailed(186); /* please enter starting size*/
    PK0NS50(); /* clear detail lines*/
    set PK0NW03 empty;
    PK0NW01.PK0NWERR = "Y";
    return;
  end

   /* convert sizes to internal sizes*/

  PK0NW01.PKTBACTI = 0; /* hold internal start size*/
  PK0NW01.PK0NWEND = 0; /* hold internal end size*/
  set SYPREC empty;

  if (PK0NW01.PK0NWPRD == "Y")
    if (PK0NM001.PK0NMSTR != " ")
      PK0NS31(); /* convert sizes*/
      if (converseVar.validationMsgNum != 0)
        if (converseVar.validationMsgNum == 45) /* no data found for product*/
          set PK0NM001.XGPCD cursor, bold;
          set PK0NM001.SY1STNBR bold;
          set PK0NM001.SY2CLRID bold;
          set PK0NM001.XDMCD bold;
        end
        return;
      end
    end
  end

  PK0NM001.XXXERRID = "PK0N125";

   /* validate product data*/

  if (PK0NW01.PK0NWPRD == "Y") /* product data was entered*/
    set PK5REC empty;
    PK5REC.XWHCD = PK0NM001.XWHCD;
    PK0NW01.PK0NWCUI = PK0NM001.PK1CUOID;
    PK5REC.PK1PRTN = PK0NW01.PK1PRTN;
    PK5REC.PK1CUOID = PK0NM001.PK1CUOID;
    PK5REC.PK1NORID = PK0NM001.PK1NORID;
    PK5REC.XGPCD = PK0NM001.XGPCD;
    PK5REC.SY1STNBR = PK0NM001.SY1STNBR;
    PK5REC.SY2CLRID = PK0NM001.SY2CLRID;
    PK5REC.XDMCD = PK0NM001.XDMCD;

    PK0N922(); /* select unique on pool detail*/
    if (converseVar.validationMsgNum != 0
     || SQLCA.VAGen_SQLCODE == 100)
      converseLib.validationFailed(185); /* product does not exist on this order*/
      PK0NS50(); /* clear detail lines*/
      PK0NW01.PK0NWERR = "Y";
      set PK0NM001.XGPCD cursor, bold;
      set PK0NM001.SY1STNBR bold;
      set PK0NM001.SY2CLRID bold;
      set PK0NM001.XDMCD bold;
      return;
    end

     /* validate that start/end sizes have a qty associated with*/
     /* them on the order*/

    if (PK0NW01.PK0NWPRD == "Y")
      if (SYPREC.SY5SZID[2] != 0)
        PK0NW01.PK0NWCT1 = SYPREC.SY5SZID[2];
        if (PK5REC.PK1QTY[PK0NWCT1] == 0)
          converseLib.validationFailed(189); /* start size doesn't exist*/
          PK0NS51(); /* clear detail lines*/
          PK0NW01.PK0NWERR = "Y";
          set PK0NM001.PK0NMEND cursor, bold;
          return;
        end
      end

      if (SYPREC.SY5SZID[1] != 0)
        PK0NW01.PK0NWCT1 = SYPREC.SY5SZID[1];
        if (PK5REC.PK1QTY[PK0NWCT1] == 0)
          converseLib.validationFailed(188); /* start size doesn't exist*/
          PK0NS51(); /* clear detail lines*/
          PK0NW01.PK0NWERR = "Y";
          set PK0NM001.PK0NMSTR cursor, bold;
          return;
        end
      end
    end

     /* if this has been reached than sizes are valid*/

    PK0NW01.PKTBACTI = SYPREC.SY5SZID[1]; /* internal start size id*/
    PK0NW01.PK0NWEND = SYPREC.SY5SZID[2]; /* internal end size id*/

  end
end // end PK0N125

// can user change key fields
Function PK0N127()
   /* ***************************************************/
     /* validate flag array to see if user can change*/
     /* key fields*/
   /* ***************************************************/

  PK0NM001.XXXERRID = "PK0N127";

        /* #####################*/
      /* can user change key fields*/
        /* #####################*/

     /* (need to check reject field before any editing, because*/
     /* user can reject when there are errors on the screen)*/

  PK0NW01.PK0NWSRS = "N"; /* need to show remaining sizes*/

  if (PK0NW01.PK0NWANO == "Y"
   && PK0NWLP1 > 0) /* have built flag array*/
    if (PK0NM001.PK1CUOID != PK0NW01.PK1CUOID
     || PK0NM001.PK1NORID != PK0NW01.PK1NORID)
      PK0NW01.PK0NWRHY = "Y";
      PK0NW01.PK0NWANO = "N"; /* not adding new record*/
      set PK0NW02 empty;
      set PK0NW03 empty;
      PK0N950();
      PK0N960();
      PK0NW01.PK0NWLP1 = 0;
      PK0NW01.PK0NWLP2 = 0;

      PK0NW01.PK0NWCT1 = 1;

      while (PK0NW01.PK0NWCT1 <= 20)
        PK0NM001.SY4IDDSC[PK0NWCT1] = " ";
        PK0NM001.PKTPPQTY[PK0NWCT1] = 0;
        PK0NM001.PK0NMREM[PK0NWCT1] = 0;
        PK0NM001.PK1QTY[PK0NWCT1] = 0;

        PK0NW01.PK0NWCT1 = PK0NW01.PK0NWCT1 + 1;

      end
    end
  end

   /* if showing new records in error, the user must process all*/
   /* records before changing key fields*/

  if (PK0NW01.PK0NWSNR == "Y") /* if showing new records*/
    if (PK0NM001.PK1CUOID != PK0NW01.PK1CUOID
     || PK0NM001.PK1NORID != PK0NW01.PK1NORID
     || PK0NM001.XGPCD is modified
     || PK0NM001.SY1STNBR is modified
     || PK0NM001.SY2CLRID is modified
     || PK0NM001.XDMCD is modified)

      PK0N190();

      PK0NW01.PK0NWSNR = "N"; /* are no longer showing records*/

    end
  end

end // end PK0N127

// validate pack by flags
Function PK0N128()
   /* ***************************************************/
     /* validate that if data was entered in 'pack by'*/
     /* fields then not much else can be entered on*/
     /* the screen*/
   /* ***************************************************/

  PK0NM001.XXXERRID = "PK0N128";

   /* set non-usable fields protected*/

  if (PK0NM001.PKTNBRPP != 0)
    PK0NW01.PK0NWERR = "Y";
    set PK0NM001.PKTNBRPP cursor, bold;
  end

  if (PK0NM001.PK0NMEND != " ")
    set PK0NM001.PK0NMEND cursor, bold;
    PK0NW01.PK0NWERR = "Y";
  end

  if (PK0NM001.PK0NMSTR != " ")
    set PK0NM001.PK0NMSTR cursor, bold;
    PK0NW01.PK0NWERR = "Y";
  end

  if (PK0NM001.YNTCD != " ")
    PK0NW01.PK0NWERR = "Y";
    set PK0NM001.YNTCD cursor, bold;
  end

  if (PK0NM001.XGPCD != " "
   || PK0NM001.SY1STNBR != " "
   || PK0NM001.SY2CLRID != " "
   || PK0NM001.XDMCD != " ")
    PK0NW01.PK0NWERR = "Y";
    set PK0NM001.XGPCD cursor, bold;
    set PK0NM001.SY1STNBR bold;
    set PK0NM001.SY2CLRID bold;
    set PK0NM001.XDMCD bold;
  end

  PK0NW01.PK0NWCT1 = 1;
  while (PK0NW01.PK0NWCT1 <= 20)
    if (PK0NM001.PKTPPQTY[PK0NWCT1] != 0)
      PK0NW01.PK0NWERR = "Y";
      set PK0NM001.PKTPPQTY[PK0NWCT1] bold;
    end
    PK0NW01.PK0NWCT1 = PK0NW01.PK0NWCT1 + 1;
  end

   /* if any errors, show them to user, before protecting fields*/

  if (PK0NW01.PK0NWERR == "Y")
    converseLib.validationFailed(269);
                                   /* fields not allowed with pack by flags*/
    return;
  end

  set PK0NM001.PKTNBRPP protect;
  set PK0NM001.PK0NMSTR protect;
  set PK0NM001.PK0NMEND protect;
  set PK0NM001.YNTCD protect;
  set PK0NM001.XGPCD protect;
  set PK0NM001.SY1STNBR protect;
  set PK0NM001.SY2CLRID protect;
  set PK0NM001.XDMCD protect;

  PK0NW01.PK0NWCT1 = 1;
  while (PK0NW01.PK0NWCT1 <= 20)
    set PK0NM001.PKTPPQTY[PK0NWCT1] protect;
    PK0NW01.PK0NWCT1 = PK0NW01.PK0NWCT1 + 1;
  end
end // end PK0N128

// process screen
Function PK0N130()
   /* ******************************************************/
   /* process the action field on the map*/
   /* ******************************************************/

  PK0NM001.XXXERRID = "PK0N130";

  if (converseVar.eventKey is pf12)
    PK0NS30(); /* calculate the number of prepacks*/
  end

  if (converseVar.eventKey is pf7
   || converseVar.eventKey is pf8
   || converseVar.eventKey is pf12
   || converseVar.eventKey is pa2)
    PK0NW01.PK0NWUPD = "N";
    return;
  end

   /* process order data*/

  if (PK0NW01.PK0NWTYP == "O" /* have order data*/
   && PK0NW01.PK0NWFST == "N") /* if data on screen hasn't changed*/

    PK0NS30(); /* calculate the number of prepacks*/
  end

  if (PK0NW01.PK0NWANO == "Y") /* if we have flag array*/
    if (PK0NM001.PK0NMACT == "A"
     && PK0NW01.PK0NWFST == "N") /* can't set flag with no data*/
      PK0N131(); /* set flags in array*/
    else
      if (PK0NM001.PK0NMACT == "D")
        PK0N131(); /* set flags in array*/
      end
    end
  end

   /* process customer data*/

  if (PK0NW01.PK0NWTYP == "C"
   && PK0NM001.PK0NMACT == "C")
    if (PK0NW01.PK0NWFST == "Y")
      converseLib.validationFailed(98); /* the record must be displayed before updated*/
      PK0NW01.PK0NWERR = "Y";
      set PK0NM001.PK0NMACT cursor, bold;
      return;
    end
  end

   /* set update flag*/

  if (PK0NW01.PK0NWTYP == "C")
    if (PK0NM001.PK0NMACT == "A"
     || PK0NM001.PK0NMACT == "C"
     || PK0NM001.PK0NMACT == "D")
      PK0NW01.PK0NWUPD = "Y";
    end
  else
    if (PK0NM001.PK0NMACT == "D"
     || PK0NM001.PK0NMRJT == "Y")
      set PK0NM001.PK0NMACT cursor;
      PK0NW01.PK0NWUPD = "Y";
    else
      if (PK0NW01.PK0NWFST == "Y")
         /* next sentence*/
      else
        if (converseVar.validationMsgNum == 0)
          if (PK0NM001.PK0NMACT == "A"
           || PK0NM001.PK0NMACT == "C")
            PK0NW01.PK0NWUPD = "Y";
          end
        end
      end
    end
  end
end // end PK0N130

// set flags in array
Function PK0N131()
   /* ******************************************************/
   /* set flags in array*/
   /* ******************************************************/

  PK0NM001.XXXERRID = "PK0N131";

  PK0NW01.PK0NWCT1 = 1;
  PK0NW01.PK0NWCT2 = 1;

  set PK0NW03 empty;
  PK0NW01.PK0NWCP1 = 1;
  PK0N953();
  if (TA5REC.TA5RTNCD != 0)
    PK0N954(); /* set temp storage empty*/
    return;
  end

   /* make sure that we have correct record to be updated*/
   /* then make sure we have correct size to be updated*/
   /* then update size done flag for each valid size*/

  while (PK0NM001.XGPCD != PK0NW03.XGPCD
   || PK0NM001.SY1STNBR != PK0NW03.SY1STNBR
   || PK0NM001.SY2CLRID != PK0NW03.SY2CLRID
   || PK0NM001.XDMCD != PK0NW03.XDMCD)

    PK0NW01.PK0NWCP1 = PK0NW01.PK0NWCP1 + 1;
    PK0N953(); /* read temp storage page*/
    if (TA5REC.TA5RTNCD == 7) /* end of file*/
      return; /* NOTHING ELSE TO BE DONE HERE*/
    end
    if (TA5REC.TA5RTNCD != 0)
      PK0N954(); /* set temp storage empty*/
      return;
    end
  end

   /* found record in flag array that matches prepack record*/

  if (PK0NM001.XGPCD == PK0NW03.XGPCD
   && PK0NM001.SY1STNBR == PK0NW03.SY1STNBR
   && PK0NM001.SY2CLRID == PK0NW03.SY2CLRID
   && PK0NM001.XDMCD == PK0NW03.XDMCD)

    if (PK0NM001.PK0NMACT == "A")

      while (PK0NW01.PK0NWCT1 <= 20
       && PK0NW01.PK0NWCT2 <= 40
       && PK0NM001.SY4IDDSC[PK0NWCT1] != " ")

        while (PK0NM001.SY4IDDSC[PK0NWCT1] != PK0NW03.SY4IDDSC[PK0NWCT2]
         && PK0NW01.PK0NWCT1 <= 20
         && PK0NW01.PK0NWCT2 <= 40)

          PK0NW01.PK0NWCT2 = PK0NW01.PK0NWCT2 + 1;
        end

         /* have correct size*/

        if (PK0NW03.SY4IDDSC[PK0NWCT2] == PK0NM001.SY4IDDSC[PK0NWCT1])
          if (PK0NM001.PKTPPQTY[PK0NWCT1] > 0)

              /* if adding record, set size done to yes*/

            PK0NW03.PK0NWSDN[PK0NWCT2] = "Y"; /* size is done*/
          end
        end

        PK0NW01.PK0NWCT1 = PK0NW01.PK0NWCT1 + 1;
        PK0NW01.PK0NWCT2 = PK0NW01.PK0NWCT2 + 1;

      end

      PK0N952(); /* update record*/
      if (converseVar.validationMsgNum != 0)
        return;
      end

    else

       /* set all size buckets containing prepack quantities to 0*/
       /* and set flag saying 'these quantities aren't complete'*/

      if (PK0NM001.PK0NMACT == "D")
        PKTREC.XWHCD = PK0NM001.XWHCD;
        PKTREC.PK1CUOID = PK0NM001.PK1CUOID;
        PKTREC.PK1NORID = PK0NM001.PK1NORID;
        if (PK0NW01.PK0NWPRD == "Y")
          PKTREC.XGPCD = PK0NM001.XGPCD;
          PKTREC.SY1STNBR = PK0NM001.SY1STNBR;
          PKTREC.SY2CLRID = PK0NM001.SY2CLRID;
          PKTREC.XDMCD = PK0NM001.XDMCD;
        else
          PKTREC.XGPCD = "*";
          PKTREC.SY1STNBR = "*";
          PKTREC.SY2CLRID = "*";
          PKTREC.XDMCD = "*";
        end
        if (PK0NM001.PK0NMSTR == " ")
          PKTREC.PKTBACTI = -1;
        else
          PKTREC.PKTBACTI = PK0NW01.PKTBACTI;
        end

        PK0N916(); /* select set from prepack*/
        if (converseVar.validationMsgNum != 0)
          PK0N918(); /* close cursor*/
          return;
        end

        PK0N917(); /* fetch next record from prepack*/
        if (converseVar.validationMsgNum != 0)
          PK0N918(); /* close cursor*/
          return;
        end

        while (SQLCA.VAGen_SQLCODE == 0)
          PK0NW01.PK0NWCT1 = 1;

          while (PK0NW01.PK0NWCT1 <= 40)
            if (PKTREC.PKTPPQTY[PK0NWCT1] > 0)
              PK0NW03.PK0NWSDN[PK0NWCT1] = "N"; /* size is no longer done*/
            end

            PK0NW01.PK0NWCT1 = PK0NW01.PK0NWCT1 + 1;
          end

          PK0N917(); /* fetch next record from prepack*/
          if (converseVar.validationMsgNum != 0)
            PK0N918(); /* close cursor*/
            return;
          end
        end
        PK0N952(); /* update record*/
        if (TA5REC.TA5RTNCD != 0)
          PK0N954(); /* set temp storage empty*/
          return;
        end
        PK0N918(); /* close cursor*/
        if (converseVar.validationMsgNum != 0)
          return;
        end

      end
    end
  end
end // end PK0N131

// update database
Function PK0N140()
   /* *******************************************************/
   /* update database*/
   /* *******************************************************/

  PK0NM001.XXXERRID = "PK0N140";

   /* update order data or customer data*/

  if (PK0NW01.PK0NWTYP == "O")
    PK0N141();
  else
    PK0N142();
  end

end // end PK0N140

// update database for orders
Function PK0N141()
   /* *******************************************************/
   /* update database for orders*/
   /* *******************************************************/

  PK0NM001.XXXERRID = "PK0N141";

   /* the user wants to delete all records with*/
   /* specified order nbr*/

  if (PK0NM001.PK0NMRJT == "Y")
    PK0N144(); /* reject order*/
    return; /* and exit here.................*/
  end

   /* ******************************************/
   /* set PKTREC key including first size*/
   /* ******************************************/

  set PKTREC empty;

  PKTREC.XWHCD = PK0NM001.XWHCD;
  PKTREC.PK1CUOID = PK0NM001.PK1CUOID;
  PK0NW01.PK0NWCUI = PK0NM001.PK1CUOID;
  PKTREC.PK1PRTN = PK0NW01.PK1PRTN;
  PKTREC.PK1NORID = PK0NM001.PK1NORID;

  PKTREC.XGPCD = PK0NM001.XGPCD;
  PKTREC.SY1STNBR = PK0NM001.SY1STNBR;
  PKTREC.SY2CLRID = PK0NM001.SY2CLRID;
  PKTREC.XDMCD = PK0NM001.XDMCD;

   /* find internal size for first size on map*/

  if (PK0NW01.PKTBACTI != 0)
    PKTREC.PKTBACTI = PK0NW01.PKTBACTI;
  else

    PK0NW01.PK0NWCT1 = 1;
    PK0NW01.PK0NWCT2 = 1;

    while (PK0NW01.PK0NWCT1 <= 19
     && PK0NW01.PK0NWCT2 <= 39
     && PK0NM001.SY4IDDSC[PK0NWCT1] != PK0NW02.SY4IDDSC[PK0NWCT2])

      PK0NW01.PK0NWCT2 = PK0NW01.PK0NWCT2 + 1;

    end

    if (PK0NM001.SY4IDDSC[PK0NWCT1] == PK0NW02.SY4IDDSC[PK0NWCT2])
      PKTREC.PKTBACTI = PK0NW02.SY5SZID[PK0NWCT2]; /* move start size*/
      PK0NW01.PKTBACTI = PK0NW02.SY5SZID[PK0NWCT2];
    end
  end

  if (PK0NW01.PKTBACTI == 0)
    PKTREC.PKTBACTI = -1;
  end

   /* ************************************* **/
   /* do table updates for adds and changes **/
   /* ************************************* **/

  if (PK0NM001.PK0NMACT == "A"
   || PK0NM001.PK0NMACT == "C")

    if (PK0NM001.PK0NMACT == "A")
      PK0NS-UPDATE-ADD();
      if (converseVar.validationMsgNum != 0)
        return;
      end
    else
      PK0NS-UPDATE-CHNG();
      if (converseVar.validationMsgNum != 0)
        return;
      end
    end

  else
    PK0N920(); /* delete from prepack*/
    if (converseVar.validationMsgNum != 0)
      return;
    end

     /* ****************************************************/
     /* delete all prepack records for this product number*/
     /* ****************************************************/

    if (PK0NM001.PK0NMACT == "D"
     && PK0NW01.PK0NWLP2 > 0)

       /* clear quantities from array and screen*/

      if (PK0NM001.PK0NMSTR == " ")
        PK0NS50(); /* clear detail lines*/
      else
        PK0NS52(); /* clear quantities*/
      end
      PK0N962(); /* update prepack record*/
      if (converseVar.validationMsgNum != 0)
        return;
      end
    end
  end

  if (PK0NM001.PK0NMACT == "D"
   && SQLCA.VAGen_SQLCODE == 100)
    converseLib.validationFailed(211); /* record to be deleted couldn't be*/
                                   /* found*/
    set PK0NM001.PK1CUOID cursor, bold;
    set PK0NM001.PK1NORID bold;
    set PK0NM001.XGPCD bold;
    set PK0NM001.SY1STNBR bold;
    set PK0NM001.SY2CLRID bold;
    set PK0NM001.XDMCD bold;
    PK0NS51(); /* clear detail lines*/
    PK0NW01.PK0NWERR = "Y";
    return;
  end

   /* *******************************************/
   /* Finally, do pool header and item changes.*/
   /* *******************************************/

  if (PK0NW01.PK0NWERR == "N")
    PK0NS-XPA-AND-QTY();
  end

  if (PK0NW01.PK0NWERR == "Y")
    return;
  end

       /* all done show message*/

  if (PK0NM001.PK0NMACT == "A")
    converseLib.validationFailed(93); /* record was added*/
  else
    if (PK0NM001.PK0NMACT == "C")
      converseLib.validationFailed(32); /* table update was successful*/
    else
      if (PK0NM001.PK0NMACT == "D")
        converseLib.validationFailed(199); /* record was deleted*/
      else
      end
    end
  end

  PK0NM001.PK0NMACT = " ";

end // end PK0N141

// update database for customer
Function PK0N142()
   /* *******************************************************/
   /* update database for customer prepack*/
   /* *******************************************************/

  PK0NM001.XXXERRID = "PK0N142";

  set PKSREC empty;

  if (PK0NM001.PK0NMACT == "C")

     /* find setup date and change count for record*/

    PKSREC.XWHCD = PK0NM001.XWHCD;
    PKSREC.KUCCOID = PK0NM001.KUCCOID;
    PKSREC.KUMSTRID = PK0NM001.KUMSTRID;
    PKSREC.XNXCD = PK0NM001.XNXCD;

    PK0N925(); /* select unique from orders prepack*/
    if (converseVar.validationMsgNum != 0)
      return;
    end
  end

   /* get the current date and time for the database update*/

  set TA2REC empty;
  TA2REC.TA2DTOPT = "GETDATE";
  call "TA0040" (TA2REC) {isNoRefresh = yes, isExternal = yes};
  if (TA2REC.TA2RTNCD == 0)
    PKSREC.ZZZCHGTM = TA2REC.TA2TIMHM;
    PKSREC.ZZZCHGDT = TA2REC.TA2GRGGN;
    if (PK0NM001.PK0NMACT == "A")
      PKSREC.ZZZSDT = TA2REC.TA2GRGGN;
    end
  else
    converseLib.validationFailed(29); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    PK0NW01.PK0NWERR = "Y"; /* there was an error*/

    TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
    TA1REC.TA1PGMNM = "TA0040 "; /* Process name*/
    TA1REC.TA1LOC = "GETTING CURRENT DATE/TIME";
    TA1REC.TA1MAP = "PK0NM001"; /* Map name*/

    call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    PK0NM001.XXXERRID = "PK0N142 "; /* Error location*/
    return; /* Return to previous process*/

  end

  if (PK0NM001.PK0NMACT == "A" /* add or change must have*/
   || PK0NM001.PK0NMACT == "C") /* pack flag*/
    if (PK0NM001.PK0NMPBS == "Y")
      PKSREC.PKSSSZFL = "N";
    else
      if (PK0NM001.PK0NMPSS == "Y")
        PKSREC.PKSSSZFL = "Y";
      else
        converseLib.validationFailed(203);
        return;
      end
    end
  end

    /* add record*/

  if (PK0NM001.PK0NMACT == "A")
    PK0N143(); /* validate and add cust nbr*/
    if (converseVar.validationMsgNum > 0)
      return; /* return if error*/
    else
      PK0N146(); /* add xpa to vpoolh01*/
      converseLib.validationFailed(93); /* added to db message*/
      return;
    end
  end

   /* delete record and then maybe add it later*/

  PKSREC.XWHCD = PK0NM001.XWHCD;
  PKSREC.KUCCOID = PK0NM001.KUCCOID;
  PKSREC.KUMSTRID = PK0NM001.KUMSTRID;
  PKSREC.XNXCD = PK0NM001.XNXCD;

  PK0N923(); /* delete from prepack*/
  if (converseVar.validationMsgNum != 0)
    return;
  end

  if (PK0NM001.PK0NMACT == "D"
   && SQLCA.VAGen_SQLCODE == 100)
    converseLib.validationFailed(201); /* record to be deleted doesn't exist*/
    PK0NW01.PK0NWERR = "Y";
    set PK0NM001.KUCCOID cursor, bold;
    set PK0NM001.KUMSTRID bold;
    set PK0NM001.XNXCD bold;
    return;
  end

  if (PK0NM001.PK0NMACT == "D")
    PK0N146(); /* clear xpa off vpoolh01*/
    if (converseVar.validationMsgNum != 0)
      return;
    end
  end

      /* ****************/
       /* change record*/
      /* ****************/

  if (PK0NM001.PK0NMACT == "C")
    PK0N924(); /* add to prepack*/
    PK0N146(); /* add xpa to vpoolh01*/
    if (converseVar.validationMsgNum != 0)
      return;
    end
  end

       /* show message*/

  if (PK0NM001.PK0NMACT == "C")
    converseLib.validationFailed(32); /* table update was successful*/
  else
    if (PK0NM001.PK0NMACT == "D")
      converseLib.validationFailed(199); /* record was deleted*/
    else
    end
  end
end // end PK0N142

// add customer
Function PK0N143()
   /* *******************************************************/
   /* add customer*/
   /* *******************************************************/

  PK0NM001.XXXERRID = "PK0N143";

    /* validate customer number*/

  PK4REC.XWHCD = PK0NM001.XWHCD;
  PK4REC.KUCCOID = PK0NM001.KUCCOID;
  PK4REC.KUMSTRID = PK0NM001.KUMSTRID;
  PK4REC.XNXCD = PK0NM001.XNXCD;

  PK0N933(); /* select set from pick pool header*/
  if (converseVar.validationMsgNum != 0)
    PK0NW01.PK0NWERR = "Y";
    return;
  end

  PK0N934(); /* fetch next from pick pool header*/
  if (converseVar.validationMsgNum != 0)
    PK0NW01.PK0NWERR = "Y";
    return;
  end

  if (SQLCA.VAGen_SQLCODE == 0)
    PK0N935(); /* close poolhdr*/
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      PK0N935(); /* close poolhdr*/
      PK6REC.KUCCOID = PK0NM001.KUCCOID;
      PK6REC.KUMSTRID = PK0NM001.KUMSTRID;

      PK0N911(); /* select unique from picking customer table*/
      if (converseVar.validationMsgNum != 0)
        PK0NW01.PK0NWERR = "Y";
        return;
      end

       /* validate status of record*/

      if (SQLCA.VAGen_SQLCODE == 100)
        converseLib.validationFailed(175); /* customer nbr is not in picking cust nbr file*/
        set PK0NM001.KUCCOID cursor, bold;
        set PK0NM001.KUMSTRID bold;
        set PK0NM001.XNXCD bold;
        PK0NW01.PK0NWERR = "Y";
        return;
      else
        converseLib.validationFailed(202); /* warning - customer not in pool added anyway*/
      end
    end
  end

  PKSREC.XWHCD = PK0NM001.XWHCD;
  PKSREC.KUCCOID = PK0NM001.KUCCOID;
  PKSREC.KUMSTRID = PK0NM001.KUMSTRID;
  PKSREC.XNXCD = PK0NM001.XNXCD;

   /* inquire to see if record already exists*/

  PK0N925(); /* select unique from customer prepack*/
  if (converseVar.validationMsgNum == 202)
     /* next sentence - no error in select stmt*/
  else
    if (converseVar.validationMsgNum != 0)
      return;
    end
  end

  if (SQLCA.VAGen_SQLCODE == 0)
    converseLib.validationFailed(44); /* record to be added already exists*/
    set PK0NM001.KUCCOID cursor, bold;
    set PK0NM001.KUMSTRID bold;
    set PK0NM001.XNXCD bold;
    PK0NM001.PK0NMPBS = " ";
    PK0NM001.PK0NMPSS = " ";
    PK0NW01.PK0NWERR = "Y";
    return;
  end

  PK0N924(); /* add record to customer prepack*/
  if (converseVar.validationMsgNum != 0)
    return;
  end

  PKSREC.PKSSSZFL = PKSREC.PKSSSZFL; /* test only*/
end // end PK0N143

// reject order
Function PK0N144()
   /* *******************************************************/
   /* PK0N144*/
   /* update database for orders rejected*/
   /* *******************************************************/

  PK0NM001.XXXERRID = "PK0N144";

   /* the user wants to delete all records with*/
   /* specified order nbr*/

  PKTREC.XWHCD = PK0NM001.XWHCD;
  PKTREC.PK1CUOID = PK0NM001.PK1CUOID;
  PKTREC.PK1NORID = PK0NM001.PK1NORID;
  PK0N919(); /* delete many records*/
  if (converseVar.validationMsgNum != 0)
    PK0NW01.PK0NWERR = "Y";
    return;
  end

  if (SQLCA.VAGen_SQLCODE == 100)
    converseLib.validationFailed(211); /* record to be deleted couldn't be*/
                                 /* found*/
    set PK0NM001.PK1CUOID cursor, bold;
    set PK0NM001.PK1NORID bold;
    PK0NS53();
    PK0NW01.PK0NWERR = "Y";
    return;
  end

  PK0N960(); /* clear prepack array*/
  if (converseVar.validationMsgNum != 0)
    return;
  end

  PK0NW01.XPACD = "  "; /* remove XPA_CUST_PACK_CD*/
  PK4REC.XWHCD = PK0NM001.XWHCD; /* set key field*/
  PK4REC.PK1CUOID = PK0NM001.PK1CUOID; /* set key field*/
  PK4REC.PK1NORID = PK0NM001.PK1NORID; /* set key field*/

  PK0N150(); /* update VPOOLH01 XPACD*/

  if (converseVar.validationMsgNum != 0)
    return;
  end

  PK0N153(); /* update pool quantitys*/
  if (converseVar.validationMsgNum != 0)
    return;
  end

  converseLib.validationFailed(200); /* all records with order nbr deleted*/
  PK0NS53(); /* clear detail lines on map*/

end // end PK0N144

// update xpa code on vpoolh01
Function PK0N146()
   /* *******************************************************/
   /* update vpoolh01, all orders for a customer*/
   /* *******************************************************/

  PK0NM001.XXXERRID = "PK0N146";

                                  /* figure out XPA code*/
  if (PK0NM001.PK0NMACT == "D")
    PK0NW01.XPACD = "  "; /* set XPA_CUST_PACK_CD*/
  end

  if (PK0NM001.PK0NMACT == "A"
   || PK0NM001.PK0NMACT == "C")
                                  /* now add xpa to VPOOLH01*/
    if (PK0NW01.PK0NWPRD == "Y") /* product info specified*/
      PK0NW01.XPACD = "CU"; /* set XPA_CUST_PACK_CD*/
    else
      if (PK0NM001.PK0NMPBS == "Y") /* pack by style*/
        PK0NW01.XPACD = "PR"; /* set XPA_CUST_PACK_CD*/
      else
        if (PK0NM001.PK0NMPSS == "Y") /* pack by style/size*/
          PK0NW01.XPACD = "SK"; /* set XPA_CUST_PACK_CD*/
        else
        end
      end
    end
  end
   /* ***********************************************************************/
   /* table up all orders that need updating.*/
   /* ***********************************************************************/
  PK4REC.XWHCD = PK0NM001.XWHCD; /* want to select all orders*/
  PK4REC.KUCCOID = PK0NM001.KUCCOID; /* with same customer number*/
   /* movE -1 TO PK4REC.KUMSTRID;*/
   /* movE -1 TO PK4REC.XNXCD;*/
  PK4REC.KUMSTRID = PK0NM001.KUMSTRID;
  PK4REC.XNXCD = PK0NM001.XNXCD;

  PK0N933(); /* select set from pick pool header*/

  PK0NW05.PK0NW5IX = 0;
  PK0NW05.PK0NW5SW = "N"; /**/

  while (PK0NW05.PK0NW5SW == "N") /* is table loaded yet ?*/
    PK0N934(); /* fetch next from pick pool header*/
    if (SQLCA.VAGen_SQLCODE != 0)
      PK0NW05.PK0NW5SW = "Y"; /* error or end of cursor*/
    else
      PK0NW05.PK0NW5IX = PK0NW05.PK0NW5IX + 1;
      PK0NW05.XWHCD[PK0NW5IX] = PK4REC.XWHCD;
      PK0NW05.PK1CUOID[PK0NW5IX] = PK4REC.PK1CUOID;
      PK0NW05.PK1NORID[PK0NW5IX] = PK4REC.PK1NORID;
    end
  end

  PK0N935(); /* close poolhdr cursor*/
  if (converseVar.validationMsgNum != 0) /* exit*/
    return;
  end
   /* ***********************************************************************/
   /* update all orders in the table.*/
   /* ***********************************************************************/

  while (PK0NW05.PK0NW5IX > 0)
    PK4REC.XWHCD = PK0NW05.XWHCD[PK0NW5IX]; /* set key field*/
    PK4REC.PK1CUOID = PK0NW05.PK1CUOID[PK0NW5IX]; /* set key field*/
    PK4REC.PK1NORID = PK0NW05.PK1NORID[PK0NW5IX]; /* set key field*/
    PK4REC.XPACD = PK0NW01.XPACD; /* set XPA_CUST_PACK_CD*/
    PK0NW05.PK0NW5IX = PK0NW05.PK0NW5IX - 1;
    PK0N150(); /* update VPOOLH01*/
    if (converseVar.validationMsgNum != 0) /* if problem*/
      PK0NW05.PK0NW5IX = 0; /* exit*/
    end
  end
end // end PK0N146

// update pool header
Function PK0N150()
   /* select unique pool header. Then apply new pack code.*/
   /* PK0NW01.XPACD contains new pack code upon entering this*/
   /* routine. PK4REC has xwhcd, PK1CUOID and PK1NORID.*/
   /* This routine is performed from PK0N141 for updates by order and*/
   /* by PK0N146 for updates by customer.*/

  PK0N910(); /* select unique pool header*/
  if (converseVar.validationMsgNum != 0) /* don't continue if problems*/
    return;
  end
  if (PK4REC.XPACD == "CU") /* cannot change from 'CU'*/
    if (PK0NW01.XPACD == "PR" /* to 'PR' or 'SK'*/
     || PK0NW01.XPACD == "SK" /**/
     || PK0NW01.PK0NWTYP == "C") /* or if processing by customer*/
      return;
    end
  end

  PK4REC.XPACD = PK0NW01.XPACD; /* update XPA_CUST_PACK_CD*/

   /* get the current date and time for the database update*/

  set TA2REC empty;
  TA2REC.TA2DTOPT = "GETDATE";
  call "TA0040" (TA2REC) {isNoRefresh = yes, isExternal = yes};
  if (TA2REC.TA2RTNCD == 0)
    PK4REC.ZZZCHGTM = TA2REC.TA2TIMHM;
    PK4REC.ZZZCHGDT = TA2REC.TA2GRGGN;
  else
    converseLib.validationFailed(29); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    PK0NW01.PK0NWERR = "Y"; /* there was an error*/

    TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
    TA1REC.TA1PGMNM = "TA0040 "; /* Process name*/
    TA1REC.TA1LOC = "GETTING CURRENT DATE/TIME";
    TA1REC.TA1MAP = "PK0NM001"; /* Map name*/

    call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    PK0NM001.XXXERRID = "PK0N150 "; /* Error location*/
    return; /* Return to previous process*/

  end

                                  /* let 'er rip*/
  PK0N970(); /* update VPOOLH01 with new xpa code*/
                                  /*  */
  return;
end // end PK0N150

// pool quantitys control
Function PK0N151()
   /* *******************************************************/
   /* update pool header and item quantitys*/
   /* to repack if in prepack table, and*/
   /* full case if not.*/
   /* Key fields for PK4REC & PK5REC must be set*/
   /* in calling modules.*/
   /* *******************************************************/

  PK0NM001.XXXERRID = "PK0N151";

  if (PK0NM001.PK0NMACT == "A") /* adding order to prepack*/

    PK0N153(); /* update header and item*/
    return;

  end

   /* need to find out if prepack records exist*/
   /* if they don't, then we need to edit pool tables.*/

  PK0N928(); /* open prepack*/

  if (converseVar.validationMsgNum != 0)
    PK0N930(); /* close prepack*/
    return;
  end

  PK0N929(); /* fetch prepack*/
  if (SQLCA.VAGen_SQLCODE == 100)
    PK0N153(); /* update header item qty's*/
  end

  PK0N930(); /* close prepack*/

end // end PK0N151

// edit pool quantitys
Function PK0N153()
   /* ************************************************************/
   /* *   Editing pool header and items quantity's*/
   /* **/
   /* *   If adding a record,*/
   /* *       zero out the full case quantity, and*/
   /* *       set repack quantity to item total qty.*/
   /* *   If deleting a record*/
   /* *       zero out the repack quantity, and*/
   /* *       set full case qty to item total qty.*/
   /* *   If changing a record, don't change a thing.*/
   /* *       Key fields have been set in PK0N141.*/
   /* *           Current XPACD was also set in 141.*/
   /* ************************************************************/

  PK0N912(); /* open item cursor*/

  if (SQLCA.VAGen_SQLCODE == 0)
    PK0N913(); /* fetch next item*/
  else
    PK0N914(); /* close item cursor*/
    return;
  end

  if (PK0NM001.PK0NMACT == "A" /* adding records*/
  )                           
    while (SQLCA.VAGen_SQLCODE == 0)

      PK5REC.PK5ITMFC = 0; /* full case quantity*/
      PK5REC.PK5ITMRP = PK5REC.PK5TIQTY; /* repack quantity*/
      PK0N971(); /* update item*/

      if (SQLCA.VAGen_SQLCODE == 0)
        PK0N913(); /* fetch next item*/
      end

    end

    PK4REC.PK4ORDRP = PK4REC.PK4OTUNT; /* update order*/
    PK4REC.PK4ORDFC = 0; /* prepack is 100 % repack*/

  else /* Deleting records*/

    PK0NW01.PK0NW-ORD-REPK-QTY = 0; /* header repack qty*/
    PK0NW01.PK0NW-ORD-FUL-CS-QTY = 0; /* header fullcase qty*/

    if (PK5REC.SY1UNPCS == 0
     || PK4REC.XPACD == "CU") /* XPACD was set in prev module*/
      while (SQLCA.VAGen_SQLCODE == 0)

        PK5REC.PK5ITMFC = PK5REC.PK5TIQTY;
        PK5REC.PK5ITMRP = 0;

        PK0N971(); /* update item*/

        if (SQLCA.VAGen_SQLCODE == 0)
          PK0N913(); /* fetch next item*/
        end
      end
      PK0NW01.PK0NW-ORD-FUL-CS-QTY = PK4REC.PK4OTUNT;
    else
      while (SQLCA.VAGen_SQLCODE == 0) /* still items to process*/

        PK0NW01.PK0NWCT4 = 0; /* initialize counter*/
        PK0NW-ITM-REPK-QTY = 0; /* item repack qty*/
        PK0NW-ITM-FUL-CS-QTY = 0; /* item fullcase qty*/
        PK5REC.PK5ITMRP = 0;
        PK5REC.PK5ITMFC = 0;

        while (PK0NW01.PK0NWCT4 <= 39) /* go through all the sizes*/
          PK0NW01.PK0NWCT4 = PK0NW01.PK0NWCT4 + 1;

          if (PK5REC.PK1QTY[PK0NWCT4] > 0)

   /* dividend result*/
            PK0NW-ITM-FUL-CS-QTY = PK5REC.PK1QTY[PK0NWCT4] / PK5REC.SY1UNPCS;

   /* remainder result*/
            PK0NW-ITM-REPK-QTY = PK5REC.PK1QTY[PK0NWCT4] % PK5REC.SY1UNPCS;

   /* dividend times multiplier*/
            PK0NW-ITM-FUL-CS-QTY = PK0NW-ITM-FUL-CS-QTY * PK5REC.SY1UNPCS;

            PK5REC.PK5ITMRP = PK5REC.PK5ITMRP + PK0NW-ITM-REPK-QTY;
            PK5REC.PK5ITMFC = PK5REC.PK5ITMFC + PK0NW-ITM-FUL-CS-QTY;

            PK0N971(); /* update item*/

          end
        end

        PK0NW-ORD-REPK-QTY = PK0NW-ORD-REPK-QTY + PK5REC.PK5ITMRP;
        PK0NW-ORD-FUL-CS-QTY = PK0NW-ORD-FUL-CS-QTY + PK5REC.PK5ITMFC;

        if (SQLCA.VAGen_SQLCODE == 0)
          PK0N913(); /* fetch next item*/
        end

      end /* still items*/
    end

    PK4REC.PK4ORDRP = PK0NW-ORD-REPK-QTY; /* update orders*/
    PK4REC.PK4ORDFC = PK0NW-ORD-FUL-CS-QTY;

  end

  if (converseVar.validationMsgNum == 0)
    PK0N970(); /* Update the pool header.*/
  end

  PK0N914(); /* close item cursor regardless of*/
                                   /* errors.*/

end // end PK0N153

// build array of flags for order
Function PK0N160()
   /* **************************************************/
     /* build array for order processing*/
   /* **************************************************/

  PK0NM001.XXXERRID = "PK0N160";

   /* check all entered data to validate its existence on pool*/
   /* header, pool detail or size tables*/

   /* if data is valid, it is moved into temp storage. if any*/
   /* data is invalid the temp storage is cleared out*/

  PK0N950(); /* purge temp storage*/
  set PK0NW03 empty; /* clear products from array*/

   /* move product data into temp storage*/

  set PK5REC empty;
  PK5REC.XWHCD = PK0NM001.XWHCD;
  PK0NW01.PK0NWCUI = PK0NM001.PK1CUOID;
  PK5REC.PK1PRTN = PK0NW01.PK1PRTN;
  PK5REC.PK1CUOID = PK0NM001.PK1CUOID;
  PK5REC.PK1NORID = PK0NM001.PK1NORID;
  PK5REC.PK1LNINB = -1;

  PK0N912(); /* select set on pool detail*/
  if (PK0NW01.PK0NWERR == "Y")
    PK0N914(); /* close pool detail*/
    return;
  end

  PK0N913(); /* fetch next from pool detail*/
  if (PK0NW01.PK0NWERR == "Y")
    PK0N914(); /* close pool detail*/
    return;
  end

  if (SQLCA.VAGen_SQLCODE == 100)
    return; /* no data in prepack table*/
  end

   /* handle pack by data*/

  if (PKTREC.PKSSSZFL != " ")
    return; /* no sizes to build flag array from*/
  end

  PK0NW01.PK0NWCT1 = 1;
  PK0NW01.PK0NWCT2 = 0;

  while (SQLCA.VAGen_SQLCODE == 0)
    PK0NW03.XWHCD = PK0NM001.XWHCD;
    PK0NW03.PK1CUOID = PK0NM001.PK1CUOID;
    PK0NW03.PK1NORID = PK0NM001.PK1NORID;
    PK0NW03.XGPCD = PK5REC.XGPCD;
    PK0NW03.SY1STNBR = PK5REC.SY1STNBR;
    PK0NW03.SY2CLRID = PK5REC.SY2CLRID;
    PK0NW03.XDMCD = PK5REC.XDMCD;

    PK0N161(); /* move sizes to array and write temp storage*/
    if (PK0NW01.PK0NWERR == "Y")
      PK0N914(); /* close pool detail*/
      return;
    end

    PK0N913(); /* fetch next from pool detail*/
    if (PK0NW01.PK0NWERR == "Y")
      PK0N914(); /* close pool detail*/
      return;
    end

  end

  PK0N914(); /* close pool detail*/

end // end PK0N160

// move sizes into order array
Function PK0N161()
   /* **************************************************/
     /* move sizes to temp storage*/
   /* **************************************************/

  PK0NM001.XXXERRID = "PK0N161";

   /* check entered sizes to validate their existence*/

   /* move sizes into tempory storage.*/

  set SYPREC empty;
  SYPREC.SYPFC = "PC"; /* product code*/
  SYPREC.SYPCMPSW = "N"; /* compressed data*/
  SYPREC.XGPCD = PK0NW03.XGPCD;
  SYPREC.SY1STNBR = PK0NW03.SY1STNBR;
  SYPREC.SY2CLRID = PK0NW03.SY2CLRID;
  SYPREC.XDMCD = PK0NW03.XDMCD;
  SYPREC.XQACD = "**";

  PK0N915(); /* select size desc from sy1190*/
  if (PK0NW01.PK0NWERR == "Y")
    return;
  end

  PK0NW01.PK0NWCT1 = 1;

  while (PK0NW01.PK0NWCT1 <= 40)

     /* move data only into sizes that have allocated qtys*/
     /* and are valid*/

    if (PK5REC.PK1QTY[PK0NWCT1] == 0 /* don't move in data*/
     || SYPREC.SY5SZID[PK0NWCT1] == 0)
      PK0NW03.SY4IDDSC[PK0NWCT1] = " ";
      PK0NW03.SY5SZID[PK0NWCT1] = 0;
      PK0NW03.PK1QTY[PK0NWCT1] = 0;
    else
      PK0NW03.SY4IDDSC[PK0NWCT1] = SYPREC.SY4IDDSC[PK0NWCT1];
      PK0NW03.SY5SZID[PK0NWCT1] = SYPREC.SY5SZID[PK0NWCT1];
      PK0NW03.PK1QTY[PK0NWCT1] = PK5REC.PK1QTY[PK0NWCT1];
    end

    PK0NW01.PK0NWCT1 = PK0NW01.PK0NWCT1 + 1;

  end

   /* need to increment page number*/

  PK0NW01.PK0NWLP1 = PK0NW01.PK0NWLP1 + 1;
  PK0N951(); /* add page to temp storage*/
  if (converseVar.validationMsgNum != 0)
    PK0NW01.PK0NWLP1 = PK0NW01.PK0NWLP1 - 1;
  end
end // end PK0N161

// check off flags in order array
Function PK0N163()
   /* **************************************************/
     /* See if pool quantities have changed from*/
     /* what pre-pack thinks they are.*/
   /* **************************************************/

  PK0NM001.XXXERRID = "PK0N163";

  PK0NW01.PK0NWCT4 = 1;

  while (PK0NW01.PK0NWCT4 <= 40)

     /* if allocated qty on order doesnt match allocated*/
     /* qty on prepack, then order was changed and*/
     /* prepack records have to be changed*/

    if (PKTREC.PK1QTY[PK0NWCT4] != PK5REC.PK1QTY[PK0NWCT4])
      converseLib.validationFailed(460); /* order changed, reject prepack*/
      PK0NW01.PK0NWERR = "Y";
      PK0NW01.PK0NW-POOL-CHANGE = "Y";
      PK0NM001.YNTDESC = "  ";
      PK0NM001.YNTCD = "  ";
      return;
    end

    PK0NW01.PK0NWCT4 = PK0NW01.PK0NWCT4 + 1;

  end

end // end PK0N163

// build prepack array
Function PK0N165()
   /* ******************************************************/
   /* build the prepack array from the prepack records*/
   /* and the flag array. the flag array is used so all*/
   /* sizes will be covered; not just the ones covered*/
   /* by prepack records*/
   /* ******************************************************/

  PK0NM001.XXXERRID = "PK0N165";

            /* ######################*/
             /* read prepack records*/
            /* ######################*/

  set PKTREC empty;
  set PK0NW04 empty;

  PKTREC.XWHCD = PK0NM001.XWHCD;
  PKTREC.PK1CUOID = PK0NM001.PK1CUOID;
  PK0NW01.PK0NWCUI = PK0NM001.PK1CUOID;
  PKTREC.PK1PRTN = PK0NW01.PK1PRTN;
  PKTREC.PK1NORID = PK0NM001.PK1NORID;
  PKTREC.XGPCD = "*";
  PKTREC.SY1STNBR = "*";
  PKTREC.SY2CLRID = "*";
  PKTREC.XDMCD = "*";
  PKTREC.PKTBACTI = -1;

  PK0N916(); /* select set from prepack*/
  if (PK0NW01.PK0NWERR == "Y")
    PK0N918(); /* close cursor*/
    return;
  end

  PK0N917(); /* select first record from prepack*/
  if (converseVar.validationMsgNum != 0)
    PK0N918(); /* close cursor*/
    PK0NW01.PK0NMRJT = "Y"; /* no prepack to rebuild*/
    return;
  end

   /* handle pack by records*/

  if (PKTREC.PKSSSZFL != " ")
    PK0NW02.XWHCD = PK0NM001.XWHCD;
    PK0NW02.PK1CUOID = PK0NM001.PK1CUOID;
    PK0NW02.PK1NORID = PK0NM001.PK1NORID;
    PK0NW02.PKSSSZFL = PKTREC.PKSSSZFL;
    PK0NS60(); /* store record into temp storage*/
    if (PK0NW01.PK0NWERR == "Y")
      PK0N918(); /* close prepack table*/
      return;
    end
    return;
  end

            /* ######################*/
           /* read pool detail records*/
            /* ######################*/

  PK0N960(); /* purge temp storage*/
  PK0NW01.PK0NWLP2 = 0; /* init page counter of prepack array*/

   /* move product data into temp storage*/

  set PK5REC empty;
  PK5REC.XWHCD = PK0NM001.XWHCD;
  PK0NW01.PK1CUOID = PK0NM001.PK1CUOID;
  PK5REC.PK1PRTN = PK0NW01.PK1PRTN;
  PK5REC.PK1CUOID = PK0NM001.PK1CUOID;
  PK5REC.PK1NORID = PK0NM001.PK1NORID;

  PK0N912(); /* select set on pool detail*/
  if (converseVar.validationMsgNum != 0)
    PK0N914(); /* close pool detail*/
    PK0N918(); /* close prepack table*/
    return;
  end

  PK0N913(); /* fetch next from pool detail*/
  if (converseVar.validationMsgNum != 0)
    PK0N914(); /* close pool detail*/
    PK0N918(); /* close prepack table*/
    return;
  end

            /* ######################*/
             /* start building array*/
            /* ######################*/

   /* make sure all products in the order are*/
   /* put into prepack array*/

  PK0NW01.PK0NWCT3 = 1;

  while (SQLCA.VAGen_SQLCODE == 0)
     /* read in all records from pool detail that are not*/
     /* in prepack table*/
    while (PK5REC.XGPCD != PKTREC.XGPCD
     || PK5REC.SY1STNBR != PKTREC.SY1STNBR
     || PK5REC.SY2CLRID != PKTREC.SY2CLRID
     || PK5REC.XDMCD != PKTREC.XDMCD)

      if (SQLCA.VAGen_SQLCODE != 0)
        PK0N914(); /* close pool detail*/
        PK0N918(); /* close prepack table*/
        return; /* nothing left to do*/
      end

      PK0N181(); /* create prepack array from pool detail*/

      PK0N913(); /* fetch next from pool detail*/
      if (PK0NW01.PK0NWERR == "Y")
        PK0N914(); /* close pool detail*/
        PK0N918(); /* close cursor*/
        return;
      end

    end

     /* have found record in prepack table*/

    while (PK5REC.XGPCD == PKTREC.XGPCD
     && PK5REC.SY1STNBR == PKTREC.SY1STNBR
     && PK5REC.SY2CLRID == PKTREC.SY2CLRID
     && PK5REC.XDMCD == PKTREC.XDMCD
     && SQLCA.VAGen_SQLCODE == 0)

       /* First see if pool data has changed since prepack was built*/

      PK0N163(); /* check for new allocations*/
      if (PK0NW01.PK0NWERR == "Y") /* need to rebuild prepack*/
        PK0N914(); /* close pool detail*/
        PK0N918(); /* close prepack table*/
        return;
      end

       /* find first valid size in pool detail*/

      while (PK0NW01.PK0NWCT3 <= 39
       && PK5REC.PK1QTY[PK0NWCT3] == 0)
        PK0NW01.PK0NWCT3 = PK0NW01.PK0NWCT3 + 1;
      end

       /* see if any sizes smaller than on prepack exist*/

      PK0NW01.PK0NWIST = 0; /* init internal start size*/
      PK0NW01.PK0NWIED = 0; /* init internal end size*/
      if (PK0NW01.PK0NWCT3 < PKTREC.PKTBACTI)
        PK0NW01.PK0NWIST = PK0NW01.PK0NWCT3; /* internal start size*/
        while (PK0NW01.PK0NWCT3 < PKTREC.PKTBACTI
         && PK0NW01.PK0NWCT3 <= 39)
          PK0NW01.PK0NWIED = PK0NW01.PK0NWCT3; /* int end size*/
          PK0NW01.PK0NWCT3 = PK0NW01.PK0NWCT3 + 1;
        end
      end

       /* store record that contains sizes less than prepack record*/

      if (PK0NW01.PK0NWIST > 0
       && PK0NW01.PK0NWIST < PKTREC.PKTBACTI)

        PK0NW02.PKTBACTI = PK0NW01.PK0NWIST;
        PK0N166();
                                   /* create prepack array from pool detail*/
        if (PK0NW01.PK0NWERR == "Y")
          PK0N914(); /* close pool detail*/
          PK0N918(); /* close prepack table*/
          return;
        end
        PK0NS60(); /* store record into temp storage*/
        if (PK0NW01.PK0NWERR == "Y")
          PK0N914(); /* close pool detail*/
          PK0N918(); /* close prepack table*/
          return;
        end

      end

       /* store record that contains prepack record*/

      if (PK0NW01.PK0NWCT3 == PKTREC.PKTBACTI)
        PK0N167(); /* create prepack array from prepack*/
                                   /* table*/
        if (PK0NW01.PK0NWERR == "Y")
          PK0N914(); /* close pool detail*/
          PK0N918(); /* close prepack table*/
          return;
        end
        PK0NS60(); /* store record into temp storage*/
        if (PK0NW01.PK0NWERR == "Y")
          PK0N914(); /* close pool detail*/
          PK0N918(); /* close prepack table*/
          return;
        end

         /* store values in prepack array*/

        PK0NS62();

      end

       /* see if any sizes larger than those on prepack exist*/

      PK0NW01.PK0NWCRD = "N"; /* init created record flag*/

       /* find largest size on prepack record*/
      PK0NW01.PK0NWCT3 = 40;
      while (PK0NW01.PK0NWCT3 > 1
       && PKTREC.PKTPPQTY[PK0NWCT3] == 0)
        PK0NW01.PK0NWCT3 = PK0NW01.PK0NWCT3 - 1;
      end

       /* look for valid size that is larger on pool detail*/
      if (PKTREC.PKTPPQTY[PK0NWCT3] > 0)
        PK0NW01.PK0NWCT3 = PK0NW01.PK0NWCT3 + 1; /* look at next size*/
        while (PK0NW01.PK0NWCT3 <= 39
         && PK5REC.PK1QTY[PK0NWCT3] == 0)
          PK0NW01.PK0NWCT3 = PK0NW01.PK0NWCT3 + 1;
        end
      end

       /* found valid size that was larger than prepack record*/

      PK0NW01.PK0NWCRD = "N"; /* init have created record flag*/
      if (PK5REC.PK1QTY[PK0NWCT3] > 0)

          /* see if record contains non sequential sizes*/

        PK0NS63();
        if (PK0NW01.PK0NWCT3 > 39)
           /* next sentence - all records covered by prepack table*/
        else

           /* create and hold record*/

          PK0N166(); /* create prepack array record from pool*/
                                   /* detail*/
          if (PK0NW01.PK0NWERR == "Y")
            PK0N914(); /* close pool detail*/
            PK0N918(); /* close prepack table*/
            return;
          end

          PK0NS63();

        end

      end

       /* read next prepack record*/

      PK0N917(); /* select next from prepack*/
      if (PK0NW01.PK0NWERR == "Y")
        PK0N918(); /* close cursor*/
        PK0N914(); /* close cursor*/
        return;
      end

       /* if product changes and there was a record created*/
       /* because of sizes larger than the previous prepack*/
       /* record, then need to store that created record*/
       /* before processing the current prepack record*/

      if (SQLCA.VAGen_SQLCODE == 100
       || PK5REC.XGPCD != PKTREC.XGPCD
       || PK5REC.SY1STNBR != PKTREC.SY1STNBR
       || PK5REC.SY2CLRID != PKTREC.SY2CLRID
       || PK5REC.XDMCD != PKTREC.XDMCD)

        if (PK0NW01.PK0NWCRD == "Y") /* if record was created*/
          PK0NS60(); /* store record into temp storage*/
          if (PK0NW01.PK0NWERR == "Y")
            PK0N914(); /* close pool detail*/
            PK0N918(); /* close prepack table*/
            return;
          end
        end

         /* have finished this product, need to read next pool detail*/

        PK0N913(); /* fetch next from pool detail*/
        if (PK0NW01.PK0NWERR == "Y")
          PK0N914(); /* close pool detail*/
          PK0N918(); /* close prepack table*/
          return;
        end

        set PK0NW04 empty; /* hold sizes already done*/
        PK0NW01.PK0NWCT3 = 1;
      else

         /* continue processing from last record*/

        PK0NS64();

      end
    end
  end

  PK0N914(); /* close pool detail*/
  PK0N918(); /* close prepack table*/
end // end PK0N165

// build array from pool detail
Function PK0N166()
   /* **************************************************/
     /* build prepack array from pool data*/
   /* **************************************************/

  PK0NM001.XXXERRID = "PK0N166";

  set PK0NW02 empty; /* clear products from array*/

   /* move product data into temp storage*/

  PK0NW01.PK0NWCT1 = 1;
  PK0NW01.PK0NWCT2 = 0;

  PK0NW02.XWHCD = PK0NM001.XWHCD;
  PK0NW02.PK1CUOID = PK0NM001.PK1CUOID;
  PK0NW02.PK1NORID = PK0NM001.PK1NORID;
  PK0NW02.XGPCD = PK5REC.XGPCD;
  PK0NW02.SY1STNBR = PK5REC.SY1STNBR;
  PK0NW02.SY2CLRID = PK5REC.SY2CLRID;
  PK0NW02.XDMCD = PK5REC.XDMCD;
  PK0NW02.PK1LNINB = PK5REC.PK1LNINB;
  PK0NW02.PK0NWRER = 0; /* error associated with this record*/

   /* find product description*/

  PKNREC.XGPCD = PK5REC.XGPCD;
  PKNREC.SY1STNBR = PK5REC.SY1STNBR;
  PKNREC.SY2CLRID = PK5REC.SY2CLRID;
  PKNREC.XDMCD = PK5REC.XDMCD;

  PK0N932(); /* fetch product description*/
  if (converseVar.validationMsgNum != 0)
    return;
  end
  if (SQLCA.VAGen_SQLCODE == 0)
    PK0NW02.SY1SSTNM = PKNREC.SY1SSTNM;
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      PK0NW02.SY1SSTNM = " ";
    end
  end

  PK0N168(); /* move sizes to array*/
end // end PK0N166

// build array from prepack table
Function PK0N167()
   /* **************************************************/
     /* build prepack array from prepack table*/
   /* **************************************************/

  PK0NM001.XXXERRID = "PK0N167";

   /* move data from prepack record to array*/

  set PK0NW02 empty;

  PK0NW02.XWHCD = PKTREC.XWHCD;
  PK0NW02.PK1PRTN = PKTREC.PK1PRTN;
  PK0NW02.PK1CUOID = PKTREC.PK1CUOID;
  PK0NW01.PK0NWCUI = PKTREC.PK1CUOID;
  PK0NW02.PK1PRTN = PK0NW01.PK1PRTN;
  PK0NW02.PK1NORID = PKTREC.PK1NORID;
  PK0NW02.XGPCD = PKTREC.XGPCD;
  PK0NW02.SY1STNBR = PKTREC.SY1STNBR;
  PK0NW02.SY2CLRID = PKTREC.SY2CLRID;
  PK0NW02.XDMCD = PKTREC.XDMCD;
  PK0NW02.YNTCD = PKTREC.YNTCD;
  PK0NW02.PKTBACTI = PKTREC.PKTBACTI;
  PK0NW02.PKSSSZFL = PKTREC.PKSSSZFL;
  PK0NW02.PKTNBRPP = PKTREC.PKTNBRPP;
  PK0NW02.PK1LNINB = PKTREC.PK1LNINB;
  PK0NW02.PK0NWRER = 0; /* error associated with this record*/
  PK0NW02.ZZZCHGCT = PKTREC.ZZZCHGCT;

   /* fetch product description*/

  PKNREC.XGPCD = PKTREC.XGPCD;
  PKNREC.SY1STNBR = PKTREC.SY1STNBR;
  PKNREC.SY2CLRID = PKTREC.SY2CLRID;
  PKNREC.XDMCD = PKTREC.XDMCD;

  PK0N932(); /* fetch product description*/
  if (converseVar.validationMsgNum != 0)
    PK0N918(); /* close cursor*/
    return;
  end
  if (SQLCA.VAGen_SQLCODE == 0)
    PK0NW02.SY1SSTNM = PKNREC.SY1SSTNM;
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      PK0NW02.SY1SSTNM = " ";
    end
  end

  PK0NW01.PK0NWCT1 = 1;
  while (PK0NW01.PK0NWCT1 <= 40)
    PK0NW02.PKTPPQTY[PK0NWCT1] = PKTREC.PKTPPQTY[PK0NWCT1];
    PK0NW02.PK1QTY[PK0NWCT1] = PKTREC.PK1QTY[PK0NWCT1];
    PK0NW01.PK0NWCT1 = PK0NW01.PK0NWCT1 + 1;
  end

  PK0N169(); /* move quantity data from sy1190*/
end // end PK0N167

// move sizes from pool detail
Function PK0N168()
   /* **************************************************/
     /* move sizes to prepack temp storage*/
   /* **************************************************/

  PK0NM001.XXXERRID = "PK0N168";

   /* if pk0nm001.pk0nmstr eq ' '*/
   /* move in all sizes*/
   /* else*/
   /* move in only selected sizes*/

   /* start/end sizes were already converted to*/
   /* internal sizes in pk0n125.*/

   /* if end size is blank, a large value of 41 is used so*/
   /* all found sizes will be less than it.*/

  if (PK0NW01.PK0NWIED == 0)
    PK0NW01.PK0NWIED = 41;
  end

   /* move sizes into tempory storage.*/

  set SYPREC empty;
  SYPREC.SYPFC = "PC"; /* product code*/
  SYPREC.SYPCMPSW = "N"; /* non compressed data*/
  SYPREC.XGPCD = PK0NW02.XGPCD;
  SYPREC.SY1STNBR = PK0NW02.SY1STNBR;
  SYPREC.SY2CLRID = PK0NW02.SY2CLRID;
  SYPREC.XDMCD = PK0NW02.XDMCD;
  SYPREC.XQACD = "**";

  PK0N915(); /* select size desc from sy1190*/
  if (converseVar.validationMsgNum != 0)
    return;
  end

  PK0NW01.PK0NWCT2 = 1;

  while (PK0NW01.PK0NWCT2 <= 40)

     /* move data only into sizes that have allocated qtys*/
     /* and are valid sizes*/

    if (PK5REC.PK1QTY[PK0NWCT2] == 0 /* don't move in data*/
     || SYPREC.SY5SZID[PK0NWCT2] == 0)
      PK0NW02.SY4IDDSC[PK0NWCT2] = " ";
      PK0NW02.SY5SZID[PK0NWCT2] = 0;
      PK0NW02.PK1QTY[PK0NWCT2] = 0;
    else

       /* if the size is between the start and*/
       /* end size, then move it into array*/

      if (SYPREC.SY5SZID[PK0NWCT2] >= PK0NW01.PK0NWIST
       && SYPREC.SY5SZID[PK0NWCT2] <= PK0NW01.PK0NWIED)
        PK0NW02.SY4IDDSC[PK0NWCT2] = SYPREC.SY4IDDSC[PK0NWCT2];
        PK0NW02.SY5SZID[PK0NWCT2] = SYPREC.SY5SZID[PK0NWCT2];
        PK0NW02.PK1QTY[PK0NWCT2] = PK5REC.PK1QTY[PK0NWCT2];

         /* hold sizes for records*/

        if (PK0NW02.PK0NMSTR == " ")
          PK0NW02.PK0NMSTR = SYPREC.SY4IDDSC[PK0NWCT2];
          PK0NW02.PKTBACTI = SYPREC.SY5SZID[PK0NWCT2];
        end
        PK0NW02.PK0NMEND = SYPREC.SY4IDDSC[PK0NWCT2];
      else
        PK0NW02.SY4IDDSC[PK0NWCT2] = " ";
        PK0NW02.SY5SZID[PK0NWCT2] = 0;
        PK0NW02.PK1QTY[PK0NWCT2] = 0;
      end
    end

    PK0NW01.PK0NWCT2 = PK0NW01.PK0NWCT2 + 1;

  end
end // end PK0N168

// move sizes from prepack table
Function PK0N169()
   /* **************************************************/
     /* move sizes to prepack temp storage*/
   /* **************************************************/

  PK0NM001.XXXERRID = "PK0N169";

  set SYPREC empty;
  SYPREC.SYPFC = "PC"; /* product code*/
  SYPREC.SYPCMPSW = "N"; /* non compressed data*/
  SYPREC.XGPCD = PK0NW02.XGPCD;
  SYPREC.SY1STNBR = PK0NW02.SY1STNBR;
  SYPREC.SY2CLRID = PK0NW02.SY2CLRID;
  SYPREC.XDMCD = PK0NW02.XDMCD;
  SYPREC.XQACD = "**";

  PK0N915(); /* select size desc from sy1190*/
  if (converseVar.validationMsgNum != 0)
    return;
  end

  PK0NW01.PK0NWCT2 = 1;

  while (PK0NW01.PK0NWCT2 <= 40)

     /* move data only into sizes that have allocated qtys*/

    if (PKTREC.PK1QTY[PK0NWCT2] == 0 /* don't move in data*/
     || SYPREC.SY5SZID[PK0NWCT2] == 0)
      PK0NW02.SY4IDDSC[PK0NWCT2] = " ";
      PK0NW02.SY5SZID[PK0NWCT2] = 0;
    else
      PK0NW02.SY4IDDSC[PK0NWCT2] = SYPREC.SY4IDDSC[PK0NWCT2];
      PK0NW02.SY5SZID[PK0NWCT2] = SYPREC.SY5SZID[PK0NWCT2];

       /* hold starting and ending size to be shown on screen*/

      if (PK0NW02.PK0NMSTR == " ")
        PK0NW02.PK0NMSTR = SYPREC.SY4IDDSC[PK0NWCT2];
        PK0NW02.PKTBACTI = SYPREC.SY5SZID[PK0NWCT2];
      end
      PK0NW02.PK0NMEND = SYPREC.SY4IDDSC[PK0NWCT2];
    end

    PK0NW01.PK0NWCT2 = PK0NW01.PK0NWCT2 + 1;

  end
end // end PK0N169

// build array for customer
Function PK0N170()
   /* **************************************************/
     /* build array for cust processing*/
   /* **************************************************/

  PK0NM001.XXXERRID = "PK0N170";

  if (PK0NM001.PK0NMACT == " ")
     /* next sentence*/
  else
    return;
  end

  set PKSREC empty;

  PKSREC.XWHCD = PK0NM001.XWHCD;
  PKSREC.KUCCOID = PK0NM001.KUCCOID;
  PKSREC.KUMSTRID = PK0NM001.KUMSTRID;
  PKSREC.XNXCD = PK0NM001.XNXCD;

  PK0N925(); /* select unique from cust prepack*/
  if (converseVar.validationMsgNum != 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == 100)
    converseLib.validationFailed(8); /* no record was found*/
    PK0NS50(); /* clear detail lines*/
    set PK0NM001.KUCCOID cursor, bold;
    set PK0NM001.KUMSTRID bold;
    set PK0NM001.XNXCD bold;
    PK0NW01.KUCCOID = 0; /* it will appear as if first time thru*/
    PK0NW01.PK0NWERR = "Y";
    return;
  end
end // end PK0N170

// create multiple prpack records
Function PK0N181()
   /* ******************************************************/
   /* create record(s) from pool detail, when there are*/
   /* no corresponding records on prepack table.*/
   /* if a product is split on the screen, this process*/
   /* makes two records out of the one product*/
   /* ******************************************************/

  PK0NM001.XXXERRID = "PK0N181";

   /* #######################################################*/
   /* have read all records in prepack table, now process all*/
   /* that follow in the flag array*/
   /* #######################################################*/

       /* ########################*/
       /* if not breaking up sizes*/
       /* ########################*/

  if (PK0NM001.XGPCD == PK5REC.XGPCD
   && PK0NM001.SY1STNBR == PK5REC.SY1STNBR
   && PK0NM001.SY2CLRID == PK5REC.SY2CLRID
   && PK0NM001.XDMCD == PK5REC.XDMCD
   && PK0NM001.PK0NMSTR != " ")
     /* next sentence - breaking up sizes*/
  else
    PK0NW01.PK0NWIST = 0;
    PK0NW01.PK0NWIED = 0;
    PK0N166(); /* build prepack array from pool detail*/
    if (PK0NW01.PK0NWERR == "Y")
      PK0N918(); /* close prepack table*/
      PK0N914(); /* close pool detail*/
      return;
    end
    PK0NS60();
    if (PK0NW01.PK0NWERR == "Y")
      PK0N918(); /* close prepack table*/
      PK0N914(); /* close pool detail*/
      return;
    end
    return;
  end

       /* ########################*/
         /* if breaking up sizes*/
       /* ########################*/

   /* find first valid size in pool detail*/

  PK0NW01.PK0NWCT3 = 1;
  while (PK0NW01.PK0NWCT3 <= 39
   && PK5REC.PK1QTY[PK0NWCT3] == 0)
    PK0NW01.PK0NWCT3 = PK0NW01.PK0NWCT3 + 1;
  end

   /* see if any sizes smaller than on pool detail exist*/

  PK0NW01.PK0NWIST = 0; /* init internal start size*/
  PK0NW01.PK0NWIED = 0; /* init internal end size*/
  if (PK0NW01.PK0NWCT3 < PK0NW01.PKTBACTI)
    PK0NW01.PK0NWIST = PK0NW01.PK0NWCT3; /* internal start size*/
    while (PK0NW01.PK0NWCT3 < PK0NW01.PKTBACTI
     && PK0NW01.PK0NWCT3 <= 39)
      PK0NW01.PK0NWIED = PK0NW01.PK0NWCT3; /* int end size*/
      PK0NW01.PK0NWCT3 = PK0NW01.PK0NWCT3 + 1;
    end
  end

   /* store record that contains sizes less than screen*/

  if (PK0NW01.PK0NWIST > 0
   && PK0NW01.PK0NWIST < PK0NW01.PKTBACTI)

    PK0NW02.PKTBACTI = PK0NW01.PK0NWIST;
    PK0N166();
                                   /* create prepack array from pool detail*/
    if (PK0NW01.PK0NWERR == "Y")
      PK0N914(); /* close pool detail*/
      PK0N918(); /* close prepack table*/
      return;
    end
    PK0NS60(); /* store record into temp storage*/
    if (PK0NW01.PK0NWERR == "Y")
      PK0N914(); /* close pool detail*/
      PK0N918(); /* close prepack table*/
      return;
    end

  end

   /* store record that contains screen size*/

  if (PK0NW01.PK0NWCT3 == PK0NW01.PKTBACTI)

     /* ###### need to move in beginning sizes*/

    PK0NW02.PKTBACTI = PK0NW01.PK0NWCT3;
    PK0NW01.PK0NWIST = PK0NW01.PK0NWCT3;
    PK0NW01.PK0NWIED = PK0NW01.PK0NWEND;
    PK0N166();
                                   /* create prepack array from pool detail*/
    if (PK0NW01.PK0NWERR == "Y")
      PK0N914(); /* close pool detail*/
      PK0N918(); /* close prepack table*/
      return;
    end
    PK0NS60(); /* store record into temp storage*/
    if (PK0NW01.PK0NWERR == "Y")
      PK0N914(); /* close pool detail*/
      PK0N918(); /* close prepack table*/
      return;
    end

  end

   /* see if any sizes larger than those on screen exist*/

   /* look for valid size on pool detail*/
   /* that is larger than ending screen value*/

  PK0NW01.PK0NWCT3 = PK0NW01.PK0NWEND;
  if (PK5REC.PK1QTY[PK0NWCT3] > 0)
    PK0NW01.PK0NWCT3 = PK0NW01.PK0NWCT3 + 1; /* look at next size*/
    while (PK0NW01.PK0NWCT3 <= 39
     && PK5REC.PK1QTY[PK0NWCT3] == 0)
      PK0NW01.PK0NWCT3 = PK0NW01.PK0NWCT3 + 1;
    end
  end

   /* found valid size that was larger than ending screen value*/

  if (PK5REC.PK1QTY[PK0NWCT3] != 0)

    PK0NW01.PK0NWCRD = "Y"; /* have created record*/
    PK0NW01.PK0NWIST = PK0NW01.PK0NWCT3; /* int start size*/
    PK0NW01.PK0NWIED = 0; /* int end size*/
    PK0N166(); /* create prepack array record from pool detail*/
    PK0NW02.PKTBACTI = PK0NW01.PK0NWCT3;
    if (PK0NW01.PK0NWERR == "Y")
      PK0N914(); /* close pool detail*/
      PK0N918(); /* close prepack table*/
      return;
    end
    PK0NS60(); /* store record into temp storage*/
    if (PK0NW01.PK0NWERR == "Y")
      PK0N914(); /* close pool detail*/
      PK0N918(); /* close prepack table*/
      return;
    end
  end
end // end PK0N181

// validate prepack table records
Function PK0N190()
   /* ******************************************************/
   /* Build array and show user all records.*/
   /* Validate prepack table records against pool header*/
   /* and detail to see if any new products or quantities*/
   /* were allocated since the prepack record was created.*/
   /* ******************************************************/

  PK0NM001.XXXERRID = "PK0N190";

            /* ######################*/
           /* read pool detail records*/
            /* ######################*/

  PK0N960(); /* purge temp storage*/
  PK0NW01.PK0NWLP2 = 0; /* init page counter of prepack array*/
  set PK0NW02 empty; /* clear products from array*/

  set PK5REC empty;
  PK5REC.XWHCD = PK0NM001.XWHCD;
  PK0NW01.PK1CUOID = PK0NM001.PK1CUOID;
  PK5REC.PK1PRTN = PK0NW01.PK1PRTN;
  PK5REC.PK1CUOID = PK0NM001.PK1CUOID;
  PK5REC.PK1NORID = PK0NM001.PK1NORID;

  PK0N912(); /* select set on pool detail*/
  if (converseVar.validationMsgNum != 0)
    PK0N914(); /* close pool detail*/
    return;
  end

  PK0N913(); /* fetch next from pool detail*/
  if (converseVar.validationMsgNum != 0)
    PK0N914(); /* close pool detail*/
    return;
  end

  if (SQLCA.VAGen_SQLCODE == 100)
    converseLib.validationFailed(184); /* record doesn't exist*/
    PK0NS50(); /* clear detail lines*/
    set PK0NW03 empty;
    PK0NW01.PK0NWERR = "Y";
    set PK0NM001.PK1CUOID cursor, bold;
    set PK0NM001.PK1NORID bold;
    PK0N914(); /* close pool detail*/
    PK0N918(); /* close prepack table*/
    return;
  end

            /* ######################*/
             /* read prepack records*/
            /* ######################*/

  set PKTREC empty;

  PKTREC.XWHCD = PK0NM001.XWHCD;
  PKTREC.PK1CUOID = PK0NM001.PK1CUOID;
  PK0NW01.PK0NWCUI = PK0NM001.PK1CUOID;
  PKTREC.PK1PRTN = PK0NW01.PK1PRTN;
  PKTREC.PK1NORID = PK0NM001.PK1NORID;
  PKTREC.XGPCD = "*";
  PKTREC.SY1STNBR = "*";
  PKTREC.SY2CLRID = "*";
  PKTREC.XDMCD = "*";
  PKTREC.PKTBACTI = -1;

  PK0N916(); /* select set from prepack*/
  if (PK0NW01.PK0NWERR == "Y")
    PK0N918(); /* close prepack table*/
    PK0N914(); /* close pool detail*/
    return;
  end

  PK0N917(); /* select first record from prepack*/
  if (converseVar.validationMsgNum != 0)
    PK0N918(); /* close prepack table*/
    PK0N914(); /* close pool detail*/
    return;
  end

   /* need to check for errors here*/

  if (SQLCA.VAGen_SQLCODE == 100) /* no prepack records*/
    if (PK0NM001.PK0NMACT == "A")
      PK0N914(); /* close pool detail*/
      PK0N918(); /* close prepack table*/
      return; /* nothing to check*/
    else
      converseLib.validationFailed(8); /* no record found*/
      PK0NW01.PK0NWERR = "Y";
      set PK0NM001.PK1CUOID cursor, bold;
      set PK0NM001.PK1NORID bold;
      if (PK0NW01.PK0NWPRD == "Y")
        set PK0NM001.XGPCD bold;
        set PK0NM001.SY1STNBR bold;
        set PK0NM001.SY2CLRID bold;
        set PK0NM001.XDMCD bold;
      end
      if (PK0NM001.PK0NMSTR != " ")
        set PK0NM001.PK0NMSTR bold;
      end
      PK0N918(); /* close cursor*/
      PK0N914(); /* close cursor*/
      PK0NS51(); /* clear detail fields*/
      return;
    end
  end

   /* check for pack by data*/

  if (PKTREC.PKSSSZFL != " ")
    PK0N918(); /* close prepack table*/
    PK0N914(); /* close pool detail*/
    return; /* data on prepack doesn't correspond to*/
                                   /* data on pool*/
  end

            /* ######################*/
           /* handle beginning records*/
            /* ######################*/

   /* make sure all products in the order and*/
   /* not in prepack table are put into prepack array*/

   /* if first record in pool detail is not same as first*/
   /* record in prepack table, need to handle that here*/

  while (PK5REC.XGPCD != PKTREC.XGPCD
   || PK5REC.SY1STNBR != PKTREC.SY1STNBR
   || PK5REC.SY2CLRID != PKTREC.SY2CLRID
   || PK5REC.XDMCD != PKTREC.XDMCD)

    if (PK5REC.SY1STNBR > PKTREC.SY1STNBR)

      PK0N167(); /* create prepack array from prepack*/
                                   /* table*/
      if (PK0NW01.PK0NWERR == "Y")
        PK0N914(); /* close pool detail*/
        PK0N918(); /* close prepack table*/
        return;
      end
      PK0NS60(); /* store record into temp storage*/
      if (PK0NW01.PK0NWERR == "Y")
        PK0N914(); /* close pool detail*/
        PK0N918(); /* close prepack table*/
        return;
      end

      PK0N917(); /* fetch next from prepack table*/
      if (PK0NW01.PK0NWERR == "Y")
        PK0N914(); /* close pool detail*/
        PK0N918(); /* close cursor*/
        return;
      end
    else

      PK0N166(); /* create prepack array from pool detail*/
      if (PK0NW01.PK0NWERR == "Y")
        PK0N914(); /* close pool detail*/
        PK0N918(); /* close prepack table*/
        return;
      end
      PK0NS60(); /* store record into temp storage*/
      if (PK0NW01.PK0NWERR == "Y")
        PK0N914(); /* close pool detail*/
        PK0N918(); /* close prepack table*/
        return;
      end

      PK0N913(); /* fetch next from pool detail*/
      if (PK0NW01.PK0NWERR == "Y")
        PK0N914(); /* close pool detail*/
        PK0N918(); /* close cursor*/
        return;
      end
    end
  end

            /* ######################*/
             /* process all records*/
            /* ######################*/

  PK0NW01.VAGen_SQLCODE = 0;
  while (SQLCA.VAGen_SQLCODE == 0
   && PK0NW01.VAGen_SQLCODE == 0)

    while (PK5REC.XGPCD != PKTREC.XGPCD
     || PK5REC.SY1STNBR != PKTREC.SY1STNBR
     || PK5REC.SY2CLRID != PKTREC.SY2CLRID
     || PK5REC.XDMCD != PKTREC.XDMCD)

      PK0N913(); /* fetch next from pool detail*/
      if (PK0NW01.PK0NWERR == "Y")
        PK0N914(); /* close pool detail*/
        PK0N918(); /* close cursor*/
        return;
      end

                /* ######################*/
             /* process non existent records*/
                /* ######################*/

       /* if a record is missing from the prepack table*/
       /* or there is an extra record on the prepack table,then*/
       /* put that record into prepack array*/

      if (PK5REC.XGPCD != PKTREC.XGPCD
       || PK5REC.SY1STNBR != PKTREC.SY1STNBR
       || PK5REC.SY2CLRID != PKTREC.SY2CLRID
       || PK5REC.XDMCD != PKTREC.XDMCD)

        if (PK5REC.SY1STNBR > PKTREC.SY1STNBR)

          PK0N167(); /* create prepack array from prepack*/
                                   /* table*/
          PK0NW02.PK0NWRER = 1; /* prd no longer on order*/
          if (PK0NW01.PK0NWERR == "Y")
            PK0N914(); /* close pool detail*/
            PK0N918(); /* close prepack table*/
            return;
          end
          PK0NS60(); /* store record into temp storage*/
          if (PK0NW01.PK0NWERR == "Y")
            PK0N914(); /* close pool detail*/
            PK0N918(); /* close prepack table*/
            return;
          end
        else

          PK0N166();
                                   /* create prepack array from pool detail*/
          if (PK0NW01.PK0NWERR == "Y")
            PK0N914(); /* close pool detail*/
            PK0N918(); /* close prepack table*/
            return;
          end
          PK0NS60(); /* store record into temp storage*/
          if (PK0NW01.PK0NWERR == "Y")
            PK0N914(); /* close pool detail*/
            PK0N918(); /* close prepack table*/
            return;
          end
        end
      end

    end

    if (SQLCA.VAGen_SQLCODE != 0)
      return;
    end

              /* ######################*/
              /* found matching records*/
              /* ######################*/

     /* flag every size on pool detail that is covered*/
     /* by a prepack record. the non valid sizes have 'y'*/
     /* moved to them so they look like they are covered*/
     /* by prepack records and we won't make new records for them*/
     /* **********************************************************/
     /* No, we will show existing records to the user, and allow*/
     /* them to be updated if needed.*/
     /* **********************************************************/

    set SYPREC empty;
    SYPREC.SYPFC = "PC"; /* product code*/
    SYPREC.SYPCMPSW = "N"; /* non compressed data*/
    SYPREC.XGPCD = PK5REC.XGPCD;
    SYPREC.SY1STNBR = PK5REC.SY1STNBR;
    SYPREC.SY2CLRID = PK5REC.SY2CLRID;
    SYPREC.XDMCD = PK5REC.XDMCD;
    SYPREC.XQACD = "**";

    PK0N915(); /* select size desc from sy1190*/
    if (PK0NW01.PK0NWERR == "Y")
      PK0N914(); /* close pool detail*/
      PK0N918(); /* close prepack table*/
      return;
    end

    PK0NW01.PK0NWCT1 = 1;
    while (PK0NW01.PK0NWCT1 <= 40)
      if (SYPREC.SY5SZID[PK0NWCT1] == 0) /* invalid sizes*/
        PK0NW04.PK1QTY[PK0NWCT1] = 0;
        PK0NW04.PK0NWSDN[PK0NWCT1] = "Y";
      else
        if (PK5REC.PK1QTY[PK0NWCT1] == 0)
          PK0NW04.PK1QTY[PK0NWCT1] = 0;
          PK0NW04.PK0NWSDN[PK0NWCT1] = "Y";
        else
          PK0NW04.PK1QTY[PK0NWCT1] = PK5REC.PK1QTY[PK0NWCT1];
          PK0NW04.PK0NWSDN[PK0NWCT1] = "N";
        end
      end
      PK0NW01.PK0NWCT1 = PK0NW01.PK0NWCT1 + 1;
    end

              /* ######################*/
             /* process matching records*/
              /* ######################*/

    while (PK5REC.XGPCD == PKTREC.XGPCD
     && PK5REC.SY1STNBR == PKTREC.SY1STNBR
     && PK5REC.SY2CLRID == PKTREC.SY2CLRID
     && PK5REC.XDMCD == PKTREC.XDMCD
     && SQLCA.VAGen_SQLCODE == 0)

       /* if allocated qty on order doesn't match allocated*/
       /* qty on prepacks, then order was changed and*/
       /* prepack records have to be changed*/

      PK0NW01.PK0NWCT1 = 1;
      PK0NW01.PK0NWCRD = "N"; /* init need to create record flag*/

      while (PK0NW01.PK0NWCT1 <= 40)
        if (PKTREC.PK1QTY[PK0NWCT1] != 0)
          if (PKTREC.PK1QTY[PK0NWCT1] == PK5REC.PK1QTY[PK0NWCT1])
            PK0NW04.PK0NWSDN[PK0NWCT1] = "Y"; /* size was done*/
          else

            PK0NW04.PK0NWSDN[PK0NWCT1] = "Y"; /* size was done*/
            PK0NW01.PK0NWCRD = "Y"; /* need to create record*/

          end
        end
        PK0NW01.PK0NWCT1 = PK0NW01.PK0NWCT1 + 1;
      end

      PK0N167(); /* create prepack array from prepack*/
                                  /* table*/
         /* need to show new allocated quantities*/

      PK0NW01.PK0NWCT1 = 1;
      while (PK0NW01.PK0NWCT1 <= 40)
        if (PKTREC.PK1QTY[PK0NWCT1] > 0
         && PKTREC.PK1QTY[PK0NWCT1] != PK5REC.PK1QTY[PK0NWCT1])
          PK0NW02.PK1QTY[PK0NWCT1] = PK5REC.PK1QTY[PK0NWCT1];
          PK0NW02.PK0NWQTE[PK0NWCT1] = "Y"; /* quantity error*/
        end
        PK0NW01.PK0NWCT1 = PK0NW01.PK0NWCT1 + 1;
      end

      if (PK0NW01.PK0NWERR == "Y")
        PK0N914(); /* close pool detail*/
        PK0N918(); /* close prepack table*/
        return;
      end
      PK0NS60(); /* store record into temp storage*/
      if (PK0NW01.PK0NWERR == "Y")
        PK0N914(); /* close pool detail*/
        PK0N918(); /* close prepack table*/
        return;
      end

      PK0N917(); /* fetch next from prepack table*/
      PK0NW01.VAGen_SQLCODE = SQLCA.VAGen_SQLCODE;
      if (PK0NW01.PK0NWERR == "Y")
        PK0N914(); /* close pool detail*/
        PK0N918(); /* close prepack table*/
        return;
      end
    end

              /* ######################*/
              /* were all sizes covered*/
              /* ######################*/

     /* have read prepack record with different product.*/
     /* if not all sizes in order were covered by sizes*/
     /* in prepack record, then need to have record with*/
     /* sizes that aren't covered*/

    PK0NW01.PK0NWCT1 = 1;

    while (PK0NW01.PK0NWCT1 <= 39
     && PK0NW04.PK0NWSDN[PK0NWCT1] == "Y")
      PK0NW01.PK0NWCT1 = PK0NW01.PK0NWCT1 + 1;
    end

     /* found sizes needing a record*/

    if (PK0NW04.PK0NWSDN[PK0NWCT1] == "N")
      PK0NW01.PK0NWIST = 0; /* init internal starting size*/
      PK0NW01.PK0NWIED = 0; /* init internal ending size*/
      PK0N166();
                                   /* create prepack array from pool detail*/

       /* only want sizes in this record that haven't been*/
       /* covered by other prepack records*/

      PK0NW01.PK0NWCT1 = 1;
      while (PK0NW01.PK0NWCT1 <= 40)
        if (PK0NW04.PK0NWSDN[PK0NWCT1] == "N")
          PK0NW02.PK0NMEND = PK0NW02.SY4IDDSC[PK0NWCT1];
        else
          PK0NW02.SY4IDDSC[PK0NWCT1] = " ";
          PK0NW02.SY5SZID[PK0NWCT1] = 0;
          PK0NW02.PKTPPQTY[PK0NWCT1] = 0;
          PK0NW02.PK1QTY[PK0NWCT1] = 0;
        end
        PK0NW01.PK0NWCT1 = PK0NW01.PK0NWCT1 + 1;
      end

      PK0NS60(); /* store record into temp storage*/
      if (PK0NW01.PK0NWERR == "Y")
        PK0N914(); /* close pool detail*/
        PK0N918(); /* close prepack table*/
        return;
      end
    end
  end

  PK0N918(); /* close prepack table*/
  if (PK0NW01.PK0NWERR == "Y")
    return;
  end

   /* #######################################*/
      /* include all pool detail records that*/
      /* follow after all prepack records*/
   /* #######################################*/

  PK0N913(); /* fetch next from pool detail*/
  if (PK0NW01.PK0NWERR == "Y")
    PK0N914(); /* close pool detail*/
    return;
  end

  while (SQLCA.VAGen_SQLCODE == 0
   && PK0NW01.VAGen_SQLCODE == 0)

    PK0N166(); /* create prepack array from pool detail*/
    if (PK0NW01.PK0NWERR == "Y")
      PK0N914(); /* close pool detail*/
      return;
    end

    PK0NS60(); /* store record into temp storage*/
    if (PK0NW01.PK0NWERR == "Y")
      PK0N914(); /* close pool detail*/
      return;
    end

    PK0N913(); /* fetch next from pool detail*/
    if (PK0NW01.PK0NWERR == "Y")
      PK0N914(); /* close pool detail*/
      return;
    end
  end

  PK0N914(); /* close pool detail*/
  if (PK0NW01.PK0NWERR == "Y")
    return;
  end

end // end PK0N190

// select cust nbr from pool
Function PK0N910()
   /* *************************************************************/
   /* select data from pick pool*/
   /* If end of file, get out*/
   /* If any error, indicate a system error.*/
   /* *************************************************************/

  PWIREC.PWIFUNC = "S ";
  call "IO1720" (PWIREC, SQLCA, PK4REC) {isNoRefresh = yes, isExternal = yes}; /* select unique*/

  if (SQLCA.VAGen_SQLCODE == 100) /* row not found*/

    return;

  end

  if (SQLCA.VAGen_SQLCODE != 0) /* Unexpected return code*/

    if (SQLCA.VAGen_SQLCODE == -911) /* Resource not available*/

      PK0NW01.PK0NWERR = "Y";
      converseLib.validationFailed(28); /* Indicate not available*/
      TA1REC.TA1FUNC = "POST"; /* Termination function*/

    else

      PK0NW01.PK0NWERR = "Y";
      converseLib.validationFailed(29); /* Indicate system error*/
      TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    end

    TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
    TA1REC.TA1PGMNM = "PK0N910 "; /* Process name*/
    TA1REC.TA1LOC = "OBTAIN CUST NBR FROM POOL";
    TA1REC.TA1MAP = "PK0NM001"; /* Map name*/
    TA1REC.TA1DBASE = "DPICK   "; /* Data base name*/
    TA1REC.TA1TBLVU = "VPOOLH01"; /* Table view name*/
    TA1REC.TA1TBLKE = PK4REC.PK4KEY; /* Table key*/

    call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    PK0NM001.XXXERRID = "PK0N910"; /* Error location*/
    return; /* Return to previous process*/

  end
end // end PK0N910

// select cust nbr from pick cust
Function PK0N911()
   /* *************************************************************/
   /* select data from picking customer table*/
   /* If end of file, get out*/
   /* If any error, indicate a system error.*/
   /* *************************************************************/

  call "IO1830" ("S ", SQLCA, PK6REC) {isNoRefresh = yes, isExternal = yes}; /* select unique*/

  if (SQLCA.VAGen_SQLCODE == 100) /* row not found*/

    return;

  end

  if (SQLCA.VAGen_SQLCODE != 0) /* Unexpected return code*/

    if (SQLCA.VAGen_SQLCODE == -911) /* Resource not available*/

      PK0NW01.PK0NWERR = "Y";
      converseLib.validationFailed(28); /* Indicate not available*/
      TA1REC.TA1FUNC = "POST"; /* Termination function*/

    else

      PK0NW01.PK0NWERR = "Y";
      converseLib.validationFailed(29); /* Indicate system error*/
      TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    end

    TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
    TA1REC.TA1PGMNM = "PK0N911 "; /* Process name*/
    TA1REC.TA1LOC = "OBTAIN CUST NBR FROM PICK CUST";
    TA1REC.TA1MAP = "PK0NM001"; /* Map name*/
    TA1REC.TA1DBASE = "DPICK   "; /* Data base name*/
    TA1REC.TA1TBLVU = "VPKCUS01"; /* Table view name*/
    TA1REC.TA1TBLKE = PK6REC.PK6GROUP; /* Table key*/

    call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    PK0NM001.XXXERRID = "PK0N911"; /* Error location*/
    return; /* Return to previous process*/

  end
end // end PK0N911

// select set for picking hdr
Function PK0N912()
   /* ************************************************************/
   /* *   select set on pk5rec*/
   /* ************************************************************/

  call "IO1990" ("S2", SQLCA, PK5REC) {isNoRefresh = yes, isExternal = yes}; /* Select table set*/

  if (SQLCA.VAGen_SQLCODE != 0) /* Unexpected return code*/

    if (SQLCA.VAGen_SQLCODE == -911) /* Resource not available*/

      PK0NW01.PK0NWERR = "Y";
      converseLib.validationFailed(28); /* Indicate not available*/
      TA1REC.TA1FUNC = "POST"; /* Termination function*/
      PK0NW01.PK0NWERR = "Y"; /* there was an error*/

    else

      PK0NW01.PK0NWERR = "Y";
      converseLib.validationFailed(29); /* Indicate system error*/
      TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    end

    TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
    TA1REC.TA1PGMNM = "PK0N912 "; /* Process name*/
    TA1REC.TA1LOC = "OBTAIN PRODUCTS FOR ORDERS";
    TA1REC.TA1MAP = "PK0NM001"; /* Map name*/
    TA1REC.TA1DBASE = "DPICK   "; /* Data base name*/
    TA1REC.TA1TBLVU = "VPOOLI01"; /* Table view name*/
    TA1REC.TA1TBLKE = PK5REC.PK5KEY; /* Table key*/

    call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    PK0NM001.XXXERRID = "PK0N912"; /* Error location*/
    return; /* Return to previous process*/

  end

end // end PK0N912

// select next for picking hdr
Function PK0N913()
   /* ************************************************************/
   /* *   fetch next record on pk5rec*/
   /* ************************************************************/

  call "IO1990" ("N2", SQLCA, PK5REC) {isNoRefresh = yes, isExternal = yes}; /* fetch next row*/

  if (SQLCA.VAGen_SQLCODE == 100) /* Row not found*/

    return; /* Return to previous process*/

  end

  if (SQLCA.VAGen_SQLCODE != 0) /* Unexpected return code*/

    PK0NW01.PK0NWERR = "Y"; /* error*/
    converseLib.validationFailed(29); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
    TA1REC.TA1PGMNM = "PK0N913 "; /* Process name*/
    TA1REC.TA1LOC = "OBTAIN PRODUCTS FOR ORDERS";
    TA1REC.TA1MAP = "PK0NM001"; /* Map name*/
    TA1REC.TA1DBASE = "DPICK   "; /* Data base name*/
    TA1REC.TA1TBLVU = "VPOOLI01"; /* Table view name*/
    TA1REC.TA1TBLKE = PK5REC.PK5KEY; /* Table key*/

    call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    PK0NM001.XXXERRID = "PK0N913"; /* Error location*/
    return; /* Return to previous process*/

  end

end // end PK0N913

// close set for picking header
Function PK0N914()
   /* ************************************************************/
   /* *   close cursor for pk5rec*/
   /* ************************************************************/

  call "IO1990" ("C2", SQLCA, PK5REC) {isNoRefresh = yes, isExternal = yes}; /* close table set*/

  if (SQLCA.VAGen_SQLCODE != 0) /* unexpected return code*/

    PK0NW01.PK0NWERR = "Y"; /* error*/
    converseLib.validationFailed(29); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
    TA1REC.TA1PGMNM = "PK0N914 "; /* Process name*/
    TA1REC.TA1LOC = "CLOSE CURSOR FOR POOL ITEM";
    TA1REC.TA1MAP = "PK0NM001"; /* Map name*/
    TA1REC.TA1DBASE = "DPICK   "; /* Data base name*/
    TA1REC.TA1TBLVU = "VPOOLI01"; /* Table view name*/
    TA1REC.TA1TBLKE = PK5REC.PK5KEY; /* Table key*/

    call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    PK0NM001.XXXERRID = "PK0N914"; /* Error location*/
    return; /* Return to previous process*/

  end
end // end PK0N914

// select sizes with sy1190
Function PK0N915()
   /* *************************************************************/
   /* select valid sizes using dpick.vpkscl01 and dpick.vpksty01*/
   /* If end of file, get out*/
   /* If any error, indicate a system error.*/
   /* *************************************************************/

  call "SY1190" (SQLCA, SYPREC) {isNoRefresh = yes, isExternal = yes}; /* select the available sizes*/

  if (SYPREC.SYPRC == 10 /* size row not found*/
   || SYPREC.SYPRC == 11 /* style row not found*/
   || SYPREC.SYPRC == 16) /* scale row not found*/
    PK0NW01.PK0NWERR = "Y";
    converseLib.validationFailed(45); /* no data was found for this product*/
                                   /* nbr*/
    PK0NM001.XXXERRID = "PK0N915";
    return;
  end

  if (SYPREC.SYPRC == 9 /* signify db2 problems*/
   || SYPREC.SYPRC == 99)

    if (SYPREC.SYPRC == 9) /* Resource not available*/

      PK0NW01.PK0NWERR = "Y";
      converseLib.validationFailed(28); /* Indicate not available*/
      TA1REC.TA1FUNC = "POST"; /* Termination function*/

    else
      if (SYPREC.SYPRC == 99) /* Unexpected return code*/

        PK0NW01.PK0NWERR = "Y";
        converseLib.validationFailed(29); /* Indicate system error*/
        TA1REC.TA1FUNC = "RETN"; /* Termination function*/

      end
    end

    TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
    TA1REC.TA1PGMNM = "PK0N915 "; /* Process name*/
    TA1REC.TA1LOC = "OBTAIN SIZE SCALE FOR PRODUCTS";
    TA1REC.TA1MAP = "PK0NM001"; /* Map name*/
    TA1REC.TA1DBASE = "DPICK   "; /* Data base name*/
    TA1REC.TA1TBLVU = "VPKSTY01"; /* Table view name*/
    TA1REC.TA1TBLKE = SYPREC.SYPDATA; /* Table key*/

    call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    PK0NM001.XXXERRID = "PK0N915"; /* Error location*/
    return; /* Return to previous process*/

  end

end // end PK0N915

// select set for order prepack
Function PK0N916()
   /* ************************************************************/
   /* *   select set on pktrec*/
   /* ************************************************************/

  call "IO2110" ("S2", SQLCA, PKTREC) {isNoRefresh = yes, isExternal = yes}; /* Select table set*/

  if (SQLCA.VAGen_SQLCODE != 0) /* Unexpected return code*/

    if (SQLCA.VAGen_SQLCODE == -911) /* Resource not available*/

      converseLib.validationFailed(28); /* Indicate not available*/
      TA1REC.TA1FUNC = "POST"; /* Termination function*/
      PK0NW01.PK0NWERR = "Y"; /* there was an error*/

    else

      converseLib.validationFailed(29); /* Indicate system error*/
      TA1REC.TA1FUNC = "RETN"; /* Termination function*/
      PK0NW01.PK0NWERR = "Y"; /* there was an error*/

    end

    TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
    TA1REC.TA1PGMNM = "PK0N916 "; /* Process name*/
    TA1REC.TA1LOC = "OBTAIN RECORDS FROM PREPACK";
    TA1REC.TA1MAP = "PK0NM001"; /* Map name*/
    TA1REC.TA1DBASE = "DPICK   "; /* Data base name*/
    TA1REC.TA1TBLVU = "VORSPP01"; /* Table view name*/
    TA1REC.TA1TBLKE = PKTREC.PKTKEY; /* Table key*/

    call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    PK0NM001.XXXERRID = "PK0N916"; /* Error location*/
    return; /* Return to previous process*/

  end

end // end PK0N916

// select next for order prepack
Function PK0N917()
   /* ************************************************************/
   /* *   fetch next record on pktrec*/
   /* ************************************************************/

  call "IO2110" ("N2", SQLCA, PKTREC) {isNoRefresh = yes, isExternal = yes}; /* fetch next row*/

  if (SQLCA.VAGen_SQLCODE == 100) /* Row not found*/

    return; /* Return to previous process*/

  end

  if (SQLCA.VAGen_SQLCODE != 0) /* Unexpected return code*/

    PK0NW01.PK0NWERR = "Y"; /* error*/
    converseLib.validationFailed(29); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
    TA1REC.TA1PGMNM = "PK0N917 "; /* Process name*/
    TA1REC.TA1LOC = "OBTAIN RECORDS FROM PREPACK";
    TA1REC.TA1MAP = "PK0NM001"; /* Map name*/
    TA1REC.TA1DBASE = "DPICK   "; /* Data base name*/
    TA1REC.TA1TBLVU = "VORSPP01"; /* Table view name*/
    TA1REC.TA1TBLKE = PKTREC.PKTKEY; /* Table key*/

    call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    PK0NM001.XXXERRID = "PK0N917"; /* Error location*/
    return; /* Return to previous process*/

  end

end // end PK0N917

// close set for order prepack
Function PK0N918()
   /* ************************************************************/
   /* *   close cursor for pktrec*/
   /* ************************************************************/

  call "IO2110" ("C2", SQLCA, PKTREC) {isNoRefresh = yes, isExternal = yes}; /* close table set*/

  if (SQLCA.VAGen_SQLCODE != 0) /* unexpected return code*/

    PK0NW01.PK0NWERR = "Y";
    converseLib.validationFailed(29); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
    TA1REC.TA1PGMNM = "PK0N918 "; /* Process name*/
    TA1REC.TA1LOC = "CLOSE CURSOR FOR PREPACK ";
    TA1REC.TA1MAP = "PK0NM001"; /* Map name*/
    TA1REC.TA1DBASE = "DPICK   "; /* Data base name*/
    TA1REC.TA1TBLVU = "VORSPP01"; /* Table view name*/
    TA1REC.TA1TBLKE = PKTREC.PKTKEY; /* Table key*/

    call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    PK0NM001.XXXERRID = "PK0N918"; /* Error location*/
    return; /* Return to previous process*/

  end
end // end PK0N918

// mass delete from order prepack
Function PK0N919()
   /* *************************************************************/
   /* mass delete from picking order prepack*/
   /* If end of file, get out*/
   /* If any error, indicate a system error.*/
   /* *************************************************************/

  call "IO2110" ("DA", SQLCA, PKTREC) {isNoRefresh = yes, isExternal = yes}; /* Fetch the next row*/

  if (SQLCA.VAGen_SQLCODE == 100) /* no record found*/

    return; /* return to previous application*/

  end

  if (SQLCA.VAGen_SQLCODE != 0) /* Unexpected return code*/

    if (SQLCA.VAGen_SQLCODE == -911)
      PK0NW01.PK0NWERR = "Y"; /* there was an error*/
      converseLib.validationFailed(28); /* data was in use by another appl*/
      TA1REC.TA1FUNC = "POST"; /* Termination function*/

    else
      converseLib.validationFailed(29); /* Indicate system error*/
      TA1REC.TA1FUNC = "RETN"; /* Termination function*/
      PK0NW01.PK0NWERR = "Y"; /* there was an error*/
    end

    TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
    TA1REC.TA1PGMNM = "PK0N919 "; /* Process name*/
    TA1REC.TA1LOC = "DELETE CONTENT FROM PREPACK";
    TA1REC.TA1MAP = "PK0NM001"; /* Map name*/
    TA1REC.TA1DBASE = "DPICK   "; /* Data base name*/
    TA1REC.TA1TBLVU = "VORSPP01"; /* Table view name*/
    TA1REC.TA1TBLKE = PKTREC.PKTKEY; /* table key*/

    call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    PK0NM001.XXXERRID = "PK0N919 "; /* Error location*/
    return; /* Return to previous process*/

  end
end // end PK0N919

// delete unique from ord prepack
Function PK0N920()
   /* *************************************************************/
   /* delete the selected record from picking order prepack*/
   /* If end of file, get out*/
   /* If any error, indicate a system error.*/
   /* *************************************************************/

  call "IO2110" ("D ", SQLCA, PKTREC) {isNoRefresh = yes, isExternal = yes}; /* Fetch the next row*/

  if (SQLCA.VAGen_SQLCODE == 100) /* no record found*/

    return; /* return to previous application*/

  end

  if (SQLCA.VAGen_SQLCODE != 0) /* Unexpected return code*/

    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(28); /* data was in use by another appl*/
      TA1REC.TA1FUNC = "POST"; /* Termination function*/
      PK0NW01.PK0NWERR = "Y"; /* there was an error*/

    else
      converseLib.validationFailed(29); /* Indicate system error*/
      TA1REC.TA1FUNC = "RETN"; /* Termination function*/
      PK0NW01.PK0NWERR = "Y"; /* there was an error*/
    end

    TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
    TA1REC.TA1PGMNM = "PK0N920 "; /* Process name*/
    TA1REC.TA1LOC = "DELETE CONTENT FROM PREPACK";
    TA1REC.TA1MAP = "PK0NM001"; /* Map name*/
    TA1REC.TA1DBASE = "DPICK   "; /* Data base name*/
    TA1REC.TA1TBLVU = "VORSPP01"; /* Table view name*/
    TA1REC.TA1TBLKE = PKTREC.PKTKEY; /* table key*/

    call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    PK0NM001.XXXERRID = "PK0N920 "; /* Error location*/
    return; /* Return to previous process*/

  end
end // end PK0N920

// add record to order prepack
Function PK0N921()
   /* *************************************************************/
   /* add the selected record to picking order prepack*/
   /* If end of file, get out*/
   /* If any error, indicate a system error.*/
   /* *************************************************************/

  call "IO2110" ("A ", SQLCA, PKTREC) {isNoRefresh = yes, isExternal = yes}; /* Fetch the next row*/

  if (SQLCA.VAGen_SQLCODE == 100) /* no record found*/

    return; /* return to previous application*/

  end

  if (SQLCA.VAGen_SQLCODE != 0) /* Unexpected return code*/

    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(28); /* data was in use by another appl*/
      TA1REC.TA1FUNC = "POST"; /* Termination function*/
      PK0NW01.PK0NWERR = "Y"; /* there was an error*/

    else
      converseLib.validationFailed(29); /* Indicate system error*/
      TA1REC.TA1FUNC = "RETN"; /* Termination function*/
      PK0NW01.PK0NWERR = "Y"; /* there was an error*/
    end

    TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
    TA1REC.TA1PGMNM = "PK0N921 "; /* Process name*/
    TA1REC.TA1LOC = "ADD CONTENT TO PREPACK";
    TA1REC.TA1MAP = "PK0NM001"; /* Map name*/
    TA1REC.TA1DBASE = "DPICK   "; /* Data base name*/
    TA1REC.TA1TBLVU = "VORSPP01"; /* Table view name*/
    TA1REC.TA1TBLKE = PKTREC.PKTKEY; /* table key*/

    call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    PK0NM001.XXXERRID = "PK0N921 "; /* Error location*/
    return; /* Return to previous process*/

  end
end // end PK0N921

// select unique on pool detail
Function PK0N922()
   /* *************************************************************/
   /* select data from pick pool detail*/
   /* If end of file, get out*/
   /* If any error, indicate a system error.*/
   /* *************************************************************/

  call "IO1990" ("SA", SQLCA, PK5REC) {isNoRefresh = yes, isExternal = yes}; /* select unique*/

  if (SQLCA.VAGen_SQLCODE == 100) /* row not found*/

    return;

  end

  if (SQLCA.VAGen_SQLCODE != 0) /* Unexpected return code*/

    if (SQLCA.VAGen_SQLCODE == -911) /* Resource not available*/

      PK0NW01.PK0NWERR = "Y";
      converseLib.validationFailed(28); /* Indicate not available*/
      TA1REC.TA1FUNC = "POST"; /* Termination function*/

    else

      PK0NW01.PK0NWERR = "Y";
      converseLib.validationFailed(29); /* Indicate system error*/
      TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    end

    TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
    TA1REC.TA1PGMNM = "PK0N922 "; /* Process name*/
    TA1REC.TA1LOC = "OBTAIN PRODUCT NBR FROM POOL";
    TA1REC.TA1MAP = "PK0NM001"; /* Map name*/
    TA1REC.TA1DBASE = "DPICK   "; /* Data base name*/
    TA1REC.TA1TBLVU = "VPOOLI01"; /* Table view name*/
    TA1REC.TA1TBLKE = PK5REC.PK5KEY; /* Table key*/

    call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    PK0NM001.XXXERRID = "PK0N922"; /* Error location*/
    return; /* Return to previous process*/

  end
end // end PK0N922

// delete from cust prepack
Function PK0N923()
   /* *************************************************************/
   /* delete from picking cust prepack*/
   /* If end of file, get out*/
   /* If any error, indicate a system error.*/
   /* *************************************************************/

  call "IO2100" ("D  ", SQLCA, PKSREC) {isNoRefresh = yes, isExternal = yes}; /* Fetch the next row*/

  if (SQLCA.VAGen_SQLCODE == 100) /* no record found*/

    return; /* return to previous application*/

  end

  if (SQLCA.VAGen_SQLCODE != 0) /* Unexpected return code*/

    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(28); /* data was in use by another appl*/
      TA1REC.TA1FUNC = "POST"; /* Termination function*/
      PK0NW01.PK0NWERR = "Y"; /* there was an error*/

    else
      converseLib.validationFailed(29); /* Indicate system error*/
      TA1REC.TA1FUNC = "RETN"; /* Termination function*/
      PK0NW01.PK0NWERR = "Y"; /* there was an error*/
    end

    TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
    TA1REC.TA1PGMNM = "PK0N923 "; /* Process name*/
    TA1REC.TA1LOC = "DELETE CONTENT FROM PREPACK";
    TA1REC.TA1MAP = "PK0NM001"; /* Map name*/
    TA1REC.TA1DBASE = "DPICK   "; /* Data base name*/
    TA1REC.TA1TBLVU = "VCUSPP01"; /* Table view name*/
    TA1REC.TA1TBLKE = PKSREC.PKSKEY; /* table key*/

    call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    PK0NM001.XXXERRID = "PK0N923 "; /* Error location*/
    return; /* Return to previous process*/

  end
end // end PK0N923

// add record to cust prepack
Function PK0N924()
   /* *************************************************************/
   /* add the selected record to picking cust prepack*/
   /* If end of file, get out*/
   /* If any error, indicate a system error.*/
   /* *************************************************************/

  call "IO2100" ("A ", SQLCA, PKSREC) {isNoRefresh = yes, isExternal = yes}; /* Fetch the next row*/

  if (SQLCA.VAGen_SQLCODE == 100) /* no record found*/

    return; /* return to previous application*/

  end

  if (SQLCA.VAGen_SQLCODE != 0) /* Unexpected return code*/

    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(28); /* data was in use by another appl*/
      TA1REC.TA1FUNC = "POST"; /* Termination function*/
      PK0NW01.PK0NWERR = "Y"; /* there was an error*/

    else
      converseLib.validationFailed(29); /* Indicate system error*/
      TA1REC.TA1FUNC = "RETN"; /* Termination function*/
      PK0NW01.PK0NWERR = "Y"; /* there was an error*/
    end

    TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
    TA1REC.TA1PGMNM = "PK0N924 "; /* Process name*/
    TA1REC.TA1LOC = "ADD CONTENT TO PREPACK";
    TA1REC.TA1MAP = "PK0NM001"; /* Map name*/
    TA1REC.TA1DBASE = "DPICK   "; /* Data base name*/
    TA1REC.TA1TBLVU = "VCUSPP01"; /* Table view name*/
    TA1REC.TA1TBLKE = PKSREC.PKSKEY; /* table key*/

    call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    PK0NM001.XXXERRID = "PK0N924 "; /* Error location*/
    return; /* Return to previous process*/

  end
end // end PK0N924

// select cust nbr from cust prpk
Function PK0N925()
   /* *************************************************************/
   /* select data from pick cust prepack*/
   /* If end of file, get out*/
   /* If any error, indicate a system error.*/
   /* *************************************************************/

  call "IO2100" ("S ", SQLCA, PKSREC) {isNoRefresh = yes, isExternal = yes}; /* select unique*/

  if (SQLCA.VAGen_SQLCODE == 100) /* row not found*/

    return;

  end

  if (SQLCA.VAGen_SQLCODE != 0) /* Unexpected return code*/

    if (SQLCA.VAGen_SQLCODE == -911) /* Resource not available*/

      PK0NW01.PK0NWERR = "Y";
      converseLib.validationFailed(28); /* Indicate not available*/
      TA1REC.TA1FUNC = "POST"; /* Termination function*/

    else

      PK0NW01.PK0NWERR = "Y";
      converseLib.validationFailed(29); /* Indicate system error*/
      TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    end

    TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
    TA1REC.TA1PGMNM = "PK0N925 "; /* Process name*/
    TA1REC.TA1LOC = "OBTAIN CUST NBR FROM PREP";
    TA1REC.TA1MAP = "PK0NM001"; /* Map name*/
    TA1REC.TA1DBASE = "DPICK   "; /* Data base name*/
    TA1REC.TA1TBLVU = "VCUSPP01"; /* Table view name*/
    TA1REC.TA1TBLKE = PKSREC.PKSKEY; /* Table key*/

    call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    PK0NM001.XXXERRID = "PK0N925"; /* Error location*/
    return; /* Return to previous process*/

  end
end // end PK0N925

// select set for order prepack
Function PK0N928()
   /* ************************************************************/
   /* *   select set on pktrec*/
   /* ************************************************************/

  call "IO2110" ("S1", SQLCA, PKTREC) {isNoRefresh = yes, isExternal = yes}; /* Select table set*/

  if (SQLCA.VAGen_SQLCODE != 0) /* Unexpected return code*/

    if (SQLCA.VAGen_SQLCODE == -911) /* Resource not available*/

      converseLib.validationFailed(28); /* Indicate not available*/
      TA1REC.TA1FUNC = "POST"; /* Termination function*/
      PK0NW01.PK0NWERR = "Y"; /* there was an error*/

    else

      converseLib.validationFailed(29); /* Indicate system error*/
      TA1REC.TA1FUNC = "RETN"; /* Termination function*/
      PK0NW01.PK0NWERR = "Y"; /* there was an error*/

    end

    TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
    TA1REC.TA1PGMNM = "PK0N928 "; /* Process name*/
    TA1REC.TA1LOC = "OBTAIN RECORDS FROM PREPACK";
    TA1REC.TA1MAP = "PK0NM001"; /* Map name*/
    TA1REC.TA1DBASE = "DPICK   "; /* Data base name*/
    TA1REC.TA1TBLVU = "VORSPP01"; /* Table view name*/
    TA1REC.TA1TBLKE = PKTREC.PKTKEY; /* Table key*/

    call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    PK0NM001.XXXERRID = "PK0N928"; /* Error location*/
    return; /* Return to previous process*/

  end

end // end PK0N928

// select next for order prepack
Function PK0N929()
   /* ************************************************************/
   /* *   fetch next record on pktrec*/
   /* ************************************************************/

  call "IO2110" ("N1", SQLCA, PKTREC) {isNoRefresh = yes, isExternal = yes}; /* fetch next row*/

  if (SQLCA.VAGen_SQLCODE == 100) /* Row not found*/

    return; /* Return to previous process*/

  end

  if (SQLCA.VAGen_SQLCODE != 0) /* Unexpected return code*/

    PK0NW01.PK0NWERR = "Y";
    converseLib.validationFailed(29); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
    TA1REC.TA1PGMNM = "PK0N929 "; /* Process name*/
    TA1REC.TA1LOC = "OBTAIN RECORDS FROM PREPACK";
    TA1REC.TA1MAP = "PK0NM001"; /* Map name*/
    TA1REC.TA1DBASE = "DPICK   "; /* Data base name*/
    TA1REC.TA1TBLVU = "VORSPP01"; /* Table view name*/
    TA1REC.TA1TBLKE = PKTREC.PKTKEY; /* Table key*/

    call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    PK0NM001.XXXERRID = "PK0N929"; /* Error location*/
    return; /* Return to previous process*/

  end

end // end PK0N929

// close set for order prepack
Function PK0N930()
   /* ************************************************************/
   /* *   close cursor for pktrec*/
   /* ************************************************************/

  call "IO2110" ("C1", SQLCA, PKTREC) {isNoRefresh = yes, isExternal = yes}; /* close table set*/

  if (SQLCA.VAGen_SQLCODE != 0) /* unexpected return code*/

    PK0NW01.PK0NWERR = "Y";
    converseLib.validationFailed(29); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
    TA1REC.TA1PGMNM = "PK0N930 "; /* Process name*/
    TA1REC.TA1LOC = "CLOSE CURSOR FOR ORDER PREPACK";
    TA1REC.TA1MAP = "PK0NM001"; /* Map name*/
    TA1REC.TA1DBASE = "DPICK   "; /* Data base name*/
    TA1REC.TA1TBLVU = "VORSPP01"; /* Table view name*/
    TA1REC.TA1TBLKE = PKTREC.PKTKEY; /* Table key*/

    call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    PK0NM001.XXXERRID = "PK0N930"; /* Error location*/
    return; /* Return to previous process*/

  end
end // end PK0N930

// select cust nbr from cust prpk
Function PK0N931()
   /* *************************************************************/
   /* select data from pick order prepack*/
   /* If end of file, get out*/
   /* If any error, indicate a system error.*/
   /* *************************************************************/

  call "IO2110" ("S ", SQLCA, PKTREC) {isNoRefresh = yes, isExternal = yes}; /* select unique*/

  if (SQLCA.VAGen_SQLCODE == 100) /* row not found*/

    return;

  end

  if (SQLCA.VAGen_SQLCODE != 0) /* Unexpected return code*/

    if (SQLCA.VAGen_SQLCODE == -911) /* Resource not available*/

      PK0NW01.PK0NWERR = "Y";
      converseLib.validationFailed(28); /* Indicate not available*/
      TA1REC.TA1FUNC = "POST"; /* Termination function*/

    else

      PK0NW01.PK0NWERR = "Y";
      converseLib.validationFailed(29); /* Indicate system error*/
      TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    end

    TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
    TA1REC.TA1PGMNM = "PK0N931 "; /* Process name*/
    TA1REC.TA1LOC = "OBTAIN ORDER FROM PREPACK";
    TA1REC.TA1MAP = "PK0NM001"; /* Map name*/
    TA1REC.TA1DBASE = "DPICK   "; /* Data base name*/
    TA1REC.TA1TBLVU = "VCUSPP01"; /* Table view name*/
    TA1REC.TA1TBLKE = PKTREC.PKTKEY; /* Table key*/

    call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    PK0NM001.XXXERRID = "PK0N931"; /* Error location*/
    return; /* Return to previous process*/

  end
end // end PK0N931

// select unique for sycrec
Function PK0N932()
   /* *************************************************************/
   /* Fetch description*/
   /* If any error, indicate a system error.*/
   /* *************************************************************/

  call "IO1810" ("S ", SQLCA, PKNREC) {isNoRefresh = yes, isExternal = yes}; /* inquire on row*/

  if (SQLCA.VAGen_SQLCODE == 0 /* Normal return code*/
  )                           
      /* CANADA 08/11/95*/

    if (PKWREC.XCTCD == "CANA")

        /* format ta1rec in case of bad return code from call to SY2000*/

      TA1REC.TA1PGMNM = "PK0N"; /* CANA program name*/
      TA1REC.TA1LOC = "PK0N932"; /* CANA sgrp name*/

      XSPK-CALL-SY2000(); /* CANA call SY2000 to get*/
                                /* product region record*/
      if (WSY2000.WSY2000-RETURN-CODE == 0) /* CANA row found*/
        return;
      else
        if (WSY2000.WSY2000-RETURN-CODE == 02) /* CANA row not found*/
          PKNREC.SY1SSTNM = " ";
          return;
        else
          if (WSY2000.WSY2000-RETURN-CODE == 98) /* CANA database busy*/
            PK0NW01.PK0NWERR = "Y";
            converseLib.validationFailed(28); /* Indicate not available*/
            TA1REC.TA1FUNC = "POST"; /* Termination function*/
          else
            PK0NW01.PK0NWERR = "Y";
            converseLib.validationFailed(29); /* Indicate system error*/
            TA1REC.TA1FUNC = "RETN"; /* Termination function*/
            converseLib.clearScreen();
             /* Clear screen before display*/
          end
          TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
          TA1REC.TA1PGMNM = "PK0N932 "; /* Process name*/
          TA1REC.TA1LOC = "INQUIRE ON PRODUCT DATA";
          TA1REC.TA1MAP = "PK0NM001"; /* Map name*/
          TA1REC.TA1DBASE = "DPICK   "; /* Data base name*/
          TA1REC.TA1TBLVU = "VPKSTY01"; /* Table view name*/

                                            /* Error diagnosis routine*/
          call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes};

          PK0NM001.XXXERRID = "PK0N932 "; /* Error location*/
          return;

        end
      end
    end
    return;
  end
  if (SQLCA.VAGen_SQLCODE == 100) /* End of selected set*/

    return; /* Return to previous process*/

  end

  if (SQLCA.VAGen_SQLCODE != 0) /* Unexpected return code*/
    if (SQLCA.VAGen_SQLCODE == -911)
      PK0NW01.PK0NWERR = "Y";
      converseLib.validationFailed(28); /* resource not available*/
      TA1REC.TA1FUNC = "POST"; /* termination function*/
    else
      PK0NW01.PK0NWERR = "Y";
      converseLib.validationFailed(29); /* Indicate system error*/
      TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    end
    TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
    TA1REC.TA1PGMNM = "PK0N932 "; /* Process name*/
    TA1REC.TA1LOC = "INQUIRE ON PRODUCT DATA";
    TA1REC.TA1MAP = "PK0NM001"; /* Map name*/
    TA1REC.TA1DBASE = "DPICK   "; /* Data base name*/
    TA1REC.TA1TBLVU = "VPKSTY01"; /* Table view name*/

    call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    PK0NM001.XXXERRID = "PK0N932 "; /* Error location*/
    return; /* Return to previous process*/

  end
end // end PK0N932

// select set  for pool header
Function PK0N933()
   /* ************************************************************/
   /* *   select set on pktrec*/
   /* ************************************************************/

  set PWIREC empty;
  PWIREC.PWIFUNC = "S2";
  call "IO1720" (PWIREC, SQLCA, PK4REC) {isNoRefresh = yes, isExternal = yes}; /* Select table set*/

  if (SQLCA.VAGen_SQLCODE != 0) /* Unexpected return code*/

    if (SQLCA.VAGen_SQLCODE == -911) /* Resource not available*/

      converseLib.validationFailed(28); /* Indicate not available*/
      TA1REC.TA1FUNC = "POST"; /* Termination function*/
      PK0NW01.PK0NWERR = "Y"; /* there was an error*/

    else

      converseLib.validationFailed(29); /* Indicate system error*/
      TA1REC.TA1FUNC = "RETN"; /* Termination function*/
      PK0NW01.PK0NWERR = "Y"; /* there was an error*/

    end

    TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
    TA1REC.TA1PGMNM = "PK0N933 "; /* Process name*/
    TA1REC.TA1LOC = "OBTAIN RECORDS FROM POOL HEADER";
    TA1REC.TA1MAP = "PK0NM001"; /* Map name*/
    TA1REC.TA1DBASE = "DPICK   "; /* Data base name*/
    TA1REC.TA1TBLVU = "VPOOLH01"; /* Table view name*/
    TA1REC.TA1TBLKE = PK4REC.PK4KEY; /* Table key*/

    call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    PK0NM001.XXXERRID = "PK0N933"; /* Error location*/
    return; /* Return to previous process*/

  end

end // end PK0N933

// select next for pool header
Function PK0N934()
   /* ************************************************************/
   /* *   fetch next record on pktrec*/
   /* ************************************************************/

  set PWIREC empty;
  PWIREC.PWIFUNC = "N2";
  call "IO1720" (PWIREC, SQLCA, PK4REC) {isNoRefresh = yes, isExternal = yes}; /* fetch next row*/

  if (SQLCA.VAGen_SQLCODE == 100) /* Row not found*/

    return; /* Return to previous process*/

  end

  if (SQLCA.VAGen_SQLCODE != 0) /* Unexpected return code*/

    PK0NW01.PK0NWERR = "Y";
    converseLib.validationFailed(29); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
    TA1REC.TA1PGMNM = "PK0N934 "; /* Process name*/
    TA1REC.TA1LOC = "OBTAIN RECORDS FROM POOL HEADER";
    TA1REC.TA1MAP = "PK0NM001"; /* Map name*/
    TA1REC.TA1DBASE = "DPICK   "; /* Data base name*/
    TA1REC.TA1TBLVU = "VPOOLH01"; /* Table view name*/
    TA1REC.TA1TBLKE = PK4REC.PK4KEY; /* Table key*/

    call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    PK0NM001.XXXERRID = "PK0N934"; /* Error location*/
    return; /* Return to previous process*/

  end

end // end PK0N934

// close  set  for pool header
Function PK0N935()
   /* ************************************************************/
   /* *   close pk4rec*/
   /* ************************************************************/

  set PWIREC empty;
  PWIREC.PWIFUNC = "C2";
  call "IO1720" (PWIREC, SQLCA, PK4REC) {isNoRefresh = yes, isExternal = yes}; /* fetch next row*/

  if (SQLCA.VAGen_SQLCODE != 0) /* Unexpected return code*/

    PK0NW01.PK0NWERR = "Y";
    converseLib.validationFailed(29); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
    TA1REC.TA1PGMNM = "PK0N935 "; /* Process name*/
    TA1REC.TA1LOC = "CLOSE POOL HEADER              ";
    TA1REC.TA1MAP = "PK0NM001"; /* Map name*/
    TA1REC.TA1DBASE = "DPICK   "; /* Data base name*/
    TA1REC.TA1TBLVU = "VPOOLH01"; /* Table view name*/
    TA1REC.TA1TBLKE = PK4REC.PK4KEY; /* Table key*/

    call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    PK0NM001.XXXERRID = "PK0N935"; /* Error location*/
    return; /* Return to previous process*/

  end

end // end PK0N935

// update prepack record
Function PK0N936()
   /* *************************************************************/
   /* update the selected record to picking order prepack*/
   /* If end of file, get out*/
   /* If any error, indicate a system error.*/
   /* *************************************************************/

  call "IO2110" ("U ", SQLCA, PKTREC) {isNoRefresh = yes, isExternal = yes}; /* Update Prepack row*/

  if (SQLCA.VAGen_SQLCODE == 100) /* no record found*/

    return; /* return to previous application*/

  end

  if (SQLCA.VAGen_SQLCODE != 0) /* Unexpected return code*/

    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(28); /* data was in use by another appl*/
      TA1REC.TA1FUNC = "POST"; /* Termination function*/
      PK0NW01.PK0NWERR = "Y"; /* there was an error*/

    else
      converseLib.validationFailed(29); /* Indicate system error*/
      TA1REC.TA1FUNC = "RETN"; /* Termination function*/
      PK0NW01.PK0NWERR = "Y"; /* there was an error*/
    end

    TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
    TA1REC.TA1PGMNM = "PK0N936 "; /* Process name*/
    TA1REC.TA1LOC = "UPDATE PREPACK        ";
    TA1REC.TA1MAP = "PK0NM001"; /* Map name*/
    TA1REC.TA1DBASE = "DPICK   "; /* Data base name*/
    TA1REC.TA1TBLVU = "VORSPP01"; /* Table view name*/
    TA1REC.TA1TBLKE = PKTREC.PKTKEY; /* table key*/

    call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    PK0NM001.XXXERRID = "PK0N936 "; /* Error location*/
    return; /* Return to previous process*/

  end
end // end PK0N936

// Purge any temporary storage
Function PK0N950()
   /* ------------------------------------------------------------*/
   /* Purge any temporary storage for this application.*/
   /* ------------------------------------------------------------*/

  set TA5REC empty;
  TA5REC.TA5APPID = "PK0N"; /* Application identification*/
  TA5REC.TA5FNCCD = "P"; /* Function code*/

  call "TA0050" (PK0NW03, TA5REC) {isNoRefresh = yes, isExternal = yes};
                                   /* Temporary storage subroutine*/

  if (TA5REC.TA5RTNCD != 0) /* Error was found*/

    TA1REC.TA1FUNC = "POST"; /* Termination function*/
    TA1REC.TA1TYPE = "APPL"; /* Type of error*/
    TA1REC.TA1PGMNM = "PK0N950 "; /* Process name*/
    TA1REC.TA1LOC = "PURGE ANY TEMPORARY STORAGE";
    TA1REC.TA1MAP = "PK0NM001"; /* Map name*/
    SQLCA.SQLCAREC = TA5REC.TA5DATA; /* Subroutine parameters*/

    call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  end
end // end PK0N950

// Add page to temporary storage
Function PK0N951()
   /* ------------------------------------------------------------*/
   /* Add the next page to temporary storage.*/
   /* ------------------------------------------------------------*/

  PK0NW03.PK0NWLEN = 587; /* Temporary storage length*/
  TA5REC.TA5APPID = "PK0N"; /* Application identification*/
  TA5REC.TA5FNCCD = "A"; /* Function code*/

  call "TA0050" (PK0NW03, TA5REC) {isNoRefresh = yes, isExternal = yes};
                                   /* Temporary storage subroutine*/

  if (TA5REC.TA5RTNCD != 0) /* Error was found*/

    PK0NW01.PK0NWERR = "Y";
    converseLib.validationFailed(29); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    TA1REC.TA1TYPE = "APPL"; /* Type of error*/
    TA1REC.TA1PGMNM = "PK0N951 "; /* Process name*/
    TA1REC.TA1LOC = "ADD PAGE TO TEMPORARY STORAGE";
    TA1REC.TA1MAP = "PK0NM001"; /* Map name*/
    SQLCA.SQLCAREC = TA5REC.TA5DATA; /* Subroutine parameters*/

    call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    PK0NM001.XXXERRID = "PK0N951 "; /* Error location*/
    return; /* Return to previous process*/

  end

  PK0NW01.PK0NWLP1 = TA5REC.TA5TSQIX; /* last page nbr*/

  set PK0NW03 empty; /* Clear temporary storage record*/

end // end PK0N951

// Update temporary storage page
Function PK0N952()
   /* ------------------------------------------------------------*/
   /* Update the page of orders in temporary storage.*/
   /* ------------------------------------------------------------*/

  set TA5REC empty;
  PK0NW03.PK0NWLEN = 587; /* Temporary storage length*/
  TA5REC.TA5APPID = "PK0N"; /* Application identification*/
  TA5REC.TA5TSQIX = PK0NW01.PK0NWCP1; /* Page number*/
  TA5REC.TA5FNCCD = "U"; /* Update page in temporary storage*/

  call "TA0050" (PK0NW03, TA5REC) {isNoRefresh = yes, isExternal = yes};
                                   /* Temporary storage subroutine*/

  if (TA5REC.TA5RTNCD != 0) /* Error was found*/

    PK0NW01.PK0NWERR = "Y";
    converseLib.validationFailed(29); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    TA1REC.TA1TYPE = "APPL"; /* Type of error*/
    TA1REC.TA1PGMNM = "PK0N952 "; /* Process name*/
    TA1REC.TA1LOC = "UPDATE PAGE IN TEMPORARY STORAGE";
    TA1REC.TA1MAP = "PK0NM001"; /* Map name*/
    SQLCA.SQLCAREC = TA5REC.TA5DATA; /* Subroutine parameters*/

    call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    PK0NM001.XXXERRID = "PK0N952 "; /* Error location*/
    return; /* Return to previous process*/

  end
end // end PK0N952

// Read temporary storage page
Function PK0N953()
   /* ------------------------------------------------------------*/
   /* Obtain the next page of orders to display.*/
   /* ------------------------------------------------------------*/

  set TA5REC empty;
  PK0NW03.PK0NWLEN = 587; /* Temporary storage length*/
  TA5REC.TA5APPID = "PK0N"; /* Application identification*/
  TA5REC.TA5TSQIX = PK0NW01.PK0NWCP1; /* Page number*/
  TA5REC.TA5FNCCD = "R"; /* Function code*/

  call "TA0050" (PK0NW03, TA5REC) {isNoRefresh = yes, isExternal = yes};
                                   /* Temporary storage subroutine*/

  if (TA5REC.TA5RTNCD == 7) /* end of file*/

     /* next sentence*/

  else
    if (TA5REC.TA5RTNCD != 0) /* Error was found*/

      converseLib.validationFailed(29); /* Indicate system error*/
      PK0NW01.PK0NWERR = "Y"; /* error on screen*/
      TA1REC.TA1FUNC = "RETN"; /* Termination function*/

      TA1REC.TA1TYPE = "APPL"; /* Type of error*/
      TA1REC.TA1PGMNM = "PK0N953 "; /* Process name*/
      TA1REC.TA1LOC = "READ PAGE FROM TEMPORARY STORAGE";
      TA1REC.TA1MAP = "PK0NM001"; /* Map name*/
      SQLCA.SQLCAREC = TA5REC.TA5DATA; /* Subroutine parameters*/

      call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

      PK0NM001.XXXERRID = "PK0N953 "; /* Error location*/
      return; /* Return to previous process*/

    end
  end
end // end PK0N953

// handle temp storage error
Function PK0N954()
   /* ***********************************************************/
   /* *  handle temp storage errors by:*/
   /* *   set temp storage empty*/
   /* *   move 'no' to a-new-order flag (pk0nwano)*/
   /* *   set last-page counters to 0 (pk0nwlp1/2)*/
   /* ***********************************************************/

  PK0NM001.XXXERRID = "PK0N954"; /* show place of error*/

  set PK0NW02 empty;
  set PK0NW03 empty;
  PK0N950();
  PK0N960();
  PK0NW01.PK0NWANO = "N"; /* not adding new record*/
  PK0NW01.PK0NWLP1 = 0;
  PK0NW01.PK0NWLP2 = 0;
  converseLib.validationFailed(229); /* system error - data is gone - exit and start over*/
  return;
end // end PK0N954

// Purge any temporary storage
Function PK0N960()
   /* ------------------------------------------------------------*/
   /* Purge any temporary storage for this application.*/
   /* ------------------------------------------------------------*/

  set TA5REC empty;
  TA5REC.TA5APPID = "PK1N"; /* Application identification*/
  TA5REC.TA5FNCCD = "P"; /* Function code*/

  call "TA0050" (PK0NW02, TA5REC) {isNoRefresh = yes, isExternal = yes};
                                   /* Temporary storage subroutine*/

  if (TA5REC.TA5RTNCD != 0) /* Error was found*/

    TA1REC.TA1FUNC = "POST"; /* Termination function*/
    TA1REC.TA1TYPE = "APPL"; /* Type of error*/
    TA1REC.TA1PGMNM = "PK0N960 "; /* Process name*/
    TA1REC.TA1LOC = "PURGE ANY TEMPORARY STORAGE";
    TA1REC.TA1MAP = "PK0NM001"; /* Map name*/
    SQLCA.SQLCAREC = TA5REC.TA5DATA; /* Subroutine parameters*/

    call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  end

  set PK0NW02 empty;
end // end PK0N960

// Add page to temporary storage
Function PK0N961()
   /* ------------------------------------------------------------*/
   /* Add the next page to temporary storage.*/
   /* ------------------------------------------------------------*/

  PK0NW02.PK0NWLEN = 912; /* Temporary storage length*/
  TA5REC.TA5APPID = "PK1N"; /* Application identification*/
  TA5REC.TA5FNCCD = "A"; /* Function code*/

  call "TA0050" (PK0NW02, TA5REC) {isNoRefresh = yes, isExternal = yes};
                                   /* Temporary storage subroutine*/

  if (TA5REC.TA5RTNCD != 0) /* Error was found*/

    PK0NW01.PK0NWERR = "Y";
    converseLib.validationFailed(29); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    TA1REC.TA1TYPE = "APPL"; /* Type of error*/
    TA1REC.TA1PGMNM = "PK0N961 "; /* Process name*/
    TA1REC.TA1LOC = "ADD PAGE TO TEMPORARY STORAGE";
    TA1REC.TA1MAP = "PK0NM001"; /* Map name*/
    SQLCA.SQLCAREC = TA5REC.TA5DATA; /* Subroutine parameters*/

    call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    PK0NM001.XXXERRID = "PK0N161 "; /* Error location*/
    return; /* Return to previous process*/

  end

  PK0NW01.PK0NWLP2 = TA5REC.TA5TSQIX; /* last page number*/
end // end PK0N961

// Update temporary storage page
Function PK0N962()
   /* ------------------------------------------------------------*/
   /* Update the page of orders in temporary storage.*/
   /* ------------------------------------------------------------*/

  set TA5REC empty;
  PK0NW02.PK0NWLEN = 912; /* Temporary storage length*/
  TA5REC.TA5TSQIX = PK0NW01.PK0NWCP2; /* page number*/
  TA5REC.TA5APPID = "PK1N"; /* Application identification*/
  TA5REC.TA5FNCCD = "U"; /* Update page in temporary storage*/

  call "TA0050" (PK0NW02, TA5REC) {isNoRefresh = yes, isExternal = yes};
                                   /* Temporary storage subroutine*/

  if (TA5REC.TA5RTNCD == 7 /* end of file*/
   || TA5REC.TA5RTNCD == 4) /* end of file*/
    return;
  end

  if (TA5REC.TA5RTNCD != 0) /* Error was found*/

    PK0NW01.PK0NWERR = "Y";
    converseLib.validationFailed(29); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    TA1REC.TA1TYPE = "APPL"; /* Type of error*/
    TA1REC.TA1PGMNM = "PK0N962 "; /* Process name*/
    TA1REC.TA1LOC = "UPDATE PAGE IN TEMPORARY STORAGE";
    TA1REC.TA1MAP = "PK0NM001"; /* Map name*/
    SQLCA.SQLCAREC = TA5REC.TA5DATA; /* Subroutine parameters*/

    call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    PK0NM001.XXXERRID = "PK0N962 "; /* Error location*/
    return; /* Return to previous process*/

  end
end // end PK0N962

// Read temporary storage page
Function PK0N963()
   /* ------------------------------------------------------------*/
   /* Obtain the next page of orders to display.*/
   /* ------------------------------------------------------------*/

  set TA5REC empty;
  PK0NW02.PK0NWLEN = 912; /* Temporary storage length*/
  TA5REC.TA5APPID = "PK1N"; /* Application identification*/
  TA5REC.TA5TSQIX = PK0NW01.PK0NWCP2; /* Page number*/
  TA5REC.TA5FNCCD = "R"; /* Function code*/

  call "TA0050" (PK0NW02, TA5REC) {isNoRefresh = yes, isExternal = yes};
                                   /* Temporary storage subroutine*/

  if (TA5REC.TA5RTNCD == 7) /* end of file*/

     /* next sentence*/

  else

    if (TA5REC.TA5RTNCD != 0) /* Error was found*/

      converseLib.validationFailed(29); /* Indicate system error*/
      PK0NW01.PK0NWERR = "Y"; /* error on screen*/
      TA1REC.TA1FUNC = "RETN"; /* Termination function*/

      TA1REC.TA1TYPE = "APPL"; /* Type of error*/
      TA1REC.TA1PGMNM = "PK0N963 "; /* Process name*/
      TA1REC.TA1LOC = "READ PAGE FROM TEMPORARY STORAGE";
      TA1REC.TA1MAP = "PK0NM001"; /* Map name*/
      SQLCA.SQLCAREC = TA5REC.TA5DATA; /* Subroutine parameters*/

      call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

      PK0NM001.XXXERRID = "PK0N963 "; /* Error location*/
      return; /* Return to previous process*/

    end
  end
end // end PK0N963

// UPDATE POOL HEADER
Function PK0N970()
   /* *************************************************************/
   /* UPDATE XPA_CUST_PACK_CD*/
   /* calling routine has set PK1CUOID and PK1NORID. Also, the new*/
   /* value of XPA_CUST_PACK_CD.*/
   /* If any error, indicate a system error.*/
   /* *************************************************************/

  PWIREC.PWIFUNC = "U ";
  call "IO1720" (PWIREC, SQLCA, PK4REC) {isNoRefresh = yes, isExternal = yes}; /* select unique*/

  if (SQLCA.VAGen_SQLCODE != 0) /* Unexpected return code*/

    if (SQLCA.VAGen_SQLCODE == -911) /* Resource not available*/

      PK0NW01.PK0NWERR = "Y";
      converseLib.validationFailed(28); /* Indicate not available*/
      TA1REC.TA1FUNC = "POST"; /* Termination function*/

    else

      PK0NW01.PK0NWERR = "Y";
      converseLib.validationFailed(29); /* Indicate system error*/
      TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    end

    TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
    TA1REC.TA1PGMNM = "PK0N970 "; /* Process name*/
    TA1REC.TA1LOC = "UPDATE CUST NBR FROM POOL";
    TA1REC.TA1MAP = "PK0NM001"; /* Map name*/
    TA1REC.TA1DBASE = "DPICK   "; /* Data base name*/
    TA1REC.TA1TBLVU = "VPOOLH01"; /* Table view name*/
    TA1REC.TA1TBLKE = PK4REC.PK4KEY; /* Table key*/

    call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    PK0NM001.XXXERRID = "PK0N970"; /* Error location*/
    return; /* Return to previous process*/

  end
end // end PK0N970

// update pool item
Function PK0N971()
   /* *************************************************************/
   /* Update VPOOLI01*/
   /*  */
   /* calling routine has set key, and*/
   /* changed quantity fields to reflect repack state.*/
   /*  */
   /* If any error, indicate a system error.*/
   /* *************************************************************/

  PWIREC.PWIFUNC = "U ";
  call "IO1990" (PWIREC, SQLCA, PK5REC) {isNoRefresh = yes, isExternal = yes}; /* update unique*/

  if (SQLCA.VAGen_SQLCODE != 0) /* Unexpected return code*/

    if (SQLCA.VAGen_SQLCODE == -911) /* Resource not available*/

      PK0NW01.PK0NWERR = "Y";
      converseLib.validationFailed(28); /* Indicate not available*/
      TA1REC.TA1FUNC = "POST"; /* Termination function*/

    else

      PK0NW01.PK0NWERR = "Y";
      converseLib.validationFailed(29); /* Indicate system error*/
      TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    end

    TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
    TA1REC.TA1PGMNM = "PK0N971         "; /* Process name*/
    TA1REC.TA1LOC = "UPDATE ITEM QTY FROM POOL";
    TA1REC.TA1MAP = "PK0NM001"; /* Map name*/
    TA1REC.TA1DBASE = "DPICK   "; /* Data base name*/
    TA1REC.TA1TBLVU = "VPOOLI01"; /* Table view name*/
    TA1REC.TA1TBLKE = PK5REC.PK5KEY; /* Table key*/

    call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    PK0NM001.XXXERRID = "PK0N971        "; /* Error location*/

  end

end // end PK0N971

// Call PK4420 w/PWSREC
Function PK0NS-CRTN-CALL()
   /* ***********************************/
          /* Compute' carton type*/
   /* ***********************************/

  try
    call "PK4420" (SQLCA, PWSREC) {isNoRefresh = yes, isExternal = yes};
  end

  if (SQLCA.VAGen_SQLCODE == -911) /* db busy*/
    PK0NW01.PK0NWERR = "Y";
    converseLib.validationFailed(028); /* database busy try again*/
    return;
  end

   /* Return Code from call { PWSRTNCD }*/

   /* values:   0 - carton computed successfully*/
             /* 1 - COBOL table size error*/
             /* 2 - required database record not found*/
             /* 3 - no cartons large enough for packages*/
             /* 4 - products do not have matching carton types*/
             /* 5 - product/size not set up with a carton class*/
             /* 6 - product is not set up with carton class rec*/
             /* 7 - product needs to be set up with a hang cart*/
             /* 8 - no items passed to pk4420*/
             /* 9 - no prepack quantities entered for item*/

             /* Generic error code moved in PK0NS-CRTN-CONTROL*/

   /* ------------------------------------------------------------*/

  if (PWSREC.PWSRTNCD == 0) /* good return*/
    return;
  end

  PK0NW01.PK0NWERR = "Y";

  if (PWSREC.PWSRTNCD == 3
   || PWSREC.PWSRTNCD == 4
   || PWSREC.PWSRTNCD == 5
   || PWSREC.PWSRTNCD == 6
   || PWSREC.PWSRTNCD == 7
   || PWSREC.PWSRTNCD == 9)
    converseLib.validationFailed(209); /* Invalid carton type*/
    return;
  end

   /* Serious error*/

  converseLib.validationFailed(29); /* Indicate system error*/

  TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  TA1REC.TA1TYPE = "APPL"; /* Type of error*/
  TA1REC.TA1LOC = "PK0NS-CRTN-CALL";
  TA1REC.TA1TBLKE = PWSREC.PWSKEY; /* table key*/
  TA1REC.TA1MAP = "PK0NM001"; /* Map name*/

  call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PK0NM001.XXXERRID = "PK0NS-CRTN-CALL"; /* Error location*/

end // end PK0NS-CRTN-CALL

// Prepare PWSREC for PK4420
Function PK0NS-CRTN-CONTROL()
   /* ******************************** **/
   /* Carton control module      **/
   /* Only for action equal 'C' or 'A' **/
   /* ******************************** **/

   /* get and move pwsrec record header information*/

  set PWSREC empty;

  set PK4REC empty;
  PK4REC.XWHCD = PK0NM001.XWHCD;
  PK0NW01.PK0NWCUI = PK0NM001.PK1CUOID;
  PK4REC.PK1PRTN = PK0NW01.PK1PRTN;
  PK4REC.PK1CUOID = PK0NM001.PK1CUOID;
  PK4REC.PK1NORID = PK0NM001.PK1NORID;

  PK0N910(); /* select unique from pool header*/
  if (converseVar.validationMsgNum != 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == 100)
    converseLib.validationFailed(184); /* order does not exist*/
    PK0NS53(); /* clear detail lines*/
    set PK0NM001.PK1CUOID cursor, bold;
    set PK0NM001.PK1NORID bold;
    PK0NW01.PK1CUOID = 0; /* init customer number*/
    PK0NW01.PK0NWERR = "Y";
    return;
  else
    PWSREC.KUCCOID = PK4REC.KUCCOID;
  end

  PK0NW06.PK0NW-6NDX = 1; /* move sizes to PWSREC*/
  while (PK0NW06.PK0NW-6NDX <= 40)
    PK0NW06.PKTPPQTY[PK0NW-6NDX] = PKTREC.PKTPPQTY[PK0NW-6NDX];
    PK0NW06.PK0NW-6NDX = PK0NW06.PK0NW-6NDX + 1;
  end
  PWSREC.PWSPPQGP[1] = PK0NW06.PK0NW-PREPAK-SIZES;

  PWSREC.OP1PARTN = PK0NW01.PK1PRTN;
  PWSREC.OP2LNINB[1] = PK0NW02.PK1LNINB;

  PWSREC.OP1CUOID = PK0NM001.PK1CUOID;
  PWSREC.OP1NORID = PK0NM001.PK1NORID;
  PWSREC.XWHCD = PK0NM001.XWHCD;
  PWSREC.XGPCD = PK0NM001.XGPCD;
  PWSREC.XBCCD = PK0NM001.XBCCD;
  PWSREC.XDMCD[1] = PK0NM001.XDMCD;
  PWSREC.SY1STNBR[1] = PK0NM001.SY1STNBR;
  PWSREC.SY2CLRID[1] = PK0NM001.SY2CLRID;

  PK0NS-CRTN-CALL(); /* Call PK4420 with PSWREC*/

  if (PK0NW01.PK0NWERR == "Y")
    PK0NM001.YNTDESC = " ";
    PK0NM001.XXXERRID = "PK0NS-CRTN-CONTROL";
    set PK0NM001.YNTCD cursor, bold;
    return;
  end

   /* get cartoon description from YNTTBL...*/

  if (PWSREC.YNTCD in YNTTBL.YNTCD /* if code is in the table*/
   && YNTTBL.XXXSTAT[sysVar.arrayIndex] == "A") /* and it is active*/
    PK0NM001.YNTCD = PWSREC.YNTCD;
    PK0NW02.YNTCD = YNTTBL.YNTCD[sysVar.arrayIndex];
    PK0NM001.YNTDESC = YNTTBL.YNTDESC[sysVar.arrayIndex];
  else
    PK0NM001.YNTCD = " ";
    PK0NM001.YNTDESC = " ";
    converseLib.validationFailed(209); /* invalid carton type code*/
    PK0NM001.XXXERRID = "PK0NS-CRTN-CONTROL";
    PK0NW01.PK0NWERR = "Y";
    set PK0NM001.YNTCD cursor, bold;
  end

end // end PK0NS-CRTN-CONTROL

// Update prepack - add
Function PK0NS-UPDATE-ADD()
   /* ***************************************** **/
   /* Update database with added orders       **/
   /* Coming from PK0N141                   **/
   /* ***************************************** **/

  PK0NM001.XXXERRID = "PK0NS-UPDATE-ADD";

   /* ****************************************** **/
   /* See if there are conflicting prepack types **/
   /* ****************************************** **/

  PK4REC.XWHCD = PK0NM001.XWHCD;
  PK4REC.PK1CUOID = PK0NM001.PK1CUOID; /* move key fields*/
  PK4REC.PK1NORID = PK0NM001.PK1NORID;

  PK0N910(); /* Select unique order header*/

  if (PK0NW01.PK0NWERR == "Y")
    return; /* Opps*/
  end

  if (PK0NW01.PK0NWPSS == "Y") /* pack by style orders*/
    if (PK4REC.XPACD != " ") /* is some other prepack record*/
      PK0NW01.PK0NWERR = "Y";
      VAGen_EZEMSG = "NOT ALLOWED WITH OTHER PREPACK CONFIGURATIONS";
      return;
    end

  else /* pack by data*/

    if (PK4REC.XPACD == " "
     || PK4REC.XPACD == "CU")
       /* next sentence*/
    else
      PK0NW01.PK0NWERR = "Y";
      VAGen_EZEMSG = "NOT ALLOWED WITH OTHER PREPACK CONFIGURATIONS";
      return;
    end
  end

   /* ***************************************** **/
   /* See if there is at least one prepack size **/
   /* ***************************************** **/

  if (PK0NW01.PK0NWPSS == "N") /* don't do pack by style orders*/
    PK0NS32(); /* check for a size to prepack*/
    if (PK0NW01.PK0NWERR == "Y")
      return; /* Opps, no sizes to prepack*/
    end

     /* ********************************************* **/
     /* move size data from the map to prepack record **/
     /* ********************************************* **/

    PK0NW01.PK0NWCT1 = 1;
    PK0NW01.PK0NWCT2 = 1;

    while (PK0NW01.PK0NWCT1 <= 19
     && PK0NW01.PK0NWCT2 <= 39
     && PK0NM001.SY4IDDSC[PK0NWCT1] != " ")

         /* looking for valid sizes*/

      while (PK0NW01.PK0NWCT1 <= 20
       && PK0NM001.SY4IDDSC[PK0NWCT1] != PK0NW02.SY4IDDSC[PK0NWCT2])
        PKTREC.PKTPPQTY[PK0NWCT2] = 0;
        PKTREC.PK1QTY[PK0NWCT2] = 0;
        PK0NW01.PK0NWCT2 = PK0NW01.PK0NWCT2 + 1;
      end

         /* found valid size*/

      if (PK0NM001.SY4IDDSC[PK0NWCT1] == PK0NW02.SY4IDDSC[PK0NWCT2])
        PKTREC.PKTPPQTY[PK0NWCT2] = PK0NM001.PKTPPQTY[PK0NWCT1];
        PKTREC.PK1QTY[PK0NWCT2] = PK0NM001.PK1QTY[PK0NWCT1];
        PK0NW02.PKTPPQTY[PK0NWCT2] = PK0NM001.PKTPPQTY[PK0NWCT1];
        PK0NW01.PK0NWCT2 = PK0NW01.PK0NWCT2 + 1;
      end

      PK0NW01.PK0NWCT1 = PK0NW01.PK0NWCT1 + 1;

    end

     /* ************************* **/
     /* validate carton type code **/
     /* ************************* **/

    PK0NS-CRTN-CONTROL(); /* Get carton type*/

    if (PK0NW01.PK0NWERR == "Y")
      return;
    end

    PKTREC.YNTCD = PK0NM001.YNTCD; /* finish moving key*/

  end /* pack by data not size*/

   /* ****************************************** **/
   /* validate prepak existance or non-existance **/
   /* ****************************************** **/

  PK0N931(); /* read unique prepak record*/

   /* see if record to be added already exists*/

  if (converseVar.validationMsgNum != 0)
    return;
  end
  if (SQLCA.VAGen_SQLCODE == 0)
    converseLib.validationFailed(44); /* record to be added already exists*/
    PK0NW01.PK0NWERR = "Y";
    PK0NW01.PK0NWBLS = "Y";
    set PK0NM001.PK1CUOID cursor, bold;
    set PK0NM001.PK1NORID bold;
    if (PKTREC.PKSSSZFL == " ")
      set PK0NM001.XGPCD bold;
      set PK0NM001.SY1STNBR bold;
      set PK0NM001.SY2CLRID bold;
      set PK0NM001.XDMCD bold;
    end
                                /* need to rebuild screen*/
    PK0NW01.PK0NWCT1 = 1;
    PK0NW01.PK0NWCT2 = 1;

    while (PK0NW01.PK0NWCT1 <= 40
     && PK0NW01.PK0NWCT2 <= 20)
      PK0N106();
      PK0NW01.PK0NWCT1 = PK0NWCT1 + 1;
    end

    PK0NS30(); /* rebuild remainders for new screen*/

    return;
  end

   /* ***************************************************** **/
   /* get the current date and time for the database update **/
   /* ***************************************************** **/

  set TA2REC empty;
  TA2REC.TA2DTOPT = "GETDATE";
  call "TA0040" (TA2REC) {isNoRefresh = yes, isExternal = yes};
  if (TA2REC.TA2RTNCD == 0)
    PKTREC.ZZZCHGTM = TA2REC.TA2TIMHM;
    PKTREC.ZZZCHGDT = TA2REC.TA2GRGGN;
    PKTREC.ZZZSDT = TA2REC.TA2GRGGN;
    PKTREC.ZZZCHGCT = PK0NW02.ZZZCHGCT;
  else
    converseLib.validationFailed(29); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    PK0NW01.PK0NWERR = "Y"; /* there was an error*/

    TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
    TA1REC.TA1PGMNM = "TA0040 "; /* Process name*/
    TA1REC.TA1LOC = "GETTING CURRENT DATE/TIME";
    TA1REC.TA1MAP = "PK0NM001"; /* Map name*/

    call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    PK0NM001.XXXERRID = "PK0N141 "; /* Error location*/
    return; /* Return to previous process*/

  end

   /* ***  move more fields to PKTREC  *** **/

  PKTREC.PKTNBRPP = PK0NM001.PKTNBRPP;
  PKTREC.PK1LNINB = PK0NW02.PK1LNINB;
  PKTREC.PKTBACTI = PK0NW01.PKTBACTI;
  PKTREC.XXXSTAT = "A"; /* set status active*/

  if (PK0NM001.PK0NMPBS == "Y")
    PKTREC.PKSSSZFL = "N";
  else
    if (PK0NM001.PK0NMPSS == "Y")
      PKTREC.PKSSSZFL = "Y";
    end
  end

   /* ****************************************** **/
   /* find correct temp storage record to update **/
   /* ****************************************** **/

  if (PK0NW01.PK0NWPSS == "Y") /* processing pack by data*/
       /* next sentence*/
  else
    PK0N962(); /* update prepack record*/
    if (TA5REC.TA5RTNCD == 7 /* eof - shouldn't be here*/
     || TA5REC.TA5RTNCD == 4) /* queue doesn't exist*/
      PK0NW01.PK0NMACT = " "; /* to reset first time thru flag*/
      return;
    else
      if (TA5REC.TA5RTNCD != 0)
        PK0N954(); /* delete temp storage*/
        return;
      end
    end
  end

  PKTREC.OSNPKGNB = PKTREC.PK1LNINB; /* osnpkgnb must be unique*/

   /* ******************************** **/
   /* PKTREC is ready to added at last **/
   /* ******************************** **/

  PK0N921(); /* add to prepack*/
  if (converseVar.validationMsgNum != 0)
    return;
  end

end // end PK0NS-UPDATE-ADD

// Prepack update - change
Function PK0NS-UPDATE-CHNG()
   /* ******************************************* **/
   /* Update database with changed orders       **/
   /* ******************************************* **/

  PK0NM001.XXXERRID = "PK0NS-UPDATE-CHNG";

   /* ***************************************** **/
   /* See if there is at least one prepack size **/
   /* ***************************************** **/

  if (PK0NW01.PK0NWPSS == "N") /* don't do pack by style orders*/
    PK0NS32(); /* check for a size to prepack*/
    if (PK0NW01.PK0NWERR == "Y")
      return; /* Opps, no sizes to prepack*/
    end
  end

   /* ********************************************* **/
   /* move size data from the map to prepack record **/
   /* ********************************************* **/

  PK0NW01.PK0NWCT1 = 1;
  PK0NW01.PK0NWCT2 = 1;

  while (PK0NW01.PK0NWCT1 <= 19
   && PK0NW01.PK0NWCT2 <= 39
   && PK0NM001.SY4IDDSC[PK0NWCT1] != " ")

       /* looking for valid sizes*/

    while (PK0NW01.PK0NWCT1 <= 20
     && PK0NM001.SY4IDDSC[PK0NWCT1] != PK0NW02.SY4IDDSC[PK0NWCT2])
      PKTREC.PKTPPQTY[PK0NWCT2] = 0;
      PKTREC.PK1QTY[PK0NWCT2] = 0;
      PK0NW01.PK0NWCT2 = PK0NW01.PK0NWCT2 + 1;
    end

       /* found valid size*/

    if (PK0NM001.SY4IDDSC[PK0NWCT1] == PK0NW02.SY4IDDSC[PK0NWCT2])
      PKTREC.PKTPPQTY[PK0NWCT2] = PK0NM001.PKTPPQTY[PK0NWCT1];
      PKTREC.PK1QTY[PK0NWCT2] = PK0NM001.PK1QTY[PK0NWCT1];
      PK0NW02.PKTPPQTY[PK0NWCT2] = PK0NM001.PKTPPQTY[PK0NWCT1];
      PK0NW01.PK0NWCT2 = PK0NW01.PK0NWCT2 + 1;
    end

    PK0NW01.PK0NWCT1 = PK0NW01.PK0NWCT1 + 1;

  end

   /* ************************* **/
   /* validate carton type code **/
   /* ************************* **/

  if (PK0NW01.PK0NWPSS == "Y") /* processing pack by data*/
       /* next sentence*/
  else
    PK0NS-CRTN-CONTROL(); /* Get carton type*/
    if (PK0NW01.PK0NWERR == "Y")
      return;
    end
  end

   /* ****************************************** **/
   /* validate prepak existance or non-existance **/
   /* ****************************************** **/

  PKTREC.YNTCD = PK0NM001.YNTCD; /* finish moving key*/

  PK0N931(); /* read unique prepak record*/

  if (converseVar.validationMsgNum != 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == 100)
    converseLib.validationFailed(211); /* record to be updated not found*/
    PK0NW01.PK0NWERR = "Y";
    set PK0NM001.PK1CUOID cursor, bold;
    set PK0NM001.PK1NORID bold;
    if (PKTREC.PKSSSZFL == " ")
      set PK0NM001.XGPCD bold;
      set PK0NM001.SY1STNBR bold;
      set PK0NM001.SY2CLRID bold;
      set PK0NM001.XDMCD bold;
    end
    return;
  end

   /* ***************************************************** **/
   /* get the current date and time for the database update **/
   /* ***************************************************** **/

  set TA2REC empty;
  TA2REC.TA2DTOPT = "GETDATE";
  call "TA0040" (TA2REC) {isNoRefresh = yes, isExternal = yes};
  if (TA2REC.TA2RTNCD == 0)
    PKTREC.ZZZCHGTM = TA2REC.TA2TIMHM;
    PKTREC.ZZZCHGDT = TA2REC.TA2GRGGN;
  else
    converseLib.validationFailed(29); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    PK0NW01.PK0NWERR = "Y"; /* there was an error*/

    TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
    TA1REC.TA1PGMNM = "TA0040 "; /* Process name*/
    TA1REC.TA1LOC = "GETTING CURRENT DATE/TIME";
    TA1REC.TA1MAP = "PK0NM001"; /* Map name*/

    call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    PK0NM001.XXXERRID = "PK0N141 "; /* Error location*/
    return; /* Return to previous process*/

  end

   /* ***  move more fields to PKTREC  *** **/

  PKTREC.PKTNBRPP = PK0NM001.PKTNBRPP;
  PKTREC.PK1LNINB = PK0NW02.PK1LNINB;
  PKTREC.PKTBACTI = PK0NW01.PKTBACTI;
  PKTREC.XXXSTAT = "A"; /* set status active*/

  if (PK0NM001.PK0NMPBS == "Y")
    PKTREC.PKSSSZFL = "N";
  else
    if (PK0NM001.PK0NMPSS == "Y")
      PKTREC.PKSSSZFL = "Y";
    end
  end

   /* ****************************************** **/
   /* find correct temp storage record to update **/
   /* ****************************************** **/

  if (PK0NW01.PK0NWPSS == "Y") /* processing pack by data*/
       /* next sentence*/
  else
    PK0N962(); /* update prepack record*/
    if (TA5REC.TA5RTNCD == 7 /* eof - shouldn't be here*/
     || TA5REC.TA5RTNCD == 4) /* queue doesn't exist*/
      PK0NW01.PK0NMACT = " "; /* to reset first time thru flag*/
      return;
    else
      if (TA5REC.TA5RTNCD != 0)
        PK0N954(); /* delete temp storage*/
        return;
      end
    end
  end

  PKTREC.OSNPKGNB = PKTREC.PK1LNINB; /* osnpkgnb must be unique*/

   /* ******************************** **/
   /* PKTREC is ready to be updated    **/
   /* ******************************** **/

  PK0N936(); /* update prepack*/
  if (converseVar.validationMsgNum != 0)
    return;
  end

end // end PK0NS-UPDATE-CHNG

// update XPA and QTY's
Function PK0NS-XPA-AND-QTY()
   /* ****************************************************** **/
   /* update pool header and item to reflect prepack changes **/
   /* ****************************************************** **/

  PK0NM001.XXXERRID = "PK0NS-XPA-AND-QTY";

   /* **************************************/
   /* Do XPA_CUST_PACK_CD changes.*/
   /* **************************************/

  if (PK0NM001.PK0NMACT == "D")

     /* only update xpa and qty's if no*/
     /* prepack items remain for order*/

    PK0N928(); /* open prepack set*/
    if (PK0NW01.PK0NWERR == "Y")
      return;
    end

    PK0N929(); /* get prepack*/
    if (SQLCA.VAGen_SQLCODE == 100) /* are no prepack records*/
      PK0NW01.XPACD = "  "; /* set XPA_CUST_PACK_CD*/
    else
      PK0N930(); /* close prepack*/
      return; /* no changes needed here*/
    end

    PK0N930(); /* close prepack*/
    if (PK0NW01.PK0NWERR == "Y")
      return;
    end
  end

   /* handle adds and changes*/

  if (PK0NM001.PK0NMACT == "A"
   || PK0NM001.PK0NMACT == "C")
    if (PK0NW01.PK0NWPRD == "Y") /* product info specified*/
      PK0NW01.XPACD = "CU"; /* set XPA_CUST_PACK_CD*/
    else
      if (PK0NM001.PK0NMPBS == "Y") /* pack by style*/
        PK0NW01.XPACD = "PR"; /* set XPA_CUST_PACK_CD*/
      else
        if (PK0NM001.PK0NMPSS == "Y") /* pack by style/size*/
          PK0NW01.XPACD = "SK"; /* set XPA_CUST_PACK_CD*/
        end
      end
    end
  end
  PK4REC.XWHCD = PK0NM001.XWHCD; /* set key field*/
  PK4REC.PK1CUOID = PK0NM001.PK1CUOID; /* set key field*/
  PK4REC.PK1NORID = PK0NM001.PK1NORID; /* set key field*/

  PK0N150(); /* update VPOOLH01*/

  if (PK0NW01.PK0NWERR == "Y")
    return;
  else
    if (PK0NM001.PK0NMACT != "C") /* Only adds or deletes,*/

      PK5REC.XWHCD = PK0NM001.XWHCD; /* set key field*/
      PK5REC.PK1PRTN = PKTREC.PK1PRTN; /* set key field*/
      PK5REC.PK1CUOID = PK0NM001.PK1CUOID; /* set key field*/
      PK5REC.PK1NORID = PK0NM001.PK1NORID; /* set key field*/

      PK0N151(); /* update pool quantity's,*/
    end /* both header and items.*/
  end

end // end PK0NS-XPA-AND-QTY

// page backward
Function PK0NS07()
   /* ************************************************************/
   /* *    this process handles the entry of pf key 7           **/
   /* *             (paging backward)                           **/
   /* ************************************************************/

  if (PK0NW01.PK0NWCP2 <= 1) /* ; if current page for prepack array le 1*/
    converseLib.validationFailed(37); /* no previous page to display*/
    PK0NW01.PK0NWCP2 = 1;
  else
    PK0NW01.PK0NWCP2 = PK0NW01.PK0NWCP2 - 1;
  end

  PK0NW01.PK0NWBLS = "Y";
   /* need to rebuild screen to show new data*/
  PK0NW01.PK0NWBLA = "N";
   /* don't need to rebuild array, already have data*/

end // end PK0NS07

// page forward
Function PK0NS08()
   /* ************************************************************/
   /* *   this process handles the entry of pf key 8            **/
   /* *                                                         **/
   /* ************************************************************/

  PK0NW01.PK0NWCP2 = PK0NW01.PK0NWCP2 + 1; /* current page*/

  PK0NW01.PK0NWBLS = "Y";
   /* need to rebuild screen to show new data*/
  PK0NW01.PK0NWBLA = "N";
   /* don't need to rebuild array, already have data*/

  if (PK0NW01.PK0NWCP2 > PK0NW01.PK0NWLP2)
    PK0NW01.PK0NWCP2 = PK0NW01.PK0NWCP2 - 1; /* current page*/
    converseLib.validationFailed(38); /* no more pages to display*/
    return;
  end
end // end PK0NS08

// calculate remaining quantities
Function PK0NS30()
   /* ************************************************************/
   /* *    this process calculates remaining quantities.        **/
   /* *    after the user has entered qtys then the pgm will have*/
   /* *    to calculate the number of prepacks that the allocated*/
   /* *    qty for the size and the user entered qty will allow.*/
   /* ************************************************************/

   /* make sure there is data on screen*/

  if (PK0NM001.PK1QTY[1] == 0)
    return; /* no values on screen*/
  end

  PK0NW01.PKTNBRPP = 999999999;

    /* get number of prepack products*/

  PK0NW01.PK0NWCT3 = 1;

  while (PK0NW01.PK0NWCT3 <= 20)
    if (PK0NM001.PKTPPQTY[PK0NWCT3] != 0) /* while prepack qtys*/

      PK0NW01.PK0NWHD1 = PK0NM001.PK1QTY[PK0NWCT3];
      PK0NW01.PK0NWTOT = PK0NW01.PK0NWHD1 / PK0NM001.PKTPPQTY[PK0NWCT3];

      if (PK0NW01.PK0NWTOT < PK0NW01.PKTNBRPP)
        PK0NW01.PKTNBRPP = PK0NW01.PK0NWTOT;
      end
    end
    PK0NW01.PK0NWCT3 = PK0NW01.PK0NWCT3 + 1;
  end

   /* If no prepacks, no remainder*/

  if (PK0NW01.PKTNBRPP == 999999999)
    return;
  end

   /* take the lowest of the results. this is the number of*/
   /* prepacks. this figure should be displayed on the*/
   /* screen under 'total prepacks'*/

  PK0NM001.PKTNBRPP = PK0NW01.PKTNBRPP;

   /* to get the remaining qtys which also are to be displayed*/
   /* back to the user in the 'rem' line on the screen beneath*/
   /* the appropriate sizes:*/
     /* rem = aloc qty - (user entered qty x nbr of prepacks)*/

  PK0NW01.PK0NWCT3 = 1;
  PK0NM001.PK0NMTRM[1] = 0;
  PK0NM001.PK0NMTRM[2] = 0;

  while (PK0NW01.PK0NWCT3 <= 10)

    PK0NW01.PK0NWHD1 = 0;
    PK0NW01.PK0NWHD2 = 0;
    PK0NW01.PK0NWHD1 = PK0NM001.PKTPPQTY[PK0NWCT3] * PK0NW01.PKTNBRPP;
    PK0NW01.PK0NWHD2 = PK0NM001.PK1QTY[PK0NWCT3] - PK0NW01.PK0NWHD1;
    PK0NM001.PK0NMREM[PK0NWCT3] = PK0NW01.PK0NWHD2;

    PK0NM001.PK0NMTRM[1] = PK0NM001.PK0NMTRM[1] +     PK0NM001.PK0NMREM[PK0NWCT3];
    PK0NW01.PK0NWCT3 = PK0NW01.PK0NWCT3 + 1;

  end

  while (PK0NW01.PK0NWCT3 <= 20
   && PK0NM001.PKTPPQTY[PK0NWCT3] != 0)

    PK0NW01.PK0NWHD1 = 0;
    PK0NW01.PK0NWHD2 = 0;
    PK0NW01.PK0NWHD1 = PK0NM001.PKTPPQTY[PK0NWCT3] * PK0NW01.PKTNBRPP;
    PK0NW01.PK0NWHD2 = PK0NM001.PK1QTY[PK0NWCT3] - PK0NW01.PK0NWHD1;
    PK0NM001.PK0NMREM[PK0NWCT3] = PK0NW01.PK0NWHD2;

    PK0NM001.PK0NMTRM[2] = PK0NM001.PK0NMTRM[2] +     PK0NM001.PK0NMREM[PK0NWCT3];
    PK0NW01.PK0NWCT3 = PK0NW01.PK0NWCT3 + 1;

  end
end // end PK0NS30

// convert extnl size to internal
Function PK0NS31()
   /* ************************************************************/
   /* *    this process converts external sizes to internal     **/
   /* *    sizes using sy1190*/
   /* ************************************************************/

  PK0NM001.XXXERRID = "PK0NS31";

   /* SET SYPREC EMPTY - done in calling procedure ;*/

  SYPREC.SYPFC = "EI"; /* product code*/
  SYPREC.SYPCMPSW = "C"; /* compressed data*/
  SYPREC.XGPCD = PK0NM001.XGPCD;
  SYPREC.SY1STNBR = PK0NM001.SY1STNBR;
  SYPREC.SY2CLRID = PK0NM001.SY2CLRID;
  SYPREC.XDMCD = PK0NM001.XDMCD;
  SYPREC.XQACD = "**";
  if (PK0NM001.PK0NMSTR > " ")
    SYPREC.SY4IDDSC[1] = PK0NM001.PK0NMSTR;
  end

  if (PK0NM001.PK0NMEND > " ")
    SYPREC.SY4IDDSC[2] = PK0NM001.PK0NMEND;
  end

  PK0N915(); /* convert sizes using sy1190*/
  if (converseVar.validationMsgNum != 0)
    return;
  end

   /* ending size must be greater than or equal to starting size*/

  if (PK0NM001.PK0NMEND != " ")
    if (SYPREC.SY5SZID[2] >= SYPREC.SY5SZID[1])
       /* next sentence*/
    else
      converseLib.validationFailed(197); /* end size must be >= start size*/
      set PK0NM001.PK0NMSTR cursor, bold;
      set PK0NM001.PK0NMEND bold;
      PK0NW01.PK0NWERR = "Y";
      return;
    end
  end

   /* show message if size isn't valid*/

  if (SYPREC.SYPSZRC[1] != 0
   && SYPREC.SYPSZRC[2] != 0)
    converseLib.validationFailed(187); /* start/end size does not exist for this prd*/
    PK0NW01.PK0NWERR = "Y";
    set PK0NM001.PK0NMSTR cursor, bold;
    set PK0NM001.PK0NMEND bold;
    return;
  else
    if (SYPREC.SYPSZRC[1] != 0)
      converseLib.validationFailed(188); /* starting size does not exist for this prd*/
      PK0NW01.PK0NWERR = "Y";
      set PK0NM001.PK0NMSTR cursor, bold;
      return;
    else
      if (SYPREC.SYPSZRC[2] != 0)
        converseLib.validationFailed(189); /* ending size does not exist for this prd*/
        PK0NW01.PK0NWERR = "Y";
        set PK0NM001.PK0NMEND cursor, bold;
        return;
      else
      end
    end
  end
end // end PK0NS31

// check all flags in array
Function PK0NS32()
   /* ******************************************************/
   /* check flag array for one item minimum*/
   /* ******************************************************/

  PK0NM001.XXXERRID = "PK0NS32";

  if (PK0NM001.PK0NMRJT == "Y")
    return; /* return pk0nwrhy equal to yes*/
  end

  PK0NW01.PK0NWRHY = "N"; /* init all records have yes flag*/

   /* hold current place in array incase all records have been*/
   /* completed*/

  PK0NW01.PK0NWHD1 = PK0NW01.PK0NWCP1;
  PK0NW01.PK0NWCP1 = 1; /* current page*/

  PK0N963(); /* read temp storage page*/
  if (TA5REC.TA5RTNCD == 7) /* end of file*/
    return; /* NOTHING ELSE TO BE DONE HERE*/
  end
  if (TA5REC.TA5RTNCD != 0)
    PK0N954(); /* set temp storage empty*/
    return;
  end

   /* ************************************************* **/
   /* make sure that we have correct record to start at **/
   /* ************************************************* **/

  while (PK0NM001.XGPCD != PK0NW02.XGPCD
   || PK0NM001.SY1STNBR != PK0NW02.SY1STNBR
   || PK0NM001.SY2CLRID != PK0NW02.SY2CLRID
   || PK0NM001.XDMCD != PK0NW02.XDMCD)

    PK0NW01.PK0NWCP1 = PK0NW01.PK0NWCP1 + 1;
    PK0N963(); /* read temp storage page*/
    if (TA5REC.TA5RTNCD == 7) /* end of file*/
      return; /* NOTHING ELSE TO BE DONE HERE*/
    end
    if (TA5REC.TA5RTNCD != 0)
      PK0N954(); /* set temp storage empty*/
      return;
    end
  end

     /* now have correct record*/

  PK0NW01.PK0NWCT1 = 1;
  while (PK0NW01.PK0NWCT1 <= 40
   && PK0NW01.PK0NWRHY != "Y")
    if (PK0NW03.PK1QTY[PK0NWCT1] != 0) /* if valid size*/
      if (PK0NW03.PK0NWSDN[PK0NWCT1] == "Y") /* and it contains prepack qty*/
        PK0NW01.PK0NWRHY = "Y"; /* can make prepack*/
      end
    end
    PK0NW01.PK0NWCT1 = PK0NW01.PK0NWCT1 + 1;
  end

   /* if have searched thru all sizes and found*/
   /* no quantities then bomb*/

  if (PK0NW01.PK0NWRHY == "N"
   && PK0NW01.PK0NWCT1 >= 40)
    converseLib.validationFailed(243);
    PK0NW01.PK0NWERR = "Y";
  end

end // end PK0NS32

// protect fields first time thru
Function PK0NS40()
   /* ***********************************************************/
   /* *  set fields protected for customer data*/
   /* ***********************************************************/

  PK0NM001.XXXERRID = "PK0NS40";

  if (PK0NW01.PK0NWERR == "Y")
    return;
  end

   /* set non-usable fields protected*/

  if (PK0NM001.PKTNBRPP != 0)
    PK0NW01.PK0NWERR = "Y";
    set PK0NM001.PKTNBRPP cursor, bold;
  end

  if (PK0NM001.PK0NMEND != " ")
    set PK0NM001.PK0NMEND cursor, bold;
    PK0NW01.PK0NWERR = "Y";
  end

  if (PK0NM001.PK0NMSTR != " ")
    set PK0NM001.PK0NMSTR cursor, bold;
    PK0NW01.PK0NWERR = "Y";
  end

  if (PK0NM001.YNTCD != " ")
    PK0NW01.PK0NWERR = "Y";
    set PK0NM001.YNTCD cursor, bold;
  end

  if (PK0NM001.PK1CUOID != 0
   || PK0NM001.PK1NORID != 0)
    set PK0NM001.PK1CUOID cursor, bold;
    set PK0NM001.PK1NORID bold;
    PK0NW01.PK0NWERR = "Y";
  end

  if (PK0NM001.PK0NMRJT != " ")
    PK0NW01.PK0NWERR = "Y";
    set PK0NM001.PK0NMRJT cursor, bold;
  end

  if (PK0NM001.XGPCD != " "
   || PK0NM001.SY1STNBR != " "
   || PK0NM001.SY2CLRID != " "
   || PK0NM001.XDMCD != " ")
    PK0NW01.PK0NWERR = "Y";
    set PK0NM001.XGPCD cursor, bold;
    set PK0NM001.SY1STNBR bold;
    set PK0NM001.SY2CLRID bold;
    set PK0NM001.XDMCD bold;
  end

  PK0NW01.PK0NWCT1 = 1;
  while (PK0NW01.PK0NWCT1 <= 20)
    if (PK0NM001.PKTPPQTY[PK0NWCT1] != 0)
      PK0NW01.PK0NWERR = "Y";
      set PK0NM001.PKTPPQTY[PK0NWCT1] bold;
    end
    PK0NW01.PK0NWCT1 = PK0NW01.PK0NWCT1 + 1;
  end

   /* if any errors, show them to user, before protecting fields*/

  if (PK0NW01.PK0NWERR == "Y")
    converseLib.validationFailed(183); /* fields not allowed with cust data*/
    return;
  end

  set PK0NM001.PK0NMACT cursor;
  set PK0NM001.PKTNBRPP protect;
  set PK0NM001.PK0NMSTR protect;
  set PK0NM001.PK0NMEND protect;
  set PK0NM001.YNTCD protect;
  set PK0NM001.XGPCD protect;
  set PK0NM001.SY1STNBR protect;
  set PK0NM001.SY2CLRID protect;
  set PK0NM001.XDMCD protect;
  set PK0NM001.PK1CUOID protect;
  set PK0NM001.PK1NORID protect;
  set PK0NM001.PK0NMRJT protect;

  PK0NW01.PK0NWCT1 = 1;
  while (PK0NW01.PK0NWCT1 <= 20)
    set PK0NM001.PKTPPQTY[PK0NWCT1] protect;
    PK0NW01.PK0NWCT1 = PK0NW01.PK0NWCT1 + 1;
  end
end // end PK0NS40

// unprotect fields for db update
Function PK0NS41()
   /* ***********************************************************/
   /* *  unprotect fields for database updates with order data*/
   /* ***********************************************************/

   /* set customer number fields protected*/

  set PK0NM001.KUCCOID protect;
  set PK0NM001.KUMSTRID protect;
  set PK0NM001.XNXCD protect;

  if (PK0NW01.PK0NWERR == "Y")
    return; /* don't want to change fields*/
  end

   /* move cursor*/

  if (PK0NM001.PK0NMACT == " "
   || PK0NM001.PK0NMACT == "D")
    set PK0NM001.PK0NMACT cursor;
  else
    set PK0NM001.PKTPPQTY[1] cursor;
  end

    /* if 'rejected all', need to change some field so pk0n122*/
    /* will think this is first time thru*/

   /* IF PK0NM001.PK0NMACT = 'D';*/
    /* AND PK0NM001.PK0NMRJT = 'Y';*/
    /* MOVE 'A' TO PK0NW01.PK0NMACT;*/
   /* END ;*/

  if (PK0NM001.PK0NMACT != "A")
    PK0NM001.PK0NMACT = " "; /* blank out action field*/
    PK0NM001.PK0NMRJT = " "; /* blank out reject all field*/
  end

   /* if entering either pack by flags cant enter much else*/

  if (PK0NM001.PK0NMPBS == "Y"
   || PK0NM001.PK0NMPSS == "Y")

    set PK0NM001.PKTNBRPP protect;
    set PK0NM001.PK0NMSTR protect;
    set PK0NM001.PK0NMEND protect;
    set PK0NM001.YNTCD protect;
    set PK0NM001.XGPCD protect;
    set PK0NM001.SY1STNBR protect;
    set PK0NM001.SY2CLRID protect;
    set PK0NM001.XDMCD protect;

    PK0NW01.PK0NWCT1 = 1;
    while (PK0NW01.PK0NWCT1 <= 20)
      set PK0NM001.PKTPPQTY[PK0NWCT1] protect;
      PK0NW01.PK0NWCT1 = PK0NW01.PK0NWCT1 + 1;
    end
  end
end // end PK0NS41

// clear detail lines
Function PK0NS50()
   /* ***********************************************************/
   /* *  clear detail lines*/
   /* ***********************************************************/

  PK0NM001.PKTNBRPP = 0;
  PK0NM001.PK0NMPBS = " ";
  PK0NM001.PK0NMPSS = " ";
  PK0NM001.SY1SSTNM = " ";
  PK0NM001.YNTCD = " ";
  PK0NM001.YNTDESC = " ";
  PK0NM001.PK0NMSTR = " ";
  PK0NM001.PK0NMEND = " ";
  PK0NM001.PK0NMTRM[1] = 0;
  PK0NM001.PK0NMTRM[2] = 0;
  PK0NW01.PK0NWCT1 = 1;

  while (PK0NW01.PK0NWCT1 <= 20)
    PK0NM001.SY4IDDSC[PK0NWCT1] = " ";
    PK0NM001.PKTPPQTY[PK0NWCT1] = 0;
    PK0NM001.PK0NMREM[PK0NWCT1] = 0;
    PK0NM001.PK1QTY[PK0NWCT1] = 0;

    PK0NW01.PK0NWCT1 = PK0NW01.PK0NWCT1 + 1;

  end
end // end PK0NS50

// clear detail lines
Function PK0NS51()
   /* ***********************************************************/
   /* *  clear detail lines*/
   /* ***********************************************************/

  PK0NM001.PKTNBRPP = 0;
  PK0NM001.PK0NMPBS = " ";
  PK0NM001.PK0NMPSS = " ";
  PK0NM001.YNTCD = " ";
  PK0NM001.YNTDESC = " ";
  PK0NM001.PK0NMTRM[1] = 0;
  PK0NM001.PK0NMTRM[2] = 0;
  PK0NW01.PK0NWCT1 = 1;

  while (PK0NW01.PK0NWCT1 <= 20)
    PK0NM001.SY4IDDSC[PK0NWCT1] = " ";
    PK0NM001.PKTPPQTY[PK0NWCT1] = 0;
    PK0NM001.PK0NMREM[PK0NWCT1] = 0;
    PK0NM001.PK1QTY[PK0NWCT1] = 0;

    PK0NW01.PK0NWCT1 = PK0NW01.PK0NWCT1 + 1;

  end
end // end PK0NS51

// clear detail lines
Function PK0NS52()
   /* ***********************************************************/
   /* *  clear detail lines*/
   /* ***********************************************************/

  PK0NM001.PKTNBRPP = 0;
  PK0NM001.PK0NMPBS = " ";
  PK0NM001.PK0NMPSS = " ";
  PK0NM001.YNTCD = " ";
  PK0NM001.YNTDESC = " ";
  PK0NM001.PK0NMTRM[1] = 0;
  PK0NM001.PK0NMTRM[2] = 0;
  PK0NW01.PK0NWCT1 = 1;

  while (PK0NW01.PK0NWCT1 <= 20)
    PK0NM001.PKTPPQTY[PK0NWCT1] = 0;
    PK0NM001.PK0NMREM[PK0NWCT1] = 0;
    PK0NW02.PKTPPQTY[PK0NWCT1] = 0;
    PK0NW02.PK0NMREM[PK0NWCT1] = 0;

    PK0NW01.PK0NWCT1 = PK0NW01.PK0NWCT1 + 1;

  end
end // end PK0NS52

// clear detail lines
Function PK0NS53()
   /* ***********************************************************/
   /* *  clear detail lines*/
   /* ***********************************************************/

  PK0NM001.PKTNBRPP = 0;
  PK0NM001.PK0NMRJT = " ";
  PK0NM001.PK0NMPBS = " ";
  PK0NM001.PK0NMPSS = " ";
  PK0NM001.XGPCD = " ";
  PK0NM001.SY1STNBR = " ";
  PK0NM001.SY2CLRID = " ";
  PK0NM001.XDMCD = " ";
  PK0NM001.SY1SSTNM = " ";
  PK0NM001.YNTCD = " ";
  PK0NM001.YNTDESC = " ";
  PK0NM001.PK0NMSTR = " ";
  PK0NM001.PK0NMEND = " ";
  PK0NM001.PK0NMTRM[1] = 0;
  PK0NM001.PK0NMTRM[2] = 0;
  PK0NW01.PK0NWCT1 = 1;

  while (PK0NW01.PK0NWCT1 <= 20)
    PK0NM001.SY4IDDSC[PK0NWCT1] = " ";
    PK0NM001.PKTPPQTY[PK0NWCT1] = 0;
    PK0NM001.PK0NMREM[PK0NWCT1] = 0;
    PK0NM001.PK1QTY[PK0NWCT1] = 0;

    PK0NW01.PK0NWCT1 = PK0NW01.PK0NWCT1 + 1;

  end
end // end PK0NS53

// store temp storage
Function PK0NS60()
   /* ***********************************************************/
   /* *  store temp storage record*/
   /* ***********************************************************/

   /* need to increment page number*/

  PK0NW01.PK0NWLP2 = PK0NW01.PK0NWLP2 + 1;
  PK0N961(); /* add page to temp storage*/
  if (PK0NW01.PK0NWERR == "Y")
    PK0NW01.PK0NWLP2 = PK0NW01.PK0NWLP2 - 1;
  end
end // end PK0NS60

// show error message
Function PK0NS61()
   /* ***********************************************************/
   /* *  if not all of order has been completed, then show*/
   /* *  error message*/
   /* ***********************************************************/

  if (PK0NW02.PK0NWRER > 0) /* if the record has an error*/
    if (PK0NW02.PK0NWRER == 1)
      converseLib.validationFailed(256); /* prd no longer on order*/
      PK0NM001.PK0NMACT = "D";
    else
      if (PK0NW02.PK0NWRER == 4)
        converseLib.validationFailed(259); /* sizes on order have changed*/
        PK0NM001.PK0NMACT = "A";
      else
        if (PK0NW02.PK0NWRER == 5)
          converseLib.validationFailed(243); /* cannot exit until all prds have qty*/
          PK0NM001.PK0NMACT = "A";
        end
      end
    end
  end
end // end PK0NS61

// create array for prepack recs
Function PK0NS62()
   /* ***********************************************************/
   /* *  move all sizes that were put into prepack array into*/
   /* *  holding area to compare to later*/
   /* ***********************************************************/

  PK0NW01.PK0NWCT1 = 1;
  while (PK0NW01.PK0NWCT1 <= 40)
    if (PK0NW02.PKTPPQTY[PK0NWCT1] > 0)
      PK0NW04.PK1QTY[PK0NWCT1] = PK0NW02.PKTPPQTY[PK0NWCT1];
      PK0NW04.PK0NWSDN[PK0NWCT1] = "Y";
    end
    PK0NW01.PK0NWCT1 = PK0NW01.PK0NWCT1 + 1;
  end
end // end PK0NS62

// check for larger sizes
Function PK0NS63()
   /* ***********************************************************/
   /* *  check all sizes in prepack array to see if larger size*/
   /* *  found in pk0n165 already is part of prepack array*/
   /* ***********************************************************/

  PK0NW01.PK0NWCT1 = PK0NW01.PK0NWCT3;

  while (PK0NW01.PK0NWCT1 <= 39
   && PK0NW04.PK0NWSDN[PK0NWCT1] == "Y")

     /* see if the size is already in prepack array*/

    if (PK5REC.PK1QTY[PK0NWCT3] > 0
     && PK0NW04.PK0NWSDN[PK0NWCT1] == "Y")
      PK0NW01.PK0NWCT1 = PK0NW01.PK0NWCT1 + 1;
    end

     /* find next valid size on pool detail*/

    if (PK5REC.PK1QTY[PK0NWCT1] == 0)
      while (PK0NW01.PK0NWCT1 <= 39
       && PK5REC.PK1QTY[PK0NWCT1] == 0)
        PK0NW01.PK0NWCT1 = PK0NW01.PK0NWCT1 + 1;
      end
    end
  end

  PK0NW01.PK0NWCT3 = PK0NW01.PK0NWCT1;
end // end PK0NS63

// where to poisition pointer
Function PK0NS64()
   /* ***********************************************************/
   /* *  find first non covered size to start looking for prepacks*/
   /* ***********************************************************/

  PK0NW01.PK0NWCT1 = PK0NW02.PKTBACTI;

  while (PK0NW01.PK0NWCT1 <= 40
   && PK0NW04.PK0NWSDN[PK0NWCT1] == "Y")
    PK0NW01.PK0NWCT1 = PK0NW01.PK0NWCT1 + 1;
  end

  PK0NW01.PK0NWCT3 = PK0NW01.PK0NWCT1;
end // end PK0NS64

//*** RECORD=PK0NW01 ****
// flags and such used in the program
// ***********************
Record PK0NW01 type basicRecord
  10 PK0NWCT1 PK0NWCT1 ; 
  10 PK0NWCT2 PK0NWCT2 ; 
  10 PK0NWCT3 PK0NWCT3 ; 
  10 PK0NWCT4 PK0NWCT4 ; 
  10 XWHCD XWHCD ; 
  10 XWHABRV XWHABRV ; 
  10 XBCCD XBCCD ; 
  10 XBCABRV XBCABRV ; 
  10 PK1CUOID PK1CUOID ; 
  10 PK0NWCUI PK0NWCUI ; 
    15 * char(7) ; 
    15 PK1PRTN PK1PRTN ; 
  10 PK1NORID PK1NORID ; 
  10 KUCCOID KUCCOID ; 
  10 KUMSTRID KUMSTRID ; 
  10 XNXCD XNXCD ; 
  10 PKCCRTCL PKCCRTCL ; 
  10 XGPCD XGPCD ; 
  10 SY1STNBR SY1STNBR ; 
  10 SY2CLRID SY2CLRID ; 
  10 XDMCD XDMCD ; 
  10 XPACD XPACD ; 
  10 YNTCD YNTCD ; 
  10 YNTDESC YNTDESC ; 
  10 VAGen_SQLCODE VAGen_SQLCODE ; 
  10 PKTBACTI PKTBACTI ; 
  10 PK0NWEND PK0NWEND ; 
  10 PK0NWIED PK0NWIED ; 
  10 PK0NWIST PK0NWIST ; 
  10 PK0NMSTR PK0NMSTR ; 
  10 PK0NMEND PK0NMEND ; 
  10 PK0NWTYP PK0NWTYP ; 
  10 PK0NWPRD PK0NWPRD ; 
  10 PK0NWUTS PK0NWUTS ; 
  10 PK0NWTSP PK0NWTSP ; 
  10 PK0NWRHY PK0NWRHY ; 
  10 PK0NWSRS PK0NWSRS ; 
  10 PK0NWSNR PK0NWSNR ; 
  10 PK0NMACT PK0NMACT ; 
  10 PK0NMRJT PK0NMRJT ; 
  10 PK0NWFST PK0NWFST ; 
  10 PK0NWPSS PK0NWPSS ; 
  10 PK0NWEOA PK0NWEOA ; 
  10 PK0NWEOS PK0NWEOS ; 
  10 PK0NWERR PK0NWERR ; 
  10 PK0NWUPD PK0NWUPD ; 
  10 PK0NWBEG PK0NWBEG ; 
  10 PK0NWHD1 PK0NWHD1 ; 
  10 PK0NWHD2 PK0NWHD2 ; 
  10 PK0NWCRD PK0NWCRD ; 
  10 PKTNBRPP PKTNBRPP ; 
  10 PK0NWTOT PK0NWTOT ; 
  10 PK0NWANO PK0NWANO ; 
  10 PK0NWONP PK0NWONP ; 
  10 PK0NWLP1 PK0NWLP1 ; 
  10 PK0NWLP2 PK0NWLP2 ; 
  10 PK0NWCP1 PK0NWCP1 ; 
  10 PK0NWCP2 PK0NWCP2 ; 
  10 PK0NWBLS PK0NWBLS ; 
  10 PK0NWBLA PK0NWBLA ; 
  10 PK0NW-ITM-REPK-QTY PK0NW-ITM-REPK-QTY ; 
  10 PK0NW-ITM-FUL-CS-QTY PK0NW-ITM-FUL-CS-QTY ; 
  10 PK0NW-ORD-REPK-QTY PK0NW-ORD-REPK-QTY ; 
  10 PK0NW-ORD-FUL-CS-QTY PK0NW-ORD-FUL-CS-QTY ; 
  10 PK0NW-POOL-CHANGE PK0NW-POOL-CHANGE ; 
end // end PK0NW01

//*** RECORD=PK0NW02 ****
// array used for temp storage to hold order prepack records
// ***********************
Record PK0NW02 type basicRecord
  5 PK0NW2GR PK0NW2GR ; 
    10 PK0NWLEN PK0NWLEN ; 
    10 PK0NW2KY PK0NW2KY ; 
      15 XWHCD XWHCD ; 
      15 PK1PRTN PK1PRTN ; 
      15 PK1CUOID PK1CUOID ; 
      15 PK1NORID PK1NORID ; 
    10 XGPCD XGPCD ; 
    10 SY1STNBR SY1STNBR ; 
    10 SY2CLRID SY2CLRID ; 
    10 XDMCD XDMCD ; 
    10 SY1SSTNM SY1SSTNM ; 
    10 YNTCD YNTCD ; 
    10 PKTBACTI PKTBACTI ; 
    10 PK0NMSTR PK0NMSTR ; 
    10 PK0NMEND PK0NMEND ; 
    10 PKSSSZFL PKSSSZFL ; 
    10 PKTNBRPP PKTNBRPP ; 
    10 PK1LNINB PK1LNINB ; 
    10 PK0NWRER PK0NWRER ; 
    10 PK0NW2SZ PK0NW2SZ [40] ; 
      15 PKTPPQTY PKTPPQTY ; 
      15 PK1QTY PK1QTY ; 
      15 PK0NWQTE PK0NWQTE ; 
      15 PK0NMREM PK0NMREM ; 
      15 SY4IDDSC SY4IDDSC ; 
      15 SY5SZID SY5SZID ; 
    10 ZZZSDT ZZZSDT ; 
    10 ZZZCHGDT ZZZCHGDT ; 
    10 ZZZCHGTM ZZZCHGTM ; 
    10 ZZZCHGCT ZZZCHGCT ; 
end // end PK0NW02

//*** RECORD=PK0NW03 ****
// array used in temp storage for holding value of flags
// when adding a prepack record.
// when each size from the order has shown to exist on
// prepack, a size done flag is set to 'y'. all sizes must
// be done before a use can change the order data.
// ***********************
Record PK0NW03 type basicRecord
  5 PK0NW3GR PK0NW3GR ; 
    10 PK0NWLEN PK0NWLEN ; 
    10 XWHCD XWHCD ; 
    10 PK1PRTN PK1PRTN ; 
    10 PK1CUOID PK1CUOID ; 
    10 PK1NORID PK1NORID ; 
    10 PK0NW3KY PK0NW3KY ; 
      15 PK0NWPDN PK0NWPDN ; 
      15 XGPCD XGPCD ; 
      15 SY1STNBR SY1STNBR ; 
      15 SY2CLRID SY2CLRID ; 
      15 XDMCD XDMCD ; 
      15 PK0NW3SZ PK0NW3SZ [40] ; 
        20 PK0NWSDN PK0NWSDN ; 
        20 SY5SZID SY5SZID ; 
        20 SY4IDDSC SY4IDDSC ; 
        20 PK1QTY PK1QTY ; 
end // end PK0NW03

//*** RECORD=PK0NW04 ****
// holds allocated quantity from pool detail. these values
// are stored in this array so they only have to be looked
// up once when calculating total prepacks and remaining
// quantities in pk0ns30
// ***********************
Record PK0NW04 type basicRecord
  5 PK0NW4GR PK0NW4GR [40] ; 
    10 PK1QTY PK1QTY ; 
    10 PK0NWSDN PK0NWSDN ; 
end // end PK0NW04

//*** RECORD=PK0NW05 ****
// holds order numbers for the same customer. these orders
// will have the xpa_cust_pack_cd updated.
// ***********************
Record PK0NW05 type basicRecord
  5 PK0NW5GR PK0NW5GR ; 
    10 PK0NW5SW PK0NW5SW ; 
    10 PK0NW5IX PK0NW5IX ; 
    10 XWHCD XWHCD [300] ; 
    10 PK1CUOID PK1CUOID [300] ; 
    10 PK1NORID PK1NORID [300] ; 
end // end PK0NW05

//*** RECORD=PK0NW06 ****
// array used to pass prepack quantities to pwsrec in
// pk0ns-crtn-control
// ***********************
Record PK0NW06 type basicRecord
  5 PK0NW6GR PK0NW6GR ; 
    10 PK0NW-6NDX PK0NW-6NDX ; 
    10 PK0NW-PREPAK-SIZES PK0NW-PREPAK-SIZES ; 
      15 PKTPPQTY PKTPPQTY [40] ; 
end // end PK0NW06

//*** RECORD=PKSREC ****
// ************* PICKING CUSTOMER SPECIFIED PREPK TBL *********
// 
// DB2 TABLE VIEW:      DPICK.VCUSPP01
// 
// COPYLIB MEMBER:      DCL00263
// 
// I/O MODULE:          IO2100
// 
// KEY TO DB2 TABLE:    XWHCD
//                      KUCCOID
//                      KUMSTRID
//                      XNXCD
// 
// DATE CREATED:        08/17/87
// 
// MAINTENANCE LOG:
// 
//   DATE    INIT.      COMMENT
// --------  -----      ---------------------------------------
// 08/17/87   TL        New record definition.
// **********************
Record PKSREC type basicRecord
  5 PKSGROUP PKSGROUP ; 
    10 PKSKEY PKSKEY ; 
      15 XWHCD XWHCD ; 
      15 KUCCOID KUCCOID ; 
      15 KUMSTRID KUMSTRID ; 
      15 XNXCD XNXCD ; 
    10 PKSSSZFL PKSSSZFL ; 
    10 ZZZSDT ZZZSDT ; 
    10 ZZZCHGDT ZZZCHGDT ; 
    10 ZZZCHGTM ZZZCHGTM ; 
    10 ZZZCHGCT ZZZCHGCT ; 
end // end PKSREC

//*** RECORD=PKTREC ****
// ************* PICKING ORDER SPECIFIED PREPACK TBL **********
// 
// DB2 TABLE VIEW:      DPICK.VORSPP01
// 
// COPYLIB MEMBER:      DCL00336
// 
// I/O MODULE:          IO2110
// 
// KEY TO DB2 TABLE:    XWHCD
//                      PK1PRTN
//                      PK1CUOID
//                      PK1NORID
//                      PKTBACTI
// 
// DATE CREATED:        08/17/87
// 
// MAINTENANCE LOG:
// 
//   DATE    INIT.      COMMENT
// --------  -----      ---------------------------------------
// 08/17/87   TL        New record definition.
// 01/15/91  CHYDE      Correct desc for data item pktbacti.
// 06/07/91  mwalto     table changes. plus renamed pk1lninb
//                      for pk-nbr-lb-item to its correct nm
// 02/08/94  MPLUTH     ADDED PK-OUTER-CRTN-QTY.
// **********************
Record PKTREC type basicRecord
  5 PKTGROUP PKTGROUP ; 
    10 PKTKEY PKTKEY ; 
      15 XWHCD XWHCD ; 
      15 PK1PRTN PK1PRTN ; 
      15 PK1CUOID PK1CUOID ; 
      15 PK1NORID PK1NORID ; 
    10 PK1LNINB PK1LNINB ; 
    10 XGPCD XGPCD ; 
    10 OSNPKGNB OSNPKGNB ; 
    10 SY1STNBR SY1STNBR ; 
    10 SY2CLRID SY2CLRID ; 
    10 XDMCD XDMCD ; 
    10 YNTCD YNTCD ; 
    10 PKTBACTI PKTBACTI ; 
    10 PKSSSZFL PKSSSZFL ; 
    10 PK4ITEMS PK4ITEMS ; 
    10 PKTNBRPP PKTNBRPP ; 
    10 OSNINCTN OSNINCTN ; 
    10 OSNNICTN OSNNICTN ; 
    10 KUCUNTCS KUCUNTCS ; 
    10 OSNTIQTY OSNTIQTY ; 
    10 PK-OUTER-CRTN-QTY PK-OUTER-CRTN-QTY ; 
    10 XXXSTAT XXXSTAT ; 
    10 PKTPPQTY PKTPPQTY [40] ; 
    10 PK1QTY PK1QTY [40] ; 
    10 ZZZSDT ZZZSDT ; 
    10 ZZZCHGDT ZZZCHGDT ; 
    10 ZZZCHGTM ZZZCHGTM ; 
    10 ZZZCHGCT ZZZCHGCT ; 
end // end PKTREC

// action field
DataItem PK0NMACT char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// external ending size id
DataItem PK0NMEND char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// remaining quantitiy
DataItem PK0NMREM num(5)  {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// y/n reject all flag
DataItem PK0NMRJT char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// external starting size id
DataItem PK0NMSTR char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// index
DataItem PK0NW-6NDX smallint {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// holding item full case qty
DataItem PK0NW-ITM-FUL-CS-QTY int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// holding item repack qty
DataItem PK0NW-ITM-REPK-QTY int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// holding order full case qty
DataItem PK0NW-ORD-FUL-CS-QTY int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// holding order repack qty
DataItem PK0NW-ORD-REPK-QTY int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// order changed, re-prepak (y/n)
DataItem PK0NW-POOL-CHANGE char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// size group data
DataItem PK0NW-PREPAK-SIZES char(160)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// group level for pk0gw02
DataItem PK0NW2GR char(912)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Key group level
DataItem PK0NW2KY char(9)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// size group data
DataItem PK0NW2SZ char(21)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// group level for pk0nw03
DataItem PK0NW3GR char(587)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// key fields for pk0nw03
DataItem PK0NW3KY char(574)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// group level for size data
DataItem PK0NW3SZ char(14)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// group level for pk0nw04
DataItem PK0NW4GR char(7)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// group level for pk0nw5
DataItem PK0NW5GR char(2403)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// index
DataItem PK0NW5IX smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// y/n is the table done
DataItem PK0NW5SW char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// group level for PK0NW06
DataItem PK0NW6GR char(162)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// y/n adding new order
DataItem PK0NWANO char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// y/n very first time thru
DataItem PK0NWBEG char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// build array from database (y/n
DataItem PK0NWBLA char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// build screen (y/n)
DataItem PK0NWBLS char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// current page for order array
DataItem PK0NWCP1 num(3)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// current page for prepack array
DataItem PK0NWCP2 num(3)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// y/n was record created
DataItem PK0NWCRD char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// counter
DataItem PK0NWCT1 num(3)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// counter
DataItem PK0NWCT2 num(3)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// counter
DataItem PK0NWCT3 num(3)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// counter
DataItem PK0NWCT4 num(3)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// pk-ord-stktf-id
DataItem PK0NWCUI num(8)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// internal end size
DataItem PK0NWEND num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// end-of-application flag (y/n)
DataItem PK0NWEOA char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// end-of-screen flag (y/n)
DataItem PK0NWEOS char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// have map error (y/n)
DataItem PK0NWERR char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// first time thru flag (y/n)
DataItem PK0NWFST char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// hold quantity
DataItem PK0NWHD1 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// hold quantity
DataItem PK0NWHD2 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// hold internal end size
DataItem PK0NWIED num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// hold internal start size
DataItem PK0NWIST num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// temporary storage length
DataItem PK0NWLEN num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// last page for order array
DataItem PK0NWLP1 num(3)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// last page for prepack array
DataItem PK0NWLP2 num(3)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// y/n processing one product
DataItem PK0NWONP char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// y/n is the product done
DataItem PK0NWPDN char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// y/n was product data entered
DataItem PK0NWPRD char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// y/n processing pack by data
DataItem PK0NWPSS char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// y/n error in quantity
DataItem PK0NWQTE char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// code for error in record
DataItem PK0NWRER num(1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// y/n record has all y flags
DataItem PK0NWRHY char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// y/n is the size done
DataItem PK0NWSDN char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// y/n show new records
DataItem PK0NWSNR char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// y/n show remaining sizes
DataItem PK0NWSRS char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// hold lowest prepack qty
DataItem PK0NWTOT int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// temporary storage page
DataItem PK0NWTSP num(4)  {
  currency = no, numericSeparator = no, sign = none, zeroFormat = yes, 
  align = right, fillCharacter = "0", inputRequired = no, minimumInput = 1
}
end

// o/c order or customer data
DataItem PK0NWTYP char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// is it okay to update db (y/n)
DataItem PK0NWUPD char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// y/n update temp storage
DataItem PK0NWUTS char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Record group level
DataItem PKSGROUP char(23)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Key group level
DataItem PKSKEY char(10)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pk-pack-sty-sz-fl
DataItem PKSSSZFL char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Record group level
DataItem PKTGROUP char(384)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Key group level
DataItem PKTKEY char(9)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pk-nbr-prepk
DataItem PKTNBRPP int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = "0", inputRequired = no
}
end

