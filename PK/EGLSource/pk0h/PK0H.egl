package pk0h;
import corpcom1.*;
import corpcom4.*;
import corpcom5.*;
import corpcom6.*;
import corpcom7.*;
import corpx1.*;
import corpx2.*;
import corpy2.*;
import corpz3.*;
import in1.common.*;
import pk.common.*;
import sw.common.*;
import sy.common.*;
import ta.common.*;
import ts.common.*;
//*** PROGRAM=PK0H ****
// ************************************************************
// * applid:    pk0h    carton class maintenance
// *
// ************************************************************
// * maint log
// *  when      who     what
// *-------- -------- -----------------------------------------
// *08/10/87  bnaber  application creation
// *11/29/88  JWOOD   ADDED NONCSP OPT TO CALLS
// *11/29/88  JWOOD   ADDED XSSEGTR LOGIC
// *06/14/89  Jcampb  added aditional line for new ctn type
// *09/21/89  jcampb  structure change - name changes
// *12/19/89  jcampb  fix mis-spelling in heading
// *07/20/92  mwalto  In pk0hsl1, add if ezetst between 53 & 65
// *                  move 65 to working storage. Change was
// *                  needed to hold more than 40 ynt codes.
// *                  Increate array occurs from 40 to 99 in
// *                  pk0hw02.
// *08/17/92  smacmi  Added xp0fs01 and record xp0fw01 to con-
// *                  vert customer nbrs to Cole-Haan format.
// *                  Added brand-code to the screen.
// *02/25/93  rmorga  Added pack factor editing ( PK0HSE5-7 ).
// *05/14/93  rmorga  Don't allow Full Case entries (PK0HSE5).
// *08/11/95  CBRINE  CANADA - add XCTCD to PKWREC
// *09/22/98  tmishr  check packing factor value <=1 in
// *                  pk0hse1 pk0hse5
// ************************************************************
// 
// purpose:
// 
//           maintain the carton classification table.
// 
//   the class of a box is a way of differentiating between
// boxes with the same carton type.  the carton type is
// a code to designate how many units will fit into it.
// for example a carton type may be a 6 pack or 9 pack etc.
// through 2 boxes are both 6 back they may be different
// dimensions.  hence the need for the carton class.
// 
// 
// 
// *********************
Program PK0H type textUIProgram //VAGen Info - main text program
  {
  includeReferencedFunctions = yes, allowUnqualifiedItemReferences = yes, 
  throwNrfEofExceptions = yes, handleHardIOErrors = no, V60ExceptionCompatibility = yes, 
  I4GLItemsNullable = no, textLiteralDefaultIsString = no, localSQLScope = yes, 
  msgTablePrefix = "PK00", inputRecord = COMMAREA, segmented = yes
  }

  // Data Declarations
  COMMAREA COMMAREA ; // record
  ERRSQLCA ERRSQLCA; // record
  PK0HW01 PK0HW01; // record
  PK0HW02 PK0HW02; // record
  PKKREC PKKREC; // record
  PKLREC PKLREC; // record
  PKOREC PKOREC; // record
  PKWREC PKWREC; // record
  SQLCA SQLCA; // record
  TA1REC TA1REC; // record
  TA2REC TA2REC; // record

  // VAGen Info - items needed for migration
  VAGen_EZESYS char(8);
  VAGen_EZEREPLY num(1);
  VAGen_EZE_WAIT_TIME bin(9,2);
  VAGen_EZE_ITEMLEN int;

  // Use Declarations
  use XWHTBL {deleteAfterUse = yes}; // table
  use YNTTBL {deleteAfterUse = yes}; // table
  use PK0HM.PK0HM001 // form
   {
    pfKeyEquate = no
  };

  function main()
    // VAGen Info - initialization needed for migration
    VAGen_EZESYS = VGLib.getVAGSysType();
    PK0H010: PK0H010();
    exit program;
  end // end main
end // end PK0H

// program control
Function PK0H010()



      /* *********************************************************/
      /* * this process controls entire program process control **/
      /* * transfer to other applications occurs in converse    **/
      /* *********************************************************/



  XSENTRY(); /* check security*/


  XSSEGTR(); /* SET SEGMENTED TRAN ID*/



  PK0H100(); /* init pgm areas*/



      /* control pgm converse*/

  PK0HW01.PK0HWAP1 = "N";

  while (PK0HW01.PK0HWAP1 == "N")
    PK0H200();
  end



   /* ************************************************************/
end // end PK0H010

// program initialization
Function PK0H100()



      /* *********************************************************/
      /* * init program areas                                   **/
      /* *********************************************************/



  set PKOREC empty;
  set PKKREC empty;
  set PK0HW01 empty;
  set PK0HW02 empty;
  set TA1REC empty;
  set SQLCA empty;
  set ERRSQLCA empty;
  converseLib.clearScreen();
  set PK0HM001 initial;
  TA1REC.TA1MAP = "PK0HM001";

      /* init map*/

  PKWREC.PKWGRPLV = COMMAREA.CAUSERA;

  if (PKWREC.XWHCD > " ")
    PK0HM001.XWHCD = PKWREC.XWHCD;
  else
    PK0HM001.XWHCD = COMMAREA.XWHCD;
  end

  PK0HSA1(); /* set up working storage*/
                                 /* ;    and validate warehouse*/
  PK0HW01.PK0HWSB1 = 1;
  PK0HSO5(); /* set up screen*/

   /* ************************************************************/
end // end PK0H100

// process map
Function PK0H200()



      /* *********************************************************/
      /* * this process controls the converse for the map and   **/
      /* * the processing of the map                            **/
      /* *********************************************************/



   /* ************************************************************/
  converse PK0HM001 ;
   /* ************************************************************/



  if (converseVar.eventKey is pa1 /* cancel*/
   || converseVar.eventKey is pa2) /* cancel*/
    COMMAREA.CAUSERA = PKWREC.PKWGRPLV;
    COMMAREA.CATOAP = "PK0H";
    XSEXIT();
    PK0HM001.VAGen_EZEMSG = COMMAREA.CAMSG;
    COMMAREA.CATOAP = " ";
  end
  if (converseVar.eventKey is pf1) /* help*/
    COMMAREA.CAUSERA = " "; /* clear user commarea*/
    XSPF1();
    PK0HM001.VAGen_EZEMSG = COMMAREA.CAMSG;
    COMMAREA.CATOAP = " ";
    converseLib.validationFailed();
  end
  if (converseVar.eventKey is pf3) /* exit to menu*/
    COMMAREA.CAUSERA = PKWREC.PKWGRPLV;
    COMMAREA.CATOAP = "PK0A";
    XSEXIT();
    PK0HM001.VAGen_EZEMSG = COMMAREA.CAMSG;
    converseLib.validationFailed();
  end
  if (converseVar.eventKey is pf4) /* master menu*/
    COMMAREA.CAUSERA = PKWREC.PKWGRPLV;
    COMMAREA.CAUSERA = " "; /* clear user commarea*/
    XSPF4();
    PK0HM001.VAGen_EZEMSG = COMMAREA.CAMSG;
    converseLib.validationFailed();
  end
  if (converseVar.eventKey is pf17) /* picking select menu*/
    COMMAREA.CAUSERA = " "; /* clear user commarea*/
    PKWREC.XWHCD = PK0HM001.XWHCD;
    COMMAREA.CAUSERA = PKWREC.PKWGRPLV;
    COMMAREA.CATOAP = "PK04";
    XSEXIT();
    PK0HM001.VAGen_EZEMSG = COMMAREA.CAMSG;
    converseLib.validationFailed();
  end
  if (converseVar.eventKey is pf18) /* picking select menu*/
    COMMAREA.CAUSERA = " "; /* clear user commarea*/
    PKWREC.XWHCD = PK0HM001.XWHCD;
    COMMAREA.CAUSERA = PKWREC.PKWGRPLV;
    COMMAREA.CATOAP = "PK0G";
    XSEXIT();
    PK0HM001.VAGen_EZEMSG = COMMAREA.CAMSG;
    converseLib.validationFailed();
  end
  if (converseVar.eventKey is pf19) /* picking select menu*/
    COMMAREA.CAUSERA = " "; /* clear user commarea*/
    PKWREC.XWHCD = PK0HM001.XWHCD;
    COMMAREA.CAUSERA = PKWREC.PKWGRPLV;
    COMMAREA.CATOAP = "PK07";
    XSEXIT();
    PK0HM001.VAGen_EZEMSG = COMMAREA.CAMSG;
    converseLib.validationFailed();
  end
  if (converseVar.eventKey is pf20) /* picking main menu*/
    COMMAREA.CAUSERA = " "; /* clear user commarea*/
    PKWREC.XWHCD = PK0HM001.XWHCD;
    COMMAREA.CAUSERA = PKWREC.PKWGRPLV;
    COMMAREA.CATOAP = "PK0S";
    XSEXIT();
    PK0HM001.VAGen_EZEMSG = COMMAREA.CAMSG;
    converseLib.validationFailed();
  end
  if (converseVar.validationMsgNum == 0)
    if (converseVar.eventKey is enter /* enter*/
     && PK0HM001.CAIOPT != " ")       /* and fastpath requested*/
      PKWREC.XWHCD = PK0HM001.XWHCD;
      COMMAREA.CAUSERA = PKWREC.PKWGRPLV;
      COMMAREA.CATOAP = PK0HM001.CAIOPT; /* next application*/
      COMMAREA.CAITEM = PK0HM001.CAITEM; /* next item*/
      XSEXIT();
      PK0HM001.VAGen_EZEMSG = COMMAREA.CAMSG;
    else
      if (converseVar.eventKey is enter /* enter only*/
       || converseVar.eventKey is pf7   /* page up, do edit first*/
       || converseVar.eventKey is pf8   /* page down, do edit first*/
       || converseVar.eventKey is pf12) /* edit only*/
        PK0HSI0(); /* pf12 and enter*/
      else
        converseLib.validationFailed(012); /* invalid pf key*/
      end
    end
  end


   /* ************************************************************/
end // end PK0H200

// load working storage
Function PK0HSA1()


         /* get warehouse code and validate*/

  XXXCURDT = VGVar.currentShortGregorianDate;
  XXXRVNBR = "01";

  if (PK0HM001.XWHCD <= " "
   || PK0HM001.XWHCD == "99")
    converseLib.validationFailed(2);
      /* invalid warehouse code entered <please re-enter>*/
    PK0HM001.XWHABRV = " ";
    PK0HW01.XWHCD = " ";
    set PK0HM001.XWHCD cursor, bold;
  else
    if (PK0HM001.XWHCD in XWHTBL.XWHCD)
      PK0HM001.XWHABRV = XWHTBL.XWHABRV[sysVar.arrayIndex];
      PKWREC.XWHABRV = XWHTBL.XWHABRV[sysVar.arrayIndex];
      PKWREC.XWHCD = PK0HM001.XWHCD;

    else
      converseLib.validationFailed(2);
        /* invalid warehouse code entered <please re-enter>*/
      PK0HM001.XWHABRV = " ";
      PK0HW01.XWHCD = " ";
      set PK0HM001.XWHCD cursor, bold;
    end
  end

  PK0HW01.PK0HWSB1 = 1;
  PK0HW01.PK0HWSB2 = 0;
  PK0HW02.PK0HWYCT = 0;
  while (YNTTBL.YNTCD[PK0HWSB1] != 99) /* count entries in tbl*/
    if (YNTTBL.XXXSTAT[PK0HWSB1] != "I") /* and move to working storage*/
      PK0HW02.PK0HWYCT = PK0HW02.PK0HWYCT + 1;
      PK0HW01.PK0HWSB2 = PK0HW01.PK0HWSB2 + 1;
      PK0HW02.PKOPFCTR[PK0HWSB2] = 0;
      PK0HW02.YNTCD[PK0HWSB2] = YNTTBL.YNTCD[PK0HWSB1];
      PK0HW02.YNTDESC[PK0HWSB2] = YNTTBL.YNTDESC[PK0HWSB1];
      PK0HW02.YNTCRWT[PK0HWSB2] = YNTTBL.YNTCRWT[PK0HWSB1];
      PK0HW02.YNTCLSLN[PK0HWSB2] = YNTTBL.YNTCLSLN[PK0HWSB1];
      PK0HW02.YNTCRFT3[PK0HWSB2] = YNTTBL.YNTCRFT3[PK0HWSB1];
      PK0HW02.YNTFCSFL[PK0HWSB2] = YNTTBL.YNTFCSFL[PK0HWSB1];
      PK0HW02.XBCCD[PK0HWSB2] = YNTTBL.XBCCD[PK0HWSB1];
      PK0HW02.YNTUOSFL[PK0HWSB2] = YNTTBL.YNTUOSFL[PK0HWSB1];
      PK0HW02.YNT-CRTN-OVSZ-FL[PK0HWSB2] = YNTTBL.YNT-CRTN-OVSZ-FL[PK0HWSB1];
      PK0HW02.YNTHNGFL[PK0HWSB2] = YNTTBL.YNTHNGFL[PK0HWSB1];
    end
    PK0HW01.PK0HWSB1 = PK0HW01.PK0HWSB1 + 1;
  end

end // end PK0HSA1

// edit screen
Function PK0HSE0()


         /* edit sreen*/



  set PK0HM001.PK0HMACT cursor;

  if (PK0HM001.PK0HMACT == " "
   || PK0HM001.PK0HMACT == "I")
      /* next sentence*/
  else
    if (PK0HM001.PK0HMACT == "D") /* deactivate*/
        /* next sentence*/
    else
      PK0HSE1(); /* tote pack factor edit*/
    end

    PK0HSE2(); /* edit carton class field*/

    PK0HSE3(); /* edit activity column*/
  end


end // end PK0HSE0

// tote pack factor edit
Function PK0HSE1()


         /* tote pack factor edit*/



  PK0HW01.PK0HWTOT = "T "; /* hold field for finding tote row in*/
                                   /* table*/

  if (PK0HM001.PK0HMACT != " " /* inquire*/
   && PK0HM001.PK0HMACT != "I")
    PK0HW01.PK0HWSB1 = 1;
    while (PK0HW01.PK0HWSB1 <= 13)
      if (PK0HM001.YNTCD[PK0HWSB1] in PK0HW02.YNTCD from 1
       && PK0HM001.PKOPFCTR[PK0HWSB1] != PK0HW02.PKOPFCTR[sysVar.arrayIndex])
        PK0HSE5(); /* edit new pack factor*/
      end
      PK0HW01.PK0HWSB1 = PK0HW01.PK0HWSB1 + 1;
    end
    if (PK0HW01.PK0HWTOT in PK0HM001.YNTCD from 1)
      PK0HW01.PK0HWSB2 = sysVar.arrayIndex;
      if (PK0HM001.PKOPFCTR[sysVar.arrayIndex] <= 0)
        converseLib.validationFailed(101); /* tot required*/
        set PK0HM001.PKOPFCTR[sysVar.arrayIndex] cursor, bold;
      else
        if (PK0HW01.PK0HWTOT in PK0HW02.YNTCD from 1
         && PK0HW02.PKOPFCTR[sysVar.arrayIndex] != PK0HM001.PKOPFCTR[PK0HWSB2]
         && PK0HM001.PKOPFCTR[PK0HWSB2] <= 1)
          /* above line stops the move of the new packin factor if > 1*/
          /* end of added code fo the above*/
          PK0HW02.PKOPFCTR[sysVar.arrayIndex] = PK0HM001.PKOPFCTR[PK0HWSB2];
        end
      end
    else
      if (PK0HW01.PK0HWTOT in PK0HW02.YNTCD from 1)
        if (PK0HW02.PKOPFCTR[sysVar.arrayIndex] <= 0)
          converseLib.validationFailed(101); /* tot required*/
        end
      end
    end
  end


  if (converseVar.validationMsgNum == 101)
    PK0HSI1();
    if (PK0HW01.PK0HWTOT in PK0HM001.YNTCD from 1)
      set PK0HM001.PKOPFCTR[sysVar.arrayIndex] cursor, bold;
    end
  end
end // end PK0HSE1

// carton class edit
Function PK0HSE2()


         /* carton class edit*/



  if (PK0HM001.PK0HMACT == "C"
   || PK0HM001.PK0HMACT == "I"
   || PK0HM001.PK0HMACT == " ")
    if (PK0HM001.PKCCRTCL == PK0HW01.PKCCRTCL)
         /* next sentence*/
    else
      PK0HM001.PKCCRTCL = PK0HW01.PKCCRTCL;
      converseLib.validationFailed(102);
         /* when action field is 'a' 'd'*/
         /* carton class cannot be changed*/
      set PK0HM001.PKCCRTCL cursor, bold;
    end
  end



end // end PK0HSE2

// edit activity field
Function PK0HSE3()


         /* edit activity column*/



  if (PK0HM001.PK0HMACT == "A" /* add or activate new row*/
   || PK0HM001.PK0HMACT == "C" /* c for change row*/
   || PK0HM001.PK0HMACT == "D") /* d for inactivate*/
    if (PK0HM001.PK0HMACT == "A") /* a for add*/
      PKOREC.XWHCD = PK0HM001.XWHCD;
      PKOREC.PKCCRTCL = PK0HM001.PKCCRTCL;
      PKOREC.PKORECST = "A";

      XSPKOS1(); /* select set and select next pkorec*/

      if (SQLCA.VAGen_SQLCODE == 0)
        converseLib.validationFailed(103);
        /* this carton class exist, 'c' or 'i' are valid actions*/
        set PK0HM001.PK0HMACT cursor, bold;
      else
        if (SQLCA.VAGen_SQLCODE == -911)
          converseLib.validationFailed(28);
          /* data was in use by another application*/
        end
      end
      XSPKOC1(); /* close set*/
    end
  else
    converseLib.validationFailed(104);
    /* a(add), c(change), d(deactivate)*/
              /* are valid entries*/
    set PK0HM001.PK0HMACT cursor, bold;
  end


end // end PK0HSE3

// set fields to normal
Function PK0HSE4()


         /* set fields to normal*/



  PK0HW01.PK0HWSB1 = 1;
  set PK0HM001.XWHCD normal;
  set PK0HM001.PK0HMACT normal;
  set PK0HM001.PKCCRTCL normal;

  while (PK0HW01.PK0HWSB1 <= 13)

    if (PK0HM001.PKCCRTCL == PK0HW01.PKCCRTCL
     && PK0HM001.PKOPFCTR[PK0HWSB1] is modified
     && PK0HM001.PK0HMACT == " ")
      converseLib.validationFailed(115);
      /* no changes allowed in display mode*/
    else
      if (PK0HM001.YNTCD[PK0HWSB1] > " ")
        set PK0HM001.PKOPFCTR[PK0HWSB1] normal;
      else
        set PK0HM001.PKOPFCTR[PK0HWSB1] skip, invisible;
        PK0HM001.YNTCD[PK0HWSB1] = " ";
        PK0HM001.YNTDESC[PK0HWSB1] = " ";
        PK0HM001.YNTCRWT[PK0HWSB1] = 0;
        PK0HM001.YNTCLSLN[PK0HWSB1] = 0;
        PK0HM001.YNTCRFT3[PK0HWSB1] = 0;
        PK0HM001.XBCCD[PK0HWSB1] = " ";
        PK0HM001.YNTUOSFL[PK0HWSB1] = " ";
        PK0HM001.YNT-CRTN-OVSZ-FL[PK0HWSB1] = " ";
        PK0HM001.YNTHNGFL[PK0HWSB1] = " ";
      end
    end

    PK0HW01.PK0HWSB1 = PK0HW01.PK0HWSB1 + 1;

  end



end // end PK0HSE4

// edit pack factor control
Function PK0HSE5()

         /* edit pack factors.*/

     /* Each pack factor must have a lower or equal*/
     /* value to the pack factor preceding it.*/
     /* Valid pack factors must be in the same brand code,*/
     /* and the hanger flag must match.*/
     /* Null entries are skipped.*/
     /* Do not edit zero or tote values.*/
     /*  */
     /* SE6 and SE7 move their own error messages.*/

     /* While examining pack factors one at a time,*/
     /* don't allow entries into Full Case rows.*/


  if (PK0HM001.PKOPFCTR[PK0HWSB1] != 0 /* no edit needed if zero value*/
   && PK0HW02.YNTCD[sysVar.arrayIndex] != PK0HW01.PK0HWTOT) /* or tote position*/

    PK0HWGO = "Y";

    if (PK0HW02.YNTFCSFL[sysVar.arrayIndex] == "Y")
      set PK0HM001.PKOPFCTR[PK0HWSB1] cursor, bold;
      converseLib.validationFailed(461); /* No full case entries*/
      PK0HWGO = "N";
    end

    if (PK0HM001.PKOPFCTR[PK0HWSB1] > 1) /* pack factor should not be > 1*/
      set PK0HM001.PKOPFCTR[PK0HWSB1] cursor, bold;
      converseLib.validationFailed(523); /* PACK FACTOR CANNOT BE GT 1*/
      PK0HWGO = "N";
    end

    if (PK0HWGO == "Y")

      PK0HSE6(); /* check prev pack factor*/

      if (PK0HWGO == "Y")

        PK0HSE7(); /* check following pack factor*/

        if (PK0HWGO == "Y")
          PK0HW02.PKOPFCTR[sysVar.arrayIndex] = PK0HM001.PKOPFCTR[PK0HWSB1];
        end
      end
    end
  else
    if (PK0HM001.PKOPFCTR[PK0HWSB1] > 1 /* pack factor should not be > 1*/
     && PK0HW02.YNTCD[sysVar.arrayIndex] == PK0HW01.PK0HWTOT) /* or tote position*/
      set PK0HM001.PKOPFCTR[PK0HWSB1] cursor, bold;
      converseLib.validationFailed(523); /* PACK FACTOR CANNOT BE GT 1*/
      PK0HWGO = "N";
    else
      PK0HW02.PKOPFCTR[sysVar.arrayIndex] = PK0HM001.PKOPFCTR[PK0HWSB1];
    end
  end


end // end PK0HSE5

// edit prev pack factor
Function PK0HSE6()

         /* edit previous pack factor.*/

     /* Find a valid pack factor on the table and*/
     /* compare it to the map pack factor.*/


  PK0HWSB2 = sysVar.arrayIndex - 1;
  PK0HWFND = "N";

  while (PK0HWSB2 >= 1 /* search while still in table*/
   && PK0HWFND != "Y") /* and not found*/

    if (PK0HW02.YNTHNGFL[PK0HWSB2] == PK0HW02.YNTHNGFL[sysVar.arrayIndex]
     && PK0HW02.XBCCD[PK0HWSB2] == PK0HW02.XBCCD[sysVar.arrayIndex]
     && PK0HW02.PKOPFCTR[PK0HWSB2] > 0)
      PK0HWFND = "Y";
    else
      PK0HWSB2 = PK0HWSB2 - 1;
    end

  end

  if (PK0HW01.PK0HWSB2 > 0
   && PK0HWFND == "Y")

    if (PK0HM001.PKOPFCTR[PK0HWSB1] >= PK0HW02.PKOPFCTR[PK0HWSB2])

      converseLib.validationFailed(458); /* pack factor error msg*/
      set PK0HM001.PKOPFCTR[PK0HWSB1] cursor, bold;
      PK0HWGO = "N";

    end
  end


end // end PK0HSE6

// edit following pack factor
Function PK0HSE7()

         /* edit following pack factor.*/

     /* Find a valid pack factor on table following*/
     /* the new map pack factor and compare it.*/


  PK0HWSB2 = sysVar.arrayIndex + 1;
  PK0HWFND = "N";

  while (PK0HWSB2 < PK0HW02.PK0HWYCT /* don't overrun table*/
   && PK0HWFND != "Y") /* and not found*/

    if (PK0HW02.YNTHNGFL[PK0HWSB2] == PK0HW02.YNTHNGFL[sysVar.arrayIndex]
     && PK0HW02.XBCCD[PK0HWSB2] == PK0HW02.XBCCD[sysVar.arrayIndex]
     && PK0HW02.PKOPFCTR[PK0HWSB2] > 0)
      PK0HWFND = "Y";
    else
      PK0HWSB2 = PK0HWSB2 + 1;
    end

  end

  if (PK0HWSB2 < PK0HW02.PK0HWYCT /* table max is tote value*/
   && PK0HWFND == "Y")           

    if (PK0HM001.PKOPFCTR[PK0HWSB1] <= PK0HW02.PKOPFCTR[PK0HWSB2])

      converseLib.validationFailed(459); /* pack factor error msg*/
      set PK0HM001.PKOPFCTR[PK0HWSB1] cursor, bold;
      PK0HWGO = "N";

    end
  end


end // end PK0HSE7

// pf7, 8, 12 and enter
Function PK0HSI0()


          /* pf7, 8, 12 and enter*/



  if (PK0HM001.XWHCD == " "
   || PK0HM001.XWHCD != PK0HW01.XWHCD)
    if (converseVar.eventKey is pf7
     || converseVar.eventKey is pf8)
      converseLib.validationFailed(23);
      set PK0HM001.XWHCD cursor, bold;
      return;
    else
      PK0HSO1(); /* validate xwh-whse-cd*/
      if (converseVar.validationMsgNum != 0)
        return;
      end
    end
  end

  if (PK0HM001.PKCCRTCL == " "
   || PK0HM001.PKCCRTCL != PK0HW01.PKCCRTCL)
    if (converseVar.eventKey is pf7
     || converseVar.eventKey is pf8)
      converseLib.validationFailed(23);
      set PK0HM001.PKCCRTCL cursor, bold;
      return;
    else
      PK0HSO4(); /* validate carton class*/
      if (converseVar.validationMsgNum != 0 /* all ok*/
       && converseVar.validationMsgNum != 312) /* warning not found*/
        return;
      end
    end
  end

  if (converseVar.eventKey is pf7
   || converseVar.eventKey is pf8)
    PK0HSE4();
    PK0HSE0();
    PK0HSI1(); /* MOVE SCREEN UP/DOWN*/
  else
    PK0HSE4(); /* set fields to normal*/
    if (PK0HM001.PK0HMACT == "I"
     || PK0HM001.PK0HMACT == " ")
      PK0HW01.PK0HWCLS = PK0HM001.PKCCRTCL;
      PK0HW01.PKCCRTCL = PK0HM001.PKCCRTCL;
      PK0HSS0(); /* enter key*/
      PK0HM001.PK0HMACT = "I"; /* i for inquire*/
    else
      if (PK0HM001.PK0HMACT == "C" /* c for change*/
       && PK0HM001.PKCCRTCL != PK0HW01.PK0HWCLS)
        PK0HW01.PK0HWCLS = PK0HM001.PKCCRTCL;
        PK0HW01.PKCCRTCL = PK0HM001.PKCCRTCL;
        PK0HSS0(); /* enter key*/
        PK0HM001.PK0HMACT = "C"; /* c for change*/
      else
        if (PK0HM001.PK0HMACT == "D" /* d for deactivate*/
         && PK0HM001.PKCCRTCL != PK0HW01.PKCCRTCL)
          PK0HW01.PKCCRTCL = PK0HM001.PKCCRTCL;
          PK0HSS0(); /* enter key*/
          PK0HM001.PK0HMACT = "D"; /* d for deactivate*/
        else
          PK0HW01.PKCCRTCL = PK0HM001.PKCCRTCL;
          PK0HSE0(); /* edit screen*/

          if (converseVar.validationMsgNum > 0)
               /* next sentence*/
          else
            if (converseVar.eventKey is pf12)
              PK0HSU0(); /* update data base*/
              if (converseVar.validationMsgNum == 0
               || converseVar.validationMsgNum == 105) /* data base updated by another appl*/
                PK0HSS0(); /* enter key*/
              end
            else
              converseLib.validationFailed(313);
                 /* all edits passed - press <pf12> to process data*/
            end
          end
        end
      end
    end
  end




end // end PK0HSI0

// pageing function
Function PK0HSI1()


          /* pf7, 8*/

  if (converseVar.validationMsgNum != 0
   && converseVar.validationMsgNum != 101)
    return;
  end

  if (converseVar.eventKey is pfkey
   && PK0HM001.YNTCD[1] in PK0HW02.YNTCD from 1)
    if (converseVar.eventKey is pf7)
      if (sysVar.arrayIndex < 14)
        converseLib.validationFailed(37);
        return;
      else
        sysVar.arrayIndex = sysVar.arrayIndex - 13;
        if (sysVar.arrayIndex <= 0)
          sysVar.arrayIndex = 1;
        end
      end
    else
      if (converseVar.eventKey is pf8)
        sysVar.arrayIndex = sysVar.arrayIndex + 13;
        if (sysVar.arrayIndex > PK0HW02.PK0HWYCT)
          converseLib.validationFailed(38);
          sysVar.arrayIndex = sysVar.arrayIndex - 13;
          return;
        end
      end
    end
  end
  if (sysVar.arrayIndex < 14)
    PK0HW01.PK0HWSB1 = 1;
  else
    if (sysVar.arrayIndex >= 14
     && sysVar.arrayIndex <= 26)
      PK0HW01.PK0HWSB1 = 14;
    else
      if (sysVar.arrayIndex >= 27
       && sysVar.arrayIndex <= 39)
        PK0HW01.PK0HWSB1 = 27;
      else
        if (sysVar.arrayIndex >= 40
         && sysVar.arrayIndex <= 52)
          PK0HW01.PK0HWSB1 = 40;
        end /* change to accommodate up to 99 ynt codes begins here...*/
        if (sysVar.arrayIndex >= 53
         && sysVar.arrayIndex <= 65)
          PK0HW01.PK0HWSB1 = 53;
        end
        if (sysVar.arrayIndex >= 66
         && sysVar.arrayIndex <= 78)
          PK0HW01.PK0HWSB1 = 66;
        end
        if (sysVar.arrayIndex >= 79
         && sysVar.arrayIndex <= 91)
          PK0HW01.PK0HWSB1 = 79;
        end
        if (sysVar.arrayIndex >= 80
         && sysVar.arrayIndex <= 99)
          PK0HW01.PK0HWSB1 = 80;
          return;
        end
      end
    end
  end

  PK0HSO5();

end // end PK0HSI1

// get warehouse code a validate
Function PK0HSO1()


         /* get warehouse code and validate*/




  if (PK0HM001.XWHCD <= " "
   || PK0HM001.XWHCD == "99")
    converseLib.validationFailed(2);
      /* invalid warehouse code entered <please re-enter>*/
    PK0HM001.XWHABRV = " ";
    PK0HW01.XWHCD = " ";
    set PK0HM001.XWHCD cursor, bold;
  else
    if (PK0HM001.XWHCD in XWHTBL.XWHCD)
      PK0HM001.XWHABRV = XWHTBL.XWHABRV[sysVar.arrayIndex];
      PKWREC.XWHABRV = XWHTBL.XWHABRV[sysVar.arrayIndex];
      PK0HW01.XWHCD = PK0HM001.XWHCD;
      PKWREC.XWHCD = PK0HM001.XWHCD;
      PK0HW01.PK0HWSB1 = 1; /* set new index*/
    else
      converseLib.validationFailed(2);
        /* invalid warehouse code entered <please re-enter>*/
      PK0HM001.XWHABRV = " ";
      PK0HW01.XWHCD = " ";
      set PK0HM001.XWHCD cursor, bold;
    end
  end



end // end PK0HSO1

// set up online screen
Function PK0HSO2()


         /* set up online screen*/

  set PKKREC empty;
  PKKREC.PKKBXCCD = PK0HM001.PKCCRTCL;
  PKKREC.XXXSTAT = "A";
  call "IO4560" ("S ", SQLCA, PKKREC) {isNoRefresh = yes, isExternal = yes};
  if (SQLCA.VAGen_SQLCODE != +0)
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(108); /* data base contention(try again)*/
      return;
    else
      if (SQLCA.VAGen_SQLCODE == +100)
        if (PK0HM001.PK0HMACT == "A")
          converseLib.validationFailed(114); /* carton class does not exist*/
          return;
        else
          converseLib.validationFailed(312);
        end
      end
    end
  end

  TA1REC.TA1LOCAT[2] = "PK0HSO4";
  set PKOREC empty;
  PKOREC.XWHCD = PK0HM001.XWHCD;
  PKOREC.PKCCRTCL = PK0HM001.PKCCRTCL;
  PKOREC.PKORECST = "A";

  XSPKOS1(); /* select set and select next pkorec*/

  if (SQLCA.VAGen_SQLCODE == -911)
    converseLib.validationFailed(108); /* data base contention*/
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      if (PK0HM001.PK0HMACT == "C") /* change a row*/
        converseLib.validationFailed(114); /* carton class does not exist*/
        set PK0HM001.PKCCRTCL cursor, bold;
      else
        if (PK0HM001.PK0HMACT != "A")
          converseLib.validationFailed(110); /* no records found*/
          move 0 to PK0HW02.PKOPFCTR[1] for all;
        end
      end
      XSPKOC1(); /* close set*/
    else
      PK0HSO3(); /* load array & set up online screen*/
      XSPKOC1(); /* close set*/
    end
  end



end // end PK0HSO2

// move pkorec to array & screen
Function PK0HSO3()

         /* move pkorec to screen*/

  TA1REC.TA1LOCAT[2] = "PK0HSO3";

  PK0HW01.PK0HWSB4 = 1; /* clear out pack factors*/
  while (PK0HW01.PK0HWSB4 <= 99)
    PK0HW02.PKOPFCTR[PK0HWSB4] = 0;
    PK0HW01.PK0HWSB4 = PK0HWSB4 + 1;
  end

  PK0HM001.PKCCRTCL = PKOREC.PKCCRTCL;
  while (SQLCA.VAGen_SQLCODE == 0) /* now re-load them*/
    if (PKOREC.YNTCD in PK0HW02.YNTCD from 1)
      PK0HW02.PKOPFCTR[sysVar.arrayIndex] = PKOREC.PKOPFCTR;
    end
    XSPKOF1(); /* select next pkorec record*/
  end

  set PKOREC empty;
  PK0HW01.PK0HWSB1 = 1;



end // end PK0HSO3

// validate carton class
Function PK0HSO4()
   /* ---------- pk0hso4 - get and validate carton class -------*/

  set PKKREC empty;
  PKKREC.PKKBXCCD = PK0HM001.PKCCRTCL;
  PKKREC.XXXSTAT = "A";
  PK0HSQ1();

  if (SQLCA.VAGen_SQLCODE == 0)
    PK0HW01.PK0HWSB1 = 1; /* set new index*/
  else
    PK0HW01.PKCCRTCL = " ";
    if (SQLCA.VAGen_SQLCODE == 100)
      if (PK0HM001.PK0HMACT == "A")
        converseLib.validationFailed(114); /* carton class not found*/
        PK0HM001.XXXERRID = "PK0HSO4";
        set PK0HM001.PKCCRTCL cursor, bold;
      else
        converseLib.validationFailed(312);
      end
    else
      if (SQLCA.VAGen_SQLCODE == -911)
        converseLib.validationFailed(108);
        PK0HM001.XXXERRID = "PK0HSO4";
      end
    end
  end



end // end PK0HSO4

// move data to screen
Function PK0HSO5()


         /* load to screen*/

  if (PKKREC.PKKBXCLN > 0)

    if (PK0HM001.PK0HMFMI == "M")
      PK0HM001.PKKBXCLN = mathLib.round(PKKREC.PKKBXCLN / .3937, -mathLib.decimals(PK0HM001.PKKBXCLN));

      PK0HM001.PKKBXCWD = mathLib.round(PKKREC.PKKBXCWD / .3937, -mathLib.decimals(PK0HM001.PKKBXCWD));

      PK0HM001.PKKBXCHG = mathLib.round(PKKREC.PKKBXCHG / .3937, -mathLib.decimals(PK0HM001.PKKBXCHG));

      PK0HWWK1 = mathLib.round(PK0HM001.PKKBXCLN * PK0HM001.PKKBXCWD, -mathLib.decimals(PK0HWWK1));
      PK0HWWK1 = mathLib.round(PK0HWWK1 * PK0HM001.PKKBXCHG, -mathLib.decimals(PK0HWWK1));

      PK0HW01.PK0HWWK1 = mathLib.round(PK0HW01.PK0HWWK1 * .000001, -mathLib.decimals(PK0HW01.PK0HWWK1));
      PK0HM001.PKKBXCF3 = PK0HW01.PK0HWWK1;

      if (PK0HW01.PK0HWWK1 < .01)
        PK0HM001.PKKBXCF3 = .01;
      end

      PK0HM001.PKLCTNLN = mathLib.round(PKLREC.PKLCTNLN / .3937, -mathLib.decimals(PK0HM001.PKLCTNLN));

      PK0HM001.PKLCTNWD = mathLib.round(PKLREC.PKLCTNWD / .3937, -mathLib.decimals(PK0HM001.PKLCTNWD));

      PK0HM001.PKLCTNHG = mathLib.round(PKLREC.PKLCTNHG / .3937, -mathLib.decimals(PK0HM001.PKLCTNHG));

      PK0HWWK1 = mathLib.round(PK0HM001.PKLCTNLN * PK0HM001.PKLCTNWD, -mathLib.decimals(PK0HWWK1));
      PK0HWWK1 = mathLib.round(PK0HWWK1 * PK0HM001.PKLCTNHG, -mathLib.decimals(PK0HWWK1));

      PK0HW01.PK0HWWK1 = mathLib.round(PK0HW01.PK0HWWK1 * .000001, -mathLib.decimals(PK0HW01.PK0HWWK1));
      PK0HM001.PKLCTNF3 = PK0HW01.PK0HWWK1;

      if (PK0HW01.PK0HWWK1 < .01)
        PK0HM001.PKLCTNF3 = .01;
      end
    else

      PK0HM001.PK0HMFMI = "U";

      PK0HM001.PKKBXCLN = PKKREC.PKKBXCLN;
      PK0HM001.PKKBXCWD = PKKREC.PKKBXCWD;
      PK0HM001.PKKBXCHG = PKKREC.PKKBXCHG;
      PK0HM001.PKKBXCF3 = PKKREC.PKKBXCF3;

      PK0HM001.PKLCTNLN = PKLREC.PKLCTNLN;
      PK0HM001.PKLCTNWD = PKLREC.PKLCTNWD;
      PK0HM001.PKLCTNHG = PKLREC.PKLCTNHG;
      PK0HM001.PKLCTNF3 = PKLREC.PKLCTNF3;

    end
  end


  if (PK0HM001.PK0HMFMI == "M")
   /* length in centimeters*/
    PK0HM001.PK0HM-PROD-DIM = "PRD DIMS, CM  "; /* to hdg*/
   /* length in centimeters*/
    PK0HM001.PK0HM-CASE-DIM = "CASE DIM, CM  "; /* to hdg*/
   /* length in meters*/
    PK0HM001.PK0HM-CUBE-UNITS-A = "M :"; /* to hdg-a*/
   /* length in meters*/
    PK0HM001.PK0HM-CUBE-UNITS-B = "M :"; /* to hdg-b*/
   /* kilograms to hdg*/
    PK0HM001.PK0HM-WEIGHT-UNITS = "KILOG"; /**/
   /* centimeters to hdg*/
    PK0HM001.PK0HM-LNGTH-UNITS = "CENTM"; /**/
   /* meters to hdg*/
    PK0HM001.PK0HM-VOLUME-UNITS = "METER"; /**/
  else
   /* length in inches*/
    PK0HM001.PK0HM-PROD-DIM = "PRD DIMS, INCH"; /* to hdg*/
   /* length in inches*/
    PK0HM001.PK0HM-CASE-DIM = "CASE DIM, INCH"; /* to hdg*/
   /* length in feet*/
    PK0HM001.PK0HM-CUBE-UNITS-A = "FT:"; /* to hdg-a*/
   /* length in feet*/
    PK0HM001.PK0HM-CUBE-UNITS-B = "FT:"; /* to hdg-b*/
   /* pounds to hdg*/
    PK0HM001.PK0HM-WEIGHT-UNITS = "POUND"; /**/
   /* inches to hdg*/
    PK0HM001.PK0HM-LNGTH-UNITS = " INCH"; /**/
   /* feet to hdg*/
    PK0HM001.PK0HM-VOLUME-UNITS = " FOOT"; /**/
  end


  PK0HW01.PK0HWSB2 = 1;
  set PK0HM001.PKCCRTCL normal;
  set PK0HM001.PK0HMACT normal;

  while (PK0HW01.PK0HWSB1 <= PK0HW02.PK0HWYCT
   && PK0HW01.PK0HWSB2 <= 13)

    PK0HM001.YNTCD[PK0HWSB2] = PK0HW02.YNTCD[PK0HWSB1];
    PK0HM001.YNTDESC[PK0HWSB2] = PK0HW02.YNTDESC[PK0HWSB1];
    PK0HM001.XBCCD[PK0HWSB2] = PK0HW02.XBCCD[PK0HWSB1];
    PK0HM001.YNTUOSFL[PK0HWSB2] = PK0HW02.YNTUOSFL[PK0HWSB1];
    PK0HM001.YNT-CRTN-OVSZ-FL[PK0HWSB2] = PK0HW02.YNT-CRTN-OVSZ-FL[PK0HWSB1];
    PK0HM001.YNTHNGFL[PK0HWSB2] = PK0HW02.YNTHNGFL[PK0HWSB1];
    if (PK0HM001.PK0HMFMI == "M")
      PK0HM001.YNTCRWT[PK0HWSB2] = mathLib.round(PK0HW02.YNTCRWT[PK0HWSB1] / 2.2046, -mathLib.decimals(PK0HM001.YNTCRWT[PK0HWSB2]));

      PK0HM001.YNTCLSLN[PK0HWSB2] = mathLib.round(PK0HW02.YNTCLSLN[PK0HWSB1] / .3937, -mathLib.decimals(PK0HM001.YNTCLSLN[PK0HWSB2]));

      PK0HM001.YNTCRFT3[PK0HWSB2] = mathLib.round(PK0HW02.YNTCRFT3[PK0HWSB1] * .0280, -mathLib.decimals(PK0HM001.YNTCRFT3[PK0HWSB2]));

    else
      PK0HM001.YNTCRWT[PK0HWSB2] = PK0HW02.YNTCRWT[PK0HWSB1];

      PK0HM001.YNTCLSLN[PK0HWSB2] = PK0HW02.YNTCLSLN[PK0HWSB1];

      PK0HM001.YNTCRFT3[PK0HWSB2] = PK0HW02.YNTCRFT3[PK0HWSB1];
    end

    PK0HM001.PKOPFCTR[PK0HWSB2] = PK0HW02.PKOPFCTR[PK0HWSB1];
    set PK0HM001.PKOPFCTR[PK0HWSB2] normal;

    PK0HW01.PK0HWSB2 = PK0HW01.PK0HWSB2 + 1;
    PK0HW01.PK0HWSB1 = PK0HW01.PK0HWSB1 + 1;

  end

  while (PK0HW01.PK0HWSB2 <= 13)

    set PK0HM001.PKOPFCTR[PK0HWSB2] skip, invisible;
    PK0HM001.YNTCD[PK0HWSB2] = " ";
    PK0HM001.YNTDESC[PK0HWSB2] = " ";
    PK0HM001.YNTCRWT[PK0HWSB2] = 0;
    PK0HM001.YNTCLSLN[PK0HWSB2] = 0;
    PK0HM001.YNTCRFT3[PK0HWSB2] = 0;
    PK0HM001.PKOPFCTR[PK0HWSB2] = 0;
    PK0HM001.XBCCD[PK0HWSB2] = " ";
    PK0HM001.YNTUOSFL[PK0HWSB2] = " ";
    PK0HM001.YNT-CRTN-OVSZ-FL[PK0HWSB2] = " ";
    PK0HM001.YNTHNGFL[PK0HWSB2] = " ";

    PK0HW01.PK0HWSB2 = PK0HW01.PK0HWSB2 + 1;

  end


end // end PK0HSO5

// access dpick.vccdim01
Function PK0HSQ1()

  call "IO4560" ("S ", SQLCA, PKKREC) {isNoRefresh = yes, isExternal = yes};
  if (SQLCA.VAGen_SQLCODE != +0
   && SQLCA.VAGen_SQLCODE != +100
   && SQLCA.VAGen_SQLCODE != -911)
    TA1REC.TA1TYPE = "DB2 ";
    TA1REC.TA1FUNC = "RETN";
    TA1REC.TA1PGMNM = "PK0HSQ1 ";
    TA1REC.TA1LOCAT[1] = "IO4560  ";
    TA1REC.TA1LOCAT[3] = "SELECT  ";
    TA1REC.TA1LOCAT[4] = "UNIQUE  ";
    TA1REC.TA1DBASE = "DPICK   ";
    TA1REC.TA1TBLVU = "VCCDIM01";
    TA1REC.TA1TBLKE = PKKREC.PKKKEY;
    move SQLCA to ERRSQLCA withV60Compat;
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback();
    call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
    XSPF4();
    exit program;
  else
    if (SQLCA.VAGen_SQLCODE == 0)
      set PKLREC empty;
      PKLREC.PKLCTNCD = PKKREC.PKKALWCD[1];
      PKLREC.XXXSTAT = PKKREC.XXXSTAT;
      call "IO4730" ("S ", SQLCA, PKLREC) {isNoRefresh = yes, isExternal = yes};
      if (SQLCA.VAGen_SQLCODE != +0
       && SQLCA.VAGen_SQLCODE != +100
       && SQLCA.VAGen_SQLCODE != -911)
        TA1REC.TA1TYPE = "DB2 ";
        TA1REC.TA1FUNC = "RETN";
        TA1REC.TA1PGMNM = "PK0HSQ1 ";
        TA1REC.TA1LOCAT[1] = "IO4560  ";
        TA1REC.TA1LOCAT[3] = "SELECT  ";
        TA1REC.TA1LOCAT[4] = "UNIQUE  ";
        TA1REC.TA1DBASE = "DPICK   ";
        TA1REC.TA1TBLVU = "VCCDIM01";
        TA1REC.TA1TBLKE = PKKREC.PKKKEY;
        move SQLCA to ERRSQLCA withV60Compat;
        VGVar.handleSysLibraryErrors = 0;
        sysLib.rollback();
        call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
        XSPF4();
        exit program;
      end

    end
  end

end // end PK0HSQ1

// do paging of screen data
Function PK0HSS0()


         /* do paging of screen data*/



  PK0HW01.PK0HWSB1 = 1;

  PK0HSO2(); /* rebuild online screen*/

  PK0HSO5(); /* online screen descriptions*/



end // end PK0HSS0

// update data base
Function PK0HSU0()

   /* *******************************************/
         /* update carton class data base*/
   /* *******************************************/

  if (PK0HM001.PK0HMACT != " "
   && PK0HM001.PK0HMACT != "I")
    PK0HSU1(); /* get date and time stamp*/
    PK0HW01.PK0HWSB1 = 1;
    while (PK0HW01.PK0HWSB1 <= PK0HW02.PK0HWYCT)

      if (PK0HW02.YNTCD[PK0HWSB1] != " ")
        PK0HSU2(); /* select unique pkorec*/
        if (PK0HM001.PK0HMACT == "D") /* inactivate row*/
          if (SQLCA.VAGen_SQLCODE == 0)
            PK0HSU5(); /* data base change*/
          end
        else
          if (PK0HW02.YNTCD[PK0HWSB1] == "T " /* tote row in table*/
           && PK0HW02.PKOPFCTR[PK0HWSB1] == 0)
            PK0HSU5(); /* data base change*/
          else
            if (PK0HW02.PKOPFCTR[PK0HWSB1] == 0)
              if (SQLCA.VAGen_SQLCODE == 0)
                PK0HSU3(); /* delete pkorec*/
              end
            else
              if (PK0HM001.PK0HMACT == "A") /* a for add*/
                if (SQLCA.VAGen_SQLCODE == 0)
                  PK0HSU5(); /* data base change*/
                else
                  PK0HSU4(); /* data base add*/
                end
              else
                if (PK0HM001.PK0HMACT == "C") /* c for change*/
                  if (SQLCA.VAGen_SQLCODE != 0)
                    PK0HSU4(); /* data base add*/
                  else
                    if (PK0HW02.PKOPFCTR[PK0HWSB1] != PKOREC.PKOPFCTR)
                      PK0HSU5(); /* data base change*/
                    end
                  end
                end
              end
            end
          end
        end
      end

      PK0HW01.PK0HWSB1 = PK0HW01.PK0HWSB1 + 1;

    end
  end


  if (PK0HM001.PK0HMACT > " ")
    if (converseVar.validationMsgNum == 0
     || converseVar.validationMsgNum == 105)
      if (converseVar.validationMsgNum == 105) /* data base updated by someone else*/
        VGVar.handleSysLibraryErrors = 0;
        sysLib.rollback();
      else
        VGVar.handleSysLibraryErrors = 0;
        sysLib.commit();
        if (PK0HM001.PK0HMACT == "D")
          converseLib.validationFailed(111); /* carton class inactivated*/
          move 0 to PK0HW02.PKOPFCTR[1] for all;
          move 0 to PK0HM001.PKOPFCTR[1] for all;
        else
          converseLib.validationFailed(32);
            /* table update was successful*/
        end
      end
      PK0HM001.PK0HMACT = " ";
    end

  end


end // end PK0HSU0

// get time and date stamp
Function PK0HSU1()



      /* get time and date stamp*/



  set TA2REC empty;
  TA2REC.TA2DTOPT = "GETDATE";
  call "TA0040" (TA2REC) {isNoRefresh = yes, isExternal = yes};



end // end PK0HSU1

// select unique pkorec
Function PK0HSU2()



         /* select unique pkorec*/



  set PKOREC empty;
  TA1REC.TA1LOCAT[2] = "PK0HSU2";
  PKOREC.XWHCD = PK0HW01.XWHCD;
  PKOREC.PKCCRTCL = PK0HW01.PKCCRTCL;
  PKOREC.YNTCD = PK0HW02.YNTCD[PK0HWSB1];

  XSPKOI0(); /* select row*/

  if (SQLCA.VAGen_SQLCODE == -911)
    converseLib.validationFailed(28); /* data base in use*/
      /* data base was in use by another appl*/
  end



end // end PK0HSU2

// delete row from data base
Function PK0HSU3()


         /* physical delete from data base*/



  TA1REC.TA1LOCAT[2] = "PK0HSU3";

  XSPKOD0(); /* delete row on data base*/

  if (SQLCA.VAGen_SQLCODE == 0)
      /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(28);
         /* data base was in use by another appl*/
    end
  end


end // end PK0HSU3

// add to data base
Function PK0HSU4()


         /* add pkorec to data base*/



  set PKOREC empty;
  TA1REC.TA1LOCAT[2] = "PK0HSU4";
  PKOREC.ZZZCHGDT = TA2REC.TA2GRGGN;
  PKOREC.ZZZCHGTM = TA2REC.TA2TIMHM;
  PKOREC.PKORECST = "A";

  PK0HSU6(); /* move row on screen to record*/

  XSPKOA0(); /* add row to data base*/

  if (SQLCA.VAGen_SQLCODE == 0)
      /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == -803)
      converseLib.validationFailed(109);
       /* needs message*/
       /* duplicate record*/
      set PK0HM001.PK0HMACT cursor, bold;
    else
      if (SQLCA.VAGen_SQLCODE == -911)
        converseLib.validationFailed(028); /* data base in use*/
          /* data base was in use by another appl*/
      end
    end
  end



end // end PK0HSU4

// change to data base
Function PK0HSU5()


         /* change pkorec in data base*/



  if (PK0HW02.PKOPFCTR[PK0HWSB1] == PKOREC.PKOPFCTR
   && PK0HM001.PK0HMACT == "C")
      /* next sentence*/
  else
    TA1REC.TA1LOCAT[2] = "PK0HSU5";

    PKOREC.ZZZCHGDT = TA2REC.TA2GRGGN;
    PKOREC.ZZZCHGTM = TA2REC.TA2TIMHM;

    if (PK0HW02.YNTCD[PK0HWSB1] == "T "
     && PK0HW02.PKOPFCTR[PK0HWSB1] == 0
     && PK0HM001.PK0HMACT == "C")
      PKOREC.PKORECST = "I";
      PK0HW02.PKOPFCTR[PK0HWSB1] = PKOREC.PKOPFCTR;
    else
      if (PK0HM001.PK0HMACT == "D")
        PKOREC.PKORECST = "D";
        PK0HW02.PKOPFCTR[PK0HWSB1] = PKOREC.PKOPFCTR;
      else
        PKOREC.PKOPFCTR = PK0HW02.PKOPFCTR[PK0HWSB1];
        PKOREC.PKORECST = "A";
      end
    end


    XSPKOR0(); /* update row on data base*/


    if (SQLCA.VAGen_SQLCODE == +100)
      converseLib.validationFailed(105);
         /* data base by another appl*/
    end

  end


end // end PK0HSU5

// move array to pkorec
Function PK0HSU6()


         /* move data from array to pkorec record*/



  PKOREC.XWHCD = PK0HW01.XWHCD;
  PKOREC.PKCCRTCL = PK0HW01.PKCCRTCL;
  PKOREC.YNTCD = PK0HW02.YNTCD[PK0HWSB1];
  PKOREC.PKOPFCTR = PK0HW02.PKOPFCTR[PK0HWSB1];



end // end PK0HSU6

// add : location : 0
Function XSPKOA0()


   /* ************************************************************/
   /* *** add unique row in: destination table                ****/
   /* *** using the std i/o processing version #0             ****/
   /* *** note: sqlcq.sqlcode used re: can't "set" ezesqcod   ****/
   /* *** note: IO process(s) do all row/rec moves so that    ****/
   /* ***       the final result will be in the record        ****/
   /* *** setup the following just before this is executed:   ****/
   /* ***   TA1REC.TA1LOCAT(2) = what executes this sgrp      ****/
   /* ***   TA1REC.TA1MAP      = what map this data is from   ****/
   /* *** code the action for the following return codes:     ****/
   /* ***      0 = successful - continue                      ****/
   /* ***   -803 = adding duplicate row - setup dupl row msg  ****/
   /* ***   -911 = deadlock - try again msg                   ****/
   /* ***     <0 = db/severe error - contact programming msg  ****/
   /* ***          note: clear screen & put keys back         ****/
   /* ***          note: TA0020 will have been executed       ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** select unique row for inquiry                       ****/
   /* *** note: 0 return code results in the -803             ****/
   /* ************************************************************/

  call "IO1960" ("S ", SQLCA, PKOREC) {isNoRefresh = yes, isExternal = yes}; /* <=== select unique row*/

  if (SQLCA.VAGen_SQLCODE == 0)
    SQLCA.VAGen_SQLCODE = -803;
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -911)
    return;
  end

  if (SQLCA.VAGen_SQLCODE < 0)
    TA1REC.TA1TYPE = "DB2 ";
    TA1REC.TA1FUNC = "RETN";
    TA1REC.TA1PGMNM = "XSPKOA0 ";
    TA1REC.TA1LOCAT[1] = "IO1960  ";
    TA1REC.TA1LOCAT[3] = "ADD     ";
    TA1REC.TA1LOCAT[4] = "UNIQUE  ";
    TA1REC.TA1DBASE = "DPICK   ";
    TA1REC.TA1TBLVU = "VCARTD01";
    TA1REC.TA1TBLKE = PKOREC.PKOKEY;
    move SQLCA to ERRSQLCA withV60Compat;
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback();
    call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
    XSPF4();
  end

   /* ************************************************************/
   /* *** insert row                                          ****/
   /* *** note: IO process initializes zzzchgct to 0          ****/
   /* ************************************************************/

  call "IO1960" ("A ", SQLCA, PKOREC) {isNoRefresh = yes, isExternal = yes}; /* <=== add row*/

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -911)
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSPKOA0 ";
  TA1REC.TA1LOCAT[1] = "IO1960  ";
  TA1REC.TA1LOCAT[3] = "ADD     ";
  TA1REC.TA1LOCAT[4] = "ROW     ";
  TA1REC.TA1DBASE = "DPICK   ";
  TA1REC.TA1TBLVU = "VCARTD01";
  TA1REC.TA1TBLKE = PKOREC.PKOKEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
  XSPF4();

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/

end // end XSPKOA0

// close : location : 0
Function XSPKOC1()


   /* ************************************************************/
   /* *** close select set of: destination table              ****/
   /* *** using the standard i/o processing version #0        ****/
   /* *** note: sqlcq.sqlcode used re: can't "set" ezesqcod   ****/
   /* *** setup the following just before this is executed:   ****/
   /* ***   TA1REC.TA1LOCAT(2) = what executes this sgrp      ****/
   /* ***   TA1REC.TA1MAP      = what map this data is from   ****/
   /* *** code the action for the following return codes:     ****/
   /* ***      0 = successful - continue                      ****/
   /* ***   -507 = cursor already closed - return 0           ****/
   /* ***     <0 = db/severe error - contact programming msg  ****/
   /* ***          note: clear screen & put keys back         ****/
   /* ***          note: TA0020 will have been executed       ****/
   /* ***                within this sgrp for <0 only         ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** close select set (if prior to EOF)                  ****/
   /* ************************************************************/

  call "IO1960" ("C1", SQLCA, PKOREC) {isNoRefresh = yes, isExternal = yes}; /* <=== close select set*/

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -501)
    SQLCA.VAGen_SQLCODE = 0;
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSPKOC1 ";
  TA1REC.TA1LOCAT[1] = "IO1960  ";
  TA1REC.TA1LOCAT[3] = "CLOSE   ";
  TA1REC.TA1LOCAT[4] = "SETINQ  ";
  TA1REC.TA1DBASE = "DPICK   ";
  TA1REC.TA1TBLVU = "VCARTD01";
  TA1REC.TA1TBLKE = PKOREC.PKOKEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
  XSPF4();

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSPKOC1

// delete : location : 0
Function XSPKOD0()


   /* ************************************************************/
   /* *** delete unique row in: destination table             ****/
   /* *** using the standard i/o processing version #0        ****/
   /* *** note: sqlcq.sqlcode used re: can't "set" ezesqcod   ****/
   /* *** note: IO process(s) do all rec/row moves so that    ****/
   /* ***       the final result will be in the record        ****/
   /* *** setup the following just before this is executed:   ****/
   /* ***   TA1REC.TA1LOCAT(2) = what executes this sgrp      ****/
   /* ***   TA1REC.TA1MAP      = what map this data is from   ****/
   /* *** code the action for the following return codes:     ****/
   /* ***      0 = successful - continue                      ****/
   /* ***   +100 = concurrent update - return with msg re:    ****/
   /* ***          deleted since last read (blank out rec)    ****/
   /* ***          updated since last read (new data in rec)  ****/
   /* ***   -911 = deadlock - setup try again error/msg       ****/
   /* ***     <0 = db/severe error - contact programming msg  ****/
   /* ***          note: clear screen & put keys back         ****/
   /* ***          note: TA0020 will have been executed       ****/
   /* ***                within this sgrp for <0 only         ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** delete unique row                                   ****/
   /* ************************************************************/

  call "IO1960" ("D ", SQLCA, PKOREC) {isNoRefresh = yes, isExternal = yes}; /* <=== select unique row*/


  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSPKOD1 ";
  TA1REC.TA1LOCAT[1] = "IO1960  ";
  TA1REC.TA1LOCAT[3] = "DELETE  ";
  TA1REC.TA1LOCAT[4] = "ROW     ";
  TA1REC.TA1DBASE = "DPICK   ";
  TA1REC.TA1TBLVU = "VCARTD01";
  TA1REC.TA1TBLKE = PKOREC.PKOKEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
  XSPF4();

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSPKOD0

// fetch : location : 0
Function XSPKOF1()


   /* ************************************************************/
   /* *** fetch next row from: destination table              ****/
   /* *** using the standard i/o processing version #0        ****/
   /* *** note: sqlcq.sqlcode used re: can't "set" ezesqcod   ****/
   /* *** note: +100 - not found was detected as part of the  ****/
   /* ***       select set previously executed                ****/
   /* *** setup the following just before this is executed:   ****/
   /* ***   TA1REC.TA1LOCAT(2) = what executes this sgrp      ****/
   /* ***   TA1REC.TA1MAP      = what map this data is from   ****/
   /* *** code the action for the following return codes:     ****/
   /* ***      0 = successful - continue                      ****/
   /* ***   +100 = EOF                                        ****/
   /* ***     <0 = db/severe error - contact programming msg  ****/
   /* ***          note: clear screen & put keys back         ****/
   /* ***          note: TA0020 will have been executed       ****/
   /* ***                within this sgrp for <0 only         ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** scan/retrieve/fetch next row                        ****/
   /* *** note: CSP closes cursor at end of set (+100)        ****/
   /* ************************************************************/

  call "IO1960" ("N1", SQLCA, PKOREC) {isNoRefresh = yes, isExternal = yes}; /* <=== select next row*/

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSPKOF1 ";
  TA1REC.TA1LOCAT[1] = "IO1960  ";
  TA1REC.TA1LOCAT[3] = "FETCH   ";
  TA1REC.TA1LOCAT[4] = "NEXT    ";
  TA1REC.TA1DBASE = "DPICK   ";
  TA1REC.TA1TBLVU = "VCARTD01";
  TA1REC.TA1TBLKE = PKOREC.PKOKEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
  XSPF4();

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSPKOF1

// inquiry : location : 0
Function XSPKOI0()


   /* ************************************************************/
   /* *** select unique row from: destination table           ****/
   /* *** using the standard i/o processing version #0        ****/
   /* *** note: second fetch used to detect duplicate rows    ****/
   /* *** note: sqlcq.sqlcode used re: can't "set" ezesqcod   ****/
   /* *** note: IO process(s) do all rec/row moves so that    ****/
   /* ***       the final result will be in the record        ****/
   /* *** setup the following just before this is executed:   ****/
   /* ***   TA1REC.TA1LOCAT(2) = what executes this sgrp      ****/
   /* ***   TA1REC.TA1MAP      = what map this data is from   ****/
   /* *** code the action for the following return codes:     ****/
   /* ***      0 = successful - continue                      ****/
   /* ***   +100 = not found - setup not fnd error/msg        ****/
   /* ***   -911 = deadlock - setup try again error/msg       ****/
   /* ***   -811 = duplicates found - contact programming msg ****/
   /* ***          note: do NOT clear screen                  ****/
   /* ***     <0 = db/severe error - contact programming msg  ****/
   /* ***          note: clear screen & put keys back         ****/
   /* ***          note: TA0020 will have been executed       ****/
   /* ***                within this sgrp for <0 only         ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** select row with unique key                          ****/
   /* ************************************************************/

  call "IO1960" ("S ", SQLCA, PKOREC) {isNoRefresh = yes, isExternal = yes}; /* <=== select unique*/

  if (SQLCA.VAGen_SQLCODE == -911)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -811) /* duplicate*/
    XSPKOS1();
    XSPKOC1();
  end

  if (SQLCA.VAGen_SQLCODE < 0)
    TA1REC.TA1TYPE = "DB2 ";
    TA1REC.TA1FUNC = "RETN";
    TA1REC.TA1PGMNM = "XSPKOI0 ";
    TA1REC.TA1LOCAT[1] = "IO1640  ";
    TA1REC.TA1LOCAT[3] = "SELECT  ";
    TA1REC.TA1LOCAT[4] = "SET     ";
    TA1REC.TA1DBASE = "DPICK   ";
    TA1REC.TA1TBLVU = "VCARTD01";
    TA1REC.TA1TBLKE = PKOREC.PKOKEY;
    move SQLCA to ERRSQLCA withV60Compat;
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback();
    call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
    XSPF4();
  end

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSPKOI0

// replace : location : 0
Function XSPKOR0()


   /* ************************************************************/
   /* *** replace unique row in: destination table            ****/
   /* *** using the standard i/o processing version #0        ****/
   /* *** note: sqlcq.sqlcode used re: can't "set" ezesqcod   ****/
   /* *** note: IO process(s) do all rec/row moves so that    ****/
   /* ***       the final result will be in the record        ****/
   /* *** setup the following just before this is executed:   ****/
   /* ***   TA1REC.TA1LOCAT(2) = what executes this sgrp      ****/
   /* ***   TA1REC.TA1MAP      = what map this data is from   ****/
   /* *** code the action for the following return codes:     ****/
   /* ***      0 = successful - continue                      ****/
   /* ***   +100 = concurrent update - return with msg re:    ****/
   /* ***          deleted since last read (blank out rec)    ****/
   /* ***          updated since last read (new data in rec)  ****/
   /* ***   -911 = deadlock - setup try again error/msg       ****/
   /* ***     <0 = db/severe error - contact programming msg  ****/
   /* ***          note: clear screen & put keys back         ****/
   /* ***          note: TA0020 will have been executed       ****/
   /* ***                within this sgrp for <0 only         ****/
   /* ************************************************************/


   /* ************************************************************/
   /* *** replace row                                         ****/
   /* *** note: IO process increments zzzchgct by +1 and uses ****/
   /* ***       current data & time for zzzchgdt & zzzchgtm   ****/
   /* ************************************************************/

  call "IO1960" ("U ", SQLCA, PKOREC) {isNoRefresh = yes, isExternal = yes}; /* <=== select unique row*/


  if (SQLCA.VAGen_SQLCODE == 0
   || SQLCA.VAGen_SQLCODE == 100)
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSPKOR0 ";
  TA1REC.TA1LOCAT[1] = "IO1960  ";
  TA1REC.TA1LOCAT[3] = "REPLACE ";
  TA1REC.TA1LOCAT[4] = "ROW     ";
  TA1REC.TA1DBASE = "DPICK   ";
  TA1REC.TA1TBLVU = "VCARTD01";
  TA1REC.TA1TBLKE = PKOREC.PKOKEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
  XSPF4();

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSPKOR0

// setinq : location : 0
Function XSPKOS1()


   /* ************************************************************/
   /* *** select set of rows from: destination table          ****/
   /* *** using the standard i/o processing version #0        ****/
   /* *** note: sqlcq.sqlcode used re: can't "set" ezesqcod   ****/
   /* *** note: +100 - not found can't be detected until the  ****/
   /* ***       first fetch is executed                       ****/
   /* *** setup the following just before this is executed:   ****/
   /* ***   TA1REC.TA1LOCAT(2) = what executes this sgrp      ****/
   /* ***   TA1REC.TA1MAP      = what map this data is from   ****/
   /* *** code the action for the following return codes:     ****/
   /* ***      0 = successful - continue                      ****/
   /* ***   +100 = none found - setup not fnd error/msg       ****/
   /* ***   -911 = deadlock - setup try again error/msg       ****/
   /* ***     <0 = db/severe error - contact programming msg  ****/
   /* ***          note: clear screen & put keys back         ****/
   /* ***          note: TA0020 will have been executed       ****/
   /* ***                within this sgrp for <0 only         ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** select set with unique key                          ****/
   /* ************************************************************/

  call "IO1960" ("S1", SQLCA, PKOREC) {isNoRefresh = yes, isExternal = yes}; /* <=== select set row*/

  if (SQLCA.VAGen_SQLCODE == -911)
    return;
  end

  if (SQLCA.VAGen_SQLCODE < 0)
    TA1REC.TA1TYPE = "DB2 ";
    TA1REC.TA1FUNC = "RETN";
    TA1REC.TA1PGMNM = "XSPKOS1 ";
    TA1REC.TA1LOCAT[1] = "IO1960  ";
    TA1REC.TA1LOCAT[3] = "SELECT  ";
    TA1REC.TA1LOCAT[4] = "SET     ";
    TA1REC.TA1DBASE = "DPICK   ";
    TA1REC.TA1TBLVU = "VCARTD01";
    TA1REC.TA1TBLKE = PKOREC.PKOKEY;
    move SQLCA to ERRSQLCA withV60Compat;
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback();
    call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
    XSPF4();
  end

   /* ************************************************************/
   /* *** scan/retrieve/fetch first row                       ****/
   /* *** in order to detect not found (+100)                 ****/
   /* *** note: CSP closes cursor at end of set (+100)        ****/
   /* *** note: any loop processing must use this first row   ****/
   /* ***       and fetch the next row at the end of the loop ****/
   /* ************************************************************/

  call "IO1960" ("N1", SQLCA, PKOREC) {isNoRefresh = yes, isExternal = yes}; /* <=== select set row*/

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSTF2S0 ";
  TA1REC.TA1LOCAT[1] = "IO1960  ";
  TA1REC.TA1LOCAT[3] = "FIRST   ";
  TA1REC.TA1LOCAT[4] = "FETCH   ";
  TA1REC.TA1DBASE = "DPICK   ";
  TA1REC.TA1TBLVU = "VCARTD01";
  TA1REC.TA1TBLKE = PKOREC.PKOKEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
  XSPF4();

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSPKOS1

//*** RECORD=PK0HW01 ****
// picking working storage.
// this area is the working storage unique to
// application PK0H
// ***********************
Record PK0HW01 type basicRecord
  5 PK0HWGRP PK0HWGRP ; 
    10 XWHCD XWHCD ; 
    10 PK0HWAP1 PK0HWAP1 ; 
    10 PK0HWSB1 PK0HWSB1 ; 
    10 PK0HWSB2 PK0HWSB2 ; 
    10 PK0HWSB3 PK0HWSB3 ; 
    10 PK0HWSB4 PK0HWSB4 ; 
    10 PK0HWCT5 PK0HWCT5 ; 
    10 PKCCRTCL PKCCRTCL ; 
    10 PK0HWTOT PK0HWTOT ; 
    10 PK0HWCLS PK0HWCLS ; 
    10 PK0HWWK1 PK0HWWK1 ; 
    10 PK0HWFND PK0HWFND ; 
    10 PK0HWGO PK0HWGO ; 
end // end PK0HW01

Record PK0HW02 type basicRecord
  5 PK0HWYCT PK0HWYCT ; 
  5 PK0HWYNT PK0HWYNT [99] ; 
    10 PKOPFCTR PKOPFCTR ; 
    10 YNTCD YNTCD ; 
    10 YNTDESC YNTDESC ; 
    10 YNTCLSLN YNTCLSLN ; 
    10 YNTCRFT3 YNTCRFT3 ; 
    10 YNTCRWT YNTCRWT ; 
    10 XBCCD XBCCD ; 
    10 YNTUOSFL YNTUOSFL ; 
    10 YNT-CRTN-OVSZ-FL YNT-CRTN-OVSZ-FL ; 
    10 YNTHNGFL YNTHNGFL ; 
    10 YNTFCSFL YNTFCSFL ; 
end // end PK0HW02

// process control flag 1
DataItem PK0HWAP1 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem PK0HWCLS char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// work counter 5
DataItem PK0HWCT5 num(8)  {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// found flag
DataItem PK0HWFND char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// keep going flag
DataItem PK0HWGO char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem PK0HWGRP char(37)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// work subscript 1
DataItem PK0HWSB1 smallint {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// work subscript 2
DataItem PK0HWSB2 smallint {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// work subscript 3
DataItem PK0HWSB3 smallint {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// work subscript 4
DataItem PK0HWSB4 smallint {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// hold area for tote
DataItem PK0HWTOT char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// work area for calc
DataItem PK0HWWK1 decimal(15,6)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// array count
DataItem PK0HWYCT num(3)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

DataItem PK0HWYNT char(40)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

