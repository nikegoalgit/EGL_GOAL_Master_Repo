package pc0r;
import corpcom1.*;
import corpcom2.*;
import corpcom3.*;
import corpcom4.*;
import corpcom5.*;
import corpcom6.*;
import corpcom7.*;
import corpx1.*;
import corpx2.*;
import corpy2.*;
import corpz3.*;
import dg.common.*;
import fb.common.*;
import fk.common.*;
import fy.common.*;
import in1.common.*;
import ku.common.*;
import ob.common.*;
import op.common.*;
import pc.common.*;
import pg.common.*;
import sl.common.*;
import sm.common.*;
import sp.common.*;
import sy.common.*;
import ta.common.*;
import tf.common.*;
import ts.common.*;
import vv.common.*;
//*** PROGRAM=PC0R ****
// This program will bring up a list of P.O. based upon the
// selection criteria passed in through PC0Z. The database
// will return 0 to N rows based upon the selection criteria.
// The program will format the screen with the information
// returned from the data base.
// 
// This program will also allow changing and printing of P.O.'s
// by transferring them to another program with the row
// information selected.
// 
// A user can get detailed size information by pressing PF11.
// They can keep pressing PF11 until there are no more sizes
// to display. A messge will be displayed when they are on the
// last screen.
// 
// A user can select a row for maintenance and hit pf12. The
// user will then be transferred to PC0K where they can modify
// the information.  Pressing enter or PF3 will return them to
// the list screen in this application.
// 
// A user can print the selected rows by pressing PF20.  The
// user will then be transfered to PC0D where they can select
// the destination printer.  After they hit enter they will be
// returned to the list screen in this application.
// 
// A user can also inquire on special instructions or ship to
// information by pressing PF6 or PF14.
// 
// A user can also override ETAL by selecting a shipment row,
// enter a override date and pressing PF16.  They will then
// update the ETAL of all styles in the shipment with new
// override date(ETALO).
// ************************************************************
//     Program Modifications.
// ------------------------------------------------------------
// who     date     comments
// ------------------------------------------------------------
// mchris  8/31/90  added receiving status '13'
// lsutto  9/19/90  allow gpc 07
// chaert  3/05/91  a48 - use items owner group on apparel
//                  finished goods.
// DFRANC 10/15/91  transfer plan number and RTA date to PC0O
//                  if PF15 selected.
// DFRANC 10/30/91  Pass YMTCD to PCWREC if transfer to PC0O
// GAMEN  12/16/91  Remove ETLO and add S.O. in its place.
// chaert 04/03/92  If 2 SO's, intransits only fetched one.
//                  pc0r113
// lsutto  6/23/92  round b-grade price calc xspcs04
// sdifle 10/23/92  changed the logic of updating ETALO date.
//                  Instead of updating only one style, it will
//                  update all styles that have same shipment.
//                  (DTRANS.VCPLHD01.TS-ETAL-OVRD-DT)
//                  Modified : pc0r, pc0r162, pc0rs28, pc0rs29
//                             pcorw00
//                  Added    : pc0r163,pc0rs32, pc0rs33
//                             pc0rw00.wtuf
// KSANFO  4/28/93  Pass SO Number to PC0O in PCWREC.PCWUSER4.
// KSANFO  8/13/93  DB2 STRUCTURE CHANGE - add ts-nike-shp-id
//                  to vfypo001 and display with rcpt data.
// dhales  9/23/93  change to xspcs05 requires regen of appl
// dhales 10/22/93  added check in pc0r220 to verify that the
//                  index was in a valid range
// gamen  12/29/93  add theater of ops code.
// gamen  01/12/94  Add MSR indicator afre s.o. display on map1
// SLEWIS 09/14/94  BUG FIX: IF PLAN MISSING SET WPLN VAR TO 0
//                  IN PC0R222.
// KGRAHA 10/27/94  Change sales order to 9.3 digits.
// jniese 12/27/95  change working storgage size because msr
//                  was being truncated.  also changed  pgm to
//                  look up european SO's on VEORHD01.
// jniese 12/06/96  recompile to get new xspcs05.
// RDAYAL 02/12/97  PCF106 - INCREASED THE SIZE OF THE TOTAL
//                  QTY IN MAP AND RECORDS.
// RDAYAL 02/28/97  fixed the azi6 abend due to stock locate
//                  receipt # being zero for equipments
// DRAMSE 03/14/97  added the sign clause for total order qty
//                  field in PC0RM001 which was removed in the
//                  PCF106 fix.
// asunda 04/29/97  recompile to get new xspcs05.
// PHARWO 06/03/97  PCA367 - PPR PROJECT, PO VIEWS
// jniese 07/11/97  PCA367 - PPR corrections
// oricha 11/13/97  Y2K modifications:  added pc0rw00.pc0rwdcy
//                  element level for ccyy so calculation in
//                  pc0rs13 could accommodate century.
// DRAMSE 02/10/98  Changed to use VPRDCU03 instead of PC2REC
//                  Changed to call VPRDCU03 instead of IO3340
//                  Changed PC0R133,PC0R142,PC0RS04
// DRAMSE 02/13/98  Generated to get new XSPCS05 / XSPCS07
// drammo 06/10/98  PCF147 - Regen appln to get new
//                  XSPCS05 & XSPCS06 which are changed to
//                  include ST po type in ETAL calculation
// rvempa 11/13/98  Fixed the truncation of shipid in map2.
// KGRAHA 04/23/99  Regen to get new XSPCS05 which now does
//                  not include 'BA' in ETAL calculation.
// vsanka 09/24/99  regenerated due to changes to xspcs05.
// SBUNGO 02/07/00  CHANGED TO USE VIEW VFCTY003
// RSELVA 08/02/00  Modified XSPCS05 for zeroing out of MADD
//                  from 20001012 onwards
// RMURTH 12/21/00  Compiled for change in SGRP XSPCS07
// *                   XSPCS07 modified to have hardcoded PADD
// *                   for WHSE '51' and Origin USA for GPC 03
// AVERMA 03/05/01  Changed to display SAP number on pf18key.
//                  changed from VPOIMT03 to VPOITM05.
// spitch 12/26/01  Disabled PF20
// *********************
Program PC0R type textUIProgram //VAGen Info - main text program
  {
  includeReferencedFunctions = yes, allowUnqualifiedItemReferences = yes, 
  throwNrfEofExceptions = yes, handleHardIOErrors = no, V60ExceptionCompatibility = yes, 
  I4GLItemsNullable = no, textLiteralDefaultIsString = no, localSQLScope = yes, 
  msgTablePrefix = "PC00", inputRecord = COMMAREA, segmented = yes
  }

  // Data Declarations
  COMMAREA COMMAREA ; // record
  ERRSQLCA ERRSQLCA; // record
  FY4REC FY4REC; // record
  FYCREC FYCREC; // record
  OP1REC OP1REC; // record
  PC0RW00 PC0RW00; // record
  PC0RW01 PC0RW01; // record
  PC0RW02 PC0RW02; // record
  PC0RW03 PC0RW03; // record
  PC0RW04 PC0RW04; // record
  PC0RW05 PC0RW05; // record
  PC0RW06 PC0RW06; // record
  PC0RW07 PC0RW07; // record
  PC0RW08 PC0RW08; // record
  PC0RW09 PC0RW09; // record
  PC0RW10 PC0RW10; // record
  PC0RW11 PC0RW11; // record
  PC0RW12 PC0RW12; // record
  PC0RW13 PC0RW13; // record
  PC0RW14 PC0RW14; // record
  PC0RW15 PC0RW15; // record
  PC0RW16 PC0RW16; // record
  PC0RW17 PC0RW17; // record
  PC0RW18 PC0RW18; // record
  PC0RW20 PC0RW20; // record
  PC0RW21 PC0RW21; // record
  PC0RW23 PC0RW23; // record
  PCOREC PCOREC; // record
  PCPREC PCPREC; // record
  PCWREC PCWREC; // record
  PCYREC PCYREC; // record
  PG2REC PG2REC; // record
  PG3REC PG3REC; // record
  SQLCA SQLCA; // record
  TA1REC TA1REC; // record
  TA2REC TA2REC; // record
  TA5REC TA5REC; // record
  TA6REC TA6REC; // record
  TAEREC TAEREC; // record
  TSEREC TSEREC; // record
  TSFREC TSFREC; // record
  TSHREC TSHREC; // record
  TSIREC TSIREC; // record
  TSOREC TSOREC; // record
  TSTREC TSTREC; // record
  VFCTY003 VFCTY003; // record
  VFYPO002 VFYPO002; // record
  VPOHDR02 VPOHDR02; // record
  VPOITM05 VPOITM05; // record
  VPOSIZ02 VPOSIZ02; // record
  VPRDCU03 VPRDCU03; // record
  XCTHREC XCTHREC; // record
  XX0XW01 XX0XW01; // record

  // VAGen Info - items needed for migration
  VAGen_EZESYS char(8);
  VAGen_EZEREPLY num(1);
  VAGen_EZE_WAIT_TIME bin(9,2);
  VAGen_EZE_ITEMLEN int;

  // Use Declarations
  use XWHTBL {deleteAfterUse = yes}; // table
  use PC0RT01 {deleteAfterUse = yes}; // table
  use PC0RT11 {deleteAfterUse = yes}; // table
  use PC0RM.PC0RM001,  // forms
      PC0RM.PC0RM002
   {
    pfKeyEquate = no
  };

  function main()
    // VAGen Info - initialization needed for migration
    VAGen_EZESYS = VGLib.getVAGSysType();
    XPPC001: XPPC001();
    goto PC0R001;
    PC0R001: PC0R001();
    goto PC0R002;
    PC0R002: PC0R002();
    goto PC0R002;
  end // end main
end // end PC0R

// Special initialization
Function PC0R001()

  PC0RM001.XXXPRCNM = "PC0R";
  PC0RM002.XXXPRCNM = "PC0R";
   /* ---------------------------------------------------------*/
   /* If entry is from any aplication other the the ones*/
   /* listed below it is an error and a message should be*/
   /* sent to PC0A.*/
   /* ---------------------------------------------------------*/

  if (COMMAREA.CAFROMAP == "PC0Z"
   || COMMAREA.CAFROMAP == "PC06"
   || COMMAREA.CAFROMAP == "PC0S"
   || COMMAREA.CAFROMAP == "PC0M"
   || COMMAREA.CAFROMAP == "PC0I"
   || COMMAREA.CAFROMAP == "PC05"
   || COMMAREA.CAFROMAP == "PC0K"
   || COMMAREA.CAFROMAP == "PC0O"
   || COMMAREA.CAFROMAP == "PB0I")
     /* next sentence*/
  else
    COMMAREA.CAITEM = " ";
    set PCWREC empty;
    PCWREC.XXXMSGNO = 191;
    COMMAREA.CAUSERA = PCWREC.CAUSERA;
    COMMAREA.CATOAP = "PC0A"; /* Return to menu*/
    XSEXIT();
    PC0RM001.XXXPRCNM = "PC0R001";
  end
   /* ---------------------------------------------------------*/
   /* If no keys were passed in the pcwrec then exit the*/
   /* application and return to the PO Menu (PC0A).*/
   /* If keys were passed then set the passed data index to 1*/
   /* ---------------------------------------------------------*/

  if (PCWREC.PCWWHSE[1] == " "
   && PCWREC.PCWCUST[1] == " ")
    COMMAREA.CAITEM = " ";
    PCWREC.XXXMSGNO = 18; /* No data to display*/
    COMMAREA.CAUSERA = PCWREC.CAUSERA;
    COMMAREA.CATOAP = "PC0A"; /* Return to menu*/
    XSEXIT();
    PC0RM001.XXXPRCNM = "PC0R001";
  end

   /* ---------------------------------------------------------*/
   /* Check commarea security fields.*/
   /* ---------------------------------------------------------*/

  if (PCWREC.XGPCD == "01"
   && COMMAREA.CAILVL[1] != "Y")
    COMMAREA.CAITEM = " ";
    PCWREC.XXXMSGNO = 138; /* Security violation*/
    COMMAREA.CAUSERA = PCWREC.CAUSERA;
    COMMAREA.CATOAP = "PC0A"; /* Return to menu*/
    XSEXIT();
    PC0RM001.XXXPRCNM = "PC0R001";
  end

  if (PCWREC.XGPCD == "02"
   && COMMAREA.CAILVL[2] != "Y")
    COMMAREA.CAITEM = " ";
    PCWREC.XXXMSGNO = 138;
    COMMAREA.CAUSERA = PCWREC.CAUSERA;
    COMMAREA.CATOAP = "PC0A"; /* Return to menu*/
    XSEXIT();
    PC0RM001.XXXPRCNM = "PC0R001";
  end

  if (PCWREC.XGPCD == "03"
   && COMMAREA.CAILVL[3] != "Y")
    COMMAREA.CAITEM = " ";
    PCWREC.XXXMSGNO = 138;
    COMMAREA.CAUSERA = PCWREC.CAUSERA;
    COMMAREA.CATOAP = "PC0A"; /* Return to menu*/
    XSEXIT();
    PC0RM001.XXXPRCNM = "PC0R001";
  end

  if (PCWREC.XGPCD == "07"
   && COMMAREA.CAILVL[7] != "Y")
    COMMAREA.CAITEM = " ";
    PCWREC.XXXMSGNO = 138;
    COMMAREA.CAUSERA = PCWREC.CAUSERA;
    COMMAREA.CATOAP = "PC0A"; /* Return to menu*/
    XSEXIT();
    PC0RM001.XXXPRCNM = "PC0R001";
  end



   /* ---------------------------------------------------------*/
   /* Initialize the work record and the map storage record*/
   /* Set Map flag to display map 1 and obtain data flag to*/
   /* yes.*/
   /* ---------------------------------------------------------*/

  set PC0RW00 empty; /* Working storage record*/
  set PC0RW01 empty; /* Map storage for map heading data*/
  set PC0RW02 empty; /* Map storage for map2 heading data*/
  set PC0RW09 empty; /* Temporary storage record*/
  set PC0RW21 empty;

  set PC0RM001 empty;
  set PC0RM002 empty;

  set SQLCA empty;
  set TAEREC empty; /* Error diagnosis information*/
  set TA1REC empty; /* Error diagnosis parameters*/
   /* SET XX0XW01 EMPTY;*/
   /* 14 rows * 253 bytes + 4 char length field = 3546 tsl length.*/
  PC0RW00.PC0RWTSL = 3546; /* Temporary storage page length*/
  PC0RW00.PC0RWMAX = 14; /* Max lines per map page*/
  PC0RW00.PC0RWMXJ = 350; /* Max JCL DD* allowed*/

   /* ---------------------------------------------------------*/
   /* Check commarea security fields for ETAL override*/
   /* update security.*/
   /* ---------------------------------------------------------*/

  if (PCWREC.XGPCD == "01"
   && COMMAREA.CAILVL[9] != "Y")
    PC0RW00.PC0RWPDF = "Y"; /* Protect date flag*/
    set PC0RM001.PC0RMETO skip, invisible;
  else
    if (PCWREC.XGPCD == "02"
     && COMMAREA.CAILVL[9] != "Y")
      PC0RW00.PC0RWPDF = "Y"; /* Protect date flag*/
      set PC0RM001.PC0RMETO skip, invisible;
    else
      if (PCWREC.XGPCD == "03"
       && COMMAREA.CAILVL[9] != "Y")
        PC0RW00.PC0RWPDF = "Y"; /* Protect date flag*/
        set PC0RM001.PC0RMETO skip, invisible;
      else
        if (PCWREC.XGPCD == "07"
         && COMMAREA.CAILVL[9] != "Y")
          PC0RW00.PC0RWPDF = "Y"; /* Protect date flag*/
          set PC0RM001.PC0RMETO skip, invisible;
        end
      end
    end
  end

   /* ---------------------------------------------------------*/
   /* Save the initial calling application ID in the*/
   /* PC0RREC(on PF3 or PF19) Pc0r will return to the*/
   /* application that called it.  However PC0R can in turn*/
   /* call other applications.*/
   /* ---------------------------------------------------------*/


  if (COMMAREA.CAFROMAP == "PC0Z"
   || COMMAREA.CAFROMAP == "PC06"
   || COMMAREA.CAFROMAP == "PC0S"
   || COMMAREA.CAFROMAP == "PB0I"
   || COMMAREA.CAFROMAP == "PC0M")

    set PC0RW10 empty;

    PC0RW10.CAFROMAP = COMMAREA.CAFROMAP;
  end

   /* ---------------------------------------------------------*/
   /* When returning  from called applications the screen should*/
   /* be restored to the destination and temporary storage*/
   /* page that was displayed prior to the call.*/
   /* ---------------------------------------------------------*/

  PC0RW00.PC0RWODF = "Y"; /* Obtain data flag*/
  PC0RW00.PC0RWSRF = "1"; /* Screen request flag*/
  PC0RW00.PC0RWDTF = "2"; /* S.O number to be displayed*/

  if (COMMAREA.CAFROMAP == "PC0I"
   || COMMAREA.CAFROMAP == "PC05"
   || COMMAREA.CAFROMAP == "PC0K"
   || COMMAREA.CAFROMAP == "PC0O")
    if (PCWREC.CAFROMAP[1] == "PC0R")
      PC0RW10.PC0RWUSR = PCWREC.PCWUSER1;
      PCWREC.CAFROMAP[1] = " ";
      PC0RW00.PC0RWIXP = PC0RW10.PC0RWIXS;
      PC0RW00.PC0RWTSP = PC0RW10.PC0RWTSP;

    else
      if (PCWREC.CAFROMAP[2] == "PC0R")
        PC0RW10.PC0RWUSR = PCWREC.PCWUSER2;
        PCWREC.CAFROMAP[2] = " ";
        PC0RW00.PC0RWIXP = PC0RW10.PC0RWIXS;
        PC0RW00.PC0RWTSP = PC0RW10.PC0RWTSP;

      else
        if (PCWREC.CAFROMAP[3] == "PC0R ")
          PC0RW10.PC0RWUSR = PCWREC.PCWUSER3;
          PCWREC.CAFROMAP[3] = " ";
          PC0RW00.PC0RWIXP = PC0RW10.PC0RWIXS;
          PC0RW00.PC0RWTSP = PC0RW10.PC0RWTSP;
        else
          if (PCWREC.CAFROMAP[4] == "PC0R ")
            PC0RW10.PC0RWUSR = PCWREC.PCWUSER4;
            PCWREC.CAFROMAP[4] = " ";
            PC0RW00.PC0RWIXP = PC0RW10.PC0RWIXS;
            PC0RW00.PC0RWTSP = PC0RW10.PC0RWTSP;
          end

        end
      end
    end
  else
    PC0RW00.PC0RWIXP = 1; /* PCWREC parameter index*/
    PC0RW00.PC0RWTSP = 1; /* Temp storage page request*/
  end

  PC0RW01.PC0RWFRD = PC0RW00.PC0RWIXP;

  PC0RW00.PC0RWIX2 = 1;

  while (PC0RW00.PC0RWIX2 <= 10)
    PC0RW00.PC0RWIX3 = PC0RW00.PC0RWIX2;
    if (PCWREC.PCWWHSE[PC0RWIX2] == " "
     && PCWREC.PCWCUST[PC0RWIX2] == " ")
      PC0RW00.PC0RWIX2 = 11;
    end
    PC0RW00.PC0RWIX2 = PC0RW00.PC0RWIX2 + 1;
  end

  PC0RW00.PC0RWIX3 = PC0RW00.PC0RWIX3 - 1;

  PC0RW01.PC0RWTOD = PC0RW00.PC0RWIX3;

   /* obtain the po header--need the create date*/
   /* for obtaining the prices*/

  PC0RS26();

   /* ------------------------------------------------------------*/
      /* CALL SUB-ROUTINE TO FIND WHICH ENVIRONMENT*/
      /* THE PROGRAM IS EXECUTING IN, DEVELOPMENT*/
      /* OR PRODUCTION.*/
   /* ------------------------------------------------------------*/
  set XCTHREC empty;
  call "XC0910" (XCTHREC) {isNoRefresh = yes, isExternal = yes};

  if (XCTHREC.XCTH-THEATER-RUNTYPE == " ")

    PC0RM001.XXXPRCNM = "PC0R001"; /* module identification*/
    converseLib.validationFailed(8); /* Error encountered with print request*/
    exit stack;
  end

end // end PC0R001

// P.O. ID Inquiry-detail
Function PC0R002()
   /* ------------------------------------------------------------*/
   /* This is the main process used to display a map.  Processing*/
   /* always returns to the top of this process and falls through*/
   /* subordinate processes until an error is found or a valid*/
   /* request is processed.  Processing sequence is as follows:*/

   /* 1) If specified display the first map*/
   /* 2) Otherwise, display the second map*/
   /* 3) Otherwise incidate an error and exit to menu*/

   /* In all subordinate processes, "EZEFLO" is used to exit to*/
   /* redisplay the map when an error is found.  This is done to*/
   /* minimize the coding effort required to skip subsequent*/
   /* processing under error conditions.*/
   /* ------------------------------------------------------------*/

  if (PC0RW00.PC0RWSRF == "1") /* Map one requested*/
    PC0R100(); /* Map one processing*/
  else
    if (PC0RW00.PC0RWSRF == "2") /* Map two requested*/
      PC0R200(); /* Map two processing*/
    else

      /* ------------------------------------------------------------*/
       /* Write the error to the Error Diagnosis Reporting Facility.*/
      /* ------------------------------------------------------------*/

      PC0RW00.XXXMSGNO = 10; /* Indicate system error*/
      PC0RM001.XXXPRCNM = "PC0R001"; /* Procedure name*/

      TA1REC.TA1FUNC = "RETN"; /* Termination function*/
      TA1REC.TA1TYPE = "APPL"; /* Type of error*/
      TA1REC.TA1LOC = "INVALID MAP NUMBER WAS REQUESTED";
      TA1REC.TA1MAPNO = PC0RW00.PC0RWSRF; /* Map number*/
      TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
      TA1REC.TA1PGMNO = PC0RM001.XXXPRCNM; /* Program number*/

      call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

      /* ------------------------------------------------------------*/
       /* Exit to display the application system menu.*/
      /* ------------------------------------------------------------*/

      COMMAREA.CATOAP = "PC0A"; /* TO application*/

      XSPCS01(); /* Exit to another application*/

      /* ------------------------------------------------------------*/
       /* Abnormally terminate the transaction if the exit failed.*/
      /* ------------------------------------------------------------*/

      TA1REC.TA1FUNC = "ABND"; /* Termination function*/

      call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

    end

  end


end // end PC0R002

// Map 1 processing
Function PC0R100()
   /* ------------------------------------------------------------*/
   /* This is the main process used to display a map.  Processing*/
   /* always returns to the top of this process and falls through*/
   /* subordinate processes until an error is found or a valid*/
   /* request is processed.  Processing sequence is as follows:*/

   /* 1) Obtain data to disply*/
   /* 2) Format the map output area and display the map.*/
   /* 3) Check the attention identifier used to respond.*/
   /* 4) Reset highlighted fields to normal intensity.*/
   /* 5) Verify the data that was entered.*/
   /* 6) Process a valid input request.*/

   /* In all subordinate processes, "EZEFLO" is used to exit to*/
   /* redisplay the map when an error is found.  This is done to*/
   /* minimize the coding effort required to skip subsequent*/
   /* processing under error conditions.*/
   /* ------------------------------------------------------------*/


  PC0R110(); /* Obtain data to display*/

  PC0R120(); /* Format and display the map*/

  PC0R130(); /* Check attention identifier*/

  PC0R140(); /* Reset fields to normal intensity*/

  PC0R150(); /* Verify the entered data*/

  PC0R160(); /* Process valid input request*/

end // end PC0R100

// Obtain data to display
Function PC0R110()

  PC0RW00.PC0RWTRC = 0;
  PC0RW00.PC0RWTSH = 0;
  PC0RW00.PC0RWTOR = 0;


   /* ------------------------------------------------------------*/
   /* If an error was found or data not requested return to*/
   /* previous process.*/
   /* ------------------------------------------------------------*/

  if (PC0RW00.PC0RWODF == "N" /* Data not requested*/
   || converseVar.validationMsgNum != 0) /* Error found*/
    return;
  end


  PC0R111(); /* Purge temporary storage*/

   /* ------------------------------------------------------------*/
   /* Obtain the item size and related data and format the*/
   /* the data lines to the temporary storage page record.*/
   /* ------------------------------------------------------------*/


  PC0R112(); /* Obtain item size data*/


   /* ------------------------------------------------------------*/
   /* Obtain the intransit data and related size data and format*/
   /* the data lines to the temporary storage page record.*/
   /* ------------------------------------------------------------*/

  PC0R113(); /* Obtain Intransit (shipped) data*/

   /* ------------------------------------------------------------*/
   /* Obtain the received data and related size data and format*/
   /* the data lines to the temporary storage page record.*/
   /* ------------------------------------------------------------*/

  PC0R114(); /* Obtain Received data*/

   /* Set the obtain data flag to 'n'*/

  PC0RW00.PC0RWODF = "N"; /* Obtain data flag*/

  if (PC0RW00.TA5TSQIX == 0) /* No temp storage page written*/
    if (PC0RW00.PC0RWIXT == 0) /* No detail line formatted*/
      converseLib.validationFailed(18); /* Indicate no data to display*/
      exit stack; /* Display error message*/
    end
  end

   /* ------------------------------------------------------------*/
   /* Detail has been created--create the balance to ship*/
   /* total record.*/
   /* ------------------------------------------------------------*/


  PC0R115(); /* Create balance to ship record*/

  if (PC0RW00.PC0RWIXT != 0) /* Write partial page to temp storage*/
    PC0RS05(); /* Add to temp storage*/
  end


end // end PC0R110

// Purge temporary storage
Function PC0R111()
   /* ------------------------------------------------------------*/
   /* Initialize the storage areas and indicators to be used.*/
   /* ------------------------------------------------------------*/

  set PC0RW09 empty; /* Map temporary storage page*/
  set TA5REC empty; /* temporary storage record*/


  PC0RW00.TA5TSQIX = 0; /* Highest page number*/
  PC0RW00.PC0RWIXT = 0; /* temporary storage line index*/

   /* ------------------------------------------------------------*/
   /* Purge any temporary storage for this application.*/
   /* ------------------------------------------------------------*/

  TA5REC.TA5APPID = COMMAREA.CACURRAP; /* Application identification*/
  TA5REC.TA5FNCCD = "P"; /* Function code*/

  try
    call "TA0050" (PC0RW09, TA5REC) {isNoRefresh = yes, isExternal = yes};
  end /* Temporary storage*/

   /* ------------------------------------------------------------*/
   /* If successful, return to previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && TA5REC.TA5RTNCD == 0)          /* and normal return code*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that a system error occurred.*/
   /* ------------------------------------------------------------*/

  TAEREC.TAEDESC1 = sysVar.errorCode; /* CSP return code*/
  TAEREC.TAEDESC2 = TA5REC.TA5DATA; /* Subroutine parameters*/

  PC0RM001.XXXPRCNM = "PC0R111"; /* Module identification*/
  converseLib.validationFailed(01); /* Indicate system error*/

  TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  TA1REC.TA1TYPE = "APPL"; /* Type of error*/
  TA1REC.TA1LOC = "PURGE ANY TEMPORARY STORAGE";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = PC0RM001.XXXPRCNM; /* Program number*/
  TA1REC.TA1MAPAP = COMMAREA.CACURRAP; /* Map application*/
  TA1REC.TA1MAPNO = "M001"; /* Map number*/

  call "TA0020" (TA1REC, SQLCA) {isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end PC0R111

// Get all item and size data
Function PC0R112()

  set VPOITM05 empty;
  set PCYREC empty;
  PCYREC.PCYFUNC = "S8";

   /* ------------------------------------------------------------*/
   /* Move the destination data from the PCWREC array to the*/
   /* heading fields (warehouse and customer xref)*/
   /* ------------------------------------------------------------*/

  PC0RW01.XWHCD = PCWREC.PCWWHSE[PC0RWIXP];
  PC0RW01.PC2CUXID = PCWREC.PCWCUST[PC0RWIXP];
  VPOITM05.XWHCD = PCWREC.PCWWHSE[PC0RWIXP];
  VPOITM05.PC2CUXID = PCWREC.PCWCUST[PC0RWIXP];

   /* ------------------------------------------------------------*/
   /* Load data from the PCWREC to the VPOITM05. Based upon the*/
   /* current index value use the destination data from the*/
   /* array in the pcwrec.*/
   /* ------------------------------------------------------------*/

  VPOITM05.XGPCD = PCWREC.XGPCD; /* GPC code*/
  VPOITM05.PO-REG-CD = PCWREC.PO-REG-CD;
  VPOITM05.PC3PONBR = PCWREC.PC3PONBR;
  if (PCWREC.SY1STNBR == " ")
    VPOITM05.SY1STNBR = "*";
  else
    VPOITM05.SY1STNBR = PCWREC.SY1STNBR;
  end

  if (PCWREC.SY2CLRID == " ")
    VPOITM05.SY2CLRID = "*";
  else
    VPOITM05.SY2CLRID = PCWREC.SY2CLRID;
  end

  if (PCWREC.XDMCD == " ")
    VPOITM05.XDMCD = "*";
  else
    VPOITM05.XDMCD = PCWREC.XDMCD;
  end

  if (PCWREC.XQACD == " ")
    VPOITM05.XQACD = "*";
  else
    VPOITM05.XQACD = PCWREC.XQACD;
  end

  if (PCWREC.XOWCD == " ")
    VPOITM05.XOWCD = "*";
  else
    VPOITM05.XOWCD = PCWREC.XOWCD;
  end

  VPOITM05.PC2INSEG = "*";

  if (PCWREC.XPGCD == " ")
    VPOITM05.XPGCD = "*";
  else
    VPOITM05.XPGCD = PCWREC.XPGCD;
  end

  if (PCWREC.XUMCD == " ")
    VPOITM05.XUMCD = "*";
  else
    VPOITM05.XUMCD = PCWREC.XUMCD;
  end

  VPOITM05.PC6ETSDT = -1;

  VPOITM05.YMTCD = "*";

  VPOITM05.PC6PLAN = -1;

  VPOITM05.XDSCD = "*";

  VPOITM05.YSMXDV = "*";

  PC0R123(); /* Open item cursor*/

   /* ------------------------------------------------------------*/
   /* If there are item rows-retrieve all items for the*/
   /* destination.*/
   /* ------------------------------------------------------------*/

  PC0RS01(); /* Fetch first item row*/
  while (VPOITM05.PC6STAT == "CX" /* While cancelled items*/
   && PC0RW00.PC0RWICF != "Y") /* and more items exist*/
    PC0RS01(); /* Fetch next item row*/
  end

  if (PC0RW00.PC0RWICF != "Y")
    /* ---------------------------------------------------------*/
     /* Move the map heading data from the VPOITM05 to*/
     /* the map storage fields.*/
    /* ---------------------------------------------------------*/

    PC0RW00.PC0RWFDT = VPOITM05.PC3POIDT; /* PO ID to working storage*/

    if (PCWREC.XGPCD == "03") /* Apparel*/
      PC0RW00.PC0RWSYR = VPOITM05.PCFSECD; /* Use the season code*/
    else
      PC0RW00.PC0RWSYR = PC0RW00.PC0RWFYY; /* Use the PO ID year*/
    end

    PC0RW00.PC0RWPMO = PC0RW00.PC0RWFMM; /* Production month*/
    PC0RW00.PC0RWDMO = PC0RW00.PC0RWFDD; /* Delivery month*/
    PC0RW00.FY1FCTYC = VPOITM05.FY1FCTYC; /* Factory code*/
    PC0RW00.PC0RWDH1 = "-";
    PC0RW00.PC0RWDH2 = "-";
    PC0RW00.PC0RWDH3 = "-";

    PC0RW01.PC0RWPID = PC0RW00.PC0RWPID;
    PC0RW01.PO-REG-CD = VPOITM05.PO-REG-CD; /* PO REGION CODE*/
    PC0RW01.PC3PONBR = VPOITM05.PC3PONBR; /* PO number*/
    PC0RW01.XGPCD = VPOITM05.XGPCD;
    PC0RW01.SY1STNBR = VPOITM05.SY1STNBR;
    PC0RW01.SY2CLRID = VPOITM05.SY2CLRID;
    PC0RW01.PC4ORTYP = VPOITM05.PC4ORTYP;
    PC0RW01.XDMCD = VPOITM05.XDMCD;
    PC0RW01.XQACD = VPOITM05.XQACD;
    PC0RW01.PC2INSEG = VPOITM05.PC2INSEG;
    PC0RW01.XPGCD = VPOITM05.XPGCD;
    PC0RW01.XUMCD = VPOITM05.XUMCD;
    PC0RW01.YMTCD = VPOITM05.YMTCD;

    set PG2REC empty; /* Initialize style color record*/

    PG2REC.XGPCD = VPOITM05.XGPCD;
    PG2REC.SY1STNBR = VPOITM05.SY1STNBR;
    PG2REC.SY2CLRID = VPOITM05.SY2CLRID;
    PG2REC.XDMCD = VPOITM05.XDMCD;

    XSPG202();

    if (SQLCA.VAGen_SQLCODE == 0)
      PC0RW01.SY1STYNM = PG2REC.SY1STYNM;
      PC0RW01.SY2CLRAB = PG2REC.SY2CLRAB;
    end
  end


  if (PC0RW00.PC0RWICF != "Y"
   && COMMAREA.CAILVL[10] == "Y")
      /* obtain the FOB price*/

    set PCOREC empty;

    PCOREC.XGPCD = VPOITM05.XGPCD;
    PCOREC.FY1FCTYC = VPOITM05.FY1FCTYC;
    PCOREC.SY1STNBR = VPOITM05.SY1STNBR;
    PCOREC.SY2CLRID = VPOITM05.SY2CLRID;
    PCOREC.XDMCD = VPOITM05.XDMCD;
    PCOREC.XQACD = VPOITM05.XQACD;
    PCOREC.PC2INSEG = VPOITM05.PC2INSEG;
    PCOREC.XUMCD = VPOITM05.XUMCD;
    PCOREC.XPGCD = VPOITM05.XPGCD;
    PCOREC.XSECD = VPOHDR02.XSECD;
    PCOREC.PC3POIDT = VPOITM05.PC3POIDT;
    PCOREC.PC3CRDT = VPOHDR02.PC3CRDT;

    XSPCS04(); /* Get fob prices*/

    /* ------------------------------------------------------------*/
     /* Load the FOB prices to storage*/
    /* ------------------------------------------------------------*/

    PC0RW00.PC0RWIX1 = 1;

    while (PC0RW00.PC0RWIX1 <= 40)

      PC0RW00.FY4FOBPR[PC0RWIX1] = PCOREC.FY4FOBPR[PC0RWIX1];
      PC0RW00.PC0RWIX1 = PC0RW00.PC0RWIX1 + 1;
    end
  end


  PC0RW00.PC0RWIXT = 0; /* Initialize data line indexd*/

  while (PC0RW00.PC0RWICF != "Y")

    PC0R124(); /* Process all items*/

  end

  PC0R125(); /* Close item cursor*/

  if (PC0RW00.PC0RWIXT > 1 /* Temporary storage index > 1*/
   || PC0RW00.TA5TSQIX > 0) /* Or page written*/

    PC0R126(); /* Create on order total qty line*/

  end

end // end PC0R112

// Obtain intransit(shipped) data
Function PC0R113()



   /* ------------------------------------------------------------*/
   /* Load data from the PCWREC to the TSTREC. Based upon the*/
   /* current index value use the destination data from the*/
   /* array in the PCWREC.*/
   /* ------------------------------------------------------------*/

  set TSTREC empty;

  TSTREC.XGPCD = VPOITM05.XGPCD;
  TSTREC.PC3PONBR = VPOITM05.PC3PONBR; /* PO number*/
  TSTREC.SY1STNBR = VPOITM05.SY1STNBR; /* Style number*/
  TSTREC.SY2CLRID = VPOITM05.SY2CLRID; /* Color code*/
  TSTREC.XDMCD = VPOITM05.XDMCD; /* Dimension code*/
  TSTREC.XOWCD = VPOITM05.XOWCD; /* Owner group code*/
  TSTREC.PC2INSEG = VPOITM05.PC2INSEG; /* Spec code*/
  TSTREC.XQACD = VPOITM05.XQACD; /* Quality code*/
  TSTREC.XPGCD = VPOITM05.XPGCD; /* Package code*/
  TSTREC.XUMCD = VPOITM05.XUMCD; /* Unit of measure*/
   /* move PC6REC.OP1PARTN TO TSTREC.OP1PARTN;/* Part char*/
   /* MOVE PC6REC.OP1CUOID TO TSTREC.OP1CUOID;/* Cust order nbr*/
   /* MOVE PC6REC.OP1NORID TO TSTREC.OP1NORID;/* Nike order nbr*/
  TSTREC.OP1PARTN = "*"; /* Part char*/
  TSTREC.OP1CUOID = -1; /* Cust order nbr*/
  TSTREC.OP1NORID = -1; /* Nike order nbr*/

   /* Destination data*/

  TSTREC.XWHCD = PCWREC.PCWWHSE[PC0RWIXP];
  TSTREC.PC2CUXID = PCWREC.PCWCUST[PC0RWIXP];


  PC0R132(); /* Open ship header/container table*/

   /* ------------------------------------------------------------*/
   /* If there are shipping rows-retrieve all rows from the*/
   /* transporation header/container table.*/
   /* ------------------------------------------------------------*/

  PC0RW00.PC0RWSDF = "N"; /* set shipping data flag to no.*/

  PC0RS06(); /* Fetch first Transporation row*/



  while (PC0RW00.PC0RWTCF != "Y")

    PC0R133(); /* Process all transporations rows*/

  end

  PC0R134(); /* Close Transporation cursor*/

  if (PC0RW00.PC0RWSDF == "Y") /* Shipping data exists*/

    PC0R135(); /* Create Intransit total*/

  end

end // end PC0R113

// Obtain received data
Function PC0R114()



   /* ------------------------------------------------------------*/
   /* Load data from the PCWREC to the VFYPO002.*/
   /* ------------------------------------------------------------*/

  set VFYPO002 empty;

  VFYPO002.XGPCD = VPOITM05.XGPCD;
  VFYPO002.PO-REG-CD = VPOITM05.PO-REG-CD; /* PO REGION CODE*/
  VFYPO002.PC3PONBR = VPOITM05.PC3PONBR; /* PO number*/
  VFYPO002.SY1STNBR = VPOITM05.SY1STNBR; /* Style number*/
  VFYPO002.SY2CLRID = VPOITM05.SY2CLRID; /* Color code*/
  VFYPO002.XDMCD = VPOITM05.XDMCD; /* Dimension code*/
  VFYPO002.PC2INSEG = VPOITM05.PC2INSEG; /* Spec code*/
  VFYPO002.XPGCD = VPOITM05.XPGCD; /* Package code*/
  VFYPO002.XUMCD = VPOITM05.XUMCD; /* Unit of measure*/
  VFYPO002.XQACD = VPOITM05.XQACD; /* Unit of measure*/
  VFYPO002.XWHCD = PCWREC.PCWWHSE[PC0RWIXP]; /* warehouse code*/
  VFYPO002.PC2CUXID = PCWREC.PCWCUST[PC0RWIXP]; /* Customer code*/
  VFYPO002.YMTCD = "*"; /* Mode code*/

  VFYPO002.XOWCD = "*"; /* Owner group code*/
  if (VPOITM05.XWHCD == "09") /* if promo warehouse*/
        /* leave OG = '*'*/
  else
    if (VPOITM05.XGPCD == "03") /* if apparel*/
      set PG2REC empty;
      PG2REC.XGPCD = VPOITM05.XGPCD;
      PG2REC.SY1STNBR = VPOITM05.SY1STNBR; /* Style number*/
      PG2REC.SY2CLRID = VPOITM05.SY2CLRID; /* Color code*/
      PG2REC.XDMCD = VPOITM05.XDMCD; /* Dimension code*/
      XSPG202();
      if (PG2REC.XFMCD == "21" /* if finished good*/
       || PG2REC.SY1BSTNB > " ")
        VFYPO002.XOWCD = VPOITM05.XOWCD; /* Owner group code*/
      end
    end
  end

  PC0R141(); /* Open received table.*/

   /* ------------------------------------------------------------*/
   /* Retrieve all rows from the received table.*/
   /* ------------------------------------------------------------*/

  PC0RW00.PC0RWRDF = "N"; /* set Received data flag to no.*/

  PC0RS24(); /* Fetch first Received row*/



  while (PC0RW00.PC0RWRCF != "Y") /* Cursor not at end*/


    PC0R142(); /* Process all received rows*/

  end

  PC0R143(); /* Close received cursor*/

  if (PC0RW00.PC0RWRDF == "Y") /* Received data exists*/

    PC0R144(); /* Create received total*/

  end

end // end PC0R114

// Create Balance to ship line
Function PC0R115()
   /* ------------------------------------------------------------*/
   /* Need to write out one blank temp storage line---there*/
   /* is a blank line between the last line and the balance*/
   /* to ship line.*/
   /* ------------------------------------------------------------*/

   /* Increment temp storage line index*/

  PC0RW00.PC0RWIXT = PC0RW00.PC0RWIXT + 1;

  set PC0RW08 empty; /* Initialize record*/
  PC0RW08.PC0RW08K = 99; /* Indicate type of record*/
  PC0RW09.PC0RW09R[PC0RWIXT] = PC0RW08.PC0RW08G;

  if (PC0RW00.PC0RWIXT == PC0RW00.PC0RWMAX) /* Max ines (13)*/

    PC0RS05(); /* Add page to temp storage*/

  end

   /* Increment temp storage line index*/

  PC0RW00.PC0RWIXT = PC0RW00.PC0RWIXT + 1;

  set PC0RW08 empty; /* Initialize record*/

  PC0RW08.PC0RW08L = "BALANCE TO SHIP:"; /* Total line literal*/

   /* Balance to ship = planned - ( shipped + received)*/
   /* Print 0 if the balance to ship is a negative*/

  PC0RW00.PC0RWWSZ = 0; /* Work field*/
  PC0RW00.PC0RWWSZ = PC0RW00.PC0RWWSZ + PC0RW00.PC0RWTSH; /* + shipped*/
  PC0RW00.PC0RWWSZ = PC0RW00.PC0RWWSZ + PC0RW00.PC0RWTRC; /* + received*/
  PC0RW08.PC0RWQTY = PC0RW00.PC0RWTOR - PC0RW00.PC0RWWSZ;

  if (PC0RW00.PC0RWWSZ == 0) /* If balance to ship = total on order*/
    return; /* do not print balance to ship line*/
  end

  PC0RW00.PC0RWIX1 = 1; /* Initialize general index*/

  while (PC0RW00.PC0RWIX1 <= 40)
    if (PC0RW00.PC0RWPZQ[PC0RWIX1] != 0 /* If planned qty or*/
     || PC0RW00.PC0RWSZQ[PC0RWIX1] != 0 /* Shipping qty or*/
     || PC0RW00.PC0RWRZQ[PC0RWIX1] != 0) /* receiving qty*/

       /* Balance to ship = planned - ( shipped + received)*/
       /* Print 0 if the balance to ship is a negative*/

      PC0RW00.PC0RWWSZ = 0; /* Work field*/
      /* Add shipping qty to work field*/
      PC0RW00.PC0RWWSZ = PC0RW00.PC0RWWSZ + PC0RW00.PC0RWSZQ[PC0RWIX1];
      /* Add receiving qty to work field*/
      PC0RW00.PC0RWWSZ = PC0RW00.PC0RWWSZ + PC0RW00.PC0RWRZQ[PC0RWIX1];
      /* Subtract work field from planned qty*/
      PC0RW08.PC7ORIGQ[PC0RWIX1] = PC0RWPZQ[PC0RWIX1] - PC0RW00.PC0RWWSZ;
      /* IF pc0rw08.pc7origq(PC0RWIX1) LT 0;*/
        /* MOVE 0 TO PC0RW00.PC0RWBZQ(PC0RWIX1);*/
      /* END ;*/
    end
    PC0RW00.PC0RWIX1 = PC0RW00.PC0RWIX1 + 1;
  end


  PC0RW08.PC0RW08K = 8; /* Indicate type of record*/
  PC0RW09.PC0RW09R[PC0RWIXT] = PC0RW08.PC0RW08G;

  if (PC0RW00.PC0RWIXT == PC0RW00.PC0RWMAX) /* Max ines (13)*/

    PC0RS05(); /* Add page to temp storage*/

  end


end // end PC0R115

// Format and display map 1
Function PC0R120()


  if (converseVar.validationMsgNum != 0)
    set PC0RM001 alarm; /* Indicate sound alarm*/
  end


   /* -----------------------------------------------------------*/
   /* If map is not formatted, format the data to display*/
   /* -----------------------------------------------------------*/


  if (PC0RW00.TA5TSQIX > 0) /* Pages were formatted*/
    if (PC0RW00.PC0RWTSP != TA5REC.TA5TSQIX) /* Desired page not current*/
      set PC0RM001 initial;
      set PC0RM002 initial;

      PC0RS18(); /* Obtain temp storage page*/




    end
  end

  PC0R121(); /* Move header data to the map*/

  if (converseVar.validationMsgNum == 0)
    PC0R122(); /* Format map 1 detail lines*/
  end

  PC0RM001.XXXCURDT = VGVar.currentShortGregorianDate; /* Current date*/

  if (PC0RW00.XXXMSGNO != 0) /* Contains informational message*/
    if (PC0RW00.XXXMSGNO == 9999)
      converseLib.validationFailed();
    else
      converseLib.validationFailed(PC0RW00.XXXMSGNO);
    end
  else

    if (COMMAREA.CAMSG > " ") /* ===> JCL job info message*/

      PC0RM001.VAGen_EZEMSG = COMMAREA.CAMSG; /* ===> job info message*/
      COMMAREA.CAMSG = " "; /* ===> reset job info message*/
      PC0RM001.XXXPRCNM = "PC0R120"; /* ===> Process name*/
      set PC0RM001 alarm; /* ===> set alarm*/
    end

  end

  if (PC0RW00.PC0RWPDF == "Y")
    set PC0RM001.PC0RMETO skip, invisible;
  end

  converse PC0RM001 ;

   /* -----------------------------------------------------------*/
   /* Clear the message fields*/
   /* -----------------------------------------------------------*/

  PC0RW00.XXXMSGNO = 0; /* Message number*/
  PC0RM001.XXXPRCNM = "PC0R"; /* Process number*/

   /* **                                                        ***/
   /* ********************** End of PC0R120 ***********************/
end // end PC0R120

// Format map Header data (1 & 2)
Function PC0R121()

   /* ------------------------------------------------------------*/
   /* Move map header from PC0RW01 display storage to the map*/
   /* fields.*/
   /* ------------------------------------------------------------*/


  PC0RM001.PC0RMPID = PC0RW01.PC0RWPID; /* PO ID*/
  PC0RM001.PC0RMFRD = PC0RW01.PC0RWFRD;
  PC0RM001.PC0RMTOD = PC0RW01.PC0RWTOD;
  PC0RM001.PO-REG-CD = PC0RW01.PO-REG-CD; /* region cd*/
  PC0RM001.PC3PONBR = PC0RW01.PC3PONBR; /* Order number*/
  PC0RM001.XWHCD = PC0RW01.XWHCD; /* Warehouse code*/
  PC0RM001.PC2CUXID = PC0RW01.PC2CUXID; /* Customer Xrex*/
  PC0RM001.XGPCD = PC0RW01.XGPCD; /* General product group*/
  PC0RM001.SY1STNBR = PC0RW01.SY1STNBR; /* Style number*/
  PC0RM001.SY1STYNM = PC0RW01.SY1STYNM; /* Style description*/
  PC0RM001.SY2CLRID = PC0RW01.SY2CLRID; /* Color*/
  PC0RM001.SY2CLRAB = PC0RW01.SY2CLRAB; /* Color description*/
  PC0RM001.PC4ORTYP = PC0RW01.PC4ORTYP; /* Order type*/
  PC0RM001.XDMCD = PC0RW01.XDMCD; /* Dimension*/
  PC0RM001.PC2INSEG = PC0RW01.PC2INSEG; /* Spec*/
  PC0RM001.XPGCD = PC0RW01.XPGCD; /* Package*/
  PC0RM001.XQACD = PC0RW01.XQACD; /* Quanlity*/
  PC0RM001.XUMCD = PC0RW01.XUMCD; /* Unit of measure*/



end // end PC0R121

// Format map 1 Detail lines
Function PC0R122()

   /* ------------------------------------------------------------*/
   /* Move each temporary storage line from the record to*/
   /* the map line.  Unprotect and display the select field*/
   /* for plan, and intransit detail data only.*/
   /* Position the cursor on the plan and intransit first detail*/
   /* line.*/
   /* ------------------------------------------------------------*/


  PC0RW00.PC0RWIXM = PC0RW00.PC0RWMAX; /* set to max lines*/

  set PC0RM001.PC0RMLIT skip, invisible; /* Darken literal*/
  set PC0RM001.PC0RMETO skip, invisible; /* Protect ETALO*/
  PC0RW00.PC0RWXDF = "Y"; /* Restrict access flag*/
  while (PC0RW00.PC0RWIXM >= 1)

    if (PC0RW09.PC0RW09K[PC0RWIXM] != 0)
      if (PC0RW00.PC0RWDTF == "2") /* S.O  data is  shown*/
        PC0RM001.PC0RMLTR = "S.O NUMBER "; /* S.O  literal*/
        PC0RM001.PC0RMLTL = "18:DPO";
        PC0RW09.PC0RW09K = "2 ";
        PC0RM001.PC0RMDTL[PC0RWIXM] = PC0RW09.PC0RW09D[PC0RWIXM];
        PC0RM001.PC0RMQTY[PC0RWIXM] = PC0RW09.PC0RWQTY[PC0RWIXM];
      else
        PC0RW09.PC0RW09K = "21";
        PC0RM001.PC0RMLTR = " SAP NUMBER"; /* SAP literal*/
        PC0RM001.PC0RMLTL = "18:S.O";
        PC0RM001.PC0RMDTL[PC0RWIXM] = PC0RW09.PC0RW09D[PC0RWIXM];
        PC0RM001.PC0RMQTY[PC0RWIXM] = PC0RW09.PC0RWQTY[PC0RWIXM];
      end

      if (PC0RW09.PC0RW09K[PC0RWIXM] == 2 /* Plan data key*/
       || PC0RW09.PC0RW09K[PC0RWIXM] == 3 /* shipping data key*/
       || PC0RW09.PC0RW09K[PC0RWIXM] == 21) /* Plan data key*/
        set PC0RM001.PC0RMSEL[PC0RWIXM] cursor, normal; /* Allow entry*/
        if (PC0RW09.PC0RW09K[PC0RWIXM] == 3) /* shipping data key*/
          set PC0RM001.PC0RMLIT initialAttributes; /* Display literal*/
          set PC0RM001.PC0RMETO cursor, initialAttributes; /* Allow entry of ETALO*/
          PC0RW00.PC0RWXDF = "N"; /* Restrict access flag*/
        end
      else
        set PC0RM001.PC0RMSEL[PC0RWIXM] initialAttributes; /* Protect and darken*/
      end
      if (PC0RW09.PC0RW09K[PC0RWIXM] == 5 /* Total fields*/
       || PC0RW09.PC0RW09K[PC0RWIXM] == 6 
       || PC0RW09.PC0RW09K[PC0RWIXM] == 7 
       || PC0RW09.PC0RW09K[PC0RWIXM] == 8)
        set PC0RM001.PC0RMDTL[PC0RWIXM] skip, bold;
        set PC0RM001.PC0RMQTY[PC0RWIXM] skip, bold;
      end
      if (PC0RW09.PC0RW09K[PC0RWIXM] == 99) /* blank line*/
        set PC0RM001.PC0RMDTL[PC0RWIXM] skip, invisible;
        set PC0RM001.PC0RMQTY[PC0RWIXM] skip, invisible;
      end
    else
      set PC0RM001.PC0RMQTY[PC0RWIXM] protect, invisible;
    end
    PC0RW00.PC0RWIXM = PC0RW00.PC0RWIXM - 1;
  end

end // end PC0R122

// Open item cursor
Function PC0R123()

   /* ------------------------------------------------------------*/
   /* Declare cursor for VPOITM05*/
   /* ------------------------------------------------------------*/

  PC0RW00.PC0RWICF = "N"; /* Set item cursor flag to no*/


  try
    call "VPOITM05" (PCYREC, SQLCA, VPOITM05) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/
    return;
  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0R123"; /* Process name*/
  TA1REC.TA1LOC = "DECLARE CURSOR          ";
  TA1REC.TA1DBASE = "DPRODC  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VPOITM05"; /* Table view name*/
  TA1REC.TA1TBLKE = VPOITM05.VPOITM05-KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0RM001.XXXPRCNM = "PC0R123";
  exit stack;

end // end PC0R123

// Process all item rows
Function PC0R124()


   /* ------------------------------------------------------------*/
   /* Calculate the dates.*/
   /* Retrieve the size row.*/
   /* Load the data to the temporary storage record.*/
   /* If the page is full write the tempoaray storage record,*/
   /* ------------------------------------------------------------*/

    /* Increment page line index*/

  PC0RW00.PC0RWIXT = PC0RW00.PC0RWIXT + 1;

    /* Increment item counter*/

  PC0RW00.PC0RWICT = PC0RW00.PC0RWICT + 1;

  PC0RS02(); /* Calculate dates*/

  PC0RS03(); /* Retrieve size row*/

  PC0RS04(); /* Load data to temp storage record*/

  if (PC0RW00.PC0RWDTF == "2")
    PC0RW02.PC0RW02K = 2;
    PC0RW09.PC0RW09K = 2; /* Record key*/
    PC0RW09.PC0RW09R[PC0RWIXT] = PC0RW02.PC0RW02G;
  else
    PC0RW21.PC0RW21K = 21;
    PC0RW09.PC0RW09K = 21; /* Record key*/
    PC0RW09.PC0RW09R[PC0RWIXT] = PC0RW21.PC0RW21G;
  end

  if (PC0RW00.PC0RWIXT == PC0RW00.PC0RWMAX) /* max lines per page(13)*/

    PC0RS05(); /* Add page to temp storage*/

  end

  PC0RS01(); /* Retrieve next item row*/
  while (VPOITM05.PC6STAT == "CX" /* While cancelled items*/
   && PC0RW00.PC0RWICF != "Y") /* and more items exist*/
    PC0RS01(); /* Retrieve next item row*/
  end

end // end PC0R124

// Close item cursor
Function PC0R125()

   /* ------------------------------------------------------------*/
   /* Close cursor for VPOITM05*/
   /* ------------------------------------------------------------*/
  set PCYREC empty;
  PCYREC.PCYFUNC = "C8";
  try
    call "VPOITM05" (PCYREC, SQLCA, VPOITM05) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/
    return;
  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0R125"; /* Process name*/
  TA1REC.TA1LOC = "CLOSE CURSOR            ";
  TA1REC.TA1DBASE = "DPRODC  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VPOITM05"; /* Table view name*/
  TA1REC.TA1TBLKE = VPOITM05.VPOITM05-KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0RM001.XXXPRCNM = "PC0R125";
  exit stack;

end // end PC0R125

// Create on order total line
Function PC0R126()
   /* ------------------------------------------------------------*/
   /* Initialize the total order data temporary storage record.*/
   /* Move the data from the working storage record to the*/
   /* temporary storage record.*/
   /* ------------------------------------------------------------*/

   /* Increment temp storage line index*/

  PC0RW00.PC0RWIXT = PC0RW00.PC0RWIXT + 1;

  set PC0RW05 empty; /* Initialize record*/

  PC0RW05.PC0RW05L = "TOTAL ON ORDER:"; /* Total line literal*/

  PC0RW05.PC0RWQTY = PC0RW00.PC0RWTOR; /* Total quantity*/

  PC0RW00.PC0RWIX1 = 1; /* Initialize general index*/

  while (PC0RW00.PC0RWIX1 <= 40)
    if (PC0RW00.PC0RWPZQ[PC0RWIX1] != 0)
      PC0RW05.PC7ORIGQ[PC0RWIX1] = PC0RW00.PC0RWPZQ[PC0RWIX1];
    end
    PC0RW00.PC0RWIX1 = PC0RW00.PC0RWIX1 + 1;
  end


  PC0RW05.PC0RW05K = 5; /* Indicate type of record*/
  PC0RW09.PC0RW09R[PC0RWIXT] = PC0RW05.PC0RW05G;

  if (PC0RW00.PC0RWIXT == PC0RW00.PC0RWMAX) /* Max ines (13)*/

    PC0RS05(); /* Add page to temp storage*/

  end


end // end PC0R126

// Check attention ID
Function PC0R130()


   /* ------------------------------------------------------------*/
   /* Clear Map on PA2*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pa2) /* PA2 was pressed*/
    converseLib.clearScreen();
     /* Clear the map fields*/
    PC0RM001.XXXPRCNM = "PC0R";
    exit stack; /* Exit to redisplay map*/
  end

   /* ------------------------------------------------------------*/
   /* If FAST PATH was requested, transfer to application.*/
   /* ------------------------------------------------------------*/

  if (PC0RM001.CATOAP > " ") /* FAST PATH was requested*/
    if (converseVar.eventKey is enter) /* ENTER was pressed*/
      set PCWREC empty;
      COMMAREA.CATOAP = PC0RM001.CATOAP; /* TO application*/
      COMMAREA.CAITEM = PC0RM001.CAITEM; /* TO application key*/
      XSPCS01();
      COMMAREA.CATOAP = "PC0A";
      PCWREC.XXXMSGNO = 6;
      XSPCS01();
    else
      PC0RM001.XXXPRCNM = "PC0R130"; /* Module identification*/
      converseLib.validationFailed(05); /* Enter must be used for fast path*/
      exit stack;
    end
  end

  if (PC0RM001.CAITEM > " ") /* item entered*/
    set PC0RM001.CAITEM cursor, bold;
    PC0RM001.XXXPRCNM = "PC0R130"; /* Module identification*/
    converseLib.validationFailed(07);
    exit stack;
  end

   /* ------------------------------------------------------------*/
   /* If intransit ETALO date is entered PF16 is required*/
   /* ------------------------------------------------------------*/

  if (PC0RM001.PC0RMETO != " ") /* If intransit ETALO date entered*/
    if (converseVar.eventKey is pf16) /* If PF16*/
      return; /* Return to calling procedure*/
    else
      PC0RM001.XXXPRCNM = "PC0R130"; /* Module identification*/
      converseLib.validationFailed(320);
      exit stack;
    end
  end


   /* ------------------------------------------------------------*/
   /* Continue to edits if enter was pressed*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is enter) /* enter was pressed*/
    return; /* Return to calling procedure*/
  end


   /* ------------------------------------------------------------*/
   /* On PF4 transfer to MN0M(even if it's not on the screen)*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf4) /* Main menu requested*/
    set PCWREC empty;
    COMMAREA.CAITEM = " "; /* application from data*/
    COMMAREA.CATOAP = "MN0M";
    XSPCS01();
    PC0RM001.XXXPRCNM = "PC0R130";
    PC0RM001.VAGen_EZEMSG = COMMAREA.CAMSG; /* If bad transfer*/
    exit stack; /* Exit to redisplay map*/
  end

   /* ------------------------------------------------------------*/
   /* On PF5 transfer to FY0M(even if it's not on the screen)*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf5) /* Main menu requested*/
    set PCWREC empty;
    COMMAREA.CAITEM = " "; /* application from data*/
    COMMAREA.CATOAP = "FY0M";
    XSPCS01();
    PC0RM001.XXXPRCNM = "PC0R130";
    PC0RM001.VAGen_EZEMSG = COMMAREA.CAMSG; /* If bad transfer*/
    exit stack; /* Exit to redisplay map*/
  end
   /* ------------------------------------------------------------*/
   /* Validate scroll request if  PF 7 or PF8*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf7 /* Scroll back requested*/
   || converseVar.eventKey is pf8) /* Scroll forward requested*/

    PC0R131(); /* Validate scroll request*/

    return; /* Exit to next process*/
  end
   /* ------------------------------------------------------------*/
   /* Continue processing if following keys are pressed*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf3
   || converseVar.eventKey is pf6
   || converseVar.eventKey is pf11
   || converseVar.eventKey is pf12
   || converseVar.eventKey is pf14
   || converseVar.eventKey is pf15
   || converseVar.eventKey is pf16
   || converseVar.eventKey is pf19
   /* OR EZEAID IS PF20*/
   || converseVar.eventKey is pf18)
    return;
  end

   /* ------------------------------------------------------------*/
   /* Purge temporary storage on PF17 and transer to PC0L*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf17) /* pf17 pressed*/

    PC0R111(); /* Purge temp storage*/

    PCWREC.PO-REG-CD = VPOHDR02.PO-REG-CD;
    PCWREC.PC3POIDT = VPOHDR02.PC3POIDT;
    PCWREC.FY1FCTYC = VPOHDR02.FY1FCTYC;
    COMMAREA.CAITEM = " "; /* application from data*/
    COMMAREA.CATOAP = "PC0L";
    XSPCS01();
    PC0RM001.XXXPRCNM = "PC0R130";
    exit stack;
  end

   /* ------------------------------------------------------------*/
   /* Purge temporary storage on PF21 and transer to PC0A*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf21) /* pf21 pressed*/

    PC0R111(); /* Purge temp storage*/
    set PCWREC empty;

    COMMAREA.CAITEM = " "; /* application from data*/
    COMMAREA.CATOAP = "PC0A";
    XSPCS01();
    PC0RM001.XXXPRCNM = "PC0R130";
    PC0RM001.VAGen_EZEMSG = COMMAREA.CAMSG; /* If bad transfer*/
    exit stack;
  end


   /* ------------------------------------------------------------*/
   /* Clear screen if PA1 or PA3 and exit to display map.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pa1 /* PA1 pressed*/
   || converseVar.eventKey is pa3) /* PA3 pressed*/
    set PC0RM001 initial; /* Clear the map fields*/
    exit stack; /* Exit to redisplay map*/
  end

   /* ------------------------------------------------------------*/
   /* At this point an invalid PF key has been pressed.*/
   /* ------------------------------------------------------------*/


  converseLib.validationFailed(04); /* Invalid PA/PF key*/
  exit stack;


end // end PC0R130

// Validate scroll request
Function PC0R131()



   /* ------------------------------------------------------------*/
   /* If scroll back was requested, ensure that pages exist.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf7 /* Scroll back request*/
   && PC0RW00.PC0RWTSP < 2)       /* and no previous pages*/

    PC0RM001.XXXPRCNM = "PC0R131"; /* Module identification*/
    converseLib.validationFailed(2); /* No previous page to display*/

  end

   /* ------------------------------------------------------------*/
   /* If scroll forward was requested, ensure that pages exist.*/
   /* ------------------------------------------------------------*/



  if (converseVar.eventKey is pf8 /* Scroll forward request*/
   && PC0RW00.PC0RWTSP >= PC0RW00.TA5TSQIX) /* and no more pages*/

    PC0RM001.XXXPRCNM = "PC0R131"; /* Module identification*/
    converseLib.validationFailed(3); /* No more pages to display*/

  end

  if (converseVar.validationMsgNum != 0) /* Errors were found*/
    exit stack;
  end



end // end PC0R131

// Open Trans/container cursor
Function PC0R132()

   /* ------------------------------------------------------------*/
   /* Declare cursor for vcplhd02*/
   /* ------------------------------------------------------------*/

  PC0RW00.PC0RWTCF = "N"; /* Set trans cursor flag to no*/


  try
    call "IO4230" ("S3", SQLCA, TSTREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/
    return;
  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0R132"; /* Process name*/
  TA1REC.TA1LOC = "DECLARE CURSOR          ";
  TA1REC.TA1DBASE = "DTRANS  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCPLHD02"; /* Table view name*/
  TA1REC.TA1TBLKE = TSTREC.TSTKEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0RM001.XXXPRCNM = "PC0R132";
  exit stack;

end // end PC0R132

// Process intransit data
Function PC0R133()

   /* ------------------------------------------------------------*/
   /* If the status on the transporation row is equal to 'rc'*/
   /* bypass the row.*/
   /* ------------------------------------------------------------*/

  if (TSTREC.TSISTAT == "TN" /* Tentative*/
   || TSTREC.TSISTAT == "IT" /* Intransit*/
   || TSTREC.TSISTAT == "CC" /* Cleared customs*/
   || TSTREC.TSISTAT == "ER" /* Shipped hard error*/
   || TSTREC.TSISTAT == "CR") /* Cleared customs / Hard error*/
     /* next sentence*/
  else

    PC0RS06(); /* Fetch next vcplhd02 row*/

    return;
  end


   /* ------------------------------------------------------------*/
   /* Obtain all the container rows for the Nike Shipping ID*/
   /* key.  Load the status for each container into a working*/
   /* storage table. If no status = a valid ship status the*/
   /* ship record will not be processed.  The quantities for any*/
   /* container with a 'it' or 'cc' status will be added into the*/
   /* accumulated totals. When the shipping header record has*/
   /* a status of 'tn','cr', or 'er' the quantities are not to*/
   /* be added into any of the total fields.*/
   /* ------------------------------------------------------------*/

  move " " to PC0RW00.TSHSTAT[1] for all; /* Init ws container statuses table*/
  move 0 to PC0RW00.TSHNKCN[1] for all; /* Init ws container numbers table*/

  PC0RW00.TSHNKCN[1] = TSTREC.TSHNKCN1;
                                   /* move nike cntnr nbrs to tbl*/
  PC0RW00.TSHNKCN[2] = TSTREC.TSHNKCN2;
  PC0RW00.TSHNKCN[3] = TSTREC.TSHNKCN3;
  PC0RW00.TSHNKCN[4] = TSTREC.TSHNKCN4;
  PC0RW00.TSHNKCN[5] = TSTREC.TSHNKCN5;
  PC0RW00.TSHNKCN[6] = TSTREC.TSHNKCN6;
  PC0RW00.TSHNKCN[7] = TSTREC.TSHNKCN7;
  PC0RW00.TSHNKCN[8] = TSTREC.TSHNKCN8;

  PC0RW00.PC0RWSHQ[1] = TSTREC.TSISHPQ1;
                                   /* move nike cntnr qty to tbl*/
  PC0RW00.PC0RWSHQ[2] = TSTREC.TSISHPQ2;
  PC0RW00.PC0RWSHQ[3] = TSTREC.TSISHPQ3;
  PC0RW00.PC0RWSHQ[4] = TSTREC.TSISHPQ4;
  PC0RW00.PC0RWSHQ[5] = TSTREC.TSISHPQ5;
  PC0RW00.PC0RWSHQ[6] = TSTREC.TSISHPQ6;
  PC0RW00.PC0RWSHQ[7] = TSTREC.TSISHPQ7;
  PC0RW00.PC0RWSHQ[8] = TSTREC.TSISHPQ8;

  set TSHREC empty; /* Initialize record*/

  TSHREC.TSFSHPID = TSTREC.TSFSHPID; /* Key*/

  PC0RW00.PC0RWIX3 = 1;
  while (PC0RW00.PC0RWIX3 <= 8 /* not end of cntnr status table*/
   && PC0RW00.TSHNKCN[PC0RWIX3] != 0) /* not end of table*/

    /* -----------------------------------------------------*/
      /* If the status on the container row is not equal to*/
      /* 'RC' (received). Move the status to the working*/
      /* storage table.*/
    /* ------------------------------------------------------*/

    TSHREC.TSHNKCN = PC0RW00.TSHNKCN[PC0RWIX3];
    PC0RS20(); /* get container row*/

    if (TSHREC.TSHSTAT != "RC")
      PC0RW00.TSHSTAT[PC0RWIX3] = TSHREC.TSHSTAT;
    end

    PC0RW00.PC0RWIX3 = PC0RW00.PC0RWIX3 + 1; /* increment while index*/

  end

  if (PC0RW00.TSHSTAT[1] == " " /* If there is no 'it' status for*/
   && PC0RW00.TSHSTAT[2] == " " /* any containers--obtain*/
   && PC0RW00.TSHSTAT[3] == " " /* the next header row and*/
   && PC0RW00.TSHSTAT[4] == " " /* exit the routine.*/
   && PC0RW00.TSHSTAT[5] == " " 
   && PC0RW00.TSHSTAT[6] == " " 
   && PC0RW00.TSHSTAT[7] == " " 
   && PC0RW00.TSHSTAT[8] == " ")

    PC0RS06(); /* Fetch next vcplhd02 row*/

    return;

  end

   /* ------------------------------------------------------------*/
   /* Calculate the dates.*/
   /* Retrieve the size rows.*/
   /* Load the data to the temporary storage record.*/
   /* Write a temporary storage record if the page is full.*/
   /* ------------------------------------------------------------*/

   /* Increment page line index*/

  PC0RW00.PC0RWIXT = PC0RW00.PC0RWIXT + 1;


  set PC0RW03 empty; /* Initialize record*/

  PC0RS13(); /* Calculate dates*/

   /* Set flag to indicate shipping data exists*/

  PC0RW00.PC0RWSDF = "Y"; /* Shipping data flag*/

   /* Move intransit data from TSTREC to temp storage record*/


  if (TSTREC.TSISTAT == "IT" /* Intransit*/
   || TSTREC.TSISTAT == "CC") /* Cleared customs*/
    PC0RW03.PC0RW03L = "SHIP";
  else
    PC0RW03.PC0RW03L = "SHIP*";
  end
  PC0RW03.PC0RWSHP = TSTREC.TSFSHPID; /* Nike Shipping number*/
  PC0RW00.PC0RWTXT = PC0RW03.PC0RWSHA;
  PC0RS31(); /* Strip off leading zeros*/
  PC0RW03.PC0RWSHA = PC0RW00.PC0RWTXT;
  PC0RW03.TSFSHPID = TSTREC.TSFSHPID; /* Nike Shipping number*/
  PC0RW03.TSIPLNBR = TSTREC.TSIPLNBR; /* Nike plan nbr*/
  PC0RW03.YSSCD = TSTREC.TSISTAT; /* Status*/
  PC0RW00.PC0RWDDT = TSTREC.TSFSTADT; /* Status date to ws*/
  PC0RW03.PC0RWSTD = PC0RW00.PC0RWSDT; /* MMDD status date*/
  PC0RW03.TSACARCD = TSTREC.TSACARCD; /* Carrier code*/
  PC0RW03.TS5CRAFT = TSTREC.TS5CRAFT; /* craft*/
  PC0RW03.TSFSHPNB = TSTREC.TSFSHPNB; /* ship number*/

  if (TSTREC.OP1CUOID > 0) /* Customer order number entered*/
        /* ----------------------------------------------------------*/
        /* Get the APAO flag from the dprodc.VPRDCU03.*/
        /* ----------------------------------------------------------*/
    set VPRDCU03 empty;
    VPRDCU03.XGPCD = TSTREC.XGPCD;
    VPRDCU03.PC2CUXID = TSTREC.PC2CUXID;
    XSPCS59(); /* select cust xref row*/

    PC0RW00.PC0RWCOR = TSTREC.OP1CUOID;
    PC0RW03.PC0RWORD = PC0RW00.PC0RWCOR;
    PC0RW03.PC0RWDOT = ".";
    PC0RW00.PC0RWNOR = TSTREC.OP1NORID;
    set OP1REC empty; /* check for MSR order*/
    OP1REC.OP1PARTN = TSTREC.OP1PARTN;
    OP1REC.OP1CUOID = TSTREC.OP1CUOID;
    OP1REC.OP1NORID = TSTREC.OP1NORID;

    if (VPRDCU03.PC-PRDCU-APAO-FL == "E")
      PC0RS35(); /* Select unique Deuro.veorhd01*/
    else
      PC0RS34(); /* Select unique DORDER.VORHDR01*/
    end

    if (SQLCA.VAGen_SQLCODE == 0
     && OP1REC.XPACD == "MS")
      PC0RW03.PC0RW-MSR-IND = "M";
    else
      PC0RW03.PC0RW-MSR-IND = " ";
    end
    PC0RW03.PC0RWNRD = PC0RW00.PC0RWNOR;
  else
    PC0RW03.PC0RWORD = " ";
    PC0RW03.PC0RWDOT = " ";
    PC0RW03.PC0RWNRD = " ";
  end

   /* ************************************************************/
   /* If the status for the container was equal to 'it' or 'cc'*/
   /* Add the quantities from the shipping record to the*/
   /* total shipping quantity field and obtain all the*/
   /* size data for the container.*/
   /* ************************************************************/

  PC0RW00.PC0RWWF1 = 0; /* Initialize work quantity size field*/

  PC0RW00.PC0RWIX3 = 1;
  while (PC0RWIX3 <= 8
   && PC0RW00.TSHNKCN[PC0RWIX3] != 0)
    if (PC0RW00.TSHSTAT[PC0RWIX3] != " ")
      PC0RW00.PC0RWWF1 = PC0RW00.PC0RWWF1 + PC0RW00.PC0RWSHQ[PC0RWIX3];
      set TSOREC empty;
      TSOREC.TSFSHPID = TSTREC.TSFSHPID; /* Nike ship Id*/
      TSOREC.TSIPLNBR = TSTREC.TSIPLNBR; /* Nike plan number*/
      TSOREC.TSHNKCN = PC0RW00.TSHNKCN[PC0RWIX3]; /* nike cntnr nbr*/
      PC0RS23(); /* Obtain size data*/
    end

    PC0RW00.PC0RWIX3 = PC0RW00.PC0RWIX3 + 1;

  end

  PC0RW03.PC0RWQTY = PC0RW00.PC0RWWF1;

  if (TSTREC.TSISTAT == "IT"
   || TSTREC.TSISTAT == "CC") /* Cleared customs*/
    PC0RW00.PC0RWTSH = PC0RW00.PC0RWTSH + PC0RW00.PC0RWWF1;
  end


  PC0RW03.PC0RW03K = 3; /* Record key*/
  PC0RW09.PC0RW09R[PC0RWIXT] = PC0RW03.PC0RW03G;

  if (PC0RW00.PC0RWIXT == PC0RW00.PC0RWMAX) /* Max lines (13)*/

    PC0RS05(); /* Add page to temp storage*/

  end

  PC0RS06(); /* Fetch next vcplhd02 row*/


end // end PC0R133

// Close cursor for vcplhd02
Function PC0R134()

   /* ------------------------------------------------------------*/
   /* Close cursor for vcplhd02*/
   /* ------------------------------------------------------------*/

  try
    call "IO4230" ("C3", SQLCA, TSTREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/
    return;
  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0R134"; /* Process name*/
  TA1REC.TA1LOC = "CLOSE CURSOR            ";
  TA1REC.TA1DBASE = "DTRANS  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCPLHD02"; /* Table view name*/
  TA1REC.TA1TBLKE = TSTREC.TSTKEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0RM001.XXXPRCNM = "PC0R13D";
  exit stack;

end // end PC0R134

// Create intransit totals
Function PC0R135()
   /* ------------------------------------------------------------*/
   /* Initialize the total shipping data temp storage record.*/
   /* Move the data from the working storage record to the*/
   /* temporary storage record.*/
   /* ------------------------------------------------------------*/

   /* Increment temporary storage index*/


  PC0RW00.PC0RWIXT = PC0RW00.PC0RWIXT + 1;

  set PC0RW06 empty; /* Initialize record*/

  PC0RW06.PC0RW06L = "TOTAL INTRANSIT:"; /* Total line literal*/

  PC0RW06.PC0RWQTY = PC0RW00.PC0RWTSH; /* Total quantity*/

  PC0RW00.PC0RWIX1 = 1; /* Initialize general index*/

  while (PC0RW00.PC0RWIX1 <= 40)
    if (PC0RW00.PC0RWSZQ[PC0RWIX1] != 0)
      PC0RW06.PC7ORIGQ[PC0RWIX1] = PC0RW00.PC0RWSZQ[PC0RWIX1];
    end
    PC0RW00.PC0RWIX1 = PC0RW00.PC0RWIX1 + 1;
  end


  PC0RW06.PC0RW06K = 6; /* Record key*/
  PC0RW09.PC0RW09R[PC0RWIXT] = PC0RW06.PC0RW06G;

  if (PC0RW00.PC0RWIXT == PC0RW00.PC0RWMAX) /* Max lines (13)*/

    PC0RS05(); /* Add page to temp storage*/

  end


end // end PC0R135

// Reset highlighted fields
Function PC0R140()

  PC0RW00.PC0RWIXM = 1; /* Initialize map index*/

  while (PC0RW00.PC0RWIXM <= PC0RW00.PC0RWMAX /* Max lines (13)*/
   && PC0RW09.PC0RW09K[PC0RWIXM] != 0)

    if (PC0RW09.PC0RW09K[PC0RWIXM] == 2  /* Plan data key*/
     || PC0RW09.PC0RW09K[PC0RWIXM] == 21 /* Plan data key*/
     || PC0RW09.PC0RW09K[PC0RWIXM] == 3) /* shipping data key*/
      set PC0RM001.PC0RMSEL[PC0RWIXM] normal; /* Allow entry*/
    else
      set PC0RM001.PC0RMSEL[PC0RWIXM] initialAttributes; /* Protect and darken*/

    end
    PC0RW00.PC0RWIXM = PC0RW00.PC0RWIXM + 1;
  end

  if (PC0RW00.PC0RWPDF == "Y" /* Protect entered date*/
   || PC0RW00.PC0RWXDF == "Y") /* Restrict entered date*/
    set PC0RM001.PC0RMLIT skip, invisible;
    set PC0RM001.PC0RMETO skip, invisible;
  else
    set PC0RM001.PC0RMLIT initialAttributes;
    set PC0RM001.PC0RMETO initialAttributes;
  end

end // end PC0R140

// Open receiving data cursor
Function PC0R141()

   /* ------------------------------------------------------------*/
   /* Declare cursor for VFYPO002*/
   /* ------------------------------------------------------------*/

  PC0RW00.PC0RWRCF = "N"; /* Set Received cursor flag to no*/


  try
    call "VFYPO002" ("S1", SQLCA, VFYPO002) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/
    return;
  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0R141"; /* Process name*/
  TA1REC.TA1LOC = "DECLARE CURSOR          ";
  TA1REC.TA1DBASE = "DPRODC  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VFYPO002"; /* Table view name*/
  TA1REC.TA1TBLKE = VFYPO002.VFYPO002-KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0RM001.XXXPRCNM = "PC0R141";
  exit stack;

end // end PC0R141

// Process receiving data
Function PC0R142()


   /* ------------------------------------------------------------*/
   /* Move the data from the database record to the PC0rW04*/
   /* storage record--then move the storage group level to*/
   /* the temporary storage record (pc0rw09).  Add the total*/
   /* received quantity from the pcmrec to the total received*/
   /* quantity in working storage.*/
   /* ------------------------------------------------------------*/


  if (VFYPO002.YRSCD == "10"
   || VFYPO002.YRSCD == "11"
   || VFYPO002.YRSCD == "12"
   || VFYPO002.YRSCD == "13")
     /* next sentence*/
  else

    PC0RS24(); /* Fetch next receiving row*/

    return;

  end


   /* Increment page line index*/

  PC0RW00.PC0RWIXT = PC0RW00.PC0RWIXT + 1;

  PC0RW00.PC0RWRDF = "Y";

  set PC0RW04 empty; /* Initialize record*/


  if (VFYPO002.YRSCD == "12")
    PC0RW04.PC0RW04L = "RCPT*";
  else
    PC0RW04.PC0RW04L = "RCPT";
  end
  PC0RW04.PC0RWRNO = VFYPO002.SL1RCRNO; /* Received report number*/
  PC0RW00.PC0RWTXT = PC0RW04.PC0RWRNA;
  PC0RS31(); /* Strip off leading zeros*/
  PC0RW04.PC0RWRNA = PC0RW00.PC0RWTXT;
  PC0RW04.YRSCD = VFYPO002.YRSCD; /* Received status*/
  PC0RW04.YMTCD = VFYPO002.YMTCD; /* Mode of transportation*/
  PC0RW04.PC0RWSHP = VFYPO002.TSFSHPID; /* Nike Ship Id*/

     /* container received data** changed to status change date*/
            /* on 2-19-91 by lsutto per Becky Platt request f107*/

   /* MOVE PCMREC.PCMYRSDT TO PC0RW00.PC0RWDDT; /* Update date to WS*/
     /* then changed it back again (to cntnr rcpt datE)*/
            /* on 9-04-91 by lsutto per John Cadero request f161*/

  PC0RW00.PC0RWDDT = VFYPO002.TSHRCTDT; /* Update date to WS*/
  PC0RW04.PC0RWTLO = PC0RW00.PC0RWSDT; /* MMDD date to temp storage*/


  if (VFYPO002.OP1CUOID > 0) /* Customer order number entered*/
       /* ----------------------------------------------------------*/
       /* Get the APAO flag from the dprodc.VPRDCU03.*/
       /* ----------------------------------------------------------*/
    set VPRDCU03 empty;
    VPRDCU03.XGPCD = VFYPO002.XGPCD;
    VPRDCU03.PC2CUXID = VFYPO002.PC2CUXID;
    XSPCS59(); /* select cust xref row*/

    PC0RW00.PC0RWCOR = VFYPO002.OP1CUOID;
    PC0RW04.PC0RWORD = PC0RW00.PC0RWCOR;
    PC0RW04.PC0RWDOT = ".";
    PC0RW00.PC0RWNOR = VFYPO002.OP1NORID;
    set OP1REC empty; /* check for MSR order*/
    OP1REC.OP1PARTN = VFYPO002.OP1PARTN;
    OP1REC.OP1CUOID = VFYPO002.OP1CUOID;
    OP1REC.OP1NORID = VFYPO002.OP1NORID;

    if (VPRDCU03.PC-PRDCU-APAO-FL == "E")
      PC0RS35(); /* Select unique Deuro.veorhd01*/
    else
      PC0RS34(); /* Select unique DORDER.VORHDR01*/
    end

    if (SQLCA.VAGen_SQLCODE == 0
     && OP1REC.XPACD == "MS")
      PC0RW04.PC0RW-MSR-IND = "M";
    else
      PC0RW04.PC0RW-MSR-IND = " ";
    end
    PC0RW04.PC0RWNRD = PC0RW00.PC0RWNOR;
  else
    PC0RW04.PC0RWORD = " ";
    PC0RW04.PC0RWDOT = " ";
    PC0RW04.PC0RWNRD = " ";
  end

   /* ------------------------------------------------------------*/
   /* Move the size quantities from the size array in the pcmrec*/
   /* to the size array in the temporary storage record (when*/
   /* there are quanitites for a size). In addition move a 'y'*/
   /* to the corresponding fields in the working storage array*/
   /* to indicate that the table entry had a quantity.  This*/
   /* flag will be used to determine what sizes will be*/
   /* displayed on the size screen.  (The users only want to*/
   /* see a size if it has a quantity associated with it).*/
   /* Add the size quanitities into the size quantity array*/
   /* for received data in working storage.*/
   /* ------------------------------------------------------------*/

  PC0RW00.PC0RWIX1 = 1; /* Initialize general index*/

  while (PC0RW00.PC0RWIX1 <= 40)
    if (VFYPO002.PCMRCPTQ[PC0RWIX1] != 0)
      PC0RW04.PC7ORIGQ[PC0RWIX1] = VFYPO002.PCMRCPTQ[PC0RWIX1];
      PC0RW00.PC0RWSTB[PC0RWIX1] = "Y"; /* size flag set to yes*/
      if (VFYPO002.YRSCD != "12")
        PC0RW00.PC0RWWSZ = 0; /* Initialize work field*/
        PC0RW00.PC0RWWSZ = PC0RW00.PC0RWWSZ + VFYPO002.PCMRCPTQ[PC0RWIX1];
         /* Add size quantity to total received size quantity*/
        PC0RW00.PC0RWRZQ[PC0RWIX1] = PC0RW00.PC0RWRZQ[PC0RWIX1] + PC0RWWSZ;
         /* Add size quantity to total received  quantity*/
        PC0RW00.PC0RWTRC = PC0RW00.PC0RWTRC + PC0RWWSZ;
      end
      PC0RW04.PC0RWQTY = PC0RW04.PC0RWQTY + VFYPO002.PCMRCPTQ[PC0RWIX1];
    end
    PC0RW00.PC0RWIX1 = PC0RW00.PC0RWIX1 + 1;
  end


  PC0RW04.PC0RW04K = 4; /* Record key*/
  PC0RW09.PC0RW09R[PC0RWIXT] = PC0RW04.PC0RW04G;

  if (PC0RW00.PC0RWIXT == PC0RW00.PC0RWMAX) /* Max lines (13)*/

    PC0RS05(); /* Add page to temp storage*/

  end


  PC0RS24(); /* Fetch next receiving row*/


end // end PC0R142

// Close vfypo001 row
Function PC0R143()

   /* ------------------------------------------------------------*/
   /* Close cursor for VFYPO002*/
   /* ------------------------------------------------------------*/

  try
    call "VFYPO002" ("C1", SQLCA, VFYPO002) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/
    return;
  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0R143"; /* Process name*/
  TA1REC.TA1LOC = "CLOSE CURSOR            ";
  TA1REC.TA1DBASE = "DPRODC  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VFYPO002"; /* Table view name*/
  TA1REC.TA1TBLKE = VFYPO002.VFYPO002-KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0RM001.XXXPRCNM = "PC0R143";
  exit stack;

end // end PC0R143

// Create Received totals
Function PC0R144()
   /* ------------------------------------------------------------*/
   /* Initialize the total received data temp storage record.*/
   /* Move the data from the working storage record to the*/
   /* temporary storage record.*/
   /* ------------------------------------------------------------*/

   /* Increment temporary storage index*/


  PC0RW00.PC0RWIXT = PC0RW00.PC0RWIXT + 1;

  set PC0RW07 empty; /* Initialize record*/

  PC0RW07.PC0RW07L = "TOTAL RECEIVED:"; /* Total line literal*/

  PC0RW07.PC0RWQTY = PC0RW00.PC0RWTRC; /* Total quantity*/

  PC0RW00.PC0RWIX1 = 1; /* Initialize general index*/

  while (PC0RW00.PC0RWIX1 <= 40)
    if (PC0RW00.PC0RWRZQ[PC0RWIX1] != 0)
      PC0RW07.PC7ORIGQ[PC0RWIX1] = PC0RW00.PC0RWRZQ[PC0RWIX1];
    end
    PC0RW00.PC0RWIX1 = PC0RW00.PC0RWIX1 + 1;
  end


  PC0RW07.PC0RW07K = 7; /* Record key*/
  PC0RW09.PC0RW09R[PC0RWIXT] = PC0RW07.PC0RW07G;

  if (PC0RW00.PC0RWIXT == PC0RW00.PC0RWMAX) /* Max lines (13)*/

    PC0RS05(); /* Add page to temp storage*/

  end


end // end PC0R144

// Verify entered data
Function PC0R150()


   /* ----------------------------------------------------*/
   /* If ETALo override date has been entered validate*/
   /* it using TA0040.*/
   /* ----------------------------------------------------*/

  if (PC0RM001.PC0RMETO != " ") /* Etal override entered*/
    if (PC0RM001.PC0RMETO != PC0RW01.PC0RWETO) /* Etal override changed*/

      set TA2REC empty;

      TA2REC.TA2GRGA = PC0RM001.PC0RMETO; /* mmddyy format*/

      PC0RS27(); /* Validate date*/

      if (TA2REC.TA2RTNCD == 0) /* Good return good*/
        PC0RW00.TSIETALO = TA2REC.TA2GRGGN; /* ETALO CCYYMMDD*/
        PC0RW01.PC0RWETO = PC0RM001.PC0RMETO;
      else
        set PC0RM001.PC0RMETO cursor, bold;
        converseLib.validationFailed(38); /* Invalid date*/
        PC0RM001.XXXPRCNM = "PC0R150"; /* Module identification*/
        exit stack;
      end
    end
  else
    PC0RW00.TSIETALO = 0;
    PC0RW01.PC0RWETO = " ";
  end

   /* ----------------------------------------------------*/
   /* Validate for PF12 (multiple lines can be selected)*/
   /* The entered value must be an 's'.*/
   /* Only plan lines can be selected.*/
   /* ----------------------------------------------------*/

  PC0RW00.PC0RWIXM = PC0RW00.PC0RWMAX; /* Initialize map index*/
  PC0RW00.PC0RWCNT = 0; /* Field to count select codes*/

  if (converseVar.eventKey is pf12) /* PC0K (product inq/maint)*/

    while (PC0RW00.PC0RWIXM >= 1)
      if (PC0RM001.PC0RMSEL[PC0RWIXM] != " ")
        if (PC0RM001.PC0RMSEL[PC0RWIXM] != "S")
          set PC0RM001.PC0RMSEL[PC0RWIXM] cursor, bold;
          converseLib.validationFailed(13);
        else
          PC0RW00.PC0RWCNT = PC0RW00.PC0RWCNT + 1;
          if (PC0RW09.PC0RW09K[PC0RWIXM] != 2
           && PC0RW09.PC0RW09K[PC0RWIXM] != 21)
            set PC0RM001.PC0RMSEL[PC0RWIXM] cursor, bold;
            converseLib.validationFailed(166); /* Only plan line can be selected*/
          end
        end
      end
      PC0RW00.PC0RWIXM = PC0RW00.PC0RWIXM - 1;
    end
    if (PC0RW00.PC0RWCNT == 0)
      set PC0RM001.PC0RMSEL[1] cursor;
      converseLib.validationFailed(25); /* Please select a line*/
    end
    if (converseVar.validationMsgNum == 0)
      return;
    else
      PC0RM001.XXXPRCNM = "PC0R150"; /* Module identification*/
      exit stack;
    end
  end

   /* ----------------------------------------------------*/
   /* Validate for PF14, PF6, PF15 (only one plan line can*/
   /* be selected).*/
   /* The entered value must be an 'S'.*/
   /* ----------------------------------------------------*/


  PC0RW00.PC0RWCNT = 0; /* Field to count select codes*/

  if (converseVar.eventKey is pf14 /* PC0D (Item ship-to)*/
   || converseVar.eventKey is pf6  /* PC0H (Item special instruction)*/
   || converseVar.eventKey is pf15) /* PC0O (Global Maintenance)*/

    while (PC0RW00.PC0RWIXM >= 1)
      if (PC0RM001.PC0RMSEL[PC0RWIXM] == "S")
        PC0RW00.PC0RWCNT = PC0RW00.PC0RWCNT + 1;
        PC0RW00.PC0RWIX1 = 1; /* Init second index*/
        while (PC0RW00.PC0RWIX1 <= PC0RW00.PC0RWMAX) /* Max lines (13)*/
          if (PC0RM001.PC0RMSEL[PC0RWIXM] == PC0RM001.PC0RMSEL[PC0RWIX1]
           && PC0RW00.PC0RWIXM != PC0RW00.PC0RWIX1)
            set PC0RM001.PC0RMSEL[PC0RWIXM] cursor, bold;
            converseLib.validationFailed(144); /* Only one line can be selected*/
          end
          if (PC0RW09.PC0RW09K[PC0RWIXM] != 2
           && PC0RW09.PC0RW09K[PC0RWIXM] != 21)
            set PC0RM001.PC0RMSEL[PC0RWIXM] cursor, bold;
            converseLib.validationFailed(109); /* Only plan line can be selected*/
          end
          PC0RW00.PC0RWIX1 = PC0RW00.PC0RWIX1 + 1;
        end
        if (PC0RW09.PC0RW09K[PC0RWIXM] != 2
         && PC0RW09.PC0RW09K[PC0RWIXM] != 21)
          set PC0RM001.PC0RMSEL[PC0RWIXM] cursor, bold;
          converseLib.validationFailed(166); /* Only plan line can be selected*/
        end
      else
        if (PC0RM001.PC0RMSEL[PC0RWIXM] != " ")
          set PC0RM001.PC0RMSEL[PC0RWIXM] cursor, bold;
          converseLib.validationFailed(13); /* S'elect code must be S*/
        end
      end
      PC0RW00.PC0RWIXM = PC0RW00.PC0RWIXM - 1;
    end
    if (PC0RW00.PC0RWCNT == 0)
      set PC0RM001.PC0RMSEL[1] cursor;
      converseLib.validationFailed(25); /* Please select a line*/
    end
    if (converseVar.validationMsgNum == 0)
      return;
    else
      PC0RM001.XXXPRCNM = "PC0R150"; /* Module identification*/
      exit stack;
    end
  end

   /* ----------------------------------------------------*/
   /* IF PF7 or PF8 have been pressed and the etal*/
   /* override date has been entered it is an error.*/
   /* ----------------------------------------------------*/

  if (converseVar.eventKey is pf7
   || converseVar.eventKey is pf8)
    if (PC0RW01.PC0RWETO != " ") /* Etal override date entered*/
      converseLib.validationFailed(284); /* Scrolling not allowed with etal override*/
      PC0RM001.XXXPRCNM = "PC0R150"; /* Module identification*/
      exit stack;
    end
  end

   /* ----------------------------------------------------*/
   /* Validate for PF16 (Check for security on update)*/
   /* Validate for PF16 (only one 'shipping' line can be*/
   /* selected.) The entered value must be an 'S'*/
   /* ----------------------------------------------------*/

  if (converseVar.eventKey is pf16) /* Update ETALO date*/
    if (PC0RW00.PC0RWPDF == "Y") /* Protect date flag*/
      converseLib.validationFailed(29); /* User does not have update authority*/
      PC0RM001.XXXPRCNM = "PC0R150"; /* Module identification*/
      exit stack;
    end
    if (PC0RW00.PC0RWXDF == "Y") /* Protect date flag*/
      converseLib.validationFailed(321); /* Must select ship line*/
      PC0RM001.XXXPRCNM = "PC0R150"; /* Module identification*/
      exit stack;
    end
  end

  if (converseVar.eventKey is pf16) /* Update ETALO date*/
    if (PC0RW01.PC0RWETO != " ") /* Etal override entered*/

      while (PC0RW00.PC0RWIXM >= 1)
        if (PC0RM001.PC0RMSEL[PC0RWIXM] == "S")
          PC0RW00.PC0RWCNT = PC0RW00.PC0RWCNT + 1;
          PC0RW00.PC0RWIX1 = 1; /* Init second index*/
          while (PC0RW00.PC0RWIX1 <= PC0RW00.PC0RWMAX) /* Max lines*/
            if (PC0RM001.PC0RMSEL[PC0RWIXM] == PC0RM001.PC0RMSEL[PC0RWIX1]
             && PC0RW00.PC0RWIXM != PC0RW00.PC0RWIX1)
              set PC0RM001.PC0RMSEL[PC0RWIXM] cursor, bold;
              converseLib.validationFailed(144); /* Only one line can be selected*/
            end
            PC0RW00.PC0RWIX1 = PC0RW00.PC0RWIX1 + 1;
          end
          if (PC0RW09.PC0RW09K[PC0RWIXM] == 3)
            PC0RW00.PC0RWIX3 = PC0RW00.PC0RWIXM;
          end
          if (PC0RW09.PC0RW09K[PC0RWIXM] != 3)
            set PC0RM001.PC0RMSEL[PC0RWIXM] cursor, bold;
            converseLib.validationFailed(109); /* Only shipping line can be selected*/
          end
        else
          if (PC0RM001.PC0RMSEL[PC0RWIXM] != " ")
            set PC0RM001.PC0RMSEL[PC0RWIXM] cursor, bold;
            converseLib.validationFailed(13); /* S'elect code must be S*/
          else
            if (PC0RW09.PC0RW09K[PC0RWIXM] == 3)
              PC0RW00.PC0RWIX3 = PC0RW00.PC0RWIXM;
            end
          end
        end
        PC0RW00.PC0RWIXM = PC0RW00.PC0RWIXM - 1;
      end
      if (PC0RW00.PC0RWCNT == 0)
        converseLib.validationFailed(321); /* Please select a line*/
        set PC0RM001.PC0RMSEL[PC0RWIX3] cursor;
      end
      if (converseVar.validationMsgNum == 0)
        return;
      else
        PC0RM001.XXXPRCNM = "PC0R150"; /* Module identification*/
        exit stack;
      end
    else /* PF16 pressed no ETALO date entered*/
      converseLib.validationFailed(283); /* MUst enter ETAL override date for update*/
      set PC0RM001.PC0RMETO cursor, bold;
      exit stack;
    end

  end

   /* ----------------------------------------------------*/
   /* Validate for enter with a shipping line selected.*/
   /* (only one line can be selected and the value must*/
   /* be an 's'.*/
   /* ----------------------------------------------------*/

  if (converseVar.eventKey is enter) /* Transfer to transporation system*/
    while (PC0RW00.PC0RWIXM >= 1)
      if (PC0RM001.PC0RMSEL[PC0RWIXM] == "S")
        PC0RW00.PC0RWCNT = PC0RW00.PC0RWCNT + 1;
        PC0RW00.PC0RWIX1 = 1; /* Init second index*/
        while (PC0RW00.PC0RWIX1 <= PC0RW00.PC0RWMAX) /* Max lines*/
          if (PC0RM001.PC0RMSEL[PC0RWIXM] == PC0RM001.PC0RMSEL[PC0RWIX1]
           && PC0RW00.PC0RWIXM != PC0RW00.PC0RWIX1)
            set PC0RM001.PC0RMSEL[PC0RWIXM] cursor, bold;
            converseLib.validationFailed(144); /* Only one line can be selected*/
          end
          PC0RW00.PC0RWIX1 = PC0RW00.PC0RWIX1 + 1;
        end
        if (PC0RW09.PC0RW09K[PC0RWIXM] != 3)
          set PC0RM001.PC0RMSEL[PC0RWIXM] cursor, bold;
          converseLib.validationFailed(109); /* Only shipping line can be selected*/
        end
      else
        if (PC0RM001.PC0RMSEL[PC0RWIXM] != " ")
          set PC0RM001.PC0RMSEL[PC0RWIXM] cursor, bold;
          converseLib.validationFailed(13); /* S'elect code must be S*/
        end
      end
      PC0RW00.PC0RWIXM = PC0RW00.PC0RWIXM - 1;
    end
    if (converseVar.validationMsgNum == 0)
      return;
    else
      PC0RM001.XXXPRCNM = "PC0R150"; /* Module identification*/
      exit stack;
    end
  end


end // end PC0R150

// Process valid input
Function PC0R160()

   /* ----------------------------------------------------*/
   /* If PF7 or PF8 has been pressed increment or*/
   /* decrement the page requested and return to the*/
   /* calling process.*/
   /* ----------------------------------------------------*/

  if (converseVar.eventKey is pf7)
    PC0RW00.PC0RWTSP = PC0RW00.PC0RWTSP - 1;
    return;
  end

  if (converseVar.eventKey is pf8)
    PC0RW00.PC0RWTSP = PC0RW00.PC0RWTSP + 1;
    return;
  end


   /* ----------------------------------------------------*/
   /* If PF11 has been pressed set the screen flag*/
   /* to map 2.*/
   /* ----------------------------------------------------*/

  if (converseVar.eventKey is pf11) /* Size screen requested*/
    PC0RW00.PC0RWSRF = "2";
    PC0RW00.PC0RWOSD = "Y"; /* Obtain size data flag*/
  end


   /* ----------------------------------------------------*/
   /* If PF3 or PF19 have been pressed transfer back*/
   /* to the initially calling application (list screen)*/
   /* On a PF3 leave the pcwrec in tact--on PF19 clear*/
   /* the pcwrec.*/
   /* ----------------------------------------------------*/

  if (converseVar.eventKey is pf3) /* List screen requested*/
    PC0R111(); /* Purge temp storage*/
    COMMAREA.CAITEM = " "; /* Application from data*/
    COMMAREA.CATOAP = PC0RW10.CAFROMAP; /* To Application*/
    COMMAREA.CAUSERA = PCWREC.CAUSERA;
    XSPCS01();
  end

  if (converseVar.eventKey is pf18)
    if (PC0RW00.PC0RWDTF == "1")
      PC0RW00.PC0RWODF = "Y";
      PC0RW00.PC0RWDTF = "2";
    else
      PC0RW00.PC0RWODF = "Y";
      PC0RW00.PC0RWDTF = "1";
    end
  end
  if (converseVar.eventKey is pf19) /* Select screen requested*/

    PC0R111(); /* Purge temp storage*/

    COMMAREA.CAITEM = " "; /* Application from data*/
    set PCWREC empty;
    PCWREC.XGPCD = COMMAREA.XGPCD;
    COMMAREA.CAUSERA = PCWREC.CAUSERA;
    COMMAREA.CATOAP = PC0RW10.CAFROMAP; /* To Application*/
    XSPCS01();
  end

   /* ----------------------------------------------------*/
   /* If PF20 is pressed load data*/
    /* and process T.S. Dump through TA0P*/
   /* ----------------------------------------------------*/

  /* IF EZEAID IS PF20;               /* Print requested*/
  /* ;*/
  /* PERFORM PC0R212;            /* ===> set-up get size desc. for print*/
  /* ;*/
  /* PERFORM PC0R500;             /* ===> set-up & print T.S. through TA0P*/
  /* ;*/
  /* EZEFLO;*/
  /* ;*/
  /* END;*/

   /* ----------------------------------------------------*/
   /* The enter key has 2 functions.  IF any intransit*/
   /* line has been selected the enter key means*/
   /* a transfer to TS0P.  IF no intransit line has*/
   /* been selected the enter key will get the next entry*/
   /* in the PCWREC destination array. If there is another*/
   /* destination set the obtain data flag to yes and*/
   /* initialize the working storage fields.*/
   /* If there are no more destinations transfer back*/
   /* to the initial calling application.*/
   /* ----------------------------------------------------*/

   /* Check for intransit line selected*/
   /* Save index value of intransit line if one is found*/

  PC0RW00.PC0RWIX1 = 1; /* Init index*/
  PC0RW00.PC0RWIX4 = 0; /* Init transporation select index*/

  while (PC0RW00.PC0RWIX1 <= PC0RW00.PC0RWMAX)
    if (PC0RM001.PC0RMSEL[PC0RWIX1] == "S"
     && PC0RW09.PC0RW09K[PC0RWIX1] == 3) /* Intransit line*/
      PC0RW00.PC0RWIX4 = PC0RW00.PC0RWIX1;
    end
    PC0RW00.PC0RWIX1 = PC0RW00.PC0RWIX1 + 1;
  end

  if (converseVar.eventKey is enter /* Enter was pressed*/
   && PC0RW00.PC0RWCNT == 0)        /* intransit line not selected*/
    PC0RW00.PC0RWIXP = PC0RW00.PC0RWIXP + 1;
    if (PCWREC.PCWWHSE[PC0RWIXP] != " "
     || PCWREC.PCWCUST[PC0RWIXP] != " ")

      PC0R161(); /* Set up for next destination*/
      PC0RW01.PC0RWFRD = PC0RW00.PC0RWIXP;

      return;

    else
      COMMAREA.CAITEM = " "; /* application from data*/
      COMMAREA.CATOAP = PC0RW10.CAFROMAP;
      XSPCS01();
    end
  end

   /* ----------------------------------------------------*/
   /* If PF16 update the ETALO date and temp storage*/
   /* and reload temp storage.*/
   /* ----------------------------------------------------*/

  if (converseVar.eventKey is pf16) /* Update ETALO date*/

    PC0R162(); /* Update Dtrans.VCPLHD01*/

    TA5REC.TA5TSQIX = 0;

    exit stack;

  end
   /* ----------------------------------------------------*/
   /* The remaining attention keys will execute a*/
   /* transfer. The following code is generic for all.*/
   /* Obtain the item record  using the item sequence*/
   /* number to get the RTA date OETS date andthe*/
   /* mode.*/
   /* ----------------------------------------------------*/

  PC0RW10.PC0RWIXS = PC0RW00.PC0RWIXP;
  PC0RW10.PC0RWTSP = PC0RW00.PC0RWTSP;

  if (PCWREC.CAFROMAP[1] == " ")

    PCWREC.CAFROMAP[1] = "PC0R"; /* From application id*/
    PCWREC.PCWUSER1 = PC0RW10.PC0RWUSR;
    PC0RW00.PC0RWIX3 = 1;

  else
    if (PCWREC.CAFROMAP[2] == " ")

      PCWREC.CAFROMAP[2] = "PC0R"; /* From application id*/
      PCWREC.PCWUSER2 = PC0RW10.PC0RWUSR;
      PC0RW00.PC0RWIX3 = 2;
    else
      if (PCWREC.CAFROMAP[3] == " ")
        PCWREC.CAFROMAP[3] = "PC0R"; /* From application id*/
        PCWREC.PCWUSER3 = PC0RW10.PC0RWUSR;
        PC0RW00.PC0RWIX3 = 3;
      else
        if (PCWREC.CAFROMAP[4] == " ")
          PCWREC.CAFROMAP[4] = "PC0R"; /* From application id*/
          PCWREC.PCWUSER4 = PC0RW10.PC0RWUSR;
          PC0RW00.PC0RWIX3 = 3;

        end
      end
    end
  end


  PC0RW00.PC0RWIXM = 1; /* Initialize screen index*/


  COMMAREA.CAITEM = " "; /* Application from data*/

   /* ----------------------------------------------------*/
   /* If PF6 move the selected item sequence number to*/
   /* the first position in the PCWREC items sequence*/
   /* array and the item sequence number field.*/
   /* ----------------------------------------------------*/

  if (converseVar.eventKey is pf6) /* Item special instruction selected*/


    while (PC0RW00.PC0RWIXM <= PC0RW00.PC0RWMAX) /* Max lines*/

      if (PC0RM001.PC0RMSEL[PC0RWIXM] == "S")
        PCWREC.PC6ITMNB = PC0RW09.PC6ITMNB[PC0RWIXM];
        PC0RS25(); /* Obtain item record*/
      end

      PC0RW00.PC0RWIXM = PC0RW00.PC0RWIXM + 1;
    end

    PCWREC.PCWFNC[PC0RWIX3] = "I";
    COMMAREA.CATOAP = "PC0I"; /* To Application*/
    COMMAREA.CAUSERA = PCWREC.CAUSERA;
    XSPCS01();
  end


   /* ----------------------------------------------------*/
   /* If PF14 move the selected item sequence number to*/
   /* the first position in the PCWREC items sequence*/
   /* array and the item sequence number field.*/
   /* ----------------------------------------------------*/

  if (converseVar.eventKey is pf14) /* Item ship to requested*/

    while (PC0RW00.PC0RWIXM <= PC0RW00.PC0RWMAX) /* Max lines*/

      if (PC0RM001.PC0RMSEL[PC0RWIXM] == "S")
        PCWREC.PC6ITMNB[1] = PC0RW09.PC6ITMNB[PC0RWIXM];
        PCWREC.XWHCD = PCWREC.PCWWHSE[PC0RWIXP];
        PCWREC.PC2CUXID = PCWREC.PCWCUST[PC0RWIXP];
        PC0RS25(); /* Obtain item record*/
      end

      PC0RW00.PC0RWIXM = PC0RW00.PC0RWIXM + 1;
    end

    COMMAREA.CATOAP = "PC05"; /* To Application*/
    PCWREC.PCWFNC[PC0RWIX3] = "I";
    XSPCS01();
  end

   /* ----------------------------------------------------*/
   /* If PF15 move the selected item sequence number to*/
   /* the first position in the PCWREC items sequence*/
   /* array and the item sequence number field.*/
   /* ----------------------------------------------------*/

  if (converseVar.eventKey is pf15) /* Global mainenance requested*/

    PC0RW00.PC0RWIX1 = 1; /* Init work index*/

    while (PC0RW00.PC0RWIXM <= PC0RW00.PC0RWMAX) /* Max lines*/

      if (PC0RM001.PC0RMSEL[PC0RWIXM] == "S")
        PCWREC.PC6ITMNB[PC0RWIX1] = PC0RW09.PC6ITMNB[PC0RWIXM];
        PCWREC.PCWUSER4 = PC0RW09.PC0RW9SO;
        PCWREC.YSMXDV = VPOITM05.YSMXDV;
        PCWREC.PO-REG-CD = PC0RW01.PO-REG-CD; /* PO region*/
        PCWREC.PC3PONBR = PC0RW01.PC3PONBR; /* PO number*/
        PCWREC.SY1STNBR = PC0RW01.SY1STNBR; /* Style number*/
        PCWREC.SY2CLRID = PC0RW01.SY2CLRID; /* Color id*/
        PCWREC.XDMCD = PC0RW01.XDMCD; /* Dimesion code*/
        PCWREC.PC2INSEG = PC0RW01.PC2INSEG; /* In seq*/
        PCWREC.XPGCD = PC0RW01.XPGCD; /* package code*/
        PCWREC.XUMCD = PC0RW01.XUMCD; /**/
        PCWREC.XWHCD = PC0RW01.XWHCD; /* Warehouse code*/
        PCWREC.PC2CUXID = PC0RW01.PC2CUXID; /* Customer xref*/
        if (PC0RW09K[PC0RWIXM] == 2) /* Plan with S.O num*/
          PC0RW02.PC0RW02D = PC0RM001.PC0RMDTL[PC0RWIXM];
          PCWREC.PC6PLAN = PC0RW02.PC0RWPLN; /* Plan number*/
          PCWREC.YMTCD = PC0RW02.YMTCD; /* Mode*/
        else /* Plan with SAP number*/
          PC0RW21.PC0RW21D = PC0RM001.PC0RMDTL[PC0RWIXM];
          PCWREC.PC6PLAN = PC0RW21.PC0RWPLN; /* Plan number*/
          PCWREC.YMTCD = PC0RW21.YMTCD; /* Mode*/
        end
        PCWREC.PC6RTADT = PC0RW01.PC0RW-RTADT[PC0RWIXM]; /* RTA date*/

        PC0RW00.PC0RWIX1 = PC0RW00.PC0RWIX1 + 1;
      end

      PC0RW00.PC0RWIXM = PC0RW00.PC0RWIXM + 1;
    end

    COMMAREA.CATOAP = "PC0O"; /* To Application*/
    COMMAREA.CAFROMAP = "PC0R"; /* from Application*/

    XSPCS01();

  end

   /* ----------------------------------------------------*/
   /* If PF12 move the selected item sequence number to*/
   /* the first position in the PCWREC items sequence*/
   /* array.*/
   /* ----------------------------------------------------*/

  if (converseVar.eventKey is pf12) /* Product inquiry maintenance*/

    PC0RW00.PC0RWIX1 = 1; /* Init work index*/

    while (PC0RW00.PC0RWIXM <= PC0RW00.PC0RWMAX) /* Max lines*/

      if (PC0RM001.PC0RMSEL[PC0RWIXM] == "S")
        PCWREC.PC6ITMNB[PC0RWIX1] = PC0RW09.PC6ITMNB[PC0RWIXM];
        PC0RW00.PC0RWIX1 = PC0RW00.PC0RWIX1 + 1;
      end

      PC0RW00.PC0RWIXM = PC0RW00.PC0RWIXM + 1;
    end


    COMMAREA.CATOAP = "PC0K"; /* To Application*/
    PCWREC.PCWFNC = "C";
    XSPCS01();
  end

   /* ----------------------------------------------------*/
   /* If enter and an intransit line has been selected*/
   /* transfer to transporation system.*/
   /* ----------------------------------------------------*/

  if (converseVar.eventKey is enter) /* Product inquiry*/

    while (PC0RW00.PC0RWIXM <= PC0RW00.PC0RWMAX) /* Max lines*/

      if (PC0RM001.PC0RMSEL[PC0RWIXM] == "S")
        PC0RW03.PC0RW03G = PC0RW09.PC0RW09R[PC0RWIXM];
        PCWREC.PC6ITMNB[1] = PC0RW03.PC0RWSHP;
      end

      PC0RW00.PC0RWIXM = PC0RW00.PC0RWIXM + 1;
    end

    COMMAREA.CATOAP = "TS0P"; /* To Application*/
    PCWREC.PO-REG-CD = PC0RW01.PO-REG-CD;
    PCWREC.PC3POIDT = PC0RW00.PC0RWFDT;
    PCWREC.FY1FCTYC = PC0RW00.FY1FCTYC;
    PCWREC.PC4ORTYP = PC0RM001.PC4ORTYP;
    PCWREC.XWHCD = PC0RM001.XWHCD;
    PCWREC.PC2INSEG = PC0RM001.PC2INSEG;
    PCWREC.XQACD = PC0RM001.XQACD;
    PCWREC.SY1STNBR = PC0RM001.SY1STNBR;
    XSPCS01();
  end

   /* ----------------------------------------------------*/
   /* Executed only on bad transfer*/
   /* ----------------------------------------------------*/

  if (converseVar.validationMsgNum > 0)
    PC0RM001.XXXPRCNM = "PC0R160";
    exit stack; /* Exit to redisplay map*/
  end
end // end PC0R160

// Set up for next destination
Function PC0R161()

   /* ---------------------------------------------------------*/
   /* Initialize the temporary storage record and all the*/
   /* destination array tables in working storage--set the*/
   /* obtain data flag to yes.*/
   /* ---------------------------------------------------------*/

  set PC0RW09 empty; /* Temporary storage record*/

  set PC0RM001 empty;
  set PC0RM002 empty;

  PC0RW00.PC0RWODF = "Y"; /* Obtain data flag*/
  PC0RW00.PC0RWOSD = "Y"; /* Size data flag*/
  PC0RW00.PC0RWTSP = 1; /* Requested temp storage page*/


  PC0RW00.PC0RWIX1 = 1; /* Initialize index*/

  PC0RW00.TA5TSQIX = 0; /* Init temp storage page counter*/
  move " " to PC0RW00.PC0RWSTB[1] for all; /* Display size flag table*/
  move " " to PC0RW00.TSHSTAT[1] for all; /* Display size flag table*/
  move 0 to PC0RW00.PC0RWPTB[1] for all; /* FOB price table*/
  move 0 to PC0RW00.PC0RWPZQ[1] for all; /* Price size qty table*/
  move 0 to PC0RW00.PC0RWSZQ[1] for all; /* Shipped size qty table*/
  move 0 to PC0RW00.PC0RWRZQ[1] for all; /* Received size qty table*/
  move 0 to PC0RW00.PC0RWBZQ[1] for all; /* Received size qty table*/
  move 0 to PC0RW00.PC7ORIGQ[1] for all; /* Size work table.*/
  move 0 to PC0RW00.PC0RWSPI[1] for all; /* Size Page index*/
  PC0RW00.PC0RWTOR = 0; /* Total ordered*/
  PC0RW00.PC0RWTSH = 0; /* Total shipped*/
  PC0RW00.PC0RWTRC = 0; /* Total received*/




end // end PC0R161

// Update transportation header
Function PC0R162()


  set TSIREC empty;

  TSIREC.TSFSHPID = PC0RW09.TSFSHPID[PC0RWIX4];

  PC0RS28(); /* DEclare cursor on DTRANS.VCPLHD01*/

  PC0RW00.PC0RWTCF = "N"; /* init trans cursor eof flag*/
  PC0RW00.PC0RWTUF = "N"; /* init trnas update flag*/

  PC0RS32(); /* Fetch the row*/

  while (PC0RW00.PC0RWTCF != "Y")

    TSIREC.TSIETALO = PC0RW00.TSIETALO; /* move new data*/
    PC0RS29(); /* update the row*/
    PC0RW00.PC0RWTUF = "Y"; /* set trans update flag*/

    PC0RS32(); /* fetch next row*/

  end

  PC0RS33(); /* Close transportation curosr*/

   /* ----------------------------------------------------------------*/
   /* end  --  logic change*/
   /* ----------------------------------------------------------------*/



  PC0RW00.PC0RWMDT = PC0RW01.PC0RWETO;
  PC0RW00.PC0RWEDM = PC0RW00.PC0RWMMM;
  PC0RW00.PC0RWEDD = PC0RW00.PC0RWMDD;
  PC0RW03.PC0RW03G = PC0RW09.PC0RW09R[PC0RWIX4];
  /* MOVE PC0RW00.PC0RWEDT TO PC0RW03.PC0RWTLO;*/
  PC0RW09.PC0RW09R[PC0RWIX4] = PC0RW03.PC0RW03G;

  PC0RM001.PC0RMETO = " ";
  PC0RW01.PC0RWETO = " ";

  PC0RS30(); /* Update temp storage*/

  if (PC0RW00.PC0RWTUF == "Y") /* if trans header updated*/
    VGVar.handleSysLibraryErrors = 0;
    sysLib.commit(); /* commit all changes*/
    PC0RW00.XXXMSGNO = 001; /* UPdate successfully completed*/
    return;
  end

end // end PC0R162

// Map 2 processing
Function PC0R200()
   /* ------------------------------------------------------------*/
   /* This is the main process used to display a map.  Processing*/
   /* always returns to the top of this process and falls through*/
   /* subordinate processes until an error is found or a valid*/
   /* request is processed.  Processing sequence is as follows:*/

   /* 1) Obtain data to display*/
   /* 2) Format the map output area and display the map.*/
   /* 3) Check the attention identifier used to respond.*/
   /* 4) Process a valid input request.*/

   /* In all subordinate processes, "EZEFLO" is used to exit to*/
   /* redisplay the map when an error is found.  This is done to*/
   /* minimize the coding effort required to skip subsequent*/
   /* processing under error conditions.*/
   /* ------------------------------------------------------------*/


  PC0R210(); /* Obtain data to display*/

  PC0R220(); /* Format and display the map*/

  PC0R230(); /* Check attention identifier*/

  PC0R240(); /* Process valid input request*/


end // end PC0R200

// Obtain data to display
Function PC0R210()

   /* ------------------------------------------------------------*/
   /* If an error was found return to previous process*/
   /* ------------------------------------------------------------*/

  if (converseVar.validationMsgNum != 0)
    return; /* Error found*/
  end



  if (PC0RW00.PC0RWODF == "Y") /* New destination requested*/

    PC0R111(); /* Purge temporary storage*/

    /* ------------------------------------------------------------*/
     /* Obtain the item size and related data and format the*/
     /* the data lines to the temporary storage page record.*/
    /* ------------------------------------------------------------*/

    PC0R112(); /* Obtain item size data*/

    /* -----------------------------------------------------------*/
     /* Obtain the intransit data and related size data and format*/
     /* the data lines to the temporary storage page record.*/
    /* ------------------------------------------------------------*/

    PC0R113(); /* Obtain Intransit (shipped) data*/


    PC0R114(); /* Obtain received data*/

    PC0R115(); /* Write balance due record*/

    if (PC0RW00.TA5TSQIX == 0) /* No temp storage page written*/
      if (PC0RW00.PC0RWIXT == 0) /* No detail line formatted*/
        converseLib.validationFailed(18); /* Indicate no data to display*/
        exit stack; /* Display error message*/
      end
    end

    if (PC0RW00.PC0RWIXT != 0) /* Write partial page to temp storage*/
      PC0RS05(); /* Add to temp storage*/
    end

  end

  if (PC0RW00.PC0RWOSD == "Y")
                                   /* Set up for size display not requested*/
    PC0R211(); /* Set up for size scrolling*/
  end


  PC0RW00.PC0RWODF = "N"; /* Obtain data flag*/
  PC0RW00.PC0RWSDF = "N"; /* Obtain size data flag*/

end // end PC0R210

// Init size screen scrolling
Function PC0R211()
   /* ------------------------------------------------------------*/
   /* Count the number of 'y' entries in the working storage*/
   /* size table flag to determine how many pages of sizes*/
   /* are to be displayed (scrolling right and left).*/
   /* ------------------------------------------------------------*/

  PC0RW00.PC0RWSPG = 0; /* Initialize size page flag*/

  PC0RW00.PC0RWIX1 = 1; /* Initialize index*/
  PC0RW00.PC0RWIX2 = 0; /* Initialize index*/

  while (PC0RW00.PC0RWIX1 <= 40)
    if (PC0RW00.PC0RWSTB[PC0RWIX1] == "Y")
      PC0RW00.PC0RWIX2 = PC0RW00.PC0RWIX2 + 1;
    end
    PC0RW00.PC0RWIX1 = PC0RW00.PC0RWIX1 + 1;
  end

   /* ------------------------------------------------------------*/
   /* Divide the size page field (which has 2 decimal positions)*/
   /* by 10 to obtain the whole number of pages (if less than*/
   /* 0 then there is only 1 page).  If the decimal field is*/
   /* not equal to zeros add 1 to number of pages.*/
   /* ------------------------------------------------------------*/

  PC0RW00.PC0RWCNP = PC0RW00.PC0RWIX2 / 10;

  if (PC0RW00.PC0RWCNP < 0)
    PC0RW00.PC0RWSPG = 1;
  else
    PC0RW00.PC0RWSPG = PC0RW00.PC0RWCNP;
    if (PC0RW00.PC0RWDEC != 0)
      PC0RW00.PC0RWSPG = PC0RW00.PC0RWSPG + 1;
    end
  end


   /* ------------------------------------------------------------*/
   /* Determine the first size field with quantities*/
   /* ------------------------------------------------------------*/

  PC0RW00.PC0RWIX1 = 1; /* Initialize work index*/

  while (PC0RW00.PC0RWIX1 <= 40
   && PC0RW00.PC0RWSTB[PC0RWIX1] == " ")

    PC0RW00.PC0RWIX1 = PC0RW00.PC0RWIX1 + 1;
  end

  PC0RW00.PC0RWFSI = PC0RW00.PC0RWIX1; /* Set first size index*/

   /* ------------------------------------------------------------*/
   /* Determine the last size field with quantities*/
   /* ------------------------------------------------------------*/


  while (PC0RW00.PC0RWIX1 <= 40)
    if (PC0RW00.PC0RWSTB[PC0RWIX1] == "Y")

      PC0RW00.PC0RWLSI = PC0RW00.PC0RWIX1;
    end
    PC0RW00.PC0RWIX1 = PC0RW00.PC0RWIX1 + 1;
  end

   /* ------------------------------------------------------------*/
   /* Determine the starting position in the table for each of*/
   /* the pages (this will be used as an index for loading the*/
   /* size quantities to the map and will be indexed by the*/
   /* pc0rwcsp field which is the current size page).*/
   /* ------------------------------------------------------------*/

   /* First page*/

  PC0RW00.PC0RWSPI[1] = PC0RW00.PC0RWFSI;


   /* Second page*/

   /* Set the index to the first size position in the table*/

  PC0RW00.PC0RWIX1 = PC0RW00.PC0RWFSI;
  PC0RW00.PC0RWIX2 = 1;

  while (PC0RW00.PC0RWIX2 <= 10
   && PC0RW00.PC0RWIX1 <= PC0RW00.PC0RWLSI)

    if (PC0RW00.PC0RWSTB[PC0RWIX1] == "Y")

      PC0RW00.PC0RWIX2 = PC0RW00.PC0RWIX2 + 1;
    end

    PC0RW00.PC0RWIX1 = PC0RW00.PC0RWIX1 + 1;
  end

  if (PC0RW00.PC0RWIX1 <= PC0RW00.PC0RWLSI)
    PC0RW00.PC0RWSPI[2] = PC0RW00.PC0RWIX1;
  end


   /* Third page*/

  PC0RW00.PC0RWIX2 = 1;

  while (PC0RW00.PC0RWIX2 <= 10
   && PC0RW00.PC0RWIX1 <= PC0RW00.PC0RWLSI)

    if (PC0RW00.PC0RWSTB[PC0RWIX1] == "Y")

      PC0RW00.PC0RWIX2 = PC0RW00.PC0RWIX2 + 1;
    end

    PC0RW00.PC0RWIX1 = PC0RW00.PC0RWIX1 + 1;
  end

  if (PC0RW00.PC0RWIX1 <= PC0RW00.PC0RWLSI)
    PC0RW00.PC0RWSPI[3] = PC0RW00.PC0RWIX1;
  end


   /* Fourth page*/

  PC0RW00.PC0RWIX2 = 1;

  while (PC0RW00.PC0RWIX2 <= 10
   && PC0RW00.PC0RWIX1 <= PC0RW00.PC0RWLSI)

    if (PC0RW00.PC0RWSTB[PC0RWIX1] == "Y")

      PC0RW00.PC0RWIX2 = PC0RW00.PC0RWIX2 + 1;
    end

    PC0RW00.PC0RWIX1 = PC0RW00.PC0RWIX1 + 1;
  end

  if (PC0RW00.PC0RWIX1 <= PC0RW00.PC0RWLSI)
    PC0RW00.PC0RWSPI[4] = PC0RW00.PC0RWIX1;
  end

   /* ------------------------------------------------------------*/
   /* set-up &  Obtain the size description*/
   /* ------------------------------------------------------------*/

  PC0R212();

   /* ------------------------------------------------------------*/
   /* Initialize fields used for scrolling right and left*/
   /* ------------------------------------------------------------*/

  PC0RW00.PC0RWSPR = 1; /* Set size page requested to 1*/
  PC0RW00.PC0RWCSP = 0; /* Set current size page to 0*/
  PC0RW00.PC0RWCSI = PC0RW00.PC0RWFSI; /* current size index*/

  PC0RW00.PC0RWOSD = "N"; /* Obtain size data flag*/

end // end PC0R211

// set-up & get Size descriptions
Function PC0R212()
   /* ------------------------------------------------------------*/
   /* set-up and Obtain the size description*/
   /* ------------------------------------------------------------*/

  set PG3REC empty;

  PG3REC.XGPCD = VPOITM05.XGPCD;
  PG3REC.SY1STNBR = VPOITM05.SY1STNBR;
  PG3REC.SY2CLRID = VPOITM05.SY2CLRID;
  PG3REC.XDMCD = VPOITM05.XDMCD;
  PG3REC.XQACD = "**";
  PG3REC.PG3FUNCD = "PC";
  PG3REC.PG3DATFM = "N";

  XSPG301(); /* Get valid sizes*/

end // end PC0R212

// Format and display map 2
Function PC0R220()

   /* -----------------------------------------------------------*/
   /* If map is not formatted, format the data to display*/
   /* -----------------------------------------------------------*/


  if (PC0RW00.TA5TSQIX > 0) /* Pages were formatted*/
    if (PC0RW00.PC0RWTSP != TA5REC.TA5TSQIX) /* Desired page not current*/

      set PC0RM001 initial;
      set PC0RM002 initial;

      PC0RS18(); /* Obtain temp storage page*/

      PC0RW00.PC0RWCSP = PC0RW00.PC0RWSPR; /* Requested = current*/

    else
      if (PC0RW00.PC0RWCSP != PC0RW00.PC0RWSPR) /* Scroll r/l request*/

        set PC0RM002 initial;
        PC0RW00.PC0RWCSP = PC0RW00.PC0RWSPR; /* Requested = current*/

      end
    end
  end

  if (PC0RW00.PC0RWCSP < 1) /* dhales - I don't like this check*/
    PC0RW00.PC0RWCSP = 1; /* but can't find the rare instance*/
  else /* when this index is out of bounds*/
    if (PC0RW00.PC0RWCSP > 4) /* and forces an abend in production*/
      PC0RW00.PC0RWCSP = 4;
    end
  end

  PC0R221(); /* Move header data to the map*/

  PC0R222(); /* Format map 2 detail lines*/
  PC0RM002.XXXCURDT = VGVar.currentShortGregorianDate; /* Current date*/


  if (PC0RW00.XXXMSGNO != 0) /* Contains informational message*/
    if (PC0RW00.XXXMSGNO == 9999)
      converseLib.validationFailed();
    else
      converseLib.validationFailed(PC0RW00.XXXMSGNO);
    end
  else

    if (COMMAREA.CAMSG > " ") /* ===> JCL job info message*/

      PC0RM002.VAGen_EZEMSG = COMMAREA.CAMSG; /* ===> job info message*/
      COMMAREA.CAMSG = " "; /* ===> reset job info message*/
      PC0RM002.XXXPRCNM = "PC0R220"; /* ===> Process name*/
      set PC0RM002 alarm; /* ===> set alarm*/
    end

  end

  PC0RM002.XXXCURDT = VGVar.currentShortGregorianDate;

  converse PC0RM002 ;



   /* -----------------------------------------------------------*/
   /* Clear the message fields*/
   /* -----------------------------------------------------------*/

  PC0RW00.XXXMSGNO = 0; /* Message number*/
  PC0RM002.XXXPRCNM = "PC0R"; /* Process number*/


   /* **                                                        ***/
   /* ********************** End of PC0R220 ***********************/
end // end PC0R220

// Load size header data to map
Function PC0R221()

   /* ------------------------------------------------------------*/
   /* Move map header from PC0RW01 display storage to the map*/
   /* fields.*/
   /* ------------------------------------------------------------*/


  PC0RM002.PC0RMPID = PC0RW01.PC0RWPID; /* PO ID*/
  PC0RM002.PC0RMFRD = PC0RW01.PC0RWFRD;
  PC0RM002.PC0RMTOD = PC0RW01.PC0RWTOD;
  PC0RM002.PO-REG-CD = PC0RW01.PO-REG-CD; /* po region*/
  PC0RM002.PC3PONBR = PC0RW01.PC3PONBR; /* Order number*/
  PC0RM002.XWHCD = PC0RW01.XWHCD; /* Warehouse code*/
  PC0RM002.PC2CUXID = PC0RW01.PC2CUXID; /* Customer Xrex*/
  PC0RM002.XGPCD = PC0RW01.XGPCD; /* General product group*/
  PC0RM002.SY1STNBR = PC0RW01.SY1STNBR; /* Style number*/
  PC0RM002.SY1STYNM = PC0RW01.SY1STYNM; /* Style description*/
  PC0RM002.SY2CLRID = PC0RW01.SY2CLRID; /* Color*/
  PC0RM002.SY2CLRAB = PC0RW01.SY2CLRAB; /* Color description*/
  PC0RM002.PC4ORTYP = PC0RW01.PC4ORTYP; /* Order type*/
  PC0RM002.XDMCD = PC0RW01.XDMCD; /* Dimension*/
  PC0RM002.PC2INSEG = PC0RW01.PC2INSEG; /* Spec*/
  PC0RM002.XPGCD = PC0RW01.XPGCD; /* Package*/
  PC0RM002.XQACD = PC0RW01.XQACD; /* Quanlity*/
  PC0RM002.XUMCD = PC0RW01.XUMCD; /* Unit of measure*/



end // end PC0R221

// Load size detail to map
Function PC0R222()

   /* ------------------------------------------------------------*/
   /* If the current page is not equal to the total pages move*/
   /* 'more sizes' to map field otherwise set the field to*/
   /* spaces.*/
   /* ------------------------------------------------------------*/

  if (PC0RW00.PC0RWSPG != PC0RW00.PC0RWCSP)
    PC0RM002.PC0RMSMG = "MORE SIZES";
    set PC0RM002.PC0RMSMG skip, bold;
  else
    PC0RM002.PC0RMSMG = " ";
  end

   /* ------------------------------------------------------------*/
   /* Load the FOB prices to the map price fields and the*/
   /* size descriptions  size description fields.*/
   /* ------------------------------------------------------------*/

  PC0RW00.PC0RWIXM = 1; /* Initialize map index*/
  PC0RW00.PC0RWIX1 = PC0RW00.PC0RWSPI[PC0RWCSP];

  while (PC0RW00.PC0RWIXM <= 10 /* while fields on the map and sizes*/
   && PC0RW00.PC0RWIX1 <= PC0RW00.PC0RWLSI)

    if (PC0RW00.PC0RWSTB[PC0RWIX1] == "Y")
      if (PC0RW00.PC7FOBFL[PC0RWIX1] == "Y")
        PC0RM002.PC0RMPRC[PC0RWIXM] = PC0RW00.PC0RWPTB[PC0RWIX1];
        set PC0RM002.PC0RMPRC[PC0RWIXM] skip, bold;
      else
        PC0RM002.PC0RMPRC[PC0RWIXM] = PC0RW00.FY4FOBPR[PC0RWIX1];
        set PC0RM002.PC0RMPRC[PC0RWIXM] initialAttributes;
      end
      PC0RM002.PC0RMSIZ[PC0RWIXM] = PG3REC.SY4IDDSC[PC0RWIX1];
      PC0RW00.PC0RWIXM = PC0RW00.PC0RWIXM + 1;
    end

    PC0RW00.PC0RWIX1 = PC0RW00.PC0RWIX1 + 1;
  end

  while (PC0RW00.PC0RWIXM <= 10) /* while map fields darken underline*/
    set PC0RM002.PC0RMSIZ[PC0RWIXM] skip, invisible;
    PC0RW00.PC0RWIXM = PC0RW00.PC0RWIXM + 1;
  end

   /* ------------------------------------------------------------*/
   /* Set FOB price fields to dark if the price is the same as*/
   /* the previous one. The first price must be handled*/
   /* different--it will always be displayed.*/
   /* ------------------------------------------------------------*/

  PC0RW00.PC0RWIXM = 2; /* Initialize map index*/
  PC0RW00.PC0RWIX1 = 1;

  while (PC0RW00.PC0RWIXM <= 10) /* while fields on the map*/

    if (PC0RM002.PC0RMPRC[PC0RWIXM] == PC0RM002.PC0RMPRC[PC0RWIX1])
      set PC0RM002.PC0RMPRC[PC0RWIXM] skip, invisible;
    end
    PC0RW00.PC0RWIX1 = PC0RW00.PC0RWIX1 + 1;
    PC0RW00.PC0RWIXM = PC0RW00.PC0RWIXM + 1;

  end

   /* ------------------------------------------------------------*/
   /* Process each of the detail lines in the PC0rw09 temp*/
   /* storage record.*/
   /* Based upon the record key move the appropriate line*/
   /* literal and plan or shipping number to the map fields,*/
   /* also the total quantity.*/
   /* ------------------------------------------------------------*/

  PC0RW00.PC0RWIXM = 1; /* Initialize map index*/
  PC0RW00.PC0RWIX1 = PC0RW00.PC0RWSPI[PC0RWCSP];

  while (PC0RW00.PC0RWIXM <= PC0RW00.PC0RWMAX /* Max lines (13)*/
   && PC0RW09.PC0RW09K[PC0RWIXM] != 0)
    if (PC0RW09K[PC0RWIXM] == 2) /* Plan detail record*/
      PC0RW02.PC0RW02G = PC0RW09.PC0RW09R[PC0RWIXM];
      PC0RW00.PC0RWSID = "PL";
      if (PC0RW02.PC0RWPLA == "    ")
        PC0RW02.PC0RWPLN = 0;
      end
      PC0RW00.PC0RWSDN = PC0RW02.PC0RWPLN;
      PC0RM002.PC0RMSTO[PC0RWIXM] = PC0RW02.PC0RWQTY;
    end

    if (PC0RW09K[PC0RWIXM] == 3) /* Shipping detail record*/
      PC0RW03.PC0RW03G = PC0RW09.PC0RW09R[PC0RWIXM];
      if (PC0RW09.PC0RWERR[PC0RWIXM] == "*")
        PC0RW00.PC0RWSID = "SH*";
      else
        PC0RW00.PC0RWSID = "SH";
      end
      PC0RW00.PC0RWSDN = PC0RW03.PC0RWSHP;
      PC0RM002.PC0RMSTO[PC0RWIXM] = PC0RW03.PC0RWQTY;
    end

    if (PC0RW09K[PC0RWIXM] == 4) /* Received detail record*/
      PC0RW04.PC0RW04G = PC0RW09.PC0RW09R[PC0RWIXM];
      if (PC0RW09.PC0RWERR[PC0RWIXM] == "*")
        PC0RW00.PC0RWSID = "RC*";
      else
        PC0RW00.PC0RWSID = "RC";
      end

      PC0RW00.PC0RWSDN = VFYPO002.SL1RCRNO; /* added by rdayal */
      /* MOVE PC0RW04.PC0RWRNO TO PC0RW00.PC0RWSDN;*/
      PC0RM002.PC0RMSTO[PC0RWIXM] = PC0RW04.PC0RWQTY;
    end

    if (PC0RW09K[PC0RWIXM] == 5) /* On order total*/
      PC0RW05.PC0RW05G = PC0RW09.PC0RW09R[PC0RWIXM];
      PC0RM002.PC0RMDLT[PC0RWIXM] = "ON ORDER";
      PC0RM002.PC0RMSTO[PC0RWIXM] = PC0RW05.PC0RWQTY;
      set PC0RM002.PC0RMDLT[PC0RWIXM] skip, bold;
      set PC0RM002.PC0RMSTO[PC0RWIXM] skip, bold;
    end

    if (PC0RW09K[PC0RWIXM] == 6) /* Shipped total*/
      PC0RW06.PC0RW06G = PC0RW09.PC0RW09R[PC0RWIXM];
      PC0RM002.PC0RMDLT[PC0RWIXM] = "INTRANSIT";
      PC0RM002.PC0RMSTO[PC0RWIXM] = PC0RW06.PC0RWQTY;
      set PC0RM002.PC0RMDLT[PC0RWIXM] skip, bold;
      set PC0RM002.PC0RMSTO[PC0RWIXM] skip, bold;
    end

    if (PC0RW09K[PC0RWIXM] == 7) /* Received total*/
      PC0RW07.PC0RW07G = PC0RW09.PC0RW09R[PC0RWIXM];
      PC0RM002.PC0RMDLT[PC0RWIXM] = "RECEIVED";
      PC0RM002.PC0RMSTO[PC0RWIXM] = PC0RW07.PC0RWQTY;
      set PC0RM002.PC0RMDLT[PC0RWIXM] skip, bold;
      set PC0RM002.PC0RMSTO[PC0RWIXM] skip, bold;
    end

    if (PC0RW09K[PC0RWIXM] == 8) /* Balance to ship*/
      PC0RW08.PC0RW08G = PC0RW09.PC0RW09R[PC0RWIXM];
      PC0RM002.PC0RMDLT[PC0RWIXM] = "TO SHIP";
      PC0RM002.PC0RMSTO[PC0RWIXM] = PC0RW08.PC0RWQTY;
      set PC0RM002.PC0RMDLT[PC0RWIXM] skip, bold;
      set PC0RM002.PC0RMSTO[PC0RWIXM] skip, bold;
    end

    if (PC0RW09K[PC0RWIXM] == 21) /* Plan detail record*/
      PC0RW21.PC0RW21G = PC0RW09.PC0RW09R[PC0RWIXM];
      PC0RW00.PC0RWSID = "PL";
      if (PC0RW21.PC0RWPLA == "    ")
        PC0RW21.PC0RWPLN = 0;
      end
      PC0RW00.PC0RWSDN = PC0RW21.PC0RWPLN;
      PC0RM002.PC0RMSTO[PC0RWIXM] = PC0RW21.PC0RWQTY;
    end
     /* Strip leading zeros from number*/

    if (PC0RW09K[PC0RWIXM] == 2
     || PC0RW09K[PC0RWIXM] == 3
     || PC0RW09K[PC0RWIXM] == 4
     || PC0RW09K[PC0RWIXM] == 21)
      PC0RW00.PC0RWTXT = PC0RW00.PC0RWSDA;
      PC0RS31();
      PC0RW00.PC0RWSDA = PC0RW00.PC0RWTXT;
      PC0RM002.PC0RMDLT[PC0RWIXM] = PC0RW00.PC0RWSLT;
    end

     /* Load the sizes for each record to the map*/

    PC0R223(); /* Load size detail*/

    PC0RW00.PC0RWIXM = PC0RW00.PC0RWIXM + 1;
  end


end // end PC0R222

// Load sizes quantities to map
Function PC0R223()

   /* ------------------------------------------------------------*/
   /* Move the size quantites from the pc0rw09 size field array*/
   /* to the map fields. If CSP allowed a 2 dimensional array*/
   /* this could be coded far more efficiently--no more said*/
   /* about this 'state of the art' language.*/

   /* pc0rwixm is the index used  for positioning in the*/
   /* pc0rw09 record and the map line.*/

   /* pc0rwix1 is the index used to determine if a size has*/
   /* a quantity and if so moves that field to the map.*/
   /* The index is set to the saved first positionin the*/
   /* size table for that page.*/

   /* pc0rwix2 is a 'dummy' index used to determin what*/
   /* size field to move the data into.*/

   /* ------------------------------------------------------------*/
    /* Move the size field from the pc0rw09 record to a quantity*/
    /* field size array in working storage.*/
   /* ------------------------------------------------------------*/

  PC0RW00.PC0RWSWA = PC0RW09.PC0RW09Z[PC0RWIXM];


  PC0RW00.PC0RWIX1 = PC0RW00.PC0RWSPI[PC0RWCSP];

  PC0RW00.PC0RWIX2 = 1;

  while (PC0RW00.PC0RWIX2 <= 10 /* While fields on the map and sizes*/
   && PC0RW00.PC0RWIX1 <= PC0RW00.PC0RWLSI)

    if (PC0RW00.PC0RWSTB[PC0RWIX1] == "Y")
      if (PC0RW00.PC0RWIX2 == 1)
        PC0RM002.PC0RMSQ1[PC0RWIXM] = PC0RW00.PC7ORIGQ[PC0RWIX1];
        if (PC0RW09.PC0RW09K[PC0RWIXM] == 5 /* Total fields*/
         || PC0RW09.PC0RW09K[PC0RWIXM] == 6 
         || PC0RW09.PC0RW09K[PC0RWIXM] == 7 
         || PC0RW09.PC0RW09K[PC0RWIXM] == 8)
          set PC0RM002.PC0RMSQ1[PC0RWIXM] skip, bold;
        end
        if (PC0RW09.PC0RW09K[PC0RWIXM] == 99) /* blank line*/
          set PC0RM002.PC0RMSQ1[PC0RWIXM] skip, invisible;
        end
      end

      if (PC0RW00.PC0RWIX2 == 2)
        PC0RM002.PC0RMSQ2[PC0RWIXM] = PC0RW00.PC7ORIGQ[PC0RWIX1];
        if (PC0RW09.PC0RW09K[PC0RWIXM] == 5 /* Total fields*/
         || PC0RW09.PC0RW09K[PC0RWIXM] == 6 
         || PC0RW09.PC0RW09K[PC0RWIXM] == 7 
         || PC0RW09.PC0RW09K[PC0RWIXM] == 8)
          set PC0RM002.PC0RMSQ2[PC0RWIXM] skip, bold;
        end
        if (PC0RW09.PC0RW09K[PC0RWIXM] == 99) /* blank line*/
          set PC0RM002.PC0RMSQ2[PC0RWIXM] skip, invisible;
        end
      end
      if (PC0RW00.PC0RWIX2 == 3)
        PC0RM002.PC0RMSQ3[PC0RWIXM] = PC0RW00.PC7ORIGQ[PC0RWIX1];
        if (PC0RW09.PC0RW09K[PC0RWIXM] == 5 /* Total fields*/
         || PC0RW09.PC0RW09K[PC0RWIXM] == 6 
         || PC0RW09.PC0RW09K[PC0RWIXM] == 7 
         || PC0RW09.PC0RW09K[PC0RWIXM] == 8)
          set PC0RM002.PC0RMSQ3[PC0RWIXM] skip, bold;
        end
        if (PC0RW09.PC0RW09K[PC0RWIXM] == 99) /* blank line*/
          set PC0RM002.PC0RMSQ3[PC0RWIXM] skip, invisible;
        end
      end

      if (PC0RW00.PC0RWIX2 == 4)
        PC0RM002.PC0RMSQ4[PC0RWIXM] = PC0RW00.PC7ORIGQ[PC0RWIX1];
        if (PC0RW09.PC0RW09K[PC0RWIXM] == 5 /* Total fields*/
         || PC0RW09.PC0RW09K[PC0RWIXM] == 6 
         || PC0RW09.PC0RW09K[PC0RWIXM] == 7 
         || PC0RW09.PC0RW09K[PC0RWIXM] == 8)
          set PC0RM002.PC0RMSQ4[PC0RWIXM] skip, bold;
        end
        if (PC0RW09.PC0RW09K[PC0RWIXM] == 99) /* blank line*/
          set PC0RM002.PC0RMSQ4[PC0RWIXM] skip, invisible;
        end
      end
      if (PC0RW00.PC0RWIX2 == 5)
        PC0RM002.PC0RMSQ5[PC0RWIXM] = PC0RW00.PC7ORIGQ[PC0RWIX1];
        if (PC0RW09.PC0RW09K[PC0RWIXM] == 5 /* Total fields*/
         || PC0RW09.PC0RW09K[PC0RWIXM] == 6 
         || PC0RW09.PC0RW09K[PC0RWIXM] == 7 
         || PC0RW09.PC0RW09K[PC0RWIXM] == 8)
          set PC0RM002.PC0RMSQ5[PC0RWIXM] skip, bold;
        end
        if (PC0RW09.PC0RW09K[PC0RWIXM] == 99) /* blank line*/
          set PC0RM002.PC0RMSQ5[PC0RWIXM] skip, invisible;
        end
      end

      if (PC0RW00.PC0RWIX2 == 6)
        PC0RM002.PC0RMSQ6[PC0RWIXM] = PC0RW00.PC7ORIGQ[PC0RWIX1];
        if (PC0RW09.PC0RW09K[PC0RWIXM] == 5 /* Total fields*/
         || PC0RW09.PC0RW09K[PC0RWIXM] == 6 
         || PC0RW09.PC0RW09K[PC0RWIXM] == 7 
         || PC0RW09.PC0RW09K[PC0RWIXM] == 8)
          set PC0RM002.PC0RMSQ6[PC0RWIXM] skip, bold;
        end
        if (PC0RW09.PC0RW09K[PC0RWIXM] == 99) /* blank line*/
          set PC0RM002.PC0RMSQ6[PC0RWIXM] skip, invisible;
        end
      end
      if (PC0RW00.PC0RWIX2 == 7)
        PC0RM002.PC0RMSQ7[PC0RWIXM] = PC0RW00.PC7ORIGQ[PC0RWIX1];
        if (PC0RW09.PC0RW09K[PC0RWIXM] == 5 /* Total fields*/
         || PC0RW09.PC0RW09K[PC0RWIXM] == 6 
         || PC0RW09.PC0RW09K[PC0RWIXM] == 7 
         || PC0RW09.PC0RW09K[PC0RWIXM] == 8)
          set PC0RM002.PC0RMSQ7[PC0RWIXM] skip, bold;
        end
        if (PC0RW09.PC0RW09K[PC0RWIXM] == 99) /* blank line*/
          set PC0RM002.PC0RMSQ7[PC0RWIXM] skip, invisible;
        end
      end
      if (PC0RW00.PC0RWIX2 == 8)
        PC0RM002.PC0RMSQ8[PC0RWIXM] = PC0RW00.PC7ORIGQ[PC0RWIX1];
        if (PC0RW09.PC0RW09K[PC0RWIXM] == 5 /* Total fields*/
         || PC0RW09.PC0RW09K[PC0RWIXM] == 6 
         || PC0RW09.PC0RW09K[PC0RWIXM] == 7 
         || PC0RW09.PC0RW09K[PC0RWIXM] == 8)
          set PC0RM002.PC0RMSQ8[PC0RWIXM] skip, bold;
        end
        if (PC0RW09.PC0RW09K[PC0RWIXM] == 99) /* blank line*/
          set PC0RM002.PC0RMSQ8[PC0RWIXM] skip, invisible;
        end
      end
      if (PC0RW00.PC0RWIX2 == 9)
        PC0RM002.PC0RMSQ9[PC0RWIXM] = PC0RW00.PC7ORIGQ[PC0RWIX1];
        if (PC0RW09.PC0RW09K[PC0RWIXM] == 5 /* Total fields*/
         || PC0RW09.PC0RW09K[PC0RWIXM] == 6 
         || PC0RW09.PC0RW09K[PC0RWIXM] == 7 
         || PC0RW09.PC0RW09K[PC0RWIXM] == 8)
          set PC0RM002.PC0RMSQ9[PC0RWIXM] skip, bold;
        end
        if (PC0RW09.PC0RW09K[PC0RWIXM] == 99) /* blank line*/
          set PC0RM002.PC0RMSQ9[PC0RWIXM] skip, invisible;
        end
      end
      if (PC0RW00.PC0RWIX2 == 10)
        PC0RM002.PC0RMSQ0[PC0RWIXM] = PC0RW00.PC7ORIGQ[PC0RWIX1];
        if (PC0RW09.PC0RW09K[PC0RWIXM] == 5 /* Total fields*/
         || PC0RW09.PC0RW09K[PC0RWIXM] == 6 
         || PC0RW09.PC0RW09K[PC0RWIXM] == 7 
         || PC0RW09.PC0RW09K[PC0RWIXM] == 8)
          set PC0RM002.PC0RMSQ0[PC0RWIXM] skip, bold;
        end
        if (PC0RW09.PC0RW09K[PC0RWIXM] == 99) /* blank line*/
          set PC0RM002.PC0RMSQ0[PC0RWIXM] skip, invisible;
        end
      end
      PC0RW00.PC0RWIX2 = PC0RW00.PC0RWIX2 + 1;
    end
    PC0RW00.PC0RWIX1 = PC0RW00.PC0RWIX1 + 1;
  end


end // end PC0R223

// Check attention ID
Function PC0R230()


   /* ------------------------------------------------------------*/
   /* Clear Map on PA2*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pa2) /* PA2 was pressed*/
    converseLib.clearScreen();
     /* Clear the map fields*/
    PC0RM002.XXXPRCNM = "PC0R";
    exit stack; /* Exit to redisplay map*/
  end

   /* ------------------------------------------------------------*/
   /* If FAST PATH was requested, transfer to application.*/
   /* ------------------------------------------------------------*/

  if (PC0RM002.CATOAP > " ") /* FAST PATH was requested*/
    if (converseVar.eventKey is enter) /* ENTER was pressed*/
      set PCWREC empty;
      COMMAREA.CATOAP = PC0RM002.CATOAP; /* TO application*/
      COMMAREA.CAITEM = PC0RM002.CAITEM; /* TO application key*/
      XSPCS01();
      COMMAREA.CATOAP = "PC0A";
      PCWREC.XXXMSGNO = 6;
      XSPCS01();
    else
      PC0RM002.XXXPRCNM = "PC0R230"; /* Module identification*/
      converseLib.validationFailed(05); /* Enter must be used for fast path*/
      exit stack;
    end
  end

  if (PC0RM002.CAITEM > " ") /* item entered*/
    set PC0RM002.CAITEM cursor, bold;
    PC0RM002.XXXPRCNM = "PC0R230"; /* Module identification*/
    converseLib.validationFailed(07);
    exit stack;
  end

   /* ------------------------------------------------------------*/
   /* on PF4 PF5 and pf21 transfer to requested application*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf4) /* Main menu requested*/
    set PCWREC empty;
    COMMAREA.CAITEM = " "; /* application from data*/
    COMMAREA.CATOAP = "MN0M";
    XSPCS01();
    PC0RM002.XXXPRCNM = "PC0R230";
    PC0RM002.VAGen_EZEMSG = COMMAREA.CAMSG; /* If bad transfer*/
    exit stack; /* Exit to redisplay map*/
  end


  if (converseVar.eventKey is pf5)
    set PCWREC empty;
    COMMAREA.CAITEM = " "; /* application from data*/
    XSPCS01();
    PC0RM002.XXXPRCNM = "PC0R230";
    PC0RM002.VAGen_EZEMSG = COMMAREA.CAMSG; /* If bad transfer*/
    exit stack; /* Exit to redisplay map*/
  end


   /* ------------------------------------------------------------*/
   /* Purge temporary storage on PF17 and transer to PC0L*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf17) /* pf17 pressed*/

    PC0R111(); /* Purge temp storage*/

    PCWREC.PO-REG-CD = VPOHDR02.PO-REG-CD;
    PCWREC.PC3POIDT = VPOHDR02.PC3POIDT;
    PCWREC.FY1FCTYC = VPOHDR02.FY1FCTYC;
    COMMAREA.CAITEM = " "; /* application from data*/
    COMMAREA.CATOAP = "PC0L";
    XSPCS01();
    PC0RM002.XXXPRCNM = "PC0R230";
    exit stack;
  end


  if (converseVar.eventKey is pf21)
    COMMAREA.CAITEM = " "; /* application from data*/
    COMMAREA.CATOAP = "PC0A";
    XSEXIT();
    PC0RM002.XXXPRCNM = "PC0R230";
    PC0RM002.VAGen_EZEMSG = COMMAREA.CAMSG; /* If bad transfer*/
    exit stack; /* Exit to redisplay map*/
  end

   /* ------------------------------------------------------------*/
   /* Validate scroll request if  PF 10 or pf 11*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf10
   || converseVar.eventKey is pf11)

    PC0R231(); /* Validate scroll request*/

    return; /* Exit to next process*/
  end

   /* ------------------------------------------------------------*/
   /* Validate scroll request if  PF 7 or PF8*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf7 /* Scroll back requested*/
   || converseVar.eventKey is pf8) /* Scroll forward requested*/

    PC0R232(); /* Validate scroll request*/

    return; /* Exit to next process*/
  end

   /* ------------------------------------------------------------*/
   /* Continue processing if following keys are pressed*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf3
   || converseVar.eventKey is enter
   || converseVar.eventKey is pf19)
  /* OR EZEAID IS PF20;*/
    return;
  end

   /* ------------------------------------------------------------*/
   /* Clear screen if PA1 or PA3 and exit to display map.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pa1 /* PA1 pressed*/
   || converseVar.eventKey is pa3) /* PA3 pressed*/
    set PC0RM002 initial; /* Clear the map fields*/
    exit stack; /* Exit to redisplay map*/
  end

   /* ------------------------------------------------------------*/
   /* At this point an invalid PF key has been pressed.*/
   /* ------------------------------------------------------------*/


  converseLib.validationFailed(04); /* Invalid PA/PF key*/
  exit stack;


end // end PC0R230

// Validate right/left scroll
Function PC0R231()



   /* ------------------------------------------------------------*/
   /* If scroll left was requested, and the first size page*/
   /* is displayed set the application size screen flag to 1.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf10 /* Scroll left request*/
   && PC0RW00.PC0RWCSP == 1)       /* Current size page on 1*/

    PC0RW00.PC0RWSRF = "1"; /* Map one requested*/
    exit stack;

  end

   /* ------------------------------------------------------------*/
   /* If scroll right was requested, ensure that pages exist.*/
   /* ------------------------------------------------------------*/



  if (converseVar.eventKey is pf11 /* Scroll right request*/
   && PC0RW00.PC0RWCSP >= PC0RW00.PC0RWSPG) /* and no more pages*/

    PC0RM002.XXXPRCNM = "PC0R231"; /* Module identification*/
    converseLib.validationFailed(76); /* No more pages to display*/
    exit stack;

  end




end // end PC0R231

// Validate up/down scroll
Function PC0R232()



   /* ------------------------------------------------------------*/
   /* If scroll back was requested, ensure that pages exist.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf7 /* Scroll back request*/
   && PC0RW00.PC0RWTSP < 2)       /* and no previous pages*/

    PC0RM002.XXXPRCNM = "PC0R232"; /* Module identification*/
    converseLib.validationFailed(2); /* No previous page to display*/

  end

   /* ------------------------------------------------------------*/
   /* If scroll forward was requested, ensure that pages exist.*/
   /* ------------------------------------------------------------*/



  if (converseVar.eventKey is pf8 /* Scroll forward request*/
   && PC0RW00.PC0RWTSP >= PC0RW00.TA5TSQIX) /* and no more pages*/

    PC0RM002.XXXPRCNM = "PC0R232"; /* Module identification*/
    converseLib.validationFailed(3); /* No more pages to display*/

  end

  if (converseVar.validationMsgNum != 0) /* Errors were found*/
    exit stack;
  end



end // end PC0R232

// Process valid input
Function PC0R240()
   /* ----------------------------------------------------*/
   /* If PF7 or PF8 has been pressed increment or*/
   /* decrement the page requested and return to the*/
   /* calling process.*/
   /* ----------------------------------------------------*/

  if (converseVar.eventKey is pf7)
    PC0RW00.PC0RWTSP = PC0RW00.PC0RWTSP - 1;
    return;
  end

  if (converseVar.eventKey is pf8)
    PC0RW00.PC0RWTSP = PC0RW00.PC0RWTSP + 1;
    return;
  end


   /* ----------------------------------------------------*/
   /* If PF11 has been pressed increment the page*/
   /* requested.*/
   /* ----------------------------------------------------*/

  if (converseVar.eventKey is pf11) /* Scroll right requested*/
    PC0RW00.PC0RWSPR = PC0RW00.PC0RWSPR + 1;
    exit stack;
  end

   /* ----------------------------------------------------*/
   /* If PF10 has been pressed decrement the page*/
   /* requested.*/
   /* ----------------------------------------------------*/

  if (converseVar.eventKey is pf10) /* Scroll left requested*/
    PC0RW00.PC0RWSPR = PC0RW00.PC0RWSPR - 1;
    exit stack;
  end

   /* ----------------------------------------------------*/
   /* If PF20 has been pressed perform T.S. Dump to*/
   /* program PC400D*/
   /* ----------------------------------------------------*/

  /* iF EZEAID IS PF20;                /* Print requested*/
  /* ;*/
  /* PERFORM PC0R500;     /* ===> process PF20, (T.S. dump  via TAOP)*/
  /* ;*/
  /* EZEFLO;*/
  /* ;*/
  /* END;*/

   /* ----------------------------------------------------*/
   /* If PF3 or PF19 have been pressed transfer back*/
   /* to the initially calling application (list screen)*/
   /* On a pf3 leave the pcwrec in tact--on PF19 clear*/
   /* the pcwrec.*/
   /* ----------------------------------------------------*/

  if (converseVar.eventKey is pf3) /* List screen requested*/
    COMMAREA.CAITEM = " "; /* Application from data*/
    COMMAREA.CATOAP = PC0RW10.CAFROMAP; /* To Application*/
    COMMAREA.CAUSERA = PCWREC.CAUSERA;
    XSPCS01();
  end

  if (converseVar.eventKey is pf19) /* Select screen requested*/
    COMMAREA.CAITEM = " "; /* Application from data*/
    set PCWREC empty;
    PCWREC.XGPCD = COMMAREA.XGPCD;
    COMMAREA.CAUSERA = PCWREC.CAUSERA;
    COMMAREA.CATOAP = PC0RW10.CAFROMAP; /* To Application*/
    XSPCS01();
  end

   /* ----------------------------------------------------*/
   /* PF21---menu requested*/
   /* ----------------------------------------------------*/

  if (converseVar.eventKey is pf21)
    COMMAREA.CAITEM = " "; /* Application from data*/
    COMMAREA.CATOAP = "PC0A"; /* To Application*/
    set PCWREC empty;
    XSPCS01();
    PC0RM001.XXXPRCNM = "PC0R240";
  end
   /* ----------------------------------------------------*/
   /* If enter is pressed check the next entry in the*/
   /* PCWREC destination array. If there is another*/
   /* destination set the obtain data flag to yes and*/
   /* initialize the working storage fields.*/
   /* If there are no more destinations transfer back*/
   /* to the initial calling application.*/
   /* ----------------------------------------------------*/

  if (converseVar.eventKey is enter) /* Enter was pressed*/
    PC0RW00.PC0RWIXP = PC0RW00.PC0RWIXP + 1;
    if (PCWREC.PCWWHSE[PC0RWIXP] != " "
     || PCWREC.PCWCUST[PC0RWIXP] != " ")

      PC0R161(); /* Set up for next destination*/
      PC0RW01.PC0RWFRD = PC0RW00.PC0RWIXP;

      return;

    else
      COMMAREA.CAITEM = " "; /* application from data*/
      COMMAREA.CATOAP = PC0RW10.CAFROMAP;
      XSPCS01();
    end
  end

  if (converseVar.validationMsgNum > 0)
    PC0RM001.XXXPRCNM = "PC0R240";
    exit stack;
  end
end // end PC0R240

// Fetch vpoitm01 row
Function PC0RS01()

   /* ------------------------------------------------------------*/
   /* If row not found return to previous process.*/
   /* If any other, indicate system error.*/
   /* ------------------------------------------------------------*/

  set PCYREC empty;
  PCYREC.PCYFUNC = "N8";

  try
    call "VPOITM05" (PCYREC, SQLCA, VPOITM05) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Row found*/
      return;
    end
    if (SQLCA.VAGen_SQLCODE == 100) /* Row not found*/
      PC0RW00.PC0RWICF = "Y"; /* Indicate cursor at EOF*/
      return;
    end

  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0RS01"; /* Process name*/
  TA1REC.TA1LOC = "FETCH ROW               ";
  TA1REC.TA1DBASE = "DPRODC  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VPOITM05"; /* Table view name*/
  TA1REC.TA1TBLKE = VPOITM05.VPOITM05-KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0RM001.XXXPRCNM = "PC0RS01";
  exit stack;

end // end PC0RS01

// Calculate dates
Function PC0RS02()

   /* -----------------------------------------------------*/
    /* Move the dates that do not need to be calculated*/
    /* from the PC6rec to working storage to format*/
    /* into MMDD format.  Then calculated the other dates*/
   /* ------------------------------------------------------*/

  set PC0RW02 empty; /* Initialize temp storage plan record*/
  set PC0RW21 empty;

    /* ETS*/

  if (VPOITM05.PC6ETSDT != 0)
    PC0RW00.PC0RWDDT = VPOITM05.PC6ETSDT; /* ETS date  to WS*/
    PC0RW02.PC0RWETS = PC0RW00.PC0RWSDT; /* MMDD screen format*/
    PC0RW21.PC0RWETS = PC0RW00.PC0RWSDT; /* MMDD screen format*/
  end

    /* PETS*/

  if (VPOITM05.PC6PETS != 0)
    PC0RW00.PC0RWDDT = VPOITM05.PC6PETS; /* PETS date  to WS*/
    PC0RW02.PC0RWPET = PC0RW00.PC0RWSDT; /* MMDD screen format*/
    PC0RW21.PC0RWPET = PC0RW00.PC0RWSDT; /* MMDD screen format*/
  end


    /* ETLO*/

  /* IF PC6REC.PC6OETAL NE 0;*/
  /* MOVE PC6REC.PC6OETAL TO PC0RW00.PC0RWDDT; /* ETLO date  to WS*/
  /* MOVE PC0RW00.PC0RWSDT TO PC0RW02.PC0RWETL; /* MMDD screen format*/
  /* END;*/

    /* RTA*/

  if (VPOITM05.PC6RTADT != 0)
    PC0RW00.PC0RWDDT = VPOITM05.PC6RTADT; /* RTA date  to WS*/
    PC0RW01.PC0RW-RTADT[PC0RWIXT] = VPOITM05.PC6RTADT; /* to WS table*/
    PC0RW02.PC0RWRTA = PC0RW00.PC0RWSDT; /* MMDD screen format*/
    PC0RW21.PC0RWRTA = PC0RW00.PC0RWSDT; /* MMDD screen format*/
  end


  set PCPREC empty;

  PCPREC.XGPCD = VPOITM05.XGPCD; /* GPC code*/
  PCPREC.FY1FCTYC = VPOITM05.FY1FCTYC; /* Factory code*/
  PCPREC.XWHCD = VPOITM05.XWHCD;
  PCPREC.PC2CUXID = VPOITM05.PC2CUXID;
  PCPREC.YMTCD = VPOITM05.YMTCD;
  PCPREC.PC6RTADT = VPOITM05.PC6RTADT; /* RTA date*/
  PCPREC.PC6ETSDT = VPOITM05.PC6ETSDT; /* Ets date*/
  PCPREC.PC4ORTYP = VPOITM05.PC4ORTYP; /* Order type*/
  PCPREC.PCPPOIDT = VPOITM05.PC3POIDT; /* P.O. ID Date*/
  PCPREC.PC6ETALF = VPOITM05.PC6ETALF; /* ETAL Default flag*/

  XSPCS05(); /* Calculate dates*/

  if (PCPREC.PCPRTSDT != 0)
    PC0RW00.PC0RWDDT = PCPREC.PCPRTSDT; /* RTS date  to WS*/
    PC0RW02.PC0RWRTS = PC0RW00.PC0RWSDT; /* MMDD screen format*/
    PC0RW21.PC0RWRTS = PC0RW00.PC0RWSDT; /* MMDD screen format*/
  end

  if (PCPREC.PCPETADT != 0)
    PC0RW00.PC0RWDDT = PCPREC.PCPETADT; /* ETA date  to WS*/
    PC0RW02.PC0RWETA = PC0RW00.PC0RWSDT; /* MMDD screen format*/
    PC0RW21.PC0RWETA = PC0RW00.PC0RWSDT; /* MMDD screen format*/
  end

  if (PCPREC.PCPETALD != 0)
    PC0RW00.PC0RWDDT = PCPREC.PCPETALD; /* ETAL date  to WS*/
    PC0RW02.PC0RWTAL = PC0RW00.PC0RWSDT; /* MMDD screen format*/
    PC0RW21.PC0RWTAL = PC0RW00.PC0RWSDT; /* MMDD screen format*/
  end



end // end PC0RS02

// Fetch size row
Function PC0RS03()

   /* ------------------------------------------------------------*/
   /* Initialize the record and load the key fields*/
   /* If row not found return to previous process.*/
   /* If any other, indicate system error.*/
   /* ------------------------------------------------------------*/

  VPOSIZ02.XGPCD = VPOITM05.XGPCD; /* GPC code*/
  VPOSIZ02.PO-REG-CD = VPOITM05.PO-REG-CD; /* PO REGION CODE*/
  VPOSIZ02.PC3PONBR = VPOITM05.PC3PONBR; /* PO number*/
  VPOSIZ02.PC6ITMNB = VPOITM05.PC6ITMNB; /* Item sequence number*/


  try
    call "VPOSIZ02" ("S ", SQLCA, VPOSIZ02) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Row found*/
      return;
    end

  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0RS03"; /* Process name*/
  TA1REC.TA1LOC = "FETCH SIZE ROW          ";
  TA1REC.TA1DBASE = "DPRODC  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VPOSIZ02"; /* Table view name*/
  TA1REC.TA1TBLKE = VPOSIZ02.VPOSIZ02-KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0RM001.XXXPRCNM = "PC0RS03";
  exit stack;

end // end PC0RS03

// Move data to temp storage rec
Function PC0RS04()
   /* ------------------------------------------------------------*/
   /* Move the data from the database records (item and size) to*/
   /* the PC0RW02 storage record--then move the storage group*/
   /* level to the temporary storage record (PC0RW09).*/
   /* Add the total ordered quantity from the VPOITM05 to the*/
   /* total ordered quantity in working storage.*/
   /* ------------------------------------------------------------*/



  PC0RW02.PC6ITMNB = VPOITM05.PC6ITMNB; /* Item sequence number*/
  PC0RW21.PC6ITMNB = VPOITM05.PC6ITMNB; /* Item sequence number*/
  PC0RW02.PC0RWPLN = VPOITM05.PC6PLAN;
  PC0RW21.PC0RWPLN = VPOITM05.PC6PLAN;
  PC0RW00.PC0RWTXT = PC0RW02.PC0RWPLA;
  PC0RW00.PC0RWTXT = PC0RW21.PC0RWPLA;
  PC0RS31(); /* Strip off leading zeros*/
  PC0RW02.PC0RWPLA = PC0RW00.PC0RWTXT;
  PC0RW21.PC0RWPLA = PC0RW00.PC0RWTXT;
  PC0RW02.YMTCD = VPOITM05.YMTCD;
  PC0RW21.YMTCD = VPOITM05.YMTCD;
  PC0RW02.XDSCD = VPOITM05.XDSCD;
  PC0RW21.XDSCD = VPOITM05.XDSCD;
  PC0RW02.PC6STAT = VPOITM05.PC6STAT;
  PC0RW21.PC6STAT = VPOITM05.PC6STAT;

  if (VPOITM05.OP1CUOID > 0) /* Customer order number entered*/
           /* ----------------------------------------------------------*/
           /* Get the APAO flag from the dprodc.VPRDCU03.*/
           /* ----------------------------------------------------------*/
    set VPRDCU03 empty;
    VPRDCU03.XGPCD = VPOITM05.XGPCD;
    VPRDCU03.PC2CUXID = VPOITM05.PC2CUXID;
    XSPCS59(); /* select cust xref row*/

    PC0RW00.PC0RWCOR = VPOITM05.OP1CUOID;
    PC0RW02.OP1CUOID = VPOITM05.OP1CUOID;
    PC0RW02.PC0RWORD = PC0RW00.PC0RWCOR;
    PC0RW02.PC0RWDOT = ".";
    PC0RW00.PC0RWNOR = VPOITM05.OP1NORID;
    PC0RW02.OP1NORID = VPOITM05.OP1NORID;
    set OP1REC empty; /* check for MSR order*/
    OP1REC.OP1PARTN = VPOITM05.OP1PARTN;
    OP1REC.OP1CUOID = VPOITM05.OP1CUOID;
    OP1REC.OP1NORID = VPOITM05.OP1NORID;

    if (VPRDCU03.PC-PRDCU-APAO-FL == "E")
      PC0RS35(); /* Select unique Deuro.veorhd01*/
    else
      PC0RS34(); /* Select unique DORDER.VORHDR01*/
    end

    if (SQLCA.VAGen_SQLCODE == 0
     && OP1REC.XPACD == "MS")
      PC0RW02.PC0RW-MSR-IND = "M";
    else
      PC0RW02.PC0RW-MSR-IND = " ";
    end
    PC0RW02.PC0RWNRD = PC0RW00.PC0RWNOR;
  else
    PC0RW02.PC0RWORD = " ";
    PC0RW02.PC0RWDOT = " ";
    PC0RW02.PC0RWNRD = " ";
  end

  PC0RW00.PC0RWSAP = VPOITM05.PC-SAP-PO-NBR;
  PC0RW21.PC0RWSAP = PC0RW00.PC0RWSAP;
     /* Updated date*/

  PC0RW00.PC0RWDDT = VPOITM05.ZZZCHGDT; /* Update date to WS*/
  PC0RW02.PC0RWUPD = PC0RW00.PC0RWSDT; /* MMDD date to temp storage*/
  PC0RW21.PC0RWUPD = PC0RW00.PC0RWSDT; /* MMDD date to temp storage*/


  PC0RW02.PC0RWQTY = VPOITM05.PC6TORDE; /* Quantity to storage*/
  PC0RW21.PC0RWQTY = VPOITM05.PC6TORDE; /* Quantity to storage*/


  PC0RW00.PC0RWTOR = PC0RW00.PC0RWTOR + VPOITM05.PC6TORDE;

   /* ------------------------------------------------------------*/
   /* Move the size quantities from the size array in the pc7rec*/
   /* to the size array in the temporary storage record (when*/
   /* there are quanitites for a size). In addition move a 'y'*/
   /* to the corresponding fields in the working storage array*/
   /* to indicate that the table entry had a quantity.  This*/
   /* flag will be used to determine what sizes will be*/
   /* displayed on the size screen.  (The users only want to*/
   /* see a size if it has a quantity associated with it).*/
   /* The FOB price is also moved to a 40 occurs table in*/
   /* the working storage record.*/
   /* Add the size quanitities into the size quantity array*/
   /* for plan data in working storage.*/
   /* ------------------------------------------------------------*/

  PC0RW00.PC0RWIX1 = 1; /* Initialize general index*/

  while (PC0RW00.PC0RWIX1 <= 40)
    if (VPOSIZ02.PC7ORDEQ[PC0RWIX1] != 0)
      PC0RW02.PC7ORIGQ[PC0RWIX1] = VPOSIZ02.PC7ORDEQ[PC0RWIX1];
      PC0RW00.PC0RWSTB[PC0RWIX1] = "Y"; /* size flag set to yes*/
      PC0RW00.PC0RWWSZ = 0; /* Initialize work field*/
      PC0RW00.PC0RWWSZ = PC0RW00.PC0RWWSZ + VPOSIZ02.PC7ORDEQ[PC0RWIX1];
       /* Add size quantity to total plan size quantity*/
      PC0RW00.PC0RWPZQ[PC0RWIX1] = PC0RW00.PC0RWPZQ[PC0RWIX1] + PC0RWWSZ;
    end
    if (PC0RW00.PC0RWICT == 1) /* First item size record*/
      PC0RW00.PC0RWPTB[PC0RWIX1] = VPOSIZ02.FY4FOBPR[PC0RWIX1];
      PC0RW00.PC7FOBFL[PC0RWIX1] = VPOSIZ02.PC7FOBFL[PC0RWIX1];
    end
    PC0RW00.PC0RWIX1 = PC0RW00.PC0RWIX1 + 1;
  end

   /* ------------------------------------------------------------*/
   /* Added security check.*/
   /* initialize to zeros or blanks the working storage price*/
   /* array and override flag array if the user doesn't have*/
   /* security to view the prices.*/
   /* ------------------------------------------------------------*/

  if (COMMAREA.CAILVL[10] == "Y")
     /* next sentence*/
  else
    move 0 to PC0RW00.PC0RWPTB[1] for all;
    move " " to PC0RW00.PC7FOBFL[1] for all;
  end


end // end PC0RS04

// Add record to temp storage
Function PC0RS05()

   /* ------------------------------------------------------------*/
   /* Add the next page to temporary storage.*/
   /* ------------------------------------------------------------*/

  PC0RW09.PC0RWTSL = PC0RW00.PC0RWTSL; /* Temporary storage length*/
  TA5REC.TA5APPID = COMMAREA.CACURRAP; /* Application identification*/
  TA5REC.TA5FNCCD = "A"; /* Function code*/

  try
    call "TA0050" (PC0RW09, TA5REC) {isNoRefresh = yes, isExternal = yes};
  end /* Temporary storage*/

   /* ------------------------------------------------------------*/
   /* If successful, initialize the storage areas and indicators*/
   /* to be used.  Return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && TA5REC.TA5RTNCD == 0)          /* and normal return code*/

    set PC0RW09 empty; /* Temp storage record*/

    PC0RW00.TA5TSQIX = TA5REC.TA5TSQIX; /* Highest page number*/
    TA5REC.TA5TSQIX = 0; /* Current page number*/
    PC0RW00.PC0RWIXT = 0; /* Temp storage line index*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TAEREC.TAEDESC1 = sysVar.errorCode; /* CSP return code*/
  TAEREC.TAEDESC2 = TA5REC.TA5DATA; /* Subroutine parameters*/

  PC0RM001.XXXPRCNM = "PC0RS05"; /* Module identification*/
  converseLib.validationFailed(01); /* Indicate system error*/

  TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  TA1REC.TA1TYPE = "APPL"; /* Type of error*/
  TA1REC.TA1LOC = "ADD PAGE TO TEMPORARY STORAGE";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = PC0RM001.XXXPRCNM; /* Program number*/
  TA1REC.TA1MAPAP = COMMAREA.CACURRAP; /* Map application*/
  TA1REC.TA1MAPNO = "PC0RM001"; /* Map number*/

  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end PC0RS05

// Fetch vcplhd02 row
Function PC0RS06()

   /* ------------------------------------------------------------*/
   /* If row not found return to previous process.*/
   /* If any other, indicate system error.*/
   /* ------------------------------------------------------------*/

  try
    call "IO4230" ("N3", SQLCA, TSTREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Row found*/
      return;
    end
    if (SQLCA.VAGen_SQLCODE == 100) /* Row not found*/
      PC0RW00.PC0RWTCF = "Y"; /* indicate cursor at EOF*/
      return;
    end

  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0RS06"; /* Process name*/
  TA1REC.TA1LOC = "FETCH ROW               ";
  TA1REC.TA1DBASE = "DTRANS  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCPLHD02"; /* Table view name*/
  TA1REC.TA1TBLKE = TSTREC.SY1STNBR; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0RM001.XXXPRCNM = "PC0RS06";
  exit stack;

end // end PC0RS06

// Open vcplit01 row
Function PC0RS07()

   /* ------------------------------------------------------------*/
   /* Declare cursor for Dtrans.Vcplit01*/
   /* ------------------------------------------------------------*/

  PC0RW00.PC0RWCCF = "N"; /* Set Carton cursor flag to no*/


  TSOREC.TSFSHPID = TSTREC.TSFSHPID; /* Nike ship ID*/
  TSOREC.TSIPLNBR = TSTREC.TSIPLNBR; /* Nike plan number*/


  try
    call "IO2580" ("S3", SQLCA, TSOREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/
    return;
  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0RS07"; /* Process name*/
  TA1REC.TA1LOC = "DECLARE CURSOR          ";
  TA1REC.TA1DBASE = "DTRANS  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCPLIT01"; /* Table view name*/
  TA1REC.TA1TBLKE = TSOREC.TSOKEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0RM001.XXXPRCNM = "PC0RS07";
  exit stack;

end // end PC0RS07

// Fetch vcplit01 row
Function PC0RS08()

   /* ------------------------------------------------------------*/
   /* If row not found return to previous process.*/
   /* If any other, indicate system error.*/
   /* ------------------------------------------------------------*/

  try
    call "IO2580" ("N3", SQLCA, TSOREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Row found*/
      return;
    end
    if (SQLCA.VAGen_SQLCODE == 100) /* Row not found*/
      PC0RW00.PC0RWCCF = "Y"; /* Indicate cursor at EOF*/
      return;
    end

  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0RS08"; /* Process name*/
  TA1REC.TA1LOC = "FETCH ROW               ";
  TA1REC.TA1DBASE = "DTRANS  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCPLIT01"; /* Table view name*/
  TA1REC.TA1TBLKE = TSOREC.TSOKEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0RM001.XXXPRCNM = "PC0RS08";
  exit stack;

end // end PC0RS08

// Close cursor for vcplit01
Function PC0RS09()

   /* ------------------------------------------------------------*/
   /* Close cursor for vcplit01*/
   /* ------------------------------------------------------------*/

  try
    call "IO2580" ("C3", SQLCA, TSOREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/
    return;
  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0RS09"; /* Process name*/
  TA1REC.TA1LOC = "CLOSE CURSOR            ";
  TA1REC.TA1DBASE = "DTRANS  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCPLIT01"; /* Table view name*/
  TA1REC.TA1TBLKE = TSOREC.TSOKEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0RM001.XXXPRCNM = "PC0RS09";
  exit stack;

end // end PC0RS09

// Calculate ETA & ETAL
Function PC0RS13()
   /* -----------------------------------------------------*/
    /* Move the dates that do not need to be calculated*/
    /* from the TSTREC to working storage to format*/
    /* into MMDD format.  Then calculated the other dates*/
   /* ------------------------------------------------------*/

    /* ETS (Estimated departure date)*/

  if (TSTREC.TSISTAT == "TN"
   || TSTREC.TSISTAT == "CR"
   || TSTREC.TSISTAT == "ER")
    PC0RW00.PC6OETS = TSTREC.TSFDPRTE; /* Estimate departure time*/
    PC0RW00.PC0RWDDT = TSTREC.TSFDPRTE; /* Estimate departure time*/
    if (PC0RW00.PC0RWSDT != 0)
      PC0RW03.PC0RWETS = PC0RW00.PC0RWSDT; /* MMDD screen format*/
    end
  else
    PC0RW00.PC6OETS = TSTREC.TSFDPRTA; /* Actual departure time*/
    PC0RW00.PC0RWDDT = TSTREC.TSFDPRTA; /* Actual departure time*/
    if (PC0RW00.PC0RWSDT != 0)
      PC0RW03.PC0RWETS = PC0RW00.PC0RWSDT; /* MMDD screen format*/
    end
  end


    /* ETA (Estimated time of arrival date)*/

  if (TSTREC.TSFDESTE != 0)
    PC0RW00.PC0RWDDT = TSTREC.TSFDESTE; /* ETS date  to WS*/
    PC0RW03.PC0RWETA = PC0RW00.PC0RWSDT; /* MMDD screen format*/
  end

    /* ETLO (Estimated time of arrival override date)*/

  if (TSTREC.TSIETALO != 0)
    PC0RW00.PC0RWDDT = TSTREC.TSIETALO; /* ETLO date  to WS*/
  /* MOVE PC0RW00.PC0RWSDT TO PC0RW03.PC0RWTLO; /* MMDD screen format*/
  end


   /* -----------------------------------------------------*/
    /* Calculate the ETAL (Estimated time of allocation)*/
    /* date. ETAL = ETA + PADD.*/
    /* For GPC code 03 if the etal day falls between the*/
    /* 26th and 1st of the month then default to the*/
    /* first of next month.*/
   /* ------------------------------------------------------*/


  set TA2REC empty; /* Initialize date record*/

  if (TSTREC.XWHCD != " "
   && TSTREC.XWHCD in XWHTBL.XWHCD)

    TA2REC.TA2DYAOD = XWHTBL.XWHPAD[sysVar.arrayIndex]; /* Warehouse PAD*/

  else

    TA2REC.TA2DYAOD = 0; /* no pad*/

  end

  if (TSTREC.TSFDESTA > 0)
    TA2REC.TA2GRGGN = TSTREC.TSFDESTA; /* actual dest dt*/
  else
    TA2REC.TA2GRGGN = TSTREC.TSFDESTE; /* estimated dest dt*/
  end

  PC0RS17(); /* Calculate ETA + PAD*/

  PC0RW00.PC0RWDDT = TA2REC.TA2GRGGN; /* ETA date  to WS*/

  if (PCWREC.XGPCD == "03")
    if (PC0RW00.PC0RWDDA < 26)
      /* next sentence*/
    else
      PC0RW00.PC0RWDDA = 1;
      if (PC0RW00.PC0RWDMO == 12)
        PC0RW00.PC0RWDMM = 1;
   /* ------------- y2k out begin ----------------*/
       /* PC0RW00.PC0RWDYR = PC0RW00.PC0RWDYR + 1;*/
   /* ------------- y2k out end ------------------*/
   /* ------------- y2k in  begin ----------------*/
        PC0RW00.PC0RWDCY = PC0RW00.PC0RWDCY + 1;
   /* ------------- y2k in end ------------------*/
      else
        PC0RW00.PC0RWDMM = PC0RW00.PC0RWDMM + 1;
      end
    end
  end

  if (PC0RW00.PC0RWSDT != 0)
    PC0RW03.PC0RWTAL = PC0RW00.PC0RWSDT; /* MMDD screen format*/
  end


end // end PC0RS13

// Add days to calculate date
Function PC0RS17()
   /* ------------------------------------------------------------*/
   /* Use the called module TA0040 to validate & convert dates.*/
   /* ------------------------------------------------------------*/

  TA2REC.TA2GRTYP = "G"; /* Type*/
  TA2REC.TA2DTOPT = "GREGGREG"; /* Validate and get all greg formats*/

   /* ------------------------------------------------------------*/
   /* Call TA0040*/
   /* ------------------------------------------------------------*/

  try
    call "TA0040" (TA2REC) {isNoRefresh = yes, isExternal = yes};
  end /* Date routine*/

   /* ------------------------------------------------------------*/
   /* If unsuccesful call, indicate a system error has occurred.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/
    return;
  else
    TAEREC.TAEDESC1 = sysVar.errorCode; /* CSP return code*/
    TAEREC.TAEDESC2 = TA2REC.TA2GRGG; /* date sent to validate*/

    PC0RM001.XXXPRCNM = "PC0RS17"; /* Module identification*/
    converseLib.validationFailed(01); /* Indicate system error*/

    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    TA1REC.TA1TYPE = "APPL"; /* Type of error*/
    TA1REC.TA1LOC = "CALL TO TA0040 TO EDIT DATE  ";
    TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
    TA1REC.TA1PGMNO = PC0RM001.XXXPRCNM; /* Program number*/
    TA1REC.TA1MAPAP = COMMAREA.CACURRAP; /* Map application*/
    TA1REC.TA1MAPNO = "M001"; /* Map number*/

    call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

    exit stack; /* Exit to display map*/
  end

end // end PC0RS17

// Obtain temp storage page
Function PC0RS18()


   /* ------------------------------------------------------------*/
   /* Obtain the next page of data from temporary storage*/
   /* ------------------------------------------------------------*/

  PC0RW09.PC0RWTSL = PC0RW00.PC0RWTSL; /* Temporary storage length*/
  TA5REC.TA5APPID = COMMAREA.CACURRAP; /* Application identification*/
  TA5REC.TA5TSQIX = PC0RW00.PC0RWTSP; /* Page number requested*/
  TA5REC.TA5FNCCD = "R"; /* Function code*/

  try
    call "TA0050" (PC0RW09, TA5REC) {isNoRefresh = yes, isExternal = yes};
  end /* Temporary storage*/

   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && TA5REC.TA5RTNCD == 0)          /* and normal return code*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TAEREC.TAEDESC1 = sysVar.errorCode; /* CSP return code*/
  TAEREC.TAEDESC2 = TA5REC.TA5DATA; /* Subroutine parameters*/

  PC0RM001.XXXPRCNM = "PC0RS18"; /* Module identification*/
  converseLib.validationFailed(01); /* Indicate system error*/

  TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  TA1REC.TA1TYPE = "APPL"; /* Type of error*/
  TA1REC.TA1LOC = "READ PAGE FROM TEMPORARY STORAGE";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = PC0RM001.XXXPRCNM; /* Program number*/
  TA1REC.TA1MAPAP = COMMAREA.CACURRAP; /* Map application*/
  TA1REC.TA1MAPNO = "M001"; /* Map number*/

  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end PC0RS18

// Select Unique Container Row
Function PC0RS20()

   /* ------------------------------------------------------------*/
   /* select unique alternate row from dtrans.vcntnr01*/
   /* ------------------------------------------------------------*/

  try
    call "IO2590" ("SA", SQLCA, TSHREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/
    return;
  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0RS20"; /* Process name*/
  TA1REC.TA1LOC = "SELECT UNIQUE           ";
  TA1REC.TA1DBASE = "DTRANS  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCNTNR01"; /* Table view name*/
  TA1REC.TA1TBLKE = TSHREC.TSHKEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0RM001.XXXPRCNM = "PC0RS20";
  exit stack;

end // end PC0RS20

// Get all sizes
Function PC0RS23()


  PC0RS07(); /* Declare cursor for vcplit01*/

  PC0RS08(); /* Fetch first vcplit01 row*/

  while (PC0RW00.PC0RWCCF != "Y")

    PC0RW00.PC0RWIX2 = TSOREC.SY5SZID; /* Work index*/

     /* Move  shipping qty from record to work field*/

    PC0RW00.PC0RWWSZ = TSOREC.TSOSHPQT;
     /* Add to shipping detail table*/
    PC0RW03.PC7ORIGQ[PC0RWIX2] = PC0RW03.PC7ORIGQ[PC0RWIX2] + PC0RWWSZ;
    if (TSTREC.TSISTAT == "IT"
     || TSTREC.TSISTAT == "CC")
       /* Add to the shipping size total table*/
      PC0RW00.PC0RWSZQ[PC0RWIX2] = PC0RW00.PC0RWSZQ[PC0RWIX2] + PC0RWWSZ;
    end

    PC0RW00.PC0RWSTB[PC0RWIX2] = "Y"; /* Indicate size has quantities*/

    PC0RS08(); /* Fetch next vcplit01 row*/

  end

  PC0RS09(); /* close vcplit01 cursor*/

end // end PC0RS23

// Fetch vfypo001 row
Function PC0RS24()

   /* ------------------------------------------------------------*/
   /* If row not found return to previous process.*/
   /* If any other, indicate system error.*/
   /* ------------------------------------------------------------*/

  try
    call "VFYPO002" ("N1", SQLCA, VFYPO002) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Row found*/
      return;
    end
    if (SQLCA.VAGen_SQLCODE == 100) /* Row not found*/
      PC0RW00.PC0RWRCF = "Y"; /* Indicate cursor at EOF*/
      return;
    end

  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0RS24"; /* Process name*/
  TA1REC.TA1LOC = "FETCH ROW               ";
  TA1REC.TA1DBASE = "DPRODC  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VFYPO002"; /* Table view name*/
  TA1REC.TA1TBLKE = VFYPO002.VFYPO002-KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0RM001.XXXPRCNM = "PC0RS24";
  exit stack;

end // end PC0RS24

// Fetch unique item row
Function PC0RS25()

   /* ------------------------------------------------------------*/
   /* If row not found return to previous process.*/
   /* If any other, indicate system error.*/
   /* ------------------------------------------------------------*/

  set VPOITM05 empty;
  VPOITM05.XGPCD = PCWREC.XGPCD;
  VPOITM05.PO-REG-CD = PCWREC.PO-REG-CD;
  VPOITM05.PC3PONBR = PCWREC.PC3PONBR;
  VPOITM05.PC6ITMNB = PC0RW09.PC6ITMNB[PC0RWIXM];

  set PCYREC empty;
  PCYREC.PCYFUNC = "S1";
  try
    call "VPOITM05" (PCYREC, SQLCA, VPOITM05) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Row found*/
      PCWREC.PC6RTADT = VPOITM05.PC6RTADT;
      PCWREC.PC6OETS = VPOITM05.PC6OETS;
      PCWREC.YMTCD = VPOITM05.YMTCD;
      return;
    end

  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0RS24"; /* Process name*/
  TA1REC.TA1LOC = "FETCH ROW               ";
  TA1REC.TA1DBASE = "DPRODC  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VPOITM05"; /* Table view name*/
  TA1REC.TA1TBLKE = VPOITM05.VPOITM05-KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0RM001.XXXPRCNM = "PC0RS25";
  exit stack;

end // end PC0RS25

// Get po header
Function PC0RS26()


  set VPOHDR02 empty;
  VPOHDR02.XGPCD = PCWREC.XGPCD;
  VPOHDR02.PO-REG-CD = PCWREC.PO-REG-CD;
  VPOHDR02.PC3PONBR = PCWREC.PC3PONBR;

   /* ------------------------------------------------------------*/
   /* Select a unique row.*/
   /* If row not found return a message to the user.*/
   /* If any other, indicate system error.*/
   /* ------------------------------------------------------------*/

  set PCYREC empty;
  PCYREC.PCYFUNC = "S ";
  try
    call "VPOHDR02" (PCYREC, SQLCA, VPOHDR02) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Row found*/


      return;

    end

  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0RS26"; /* PROCESS NAME*/
  TA1REC.TA1LOC = "SELECT UNIQUE ROW       ";
  TA1REC.TA1DBASE = "DPRODC  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VPOHDR02"; /* Table view name*/
  TA1REC.TA1TBLKE = VPOHDR02.VPOHDR02-KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0RM001.XXXPRCNM = "PC0RS26";
  exit stack;

end // end PC0RS26

// Validate ETALO date
Function PC0RS27()

   /* ------------------------------------------------------------*/
   /* Use the called module TA0040 to validate & convert dates.*/
   /* ------------------------------------------------------------*/

  TA2REC.TA2GRTYP = "A"; /* Type MMDDYY*/

  TA2REC.TA2DTOPT = "GREGGREG"; /* Validate and get all greg formats*/

   /* ------------------------------------------------------------*/
   /* Call TA0040*/
   /* ------------------------------------------------------------*/

  try
    call "TA0040" (TA2REC) {isNoRefresh = yes, isExternal = yes};
  end /* Date routine*/

   /* ------------------------------------------------------------*/
   /* If unsuccesful call, indicate a system error has occurred.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/
    return;
  else
    TAEREC.TAEDESC1 = sysVar.errorCode; /* CSP return code*/
    TAEREC.TAEDESC2 = TA2REC.TA2GRGG; /* date sent to validate*/

    converseLib.validationFailed(01); /* Indicate system error*/

    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    TA1REC.TA1TYPE = "APPL"; /* Type of error*/
    TA1REC.TA1LOC = "CALL TO TA0040 TO VERIFY DATE";
    TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
    TA1REC.TA1PGMNO = "PC0RS27"; /* Program number*/
    TA1REC.TA1MAPAP = COMMAREA.CACURRAP; /* Map application*/

    call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

    exit stack; /* Exit to display map*/
  end

end // end PC0RS27

// Open DTRANS.VCLPHD01 cursor
Function PC0RS28()
   /* ---------------------------------------------------------------------*/
             /* Declare curosor for DTRANS.VCPLHD01*/
   /* ---------------------------------------------------------------------*/


  try
    call "IO2570" ("S1", SQLCA, TSIREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select table set*/

  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Row found*/
      return;
    end

  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(19); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(01); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end


  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0RS28"; /* Process name*/
  TA1REC.TA1LOC = "DECLARE CURSOR          ";
  TA1REC.TA1DBASE = "DTRANS"; /* Data base name*/
  TA1REC.TA1TBLVU = "VCPLHD01"; /* Table view name*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0RM001.XXXPRCNM = "PC0RS28";
  exit stack;

end // end PC0RS28

// Update DTRANS.VCLPHD01
Function PC0RS29()


   /* ------------------------------------------------------------*/
   /* This module updates a table row.*/
   /* It will return and document system errors if unexpected*/
   /* return codes are found.*/
   /* ------------------------------------------------------------*/

  XX0XS01();

  TSIREC.ZZZCHGDT = XX0XW01.XX0XWDAT;
  TSIREC.ZZZCHGTM = XX0XW01.XX0XWTIM;



  try
    call "IO2570" ("U ", SQLCA, TSIREC) {isNoRefresh = yes, isExternal = yes};
  end /* update table row*/

  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Expected return codes*/

      return; /* Return to previous process*/

    end
  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(19); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(01); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
     /* Clear screen before redisplay*/
  end

  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback(); /* Rollback if bad return code*/

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0RS29 "; /* Process name*/
  TA1REC.TA1LOC = "UPDATE TABLE ROW";
  TA1REC.TA1DBASE = "DTRANS  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCPLHD01"; /* Table view name*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0RM001.XXXPRCNM = "PC0RS29"; /* Process name*/

  exit stack;

end // end PC0RS29

// Update temp storage
Function PC0RS30()

   /* ------------------------------------------------------------*/
   /* Update the page in temporary storage.*/
   /* ------------------------------------------------------------*/

  PC0RW09.PC0RWTSL = PC0RW00.PC0RWTSL; /* Temporary storage length*/
  TA5REC.TA5APPID = COMMAREA.CACURRAP; /* Application id*/
  TA5REC.TA5FNCCD = "U"; /* Function code*/

  try
    call "TA0050" (PC0RW09, TA5REC) {isNoRefresh = yes, isExternal = yes};
  end /* Temporary storage*/

   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && TA5REC.TA5RTNCD == 0)          /* and normal return code*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TAEREC.TAEDESC1 = sysVar.errorCode; /* CSP return code*/
  TAEREC.TAEDESC2 = TA5REC.TA5DATA; /* Subroutine parameters*/

  PC0RM001.XXXPRCNM = "PC0RS30"; /* Module identification*/
  converseLib.validationFailed(01); /* Indicate system error*/

  TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  TA1REC.TA1TYPE = "APPL"; /* Type of error*/
  TA1REC.TA1LOC = "UPDATE PAGE IN TEMPORARY STORAGE";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = PC0RM001.XXXPRCNM; /* Program number*/
  TA1REC.TA1MAPAP = COMMAREA.CACURRAP; /* Map application*/
  TA1REC.TA1MAPNO = "M001"; /* Map number*/

  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end PC0RS30

// Strip leading 0s for PO# & Qty
Function PC0RS31()
   /* ------------------------------------------------------------*/
    /* This routine will strip off leading zeros created from*/
    /* a numeric field being loaded/formatted to a character*/
    /* field.  The working storage field used in this process*/
    /* is identical to the length of the display fields on the*/
    /* map and is PC0RW00.PC0RWTXT. It will be indexed by*/
    /* PC0RW00.PC0RIXT on the positional field PC0RW00.PC0RWPOS*/
   /* ------------------------------------------------------------*/

  PC0RW00.PC0RWIXZ = 1; /* ===> temp. text index*/

  while (PC0RW00.PC0RWIXZ <= 9 /* ===> temp. text index*/
   && PC0RW00.PC0RWPOS[PC0RWIXZ] == "0") /* ===> text position*/

    PC0RW00.PC0RWPOS[PC0RWIXZ] = " "; /* ===> text position*/
    PC0RW00.PC0RWIXZ = PC0RW00.PC0RWIXZ + 1; /* ===> increment index*/

  end

end // end PC0RS31

// Fetch vcplhd01 row
Function PC0RS32()

   /* ------------------------------------------------------------*/
                 /* fetcg DTRAN.VCPLHD01 row*/
   /* If row not found return to previous process.*/
   /* If any other, indicate system error.*/
   /* ------------------------------------------------------------*/

  try
    call "IO2570" ("N1", SQLCA, TSIREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Row found*/
      return;
    end
    if (SQLCA.VAGen_SQLCODE == 100) /* Row not found*/
      PC0RW00.PC0RWTCF = "Y"; /* Indicate cursor at EOF*/
      return;
    end

  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(19); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(01); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0RS32"; /* Process name*/
  TA1REC.TA1LOC = "FETCH ROW               ";
  TA1REC.TA1DBASE = "DTRANS  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCPLHD01"; /* Table view name*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0RM001.XXXPRCNM = "PC0RS32";
  exit stack;

end // end PC0RS32

// Close cursor for vcplhd01
Function PC0RS33()

   /* ------------------------------------------------------------*/
   /* Close cursor for vcplhd01*/
   /* ------------------------------------------------------------*/

  try
    call "IO2570" ("C1", SQLCA, TSIREC) {isNoRefresh = yes, isExternal = yes};
  end /* close cursor*/

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/
    return;
  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(19); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(01); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0RS33"; /* Process name*/
  TA1REC.TA1LOC = "CLOSE CURSOR            ";
  TA1REC.TA1DBASE = "DTRANS  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCPLHD01"; /* Table view name*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0RM001.XXXPRCNM = "PC0RS09";
  exit stack;

end // end PC0RS33

// Select unique DORDER.VORHDR01
Function PC0RS34()
   /* ------------------------------------------------------------*/
   /* Select the row to display from the table.*/
   /* ------------------------------------------------------------*/

  try
    call "IO0430" ("S ", SQLCA, OP1REC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/

    if (SQLCA.VAGen_SQLCODE == 0 /* Normal return code*/
     || SQLCA.VAGen_SQLCODE == 100) /* row not found*/
      return; /* Return to previous process*/
    end

  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL Commarea*/


  PC0RM001.XXXPRCNM = "PC0RS34"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    converseLib.clearScreen();
     /* Clear screen before display*/

  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "SELECT THE TABLE ROW";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNM = PC0RM001.XXXPRCNM; /* Program number*/
  TA1REC.TA1DBASE = "DORDER  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VORHDR01"; /* Table view name*/
  TA1REC.TA1TBLKE = OP1REC.OP1KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/

   /* **                                                        ***/
   /* ********************** End of PC0RS34 ***********************/
end // end PC0RS34

// Select unique DEURO.VEORHD01
Function PC0RS35()
   /* ------------------------------------------------------------*/
   /* Select the row to display from the table.*/
   /* ------------------------------------------------------------*/

  try
    call "VEORHD01" ("S ", SQLCA, OP1REC) {isNoRefresh = yes, isExternal = yes};
  end /* Sel. row*/

   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/

    if (SQLCA.VAGen_SQLCODE == 0 /* Normal return code*/
     || SQLCA.VAGen_SQLCODE == 100) /* row not found*/
      return; /* Return to previous process*/
    end

  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL Commarea*/


  PC0RM001.XXXPRCNM = "PC0RS35"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    converseLib.clearScreen();
     /* Clear screen before display*/

  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "SELECT THE TABLE ROW";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNM = PC0RM001.XXXPRCNM; /* Program number*/
  TA1REC.TA1DBASE = "DORDER  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VORHDR01"; /* Table view name*/
  TA1REC.TA1TBLKE = OP1REC.OP1KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/

   /* **                                                        ***/
   /* ********************** End of PC0RS35 ***********************/
end // end PC0RS35

//*** RECORD=PC0RW00 ****
// ---------------------------
// Application Working Storage
// ---------------------------
// y2kproj     11-14-97     oricha   added pc0rwdcy (ccyy)
// ***********************
Record PC0RW00 type basicRecord
  5 * char(1580) ; 
    10 PC0RWRC PC0RWRC [4] ; 
    10 PC0RWSQ PC0RWSQ [4] ; 
    10 PC0RWTSL PC0RWTSL ; 
    10 PC0RWODF PC0RWODF ; 
    10 PC0RWSRF PC0RWSRF ; 
    10 TA5TSQIX TA5TSQIX ; 
    10 PC0RWPAG PC0RWPAG ; 
    10 PC0RWTSP PC0RWTSP ; 
    10 PC0RWICF PC0RWICF ; 
    10 PC0RWRCF PC0RWRCF ; 
    10 PC0RWTCF PC0RWTCF ; 
    10 PC0RWTUF PC0RWTUF ; 
    10 PC0RWCCF PC0RWCCF ; 
    10 PC0RWSDF PC0RWSDF ; 
    10 PC0RWRDF PC0RWRDF ; 
    10 PC0RWOSD PC0RWOSD ; 
    10 PC0RWPDF PC0RWPDF ; 
    10 PC0RWXDF PC0RWXDF ; 
    10 PC0RWTXT PC0RWTXT ; 
      15 PC0RWPOS PC0RWPOS [9] ; 
    10 PC0RWCNT PC0RWCNT ; 
    10 PC0RWICT PC0RWICT ; 
    10 PC0RWSPG PC0RWSPG ; 
    10 PC0RWCNP PC0RWCNP [3] ; 
      15 PC0RWINT PC0RWINT ; 
      15 PC0RWDEC PC0RWDEC ; 
    10 PC0RWSPR PC0RWSPR ; 
    10 PC0RWCSP PC0RWCSP ; 
    10 PC0RWETA PC0RWETA ; 
    10 PC0RWDDT PC0RWDDT ; 
      15 PC0RWDCY PC0RWDCY ; 
        20 PC0RWDCR PC0RWDCR ; 
        20 PC0RWDYR PC0RWDYR ; 
      15 PC0RWSDT PC0RWSDT ; 
        20 PC0RWDMM PC0RWDMM ; 
        20 PC0RWDDA PC0RWDDA ; 
    10 XGPCD XGPCD ; 
    10 PC0RWPID PC0RWPID ; 
      15 PC0RWSYR PC0RWSYR ; 
      15 PC0RWDH1 PC0RWDH1 ; 
      15 PC0RWPMO PC0RWPMO ; 
      15 PC0RWDH2 PC0RWDH2 ; 
      15 PC0RWDMO PC0RWDMO ; 
      15 PC0RWDH3 PC0RWDH3 ; 
      15 FY1FCTYC FY1FCTYC ; 
    10 PC0RWSLT PC0RWSLT ; 
      15 PC0RWSID PC0RWSID ; 
      15 PC0RWSDA PC0RWSDA ; 
        20 PC0RWSDN PC0RWSDN ; 
    10 PC6OETS PC6OETS ; 
    10 PC6PETS PC6PETS ; 
    10 PC6RTADT PC6RTADT ; 
    10 PC0RWFDT PC0RWFDT ; 
      15 PC0RWFCT PC0RWFCT ; 
      15 PC0RWYMD PC0RWYMD ; 
        20 PC0RWFYY PC0RWFYY ; 
        20 PC0RWFMM PC0RWFMM ; 
        20 PC0RWFDD PC0RWFDD ; 
    10 PC0RWMDT PC0RWMDT ; 
      15 PC0RWMMM PC0RWMMM ; 
      15 PC0RWMDD PC0RWMDD ; 
      15 PC0RWMYY PC0RWMYY ; 
    10 PC0RWEDT PC0RWEDT ; 
      15 PC0RWEDM PC0RWEDM ; 
      15 PC0RWEDD PC0RWEDD ; 
    10 TSIETALO TSIETALO ; 
    10 TA1TBLKE TA1TBLKE ; 
      15 PC0RWKA1 PC0RWKA1 ; 
      15 PC0RWKA2 PC0RWKA2 ; 
      15 PC0RWKA3 PC0RWKA3 ; 
      15 PC0RWKA4 PC0RWKA4 ; 
    10 PC0RWIXM PC0RWIXM ; 
    10 PC0RWIXZ PC0RWIXZ ; 
    10 PC0RWIX1 PC0RWIX1 ; 
    10 PC0RWIX2 PC0RWIX2 ; 
    10 PC0RWIX3 PC0RWIX3 ; 
    10 PC0RWIX4 PC0RWIX4 ; 
    10 PC0RWIX5 PC0RWIX5 ; 
    10 PC0RWIX6 PC0RWIX6 ; 
    10 PC0RWIXT PC0RWIXT ; 
    10 PC0RWIXP PC0RWIXP ; 
    10 PC0RWMAX PC0RWMAX ; 
    10 PC0RWMXJ PC0RWMXJ ; 
    10 PC0RWCSI PC0RWCSI ; 
    10 PC0RWFSI PC0RWFSI ; 
    10 PC0RWLSI PC0RWLSI ; 
    10 PC0RWSPI PC0RWSPI [4] ; 
    10 PC0RWTOR PC0RWTOR ; 
    10 PC0RWTSH PC0RWTSH ; 
    10 PC0RWTRC PC0RWTRC ; 
    10 PC0RWSTB PC0RWSTB [40] ; 
    10 PC0RWPTB PC0RWPTB [40] ; 
    10 FY4FOBPR FY4FOBPR [40] ; 
    10 PC7FOBFL PC7FOBFL [40] ; 
    10 PC0RWPZQ PC0RWPZQ [40] ; 
    10 PC0RWSZQ PC0RWSZQ [40] ; 
    10 PC0RWRZQ PC0RWRZQ [40] ; 
    10 PC0RWBZQ PC0RWBZQ [40] ; 
    10 PC0RWKEY PC0RWKEY ; 
    10 PC0RWSWA PC0RWSWA ; 
      15 PC7ORIGQ PC7ORIGQ [40] ; 
    10 PC0RWSQA PC0RWSQA ; 
      15 PC0RWSQ1 PC0RWSQ1 [10] ; 
    10 TSHSTAT TSHSTAT [8] ; 
    10 TSHNKCN TSHNKCN [8] ; 
    10 PC0RWSHQ PC0RWSHQ [8] ; 
    10 PC0RWWF1 PC0RWWF1 ; 
    10 PC0RWWF2 PC0RWWF2 ; 
    10 PC0RWWSZ PC0RWWSZ ; 
    10 PC0RWCOR PC0RWCOR ; 
    10 PC0RWNOR PC0RWNOR ; 
    10 XXXMSGNO XXXMSGNO ; 
    10 PC0RWSAP PC0RWSAP ; 
    10 PC0RWDTF PC0RWDTF ; 
end // end PC0RW00

//*** RECORD=PC0RW01 ****
// PC0rm001 map heading storage record
// ***********************
Record PC0RW01 type basicRecord
  5 PC0RW01G PC0RW01G ; 
    10 PC0RWPID PC0RWPID ; 
    10 PC0RWFRD PC0RWFRD ; 
    10 PC0RWTOD PC0RWTOD ; 
    10 PC3PONBR PC3PONBR ; 
    10 XWHCD XWHCD ; 
    10 PC2CUXID PC2CUXID ; 
    10 XGPCD XGPCD ; 
    10 PO-REG-CD PO-REG-CD ; 
    10 SY1STNBR SY1STNBR ; 
    10 SY2CLRID SY2CLRID ; 
    10 SY1STYNM SY1STYNM ; 
    10 SY2CLRAB SY2CLRAB ; 
    10 PC4ORTYP PC4ORTYP ; 
    10 XDMCD XDMCD ; 
    10 XQACD XQACD ; 
    10 PC2INSEG PC2INSEG ; 
    10 XPGCD XPGCD ; 
    10 XUMCD XUMCD ; 
    10 YMTCD YMTCD ; 
    10 PC0RWETO PC0RWETO ; 
    10 PC0RW-RTADT PC0RW-RTADT [100] ; 
    10 * char(1) ; 
end // end PC0RW01

//*** RECORD=PC0RW02 ****
// PC0rm001 map plan data and sizes record
//   This record is used for defining the plan item data
//   Record key is  2
// ************ maintenance log *******************************
// *  SR      logon     date         description
// *          ksanfo    04/27/93     added SO to record
// *
// *
// ************ maintenance log *******************************
// ***********************
Record PC0RW02 type basicRecord
  5 PC0RW02G PC0RW02G ; 
    10 PC6ITMNB PC6ITMNB ; 
    10 TSFSHPID TSFSHPID ; 
    10 TSIPLNBR TSIPLNBR ; 
    10 PC0RW02K PC0RW02K ; 
    10 PC0RW02D PC0RW02D ; 
      15 PC0RWPLA PC0RWPLA ; 
        20 PC0RWPLN PC0RWPLN ; 
      15 * char(3) ; 
      15 YMTCD YMTCD ; 
      15 * char(3) ; 
      15 XDSCD XDSCD ; 
      15 * char(3) ; 
      15 PC6STAT PC6STAT ; 
      15 * char(2) ; 
      15 PC0RWUPD PC0RWUPD ; 
      15 * char(1) ; 
      15 PC0RWRTS PC0RWRTS ; 
      15 * char(1) ; 
      15 PC0RWPET PC0RWPET ; 
      15 * char(2) ; 
      15 PC0RWETS PC0RWETS ; 
      15 * char(1) ; 
      15 PC0RWETA PC0RWETA ; 
      15 * char(1) ; 
      15 PC0RWRTA PC0RWRTA ; 
      15 * char(1) ; 
      15 PC0RWTAL PC0RWTAL ; 
      15 * char(1) ; 
      15 PC0RWORD PC0RWORD ; 
      15 PC0RWDOT PC0RWDOT ; 
      15 PC0RWNRD PC0RWNRD ; 
      15 PC0RW-MSR-IND PC0RW-MSR-IND ; 
      15 * char(1) ; 
      15 OP1CUOID OP1CUOID ; 
      15 OP1NORID OP1NORID ; 
    10 PC0RWQTY PC0RWQTY ; 
    10 PC0RW02Z PC0RW02Z ; 
      15 PC7ORIGQ PC7ORIGQ [40] ; 
end // end PC0RW02

//*** RECORD=PC0RW03 ****
// PC0rm001 map ship data and sizes record
//   This record is used to define the ship plan data
//   Record key is 3
// ***********************
Record PC0RW03 type basicRecord
  5 PC0RW03G PC0RW03G ; 
    10 * smallint ; 
    10 TSFSHPID TSFSHPID ; 
    10 TSIPLNBR TSIPLNBR ; 
    10 PC0RW03K PC0RW03K ; 
    10 PC0RW03D PC0RW03D ; 
      15 PC0RW03L PC0RW03L ; 
      15 PC0RWSHA PC0RWSHA ; 
        20 PC0RWSHP PC0RWSHP ; 
      15 * char(1) ; 
      15 YSSCD YSSCD ; 
      15 * char(1) ; 
      15 PC0RWSTD PC0RWSTD ; 
      15 * char(1) ; 
      15 TSACARCD TSACARCD ; 
      15 * char(1) ; 
      15 TS5CRAFT TS5CRAFT ; 
      15 * char(1) ; 
      15 TSFSHPNB TSFSHPNB ; 
      15 * char(1) ; 
      15 PC0RWETS PC0RWETS ; 
      15 * char(1) ; 
      15 PC0RWETA PC0RWETA ; 
      15 * char(6) ; 
      15 PC0RWTAL PC0RWTAL ; 
      15 * char(1) ; 
      15 PC0RWORD PC0RWORD ; 
      15 PC0RWDOT PC0RWDOT ; 
      15 PC0RWNRD PC0RWNRD ; 
      15 PC0RW-MSR-IND PC0RW-MSR-IND ; 
      15 * char(7) ; 
    10 PC0RWQTY PC0RWQTY ; 
    10 PC0RW03Z PC0RW03Z ; 
      15 PC7ORIGQ PC7ORIGQ [40] ; 
end // end PC0RW03

//*** RECORD=PC0RW04 ****
// PC0rm001 map receiving data and size record
//   This record is used to define the received data (receipt)
//   Record key is 4
// ************************************************************
// *                  MAINTENANCE LOB                         *
// *    sr#      DATE     USER ID         DESCRIPTION         *
// * -------- ---------   -------  ---------------------------*
// * TBL CHG   08/13/93    KSANFO  Added TS-NIKE-SHP-ID to    *
// *                               display of rcpt records    *
// ************************************************************
// ***********************
Record PC0RW04 type basicRecord
  5 PC0RW04G PC0RW04G ; 
    10 * smallint ; 
    10 * int ; 
    10 * smallint ; 
    10 PC0RW04K PC0RW04K ; 
    10 PC0RW04D PC0RW04D ; 
      15 PC0RW04L PC0RW04L ; 
      15 * char(2) ; 
      15 YMTCD YMTCD ; 
      15 * char(4) ; 
      15 YRSCD YRSCD ; 
      15 * char(1) ; 
      15 PC0RWRNA PC0RWRNA ; 
        20 PC0RWRNO PC0RWRNO ; 
      15 * char(2) ; 
      15 PC0RWSHP PC0RWSHP ; 
      15 * char(19) ; 
      15 PC0RWTLO PC0RWTLO ; 
      15 * char(1) ; 
      15 PC0RWORD PC0RWORD ; 
      15 PC0RWDOT PC0RWDOT ; 
      15 PC0RWNRD PC0RWNRD ; 
      15 PC0RW-MSR-IND PC0RW-MSR-IND ; 
      15 * char(7) ; 
    10 PC0RWQTY PC0RWQTY ; 
    10 PC0RW04Z PC0RW04Z ; 
      15 PC7ORIGQ PC7ORIGQ [40] ; 
end // end PC0RW04

//*** RECORD=PC0RW05 ****
// PC0rm001 map total order data and size record
//   This record is used to define the item plan total
//   Record key is 5
// ***********************
Record PC0RW05 type basicRecord
  5 PC0RW05G PC0RW05G ; 
    10 * smallint ; 
    10 * int ; 
    10 * smallint ; 
    10 PC0RW05K PC0RW05K ; 
    10 PC0RW05D PC0RW05D ; 
      15 * char(54) ; 
      15 PC0RW05L PC0RW05L ; 
      15 * char(8) ; 
    10 PC0RWQTY PC0RWQTY ; 
    10 PC0RW05Z PC0RW05Z ; 
      15 PC7ORIGQ PC7ORIGQ [40] ; 
end // end PC0RW05

//*** RECORD=PC0RW06 ****
// PC0rm001 map total ship data and size record
//   This record is used to define the ship total total
//   Record key is 6
// ***********************
Record PC0RW06 type basicRecord
  5 PC0RW06G PC0RW06G ; 
    10 * smallint ; 
    10 * int ; 
    10 * smallint ; 
    10 PC0RW06K PC0RW06K ; 
    10 PC0RW06D PC0RW06D ; 
      15 * char(53) ; 
      15 PC0RW06L PC0RW06L ; 
      15 * char(8) ; 
    10 PC0RWQTY PC0RWQTY ; 
    10 PC0RW06Z PC0RW06Z ; 
      15 PC7ORIGQ PC7ORIGQ [40] ; 
end // end PC0RW06

//*** RECORD=PC0RW07 ****
// PC0rm001 map total received data and size record
//   This record is used to define the receiving total data
//   Record key is 7
// ***********************
Record PC0RW07 type basicRecord
  5 PC0RW07G PC0RW07G ; 
    10 * smallint ; 
    10 * int ; 
    10 * smallint ; 
    10 PC0RW07K PC0RW07K ; 
    10 PC0RW07D PC0RW07D ; 
      15 * char(54) ; 
      15 PC0RW07L PC0RW07L ; 
      15 * char(8) ; 
    10 PC0RWQTY PC0RWQTY ; 
    10 PC0RW07Z PC0RW07Z ; 
      15 PC7ORIGQ PC7ORIGQ [40] ; 
end // end PC0RW07

//*** RECORD=PC0RW08 ****
// PC0rm001 map balance due record  and size record
//   This record is used to define the balance due data
//   Record key is 8
// ***********************
Record PC0RW08 type basicRecord
  5 PC0RW08G PC0RW08G ; 
    10 * smallint ; 
    10 * int ; 
    10 * smallint ; 
    10 PC0RW08K PC0RW08K ; 
    10 PC0RW08D PC0RW08D ; 
      15 * char(53) ; 
      15 PC0RW08L PC0RW08L ; 
      15 * char(8) ; 
    10 PC0RWQTY PC0RWQTY ; 
    10 PC0RW08Z PC0RW08Z ; 
      15 PC7ORIGQ PC7ORIGQ [40] ; 
end // end PC0RW08

//*** RECORD=PC0RW09 ****
// temporary storage record
// ********************* MAINTENANCE LOG **********************
// *
// *    SR     LOGON     DATE       DESCRIPTION
// *           KSANFO    04/27/93   ADDED SO TO RECORD
// *
// ********************* MAINTENANCE LOG **********************
// ***********************
Record PC0RW09 type basicRecord
  5 PC0RW09G PC0RW09G ; 
    10 PC0RWTSL PC0RWTSL ; 
    10 PC0RW09R PC0RW09R [14] ; 
      15 PC6ITMNB PC6ITMNB ; 
      15 TSFSHPID TSFSHPID ; 
      15 TSIPLNBR TSIPLNBR ; 
      15 PC0RW09K PC0RW09K ; 
      15 PC0RW09D PC0RW09D ; 
        20 * char(4) ; 
        20 PC0RWERR PC0RWERR ; 
        20 * char(66) ; 
        20 PC0RW9SO PC0RW9SO ; 
          25 OP1CUOID OP1CUOID ; 
          25 OP1NORID OP1NORID ; 
      15 PC0RWQTY PC0RWQTY ; 
      15 PC0RW09Z PC0RW09Z ; 
end // end PC0RW09

//*** RECORD=PC0RW10 ****
// ---------------------------
// Application commarea record
// ---------------------------
// ***********************
Record PC0RW10 type basicRecord
  5 PC0RWUSR PC0RWUSR ; 
    10 CAFROMAP CAFROMAP ; 
    10 PC0RWIXS PC0RWIXS ; 
    10 PC0RWTSP PC0RWTSP ; 
    10 XXXMSGNO XXXMSGNO ; 
end // end PC0RW10

//*** RECORD=PC0RW11 ****
// PC0RM001 map heading storage record, Reformatted for TAOP
//    and the batch application PC400D.
//    Note:
//           This record matched the include:
// 
//            COPYLIB:   WPC4001
// 
// 
// ***********************
Record PC0RW11 type basicRecord
  5 PC0RW11G PC0RW11G ; 
    10 PC0RW111 PC0RW111 ; 
      15 XX0XWTIM XX0XWTIM ; 
      15 PC0RWPID PC0RWPID ; 
      15 PC0RWNBR PC0RWNBR ; 
      15 XWHCD XWHCD ; 
      15 PC2CUXID PC2CUXID ; 
      15 XGPCD XGPCD ; 
      15 SY1STNBR SY1STNBR ; 
      15 SY2CLRID SY2CLRID ; 
      15 SY1STYNM SY1STYNM ; 
      15 * char(6) ; 
    10 PC0RW112 PC0RW112 ; 
      15 SY2CLRAB SY2CLRAB ; 
      15 PC4ORTYP PC4ORTYP ; 
      15 XDMCD XDMCD ; 
      15 XQACD XQACD ; 
      15 PC2INSEG PC2INSEG ; 
      15 XPGCD XPGCD ; 
      15 XUMCD XUMCD ; 
      15 * char(51) ; 
    10 PC0RW001 PC0RW001 ; 
      15 PC0RWSZ1 PC0RWSZ1 ; 
        20 PC0RWSD1 PC0RWSD1 [10] ; 
      15 * char(27) ; 
    10 PC0RW002 PC0RW002 ; 
      15 PC0RWSZ2 PC0RWSZ2 ; 
        20 PC0RWSD2 PC0RWSD2 [10] ; 
      15 * char(27) ; 
    10 PC0RW003 PC0RW003 ; 
      15 PC0RWSZ3 PC0RWSZ3 ; 
        20 PC0RWSD3 PC0RWSD3 [10] ; 
      15 * char(27) ; 
    10 PC0RW004 PC0RW004 ; 
      15 PC0RWSZ4 PC0RWSZ4 ; 
        20 PC0RWSD4 PC0RWSD4 [10] ; 
      15 * char(27) ; 
    10 PC0RWQL1 PC0RWQL1 ; 
      15 PC0RWQA1 PC0RWQA1 ; 
        20 PC0RWSQ1 PC0RWSQ1 [10] ; 
      15 * char(27) ; 
end // end PC0RW11

//*** RECORD=PC0RW12 ****
// PC0RM001 map Plan Data
//   This record is used for defining the plan item data
//   Record key is  "2".
// ***********************
Record PC0RW12 type basicRecord
  5 PC0RW12G PC0RW12G ; 
    10 PC0RWPLN PC0RWPLN ; 
    10 YMTCD YMTCD ; 
    10 XDSCD XDSCD ; 
    10 PC6STAT PC6STAT ; 
    10 PC0RWUPD PC0RWUPD ; 
    10 PC0RWRTS PC0RWRTS ; 
    10 PC0RWPET PC0RWPET ; 
    10 PC0RWETS PC0RWETS ; 
    10 PC0RWETA PC0RWETA ; 
    10 PC0RWRTA PC0RWRTA ; 
    10 PC0RWTAL PC0RWTAL ; 
    10 PC0RWETL PC0RWETL ; 
    10 PC0RWQTY PC0RWQTY ; 
    10 * char(29) ; 
end // end PC0RW12

//*** RECORD=PC0RW13 ****
// PC0RM001 map Ship data
//   This record is used to define the ship plan data
//   Record key is "3"
// ***********************
Record PC0RW13 type basicRecord
  5 PC0RW13G PC0RW13G ; 
    10 PC0RW03L PC0RW03L ; 
    10 PC0RWSHP PC0RWSHP ; 
    10 YSSCD YSSCD ; 
    10 PC0RWSTD PC0RWSTD ; 
    10 TSACARCD TSACARCD ; 
    10 TS5CRAFT TS5CRAFT ; 
    10 TSFSHPNB TSFSHPNB ; 
    10 PC0RWETS PC0RWETS ; 
    10 PC0RWETA PC0RWETA ; 
    10 PC0RWTAL PC0RWTAL ; 
    10 PC0RWTLO PC0RWTLO ; 
    10 PC0RWQTY PC0RWQTY ; 
    10 * char(24) ; 
end // end PC0RW13

//*** RECORD=PC0RW14 ****
// PC0RM001 map Receiving data
//   This record is used to define the receiving data
//   Record key is 4
// ***********************
Record PC0RW14 type basicRecord
  5 PC0RW14G PC0RW14G ; 
    10 PC0RW04L PC0RW04L ; 
    10 YMTCD YMTCD ; 
    10 YRSCD YRSCD ; 
    10 PC0RWRNO PC0RWRNO ; 
    10 PC0RWTLO PC0RWTLO ; 
    10 PC0RWQTY PC0RWQTY ; 
    10 * char(50) ; 
end // end PC0RW14

//*** RECORD=PC0RW15 ****
// PC0RM001 map Total Order Data
//   This record is used to define the item plan total
//   Record key is 5
// ***********************
Record PC0RW15 type basicRecord
  5 PC0RW15G PC0RW15G ; 
    10 PC0RW05L PC0RW05L ; 
    10 PC0RWQTY PC0RWQTY ; 
    10 * char(55) ; 
end // end PC0RW15

//*** RECORD=PC0RW16 ****
// PC0RM001 map Total Ship data
//   This record is used to define the ship total total
//   Record key is 6
// ***********************
Record PC0RW16 type basicRecord
  5 PC0RW16G PC0RW16G ; 
    10 PC0RW06L PC0RW06L ; 
    10 PC0RWQTY PC0RWQTY ; 
    10 * char(54) ; 
end // end PC0RW16

//*** RECORD=PC0RW17 ****
// PC0rm001 map total received data and size record
//   This record is used to define the receiving total data
//   Record key is 7
// ***********************
Record PC0RW17 type basicRecord
  5 PC0RW17G PC0RW17G ; 
    10 PC0RW07L PC0RW07L ; 
    10 PC0RWQTY PC0RWQTY ; 
    10 * char(55) ; 
end // end PC0RW17

//*** RECORD=PC0RW18 ****
// PC0RM001 map Balance Due record
//   This record is used to define the balance due data
//   Record key is 8
// ***********************
Record PC0RW18 type basicRecord
  5 PC0RW18G PC0RW18G ; 
    10 PC0RW08L PC0RW08L ; 
    10 PC0RWQTY PC0RWQTY ; 
    10 * char(54) ; 
end // end PC0RW18

//*** RECORD=PC0RW20 ****
// ************* PRODUCTION ORDER MAP RECORD ******************
// **               JCL W.S. Pass record                     **
// **                   (DD * cards)                         **
// 
//    RECORD NAME:      PC0RW20
// 
//    COPYLIB    :      WPC400D (used by Batch programs)
// 
//       This record is a working storage record to save and
//    and load an array of data used for JCL submisson.
//       It holds information that the user has selected
//    by pressing PF20  and is load to the TA6REC enabling
//    the JOB SUBMITTER SUBROUTINE (XPTAOP) to submit the job
//    appropriatly.  The COPYLIB member is the ++include that
//    the batch programs use in there processing of the data
//    passed.
// 
//      It consists of the following:
//            Record Key     --> Type of Data
//            Record Seqence --> Partitioned Data (part 1 etc.)
//            Record Data    --> Actual P.O. Data.
// 
// **                                                        **
// **                                                        **
// ************* PRODUCTION ORDER MAP RECORD ******************
// ***********************
Record PC0RW20 type basicRecord
  5 PC0RWR20 PC0RWR20 [500] ; 
    10 PC0RWKEY PC0RWKEY ; 
    10 PC0RWSEQ PC0RWSEQ ; 
    10 PC0RWPAR PC0RWPAR ; 
end // end PC0RW20

//*** RECORD=PC0RW21 ****
// PC0rm001 map plan data and sizes record
//   This record is used for defining the plan item data
//   Record key is  21.
// ***********************
Record PC0RW21 type basicRecord
  5 PC0RW21G PC0RW21G ; 
    10 PC6ITMNB PC6ITMNB ; 
    10 TSFSHPID TSFSHPID ; 
    10 TSIPLNBR TSIPLNBR ; 
    10 PC0RW21K PC0RW21K ; 
    10 PC0RW21D PC0RW21D ; 
      15 PC0RWPLA PC0RWPLA ; 
        20 PC0RWPLN PC0RWPLN ; 
      15 * char(3) ; 
      15 YMTCD YMTCD ; 
      15 * char(3) ; 
      15 XDSCD XDSCD ; 
      15 * char(3) ; 
      15 PC6STAT PC6STAT ; 
      15 * char(2) ; 
      15 PC0RWUPD PC0RWUPD ; 
      15 * char(1) ; 
      15 PC0RWRTS PC0RWRTS ; 
      15 * char(1) ; 
      15 PC0RWPET PC0RWPET ; 
      15 * char(2) ; 
      15 PC0RWETS PC0RWETS ; 
      15 * char(1) ; 
      15 PC0RWETA PC0RWETA ; 
      15 * char(1) ; 
      15 PC0RWRTA PC0RWRTA ; 
      15 * char(1) ; 
      15 PC0RWTAL PC0RWTAL ; 
      15 * char(4) ; 
      15 PC0RWSAP PC0RWSAP ; 
      15 * char(8) ; // op_cust_ord_id
    10 PC0RWQTY PC0RWQTY ; 
    10 PC0RW21Z PC0RW21Z ; 
      15 PC7ORIGQ PC7ORIGQ [40] ; 
end // end PC0RW21

//*** RECORD=PC0RW23 ****
// PC0RM001 map Plan Data
//   This record is used for defining the plan item data
//   Record key is  "21".
// ***********************
Record PC0RW23 type basicRecord
  5 PC0RW23G PC0RW23G ; 
    10 PC0RWPLN PC0RWPLN ; 
    10 YMTCD YMTCD ; 
    10 XDSCD XDSCD ; 
    10 PC6STAT PC6STAT ; 
    10 PC0RWUPD PC0RWUPD ; 
    10 PC0RWRTS PC0RWRTS ; 
    10 PC0RWPET PC0RWPET ; 
    10 PC0RWETS PC0RWETS ; 
    10 PC0RWETA PC0RWETA ; 
    10 PC0RWRTA PC0RWRTA ; 
    10 * char(4) ; // etal date
    10 PC0RWETL PC0RWETL ; 
    10 PC0RWQTY PC0RWQTY ; 
    10 * char(29) ; 
end // end PC0RW23

// MSR indicator
DataItem PC0RW-MSR-IND char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// RTA Date table
DataItem PC0RW-RTADT int {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// PC0RW11 size level (part 1)
DataItem PC0RW001 char(77)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// PC0RW11 size level (part 2)
DataItem PC0RW002 char(77)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// PC0RW11 size level (part 3)
DataItem PC0RW003 char(77)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// PC0RW11 size level (part 4)
DataItem PC0RW004 char(77)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pc0rw01 group level
DataItem PC0RW01G char(506)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// plan data
DataItem PC0RW02D char(77)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pc0rw01 group level
DataItem PC0RW02G char(253)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// record key
DataItem PC0RW02K num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// size data
DataItem PC0RW02Z char(160)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// ship data
DataItem PC0RW03D char(77)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pc0rw01 group level
DataItem PC0RW03G char(253)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// record key
DataItem PC0RW03K num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// ship literal
DataItem PC0RW03L char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// size data
DataItem PC0RW03Z char(160)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Receiving data
DataItem PC0RW04D char(77)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pc0rw01 group level
DataItem PC0RW04G char(253)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// record key
DataItem PC0RW04K num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// receiving literal
DataItem PC0RW04L char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// size data
DataItem PC0RW04Z char(160)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data
DataItem PC0RW05D char(77)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pc0rw01 group level
DataItem PC0RW05G char(253)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// record key
DataItem PC0RW05K num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// total order literal
DataItem PC0RW05L char(15)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// size data
DataItem PC0RW05Z char(160)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data
DataItem PC0RW06D char(77)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pc0rw01 group level
DataItem PC0RW06G char(253)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// record key
DataItem PC0RW06K num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// total shipped literal
DataItem PC0RW06L char(16)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// size data
DataItem PC0RW06Z char(160)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data
DataItem PC0RW07D char(77)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pc0rw01 group level
DataItem PC0RW07G char(253)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// record key
DataItem PC0RW07K num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// total received literal
DataItem PC0RW07L char(15)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// size data
DataItem PC0RW07Z char(160)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data
DataItem PC0RW08D char(77)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pc0rw01 group level
DataItem PC0RW08G char(253)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// record key
DataItem PC0RW08K num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// total received literal
DataItem PC0RW08L char(16)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// size data
DataItem PC0RW08Z char(160)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data
DataItem PC0RW09D char(77)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pc0rw09 group level
DataItem PC0RW09G char(3546)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// record key
DataItem PC0RW09K num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// pc0rw09 record data
DataItem PC0RW09R char(253)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// size data
DataItem PC0RW09Z char(160)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// PC0RW11 header level (part 1)
DataItem PC0RW111 char(77)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// PC0RW11 header level (part 2)
DataItem PC0RW112 char(77)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pc0rw01 group level
DataItem PC0RW11G char(539)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// PC0RW12 group level
DataItem PC0RW12G char(76)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// PC0RW13 group level
DataItem PC0RW13G char(76)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// PC0RW14 group level
DataItem PC0RW14G char(76)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// PC0RW15 group level
DataItem PC0RW15G char(76)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// PC0RW16 group level
DataItem PC0RW16G char(76)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// PC0RW17 group level
DataItem PC0RW17G char(76)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// PC0RW18 group level
DataItem PC0RW18G char(76)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// plan data
DataItem PC0RW21D char(77)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pc0rw01 group level
DataItem PC0RW21G char(253)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// record key
DataItem PC0RW21K num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// size data
DataItem PC0RW21Z char(160)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// PC0RW12 group level
DataItem PC0RW23G char(76)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem PC0RW9SO char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Balance to ship qty
DataItem PC0RWBZQ int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Confirm cancel flag
DataItem PC0RWCCF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// calc number of size pages
DataItem PC0RWCNP num(3,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Select field counter
DataItem PC0RWCNT num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// customer order number
DataItem PC0RWCOR num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Current size index
DataItem PC0RWCSI smallint {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Current size page
DataItem PC0RWCSP num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Database date century
DataItem PC0RWDCR num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// century/year ccyy
DataItem PC0RWDCY num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// database date day
DataItem PC0RWDDA num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Database date
DataItem PC0RWDDT num(8)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = nullFill, inputRequired = no
}
end

// decimal number
DataItem PC0RWDEC num(2,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Dash one
DataItem PC0RWDH1 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Dash two
DataItem PC0RWDH2 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Dash three
DataItem PC0RWDH3 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// database date month
DataItem PC0RWDMM num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// P.O. id second month
DataItem PC0RWDMO char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// '.' literal
DataItem PC0RWDOT char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// SAP/S.O data flag
DataItem PC0RWDTF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// database date year
DataItem PC0RWDYR num(2)  {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// etal date day
DataItem PC0RWEDD num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// etal date month
DataItem PC0RWEDM num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// etal date mmdd
DataItem PC0RWEDT num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Error indicator
DataItem PC0RWERR char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// ETA calculated
DataItem PC0RWETA char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// etlo date
DataItem PC0RWETL char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Entered ETALO date
DataItem PC0RWETO char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// ets date
DataItem PC0RWETS char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Reformat century
DataItem PC0RWFCT num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Reformat day
DataItem PC0RWFDD num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Reformat date CCYYmmdd
DataItem PC0RWFDT num(8)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Reformat month
DataItem PC0RWFMM num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// from destination
DataItem PC0RWFRD num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// First size index
DataItem PC0RWFSI smallint {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Reformat year
DataItem PC0RWFYY num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// item close flag
DataItem PC0RWICF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Count item records
DataItem PC0RWICT num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// integer number
DataItem PC0RWINT num(1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// General index 1
DataItem PC0RWIX1 smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// General index 2
DataItem PC0RWIX2 smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// General index 3
DataItem PC0RWIX3 smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// General index 4
DataItem PC0RWIX4 smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// General index 5
DataItem PC0RWIX5 smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// General index 6 (TAOP usage)
DataItem PC0RWIX6 smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Map index
DataItem PC0RWIXM smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Passed data index
DataItem PC0RWIXP smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// saved data index
DataItem PC0RWIXS smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Temporary storage index
DataItem PC0RWIXT smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Leading zero index
DataItem PC0RWIXZ smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// 1st field of key char
DataItem PC0RWKA1 char(10)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// 2nd field of key char
DataItem PC0RWKA2 char(10)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// 3rd field of key char
DataItem PC0RWKA3 char(10)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// 4th field of key char
DataItem PC0RWKA4 char(10)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Record Key
DataItem PC0RWKEY char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Last size index
DataItem PC0RWLSI smallint {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Max lines per map
DataItem PC0RWMAX smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// map day
DataItem PC0RWMDD num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Map date
DataItem PC0RWMDT char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Map month
DataItem PC0RWMMM num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Max lines for # fo DD* allowed
DataItem PC0RWMXJ smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// map year
DataItem PC0RWMYY num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// PC_PO_NBR
DataItem PC0RWNBR num(6)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Nike order number
DataItem PC0RWNOR num(3)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Nike Order nbr
DataItem PC0RWNRD char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Obtain data flag
DataItem PC0RWODF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Cust Order nbr
DataItem PC0RWORD char(9)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Obtain size data flag
DataItem PC0RWOSD char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// save Current T.S. page
DataItem PC0RWPAG num(4)  {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Record Parameter data
DataItem PC0RWPAR char(77)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// protect date flag
DataItem PC0RWPDF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pets date
DataItem PC0RWPET char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Map PO ID
DataItem PC0RWPID char(13)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Map plan number alpha
DataItem PC0RWPLA char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Map plan number
DataItem PC0RWPLN num(4)  {
  currency = no, numericSeparator = no, sign = none, 
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// P.O. Id first month
DataItem PC0RWPMO char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Char to stip leading zeros
DataItem PC0RWPOS char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// FOB price table
DataItem PC0RWPTB decimal(7,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Plan size quantity
DataItem PC0RWPZQ int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// size quantity array (part 1)
DataItem PC0RWQA1 char(50)  {
  align = right, fillCharacter = nullFill, inputRequired = no
}
end

// PC0RW11 qtys level (part 1)
DataItem PC0RWQL1 char(77)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// map total quantity
DataItem PC0RWQTY num(6)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Batch group level record
DataItem PC0RWR20 char(80)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// size buckets flag 10 per flag
DataItem PC0RWRC char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Received cursor flag
DataItem PC0RWRCF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Received data flag
DataItem PC0RWRDF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// map receiving rpt nbr alpha
DataItem PC0RWRNA char(7)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// map receiving rpt nbr
DataItem PC0RWRNO num(7)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// rta date
DataItem PC0RWRTA char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// rts date
DataItem PC0RWRTS char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// received size quantity
DataItem PC0RWRZQ int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// pc_sap_po_nbr
DataItem PC0RWSAP char(10)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// size description
DataItem PC0RWSD1 char(5)  {
  align = right, fillCharacter = nullFill, inputRequired = no
}
end

// size description
DataItem PC0RWSD2 char(5)  {
  align = right, fillCharacter = nullFill, inputRequired = no
}
end

// size description
DataItem PC0RWSD3 char(5)  {
  align = right, fillCharacter = nullFill, inputRequired = no
}
end

// size description
DataItem PC0RWSD4 char(5)  {
  align = right, fillCharacter = nullFill, inputRequired = no
}
end

// size detail number alpha
DataItem PC0RWSDA char(7)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Shipping data flag
DataItem PC0RWSDF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// size detail number
DataItem PC0RWSDN num(7)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Screen data
DataItem PC0RWSDT num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Record Sequence Key
DataItem PC0RWSEQ num(1)  {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// nike shipping number alpha
DataItem PC0RWSHA char(7)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// nike shipping number
DataItem PC0RWSHP num(7)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// TS_CPL_QTOT_SHP
DataItem PC0RWSHQ int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// size detail id
DataItem PC0RWSID char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// size detail literal
DataItem PC0RWSLT char(10)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Size page scroll counter
DataItem PC0RWSPG num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// size page index
DataItem PC0RWSPI smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Size page reqested
DataItem PC0RWSPR num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// sequence indicator for flag
DataItem PC0RWSQ num(1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// size quanity
DataItem PC0RWSQ1 num(5)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = nullFill, inputRequired = no
}
end

// size qty work array
DataItem PC0RWSQA char(50)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Screen request flag
DataItem PC0RWSRF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// size table flag
DataItem PC0RWSTB char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// status date
DataItem PC0RWSTD char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// size work array
DataItem PC0RWSWA char(160)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Season or year
DataItem PC0RWSYR char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// size description grp (part 1)
DataItem PC0RWSZ1 char(50)  {
  align = right, fillCharacter = nullFill, inputRequired = no
}
end

// size description grp (part 2)
DataItem PC0RWSZ2 char(50)  {
  align = right, fillCharacter = nullFill, inputRequired = no
}
end

// size description grp (part 3)
DataItem PC0RWSZ3 char(50)  {
  align = right, fillCharacter = nullFill, inputRequired = no
}
end

// size description grp (part 4)
DataItem PC0RWSZ4 char(50)  {
  align = right, fillCharacter = nullFill, inputRequired = no
}
end

// shipped size quantity
DataItem PC0RWSZQ int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// etal date
DataItem PC0RWTAL char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// trans cursor flag
DataItem PC0RWTCF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// etlo date
DataItem PC0RWTLO char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// to destination
DataItem PC0RWTOD num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Total ordered quantity
DataItem PC0RWTOR int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Total received quantity
DataItem PC0RWTRC int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Total shipped quantity
DataItem PC0RWTSH int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Temporary storage page length
DataItem PC0RWTSL num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Increment and decrement page
DataItem PC0RWTSP num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// trans updated flag
DataItem PC0RWTUF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Redefine numeric to strip zero
DataItem PC0RWTXT char(9)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// updated date
DataItem PC0RWUPD char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem PC0RWUSR char(14)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// work field 1
DataItem PC0RWWF1 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// work field 2
DataItem PC0RWWF2 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Size total work field
DataItem PC0RWWSZ int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// restrict date flag
DataItem PC0RWXDF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Reformat date yymmdd
DataItem PC0RWYMD num(6)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

