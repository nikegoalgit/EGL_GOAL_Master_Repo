package pc0h;
import corpcom1.*;
import corpcom2.*;
import corpcom3.*;
import corpcom4.*;
import corpcom5.*;
import corpcom6.*;
import corpcom7.*;
import corpx1.*;
import corpx2.*;
import corpy2.*;
import corpz3.*;
import fy.common.*;
import in1.common.*;
import pc.common.*;
import sy.common.*;
import ta.common.*;
import ts.common.*;
import vv.common.*;
//*** PROGRAM=PC0H ****
// This program will allow the user to inquire/maintain
// p.o. hdr special instruction information. The database
// will return 0 to n rows based upon the selection criteria.
// This program will format the screen with the data returned
// from the database.
// 
// This program enables the user to inquiry, add, change, or
// delete p.o. hdr special instruction rows.
// 
//   A user can select p.o. hdr special instruction rows
// for inquiry by general product group and p.o. number.  By
// pressing ENTER the data will be displayed for viewing.
// 
//   A user may add new rows by pressing PF13 from the list
// screen (blank or filled with rows).  This will position
// them in an ADD screen.  A row can then be added ( if
// entries pass edit criteria) by pressing ENTER.  The user
// may continue adding or exit to the list screen.
// 
//   A user may select one or more rows for change and press
// PF14.  The user will then be positioned in an CHANGE
// screen where they can apply their changes(non-key data only)
// and hit ENTER to cycle to the next row selected, or, PF3
// to return to the list screen.
// 
//   A user may select one or more rows for delete and press
// PF15.  The user will then be positioned in an DELETE
// screen where they will hit enter to confrim delete and
// cycle to the next row selected, or, PF3 to return to the
// list screen.
// 
// -------   -------- --------   -----------------------------
// control     date     userid    description
// -------   --------  --------   -----------------------------
//           06/26/89   rgilli    created
//           09/17/90   lsutto    allow GPC 07
//           10/01/93   dhales    fix for csp upgrade
//           04/03/97   jniese    changed to wait 2 seconds to
//                                ensure different timestamps
// PCA367    06/06/97   PHARWO    PPR PROJECT - PO VIEWS
// PCA367    07/12/97   jniese    PPR corrections
// *********************
Program PC0H type textUIProgram //VAGen Info - main text program
  {
  includeReferencedFunctions = yes, allowUnqualifiedItemReferences = yes, 
  throwNrfEofExceptions = yes, handleHardIOErrors = no, V60ExceptionCompatibility = yes, 
  I4GLItemsNullable = no, textLiteralDefaultIsString = no, localSQLScope = yes, 
  msgTablePrefix = "PC00", inputRecord = COMMAREA, segmented = yes
  }

  // Data Declarations
  COMMAREA COMMAREA ; // record
  ERRSQLCA ERRSQLCA; // record
  PC0HW01 PC0HW01; // record
  PC0HW02 PC0HW02; // record
  PCBREC PCBREC; // record
  PCDREC PCDREC; // record
  PCEREC PCEREC; // record
  PCWREC PCWREC; // record
  PCYREC PCYREC; // record
  SQLCA SQLCA; // record
  TA1REC TA1REC; // record
  TA2REC TA2REC; // record
  TA5REC TA5REC; // record
  TAEREC TAEREC; // record
  VPOAHD02 VPOAHD02; // record
  VPOHDR02 VPOHDR02; // record
  XX0XW01 XX0XW01; // record
  XX0XW02 XX0XW02; // record

  // VAGen Info - items needed for migration
  VAGen_EZESYS char(8);
  VAGen_EZEREPLY num(1);
  VAGen_EZE_WAIT_TIME bin(9,2);
  VAGen_EZE_ITEMLEN int;

  // Use Declarations
  use XGPTBL {deleteAfterUse = yes}; // table
  use YOATBL; // table
  use YSITBL {deleteAfterUse = yes}; // table
  use PC0HM.PC0HM001,  // forms
      PC0HM.PC0HM002, 
      PC0HM.XX0XM001
   {
    pfKeyEquate = no
  };

  function main()
    // VAGen Info - initialization needed for migration
    VAGen_EZESYS = VGLib.getVAGSysType();
    XPPC001: XPPC001();

     /* ------------------------------------------------------------*/
     /* flow to first time processing*/
     /* ------------------------------------------------------------*/

    goto PC0H001;

    PC0H001: PC0H001();

     /* ------------------------------------------------------------*/
     /* flow to converse the main process used to display map(s)*/
     /* ------------------------------------------------------------*/

    goto PC0H002;

    PC0H002: PC0H002();
     /* ------------------------------------------------------------*/
     /* flow to converse the main process used to display a map(s)*/
     /* ------------------------------------------------------------*/

    goto PC0H002;

  end // end main
end // end PC0H

// first time processing
Function PC0H001()
   /* ------------------------------------------------------------*/
   /* check commarea security fields*/
   /* ------------------------------------------------------------*/

  if (COMMAREA.XGPCD != "01"
   && COMMAREA.XGPCD != "02"
   && COMMAREA.XGPCD != "03"
   && COMMAREA.XGPCD != "07")
    COMMAREA.CAITEM = " ";
    PCWREC.XXXMSGNO = 138; /* security violation*/
    COMMAREA.CAUSERA = PCWREC.CAUSERA;
    COMMAREA.CATOAP = "PC0A";
    XSEXIT();
  end

  if (COMMAREA.CAFROMAP != "PC0L"
   && COMMAREA.CAFROMAP != "PC0E"
   && COMMAREA.CAFROMAP != "PC0G")
    COMMAREA.CAITEM = " ";
    PCWREC.XXXMSGNO = 191; /* security violation*/
    COMMAREA.CAUSERA = PCWREC.CAUSERA;
    COMMAREA.CATOAP = "PC0A";
    XSEXIT();
  end

   /* ------------------------------------------------------------*/
   /* first time processing*/
   /* ------------------------------------------------------------*/

  set PC0HW01 empty;
  set PC0HW02 empty;
  set TA1REC empty;
  set TA2REC empty;
  set TA5REC empty;
  set TAEREC empty;
  set SQLCA empty;
  set ERRSQLCA empty;
  set VPOHDR02 empty;
  set PCBREC empty;
  set PCDREC empty;
  set PCEREC empty;
  set PCYREC empty;

  PC0HW01.PC0HWCIX = 1; /* init cursor index*/
  PC0HW01.PC0HWMAP = "1"; /* init to map 1*/
  PC0HW01.PC0HWSWR = "Y"; /* init request for data switch*/
  PC0HW01.PC0HWBYF = "N"; /* init bypass processing switch*/

  PC0HW01.XGPCD = COMMAREA.XGPCD;
  PC0HW01.PO-REG-CD = PCWREC.PO-REG-CD;
  PC0HW01.PC3PONBR = PCWREC.PC3PONBR;
  PC0HW01.PC0HWPID = PCWREC.PC3POIDT;

   /* reformat p.o. id for display*/

  if (PC0HW01.PC0HWPID > 0)
    if (COMMAREA.XGPCD == "03")
      PC0HW01.PC0HWFPY = PCWREC.PCFSECD;
    else
      PC0HW01.PC0HWFPY = PC0HW01.PC0HWPOY;
    end
    PC0HW01.PC0HWFPM = PC0HW01.PC0HWPOM;
    PC0HW01.PC0HWFPD = PC0HW01.PC0HWPDM;
    PC0HW01.PC0HWFFC = PCWREC.FY1FCTYC;
    PC0HW01.PC0HWDS1 = "-";
    PC0HW01.PC0HWDS2 = "-";
    PC0HW01.PC0HWDS3 = "-";
  end

  if (COMMAREA.CAFROMAP != "PC0G")
    if (PCWREC.CAFROMAP[1] == " ")
      PCWREC.CAFROMAP[1] = "PC0H";
      PCWREC.PCWUSER1 = COMMAREA.CAFROMAP;
    else
      if (PCWREC.CAFROMAP[2] == " ")
        PCWREC.CAFROMAP[2] = "PC0H";
        PCWREC.PCWUSER2 = COMMAREA.CAFROMAP;
      else
        if (PCWREC.CAFROMAP[3] == " ")
          PCWREC.CAFROMAP[3] = "PC0H";
          PCWREC.PCWUSER3 = COMMAREA.CAFROMAP;
        else
          if (PCWREC.CAFROMAP[4] == " ")
            PCWREC.CAFROMAP[4] = "PC0H";
            PCWREC.PCWUSER4 = COMMAREA.CAFROMAP;
          end
        end
      end
    end
  else
    if (PCWREC.CAFROMAP[1] == "PC0H")
      COMMAREA.CAFROMAP = PCWREC.PCWUSER1;
      PCWREC.CAFROMAP[1] = " ";
    else
      if (PCWREC.CAFROMAP[2] == "PC0H")
        COMMAREA.CAFROMAP = PCWREC.PCWUSER2;
        PCWREC.CAFROMAP[2] = " ";
      else
        if (PCWREC.CAFROMAP[3] == "PC0H")
          COMMAREA.CAFROMAP = PCWREC.PCWUSER3;
          PCWREC.CAFROMAP[3] = " ";
        else
          if (PCWREC.CAFROMAP[4] == "PC0H")
            COMMAREA.CAFROMAP = PCWREC.PCWUSER4;
            PCWREC.CAFROMAP[4] = " ";
          end
        end
      end
    end
  end

  PC0HW01.PC0HWINQ = "N";
  if (COMMAREA.CAFROMAP == "PC0L")
    PC0HW01.PC0HWCIX = 1;
    while (PC0HW01.PC0HWCIX <= 4)
      if (PCWREC.CAFROMAP[PC0HWCIX] == "PC0L"
       && PCWREC.PCWFNC[PC0HWCIX] == "I")
        PC0HW01.PC0HWINQ = "Y";
      end
      PC0HW01.PC0HWCIX = PC0HW01.PC0HWCIX + 1;
    end
    PC0HW01.PC0HWCIX = 1;
  end

end // end PC0H001

// p.o. hdr spec instr inq/maint
Function PC0H002()

   /* ------------------------------------------------------------*/
   /* This is the main process used to display maps.  Processing*/
   /* always returns to the top of this process and falls through*/
   /* subordinate processes until an error is found or a valid*/
   /* request is processed.  Processing sequence is as follows:*/

   /* 1) If specified, display the first map.*/
      /* Otherwise, if specified, display the second map.*/
      /* Otherwise, indicate error and exit to Master Menu.*/

   /* ------------------------------------------------------------*/

   /* ------------------------------------------------------------*/
   /* Display the p.o. hdr special instruction - list screen*/
   /* ------------------------------------------------------------*/

  if (PC0HW01.PC0HWMAP == "1") /* Map 1 was requested*/
    PC0H100(); /* Display map 1*/
  end

   /* ------------------------------------------------------------*/
   /* Display the p.o. hdr special instruction - INQUIRY screen*/
   /* and control processing of 'S'elected data*/
   /* ------------------------------------------------------------*/

  if (PC0HW01.PC0HWMAP == "2" /* Map 2 was selected*/
   && PC0HW01.PC0HWFSW == "I") /* and INQUIRE function*/

    if (converseVar.validationMsgNum == 0
     && PC0HW01.PC0HWBYF == "N")
      PC0HW01.PC0HWIXM = 1; /* Initialize index*/
    end

    while (PC0HW01.PC0HWIXM <= 12 /* Until end of page*/
     && PC0HW01.PC0HWMAP == "2") /* and map 2*/

      if (PC0HM001.PC0HMSEL[PC0HWIXM] == "S") /* If line selected*/
        PC0H200(); /* Display INQUIRY Map*/
      end

      if (converseVar.validationMsgNum == 0 /* If no problems*/
       && PC0HW01.PC0HWBYF == "N")         
        PC0HW01.PC0HWIXM = PC0HW01.PC0HWIXM + 1; /* Increment index*/
      end
    end
    PC0HW01.PC0HWMAP = "1"; /* Set map number to 1*/
  end

   /* ------------------------------------------------------------*/
   /* Display the p.o. hdr special instruction - ADD screen*/
   /* ------------------------------------------------------------*/

  if (PC0HW01.PC0HWMAP == "2" /* Map 2 was requested*/
   && PC0HW01.PC0HWFSW == "A") /* and ADD function*/
    PC0H300(); /* Display Add Map*/
  end

   /* ------------------------------------------------------------*/
   /* Display the p.o. hdr special instruction - CHANGE screen*/
   /* and control processing of 'S'elected data*/
   /* ------------------------------------------------------------*/

  if (PC0HW01.PC0HWMAP == "2" /* Map 2 was selected*/
   && PC0HW01.PC0HWFSW == "C") /* and CHANGE function*/

    if (converseVar.validationMsgNum == 0
     && PC0HW01.PC0HWBYF == "N")
      PC0HW01.PC0HWIXM = 1; /* Initialize index*/
    end

    while (PC0HW01.PC0HWIXM <= 12 /* Until end of page*/
     && PC0HW01.PC0HWMAP == "2") /* and map 2*/

      if (PC0HM001.PC0HMSEL[PC0HWIXM] == "S") /* If line selected*/
        PC0H400(); /* Display CHANGE screen*/
      end

      if (converseVar.validationMsgNum == 0 /* If no problems*/
       && PC0HW01.PC0HWBYF == "N")         
        PC0HW01.PC0HWIXM = PC0HW01.PC0HWIXM + 1; /* Incr index*/
      end

    end
    PC0HW01.PC0HWMAP = "1"; /* Set map number to 1*/
  end


   /* ------------------------------------------------------------*/
   /* Display the p.o. hdr special instruction - DELETE screen*/
   /* and control processing of 'S'elected data*/
   /* ------------------------------------------------------------*/

  if (PC0HW01.PC0HWMAP == "2" /* Map 2 was selected*/
   && PC0HW01.PC0HWFSW == "D") /* and DELETE function*/

    if (converseVar.validationMsgNum == 0
     && PC0HW01.PC0HWBYF == "N")
      PC0HW01.PC0HWIXM = 1; /* Initialize index*/
    end

    while (PC0HW01.PC0HWIXM <= 12 /* Until end of page*/
     && PC0HW01.PC0HWMAP == "2") /* and map 2*/

      if (PC0HM001.PC0HMSEL[PC0HWIXM] == "S") /* If line selected*/
        PC0H500(); /* Display CHANGE screen*/
      end

      if (converseVar.validationMsgNum == 0 /* If no problems*/
       && PC0HW01.PC0HWBYF == "N")         
        PC0HW01.PC0HWIXM = PC0HW01.PC0HWIXM + 1; /* Increment index*/
      end

    end
    PC0HW01.PC0HWMAP = "1"; /* Set map number to 1*/
  end


   /* ------------------------------------------------------------*/
   /* If invalid map number terminate processing*/
   /* ------------------------------------------------------------*/

  if (PC0HW01.PC0HWMAP == "1"
   || PC0HW01.PC0HWMAP == "2")

     /* next sentence*/
  else

    TA1REC.TA1TYPE = "APPL"; /* Type of error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    TA1REC.TA1PGMNM = "PC0H002 "; /* Process name*/
    TA1REC.TA1LOC = "MAIN APPLICATION PROCESS";
    TA1REC.TA1MAP = PC0HW01.PC0HWMAP; /* Map name*/
    TAEREC.TAEDESC1 = "MAP NUMBER IS INVALID";

    call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diag routine*/
  end


   /* ------------------------------------------------------------*/
   /* If invalid function switch terminate processing*/
   /* ------------------------------------------------------------*/

  if (PC0HW01.PC0HWMAP == "2")
    if (PC0HW01.PC0HWFSW == "A"
     || PC0HW01.PC0HWFSW == "I"
     || PC0HW01.PC0HWFSW == "C"
     || PC0HW01.PC0HWFSW == "D")

       /* next sentence*/

    else
      TA1REC.TA1TYPE = "APPL"; /* Type of error*/
      TA1REC.TA1FUNC = "RETN"; /* Termination function*/
      TA1REC.TA1PGMNM = "PC0H002 "; /* Process name*/
      TA1REC.TA1LOC = "MAIN APPLICATION PROCESS";
      TA1REC.TA1MAP = PC0HW01.PC0HWMAP; /* Map name*/
      TAEREC.TAEDESC1 = "MAP FUNCTION IS INVALID";

      call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diag routine*/
    end
  end

end // end PC0H002

// p.o. hdr spec instr list
Function PC0H100()

   /* ------------------------------------------------------------*/
   /* This is the main process used to display a map.  Processing*/
   /* always returns to the top of this process and falls through*/
   /* subordinate processes until an error is found or a valid*/
   /* request is processed.  Processing sequence is as follows:*/

   /* 1) Obtain the data to display.*/
   /* 2) Format the map output area and display the map.*/
   /* 3) Check the attention identifier used to respond.*/
   /* 4) Reset highlighted fields to normal intensity.*/
   /* 5) Verify the data that was entered.*/
   /* 6) Process a valid input request.*/

   /* ------------------------------------------------------------*/

  PC0H110(); /* Obtain the data to display*/

  PC0H120(); /* Format and display the map*/

  PC0H130(); /* Check attention identifier*/

  PC0H140(); /* Reset fields to normal intensity*/

  PC0H150(); /* Verify the entered data*/

  PC0H160(); /* Process valid input request*/


end // end PC0H100

// Obtain the data to display
Function PC0H110()

   /* ------------------------------------------------------------*/
     /* Purge any existing queue in temporary storage.*/
     /* Select and open the cursor for the set(s) to be formatted*/
     /* Fetch and format the data in the page.*/
     /* If the page is full, add the page to the storage queue.*/
     /* At end of rows, add any partial page to the queue.*/
     /* At end of rows, close the selected set cursor.*/
     /* If no data found, display error message and return to*/
       /* previous process.*/
     /* Indicate that the request for data was completed.*/
   /* ------------------------------------------------------------*/

  if (PC0HW01.PC0HWSWR == "N") /* Data not requested*/

    return;

  end


  PC0HS01(); /* Purge any temporary storage*/

  set PCEREC empty; /* Clear p.o. hdr spec instr record*/
  set PC0HW02 empty; /* Clear temporary storage record*/
  set PC0HM001 initial; /* Clear map pc0hm001*/
  PC0HW01.PC0HWCIX = 1; /* reset cursor index*/
  PC0HW01.PC0HWPSW = "N"; /* reset problem switch*/

   /* ------------------------------------------------------------*/
   /* load key fields for display*/
   /* ------------------------------------------------------------*/

  PC0HM001.XGPCD = PC0HW01.XGPCD;
  PC0HM001.PC3PONBR = PC0HW01.PC3PONBR;
  PC0HM001.PC0HMPOI = PC0HW01.PC0HWFPI;

   /* Select requested p.o. header special instruction rows*/

  PCEREC.XGPCD = PC0HW01.XGPCD;
  PCEREC.PC3PONBR = PC0HW01.PC3PONBR;

  PC0HS02(); /* Select set and open the cursor*/

  if (SQLCA.VAGen_SQLCODE == 0) /* No errors were found*/
    PC0HW01.PC0HWIXM = 1; /* Initialize display line number*/
    PC0HW01.PC0HWPOW = "N"; /* Initialize end of file switch*/

    PC0HS03(); /* Fetch pcerec row*/

    while (PC0HW01.PC0HWPOW == "N") /* Until end of set or problem found*/

       /* load temporary storage record pc0hw02*/

      PC0HW02.XGPCD[PC0HWIXM] = PCEREC.XGPCD;
      PC0HW02.PCASINBR[PC0HWIXM] = PCEREC.PCASINBR;
      PC0HW02.YSICD[PC0HWIXM] = PCEREC.YSICD;
      PC0HW02.PCASIDSC[PC0HWIXM] = PCEREC.PCASIDSC;
      PC0HW02.PCEPRSEQ[PC0HWIXM] = PCEREC.PCEPRSEQ;

       /* load source description*/

      if (PCEREC.PCESIID == "N")
        PC0HW02.PC0HMSRC[PC0HWIXM] = "NIKE";
      else
        if (PCEREC.PCESIID == "C")
          PC0HW02.PC0HMSRC[PC0HWIXM] = "CUST";
        else
          if (PCEREC.PCESIID == "P")
            PC0HW02.PC0HMSRC[PC0HWIXM] = "P.O.";
          else
            PC0HW02.PC0HMSRC[PC0HWIXM] = " ";
          end
        end
      end

      PC0HW02.ZZZCHGCT[PC0HWIXM] = PCEREC.ZZZCHGCT;

      if (PC0HW01.PC0HWIXM >= 12)
        PC0HS04(); /* Add page to temp storage*/
      else
        PC0HW01.PC0HWIXM = PC0HW01.PC0HWIXM + 1; /* Incr. index*/
      end

      PC0HS03(); /* Fetch pcerec row*/

    end

    PC0HW01.PC0HWTSP = 1; /* Initialize page number*/

    PC0HS05(); /* Close set of pcerec rows*/

  end

  if (PC0HW01.PC0HWPSW == "N" /* no errors*/
   && PC0HW01.PC0HWIXM > 1)   /* additional data for temp storage*/

    PC0HS04(); /* add page to temp storage*/

  end

  if (PC0HW01.TA5TSQIX == 0) /* No data to display*/
    PC0HW01.PC0HWPSW = "Y"; /* indicate error exists*/
    converseLib.validationFailed(312); /* Indicate no data to display*/
    PC0HM001.XXXPRCNM = "PC0H110"; /* process name*/
  else
    PC0HW01.PC0HWSWR = "N"; /* Request for data completed*/
  end

end // end PC0H110

// Format and display the map
Function PC0H120()

   /* ------------------------------------------------------------*/
   /* If no error(s) to display, format the selected data.*/
   /* Indicate sound audible alarm for any error.*/
   /* ------------------------------------------------------------*/

   /* ------------------------------------------------------------*/
   /* If data has no message to display load list screen*/
   /* ------------------------------------------------------------*/

  if (converseVar.validationMsgNum == 0 /* no message to display*/
   || PC0HW01.PC0HWBYF == "Y")         

    PC0H121(); /* Format the selected data*/

  end

   /* ------------------------------------------------------------*/
   /* The problem switch is set if: -invalid request*/
   /* ------------------------------------------------------------*/

  if (PC0HW01.PC0HWPSW == "Y") /* Error message to display*/
    set PC0HM001.PC0HMPGL initialAttributes; /* Turn off "PAGE" literal*/
    set PC0HM001.PC0HMOFL initialAttributes; /* Turn off "OF" literal*/
    set PC0HM001.PC0HWTSP initialAttributes; /* turn off current page number*/
    set PC0HM001.TA5TSQIX initialAttributes; /* Turn off highest page number*/

  end

   /* ------------------------------------------------------------*/
   /* Display PF key options*/
   /* ------------------------------------------------------------*/

  PC0HW01.PC0HWUPD = "N";

  if (PC0HW01.PC0HWINQ == "N") /* update requested*/
    PC0HW01.PC0HWUPD = "Y";
  end

  if (PC0HW01.PC0HWUPD == "Y") /* updates allowed*/
    set PC0HM001.PC0HMADD skip;
    set PC0HM001.PC0HMCHG skip;
    set PC0HM001.PC0HMDEL skip;
  end

   /* ------------------------------------------------------------*/
   /* if data successful updated display message*/
   /* ------------------------------------------------------------*/

  if (PC0HW01.PC0HWMFL == "Y") /* update flag on*/
    converseLib.validationFailed(1);
    PC0HM001.XXXPRCNM = "PC0H120"; /* process name*/
    PC0HW01.PC0HWMFL = "N"; /* reset message flag*/
  end

   /* ------------------------------------------------------------*/
   /* If any errors sound the alarm*/
   /* ------------------------------------------------------------*/

  if (converseVar.validationMsgNum != 0) /* Error message to display*/
    set PC0HM001 alarm; /* Indicate sound alarm*/
  end

   /* ------------------------------------------------------------*/
   /* Display p.o. hdr special instruction list screen*/
   /* ------------------------------------------------------------*/

  PC0HM001.XXXCURDT = VGVar.currentShortGregorianDate; /* Current date*/

  converse PC0HM001 ;

  PC0HW01.PC0HWPSW = "N"; /* Reset problem switch*/
  PC0HW01.PC0HWBYF = "N"; /* reset bypass flag*/

end // end PC0H120

// Format the selected data
Function PC0H121()

   /* ------------------------------------------------------------*/
   /* Obtain temporary storage, load and display map fields.*/
   /* ------------------------------------------------------------*/

  set PC0HM001 initial;

  PC0HM001.XGPCD = PC0HW01.XGPCD;
  if (PC0HW01.XGPCD in XGPTBL.XGPCD)
    PC0HM001.XGPDESC = XGPTBL.XGPDESC[sysVar.arrayIndex];
  end
  PC0HM001.PC3PONBR = PC0HW01.PC3PONBR;
  PC0HM001.PC0HMPOI = PC0HW01.PC0HWFPI;

  PC0HS06(); /* Obtain temporary storage page*/

  set PC0HM001.PC0HMPGL skip; /* Display "PAGE" literal*/
  set PC0HM001.PC0HMOFL skip; /* Display "OF" literal*/

  PC0HM001.PC0HWTSP = PC0HW01.PC0HWTSP; /* Current page number*/
  set PC0HM001.PC0HWTSP skip; /* Display number*/
  PC0HM001.TA5TSQIX = PC0HW01.TA5TSQIX; /* Highest page number*/
  set PC0HM001.TA5TSQIX skip; /* Display number*/

  PC0HW01.PC0HWIXM = 1; /* Initialize line index*/
  while (PC0HW01.PC0HWIXM <= 12 /* Until end of lines or*/
   && PC0HW02.YSICD[PC0HWIXM] != " ") /* all special instr displayed*/

    set PC0HM001.PC0HMSEL[PC0HWIXM] normal; /* Display select flag*/
    PC0HM001.PC0HMSEL[PC0HWIXM] = PC0HW02.PC0HMSEL[PC0HWIXM];
    PC0HM001.YSICD[PC0HWIXM] = PC0HW02.YSICD[PC0HWIXM];
    PC0HM001.PCASIDSC[PC0HWIXM] = PC0HW02.PCASIDSC[PC0HWIXM];
    PC0HM001.PCEPRSEQ[PC0HWIXM] = PC0HW02.PCEPRSEQ[PC0HWIXM];
    PC0HM001.PC0HMSRC[PC0HWIXM] = PC0HW02.PC0HMSRC[PC0HWIXM];

    PC0HW01.PC0HWIXM = PC0HW01.PC0HWIXM + 1; /* Increment line index*/

  end

  set PC0HM001.PC0HMSEL[PC0HWCIX] cursor; /* Last row viewed*/

end // end PC0H121

// Check attention identifier
Function PC0H130()

   /* ------------------------------------------------------------*/
   /* Check attention identifier used to invoke the transaction.*/
   /* If FAST PATH was requested, transfer to the application.*/
   /* If transfer failed, display returned error message.*/
   /* ------------------------------------------------------------*/

   /* ------------------------------------------------------------*/
   /* PA2 - Refresh screen pc0hm001*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pa2) /* PA2 was pressed*/
    converseLib.clearScreen();
     /* refresh screen*/
    PC0HW01.PC0HWBYF = "Y"; /* bypass reload of screen*/

    exit stack; /* Exit to redisplay map*/

  end

   /* ------------------------------------------------------------*/
   /* PF3 - Return to P.O. menu*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf3) /* PF3 was pressed*/

    PC0HS01(); /* Purge any temporary storage*/

    COMMAREA.CAITEM = " "; /* Application data*/
    COMMAREA.CATOAP = COMMAREA.CAFROMAP; /* Set to p.o. menu*/

    if (COMMAREA.CATOAP == "PC0E")
      PCWREC.PCWUSER4 = " ";
    end

    XSPCS01(); /* Exit to p.o. menu*/

    PC0HW01.PC0HWPSW = "Y"; /* set problem switch*/
    PC0HM001.XXXPRCNM = "PC0H130"; /* Process name*/

    exit stack; /* Exit to redisplay map*/

  end

   /* ------------------------------------------------------------*/
   /* PF13 - Verify if user is authorized to add p.o. hdr special*/
          /* instruction data.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf13 /* PF13 was pressed*/
   && PC0HW01.PC0HWUPD == "N")     /* and user add not authorized*/
    PC0HM001.XXXPRCNM = "PC0H130"; /* Process name*/
    converseLib.validationFailed(4); /* Indicate invalid attention key*/
    exit stack; /* Exit to redisplay map*/
  end

   /* ------------------------------------------------------------*/
   /* PF14 - Verify if user is authorized to change p.o. hdr*/
          /* special instruction data*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf14 /* PF14 was pressed*/
   && PC0HW01.PC0HWUPD == "N")     /* and user chg not authorized*/
    PC0HM001.XXXPRCNM = "PC0H130"; /* Process name*/
    converseLib.validationFailed(4); /* Indicate invalid attention key*/
    exit stack; /* Exit to redisplay map*/
  end

   /* ------------------------------------------------------------*/
   /* PF15 - Verify if user is authorized to delete p.o. hdr*/
          /* special instruction data*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf15 /* PF15 was pressed*/
   && PC0HW01.PC0HWUPD == "N")     /* and user del not authorized*/
    PC0HM001.XXXPRCNM = "PC0H130"; /* Process name*/
    converseLib.validationFailed(4); /* Indicate invalid attention key*/
    exit stack; /* Exit to redisplay map*/
  end

   /* ------------------------------------------------------------*/
   /* The from application data is saved in the pcwrec.*/
   /* This data is loaded in routine PC0h001.  The data*/
   /* must be saved for the return journey.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf16)
    if (PCWREC.CAFROMAP[1] == " "
     || PCWREC.CAFROMAP[1] == "PC0H")
      PCWREC.CAFROMAP[1] = "PC0H"; /* From application id*/

    else
      if (PCWREC.CAFROMAP[2] == " "
       || PCWREC.CAFROMAP[2] == "PC0H")
        PCWREC.CAFROMAP[2] = "PC0H"; /* From application id*/
      else
        if (PCWREC.CAFROMAP[3] == " "
         || PCWREC.CAFROMAP[3] == "PC0H")
          PCWREC.CAFROMAP[3] = "PC0H"; /* From application id*/
        else
          if (PCWREC.CAFROMAP[4] == " "
           || PCWREC.CAFROMAP[4] == "PC0H")
            PCWREC.CAFROMAP[4] = "PC0H"; /* From application id*/
          end
        end
      end
    end
  end

   /* ------------------------------------------------------------*/
   /* PF16 - transfer to nike special instruction*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf16) /* PF3 was pressed*/

    PC0HS01(); /* Purge any temporary storage*/

    COMMAREA.CAITEM = " "; /* Application data*/
    COMMAREA.CATOAP = "PC0G"; /* Set to nike special instruction*/

    XSPCS01(); /* Exit to p.o. menu*/

    PC0HW01.PC0HWPSW = "Y"; /* set problem switch*/
    PC0HM001.XXXPRCNM = "PC0H130"; /* Process name*/

    exit stack; /* Exit to redisplay map*/

  end
   /* ------------------------------------------------------------*/
   /* Indicate invalid key has been pressed.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey not enter /* ENTER was not pressed*/
   && converseVar.eventKey not pf7   /* and PF7 was not pressed*/
   && converseVar.eventKey not pf8   /* and PF8 was not pressed*/
   && converseVar.eventKey not pf13  /* and PF13 was not pressed*/
   && converseVar.eventKey not pf14  /* and PF14 was not pressed*/
   && converseVar.eventKey not pf15  /* and PF15 was not pressed*/
   && converseVar.eventKey not pf16) /* and PF16 was not pressed*/

    PC0HM001.XXXPRCNM = "PC0H130"; /* Process name*/
    converseLib.validationFailed(4); /* Indicate invalid attention key*/

    if (converseVar.eventKey is pa1 /* PA1 was pressed*/
     || converseVar.eventKey is pa3) /* or PA3 was pressed*/
      converseLib.clearScreen();
       /* Clear screen before redisplay*/
      PC0HW01.PC0HWBYF = "Y"; /* bypass reload of data*/
    end

    exit stack; /* Exit to redisplay map*/

  end

end // end PC0H130

// Reset highlighted fields
Function PC0H140()

   /* ------------------------------------------------------------*/
   /* Reset field attributes to normal intensity.*/
   /* ------------------------------------------------------------*/

  set PC0HM001.XGPCD initialAttributes; /* gpc code*/
  set PC0HM001.PC3PONBR initialAttributes; /* p.o. number*/
  set PC0HM001.PC0HMPOI initialAttributes; /* p.o. id*/

  PC0HW01.PC0HWIXM = 1; /* Initialize line index*/

  while (PC0HW01.PC0HWIXM <= 12 /* Until end of lines*/
   && PC0HM001.YSICD[PC0HWIXM] != " ")
                                   /* and special instr. type exists*/
    set PC0HM001.PC0HMSEL[PC0HWIXM] normal; /* Reset select flag*/
    PC0HW01.PC0HWIXM = PC0HW01.PC0HWIXM + 1; /* Increment line index*/
  end

end // end PC0H140

// Verify the entered data
Function PC0H150()

   /* ------------------------------------------------------------*/
   /* Highlight any application data that was entered.*/
   /* Determine whether a valid request to scroll was entered.*/
   /* If not a scroll request, verify any changed data.*/
   /* If any errors were found, exit to redisplay the map.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf7 /* Scroll back request*/
   || converseVar.eventKey is pf8) /* or scroll forward request*/

    PC0H151(); /* Verify scroll request*/

  else
    if (converseVar.eventKey not pf13)

      PC0H152(); /* Verify any changed data*/

    end
  end

end // end PC0H150

// Verify scroll request
Function PC0H151()

   /* ------------------------------------------------------------*/
   /* Ensure that pages exist to scroll forward or back.*/
   /* Indicate an error for any data that was modified.*/
   /* ------------------------------------------------------------*/
  PC0HW01.PC0HWIXM = 12; /* Initialize line index*/

  while (PC0HW01.PC0HWIXM > 0) /* Until end of lines*/
    if (PC0HM001.PC0HMSEL[PC0HWIXM] > " "
     && PC0HM001.PC0HMSEL[PC0HWIXM] != "V")
      set PC0HM001.PC0HMSEL[PC0HWIXM] cursor, modified, bold; /* Highlight*/
      PC0HM001.XXXPRCNM = "PC0H151"; /* Process name*/
      converseLib.validationFailed(14); /* Modifications not allowed*/
    end
    PC0HW01.PC0HWIXM = PC0HW01.PC0HWIXM - 1; /* Decrement line number*/
  end

  if (converseVar.eventKey is pf7 /* Scroll back request*/
   && PC0HW01.PC0HWTSP < 2        /* and no previous pages*/
   && converseVar.validationMsgNum == 0) /* no errors*/
    PC0HM001.XXXPRCNM = "PC0H151"; /* Process name*/
    converseLib.validationFailed(2); /* No previous page to display*/
  end

  if (converseVar.eventKey is pf8          /* Scroll forward request*/
   && PC0HW01.PC0HWTSP >= PC0HW01.TA5TSQIX /* and no more pages*/
   && converseVar.validationMsgNum == 0)   /* no errors*/
    PC0HM001.XXXPRCNM = "PC0H151"; /* Process name*/
    converseLib.validationFailed(3); /* No more pages to display*/
  end

  if (converseVar.validationMsgNum == 0)
    PC0HW01.PC0HWCIX = 1; /* set cursor at first row*/
  end

end // end PC0H151

// Verify any changed data
Function PC0H152()

  if (converseVar.validationMsgNum != 0 /* error message*/
   || PC0HW01.PC0HWBYF == "Y")         
    return;
  end

   /* ------------------------------------------------------------*/
   /* Check to see if data has been selected off the list screen*/
   /* ------------------------------------------------------------*/

  PC0HW01.PC0HWSFL = "N"; /* Initialize selection flag*/
  PC0HW01.PC0HWIXM = 12; /* Initialize index*/

  while (PC0HW01.PC0HWIXM > 0) /* Until end of lines*/
    if (PC0HM001.PC0HMSEL[PC0HWIXM] != " ") /* If selection not blank*/
      if (PC0HM001.PC0HMSEL[PC0HWIXM] == "S")
        PC0HW01.PC0HWSFL = "Y"; /* Initialize selection flag*/
      else
        if (PC0HM001.PC0HMSEL[PC0HWIXM] != "V") /* invalid entry*/
          converseLib.validationFailed(13); /* Error message and highlight*/
          PC0HM001.XXXPRCNM = "PC0H152"; /* Process name*/
          PC0HW01.PC0HWSFL = "Y"; /* Initialize selection flag*/
          set PC0HM001.PC0HMSEL[PC0HWIXM] cursor, modified, bold;
        end
      end
    end

    PC0HW01.PC0HWIXM = PC0HW01.PC0HWIXM - 1; /* Decrement line index*/
  end

   /* ------------------------------------------------------------*/
   /* If PF14 or 15 was pressed and no data was selected*/
   /* display error message*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf14 /* PF14 change request*/
   || converseVar.eventKey is pf15) /* pf15 deletion request*/
    if (PC0HW01.PC0HWSFL == "N") /* and selection was not made*/
      PC0HM001.XXXPRCNM = "PC0H152"; /* Process name*/
      converseLib.validationFailed(25); /* enter 's' for selection*/
    end
  end
end // end PC0H152

// Process valid input request
Function PC0H160()

   /* ------------------------------------------------------------*/
   /* If a scroll request, adjust temporary storage page number.*/
   /* Update any changed data.*/
   /* ------------------------------------------------------------*/

  if (converseVar.validationMsgNum != 0 /* Error message set up*/
   || PC0HW01.PC0HWBYF == "Y")          /* bypass processing*/
    return;
  end

  if (converseVar.eventKey is pf7) /* Scroll back requested*/
    PC0HW01.PC0HWTSP = PC0HW01.PC0HWTSP - 1; /* Decrement page number*/
    return;
  end

  if (converseVar.eventKey is pf8) /* Scroll forward requested*/
    PC0HW01.PC0HWTSP = PC0HW01.PC0HWTSP + 1; /* Increment page number*/
    return;
  end

   /* ------------------------------------------------------------*/
   /* Inquiry function has been requested*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is enter /* Enter was pressed*/
   && PC0HW01.PC0HWSFL == "Y")      /* and selection was made*/
    PC0HW01.PC0HWMAP = "2"; /* Select Map #2*/
    PC0HW01.PC0HWFSW = "I"; /* Select inquiry function*/
    converseLib.validationFailed(0); /* Clear error message field*/
  end

   /* ------------------------------------------------------------*/
   /* Add function has been requested*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf13) /* PF13 was pressed*/
    PC0HW01.PC0HWMAP = "2"; /* Select Map #2*/
    PC0HW01.PC0HWFSW = "A"; /* Select add function*/
    converseLib.validationFailed(0); /* Clear error message field*/
    return;
  end

   /* ------------------------------------------------------------*/
   /* Change function has been requested*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf14 /* PF14 was pressed*/
   && PC0HW01.PC0HWSFL == "Y")     /* and selection was made*/
    PC0HW01.PC0HWMAP = "2"; /* Select Map #2*/
    PC0HW01.PC0HWFSW = "C"; /* Select change function*/
    converseLib.validationFailed(0); /* Clear error message field*/
    return;
  end

   /* ------------------------------------------------------------*/
   /* Delete function has been requested*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf15 /* PF15 was pressed*/
   && PC0HW01.PC0HWSFL == "Y")     /* and selection was made*/
    PC0HW01.PC0HWMAP = "2"; /* Select Map #2*/
    PC0HW01.PC0HWFSW = "D"; /* Select delete function*/
    converseLib.validationFailed(0); /* Clear error message field*/
    return;
  end

end // end PC0H160

// p.o. hdr special instr - inq
Function PC0H200()

   /* ------------------------------------------------------------*/
   /* This is the main process used to display a map.  Processing*/
   /* always returns to the top of this process and falls through*/
   /* subordinate processes until an error is found or a valid*/
   /* request is processed.  Processing sequence is as follows:*/

   /* 1) Obtain the data to display.*/
   /* 2) Format the map output area and display the map.*/
   /* 3) Check the attention identifier used to respond.*/
   /* 4) Reset highlighted fields to normal intensity.*/

   /* In all subordinate processes, "EZEFLO" is used to exit to*/
   /* redisplay the map when an error is found.  This is done to*/
   /* minimize the coding effort required to skip subsequent*/
   /* processing under error conditions.*/
   /* ------------------------------------------------------------*/

  PC0H210(); /* obtain data*/

  PC0H220(); /* Format and display the map*/

  PC0H230(); /* Check attention identifier*/

  PC0H240(); /* Reset fields to normal intensity*/

end // end PC0H200

// Obtain spec instr text
Function PC0H210()

   /* ------------------------------------------------------------*/
   /* obtain the special instruction text row(s) for display*/
   /* ------------------------------------------------------------*/

  if (converseVar.validationMsgNum == 0 /* no errors*/
   && PC0HW01.PC0HWBYF == "N")         

    set PC0HM002 initial; /* clear screen pc0hm002*/
    set PCBREC empty; /* init spec. text rec pcbrec*/

    PCBREC.XGPCD = PC0HW02.XGPCD[PC0HWIXM];
    PCBREC.PCASINBR = PC0HW02.PCASINBR[PC0HWIXM];

    PC0HS07(); /* select set and open the cursor*/

    PC0HW01.PC0HWSIX = 1; /* init spec.instr. line index*/
    PC0HW01.PC0HWSTW = "N"; /* init spec. instr. text switch*/

    PC0HS08(); /* fetch pcbrec row*/

    while (PC0HW01.PC0HWSTW == "N" /* until end of special text or*/
     && PC0HW01.PC0HWSIX <= 13) /* CAN NOT EXCEED 13 ENTRIES*/

       /* load special instruction text for display*/

      PC0HM002.PCBSITXT[PC0HWSIX] = PCBREC.PCBSITXT;

      PC0HS08(); /* fetch pcbrec row*/

      PC0HW01.PC0HWSIX = PC0HW01.PC0HWSIX + 1; /* incr. index*/

    end

    PC0HS09(); /* close pcbrec row*/

  end

end // end PC0H210

// Format and display the map
Function PC0H220()

   /* ------------------------------------------------------------*/
   /* Format the map heading.*/
   /* If no error to display, format the selected data.*/
   /* Indicate sound audible alarm for any error.*/
   /* ------------------------------------------------------------*/

  if (converseVar.validationMsgNum == 0 /* No errors*/
   && PC0HW01.PC0HWBYF == "N")         

     /* load p.o. hdr special instruction from temp storage*/

    PC0HM002.XGPCD = PC0HW01.XGPCD;
    if (PC0HW01.XGPCD in XGPTBL.XGPCD)
      PC0HM002.XGPABRV = XGPTBL.XGPABRV[sysVar.arrayIndex];
    end
    PC0HM002.PC3PONBR = PC0HW01.PC3PONBR;
    PC0HM002.PC0HMPOI = PC0HW01.PC0HWFPI;
    PC0HM002.YSICD = PC0HW02.YSICD[PC0HWIXM];
    if (PC0HW02.YSICD[PC0HWIXM] in YSITBL.YSICD)
      PC0HM002.YSISDESC = YSITBL.YSISDESC[sysVar.arrayIndex];
    end
    PC0HM002.PCASIDSC = PC0HW02.PCASIDSC[PC0HWIXM];
    PC0HM002.PCEPRSEQ = PC0HW02.PCEPRSEQ[PC0HWIXM];
    PC0HM002.PC0HMSRC = PC0HW02.PC0HMSRC[PC0HWIXM];

    PC0HW01.PC0HWCIX = PC0HW01.PC0HWIXM; /* save to position cursor*/
    PC0HW02.PC0HMSEL[PC0HWIXM] = "V";

    PC0HS10(); /* update temp storage*/

  end

   /* protect all enterable fields*/

  set PC0HM002.XGPCD protect; /* Gpc code*/
  set PC0HM002.YSICD protect; /* special instr. type code*/
  set PC0HM002.PCASIDSC protect; /* special instr. type desc*/
  set PC0HM002.PC3PONBR protect; /* p.o. number*/
  set PC0HM002.PC0HMPOI protect; /* p.o. id*/
  set PC0HM002.PCEPRSEQ protect; /* print sequence*/
  set PC0HM002.PC0HMSRC protect; /* source description*/

  PC0HW01.PC0HWSIX = 1; /* init spec. text line index*/
  while (PC0HW01.PC0HWSIX <= 13)
    set PC0HM002.PCBSITXT[PC0HWSIX] protect; /* spec text*/
    PC0HW01.PC0HWSIX = PC0HW01.PC0HWSIX + 1; /* incr. index*/
  end

  PC0HM002.PC0HMFNC = "INQUIRY"; /* Move inquiry literal to map*/
  PC0HM002.XXXCURDT = VGVar.currentShortGregorianDate; /* Current date*/

  if (converseVar.validationMsgNum != 0) /* Errors exist*/
    set PC0HM002 alarm; /* sound the alarm*/
  end

  converse PC0HM002 ;

  PC0HW01.PC0HWPSW = "N"; /* Initialize problem switch*/
  PC0HW01.PC0HWBYF = "N"; /* reset bypass processing flag*/

end // end PC0H220

// Check attention identifier
Function PC0H230()

   /* ------------------------------------------------------------*/
   /* Check attention identifier used to invoke the transaction.*/
   /* ------------------------------------------------------------*/

   /* ------------------------------------------------------------*/
   /* PA2 - Refresh screen pc0hm002*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pa2) /* PA2 was pressed*/
    converseLib.clearScreen();
     /* refresh screen*/
    PC0HW01.PC0HWBYF = "Y"; /* bypass reload*/
    return; /* exit to redisplay map*/
  end

   /* ------------------------------------------------------------*/
   /* PF3 - Return to p.o. hdr special instruction list screen*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf3) /* PF3 was pressed*/
    PC0HW01.PC0HWMAP = "1"; /* Move to map 1*/

    exit stack; /* Exit to redisplay map*/

  end

   /* ------------------------------------------------------------*/
   /* Indicate invalid key has been pressed*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey not enter) /* ENTER was not pressed*/
    PC0HM002.XXXPRCNM = "PC0H230"; /* Process name*/
    converseLib.validationFailed(4); /* Indicate invalid attention key*/
    if (converseVar.eventKey is pa1 /* PA1 was pressed*/
     || converseVar.eventKey is pa3) /* or PA3 was pressed*/
      converseLib.clearScreen();
       /* Clear screen before redisplay*/
      PC0HW01.PC0HWBYF = "Y"; /* bypass reload*/
    end

    return; /* Exit to redisplay map*/

  end


end // end PC0H230

// Reset highlighted fields
Function PC0H240()

   /* ------------------------------------------------------------*/
   /* Reset field attributes to normal intensity.*/
   /* ------------------------------------------------------------*/

  set PC0HM002.XGPCD initialAttributes; /* Gpc code*/
  set PC0HM002.YSICD initialAttributes; /* special instr. type*/
  set PC0HM002.PCASIDSC initialAttributes; /* instruction description*/
  set PC0HM002.PC3PONBR initialAttributes; /* p.o. number*/
  set PC0HM002.PC0HMPOI initialAttributes; /* p.o. id*/
  set PC0HM002.PCEPRSEQ initialAttributes; /* print sequence*/
  set PC0HM002.PC0HMSRC initialAttributes; /* source description*/

  PC0HW01.PC0HWSIX = 1; /* init spec text index*/
  while (PC0HW01.PC0HWSIX <= 13)
    set PC0HM002.PCBSITXT[PC0HWSIX] initialAttributes;
    PC0HW01.PC0HWSIX = PC0HW01.PC0HWSIX + 1;
  end

end // end PC0H240

// p.o. hdr special instr - add
Function PC0H300()

   /* ------------------------------------------------------------*/
   /* This is the main process used to display a map.  Processing*/
   /* always returns to the top of this process and falls through*/
   /* subordinate processes until an error is found or a valid*/
   /* request is processed.  Processing sequence is as follows:*/

   /* 1) Format the map output area and display the map.*/
   /* 2) Check the attention identifier used to respond.*/
   /* 3) Reset highlighted fields to normal intensity.*/
   /* 4) Verify the data that was entered.*/
   /* 5) Process a valid input request.*/

   /* In all subordinate processes, "EZEFLO" is used to exit to*/
   /* redisplay the map when an error is found.  This is done to*/
   /* minimize the coding effort required to skip subsequent*/
   /* processing under error conditions.*/
   /* ------------------------------------------------------------*/

  PC0H310(); /* Format and display the map*/

  PC0H320(); /* Check attention identifier*/

  PC0H330(); /* Reset fields to normal intensity*/

  PC0H340(); /* verify the entered data*/

  PC0H350(); /* process valid input request*/

end // end PC0H300

// Format and display the map
Function PC0H310()

   /* ------------------------------------------------------------*/
   /* Format the map heading.*/
   /* If no error to display, format the selected data.*/
   /* Indicate sound audible alarm for any error.*/
   /* ------------------------------------------------------------*/

  if (converseVar.validationMsgNum == 0 /* No errors*/
   && PC0HW01.PC0HWBYF == "N")         

    set PC0HM002 initial; /* clear map pc0hm002*/
    PC0HM002.XGPCD = PC0HW01.XGPCD;
    if (PC0HW01.XGPCD in XGPTBL.XGPCD)
      PC0HM002.XGPABRV = XGPTBL.XGPABRV[sysVar.arrayIndex];
    end
    PC0HM002.PC3PONBR = PC0HW01.PC3PONBR;
    PC0HM002.PC0HMPOI = PC0HW01.PC0HWFPI;
    PC0HM002.PCEPRSEQ = 1;
    PC0HM002.PC0HMSRC = "P.O.";

    set PC0HM002.YSICD cursor, normal; /* Position cursor*/
    PC0HM002.PC0HMFNC = "ADD";

  end

  if (PC0HW01.PC0HWMFL == "Y")
    converseLib.validationFailed(1); /* update message*/
    PC0HM002.XXXPRCNM = "PC0H310"; /* process name*/
    PC0HW01.PC0HWMFL = "N"; /* reset message flag*/
  end

  if (converseVar.validationMsgNum != 0) /* Errors exist*/
    set PC0HM002 alarm; /* sound the alarm*/
  end

  set PC0HM002.XGPCD protect; /* protect gpc*/
  set PC0HM002.PC3PONBR protect; /* protect p.o. number*/
  set PC0HM002.PC0HMPOI protect; /* protect p.o id*/
  PC0HM002.XXXCURDT = VGVar.currentShortGregorianDate; /* Current date*/

  converse PC0HM002 ;

  PC0HW01.PC0HWPSW = "N"; /* Initialize problem switch*/
  PC0HW01.PC0HWBYF = "N"; /* reset bypass flag*/

  if (converseVar.eventKey is enter)
    PC0H311();
  end
end // end PC0H310

// Check for ? inquiry by user
Function PC0H311()

   /* ------------------------------------------------------------*/

              /* CHECK FOR USER ? CODE INQUIRY*/

     /* 1) If the user has enter a '?' in any of the appropiate*/
        /* fields, display the pop up window for that CSP table*/
        /* and allow for inquiry.*/

     /* 2) Set map page after all windows displayed*/

   /* ------------------------------------------------------------*/


  if (PC0HM002.YSICD == "?")

    /* *************************************************************/
     /* Check special instruction type for ?*/
    /* *************************************************************/


    XPXX001(); /* perform pop-up window initialize*/
    XX0XW02.XX0XWHDR = "  SPECIAL INSTRUCTION TYPE"; /* heading*/

    while (XX0XW02.XX0XWEND == "N") /* until user hits enter*/
      XPYSI01(); /* perform special instr type window*/
    end

     /* **********************************************************/
     /* *  If the pass index is greater than zero, use the      **/
     /* *  passed table index 'XX0XWPIX' to move the xref type  **/
     /* *  table code and description to the map.               **/
     /* **********************************************************/

    if (XX0XW02.XX0XWPIX > 0) /* if user selected a code*/
      PC0HM002.YSICD = YSITBL.YSICD[XX0XWPIX]; /* move code*/
      PC0HM002.YSISDESC = YSITBL.YSIDESC[XX0XWPIX]; /* move name*/
    else
      PC0HM002.YSICD = PC0HW01.YSICD;
      if (PC0HW01.YSICD in YSITBL.YSICD)
        PC0HM002.YSISDESC = YSITBL.YSISDESC[sysVar.arrayIndex];
      end
    end

    set PC0HM002.YSICD cursor; /* set cursor*/

    converseLib.clearScreen();

    PC0HW01.PC0HWBYF = "Y"; /* bypass processing*/

  end


end // end PC0H311

// Check attention identifier
Function PC0H320()

   /* ------------------------------------------------------------*/
   /* Check attention identifier used to invoke the transaction.*/
   /* ------------------------------------------------------------*/

   /* ------------------------------------------------------------*/
   /* PA2 - Refresh screen pc0hm002*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pa2) /* PA2 was pressed*/
    converseLib.clearScreen();
     /* refresh screen*/
    PC0HW01.PC0HWBYF = "Y"; /* bypass processing flag*/
    return; /* exit to redisplay map*/
  end

   /* ------------------------------------------------------------*/
   /* PF3 - Return to p.o. special hdr list screen pc0hm001*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf3) /* PF3 was pressed*/
    PC0HW01.PC0HWSWR = "Y"; /* request for data yes*/
    PC0HW01.PC0HWMAP = "1"; /* Move to map 1*/

    exit stack; /* Exit to redisplay map*/

  end

   /* ------------------------------------------------------------*/
   /* Indicate invalid key has been pressed*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey not enter) /* ENTER was not pressed*/
    PC0HM002.XXXPRCNM = "PC0H320"; /* Process name*/
    converseLib.validationFailed(4); /* Indicate invalid attention key*/
    if (converseVar.eventKey is pa1 /* PA1 was pressed*/
     || converseVar.eventKey is pa3) /* or PA3 was pressed*/
      converseLib.clearScreen();
       /* Clear screen before redisplay*/
      PC0HW01.PC0HWBYF = "Y"; /* bypass processing flag*/
    end

    return; /* Exit to redisplay map*/

  end


end // end PC0H320

// Reset highlighted fields
Function PC0H330()

   /* ------------------------------------------------------------*/
   /* Reset field attributes to normal intensity.*/
   /* ------------------------------------------------------------*/

  set PC0HM002.XGPCD initialAttributes; /* Gpc code*/
  set PC0HM002.YSICD initialAttributes; /* special instr. type*/
  set PC0HM002.PCASIDSC initialAttributes; /* instruction description*/
  set PC0HM002.PC3PONBR initialAttributes; /* p.o. number*/
  set PC0HM002.PC0HMPOI initialAttributes; /* p.o. id*/
  set PC0HM002.PCEPRSEQ initialAttributes; /* print sequence*/

  PC0HW01.PC0HWSIX = 1; /* init spec text index*/
  while (PC0HW01.PC0HWSIX <= 13)
    set PC0HM002.PCBSITXT[PC0HWSIX] initialAttributes;
    PC0HW01.PC0HWSIX = PC0HW01.PC0HWSIX + 1;
  end

end // end PC0H330

// Verify the entered data
Function PC0H340()

   /* ------------------------------------------------------------*/
   /* Highlight any application data that was entered.*/
   /* If any errors were found, exit to redisplay the map.*/
   /* ------------------------------------------------------------*/
  PC0HW01.PC0HWDEF = "N"; /* initialize data entered flag*/

  if (converseVar.eventKey is enter) /* if enter was pressed*/
    PC0H341(); /* validate input data*/
  end

end // end PC0H340

// validate input data
Function PC0H341()

   /* ------------------------------------------------------------*/
     /* validate any input data.*/
     /* if errors were found, exit to redisplay the map*/
   /* ------------------------------------------------------------*/

  PC0HW01.PC0HWDEF = "Y"; /* data has been entered*/

   /* ------------------------------------------------------------*/
   /* Verify special instruction text has been entered*/
   /* ------------------------------------------------------------*/

  PC0HW01.PC0HWSIX = 13;
  PC0HW01.PC0HWTEF = "N";
  while (PC0HW01.PC0HWSIX >= 1
   && PC0HW01.PC0HWTEF == "N")
    if (PC0HM002.PCBSITXT[PC0HWSIX] != " ")
      PC0HW01.PC0HWTEF = "Y";
    end

    PC0HW01.PC0HWSIX = PC0HW01.PC0HWSIX - 1; /* incr. index*/

  end

  if (PC0HW01.PC0HWTEF == "N")
    converseLib.validationFailed(161); /* special instructions missing/invalid*/
    PC0HM002.XXXPRCNM = "PC0H341"; /* load process name*/
    PC0HW01.PC0HWSIX = 13;
    while (PC0HW01.PC0HWSIX >= 1)
      set PC0HM002.PCBSITXT[PC0HWSIX] cursor, modified, bold;

      PC0HW01.PC0HWSIX = PC0HW01.PC0HWSIX - 1; /* incr. index*/

    end
  end

   /* ------------------------------------------------------------*/
   /* Validate print sequence*/
   /* ------------------------------------------------------------*/

  if (PC0HM002.PCEPRSEQ == 0)
    converseLib.validationFailed(140); /* print seq must be gt zero*/
    PC0HM002.XXXPRCNM = "PC0H341"; /* load process name*/
    set PC0HM002.PCEPRSEQ cursor, modified, bold;
  end


   /* ------------------------------------------------------------*/
   /* validate p.o. hdr special instruction short description*/
   /* ------------------------------------------------------------*/

  if (PC0HM002.PCASIDSC == " ")
    converseLib.validationFailed(161); /* special instructions missing/invalid*/
    PC0HM002.XXXPRCNM = "PC0H341"; /* load process name*/
    set PC0HM002.PCASIDSC cursor, modified, bold;
  end

   /* ------------------------------------------------------------*/
   /* Validate special instruction type*/
   /* ------------------------------------------------------------*/

  PC0HW01.YSICD = " ";
  if (PC0HM002.YSICD != " ")
    if (PC0HM002.YSICD in YSITBL.YSICD
     && YSITBL.XXXSTAT[sysVar.arrayIndex] == "A") /* active spec instr type*/
      PC0HM002.YSISDESC = YSITBL.YSISDESC[sysVar.arrayIndex];
      PC0HW01.YSICD = PC0HM002.YSICD;
    else
      converseLib.validationFailed(67); /* missing/invalid spec instr type*/
      PC0HM002.XXXPRCNM = "PC0H341"; /* load process name*/
      PC0HM002.YSISDESC = " "; /* clear map spec instr desc*/
      set PC0HM002.YSICD cursor, modified, bold;
    end
  else
    converseLib.validationFailed(67); /* missing/invalid spec instr type*/
    PC0HM002.XXXPRCNM = "PC0H341"; /* load process name*/
    PC0HM002.YSISDESC = " "; /* clear map spec instr desc*/
    set PC0HM002.YSICD cursor, modified, bold;
  end

end // end PC0H341

// process valid input request
Function PC0H350()

   /* ------------------------------------------------------------*/
   /* process valid input request*/
   /* ------------------------------------------------------------*/

  if (PC0HW01.PC0HWDEF == "N"           /* data not entered*/
   || converseVar.validationMsgNum != 0 /* errors*/
   || PC0HW01.PC0HWBYF == "Y")          /* bypass proccessing*/
    return;
  end

  set PCEREC empty; /* init p.o. hdr special instr rec*/
  set PCBREC empty; /* init special instr text rec*/

  XX0XS01(); /* obtain current date and time*/

  PCDREC.XGPCD = PC0HM002.XGPCD;

  PC0HS11(); /* select next spec instr number*/

   /* load p.o. hdr special instruction header*/

  PCEREC.XGPCD = PC0HM002.XGPCD;
  PCEREC.PCASINBR = PCDREC.PCDSINBR;
  PCEREC.PC3PONBR = PC0HM002.PC3PONBR;
  PCEREC.YSICD = PC0HM002.YSICD;
  PCEREC.PCASIDSC = PC0HM002.PCASIDSC;
  PCEREC.PCEPRSEQ = PC0HM002.PCEPRSEQ;
  PCEREC.PCESIID = "P";
  PCEREC.ZZZSDT = XX0XW01.XX0XWDAT;

  PC0HS12(); /* add customer special instr header*/

   /* determine the number of special msg text lines to be added*/

  PC0HW01.PC0HWSIX = 13;
  while (PC0HM002.PCBSITXT[PC0HWSIX] == " ")
    PC0HW01.PC0HWSIX = PC0HW01.PC0HWSIX - 1;
  end

   /* load special instruction text*/

  PCBREC.XGPCD = PC0HM002.XGPCD;
  PCBREC.PCASINBR = PCDREC.PCDSINBR;
  PCBREC.ZZZSDT = XX0XW01.XX0XWDAT;
  PC0HW01.PC0HWLIX = PC0HW01.PC0HWSIX;
  PC0HW01.PC0HWSIX = 1;
  while (PC0HW01.PC0HWSIX <= PC0HW01.PC0HWLIX)

    PCBREC.PCBSISEQ = PC0HW01.PC0HWSIX;
    PCBREC.PCBSITXT = PC0HM002.PCBSITXT[PC0HWSIX];

    PC0HS13(); /* add special instruction text*/

    PC0HW01.PC0HWSIX = PC0HW01.PC0HWSIX + 1;

  end

  set VPOHDR02 empty;

  VPOHDR02.XGPCD = PC0HM002.XGPCD;
  VPOHDR02.PO-REG-CD = PCWREC.PO-REG-CD;
  VPOHDR02.PC3PONBR = PC0HM002.PC3PONBR;

  PC0HS14(); /* select p.o. header*/

  if (SQLCA.VAGen_SQLCODE == 0)

    VPOHDR02.PC3SIFL = "Y";
    VPOHDR02.ZZZCHGDT = XX0XW01.XX0XWDAT;
    VPOHDR02.ZZZCHGTM = XX0XW01.XX0XWTIM;

    PC0HS15(); /* update po header row*/

    if (SQLCA.VAGen_SQLCODE == 100)
      PC0HW01.PC0HWPSW = "Y"; /* set error flag*/
      converseLib.validationFailed(12); /* data updated by another application*/
    end
  else
    PC0HW01.PC0HWPSW = "Y"; /* set problem switch*/
    converseLib.validationFailed(168); /* data deleted by another application*/
  end

  PC0HS20(); /* create si header audit*/

  if (PC0HW01.PC0HWPSW == "Y")
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback();
    PC0HW01.PC0HWMFL = "N"; /* reset message flag*/
  else
    VGVar.handleSysLibraryErrors = 0;
    sysLib.commit();
    PC0HW01.PC0HWMFL = "Y"; /* set message flag*/
  end

  PC0HM002.XXXPRCNM = "PC0H350"; /* set process name*/

end // end PC0H350

// p.o. hdr special instr - chg
Function PC0H400()

   /* ------------------------------------------------------------*/
   /* This is the main process used to display a map.  Processing*/
   /* always returns to the top of this process and falls through*/
   /* subordinate processes until an error is found or a valid*/
   /* request is processed.  Processing sequence is as follows:*/

   /* 1) Obtain the data to display.*/
   /* 2) Format the map output area and display the map.*/
   /* 3) Check the attention identifier used to respond.*/
   /* 4) Reset highlighted fields to normal intensity.*/
   /* 5) Verify the data that was entered.*/
   /* 6) Process a valid input request.*/

   /* In all subordinate processes, "EZEFLO" is used to exit to*/
   /* redisplay the map when an error is found.  This is done to*/
   /* minimize the coding effort required to skip subsequent*/
   /* processing under error conditions.*/
   /* ------------------------------------------------------------*/

  PC0H410(); /* obtain data to display*/

  PC0H420(); /* Format and display the map*/

  PC0H430(); /* Check attention identifier*/

  PC0H440(); /* Reset fields to normal intensity*/

  PC0H450(); /* Verify the entered data*/

  PC0H460(); /* process valid input request*/

end // end PC0H400

// select spec instr text row(s)
Function PC0H410()

   /* ------------------------------------------------------------*/
   /* select special instruction text row(s) for display*/
   /* ------------------------------------------------------------*/

  if (converseVar.validationMsgNum == 0 /* no errors*/
   && PC0HW01.PC0HWBYF == "N")          /* processing processing*/
    set PC0HM002 initial; /* clear screen pc0hm002*/

    set PCBREC empty; /* init spec. text rec pcbrec*/
    move " " to PC0HWTXT[1] for all; /* clear w/s text table*/

    PCBREC.XGPCD = PC0HW02.XGPCD[PC0HWIXM];
    PCBREC.PCASINBR = PC0HW02.PCASINBR[PC0HWIXM];

    PC0HS07(); /* select set and open the cursor*/

    if (SQLCA.VAGen_SQLCODE == 0)
      PC0HW01.PC0HWSIX = 1; /* init spec.instr. line index*/
      PC0HW01.PC0HWSTW = "N"; /* init spec. instr. text switch*/

      PC0HS08(); /* fetch pcbrec row*/

      while (PC0HW01.PC0HWSIX <= 13 /* CAN NOT EXCEED 13 ENTRIES*/
       && PC0HW01.PC0HWSTW == "N") /* until end of set*/

        PC0HM002.PCBSITXT[PC0HWSIX] = PCBREC.PCBSITXT;
        PC0HW01.PCBSITXT[PC0HWSIX] = PCBREC.PCBSITXT;

        PC0HS08(); /* fetch pcbrec row*/

        PC0HW01.PC0HWSIX = PC0HW01.PC0HWSIX + 1; /* incr. index*/

      end

      PC0HS09(); /* close pcbrec row*/

    end
  end

end // end PC0H410

// Format and display the map
Function PC0H420()

   /* ------------------------------------------------------------*/
   /* Format the map heading.*/
   /* If no error to display, format the selected data.*/
   /* Indicate sound audible alarm for any error.*/
   /* ------------------------------------------------------------*/

  if (converseVar.validationMsgNum == 0 /* No errors*/
   && PC0HW01.PC0HWBYF == "N")          /* do not bypass processing*/

     /* load p.o. hdr special instruction from temp storage*/

    PC0HM002.XGPCD = PC0HW01.XGPCD;
    if (PC0HW01.XGPCD in XGPTBL.XGPCD)
      PC0HM002.XGPABRV = XGPTBL.XGPABRV[sysVar.arrayIndex];
    end
    PC0HM002.PC3PONBR = PC0HW01.PC3PONBR;
    PC0HM002.PC0HMPOI = PC0HW01.PC0HWFPI;
    PC0HM002.YSICD = PC0HW02.YSICD[PC0HWIXM];
    if (PC0HW02.YSICD[PC0HWIXM] in YSITBL.YSICD)
      PC0HM002.YSISDESC = YSITBL.YSISDESC[sysVar.arrayIndex];
    end
    PC0HM002.PCASIDSC = PC0HW02.PCASIDSC[PC0HWIXM];
    PC0HM002.PCEPRSEQ = PC0HW02.PCEPRSEQ[PC0HWIXM];
    PC0HM002.PC0HMSRC = PC0HW02.PC0HMSRC[PC0HWIXM];

    set PC0HM002.PCASIDSC cursor; /* Position cursor*/
    PC0HW01.PC0HWCIX = PC0HW01.PC0HWIXM; /* save to position cursor*/
    PC0HW02.PC0HMSEL[PC0HWIXM] = "V";

    PC0HS10(); /* update temp storage*/

  end

   /* protect key fields*/

  set PC0HM002.XGPCD protect; /* Gpc code*/
  set PC0HM002.PC3PONBR protect; /* p.o. number*/
  set PC0HM002.PC0HMPOI protect; /* p.o. id*/
  set PC0HM002.YSICD protect; /* special instruction type*/

  PC0HM002.PC0HMFNC = "CHANGE"; /* Move inquiry literal to map*/
  PC0HM002.XXXCURDT = VGVar.currentShortGregorianDate; /* Current date*/

  if (PC0HW01.PC0HWMFL == "Y")
    converseLib.validationFailed(1); /* update message*/
    PC0HM002.XXXPRCNM = "PC0H420"; /* process name*/
    PC0HW01.PC0HWMFL = "N"; /* reset message flag*/
  end

  if (converseVar.validationMsgNum != 0) /* Errors exist*/
    if (converseVar.validationMsgNum == 99)
      converseLib.validationFailed(0); /* reset ezemno*/
    else
      set PC0HM002 alarm; /* sound the alarm*/
    end
  end

  converse PC0HM002 ;

  PC0HW01.PC0HWPSW = "N"; /* Initialize problem switch*/

end // end PC0H420

// Check attention identifier
Function PC0H430()

   /* ------------------------------------------------------------*/
   /* Check attention identifier used to invoke the transaction.*/
   /* ------------------------------------------------------------*/

   /* ------------------------------------------------------------*/
   /* PA2 - Refresh screen pc0hm002*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pa2) /* PA2 was pressed*/
    converseLib.clearScreen();
     /* refresh screen*/
    PC0HW01.PC0HWBYF = "Y"; /* bypass reload*/
    return; /* exit to redisplay map*/
  end

   /* ------------------------------------------------------------*/
   /* PF3 - Return to p.o. header special instruction list screen*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf3) /* PF3 was pressed*/
    PC0HW01.PC0HWMAP = "1"; /* Move to map 1*/

    exit stack; /* Exit to redisplay map*/

  end

   /* ------------------------------------------------------------*/
   /* Indicate invalid key has been pressed*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey not enter) /* ENTER was not pressed*/
    PC0HM002.XXXPRCNM = "PC0H430"; /* Process name*/
    converseLib.validationFailed(4); /* Indicate invalid attention key*/
    if (converseVar.eventKey is pa1 /* PA1 was pressed*/
     || converseVar.eventKey is pa3) /* or PA3 was pressed*/
      converseLib.clearScreen();
       /* Clear screen before redisplay*/
      PC0HW01.PC0HWBYF = "Y"; /* bypass reload*/
    end

    return; /* Exit to redisplay map*/

  end

end // end PC0H430

// Reset highlighted fields
Function PC0H440()

   /* ------------------------------------------------------------*/
   /* Reset field attributes to normal intensity.*/
   /* ------------------------------------------------------------*/

  set PC0HM002.XGPCD initialAttributes; /* Gpc code*/
  set PC0HM002.YSICD initialAttributes; /* special instr. type*/
  set PC0HM002.PCASIDSC initialAttributes; /* instruction description*/
  set PC0HM002.PC3PONBR initialAttributes; /* p.o. number*/
  set PC0HM002.PC0HMPOI initialAttributes; /* p.o. id*/
  set PC0HM002.PCEPRSEQ initialAttributes; /* print seq*/

  PC0HW01.PC0HWSIX = 1; /* init spec text index*/
  while (PC0HW01.PC0HWSIX <= 13)
    set PC0HM002.PCBSITXT[PC0HWSIX] initialAttributes;
    PC0HW01.PC0HWSIX = PC0HW01.PC0HWSIX + 1;
  end

end // end PC0H440

// Verify the entered data
Function PC0H450()

   /* ------------------------------------------------------------*/
   /* Highlight any application data that was entered.*/
   /* If any errors were found, exit to redisplay the map.*/
   /* ------------------------------------------------------------*/
  PC0HW01.PC0HWDEF = "N"; /* initialize data entered flag*/

   /* if no changes have been applied bypass edits*/

  if (PC0HM002.PCEPRSEQ == PC0HW02.PCEPRSEQ[PC0HWIXM]
   && PC0HM002.PCASIDSC == PC0HW02.PCASIDSC[PC0HWIXM])
    PC0HW01.PC0HWSIX = 1;
    PC0HW01.PC0HWTEF = "N";
    while (PC0HW01.PC0HWSIX <= 13)
      if (PC0HW01.PCBSITXT[PC0HWSIX] != PC0HM002.PCBSITXT[PC0HWSIX])
        PC0HW01.PC0HWTEF = "Y"; /* text entered flag*/
      end
      PC0HW01.PC0HWSIX = PC0HW01.PC0HWSIX + 1;
    end

    if (PC0HW01.PC0HWTEF == "N")
      return;
    end
  end

  PC0H451(); /* validate input data*/

end // end PC0H450

// validate input data
Function PC0H451()

   /* ------------------------------------------------------------*/
     /* validate any input data.*/
     /* if errors were found, exit to redisplay the map*/
   /* ------------------------------------------------------------*/

  PC0HW01.PC0HWDEF = "Y"; /* data has been entered*/

   /* ------------------------------------------------------------*/
   /* Verify special instruction text has been entered*/
   /* ------------------------------------------------------------*/

  PC0HW01.PC0HWSIX = 13;
  PC0HW01.PC0HWTEF = "N";
  while (PC0HW01.PC0HWSIX >= 1
   && PC0HW01.PC0HWTEF == "N")
    if (PC0HM002.PCBSITXT[PC0HWSIX] != " ")
      PC0HW01.PC0HWTEF = "Y";
    end

    PC0HW01.PC0HWSIX = PC0HW01.PC0HWSIX - 1; /* incr. index*/

  end

  if (PC0HW01.PC0HWTEF == "N")
    converseLib.validationFailed(161); /* special instructions missing/invalid*/
    PC0HM002.XXXPRCNM = "PC0H451"; /* load process name*/
    PC0HW01.PC0HWSIX = 13;
    while (PC0HW01.PC0HWSIX >= 1)
      set PC0HM002.PCBSITXT[PC0HWSIX] cursor, modified, bold;

      PC0HW01.PC0HWSIX = PC0HW01.PC0HWSIX - 1; /* incr. index*/

    end
  end

   /* ------------------------------------------------------------*/
   /* Validate print sequence*/
   /* ------------------------------------------------------------*/

  if (PC0HM002.PCEPRSEQ <= 0)
    PC0HM002.XXXPRCNM = "PC0H451"; /* load process name*/
    converseLib.validationFailed(140); /* print sequence gt zero*/
    set PC0HM002.PCEPRSEQ cursor, modified, bold;
  end

   /* ------------------------------------------------------------*/
   /* validate p.o hdr special instruction short description*/
   /* ------------------------------------------------------------*/

  if (PC0HM002.PCASIDSC == " ")
    PC0HM002.XXXPRCNM = "PC0H451"; /* load process name*/
    converseLib.validationFailed(161); /* special instructions missing/invalid*/
    set PC0HM002.PCASIDSC cursor, modified, bold;
  end


end // end PC0H451

// process valid input request
Function PC0H460()

   /* ------------------------------------------------------------*/
   /* process valid input request*/
   /* ------------------------------------------------------------*/

  if (PC0HW01.PC0HWDEF == "N"           /* data has not changed*/
   || converseVar.validationMsgNum != 0 /* errors*/
   || PC0HW01.PC0HWBYF == "Y")          /* bypass processing*/

    return;

  end

   /* ------------------------------------------------------------*/
   /* init p.o. hdr special instruction hdr and detail records*/
   /* ------------------------------------------------------------*/

  set PCEREC empty; /* init p.o. hdr special instr rec*/
  set PCBREC empty; /* init special instr text rec*/

   /* ------------------------------------------------------------*/
   /* obtain current date and time for update*/
   /* ------------------------------------------------------------*/

  XX0XS01(); /* obtain current date and time*/


   /* ------------------------------------------------------------*/
   /* udpate p.o. hdr special instruction header information*/
   /* ------------------------------------------------------------*/

  PCEREC.XGPCD = PC0HM002.XGPCD;
  PCEREC.PCASINBR = PC0HW02.PCASINBR[PC0HWIXM];

  PC0HS16(); /* select p.o. hdr special instr hdr*/

  if (SQLCA.VAGen_SQLCODE == 100) /* p.o. spec instr hdr has been deleted*/
    PC0HM001.XXXPRCNM = "PC0H460";
    PC0HW01.PC0HWMAP = 1; /* reset map*/
    converseLib.validationFailed(26); /* data deleted by another application*/
    exit stack;
  else
    PCEREC.PCASIDSC = PC0HM002.PCASIDSC;
    PCEREC.PCEPRSEQ = PC0HM002.PCEPRSEQ;
    PCEREC.PCESIID = "P";
    PCEREC.ZZZCHGCT = PC0HW02.ZZZCHGCT[PC0HWIXM];
    PCEREC.ZZZCHGDT = XX0XW01.XX0XWDAT;
    PCEREC.ZZZCHGTM = XX0XW01.XX0XWTIM;

    PC0HS17(); /* upd p.o. hdr special instr header*/

    if (SQLCA.VAGen_SQLCODE == 100)

      PC0H461(); /* upd temp storage/screen w/upd data*/

    else

      VPOHDR02.XGPCD = PC0HM002.XGPCD;
      VPOHDR02.PO-REG-CD = PCWREC.PO-REG-CD;
      VPOHDR02.PC3PONBR = PC0HM002.PC3PONBR;
      PC0HS14(); /* select po header*/

      PC0HS20(); /* create hdr si audit*/
    end
  end

   /* ------------------------------------------------------------*/
   /* If p.o. hdr special instruction text information changed*/
   /* update table row*/
   /* ------------------------------------------------------------*/

  if (PC0HW01.PC0HWPSW == "N")
    PC0HW01.PC0HWSIX = 1;
    PC0HW01.PC0HWTEF = "N";
    while (PC0HW01.PC0HWSIX <= 13)
      if (PC0HW01.PCBSITXT[PC0HWSIX] != PC0HM002.PCBSITXT[PC0HWSIX])
        PC0HW01.PC0HWTEF = "Y";
      end
      PC0HW01.PC0HWSIX = PC0HW01.PC0HWSIX + 1;
    end

    if (PC0HW01.PC0HWTEF == "Y") /* special message text changed*/

      PCBREC.XGPCD = PC0HM002.XGPCD;
      PCBREC.PCASINBR = PC0HW02.PCASINBR[PC0HWIXM];
      PCBREC.ZZZSDT = XX0XW01.XX0XWDAT;

      PC0HS18(); /* delete pcbrec set*/

       /* Determine how many message text lines to add*/
       /* (bypass blank lines)*/

      PC0HW01.PC0HWSIX = 13;
      while (PC0HM002.PCBSITXT[PC0HWSIX] == " ") /* determine load index*/
        PC0HW01.PC0HWSIX = PC0HW01.PC0HWSIX - 1;
      end

       /* Load special message text data*/

      PC0HW01.PC0HWLIX = PC0HW01.PC0HWSIX; /* max entries*/
      PC0HW01.PC0HWSIX = 1;
      PCBREC.XGPCD = PC0HM002.XGPCD;
      PCBREC.PCASINBR = PC0HW02.PCASINBR[PC0HWIXM];
      while (PC0HW01.PC0HWSIX <= PC0HW01.PC0HWLIX)
        PCBREC.PCBSISEQ = PC0HW01.PC0HWSIX;
        PCBREC.PCBSITXT = PC0HM002.PCBSITXT[PC0HWSIX];

        PC0HS13(); /* add special instruction text*/

        PC0HW01.PC0HWSIX = PC0HW01.PC0HWSIX + 1;

      end
    end
  end

  if (PC0HW01.PC0HWPSW == "Y")
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback(); /* roll out all database changes*/
    PC0HW01.PC0HWMFL = "N"; /* data update flag*/
  else

     /* update temp storage (p.o. hdr special instruction info)*/

    PC0HW02.YSICD[PC0HWIXM] = PCEREC.YSICD;
    PC0HW02.PCASIDSC[PC0HWIXM] = PCEREC.PCASIDSC;
    PC0HW02.PCEPRSEQ[PC0HWIXM] = PCEREC.PCEPRSEQ;
    PC0HW02.PC0HMSRC[PC0HWIXM] = "P.O.";
    PC0HW02.ZZZCHGCT[PC0HWIXM] = PCEREC.ZZZCHGCT;

    PC0HS10(); /* update temp storage*/

    VGVar.handleSysLibraryErrors = 0;
    sysLib.commit(); /* changes completed*/
    PC0HW01.PC0HWMFL = "Y"; /* data update flag*/
  end

  PC0HM002.XXXPRCNM = "PC0H460"; /* process name*/

end // end PC0H460

// upd temp storage/map
Function PC0H461()

   /* ------------------------------------------------------------*/
   /* if p.o. hdr special instruction data changed obtain both*/
   /* the p.o. hdr special instruction hdr and text to update*/
   /* temporary storage and map fields.*/
   /* ------------------------------------------------------------*/

  PCEREC.XGPCD = PC0HM002.XGPCD;
  PCEREC.PCASINBR = PC0HW02.PCASINBR[PC0HWIXM];

  PC0HS16(); /* select p.o. hdr special instr.*/

  if (SQLCA.VAGen_SQLCODE == 100)
    PC0HM001.XXXPRCNM = "PC0H461"; /* load process name*/
    PC0HW01.PC0HWMAP = 1; /* display list screen*/
    converseLib.validationFailed(26); /* data deleted by another appl.*/
    exit stack; /* exit*/
  end

  PC0HW01.PC0HWPSW = "Y"; /* set problem switch*/
  converseLib.validationFailed(12); /* data updated by another appl.*/

   /* update temp storage*/

  PC0HW02.PCASIDSC[PC0HWIXM] = PCEREC.PCASIDSC;
  PC0HW02.PCEPRSEQ[PC0HWIXM] = PCEREC.PCEPRSEQ;
  if (PCEREC.PCESIID == "N")
    PC0HW02.PC0HMSRC[PC0HWIXM] = "NIKE";
  else
    if (PCEREC.PCESIID == "C")
      PC0HW02.PC0HMSRC[PC0HWIXM] = "CUST";
    else
      if (PCEREC.PCESIID == "P")
        PC0HW02.PC0HMSRC[PC0HWIXM] = "P.O.";
      else
        PC0HW02.PC0HMSRC[PC0HWIXM] = " ";
      end
    end
  end
  PC0HW02.ZZZCHGCT[PC0HWIXM] = PCEREC.ZZZCHGCT;

  PC0HS10(); /* update temp storage*/

   /* update pc0hm002 map*/

  PC0HM002.PCASIDSC = PC0HW02.PCASIDSC[PC0HWIXM];
  PC0HM002.PCEPRSEQ = PC0HW02.PCEPRSEQ[PC0HWIXM];
  PC0HM002.PC0HMSRC = PC0HW02.PC0HMSRC[PC0HWIXM];

   /* reload message text for display*/

  set PCBREC empty; /* init spec. text rec pcbrec*/
  move " " to PC0HWTXT[1] for all; /* clear w/s text table*/

  PCBREC.XGPCD = PC0HW02.XGPCD[PC0HWIXM];
  PCBREC.PCASINBR = PC0HW02.PCASINBR[PC0HWIXM];

  PC0HS07(); /* select set and open the cursor*/

  PC0HW01.PC0HWSIX = 1; /* init spec.instr. line index*/
  PC0HW01.PC0HWSTW = "N"; /* init spec. instr. text switch*/

  PC0HS08(); /* fetch pcbrec row*/

  while (PC0HW01.PC0HWSIX <= 13) /* CAN NOT EXCEED 13 ENTRIES*/

     /* load special instruction text for display and compare use*/

    if (PC0HW01.PC0HWSTW == "N")
      PC0HM002.PCBSITXT[PC0HWSIX] = PCBREC.PCBSITXT;
      PC0HW01.PCBSITXT[PC0HWSIX] = PCBREC.PCBSITXT;
    else
      PC0HM002.PCBSITXT[PC0HWSIX] = " ";
    end

    PC0HS08(); /* fetch pcbrec row*/

    PC0HW01.PC0HWSIX = PC0HW01.PC0HWSIX + 1; /* incr. index*/

  end

  PC0HS09(); /* close pcbrec row*/

end // end PC0H461

// p.o. hdr special instr - del
Function PC0H500()

   /* ------------------------------------------------------------*/
   /* This is the main process used to display a map.  Processing*/
   /* always returns to the top of this process and falls through*/
   /* subordinate processes until an error is found or a valid*/
   /* request is processed.  Processing sequence is as follows:*/

   /* 1) Obtain the data to display.*/
   /* 2) Format the map output area and display the map.*/
   /* 3) Check the attention identifier used to respond.*/
   /* 4) Reset highlighted fields to normal intensity.*/
   /* 5) Verify the data that was entered.*/
   /* 6) Process a valid input request.*/

   /* In all subordinate processes, "EZEFLO" is used to exit to*/
   /* redisplay the map when an error is found.  This is done to*/
   /* minimize the coding effort required to skip subsequent*/
   /* processing under error conditions.*/
   /* ------------------------------------------------------------*/

  PC0H510(); /* obtain data*/

  PC0H520(); /* Format and display the map*/

  PC0H530(); /* Check attention identifier*/

  PC0H540(); /* Reset fields to normal intensity*/

  PC0H550(); /* verify the entered data*/

  PC0H560(); /* process valid input request*/

end // end PC0H500

// Obtain spec instr text
Function PC0H510()

   /* ------------------------------------------------------------*/
   /* obtain the special instruction text row(s) for display*/
   /* ------------------------------------------------------------*/

  if (converseVar.validationMsgNum == 0 /* no errors*/
   && PC0HW01.PC0HWBYF == "N")         

    set PC0HM002 initial; /* clear screen pc0hm002*/
    set PCBREC empty; /* init spec. text rec pcbrec*/

    PCBREC.XGPCD = PC0HW02.XGPCD[PC0HWIXM];
    PCBREC.PCASINBR = PC0HW02.PCASINBR[PC0HWIXM];

    PC0HS07(); /* select set and open the cursor*/

    PC0HW01.PC0HWSIX = 1; /* init spec.instr. line index*/
    PC0HW01.PC0HWSTW = "N"; /* init spec. instr. text switch*/

    PC0HS08(); /* fetch pcbrec row*/

    while (PC0HW01.PC0HWSTW == "N" /* until end of special text or*/
     && PC0HW01.PC0HWSIX <= 13) /* CAN NOT EXCEED 13 ENTRIES*/

       /* load special instruction text for display*/

      PC0HM002.PCBSITXT[PC0HWSIX] = PCBREC.PCBSITXT;

      PC0HS08(); /* fetch pcbrec row*/

      PC0HW01.PC0HWSIX = PC0HW01.PC0HWSIX + 1; /* incr. index*/

    end

    PC0HS09(); /* close set of pcbrec rows*/

  end

end // end PC0H510

// Format and display the map
Function PC0H520()

   /* ------------------------------------------------------------*/
   /* Format the map heading.*/
   /* If no error to display, format the selected data.*/
   /* Indicate sound audible alarm for any error.*/
   /* ------------------------------------------------------------*/

  if (converseVar.validationMsgNum == 0 /* No errors*/
   && PC0HW01.PC0HWBYF == "N")         

     /* load p.o. hdr special instruction from temp storage*/

    PC0HM002.XGPCD = PC0HW01.XGPCD;
    if (PC0HW01.XGPCD in XGPTBL.XGPCD)
      PC0HM002.XGPABRV = XGPTBL.XGPABRV[sysVar.arrayIndex];
    end
    PC0HM002.PC3PONBR = PC0HW01.PC3PONBR;
    PC0HM002.PC0HMPOI = PC0HW01.PC0HWFPI;
    PC0HM002.YSICD = PC0HW02.YSICD[PC0HWIXM];
    if (PC0HW02.YSICD[PC0HWIXM] in YSITBL.YSICD)
      PC0HM002.YSISDESC = YSITBL.YSISDESC[sysVar.arrayIndex];
    end
    PC0HM002.PCASIDSC = PC0HW02.PCASIDSC[PC0HWIXM];
    PC0HM002.PCEPRSEQ = PC0HW02.PCEPRSEQ[PC0HWIXM];
    PC0HM002.PC0HMSRC = PC0HW02.PC0HMSRC[PC0HWIXM];

    converseLib.validationFailed(27); /* press enter to delete data*/
    PC0HW01.PC0HWCIX = PC0HW01.PC0HWIXM; /* save to position cursor*/
    PC0HW02.PC0HMSEL[PC0HWIXM] = "V";

    PC0HS10(); /* update temp storage*/

  end

   /* Protect all p.o. hdr special instruction data*/

  set PC0HM002.XGPCD protect; /* Gpc code*/
  set PC0HM002.YSICD protect; /* special instr. type code*/
  set PC0HM002.PCASIDSC protect; /* special instruction short desc*/
  set PC0HM002.PCEPRSEQ protect; /* print sequence*/

  PC0HW01.PC0HWSIX = 1; /* init spec text index*/
  while (PC0HW01.PC0HWSIX <= 13)
    set PC0HM002.PCBSITXT[PC0HWSIX] protect;
    PC0HW01.PC0HWSIX = PC0HW01.PC0HWSIX + 1;
  end

  PC0HM002.PC0HMFNC = "DELETE"; /* Move copy literal to map*/
  PC0HM002.XXXCURDT = VGVar.currentShortGregorianDate; /* Current date*/

  if (PC0HW01.PC0HWMFL == "Y")
    converseLib.validationFailed(1); /* update message*/
    PC0HM002.XXXPRCNM = "PC0H520"; /* process name*/
    PC0HW01.PC0HWMFL = "N"; /* reset message flag*/
  end

  if (converseVar.validationMsgNum != 0) /* Errors exist*/
    if (converseVar.validationMsgNum == 99)
      converseLib.validationFailed(0); /* reset ezemno*/
    else
      if (converseVar.validationMsgNum != 27) /* bypass delete message*/
        set PC0HM002 alarm; /* sound the alarm*/
      end
    end
  end

  converse PC0HM002 ;

  PC0HW01.PC0HWPSW = "N"; /* Initialize problem switch*/

end // end PC0H520

// Check attention identifier
Function PC0H530()

   /* ------------------------------------------------------------*/
   /* Check attention identifier used to invoke the transaction.*/
   /* ------------------------------------------------------------*/

   /* ------------------------------------------------------------*/
   /* PA2 - Refresh screen pc0hm002*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pa2) /* PA2 was pressed*/
    converseLib.clearScreen();
     /* refresh screen*/
    PC0HW01.PC0HWBYF = "Y"; /* bypass reload*/
    return; /* exit to redisplay map*/
  end

   /* ------------------------------------------------------------*/
   /* PF3 - Return to p.o. header special instruction list*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf3) /* PF3 was pressed*/

    PC0HW01.PC0HWMAP = "1"; /* Move to map 1*/

    exit stack; /* Exit to redisplay map*/

  end

   /* ------------------------------------------------------------*/
   /* Indicate invalid key has been pressed*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey not enter) /* ENTER was not pressed*/
    PC0HM002.XXXPRCNM = "PC0H530"; /* Process name*/
    converseLib.validationFailed(4); /* Indicate invalid attention key*/
    if (converseVar.eventKey is pa1 /* PA1 was pressed*/
     || converseVar.eventKey is pa3) /* or PA3 was pressed*/
      converseLib.clearScreen();
       /* Clear screen before redisplay*/
      PC0HW01.PC0HWBYF = "Y"; /* bypass reload*/
    end

    exit stack; /* Exit to redisplay map*/

  end


end // end PC0H530

// Reset highlighted fields
Function PC0H540()

   /* ------------------------------------------------------------*/
   /* Reset field attributes to normal intensity.*/
   /* ------------------------------------------------------------*/

  set PC0HM002.XGPCD initialAttributes; /* Gpc code*/
  set PC0HM002.YSICD initialAttributes; /* special instr. type*/
  set PC0HM002.PCASIDSC initialAttributes; /* instruction description*/
  set PC0HM002.PCEPRSEQ initialAttributes; /* print sequence number*/

  PC0HW01.PC0HWSIX = 1; /* init spec text index*/
  while (PC0HW01.PC0HWSIX <= 13)
    set PC0HM002.PCBSITXT[PC0HWSIX] initialAttributes;
    PC0HW01.PC0HWSIX = PC0HW01.PC0HWSIX + 1;
  end

end // end PC0H540

// verify the entered data
Function PC0H550()

   /* ------------------------------------------------------------*/
   /* Verify deletion request*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is enter)
    PCEREC.XGPCD = PC0HW02.XGPCD[PC0HWIXM];
    PCEREC.PCASINBR = PC0HW02.PCASINBR[PC0HWIXM];

    PC0HS16(); /* select the po hdr special instr*/

    if (SQLCA.VAGen_SQLCODE == 100)
      PC0HM002.XXXPRCNM = "PC0H550"; /* load process name*/
      PC0HW01.PC0HWMAP = 1; /* display list screen*/
      converseLib.validationFailed(26);
    end
  end

end // end PC0H550

// process valid input request
Function PC0H560()

   /* ------------------------------------------------------------*/
   /* process valid input request*/
   /* ------------------------------------------------------------*/
  if (converseVar.validationMsgNum != 0 /* errors exist*/
   || PC0HW01.PC0HWBYF == "Y")         
    return;
  end

  PC0HS19();
                                   /* delete  p.o. special instr hdr record*/

   /* delete special instruction text*/

  PCBREC.XGPCD = PC0HW02.XGPCD[PC0HWIXM];
  PCBREC.PCASINBR = PC0HW02.PCASINBR[PC0HWIXM];

  PC0HS18(); /* delete special instruction text*/

   /* check to see if all special instructions have been deleted*/

  PCEREC.XGPCD = PC0HW01.XGPCD;
  PCEREC.PC3PONBR = PC0HW01.PC3PONBR;

  PC0HS02(); /* Select set and open the cursor*/

  PC0HS03(); /* Fetch pcerec row*/

  if (SQLCA.VAGen_SQLCODE == 100)

    XX0XS01(); /* obtain date and time*/

    set VPOHDR02 empty;

    VPOHDR02.XGPCD = PC0HM002.XGPCD;
    VPOHDR02.PO-REG-CD = PCWREC.PO-REG-CD;
    VPOHDR02.PC3PONBR = PC0HM002.PC3PONBR;

    PC0HS14(); /* select p.o. header*/

    if (SQLCA.VAGen_SQLCODE == 0)

      VPOHDR02.PC3SIFL = "N";
      VPOHDR02.ZZZCHGDT = XX0XW01.XX0XWDAT;
      VPOHDR02.ZZZCHGTM = XX0XW01.XX0XWTIM;

      PC0HS15(); /* update po header*/

      if (SQLCA.VAGen_SQLCODE == 100)
        PC0HW01.PC0HWPSW = "Y"; /* set error switch*/
        converseLib.validationFailed(170); /* p.o. hdr updated by another appl*/
      end
    else
      PC0HW01.PC0HWPSW = "Y"; /* set error switch*/
      converseLib.validationFailed(168); /* p.o. hdr deleted by another appl*/
    end
  end

  PC0HS05(); /* close pcerec*/

  if (PC0HW01.PC0HWPSW == "Y")
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback();
    PC0HW01.PC0HWMFL = "N"; /* reset message flag*/
  else
    VGVar.handleSysLibraryErrors = 0;
    sysLib.commit();
    PC0HW01.PC0HWSWR = "Y"; /* set data request flag*/
    PC0HW01.PC0HWMFL = "Y"; /* message flag*/
  end

  PC0HM002.XXXPRCNM = "PC0H560"; /* process name*/
end // end PC0H560

// Purge temp storage
Function PC0HS01()

   /* ------------------------------------------------------------*/
   /* Purge any temporary storage for this application.*/
   /* ------------------------------------------------------------*/

  TA5REC.TA5APPID = "PC0H"; /* Application identification*/
  TA5REC.TA5FNCCD = "P"; /* Function code*/

  try
    call "TA0050" (PC0HW02, TA5REC) {isNoRefresh = yes, isExternal = yes};
  end /* Temporary storage*/

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && TA5REC.TA5RTNCD == 0)          /* No error was found*/

       /* NEXT SENTENCE*/

  else

    TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
    TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
    TA1REC.TA1TYPE = "APPL"; /* Type of error*/
    TA1REC.TA1PGMNM = "PC0HS01"; /* Process name*/
    TA1REC.TA1LOC = "PURGE ANY TEMPORARY STORAGE";

    call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  end

  PC0HW01.PC0HWTSP = 0; /* Reset current page number*/
  PC0HW01.TA5TSQIX = 0; /* Reset highest page number*/

end // end PC0HS01

// Select Set pcerec (S1)
Function PC0HS02()

   /* ------------------------------------------------------------*/
   /* Select the set of table rows*/
   /* If not available, return an error message to the user.*/
   /* If any other, indicate system error.*/
   /* ------------------------------------------------------------*/

  try
    call "IO3280" ("S1", SQLCA, PCEREC) {isNoRefresh = yes, isExternal = yes};
  end
                                   /* Select table set S1*/

  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Expected return code*/

      return; /* Return to previous process*/

    end
  end

  if (sysVar.errorCode == "00000000"
   && SQLCA.VAGen_SQLCODE == -911) /* Resource not available*/
    PC0HW01.PC0HWSWR = "N"; /* request for data no*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0HS02"; /* Process name*/
  TA1REC.TA1LOC = "SELECT SET OF TABLE ROWS";
  TA1REC.TA1DBASE = "DPRODC. "; /* Data base name*/
  TA1REC.TA1TBLVU = "VPOHSI01"; /* Table view name*/
  TA1REC.TA1TBLKE = PCEREC.PCEGROUP; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0HM001.XXXPRCNM = "PC0HS02"; /* Process name*/

  exit stack;

end // end PC0HS02

// Fetch pcerec row
Function PC0HS03()

   /* ------------------------------------------------------------*/
   /* Fetch the next row from the selected set of rows.*/
   /* If end of file, set end of file switch.*/
   /* If any error, indicate a system error.*/
   /* Format the data in the temporary storage display line.*/
   /* ------------------------------------------------------------*/

  try
    call "IO3280" ("N1", SQLCA, PCEREC) {isNoRefresh = yes, isExternal = yes};
  end
                                   /* Fetch next row from n1*/

  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Everything OK*/

      return; /* Return to previous process*/

    end

    if (SQLCA.VAGen_SQLCODE == 100) /* End of selected set*/

      PC0HW01.PC0HWPOW = "Y"; /* end of set found*/
      return; /* Return to previous process*/

    end
  end

  if (sysVar.errorCode == "00000000"
   && SQLCA.VAGen_SQLCODE == -911) /* Resource not available*/
    PC0HW01.PC0HWSWR = "N"; /* request for data no*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  end


  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0HS03"; /* Process name*/
  TA1REC.TA1LOC = "FETCH NEXT SELECTED TABLE ROW";
  TA1REC.TA1DBASE = "DPRODC. "; /* Data base name*/
  TA1REC.TA1TBLVU = "VPOHSI01"; /* Table view name*/
  TA1REC.TA1TBLKE = PCEREC.PCEGROUP; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0HM001.XXXPRCNM = "PC0HS03"; /* Process name*/

  exit stack;

end // end PC0HS03

// Add page to temp storage
Function PC0HS04()

   /* ------------------------------------------------------------*/
   /* Add the next page to temporary storage.*/
   /* ------------------------------------------------------------*/

  PC0HW02.PC0HWLEN = 564; /* Temporary storage length*/
  TA5REC.TA5APPID = "PC0H"; /* Application identification*/
  TA5REC.TA5FNCCD = "A"; /* Function code*/

  try
    call "TA0050" (PC0HW02, TA5REC) {isNoRefresh = yes, isExternal = yes};
  end /* Temporary storage*/

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && TA5REC.TA5RTNCD == 0)          /* everything is a-ok*/
    PC0HW01.TA5TSQIX = TA5REC.TA5TSQIX; /* Highest page number*/
    PC0HW01.PC0HWIXM = 1; /* Reset display line number*/
    set PC0HW02 empty; /* Clear temporary storage record*/
  else /* error was found*/
    TAEREC.TAEDESC1 = sysVar.errorCode; /* Csp return code*/
    TA1REC.TA1TYPE = "APPL"; /* Type of error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    TA1REC.TA1PGMNM = "PC0HS04"; /* Process name*/
    TA1REC.TA1LOC = "ADD PAGE TO TEMPORARY STORAGE";
    TAEREC.TAEDESC2 = TA5REC.TA5DATA; /* Subroutine parameters*/

    call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    PC0HM001.XXXPRCNM = "PC0HS04"; /* Process name*/
    converseLib.validationFailed(10); /* Indicate system error*/
    PC0HW01.PC0HWSWR = "Y"; /* request data*/

  end

end // end PC0HS04

// Close selected pcerec set
Function PC0HS05()

   /* ------------------------------------------------------------*/
   /* Close the selected set of table rows.*/
   /* If any error, indicate a system error.*/
   /* ------------------------------------------------------------*/

  try
    call "IO3280" ("C1", SQLCA, PCEREC) {isNoRefresh = yes, isExternal = yes};
  end /* Close table set C1*/

  if (sysVar.errorCode == "00000000"
   && SQLCA.VAGen_SQLCODE == 0) /* Expected return code*/

       /* NEXT SENTENCE*/

  else

    TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
    TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
    TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    TA1REC.TA1PGMNM = "PC0HS05"; /* Process name*/
    TA1REC.TA1LOC = "CLOSE SELECTED SET OF TABLE ROWS";
    TA1REC.TA1DBASE = "DPRODC. "; /* Data base name*/
    TA1REC.TA1TBLVU = "VPOHSI01"; /* Table view name*/

    call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    PC0HM001.XXXPRCNM = "PC0HS05"; /* Process name*/
    converseLib.validationFailed(10); /* Indicate system error*/
    PC0HW01.PC0HWSWR = "Y"; /* request data*/

    exit stack;

  end

end // end PC0HS05

// Obtain lines from temp storage
Function PC0HS06()

   /* ------------------------------------------------------------*/
   /* Obtain the next page of data to display.*/
   /* ------------------------------------------------------------*/

  PC0HW02.PC0HWLEN = 564; /* Temporary storage length*/
  TA5REC.TA5APPID = "PC0H"; /* Application identification*/
  TA5REC.TA5TSQIX = PC0HW01.PC0HWTSP; /* Page number*/
  TA5REC.TA5FNCCD = "R"; /* Function code*/

  call "TA0050" (PC0HW02, TA5REC) {isNoRefresh = yes, isExternal = yes};
                                   /* Temporary storage subroutine*/

  if (TA5REC.TA5RTNCD != 0) /* Error was found*/

    TA1REC.TA1TYPE = "APPL"; /* Type of error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    TA1REC.TA1PGMNM = "PC0HS06"; /* Process name*/
    TA1REC.TA1LOC = "READ PAGE FROM TEMPORARY STORAGE";
    TA1REC.TA1MAP = "PC0HM001"; /* Map name*/
    TAEREC.TAEDESC1 = TA5REC.TA5DATA; /* Subroutine parameters*/

    call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    PC0HW01.PC0HWSWR = "Y"; /* request data*/
    converseLib.validationFailed(10); /* Indicate system error*/
    PC0HM001.XXXPRCNM = "PC0HS06"; /* Process name*/

    exit stack; /* Exit to redisplay map*/

  end

end // end PC0HS06

// Select Set pcbrec (S1)
Function PC0HS07()

   /* ------------------------------------------------------------*/
   /* Select the set of table rows*/
   /* If not available, return an error message to the user.*/
   /* If any other, indicate system error.*/
   /* ------------------------------------------------------------*/

  try
    call "IO3330" ("S1", SQLCA, PCBREC) {isNoRefresh = yes, isExternal = yes};
  end
                                   /* Select table set S1*/

  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Expected return code*/

      return; /* Return to previous process*/

    end
  end

  if (sysVar.errorCode == "00000000"
   && SQLCA.VAGen_SQLCODE == -911) /* Resource not available*/
    PC0HW01.PC0HWSWR = "N"; /* request for data no*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0HS07"; /* Process name*/
  TA1REC.TA1LOC = "SELECT SET OF TABLE ROWS";
  TA1REC.TA1DBASE = "DPRODC. "; /* Data base name*/
  TA1REC.TA1TBLVU = "VSITXT01"; /* Table view name*/
  TA1REC.TA1TBLKE = PCBREC.PCBGROUP; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0HW01.PC0HWMAP = "1"; /* display list map*/
  PC0HM001.XXXPRCNM = "PC0HS07"; /* Process name*/

  exit stack;

end // end PC0HS07

// Fetch pcbrec row
Function PC0HS08()

   /* ------------------------------------------------------------*/
   /* Fetch the next row from the selected set of rows.*/
   /* If end of file, set end of file switch.*/
   /* If any error, indicate a system error.*/
   /* Format the data in the temporary storage display line.*/
   /* ------------------------------------------------------------*/

  try
    call "IO3330" ("N1", SQLCA, PCBREC) {isNoRefresh = yes, isExternal = yes};
  end
                                   /* Fetch next row from n1*/

  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Everything OK*/

      return; /* Return to previous process*/

    end

    if (SQLCA.VAGen_SQLCODE == 100) /* End of selected set*/

      PC0HW01.PC0HWSTW = "Y"; /* end of set found*/
      return; /* Return to previous process*/

    end
  end

  if (sysVar.errorCode == "00000000"
   && SQLCA.VAGen_SQLCODE == -911) /* Resource not available*/
    PC0HW01.PC0HWSWR = "N"; /* request for data no*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  end


  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0HS08"; /* Process name*/
  TA1REC.TA1LOC = "FETCH NEXT SELECTED TABLE ROW";
  TA1REC.TA1DBASE = "DPRODC. "; /* Data base name*/
  TA1REC.TA1TBLVU = "VSITXT01"; /* Table view name*/
  TA1REC.TA1TBLKE = PCBREC.PCBGROUP; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0HM001.XXXPRCNM = "PC0HS08"; /* Process name*/

  exit stack;

end // end PC0HS08

// Close selected pcbrec set
Function PC0HS09()

   /* ------------------------------------------------------------*/
   /* Close the selected set of table rows.*/
   /* If any error, indicate a system error.*/
   /* ------------------------------------------------------------*/

  try
    call "IO3330" ("C1", SQLCA, PCBREC) {isNoRefresh = yes, isExternal = yes};
  end /* Close table set C1*/

  if (sysVar.errorCode == "00000000"
   && SQLCA.VAGen_SQLCODE == 0) /* Expected return code*/

       /* NEXT SENTENCE*/

  else

    TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
    TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
    TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    TA1REC.TA1PGMNM = "PC0HS09"; /* Process name*/
    TA1REC.TA1LOC = "CLOSE SELECTED SET OF TABLE ROWS";
    TA1REC.TA1DBASE = "DPRODC. "; /* Data base name*/
    TA1REC.TA1TBLVU = "VSITXT01"; /* Table view name*/

    call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    PC0HM001.XXXPRCNM = "PC0HS09"; /* Process name*/
    converseLib.validationFailed(10); /* Indicate system error*/
    PC0HW01.PC0HWSWR = "Y"; /* request data*/

    exit stack;

  end

end // end PC0HS09

// update temporary storage
Function PC0HS10()

   /* ------------------------------------------------------------*/
   /* Update the temp storage page.*/
   /* ------------------------------------------------------------*/

  PC0HW02.PC0HWLEN = 564; /* Temporary storage length*/
  TA5REC.TA5APPID = "PC0H"; /* Application identification*/
  TA5REC.TA5TSQIX = PC0HW01.PC0HWTSP; /* Page number*/
  TA5REC.TA5FNCCD = "U"; /* Function code*/

  call "TA0050" (PC0HW02, TA5REC) {isNoRefresh = yes, isExternal = yes};
                                   /* Temporary storage subroutine*/

  if (TA5REC.TA5RTNCD != 0) /* Error was found*/

    TA1REC.TA1TYPE = "APPL"; /* Type of error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    TA1REC.TA1PGMNM = "PC0HS10"; /* Process name*/
    TA1REC.TA1LOC = "UPD PAGE IN TEMPORARY STORAGE";
    TA1REC.TA1MAP = "PC0HM002"; /* Map name*/
    TAEREC.TAEDESC1 = TA5REC.TA5DATA; /* Subroutine parameters*/

    call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    PC0HW01.PC0HWSWR = "Y"; /* request data*/
    PC0HW01.PC0HWMAP = 1; /* redisplay list screen*/
    PC0HM001.XXXPRCNM = "PC0HS10"; /* Process name*/
    converseLib.validationFailed(10); /* Indicate system error*/

    exit stack; /* Exit to redisplay map*/

  end

end // end PC0HS10

// Select next spec inst nbr
Function PC0HS11()

   /* ------------------------------------------------------------*/
   /* Select a unique row.*/
   /* If not available, return an error message to the user.*/
   /* If any other, indicate system error.*/
   /* ------------------------------------------------------------*/

  try
    call "IO3350" ("G ", SQLCA, PCDREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Row found*/

      return; /* Return to previous process*/

    end
  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    PC0HW01.PC0HWSWR = "N"; /* request for data no*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback(); /* rollback updates*/
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0HS11"; /* Process name*/
  TA1REC.TA1LOC = "SELECT NEXT INSTR. NBR ROW ";
  TA1REC.TA1DBASE = "DPRODC. "; /* Data base name*/
  TA1REC.TA1TBLVU = "VSICTL01"; /* Table view name*/
  TA1REC.TA1TBLKE = PCDREC.PCDGROUP; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0HW01.PC0HWPSW = "Y"; /* set problem switch*/
  PC0HM002.XXXPRCNM = "PC0HS11"; /* Process name*/

  exit stack;

end // end PC0HS11

// Add p.o. header special instr
Function PC0HS12()

   /* ------------------------------------------------------------*/
   /* This module adds a table row.*/
   /* It will return and document system errors if unexpected*/
     /* return codes are found.*/
   /* ------------------------------------------------------------*/

  try
    call "IO3280" ("A ", SQLCA, PCEREC) {isNoRefresh = yes, isExternal = yes};
  end /* Add table row*/

  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Expected return codes*/

      return; /* Return to previous process*/

    end
  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback(); /* rollback updates*/
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0HS12"; /* Process name*/
  TA1REC.TA1LOC = "ADD TABLE ROW";
  TA1REC.TA1DBASE = "DPRODC. "; /* Data base name*/
  TA1REC.TA1TBLVU = "VPOHSI01"; /* Table view name*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0HW01.PC0HWPSW = "Y"; /* set problem switch*/
  PC0HM002.XXXPRCNM = "PC0HS12"; /* Process name*/

  exit stack;

end // end PC0HS12

// Add spec instr text row
Function PC0HS13()

   /* ------------------------------------------------------------*/
   /* This module adds a table row.*/
   /* It will return and document system errors if unexpected*/
     /* return codes are found.*/
   /* ------------------------------------------------------------*/

  try
    call "IO3330" ("A ", SQLCA, PCBREC) {isNoRefresh = yes, isExternal = yes};
  end /* Add table row*/

  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Expected return codes*/

      return; /* Return to previous process*/

    end
  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback();
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0HS13"; /* Process name*/
  TA1REC.TA1LOC = "ADD TABLE ROW";
  TA1REC.TA1DBASE = "DPRODC. "; /* Data base name*/
  TA1REC.TA1TBLVU = "VSITXT01"; /* Table view name*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0HM002.XXXPRCNM = "PC0CS13"; /* Process name*/

  exit stack;

end // end PC0HS13

// Select p.o. hdr row
Function PC0HS14()

   /* ------------------------------------------------------------*/
   /* Select a unique row.*/
   /* If not available, return an error message to the user.*/
   /* If any other, indicate system error.*/
   /* ------------------------------------------------------------*/

  set PCYREC empty;
  PCYREC.PCYFUNC = "S ";
  try
    call "VPOHDR02" (PCYREC, SQLCA, VPOHDR02) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0 /* Row found*/
     || SQLCA.VAGen_SQLCODE == 100) /* Row not found*/

      return; /* Return to previous process*/

    end
  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    PC0HW01.PC0HWSWR = "N"; /* request for data no*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback(); /* rollback updates*/
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0HS14"; /* Process name*/
  TA1REC.TA1LOC = "SELECT P.O. HDR  ROW       ";
  TA1REC.TA1DBASE = "DPRODC. "; /* Data base name*/
  TA1REC.TA1TBLVU = "VPOHDR02"; /* Table view name*/
  TA1REC.TA1TBLKE = VPOHDR02.VPOHDR02-GROUP; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0HM002.XXXPRCNM = "PC0HS14"; /* Process name*/

  exit stack;

end // end PC0HS14

// upd po hdr row
Function PC0HS15()

   /* ------------------------------------------------------------*/
   /* This module updates a table row.*/
   /* It will return and document system errors if unexpected*/
     /* return codes are found.*/
   /* ------------------------------------------------------------*/

  set PCYREC empty;
  PCYREC.PCYFUNC = "U ";
  try
    call "VPOHDR02" (PCYREC, SQLCA, VPOHDR02) {isNoRefresh = yes, isExternal = yes};
  end /* upd table row*/

  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0 /* Expected return codes*/
     || SQLCA.VAGen_SQLCODE == 100)

      return; /* Return to previous process*/

    end
  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback();
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0HS15"; /* Process name*/
  TA1REC.TA1LOC = "UPD TABLE ROW";
  TA1REC.TA1DBASE = "DPRODC. "; /* Data base name*/
  TA1REC.TA1TBLVU = "VPOHDR02"; /* Table view name*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0HM002.XXXPRCNM = "PC0CS15"; /* Process name*/

  exit stack;

end // end PC0HS15

// Select p.o. spec inst hdr
Function PC0HS16()

   /* ------------------------------------------------------------*/
   /* Select a unique row.*/
   /* If not available, return an error message to the user.*/
   /* If any other, indicate system error.*/
   /* ------------------------------------------------------------*/

  try
    call "IO3280" ("S ", SQLCA, PCEREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0 /* Row found*/
     || SQLCA.VAGen_SQLCODE == 100) /* Row not found*/

      return; /* Return to previous process*/

    end
  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    PC0HW01.PC0HWSWR = "N"; /* request for data no*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0HS16"; /* Process name*/
  TA1REC.TA1LOC = "SELECT P.O. HDR INSTR. ROW ";
  TA1REC.TA1DBASE = "DPRODC. "; /* Data base name*/
  TA1REC.TA1TBLVU = "VPOHSI01"; /* Table view name*/
  TA1REC.TA1TBLKE = PCEREC.PCEGROUP; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0HM002.XXXPRCNM = "PC0HS16"; /* Process name*/

  exit stack;

end // end PC0HS16

// upd p.o. spec instr hdr row
Function PC0HS17()

   /* ------------------------------------------------------------*/
   /* This module updates a table row.*/
   /* It will return and document system errors if unexpected*/
     /* return codes are found.*/
   /* ------------------------------------------------------------*/

  try
    call "IO3280" ("U ", SQLCA, PCEREC) {isNoRefresh = yes, isExternal = yes};
  end /* upd table row*/

  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0 /* Expected return codes*/
     || SQLCA.VAGen_SQLCODE == 100)

      return; /* Return to previous process*/

    end
  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback();
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0HS17"; /* Process name*/
  TA1REC.TA1LOC = "UPD TABLE ROW";
  TA1REC.TA1DBASE = "DPRODC. "; /* Data base name*/
  TA1REC.TA1TBLVU = "VPOHSI01"; /* Table view name*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0HM002.XXXPRCNM = "PC0CS17"; /* Process name*/

  exit stack;

end // end PC0HS17

// del spec instr text rows
Function PC0HS18()

   /* ------------------------------------------------------------*/
   /* This module deletes table rows*/
   /* It will return and document system errors if unexpected*/
     /* return codes are found.*/
   /* ------------------------------------------------------------*/

  try
    call "IO3330" ("D ", SQLCA, PCBREC) {isNoRefresh = yes, isExternal = yes};
  end /* del table rows*/

  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Expected return codes*/

      return; /* Return to previous process*/

    end
  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback();
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0HS18"; /* Process name*/
  TA1REC.TA1LOC = "DEL TABLE ROW";
  TA1REC.TA1DBASE = "DPRODC. "; /* Data base name*/
  TA1REC.TA1TBLVU = "VSITXT01"; /* Table view name*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0HM002.XXXPRCNM = "PC0CS18"; /* Process name*/

  exit stack;

end // end PC0HS18

// del p.o. hdr spec instr
Function PC0HS19()

   /* ------------------------------------------------------------*/
   /* This module deletes a table row.*/
   /* It will return and document system errors if unexpected*/
     /* return codes are found.*/
   /* ------------------------------------------------------------*/

  try
    call "IO3280" ("D ", SQLCA, PCEREC) {isNoRefresh = yes, isExternal = yes};
  end /* del table row*/

  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Expected return codes*/

      return; /* Return to previous process*/

    end
  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback();
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0HS19"; /* Process name*/
  TA1REC.TA1LOC = "DEL TABLE ROW";
  TA1REC.TA1DBASE = "DPRODC. "; /* Data base name*/
  TA1REC.TA1TBLVU = "VPOHSI01"; /* Table view name*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0HM002.XXXPRCNM = "PC0CS19"; /* Process name*/

  exit stack;

end // end PC0HS19

// Insert header audit - VPOAHD01
Function PC0HS20()
   /* ------------------------------------------------------------*/
   /* Move values to header audit record.*/
   /* ------------------------------------------------------------*/

  set VPOAHD02 empty; /* Init header audit rec*/
  VPOAHD02.XGPCD = VPOHDR02.XGPCD; /* GPC code*/
  VPOAHD02.PO-REG-CD = VPOHDR02.PO-REG-CD; /* PO REGION CODE*/
  VPOAHD02.PC3PONBR = VPOHDR02.PC3PONBR; /* PO number*/
  VPOAHD02.PC3POIDT = VPOHDR02.PC3POIDT; /* PO ID*/
  VPOAHD02.PCFSECD = VPOHDR02.PCFSECD; /* Season*/
  VPOAHD02.FY1FCTYC = VPOHDR02.FY1FCTYC; /* Factory*/
  VPOAHD02.PC3BUYMO = VPOHDR02.PC3BUYMO; /* Buy month*/
  if (VPOHDR02.XGPCD == "02")
    VPOAHD02.YOACD = "31"; /* Audit code*/
  else
    VPOAHD02.YOACD = "77"; /* Audit code*/
  end
  VPOAHD02.XXXPGUID = COMMAREA.CAUSERID; /* Userid*/
  VPOAHD02.YACCD = " "; /* Audit comment*/
  VPOAHD02.PC4ORTYP = VPOHDR02.PC4ORTYP; /* PO type*/
  VPOAHD02.PCIBFRA = "SPECIAL INSTR"; /* Before value*/
  VPOAHD02.PCIAFTA = " "; /* After value*/
      /* save si sequence nbr in the after number value*/
  VPOAHD02.PCIAFTN = PCEREC.PCASINBR;

  PC0HSA8(); /* set c/m and o/a prt flags*/

  XX0XS01(); /* Get date and time*/
  PC0HW01.PC0H-ZZHHMMSS = XX0XW01.XX0XWHMS;
  while (XX0XW01.XX0XWHMS == PC0HW01.PC0H-ZZHHMMSS)
    XX0XS01(); /* Get date and time*/
  end

  VPOAHD02.ZZZSDT = XX0XW01.XX0XWDAT; /* Set up date*/
  VPOAHD02.ZZHHMMSS = XX0XW01.XX0XWHMS; /* SET UP TIME*/
  VPOAHD02.ZZZCHGDT = XX0XW01.XX0XWDAT; /* Change date*/
  VPOAHD02.ZZZCHGTM = XX0XW01.XX0XWTIM; /* Change time*/
  VPOAHD02.ZZZCHGCT = 0; /* Change count*/

   /* ------------------------------------------------------------*/
   /* Insert row for VPOAHD02.*/
   /* ------------------------------------------------------------*/

  try
    call "VPOAHD02" ("A ", SQLCA, VPOAHD02) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == 0)      /* Row found*/
    return;
  end


  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end

  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
                                   /* Rollback all database changes*/

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0HS20"; /* Process name*/
  TA1REC.TA1LOC = "ADD HEADER AUDIT ROW   ";
  TA1REC.TA1DBASE = "DPRODC  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VPOAHD02"; /* Table view name*/
  TA1REC.TA1TBLKE = VPOAHD02.VPOAHD02-KEY; /* Error key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0HM001.XXXPRCNM = "PC0HS20"; /* Module identification*/
  exit stack;

end // end PC0HS20

// load chg memo and oa memo flag
Function PC0HSA8()
   /* ------------------------------------------------------------*/
   /* Determine if the Change memo flag is set and load the*/
   /* appropriate change memo flag accordingly*/
   /* Do the same for oa memo flag*/
   /* ------------------------------------------------------------*/


  if (VPOHDR02.PC3PRTIN == "P") /* ===> po is printed*/
    if (VPOAHD02.YOACD in YOATBL.YOACD) /* ===> Code is in table*/

      if (YOATBL.YOACMFL[sysVar.arrayIndex] == "Y") /* ===> change memo flag*/
        VPOAHD02.PCJMEMO = " ";
      else
        VPOAHD02.PCJMEMO = "N";
      end /* =====>*/
      if (YOATBL.YOAADJFL[sysVar.arrayIndex] == "Y") /* ===> o/a adj flag*/
        VPOAHD02.PCJOAPRT = " ";
      else
        VPOAHD02.PCJOAPRT = "N";
      end /* =====>*/

    else /* ===> code not in table*/

      PC0HM001.XXXPRCNM = "PC0HSA8"; /* Module identification*/
      converseLib.validationFailed(139); /* Indicate missing or invalid*/

      VGVar.handleSysLibraryErrors = 0;
      sysLib.rollback(); /* ===> rollback all changes*/

      exit stack;

    end
  else
    VPOAHD02.PCJMEMO = "N";
    VPOAHD02.PCJOAPRT = "N";
  end


   /* **                                                        ***/
   /* ********************** End of PC0hSA8 ***********************/
end // end PC0HSA8

//*** RECORD=PC0HW01 ****
// Working storage for pc0h - p.o. header special instruction
// ***********************
Record PC0HW01 type basicRecord
  5 PC0HW1GP PC0HW1GP ; 
    10 PC0HWIXM PC0HWIXM ; 
    10 PC0HWLIX PC0HWLIX ; 
    10 PC0HWCIX PC0HWCIX ; 
    10 PC0HWSIX PC0HWSIX ; 
    10 PC0HWSTW PC0HWSTW ; 
    10 PC0HWPOW PC0HWPOW ; 
    10 PC0HWSFL PC0HWSFL ; 
    10 PC0HWTEF PC0HWTEF ; 
    10 PC0HWPSW PC0HWPSW ; 
    10 PC0HWSWR PC0HWSWR ; 
    10 PC0HWTSP PC0HWTSP ; 
    10 PC0H-ZZHHMMSS PC0H-ZZHHMMSS ; 
    10 PC0HWMAP PC0HWMAP ; 
    10 PC0HWFSW PC0HWFSW ; 
    10 PC0HWTXT PC0HWTXT [13] ; 
      15 PCBSITXT PCBSITXT ; 
    10 PC3PONBR PC3PONBR ; 
    10 YSICD YSICD ; 
    10 XGPCD XGPCD ; 
    10 XGPDESC XGPDESC ; 
    10 PO-REG-CD PO-REG-CD ; 
    10 PC0HWPID PC0HWPID ; 
      15 PC0HWPOC PC0HWPOC ; 
      15 PC0HWPOY PC0HWPOY ; 
      15 PC0HWPOM PC0HWPOM ; 
      15 PC0HWPDM PC0HWPDM ; 
    10 PC0HWFPI PC0HWFPI ; 
      15 PC0HWFPY PC0HWFPY ; 
      15 PC0HWDS1 PC0HWDS1 ; 
      15 PC0HWFPM PC0HWFPM ; 
      15 PC0HWDS2 PC0HWDS2 ; 
      15 PC0HWFPD PC0HWFPD ; 
      15 PC0HWDS3 PC0HWDS3 ; 
      15 PC0HWFFC PC0HWFFC ; 
    10 PC0HWMFL PC0HWMFL ; 
    10 PC0HWDEF PC0HWDEF ; 
    10 PC0HWUPD PC0HWUPD ; 
    10 PC0HWBYF PC0HWBYF ; 
    10 PC0HWINQ PC0HWINQ ; 
    10 TA5TSQIX TA5TSQIX ; 
end // end PC0HW01

//*** RECORD=PC0HW02 ****
// Temp. storage record for pc0f - p.o. customer spec inst list
// ***********************
Record PC0HW02 type basicRecord
  10 PC0HWLEN PC0HWLEN ; 
  10 PC0HWLIN PC0HWLIN [12] ; 
    15 PC0HMSEL PC0HMSEL ; 
    15 XGPCD XGPCD ; 
    15 PCASINBR PCASINBR ; 
    15 YSICD YSICD ; 
    15 PCASIDSC PCASIDSC ; 
    15 PCEPRSEQ PCEPRSEQ ; 
    15 PC0HMSRC PC0HMSRC ; 
    15 ZZZCHGCT ZZZCHGCT ; 
end // end PC0HW02

DataItem PC0H-ZZHHMMSS num(6)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

DataItem PC0HMSEL char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// PC_SINST_IND desc
DataItem PC0HMSRC char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pc0hw01 group level
DataItem PC0HW1GP char(874)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// bypass processing flag
DataItem PC0HWBYF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// cursor index
DataItem PC0HWCIX num(4)  {
  currency = no, numericSeparator = no, sign = none, zeroFormat = yes, 
  align = right, fillCharacter = "0", inputRequired = no, minimumInput = 1
}
end

// data entered flag
DataItem PC0HWDEF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dash 1
DataItem PC0HWDS1 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dash 2
DataItem PC0HWDS2 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dash 3
DataItem PC0HWDS3 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// factory
DataItem PC0HWFFC char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// delivery month
DataItem PC0HWFPD num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// p.o. id display format
DataItem PC0HWFPI char(12)  {
  align = right, fillCharacter = nullFill, inputRequired = no
}
end

// po month
DataItem PC0HWFPM num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// po year
DataItem PC0HWFPY char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// add/del function switch
DataItem PC0HWFSW char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// inquiry allowed
DataItem PC0HWINQ char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// index for map fields
DataItem PC0HWIXM smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// temp storage length
DataItem PC0HWLEN num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// temp storage line
DataItem PC0HWLIN char(47)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// load special msg text index
DataItem PC0HWLIX num(4)  {
  currency = no, numericSeparator = no, sign = none, zeroFormat = yes, 
  align = right, fillCharacter = "0", inputRequired = no, minimumInput = 1
}
end

// map to be displayed
DataItem PC0HWMAP char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// message flag
DataItem PC0HWMFL char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// p.o. delivery month
DataItem PC0HWPDM num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// reformat pc3poidt
DataItem PC0HWPID num(8)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = nullFill, inputRequired = no
}
end

// p.o. century
DataItem PC0HWPOC num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// p.o. month
DataItem PC0HWPOM num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// end of p.o. hdr spec instr
DataItem PC0HWPOW char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// p.o. year
DataItem PC0HWPOY num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// problem switch
DataItem PC0HWPSW char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// selection flag
DataItem PC0HWSFL char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// special instr text index
DataItem PC0HWSIX smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// end of special instr text
DataItem PC0HWSTW char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// request for data switch
DataItem PC0HWSWR char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// special text data entered
DataItem PC0HWTEF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem PC0HWTSP num(4)  {
  currency = no, numericSeparator = no, sign = none, zeroFormat = yes, 
  align = right, fillCharacter = nullFill, inputRequired = no
}
end

// verify chg in spec text
DataItem PC0HWTXT char(60)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// updates allowed
DataItem PC0HWUPD char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

