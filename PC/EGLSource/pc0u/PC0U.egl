package pc0u;
import corpcom1.*;
import corpcom2.*;
import corpcom3.*;
import corpcom4.*;
import corpcom5.*;
import corpcom6.*;
import corpcom7.*;
import corpx1.*;
import corpx2.*;
import corpy2.*;
import corpz3.*;
import fb.common.*;
import fk.common.*;
import fy.common.*;
import in1.common.*;
import ku.common.*;
import op.common.*;
import pc.common.*;
import pg.common.*;
import pt.common.*;
import sl.common.*;
import sy.common.*;
import ta.common.*;
import ts.common.*;
import vv.common.*;
//*** PROGRAM=PC0U ****
// This program will bring up a list of P.O. work in process
// and transporation information. T database will return 0 to n
// rows based upon the selection criteria.  The program will
// format the screen with the nformation returned from the
// data base.
// 
// This program will also allow changing and printing of P.O.'s
// by transferring them to another program with the row
// information selected.
// 
// A user can get detailed size information by pressing PF9.
// They can keep press PF11 to scroll right until there are no
// more sizes to display. A message will be displayed when they
// are on the last screen.
// 
// A user can select a row for maintenance and hit pf12. The
// user will then be transferred to PXoK where they can modify
// the information.  Pressing enter or PF3 will return them to
// the list screen in this application.
// 
// A user can print the selected rows by pressing PF20.  The
// user will then be transfered to PC0D where they can select
// the destination printer.  After they hit enter they will be
// returned to the list screen in this application.
// 
// A user can also inquire on special instructions or ship to
// information by pressing PF6 or PF14.
// 
// A user can also inquire on transporation information by
// selecting a shipment row and pressing PF16.  They will then
// transferred to the transporation system.
// 
// CHANGED   BY    DESCRIPTION
// ________ ______ _________________________________________
// 06/13/90 mchris fixed irreg % lines
// 08/31/90 mchris added receiving status '13'
// 09/19/90 lsutto allow gpc 07 access
// 10/29/90 GAMEN  Move the blank from in front of color
//                 to after it in the pc0uw02 record
// 12/26/90 lsutto add owner group to screens
// 03/05/91 chaert a48 - use items owner group on apparel
//                 finished goods. see pc0u115.
// 05/07/91 chaert PC0U113, save and restore item info to fix
//                 bug in fypo retrieval. Add PC0UW16.
// 
// 05/24/91 ppeter PC0U001 - change to allow transfer in from
//                 'PB0D' and return.
// 08/08/91 chaert PC0U113, save pkg type for fypo retrieval
// 09/18/91 chaert PC0U110, add retrieval of unattached trans-
//                 portation records. a139
// 10/02/91 chaert PC0US62, S67 update to unattachd trans recs
// 10/08/91 chaert PC0US70, S71 don't use xqa in match
// 02/04/92 gamen  Add PB0I to access list from other appl's.
// 02/14/92 chaert wildcard xow when warehouse is 03 or 12
// 06/23/92 lsutto round b-grade price calc in xspcs04
// 06/25/92 gamen  Add s.o. to map 1 by using pf11 to get
//                 to it. pf10 will bring up etal/etal-o.
// 06/08/92 gamen  Initialize total shipped in lower level.
// 07/17/92 lsutto pc0u210: chg to pc6rec color (not w00.clr)
// 09/14/92 gamen  Don't wilcard xowcd in pc0u115.
// 09/15/92 gamen  Fix irregular receipts in pc0u115. Cust xref
//                 was not being moved in and s.o. moved to
//                 the wrong record.
// 09/14/92 gamen  Don't wilcard xowcd in pc0us71.
// 05/06/93 chaert In the unmatched trans/rcpt routine, do not
//                 look at CX Items.(PC0US71)
// 05/11/93 chaert pc0u115, if PO has qual 02, also look for 01
// 05/28/93 GAMEN  Increse size of irr % to 999.9
// 06/01/93 GAMEN  Fix irreg total so it's not incrememnted
//                 when pf11/pf10 is pressed.
// 08/10/93 dhales db2 changes and fix pc0uw19 for upcoming
//                 conversion to csp v4.1
// 09/23/93 dhales change to xspcs05 requires appl regen
// 10/05/93 dhales change to intransit etal calculation
// 12/29/93 gamen  add theater of ops code.
// 02/18/94 dhales limit access to pc0k for po numbers greater
//                 than 299999
// 11/01/94 jjuch  Change to exclude apao po nbr > 699999 in
//                 pc0u160.
// 01/20/95 gamen  change etal calc for aprl (xspcs07)
// 01/31/95 gamen  Change display on intransit data to show
//                 shipment type. Remove shipment number.
// 04/29/96 jniese Change processing of container item in
//                 pc0us15 and s16 to prevent online abends.
//                 Tentative 'TN' shipments do not have to have
//                 a container.
// 07/17/96 jcarl1 Changed to wildcard SO for RF type PO's
//                 when matching to CPLHD02 view.  This is to
//                 accomodate the Bassett Walker/JCPenney
//                 project.
// 08/19/96 jcarl1 Changed to wildcard SO for RF type PO's
//                 when matching to FYPO001 view.  This is to
//                 accomodate the Bassett Walker/JCPenney
//                 project.
// 09/13/96 jcarl1 Changed to wildcard SO for AR type PO's
//                 when matching to FYPO001 view.  This is to
//                 accomodate the Bassett Walker/JCPenney
//                 project.  Also fixed truncation of ending
//                 page number.
// 12/06/96 jniese recompile to get new xspcs05.
// 04/29/97 asunda recompile to get new xspcs05.
// 06/03/97 PHARWO PCA367 - PPR PROJECT, PO VIEWS.
// 06/29/97 jniese PCA367 - PPR fixes
// 12/02/97 bmusti modified jcl table.
// 02/03/98 skamba Wild card Whse-cd/Customer xref for
//                 apparel B-grades ( Refer PC0U115, PC0US70,
//                 PC0US71)
// 02/10/98 DRAMSE Changed to use VPRDCU03 instead of PC2REC
//                 Changed to use VPRDCU03 instead of IO3340
// 02/13/98 DRAMSE recompile to get new xspcs05/XSPCS07
// 05/06/98 jniese pca999 - correct problem in pc0us71.  Was
//                 using incorrect record for xqacd.
// 05/29/98 jniese pca999 - correct problem in pc0u115.  Was
//                 using incorrect value for inseg for qual 02
// 06/03/98 vramac y2kfix - correct y2k bug in pc0us19.
// 06/10/98 drammo PCF147 - Regen appln to get new
//                 XSPCS05 & XSPCS06 which are changed to
//                 include ST po type in ETAL calculation
// 06/15/98 skamba Wild card UOM-CD/PC-CU-IN-SEG-CD for
//                 apparel B-grades ( Refer PC0U115, PC0US70,
//                 PC0US71)
// 04/23/99 KGRAHA Regen to get new XSPCS05 which now does
//                 not include 'BA' in pushing the ETAL forward
// 04/29/99 KGRAHA Protect MM, MD, DS, & BA from having the ETS
//                 pushed forward in PC0US19.
// 09/24/99 vsanka regenerated due to changes to xspcs05.
// 11/04/99 vsanka changes to remove push logic in pc0us19.
// 02/07/00 SBUNGO CHANGED TO USE VIEW VFCTY003
// 08/02/00 RSELVA Modified  XSPCS05 for zeroing out of MADD,
//                 from 20001012 onwards.
// 12/21/00 rmurth Compiled for change in SGRP XSPCS07
// *                   XSPCS07 modified to have hardcoded PADD
// *                   for WHSE '51' and Origin USA for GPC 03
// 03/05/01 AVERMA changed to display SAP number on pf18.
//                 changed to use VPOITM03 to VPOITM05.
// 03/21/01 rmurth Changed  PC0US19,PC0US51 (ETAL logic for
// *               transportation data) to have hardcoded PADD
// *               for WHSE '51' and Origin USA for GPC 03.
// 12/27/01 SPITCH Disabled PF20
// *********************
Program PC0U type textUIProgram //VAGen Info - main text program
  {
  includeReferencedFunctions = yes, allowUnqualifiedItemReferences = yes, 
  throwNrfEofExceptions = yes, handleHardIOErrors = no, V60ExceptionCompatibility = yes, 
  I4GLItemsNullable = no, textLiteralDefaultIsString = no, localSQLScope = yes, 
  msgTablePrefix = "PC00", inputRecord = COMMAREA, segmented = yes
  }

  // Data Declarations
  COMMAREA COMMAREA ; // record
  ERRSQLCA ERRSQLCA; // record
  PC0UW00 PC0UW00; // record
  PC0UW01 PC0UW01; // record
  PC0UW02 PC0UW02; // record
  PC0UW03 PC0UW03; // record
  PC0UW04 PC0UW04; // record
  PC0UW05 PC0UW05; // record
  PC0UW06 PC0UW06; // record
  PC0UW07 PC0UW07; // record
  PC0UW08 PC0UW08; // record
  PC0UW09 PC0UW09; // record
  PC0UW10 PC0UW10; // record
  PC0UW11 PC0UW11; // record
  PC0UW12 PC0UW12; // record
  PC0UW13 PC0UW13; // record
  PC0UW14 PC0UW14; // record
  PC0UW15 PC0UW15; // record
  PC0UW16 PC0UW16; // record
  PC0UW17 PC0UW17; // record
  PC0UW18 PC0UW18; // record
  PC0UW19 PC0UW19; // record
  PC0UW20 PC0UW20; // record
  PC0UW21 PC0UW21; // record
  PC0UW22 PC0UW22; // record
  PC0UW23 PC0UW23; // record
  PC0UW24 PC0UW24; // record
  PC0UW25 PC0UW25; // record
  PC0UW26 PC0UW26; // record
  PC0UW30 PC0UW30; // record
  PCPREC PCPREC; // record
  PCWREC PCWREC; // record
  PCYREC PCYREC; // record
  PCZREC PCZREC; // record
  PG2REC PG2REC; // record
  PG3REC PG3REC; // record
  PTDREC PTDREC; // record
  SQLCA SQLCA; // record
  TA1REC TA1REC; // record
  TA2REC TA2REC; // record
  TA5REC TA5REC; // record
  TA6REC TA6REC; // record
  TAEREC TAEREC; // record
  TSEREC TSEREC; // record
  TSFREC TSFREC; // record
  TSHREC TSHREC; // record
  TSIREC TSIREC; // record
  TSOREC TSOREC; // record
  TSTREC TSTREC; // record
  VFCTY003 VFCTY003; // record
  VFYPO002 VFYPO002; // record
  VPOHDR02 VPOHDR02; // record
  VPOITM05 VPOITM05; // record
  VPOSIZ02 VPOSIZ02; // record
  VPRDCU03 VPRDCU03; // record
  XCTHREC XCTHREC; // record
  XX0XW01 XX0XW01; // record

  // VAGen Info - items needed for migration
  VAGen_EZESYS char(8);
  VAGen_EZEREPLY num(1);
  VAGen_EZE_WAIT_TIME bin(9,2);
  VAGen_EZE_ITEMLEN int;

  // Use Declarations
  use XWHTBL {deleteAfterUse = yes}; // table
  use PC0UT01 {deleteAfterUse = yes}; // table
  use PC0UT11 {deleteAfterUse = yes}; // table
  use PC0UM.PC0UM001,  // forms
      PC0UM.PC0UM002
   {
    pfKeyEquate = no
  };

  function main()
    // VAGen Info - initialization needed for migration
    VAGen_EZESYS = VGLib.getVAGSysType();
    XPPC001: XPPC001();
    goto PC0U001;
    PC0U001: PC0U001();
    goto PC0U002;
    PC0U002: PC0U002();
    goto PC0U002;
  end // end main
end // end PC0U

// Special initialization
Function PC0U001()

   /* ---------------------------------------------------------*/
   /* If entry is from any aplication other the the ones*/
   /* listed below it is an error and a message should be*/
   /* sent to PC0A.*/
   /* ---------------------------------------------------------*/

  if (COMMAREA.CAFROMAP == "PC0Z"
   || COMMAREA.CAFROMAP == "PC06"
   || COMMAREA.CAFROMAP == "PC0S"
   || COMMAREA.CAFROMAP == "PC0M"
   || COMMAREA.CAFROMAP == "PC0I"
   || COMMAREA.CAFROMAP == "PC05"
   || COMMAREA.CAFROMAP == "PC0K"
   || COMMAREA.CAFROMAP == "PC07"
   || COMMAREA.CAFROMAP == "PB0D"
   || COMMAREA.CAFROMAP == "PB0I")
     /* next sentence*/
  else
    COMMAREA.CAITEM = " ";
    set PCWREC empty;
    PCWREC.XXXMSGNO = 191;
    COMMAREA.CAUSERA = PCWREC.CAUSERA;
    COMMAREA.CATOAP = "PC0A"; /* Return to menu*/
    XSEXIT();
    PC0UM001.XXXPRCNM = "PC0U001";
  end
   /* ---------------------------------------------------------*/
   /* If no keys were passed in the pcwrec then exit the*/
   /* application and return to the PO Menu (PC0A).*/
   /* If keys were passed then set the passed data index to 1*/
   /* ---------------------------------------------------------*/

  if (PCWREC.PC3PONBR == 0)
    COMMAREA.CAITEM = " ";
    PCWREC.XXXMSGNO = 18; /* No data to display*/
    COMMAREA.CAUSERA = PCWREC.CAUSERA;
    COMMAREA.CATOAP = "PC0A"; /* Return to menu*/
    XSEXIT();
    PC0UM001.XXXPRCNM = "PC0U001";
  end

   /* ---------------------------------------------------------*/
   /* Check commarea security fields.*/
   /* ---------------------------------------------------------*/

  if (PCWREC.XGPCD == "01"
   && COMMAREA.CAILVL[1] != "Y")
    COMMAREA.CAITEM = " ";
    PCWREC.XXXMSGNO = 138; /* Security violation*/
    COMMAREA.CAUSERA = PCWREC.CAUSERA;
    COMMAREA.CATOAP = "PC0A"; /* Return to menu*/
    XSEXIT();
    PC0UM001.XXXPRCNM = "PC0U001";
  end

  if (PCWREC.XGPCD == "02"
   && COMMAREA.CAILVL[2] != "Y")
    COMMAREA.CAITEM = " ";
    PCWREC.XXXMSGNO = 138;
    COMMAREA.CAUSERA = PCWREC.CAUSERA;
    COMMAREA.CATOAP = "PC0A"; /* Return to menu*/
    XSEXIT();
    PC0UM001.XXXPRCNM = "PC0U001";
    converseLib.validationFailed(10);
  end

  if (PCWREC.XGPCD == "03"
   && COMMAREA.CAILVL[3] != "Y")
    COMMAREA.CAITEM = " ";
    PCWREC.XXXMSGNO = 138;
    COMMAREA.CAUSERA = PCWREC.CAUSERA;
    COMMAREA.CATOAP = "PC0A"; /* Return to menu*/
    XSEXIT();
    PC0UM001.XXXPRCNM = "PC0U001";
    converseLib.validationFailed(10);
  end

  if (PCWREC.XGPCD == "07"
   && COMMAREA.CAILVL[7] != "Y")
    COMMAREA.CAITEM = " ";
    PCWREC.XXXMSGNO = 138;
    COMMAREA.CAUSERA = PCWREC.CAUSERA;
    COMMAREA.CATOAP = "PC0A"; /* Return to menu*/
    XSEXIT();
    PC0UM001.XXXPRCNM = "PC0U001";
    converseLib.validationFailed(10);
  end


   /* ---------------------------------------------------------*/
   /* Initialize the work record and the map storage record*/
   /* Set Map flag to display map 1 and obtain data flag to*/
   /* yes.*/
   /* ---------------------------------------------------------*/

  set PC0UW00 empty; /* Working storage record*/
  set PC0UW01 empty; /* Map storage for map heading data*/
  set PC0UW12 empty; /* Temporary storage record*/

  set PC0UM001 empty;
  set PC0UM002 empty;

  set SQLCA empty;
  set TAEREC empty; /* Error diagnosis information*/
  set TA1REC empty; /* Error diagnosis parameters*/

   /* * storage length = 14 rows * 285 bytes + 4 for num = 3994*/
  PC0UW00.PC0UWTSL = 3994; /* Temporary storage page length*/
  PC0UW00.PC0UWMAX = 14; /* Max lines per map page*/
  PC0UW00.PC0UWMXJ = 70; /* Max JCL DD* card allowed*/

   /* ---------------------------------------------------------*/
   /* Check commarea security fields for updating ETALO date*/
   /* ---------------------------------------------------------*/

  if (PCWREC.XGPCD == "01"
   && COMMAREA.CAILVL[9] != "Y")
    PC0UW00.PC0UWPDF = "Y"; /* Protect date flag*/
  else
    if (PCWREC.XGPCD == "02"
     && COMMAREA.CAILVL[9] != "Y")
      PC0UW00.PC0UWPDF = "Y"; /* Protect date flag*/
    else
      if (PCWREC.XGPCD == "03"
       && COMMAREA.CAILVL[9] != "Y")
        PC0UW00.PC0UWPDF = "Y"; /* Protect date flag*/
      else
        if (PCWREC.XGPCD == "07"
         && COMMAREA.CAILVL[9] != "Y")
          PC0UW00.PC0UWPDF = "Y"; /* Protect date flag*/
        end
      end
    end
  end

   /* ---------------------------------------------------------*/
   /* Save the initial calling application ID in the*/
   /* PC0UREC(on PF3 or PF19) pc0u will return to the*/
   /* application that called it.  However PC0U can in turn*/
   /* call other applications.*/
   /* ---------------------------------------------------------*/


  if (COMMAREA.CAFROMAP == "PC0Z"
   || COMMAREA.CAFROMAP == "PC06"
   || COMMAREA.CAFROMAP == "PC0S"
   || COMMAREA.CAFROMAP == "PC0M"
   || COMMAREA.CAFROMAP == "PB0D"
   || COMMAREA.CAFROMAP == "PB0I")

    set PC0UW13 empty;

    PC0UW13.CAFROMAP = COMMAREA.CAFROMAP;
  end

   /* ---------------------------------------------------------*/
   /* When returning  from called applications the screen should*/
   /* be restored to the temporary storagepage that was*/
   /* displayed prior to the call.*/
   /* ---------------------------------------------------------*/

  PC0UW00.PC0UWODF = "Y"; /* Obtain data flag*/
  PC0UW00.PC0UWSRF = "1"; /* Screen request flag*/
  PC0UW00.PC0UWDTF = "1"; /* Etal data to be displayed*/

  if (COMMAREA.CAFROMAP == "PC0I"
   || COMMAREA.CAFROMAP == "PC05"
   || COMMAREA.CAFROMAP == "PC0K"
   || COMMAREA.CAFROMAP == "PC07")
    if (PCWREC.CAFROMAP[1] == "PC0U")
      PC0UW13.PC0UWUSR = PCWREC.PCWUSER1;
      PCWREC.CAFROMAP[1] = " ";
      PC0UW00.PC0UWTSP = PC0UW13.PC0UWTSP;

    else
      if (PCWREC.CAFROMAP[2] == "PC0U")
        PC0UW13.PC0UWUSR = PCWREC.PCWUSER2;
        PCWREC.CAFROMAP[2] = " ";
        PC0UW00.PC0UWTSP = PC0UW13.PC0UWTSP;

      else
        if (PCWREC.CAFROMAP[3] == "PC0U ")
          PC0UW13.PC0UWUSR = PCWREC.PCWUSER3;
          PCWREC.CAFROMAP[3] = " ";
          PC0UW00.PC0UWTSP = PC0UW13.PC0UWTSP;
        else
          if (PCWREC.CAFROMAP[4] == "PC0U ")
            PC0UW13.PC0UWUSR = PCWREC.PCWUSER4;
            PCWREC.CAFROMAP[4] = " ";
            PC0UW00.PC0UWTSP = PC0UW13.PC0UWTSP;
          end

        end
      end
    end
  else
    PC0UW00.PC0UWTSP = 1; /* Temp storage page request*/
  end


  if (COMMAREA.CAFROMAP == "PC0I"
   || COMMAREA.CAFROMAP == "PC05"
   || COMMAREA.CAFROMAP == "PC0K"
   || COMMAREA.CAFROMAP == "PC07")
    PCWREC.XGPCD = PC0UW13.XGPCD;
    PCWREC.PO-REG-CD = PC0UW13.PO-REG-CD;
    PCWREC.PC3PONBR = PC0UW13.PC3PONBR;
    PCWREC.YSMXDV = PC0UW13.YSMXDV;
    PCWREC.SY1STNBR = PC0UW13.SY1STNBR;
    PCWREC.SY2CLRID = PC0UW13.SY2CLRID;
    PCWREC.XDMCD = PC0UW13.XDMCD;
    PCWREC.XQACD = PC0UW13.XQACD;
    PCWREC.XOWCD = PC0UW13.XOWCD;
    PCWREC.XPGCD = PC0UW13.XPGCD;
    PCWREC.XUMCD = PC0UW13.XUMCD;
  end

   /* ---------------------------------------------------------*/
   /* Move the map heading data from the pcwrec to*/
   /* the map storage fields.*/
   /* ---------------------------------------------------------*/

  PC0UW01.XGPCD = PCWREC.XGPCD;
  PC0UW01.PO-REG-CD = PCWREC.PO-REG-CD; /* PO number*/
  PC0UW01.PC3PONBR = PCWREC.PC3PONBR; /* PO number*/
  if (PCWREC.SY1STNBR != "*")
    PC0UW01.SY1STNBR = PCWREC.SY1STNBR;
  end
  if (PCWREC.SY2CLRID != "*")
    PC0UW01.SY2CLRID = PCWREC.SY2CLRID;
  end
  if (PCWREC.XDMCD != "*")
    PC0UW01.XDMCD = PCWREC.XDMCD;
  end
  if (PCWREC.XQACD != "*")
    PC0UW01.XQACD = PCWREC.XQACD;
  end
  if (PCWREC.PC2INSEG != "*")
    PC0UW01.PC2INSEG = PCWREC.PC2INSEG;
  end
  if (PCWREC.XPGCD != "*")
    PC0UW01.XPGCD = PCWREC.XPGCD;
  end
  if (PCWREC.XUMCD != "*")
    PC0UW01.XUMCD = PCWREC.XUMCD;
  end

  set VPOHDR02 empty;

  VPOHDR02.XGPCD = PCWREC.XGPCD;
  VPOHDR02.PO-REG-CD = PCWREC.PO-REG-CD;
  VPOHDR02.PC3PONBR = PCWREC.PC3PONBR;

  PC0US01(); /* Obtain PO header*/

  PC0UW01.PO-REG-CD = VPOHDR02.PO-REG-CD;
  PC0UW01.PC4ORTYP = VPOHDR02.PC4ORTYP;
  PC0UW00.PC0UWFDT = VPOHDR02.PC3POIDT; /* PO ID to working storage*/

  if (PCWREC.XGPCD == "03") /* Apparel*/
    PC0UW00.PC0UWSYR = VPOHDR02.PCFSECD; /* Use the season code*/
  else
    PC0UW00.PC0UWSYR = PC0UW00.PC0UWFYY; /* Use the PO ID year*/
  end

  PC0UW00.PC0UWPMO = PC0UW00.PC0UWFMM; /* Production month*/
  PC0UW00.PC0UWDMO = PC0UW00.PC0UWFDD; /* Delivery month*/
  PC0UW00.FY1FCTYC = VPOHDR02.FY1FCTYC; /* Factory code*/
  PC0UW00.PC0UWDH1 = "-";
  PC0UW00.PC0UWDH2 = "-";
  PC0UW00.PC0UWDH3 = "-";

  PC0UW01.PC0UWPID = PC0UW00.PC0UWPID;

  PC0UW00.PC0UWFDT = VPOHDR02.PC3CRDT; /* created date*/
  PC0UW00.PC0UWMMM = PC0UW00.PC0UWFMM;
  PC0UW00.PC0UWMDD = PC0UW00.PC0UWFDD;
  PC0UW00.PC0UWMYY = PC0UW00.PC0UWFYY;
  PC0UW01.PC0UMEDT = PC0UW00.PC0UWMDT;

  if (VPOHDR02.PC3BLPO != 0)
    PC0UW01.PC3BLPO = VPOHDR02.PC3BLPO;
  else
    PC0UW01.PC3BLPO = VPOHDR02.IN7STNBR;
  end

  PC0UM001.XXXPRCNM = "PC0U"; /* process number*/
  PC0UM002.XXXPRCNM = "PC0U"; /* process number*/



   /* ------------------------------------------------------------*/
      /* CALL SUB-ROUTINE TO FIND WHICH ENVIRONMENT*/
      /* THE PROGRAM IS EXECUTING IN, DEVELOPMENT*/
      /* OR PRODUCTION.*/
   /* ------------------------------------------------------------*/
  set XCTHREC empty;
  call "XC0910" (XCTHREC) {isNoRefresh = yes, isExternal = yes};

  if (XCTHREC.XCTH-THEATER-RUNTYPE == " ")

    PC0UM001.XXXPRCNM = "PC0U001"; /* module identification*/
    converseLib.validationFailed(8); /* Error encountered with print request*/
    exit stack;
  end

end // end PC0U001

// P.O. ID Inquiry-detail
Function PC0U002()
   /* ------------------------------------------------------------*/
   /* This is the main process used to display a map.  Processing*/
   /* always returns to the top of this process and falls through*/
   /* subordinate processes until an error is found or a valid*/
   /* request is processed.  Processing sequence is as follows:*/

   /* 1) If specified display the first map*/
   /* 2) Otherwise, display the second map*/
   /* 3) Otherwise incidate an error and exit to menu*/

   /* In all subordinate processes, "EZEFLO" is used to exit to*/
   /* redisplay the map when an error is found.  This is done to*/
   /* minimize the coding effort required to skip subsequent*/
   /* processing under error conditions.*/
   /* ------------------------------------------------------------*/

  if (PC0UW00.PC0UWSRF == "1") /* Map one requested*/
    PC0U100(); /* Map one processing*/
  else
    if (PC0UW00.PC0UWSRF == "2") /* Map two requested*/
      PC0U200(); /* Map two processing*/
    else

      /* ------------------------------------------------------------*/
       /* Write the error to the Error Diagnosis Reporting Facility.*/
      /* ------------------------------------------------------------*/

      PC0UW00.XXXMSGNO = 10; /* Indicate system error*/
      PC0UM001.XXXPRCNM = "PC0U002"; /* Procedure name*/

      TA1REC.TA1FUNC = "RETN"; /* Termination function*/
      TA1REC.TA1TYPE = "APPL"; /* Type of error*/
      TA1REC.TA1LOC = "INVALID MAP NUMBER WAS REQUESTED";
      TA1REC.TA1MAPNO = PC0UW00.PC0UWSRF; /* Map number*/
      TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
      TA1REC.TA1PGMNO = PC0UM001.XXXPRCNM; /* Program number*/

      call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

      /* ------------------------------------------------------------*/
       /* Exit to display the application system menu.*/
      /* ------------------------------------------------------------*/

      COMMAREA.CATOAP = "PC0A"; /* TO application*/

      XSPCS01(); /* Exit to another application*/

      /* ------------------------------------------------------------*/
       /* Abnormally terminate the transaction if the exit failed.*/
      /* ------------------------------------------------------------*/

      TA1REC.TA1FUNC = "ABND"; /* Termination function*/

      call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

    end

  end


end // end PC0U002

// Map 1 processing
Function PC0U100()
   /* ------------------------------------------------------------*/
   /* This is the main process used to display a map.  Processing*/
   /* always returns to the top of this process and falls through*/
   /* subordinate processes until an error is found or a valid*/
   /* request is processed.  Processing sequence is as follows:*/

   /* 1) Obtain data to disply*/
   /* 2) Format the map output area and display the map.*/
   /* 3) Check the attention identifier used to respond.*/
   /* 4) Reset highlighted fields to normal intensity.*/
   /* 5) Verify the data that was entered.*/
   /* 6) Process a valid input request.*/

   /* In all subordinate processes, "EZEFLO" is used to exit to*/
   /* redisplay the map when an error is found.  This is done to*/
   /* minimize the coding effort required to skip subsequent*/
   /* processing under error conditions.*/
   /* ------------------------------------------------------------*/


  PC0U110(); /* Obtain data to display*/

  PC0U120(); /* Format and display the map*/

  PC0U130(); /* Check attention identifier*/

  PC0U140(); /* Reset fields to normal intensity*/

  PC0U150(); /* Verify the entered data*/

  PC0U160(); /* Process valid input request*/

end // end PC0U100

// Process all item rows
Function PC0U101()


   /* ------------------------------------------------------------*/
   /* Calculate the dates.*/
   /* Retrieve the size row.*/
   /* Load the data to the temporary storage record.*/
   /* If the page is full write the tempoaray storage record,*/
   /* ------------------------------------------------------------*/

    /* Increment page line index*/

  PC0UW00.PC0UWIXT = PC0UW00.PC0UWIXT + 1;

    /* Increment item counter*/

  PC0UW00.PC0UWICT = PC0UW00.PC0UWICT + 1;

  PC0US04();

  PC0US09(); /* Retrieve item size row*/

  PC0US10(); /* Load item data to temp storage*/


  if (PC0UW00.PC0UWDTF == "3")
    PC0UW30.PC0UW02K = 30;
    PC0UW12.PC0UW12R[PC0UWIXT] = PC0UW30.PC0UW02G;
  else
    if (PC0UW00.PC0UWDTF == "1") /* Etal data*/
      PC0UW02.PC0UW02K = 2; /* Record key*/
      PC0UW12.PC0UW12R[PC0UWIXT] = PC0UW02.PC0UW02G;
    else /* S.O. data*/
      PC0UW22.PC0UW02K = 22; /* Record key*/
      PC0UW12.PC0UW12R[PC0UWIXT] = PC0UW22.PC0UW02G;
    end
  end

  if (PC0UW00.PC0UWIXT == PC0UW00.PC0UWMAX) /* max lines per page*/

    PC0US12(); /* Add page to temp storage*/

  end

end // end PC0U101

// Obtain data to display
Function PC0U110()



   /* ------------------------------------------------------------*/
   /* If an error was found or data not requested return to*/
   /* previous process.*/
   /* ------------------------------------------------------------*/

  if (PC0UW00.PC0UWODF == "N" /* Data not requested*/
   || converseVar.validationMsgNum != 0) /* Error found*/
    return;
  end



  PC0U111(); /* Purge temporary storage*/

   /* ------------------------------------------------------------*/
   /* Open cursor for item row*/
   /* ------------------------------------------------------------*/

  PC0US02(); /* Open cursor for item row*/

   /* ------------------------------------------------------------*/
   /* Obtain first item row*/
   /* If there are item rows initialize the color total fields,*/
   /* and save the color.*/
   /* ------------------------------------------------------------*/

  PC0US03(); /* Obtain item row*/
  while (VPOITM05.PC6STAT == "CX" /* While cancelled items*/
   && PC0UW00.PC0UWICF != "Y") /* and more items exist*/
    PC0US03(); /* Obtain next item row*/
  end

  if (PC0UW00.PC0UWICF != "Y"
   && PC0UW01.SY1STNBR == " ")
    PC0UW01.SY1STNBR = VPOITM05.SY1STNBR;
  end
  move 0 to PC0UW00.PC0UWSSZ[1] for all;
  move 0 to PC0UW00.PC0UWSRZ[1] for all;
  move 0 to PC0UW00.PC0UWIRS[1] for all;
  move 0 to PC0UW00.PC0UWTIZ[1] for all;
  move 0 to PC0UW00.PC0UWISZ[1] for all;
  move 0 to PC0UW00.PC0UWSS[1] for all;
  move 0 to PC0UW00.PC0UWAMT[1] for all;
  PC0UW00.PC0UWTIS = 0;
  PC0UW00.PC0UWISR = 0;
  PC0UW00.PC0UWTSR = 0;
  PC0UW00.PC0UWTSS = 0;
  while (PC0UW00.PC0UWICF != "Y")

     /* Initialize color totals*/

    PC0UW00.PC0UWTIC = 0; /* Total items by color*/
    PC0UW00.PC0UWTCS = 0; /* Total intransit by color*/
    PC0UW00.PC0UWTCR = 0; /* Total receiving by color*/
    PC0UW00.PC0UWICS = 0; /* Irregular shipping by color*/
    PC0UW00.PC0UWICR = 0; /* Irregular receiving by color*/
    move 0 to PC0UW00.PC0UWICZ[1] for all; /* Total item color size array*/
    move 0 to PC0UW00.PC0UWCSZ[1] for all; /* Total shipping color size array*/
    move 0 to PC0UW00.PC0UWCRZ[1] for all; /* Total receiving color size array*/
    move 0 to PC0UW00.PC0UWISC[1] for all;
                                   /* Total irreg shipping color size array*/
    move 0 to PC0UW00.PC0UWIRC[1] for all; /* Total irreg receiv color size array*/
    PC0UW00.PC0UWTCT = 0; /* Total cut quantity*/
    move 0 to PC0UW00.PC0UWTCZ[1] for all; /* Total cut size array*/

     /* Initialize destination array*/

    move " " to PC0UW00.XWHCD[1] for all; /* Initialize destination arrays*/
    move " " to PC0UW00.PC2CUXID[1] for all;
    move " " to PC0UW00.PC2INSEG[1] for all;
    move 0 to PC0UW00.PC0UWTID[1] for all; /* Total item for destination*/
    PC0UW00.PC0UWDIX = 1; /* Init destination index*/
    PC0UW00.PC0UWICT = 0; /* Item count for each color*/

    PC0U112(); /* Init destination size table*/

    /* ------------------------------------------------------------*/
     /* Obtain and load the size descriptions*/
    /* ------------------------------------------------------------*/

    set PG3REC empty;

    PG3REC.XGPCD = PCWREC.XGPCD;
    PG3REC.SY1STNBR = VPOITM05.SY1STNBR;
    PG3REC.SY2CLRID = VPOITM05.SY2CLRID;
    PG3REC.XDMCD = VPOITM05.XDMCD;
    PG3REC.XQACD = "**";
    PG3REC.PG3FUNCD = "PC";
    PG3REC.PG3DATFM = "N";

    XSPG301(); /* Get valid sizes*/

    PC0UW00.PC0UWIX1 = 1;
    while (PC0UW00.PC0UWIX1 <= 40)
      if (PG3REC.SY4IDDSC[PC0UWIX1] != " ")
        PC0UW00.SY4IDDSC[PC0UWIX1] = PG3REC.SY4IDDSC[PC0UWIX1];
      end
      PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
    end

    PC0UW00.PC0UWDIX = 1; /* Init destination index*/

     /* Save current color*/

    PC0UW00.SY2CLRID = VPOITM05.SY2CLRID;


    /* ------------------------------------------------------------*/
     /* Process all the items for a color*/
    /* ------------------------------------------------------------*/

    while (PC0UW00.PC0UWICF == "N" /* more data and same color*/
     && VPOITM05.SY2CLRID == PC0UW00.SY2CLRID)

      PC0U113(); /* Process all items rows (for all*/
                                   /* destinations)*/


    end
    if (PC0UW00.TA5TSQIX == 0 /* No temp storage page written*/
     && PC0UW00.PC0UWIXT == 0) /* No detail line formatted*/
       /* next sentence*/
    else

      if (PC0UW00.PC0UWICT > 1) /* If more than 1 item for this color*/
        PC0U114(); /* Create balance on order record*/
      end

      PC0US43();
                                   /* Create cut detail and cut total lines*/

      PC0UW00.PC0UWDIX = +1; /* Initialize destination index*/
      while (PC0UW00.PC0UWDIX <= PC0UW00.PC0UWDMX)

        PC0U115(); /* process all shipping and receiving*/
                                   /* rows*/

        PC0UW00.PC0UWDIX = PC0UW00.PC0UWDIX + 1;

      end
      PC0U116(); /* Create color balance to ship*/
      PC0U117(); /* Create color irregular %*/

      /* ------------------------------------------------------------*/
       /* Display blank line between colors if no totals for color.*/
      /* ------------------------------------------------------------*/

      if (PC0UW00.PC0UWICF == "N" /* If more items*/
       && PC0UWIXT != 0)          /* and not at top of page*/
        if (PC0UW12.PC0UW12K[PC0UWIXT] == 2 /* If item was last displayed*/
         || PC0UW12.PC0UW12K[PC0UWIXT] == 22
         || PC0UW12.PC0UW12K[PC0UWIXT] == 30)
          PC0UW00.PC0UWIXT = PC0UW00.PC0UWIXT + 1; /* move down 1 line*/
          if (PC0UW00.PC0UWIXT == PC0UW00.PC0UWMAX) /* Max lines*/
            PC0US12(); /* Add to temp storage*/
          end
        end
      end
    end

  end

  PC0US33(); /* Close item cursor*/

   /* Set the obtain data flag to 'n'*/

  PC0UW00.PC0UWODF = "N"; /* Obtain data flag*/

  if (PC0UW00.TA5TSQIX == 0) /* No temp storage page written*/
    if (PC0UW00.PC0UWIXT == 0) /* No detail line formatted*/
      PC0UM001.XXXPRCNM = "PC0U110"; /* procedure name*/
      converseLib.validationFailed(18); /* Indicate no data to display*/
      exit stack; /* Display error message*/
    end
  end

   /* ------------------------------------------------------------*/
   /* Detail has been created--create the style total records*/
   /* ------------------------------------------------------------*/

  PC0UW00.PC0UWIXT = PC0UW00.PC0UWIXT + 1;
  if (PC0UW00.PC0UWIXT == PC0UW00.PC0UWMAX) /* Max lines*/
    PC0US12(); /* Add to temp storage*/
  end

  PC0U118(); /* Create Style balance to ship*/

  PC0U119(); /* Create Style irregular %*/

   /* IF PC0UW00.PC0UWIXT NE 0;      /* Write partial page to temp storage*/
   /* PC0US12;                     /* Add to temp storage*/
   /* END;*/


   /* ------------------------------------------------------------*/
   /* get any fypo and cplhd records that do not match the items*/
   /* ------------------------------------------------------------*/

  PC0U310(); /* retrieve transporation recs*/

  if (PC0UW00.PC0UWIXT != 0) /* Write partial page to temp storage*/
    PC0US12(); /* Add to temp storage*/
  end



end // end PC0U110

// Purge temporary storage
Function PC0U111()
   /* ------------------------------------------------------------*/
   /* Initialize the storage areas and indicators to be used.*/
   /* ------------------------------------------------------------*/

  set PC0UW12 empty; /* Map temporary storage page*/
  set TA5REC empty; /* temporary storage record*/


  PC0UW00.TA5TSQIX = 0; /* Highest page number*/
  PC0UW00.PC0UWIXT = 0; /* temporary storage line index*/

   /* ------------------------------------------------------------*/
   /* Purge any temporary storage for this application.*/
   /* ------------------------------------------------------------*/

  TA5REC.TA5APPID = COMMAREA.CACURRAP; /* Application identification*/
  TA5REC.TA5FNCCD = "P"; /* Function code*/

  try
    call "TA0050" (PC0UW12, TA5REC) {isNoRefresh = yes, isExternal = yes};
  end /* Temporary storage*/

   /* ------------------------------------------------------------*/
   /* If successful, return to previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && TA5REC.TA5RTNCD == 0)          /* and normal return code*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that a system error occurred.*/
   /* ------------------------------------------------------------*/

  TAEREC.TAEDESC1 = sysVar.errorCode; /* CSP return code*/
  TAEREC.TAEDESC2 = TA5REC.TA5DATA; /* Subroutine parameters*/

  PC0UM001.XXXPRCNM = "PC0U111"; /* Module identification*/
  converseLib.validationFailed(01); /* Indicate system error*/

  TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  TA1REC.TA1TYPE = "APPL"; /* Type of error*/
  TA1REC.TA1LOC = "PURGE ANY TEMPORARY STORAGE";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = PC0UM001.XXXPRCNM; /* Program number*/
  TA1REC.TA1MAPAP = COMMAREA.CACURRAP; /* Map application*/
  TA1REC.TA1MAPNO = "M001"; /* Map number*/

  call "TA0020" (TA1REC, SQLCA) {isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end PC0U111

// Init destination size fields
Function PC0U112()
   /* ------------------------------------------------------------*/
   /* Initialize the working storage destination tables.*/
   /* ------------------------------------------------------------*/

  move 0 to PC0UW00.PC0UWD01[1] for all;

  move 0 to PC0UW00.PC0UWD02[1] for all;

  move 0 to PC0UW00.PC0UWD03[1] for all;

  move 0 to PC0UW00.PC0UWD04[1] for all;

  move 0 to PC0UW00.PC0UWD05[1] for all;

  move 0 to PC0UW00.PC0UWD06[1] for all;

  move 0 to PC0UW00.PC0UWD07[1] for all;

  move 0 to PC0UW00.PC0UWD08[1] for all;

  move 0 to PC0UW00.PC0UWD09[1] for all;

  move 0 to PC0UW00.PC0UWD10[1] for all;

  move 0 to PC0UW00.PC0UWD11[1] for all;

  move 0 to PC0UW00.PC0UWD12[1] for all;

  move 0 to PC0UW00.PC0UWD13[1] for all;

  move 0 to PC0UW00.PC0UWD14[1] for all;

  move 0 to PC0UW00.PC0UWD15[1] for all;

  move 0 to PC0UW00.PC0UWD16[1] for all;

  move 0 to PC0UW00.PC0UWD17[1] for all;

  move 0 to PC0UW00.PC0UWD18[1] for all;

  move 0 to PC0UW00.PC0UWD19[1] for all;

  move 0 to PC0UW00.PC0UWD20[1] for all;


end // end PC0U112

// Get all item and size data
Function PC0U113()


   /* ------------------------------------------------------------*/
   /* Process all the item rows--saving each destination in*/
   /* a table in working storage.*/
   /* ------------------------------------------------------------*/

  PC0UW00.XWHCD[PC0UWDIX] = VPOITM05.XWHCD; /* Save destination*/
  PC0UW00.PC2CUXID[PC0UWDIX] = VPOITM05.PC2CUXID;
  PC0UW00.PC2INSEG[PC0UWDIX] = VPOITM05.PC2INSEG;
  PC0UW00.XOWCD[PC0UWDIX] = VPOITM05.XOWCD;
  PC0UW00.OP1PARTN[PC0UWDIX] = VPOITM05.OP1PARTN;
  PC0UW00.OP1CUOID[PC0UWDIX] = VPOITM05.OP1CUOID;
  PC0UW00.OP1NORID[PC0UWDIX] = VPOITM05.OP1NORID;


   /* ------------------------------------------------------------*/
   /* save key fields in case last rec retrieved is 'cx'*/
   /* ------------------------------------------------------------*/
  PC0UW16.SY1STNBR = VPOITM05.SY1STNBR; /* save style*/
  PC0UW16.SY2CLRID = VPOITM05.SY2CLRID; /* save color*/
  PC0UW16.XOWCD = VPOITM05.XOWCD; /* Save owner group*/
  PC0UW16.XDMCD = VPOITM05.XDMCD; /* Save dimension*/
  PC0UW16.XPGCD = VPOITM05.XPGCD; /* Save package type*/
  PC0UW16.XUMCD = VPOITM05.XUMCD; /* Save unit of measure*/
  PC0UW16.XQACD = VPOITM05.XQACD; /* Save quality code*/

     /* save for bts processing*/
  PC0UW00.XDMCD = VPOITM05.XDMCD; /* Save dimension*/
  PC0UW00.XPGCD = VPOITM05.XPGCD; /* Save package type*/
  PC0UW00.XUMCD = VPOITM05.XUMCD; /* Save unit of measure*/
  PC0UW00.XQACD = VPOITM05.XQACD; /* Save quality code*/

  while (PC0UW00.PC0UWICF == "N"
   && VPOITM05.SY2CLRID == PC0UW00.SY2CLRID
   && VPOITM05.XWHCD == PC0UW00.XWHCD[PC0UWDIX]
   && VPOITM05.PC2CUXID == PC0UW00.PC2CUXID[PC0UWDIX]
   && VPOITM05.XOWCD == PC0UW00.XOWCD[PC0UWDIX]
   && VPOITM05.OP1PARTN == PC0UW00.OP1PARTN[PC0UWDIX]
   && VPOITM05.OP1CUOID == PC0UW00.OP1CUOID[PC0UWDIX]
   && VPOITM05.OP1NORID == PC0UW00.OP1NORID[PC0UWDIX])

    PC0U101(); /* Process items for destination*/

    PC0US03(); /* Fetch next item row*/
    while (VPOITM05.PC6STAT == "CX" /* While cancelled items*/
     && PC0UW00.PC0UWICF != "Y") /* and more items exist*/
      PC0US03(); /* Fetch next item row*/
    end
    if (VPOITM05.PC6STAT == "CX") /* No other open items found*/
      VPOITM05.SY1STNBR = PC0UW16.SY1STNBR; /* reload style*/
      VPOITM05.SY2CLRID = PC0UW16.SY2CLRID; /* save color*/
      VPOITM05.XOWCD = PC0UW16.XOWCD; /* Save owner group*/
      VPOITM05.XDMCD = PC0UW16.XDMCD; /* Save dimension*/
      VPOITM05.XPGCD = PC0UW16.XPGCD; /* Save package type*/
      VPOITM05.XUMCD = PC0UW16.XUMCD; /* Save unit of measure*/
      VPOITM05.XQACD = PC0UW16.XQACD; /* Save quality code*/
    end

  end

  if (PC0UW00.PC0UWICF == "N"
   && VPOITM05.SY2CLRID == PC0UW00.SY2CLRID)
    PC0UW00.PC0UWDIX = PC0UW00.PC0UWDIX + 1; /* Increment dest index*/
  else
    PC0UW00.PC0UWDMX = PC0UW00.PC0UWDIX; /* destination max*/
  end


end // end PC0U113

// Create on order total line
Function PC0U114()
   /* ------------------------------------------------------------*/
   /* Initialize the total order data temporary storage record.*/
   /* Move the data from the working storage record to the*/
   /* temporary storage record.*/
   /* ------------------------------------------------------------*/

   /* Increment temp storage line index*/

  PC0UW00.PC0UWIXT = PC0UW00.PC0UWIXT + 1;

  set PC0UW05 empty; /* Initialize record*/

  PC0UW05.PC0UW05L = "TOTAL ON ORDER  :"; /* Total line literal*/
  PC0UW05.PC0UWBLT = "TOTAL ON ORDER  :"; /* Screen two literal*/

  PC0UW05.PC0UWQTY = PC0UW00.PC0UWTIC; /* Total quantity*/

  PC0UW00.PC0UWIX1 = 1; /* Initialize general index*/

  while (PC0UW00.PC0UWIX1 <= 40)
    if (PC0UW00.PC0UWICZ[PC0UWIX1] != 0)
      PC0UW05.PC0UWORQ[PC0UWIX1] = PC0UW00.PC0UWICZ[PC0UWIX1];
    end
    PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
  end


  PC0UW05.PC0UW05K = 5; /* Indicate type of record*/
  PC0UW12.PC0UW12R[PC0UWIXT] = PC0UW05.PC0UW05G;

  if (PC0UW00.PC0UWIXT == PC0UW00.PC0UWMAX) /* Max ines (13)*/

    PC0US12(); /* Add page to temp storage*/

  end


end // end PC0U114

// Process ship/rec dest data
Function PC0U115()
   /* ------------------------------------------------------------*/
   /* First get all the of the shipping data for a destination*/
   /* Then check to see if the quality code was an 01--if so*/
   /* use '02' as the quality code and get any irregular*/
   /* quantities for the destination.*/
   /* Then get all of the received data for a destination.*/
   /* The same procedure is done for the quality code.*/
   /* If there was shipping and/or received data create a*/
   /* balance to ship record and a irregular percent record*/
   /* for each destination.*/
   /* ------------------------------------------------------------*/

   /* Initialize destination total arrays for shipping & receiving*/

  PC0UW00.PC0UWTDS = 0; /* Destination shipped*/
  PC0UW00.PC0UWTDR = 0; /* Destination receiving*/
  PC0UW00.PC0UWIDS = 0; /* Irregular shipping dest*/
  PC0UW00.PC0UWIDR = 0; /* Irregular receiving dest*/
  move 0 to PC0UW00.PC0UWDSZ[1] for all; /* Destination shipping size array*/
  move 0 to PC0UW00.PC0UWDRZ[1] for all; /* Destination recieved size array*/
  move 0 to PC0UW00.PC0UWISD[1] for all;
                                   /* Destination irreg shipping size array*/
  move 0 to PC0UW00.PC0UWIRD[1] for all; /* Destination irreg receiving size*/
                                   /* array*/
  set TSTREC empty;

  TSTREC.XGPCD = PCWREC.XGPCD;
  TSTREC.PC3PONBR = PCWREC.PC3PONBR; /* PO number*/
  TSTREC.SY1STNBR = VPOITM05.SY1STNBR; /* Style number*/
  TSTREC.SY2CLRID = PC0UW00.SY2CLRID; /* Color code*/
  TSTREC.OP1PARTN = PC0UW00.OP1PARTN[PC0UWDIX];
  TSTREC.OP1CUOID = PC0UW00.OP1CUOID[PC0UWDIX]; /* Cust ord*/
  TSTREC.OP1NORID = PC0UW00.OP1NORID[PC0UWDIX]; /* Nike ord*/
  TSTREC.XOWCD = PC0UW00.XOWCD[PC0UWDIX]; /* Owner Group code*/
  TSTREC.PC2INSEG = PC0UW00.PC2INSEG[PC0UWDIX]; /* Spec code*/
  TSTREC.XDMCD = PC0UW00.XDMCD; /* Dimension code*/
  TSTREC.XQACD = PC0UW00.XQACD; /* Quality code*/
  TSTREC.XPGCD = PC0UW00.XPGCD; /* Package code*/
  TSTREC.XUMCD = PC0UW00.XUMCD; /* Unit of measure*/

  if (VPOITM05.PC4ORTYP == "AR")
    TSTREC.OP1PARTN = "*";
    TSTREC.OP1CUOID = -1; /* Cust ord*/
    TSTREC.OP1NORID = -1; /* Nike ord*/
  end

   /* Destination data*/

  TSTREC.XWHCD = PC0UW00.XWHCD[PC0UWDIX];
  TSTREC.PC2CUXID = PC0UW00.PC2CUXID[PC0UWDIX];


  PC0US13(); /* Open ship header/container table*/

   /* ------------------------------------------------------------*/
   /* If there are shipping rows-retrieve all rows from the*/
   /* transporation header/container table for a destination*/
   /* ------------------------------------------------------------*/


   /* MOVE 0 TO PC0UW00.PC0UWTSS;*/
   /* MOVE 0 TO PC0UW00.PC0UWTSR;*/
   /* MOVE 0 TO PC0UW00.PC0UWWF1;*/
  PC0UW00.PC0UWISF = "N"; /* Set irregular ship flag to no*/
  PC0UW00.PC0UWIRF = "N"; /* Set irregular received flag to no*/
  PC0UW00.PC0UWSDF = "N"; /* set shipping data flag to no.*/

  PC0US14(); /* Fetch Transporation row*/



  while (PC0UW00.PC0UWTCF != "Y")

    PC0US15(); /* Process all transporations rows*/

  end

  PC0US24(); /* Close Transporation cursor*/

   /* ------------------------------------------------------------*/
   /* Get any irregular intransit data for a destination.*/
   /* ------------------------------------------------------------*/


  if (TSTREC.XQACD == "01") /* Processed quanitity code one first*/
    set TSTREC empty;

    TSTREC.XGPCD = PCWREC.XGPCD;
    TSTREC.PC3PONBR = PCWREC.PC3PONBR; /* PO number*/
    TSTREC.SY1STNBR = VPOITM05.SY1STNBR; /* Style number*/
    TSTREC.SY2CLRID = PC0UW00.SY2CLRID; /* Color code*/
    TSTREC.XOWCD = PC0UW00.XOWCD[PC0UWDIX]; /* Owner Group code*/
    TSTREC.PC2INSEG = PC0UW00.PC2INSEG[PC0UWDIX]; /* Spec code*/
    TSTREC.XQACD = "02"; /* Quality code*/
    TSTREC.XDMCD = PC0UW00.XDMCD; /* Dimension code*/
    TSTREC.XPGCD = PC0UW00.XPGCD; /* Package code*/
    TSTREC.XUMCD = PC0UW00.XUMCD; /* Unit of measure*/
    TSTREC.OP1PARTN = PC0UW00.OP1PARTN[PC0UWDIX]; /* Part char*/
    TSTREC.OP1CUOID = PC0UW00.OP1CUOID[PC0UWDIX]; /* Cust ord*/
    TSTREC.OP1NORID = PC0UW00.OP1NORID[PC0UWDIX]; /* Nike ord*/
    if (VPOITM05.PC4ORTYP == "AR")
      TSTREC.OP1PARTN = "*";
      TSTREC.OP1CUOID = -1; /* Cust ord*/
      TSTREC.OP1NORID = -1; /* Nike ord*/
    end

    /* Destination data*/

    TSTREC.XWHCD = PC0UW00.XWHCD[PC0UWDIX];
    TSTREC.PC2CUXID = PC0UW00.PC2CUXID[PC0UWDIX];


    if (PCWREC.XGPCD == "03"
     && TSTREC.XQACD == "02"
     && PC0UW00.XWHCD[PC0UWDIX] != "18")
      TSTREC.XWHCD = "*";
      TSTREC.PC2CUXID = "*";
      TSTREC.OP1PARTN = "*";
      TSTREC.XOWCD = "*"; /* Owner Group code*/
      TSTREC.XUMCD = "*"; /* Unit of measure code*/
      TSTREC.PC2INSEG = "*"; /* Spec code*/
      TSTREC.OP1CUOID = -1; /* Cust ord*/
      TSTREC.OP1NORID = -1; /* Nike ord*/
    end

    PC0US13(); /* Open ship header/container table*/

    /* ------------------------------------------------------------*/
     /* If there are shipping rows-retrieve all rows from the*/
     /* transporation header/container table for a destination*/
    /* ------------------------------------------------------------*/


    PC0US14(); /* Fetch Transporation row*/



    while (PC0UW00.PC0UWTCF != "Y")

      PC0UW00.PC0UWISF = "Y"; /* Set irregular shipped flag to yes*/

      PC0US15(); /* Process all transporations rows*/

    end

    PC0US24(); /* Close Transporation cursor*/
  end

   /* ------------------------------------------------------------*/
   /* Obtain the receiving data for the destination.*/
   /* Load data from the PCWREC to the pcmrec.*/
   /* ------------------------------------------------------------*/

  PC0UW00.PC0UWIRF = "N"; /* Irregular quality flag*/
  PC0UW00.PC0UWRDF = "N"; /* Set Received data flag to yes*/

  set VFYPO002 empty;

  VFYPO002.XGPCD = PCWREC.XGPCD;
  VFYPO002.PC3PONBR = PCWREC.PC3PONBR; /* PO number*/
  VFYPO002.SY1STNBR = VPOITM05.SY1STNBR; /* Style number*/
  VFYPO002.SY2CLRID = PC0UW00.SY2CLRID; /* Color code*/
  VFYPO002.XDMCD = PC0UW00.XDMCD; /* Dimension code*/
  VFYPO002.XPGCD = PC0UW00.XPGCD; /* Package code*/
  VFYPO002.XUMCD = PC0UW00.XUMCD; /* Unit of measure*/
  VFYPO002.XWHCD = PC0UW00.XWHCD[PC0UWDIX]; /* warehouse code*/
  VFYPO002.PC2CUXID = PC0UW00.PC2CUXID[PC0UWDIX]; /* Customer*/
  VFYPO002.PC2INSEG = PC0UW00.PC2INSEG[PC0UWDIX];
  VFYPO002.OP1PARTN = PC0UW00.OP1PARTN[PC0UWDIX]; /* Part char*/
  VFYPO002.OP1CUOID = PC0UW00.OP1CUOID[PC0UWDIX]; /* Cust ord*/
  VFYPO002.OP1NORID = PC0UW00.OP1NORID[PC0UWDIX]; /* Nike ord*/
  VFYPO002.XQACD = "01"; /* Quality code*/
  VFYPO002.YMTCD = "*"; /* Mode code*/
  if (VPOITM05.PC4ORTYP == "AR")
    VFYPO002.OP1PARTN = "*";
    VFYPO002.OP1CUOID = -1; /* Cust ord*/
    VFYPO002.OP1NORID = -1; /* Nike ord*/
  end


  VFYPO002.XOWCD = PC0UW00.XOWCD[PC0UWDIX]; /* Owner Group code*/


  PC0US25(); /* Open received cursor*/

   /* ------------------------------------------------------------*/
   /* Retrieve all rows from the received table.*/
   /* ------------------------------------------------------------*/


  PC0US26(); /* Fetch received row*/



  while (PC0UW00.PC0UWRCF != "Y") /* Cursor not at end*/

    PC0UW00.PC0UWRDF = "Y"; /* set Received data flag to yes*/

    PC0US27(); /* Process all received rows*/

  end

  PC0US28(); /* Close received cursor*/



   /* ------------------------------------------------------------*/
   /* Retrieve all irregular rows from the received table.*/
   /* ------------------------------------------------------------*/

  PC0UW00.PC0UWIRF = "N"; /* Irregular quality flag*/

  set VFYPO002 empty;

  VFYPO002.XGPCD = PCWREC.XGPCD;
  VFYPO002.PC3PONBR = PCWREC.PC3PONBR; /* PO number*/
  VFYPO002.SY1STNBR = VPOITM05.SY1STNBR; /* Style number*/
  VFYPO002.SY2CLRID = PC0UW00.SY2CLRID; /* Color code*/
  VFYPO002.XQACD = "02"; /* Quality code*/
  VFYPO002.XDMCD = PC0UW00.XDMCD; /* Dimension code*/
  VFYPO002.XPGCD = PC0UW00.XPGCD; /* Package code*/
  VFYPO002.XUMCD = PC0UW00.XUMCD; /* Unit of measure*/
  VFYPO002.XWHCD = PC0UW00.XWHCD[PC0UWDIX]; /* warehouse code*/
  VFYPO002.PC2CUXID = PC0UW00.PC2CUXID[PC0UWDIX]; /* Customer*/
  VFYPO002.PC2INSEG = PC0UW00.PC2INSEG[PC0UWDIX];
  VFYPO002.OP1PARTN = PC0UW00.OP1PARTN[PC0UWDIX]; /* Part char*/
  VFYPO002.OP1CUOID = PC0UW00.OP1CUOID[PC0UWDIX]; /* Cust ord*/
  VFYPO002.OP1NORID = PC0UW00.OP1NORID[PC0UWDIX]; /* Nike ord*/
  if (VPOITM05.PC4ORTYP == "AR")
    VFYPO002.OP1PARTN = "*";
    VFYPO002.OP1CUOID = -1; /* Cust ord*/
    VFYPO002.OP1NORID = -1; /* Nike ord*/
  end
  VFYPO002.YMTCD = "*"; /* Mode code*/

  VFYPO002.XOWCD = PC0UW00.XOWCD[PC0UWDIX]; /* Owner Group code*/


  if (PCWREC.XGPCD == "03"
   && VFYPO002.XQACD == "02"
   && PC0UW00.XWHCD[PC0UWDIX] == "18")
    VFYPO002.XWHCD = "*";
    VFYPO002.PC2CUXID = "*";
    VFYPO002.OP1PARTN = "*";
    VFYPO002.XOWCD = "*"; /* Owner Group code*/
    VFYPO002.XUMCD = "*"; /* Unit of measure code*/
    VFYPO002.PC2INSEG = "*"; /* Spec code*/
    VFYPO002.OP1CUOID = -1; /* Cust ord*/
    VFYPO002.OP1NORID = -1; /* Nike ord*/
  end

  PC0US25(); /* Open received cursor*/

    /* ------------------------------------------------------------*/
     /* Retrieve all rows from the received table.*/
    /* ------------------------------------------------------------*/


  PC0US26(); /* Fetch received row*/



  while (PC0UW00.PC0UWRCF != "Y") /* Cursor not at end*/

    PC0UW00.PC0UWIRF = "Y"; /* Set irregular received flag to yes*/
    PC0UW00.PC0UWRDF = "Y"; /* set Received data flag to yes*/

    PC0US27(); /* Process all received rows*/

  end

  PC0US28(); /* Close received cursor*/
   /* ------------------------------------------------------------*/
  return; /* Do not show destination totals*/
   /* ------------------------------------------------------------*/
   /* ------------------------------------------------------------*/
   /* If there was shipping or receiving data create destination*/
   /* balance to ship temp storage record.*/
   /* If there was irregular received data (not equal to zeros)*/
   /* create destination irregular percent temp storage record.*/
   /* ------------------------------------------------------------*/

  if (PC0UW00.PC0UWSDF == "Y" /* Shipping data exists or*/
   || PC0UW00.PC0UWRDF == "Y") /* Received data exists*/

    PC0US29(); /* Create destination balance to ship*/

    if (PC0UW00.PC0UWIRF == "Y" /* If irregular received data*/
     && PC0UW00.PC0UWIDR != 0)  /* And total not zeros*/

      PC0US31();
                                   /* Create destination irregular % record*/

    end

  end

end // end PC0U115

// Create color balance to ship
Function PC0U116()

  set PC0UW08 empty; /* Initialize record*/

  PC0UW08.SY2CLRID = PC0UW00.SY2CLRID;
  PC0UW08.PC0UWS2C = PC0UW00.SY2CLRID;
  PC0UW08.PC0UWLIT = "BALANCE TO SHIP:"; /* balance due literal*/
  PC0UW08.PC0UWSTL = "BALANCE TO SHIP:"; /* second screen*/

   /* Balance to ship = planned - ( shipped + received)*/

  PC0UW00.PC0UWWF1 = 0;
  PC0UW00.PC0UWWF1 = PC0UW00.PC0UWTCS + PC0UW00.PC0UWTCR; /* rec'd + ship*/
  PC0UW08.PC0UWQTY = PC0UW00.PC0UWTIC - PC0UW00.PC0UWWF1;

  if (PC0UW00.PC0UWWF1 == 0)
    return;
  end

   /* Increment temp storage line index*/

  PC0UW00.PC0UWIXT = PC0UW00.PC0UWIXT + 1;


  PC0UW00.PC0UWIX1 = 1; /* Initialize general index*/

  while (PC0UW00.PC0UWIX1 <= 40)
    if (PC0UW00.PC0UWICZ[PC0UWIX1] != 0 /* If planned qty or*/
     || PC0UW00.PC0UWCSZ[PC0UWIX1] != 0 /* Shipping qty or*/
     || PC0UW00.PC0UWCRZ[PC0UWIX1] != 0) /* receiving qty*/

       /* Balance to ship = planned - ( shipped + received)*/

      PC0UW00.PC0UWWF1 = 0; /* Work field*/
      /* Add shipping qty to work field*/
      PC0UW00.PC0UWWF1 = PC0UW00.PC0UWWF1 + PC0UW00.PC0UWCSZ[PC0UWIX1];
      /* Add receiving qty to work field*/
      PC0UW00.PC0UWWF1 = PC0UW00.PC0UWWF1 + PC0UW00.PC0UWCRZ[PC0UWIX1];
      /* Subtract work field from planned qty*/
      PC0UW08.PC0UWORQ[PC0UWIX1] = PC0UWICZ[PC0UWIX1] - PC0UW00.PC0UWWF1;
    end
    PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
  end


  PC0UW08.PC0UW08K = 8; /* Indicate type of record*/
  PC0UW12.PC0UW12R[PC0UWIXT] = PC0UW08.PC0UW08G;

  if (PC0UW00.PC0UWIXT == PC0UW00.PC0UWMAX) /* Max lines*/

    PC0US12(); /* Add page to temp storage*/

  end


end // end PC0U116

// Create color irregular %
Function PC0U117()


  set PC0UW09 empty; /* Initialize record*/

  PC0UW09.SY2CLRID = PC0UW00.SY2CLRID;
  PC0UW09.SY2CLRID = PC0UW00.SY2CLRID;
  PC0UW09.PC0UWLIT = "IRREGS %       :"; /* balance due literal*/
  PC0UW09.PC0UWIPL = "IRREGS %       :"; /* second screen*/

   /* Irregular % =*/
   /* received irregulars (by color) / total ordered (by color)*/

  if (PC0UW00.PC0UWICR != 0
   && PC0UW00.PC0UWTIC != 0)
    PC0UW00.PC0UWWF5 = mathLib.round(PC0UW00.PC0UWICR / PC0UW00.PC0UWTIC, -mathLib.decimals(PC0UW00.PC0UWWF5));
    PC0UW09.PC0UWQTY = PC0UW00.PC0UWWF5 * 100;
  else
    return;
  end

   /* Increment temp storage line index*/

  PC0UW00.PC0UWIXT = PC0UW00.PC0UWIXT + 1;

  PC0UW00.PC0UWIX1 = 1; /* Initialize general index*/

  while (PC0UW00.PC0UWIX1 <= 40)
    if (PC0UW00.PC0UWICZ[PC0UWIX1] != 0 /* If planned qty or*/
     && PC0UW00.PC0UWIRC[PC0UWIX1] != 0) /* receiving qty*/


       /* Irregular % =*/
       /* received irregulars (by color) / total ordered (by color)*/

      PC0UW00.PC0UWWF1 = PC0UW00.PC0UWICZ[PC0UWIX1]; /* planned*/
      PC0UW00.PC0UWWF2 = PC0UW00.PC0UWIRC[PC0UWIX1]; /* received*/
      PC0UW00.PC0UWWF5 = mathLib.round(PC0UW00.PC0UWWF2 / PC0UW00.PC0UWWF1, -mathLib.decimals(PC0UW00.PC0UWWF5));
      PC0UW09.PC0UWORQ[PC0UWIX1] = PC0UW00.PC0UWWF5 * 100;
    end
    PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
  end


  PC0UW09.PC0UW09K = 9; /* Indicate type of record*/
  PC0UW12.PC0UW12R[PC0UWIXT] = PC0UW09.PC0UW09G;

  if (PC0UW00.PC0UWIXT == PC0UW00.PC0UWMAX) /* Max lines*/

    PC0US12(); /* Add page to temp storage*/

  end


end // end PC0U117

// Create style balance to ship
Function PC0U118()


  set PC0UW10 empty; /* Initialize record*/

  PC0UW10.PC0UWLIT = "TOT BALANCE TO SHIP:"; /* balance due literal*/
  PC0UW10.PC0UWSTL = "TOT BALANCE TO SHIP:"; /* second screen*/

   /* Balance to ship = planned - ( shipped + received)*/

  PC0UW00.PC0UWWF1 = 0;
  PC0UW00.PC0UWWF1 = PC0UW00.PC0UWTSS + PC0UW00.PC0UWTSR; /* ship + rec'd*/
  PC0UW10.PC0UWQTY = PC0UW00.PC0UWTIS - PC0UW00.PC0UWWF1;

   /* Increment temp storage line index*/

  PC0UW00.PC0UWIXT = PC0UW00.PC0UWIXT + 1;

  PC0UW00.PC0UWIX1 = 1; /* Initialize general index*/

  while (PC0UW00.PC0UWIX1 <= 40)
    if (PC0UW00.PC0UWISZ[PC0UWIX1] != 0 /* If planned qty or*/
     || PC0UW00.PC0UWSSZ[PC0UWIX1] != 0 /* Shipping qty or*/
     || PC0UW00.PC0UWSRZ[PC0UWIX1] != 0) /* receiving qty*/

       /* Balance to ship = planned - ( shipped + received)*/

      PC0UW00.PC0UWWF1 = 0; /* Work field*/
      /* Add shipping qty to work field*/
      PC0UW00.PC0UWWF1 = PC0UW00.PC0UWWF1 + PC0UW00.PC0UWSSZ[PC0UWIX1];
      /* Add receiving qty to work field*/
      PC0UW00.PC0UWWF1 = PC0UW00.PC0UWWF1 + PC0UW00.PC0UWSRZ[PC0UWIX1];
      /* Subtract work field from planned qty*/
      PC0UW10.PC0UWORQ[PC0UWIX1] = PC0UWISZ[PC0UWIX1] - PC0UW00.PC0UWWF1;
    end
    PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
  end


  PC0UW10.PC0UW10K = 10; /* Indicate type of record*/
  PC0UW12.PC0UW12R[PC0UWIXT] = PC0UW10.PC0UW10G;

  if (PC0UW00.PC0UWIXT == PC0UW00.PC0UWMAX) /* Max lines*/

    PC0US12(); /* Add page to temp storage*/

  end


end // end PC0U118

// Create style irregular %
Function PC0U119()


  set PC0UW11 empty; /* Initialize record*/

  PC0UW11.PC0UWLIT = "TOT IRREGS %       :"; /* balance due literal*/
  PC0UW11.PC0UWTIR = "TOT IRREGS %       :"; /* second screen*/

   /* Irregular % =*/
   /* received irregulars (by color) / total ordered (by color)*/

  if (PC0UW00.PC0UWISR != 0
   && PC0UW00.PC0UWTIS != 0)
    PC0UW00.PC0UWWF5 = mathLib.round(PC0UW00.PC0UWISR / PC0UW00.PC0UWTIS, -mathLib.decimals(PC0UW00.PC0UWWF5));
    PC0UW11.PC0UWQTY = PC0UW00.PC0UWWF5 * 100;
  else
    return;
  end

   /* Increment temp storage line index*/

  PC0UW00.PC0UWIXT = PC0UW00.PC0UWIXT + 1;

  PC0UW00.PC0UWIX1 = 1; /* Initialize general index*/

  while (PC0UW00.PC0UWIX1 <= 40)
    if (PC0UW00.PC0UWISZ[PC0UWIX1] != 0 /* If planned qty or*/
     && PC0UW00.PC0UWIRS[PC0UWIX1] != 0) /* receiving qty*/


       /* Irregular % =*/
       /* received irregulars (by color) / total ordered (by color)*/

      PC0UW00.PC0UWWF1 = PC0UW00.PC0UWISZ[PC0UWIX1]; /* planned*/
      PC0UW00.PC0UWWF2 = PC0UW00.PC0UWIRS[PC0UWIX1]; /* received*/
      PC0UW00.PC0UWWF5 = mathLib.round(PC0UW00.PC0UWWF2 / PC0UW00.PC0UWWF1, -mathLib.decimals(PC0UW00.PC0UWWF5));
      PC0UW11.PC0UWORQ[PC0UWIX1] = PC0UW00.PC0UWWF5 * 100;
    end
    PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
  end


  PC0UW11.PC0UW11K = 11; /* Indicate type of record*/
  PC0UW12.PC0UW12R[PC0UWIXT] = PC0UW11.PC0UW11G;

  if (PC0UW00.PC0UWIXT == PC0UW00.PC0UWMAX) /* Max lines*/

    PC0US12(); /* Add page to temp storage*/

  end


end // end PC0U119

// Format and display map 1
Function PC0U120()


  if (converseVar.validationMsgNum != 0)
    set PC0UM001 alarm; /* Indicate sound alarm*/
  end


   /* -----------------------------------------------------------*/
   /* If map is not formatted, format the data to display*/
   /* -----------------------------------------------------------*/


  if (PC0UW00.TA5TSQIX > 0) /* Pages were formatted*/
    if (PC0UW00.PC0UWTSP != TA5REC.TA5TSQIX) /* Desired page not current*/
      set PC0UM001 initial;
      set PC0UM002 initial;

      PC0US34(); /* Obtain temp storage page*/
      PC0UM001.PC0UMTOP = PC0UW00.TA5TSQIX;
      PC0UM001.PC0UMFRP = PC0UW00.PC0UWTSP;




    end
  end

  PC0U121(); /* Move header data to the map*/

  if (converseVar.validationMsgNum == 0)
    PC0U122(); /* Format map 1 detail lines*/
  end

  PC0UM001.XXXCURDT = VGVar.currentShortGregorianDate; /* Current date*/

  if (PC0UW00.XXXMSGNO != 0) /* Contains informational message*/
    if (PC0UW00.XXXMSGNO == 9999)
      converseLib.validationFailed();
    else
      converseLib.validationFailed(PC0UW00.XXXMSGNO);
    end
  else

    if (COMMAREA.CAMSG > " ") /* ===> JCL job info message*/

      PC0UM001.VAGen_EZEMSG = COMMAREA.CAMSG; /* ===> job info message*/
      COMMAREA.CAMSG = " "; /* ===> reset job info message*/
      PC0UM001.XXXPRCNM = "PC0U120"; /* ===> Process name*/
      set PC0UM001 alarm; /* ===> set alarm*/
    end

  end


  if (PC0UW00.PC0UWPDF == "Y") /* Protect date*/
    set PC0UM001.PC0UMETO skip, invisible;
  end

  converse PC0UM001 ;

   /* -----------------------------------------------------------*/
   /* Clear the message fields*/
   /* -----------------------------------------------------------*/

  PC0UW00.XXXMSGNO = 0; /* Message number*/
  PC0UM001.XXXPRCNM = "PC0U"; /* Process number*/

   /* **                                                        ***/
   /* ********************** End of PC0u120 ***********************/
end // end PC0U120

// Format map Header data (1 & 2)
Function PC0U121()

   /* ------------------------------------------------------------*/
   /* Move map header from PC0UW01 display storage to the map*/
   /* fields.*/
   /* ------------------------------------------------------------*/


   /* MOVE PC0UW01.po-reg-cd TO PC0UM001.po-reg-cd;/* region cd*/
  PC0UM001.PC3PONBR = PC0UW01.PC3PONBR; /* Order number*/
  PC0UM001.PC0UMPID = PC0UW01.PC0UWPID; /* PO ID*/
  PC0UM001.XGPCD = PC0UW01.XGPCD; /* General product group*/
  PC0UM001.SY1STNBR = PC0UW01.SY1STNBR; /* Style number*/
  PC0UM001.SY2CLRID = PC0UW01.SY2CLRID; /* Color*/
  PC0UM001.PC4ORTYP = PC0UW01.PC4ORTYP; /* Order type*/
  PC0UM001.PC3BLPO = PC0UW01.PC3BLPO;
  PC0UM001.PC0UMEDT = PC0UW01.PC0UMEDT;
  PC0UM001.PC2INSEG = PC0UW01.PC2INSEG; /* Spec difference*/
  PC0UM001.XDMCD = PC0UW01.XDMCD; /* Dimension*/
  PC0UM001.XPGCD = PC0UW01.XPGCD; /* Package*/
  PC0UM001.XQACD = PC0UW01.XQACD; /* Quanlity*/

  if (PCWREC.SY1STNBR != "*")
    set PC0UM001.SY1STNBR skip, bold;
  end

  if (PCWREC.SY2CLRID != "*")
    set PC0UM001.SY2CLRID skip, bold;
  end

  if (PCWREC.PC2INSEG != "*")
    set PC0UM001.PC2INSEG skip, bold;
  end

  if (PCWREC.XDMCD != "*")
    set PC0UM001.XDMCD skip, bold;
  end

  if (PCWREC.XPGCD != "*")
    set PC0UM001.XPGCD skip, bold;
  end

  if (PCWREC.XQACD != "*")
    set PC0UM001.XQACD skip, bold;
  end

  if (COMMAREA.CAILVL[10] == "N") /* ===> FOB  security*/
    set PC0UM001.PC0UMPF2 skip, invisible;
  end


end // end PC0U121

// Format map 1 Detail lines
Function PC0U122()

   /* ------------------------------------------------------------*/
   /* Move each temporary storage line from the record to*/
   /* the map line.  Unprotect and display the select field*/
   /* for plan, and intransit detail data only.*/
   /* Position the cursor on the plan and intransit first detail*/
   /* line.*/
   /* ------------------------------------------------------------*/

  set PC0UM001.PC0UMLIT skip, invisible; /* Darken literal*/
  set PC0UM001.PC0UMETO skip, invisible; /* Darken ETALO*/
  PC0UW00.PC0UWXDF = "Y"; /* Restrict access flag*/

  PC0UW00.PC0UWIXM = PC0UW00.PC0UWMAX; /* set to max lines*/

  while (PC0UW00.PC0UWIXM >= 1)

    if (PC0UW12.PC0UW12K[PC0UWIXM] != 0)
      if (PC0UW00.PC0UWDTF == "3") /* SAP number to be shown*/
        PC0UM001.PC0UMLTL = " SAP NUMBER  "; /* SAP  literal*/
        PC0UM001.PC0UMDTL[PC0UWIXM] = PC0UW12.PC0UW12D[PC0UWIXM];
      else
        if (PC0UW00.PC0UWDTF == "1") /* Etal data to be shown*/
          PC0UM001.PC0UMLTL = " ETAL  ETAL-O"; /* Etal literal*/
          PC0UM001.PC0UMLRL = "11:S.O."; /* left/right literal*/
          PC0UM001.PC0UMDTL[PC0UWIXM] = PC0UW12.PC0UW12D[PC0UWIXM];
        else
          PC0UM001.PC0UMLTL = " SALES ORDER "; /* S.O. literal*/
          PC0UM001.PC0UMLRL = "10:ETAL"; /* left/right literal*/
          PC0UM001.PC0UMDTL[PC0UWIXM] = PC0UW12.PC0UW12D[PC0UWIXM];
        end
      end

      if (PC0UW12.PC0UW12K[PC0UWIXM] == 7 /* destination %*/
       || PC0UW12.PC0UW12K[PC0UWIXM] == 9 /* color %*/
       || PC0UW12.PC0UW12K[PC0UWIXM] == 11) /* style %*/
        PC0UW00.PC0UWNUM = PC0UW12.PC0UWQTY[PC0UWIXM];
        PC0U123(); /* unstring decimal field*/
        PC0UM001.PC0UMQTY[PC0UWIXM] = PC0UW00.PC0UWCHW;
      else
        PC0U125(); /* unstring  integer field*/
        PC0UM001.PC0UMQTY[PC0UWIXM] = PC0UW00.PC0UWCHW;
      end
      if (PC0UW12.PC0UW12K[PC0UWIXM] == 2  /* Plan data key with etal*/
       || PC0UW12.PC0UW12K[PC0UWIXM] == 3  /* shipping data key*/
       || PC0UW12.PC0UW12K[PC0UWIXM] == 18 /* shipping data key*/
       || PC0UW12.PC0UW12K[PC0UWIXM] == 22 /* plan data with s.o.*/
       || PC0UW12.PC0UW12K[PC0UWIXM] == 30) /* plan data with sap number*/
        set PC0UM001.PC0UMSEL[PC0UWIXM] cursor, normal; /* Allow entry*/
        set PC0UM001.PC0UMQTY[PC0UWIXM] initialAttributes;
        set PC0UM001.PC0UMDTL[PC0UWIXM] skip;
        if (PC0UW12.PC0UW12K[PC0UWIXM] == 3) /* shipping data key*/
          set PC0UM001.PC0UMLIT initialAttributes; /* Display literal*/
          set PC0UM001.PC0UMETO cursor, initialAttributes; /* Allow entry of ETALO*/
          PC0UW00.PC0UWXDF = "N"; /* Restrict access flag*/
        end
      else
        set PC0UM001.PC0UMSEL[PC0UWIXM] initialAttributes; /* Protect and darken*/
      end
      if (PC0UW12.PC0UW12K[PC0UWIXM] == 5 /* Total fields*/
       || PC0UW12.PC0UW12K[PC0UWIXM] == 6 
       || PC0UW12.PC0UW12K[PC0UWIXM] == 7 
       || PC0UW12.PC0UW12K[PC0UWIXM] == 8 
       || PC0UW12.PC0UW12K[PC0UWIXM] == 9 
       || PC0UW12.PC0UW12K[PC0UWIXM] == 10
       || PC0UW12.PC0UW12K[PC0UWIXM] == 11
       || PC0UW12.PC0UW12K[PC0UWIXM] == 15)
        set PC0UM001.PC0UMDTL[PC0UWIXM] skip, bold;
        set PC0UM001.PC0UMQTY[PC0UWIXM] skip, bold;
      else
        set PC0UM001.PC0UMQTY[PC0UWIXM] initialAttributes;
        set PC0UM001.PC0UMDTL[PC0UWIXM] skip;
      end
    else
      set PC0UM001.PC0UMQTY[PC0UWIXM] protect, invisible;
    end
    if (PC0UW12.PC0UW12K[PC0UWIXM] == 19) /* unmtchd trans label*/
      set PC0UM001.PC0UMQTY[PC0UWIXM] protect, invisible;
    end
    PC0UW00.PC0UWIXM = PC0UW00.PC0UWIXM - 1;
  end

end // end PC0U122

// Unstring decimal field
Function PC0U123()

  /* MOVE ' ' TO PC0UW00.PC0UWDFL;     /* blank fill*/
  PC0UW00.PC0UWDFL = PC0UW00.PC0UWNF1; /* % hndr place*/
  PC0UW00.PC0UWDZ1 = PC0UW00.PC0UWNF2; /* % tens place*/
  PC0UW00.PC0UWDZ2 = PC0UW00.PC0UWNF3; /* % ones place*/
  PC0UW00.PC0UWDPT = "."; /* decimal point*/
  PC0UW00.PC0UWDEF = PC0UW00.PC0UWNDE; /* decimal value*/

  if (PC0UW00.PC0UWNF1 == 0)
    PC0UW00.PC0UWDFL = " "; /* suppress hundreds place*/
  end

  if (PC0UW00.PC0UWNF1 == 0
   && PC0UW00.PC0UWNF2 == 0)
    PC0UW00.PC0UWDZ1 = " "; /* suppress tens place*/
  end

  if (PC0UW00.PC0UWNF1 == 0
   && PC0UW00.PC0UWNF2 == 0
   && PC0UW00.PC0UWNF3 == 0)
    PC0UW00.PC0UWDZ2 = " "; /* suppress tens place*/
  end

  if (PC0UW00.PC0UWNF1 == 0
   && PC0UW00.PC0UWNF2 == 0
   && PC0UW00.PC0UWNF3 == 0
   && PC0UW00.PC0UWDEF == "0")
    PC0UW00.PC0UWDEF = " "; /* suppress decimal*/
    PC0UW00.PC0UWDPT = " "; /* suppress decimal point*/
  end

  PC0UW00.PC0UWCHW = PC0UW00.PC0UWDNM; /* move to char field*/

end // end PC0U123

// Unstring integer field
Function PC0U124()

  if (PC0UW00.PC0UWNUM < 0)
    PC0UW00.PC0UWNEF = "Y";
    PC0UW00.PC0UWNUM = PC0UW00.PC0UWNUM * -1;
  else
    PC0UW00.PC0UWNEF = "N";
  end

  PC0UW00.PC0UWNIN = PC0UW00.PC0UWNFL; /* Get rid of decimal*/
  PC0UW00.PC0UWCHW = PC0UW00.PC0UWNIN; /* Move to character field*/

   /* Find first signigicant digit*/

  PC0UW00.PC0UWIX1 = 1;

  while (PC0UW00.PC0UWIX1 <= 7
   && PC0UW00.PC0UWCHA[PC0UWIX1] == "0")
    PC0UW00.PC0UWCHA[PC0UWIX1] = " ";
    PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
  end


  if (PC0UW00.PC0UWNEF == "Y") /* negative number*/
    PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 - 1;
    PC0UW00.PC0UWCHA[PC0UWIX1] = "-";
  end

  if (PC0UW00.PC0UWCHA[7] == " ")
    PC0UW00.PC0UWCHA[7] = "0";
  end
end // end PC0U124

// Unstring integer field
Function PC0U125()

  PC0UW00.PC0UWNN7 = PC0UW12.PC0UWQTY[PC0UWIXM];
  if (PC0UW00.PC0UWNN7 < 0)
    PC0UW00.PC0UWNEF = "Y";
    PC0UW00.PC0UWNN7 = PC0UW00.PC0UWNN7 * -1;
  else
    PC0UW00.PC0UWNEF = "N";
  end

  PC0UW00.PC0UWCHW = PC0UW00.PC0UWNN7; /* Move to character field*/

   /* Find first signigicant digit*/

  PC0UW00.PC0UWIX1 = 1;

  while (PC0UW00.PC0UWIX1 <= 7
   && PC0UW00.PC0UWCHA[PC0UWIX1] == "0")
    PC0UW00.PC0UWCHA[PC0UWIX1] = " ";
    PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
  end


  if (PC0UW00.PC0UWNEF == "Y") /* negative number*/
    PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 - 1;
    PC0UW00.PC0UWCHA[PC0UWIX1] = "-";
  end

  if (PC0UW00.PC0UWCHA[7] == " ")
    PC0UW00.PC0UWCHA[7] = "0";
  end
end // end PC0U125

// Check attention ID
Function PC0U130()


   /* ------------------------------------------------------------*/
   /* Clear Map on PA2*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pa2) /* PA2 was pressed*/
    converseLib.clearScreen();
     /* Clear the map fields*/
    PC0UM001.XXXPRCNM = "PC0U";
    exit stack; /* Exit to redisplay map*/
  end

   /* ------------------------------------------------------------*/
   /* If FAST PATH was requested, transfer to application.*/
   /* ------------------------------------------------------------*/

  if (PC0UM001.CATOAP > " ") /* FAST PATH was requested*/
    if (converseVar.eventKey is enter) /* ENTER was pressed*/
      set PCWREC empty;
      COMMAREA.CATOAP = PC0UM001.CATOAP; /* TO application*/
      COMMAREA.CAITEM = PC0UM001.CAITEM; /* TO application key*/
      XSPCS01();
      COMMAREA.CATOAP = "PC0A";
      PCWREC.XXXMSGNO = 191;
      XSPCS01();
    else
      PC0UM001.XXXPRCNM = "PC0U130"; /* Module identification*/
      converseLib.validationFailed(05); /* Enter must be used for fast path*/
      exit stack;
    end
  end

   /* ------------------------------------------------------------*/
   /* On PF4 transfer to MN0M(even if it's not on the screen)*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf4) /* Main menu requested*/
    set PCWREC empty;
    COMMAREA.CAITEM = " "; /* application from data*/
    COMMAREA.CATOAP = "MN0M";
    XSPCS01();
    PC0UM001.XXXPRCNM = "PC0U130";
    PC0UM001.VAGen_EZEMSG = COMMAREA.CAMSG; /* If bad transfer*/
    exit stack; /* Exit to redisplay map*/
  end

   /* ------------------------------------------------------------*/
   /* On PF5 transfer to FY0M(even if it's not on the screen)*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf5) /* Main menu requested*/
    set PCWREC empty;
    COMMAREA.CAITEM = " "; /* application from data*/
    COMMAREA.CATOAP = "FY0M";
    XSPCS01();
    PC0UM001.XXXPRCNM = "PC0U130";
    PC0UM001.VAGen_EZEMSG = COMMAREA.CAMSG; /* If bad transfer*/
    exit stack; /* Exit to redisplay map*/
  end
   /* ------------------------------------------------------------*/
   /* Validate scroll request if  PF 7 or PF8*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf7 /* Scroll back requested*/
   || converseVar.eventKey is pf8) /* Scroll forward requested*/

    PC0U131(); /* Validate scroll request*/

    return; /* Exit to next process*/
  end

  if (converseVar.eventKey is pf10 /* ETAL screen*/
   && PC0UW00.PC0UWDTF == "1")    
    PC0UM001.XXXPRCNM = "PC0U130";
    converseLib.validationFailed(04); /* Invalid PA/PF key*/
    exit stack;
  end

  if (converseVar.eventKey is pf11 /* S.O. screen*/
   && PC0UW00.PC0UWDTF == "2")    
    PC0UM001.XXXPRCNM = "PC0U130";
    converseLib.validationFailed(04); /* Invalid PA/PF key*/
    exit stack;
  end

   /* ------------------------------------------------------------------*/
   /* SHOW SAP NUMBER*/
   /* ------------------------------------------------------------------*/
  if (converseVar.eventKey is pf18
   && PC0UW00.PC0UWDTF == "3")
    PC0UM001.XXXPRCNM = "PC0U130";
    converseLib.validationFailed(04);
    exit stack; /* Invalid PA/PF Key*/
  end
   /* ------------------------------------------------------------*/
   /* Continue processing if following keys are pressed*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is enter /* TS0P*/
   || converseVar.eventKey is pf2   /* FOB*/
   || converseVar.eventKey is pf3   /* Detail*/
   || converseVar.eventKey is pf6   /* Special instructions*/
   || converseVar.eventKey is pf9   /* Size screen*/
   || converseVar.eventKey is pf10  /* ETAL screen*/
   || converseVar.eventKey is pf11  /* S.O. screen*/
   || converseVar.eventKey is pf12  /* Maintenance*/
   || converseVar.eventKey is pf14  /* Ship to*/
   || converseVar.eventKey is pf16  /* Trans*/
   || converseVar.eventKey is pf19  /* Select*/
   /* OR EZEAID IS PF20              /**/
   /* Print*/
   || converseVar.eventKey is pf18) /* SAP screen*/

    if (converseVar.eventKey is pf2 /* FOB*/
     && COMMAREA.CAILVL[10] == "N") /* ===> FOB  security*/
      /* ============= Next Sentence ==========>*/
    else
      return;
    end

  end
   /* ------------------------------------------------------------*/
   /* Purge temporary storage on PF21 and transer to PC0a*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf21) /* pf21 pressed*/

    PC0U111(); /* Purge temp storage*/
    set PCWREC empty;

    COMMAREA.CAITEM = " "; /* application from data*/
    COMMAREA.CATOAP = "PC0A";
    XSPCS01();
    PC0UM001.XXXPRCNM = "PC0U130";
    PC0UM001.VAGen_EZEMSG = COMMAREA.CAMSG; /* If bad transfer*/
    exit stack;
  end

   /* ------------------------------------------------------------*/
   /* Purge temporary storage on PF17 and transer to PC0l*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf17) /* pf17 pressed*/

    PC0U111(); /* Purge temp storage*/

    PCWREC.PC3POIDT = VPOHDR02.PC3POIDT;
    PCWREC.FY1FCTYC = VPOHDR02.FY1FCTYC;
    PCWREC.PO-REG-CD = VPOHDR02.PO-REG-CD;
    COMMAREA.CAITEM = " "; /* application from data*/
    COMMAREA.CATOAP = "PC0L";
    XSPCS01();
    PC0UM001.XXXPRCNM = "PC0U130";
    exit stack;
  end

   /* ------------------------------------------------------------*/
   /* Clear screen if PA1 or PA3 and exit to display map.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pa1 /* PA1 pressed*/
   || converseVar.eventKey is pa3) /* PA3 pressed*/
    set PC0UM001 initial; /* Clear the map fields*/
    exit stack; /* Exit to redisplay map*/
  end

   /* ------------------------------------------------------------*/
   /* At this point an invalid PF key has been pressed.*/
   /* ------------------------------------------------------------*/

  PC0UM001.XXXPRCNM = "PC0U130";
  converseLib.validationFailed(04); /* Invalid PA/PF key*/
  exit stack;


end // end PC0U130

// Validate scroll request
Function PC0U131()



   /* ------------------------------------------------------------*/
   /* If scroll back was requested, ensure that pages exist.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf7 /* Scroll back request*/
   && PC0UW00.PC0UWTSP < 2)       /* and no previous pages*/

    PC0UM001.XXXPRCNM = "PC0U131"; /* Module identification*/
    converseLib.validationFailed(2); /* No previous page to display*/

  end

   /* ------------------------------------------------------------*/
   /* If scroll forward was requested, ensure that pages exist.*/
   /* ------------------------------------------------------------*/



  if (converseVar.eventKey is pf8 /* Scroll forward request*/
   && PC0UW00.PC0UWTSP >= PC0UW00.TA5TSQIX) /* and no more pages*/

    PC0UM001.XXXPRCNM = "PC0U131"; /* Module identification*/
    converseLib.validationFailed(3); /* No more pages to display*/

  end

  if (converseVar.validationMsgNum != 0) /* Errors were found*/
    exit stack;
  end



end // end PC0U131

// Reset highlighted fields
Function PC0U140()

  PC0UW00.PC0UWIXM = 1; /* Initialize map index*/

  while (PC0UW00.PC0UWIXM <= PC0UW00.PC0UWMAX /* Max lines*/
   && PC0UW12.PC0UW12K[PC0UWIXM] != 0)

    if (PC0UW12.PC0UW12K[PC0UWIXM] == 2  /* Plan data key*/
     || PC0UW12.PC0UW12K[PC0UWIXM] == 3  /* shipping data key*/
     || PC0UW12.PC0UW12K[PC0UWIXM] == 22 /* Plan data*/
     || PC0UW12.PC0UW12K[PC0UWIXM] == 30) /* Plan data*/
      set PC0UM001.PC0UMSEL[PC0UWIXM] normal; /* Allow entry*/
    else
      set PC0UM001.PC0UMSEL[PC0UWIXM] initialAttributes; /* Protect and darken*/

    end
    PC0UW00.PC0UWIXM = PC0UW00.PC0UWIXM + 1;
  end

  if (PC0UW00.PC0UWPDF == "Y" /* Protect entered date*/
   || PC0UW00.PC0UWXDF == "Y") /* Restrict entered date*/
    set PC0UM001.PC0UMLIT skip, invisible;
    set PC0UM001.PC0UMETO skip, invisible;
  else
    set PC0UM001.PC0UMLIT initialAttributes;
    set PC0UM001.PC0UMETO initialAttributes;
  end

end // end PC0U140

// Verify entered data
Function PC0U150()


   /* ----------------------------------------------------*/
   /* If ETALo override date has been entered validate*/
   /* it using TA0040.*/
   /* ----------------------------------------------------*/

  if (PC0UM001.PC0UMETO != " ") /* Etal override entered*/
    if (PC0UM001.PC0UMETO != PC0UW01.PC0UWETO) /* Etal override changed*/

      set TA2REC empty;

      TA2REC.TA2GRGA = PC0UM001.PC0UMETO; /* mmddyy format*/

      PC0US37(); /* Validate date*/

      if (TA2REC.TA2RTNCD == 0) /* Good return good*/
        PC0UW00.TSIETALO = TA2REC.TA2GRGGN; /* ETALO CCYYMMDD*/
        PC0UW01.PC0UWETO = PC0UM001.PC0UMETO;
      else
        set PC0UM001.PC0UMETO cursor, bold;
        converseLib.validationFailed(38); /* Invalid date*/
        exit stack;
      end
    end
  else
    PC0UW00.TSIETALO = 0;
    PC0UW01.PC0UWETO = " ";
  end

   /* ----------------------------------------------------*/
   /* Validate for PF12 (multiple lines can be selected)*/
   /* The entered value must be an 's'.*/
   /* Only plan lines can be selected.*/
   /* ----------------------------------------------------*/

  PC0UW00.PC0UWIXM = PC0UW00.PC0UWMAX; /* Initialize map index*/
  PC0UW00.PC0UWCNT = 0; /* Field to count select codes*/

  if (converseVar.eventKey is pf12) /* PC0K (product inq/maint)*/

    while (PC0UW00.PC0UWIXM >= 1)
      if (PC0UM001.PC0UMSEL[PC0UWIXM] != " ")
        if (PC0UM001.PC0UMSEL[PC0UWIXM] != "S")
          set PC0UM001.PC0UMSEL[PC0UWIXM] cursor, bold;
          PC0UM001.XXXPRCNM = "PC0U150";
          converseLib.validationFailed(13);
        else
          PC0UW00.PC0UWCNT = PC0UW00.PC0UWCNT + 1;
          if (PC0UW12.PC0UW12K[PC0UWIXM] != 2
           && PC0UW12.PC0UW12K[PC0UWIXM] != 22
           && PC0UW12.PC0UW12K[PC0UWIXM] != 30)
            set PC0UM001.PC0UMSEL[PC0UWIXM] cursor, bold;
            PC0UM001.XXXPRCNM = "PC0U150";
            converseLib.validationFailed(166); /* Only plan line can be selected*/
          end
        end
      end
      PC0UW00.PC0UWIXM = PC0UW00.PC0UWIXM - 1;
    end
    if (PC0UW00.PC0UWCNT == 0)
      set PC0UM001.PC0UMSEL[1] cursor;
      PC0UM001.XXXPRCNM = "PC0U150";
      converseLib.validationFailed(25); /* Please select a line*/
    end
    if (converseVar.validationMsgNum == 0)
      return;
    else
      exit stack;
    end
  end

   /* ----------------------------------------------------*/
   /* Validate for PF14 or PF6*/
   /* Only one plan can be selected).*/
   /* The entered value must be an 'S'.*/
   /* ----------------------------------------------------*/


  PC0UW00.PC0UWCNT = 0; /* Field to count select codes*/

  if (converseVar.eventKey is pf14 /* PC0D (Item ship-to)*/
   || converseVar.eventKey is pf6) /* PC0H (Item special instruction)*/

    while (PC0UW00.PC0UWIXM >= 1)
      if (PC0UM001.PC0UMSEL[PC0UWIXM] == "S")
        PC0UW00.PC0UWCNT = PC0UW00.PC0UWCNT + 1;
        PC0UW00.PC0UWIX1 = 1; /* Init second index*/
        while (PC0UW00.PC0UWIX1 <= PC0UW00.PC0UWMAX) /* Max lines*/
          if (PC0UM001.PC0UMSEL[PC0UWIXM] == PC0UM001.PC0UMSEL[PC0UWIX1]
           && PC0UW00.PC0UWIXM != PC0UW00.PC0UWIX1)
            set PC0UM001.PC0UMSEL[PC0UWIXM] cursor, bold;
            PC0UM001.XXXPRCNM = "PC0U150";
            converseLib.validationFailed(144); /* Only one line can be selected*/
          end
          if (PC0UW12.PC0UW12K[PC0UWIXM] != 2
           && PC0UW12.PC0UW12K[PC0UWIXM] != 22
           && PC0UW12.PC0UW12K[PC0UWIXM] != 30)
            set PC0UM001.PC0UMSEL[PC0UWIXM] cursor, bold;
            PC0UM001.XXXPRCNM = "PC0U150";
            converseLib.validationFailed(109); /* Only plan line can be selected*/
          end
          PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
        end
        if (PC0UW12.PC0UW12K[PC0UWIXM] != 2
         && PC0UW12.PC0UW12K[PC0UWIXM] != 22
         && PC0UW12.PC0UW12K[PC0UWIXM] != 30)
          set PC0UM001.PC0UMSEL[PC0UWIXM] cursor, bold;
          PC0UM001.XXXPRCNM = "PC0U150";
          converseLib.validationFailed(166); /* Only plan line can be selected*/
        end
      else
        if (PC0UM001.PC0UMSEL[PC0UWIXM] != " ")
          set PC0UM001.PC0UMSEL[PC0UWIXM] cursor, bold;
          PC0UM001.XXXPRCNM = "PC0U150";
          converseLib.validationFailed(13); /* S'elect code must be S*/
        end
      end
      PC0UW00.PC0UWIXM = PC0UW00.PC0UWIXM - 1;
    end
    if (PC0UW00.PC0UWCNT == 0)
      set PC0UM001.PC0UMSEL[1] cursor;
      PC0UM001.XXXPRCNM = "PC0U150";
      converseLib.validationFailed(25); /* Please select a line*/
    end
    if (converseVar.validationMsgNum == 0)
      return;
    else
      exit stack;
    end
  end

   /* ----------------------------------------------------*/
   /* Validate that ETALO date has not been entered*/
   /* if PF7 or PF8 have been pressed.*/
   /* ----------------------------------------------------*/

  if (converseVar.eventKey is pf7
   || converseVar.eventKey is pf8)
    if (PC0UW01.PC0UWETO != " ") /* ETALO date has been entered*/
      PC0UM001.XXXPRCNM = "PC0U150";
      converseLib.validationFailed(284); /* No scrolling when date entered*/
      exit stack;
    end
  end


   /* ----------------------------------------------------*/
   /* Validate for PF16 (Check for security on update)*/
   /* Validate for PF16 (only one 'shipping' line can be*/
   /* selected.) The entered value must be an 'S'*/
   /* ----------------------------------------------------*/

  if (converseVar.eventKey is pf16) /* Update ETALO date*/
    if (PC0UW00.PC0UWPDF == "Y") /* Protect date flag*/
      converseLib.validationFailed(29); /* User does not have update authority*/
      PC0UM001.XXXPRCNM = "PC0U150";
      exit stack;
    end
    if (PC0UW00.PC0UWXDF == "Y") /* Protect date flag*/
      converseLib.validationFailed(321); /* User does not have update authority*/
      PC0UM001.XXXPRCNM = "PC0U150";
      exit stack;
    end
  end

  PC0UW00.PC0UWIX3 = 0;

  if (converseVar.eventKey is pf16) /* Update ETALO date*/
    if (PC0UW01.PC0UWETO != " ") /* Etal override entered*/

      PC0UW00.PC0UWIXM = PC0UW00.PC0UWMAX;
      while (PC0UW00.PC0UWIXM >= 1)
        if (PC0UM001.PC0UMSEL[PC0UWIXM] == "S")
          PC0UW00.PC0UWCNT = PC0UW00.PC0UWCNT + 1;
          PC0UW00.PC0UWIX1 = 1; /* Init second index*/
          while (PC0UW00.PC0UWIX1 <= PC0UW00.PC0UWMAX) /* Max lines*/
            if (PC0UM001.PC0UMSEL[PC0UWIXM] == PC0UM001.PC0UMSEL[PC0UWIX1]
             && PC0UW00.PC0UWIXM != PC0UW00.PC0UWIX1)
              set PC0UM001.PC0UMSEL[PC0UWIXM] cursor, bold;
              converseLib.validationFailed(144); /* Only one line can be selected*/
            end
            PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
          end
          if (PC0UW12.PC0UW12K[PC0UWIXM] == 3
           || PC0UW12.PC0UW12K[PC0UWIXM] == 18)
            PC0UW00.PC0UWIX3 = PC0UW00.PC0UWIXM;
          end
          if (PC0UW12.PC0UW12K[PC0UWIXM] != 3
           && PC0UW12.PC0UW12K[PC0UWIXM] != 18)
            set PC0UM001.PC0UMSEL[PC0UWIXM] cursor, bold;
            converseLib.validationFailed(109); /* Only shipping line can be selected*/
          end
        else
          if (PC0UM001.PC0UMSEL[PC0UWIXM] != " ")
            set PC0UM001.PC0UMSEL[PC0UWIXM] cursor, bold;
            converseLib.validationFailed(13); /* S'elect code must be S*/
          else
            if (PC0UW12.PC0UW12K[PC0UWIXM] == 3
             || PC0UW12.PC0UW12K[PC0UWIXM] == 18)
              PC0UW00.PC0UWIX3 = PC0UW00.PC0UWIXM;
            end
          end
        end
        PC0UW00.PC0UWIXM = PC0UW00.PC0UWIXM - 1;
      end
      if (PC0UW00.PC0UWCNT == 0)
        if (PC0UW00.PC0UWIX3 != 0)
          set PC0UM001.PC0UMSEL[PC0UWIX3] cursor;
        end
        converseLib.validationFailed(321); /* Please select a line*/
      end
      if (converseVar.validationMsgNum == 0)
        return;
      else
        PC0UM001.XXXPRCNM = "PC0U150";
        exit stack;
      end
    else /* PF16 pressed no ETALO date entered*/
      converseLib.validationFailed(283); /* MUst enter ETAL override date for*/
                                   /* update*/
      PC0UM001.XXXPRCNM = "PC0U150";
      set PC0UM001.PC0UMETO cursor, bold;
      exit stack;
    end

  end

   /* ----------------------------------------------------*/
   /* Validate for enter if a shipping line has been*/
   /* selected. The entered value must be an 'S'*/
   /* and only one line can be selected.*/
   /* ----------------------------------------------------*/

  if (converseVar.eventKey is enter) /* TS0P (Product inquiry)*/

    while (PC0UW00.PC0UWIXM >= 1)
      if (PC0UM001.PC0UMSEL[PC0UWIXM] == "S")
        PC0UW00.PC0UWCNT = PC0UW00.PC0UWCNT + 1;
        PC0UW00.PC0UWIX1 = 1; /* Init second index*/
        while (PC0UW00.PC0UWIX1 <= PC0UW00.PC0UWMAX) /* Max lines (13)*/
          if (PC0UM001.PC0UMSEL[PC0UWIXM] == PC0UM001.PC0UMSEL[PC0UWIX1]
           && PC0UW00.PC0UWIXM != PC0UW00.PC0UWIX1)
            set PC0UM001.PC0UMSEL[PC0UWIXM] cursor, bold;
            PC0UM001.XXXPRCNM = "PC0U150";
            converseLib.validationFailed(144); /* Only one line can be selected*/
          end
          PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
        end
        if (PC0UW12.PC0UW12K[PC0UWIXM] != 3
         && PC0UW12.PC0UW12K[PC0UWIXM] != 18)
          set PC0UM001.PC0UMSEL[PC0UWIXM] cursor, bold;
          PC0UM001.XXXPRCNM = "PC0U150";
          converseLib.validationFailed(109); /* Only shipping line can be selected*/
        end
      else
        if (PC0UM001.PC0UMSEL[PC0UWIXM] != " ")
          set PC0UM001.PC0UMSEL[PC0UWIXM] cursor, bold;
          PC0UM001.XXXPRCNM = "PC0U150";
          converseLib.validationFailed(13); /* S'elect code must be S*/
        end
      end
      PC0UW00.PC0UWIXM = PC0UW00.PC0UWIXM - 1;
    end
    if (converseVar.validationMsgNum == 0)
      return;
    else
      exit stack;
    end
  end

end // end PC0U150

// Process valid input
Function PC0U160()

   /* ----------------------------------------------------*/
   /* If PF7 or PF8 has been pressed increment or*/
   /* decrement the page requested and return to the*/
   /* calling process.*/
   /* ----------------------------------------------------*/

  if (converseVar.eventKey is pf7)
    PC0UW00.PC0UWTSP = PC0UW00.PC0UWTSP - 1;
    return;
  end

  if (converseVar.eventKey is pf8)
    PC0UW00.PC0UWTSP = PC0UW00.PC0UWTSP + 1;
    return;
  end


   /* ----------------------------------------------------*/
   /* If PF9 has been pressed set the screen flag*/
   /* to map 2.*/
   /* ----------------------------------------------------*/

  if (converseVar.eventKey is pf9) /* Size screen requested*/
    PC0UW00.PC0UWSRF = "2";
    PC0UW00.PC0UWOSD = "Y"; /* Obtain size data flag*/
    exit stack;
  end

   /* ----------------------------------------------------*/
   /* If PF10 has been pressed set the screen flag*/
   /* to map ETAL screen*/
   /* ----------------------------------------------------*/

  if (converseVar.eventKey is pf10) /* Size screen requested*/
    PC0UW00.PC0UWSRF = "1";
    PC0UW00.PC0UWDTF = "1"; /* Data flag*/
    PC0UW00.PC0UWODF = "Y"; /* Obtain data flag*/
    exit stack;
  end

   /* -----------------------------------------------------*/
   /* If PF18 has been pressed set the screen flag*/
   /* to map SAP  screen*/
   /* -----------------------------------------------------*/
  if (converseVar.eventKey is pf18) /* Size screen requested*/
    PC0UW00.PC0UWSRF = "1";
    PC0UW00.PC0UWDTF = "3"; /* Data flag*/
    PC0UW00.PC0UWODF = "Y"; /* Obtain data flag*/
    exit stack;
  end
   /* ----------------------------------------------------*/
   /* If PF11 has been pressed set the screen flag*/
   /* to map S.O. screen*/
   /* ----------------------------------------------------*/

  if (converseVar.eventKey is pf11) /* Size screen requested*/
    PC0UW00.PC0UWSRF = "1";
    PC0UW00.PC0UWDTF = "2"; /* Data flag*/
    PC0UW00.PC0UWODF = "Y"; /* Obtain data flag*/
    exit stack;
  end


   /* ----------------------------------------------------*/
   /* If PF3 or PF19 have been pressed transfer back*/
   /* to the initially calling application (list screen)*/
   /* On a pf3 leave the pcwrec intact--on PF19 clear*/
   /* the pcwrec.*/
   /* ----------------------------------------------------*/

  if (converseVar.eventKey is pf3) /* List screen requested*/
    PC0U111(); /* Purge temp storage*/
    COMMAREA.CAITEM = " "; /* Application from data*/
    COMMAREA.CATOAP = PC0UW13.CAFROMAP; /* To Application*/
    COMMAREA.CAUSERA = PCWREC.CAUSERA;
    XSPCS01();
  end

  if (converseVar.eventKey is pf19) /* Select screen requested*/

    PC0U111(); /* Purge temp storage*/

    COMMAREA.CAITEM = " "; /* Application from data*/
    set PCWREC empty;
    PCWREC.XGPCD = COMMAREA.XGPCD;
    COMMAREA.CAUSERA = PCWREC.CAUSERA;
    COMMAREA.CATOAP = PC0UW13.CAFROMAP; /* To Application*/
    XSPCS01();
  end

   /* ----------------------------------------------------*/
   /* If PF20 is pressed load data and call Trec and*/
   /* ----------------------------------------------------*/

  /* IF EZEAID IS PF20;               /* Print requested*/
  /* ;*/
  /* PERFORM PC0U500;               /* ===> Set-up and print T.S. through*/
                                   /* TA0P*/
  /* EZEFLO;*/
  /* ;*/
  /* END;*/


   /* ----------------------------------------------------*/
   /* If any intransit line has been selected the enter*/
   /* key means a transfer to TSOP.*/
   /* ----------------------------------------------------*/

   /* Check for intransit line selected*/
   /* Save index value of intransit line if one is found*/

  PC0UW00.PC0UWIX1 = 1; /* Init index*/
  PC0UW00.PC0UWIX4 = 0; /* Init transporation select index*/

  while (PC0UW00.PC0UWIX1 <= PC0UW00.PC0UWMAX)
    if (PC0UM001.PC0UMSEL[PC0UWIX1] == "S"
     && PC0UW12.PC0UW12K[PC0UWIX1] == 3) /* Intransit line*/
      PC0UW00.PC0UWIX4 = PC0UW00.PC0UWIX1;
    end
    PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
  end

  if (converseVar.eventKey is enter /* Enter was pressed*/
   && PC0UW00.PC0UWCNT == 0)        /* intransit line not selected*/
    return;
  end

   /* ----------------------------------------------------*/
   /* If PF16 update the ETALO date and temp storage*/
   /* and reload temp storage.*/
   /* ----------------------------------------------------*/

  if (converseVar.eventKey is pf16) /* Update ETALO date*/

    PC0US38(); /* Update Dtrans.VCPLHD01*/


    TA5REC.TA5TSQIX = 0;

    exit stack;

  end

   /* ----------------------------------------------------*/
   /* The remaining attention keys will execute a*/
   /* transfer. The following code is generic for all.*/
   /* ----------------------------------------------------*/


  PC0UW13.PC0UWTSP = PC0UW00.PC0UWTSP;
  PC0UW13.XGPCD = PCWREC.XGPCD;
  PC0UW13.PO-REG-CD = PCWREC.PO-REG-CD;
  PC0UW13.PC3PONBR = PCWREC.PC3PONBR;
  PC0UW13.YSMXDV = PCWREC.YSMXDV;
  PC0UW13.SY1STNBR = PCWREC.SY1STNBR;
  PC0UW13.SY2CLRID = PCWREC.SY2CLRID;
  PC0UW13.XDMCD = PCWREC.XDMCD;
  PC0UW13.XQACD = PCWREC.XQACD;
  PC0UW13.XOWCD = PCWREC.XOWCD;
  PC0UW13.XPGCD = PCWREC.XPGCD;
  PC0UW13.XUMCD = PCWREC.XUMCD;


  if (PCWREC.CAFROMAP[1] == " ")

    PCWREC.CAFROMAP[1] = "PC0U"; /* From application id*/
    PCWREC.PCWUSER1 = PC0UW13.PC0UWUSR;

  else
    if (PCWREC.CAFROMAP[2] == " ")

      PCWREC.CAFROMAP[2] = "PC0U"; /* From application id*/
      PCWREC.PCWUSER2 = PC0UW13.PC0UWUSR;
    else
      if (PCWREC.CAFROMAP[3] == " ")
        PCWREC.CAFROMAP[3] = "PC0U"; /* From application id*/
        PCWREC.PCWUSER3 = PC0UW13.PC0UWUSR;
      else
        if (PCWREC.CAFROMAP[4] == " ")
          PCWREC.CAFROMAP[4] = "PC0U"; /* From application id*/
          PCWREC.PCWUSER4 = PC0UW13.PC0UWUSR;

        end
      end
    end
  end


  PC0UW00.PC0UWIXM = 1; /* Initialize screen index*/


  COMMAREA.CAITEM = " "; /* Application from data*/

   /* ----------------------------------------------------*/
   /* If PF2 move style number to the PCWREC*/
   /* ----------------------------------------------------*/

  if (converseVar.eventKey is pf2) /* FOB*/

    PC0U111(); /* Purge temp storage*/
    PCWREC.SY1STNBR = PC0UM001.SY1STNBR;

    COMMAREA.CATOAP = "PC07"; /* To Application*/
    COMMAREA.CAUSERA = PCWREC.CAUSERA;
    XSPCS01();
  end



   /* ----------------------------------------------------*/
   /* If PF6 move the selected item sequence number to*/
   /* the first position in the PCWREC items sequence*/
   /* array and the item sequence number field.*/
   /* ----------------------------------------------------*/

  if (converseVar.eventKey is pf6) /* Item special instruction selected*/


    while (PC0UW00.PC0UWIXM <= PC0UW00.PC0UWMAX) /* Max lines*/

      if (PC0UM001.PC0UMSEL[PC0UWIXM] == "S")
        PCWREC.PC6ITMNB = PC0UW12.PC6ITMNB[PC0UWIXM];
        PC0US36(); /* Get item*/
      end

      PC0UW00.PC0UWIXM = PC0UW00.PC0UWIXM + 1;
    end

    PC0U111(); /* Purge temp storage*/
    PCWREC.PCWFNC = "I"; /* Function passed*/
    COMMAREA.CATOAP = "PC0I"; /* To Application*/
    COMMAREA.CAUSERA = PCWREC.CAUSERA;
    XSPCS01();
  end


   /* ----------------------------------------------------*/
   /* If PF14 move the selected item sequence number to*/
   /* the first position in the PCWREC items sequence*/
   /* array and the item sequence number field.*/
   /* ----------------------------------------------------*/

  if (converseVar.eventKey is pf14) /* Item ship to requested*/

    while (PC0UW00.PC0UWIXM <= PC0UW00.PC0UWMAX) /* Max lines*/

      if (PC0UM001.PC0UMSEL[PC0UWIXM] == "S")
        PCWREC.PC6ITMNB[1] = PC0UW12.PC6ITMNB[PC0UWIXM];
        PC0US36(); /* Get item*/

      end

      PC0UW00.PC0UWIXM = PC0UW00.PC0UWIXM + 1;
    end

    PC0U111(); /* Purge temp storage*/
    COMMAREA.CATOAP = "PC05"; /* To Application*/
    PCWREC.PCWFNC = "I";
    XSPCS01();
  end

   /* ----------------------------------------------------*/
   /* If PF12 move the selected item sequence number to*/
   /* the first position in the PCWREC items sequence*/
   /* array.*/
   /* ----------------------------------------------------*/

  if (converseVar.eventKey is pf12) /* Product inquiry maintenance*/

    PC0UW00.PC0UWIX1 = 1; /* Init work index*/

    while (PC0UW00.PC0UWIXM <= PC0UW00.PC0UWMAX) /* Max lines*/

      if (PC0UM001.PC0UMSEL[PC0UWIXM] == "S")
        PCWREC.PC6ITMNB[PC0UWIX1] = PC0UW12.PC6ITMNB[PC0UWIXM];
        PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
      end

      PC0UW00.PC0UWIXM = PC0UW00.PC0UWIXM + 1;
    end

    if (PCWREC.PC3PONBR > 299999
     && PCWREC.PC3PONBR < 700000)

      PC0U111(); /* Purge temp storage*/
      COMMAREA.CATOAP = "PC0K"; /* To Application*/
      PCWREC.PCWFNC = "C"; /* Function passed*/
      XSPCS01();
    else
      PC0UM001.XXXPRCNM = "PC0U160"; /* process name*/
      converseLib.validationFailed(509); /* out of range*/
      PC0UW00.PC0UWIX1 = 1; /* Init work index*/

      while (PC0UW00.PC0UWIXM <= PC0UW00.PC0UWMAX) /* Max lines*/

        if (PC0UM001.PC0UMSEL[PC0UWIXM] == "S")
          PCWREC.PC6ITMNB[PC0UWIX1] = PC0UW12.PC6ITMNB[PC0UWIXM];
          PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
        end
        PC0UW00.PC0UWIXM = PC0UW00.PC0UWIXM + 1;
      end
      return;
    end
  end

   /* ----------------------------------------------------*/
   /* If PF16 move the selected item sequence number to*/
   /* the first position in the PCWREC items sequence*/
   /* array and the item sequence number field.*/
   /* ----------------------------------------------------*/

  if (converseVar.eventKey is enter) /* Product inquiry*/

    while (PC0UW00.PC0UWIXM <= PC0UW00.PC0UWMAX) /* Max lines*/

      if (PC0UW12.PC0UW12K[PC0UWIXM] == 2) /* Style/color line*/
        PC0UW02.PC0UW02G = PC0UW12.PC0UW12R[PC0UWIXM];
      end

      if (PC0UW12.PC0UW12K[PC0UWIXM] == 22) /* Style/color line*/
        PC0UW22.PC0UW02G = PC0UW12.PC0UW12R[PC0UWIXM];
      end

      if (PC0UM001.PC0UMSEL[PC0UWIXM] == "S")
        PCWREC.PC6ITMNB[PC0UWIX1] = PC0UW12.PC6ITMNB[PC0UWIXM];
        PC0US50(); /* ===> set PCWREC fields*/
      end

      PC0UW00.PC0UWIXM = PC0UW00.PC0UWIXM + 1;
    end

    PC0U111(); /* Purge temp storage*/
    COMMAREA.CATOAP = "TS0P"; /* To Application*/
    XSPCS01();
  end

   /* ----------------------------------------------------*/
   /* Executed only on bad transfer*/
   /* ----------------------------------------------------*/

  if (converseVar.validationMsgNum > 0)
    PC0UM001.XXXPRCNM = "PC0U160";
    exit stack; /* Exit to redisplay map*/
  end

end // end PC0U160

// Map 2 processing
Function PC0U200()
   /* ------------------------------------------------------------*/
   /* This is the main process used to display a map.  Processing*/
   /* always returns to the top of this process and falls through*/
   /* subordinate processes until an error is found or a valid*/
   /* request is processed.  Processing sequence is as follows:*/

   /* 1) Obtain data to display*/
   /* 2) Format the map output area and display the map.*/
   /* 3) Check the attention identifier used to respond.*/
   /* 4) Reset highlighted fields*/
   /* 5) Validate data*/
   /* 6) Process valid input request*/

   /* In all subordinate processes, "EZEFLO" is used to exit to*/
   /* redisplay the map when an error is found.  This is done to*/
   /* minimize the coding effort required to skip subsequent*/
   /* processing under error conditions.*/
   /* ------------------------------------------------------------*/


  PC0U210(); /* Obtain data to display*/

  PC0U220(); /* Format and display the map*/

  PC0U230(); /* Check attention identifier*/

  PC0U240(); /* Reset highlighted fields*/

  PC0U250(); /* Validate data*/

  PC0U260(); /* Process valid input request*/

end // end PC0U200

// Obtain data to display
Function PC0U210()

  if (PC0UW00.PC0UWOSD == "N")
                                   /* Set up for size display not requested*/
    return;
  end


   /* ------------------------------------------------------------*/
   /* Count the number of 'y' entries in the working storage*/
   /* size table flag to determine how many pages of sizes*/
   /* are to be displayed (scrolling right and left).*/
   /* ------------------------------------------------------------*/

  PC0UW00.PC0UWSPG = 0; /* Initialize size page flag*/

  PC0UW00.PC0UWIX1 = 1; /* Initialize index*/
  PC0UW00.PC0UWIX2 = 0; /* Initialize index*/

  while (PC0UW00.PC0UWIX1 <= 40)
    if (PC0UW00.PC0UWSTB[PC0UWIX1] == "Y")
      PC0UW00.PC0UWIX2 = PC0UW00.PC0UWIX2 + 1;
    end
    PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
  end

   /* ------------------------------------------------------------*/
   /* Divide the size page field (which has 2 decimal positions)*/
   /* by 10 to obtain the whole number of pages (if less than*/
   /* 0 then there is only 1 page).  If the decimal field is*/
   /* not equal to zeros add 1 to number of pages.*/
   /* ------------------------------------------------------------*/

  PC0UW00.PC0UWCNP = PC0UW00.PC0UWIX2 / 4;

  if (PC0UW00.PC0UWCNP < 0)
    PC0UW00.PC0UWSPG = 1;
  else
    PC0UW00.PC0UWSPG = PC0UW00.PC0UWCNP;
    if (PC0UW00.PC0UWDEC != 0)
      PC0UW00.PC0UWSPG = PC0UW00.PC0UWSPG + 1;
    end
  end


   /* ------------------------------------------------------------*/
   /* Determine the first size field with quantities*/
   /* ------------------------------------------------------------*/

  PC0UW00.PC0UWIX1 = 1; /* Initialize work index*/

  while (PC0UW00.PC0UWIX1 <= 40
   && PC0UW00.PC0UWSTB[PC0UWIX1] == " ")

    PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
  end

  PC0UW00.PC0UWFSI = PC0UW00.PC0UWIX1; /* Set first size index*/

   /* ------------------------------------------------------------*/
   /* Determine the last size field with quantities*/
   /* ------------------------------------------------------------*/


  while (PC0UW00.PC0UWIX1 <= 40)
    if (PC0UW00.PC0UWSTB[PC0UWIX1] == "Y")

      PC0UW00.PC0UWLSI = PC0UW00.PC0UWIX1;
    end
    PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
  end

   /* ------------------------------------------------------------*/
   /* Determine the starting position in the table for each of*/
   /* the pages (this will be used as an index for loading the*/
   /* size quantities to the map and will be indexed by the*/
   /* pc0uwcsp field which is the current size page).*/
   /* ------------------------------------------------------------*/

   /* First page*/

  PC0UW00.PC0UWSPI[1] = PC0UW00.PC0UWFSI;


   /* Second page*/

   /* Set the index to the first size position in the table*/

  PC0UW00.PC0UWIX1 = PC0UW00.PC0UWFSI;
  PC0UW00.PC0UWIX2 = 1;

  while (PC0UW00.PC0UWIX2 <= 4
   && PC0UW00.PC0UWIX1 <= PC0UW00.PC0UWLSI)

    if (PC0UW00.PC0UWSTB[PC0UWIX1] == "Y")

      PC0UW00.PC0UWIX2 = PC0UW00.PC0UWIX2 + 1;
    end

    PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
  end

  if (PC0UW00.PC0UWIX1 <= PC0UW00.PC0UWLSI)
    PC0UW00.PC0UWSPI[2] = PC0UW00.PC0UWIX1;
  end


   /* Third page*/

  PC0UW00.PC0UWIX2 = 1;

  while (PC0UW00.PC0UWIX2 <= 4
   && PC0UW00.PC0UWIX1 <= PC0UW00.PC0UWLSI)

    if (PC0UW00.PC0UWSTB[PC0UWIX1] == "Y")

      PC0UW00.PC0UWIX2 = PC0UW00.PC0UWIX2 + 1;
    end

    PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
  end

  if (PC0UW00.PC0UWIX1 <= PC0UW00.PC0UWLSI)
    PC0UW00.PC0UWSPI[3] = PC0UW00.PC0UWIX1;
  end


   /* Fourth page*/

  PC0UW00.PC0UWIX2 = 1;

  while (PC0UW00.PC0UWIX2 <= 4
   && PC0UW00.PC0UWIX1 <= PC0UW00.PC0UWLSI)

    if (PC0UW00.PC0UWSTB[PC0UWIX1] == "Y")

      PC0UW00.PC0UWIX2 = PC0UW00.PC0UWIX2 + 1;
    end

    PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
  end

  if (PC0UW00.PC0UWIX1 <= PC0UW00.PC0UWLSI)
    PC0UW00.PC0UWSPI[4] = PC0UW00.PC0UWIX1;
  end


   /* fifth page*/

  PC0UW00.PC0UWIX2 = 1;

  while (PC0UW00.PC0UWIX2 <= 4
   && PC0UW00.PC0UWIX1 <= PC0UW00.PC0UWLSI)

    if (PC0UW00.PC0UWSTB[PC0UWIX1] == "Y")

      PC0UW00.PC0UWIX2 = PC0UW00.PC0UWIX2 + 1;
    end

    PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
  end

  if (PC0UW00.PC0UWIX1 <= PC0UW00.PC0UWLSI)
    PC0UW00.PC0UWSPI[5] = PC0UW00.PC0UWIX1;
  end


   /* sixth page*/

  PC0UW00.PC0UWIX2 = 1;

  while (PC0UW00.PC0UWIX2 <= 4
   && PC0UW00.PC0UWIX1 <= PC0UW00.PC0UWLSI)

    if (PC0UW00.PC0UWSTB[PC0UWIX1] == "Y")

      PC0UW00.PC0UWIX2 = PC0UW00.PC0UWIX2 + 1;
    end

    PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
  end

  if (PC0UW00.PC0UWIX1 <= PC0UW00.PC0UWLSI)
    PC0UW00.PC0UWSPI[6] = PC0UW00.PC0UWIX1;
  end

   /* Seventh page*/

  PC0UW00.PC0UWIX2 = 1;

  while (PC0UW00.PC0UWIX2 <= 4
   && PC0UW00.PC0UWIX1 <= PC0UW00.PC0UWLSI)

    if (PC0UW00.PC0UWSTB[PC0UWIX1] == "Y")

      PC0UW00.PC0UWIX2 = PC0UW00.PC0UWIX2 + 1;
    end

    PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
  end

  if (PC0UW00.PC0UWIX1 <= PC0UW00.PC0UWLSI)
    PC0UW00.PC0UWSPI[7] = PC0UW00.PC0UWIX1;
  end

   /* eight page*/

  PC0UW00.PC0UWIX2 = 1;

  while (PC0UW00.PC0UWIX2 <= 4
   && PC0UW00.PC0UWIX1 <= PC0UW00.PC0UWLSI)

    if (PC0UW00.PC0UWSTB[PC0UWIX1] == "Y")

      PC0UW00.PC0UWIX2 = PC0UW00.PC0UWIX2 + 1;
    end

    PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
  end

  if (PC0UW00.PC0UWIX1 <= PC0UW00.PC0UWLSI)
    PC0UW00.PC0UWSPI[8] = PC0UW00.PC0UWIX1;
  end

   /* ninth page*/

  PC0UW00.PC0UWIX2 = 1;

  while (PC0UW00.PC0UWIX2 <= 4
   && PC0UW00.PC0UWIX1 <= PC0UW00.PC0UWLSI)

    if (PC0UW00.PC0UWSTB[PC0UWIX1] == "Y")

      PC0UW00.PC0UWIX2 = PC0UW00.PC0UWIX2 + 1;
    end

    PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
  end

  if (PC0UW00.PC0UWIX1 <= PC0UW00.PC0UWLSI)
    PC0UW00.PC0UWSPI[9] = PC0UW00.PC0UWIX1;
  end

   /* tenth page*/

  PC0UW00.PC0UWIX2 = 1;

  while (PC0UW00.PC0UWIX2 <= 4
   && PC0UW00.PC0UWIX1 <= PC0UW00.PC0UWLSI)

    if (PC0UW00.PC0UWSTB[PC0UWIX1] == "Y")

      PC0UW00.PC0UWIX2 = PC0UW00.PC0UWIX2 + 1;
    end

    PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
  end

  if (PC0UW00.PC0UWIX1 <= PC0UW00.PC0UWLSI)
    PC0UW00.PC0UWSPI[10] = PC0UW00.PC0UWIX1;
  end

   /* ------------------------------------------------------------*/
   /* Obtain the size description*/
   /* ------------------------------------------------------------*/

  set PG3REC empty;

  PG3REC.XGPCD = PCWREC.XGPCD;
  PG3REC.SY1STNBR = VPOITM05.SY1STNBR;

       /* 071792 lsutto chgd to pc6rec...*/
   /* MOVE PC0UW00.SY2CLRID TO PG3REC.SY2CLRID;*/
  PG3REC.SY2CLRID = VPOITM05.SY2CLRID;

  PG3REC.XDMCD = VPOITM05.XDMCD;
  PG3REC.XQACD = "**";
  PG3REC.PG3FUNCD = "PC";
  PG3REC.PG3DATFM = "N";

  XSPG301(); /* Get valid sizes*/

   /* ------------------------------------------------------------*/
   /* Initialize fields used for scrolling right and left*/
   /* ------------------------------------------------------------*/

  PC0UW00.PC0UWSPR = 1; /* Set size page requested to 1*/
  PC0UW00.PC0UWCSP = 0; /* Set current size page to 0*/
  PC0UW00.PC0UWCSI = PC0UW00.PC0UWFSI; /* current size index*/

  PC0UW00.PC0UWOSD = "N"; /* Obtain size data flag*/


end // end PC0U210

// Format and display map 2
Function PC0U220()

   /* -----------------------------------------------------------*/
   /* If map is not formatted, format the data to display*/
   /* -----------------------------------------------------------*/


  if (PC0UW00.TA5TSQIX > 0) /* Pages were formatted*/
    if (PC0UW00.PC0UWTSP != TA5REC.TA5TSQIX) /* Desired page not current*/

      set PC0UM001 initial;
      set PC0UM002 initial;

      PC0US34(); /* Obtain temp storage page*/
      PC0UM002.PC0UMTOP = PC0UW00.TA5TSQIX;
      PC0UM002.PC0UMFRP = PC0UW00.PC0UWTSP;

      PC0UW00.PC0UWCSP = PC0UW00.PC0UWSPR; /* Requested = current*/

    else
      if (PC0UW00.PC0UWCSP != PC0UW00.PC0UWSPR) /* Scroll r/l request*/

        set PC0UM002 initial;
        PC0UW00.PC0UWCSP = PC0UW00.PC0UWSPR; /* Requested = current*/

      end
    end
  end

  PC0U221(); /* Move header data to the map*/

  if (converseVar.validationMsgNum == 0)
    PC0U222(); /* Format map 2 detail lines*/
  end

  PC0UM002.XXXCURDT = VGVar.currentShortGregorianDate; /* Current date*/


  if (PC0UW00.XXXMSGNO != 0) /* Contains informational message*/
    if (PC0UW00.XXXMSGNO == 9999)
      converseLib.validationFailed();
    else
      converseLib.validationFailed(PC0UW00.XXXMSGNO);
    end
  else

    if (COMMAREA.CAMSG > " ") /* ===> JCL job info message*/

      PC0UM002.VAGen_EZEMSG = COMMAREA.CAMSG; /* ===> job info message*/
      COMMAREA.CAMSG = " "; /* ===> reset job info message*/
      PC0UM002.XXXPRCNM = "PC0U220"; /* ===> Process name*/
      set PC0UM002 alarm; /* ===> set alarm*/
    end

  end

  PC0UM002.XXXCURDT = VGVar.currentShortGregorianDate;

  converse PC0UM002 ;



   /* -----------------------------------------------------------*/
   /* Clear the message fields*/
   /* -----------------------------------------------------------*/

  PC0UW00.XXXMSGNO = 0; /* Message number*/
  PC0UM002.XXXPRCNM = "PC0U"; /* Process number*/




   /* **                                                        ***/
   /* ********************** End of PC0U220 ***********************/
end // end PC0U220

// Load size header data to map
Function PC0U221()

   /* ------------------------------------------------------------*/
   /* Move map header from pc0uW01 display storage to the map*/
   /* fields.*/
   /* ------------------------------------------------------------*/


  PC0UM002.XGPCD = PC0UW01.XGPCD; /* General product group*/
   /* MOVE PC0UW01.PO-REG-CD TO PC0UM002.PO-REG-CD; /* region code*/
  PC0UM002.PC3PONBR = PC0UW01.PC3PONBR; /* Order number*/
  PC0UM002.PC0UMPID = PC0UW01.PC0UWPID; /* PO ID*/
  PC0UM002.SY1STNBR = PC0UW01.SY1STNBR; /* Style number*/
  PC0UM002.SY2CLRID = PC0UW01.SY2CLRID; /* Color*/
  PC0UM002.PC4ORTYP = PC0UW01.PC4ORTYP; /* Order type*/
  PC0UM002.PC3BLPO = PC0UW01.PC3BLPO;
  PC0UM002.PC0UMEDT = PC0UW01.PC0UMEDT;
  PC0UM002.XDMCD = PC0UW01.XDMCD; /* Dimension*/
  PC0UM002.XPGCD = PC0UW01.XPGCD; /* Package*/
  PC0UM002.XQACD = PC0UW01.XQACD; /* Quanlity*/
  PC0UM002.PC0UMTOP = PC0UW00.TA5TSQIX;
  PC0UM002.PC0UMFRP = PC0UW00.PC0UWTSP;

  if (PCWREC.SY1STNBR != "*")
    set PC0UM002.SY1STNBR skip, bold;
  end

   /* ====> Set the More sizes literal as needed*/
        /* ------------------------------------*/
  if (PC0UW00.PC0UWSPG > PC0UW00.PC0UWCSP) /* ===> Current Size Page*/
    set PC0UM002.PC0UMMSL skip; /* ===> more size literal*/
    PC0UM002.PC0UMPFL = "11:RIGHT"; /* ===> PF Key literal*/
  else

    set PC0UM002.PC0UMMSL skip, invisible;
    if (PC0UW00.PC0UWSPG == 1) /* ===> Current Size Page*/
      PC0UM002.PC0UMPFL = "11:RIGHT"; /* ===> PF Key literal*/
    else
      PC0UM002.PC0UMPFL = "10:LEFT "; /* ===> PF Key literal*/
    end

  end


  if (COMMAREA.CAILVL[10] == "N") /* ===> FOB  security*/
    set PC0UM002.PC0UMPF2 skip, invisible;
  end


end // end PC0U221

// Load size detail to map
Function PC0U222()
   /* ------------------------------------------------------------*/
   /* Load the size descriptions to the size description map*/
   /* fields.*/
   /* ------------------------------------------------------------*/

  PC0UW00.PC0UWIXM = 1; /* Initialize map index*/
  PC0UW00.PC0UWIX1 = PC0UW00.PC0UWSPI[PC0UWCSP];

  while (PC0UW00.PC0UWIXM <= 4 /* while fields on the map and sizes*/
   && PC0UW00.PC0UWIX1 <= PC0UW00.PC0UWLSI)

    if (PC0UW00.PC0UWSTB[PC0UWIX1] == "Y")
      PC0UM002.PC0UMSIZ[PC0UWIXM] = PC0UW00.SY4IDDSC[PC0UWIX1];
      PC0UW00.PC0UWIXM = PC0UW00.PC0UWIXM + 1;
    end

    PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
  end

  while (PC0UW00.PC0UWIXM <= 4) /* while map fields darken underline*/
    set PC0UM002.PC0UMSIZ[PC0UWIXM] skip, invisible;
    PC0UW00.PC0UWIXM = PC0UW00.PC0UWIXM + 1;
  end


   /* ------------------------------------------------------------*/
   /* Process each of the detail lines in the pc0uw12 temp*/
   /* storage record.*/
   /* ------------------------------------------------------------*/

  PC0UW00.PC0UWIXM = 1; /* Initialize map index*/
  PC0UW00.PC0UWIX1 = PC0UW00.PC0UWSPI[PC0UWCSP];

  while (PC0UW00.PC0UWIXM <= PC0UW00.PC0UWMAX) /* Max lines*/
    if (PC0UW12K[PC0UWIXM] == 2) /* item detail record*/
      PC0UW02.PC0UW02G = PC0UW12.PC0UW12R[PC0UWIXM];
      PC0UM002.PC0UMSDL[PC0UWIXM] = PC0UW02.PC0UWSC2;

      PC0U125(); /* Unstring integer quantity*/

      PC0UM002.PC0UMSTO[PC0UWIXM] = PC0UW00.PC0UWCHW;
      set PC0UM002.PC0UMSDL[PC0UWIXM] initialAttributes;
      set PC0UM002.PC0UMSTO[PC0UWIXM] initialAttributes;

    end

    if (PC0UW12K[PC0UWIXM] == 22) /* item detail record*/
      PC0UW22.PC0UW02G = PC0UW12.PC0UW12R[PC0UWIXM];
      PC0UM002.PC0UMSDL[PC0UWIXM] = PC0UW22.PC0UWSC2;

      PC0U125(); /* Unstring integer quantity*/

      PC0UM002.PC0UMSTO[PC0UWIXM] = PC0UW00.PC0UWCHW;
      set PC0UM002.PC0UMSDL[PC0UWIXM] initialAttributes;
      set PC0UM002.PC0UMSTO[PC0UWIXM] initialAttributes;

    end

    if (PC0UW12K[PC0UWIXM] == 30) /* item detail record*/
      PC0UW30.PC0UW02G = PC0UW12.PC0UW12R[PC0UWIXM];
      PC0UM002.PC0UMSDL[PC0UWIXM] = PC0UW30.PC0UWSC2;

      PC0U125(); /* Unstring integer quantity*/

      PC0UM002.PC0UMSTO[PC0UWIXM] = PC0UW00.PC0UWCHW;
      set PC0UM002.PC0UMSDL[PC0UWIXM] initialAttributes;
      set PC0UM002.PC0UMSTO[PC0UWIXM] initialAttributes;

    end
    if (PC0UW12K[PC0UWIXM] == 3) /* Shipping detail record*/
      PC0UW03.PC0UW03G = PC0UW12.PC0UW12R[PC0UWIXM];
      PC0UM002.PC0UMSDL[PC0UWIXM] = PC0UW03.PC0UWSC2;

      PC0U125(); /* Unstring integer quantity*/

      PC0UM002.PC0UMSTO[PC0UWIXM] = PC0UW00.PC0UWCHW;
      set PC0UM002.PC0UMSDL[PC0UWIXM] initialAttributes;
      set PC0UM002.PC0UMSTO[PC0UWIXM] initialAttributes;
    end

    if (PC0UW12K[PC0UWIXM] == 23) /* Shipping detail record*/
      PC0UW23.PC0UW03G = PC0UW12.PC0UW12R[PC0UWIXM];
      PC0UM002.PC0UMSDL[PC0UWIXM] = PC0UW23.PC0UWSC2;

      PC0U125(); /* Unstring integer quantity*/

      PC0UM002.PC0UMSTO[PC0UWIXM] = PC0UW00.PC0UWCHW;
      set PC0UM002.PC0UMSDL[PC0UWIXM] initialAttributes;
      set PC0UM002.PC0UMSTO[PC0UWIXM] initialAttributes;
    end

    if (PC0UW12K[PC0UWIXM] == 4) /* Received detail record w/etal*/
      PC0UW04.PC0UW04G = PC0UW12.PC0UW12R[PC0UWIXM];
      PC0UM002.PC0UMSDL[PC0UWIXM] = PC0UW04.PC0UWSC2;

      PC0U125(); /* Unstring integer quantity*/

      PC0UM002.PC0UMSTO[PC0UWIXM] = PC0UW00.PC0UWCHW;
      set PC0UM002.PC0UMSDL[PC0UWIXM] initialAttributes;
      set PC0UM002.PC0UMSTO[PC0UWIXM] initialAttributes;
    end

    if (PC0UW12K[PC0UWIXM] == 24) /* Received detail record w/s.o.*/
      PC0UW24.PC0UW04G = PC0UW12.PC0UW12R[PC0UWIXM];
      PC0UM002.PC0UMSDL[PC0UWIXM] = PC0UW24.PC0UWSC2;

      PC0U125(); /* Unstring integer quantity*/

      PC0UM002.PC0UMSTO[PC0UWIXM] = PC0UW00.PC0UWCHW;
      set PC0UM002.PC0UMSDL[PC0UWIXM] initialAttributes;
      set PC0UM002.PC0UMSTO[PC0UWIXM] initialAttributes;
    end

    if (PC0UW12K[PC0UWIXM] == 5) /* On order total*/
      PC0UW05.PC0UW05G = PC0UW12.PC0UW12R[PC0UWIXM];

      PC0UM002.PC0UMSDL[PC0UWIXM] = PC0UW05.PC0UWSC2;

      PC0U125(); /* Unstring integer quantity*/

      PC0UM002.PC0UMSTO[PC0UWIXM] = PC0UW00.PC0UWCHW;
      set PC0UM002.PC0UMSDL[PC0UWIXM] skip, bold;
      set PC0UM002.PC0UMSTO[PC0UWIXM] skip, bold;
    end

    if (PC0UW12K[PC0UWIXM] == 6) /* Destination balance to ship*/
      PC0UW06.PC0UW06G = PC0UW12.PC0UW12R[PC0UWIXM];

      PC0UM002.PC0UMSDL[PC0UWIXM] = PC0UW06.PC0UWSC2;

      PC0U125(); /* Unstring integer quantity*/

      PC0UM002.PC0UMSTO[PC0UWIXM] = PC0UW00.PC0UWCHW;
      set PC0UM002.PC0UMSDL[PC0UWIXM] skip, bold;
      set PC0UM002.PC0UMSTO[PC0UWIXM] skip, bold;
    end

    if (PC0UW12K[PC0UWIXM] == 7) /* Destination irregular pct*/
      PC0UW07.PC0UW07G = PC0UW12.PC0UW12R[PC0UWIXM];

      PC0UM002.PC0UMSDL[PC0UWIXM] = PC0UW07.PC0UWSC2;
      PC0UW00.PC0UWNUM = PC0UW12.PC0UWQTY[PC0UWIXM];

      PC0U123(); /* Unstring decimal quantity*/

      PC0UM002.PC0UMSTO[PC0UWIXM] = PC0UW00.PC0UWCHW;
      set PC0UM002.PC0UMSDL[PC0UWIXM] skip, bold;
      set PC0UM002.PC0UMSTO[PC0UWIXM] skip, bold;
    end

    if (PC0UW12K[PC0UWIXM] == 8) /* Color balance to ship*/
      PC0UW08.PC0UW08G = PC0UW12.PC0UW12R[PC0UWIXM];

      PC0UM002.PC0UMSDL[PC0UWIXM] = PC0UW08.PC0UWSC2;

      PC0U125(); /* Unstring integer quantity*/

      PC0UM002.PC0UMSTO[PC0UWIXM] = PC0UW00.PC0UWCHW;
      set PC0UM002.PC0UMSDL[PC0UWIXM] skip, bold;
      set PC0UM002.PC0UMSTO[PC0UWIXM] skip, bold;
    end

    if (PC0UW12K[PC0UWIXM] == 9) /* color irregular pct*/
      PC0UW09.PC0UW09G = PC0UW12.PC0UW12R[PC0UWIXM];

      PC0UM002.PC0UMSDL[PC0UWIXM] = PC0UW09.PC0UWSC2;
      PC0UW00.PC0UWNUM = PC0UW12.PC0UWQTY[PC0UWIXM];

      PC0U123(); /* Unstring decimal quantity*/

      PC0UM002.PC0UMSTO[PC0UWIXM] = PC0UW00.PC0UWCHW;
      set PC0UM002.PC0UMSDL[PC0UWIXM] skip, bold;
      set PC0UM002.PC0UMSTO[PC0UWIXM] skip, bold;
    end

    if (PC0UW12K[PC0UWIXM] == 10) /* style balance to ship*/
      PC0UW10.PC0UW10G = PC0UW12.PC0UW12R[PC0UWIXM];

      PC0UM002.PC0UMSDL[PC0UWIXM] = PC0UW10.PC0UWSC2;

      PC0U125(); /* Unstring integer quantity*/

      PC0UM002.PC0UMSTO[PC0UWIXM] = PC0UW00.PC0UWCHW;
      set PC0UM002.PC0UMSDL[PC0UWIXM] skip, bold;
      set PC0UM002.PC0UMSTO[PC0UWIXM] skip, bold;
    end

    if (PC0UW12K[PC0UWIXM] == 11) /* color irregular pct*/
      PC0UW11.PC0UW11G = PC0UW12.PC0UW12R[PC0UWIXM];

      PC0UM002.PC0UMSDL[PC0UWIXM] = PC0UW11.PC0UWSC2;
      PC0UW00.PC0UWNUM = PC0UW12.PC0UWQTY[PC0UWIXM];

      PC0U123(); /* Unstring decimal quantity*/

      PC0UM002.PC0UMSTO[PC0UWIXM] = PC0UW00.PC0UWCHW;
      set PC0UM002.PC0UMSDL[PC0UWIXM] skip, bold;
      set PC0UM002.PC0UMSTO[PC0UWIXM] skip, bold;
    end

    if (PC0UW12K[PC0UWIXM] == 14) /* Cut detail*/
      PC0UW14.PC0UW14G = PC0UW12.PC0UW12R[PC0UWIXM];

      PC0UM002.PC0UMSDL[PC0UWIXM] = PC0UW14.PC0UWSC2;

      PC0U125(); /* Unstring integer quantity*/

      PC0UM002.PC0UMSTO[PC0UWIXM] = PC0UW00.PC0UWCHW;
      set PC0UM002.PC0UMSDL[PC0UWIXM] initialAttributes;
      set PC0UM002.PC0UMSTO[PC0UWIXM] initialAttributes;
    end

    if (PC0UW12K[PC0UWIXM] == 15) /* balance to cut*/
      PC0UW15.PC0UW15G = PC0UW12.PC0UW12R[PC0UWIXM];

      PC0UM002.PC0UMSDL[PC0UWIXM] = PC0UW15.PC0UWSC2;

      PC0U125(); /* Unstring integer quantity*/

      PC0UM002.PC0UMSTO[PC0UWIXM] = PC0UW00.PC0UWCHW;
      set PC0UM002.PC0UMSDL[PC0UWIXM] skip, bold;
      set PC0UM002.PC0UMSTO[PC0UWIXM] skip, bold;
    end

    if (PC0UW12K[PC0UWIXM] == 17) /* Received detail record unmatched*/
      PC0UW17.PC0UW17G = PC0UW12.PC0UW12R[PC0UWIXM];
      PC0UM002.PC0UMSDL[PC0UWIXM] = PC0UW17.PC0UWSC2;

      PC0U125(); /* Unstring integer quantity*/

      PC0UM002.PC0UMSTO[PC0UWIXM] = PC0UW00.PC0UWCHW;
      set PC0UM002.PC0UMSDL[PC0UWIXM] initialAttributes;
      set PC0UM002.PC0UMSTO[PC0UWIXM] initialAttributes;
    end

    if (PC0UW12K[PC0UWIXM] == 26) /* Received detail record unmatched*/
      PC0UW26.PC0UW17G = PC0UW12.PC0UW12R[PC0UWIXM];
      PC0UM002.PC0UMSDL[PC0UWIXM] = PC0UW26.PC0UWSC2;

      PC0U125(); /* Unstring integer quantity*/

      PC0UM002.PC0UMSTO[PC0UWIXM] = PC0UW00.PC0UWCHW;
      set PC0UM002.PC0UMSDL[PC0UWIXM] initialAttributes;
      set PC0UM002.PC0UMSTO[PC0UWIXM] initialAttributes;
    end

    if (PC0UW12K[PC0UWIXM] == 18) /* Shipping detail record unmatched*/
      PC0UW18.PC0UW18G = PC0UW12.PC0UW12R[PC0UWIXM];
      PC0UM002.PC0UMSDL[PC0UWIXM] = PC0UW18.PC0UWSC2;

      PC0U125(); /* Unstring integer quantity*/

      PC0UM002.PC0UMSTO[PC0UWIXM] = PC0UW00.PC0UWCHW;
      set PC0UM002.PC0UMSDL[PC0UWIXM] initialAttributes;
      set PC0UM002.PC0UMSTO[PC0UWIXM] initialAttributes;
    end

    if (PC0UW12K[PC0UWIXM] == 25) /* Shipping detail record unmatched*/
      PC0UW25.PC0UW18G = PC0UW12.PC0UW12R[PC0UWIXM];
      PC0UM002.PC0UMSDL[PC0UWIXM] = PC0UW25.PC0UWSC2;

      PC0U125(); /* Unstring integer quantity*/

      PC0UM002.PC0UMSTO[PC0UWIXM] = PC0UW00.PC0UWCHW;
      set PC0UM002.PC0UMSDL[PC0UWIXM] initialAttributes;
      set PC0UM002.PC0UMSTO[PC0UWIXM] initialAttributes;
    end

    if (PC0UW12.PC0UW12K[PC0UWIXM] != 0)
       /* Load the sizes for each record to the map*/

      PC0U223(); /* Load size detail*/

    end

    if (PC0UW12K[PC0UWIXM] == 19) /* UNMATCHED TRNS LABEL*/
      PC0UW19.PC0UW19G = PC0UW12.PC0UW12R[PC0UWIXM];
      PC0UM002.PC0UMSDL[PC0UWIXM] = PC0UW19.PC0UW-LABEL;
      set PC0UM002.PC0UMSQ1[PC0UWIXM] protect, invisible;
      set PC0UM002.PC0UMSQ2[PC0UWIXM] protect, invisible;
      set PC0UM002.PC0UMSQ3[PC0UWIXM] protect, invisible;
      set PC0UM002.PC0UMSQ4[PC0UWIXM] protect, invisible;
      set PC0UM002.PC0UMSTO[PC0UWIXM] protect, invisible;
    end

    PC0UW00.PC0UWIXM = PC0UW00.PC0UWIXM + 1;

  end

   /* ------------------------------------------------------------*/
   /* Position the cursor on the plan and intransit first detail*/
   /* line. Highlight total fields*/
   /* ------------------------------------------------------------*/


  PC0UW00.PC0UWIXM = PC0UW00.PC0UWMAX; /* set to max lines*/


  while (PC0UW00.PC0UWIXM >= 1)

    if (PC0UW12.PC0UW12K[PC0UWIXM] != 0)
      if (PC0UW12.PC0UW12K[PC0UWIXM] == 2  /* Plan data key*/
       || PC0UW12.PC0UW12K[PC0UWIXM] == 3  /* shipping data key*/
       || PC0UW12.PC0UW12K[PC0UWIXM] == 18 /* shipping data key*/
       || PC0UW12.PC0UW12K[PC0UWIXM] == 22 /* Plan data key*/
       || PC0UW12.PC0UW12K[PC0UWIXM] == 30) /* Plan data key*/
        set PC0UM002.PC0UMSEL[PC0UWIXM] cursor, normal; /* Allow entry*/
      else
        set PC0UM002.PC0UMSEL[PC0UWIXM] initialAttributes; /* Protect and darken*/
      end
    else
      set PC0UM001.PC0UMQTY[PC0UWIXM] protect, invisible;
    end
    PC0UW00.PC0UWIXM = PC0UW00.PC0UWIXM - 1;
  end
end // end PC0U222

// Load sizes quantities to map
Function PC0U223()

   /* ------------------------------------------------------------*/
   /* Move the size quantites from the pc0uw12 size field array*/
   /* to the map fields. If CSP allowed a 2 dimensional array*/
   /* this could be coded far more efficiently--no more said*/
   /* about this 'state of the art' language.*/

   /* pc0uwixm is the index used  for positioning in the*/
   /* pc0uw12 record and the map line.*/

   /* pc0uwix1 is the index used to determine if a size has*/
   /* a quantity and if so moves that field to the map.*/
   /* The index is set to the saved first position in the*/
   /* size table for that page.*/

   /* pc0uwix2 is a 'dummy' index used to determine what*/
   /* size field to move the data into.*/

   /* ------------------------------------------------------------*/
    /* Move the size field from the pc0uw12 record to a quantity*/
    /* field size array in working storage.*/
   /* ------------------------------------------------------------*/

  PC0UW00.PC0UWSWA = PC0UW12.PC0UW12Z[PC0UWIXM];


  PC0UW00.PC0UWIX5 = PC0UW00.PC0UWSPI[PC0UWCSP];

  PC0UW00.PC0UWIX2 = 1;

  while (PC0UW00.PC0UWIX2 <= 4 /* While fields on the map and sizes*/
   && PC0UW00.PC0UWIX5 <= PC0UW00.PC0UWLSI)

    if (PC0UW00.PC0UWSTB[PC0UWIX5] == "Y")
      if (PC0UW00.PC0UWIX2 == 1)
        PC0UW00.PC0UWNUM = PC0UW00.PC0UWAMT[PC0UWIX5];
        if (PC0UW12.PC0UW12K[PC0UWIXM] == 7 /* Destination %*/
         || PC0UW12.PC0UW12K[PC0UWIXM] == 9 /* Color %*/
         || PC0UW12.PC0UW12K[PC0UWIXM] == 11) /* Style %*/
          PC0U123(); /* Unstring decimal*/
        else
          PC0U124(); /* Unstring integer*/
        end
        PC0UM002.PC0UMSQ1[PC0UWIXM] = PC0UW00.PC0UWCHW;
        if (PC0UW12.PC0UW12K[PC0UWIXM] == 5 /* Total fields*/
         || PC0UW12.PC0UW12K[PC0UWIXM] == 6 
         || PC0UW12.PC0UW12K[PC0UWIXM] == 7 
         || PC0UW12.PC0UW12K[PC0UWIXM] == 8 
         || PC0UW12.PC0UW12K[PC0UWIXM] == 9 
         || PC0UW12.PC0UW12K[PC0UWIXM] == 10
         || PC0UW12.PC0UW12K[PC0UWIXM] == 11
         || PC0UW12.PC0UW12K[PC0UWIXM] == 15)
          set PC0UM002.PC0UMSQ1[PC0UWIXM] skip, bold;
        else
          set PC0UM002.PC0UMSQ1[PC0UWIXM] protect;
        end
      end

      if (PC0UW00.PC0UWIX2 == 2)
        PC0UW00.PC0UWNUM = PC0UW00.PC0UWAMT[PC0UWIX5];
        if (PC0UW12.PC0UW12K[PC0UWIXM] == 7 /* Destination %*/
         || PC0UW12.PC0UW12K[PC0UWIXM] == 9 /* Color %*/
         || PC0UW12.PC0UW12K[PC0UWIXM] == 11) /* Style %*/
          PC0U123(); /* Unstring decimal*/
        else
          PC0U124(); /* Unstring integer*/
        end
        PC0UM002.PC0UMSQ2[PC0UWIXM] = PC0UW00.PC0UWCHW;
        if (PC0UW12.PC0UW12K[PC0UWIXM] == 5 /* Total fields*/
         || PC0UW12.PC0UW12K[PC0UWIXM] == 6 
         || PC0UW12.PC0UW12K[PC0UWIXM] == 7 
         || PC0UW12.PC0UW12K[PC0UWIXM] == 8 
         || PC0UW12.PC0UW12K[PC0UWIXM] == 9 
         || PC0UW12.PC0UW12K[PC0UWIXM] == 10
         || PC0UW12.PC0UW12K[PC0UWIXM] == 11
         || PC0UW12.PC0UW12K[PC0UWIXM] == 15)
          set PC0UM002.PC0UMSQ2[PC0UWIXM] skip, bold;
        else
          set PC0UM002.PC0UMSQ2[PC0UWIXM] protect;
        end
      end
      if (PC0UW00.PC0UWIX2 == 3)
        PC0UW00.PC0UWNUM = PC0UW00.PC0UWAMT[PC0UWIX5];
        if (PC0UW12.PC0UW12K[PC0UWIXM] == 7 /* Destination %*/
         || PC0UW12.PC0UW12K[PC0UWIXM] == 9 /* Color %*/
         || PC0UW12.PC0UW12K[PC0UWIXM] == 11) /* Style %*/
          PC0U123(); /* Unstring decimal*/
        else
          PC0U124(); /* Unstring integer*/
        end
        PC0UM002.PC0UMSQ3[PC0UWIXM] = PC0UW00.PC0UWCHW;
        if (PC0UW12.PC0UW12K[PC0UWIXM] == 5 /* Total fields*/
         || PC0UW12.PC0UW12K[PC0UWIXM] == 6 
         || PC0UW12.PC0UW12K[PC0UWIXM] == 7 
         || PC0UW12.PC0UW12K[PC0UWIXM] == 8 
         || PC0UW12.PC0UW12K[PC0UWIXM] == 9 
         || PC0UW12.PC0UW12K[PC0UWIXM] == 10
         || PC0UW12.PC0UW12K[PC0UWIXM] == 11
         || PC0UW12.PC0UW12K[PC0UWIXM] == 15)
          set PC0UM002.PC0UMSQ3[PC0UWIXM] skip, bold;
        else
          set PC0UM002.PC0UMSQ3[PC0UWIXM] protect;
        end
      end

      if (PC0UW00.PC0UWIX2 == 4)
        PC0UW00.PC0UWNUM = PC0UW00.PC0UWAMT[PC0UWIX5];
        if (PC0UW12.PC0UW12K[PC0UWIXM] == 7 /* Destination %*/
         || PC0UW12.PC0UW12K[PC0UWIXM] == 9 /* Color %*/
         || PC0UW12.PC0UW12K[PC0UWIXM] == 11) /* Style %*/
          PC0U123(); /* Unstring decimal*/
        else
          PC0U124(); /* Unstring integer*/
        end
        PC0UM002.PC0UMSQ4[PC0UWIXM] = PC0UW00.PC0UWCHW;
        if (PC0UW12.PC0UW12K[PC0UWIXM] == 5 /* Total fields*/
         || PC0UW12.PC0UW12K[PC0UWIXM] == 6 
         || PC0UW12.PC0UW12K[PC0UWIXM] == 7 
         || PC0UW12.PC0UW12K[PC0UWIXM] == 8 
         || PC0UW12.PC0UW12K[PC0UWIXM] == 9 
         || PC0UW12.PC0UW12K[PC0UWIXM] == 10
         || PC0UW12.PC0UW12K[PC0UWIXM] == 11
         || PC0UW12.PC0UW12K[PC0UWIXM] == 15)
          set PC0UM002.PC0UMSQ4[PC0UWIXM] skip, bold;
        else
          set PC0UM002.PC0UMSQ4[PC0UWIXM] protect;
        end
      end
      PC0UW00.PC0UWIX2 = PC0UW00.PC0UWIX2 + 1;
    end
    PC0UW00.PC0UWIX5 = PC0UW00.PC0UWIX5 + 1;
  end


end // end PC0U223

// Check attention id
Function PC0U230()


   /* ------------------------------------------------------------*/
   /* Clear Map on PA2*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pa2) /* PA2 was pressed*/
    converseLib.clearScreen();
     /* Clear the map fields*/
    PC0UM002.XXXPRCNM = "PC0U";
    exit stack; /* Exit to redisplay map*/
  end

   /* ------------------------------------------------------------*/
   /* If FAST PATH was requested, transfer to application.*/
   /* ------------------------------------------------------------*/

  if (PC0UM002.CATOAP > " ") /* FAST PATH was requested*/
    if (converseVar.eventKey is enter) /* ENTER was pressed*/
      set PCWREC empty;
      COMMAREA.CATOAP = PC0UM002.CATOAP; /* TO application*/
      COMMAREA.CAITEM = PC0UM002.CAITEM; /* TO application key*/
      XSPCS01();
      COMMAREA.CATOAP = "PC0A";
      PCWREC.XXXMSGNO = 191;
      XSPCS01();
      converseLib.validationFailed(05); /* Enter must be used for fast path*/
      exit stack;
    end
  end

   /* ------------------------------------------------------------*/
   /* On PF4 transfer to MN0M(even if it's not on the screen)*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf4) /* Main menu requested*/
    set PCWREC empty;
    COMMAREA.CAITEM = " "; /* application from data*/
    COMMAREA.CATOAP = "MN0M";
    XSPCS01();
    PC0UM002.XXXPRCNM = "PC0U230";
    PC0UM002.VAGen_EZEMSG = COMMAREA.CAMSG; /* If bad transfer*/
    exit stack; /* Exit to redisplay map*/
  end

   /* ------------------------------------------------------------*/
   /* On PF5 transfer to FY0M(even if it's not on the screen)*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf5) /* Main menu requested*/
    set PCWREC empty;
    COMMAREA.CAITEM = " "; /* application from data*/
    COMMAREA.CATOAP = "FY0M";
    XSPCS01();
    PC0UM002.XXXPRCNM = "PC0U230";
    PC0UM002.VAGen_EZEMSG = COMMAREA.CAMSG; /* If bad transfer*/
    exit stack; /* Exit to redisplay map*/
  end
   /* ------------------------------------------------------------*/
   /* On PF17 transfer to PC0L*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf17)

    COMMAREA.CAITEM = " "; /* application from data*/
    COMMAREA.CATOAP = "PC0L";
    PCWREC.FY1FCTYC = VPOHDR02.FY1FCTYC;
    PCWREC.PC3POIDT = VPOHDR02.PC3POIDT;
    PCWREC.PO-REG-CD = VPOHDR02.PO-REG-CD;
    XSPCS01();
    PC0UM002.XXXPRCNM = "PC0U230";
    exit stack; /* Exit to redisplay map*/
  end
   /* ------------------------------------------------------------*/
   /* Validate scroll request if  PF11*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf11 /* Scroll right requested*/
   || converseVar.eventKey is pf10) /* Scroll left  requested*/

    PC0U231(); /* Validate scroll request*/

    return; /* Exit to next process*/

  end
   /* ------------------------------------------------------------*/
   /* Validate scroll request if  PF7 or PF8*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf7 /* Scroll back requested*/
   || converseVar.eventKey is pf8) /* Scroll forward requested*/

    PC0U232(); /* Validate scroll request*/

    return; /* Exit to next process*/
  end

   /* ------------------------------------------------------------*/
   /* Continue processing if following keys are pressed*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is enter /* TS0P*/
   || converseVar.eventKey is pf2   /* FOB*/
   || converseVar.eventKey is pf6   /* Special instructions*/
   || converseVar.eventKey is pf12  /* Maintenance*/
   || converseVar.eventKey is pf14  /* Ship to*/
   || converseVar.eventKey is pf17) /* PO header*/
  /* OR EZEAID IS PF20;               /* Print*/

    if (converseVar.eventKey is pf2 /* FOB*/
     && COMMAREA.CAILVL[10] == "N") /* ===> FOB  security*/
      /* =========== Next Sentence ==========>*/
    else
      return;
    end

  end

   /* ------------------------------------------------------------*/
   /* Purge temporary storage on PF21 and transer to PC0A*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf21) /* pf21 pressed*/

    PC0U111(); /* Purge temp storage*/
    set PCWREC empty;

    COMMAREA.CAITEM = " "; /* application from data*/
    COMMAREA.CATOAP = "PC0A";
    XSPCS01();
    PC0UM002.XXXPRCNM = "PC0U230";
    PC0UM002.VAGen_EZEMSG = COMMAREA.CAMSG; /* If bad transfer*/
    exit stack;
  end

   /* ------------------------------------------------------------*/
   /* Purge temporary storage on PF19 and transer list screen*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf19) /* pf19 pressed*/

    PC0U111(); /* Purge temp storage*/
    COMMAREA.CAITEM = " ";
    COMMAREA.CATOAP = PC0UW13.CAFROMAP;
    COMMAREA.CAUSERA = PCWREC.CAUSERA;

    XSEXIT();
    converseLib.validationFailed(10);
    PC0UM002.XXXPRCNM = "PC0U230";
    PC0UM002.VAGen_EZEMSG = COMMAREA.CAMSG; /* If bad transfer*/
    exit stack;
  end

   /* ------------------------------------------------------------*/
   /* PF3 set to first screen*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf3) /* pf3 pressed*/

    PC0UW00.PC0UWSRF = 1; /* Map 1 requested*/
    exit stack;
  end

   /* ------------------------------------------------------------*/
   /* Clear screen if PA1 or PA3 and exit to display map.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pa1 /* PA1 pressed*/
   || converseVar.eventKey is pa3) /* PA3 pressed*/
    set PC0UM002 initial; /* Clear the map fields*/
    exit stack; /* Exit to redisplay map*/
  end

   /* ------------------------------------------------------------*/
   /* At this point an invalid PF key has been pressed.*/
   /* ------------------------------------------------------------*/


  PC0UM001.XXXPRCNM = "PC0U230";
  converseLib.validationFailed(04); /* Invalid PA/PF key*/
  exit stack;


end // end PC0U230

// Validate right scroll
Function PC0U231()

   /* ------------------------------------------------------------*/
   /* If scroll right was requested, ensure that pages exist.*/
   /* ------------------------------------------------------------*/



  if (converseVar.eventKey is pf11 /* Scroll right request*/
   && PC0UW00.PC0UWCSP >= PC0UW00.PC0UWSPG) /* and no more pages*/

    PC0UM002.XXXPRCNM = "PC0U231"; /* Module identification*/
    converseLib.validationFailed(76); /* No more pages to display*/
    exit stack;

  end


  if (converseVar.eventKey is pf10 /* Scroll left  request*/
   && PC0UW00.PC0UWCSP == 1)      

    PC0UM002.XXXPRCNM = "PC0U231"; /* Module identification*/
    converseLib.validationFailed(76); /* No more pages to display*/
    exit stack;

  end




end // end PC0U231

// Validate up/down scroll
Function PC0U232()



   /* ------------------------------------------------------------*/
   /* If scroll back was requested, ensure that pages exist.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf7 /* Scroll back request*/
   && PC0UW00.PC0UWTSP < 2)       /* and no previous pages*/

    PC0UM002.XXXPRCNM = "PC0U232"; /* Module identification*/
    converseLib.validationFailed(2); /* No previous page to display*/

  end

   /* ------------------------------------------------------------*/
   /* If scroll forward was requested, ensure that pages exist.*/
   /* ------------------------------------------------------------*/



  if (converseVar.eventKey is pf8 /* Scroll forward request*/
   && PC0UW00.PC0UWTSP >= PC0UW00.TA5TSQIX) /* and no more pages*/

    PC0UM002.XXXPRCNM = "PC0U232"; /* Module identification*/
    converseLib.validationFailed(3); /* No more pages to display*/

  end

  if (converseVar.validationMsgNum != 0) /* Errors were found*/
    exit stack;
  end



end // end PC0U232

// Reset highlighted fields
Function PC0U240()

  PC0UW00.PC0UWIXM = 1; /* Initialize map index*/

  while (PC0UW00.PC0UWIXM <= PC0UW00.PC0UWMAX /* Max lines (13)*/
   && PC0UW12.PC0UW12K[PC0UWIXM] != 0)

    if (PC0UW12.PC0UW12K[PC0UWIXM] == 2  /* Plan data key*/
     || PC0UW12.PC0UW12K[PC0UWIXM] == 3  /* shipping data key*/
     || PC0UW12.PC0UW12K[PC0UWIXM] == 22 /* Plan data key*/
     || PC0UW12.PC0UW12K[PC0UWIXM] == 30) /* Plan data key*/
      set PC0UM002.PC0UMSEL[PC0UWIXM] normal; /* Allow entry*/
    else
      set PC0UM002.PC0UMSEL[PC0UWIXM] initialAttributes; /* Protect and darken*/

    end
    PC0UW00.PC0UWIXM = PC0UW00.PC0UWIXM + 1;
  end


end // end PC0U240

// Verify entered data
Function PC0U250()

   /* ----------------------------------------------------*/
   /* Validate for PF12 (multiple lines can be selected)*/
   /* The entered value must be an 's'.*/
   /* Only plan lines can be selected.*/
   /* ----------------------------------------------------*/

  PC0UW00.PC0UWIXM = PC0UW00.PC0UWMAX; /* Initialize map index*/
  PC0UW00.PC0UWCNT = 0; /* Field to count select codes*/

  if (converseVar.eventKey is pf12) /* PC0K (product inq/maint)*/

    while (PC0UW00.PC0UWIXM >= 1)
      if (PC0UM002.PC0UMSEL[PC0UWIXM] != " ")
        if (PC0UM002.PC0UMSEL[PC0UWIXM] != "S")
          set PC0UM002.PC0UMSEL[PC0UWIXM] cursor, bold;
          PC0UM002.XXXPRCNM = "PC0U250";
          converseLib.validationFailed(13);
        else
          PC0UW00.PC0UWCNT = PC0UW00.PC0UWCNT + 1;
          if (PC0UW12.PC0UW12K[PC0UWIXM] != 2
           && PC0UW12.PC0UW12K[PC0UWIXM] != 22
           && PC0UW12.PC0UW12K[PC0UWIXM] != 30)
            set PC0UM002.PC0UMSEL[PC0UWIXM] cursor, bold;
            PC0UM002.XXXPRCNM = "PC0U250";
            converseLib.validationFailed(166); /* Only plan line can be selected*/
          end
        end
      end
      PC0UW00.PC0UWIXM = PC0UW00.PC0UWIXM - 1;
    end
    if (PC0UW00.PC0UWCNT == 0)
      set PC0UM002.PC0UMSEL[1] cursor;
      PC0UM002.XXXPRCNM = "PC0U250";
      converseLib.validationFailed(25); /* Please select a line*/
    end
    if (converseVar.validationMsgNum == 0)
      return;
    else
      exit stack;
    end
  end

   /* ----------------------------------------------------*/
   /* Validate for PF14 or Pf6*/
   /* Only one plan can be selected).*/
   /* The entered value must be an 'S'.*/
   /* ----------------------------------------------------*/


  PC0UW00.PC0UWCNT = 0; /* Field to count select codes*/

  if (converseVar.eventKey is pf14 /* PC0D (Item ship-to)*/
   || converseVar.eventKey is pf6) /* PC0H (Item special instruction)*/

    while (PC0UW00.PC0UWIXM >= 1)
      if (PC0UM002.PC0UMSEL[PC0UWIXM] == "S")
        PC0UW00.PC0UWCNT = PC0UW00.PC0UWCNT + 1;
        PC0UW00.PC0UWIX1 = 1; /* Init second index*/
        while (PC0UW00.PC0UWIX1 <= PC0UW00.PC0UWMAX) /* Max lines (13)*/
          if (PC0UM002.PC0UMSEL[PC0UWIXM] == PC0UM002.PC0UMSEL[PC0UWIX1]
           && PC0UW00.PC0UWIXM != PC0UW00.PC0UWIX1)
            set PC0UM002.PC0UMSEL[PC0UWIXM] cursor, bold;
            PC0UM002.XXXPRCNM = "PC0U250";
            converseLib.validationFailed(144); /* Only one line can be selected*/
          end
          if (PC0UW12.PC0UW12K[PC0UWIXM] != 2
           && PC0UW12.PC0UW12K[PC0UWIXM] != 22
           && PC0UW12.PC0UW12K[PC0UWIXM] != 30)
            set PC0UM002.PC0UMSEL[PC0UWIXM] cursor, bold;
            PC0UM002.XXXPRCNM = "PC0U250";
            converseLib.validationFailed(109); /* Only plan line can be selected*/
          end
          PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
        end
        if (PC0UW12.PC0UW12K[PC0UWIXM] != 2
         && PC0UW12.PC0UW12K[PC0UWIXM] != 22
         && PC0UW12.PC0UW12K[PC0UWIXM] != 30)
          set PC0UM002.PC0UMSEL[PC0UWIXM] cursor, bold;
          PC0UM002.XXXPRCNM = "PC0U250";
          converseLib.validationFailed(166); /* Only plan line can be selected*/
        end
      else
        if (PC0UM002.PC0UMSEL[PC0UWIXM] != " ")
          set PC0UM002.PC0UMSEL[PC0UWIXM] cursor, bold;
          PC0UM002.XXXPRCNM = "PC0U250";
          converseLib.validationFailed(13); /* S'elect code must be S*/
        end
      end
      PC0UW00.PC0UWIXM = PC0UW00.PC0UWIXM - 1;
    end
    if (PC0UW00.PC0UWCNT == 0)
      set PC0UM002.PC0UMSEL[1] cursor;
      converseLib.validationFailed(25); /* Please select a line*/
    end
    if (converseVar.validationMsgNum == 0)
      return;
    else
      exit stack;
    end
  end

   /* ----------------------------------------------------*/
   /* Validate for enter if a shipping line has been*/
   /* selected. The entered value must be an 'S'*/
   /* and only one line can be selected.*/
   /* ----------------------------------------------------*/

  if (converseVar.eventKey is enter) /* TS0P (Product inquiry)*/

    while (PC0UW00.PC0UWIXM >= 1)
      if (PC0UM002.PC0UMSEL[PC0UWIXM] == "S")
        PC0UW00.PC0UWCNT = PC0UW00.PC0UWCNT + 1;
        PC0UW00.PC0UWIX1 = 1; /* Init second index*/
        while (PC0UW00.PC0UWIX1 <= PC0UW00.PC0UWMAX) /* Max lines (13)*/
          if (PC0UM002.PC0UMSEL[PC0UWIXM] == PC0UM002.PC0UMSEL[PC0UWIX1]
           && PC0UW00.PC0UWIXM != PC0UW00.PC0UWIX1)
            set PC0UM002.PC0UMSEL[PC0UWIXM] cursor, bold;
            PC0UM002.XXXPRCNM = "PC0U250";
            converseLib.validationFailed(144); /* Only one line can be selected*/
          end
          PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
        end
        if (PC0UW12.PC0UW12K[PC0UWIXM] != 3
         && PC0UW12.PC0UW12K[PC0UWIXM] != 18)
          set PC0UM002.PC0UMSEL[PC0UWIXM] cursor, bold;
          PC0UM002.XXXPRCNM = "PC0U250";
          converseLib.validationFailed(109); /* Only shipping line can be selected*/
        end
      else
        if (PC0UM002.PC0UMSEL[PC0UWIXM] != " ")
          set PC0UM002.PC0UMSEL[PC0UWIXM] cursor, bold;
          PC0UM002.XXXPRCNM = "PC0U250";
          converseLib.validationFailed(13); /* S'elect code must be S*/
        end
      end
      PC0UW00.PC0UWIXM = PC0UW00.PC0UWIXM - 1;
    end
    if (converseVar.validationMsgNum == 0)
      return;
    else
      exit stack;
    end
  end

end // end PC0U250

// Process valid input
Function PC0U260()

   /* ----------------------------------------------------*/
   /* If PF11 has been pressed increment the page*/
   /* requested.*/
   /* ----------------------------------------------------*/

  if (converseVar.eventKey is pf11) /* Scroll right requested*/
    PC0UW00.PC0UWSPR = PC0UW00.PC0UWSPR + 1;
    exit stack;
  end


   /* ----------------------------------------------------*/
   /* If PF10 has been pressed decrement the page*/
   /* requested.*/
   /* ----------------------------------------------------*/

  if (converseVar.eventKey is pf10) /* Scroll left  requested*/
    PC0UW00.PC0UWSPR = PC0UW00.PC0UWSPR - 1;
    exit stack;
  end

   /* ----------------------------------------------------*/
   /* If PF7 or PF8 has been pressed increment or*/
   /* decrement the page requested and return to the*/
   /* calling process.*/
   /* ----------------------------------------------------*/

  if (converseVar.eventKey is pf7)
    PC0UW00.PC0UWTSP = PC0UW00.PC0UWTSP - 1;
    return;
  end

  if (converseVar.eventKey is pf8)
    PC0UW00.PC0UWTSP = PC0UW00.PC0UWTSP + 1;
    return;
  end


   /* ----------------------------------------------------*/
   /* If PF3 or pf19 have been pressed transfer back*/
   /* to the initially calling application (list screen)*/
   /* On a pf3 leave the pcwrec in tact--on PF19 clear*/
   /* the pcwrec.*/
   /* ----------------------------------------------------*/

  if (converseVar.eventKey is pf3) /* List screen requested*/
    PC0U111(); /* Purge temp storage*/
    COMMAREA.CAITEM = " "; /* Application from data*/
    COMMAREA.CATOAP = PC0UW13.CAFROMAP; /* To Application*/
    COMMAREA.CAUSERA = PCWREC.CAUSERA;
    XSPCS01();
  end

  if (converseVar.eventKey is pf19) /* Select screen requested*/

    PC0U111(); /* Purge temp storage*/

    COMMAREA.CAITEM = " "; /* Application from data*/
    set PCWREC empty;
    PCWREC.XGPCD = COMMAREA.XGPCD;
    COMMAREA.CAUSERA = PCWREC.CAUSERA;
    COMMAREA.CATOAP = PC0UW13.CAFROMAP; /* To Application*/
    XSPCS01();
  end


   /* ----------------------------------------------------*/
   /* If PF20 is pressed*/
     /* - Set-up and print T.S. through TA0P*/
   /* ----------------------------------------------------*/

  /* IF EZEAID IS PF20;                /* Print requested*/
  /* ;*/
  /* PERFORM PC0U500;                 /* ===> Set-up and print T.S. through*/
                                   /* TA0P*/
  /* EZEFLO;*/
  /* ;*/
  /* END;*/


   /* ----------------------------------------------------*/
   /* If any intransit line has been selected the enter*/
   /* key means a transfer to TSOP.*/
   /* ----------------------------------------------------*/

   /* Check for intransit line selected*/
   /* Save index value of intransit line if one is found*/

  PC0UW00.PC0UWIX1 = 1; /* Init index*/
  PC0UW00.PC0UWIX4 = 0; /* Init transporation select index*/

  while (PC0UW00.PC0UWIX1 <= PC0UW00.PC0UWMAX)
    if (PC0UM002.PC0UMSEL[PC0UWIX1] == "S"
     && PC0UW12.PC0UW12K[PC0UWIX1] == 3) /* Intransit line*/
      PC0UW00.PC0UWIX4 = PC0UW00.PC0UWIX1;
    end
    PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
  end

  if (converseVar.eventKey is enter /* Enter was pressed*/
   && PC0UW00.PC0UWCNT == 0)        /* intransit line not selected*/
    return;
  end

   /* ----------------------------------------------------*/
   /* The remaining attention keys will execute a*/
   /* transfer. The following code is generic for all.*/
   /* ----------------------------------------------------*/


  PC0UW13.PC0UWTSP = PC0UW00.PC0UWTSP;

  PC0UW13.XGPCD = PCWREC.XGPCD;
  PC0UW13.PO-REG-CD = PCWREC.PO-REG-CD;
  PC0UW13.PC3PONBR = PCWREC.PC3PONBR;
  PC0UW13.YSMXDV = PCWREC.YSMXDV;
  PC0UW13.SY1STNBR = PCWREC.SY1STNBR;
  PC0UW13.SY2CLRID = PCWREC.SY2CLRID;
  PC0UW13.XDMCD = PCWREC.XDMCD;
  PC0UW13.XQACD = PCWREC.XQACD;
  PC0UW13.XOWCD = PCWREC.XOWCD;
  PC0UW13.XPGCD = PCWREC.XPGCD;
  PC0UW13.XUMCD = PCWREC.XUMCD;


  if (PCWREC.CAFROMAP[1] == " ")

    PCWREC.CAFROMAP[1] = "PC0U"; /* From application id*/
    PCWREC.PCWUSER1 = PC0UW13.PC0UWUSR;

  else
    if (PCWREC.CAFROMAP[2] == " ")

      PCWREC.CAFROMAP[2] = "PC0U"; /* From application id*/
      PCWREC.PCWUSER2 = PC0UW13.PC0UWUSR;
    else
      if (PCWREC.CAFROMAP[3] == " ")
        PCWREC.CAFROMAP[3] = "PC0U"; /* From application id*/
        PCWREC.PCWUSER3 = PC0UW13.PC0UWUSR;
      else
        if (PCWREC.CAFROMAP[4] == " ")
          PCWREC.CAFROMAP[4] = "PC0U"; /* From application id*/
          PCWREC.PCWUSER4 = PC0UW13.PC0UWUSR;

        end
      end
    end
  end


  PC0UW00.PC0UWIXM = 1; /* Initialize screen index*/


  COMMAREA.CAITEM = " "; /* Application from data*/

   /* ----------------------------------------------------*/
   /* If PF2 move style number to the pcwrec*/
   /* ----------------------------------------------------*/

  if (converseVar.eventKey is pf2) /* FOB*/


    PCWREC.SY1STNBR = PC0UM002.SY1STNBR;

    PC0U111(); /* Purge temp storage*/
    COMMAREA.CATOAP = "PC07"; /* To Application*/
    COMMAREA.CAUSERA = PCWREC.CAUSERA;
    XSPCS01();
  end


   /* ----------------------------------------------------*/
   /* If PF6 move the selected item sequence number to*/
   /* the first position in the PCWREC items sequence*/
   /* array and the item sequence number field.*/
   /* ----------------------------------------------------*/

  if (converseVar.eventKey is pf6) /* Item special instruction selected*/


    while (PC0UW00.PC0UWIXM <= PC0UW00.PC0UWMAX) /* Max lines (13)*/

      if (PC0UM002.PC0UMSEL[PC0UWIXM] == "S")
        PCWREC.PC6ITMNB = PC0UW12.PC6ITMNB[PC0UWIXM];
        PC0US36(); /* Get item*/
      end

      PC0UW00.PC0UWIXM = PC0UW00.PC0UWIXM + 1;
    end

    PC0U111(); /* Purge temp storage*/
    PCWREC.PCWFNC = "I"; /* Function passed*/
    COMMAREA.CATOAP = "PC0I"; /* To Application*/
    COMMAREA.CAUSERA = PCWREC.CAUSERA;
    XSPCS01();
  end


   /* ----------------------------------------------------*/
   /* If PF14 move the selected item sequence number to*/
   /* the first position in the PCWREC items sequence*/
   /* array and the item sequence number field.*/
   /* ----------------------------------------------------*/

  if (converseVar.eventKey is pf14) /* Item ship to requested*/

    while (PC0UW00.PC0UWIXM <= PC0UW00.PC0UWMAX) /* Max lines(13)*/

      if (PC0UM002.PC0UMSEL[PC0UWIXM] == "S")
        PCWREC.PC6ITMNB[1] = PC0UW12.PC6ITMNB[PC0UWIXM];
        PC0US36(); /* Get item*/
      end

      PC0UW00.PC0UWIXM = PC0UW00.PC0UWIXM + 1;
    end

    PC0U111(); /* Purge temp storage*/
    COMMAREA.CATOAP = "PC05"; /* To Application*/
    PCWREC.PCWFNC = "I";
    XSPCS01();
  end

   /* ----------------------------------------------------*/
   /* If PF12 move the selected item sequence number to*/
   /* the first position in the PCWREC items sequence*/
   /* array.*/
   /* ----------------------------------------------------*/

  if (converseVar.eventKey is pf12) /* Product inquiry maintenance*/

    PC0UW00.PC0UWIX1 = 1; /* Init work index*/

    while (PC0UW00.PC0UWIXM <= PC0UW00.PC0UWMAX) /* Max lines (13)*/

      if (PC0UM002.PC0UMSEL[PC0UWIXM] == "S")
        PCWREC.PC6ITMNB[PC0UWIX1] = PC0UW12.PC6ITMNB[PC0UWIXM];
        PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
        PC0US36(); /* Get item*/
      end

      PC0UW00.PC0UWIXM = PC0UW00.PC0UWIXM + 1;
    end


    PC0U111(); /* Purge temp storage*/
    COMMAREA.CATOAP = "PC0K"; /* To Application*/
    PCWREC.PCWFNC = "C"; /* Function passed*/
    XSPCS01();
  end

   /* ----------------------------------------------------*/
   /* If any intransit line has been selected the enter*/
   /* key means a transfer to TSOP.*/
   /* ----------------------------------------------------*/

  if (converseVar.eventKey is enter) /* Product inquiry*/

    while (PC0UW00.PC0UWIXM <= PC0UW00.PC0UWMAX) /* Max lines*/

      if (PC0UW12.PC0UW12K[PC0UWIXM] == 2) /* Style/clr detail line*/
        PC0UW02.PC0UW02G = PC0UW12.PC0UW12R[PC0UWIXM];
      end

      if (PC0UW12.PC0UW12K[PC0UWIXM] == 22) /* Style/clr detail line*/
        PC0UW22.PC0UW02G = PC0UW12.PC0UW12R[PC0UWIXM];
      end

      if (PC0UW12.PC0UW12K[PC0UWIXM] == 30) /* Style/clr detail line*/
        PC0UW30.PC0UW02G = PC0UW12.PC0UW12R[PC0UWIXM];
      end

      if (PC0UM002.PC0UMSEL[PC0UWIXM] == "S")
        PCWREC.PC6ITMNB[PC0UWIX1] = PC0UW12.PC6ITMNB[PC0UWIXM];
        PC0US50(); /* ===> set PCWREC fields*/
      end

      PC0UW00.PC0UWIXM = PC0UW00.PC0UWIXM + 1;
    end

    PC0U111(); /* Purge temp storage*/
    COMMAREA.CATOAP = "TS0P"; /* To Application*/
    XSPCS01();
  end

   /* ----------------------------------------------------*/
   /* Executed only on bad transfer*/
   /* ----------------------------------------------------*/

  if (converseVar.validationMsgNum > 0)
    PC0UM002.XXXPRCNM = "PC0U260";
    exit stack; /* Exit to redisplay map*/
  end

end // end PC0U260

Function PC0U310()



   /* ------------------------------------------------------------*/
   /* First get all the of the shipping data for a PO*/
   /* Then match to po items.  If they match they are already*/
   /* displayed.   If they do not match, set up a display line.*/
   /* ------------------------------------------------------------*/

   /* Initialize destination total arrays for shipping & receiving*/

  PC0UW00.PC0UWTDS = 0; /* Destination shipped*/
  PC0UW00.PC0UWTDR = 0; /* Destination receiving*/
  PC0UW00.PC0UWIDS = 0; /* Irregular shipping dest*/
  PC0UW00.PC0UWIDR = 0; /* Irregular receiving dest*/
  move 0 to PC0UW00.PC0UWDSZ[1] for all; /* Destination shipping size array*/
  move 0 to PC0UW00.PC0UWDRZ[1] for all; /* Destination recieved size array*/
  move 0 to PC0UW00.PC0UWISD[1] for all;
                                   /* Destination irreg shipping size array*/
  move 0 to PC0UW00.PC0UWIRD[1] for all; /* Destination irreg receiving size*/
                                   /* array*/
  set TSTREC empty;

  PC0UW00.PC0UW-FLG-1 = "Y"; /* set flag so label prints*/

  TSTREC.XGPCD = PCWREC.XGPCD;
  TSTREC.PC3PONBR = PCWREC.PC3PONBR; /* PO number*/
  TSTREC.SY1STNBR = PCWREC.SY1STNBR; /* style number*/
  TSTREC.SY2CLRID = PCWREC.SY2CLRID; /* color*/
  TSTREC.XQACD = PCWREC.XQACD; /* quality code*/
  TSTREC.PC2INSEG = PCWREC.PC2INSEG; /**/
  TSTREC.XPGCD = PCWREC.XPGCD; /* packing code*/
  TSTREC.XDMCD = PCWREC.XDMCD; /* dim code*/
  TSTREC.XOWCD = PCWREC.XOWCD; /* owning group*/


  PC0US60(); /* Open ship header/container table*/

   /* ------------------------------------------------------------*/
   /* If there are shipping rows-retrieve all rows from the*/
   /* transporation header/container table for a destination*/
   /* ------------------------------------------------------------*/


  PC0UW00.PC0UWISF = "N"; /* Set irregular ship flag to no*/
  PC0UW00.PC0UWIRF = "N"; /* Set irregular received flag to no*/
  PC0UW00.PC0UWSDF = "N"; /* set shipping data flag to no.*/

  PC0US61(); /* Fetch Transporation row*/



  while (PC0UW00.PC0UWTCF != "Y")

    PC0US62(); /* Process all transporations rows*/

  end

  PC0US63(); /* Close Transporation cursor*/


   /* ------------------------------------------------------------*/
   /* Obtain the receiving data for the PO*/
   /* Load data from the PCWREC to the pcmrec.*/
   /* match the fypo record to a po item.  If it matches, it has*/
   /* already been displayed.  if not, display it.*/
   /* ------------------------------------------------------------*/

  PC0UW00.PC0UWIRF = "N"; /* Irregular quality flag*/
  PC0UW00.PC0UWRDF = "N"; /* Set Received data flag to yes*/

  set VFYPO002 empty;

  VFYPO002.XGPCD = PCWREC.XGPCD;
  VFYPO002.PO-REG-CD = PCWREC.PO-REG-CD; /* PO number*/
  VFYPO002.PC3PONBR = PCWREC.PC3PONBR; /* PO number*/

  PC0US65(); /* Open received cursor*/

   /* ------------------------------------------------------------*/
   /* Retrieve all rows from the received table.*/
   /* ------------------------------------------------------------*/


  PC0US66(); /* Fetch received row*/



  while (PC0UW00.PC0UWRCF != "Y") /* Cursor not at end*/

    PC0UW00.PC0UWRDF = "Y"; /* set Received data flag to yes*/

    PC0US67(); /* Process all received rows*/

  end

  PC0US68(); /* Close received cursor*/



end // end PC0U310

// Obtain PO header
Function PC0US01()

   /* ------------------------------------------------------------*/
   /* Select a unique row.*/
   /* If row not found return a message to the user.*/
   /* If any other, indicate system error.*/
   /* ------------------------------------------------------------*/

  set PCYREC empty;
  PCYREC.PCYFUNC = "S ";
  try
    call "VPOHDR02" (PCYREC, SQLCA, VPOHDR02) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Row found*/


      return;

    end

  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0US01"; /* PROCESS NAME*/
  TA1REC.TA1LOC = "SELECT UNIQUE ROW       ";
  TA1REC.TA1DBASE = "DPRODC  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VPOHDR02"; /* Table view name*/
  TA1REC.TA1TBLKE = VPOHDR02.VPOHDR02-KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0UM001.XXXPRCNM = "PC0US01";
  exit stack;

end // end PC0US01

// Open item cursor
Function PC0US02()

   /* ------------------------------------------------------------*/
   /* Declare cursor for VPOITM05*/
   /* ------------------------------------------------------------*/

  PC0UW00.PC0UWICF = "N"; /* Set item cursor flag to no*/

  set VPOITM05 empty;

  VPOITM05.XGPCD = PCWREC.XGPCD;
  VPOITM05.PO-REG-CD = PCWREC.PO-REG-CD;
  VPOITM05.PC3PONBR = PCWREC.PC3PONBR;
  VPOITM05.YSMXDV = PCWREC.YSMXDV;
  VPOITM05.SY1STNBR = PCWREC.SY1STNBR;

  if (PCWREC.SY2CLRID == " ")
    VPOITM05.SY2CLRID = "*";
  else
    VPOITM05.SY2CLRID = PCWREC.SY2CLRID;
  end

  VPOITM05.XDMCD = PCWREC.XDMCD;
  VPOITM05.XQACD = PCWREC.XQACD;
  VPOITM05.XOWCD = PCWREC.XOWCD;

  if (PCWREC.PC2INSEG == " ")
    VPOITM05.PC2INSEG = "*";
  else
    VPOITM05.PC2INSEG = PCWREC.PC2INSEG;
  end

  VPOITM05.XPGCD = PCWREC.XPGCD;
  VPOITM05.XUMCD = PCWREC.XUMCD;
  VPOITM05.XPLCD = "*";
  VPOITM05.XPRCD = "*";
  VPOITM05.XPCCD = "*";
  VPOITM05.SYBSTGNB = "*";
  VPOITM05.PC6XCTCD = "*";
  VPOITM05.XDSCD = "*";
  VPOITM05.XWHCD = "*";
  VPOITM05.PC2CUXID = "*";
  VPOITM05.PC6STAT = "*";

  set PCYREC empty;
  PCYREC.PCYFUNC = "S6";
  try
    call "VPOITM05" (PCYREC, SQLCA, VPOITM05) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/
    return;
  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0US02"; /* Process name*/
  TA1REC.TA1LOC = "DECLARE CURSOR          ";
  TA1REC.TA1DBASE = "DPRODC  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VPOITM05"; /* Table view name*/
  TA1REC.TA1TBLKE = VPOITM05.VPOITM05-KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0UM001.XXXPRCNM = "PC0US02";
  exit stack;

end // end PC0US02

// Fetch next item row
Function PC0US03()

   /* ------------------------------------------------------------*/
   /* If row not found return to previous process.*/
   /* If any other, indicate system error.*/
   /* ------------------------------------------------------------*/

  set PCYREC empty;
  PCYREC.PCYFUNC = "N6";
  try
    call "VPOITM05" (PCYREC, SQLCA, VPOITM05) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Row found*/
      return;
    end
    if (SQLCA.VAGen_SQLCODE == 100) /* Row not found*/
      PC0UW00.PC0UWICF = "Y"; /* Indicate cursor at EOF*/
      return;
    end

  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0US03"; /* Process name*/
  TA1REC.TA1LOC = "FETCH ROW               ";
  TA1REC.TA1DBASE = "DPRODC  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VPOITM05"; /* Table view name*/
  TA1REC.TA1TBLKE = VPOITM05.VPOITM05-KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0UM001.XXXPRCNM = "PC0US03";
  exit stack;

end // end PC0US03

// Calculate item dates
Function PC0US04()
   /* -----------------------------------------------------*/
    /* Move the dates that do not need to be calculated*/
    /* from the VPOITM05 to working storage to format*/
    /* into MMDDYY format.  Then calculated the other dates*/
   /* ------------------------------------------------------*/

  set PC0UW02 empty; /* Initialize temp storage plan record*/
  set PC0UW22 empty; /* Initialize temp storage plan record2*/
  set PC0UW30 empty;

    /* ETS*/

  if (VPOITM05.PC6ETSDT != 0)
    PC0UW00.PC0UWFDT = VPOITM05.PC6ETSDT; /* ETS date  to WS*/
    PC0UW00.PC0UWMMM = PC0UW00.PC0UWFMM;
    PC0UW00.PC0UWMDD = PC0UW00.PC0UWFDD;
    PC0UW00.PC0UWMYY = PC0UW00.PC0UWFYY;
    PC0UW02.PC0UWETS = PC0UW00.PC0UWMDT; /* MMDDYY screen format*/
    PC0UW22.PC0UWETS = PC0UW00.PC0UWMDT; /* MMDDYY screen format*/
    PC0UW30.PC0UWETS = PC0UW00.PC0UWMDT; /* MMDDYY screen format*/
    PC0UW02.PC0UW2ET = PC0UW00.PC0UWMMD; /* MMDD screen format*/
    PC0UW22.PC0UW2ET = PC0UW00.PC0UWMMD; /* MMDD screen format*/
    PC0UW30.PC0UW2ET = PC0UW00.PC0UWMMD; /* MMDD screen format*/
  end

    /* PETS (original ETS date)*/

  if (VPOITM05.PC6OETS != 0)
    PC0UW00.PC0UWFDT = VPOITM05.PC6OETS; /* PETS date  to WS*/
    PC0UW00.PC0UWMMM = PC0UW00.PC0UWFMM;
    PC0UW00.PC0UWMDD = PC0UW00.PC0UWFDD;
    PC0UW00.PC0UWMYY = PC0UW00.PC0UWFYY;
    PC0UW02.PC0UWOTS = PC0UW00.PC0UWMDT; /* MMDDYY screen format*/
    PC0UW22.PC0UWOTS = PC0UW00.PC0UWMDT; /* MMDDYY screen format*/
    PC0UW30.PC0UWOTS = PC0UW00.PC0UWMDT; /* MMDDYY screen format*/
  end


    /* ETLO-O*/

  if (VPOITM05.PC6OETAL != 0)
    PC0UW00.PC0UWFDT = VPOITM05.PC6OETAL; /* ETLO date  to WS*/
    PC0UW00.PC0UWMMM = PC0UW00.PC0UWFMM;
    PC0UW00.PC0UWMDD = PC0UW00.PC0UWFDD;
    PC0UW00.PC0UWMYY = PC0UW00.PC0UWFYY;
    PC0UW02.PC0UWTAO = PC0UW00.PC0UWMDT; /* MMDD screen format*/
  end

  set PCPREC empty;
  PCPREC.XGPCD = VPOITM05.XGPCD;
  PCPREC.XWHCD = VPOITM05.XWHCD;
  PCPREC.FY1FCTYC = VPOITM05.FY1FCTYC;
  PCPREC.PC2CUXID = VPOITM05.PC2CUXID;
  PCPREC.PC4ORTYP = VPOITM05.PC4ORTYP;
  PCPREC.YMTCD = VPOITM05.YMTCD;
  PCPREC.PC6ETSDT = VPOITM05.PC6ETSDT;
  PCPREC.PC6RTADT = VPOITM05.PC6RTADT;
  PCPREC.YSMXDV = VPOITM05.YSMXDV;

  XSPCS05(); /* Calculate dates*/

  PC0UW00.PC0UWFDT = PCPREC.PCPETALD; /* ETAl date  to WS*/
  PC0UW00.PC0UWMMM = PC0UW00.PC0UWFMM;
  PC0UW00.PC0UWMDD = PC0UW00.PC0UWFDD;
  PC0UW00.PC0UWMYY = PC0UW00.PC0UWFYY;
  PC0UW02.PC0UWTAL = PC0UW00.PC0UWMDT; /* MMDDYY screen format*/
  PC0UW02.PC0UW2EA = PC0UW00.PC0UWMMD; /* MMDD screen format*/
  PC0UW22.PC0UW2EA = PC0UW00.PC0UWMMD; /* MMDD screen format*/
  PC0UW30.PC0UW2EA = PC0UW00.PC0UWMMD; /* MMDD screen format*/

end // end PC0US04

// Calculate date - days
Function PC0US08()

   /* ------------------------------------------------------------*/
   /* Use the called module TA0040 to validate & convert dates.*/
   /* ------------------------------------------------------------*/

  TA2REC.TA2GRTYP = "G"; /* Type*/
  TA2REC.TA2DTOPT = "GREGGREG"; /* Validate and get all greg formats*/

   /* ------------------------------------------------------------*/
   /* Call TA0040*/
   /* ------------------------------------------------------------*/

  try
    call "TA0040" (TA2REC) {isNoRefresh = yes, isExternal = yes};
  end /* Date routine*/

   /* ------------------------------------------------------------*/
   /* If unsuccesful call, indicate a system error has occurred.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/
    return;
  else
    TAEREC.TAEDESC1 = sysVar.errorCode; /* CSP return code*/
    TAEREC.TAEDESC2 = TA2REC.TA2GRGG; /* date sent to validate*/

    PC0UM001.XXXPRCNM = "PC0US08"; /* Module identification*/
    converseLib.validationFailed(01); /* Indicate system error*/

    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    TA1REC.TA1TYPE = "APPL"; /* Type of error*/
    TA1REC.TA1LOC = "CALL TO TA0040 TO EDIT DATE  ";
    TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
    TA1REC.TA1PGMNO = PC0UM001.XXXPRCNM; /* Program number*/
    TA1REC.TA1MAPAP = COMMAREA.CACURRAP; /* Map application*/
    TA1REC.TA1MAPNO = "M001"; /* Map number*/

    call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

    exit stack; /* Exit to display map*/
  end

end // end PC0US08

// Fetch item size row
Function PC0US09()

   /* ------------------------------------------------------------*/
   /* Initialize the record and load the key fields*/
   /* If row not found return to previous process.*/
   /* If any other, indicate system error.*/
   /* ------------------------------------------------------------*/

  VPOSIZ02.XGPCD = VPOITM05.XGPCD; /* GPC code*/
  VPOSIZ02.PO-REG-CD = VPOITM05.PO-REG-CD; /* PO REGION CODE*/
  VPOSIZ02.PC3PONBR = VPOITM05.PC3PONBR; /* PO number*/
  VPOSIZ02.PC6ITMNB = VPOITM05.PC6ITMNB; /* Item sequence number*/


  try
    call "VPOSIZ02" ("S ", SQLCA, VPOSIZ02) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Row found*/
      return;
    end

  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0US09"; /* Process name*/
  TA1REC.TA1LOC = "FETCH SIZE ROW          ";
  TA1REC.TA1DBASE = "DPRODC  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VPOSIZ02"; /* Table view name*/
  TA1REC.TA1TBLKE = VPOSIZ02.VPOSIZ02-KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0UM001.XXXPRCNM = "PC0US09";
  exit stack;

end // end PC0US09

// Move item data to temp storage
Function PC0US10()
   /* ------------------------------------------------------------*/
   /* Move the data from the database records (item and size) to*/
   /* the pc0uW02 storage record--then move the storage group*/
   /* level to the temporary storage record (pc0uW12).*/
   /* Add the total ordered quantity from the Vpoitm05c to the*/
   /* total ordered quantity in working storage.*/
   /* ------------------------------------------------------------*/


  PC0UW02.PC6ITMNB = VPOITM05.PC6ITMNB; /* Item sequence number*/
  PC0UW22.PC6ITMNB = VPOITM05.PC6ITMNB; /* Item sequence number*/
  PC0UW30.PC6ITMNB = VPOITM05.PC6ITMNB; /* Item sequence number*/

  if (PC0UW00.PC0UWICT == 1 /* The first item record*/
   || PC0UW00.PC0UWIXT == 1) /* Or first line on a page*/
    PC0UW02.PC0UW2CL = VPOITM05.SY2CLRID;
    PC0UW22.PC0UW2CL = VPOITM05.SY2CLRID;
    PC0UW30.PC0UW2CL = VPOITM05.SY2CLRID;
    PC0UW02.SY2CLRID = VPOITM05.SY2CLRID;
    PC0UW22.SY2CLRID = VPOITM05.SY2CLRID;
    PC0UW30.SY2CLRID = VPOITM05.SY2CLRID;
  end

  PC0UW02.XQACD = VPOITM05.XQACD;
  PC0UW22.XQACD = VPOITM05.XQACD;
  PC0UW30.XQACD = VPOITM05.XQACD;
  PC0UW02.XOWCD = VPOITM05.XOWCD;
  PC0UW22.XOWCD = VPOITM05.XOWCD;
  PC0UW30.XOWCD = VPOITM05.XOWCD;
  PC0UW02.PC2INSEG = VPOITM05.PC2INSEG;
  PC0UW22.PC2INSEG = VPOITM05.PC2INSEG;
  PC0UW30.PC2INSEG = VPOITM05.PC2INSEG;
  PC0UW02.XPGCD = VPOITM05.XPGCD;
  PC0UW22.XPGCD = VPOITM05.XPGCD;
  PC0UW30.XPGCD = VPOITM05.XPGCD;
  PC0UW02.XWHCD = VPOITM05.XWHCD;
  PC0UW22.XWHCD = VPOITM05.XWHCD;
  PC0UW30.XWHCD = VPOITM05.XWHCD;
  PC0UW02.PC2CUXID = VPOITM05.PC2CUXID;
  PC0UW22.PC2CUXID = VPOITM05.PC2CUXID;
  PC0UW30.PC2CUXID = VPOITM05.PC2CUXID;
  PC0UW02.PC6STAT = VPOITM05.PC6STAT;
  PC0UW22.PC6STAT = VPOITM05.PC6STAT;
  PC0UW30.PC6STAT = VPOITM05.PC6STAT;
  if (VPOITM05.PC-SAP-PO-NBR != " ") /* SAP   number exists*/
    PC0UW00.PC0UWSAP = VPOITM05.PC-SAP-PO-NBR; /* SAP number*/
    PC0UW30.PC0UWSAP = PC0UW00.PC0UWSAP;
  else
    PC0UW30.PC0UWSAP = " "; /* formatted sap number*/
  end
  if (VPOITM05.OP1CUOID != 0) /* Something there*/
    PC0UW00.PC0UWCOR = VPOITM05.OP1CUOID; /* Sales order nbr*/
    PC0UW00.PC0UWDOT = "."; /* Period literal*/
    PC0UW00.PC0UWNOR = VPOITM05.OP1NORID; /* Nike order nbr*/
    PC0UW22.PC0UWSNN = PC0UW00.PC0UWORD; /* formatted sales/nike ord*/
  else
    PC0UW00.PC0UWCOR = 0; /* Sales order nbr*/
    PC0UW00.PC0UWDOT = " "; /* Period literal*/
    PC0UW00.PC0UWNOR = 0; /* Nike order nbr*/
    PC0UW22.PC0UWSNN = " "; /* formatted sales/nike ord*/
  end

     /* Updated date*/

  PC0UW00.PC0UWFDT = VPOITM05.ZZZCHGDT; /* Update date to WS*/
  PC0UWMMM = PC0UW00.PC0UWFMM;
  PC0UWMDD = PC0UW00.PC0UWFDD;
  PC0UWMYY = PC0UW00.PC0UWFYY;
  PC0UW02.PC0UWUPD = PC0UW00.PC0UWMDT; /* MMDDYY date to temp storage*/
  PC0UW22.PC0UWUPD = PC0UW00.PC0UWMDT; /* MMDDYY date to temp storage*/
  PC0UW30.PC0UWUPD = PC0UW00.PC0UWMDT; /* MMDDYY date to temp storage*/
  PC0UW02.YMTCD = VPOITM05.YMTCD;
  PC0UW22.YMTCD = VPOITM05.YMTCD;
  PC0UW30.YMTCD = VPOITM05.YMTCD;
  PC0UW02.PC0UW2QA = VPOITM05.XQACD;
  PC0UW22.PC0UW2QA = VPOITM05.XQACD;
  PC0UW30.PC0UW2QA = VPOITM05.XQACD;
  PC0UW02.PC0UW2SP = VPOITM05.PC2INSEG;
  PC0UW22.PC0UW2SP = VPOITM05.PC2INSEG;
  PC0UW30.PC0UW2SP = VPOITM05.PC2INSEG;
  PC0UW02.PC0UW2PK = VPOITM05.XPGCD;
  PC0UW22.PC0UW2PK = VPOITM05.XPGCD;
  PC0UW30.PC0UW2PK = VPOITM05.XPGCD;
  PC0UW02.PC0UW2OW = VPOITM05.XOWCD;
  PC0UW22.PC0UW2OW = VPOITM05.XOWCD;
  PC0UW30.PC0UW2OW = VPOITM05.XOWCD;
  PC0UW02.PC0UW2ST = VPOITM05.PC6STAT;
  PC0UW22.PC0UW2ST = VPOITM05.PC6STAT;
  PC0UW30.PC0UW2ST = VPOITM05.PC6STAT;
  PC0UW02.PC0UW2PL = VPOITM05.PC6PLAN;
  PC0UW22.PC0UW2PL = VPOITM05.PC6PLAN;
  PC0UW22.PC0UW2PL = VPOITM05.PC6PLAN;
  PC0UW30.PC0UW2PL = VPOITM05.PC6PLAN;
  PC0UW02.PC0UWPLN = VPOITM05.PC6PLAN;
  PC0UW22.PC0UWPLN = VPOITM05.PC6PLAN;
  PC0UW30.PC0UWPLN = VPOITM05.PC6PLAN;
  PC0UW02.PC0UW2MT = VPOITM05.YMTCD;
  PC0UW22.PC0UW2MT = VPOITM05.YMTCD;
  PC0UW30.PC0UW2MT = VPOITM05.YMTCD;


  PC0UW02.PC0UWQTY = VPOITM05.PC6TORDE; /* Quantity to storage*/
  PC0UW22.PC0UWQTY = VPOITM05.PC6TORDE; /* Quantity to storage*/
  PC0UW30.PC0UWQTY = VPOITM05.PC6TORDE; /* Quantity to storage*/


   /* Add ordered qty to total by destination, color and style*/


  PC0UW00.PC0UWWF1 = VPOITM05.PC6TORDE;
  PC0UW00.PC0UWTID[PC0UWDIX] = PC0UW00.PC0UWTID[PC0UWDIX] + PC0UWWF1;
  PC0UW00.PC0UWTIC = PC0UW00.PC0UWTIC + VPOITM05.PC6TORDE; /* Color*/
  PC0UW00.PC0UWTIS = PC0UW00.PC0UWTIS + VPOITM05.PC6TORDE; /* Style*/

   /* ------------------------------------------------------------*/
   /* Move the size quantities from the size array in the PC7REC*/
   /* to the size array in the temporary storage record (when*/
   /* there are quanitites for a size). In addition move a 'y'*/
   /* to the corresponding fields in the working storage array*/
   /* to indicate that the table entry had a quantity.  This*/
   /* flag will be used to determine what sizes will be*/
   /* displayed on the size screen.  (The users only want to*/
   /* see a size if it has a quantity associated with it).*/
   /* The FOB price is also moved to a 40 occurs table in*/
   /* the working storage record.*/
   /* Add the size quantities into the size quantity array*/
   /* for item data in working storage.*/
   /* ------------------------------------------------------------*/

  PC0UW00.PC0UWIX1 = 1; /* Initialize general index*/

  while (PC0UW00.PC0UWIX1 <= 40)

    if (VPOSIZ02.PC7ORDEQ[PC0UWIX1] != 0)

      PC0UW02.PC0UWORQ[PC0UWIX1] = VPOSIZ02.PC7ORDEQ[PC0UWIX1];
      PC0UW22.PC0UWORQ[PC0UWIX1] = VPOSIZ02.PC7ORDEQ[PC0UWIX1];
      PC0UW00.PC0UWSTB[PC0UWIX1] = "Y"; /* size flag set to yes*/
      PC0UW00.PC0UWWSZ = 0; /* Initialize work field*/
      PC0UW00.PC0UWWSZ = VPOSIZ02.PC7ORDEQ[PC0UWIX1];

       /* Add size quantity to total item size quantity,destination,*/
       /* color and style*/

      PC0UW00.PC0UWISZ[PC0UWIX1] = PC0UW00.PC0UWISZ[PC0UWIX1] + PC0UWWSZ;
      PC0UW00.PC0UWICZ[PC0UWIX1] = PC0UW00.PC0UWICZ[PC0UWIX1] + PC0UWWSZ;

      PC0US11(); /* Add to destination size table*/

    end
    PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
  end

end // end PC0US10

// Add to dest size array
Function PC0US11()

   /* ------------------------------------------------------------*/
   /* Add to destination size array table.*/
   /* ------------------------------------------------------------*/

  if (PC0UW00.PC0UWDIX == 1)
    PC0UW00.PC0UWD01[PC0UWIX1] = PC0UW00.PC0UWD01[PC0UWIX1] + PC0UWWSZ;
    return;
  end

  if (PC0UW00.PC0UWDIX == 2)
    PC0UW00.PC0UWD02[PC0UWIX1] = PC0UW00.PC0UWD02[PC0UWIX1] + PC0UWWSZ;
    return;
  end

  if (PC0UW00.PC0UWDIX == 3)
    PC0UW00.PC0UWD03[PC0UWIX1] = PC0UW00.PC0UWD03[PC0UWIX1] + PC0UWWSZ;
    return;
  end

  if (PC0UW00.PC0UWDIX == 4)
    PC0UW00.PC0UWD04[PC0UWIX1] = PC0UW00.PC0UWD04[PC0UWIX1] + PC0UWWSZ;
    return;
  end

  if (PC0UW00.PC0UWDIX == 5)
    PC0UW00.PC0UWD05[PC0UWIX1] = PC0UW00.PC0UWD05[PC0UWIX1] + PC0UWWSZ;
    return;
  end

  if (PC0UW00.PC0UWDIX == 6)
    PC0UW00.PC0UWD06[PC0UWIX1] = PC0UW00.PC0UWD06[PC0UWIX1] + PC0UWWSZ;
    return;
  end

  if (PC0UW00.PC0UWDIX == 7)
    PC0UW00.PC0UWD07[PC0UWIX1] = PC0UW00.PC0UWD07[PC0UWIX1] + PC0UWWSZ;
    return;
  end

  if (PC0UW00.PC0UWDIX == 8)
    PC0UW00.PC0UWD08[PC0UWIX1] = PC0UW00.PC0UWD08[PC0UWIX1] + PC0UWWSZ;
    return;
  end

  if (PC0UW00.PC0UWDIX == 9)
    PC0UW00.PC0UWD09[PC0UWIX1] = PC0UW00.PC0UWD09[PC0UWIX1] + PC0UWWSZ;
    return;
  end

  if (PC0UW00.PC0UWDIX == 10)
    PC0UW00.PC0UWD10[PC0UWIX1] = PC0UW00.PC0UWD10[PC0UWIX1] + PC0UWWSZ;
    return;
  end

  if (PC0UW00.PC0UWDIX == 11)
    PC0UW00.PC0UWD11[PC0UWIX1] = PC0UW00.PC0UWD11[PC0UWIX1] + PC0UWWSZ;
    return;
  end

  if (PC0UW00.PC0UWDIX == 12)
    PC0UW00.PC0UWD12[PC0UWIX1] = PC0UW00.PC0UWD12[PC0UWIX1] + PC0UWWSZ;
    return;
  end
  if (PC0UW00.PC0UWDIX == 13)
    PC0UW00.PC0UWD13[PC0UWIX1] = PC0UW00.PC0UWD13[PC0UWIX1] + PC0UWWSZ;
    return;
  end

  if (PC0UW00.PC0UWDIX == 14)
    PC0UW00.PC0UWD14[PC0UWIX1] = PC0UW00.PC0UWD14[PC0UWIX1] + PC0UWWSZ;
    return;
  end

  if (PC0UW00.PC0UWDIX == 15)
    PC0UW00.PC0UWD15[PC0UWIX1] = PC0UW00.PC0UWD15[PC0UWIX1] + PC0UWWSZ;
    return;
  end

  if (PC0UW00.PC0UWDIX == 16)
    PC0UW00.PC0UWD16[PC0UWIX1] = PC0UW00.PC0UWD16[PC0UWIX1] + PC0UWWSZ;
    return;
  end

  if (PC0UW00.PC0UWDIX == 17)
    PC0UW00.PC0UWD17[PC0UWIX1] = PC0UW00.PC0UWD17[PC0UWIX1] + PC0UWWSZ;
    return;
  end

  if (PC0UW00.PC0UWDIX == 18)
    PC0UW00.PC0UWD18[PC0UWIX1] = PC0UW00.PC0UWD18[PC0UWIX1] + PC0UWWSZ;
    return;
  end

  if (PC0UW00.PC0UWDIX == 19)
    PC0UW00.PC0UWD19[PC0UWIX1] = PC0UW00.PC0UWD19[PC0UWIX1] + PC0UWWSZ;
    return;
  end

  if (PC0UW00.PC0UWDIX == 20)
    PC0UW00.PC0UWD20[PC0UWIX1] = PC0UW00.PC0UWD20[PC0UWIX1] + PC0UWWSZ;
    return;
  end


end // end PC0US11

// Add record to temp storage
Function PC0US12()

   /* ------------------------------------------------------------*/
   /* Add the next page to temporary storage.*/
   /* ------------------------------------------------------------*/

  PC0UW12.PC0UWTSL = PC0UW00.PC0UWTSL; /* Temporary storage length*/
  TA5REC.TA5APPID = COMMAREA.CACURRAP; /* Application identification*/
  TA5REC.TA5FNCCD = "A"; /* Function code*/

  try
    call "TA0050" (PC0UW12, TA5REC) {isNoRefresh = yes, isExternal = yes};
  end /* Temporary storage*/

   /* ------------------------------------------------------------*/
   /* If successful, initialize the storage areas and indicators*/
   /* to be used.  Return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && TA5REC.TA5RTNCD == 0)          /* and normal return code*/

    set PC0UW12 empty; /* Temp storage record*/

    PC0UW00.TA5TSQIX = TA5REC.TA5TSQIX; /* Highest page number*/
    TA5REC.TA5TSQIX = 0; /* Current page number*/
    PC0UW00.PC0UWIXT = 0; /* Temp storage line index*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TAEREC.TAEDESC1 = sysVar.errorCode; /* CSP return code*/
  TAEREC.TAEDESC2 = TA5REC.TA5DATA; /* Subroutine parameters*/

  PC0UM001.XXXPRCNM = "PC0US12"; /* Module identification*/
  converseLib.validationFailed(10); /* Indicate system error*/

  TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  TA1REC.TA1TYPE = "APPL"; /* Type of error*/
  TA1REC.TA1LOC = "ADD PAGE TO TEMPORARY STORAGE";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = PC0UM001.XXXPRCNM; /* Program number*/
  TA1REC.TA1MAPAP = COMMAREA.CACURRAP; /* Map application*/
  TA1REC.TA1MAPNO = "PC0UM001"; /* Map number*/

  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end PC0US12

// Open ship header/container cur
Function PC0US13()

   /* ------------------------------------------------------------*/
   /* Declare cursor for vcplhd02*/
   /* ------------------------------------------------------------*/

  PC0UW00.PC0UWTCF = "N"; /* Set trans cursor flag to no*/


  try
    call "IO4230" ("S6", SQLCA, TSTREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/
    return;
  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0US13"; /* Process name*/
  TA1REC.TA1LOC = "DECLARE CURSOR          ";
  TA1REC.TA1DBASE = "DTRANS  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCPLHD02"; /* Table view name*/
  TA1REC.TA1TBLKE = TSTREC.TSTKEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0UM001.XXXPRCNM = "PC0US13";
  exit stack;

end // end PC0US13

// Fetch transportation row
Function PC0US14()

   /* ------------------------------------------------------------*/
   /* If row found return to calling processes--if not found*/
   /* set end of cursor flag --in other errors call ta0020*/
   /* ------------------------------------------------------------*/

  try
    call "IO4230" ("N6", SQLCA, TSTREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Row found*/
      return;
    end
    if (SQLCA.VAGen_SQLCODE == 100) /* Row not found*/
      PC0UW00.PC0UWTCF = "Y"; /* Indicate cursor at EOF*/
      return;
    end

  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0US14"; /* Process name*/
  TA1REC.TA1LOC = "FETCH ROW               ";
  TA1REC.TA1DBASE = "DTRANS  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCPLHD02"; /* Table view name*/
  TA1REC.TA1TBLKE = TSTREC.TSTKEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0UM001.XXXPRCNM = "PC0US14";
  exit stack;

end // end PC0US14

// Process all transportation row
Function PC0US15()

   /* ------------------------------------------------------------*/
   /* If the status on the transporation row is equal to 'rc'*/
   /* bypass the row.*/
   /* ------------------------------------------------------------*/

  if (TSTREC.TSISTAT == "TN" /* Tentative*/
   || TSTREC.TSISTAT == "IT" /* Intransit*/
   || TSTREC.TSISTAT == "CC" /* Cleared customs*/
   || TSTREC.TSISTAT == "CR" /* Cleared customs / Hard error*/
   || TSTREC.TSISTAT == "ER") /* Shipped / Hard error*/
     /* next sentence*/
  else

    PC0US14(); /* Fetch next transporation row*/

    return;
  end


   /* ------------------------------------------------------------*/
   /* Obtain all the container rows for the Nike Shipping ID*/
   /* key.  Load the status for each container into a working*/
   /* storage table. If the status is not a valid status then the*/
   /* record will not be processed.  The quantities for any*/
   /* container with a valid status will be added into the*/
   /* accumulated totals. When the shipping header record has*/
   /* a status of 'tn' or 'cr' or 'er' the quantities are not to*/
   /* be added into any of the total fields.*/
   /* ------------------------------------------------------------*/

  move " " to PC0UW00.TSHSTAT[1] for all; /* Init ws container status table.*/
  move 0 to PC0UW00.TSHNKCN[1] for all; /* init ws container numbers table*/

  PC0UW00.TSHNKCN[1] = TSTREC.TSHNKCN1;
                                   /* move nike cntnr nbrs to tbl*/
  PC0UW00.TSHNKCN[2] = TSTREC.TSHNKCN2;
  PC0UW00.TSHNKCN[3] = TSTREC.TSHNKCN3;
  PC0UW00.TSHNKCN[4] = TSTREC.TSHNKCN4;
  PC0UW00.TSHNKCN[5] = TSTREC.TSHNKCN5;
  PC0UW00.TSHNKCN[6] = TSTREC.TSHNKCN6;
  PC0UW00.TSHNKCN[7] = TSTREC.TSHNKCN7;
  PC0UW00.TSHNKCN[8] = TSTREC.TSHNKCN8;

  PC0UW00.PC0UWSHQ[1] = TSTREC.TSISHPQ1;
                                   /* move nike cntnr qty to tbl*/
  PC0UW00.PC0UWSHQ[2] = TSTREC.TSISHPQ2;
  PC0UW00.PC0UWSHQ[3] = TSTREC.TSISHPQ3;
  PC0UW00.PC0UWSHQ[4] = TSTREC.TSISHPQ4;
  PC0UW00.PC0UWSHQ[5] = TSTREC.TSISHPQ5;
  PC0UW00.PC0UWSHQ[6] = TSTREC.TSISHPQ6;
  PC0UW00.PC0UWSHQ[7] = TSTREC.TSISHPQ7;
  PC0UW00.PC0UWSHQ[8] = TSTREC.TSISHPQ8;

  set TSHREC empty; /* Initialize record*/

  TSHREC.TSFSHPID = TSTREC.TSFSHPID; /* Key*/

  PC0UW00.PC0UWIX3 = 1;
  while (PC0UW00.PC0UWIX3 <= 8 /* not end of cntnr status table*/
   && PC0UW00.TSHNKCN[PC0UWIX3] != 0)

    /* -----------------------------------------------------*/
      /* If the status on the container row is not equal*/
      /* to 'rc' move the status to the working*/
      /* storage table.*/
    /* ------------------------------------------------------*/

    TSHREC.TSHNKCN = PC0UW00.TSHNKCN[PC0UWIX3];
    PC0US16(); /* get container row*/

    if (TSHREC.TSHSTAT == "RC")
      /* next sentence*/
    else
      if (TSTREC.TSISTAT == "TN" /* Tentative*/
       && SQLCA.VAGen_SQLCODE == 100) /* and no container found*/
        PC0UW00.TSHSTAT[PC0UWIX3] = "TN";
      else
        PC0UW00.TSHSTAT[PC0UWIX3] = TSHREC.TSHSTAT;
      end
    end

    PC0UW00.PC0UWIX3 = PC0UW00.PC0UWIX3 + 1; /* increment while index*/

  end

  if (PC0UW00.TSHSTAT[1] == " " /* If there is no valid status for*/
   && PC0UW00.TSHSTAT[2] == " " /* any containers--obtain*/
   && PC0UW00.TSHSTAT[3] == " " /* the next header row and*/
   && PC0UW00.TSHSTAT[4] == " " /* exit the routine.*/
   && PC0UW00.TSHSTAT[5] == " " 
   && PC0UW00.TSHSTAT[6] == " " 
   && PC0UW00.TSHSTAT[7] == " " 
   && PC0UW00.TSHSTAT[8] == " ")

    PC0US14(); /* Fetch next transporation row*/

    return;

  end

   /* ------------------------------------------------------------*/
   /* Calculate the dates.*/
   /* Retrieve the size rows.*/
   /* Load the data to the temporary storage record.*/
   /* Write a temporary storage record if the page is full.*/
   /* ------------------------------------------------------------*/

   /* Increment page line index*/

  PC0UW00.PC0UWIXT = PC0UW00.PC0UWIXT + 1;


  set PC0UW03 empty; /* Initialize records*/
  set PC0UW23 empty;

  PC0US19(); /* Calculate shipping dates*/

   /* Set flag to indicate shipping data exists*/

  PC0UW00.PC0UWSDF = "Y"; /* Shipping data flag*/

   /* Move intransit data from TSTREC to temp storage record*/

  if (PC0UW00.PC0UWISF == "Y") /* Irregular shipping flag*/
    PC0UW03.PC0UW03I = "IR"; /* Irregular literal*/
    PC0UW03.PC0UWIRT = "IR"; /* Screen two irregular literal*/
    PC0UW23.PC0UW03I = "IR"; /* Irregular literal*/
    PC0UW23.PC0UWIRT = "IR"; /* Screen two irregular literal*/
  end

  if (TSHREC.TSHSTAT == "IT"
   || TSHREC.TSHSTAT == "CC")
    PC0UW03.PC0UW03L = " INTRANSIT:"; /* Intransit literal*/
    PC0UW23.PC0UW03L = " INTRANSIT:"; /* Intransit literal*/
    if (TSTREC.XWHCD != " ")
      PC0UW03.PC0UWIWL = " IN WH:"; /* Screen 2 in whse literal*/
      PC0UW03.PC0UWWHS = TSTREC.XWHCD; /* Screen two warehouse code*/
      PC0UW23.PC0UWIWL = " IN WH:"; /* Screen 2 in whse literal*/
      PC0UW23.PC0UWWHS = TSTREC.XWHCD; /* Screen two warehouse code*/
    end
  else
    PC0UW03.PC0UW03L = "*INTRANSIT:"; /* Intransit literal*/
    PC0UW23.PC0UW03L = "*INTRANSIT:"; /* Intransit literal*/
    if (TSTREC.XWHCD != " ")
      PC0UW03.PC0UWIWL = "*IN WH:"; /* Screen 2 in whse literal*/
      PC0UW03.PC0UWWHS = TSTREC.XWHCD; /* Screen two warehouse code*/
      PC0UW23.PC0UWIWL = "*IN WH:"; /* Screen 2 in whse literal*/
      PC0UW23.PC0UWWHS = TSTREC.XWHCD; /* Screen two warehouse code*/
    end
  end

  PC0UW03.XWHCD = TSTREC.XWHCD;
  PC0UW23.XWHCD = TSTREC.XWHCD;
  PC0UW03.PC2CUXID = TSTREC.PC2CUXID;
  PC0UW23.PC2CUXID = TSTREC.PC2CUXID;
  PC0UW03.TSISTAT = TSTREC.TSISTAT; /* Status*/
  PC0UW23.TSISTAT = TSTREC.TSISTAT; /* Status*/
  PC0UW03.PC0UW-SLASH = "/";
  PC0UW23.PC0UW-SLASH = "/";
  PC0UW03.YSTCD = TSTREC.YSTCD; /* Shipment type*/
  PC0UW23.YSTCD = TSTREC.YSTCD; /* shipment type*/
  PC0UW00.PC0UWFDT = TSTREC.TSFSTADT; /* Status date to ws*/
  PC0UW03.TSFSHPID = TSTREC.TSFSHPID;
  PC0UW23.TSFSHPID = TSTREC.TSFSHPID;
  PC0UW03.TSIPLNBR = TSTREC.TSIPLNBR;
  PC0UW23.TSIPLNBR = TSTREC.TSIPLNBR;
  PC0UW00.PC0UWMMM = PC0UW00.PC0UWFMM;
  PC0UW00.PC0UWMDD = PC0UW00.PC0UWFDD;
  PC0UW03.PC0UWSTD = PC0UW00.PC0UWMMD;
  PC0UW23.PC0UWSTD = PC0UW00.PC0UWMMD;
  PC0UW03.TSACARCD = TSTREC.TSACARCD; /* Carrier code*/
  PC0UW23.TSACARCD = TSTREC.TSACARCD; /* Carrier code*/
  PC0UW03.TS5CRAFT = TSTREC.TS5CRAFT; /* craft*/
  PC0UW23.TS5CRAFT = TSTREC.TS5CRAFT; /* craft*/

   /* Get rid of leading zeros for the shipping number*/


  PC0UW00.PC0UWSHX = TSTREC.TSFSHPID; /* numeric field*/
  PC0UW00.PC0UWSHW = PC0UW00.PC0UWSHX; /* Move to character field*/

   /* Find first significant digit*/

  PC0UW00.PC0UWIX4 = 1;

  while (PC0UW00.PC0UWIX4 <= 8
   && PC0UW00.PC0UWSHA[PC0UWIX4] == "0")
    PC0UW00.PC0UWSHA[PC0UWIX4] = " ";
    PC0UW00.PC0UWIX4 = PC0UW00.PC0UWIX4 + 1;
  end

  PC0UW03.PC0UWSHN = PC0UW00.PC0UWSHW; /* Shipping number*/
  PC0UW23.PC0UWSHN = PC0UW00.PC0UWSHW; /* Shipping number*/

   /* *************************************************************/
   /* If the status for the container was equal to 'it' or 'cc'*/
   /* Add the quantities from the shipping record to the*/
   /* total shipping quantity field and obtain all the*/
   /* size data for the container.*/
   /* *************************************************************/

  PC0UW00.PC0UWWF1 = 0; /* Initialize 'it''cc' work qty field*/
  PC0UW00.PC0UWWT1 = 0; /* Initialize 'tn' work qty field*/

  PC0UW00.PC0UWIX3 = 1;
  while (PC0UWIX3 <= 8
   && PC0UW00.TSHNKCN[PC0UWIX3] != 0)
    if (PC0UW00.TSHSTAT[PC0UWIX3] != " ")
      if (TSTREC.TSISTAT == "IT"
       || TSTREC.TSISTAT == "CC")
        PC0UW00.PC0UWWF1 = PC0UW00.PC0UWWF1 + PC0UW00.PC0UWSHQ[PC0UWIX3];
      else
         /* ==> tentative or hard errors only show a total on the*/
         /* ==>   screen and don't calculate into the regular totals*/
        PC0UW00.PC0UWWT1 = PC0UW00.PC0UWWT1 + PC0UW00.PC0UWSHQ[PC0UWIX3];
      end
      set TSOREC empty;
      TSOREC.TSFSHPID = TSTREC.TSFSHPID; /* Nike ship Id*/
      TSOREC.TSIPLNBR = TSTREC.TSIPLNBR; /* Nike plan number*/
      TSOREC.TSHNKCN = PC0UW00.TSHNKCN[PC0UWIX3]; /* Container nbr*/
      PC0US20(); /* Obtain intransit size data*/
    end

    PC0UW00.PC0UWIX3 = PC0UW00.PC0UWIX3 + 1;

  end

  if (TSTREC.TSISTAT == "IT"
   || TSTREC.TSISTAT == "CC")
    PC0UW03.PC0UWQTY = PC0UW00.PC0UWWF1;
    PC0UW23.PC0UWQTY = PC0UW00.PC0UWWF1;
  else
    PC0UW03.PC0UWQTY = PC0UW00.PC0UWWT1; /* for tentative/hard errors*/
    PC0UW23.PC0UWQTY = PC0UW00.PC0UWWT1; /* for tentative/hard errors*/
  end


  if (PC0UW00.PC0UWISF == "Y") /* If irregular shipping data*/
    PC0UW00.PC0UWIDS = PC0UW00.PC0UWIDS + PC0UWWF1; /* Irreg by destination*/
    PC0UW00.PC0UWICS = PC0UW00.PC0UWICS + PC0UWWF1; /* Irreg by color*/
    PC0UW00.PC0UWISS = PC0UW00.PC0UWICS + PC0UWWF1; /* Irreg by style*/
  else
    PC0UW00.PC0UWTDS = PC0UW00.PC0UWTDS + PC0UWWF1; /* Total by destination*/
    PC0UW00.PC0UWTCS = PC0UW00.PC0UWTCS + PC0UWWF1; /* Total by color*/
    PC0UW00.PC0UWTSS = PC0UW00.PC0UWTSS + PC0UWWF1; /* Total by style*/
  end

  if (PC0UW00.PC0UWDTF == "1") /* Etal data*/
    PC0UW03.PC0UW03K = 3; /* Record key*/
    PC0UW12.PC0UW12R[PC0UWIXT] = PC0UW03.PC0UW03G;
  else /* s.o. data*/
    PC0UW23.PC0UW03K = 23; /* Record key*/
    PC0UW12.PC0UW12R[PC0UWIXT] = PC0UW23.PC0UW03G;
  end

  if (PC0UW00.PC0UWIXT == PC0UW00.PC0UWMAX) /* Max lines (13)*/

    PC0US12(); /* Add page to temp storage*/

  end

  PC0US14(); /* Fetch next vcplhd02 row*/

end // end PC0US15

// Get Unique Dtrans.Vcntnr01 row
Function PC0US16()

   /* ------------------------------------------------------------*/
   /* Get a Row From Dtrans.vcntnr01*/
   /* ------------------------------------------------------------*/


  try
    call "IO2590" ("SA", SQLCA, TSHREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0) /* and normal return code*/
      return;
    else
      if (SQLCA.VAGen_SQLCODE == 100 /* record not found*/
       && TSTREC.TSISTAT == "TN")    /* and status = 'TN'*/
        return;
      end
    end
  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0US16"; /* Process name*/
  TA1REC.TA1LOC = "SELECT UNIQUE ALTERNATE ";
  TA1REC.TA1DBASE = "DTRANS  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCNTNR01"; /* Table view name*/
  TA1REC.TA1TBLKE = TSHREC.TSHKEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0UM001.XXXPRCNM = "PC0US16";
  exit stack;

end // end PC0US16

// Calculate shipping dates
Function PC0US19()


   /* -----------------------------------------------------*/
    /* Move the dates that do not need to be calculated*/
    /* from the TSTREC to working storage to format*/
    /* into MMDD format.  Then calculated the other dates*/
   /* ------------------------------------------------------*/

    /* ETAL override*/

  if (PC0UW00.PC0UWDTF == "1") /* etal data*/
    if (TSTREC.TSIETALO != 0)
      PC0UW00.PC0UWFDT = TSTREC.TSIETALO;
      PC0UW00.PC0UWMMM = PC0UW00.PC0UWFMM;
      PC0UW00.PC0UWMDD = PC0UW00.PC0UWFDD;
      PC0UW00.PC0UWMYY = PC0UW00.PC0UWFYY;
      PC0UW03.PC0UWTAO = PC0UW00.PC0UWMDT; /* MMDDYY screen format*/
    end
  else
    if (TSTREC.OP1CUOID != 0)
      PC0UW00.PC0UWCOR = TSTREC.OP1CUOID;
      PC0UW00.PC0UWDOT = ".";
      PC0UW00.PC0UWNOR = TSTREC.OP1NORID;
      PC0UW23.PC0UWSNN = PC0UW00.PC0UWORD;
    else
      PC0UW00.PC0UWCOR = 0;
      PC0UW00.PC0UWDOT = " ";
      PC0UW00.PC0UWNOR = 0;
      PC0UW23.PC0UWSNN = " ";
    end
  end

    /* ETS (Estimated departure date)*/

  PC0UW00.PC0UWFDT = 0;

  if (TSTREC.TSISTAT == "TN")
    PC0UW00.PC0UWFDT = TSTREC.TSFDPRTE; /* Estimate departure time*/
    PC0UW00.PC0UWMMM = PC0UW00.PC0UWFMM;
    PC0UW00.PC0UWMDD = PC0UW00.PC0UWFDD;
    PC0UW00.PC0UWMYY = PC0UW00.PC0UWFYY;
    PC0UW03.PC0UWETS = PC0UW00.PC0UWMDT; /* MMDDYY screen format*/
    PC0UW03.PC0UW2TS = PC0UW00.PC0UWMMD; /* MMDD screen format*/
    PC0UW23.PC0UWETS = PC0UW00.PC0UWMDT; /* MMDDYY screen format*/
    PC0UW23.PC0UW2TS = PC0UW00.PC0UWMMD; /* MMDD screen format*/
  else
    PC0UW00.PC0UWFDT = TSTREC.TSFDPRTA; /* Actual departure time*/
    PC0UW00.PC0UWMMM = PC0UW00.PC0UWFMM;
    PC0UW00.PC0UWMDD = PC0UW00.PC0UWFDD;
    PC0UW00.PC0UWMYY = PC0UW00.PC0UWFYY;
    PC0UW03.PC0UWETS = PC0UW00.PC0UWMDT; /* MMDDYY screen format*/
    PC0UW03.PC0UW2TS = PC0UW00.PC0UWMMD; /* MMDD screen format*/
    PC0UW23.PC0UWETS = PC0UW00.PC0UWMDT; /* MMDDYY screen format*/
    PC0UW23.PC0UW2TS = PC0UW00.PC0UWMMD; /* MMDD screen format*/
  end



   /* -----------------------------------------------------*/
    /* Calculate the ETAL (Estimated time of allocation)*/
    /* date. ETAL = ETA (or RTA) + PADD*/
   /* ------------------------------------------------------*/



  set TA2REC empty; /* Initialize date record*/

  if (TSTREC.XWHCD != " "
   && TSTREC.XWHCD in XWHTBL.XWHCD)

    set TA2REC empty; /* Initialize record*/
    if (TSTREC.XGPCD == "03")
      if (TSTREC.XWHCD == "51" && 
      VFCTY003.PC-XCT-ORIG-CD == " ")
        if (VFCTY003.XCTCD == "USA")
          TA2REC.TA2DYAOD = 2; /* Padd days*/
        else
          TA2REC.TA2DYAOD = XWHTBL.XWHPAD[sysVar.arrayIndex]; /* Padd days*/
        end
      else
        if (TSTREC.XWHCD == "51" && 
        VFCTY003.PC-XCT-ORIG-CD == "USA")
          TA2REC.TA2DYAOD = 2; /* Padd days*/
        else
          TA2REC.TA2DYAOD = XWHTBL.XWHPAD[sysVar.arrayIndex]; /* Padd days*/
        end
      end
    else
      TA2REC.TA2DYAOD = XWHTBL.XWHPAD[sysVar.arrayIndex]; /* Padd days*/
    end
  else
    TA2REC.TA2DYAOD = 0; /* no PAD*/
  end

  if (TSTREC.TSFDESTA > 0)
    TA2REC.TA2GRGGN = TSTREC.TSFDESTA; /* RTA DATE*/
  else
    TA2REC.TA2GRGGN = TSTREC.TSFDESTE; /* ETa date*/
  end

  PC0US08(); /* Calculate date - days*/

  PC0UW00.PC0UWFDT = TA2REC.TA2GRGGN; /* ETAl date  to WS*/

   /* IF PCWREC.XGPCD EQ '03';*/
    /* IF PC0UW00.PC0UWFDD GE 21;*/
      /* IF PC0UW01.PC4ORTYP NE 'MM'*/
      /* AND PC0UW01.PC4ORTYP NE 'MD'*/
      /* AND PC0UW01.PC4ORTYP NE 'DS'*/
      /* AND PC0UW01.PC4ORTYP NE 'BA';*/
        /* MOVE 1 TO PC0UW00.PC0UWFDD;*/
        /* IF PC0UW00.PC0UWFMM EQ 12;*/
          /* MOVE 1 TO PC0UW00.PC0UWFMM;*/
          /* IF PC0UW00.PC0UWFYY EQ 99;*/
            /* MOVE 0 TO PC0UW00.PC0UWFYY;*/
            /* PC0UW00.PC0UWFCT = PC0UW00.PC0UWFCT + 1;*/
          /* ELSE;*/
            /* PC0UW00.PC0UWFYY = PC0UW00.PC0UWFYY + 1;*/
          /* END;*/
       /* ELSE;*/
         /* PC0UW00.PC0UWFMM = PC0UW00.PC0UWFMM + 1;*/
       /* END;*/
     /* END;*/
   /* END;*/
   /* eND;*/

  if (PC0UW00.PC0UWDTF == "1") /* etal data*/
    PC0UW00.PC0UWMMM = PC0UW00.PC0UWFMM;
    PC0UW00.PC0UWMDD = PC0UW00.PC0UWFDD;
    PC0UW00.PC0UWMYY = PC0UW00.PC0UWFYY;
    PC0UW03.PC0UWTAL = PC0UW00.PC0UWMDT; /* MMDDYY screen format*/
    PC0UW03.PC0UW2TA = PC0UW00.PC0UWMMD; /* MMDD screen format*/
  end

end // end PC0US19

// Get intransit size data
Function PC0US20()


  PC0US21(); /* Declare cursor for vcplit01*/

  PC0US22(); /* Fetch next vcplit01 row*/

  while (PC0UW00.PC0UWCCF != "Y")

    PC0UW00.PC0UWIX2 = TSOREC.SY5SZID; /* Work index*/

     /* Move  shipping qty from record to work field*/

    if (TSOREC.TSOSHPQT != 0)
      PC0UW00.PC0UWWSZ = TSOREC.TSOSHPQT;
       /* Add to total for size*/
      PC0UW03.PC0UWORQ[PC0UWIX2] = PC0UW03.PC0UWORQ[PC0UWIX2] + PC0UWWSZ;
      PC0UW23.PC0UWORQ[PC0UWIX2] = PC0UW23.PC0UWORQ[PC0UWIX2] + PC0UWWSZ;
      if (TSTREC.TSISTAT == "IT"
       || TSTREC.TSISTAT == "CC")
        if (PC0UW00.PC0UWISF == "Y") /* Irregular shipping data*/
           /* Add to irregular totals for dest, color and style*/
          PC0UW00.PC0UWISD[PC0UWIX2] = PC0UW00.PC0UWISD[PC0UWIX2] +           PC0UWWSZ;
          PC0UW00.PC0UWISC[PC0UWIX2] = PC0UW00.PC0UWISC[PC0UWIX2] +           PC0UWWSZ;
          PC0UW00.PC0UWSS[PC0UWIX2] = PC0UW00.PC0UWSS[PC0UWIX2] + PC0UWWSZ;
        else
           /* Add to totals for dest, color and style*/
          PC0UW00.PC0UWDSZ[PC0UWIX2] = PC0UW00.PC0UWDSZ[PC0UWIX2] +           PC0UWWSZ;
          PC0UW00.PC0UWCSZ[PC0UWIX2] = PC0UW00.PC0UWCSZ[PC0UWIX2] +           PC0UWWSZ;
          PC0UW00.PC0UWSSZ[PC0UWIX2] = PC0UW00.PC0UWSSZ[PC0UWIX2] +           PC0UWWSZ;
        end
      end

      PC0UW00.PC0UWSTB[PC0UWIX2] = "Y"; /* Indicate size has quantities*/
    end

    PC0US22(); /* Fetch next vcplit01 row*/

  end

  PC0US23(); /* close vcplit01 cursor*/

end // end PC0US20

// Open vcplit01 row
Function PC0US21()

   /* ------------------------------------------------------------*/
   /* Declare cursor for Dtrans.Vcplit01*/
   /* ------------------------------------------------------------*/

  PC0UW00.PC0UWCCF = "N"; /* Set Carton cursor flag to no*/


  TSOREC.TSFSHPID = TSTREC.TSFSHPID; /* Nike ship ID*/
  TSOREC.TSIPLNBR = TSTREC.TSIPLNBR; /* Nike plan number*/


  try
    call "IO2580" ("S3", SQLCA, TSOREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/
    return;
  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0US21"; /* Process name*/
  TA1REC.TA1LOC = "DECLARE CURSOR          ";
  TA1REC.TA1DBASE = "DTRANS  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCPLIT01"; /* Table view name*/
  TA1REC.TA1TBLKE = TSOREC.TSOKEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0UM001.XXXPRCNM = "PC0US21";
  exit stack;

end // end PC0US21

// Fetch vcplit01 row
Function PC0US22()

   /* ------------------------------------------------------------*/
   /* If row not found return to previous process.*/
   /* If any other, indicate system error.*/
   /* ------------------------------------------------------------*/

  try
    call "IO2580" ("N3", SQLCA, TSOREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Row found*/
      return;
    end
    if (SQLCA.VAGen_SQLCODE == 100) /* Row not found*/
      PC0UW00.PC0UWCCF = "Y"; /* Indicate cursor at EOF*/
      return;
    end

  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0US22"; /* Process name*/
  TA1REC.TA1LOC = "FETCH ROW               ";
  TA1REC.TA1DBASE = "DTRANS  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCPLIT01"; /* Table view name*/
  TA1REC.TA1TBLKE = TSOREC.TSOKEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0UM001.XXXPRCNM = "PC0US22";
  exit stack;

end // end PC0US22

// Close cursor for vcplit01
Function PC0US23()

   /* ------------------------------------------------------------*/
   /* Close cursor for vcplit01*/
   /* ------------------------------------------------------------*/

  try
    call "IO2580" ("C3", SQLCA, TSOREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/
    return;
  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0US23"; /* Process name*/
  TA1REC.TA1LOC = "CLOSE CURSOR            ";
  TA1REC.TA1DBASE = "DTRANS  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCPLIT01"; /* Table view name*/
  TA1REC.TA1TBLKE = TSOREC.TSOKEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0UM001.XXXPRCNM = "PC0US23";
  exit stack;

end // end PC0US23

// Close transporation cursor
Function PC0US24()

   /* ------------------------------------------------------------*/
   /* Close cursor for vcplhd02*/
   /* ------------------------------------------------------------*/

  try
    call "IO4230" ("C6", SQLCA, TSTREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/
    return;
  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0US24"; /* Process name*/
  TA1REC.TA1LOC = "CLOSE CURSOR            ";
  TA1REC.TA1DBASE = "DTRANS  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCPLHD02"; /* Table view name*/
  TA1REC.TA1TBLKE = TSTREC.TSTKEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0UM001.XXXPRCNM = "PC0US24";
  exit stack;

end // end PC0US24

// Open received cursor
Function PC0US25()

   /* ------------------------------------------------------------*/
   /* Declare cursor for VFYPO002*/
   /* ------------------------------------------------------------*/

  PC0UW00.PC0UWRCF = "N"; /* Set Received cursor flag to no*/


  try
    call "VFYPO002" ("SI", SQLCA, VFYPO002) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/
    return;
  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0US25"; /* Process name*/
  TA1REC.TA1LOC = "DECLARE CURSOR          ";
  TA1REC.TA1DBASE = "DPRODC  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VFYPO002"; /* Table view name*/
  TA1REC.TA1TBLKE = VFYPO002.VFYPO002-KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0UM001.XXXPRCNM = "PC0US25";
  exit stack;

end // end PC0US25

// Fetch received row
Function PC0US26()

   /* ------------------------------------------------------------*/
   /* If row not found return to previous process.*/
   /* If any other, indicate system error.*/
   /* ------------------------------------------------------------*/

  try
    call "VFYPO002" ("NI", SQLCA, VFYPO002) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Row found*/
      return;
    end
    if (SQLCA.VAGen_SQLCODE == 100) /* Row not found*/
      PC0UW00.PC0UWRCF = "Y"; /* Indicate cursor at EOF*/
      return;
    end

  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0US26"; /* Process name*/
  TA1REC.TA1LOC = "FETCH ROW               ";
  TA1REC.TA1DBASE = "DPRODC  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VFYPO002"; /* Table view name*/
  TA1REC.TA1TBLKE = VFYPO002.VFYPO002-KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0UM001.XXXPRCNM = "PC0US26";
  exit stack;

end // end PC0US26

// Process all received rows
Function PC0US27()


   /* ------------------------------------------------------------*/
   /* Move the data from the database record to the pc0uW04/W24*/
   /* storage record--then move the storage group level to*/
   /* the temporary storage record (pc0uw09).  Add the total*/
   /* received quantity from the pcmrec to the total received*/
   /* quantity in working storage.*/
   /* ------------------------------------------------------------*/


  if (VFYPO002.YRSCD == "10"
   || VFYPO002.YRSCD == "11"
   || VFYPO002.YRSCD == "12"
   || VFYPO002.YRSCD == "13")
     /* next sentence*/
  else

    PC0US26(); /* Fetch next receiving row*/

    return;

  end


   /* Increment page line index*/

  PC0UW00.PC0UWIXT = PC0UW00.PC0UWIXT + 1;

  set PC0UW04 empty; /* Initialize record*/
  set PC0UW24 empty; /* Initialize record*/


  if (PC0UW00.PC0UWIRF == "Y")
    PC0UW04.PC0UW04I = "IR";
    PC0UW04.PC0UWIRL = "IR";
    PC0UW24.PC0UW04I = "IR";
    PC0UW24.PC0UWIRL = "IR";
  end
  if (VFYPO002.YRSCD == "12")
    PC0UW04.PC0UW04L = "*RECEIPT:";
    PC0UW04.PC0UWRCL = "*RECEIPT:";
    PC0UW24.PC0UW04L = "*RECEIPT:";
    PC0UW24.PC0UWRCL = "*RECEIPT:";
  else
    PC0UW04.PC0UW04L = " RECEIPT:";
    PC0UW04.PC0UWRCL = " RECEIPT:";
    PC0UW24.PC0UW04L = " RECEIPT:";
    PC0UW24.PC0UWRCL = " RECEIPT:";
  end
  PC0UW04.XWHCD = PC0UW00.XWHCD[PC0UWDIX];
  PC0UW04.PC2CUXID = PC0UW00.PC2CUXID[PC0UWDIX];
  PC0UW24.XWHCD = PC0UW00.XWHCD[PC0UWDIX];
  PC0UW24.PC2CUXID = PC0UW00.PC2CUXID[PC0UWDIX];

   /* Get rid of leading zeros for the receiving number*/


  PC0UW04.YRSCD = VFYPO002.YRSCD; /* Received status*/
  PC0UW04.YMTCD = VFYPO002.YMTCD; /* Transportation mode*/
  PC0UW24.YRSCD = VFYPO002.YRSCD; /* Received status*/
  PC0UW24.YMTCD = VFYPO002.YMTCD; /* Transportation mode*/
  PC0UW00.PC0UWSHX = VFYPO002.SL1RCRNO; /* Received report number*/
  PC0UW00.PC0UWSHW = PC0UW00.PC0UWSHX; /* Move to character field*/

   /* FIND FIRST SIGNIGICANT DIGIT*/

  PC0UW00.PC0UWIX4 = 1;

  while (PC0UW00.PC0UWIX4 <= 8
   && PC0UW00.PC0UWSHA[PC0UWIX4] == "0")
    PC0UW00.PC0UWSHA[PC0UWIX4] = " ";
    PC0UW00.PC0UWIX4 = PC0UW00.PC0UWIX4 + 1;
  end

  PC0UW04.PC0UWRNO = PC0UW00.PC0UWSHW;
  PC0UW04.PC0UWRCN = PC0UW00.PC0UWSHW;
  PC0UW24.PC0UWRNO = PC0UW00.PC0UWSHW;
  PC0UW24.PC0UWRCN = PC0UW00.PC0UWSHW;

     /* container received data*/

  if (PC0UW00.PC0UWDTF == "1") /* Show ETAL data*/
    PC0UW00.PC0UWFDT = VFYPO002.TSHRCTDT; /* Update date to WS*/
    PC0UW00.PC0UWMMM = PC0UW00.PC0UWFMM;
    PC0UW00.PC0UWMDD = PC0UW00.PC0UWFDD;
    PC0UW00.PC0UWMYY = PC0UW00.PC0UWFYY;
    PC0UW04.PC0UWTAL = PC0UW00.PC0UWMDT;
                                   /* MMDDYY date to temp storage*/
    PC0UW04.PC0UW2TA = PC0UW00.PC0UWMMD; /* MMDD screen 2 date*/
  else
    if (VFYPO002.OP1CUOID != 0)
      PC0UW00.PC0UWCOR = VFYPO002.OP1CUOID;
      PC0UW00.PC0UWDOT = ".";
      PC0UW00.PC0UWNOR = VFYPO002.OP1NORID;
      PC0UW24.PC0UWSNN = PC0UW00.PC0UWORD;
    else
      PC0UW00.PC0UWCOR = 0;
      PC0UW00.PC0UWDOT = " ";
      PC0UW00.PC0UWNOR = 0;
      PC0UW24.PC0UWSNN = " ";
    end
  end


   /* ------------------------------------------------------------*/
   /* Move the size quantities from the size array in the pcmrec*/
   /* to the size array in the temporary storage record (when*/
   /* there are quanitites for a size). In addition move a 'y'*/
   /* to the corresponding fields in the working storage array*/
   /* to indicate that the table entry had a quantity.  This*/
   /* flag will be used to determine what sizes will be*/
   /* displayed on the size screen.  (The users only want to*/
   /* see a size if it has a quantity associated with it).*/
   /* Add the size quanitities into the size quantity array*/
   /* for received data in working storage.*/
   /* In addition for some inexplicable reason the user wants*/
   /* to see the receiving quantites as negatives.*/
   /* ------------------------------------------------------------*/

  PC0UW00.PC0UWIX1 = 1; /* Initialize general index*/

  while (PC0UW00.PC0UWIX1 <= 40)
    if (VFYPO002.PCMRCPTQ[PC0UWIX1] != 0)
      PC0UW04.PC0UWORQ[PC0UWIX1] = VFYPO002.PCMRCPTQ[PC0UWIX1];
      PC0UW24.PC0UWORQ[PC0UWIX1] = VFYPO002.PCMRCPTQ[PC0UWIX1];
      PC0UW00.PC0UWSTB[PC0UWIX1] = "Y"; /* size flag set to yes*/
      PC0UW00.PC0UWWSZ = VFYPO002.PCMRCPTQ[PC0UWIX1];
      PC0UW04.PC0UWQTY = PC0UW04.PC0UWQTY + PC0UWWSZ;
      PC0UW24.PC0UWQTY = PC0UW24.PC0UWQTY + PC0UWWSZ;
      if (VFYPO002.YRSCD != "12")
        if (PC0UW00.PC0UWIRF == "Y") /* Irregular data*/
           /* Add size quantity to irregular received size fields*/
          PC0UW00.PC0UWIDR = PC0UW00.PC0UWIDR + PC0UWWSZ;
          PC0UW00.PC0UWICR = PC0UW00.PC0UWICR + PC0UWWSZ;
          PC0UW00.PC0UWISR = PC0UW00.PC0UWISR + PC0UWWSZ;
          PC0UW00.PC0UWIRD[PC0UWIX1] = PC0UW00.PC0UWIRD[PC0UWIX1] +           PC0UWWSZ;
          PC0UW00.PC0UWIRC[PC0UWIX1] = PC0UW00.PC0UWIRC[PC0UWIX1] +           PC0UWWSZ;
          PC0UW00.PC0UWIRS[PC0UWIX1] = PC0UW00.PC0UWIRS[PC0UWIX1] +           PC0UWWSZ;
           /* Add size quantity to total received  quantity*/
        else
          PC0UW00.PC0UWTDR = PC0UW00.PC0UWTDR + PC0UWWSZ;
          PC0UW00.PC0UWTCR = PC0UW00.PC0UWTCR + PC0UWWSZ;
          PC0UW00.PC0UWTSR = PC0UW00.PC0UWTSR + PC0UWWSZ;
          PC0UW00.PC0UWDRZ[PC0UWIX1] = PC0UW00.PC0UWDRZ[PC0UWIX1] +           PC0UWWSZ;
          PC0UW00.PC0UWCRZ[PC0UWIX1] = PC0UW00.PC0UWCRZ[PC0UWIX1] +           PC0UWWSZ;
          PC0UW00.PC0UWSRZ[PC0UWIX1] = PC0UW00.PC0UWSRZ[PC0UWIX1] +           PC0UWWSZ;
        end
      end
    end
    PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
  end

  if (PC0UW00.PC0UWDTF == "1") /* Show ETAL data*/
    PC0UW04.PC0UW04K = 4; /* Record key*/
    PC0UW12.PC0UW12R[PC0UWIXT] = PC0UW04.PC0UW04G;
  else
    PC0UW24.PC0UW04K = 24; /* Record key*/
    PC0UW12.PC0UW12R[PC0UWIXT] = PC0UW24.PC0UW04G;
  end

  if (PC0UW00.PC0UWIXT == PC0UW00.PC0UWMAX) /* Max lines*/

    PC0US12(); /* Add page to temp storage*/

  end


  PC0US26(); /* Fetch next receiving row*/


end // end PC0US27

// Close received cursor
Function PC0US28()

   /* ------------------------------------------------------------*/
   /* Close cursor for VFYPO002*/
   /* ------------------------------------------------------------*/

  try
    call "VFYPO002" ("CI", SQLCA, VFYPO002) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/
    return;
  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0US80"; /* Process name*/
  TA1REC.TA1LOC = "CLOSE CURSOR            ";
  TA1REC.TA1DBASE = "DPRODC  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VFYPO002"; /* Table view name*/
  TA1REC.TA1TBLKE = VFYPO002.VFYPO002-KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0UM001.XXXPRCNM = "PC0US80";
  exit stack;

end // end PC0US28

// Create dest balance due record
Function PC0US29()

   /* ------------------------------------------------------------*/
   /* Initialize the destination balance to ship temp storage*/
   /* record and move the data from working storage to the*/
   /* record.*/
   /* ------------------------------------------------------------*/

  set PC0UW06 empty; /* Initialize record*/

  PC0UW06.PC0UW06L = "BALANCE TO SHIP:"; /* Total line literal*/
  PC0UW06.PC0UWSTL = "BALANCE TO SHIP:";
  PC0UW06.XWHCD = PC0UW00.XWHCD[PC0UWDIX];
  PC0UW06.PC2CUXID = PC0UW00.PC2CUXID[PC0UWDIX];

   /* Compute destination balance due =*/
   /* dest on order - (dest shipped + dest rec'd)*/

  PC0UW00.PC0UWWF1 = 0; /* Work field*/
  PC0UW00.PC0UWWF1 = PC0UW00.PC0UWTDS + PC0UW00.PC0UWTDR;
  PC0UW06.PC0UWQTY = PC0UWTID[PC0UWDIX] - PC0UW00.PC0UWWF1;

  if (PC0UW00.PC0UWWF1 == 0)
    return;
  end

   /* Increment temporary storage index*/

  PC0UW00.PC0UWIXT = PC0UW00.PC0UWIXT + 1;

  PC0US30(); /* Compute destination balance due by size*/


  PC0UW06.PC0UW06K = 6; /* Record key*/
  PC0UW12.PC0UW12R[PC0UWIXT] = PC0UW06.PC0UW06G;

  if (PC0UW00.PC0UWIXT == PC0UW00.PC0UWMAX) /* Max lines (13)*/

    PC0US12(); /* Add page to temp storage*/

  end

end // end PC0US29

// compute dest bal due by size
Function PC0US30()

   /* ------------------------------------------------------------*/
   /* Determine which destination is being processed and*/
   /* calculate the sizes amounts for that destination.*/
   /* ------------------------------------------------------------*/

  if (PC0UW00.PC0UWDIX == 1)

    PC0UW00.PC0UWIX1 = 1; /* Initialize general index*/

    while (PC0UW00.PC0UWIX1 <= 40)

      PC0UW00.PC0UWWF4 = 0;
      PC0UW00.PC0UWWF1 = PC0UW00.PC0UWD01[PC0UWIX1]; /* On order*/
      PC0UW00.PC0UWWF2 = PC0UW00.PC0UWDSZ[PC0UWIX1]; /* Shipped*/
      PC0UW00.PC0UWWF3 = PC0UW00.PC0UWDRZ[PC0UWIX1]; /* Received*/
      PC0UW00.PC0UWWF4 = PC0UW00.PC0UWWF2 + PC0UW00.PC0UWWF3;
      PC0UW06.PC0UWORQ[PC0UWIX1] = PC0UW00.PC0UWWF1 - PC0UW00.PC0UWWF4;

      PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
    end
    return;
  end



  if (PC0UW00.PC0UWDIX == 2)

    PC0UW00.PC0UWIX1 = 1; /* Initialize general index*/

    while (PC0UW00.PC0UWIX1 <= 40)

      PC0UW00.PC0UWWF4 = 0;
      PC0UW00.PC0UWWF1 = PC0UW00.PC0UWD02[PC0UWIX1]; /* On order*/
      PC0UW00.PC0UWWF2 = PC0UW00.PC0UWDSZ[PC0UWIX1]; /* Shipped*/
      PC0UW00.PC0UWWF3 = PC0UW00.PC0UWDRZ[PC0UWIX1]; /* Received*/
      PC0UW00.PC0UWWF4 = PC0UW00.PC0UWWF2 + PC0UW00.PC0UWWF3;
      PC0UW06.PC0UWORQ[PC0UWIX1] = PC0UW00.PC0UWWF1 - PC0UW00.PC0UWWF4;

      PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
    end
    return;
  end

  if (PC0UW00.PC0UWDIX == 3)
    PC0UW00.PC0UWIX1 = 1; /* Initialize general index*/

    while (PC0UW00.PC0UWIX1 <= 40)

      PC0UW00.PC0UWWF4 = 0;
      PC0UW00.PC0UWWF1 = PC0UW00.PC0UWD03[PC0UWIX1]; /* On order*/
      PC0UW00.PC0UWWF2 = PC0UW00.PC0UWDSZ[PC0UWIX1]; /* Shipped*/
      PC0UW00.PC0UWWF3 = PC0UW00.PC0UWDRZ[PC0UWIX1]; /* Received*/
      PC0UW00.PC0UWWF4 = PC0UW00.PC0UWWF2 + PC0UW00.PC0UWWF3;
      PC0UW06.PC0UWORQ[PC0UWIX1] = PC0UW00.PC0UWWF1 - PC0UW00.PC0UWWF4;

      PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
    end
    return;
  end

  if (PC0UW00.PC0UWDIX == 4)
    PC0UW00.PC0UWIX1 = 1; /* Initialize general index*/

    while (PC0UW00.PC0UWIX1 <= 40)

      PC0UW00.PC0UWWF4 = 0;
      PC0UW00.PC0UWWF1 = PC0UW00.PC0UWD04[PC0UWIX1]; /* On order*/
      PC0UW00.PC0UWWF2 = PC0UW00.PC0UWDSZ[PC0UWIX1]; /* Shipped*/
      PC0UW00.PC0UWWF3 = PC0UW00.PC0UWDRZ[PC0UWIX1]; /* Received*/
      PC0UW00.PC0UWWF4 = PC0UW00.PC0UWWF2 + PC0UW00.PC0UWWF3;
      PC0UW06.PC0UWORQ[PC0UWIX1] = PC0UW00.PC0UWWF1 - PC0UW00.PC0UWWF4;

      PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
    end
    return;
  end

  if (PC0UW00.PC0UWDIX == 5)
    PC0UW00.PC0UWIX1 = 1; /* Initialize general index*/

    while (PC0UW00.PC0UWIX1 <= 40)

      PC0UW00.PC0UWWF4 = 0;
      PC0UW00.PC0UWWF1 = PC0UW00.PC0UWD05[PC0UWIX1]; /* On order*/
      PC0UW00.PC0UWWF2 = PC0UW00.PC0UWDSZ[PC0UWIX1]; /* Shipped*/
      PC0UW00.PC0UWWF3 = PC0UW00.PC0UWDRZ[PC0UWIX1]; /* Received*/
      PC0UW00.PC0UWWF4 = PC0UW00.PC0UWWF2 + PC0UW00.PC0UWWF3;
      PC0UW06.PC0UWORQ[PC0UWIX1] = PC0UW00.PC0UWWF1 - PC0UW00.PC0UWWF4;

      PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
    end
    return;
  end

  if (PC0UW00.PC0UWDIX == 6)
    PC0UW00.PC0UWIX1 = 1; /* Initialize general index*/

    while (PC0UW00.PC0UWIX1 <= 40)

      PC0UW00.PC0UWWF4 = 0;
      PC0UW00.PC0UWWF1 = PC0UW00.PC0UWD06[PC0UWIX1]; /* On order*/
      PC0UW00.PC0UWWF2 = PC0UW00.PC0UWDSZ[PC0UWIX1]; /* Shipped*/
      PC0UW00.PC0UWWF3 = PC0UW00.PC0UWDRZ[PC0UWIX1]; /* Received*/
      PC0UW00.PC0UWWF4 = PC0UW00.PC0UWWF2 + PC0UW00.PC0UWWF3;
      PC0UW06.PC0UWORQ[PC0UWIX1] = PC0UW00.PC0UWWF1 - PC0UW00.PC0UWWF4;

      PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
    end
    return;
  end

  if (PC0UW00.PC0UWDIX == 7)
    PC0UW00.PC0UWIX1 = 1; /* Initialize general index*/

    while (PC0UW00.PC0UWIX1 <= 40)

      PC0UW00.PC0UWWF4 = 0;
      PC0UW00.PC0UWWF1 = PC0UW00.PC0UWD07[PC0UWIX1]; /* On order*/
      PC0UW00.PC0UWWF2 = PC0UW00.PC0UWDSZ[PC0UWIX1]; /* Shipped*/
      PC0UW00.PC0UWWF3 = PC0UW00.PC0UWDRZ[PC0UWIX1]; /* Received*/
      PC0UW00.PC0UWWF4 = PC0UW00.PC0UWWF2 + PC0UW00.PC0UWWF3;
      PC0UW06.PC0UWORQ[PC0UWIX1] = PC0UW00.PC0UWWF1 - PC0UW00.PC0UWWF4;

      PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
    end
    return;
  end

  if (PC0UW00.PC0UWDIX == 8)
    PC0UW00.PC0UWIX1 = 1; /* Initialize general index*/

    while (PC0UW00.PC0UWIX1 <= 40)

      PC0UW00.PC0UWWF4 = 0;
      PC0UW00.PC0UWWF1 = PC0UW00.PC0UWD08[PC0UWIX1]; /* On order*/
      PC0UW00.PC0UWWF2 = PC0UW00.PC0UWDSZ[PC0UWIX1]; /* Shipped*/
      PC0UW00.PC0UWWF3 = PC0UW00.PC0UWDRZ[PC0UWIX1]; /* Received*/
      PC0UW00.PC0UWWF4 = PC0UW00.PC0UWWF2 + PC0UW00.PC0UWWF3;
      PC0UW06.PC0UWORQ[PC0UWIX1] = PC0UW00.PC0UWWF1 - PC0UW00.PC0UWWF4;

      PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
    end
    return;
  end

  if (PC0UW00.PC0UWDIX == 9)
    PC0UW00.PC0UWIX1 = 1; /* Initialize general index*/

    while (PC0UW00.PC0UWIX1 <= 40)

      PC0UW00.PC0UWWF4 = 0;
      PC0UW00.PC0UWWF1 = PC0UW00.PC0UWD09[PC0UWIX1]; /* On order*/
      PC0UW00.PC0UWWF2 = PC0UW00.PC0UWDSZ[PC0UWIX1]; /* Shipped*/
      PC0UW00.PC0UWWF3 = PC0UW00.PC0UWDRZ[PC0UWIX1]; /* Received*/
      PC0UW00.PC0UWWF4 = PC0UW00.PC0UWWF2 + PC0UW00.PC0UWWF3;
      PC0UW06.PC0UWORQ[PC0UWIX1] = PC0UW00.PC0UWWF1 - PC0UW00.PC0UWWF4;

      PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
    end
    return;
  end

  if (PC0UW00.PC0UWDIX == 10)
    PC0UW00.PC0UWIX1 = 1; /* Initialize general index*/

    while (PC0UW00.PC0UWIX1 <= 40)

      PC0UW00.PC0UWWF4 = 0;
      PC0UW00.PC0UWWF1 = PC0UW00.PC0UWD10[PC0UWIX1]; /* On order*/
      PC0UW00.PC0UWWF2 = PC0UW00.PC0UWDSZ[PC0UWIX1]; /* Shipped*/
      PC0UW00.PC0UWWF3 = PC0UW00.PC0UWDRZ[PC0UWIX1]; /* Received*/
      PC0UW00.PC0UWWF4 = PC0UW00.PC0UWWF2 + PC0UW00.PC0UWWF3;
      PC0UW06.PC0UWORQ[PC0UWIX1] = PC0UW00.PC0UWWF1 - PC0UW00.PC0UWWF4;

      PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
    end
    return;
  end

  if (PC0UW00.PC0UWDIX == 11)
    PC0UW00.PC0UWIX1 = 1; /* Initialize general index*/

    while (PC0UW00.PC0UWIX1 <= 40)

      PC0UW00.PC0UWWF4 = 0;
      PC0UW00.PC0UWWF1 = PC0UW00.PC0UWD11[PC0UWIX1]; /* On order*/
      PC0UW00.PC0UWWF2 = PC0UW00.PC0UWDSZ[PC0UWIX1]; /* Shipped*/
      PC0UW00.PC0UWWF3 = PC0UW00.PC0UWDRZ[PC0UWIX1]; /* Received*/
      PC0UW00.PC0UWWF4 = PC0UW00.PC0UWWF2 + PC0UW00.PC0UWWF3;
      PC0UW06.PC0UWORQ[PC0UWIX1] = PC0UW00.PC0UWWF1 - PC0UW00.PC0UWWF4;

      PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
    end
    return;
  end

  if (PC0UW00.PC0UWDIX == 12)
    PC0UW00.PC0UWIX1 = 1; /* Initialize general index*/

    while (PC0UW00.PC0UWIX1 <= 40)

      PC0UW00.PC0UWWF4 = 0;
      PC0UW00.PC0UWWF1 = PC0UW00.PC0UWD12[PC0UWIX1]; /* On order*/
      PC0UW00.PC0UWWF2 = PC0UW00.PC0UWDSZ[PC0UWIX1]; /* Shipped*/
      PC0UW00.PC0UWWF3 = PC0UW00.PC0UWDRZ[PC0UWIX1]; /* Received*/
      PC0UW00.PC0UWWF4 = PC0UW00.PC0UWWF2 + PC0UW00.PC0UWWF3;
      PC0UW06.PC0UWORQ[PC0UWIX1] = PC0UW00.PC0UWWF1 - PC0UW00.PC0UWWF4;

      PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
    end
    return;
  end
  if (PC0UW00.PC0UWDIX == 13)
    PC0UW00.PC0UWIX1 = 1; /* Initialize general index*/

    while (PC0UW00.PC0UWIX1 <= 40)

      PC0UW00.PC0UWWF4 = 0;
      PC0UW00.PC0UWWF1 = PC0UW00.PC0UWD13[PC0UWIX1]; /* On order*/
      PC0UW00.PC0UWWF2 = PC0UW00.PC0UWDSZ[PC0UWIX1]; /* Shipped*/
      PC0UW00.PC0UWWF3 = PC0UW00.PC0UWDRZ[PC0UWIX1]; /* Received*/
      PC0UW00.PC0UWWF4 = PC0UW00.PC0UWWF2 + PC0UW00.PC0UWWF3;
      PC0UW06.PC0UWORQ[PC0UWIX1] = PC0UW00.PC0UWWF1 - PC0UW00.PC0UWWF4;

      PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
    end
    return;
  end

  if (PC0UW00.PC0UWDIX == 14)
    PC0UW00.PC0UWIX1 = 1; /* Initialize general index*/

    while (PC0UW00.PC0UWIX1 <= 40)

      PC0UW00.PC0UWWF4 = 0;
      PC0UW00.PC0UWWF1 = PC0UW00.PC0UWD14[PC0UWIX1]; /* On order*/
      PC0UW00.PC0UWWF2 = PC0UW00.PC0UWDSZ[PC0UWIX1]; /* Shipped*/
      PC0UW00.PC0UWWF3 = PC0UW00.PC0UWDRZ[PC0UWIX1]; /* Received*/
      PC0UW00.PC0UWWF4 = PC0UW00.PC0UWWF2 + PC0UW00.PC0UWWF3;
      PC0UW06.PC0UWORQ[PC0UWIX1] = PC0UW00.PC0UWWF1 - PC0UW00.PC0UWWF4;

      PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
    end
    return;
  end

  if (PC0UW00.PC0UWDIX == 15)
    PC0UW00.PC0UWIX1 = 1; /* Initialize general index*/

    while (PC0UW00.PC0UWIX1 <= 40)

      PC0UW00.PC0UWWF4 = 0;
      PC0UW00.PC0UWWF1 = PC0UW00.PC0UWD15[PC0UWIX1]; /* On order*/
      PC0UW00.PC0UWWF2 = PC0UW00.PC0UWDSZ[PC0UWIX1]; /* Shipped*/
      PC0UW00.PC0UWWF3 = PC0UW00.PC0UWDRZ[PC0UWIX1]; /* Received*/
      PC0UW00.PC0UWWF4 = PC0UW00.PC0UWWF2 + PC0UW00.PC0UWWF3;
      PC0UW06.PC0UWORQ[PC0UWIX1] = PC0UW00.PC0UWWF1 - PC0UW00.PC0UWWF4;

      PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
    end
    return;
  end

  if (PC0UW00.PC0UWDIX == 16)
    PC0UW00.PC0UWIX1 = 1; /* Initialize general index*/

    while (PC0UW00.PC0UWIX1 <= 40)

      PC0UW00.PC0UWWF4 = 0;
      PC0UW00.PC0UWWF1 = PC0UW00.PC0UWD16[PC0UWIX1]; /* On order*/
      PC0UW00.PC0UWWF2 = PC0UW00.PC0UWDSZ[PC0UWIX1]; /* Shipped*/
      PC0UW00.PC0UWWF3 = PC0UW00.PC0UWDRZ[PC0UWIX1]; /* Received*/
      PC0UW00.PC0UWWF4 = PC0UW00.PC0UWWF2 + PC0UW00.PC0UWWF3;
      PC0UW06.PC0UWORQ[PC0UWIX1] = PC0UW00.PC0UWWF1 - PC0UW00.PC0UWWF4;

      PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
    end
    return;
  end

  if (PC0UW00.PC0UWDIX == 17)
    PC0UW00.PC0UWIX1 = 1; /* Initialize general index*/

    while (PC0UW00.PC0UWIX1 <= 40)

      PC0UW00.PC0UWWF4 = 0;
      PC0UW00.PC0UWWF1 = PC0UW00.PC0UWD17[PC0UWIX1]; /* On order*/
      PC0UW00.PC0UWWF2 = PC0UW00.PC0UWDSZ[PC0UWIX1]; /* Shipped*/
      PC0UW00.PC0UWWF3 = PC0UW00.PC0UWDRZ[PC0UWIX1]; /* Received*/
      PC0UW00.PC0UWWF4 = PC0UW00.PC0UWWF2 + PC0UW00.PC0UWWF3;
      PC0UW06.PC0UWORQ[PC0UWIX1] = PC0UW00.PC0UWWF1 - PC0UW00.PC0UWWF4;

      PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
    end
    return;
  end

  if (PC0UW00.PC0UWDIX == 18)
    PC0UW00.PC0UWIX1 = 1; /* Initialize general index*/

    while (PC0UW00.PC0UWIX1 <= 40)

      PC0UW00.PC0UWWF4 = 0;
      PC0UW00.PC0UWWF1 = PC0UW00.PC0UWD18[PC0UWIX1]; /* On order*/
      PC0UW00.PC0UWWF2 = PC0UW00.PC0UWDSZ[PC0UWIX1]; /* Shipped*/
      PC0UW00.PC0UWWF3 = PC0UW00.PC0UWDRZ[PC0UWIX1]; /* Received*/
      PC0UW00.PC0UWWF4 = PC0UW00.PC0UWWF2 + PC0UW00.PC0UWWF3;
      PC0UW06.PC0UWORQ[PC0UWIX1] = PC0UW00.PC0UWWF1 - PC0UW00.PC0UWWF4;

      PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
    end
    return;
  end

  if (PC0UW00.PC0UWDIX == 19)
    PC0UW00.PC0UWIX1 = 1; /* Initialize general index*/

    while (PC0UW00.PC0UWIX1 <= 40)

      PC0UW00.PC0UWWF4 = 0;
      PC0UW00.PC0UWWF1 = PC0UW00.PC0UWD19[PC0UWIX1]; /* On order*/
      PC0UW00.PC0UWWF2 = PC0UW00.PC0UWDSZ[PC0UWIX1]; /* Shipped*/
      PC0UW00.PC0UWWF3 = PC0UW00.PC0UWDRZ[PC0UWIX1]; /* Received*/
      PC0UW00.PC0UWWF4 = PC0UW00.PC0UWWF2 + PC0UW00.PC0UWWF3;
      PC0UW06.PC0UWORQ[PC0UWIX1] = PC0UW00.PC0UWWF1 - PC0UW00.PC0UWWF4;

      PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
    end
    return;
  end

  if (PC0UW00.PC0UWDIX == 20)
    PC0UW00.PC0UWIX1 = 1; /* Initialize general index*/

    while (PC0UW00.PC0UWIX1 <= 40)

      PC0UW00.PC0UWWF4 = 0;
      PC0UW00.PC0UWWF1 = PC0UW00.PC0UWD20[PC0UWIX1]; /* On order*/
      PC0UW00.PC0UWWF2 = PC0UW00.PC0UWDSZ[PC0UWIX1]; /* Shipped*/
      PC0UW00.PC0UWWF3 = PC0UW00.PC0UWDRZ[PC0UWIX1]; /* Received*/
      PC0UW00.PC0UWWF4 = PC0UW00.PC0UWWF2 + PC0UW00.PC0UWWF3;
      PC0UW06.PC0UWORQ[PC0UWIX1] = PC0UW00.PC0UWWF1 - PC0UW00.PC0UWWF4;

      PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
    end
    return;
  end


end // end PC0US30

// Create dest Irregular % record
Function PC0US31()

   /* ------------------------------------------------------------*/
   /* Initialize the destination irregular percent temp storage*/
   /* record and move the data from working storage to the*/
   /* record.*/
   /* ------------------------------------------------------------*/

  set PC0UW07 empty; /* Initialize record*/

  PC0UW07.PC0UWLIT = "IRREGS %       :"; /* Total line literal*/
  PC0UW07.PC0UWIPL = "IRREGS %       :"; /* Second screen*/
  PC0UW07.XWHCD = PC0UW00.XWHCD[PC0UWDIX];
  PC0UW07.PC2CUXID = PC0UW00.PC2CUXID[PC0UWDIX];

   /* Compute destination irregular percent =*/
   /* irregular received / on order (for destination)*/

  PC0UW00.PC0UWWF1 = PC0UW00.PC0UWTID[PC0UWDIX];
  if (PC0UW00.PC0UWWF1 != 0
   && PC0UW00.PC0UWIDR != 0)
    PC0UW00.PC0UWWF5 = PC0UW00.PC0UWIDR / PC0UW00.PC0UWWF1;
    PC0UW07.PC0UWQTY = PC0UW00.PC0UWWF5 * 100;
  else
    return;
  end

   /* Increment temporary storage index*/

  PC0UW00.PC0UWIXT = PC0UW00.PC0UWIXT + 1;

  PC0US32(); /* Compute destination irregs % by size*/

  PC0UW07.PC0UW07K = 7; /* Record key*/
  PC0UW12.PC0UW12R[PC0UWIXT] = PC0UW07.PC0UW07G;

  if (PC0UW00.PC0UWIXT == PC0UW00.PC0UWMAX) /* Max lines (13)*/

    PC0US12(); /* Add page to temp storage*/

  end

end // end PC0US31

// compute Irreg % by size
Function PC0US32()

   /* ------------------------------------------------------------*/
   /* Determine which destination is being processed and the*/
   /* calculate the irreg percent for that destination.*/
   /* ------------------------------------------------------------*/

  if (PC0UW00.PC0UWDIX == 1)

    PC0UW00.PC0UWIX1 = 1; /* Initialize general index*/

    while (PC0UW00.PC0UWIX1 <= 40)

      PC0UW00.PC0UWWF1 = PC0UW00.PC0UWD01[PC0UWIX1]; /* On order*/
      PC0UW00.PC0UWWF2 = PC0UW00.PC0UWIRD[PC0UWIX1]; /* Received*/
      if (PC0UW00.PC0UWWF1 != 0
       && PC0UW00.PC0UWWF2 != 0)
        PC0UW00.PC0UWWF5 = PC0UW00.PC0UWWF2 / PC0UW00.PC0UWWF1;
        PC0UW07.PC0UWORQ[PC0UWIX1] = PC0UW00.PC0UWWF5 * 100;
      end

      PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
    end
    return;
  end



  if (PC0UW00.PC0UWDIX == 2)

    PC0UW00.PC0UWIX1 = 1; /* Initialize general index*/

    while (PC0UW00.PC0UWIX1 <= 40)

      PC0UW00.PC0UWWF1 = PC0UW00.PC0UWD02[PC0UWIX1]; /* On order*/
      PC0UW00.PC0UWWF2 = PC0UW00.PC0UWIRD[PC0UWIX1]; /* Received*/
      if (PC0UW00.PC0UWWF1 != 0
       && PC0UW00.PC0UWWF2 != 0)
        PC0UW00.PC0UWWF5 = PC0UW00.PC0UWWF2 / PC0UW00.PC0UWWF1;
        PC0UW07.PC0UWORQ[PC0UWIX1] = PC0UW00.PC0UWWF5 * 100;
      end

      PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
    end
    return;
  end

  if (PC0UW00.PC0UWDIX == 3)
    PC0UW00.PC0UWIX1 = 1; /* Initialize general index*/

    while (PC0UW00.PC0UWIX1 <= 40)

      PC0UW00.PC0UWWF1 = PC0UW00.PC0UWD03[PC0UWIX1]; /* On order*/
      PC0UW00.PC0UWWF2 = PC0UW00.PC0UWIRD[PC0UWIX1]; /* Received*/
      if (PC0UW00.PC0UWWF1 != 0
       && PC0UW00.PC0UWWF2 != 0)
        PC0UW00.PC0UWWF5 = PC0UW00.PC0UWWF2 / PC0UW00.PC0UWWF1;
        PC0UW07.PC0UWORQ[PC0UWIX1] = PC0UW00.PC0UWWF5 * 100;
      end

      PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
    end
    return;
  end

  if (PC0UW00.PC0UWDIX == 4)
    PC0UW00.PC0UWIX1 = 1; /* Initialize general index*/

    while (PC0UW00.PC0UWIX1 <= 40)

      PC0UW00.PC0UWWF1 = PC0UW00.PC0UWD04[PC0UWIX1]; /* On order*/
      PC0UW00.PC0UWWF2 = PC0UW00.PC0UWIRD[PC0UWIX1]; /* Received*/
      if (PC0UW00.PC0UWWF1 != 0
       && PC0UW00.PC0UWWF2 != 0)
        PC0UW00.PC0UWWF5 = PC0UW00.PC0UWWF2 / PC0UW00.PC0UWWF1;
        PC0UW07.PC0UWORQ[PC0UWIX1] = PC0UW00.PC0UWWF5 * 100;
      end

      PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
    end
    return;
  end

  if (PC0UW00.PC0UWDIX == 5)
    PC0UW00.PC0UWIX1 = 1; /* Initialize general index*/

    while (PC0UW00.PC0UWIX1 <= 40)

      PC0UW00.PC0UWWF1 = PC0UW00.PC0UWD05[PC0UWIX1]; /* On order*/
      PC0UW00.PC0UWWF2 = PC0UW00.PC0UWIRD[PC0UWIX1]; /* Received*/
      if (PC0UW00.PC0UWWF1 != 0
       && PC0UW00.PC0UWWF2 != 0)
        PC0UW00.PC0UWWF5 = PC0UW00.PC0UWWF2 / PC0UW00.PC0UWWF1;
        PC0UW07.PC0UWORQ[PC0UWIX1] = PC0UW00.PC0UWWF5 * 100;
      end

      PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
    end
    return;
  end

  if (PC0UW00.PC0UWDIX == 6)
    PC0UW00.PC0UWIX1 = 1; /* Initialize general index*/

    while (PC0UW00.PC0UWIX1 <= 40)

      PC0UW00.PC0UWWF1 = PC0UW00.PC0UWD06[PC0UWIX1]; /* On order*/
      PC0UW00.PC0UWWF2 = PC0UW00.PC0UWIRD[PC0UWIX1]; /* Received*/
      if (PC0UW00.PC0UWWF1 != 0
       && PC0UW00.PC0UWWF2 != 0)
        PC0UW00.PC0UWWF5 = PC0UW00.PC0UWWF2 / PC0UW00.PC0UWWF1;
        PC0UW07.PC0UWORQ[PC0UWIX1] = PC0UW00.PC0UWWF5 * 100;
      end

      PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
    end
    return;
  end

  if (PC0UW00.PC0UWDIX == 7)
    PC0UW00.PC0UWIX1 = 1; /* Initialize general index*/

    while (PC0UW00.PC0UWIX1 <= 40)

      PC0UW00.PC0UWWF1 = PC0UW00.PC0UWD07[PC0UWIX1]; /* On order*/
      PC0UW00.PC0UWWF2 = PC0UW00.PC0UWIRD[PC0UWIX1]; /* Received*/
      if (PC0UW00.PC0UWWF1 != 0
       && PC0UW00.PC0UWWF2 != 0)
        PC0UW00.PC0UWWF5 = PC0UW00.PC0UWWF2 / PC0UW00.PC0UWWF1;
        PC0UW07.PC0UWORQ[PC0UWIX1] = PC0UW00.PC0UWWF5 * 100;
      end

      PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
    end
    return;
  end

  if (PC0UW00.PC0UWDIX == 8)
    PC0UW00.PC0UWIX1 = 1; /* Initialize general index*/

    while (PC0UW00.PC0UWIX1 <= 40)

      PC0UW00.PC0UWWF1 = PC0UW00.PC0UWD08[PC0UWIX1]; /* On order*/
      PC0UW00.PC0UWWF2 = PC0UW00.PC0UWIRD[PC0UWIX1]; /* Received*/
      if (PC0UW00.PC0UWWF1 != 0
       && PC0UW00.PC0UWWF2 != 0)
        PC0UW00.PC0UWWF5 = PC0UW00.PC0UWWF2 / PC0UW00.PC0UWWF1;
        PC0UW07.PC0UWORQ[PC0UWIX1] = PC0UW00.PC0UWWF5 * 100;
      end

      PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
    end
    return;
  end

  if (PC0UW00.PC0UWDIX == 9)
    PC0UW00.PC0UWIX1 = 1; /* Initialize general index*/

    while (PC0UW00.PC0UWIX1 <= 40)

      PC0UW00.PC0UWWF1 = PC0UW00.PC0UWD09[PC0UWIX1]; /* On order*/
      PC0UW00.PC0UWWF2 = PC0UW00.PC0UWIRD[PC0UWIX1]; /* Received*/
      if (PC0UW00.PC0UWWF1 != 0
       && PC0UW00.PC0UWWF2 != 0)
        PC0UW00.PC0UWWF5 = PC0UW00.PC0UWWF2 / PC0UW00.PC0UWWF1;
        PC0UW07.PC0UWORQ[PC0UWIX1] = PC0UW00.PC0UWWF5 * 100;
      end

      PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
    end
    return;
  end

  if (PC0UW00.PC0UWDIX == 10)
    PC0UW00.PC0UWIX1 = 1; /* Initialize general index*/

    while (PC0UW00.PC0UWIX1 <= 40)

      PC0UW00.PC0UWWF1 = PC0UW00.PC0UWD10[PC0UWIX1]; /* On order*/
      PC0UW00.PC0UWWF2 = PC0UW00.PC0UWIRD[PC0UWIX1]; /* Received*/
      if (PC0UW00.PC0UWWF1 != 0
       && PC0UW00.PC0UWWF2 != 0)
        PC0UW00.PC0UWWF5 = PC0UW00.PC0UWWF2 / PC0UW00.PC0UWWF1;
        PC0UW07.PC0UWORQ[PC0UWIX1] = PC0UW00.PC0UWWF5 * 100;
      end

      PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
    end
    return;
  end

  if (PC0UW00.PC0UWDIX == 11)
    PC0UW00.PC0UWIX1 = 1; /* Initialize general index*/

    while (PC0UW00.PC0UWIX1 <= 40)

      PC0UW00.PC0UWWF1 = PC0UW00.PC0UWD11[PC0UWIX1]; /* On order*/
      PC0UW00.PC0UWWF2 = PC0UW00.PC0UWIRD[PC0UWIX1]; /* Received*/
      if (PC0UW00.PC0UWWF1 != 0
       && PC0UW00.PC0UWWF2 != 0)
        PC0UW00.PC0UWWF5 = PC0UW00.PC0UWWF2 / PC0UW00.PC0UWWF1;
        PC0UW07.PC0UWORQ[PC0UWIX1] = PC0UW00.PC0UWWF5 * 100;
      end

      PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
    end
    return;
  end

  if (PC0UW00.PC0UWDIX == 12)
    PC0UW00.PC0UWIX1 = 1; /* Initialize general index*/

    while (PC0UW00.PC0UWIX1 <= 40)

      PC0UW00.PC0UWWF1 = PC0UW00.PC0UWD12[PC0UWIX1]; /* On order*/
      PC0UW00.PC0UWWF2 = PC0UW00.PC0UWIRD[PC0UWIX1]; /* Received*/
      if (PC0UW00.PC0UWWF1 != 0
       && PC0UW00.PC0UWWF2 != 0)
        PC0UW00.PC0UWWF5 = PC0UW00.PC0UWWF2 / PC0UW00.PC0UWWF1;
        PC0UW07.PC0UWORQ[PC0UWIX1] = PC0UW00.PC0UWWF5 * 100;
      end

      PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
    end
    return;
  end
  if (PC0UW00.PC0UWDIX == 13)
    PC0UW00.PC0UWIX1 = 1; /* Initialize general index*/

    while (PC0UW00.PC0UWIX1 <= 40)

      PC0UW00.PC0UWWF1 = PC0UW00.PC0UWD13[PC0UWIX1]; /* On order*/
      PC0UW00.PC0UWWF2 = PC0UW00.PC0UWIRD[PC0UWIX1]; /* Received*/
      if (PC0UW00.PC0UWWF1 != 0
       && PC0UW00.PC0UWWF2 != 0)
        PC0UW00.PC0UWWF5 = PC0UW00.PC0UWWF2 / PC0UW00.PC0UWWF1;
        PC0UW07.PC0UWORQ[PC0UWIX1] = PC0UW00.PC0UWWF5 * 100;
      end

      PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
    end
    return;
  end

  if (PC0UW00.PC0UWDIX == 14)
    PC0UW00.PC0UWIX1 = 1; /* Initialize general index*/

    while (PC0UW00.PC0UWIX1 <= 40)

      PC0UW00.PC0UWWF1 = PC0UW00.PC0UWD14[PC0UWIX1]; /* On order*/
      PC0UW00.PC0UWWF2 = PC0UW00.PC0UWIRD[PC0UWIX1]; /* Received*/
      if (PC0UW00.PC0UWWF1 != 0
       && PC0UW00.PC0UWWF2 != 0)
        PC0UW00.PC0UWWF5 = PC0UW00.PC0UWWF2 / PC0UW00.PC0UWWF1;
        PC0UW07.PC0UWORQ[PC0UWIX1] = PC0UW00.PC0UWWF5 * 100;
      end

      PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
    end
    return;
  end

  if (PC0UW00.PC0UWDIX == 15)
    PC0UW00.PC0UWIX1 = 1; /* Initialize general index*/

    while (PC0UW00.PC0UWIX1 <= 40)

      PC0UW00.PC0UWWF1 = PC0UW00.PC0UWD15[PC0UWIX1]; /* On order*/
      PC0UW00.PC0UWWF2 = PC0UW00.PC0UWIRD[PC0UWIX1]; /* Received*/
      if (PC0UW00.PC0UWWF1 != 0
       && PC0UW00.PC0UWWF2 != 0)
        PC0UW00.PC0UWWF5 = PC0UW00.PC0UWWF2 / PC0UW00.PC0UWWF1;
        PC0UW07.PC0UWORQ[PC0UWIX1] = PC0UW00.PC0UWWF5 * 100;
      end

      PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
    end
    return;
  end

  if (PC0UW00.PC0UWDIX == 16)
    PC0UW00.PC0UWIX1 = 1; /* Initialize general index*/

    while (PC0UW00.PC0UWIX1 <= 40)

      PC0UW00.PC0UWWF1 = PC0UW00.PC0UWD16[PC0UWIX1]; /* On order*/
      PC0UW00.PC0UWWF2 = PC0UW00.PC0UWIRD[PC0UWIX1]; /* Received*/
      if (PC0UW00.PC0UWWF1 != 0
       && PC0UW00.PC0UWWF2 != 0)
        PC0UW00.PC0UWWF5 = PC0UW00.PC0UWWF2 / PC0UW00.PC0UWWF1;
        PC0UW07.PC0UWORQ[PC0UWIX1] = PC0UW00.PC0UWWF5 * 100;
      end

      PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
    end
    return;
  end

  if (PC0UW00.PC0UWDIX == 17)
    PC0UW00.PC0UWIX1 = 1; /* Initialize general index*/

    while (PC0UW00.PC0UWIX1 <= 40)

      PC0UW00.PC0UWWF1 = PC0UW00.PC0UWD17[PC0UWIX1]; /* On order*/
      PC0UW00.PC0UWWF2 = PC0UW00.PC0UWIRD[PC0UWIX1]; /* Received*/
      if (PC0UW00.PC0UWWF1 != 0
       && PC0UW00.PC0UWWF2 != 0)
        PC0UW00.PC0UWWF5 = PC0UW00.PC0UWWF2 / PC0UW00.PC0UWWF1;
        PC0UW07.PC0UWORQ[PC0UWIX1] = PC0UW00.PC0UWWF5 * 100;
      end

      PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
    end
    return;
  end

  if (PC0UW00.PC0UWDIX == 18)
    PC0UW00.PC0UWIX1 = 1; /* Initialize general index*/

    while (PC0UW00.PC0UWIX1 <= 40)

      PC0UW00.PC0UWWF1 = PC0UW00.PC0UWD18[PC0UWIX1]; /* On order*/
      PC0UW00.PC0UWWF2 = PC0UW00.PC0UWIRD[PC0UWIX1]; /* Received*/
      if (PC0UW00.PC0UWWF1 != 0
       && PC0UW00.PC0UWWF2 != 0)
        PC0UW00.PC0UWWF5 = PC0UW00.PC0UWWF2 / PC0UW00.PC0UWWF1;
        PC0UW07.PC0UWORQ[PC0UWIX1] = PC0UW00.PC0UWWF5 * 100;
      end

      PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
    end
    return;
  end

  if (PC0UW00.PC0UWDIX == 19)
    PC0UW00.PC0UWIX1 = 1; /* Initialize general index*/

    while (PC0UW00.PC0UWIX1 <= 40)

      PC0UW00.PC0UWWF1 = PC0UW00.PC0UWD19[PC0UWIX1]; /* On order*/
      PC0UW00.PC0UWWF2 = PC0UW00.PC0UWIRD[PC0UWIX1]; /* Received*/
      if (PC0UW00.PC0UWWF1 != 0
       && PC0UW00.PC0UWWF2 != 0)
        PC0UW00.PC0UWWF5 = PC0UW00.PC0UWWF2 / PC0UW00.PC0UWWF1;
        PC0UW07.PC0UWORQ[PC0UWIX1] = PC0UW00.PC0UWWF5 * 100;
      end

      PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
    end
    return;
  end

  if (PC0UW00.PC0UWDIX == 20)
    PC0UW00.PC0UWIX1 = 1; /* Initialize general index*/

    while (PC0UW00.PC0UWIX1 <= 40)

      PC0UW00.PC0UWWF1 = PC0UW00.PC0UWD20[PC0UWIX1]; /* On order*/
      PC0UW00.PC0UWWF2 = PC0UW00.PC0UWIRD[PC0UWIX1]; /* Received*/
      if (PC0UW00.PC0UWWF1 != 0
       && PC0UW00.PC0UWWF2 != 0)
        PC0UW00.PC0UWWF5 = PC0UW00.PC0UWWF2 / PC0UW00.PC0UWWF1;
        PC0UW07.PC0UWORQ[PC0UWIX1] = PC0UW00.PC0UWWF5 * 100;
      end

      PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
    end
    return;
  end


end // end PC0US32

// Close item cursor
Function PC0US33()

   /* ------------------------------------------------------------*/
   /* Close cursor for VPOITM05*/
   /* ------------------------------------------------------------*/
  set PCYREC empty;
  PCYREC.PCYFUNC = "C6";
  try
    call "VPOITM05" (PCYREC, SQLCA, VPOITM05) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/
    return;
  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0US33"; /* Process name*/
  TA1REC.TA1LOC = "CLOSE CURSOR            ";
  TA1REC.TA1DBASE = "DPRODC  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VPOITM05"; /* Table view name*/
  TA1REC.TA1TBLKE = VPOITM05.VPOITM05-KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0UM001.XXXPRCNM = "PC0US33";
  exit stack;

end // end PC0US33

// Obtain temp storage page
Function PC0US34()


   /* ------------------------------------------------------------*/
   /* Obtain the next page of data from temporary storage*/
   /* ------------------------------------------------------------*/

  PC0UW12.PC0UWTSL = PC0UW00.PC0UWTSL; /* Temporary storage length*/
  TA5REC.TA5APPID = COMMAREA.CACURRAP; /* Application identification*/
  TA5REC.TA5TSQIX = PC0UW00.PC0UWTSP; /* Page number requested*/
  TA5REC.TA5FNCCD = "R"; /* Function code*/

  try
    call "TA0050" (PC0UW12, TA5REC) {isNoRefresh = yes, isExternal = yes};
  end /* Temporary storage*/

   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && TA5REC.TA5RTNCD == 0)          /* and normal return code*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TAEREC.TAEDESC1 = sysVar.errorCode; /* CSP return code*/
  TAEREC.TAEDESC2 = TA5REC.TA5DATA; /* Subroutine parameters*/

  PC0UM001.XXXPRCNM = "PC0US34"; /* Module identification*/
  converseLib.validationFailed(10); /* Indicate system error*/

  TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  TA1REC.TA1TYPE = "APPL"; /* Type of error*/
  TA1REC.TA1LOC = "READ PAGE FROM TEMPORARY STORAGE";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = PC0UM001.XXXPRCNM; /* Program number*/
  TA1REC.TA1MAPAP = COMMAREA.CACURRAP; /* Map application*/
  TA1REC.TA1MAPNO = "M001"; /* Map number*/

  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end PC0US34

// Obtain item row
Function PC0US36()

   /* ------------------------------------------------------------*/
   /* If row not found return to previous process.*/
   /* If any other, indicate system error.*/
   /* ------------------------------------------------------------*/

  set VPOITM05 empty;
  VPOITM05.XGPCD = PCWREC.XGPCD;
  VPOITM05.PO-REG-CD = PCWREC.PO-REG-CD;
  VPOITM05.PC3PONBR = PCWREC.PC3PONBR;
  VPOITM05.PC6ITMNB = PC0UW12.PC6ITMNB[PC0UWIXM];

  set PCYREC empty;
  PCYREC.PCYFUNC = "SA";
  try
    call "VPOITM05" (PCYREC, SQLCA, VPOITM05) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Row found*/
      PCWREC.PO-REG-CD = VPOITM05.PO-REG-CD;
      PCWREC.PC3POIDT = VPOITM05.PC3POIDT;
      PCWREC.SY1STNBR = VPOITM05.SY1STNBR;
      PCWREC.SY2CLRID = VPOITM05.SY2CLRID;
      PCWREC.XDMCD = VPOITM05.XDMCD;
      PCWREC.XQACD = VPOITM05.XQACD;
      PCWREC.XOWCD = VPOITM05.XOWCD;
      PCWREC.PC2INSEG = VPOITM05.PC2INSEG;
      PCWREC.PCFSECD = VPOITM05.PCFSECD;
      PCWREC.XPGCD = VPOITM05.XPGCD;
      PCWREC.XUMCD = VPOITM05.XUMCD;
      PCWREC.PC6ETSDT = VPOITM05.PC6ETSDT;
      PCWREC.PC6RTADT = VPOITM05.PC6RTADT;
      PCWREC.PC6OETS = VPOITM05.PC6OETS;
      PCWREC.YMTCD = VPOITM05.YMTCD;
      PCWREC.XWHCD = VPOITM05.XWHCD;
      PCWREC.PC2CUXID = VPOITM05.PC2CUXID;
      return;
    end

  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0US36"; /* Process name*/
  TA1REC.TA1LOC = "FETCH ROW               ";
  TA1REC.TA1DBASE = "DPRODC  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VPOITM05"; /* Table view name*/
  TA1REC.TA1TBLKE = VPOITM05.VPOITM05-KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0UM001.XXXPRCNM = "PC0US36";
  exit stack;



end // end PC0US36

// Validate ETALO date
Function PC0US37()

   /* ------------------------------------------------------------*/
   /* Use the called module TA0040 to validate & convert dates.*/
   /* ------------------------------------------------------------*/

  TA2REC.TA2GRTYP = "A"; /* Type MMDDYY*/

  TA2REC.TA2DTOPT = "GREGGREG"; /* Validate and get all greg formats*/

   /* ------------------------------------------------------------*/
   /* Call TA0040*/
   /* ------------------------------------------------------------*/

  try
    call "TA0040" (TA2REC) {isNoRefresh = yes, isExternal = yes};
  end /* Date routine*/

   /* ------------------------------------------------------------*/
   /* If unsuccesful call, indicate a system error has occurred.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/
    return;
  else
    TAEREC.TAEDESC1 = sysVar.errorCode; /* CSP return code*/
    TAEREC.TAEDESC2 = TA2REC.TA2GRGG; /* date sent to validate*/

    converseLib.validationFailed(01); /* Indicate system error*/

    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    TA1REC.TA1TYPE = "APPL"; /* Type of error*/
    TA1REC.TA1LOC = "CALL TO TA0040 TO VERIFY DATE";
    TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
    TA1REC.TA1PGMNO = "PC0US37"; /* Program number*/
    TA1REC.TA1MAPAP = COMMAREA.CACURRAP; /* Map application*/

    call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

    exit stack; /* Exit to display map*/
  end

end // end PC0US37

// update ETALO date
Function PC0US38()

   /* ---------------------------------------------------------*/
   /* Obtain the DTRANS.VCPLHD01 for the intransit line*/
   /* requested--then update the ETALO date on the selected*/
   /* row.*/
   /* ---------------------------------------------------------*/

  set TSIREC empty;

  TSIREC.TSFSHPID = PC0UW12.TSFSHPID[PC0UWIX4];
  TSIREC.TSIPLNBR = PC0UW12.TSIPLNBR[PC0UWIX4];

  PC0US40(); /* OBtain unique DTRANS.VCPLHD01*/

  TSIREC.TSIETALO = PC0UW00.TSIETALO;

  PC0US41(); /* Update DTRANS.VCPLHD01*/


  PC0UW00.PC0UWMDT = PC0UW01.PC0UWETO;
  PC0UW00.PC0UWEDM = PC0UW00.PC0UWMMM;
  PC0UW00.PC0UWEDD = PC0UW00.PC0UWMDD;
  PC0UW00.PC0UWEDY = PC0UW00.PC0UWMYY;
  if (PC0UW00.PC0UWDTF == "1")
    PC0UW03.PC0UW03G = PC0UW12.PC0UW12R[PC0UWIX4];
    PC0UW03.PC0UWTAO = PC0UW00.PC0UWEDT;
    PC0UW12.PC0UW12R[PC0UWIX4] = PC0UW03.PC0UW03G;
  else
    PC0UW23.PC0UW03G = PC0UW12.PC0UW12R[PC0UWIX4];
    PC0UW23.PC0UWSNN = PC0UW00.PC0UWORD;
    PC0UW12.PC0UW12R[PC0UWIX4] = PC0UW23.PC0UW03G;
  end

  PC0UM001.PC0UMETO = " ";
  PC0UW01.PC0UWETO = " ";

  PC0US42(); /* Update temp storage*/

  PC0UW00.XXXMSGNO = 001; /* UPdate successfully completed*/


end // end PC0US38

// Obtain unique DTRANS.VCLPHD01
Function PC0US40()



  try
    call "IO2570" ("SA", SQLCA, TSIREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Row found*/
      return;
    end

  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(19); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(01); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0US40"; /* Process name*/
  TA1REC.TA1LOC = "FETCH UNIQUE ROW        ";
  TA1REC.TA1DBASE = "DFTRANS "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCPLHD01"; /* Table view name*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0UM001.XXXPRCNM = "PC0US40";
  exit stack;

end // end PC0US40

// Update DTRANS.VCLPHD01
Function PC0US41()


   /* ------------------------------------------------------------*/
   /* This module updates a table row.*/
   /* It will return and document system errors if unexpected*/
   /* return codes are found.*/
   /* ------------------------------------------------------------*/

  XX0XS01();

  TSIREC.ZZZCHGDT = XX0XW01.XX0XWDAT;
  TSIREC.ZZZCHGTM = XX0XW01.XX0XWTIM;



  try
    call "IO2570" ("U ", SQLCA, TSIREC) {isNoRefresh = yes, isExternal = yes};
  end /* Delete table row*/

  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Expected return codes*/

      VGVar.handleSysLibraryErrors = 0;
      sysLib.commit();

      return; /* Return to previous process*/

    end
  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(19); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(01); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
     /* Clear screen before redisplay*/
  end

  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback(); /* Rollback if bad return code*/

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0US41 "; /* Process name*/
  TA1REC.TA1LOC = "UPDATE TABLE ROW";
  TA1REC.TA1DBASE = "DTRANS  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCPLHD01"; /* Table view name*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0UM001.XXXPRCNM = "PC0US41"; /* Process name*/

  exit stack;

end // end PC0US41

// Update temp storage
Function PC0US42()

   /* ------------------------------------------------------------*/
   /* Update the page in temporary storage.*/
   /* ------------------------------------------------------------*/

  PC0UW12.PC0UWTSL = PC0UW00.PC0UWTSL; /* Temporary storage length*/
  TA5REC.TA5APPID = COMMAREA.CACURRAP; /* Application id*/
  TA5REC.TA5FNCCD = "U"; /* Function code*/

  try
    call "TA0050" (PC0UW12, TA5REC) {isNoRefresh = yes, isExternal = yes};
  end /* Temporary storage*/

   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && TA5REC.TA5RTNCD == 0)          /* and normal return code*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TAEREC.TAEDESC1 = sysVar.errorCode; /* CSP return code*/
  TAEREC.TAEDESC2 = TA5REC.TA5DATA; /* Subroutine parameters*/

  PC0UM001.XXXPRCNM = "PC0US42"; /* Module identification*/
  converseLib.validationFailed(01); /* Indicate system error*/

  TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  TA1REC.TA1TYPE = "APPL"; /* Type of error*/
  TA1REC.TA1LOC = "UPDATE PAGE IN TEMPORARY STORAGE";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = PC0UM001.XXXPRCNM; /* Program number*/
  TA1REC.TA1MAPAP = COMMAREA.CACURRAP; /* Map application*/
  TA1REC.TA1MAPNO = "M001"; /* Map number*/

  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end PC0US42

// Create cut detail etc
Function PC0US43()


   /* ------------------------------------------------------------*/
   /* Get all the WIP data for the style--on a date break write*/
   /* a Cut detail temp storage record.  At end of cursor*/
   /* if there has been WIP detail data write the balance to*/
   /* cut total record.*/
   /* ------------------------------------------------------------*/

  set PTDREC empty;

  PTDREC.XGPCD = PCWREC.XGPCD;
  PTDREC.PC3PONBR = PCWREC.PC3PONBR; /* PO number*/
  PTDREC.SY1STNBR = VPOITM05.SY1STNBR; /* Style number*/
  PTDREC.SY2CLRID = PC0UW00.SY2CLRID; /* Color code*/
  PTDREC.XDMCD = VPOITM05.XDMCD; /* Dimension code*/
  PTDREC.FY1FCTYC = "*"; /* Factory code*/
  PTDREC.YPUCD = "*"; /* Status code*/

   /* Destination data*/


  PC0US44(); /* Open DPRODC.VPOWIP01*/

   /* ------------------------------------------------------------*/
   /* If there are WIP rows-retrieve all rows for  the style*/
   /* and color.  Do a break on date.*/
   /* ------------------------------------------------------------*/

  PC0US45(); /* Fetch DPRODC.VPOWIP01row*/

  PC0UW00.PC0UWDCT = 0; /* Date WIP total*/

  while (PC0UW00.PC0UWWCF != "Y")

    PC0UW00.PTDCTDT = PTDREC.PTDCTDT; /* Save date*/
    move 0 to PC0UW00.PC0UWDCZ[1] for all; /* Init date size array*/
    PC0UW00.PC0UWDCT = 0; /* Date WIP total*/

    while (PTDREC.PTDCTDT == PC0UW00.PTDCTDT
     && PC0UW00.PC0UWWCF != "Y")

      if (PTDREC.YPUCD == "OP"
       || PTDREC.YPUCD == "FC"
       || PTDREC.YPUCD == "NC")
        PC0UW00.PC0UWIX1 = 1; /* Init work index*/
        while (PC0UW00.PC0UWIX1 <= 40) /* Size max*/
          if (PTDREC.PTDCTQTY[PC0UWIX1] != 0)
            PC0UW00.PC0UWSTB[PC0UWIX1] = "Y"; /* size flag to yes*/
            PC0UW00.PC0UWWF1 = PTDREC.PTDCTQTY[PC0UWIX1];
            PC0UW00.PC0UWTCT = PC0UW00.PC0UWTCT + PC0UW00.PC0UWWF1;
            PC0UW00.PC0UWDCT = PC0UW00.PC0UWDCT + PC0UW00.PC0UWWF1;
            PC0UW00.PC0UWDCZ[PC0UWIX1] = PC0UW00.PC0UWDCZ[PC0UWIX1] + PC0UWWF1;
            PC0UW00.PC0UWTCZ[PC0UWIX1] = PC0UW00.PC0UWTCZ[PC0UWIX1] + PC0UWWF1;
          end
          PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
        end
      end
      PC0US45(); /* Fetch DPRODC.VPOWIP01 row*/
    end
    if (PC0UW00.PC0UWDCT != 0)
      PC0US46(); /* Create Cut detail line*/
    end

  end

  if (PC0UW00.PC0UWTCT != 0)
    PC0US47(); /* Create balance to cut line*/
  end

  PC0US48(); /* Close DPRODC.VPOWIP01*/


end // end PC0US43

// Open DPRODC.VPOWIP01 cursor
Function PC0US44()

   /* ------------------------------------------------------------*/
   /* Declare cursor for vpowip01*/
   /* ------------------------------------------------------------*/

  PC0UW00.PC0UWWCF = "N"; /* Set WIP cursor flag to no*/


  try
    call "IO4580" ("S1", SQLCA, PTDREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/
    return;
  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0US44"; /* Process name*/
  TA1REC.TA1LOC = "DECLARE CURSOR          ";
  TA1REC.TA1DBASE = "DPRODC  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VPOWIP01"; /* Table view name*/
  TA1REC.TA1TBLKE = PTDREC.SY1STNBR; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0UM001.XXXPRCNM = "PC0US44";
  exit stack;

end // end PC0US44

// Fetch DPRODC.VPOWIP01 row
Function PC0US45()

   /* ------------------------------------------------------------*/
   /* If row found return to calling processes--if not found*/
   /* set end of cursor flag --in other errors call ta0020*/
   /* ------------------------------------------------------------*/

  try
    call "IO4580" ("N1", SQLCA, PTDREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Row found*/
      return;
    end
    if (SQLCA.VAGen_SQLCODE == 100) /* Row not found*/
      PC0UW00.PC0UWWCF = "Y"; /* Indicate cursor at EOF*/
      return;
    end

  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0US45"; /* Process name*/
  TA1REC.TA1LOC = "FETCH ROW               ";
  TA1REC.TA1DBASE = "DPRODC  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VPOWIP01"; /* Table view name*/
  TA1REC.TA1TBLKE = PTDREC.SY1STNBR; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0UM001.XXXPRCNM = "PC0US45";
  exit stack;

end // end PC0US45

// Create cut detail line
Function PC0US46()


   /* ------------------------------------------------------------*/
   /* Move the data from the database record to the pc0uW14*/
   /* storage record--then move the storage group level to*/
   /* the temporary storage record (pc0uw09).*/
   /* ------------------------------------------------------------*/

   /* Increment page line index*/

  PC0UW00.PC0UWIXT = PC0UW00.PC0UWIXT + 1;

  set PC0UW14 empty; /* Initialize record*/


  PC0UW14.PC0UWCTL = "CUT DATE:  "; /* Screen one literal*/
  PC0UW14.PC0UW2LT = "CUT DATE:  "; /* Screen two literal*/
  PC0UW00.PC0UWFDT = PC0UW00.PTDCTDT; /* Saved date to ws*/
  PC0UW00.PC0UWMYY = PC0UW00.PC0UWFYY;
  PC0UW00.PC0UWMDD = PC0UW00.PC0UWFDD;
  PC0UW00.PC0UWMMM = PC0UW00.PC0UWFMM;
  PC0UW14.PC0UWCDT = PC0UW00.PC0UWMDT; /* MMDDYY to screen 1 date*/
  PC0UW14.PC0UW2CD = PC0UW00.PC0UWMDT; /* MMDDYY to screen 2 date*/
  PC0UW14.PC0UWQTY = PC0UW00.PC0UWDCT; /* Screen 1 date total*/


  PC0UW00.PC0UWIX1 = 1;

  while (PC0UW00.PC0UWIX1 <= 40)
    if (PC0UW00.PC0UWDCZ[PC0UWIX1] != 0)
      PC0UW14.PC0UWORQ[PC0UWIX1] = PC0UW00.PC0UWDCZ[PC0UWIX1];
    end
    PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
  end

  PC0UW14.PC0UW14K = 14; /* Record key*/
  PC0UW12.PC0UW12R[PC0UWIXT] = PC0UW14.PC0UW14G;

  if (PC0UW00.PC0UWIXT == PC0UW00.PC0UWMAX) /* Max lines*/

    PC0US12(); /* Add page to temp storage*/

  end



end // end PC0US46

// Create balance to cut line
Function PC0US47()
   /* ------------------------------------------------------------*/
   /* Initialize the balance to cut temporary storage record.*/
   /* Move the data from the working storage fields to the*/
   /* temporary storage record.*/
   /* ------------------------------------------------------------*/

   /* Increment temp storage line index*/

  PC0UW00.PC0UWIXT = PC0UW00.PC0UWIXT + 1;

  set PC0UW15 empty; /* Initialize record*/

  PC0UW15.PC0UW15L = "BALANCE TO CUT  :"; /* Total line literal*/
  PC0UW15.PC0UWBCL = "BALANCE TO CUT  :"; /* Screen two literal*/

   /* Balance to cut = total on order - total cut*/

  PC0UW15.PC0UWQTY = PC0UW00.PC0UWTIC - PC0UW00.PC0UWTCT;

  PC0UW00.PC0UWIX1 = 1; /* Initialize general index*/

  while (PC0UW00.PC0UWIX1 <= 40)
    PC0UWWF1 = PC0UW00.PC0UWICZ[PC0UWIX1] - PC0UW00.PC0UWTCZ[PC0UWIX1];
    PC0UW15.PC0UWORQ[PC0UWIX1] = PC0UW00.PC0UWWF1;
    PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
  end


  PC0UW15.PC0UW15K = 15; /* Indicate type of record*/

  PC0UW12.PC0UW12R[PC0UWIXT] = PC0UW15.PC0UW15G;

  if (PC0UW00.PC0UWIXT == PC0UW00.PC0UWMAX) /* Max ines*/

    PC0US12(); /* Add page to temp storage*/

  end



end // end PC0US47

// Close DPRODC.VPOWIP01 cursor
Function PC0US48()

   /* ------------------------------------------------------------*/
   /* Close cursor for vpowip01*/
   /* ------------------------------------------------------------*/

  try
    call "IO4580" ("C1", SQLCA, PTDREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/
    return;
  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0US48"; /* Process name*/
  TA1REC.TA1LOC = "CLOSE CURSOR            ";
  TA1REC.TA1DBASE = "DPRODC  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VVPLHD01"; /* Table view name*/
  TA1REC.TA1TBLKE = PTDREC.SY1STNBR; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0UM001.XXXPRCNM = "PC0US48";
  exit stack;

end // end PC0US48

// Clear PCWREC record of "*"
Function PC0US50()
   /* ------------------------------------------------------------*/
   /* This module clears the Wildcard "*" from the PCWREC pass*/
   /* record when going to the TS system, via a "S"election*/
   /* of a intransit row and hitting <ENTER>. XFER to TS0P.*/
   /* ------------------------------------------------------------*/

  if (PC0UW00.PC0UWDTF == "1") /* Etal row*/
    PCWREC.PC2INSEG = PC0UW02.PC2INSEG;
    PCWREC.SY2CLRID = PC0UW02.SY2CLRID;
    PCWREC.XQACD = PC0UW02.XQACD;
    PCWREC.XWHCD = PC0UW02.XWHCD;
    PCWREC.XPGCD = PC0UW02.XPGCD;
  else
    PCWREC.PC2INSEG = PC0UW22.PC2INSEG;
    PCWREC.SY2CLRID = PC0UW22.SY2CLRID;
    PCWREC.XQACD = PC0UW22.XQACD;
    PCWREC.XWHCD = PC0UW22.XWHCD;
    PCWREC.XPGCD = PC0UW22.XPGCD;
  end

  PCWREC.SY1STNBR = PC0UM001.SY1STNBR;

  if (PCWREC.XDMCD == "*")
    PCWREC.XDMCD = " ";
  end

  if (PCWREC.XOWCD == "*")
    PCWREC.XOWCD = " ";
  end

  if (PCWREC.XUMCD == "*")
    PCWREC.XUMCD = " ";
  end

  if (PCWREC.YSMXDV == "*")
    PCWREC.YSMXDV = " ";
  end

end // end PC0US50

// Calculate shipping dates
Function PC0US51()


   /* -----------------------------------------------------*/
    /* Move the dates that do not need to be calculated*/
    /* from the TSTREC to working storage to format*/
    /* into MMDD format.  Then calculated the other dates*/
   /* ------------------------------------------------------*/

    /* ETAL override*/

  if (TSTREC.TSIETALO != 0)
    PC0UW00.PC0UWFDT = TSTREC.TSIETALO;
    PC0UW00.PC0UWMMM = PC0UW00.PC0UWFMM;
    PC0UW00.PC0UWMDD = PC0UW00.PC0UWFDD;
    PC0UW00.PC0UWMYY = PC0UW00.PC0UWFYY;
    PC0UW18.PC0UWTAO = PC0UW00.PC0UWMDT; /* MMDDYY screen format*/
  end

    /* ETS (Estimated departure date)*/

  PC0UW00.PC0UWFDT = 0;

  if (TSTREC.TSISTAT == "TN")
    PC0UW00.PC0UWFDT = TSTREC.TSFDPRTE; /* Estimate departure time*/
    PC0UW00.PC0UWMMM = PC0UW00.PC0UWFMM;
    PC0UW00.PC0UWMDD = PC0UW00.PC0UWFDD;
    PC0UW00.PC0UWMYY = PC0UW00.PC0UWFYY;
    PC0UW18.PC0UWETS = PC0UW00.PC0UWMDT; /* MMDDYY screen format*/
    PC0UW18.PC0UW2TS = PC0UW00.PC0UWMMD; /* MMDD screen format*/
  else
    PC0UW00.PC0UWFDT = TSTREC.TSFDPRTA; /* Actual departure time*/
    PC0UW00.PC0UWMMM = PC0UW00.PC0UWFMM;
    PC0UW00.PC0UWMDD = PC0UW00.PC0UWFDD;
    PC0UW00.PC0UWMYY = PC0UW00.PC0UWFYY;
    PC0UW18.PC0UWETS = PC0UW00.PC0UWMDT; /* MMDDYY screen format*/
    PC0UW18.PC0UW2TS = PC0UW00.PC0UWMMD; /* MMDD screen format*/
  end



   /* -----------------------------------------------------*/
    /* Calculate the ETAL (Estimated time of allocation)*/
    /* date. ETAL = ETA (or RTA) + PADD*/
   /* ------------------------------------------------------*/



  set TA2REC empty; /* Initialize date record*/

  if (TSTREC.XWHCD != " "
   && TSTREC.XWHCD in XWHTBL.XWHCD)

    set TA2REC empty; /* Initialize record*/
    if (TSTREC.XGPCD == "03")
      if (TSTREC.XWHCD == "51" && 
      VFCTY003.PC-XCT-ORIG-CD == " ")
        if (VFCTY003.XCTCD == "USA")
          TA2REC.TA2DYAOD = 2; /* Padd days*/
        else
          TA2REC.TA2DYAOD = XWHTBL.XWHPAD[sysVar.arrayIndex]; /* Padd days*/
        end
      else
        if (TSTREC.XWHCD == "51" && 
        VFCTY003.PC-XCT-ORIG-CD == "USA")
          TA2REC.TA2DYAOD = 2; /* Padd days*/
        else
          TA2REC.TA2DYAOD = XWHTBL.XWHPAD[sysVar.arrayIndex]; /* Padd days*/
        end
      end
    else
      TA2REC.TA2DYAOD = XWHTBL.XWHPAD[sysVar.arrayIndex]; /* Padd days*/
    end
  else
    TA2REC.TA2DYAOD = 0; /* no PAD*/
  end

  if (TSTREC.TSFDESTA > 0)
    TA2REC.TA2GRGGN = TSTREC.TSFDESTA; /* RTA DATE*/
  else
    TA2REC.TA2GRGGN = TSTREC.TSFDESTE; /* ETa date*/
  end

  PC0US08(); /* Calculate date - days*/

  PC0UW00.PC0UWFDT = TA2REC.TA2GRGGN; /* ETAl date  to WS*/

  if (PCWREC.XGPCD == "03")
    if (PC0UW00.PC0UWFDD < 26)
      /* next sentence*/
    else
      PC0UW00.PC0UWFDD = 1;
      if (PC0UW00.PC0UWFMM == 12)
        PC0UW00.PC0UWFMM = 1;
        PC0UW00.PC0UWFYY = PC0UW00.PC0UWFYY + 1;
      else
        PC0UW00.PC0UWFMM = PC0UW00.PC0UWFMM + 1;
      end
    end
  end

  PC0UW00.PC0UWMMM = PC0UW00.PC0UWFMM;
  PC0UW00.PC0UWMDD = PC0UW00.PC0UWFDD;
  PC0UW00.PC0UWMYY = PC0UW00.PC0UWFYY;
  PC0UW18.PC0UWTAL = PC0UW00.PC0UWMDT; /* MMDDYY screen format*/
  PC0UW18.PC0UW2TA = PC0UW00.PC0UWMMD; /* MMDD screen format*/


end // end PC0US51

// Get Intransit siz data
Function PC0US52()


  PC0US21(); /* Declare cursor for vcplit01*/

  PC0US22(); /* Fetch next vcplit01 row*/

  while (PC0UW00.PC0UWCCF != "Y")

    PC0UW00.PC0UWIX2 = TSOREC.SY5SZID; /* Work index*/

     /* Move  shipping qty from record to work field*/

    if (TSOREC.TSOSHPQT != 0)
      PC0UW00.PC0UWWSZ = TSOREC.TSOSHPQT;
       /* Add to total for size*/
      PC0UW18.PC0UWORQ[PC0UWIX2] = PC0UW18.PC0UWORQ[PC0UWIX2] + PC0UWWSZ;
      PC0UW25.PC0UWORQ[PC0UWIX2] = PC0UW25.PC0UWORQ[PC0UWIX2] + PC0UWWSZ;
      if (TSTREC.TSISTAT == "IT"
       || TSTREC.TSISTAT == "CC")
        if (PC0UW00.PC0UWISF == "Y") /* Irregular shipping data*/
           /* Add to irregular totals for dest, color and style*/
          PC0UW00.PC0UWISD[PC0UWIX2] = PC0UW00.PC0UWISD[PC0UWIX2] + PC0UWWSZ;
          PC0UW00.PC0UWISC[PC0UWIX2] = PC0UW00.PC0UWISC[PC0UWIX2] + PC0UWWSZ;
          PC0UW00.PC0UWSS[PC0UWIX2] = PC0UW00.PC0UWSS[PC0UWIX2] + PC0UWWSZ;
        else
           /* Add to totals for dest, color and style*/
          PC0UW00.PC0UWDSZ[PC0UWIX2] = PC0UW00.PC0UWDSZ[PC0UWIX2] + PC0UWWSZ;
          PC0UW00.PC0UWCSZ[PC0UWIX2] = PC0UW00.PC0UWCSZ[PC0UWIX2] + PC0UWWSZ;
          PC0UW00.PC0UWSSZ[PC0UWIX2] = PC0UW00.PC0UWSSZ[PC0UWIX2] + PC0UWWSZ;
        end
      end

      PC0UW00.PC0UWSTB[PC0UWIX2] = "Y"; /* Indicate size has quantities*/
    end

    PC0US22(); /* Fetch next vcplit01 row*/

  end

  PC0US23(); /* close vcplit01 cursor*/

end // end PC0US52

// OPEN DTRANS.VCPLHD02 CURSOR
Function PC0US60()

   /* ------------------------------------------------------------*/
   /* Declare cursor for vcplhd02*/
   /* ------------------------------------------------------------*/

  PC0UW00.PC0UWTCF = "N"; /* Set trans cursor flag to no*/


  try
    call "IO4230" ("S4", SQLCA, TSTREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/
    return;
  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0US60"; /* Process name*/
  TA1REC.TA1LOC = "DECLARE CURSOR          ";
  TA1REC.TA1DBASE = "DTRANS  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCPLHD02"; /* Table view name*/
  TA1REC.TA1TBLKE = TSTREC.TSTKEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0UM001.XXXPRCNM = "PC0US60";
  exit stack;

end // end PC0US60

// FETCH VCPLHD02
Function PC0US61()

   /* ------------------------------------------------------------*/
   /* If row found return to calling processes--if not found*/
   /* set end of cursor flag --in other errors call ta0020*/
   /* ------------------------------------------------------------*/

  try
    call "IO4230" ("N4", SQLCA, TSTREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Row found*/
      return;
    end
    if (SQLCA.VAGen_SQLCODE == 100) /* Row not found*/
      PC0UW00.PC0UWTCF = "Y"; /* Indicate cursor at EOF*/
      return;
    end

  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0US61"; /* Process name*/
  TA1REC.TA1LOC = "FETCH ROW               ";
  TA1REC.TA1DBASE = "DTRANS  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCPLHD02"; /* Table view name*/
  TA1REC.TA1TBLKE = TSTREC.TSTKEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0UM001.XXXPRCNM = "PC0US61";
  exit stack;

end // end PC0US61

// PROCESS VCPLHD02
Function PC0US62()

   /* ------------------------------------------------------------*/
   /* If the status on the transporation row is equal to 'rc'*/
   /* bypass the row.*/
   /* ------------------------------------------------------------*/

  if (TSTREC.TSISTAT == "TN" /* Tentative*/
   || TSTREC.TSISTAT == "IT" /* Intransit*/
   || TSTREC.TSISTAT == "CC" /* Cleared customs*/
   || TSTREC.TSISTAT == "CR" /* Cleared customs / Hard error*/
   || TSTREC.TSISTAT == "ER") /* Shipped / Hard error*/
    PC0US70(); /* GET MATCHING PO ITEMS*/

    if (PC0UW00.PC0UW-ITM-FND == "Y") /* IF ITEM IS FOUND*/
                                  /* TRANS REC ALREADY DISPLAYED*/
      PC0US61(); /* Fetch next transporation row*/

      return;
    else
       /* next sentence SET UP TRANS REC FOR DISPLAY*/
    end
  else

    PC0US61(); /* Fetch next transporation row*/

    return;
  end


   /* ------------------------------------------------------------*/
   /* Obtain all the container rows for the Nike Shipping ID*/
   /* key.  Load the status for each container into a working*/
   /* storage table. If the status is not a valid status then the*/
   /* record will not be processed.  The quantities for any*/
   /* container with a valid status will be added into the*/
   /* accumulated totals. When the shipping header record has*/
   /* a status of 'tn' or 'cr' or 'er' the quantities are not to*/
   /* be added into any of the total fields.*/
   /* ------------------------------------------------------------*/

  move " " to PC0UW00.TSHSTAT[1] for all; /* Init ws container status table.*/
  move 0 to PC0UW00.TSHNKCN[1] for all; /* init ws container numbers table*/

  PC0UW00.TSHNKCN[1] = TSTREC.TSHNKCN1;
                                   /* move nike cntnr nbrs to tbl*/
  PC0UW00.TSHNKCN[2] = TSTREC.TSHNKCN2;
  PC0UW00.TSHNKCN[3] = TSTREC.TSHNKCN3;
  PC0UW00.TSHNKCN[4] = TSTREC.TSHNKCN4;
  PC0UW00.TSHNKCN[5] = TSTREC.TSHNKCN5;
  PC0UW00.TSHNKCN[6] = TSTREC.TSHNKCN6;
  PC0UW00.TSHNKCN[7] = TSTREC.TSHNKCN7;
  PC0UW00.TSHNKCN[8] = TSTREC.TSHNKCN8;

  PC0UW00.PC0UWSHQ[1] = TSTREC.TSISHPQ1;
                                   /* move nike cntnr qty to tbl*/
  PC0UW00.PC0UWSHQ[2] = TSTREC.TSISHPQ2;
  PC0UW00.PC0UWSHQ[3] = TSTREC.TSISHPQ3;
  PC0UW00.PC0UWSHQ[4] = TSTREC.TSISHPQ4;
  PC0UW00.PC0UWSHQ[5] = TSTREC.TSISHPQ5;
  PC0UW00.PC0UWSHQ[6] = TSTREC.TSISHPQ6;
  PC0UW00.PC0UWSHQ[7] = TSTREC.TSISHPQ7;
  PC0UW00.PC0UWSHQ[8] = TSTREC.TSISHPQ8;

  set TSHREC empty; /* Initialize record*/

  TSHREC.TSFSHPID = TSTREC.TSFSHPID; /* Key*/

  PC0UW00.PC0UWIX3 = 1;
  while (PC0UW00.PC0UWIX3 <= 8 /* not end of cntnr status table*/
   && PC0UW00.TSHNKCN[PC0UWIX3] != 0)

    /* -----------------------------------------------------*/
      /* If the status on the container row is not equal*/
      /* to 'rc' move the status to the working*/
      /* storage table.*/
    /* ------------------------------------------------------*/

    TSHREC.TSHNKCN = PC0UW00.TSHNKCN[PC0UWIX3];
    PC0US16(); /* get container row*/

    if (TSHREC.TSHSTAT != "RC")
      PC0UW00.TSHSTAT[PC0UWIX3] = TSHREC.TSHSTAT;
    end

    PC0UW00.PC0UWIX3 = PC0UW00.PC0UWIX3 + 1; /* increment while index*/

  end

  if (PC0UW00.TSHSTAT[1] == " " /* If there is no valid status for*/
   && PC0UW00.TSHSTAT[2] == " " /* any containers--obtain*/
   && PC0UW00.TSHSTAT[3] == " " /* the next header row and*/
   && PC0UW00.TSHSTAT[4] == " " /* exit the routine.*/
   && PC0UW00.TSHSTAT[5] == " " 
   && PC0UW00.TSHSTAT[6] == " " 
   && PC0UW00.TSHSTAT[7] == " " 
   && PC0UW00.TSHSTAT[8] == " ")

    PC0US61(); /* Fetch next transporation row*/

    return;

  end

   /* ------------------------------------------------------------*/
   /* Calculate the dates.*/
   /* Retrieve the size rows.*/
   /* Load the data to the temporary storage record.*/
   /* Write a temporary storage record if the page is full.*/
   /* ------------------------------------------------------------*/

   /* Increment page line index*/

  if (PC0UW00.PC0UW-FLG-1 == "Y") /* FIRST UNMATCHED TRANS REC*/
    PC0UW00.PC0UW-FLG-1 = "N"; /* RESET FLAG*/
    set PC0UW19 empty; /* INITALIZE RECORD*/
    PC0UW00.PC0UW-TRANS-LBL = "UNMATCHED TRANSPORTATION RECORDS";
    PC0UW19.PC0UW-LABEL = PC0UW00.PC0UW-TRANS-LBL;

    PC0UW19.PC0UW19K = 19; /* Record key*/
    PC0UW00.PC0UWIXT = PC0UW00.PC0UWIXT + 2; /* SKIP LINE, PRT HDING*/

    if (PC0UW00.PC0UWIXT == PC0UW00.PC0UWMAX /* Max lines (13)*/
     || PC0UW00.PC0UWIXT > PC0UW00.PC0UWMAX) /* Max lines (13)*/

      PC0US12(); /* Add page to temp storage*/
      PC0UW00.PC0UWIXT = PC0UW00.PC0UWIXT + 1;

    end
    PC0UW12.PC0UW12R[PC0UWIXT] = PC0UW19.PC0UW19G;

    if (PC0UW00.PC0UWIXT == PC0UW00.PC0UWMAX) /* Max lines (13)*/

      PC0US12(); /* Add page to temp storage*/

    end
  end

  PC0UW00.PC0UWIXT = PC0UW00.PC0UWIXT + 1;


  set PC0UW18 empty; /* Initialize record*/
  set PC0UW25 empty; /* Initialize record*/

  PC0US51(); /* Calculate shipping dates*/

  if (PC0UW00.PC0UWDTF == "2") /* Display s.o.*/
    if (TSTREC.OP1CUOID != 0)
      PC0UW00.PC0UWCOR = TSTREC.OP1CUOID;
      PC0UW00.PC0UWDOT = ".";
      PC0UW00.PC0UWNOR = TSTREC.OP1NORID;
      PC0UW25.PC0UWSNN = PC0UW00.PC0UWORD;
    else
      PC0UW00.PC0UWCOR = 0;
      PC0UW00.PC0UWDOT = " ";
      PC0UW00.PC0UWNOR = 0;
      PC0UW25.PC0UWSNN = " ";
    end
  end

   /* Set flag to indicate shipping data exists*/

  PC0UW00.PC0UWSDF = "Y"; /* Shipping data flag*/

   /* Move intransit data from TSTREC to temp storage record*/

  if (PC0UW00.PC0UWISF == "Y") /* Irregular shipping flag*/
    PC0UW18.PC0UW18I = "IR"; /* Irregular literal*/
    PC0UW18.PC0UWIRT = "IR"; /* Screen two irregular literal*/
    PC0UW25.PC0UW18I = "IR"; /* Irregular literal*/
    PC0UW25.PC0UWIRT = "IR"; /* Screen two irregular literal*/
  end

  if (TSHREC.TSHSTAT == "IT"
   || TSHREC.TSHSTAT == "CC")
    PC0UW18.PC0UW18L = " INTR:"; /* Intransit literal*/
    PC0UW25.PC0UW18L = " INTR:"; /* Intransit literal*/
    if (TSTREC.XWHCD != " ")
      PC0UW18.PC0UW-WS-RLBL = " INWH:"; /* Screen two in literal*/
      PC0UW25.PC0UW-WS-RLBL = " INWH:"; /* Screen two in literal*/
    end
  else
    PC0UW18.PC0UW18L = "*INTR:"; /* Intransit literal*/
    PC0UW25.PC0UW18L = "*INTR:"; /* Intransit literal*/
    if (TSTREC.XWHCD != " ")
      PC0UW18.PC0UW-WS-RLBL = "*INWH:"; /* Screen two in literal*/
      PC0UW25.PC0UW-WS-RLBL = "*INWH:"; /* Screen two in literal*/
    end
  end

  PC0UW18.XWHCD = TSTREC.XWHCD;
  PC0UW25.XWHCD = TSTREC.XWHCD;
  PC0UW18.PC2CUXID = TSTREC.PC2CUXID;
  PC0UW25.PC2CUXID = TSTREC.PC2CUXID;
  PC0UW18.TSISTAT = TSTREC.TSISTAT; /* Status*/
  PC0UW25.TSISTAT = TSTREC.TSISTAT; /* Status*/
  PC0UW18.PC0UW-SLASH = "/";
  PC0UW25.PC0UW-SLASH = "/";
  PC0UW18.YSTCD = TSTREC.YSTCD; /* Shipment type*/
  PC0UW25.YSTCD = TSTREC.YSTCD; /* shipment type*/
  PC0UW00.PC0UWFDT = TSTREC.TSFSTADT; /* Status date to ws*/
  PC0UW18.TSFSHPID = TSTREC.TSFSHPID;
  PC0UW25.TSFSHPID = TSTREC.TSFSHPID;
  PC0UW18.TSIPLNBR = TSTREC.TSIPLNBR;
  PC0UW25.TSIPLNBR = TSTREC.TSIPLNBR;
  PC0UW00.PC0UWMMM = PC0UW00.PC0UWFMM;
  PC0UW00.PC0UWMDD = PC0UW00.PC0UWFDD;
  PC0UW18.PC0UWSTD = PC0UW00.PC0UWMMD;
  PC0UW25.PC0UWSTD = PC0UW00.PC0UWMMD;
  PC0UW18.TSACARCD = TSTREC.TSACARCD; /* Carrier code*/
  PC0UW25.TSACARCD = TSTREC.TSACARCD; /* Carrier code*/
  PC0UW18.TS5CRAFT = TSTREC.TS5CRAFT; /* craft*/
  PC0UW25.TS5CRAFT = TSTREC.TS5CRAFT; /* craft*/
  PC0UW18.SY2CLRID = TSTREC.SY2CLRID; /* color code*/
  PC0UW25.SY2CLRID = TSTREC.SY2CLRID; /* color code*/
  PC0UW18.PC0UW-SC2-CLR = TSTREC.SY2CLRID; /* color code*/
  PC0UW25.PC0UW-SC2-CLR = TSTREC.SY2CLRID; /* color code*/
  PC0UW18.XOWCD = TSTREC.XOWCD; /* OWNER GROUP*/
  PC0UW25.XOWCD = TSTREC.XOWCD; /* OWNER GROUP*/
  PC0UW18.XQACD = TSTREC.XQACD; /* QUALITY CODE*/
  PC0UW25.XQACD = TSTREC.XQACD; /* QUALITY CODE*/

   /* Get rid of leading zeros for the shipping number*/


  PC0UW00.PC0UWSHX = TSTREC.TSFSHPID; /* numeric field*/
  PC0UW00.PC0UWSHW = PC0UW00.PC0UWSHX; /* Move to character field*/

   /* Find first significant digit*/

  PC0UW00.PC0UWIX4 = 1;

  while (PC0UW00.PC0UWIX4 <= 8
   && PC0UW00.PC0UWSHA[PC0UWIX4] == "0")
    PC0UW00.PC0UWSHA[PC0UWIX4] = " ";
    PC0UW00.PC0UWIX4 = PC0UW00.PC0UWIX4 + 1;
  end

  PC0UW18.PC0UWSHN = PC0UW00.PC0UWSHW; /* Shipping number*/
  PC0UW25.PC0UWSHN = PC0UW00.PC0UWSHW; /* Shipping number*/

   /* *************************************************************/
   /* If the status for the container was equal to 'it' or 'cc'*/
   /* Add the quantities from the shipping record to the*/
   /* total shipping quantity field and obtain all the*/
   /* size data for the container.*/
   /* *************************************************************/

  PC0UW00.PC0UWWF1 = 0; /* Initialize 'it''cc' work qty field*/
  PC0UW00.PC0UWWT1 = 0; /* Initialize 'tn' work qty field*/

  PC0UW00.PC0UWIX3 = 1;
  while (PC0UWIX3 <= 8
   && PC0UW00.TSHNKCN[PC0UWIX3] != 0)
    if (PC0UW00.TSHSTAT[PC0UWIX3] != " ")
      if (TSTREC.TSISTAT == "IT"
       || TSTREC.TSISTAT == "CC")
        PC0UW00.PC0UWWF1 = PC0UW00.PC0UWWF1 + PC0UW00.PC0UWSHQ[PC0UWIX3];
      else
         /* ==> tentative or hard errors only show a total on the*/
         /* ==>   screen and don't calculate into the regular totals*/
        PC0UW00.PC0UWWT1 = PC0UW00.PC0UWWT1 + PC0UW00.PC0UWSHQ[PC0UWIX3];
      end
      set TSOREC empty;
      TSOREC.TSFSHPID = TSTREC.TSFSHPID; /* Nike ship Id*/
      TSOREC.TSIPLNBR = TSTREC.TSIPLNBR; /* Nike plan number*/
      TSOREC.TSHNKCN = PC0UW00.TSHNKCN[PC0UWIX3]; /* Container nbr*/
      PC0US52(); /* Obtain intransit size data*/
    end

    PC0UW00.PC0UWIX3 = PC0UW00.PC0UWIX3 + 1;

  end

  if (TSTREC.TSISTAT == "IT"
   || TSTREC.TSISTAT == "CC")
    PC0UW18.PC0UWQTY = PC0UW00.PC0UWWF1;
    PC0UW25.PC0UWQTY = PC0UW00.PC0UWWF1;
  else
    PC0UW18.PC0UWQTY = PC0UW00.PC0UWWT1; /* for tentative/hard errors*/
    PC0UW25.PC0UWQTY = PC0UW00.PC0UWWT1; /* for tentative/hard errors*/
  end


  if (PC0UW00.PC0UWISF == "Y") /* If irregular shipping data*/
    PC0UW00.PC0UWIDS = PC0UW00.PC0UWIDS + PC0UWWF1; /* Irreg by destination*/
    PC0UW00.PC0UWICS = PC0UW00.PC0UWICS + PC0UWWF1; /* Irreg by color*/
    PC0UW00.PC0UWISS = PC0UW00.PC0UWICS + PC0UWWF1; /* Irreg by style*/
  else
    PC0UW00.PC0UWTDS = PC0UW00.PC0UWTDS + PC0UWWF1; /* Total by destination*/
    PC0UW00.PC0UWTCS = PC0UW00.PC0UWTCS + PC0UWWF1; /* Total by color*/
    PC0UW00.PC0UWTSS = PC0UW00.PC0UWTSS + PC0UWWF1; /* Total by style*/
  end

  if (PC0UW00.PC0UWDTF == "1") /* Display ETAL*/
    PC0UW18.PC0UW18K = 18; /* Record key*/
    PC0UW12.PC0UW12R[PC0UWIXT] = PC0UW18.PC0UW18G;
  else
    PC0UW25.PC0UW18K = 25; /* Record key*/
    PC0UW12.PC0UW12R[PC0UWIXT] = PC0UW25.PC0UW18G;
  end

  if (PC0UW00.PC0UWIXT == PC0UW00.PC0UWMAX) /* Max lines (13)*/

    PC0US12(); /* Add page to temp storage*/

  end

  PC0US61(); /* Fetch next vcplhd02 row*/

end // end PC0US62

// CLOSE DTRANS.VCPLHD02
Function PC0US63()

   /* ------------------------------------------------------------*/
   /* Close cursor for vcplhd02*/
   /* ------------------------------------------------------------*/

  try
    call "IO4230" ("C4", SQLCA, TSTREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/
    return;
  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0US63"; /* Process name*/
  TA1REC.TA1LOC = "CLOSE CURSOR            ";
  TA1REC.TA1DBASE = "DTRANS  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCPLHD02"; /* Table view name*/
  TA1REC.TA1TBLKE = TSTREC.TSTKEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0UM001.XXXPRCNM = "PC0US63";
  exit stack;

end // end PC0US63

// OPEN DTRANS.VFYPO001 CURSOR
Function PC0US65()

   /* ------------------------------------------------------------*/
   /* Declare cursor for VFYPO002*/
   /* ------------------------------------------------------------*/

  PC0UW00.PC0UWRCF = "N"; /* Set Received cursor flag to no*/


  try
    call "VFYPO002" ("S7", SQLCA, VFYPO002) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/
    return;
  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0US65"; /* Process name*/
  TA1REC.TA1LOC = "DECLARE CURSOR          ";
  TA1REC.TA1DBASE = "DPRODC  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VFYPO002"; /* Table view name*/
  TA1REC.TA1TBLKE = VFYPO002.VFYPO002-KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0UM001.XXXPRCNM = "PC0US65";
  exit stack;

end // end PC0US65

// FETCH VFYPO001
Function PC0US66()

   /* ------------------------------------------------------------*/
   /* If row not found return to previous process.*/
   /* If any other, indicate system error.*/
   /* ------------------------------------------------------------*/

  try
    call "VFYPO002" ("N7", SQLCA, VFYPO002) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Row found*/
      return;
    end
    if (SQLCA.VAGen_SQLCODE == 100) /* Row not found*/
      PC0UW00.PC0UWRCF = "Y"; /* Indicate cursor at EOF*/
      return;
    end

  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0US66"; /* Process name*/
  TA1REC.TA1LOC = "FETCH ROW               ";
  TA1REC.TA1DBASE = "DPRODC  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VFYPO002"; /* Table view name*/
  TA1REC.TA1TBLKE = VFYPO002.VFYPO002-KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0UM001.XXXPRCNM = "PC0US66";
  exit stack;

end // end PC0US66

// PROCESS VFYPO001
Function PC0US67()


   /* ------------------------------------------------------------*/
   /* Move the data from the database record to the pc0uw17/26*/
   /* storage record--then move the storage group level to*/
   /* the temporary storage record (pc0uw09).  Add the total*/
   /* received quantity from the pcmrec to the total received*/
   /* quantity in working storage.*/
   /* ------------------------------------------------------------*/


  if (VFYPO002.YRSCD == "10"
   || VFYPO002.YRSCD == "11"
   || VFYPO002.YRSCD == "12"
   || VFYPO002.YRSCD == "13")
    PC0US71(); /* GO AFTER PO ITEM DATA*/
    if (PC0UW00.PC0UW-ITM-FND == "Y") /* IF THE ITEM IS FOUND*/
                                  /* WE DON'T NEED THIS TRANS REC*/
      PC0US66(); /* Fetch next receiving row*/
      return;

    else
       /* next sentence  SET UP RECORD FOR DISPLAY*/
    end
  else

    PC0US66(); /* Fetch next receiving row*/

    return;

  end

   /* IF THIS IS THE FIRST UNMATCHED TRANS REC.  MOVE OUT A LABEL*/
   /* Increment page line index*/

  if (PC0UW00.PC0UW-FLG-1 == "Y") /* FIRST UNMATCHED TRANS REC*/
    PC0UW00.PC0UW-FLG-1 = "N"; /* RESET FLAG*/
    set PC0UW19 empty; /* INITALIZE RECORD*/
    PC0UW00.PC0UW-TRANS-LBL = "UNMATCHED TRANSPORTATION RECORDS";
    PC0UW19.PC0UW-LABEL = PC0UW00.PC0UW-TRANS-LBL;

    PC0UW19.PC0UW19K = 19; /* Record key*/
    PC0UW00.PC0UWIXT = PC0UW00.PC0UWIXT + 2; /* SKIP LINE, PRT HDING*/

    if (PC0UW00.PC0UWIXT == PC0UW00.PC0UWMAX /* Max lines (13)*/
     || PC0UW00.PC0UWIXT > PC0UW00.PC0UWMAX) /* Max lines (13)*/

      PC0US12(); /* Add page to temp storage*/
      PC0UW00.PC0UWIXT = PC0UW00.PC0UWIXT + 1;

    end
    PC0UW12.PC0UW12R[PC0UWIXT] = PC0UW19.PC0UW19G;

    if (PC0UW00.PC0UWIXT == PC0UW00.PC0UWMAX) /* Max lines (13)*/

      PC0US12(); /* Add page to temp storage*/

    end
  end

   /* Increment page line index*/

  PC0UW00.PC0UWIXT = PC0UW00.PC0UWIXT + 1;

  set PC0UW17 empty; /* Initialize record*/
  set PC0UW26 empty; /* Initialize record*/


  if (PC0UW00.PC0UWIRF == "Y")
    PC0UW17.PC0UW17I = "IR";
    PC0UW17.PC0UWIRL = "IR";
    PC0UW26.PC0UW17I = "IR";
    PC0UW26.PC0UWIRL = "IR";
  end
  if (VFYPO002.YRSCD == "12")
    PC0UW17.PC0UW17L = "*RCPT:";
    PC0UW17.PC0UW2RC = "*RCPT:";
    PC0UW26.PC0UW17L = "*RCPT:";
    PC0UW26.PC0UW2RC = "*RCPT:";
  else
    PC0UW17.PC0UW17L = " RCPT:";
    PC0UW17.PC0UW2RC = " RCPT:";
    PC0UW26.PC0UW17L = " RCPT:";
    PC0UW26.PC0UW2RC = " RCPT:";
  end
  PC0UW17.XWHCD = VFYPO002.XWHCD;
  PC0UW26.XWHCD = VFYPO002.XWHCD;
  PC0UW17.PC2CUXID = VFYPO002.PC2CUXID;
  PC0UW26.PC2CUXID = VFYPO002.PC2CUXID;
  PC0UW17.SY2CLRID = VFYPO002.SY2CLRID;
  PC0UW26.SY2CLRID = VFYPO002.SY2CLRID;
  PC0UW17.PC0UW2CR = VFYPO002.SY2CLRID;
  PC0UW26.PC0UW2CR = VFYPO002.SY2CLRID;
  PC0UW17.XOWCD = VFYPO002.XOWCD;
  PC0UW26.XOWCD = VFYPO002.XOWCD;
  PC0UW17.XQACD = VFYPO002.XQACD; /* Transportation mode*/
  PC0UW26.XQACD = VFYPO002.XQACD; /* Transportation mode*/

   /* Get rid of leading zeros for the receiving number*/


  PC0UW17.YRSCD = VFYPO002.YRSCD; /* Received status*/
  PC0UW26.YRSCD = VFYPO002.YRSCD; /* Received status*/
  PC0UW17.YMTCD = VFYPO002.YMTCD; /* Transportation mode*/
  PC0UW26.YMTCD = VFYPO002.YMTCD; /* Transportation mode*/
  PC0UW00.PC0UWSHX = VFYPO002.SL1RCRNO; /* Received report number*/
  PC0UW00.PC0UWSHW = PC0UW00.PC0UWSHX; /* Move to character field*/

   /* FIND FIRST SIGNIGICANT DIGIT*/

  PC0UW00.PC0UWIX4 = 1;

  while (PC0UW00.PC0UWIX4 <= 8
   && PC0UW00.PC0UWSHA[PC0UWIX4] == "0")
    PC0UW00.PC0UWSHA[PC0UWIX4] = " ";
    PC0UW00.PC0UWIX4 = PC0UW00.PC0UWIX4 + 1;
  end

  PC0UW17.PC0UWRNO = PC0UW00.PC0UWSHW;
  PC0UW17.PC0UWRCN = PC0UW00.PC0UWSHW;
  PC0UW26.PC0UWRNO = PC0UW00.PC0UWSHW;
  PC0UW26.PC0UWRCN = PC0UW00.PC0UWSHW;

     /* container received data*/

  if (PC0UW00.PC0UWDTF == "1") /* Show ETAL data*/
    PC0UW00.PC0UWFDT = VFYPO002.TSHRCTDT; /* Update date to WS*/
    PC0UW00.PC0UWMMM = PC0UW00.PC0UWFMM;
    PC0UW00.PC0UWMDD = PC0UW00.PC0UWFDD;
    PC0UW00.PC0UWMYY = PC0UW00.PC0UWFYY;
    PC0UW17.PC0UWTAL = PC0UW00.PC0UWMDT;
                                   /* MMDDYY date to temp storage*/
    PC0UW17.PC0UW2TA = PC0UW00.PC0UWMMD; /* MMDD screen 2 date*/
  else
    if (VFYPO002.OP1CUOID != 0)
      PC0UW00.PC0UWCOR = VFYPO002.OP1CUOID;
      PC0UW00.PC0UWDOT = ".";
      PC0UW00.PC0UWNOR = VFYPO002.OP1NORID;
      PC0UW26.PC0UWSNN = PC0UW00.PC0UWORD;
    else
      PC0UW00.PC0UWCOR = 0;
      PC0UW00.PC0UWDOT = " ";
      PC0UW00.PC0UWNOR = 0;
      PC0UW26.PC0UWSNN = " ";
    end
  end


   /* ------------------------------------------------------------*/
   /* Move the size quantities from the size array in the pcmrec*/
   /* to the size array in the temporary storage record (when*/
   /* there are quanitites for a size). In addition move a 'y'*/
   /* to the corresponding fields in the working storage array*/
   /* to indicate that the table entry had a quantity.  This*/
   /* flag will be used to determine what sizes will be*/
   /* displayed on the size screen.  (The users only want to*/
   /* see a size if it has a quantity associated with it).*/
   /* Add the size quanitities into the size quantity array*/
   /* for received data in working storage.*/
   /* In addition for some inexplicable reason the user wants*/
   /* to see the receiving quantites as negatives.*/
   /* ------------------------------------------------------------*/

  PC0UW00.PC0UWIX1 = 1; /* Initialize general index*/

  while (PC0UW00.PC0UWIX1 <= 40)
    if (VFYPO002.PCMRCPTQ[PC0UWIX1] != 0)
      PC0UW17.PC0UWORQ[PC0UWIX1] = VFYPO002.PCMRCPTQ[PC0UWIX1];
      PC0UW26.PC0UWORQ[PC0UWIX1] = VFYPO002.PCMRCPTQ[PC0UWIX1];
      PC0UW00.PC0UWSTB[PC0UWIX1] = "Y"; /* size flag set to yes*/
      PC0UW00.PC0UWWSZ = VFYPO002.PCMRCPTQ[PC0UWIX1];
      PC0UW17.PC0UWQTY = PC0UW17.PC0UWQTY + PC0UWWSZ;
      PC0UW26.PC0UWQTY = PC0UW26.PC0UWQTY + PC0UWWSZ;
      if (VFYPO002.YRSCD != "12")
        if (PC0UW00.PC0UWIRF == "Y") /* Irregular data*/
           /* Add size quantity to irregular received size fields*/
          PC0UW00.PC0UWIDR = PC0UW00.PC0UWIDR + PC0UWWSZ;
          PC0UW00.PC0UWICR = PC0UW00.PC0UWICR + PC0UWWSZ;
          PC0UW00.PC0UWISR = PC0UW00.PC0UWISR + PC0UWWSZ;
          PC0UW00.PC0UWIRD[PC0UWIX1] = PC0UW00.PC0UWIRD[PC0UWIX1] +           PC0UWWSZ;
          PC0UW00.PC0UWIRC[PC0UWIX1] = PC0UW00.PC0UWIRC[PC0UWIX1] +           PC0UWWSZ;
          PC0UW00.PC0UWIRS[PC0UWIX1] = PC0UW00.PC0UWIRS[PC0UWIX1] +           PC0UWWSZ;
           /* Add size quantity to total received  quantity*/
        else
          PC0UW00.PC0UWTDR = PC0UW00.PC0UWTDR + PC0UWWSZ;
          PC0UW00.PC0UWTCR = PC0UW00.PC0UWTCR + PC0UWWSZ;
          PC0UW00.PC0UWTSR = PC0UW00.PC0UWTSR + PC0UWWSZ;
          PC0UW00.PC0UWDRZ[PC0UWIX1] = PC0UW00.PC0UWDRZ[PC0UWIX1] +           PC0UWWSZ;
          PC0UW00.PC0UWCRZ[PC0UWIX1] = PC0UW00.PC0UWCRZ[PC0UWIX1] +           PC0UWWSZ;
          PC0UW00.PC0UWSRZ[PC0UWIX1] = PC0UW00.PC0UWSRZ[PC0UWIX1] +           PC0UWWSZ;
        end
      end
    end
    PC0UW00.PC0UWIX1 = PC0UW00.PC0UWIX1 + 1;
  end

  if (PC0UW00.PC0UWDTF == "1") /* Show ETAL data*/
    PC0UW17.PC0UW17K = 17; /* Record key*/
    PC0UW12.PC0UW12R[PC0UWIXT] = PC0UW17.PC0UW17G;
  else
    PC0UW26.PC0UW17K = 26; /* Record key*/
    PC0UW12.PC0UW12R[PC0UWIXT] = PC0UW26.PC0UW17G;
  end

  if (PC0UW00.PC0UWIXT == PC0UW00.PC0UWMAX) /* Max lines*/

    PC0US12(); /* Add page to temp storage*/

  end


  PC0US66(); /* Fetch next receiving row*/



end // end PC0US67

// CLOSE DTRANS.VFYPO001
Function PC0US68()

   /* ------------------------------------------------------------*/
   /* Close cursor for VFYPO002*/
   /* ------------------------------------------------------------*/

  try
    call "VFYPO002" ("C7", SQLCA, VFYPO002) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/
    return;
  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0US68"; /* Process name*/
  TA1REC.TA1LOC = "CLOSE CURSOR            ";
  TA1REC.TA1DBASE = "DPRODC  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VFYPO002"; /* Table view name*/
  TA1REC.TA1TBLKE = VFYPO002.VFYPO002-KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0UM001.XXXPRCNM = "PC0US68";
  exit stack;

end // end PC0US68

// GET UNMATCHED TSTRECS
Function PC0US70()
   /* -------------------------------------------------------------------*/
   /* RETRIEVE PO ITEMS BASED ON THE TSTREC FIELDS*/
   /* -------------------------------------------------------------------*/
   /*  */
  set VPOITM05 empty;
  PC0UW00.PC0UW-ITM-FND = "N";
   /*  */
   /* SET UP PO ITEM TO READ*/
   /*  */
  VPOITM05.PC3PONBR = TSTREC.PC3PONBR;
  VPOITM05.PO-REG-CD = PCWREC.PO-REG-CD;
  VPOITM05.XGPCD = TSTREC.XGPCD;
  VPOITM05.SY1STNBR = TSTREC.SY1STNBR;
  VPOITM05.SY2CLRID = TSTREC.SY2CLRID;
  VPOITM05.XOWCD = TSTREC.XOWCD;
  VPOITM05.XDMCD = TSTREC.XDMCD;
  VPOITM05.PC2INSEG = TSTREC.PC2INSEG;
  VPOITM05.XPGCD = TSTREC.XPGCD;
  VPOITM05.XUMCD = TSTREC.XUMCD;
  VPOITM05.PC2CUXID = TSTREC.PC2CUXID;
  VPOITM05.XWHCD = TSTREC.XWHCD;
  VPOITM05.OP1PARTN = TSTREC.OP1PARTN;
  VPOITM05.OP1CUOID = TSTREC.OP1CUOID;
  VPOITM05.OP1NORID = TSTREC.OP1NORID;
  if (TSTREC.YSTCD == "AR")
    VPOITM05.OP1PARTN = "*";
    VPOITM05.OP1CUOID = -1;
    VPOITM05.OP1NORID = -1;
  end
  VPOITM05.PC6ETSDT = -1;
  VPOITM05.PC6PLAN = -1;
  VPOITM05.PC6RTADT = -1;
  VPOITM05.PC6OETS = -1;
  VPOITM05.YMTCD = "*";
  VPOITM05.XDSCD = "*";
  VPOITM05.YSMXDV = "*";
  VPOITM05.XQACD = "*";

  if (PCWREC.XGPCD == "03"
   && TSTREC.XQACD == "02"
   && PC0UW00.XWHCD[PC0UWDIX] != "18")
    VPOITM05.XWHCD = "*";
    VPOITM05.PC2CUXID = "*";
    VPOITM05.XOWCD = "*";
    VPOITM05.XUMCD = "*";
    VPOITM05.PC2INSEG = "*";
    VPOITM05.OP1PARTN = "*";
    VPOITM05.OP1CUOID = -1;
    VPOITM05.OP1NORID = -1;
  end

  PC0US74(); /* OPEN CURSOR FOR PO ITEM*/
   /*  */
  PC0US75(); /* FETCH FIRST ITEM*/
   /*  */
  while (SQLCA.VAGen_SQLCODE == 0 /* fetch until non-cancelled*/
   && VPOITM05.PC6STAT == "CX") /* item found*/
    PC0UW00.PC0UW-ITM-FND = "N";
    PC0US75();
  end
   /*  */
  PC0US76(); /* CLOSE CURSOR*/
   /*  */
   /*  */
end // end PC0US70

// GET UNMATCHED PCMRECS
Function PC0US71()
   /* -------------------------------------------------------------------*/
   /* RETRIEVE PO ITEMS BASED ON THE VFYPO002 FIELDS*/
   /* -------------------------------------------------------------------*/
   /*  */
  set VPOITM05 empty;
  PC0UW00.PC0UW-ITM-FND = "N";
   /*  */
   /* SET UP PO ITEM TO READ*/
   /*  */
  VPOITM05.PO-REG-CD = VFYPO002.PO-REG-CD;
  VPOITM05.PC3PONBR = VFYPO002.PC3PONBR;
  VPOITM05.XGPCD = VFYPO002.XGPCD;
  VPOITM05.SY1STNBR = VFYPO002.SY1STNBR;
  VPOITM05.SY2CLRID = VFYPO002.SY2CLRID;
  VPOITM05.XDMCD = VFYPO002.XDMCD;
  VPOITM05.PC2INSEG = VFYPO002.PC2INSEG;
  VPOITM05.XPGCD = VFYPO002.XPGCD;
  VPOITM05.XUMCD = VFYPO002.XUMCD;
  VPOITM05.PC2CUXID = VFYPO002.PC2CUXID;
  VPOITM05.XWHCD = VFYPO002.XWHCD;
  VPOITM05.OP1PARTN = VFYPO002.OP1PARTN;
  VPOITM05.OP1CUOID = VFYPO002.OP1CUOID;
  VPOITM05.OP1NORID = VFYPO002.OP1NORID;
  if (VFYPO002.PC4ORTYP == "AR")
    VPOITM05.OP1PARTN = "*";
    VPOITM05.OP1CUOID = -1; /* Cust ord*/
    VPOITM05.OP1NORID = -1; /* Nike ord*/
  end
  VPOITM05.PC6ETSDT = -1;
  VPOITM05.PC6PLAN = -1;
  VPOITM05.PC6RTADT = -1;
  VPOITM05.PC6OETS = -1;
  VPOITM05.XDSCD = "*";
  VPOITM05.YSMXDV = "*";
  VPOITM05.XQACD = "*";
  VPOITM05.YMTCD = "*";

  VPOITM05.XOWCD = VFYPO002.XOWCD;

  if (PCWREC.XGPCD == "03"
   && VFYPO002.XQACD == "02"
   && VFYPO002.XWHCD != "18")
    VPOITM05.XWHCD = "*";
    VPOITM05.XUMCD = "*";
    VPOITM05.PC2CUXID = "*";
    VPOITM05.XOWCD = "*";
    VPOITM05.PC2INSEG = "*";
    VPOITM05.OP1PARTN = "*";
    VPOITM05.OP1CUOID = -1;
    VPOITM05.OP1NORID = -1;
  end

  PC0US74(); /* OPEN CURSOR FOR PO ITEM*/
   /*  */
  PC0US75(); /* FETCH FIRST ITEM*/
  while (SQLCA.VAGen_SQLCODE == 0 /* keep reading until status other*/
   && VPOITM05.PC6STAT == "CX") /* than cancelled found, or end of*/
    PC0UW00.PC0UW-ITM-FND = "N"; /* cursor*/
    PC0US75();
  end
   /*  */
  PC0US76(); /* CLOSE CURSOR*/
   /*  */
end // end PC0US71

// OPEN POITM CURSOR
Function PC0US74()

   /* ------------------------------------------------------------*/
   /* Declare cursor for VPOITM05*/
   /* ------------------------------------------------------------*/


  set PCYREC empty;
  PCYREC.PCYFUNC = "SH";
  try
    call "VPOITM05" (PCYREC, SQLCA, VPOITM05) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/
    return;
  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0US74"; /* Process name*/
  TA1REC.TA1LOC = "DECLARE CURSOR          ";
  TA1REC.TA1DBASE = "DPRODC  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VPOITM05"; /* Table view name*/
  TA1REC.TA1TBLKE = VPOITM05.VPOITM05-KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0UM001.XXXPRCNM = "PC0US74";
  exit stack;

end // end PC0US74

// FETCH POITM REC
Function PC0US75()
   /* ------------------------------------------------------------*/
   /* If row not found return to previous process.*/
   /* If any other, indicate system error.*/
   /* ------------------------------------------------------------*/

  set PCYREC empty;
  PCYREC.PCYFUNC = "NH";
  try
    call "VPOITM05" (PCYREC, SQLCA, VPOITM05) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Row found*/
      PC0UW00.PC0UW-ITM-FND = "Y"; /* Indicate ITEM FOUND*/
      return;
    end
    if (SQLCA.VAGen_SQLCODE == 100) /* Row not found*/
      return;
    end

  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0US75"; /* Process name*/
  TA1REC.TA1LOC = "FETCH ROW               ";
  TA1REC.TA1DBASE = "DPRODC  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VPOITM05"; /* Table view name*/
  TA1REC.TA1TBLKE = VPOITM05.VPOITM05-KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0UM001.XXXPRCNM = "PC0US75";
  exit stack;

end // end PC0US75

// CLOSE POITM CURSOR
Function PC0US76()

   /* ------------------------------------------------------------*/
   /* Close cursor for VPOITM05*/
   /* ------------------------------------------------------------*/
  set PCYREC empty;
  PCYREC.PCYFUNC = "CH";
  try
    call "VPOITM05" (PCYREC, SQLCA, VPOITM05) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/
    return;
  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "PC0US76"; /* Process name*/
  TA1REC.TA1LOC = "CLOSE CURSOR            ";
  TA1REC.TA1DBASE = "DPRODC  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VPOITM05"; /* Table view name*/
  TA1REC.TA1TBLKE = VPOITM05.VPOITM05-KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  PC0UM001.XXXPRCNM = "PC0US76";
  exit stack;

end // end PC0US76

//*** RECORD=PC0UW00 ****
// ---------------------------
// Application Working Storage
// ---------------------------
// ***********************
Record PC0UW00 type basicRecord
  5 * char(7595) ; 
    10 PC0UWRC PC0UWRC [4] ; 
    10 PC0UWSQ PC0UWSQ [4] ; 
    10 PC0UWMXJ PC0UWMXJ [4] ; 
    10 PC0UWTSL PC0UWTSL ; 
    10 PC0UWODF PC0UWODF ; 
    10 PC0UWXDF PC0UWXDF ; 
    10 PC0UWSRF PC0UWSRF ; 
    10 TA5TSQIX TA5TSQIX ; 
    10 PC0UWTSP PC0UWTSP ; 
    10 PC0UWPAG PC0UWPAG ; 
    10 PC0UWICF PC0UWICF ; 
    10 PC0UW-ITM-FND PC0UW-ITM-FND ; 
    10 PC0UWRCF PC0UWRCF ; 
    10 PC0UWWCF PC0UWWCF ; 
    10 PC0UWTCF PC0UWTCF ; 
    10 PC0UWCCF PC0UWCCF ; 
    10 PC0UWSDF PC0UWSDF ; 
    10 PC0UWRDF PC0UWRDF ; 
    10 PC0UWOSD PC0UWOSD ; 
    10 PC0UWIRF PC0UWIRF ; 
    10 PC0UWISF PC0UWISF ; 
    10 PC0UWNEF PC0UWNEF ; 
    10 PC0UWPDF PC0UWPDF ; 
    10 SY2CLRID SY2CLRID ; 
    10 PC0UWCNT PC0UWCNT ; 
    10 PC0UWICT PC0UWICT ; 
    10 PC0UWSPG PC0UWSPG ; 
    10 PC0UWCNP PC0UWCNP [3] ; 
      15 PC0UWINT PC0UWINT ; 
      15 PC0UWDEC PC0UWDEC ; 
    10 PC0UWSPR PC0UWSPR ; 
    10 PC0UWCSP PC0UWCSP ; 
    10 PC0UWETA PC0UWETA ; 
    10 PC0UWDDT PC0UWDDT ; 
      15 PC0UWDCR PC0UWDCR ; 
      15 PC0UWDYR PC0UWDYR ; 
      15 PC0UWDMT PC0UWDMT ; 
      15 PC0UWDDA PC0UWDDA ; 
    10 PC0UWSDT PC0UWSDT ; 
      15 PC0UWSMM PC0UWSMM ; 
      15 PC0UWSDD PC0UWSDD ; 
      15 PC0UWSYY PC0UWSYY ; 
    10 XGPCD XGPCD ; 
    10 XPGCD XPGCD ; 
    10 XDMCD XDMCD ; 
    10 XUMCD XUMCD ; 
    10 XQACD XQACD ; 
    10 PC0UWPID PC0UWPID ; 
      15 PC0UWSYR PC0UWSYR ; 
      15 PC0UWDH1 PC0UWDH1 ; 
      15 PC0UWPMO PC0UWPMO ; 
      15 PC0UWDH2 PC0UWDH2 ; 
      15 PC0UWDMO PC0UWDMO ; 
      15 PC0UWDH3 PC0UWDH3 ; 
      15 FY1FCTYC FY1FCTYC ; 
    10 PC0UWSLT PC0UWSLT ; 
      15 PC0UWSID PC0UWSID ; 
      15 PC0UWSDN PC0UWSDN ; 
    10 PC6OETS PC6OETS ; 
    10 PC6PETS PC6PETS ; 
    10 PC6RTADT PC6RTADT ; 
    10 PC0UWFDT PC0UWFDT ; 
      15 PC0UWFCT PC0UWFCT ; 
      15 PC0UWYMD PC0UWYMD ; 
        20 PC0UWFYY PC0UWFYY ; 
        20 PC0UWFMM PC0UWFMM ; 
        20 PC0UWFDD PC0UWFDD ; 
    10 PC0UWMDT PC0UWMDT ; 
      15 PC0UWMMD PC0UWMMD ; 
        20 PC0UWMMM PC0UWMMM ; 
        20 PC0UWMDD PC0UWMDD ; 
      15 PC0UWMYY PC0UWMYY ; 
    10 PC0UWEDT PC0UWEDT ; 
      15 PC0UWEDM PC0UWEDM ; 
      15 PC0UWEDD PC0UWEDD ; 
      15 PC0UWEDY PC0UWEDY ; 
    10 TSIETALO TSIETALO ; 
    10 TA1TBLKE TA1TBLKE ; 
      15 PC0UWKA1 PC0UWKA1 ; 
      15 PC0UWKA2 PC0UWKA2 ; 
      15 PC0UWKA3 PC0UWKA3 ; 
      15 PC0UWKA4 PC0UWKA4 ; 
    10 PC0UWIXM PC0UWIXM ; 
    10 PC0UWDIX PC0UWDIX ; 
    10 PC0UWIX1 PC0UWIX1 ; 
    10 PC0UWIX2 PC0UWIX2 ; 
    10 PC0UWIX3 PC0UWIX3 ; 
    10 PC0UWIX4 PC0UWIX4 ; 
    10 PC0UWIX5 PC0UWIX5 ; 
    10 PC0UWIX6 PC0UWIX6 ; 
    10 PC0UWIXT PC0UWIXT ; 
    10 PC0UWIXP PC0UWIXP ; 
    10 PC0UWMAX PC0UWMAX ; 
    10 PC0UWDMX PC0UWDMX ; 
    10 PC0UWCSI PC0UWCSI ; 
    10 PC0UWFSI PC0UWFSI ; 
    10 PC0UWLSI PC0UWLSI ; 
    10 PC0UWSPI PC0UWSPI [10] ; 
    10 * char(1) ; 
    10 PC0UWTOR PC0UWTOR ; 
    10 PC0UWTIC PC0UWTIC ; 
    10 PC0UWTIS PC0UWTIS ; 
    10 PC0UWTIZ PC0UWTIZ [40] ; 
    10 PC0UWICZ PC0UWICZ [40] ; 
    10 PC0UWISZ PC0UWISZ [40] ; 
    10 * char(1) ; 
    10 PC0UWTDS PC0UWTDS ; 
    10 PC0UWTCS PC0UWTCS ; 
    10 PC0UWTSS PC0UWTSS ; 
    10 PC0UWIDS PC0UWIDS ; 
    10 PC0UWICS PC0UWICS ; 
    10 PC0UWISS PC0UWISS ; 
    10 PC0UWDSZ PC0UWDSZ [40] ; 
    10 PC0UWCSZ PC0UWCSZ [40] ; 
    10 PC0UWSSZ PC0UWSSZ [40] ; 
    10 PC0UWISD PC0UWISD [40] ; 
    10 PC0UWISC PC0UWISC [40] ; 
    10 PC0UWSS PC0UWSS [40] ; 
    10 * char(1) ; 
    10 PC0UWTDR PC0UWTDR ; 
    10 PC0UWTCR PC0UWTCR ; 
    10 PC0UWTSR PC0UWTSR ; 
    10 PC0UWIDR PC0UWIDR ; 
    10 PC0UWICR PC0UWICR ; 
    10 PC0UWISR PC0UWISR ; 
    10 PC0UWDRZ PC0UWDRZ [40] ; 
    10 PC0UWCRZ PC0UWCRZ [40] ; 
    10 PC0UWSRZ PC0UWSRZ [40] ; 
    10 PC0UWIRD PC0UWIRD [40] ; 
    10 PC0UWIRC PC0UWIRC [40] ; 
    10 PC0UWIRS PC0UWIRS [40] ; 
    10 * char(1) ; 
    10 PC0UWTCT PC0UWTCT ; 
    10 PC0UWDCT PC0UWDCT ; 
    10 PC0UWTCZ PC0UWTCZ [40] ; 
    10 PC0UWDCZ PC0UWDCZ [40] ; 
    10 PTDCTDT PTDCTDT ; 
    10 PC0UWDTB PC0UWDTB ; 
      20 XWHCD XWHCD [20] ; 
      20 PC2CUXID PC2CUXID [20] ; 
      20 PC2INSEG PC2INSEG [20] ; 
      20 XOWCD XOWCD [20] ; 
      20 PC0UWTID PC0UWTID [20] ; 
      20 OP1PARTN OP1PARTN [20] ; 
      20 OP1CUOID OP1CUOID [20] ; 
      20 OP1NORID OP1NORID [20] ; 
    10 * char(1) ; 
    10 PC0UWSQA PC0UWSQA ; 
      15 PC0UWSQ1 PC0UWSQ1 [10] ; 
    10 * char(1) ; 
    10 PC0UWSQB PC0UWSQB ; 
      15 PC0UWSQ2 PC0UWSQ2 [10] ; 
    10 PC0UWSHX PC0UWSHX ; 
    10 PC0UWSHW PC0UWSHW ; 
      15 PC0UWSHA PC0UWSHA [8] ; 
    10 PC0UWNUM PC0UWNUM ; 
      15 PC0UWNFL PC0UWNFL ; 
        20 PC0UWNF0 PC0UWNF0 ; 
        20 PC0UWNF1 PC0UWNF1 ; 
        20 PC0UWNF2 PC0UWNF2 ; 
        20 PC0UWNF3 PC0UWNF3 ; 
      15 PC0UWNDE PC0UWNDE ; 
    10 PC0UWNIN PC0UWNIN ; 
    10 PC0UWNN7 PC0UWNN7 ; 
    10 PC0UWCHW PC0UWCHW ; 
      15 PC0UWCHA PC0UWCHA [7] ; 
    10 PC0UWDNM PC0UWDNM ; 
      15 PC0UWDFL PC0UWDFL ; 
      15 PC0UWDZ1 PC0UWDZ1 ; 
      15 PC0UWDZ2 PC0UWDZ2 ; 
      15 PC0UWDPT PC0UWDPT ; 
      15 PC0UWDEF PC0UWDEF ; 
    10 PC0UWD01 PC0UWD01 [40] ; 
    10 PC0UWD02 PC0UWD02 [40] ; 
    10 PC0UWD03 PC0UWD03 [40] ; 
    10 PC0UWD04 PC0UWD04 [40] ; 
    10 PC0UWD05 PC0UWD05 [40] ; 
    10 PC0UWD06 PC0UWD06 [40] ; 
    10 PC0UWD07 PC0UWD07 [40] ; 
    10 PC0UWD08 PC0UWD08 [40] ; 
    10 PC0UWD09 PC0UWD09 [40] ; 
    10 PC0UWD10 PC0UWD10 [40] ; 
    10 PC0UWD11 PC0UWD11 [40] ; 
    10 PC0UWD12 PC0UWD12 [40] ; 
    10 PC0UWD13 PC0UWD13 [40] ; 
    10 PC0UWD14 PC0UWD14 [40] ; 
    10 PC0UWD15 PC0UWD15 [40] ; 
    10 PC0UWD16 PC0UWD16 [40] ; 
    10 PC0UWD17 PC0UWD17 [40] ; 
    10 PC0UWD18 PC0UWD18 [40] ; 
    10 PC0UWD19 PC0UWD19 [40] ; 
    10 PC0UWD20 PC0UWD20 [40] ; 
    10 PC0UWSTB PC0UWSTB [40] ; 
    10 SY4IDDSC SY4IDDSC [40] ; 
    10 PC0UWPZQ PC0UWPZQ [40] ; 
    10 PC0UWSWA PC0UWSWA ; 
      15 PC0UWAMT PC0UWAMT [40] ; 
    10 TSHSTAT TSHSTAT [8] ; 
    10 TSHNKCN TSHNKCN [8] ; 
    10 PC0UWSHQ PC0UWSHQ [8] ; 
    10 PC0UWWF1 PC0UWWF1 ; 
    10 PC0UWWF2 PC0UWWF2 ; 
    10 PC0UWWF3 PC0UWWF3 ; 
    10 PC0UWWF4 PC0UWWF4 ; 
    10 PC0UWWF5 PC0UWWF5 ; 
    10 PC0UWWT1 PC0UWWT1 ; 
    10 PC0UWWSZ PC0UWWSZ ; 
    10 XXXMSGNO XXXMSGNO ; 
    10 PC0UW-FLG-1 PC0UW-FLG-1 ; 
    10 PC0UW-TRANS-LBL PC0UW-TRANS-LBL ; 
      15 * char(3) ; 
      15 PC0UW-TRANS-HDR PC0UW-TRANS-HDR ; 
    10 PC0UWDTF PC0UWDTF ; 
    10 PC0UWORD PC0UWORD ; 
      15 PC0UWCOR PC0UWCOR ; 
      15 PC0UWDOT PC0UWDOT ; 
      15 PC0UWNOR PC0UWNOR ; 
    10 PC0UWSAP PC0UWSAP ; 
end // end PC0UW00

//*** RECORD=PC0UW01 ****
// PC0rm001 map heading storage record
// ***********************
Record PC0UW01 type basicRecord
  5 PC0UW01G PC0UW01G ; 
    10 PC3PONBR PC3PONBR ; 
    10 PC0UWPID PC0UWPID ; 
    10 XGPCD XGPCD ; 
    10 PO-REG-CD PO-REG-CD ; 
    10 PC0UWFRP PC0UWFRP ; 
    10 PC0UWTOP PC0UWTOP ; 
    10 SY1STNBR SY1STNBR ; 
    10 SY2CLRID SY2CLRID ; 
    10 XQACD XQACD ; 
    10 PC2INSEG PC2INSEG ; 
    10 XPGCD XPGCD ; 
    10 XDMCD XDMCD ; 
    10 XUMCD XUMCD ; 
    10 PC4ORTYP PC4ORTYP ; 
    10 PC4SDESC PC4SDESC ; 
    10 PC0UMEDT PC0UMEDT ; 
    10 PC3BLPO PC3BLPO ; 
    10 PC0UWETO PC0UWETO ; 
    10 * char(1) ; 
end // end PC0UW01

//*** RECORD=PC0UW02 ****
// PC0um001 map plan data and sizes record
//   This record is used for defining the plan item data
//   Record key is  2
// ***********************
Record PC0UW02 type basicRecord
  5 PC0UW02G PC0UW02G ; 
    10 PC6ITMNB PC6ITMNB ; 
    10 * int ; 
    10 * smallint ; 
    10 PC0UW02K PC0UW02K ; 
    10 PC0UW02D PC0UW02D ; 
      15 SY2CLRID SY2CLRID ; 
      15 * char(1) ; 
      15 XQACD XQACD ; 
      15 * char(1) ; 
      15 XOWCD XOWCD ; 
      15 * char(1) ; 
      15 PC2INSEG PC2INSEG ; 
      15 * char(1) ; 
      15 XPGCD XPGCD ; 
      15 * char(1) ; 
      15 XWHCD XWHCD ; 
      15 * char(1) ; 
      15 PC2CUXID PC2CUXID ; 
      15 * char(1) ; 
      15 PC6STAT PC6STAT ; 
      15 * char(1) ; 
      15 PC0UWUPD PC0UWUPD ; 
      15 * char(1) ; 
      15 PC0UWPLN PC0UWPLN ; 
      15 * char(1) ; 
      15 YMTCD YMTCD ; 
      15 * char(1) ; 
      15 PC0UWOTS PC0UWOTS ; 
      15 * char(1) ; 
      15 PC0UWETS PC0UWETS ; 
      15 * char(1) ; 
      15 PC0UWTAL PC0UWTAL ; 
      15 * char(1) ; 
      15 PC0UWTAO PC0UWTAO ; 
      15 * char(1) ; 
    10 PC0UWQTY PC0UWQTY ; 
    10 PC0UWSC2 PC0UWSC2 ; 
      15 PC0UW2CL PC0UW2CL ; 
      15 * char(1) ; 
      15 PC0UW2QA PC0UW2QA ; 
      15 * char(1) ; 
      15 PC0UW2OW PC0UW2OW ; 
      15 * char(1) ; 
      15 PC0UW2SP PC0UW2SP ; 
      15 * char(1) ; 
      15 PC0UW2PK PC0UW2PK ; 
      15 * char(1) ; 
      15 PC0UW2ST PC0UW2ST ; 
      15 * char(1) ; 
      15 PC0UW2PL PC0UW2PL ; 
      15 * char(1) ; 
      15 PC0UW2MT PC0UW2MT ; 
      15 * char(1) ; 
      15 PC0UW2ET PC0UW2ET ; 
      15 * char(1) ; 
      15 PC0UW2EA PC0UW2EA ; 
    10 PC0UW02Z PC0UW02Z ; 
      15 PC0UWORQ PC0UWORQ [40] ; 
end // end PC0UW02

//*** RECORD=PC0UW03 ****
// PC0um001 map intransit data and sizes record
//   This record is used to define the intransit data
//   Record key is 3
// ***********************
Record PC0UW03 type basicRecord
  5 PC0UW03G PC0UW03G ; 
    10 * smallint ; 
    10 TSFSHPID TSFSHPID ; 
    10 TSIPLNBR TSIPLNBR ; 
    10 PC0UW03K PC0UW03K ; 
    10 PC0UW03D PC0UW03D ; 
      15 * char(2) ; 
      15 PC0UW03I PC0UW03I ; 
      15 PC0UW03L PC0UW03L ; 
      15 * char(2) ; 
      15 XWHCD XWHCD ; 
      15 * char(1) ; 
      15 PC2CUXID PC2CUXID ; 
      15 * char(1) ; 
      15 TSISTAT TSISTAT ; 
      15 PC0UW-SLASH PC0UW-SLASH ; 
      15 YSTCD YSTCD ; 
      15 * char(1) ; 
      15 PC0UWSTD PC0UWSTD ; 
      15 * char(1) ; 
      15 TSACARCD TSACARCD ; 
      15 * char(1) ; 
      15 TS5CRAFT TS5CRAFT ; 
      15 * char(3) ; 
      15 PC0UWETS PC0UWETS ; 
      15 * char(1) ; 
      15 PC0UWTAL PC0UWTAL ; 
      15 * char(1) ; 
      15 PC0UWTAO PC0UWTAO ; 
      15 * char(1) ; 
    10 PC0UWQTY PC0UWQTY ; 
    10 PC0UWSC2 PC0UWSC2 ; 
      15 PC0UWIRT PC0UWIRT ; 
      15 PC0UWIWL PC0UWIWL ; 
      15 PC0UWWHS PC0UWWHS ; 
      15 * char(1) ; 
      15 PC0UWSHN PC0UWSHN ; 
      15 * char(3) ; 
      15 PC0UW2TS PC0UW2TS ; 
      15 * char(1) ; 
      15 PC0UW2TA PC0UW2TA ; 
      15 * char(3) ; 
    10 PC0UW03Z PC0UW03Z ; 
      15 PC0UWORQ PC0UWORQ [40] ; 
end // end PC0UW03

//*** RECORD=PC0UW04 ****
// PC0um001 map receiving data and size record
//   This record is used to define the receiving data
//   Record key is 4
// ***********************
Record PC0UW04 type basicRecord
  5 PC0UW04G PC0UW04G ; 
    10 * smallint ; 
    10 * int ; 
    10 * smallint ; 
    10 PC0UW04K PC0UW04K ; 
    10 PC0UW04D PC0UW04D ; 
      15 * char(4) ; 
      15 PC0UW04I PC0UW04I ; 
      15 PC0UW04L PC0UW04L ; 
      15 * char(2) ; 
      15 XWHCD XWHCD ; 
      15 * char(1) ; 
      15 PC2CUXID PC2CUXID ; 
      15 * char(1) ; 
      15 YRSCD YRSCD ; 
      15 * char(1) ; 
      15 PC0UWRNO PC0UWRNO ; 
      15 * char(2) ; 
      15 YMTCD YMTCD ; 
      15 * char(15) ; 
      15 PC0UWTAL PC0UWTAL ; 
      15 * char(8) ; 
    10 PC0UWQTY PC0UWQTY ; 
    10 PC0UWSC2 PC0UWSC2 ; 
      15 PC0UWIRL PC0UWIRL ; 
      15 PC0UWRCL PC0UWRCL ; 
      15 * char(1) ; 
      15 PC0UWRCN PC0UWRCN ; 
      15 * char(8) ; 
      15 PC0UW2TA PC0UW2TA ; 
      15 * char(3) ; 
    10 PC0UW04Z PC0UW04Z ; 
      15 PC0UWORQ PC0UWORQ [40] ; 
end // end PC0UW04

//*** RECORD=PC0UW05 ****
// PC0um001 map total plan data and size record
//   This record is used to define the item plan total
//   Record key is 5
// ***********************
Record PC0UW05 type basicRecord
  5 PC0UW05G PC0UW05G ; 
    10 * smallint ; 
    10 * int ; 
    10 * smallint ; 
    10 PC0UW05K PC0UW05K ; 
    10 PC0UW05D PC0UW05D ; 
      15 * char(30) ; 
      15 PC0UW05L PC0UW05L ; 
      15 * char(22) ; 
    10 PC0UWQTY PC0UWQTY ; 
    10 PC0UWSC2 PC0UWSC2 ; 
      15 * char(4) ; 
      15 PC0UWBLT PC0UWBLT ; 
      15 * char(14) ; 
    10 PC0UW05Z PC0UW05Z ; 
      15 PC0UWORQ PC0UWORQ [40] ; 
end // end PC0UW05

//*** RECORD=PC0UW06 ****
// PC0um001 map destination balance to ship and size record
//   This record is used to define the destination bal to ship
//   Record key is 6
// ***********************
Record PC0UW06 type basicRecord
  5 PC0UW06G PC0UW06G ; 
    10 * smallint ; 
    10 * int ; 
    10 * smallint ; 
    10 PC0UW06K PC0UW06K ; 
    10 PC0UW06D PC0UW06D ; 
      15 * char(15) ; 
      15 XWHCD XWHCD ; 
      15 * char(3) ; 
      15 PC2CUXID PC2CUXID ; 
      15 * char(5) ; 
      15 PC0UW06L PC0UW06L ; 
      15 * char(22) ; 
    10 PC0UWQTY PC0UWQTY ; 
    10 PC0UWSC2 PC0UWSC2 ; 
      15 * char(4) ; 
      15 PC0UWSTL PC0UWSTL ; 
      15 * char(8) ; 
    10 PC0UW06Z PC0UW06Z ; 
      15 PC0UWORQ PC0UWORQ [40] ; 
end // end PC0UW06

//*** RECORD=PC0UW07 ****
// PC0um001 map destination irregular percent record
//   This record is used to define the dest irregular % data
//   Record key is 8
// ***********************
Record PC0UW07 type basicRecord
  5 PC0UW07G PC0UW07G ; 
    10 * smallint ; 
    10 * int ; 
    10 * smallint ; 
    10 PC0UW07K PC0UW07K ; 
    10 PC0UW07D PC0UW07D ; 
      15 * char(15) ; 
      15 XWHCD XWHCD ; 
      15 * char(3) ; 
      15 PC2CUXID PC2CUXID ; 
      15 * char(5) ; 
      15 PC0UWLIT PC0UWLIT ; 
      15 * char(20) ; 
    10 PC0UWQTY PC0UWQTY ; 
    10 PC0UWSC2 PC0UWSC2 ; 
      15 * char(4) ; 
      15 PC0UWIPL PC0UWIPL ; 
      15 * char(15) ; 
    10 PC0UW07Z PC0UW07Z ; 
      15 PC0UWORQ PC0UWORQ [40] ; 
end // end PC0UW07

//*** RECORD=PC0UW08 ****
// PC0um001 map color balance to ship record
//   This record is used to define the color balance to ship
//   Record key is 8
// ***********************
Record PC0UW08 type basicRecord
  5 PC0UW08G PC0UW08G ; 
    10 * smallint ; 
    10 * int ; 
    10 * smallint ; 
    10 PC0UW08K PC0UW08K ; 
    10 PC0UW08D PC0UW08D ; 
      15 * char(1) ; 
      15 SY2CLRID SY2CLRID ; 
      15 * char(1) ; 
      15 PC0UW08T PC0UW08T ; 
      15 * char(16) ; 
      15 PC0UWLIT PC0UWLIT ; 
      15 * char(20) ; 
    10 PC0UWQTY PC0UWQTY ; 
    10 PC0UWSC2 PC0UWSC2 ; 
      15 PC0UWS2C PC0UWS2C ; 
      15 * char(1) ; 
      15 PC0UWSTL PC0UWSTL ; 
      15 * char(8) ; 
    10 PC0UW08Z PC0UW08Z ; 
      15 PC0UWORQ PC0UWORQ [40] ; 
end // end PC0UW08

//*** RECORD=PC0UW09 ****
// PC0um001 map color irregular percent record
//   This record is used to define the color irregular % data
//   Record key is 9
// ***********************
Record PC0UW09 type basicRecord
  5 PC0UW09G PC0UW09G ; 
    10 * smallint ; 
    10 * int ; 
    10 * smallint ; 
    10 PC0UW09K PC0UW09K ; 
    10 PC0UW09D PC0UW09D ; 
      15 * char(1) ; 
      15 SY2CLRID SY2CLRID ; 
      15 * char(1) ; 
      15 PC0UW09T PC0UW09T ; 
      15 * char(16) ; 
      15 PC0UWLIT PC0UWLIT ; 
      15 * char(20) ; 
    10 PC0UWQTY PC0UWQTY ; 
    10 PC0UWSC2 PC0UWSC2 ; 
      15 PC0UWS2C PC0UWS2C ; 
      15 * char(1) ; 
      15 PC0UWIPL PC0UWIPL ; 
      15 * char(15) ; 
    10 PC0UW09Z PC0UW09Z ; 
      15 PC0UWORQ PC0UWORQ [40] ; 
end // end PC0UW09

//*** RECORD=PC0UW10 ****
// PC0um001 map style balance to ship record
//   This record is used to define the style balance to ship
//   Record key is 10
// ***********************
Record PC0UW10 type basicRecord
  5 PC0UW10G PC0UW10G ; 
    10 * smallint ; 
    10 * int ; 
    10 * smallint ; 
    10 PC0UW10K PC0UW10K ; 
    10 PC0UW10D PC0UW10D ; 
      15 * char(5) ; 
      15 PC0UW10T PC0UW10T ; 
      15 * char(16) ; 
      15 PC0UWLIT PC0UWLIT ; 
      15 * char(20) ; 
    10 PC0UWQTY PC0UWQTY ; 
    10 PC0UWSC2 PC0UWSC2 ; 
      15 PC0UWSTL PC0UWSTL ; 
      15 * char(12) ; 
    10 PC0UW10Z PC0UW10Z ; 
      15 PC0UWORQ PC0UWORQ [40] ; 
end // end PC0UW10

//*** RECORD=PC0UW11 ****
// PC0um001 map style irregular percent record
//   This record is used to define the style irregular % data
//   Record key is 11
// ***********************
Record PC0UW11 type basicRecord
  5 PC0UW11G PC0UW11G ; 
    10 * smallint ; 
    10 * int ; 
    10 * smallint ; 
    10 PC0UW11K PC0UW11K ; 
    10 PC0UW11D PC0UW11D ; 
      15 * char(5) ; 
      15 PC0UW11T PC0UW11T ; 
      15 * char(16) ; 
      15 PC0UWLIT PC0UWLIT ; 
      15 * char(20) ; 
    10 PC0UWQTY PC0UWQTY ; 
    10 PC0UWSC2 PC0UWSC2 ; 
      15 PC0UWTIR PC0UWTIR ; 
      15 * char(15) ; 
    10 PC0UW11Z PC0UW11Z ; 
      15 PC0UWORQ PC0UWORQ [40] ; 
end // end PC0UW11

//*** RECORD=PC0UW12 ****
// temporary storage record
// ***********************
Record PC0UW12 type basicRecord
  5 PC0UW12G PC0UW12G ; 
    10 PC0UWTSL PC0UWTSL ; 
    10 PC0UW12R PC0UW12R [14] ; 
      15 PC6ITMNB PC6ITMNB ; 
      15 TSFSHPID TSFSHPID ; 
      15 TSIPLNBR TSIPLNBR ; 
      15 PC0UW12K PC0UW12K ; 
      15 PC0UW12D PC0UW12D ; 
      15 PC0UWQTY PC0UWQTY ; 
      15 PC0UWSC2 PC0UWSC2 ; 
      15 PC0UW12Z PC0UW12Z ; 
end // end PC0UW12

//*** RECORD=PC0UW13 ****
// PC0rm001 map heading storage record
// ***********************
Record PC0UW13 type basicRecord
  5 PC0UWUSR PC0UWUSR ; 
    10 CAFROMAP CAFROMAP ; 
    10 PC0UWTSP PC0UWTSP ; 
    10 XGPCD XGPCD ; 
    10 PO-REG-CD PO-REG-CD ; 
    10 PC3PONBR PC3PONBR ; 
    10 YSMXDV YSMXDV ; 
    10 SY1STNBR SY1STNBR ; 
    10 SY2CLRID SY2CLRID ; 
    10 XDMCD XDMCD ; 
    10 XQACD XQACD ; 
    10 XOWCD XOWCD ; 
    10 PC2INSEG PC2INSEG ; 
    10 XPGCD XPGCD ; 
    10 XUMCD XUMCD ; 
    10 * char(1) ; 
end // end PC0UW13

//*** RECORD=PC0UW14 ****
// PC0um001 map WIP data and sizes record
//   This record is used for defining the WIP data
//   Record key is  14
// ***********************
Record PC0UW14 type basicRecord
  5 PC0UW14G PC0UW14G ; 
    10 * smallint ; 
    10 * int ; 
    10 * smallint ; 
    10 PC0UW14K PC0UW14K ; 
    10 PC0UW14D PC0UW14D ; 
      15 * char(35) ; 
      15 PC0UWCTL PC0UWCTL ; 
      15 PC0UWCDT PC0UWCDT ; 
      15 * char(16) ; 
    10 PC0UWQTY PC0UWQTY ; 
    10 PC0UWSC2 PC0UWSC2 ; 
      15 * char(4) ; 
      15 PC0UW2LT PC0UW2LT ; 
      15 * char(9) ; 
      15 PC0UW2CD PC0UW2CD ; 
      15 * char(8) ; 
    10 PC0UW14Z PC0UW14Z ; 
      15 PC0UWORQ PC0UWORQ [40] ; 
end // end PC0UW14

//*** RECORD=PC0UW15 ****
// PC0um001 map  balance to cut and size record
//   This record is used to define the balance to cut data
//   Record key is 15
// ***********************
Record PC0UW15 type basicRecord
  5 PC0UW15G PC0UW15G ; 
    10 * smallint ; 
    10 * int ; 
    10 * smallint ; 
    10 PC0UW15K PC0UW15K ; 
    10 PC0UW15D PC0UW15D ; 
      15 * char(30) ; 
      15 PC0UW15L PC0UW15L ; 
      15 * char(22) ; 
    10 PC0UWQTY PC0UWQTY ; 
    10 PC0UWSC2 PC0UWSC2 ; 
      15 * char(4) ; 
      15 PC0UWBCL PC0UWBCL ; 
      15 * char(8) ; 
    10 PC0UW15Z PC0UW15Z ; 
      15 PC0UWORQ PC0UWORQ [40] ; 
end // end PC0UW15

//*** RECORD=PC0UW16 ****
// created 5/7/91 to store item's style info for pc0u113
// ***********************
Record PC0UW16 type basicRecord
  10 SY1STNBR SY1STNBR ; 
  10 SY2CLRID SY2CLRID ; 
  10 XDMCD XDMCD ; 
  10 XQACD XQACD ; 
  10 XOWCD XOWCD ; 
  10 XPGCD XPGCD ; 
  10 XUMCD XUMCD ; 
  10 * char(3) ; 
end // end PC0UW16

//*** RECORD=PC0UW17 ****
// PC0um001 map receiving data and size record
//   This record is used to define the receiving data
//   that does not match any existing PO Items
//   Record key is 17
// ***********************
Record PC0UW17 type basicRecord
  5 PC0UW17G PC0UW17G ; 
    10 * smallint ; 
    10 * int ; 
    10 * smallint ; 
    10 PC0UW17K PC0UW17K ; 
    10 PC0UW17D PC0UW17D ; 
      15 SY2CLRID SY2CLRID ; 
      15 * char(1) ; 
      15 XQACD XQACD ; 
      15 * char(1) ; 
      15 XOWCD XOWCD ; 
      15 PC0UW17I PC0UW17I ; 
      15 PC0UW17L PC0UW17L ; 
      15 XWHCD XWHCD ; 
      15 * char(1) ; 
      15 PC2CUXID PC2CUXID ; 
      15 * char(1) ; 
      15 YRSCD YRSCD ; 
      15 * char(1) ; 
      15 PC0UWRNO PC0UWRNO ; 
      15 * char(2) ; 
      15 YMTCD YMTCD ; 
      15 * char(15) ; 
      15 PC0UWTAL PC0UWTAL ; 
      15 * char(8) ; 
    10 PC0UWQTY PC0UWQTY ; 
    10 PC0UWSC2 PC0UWSC2 ; 
      15 PC0UW2CR PC0UW2CR ; 
      15 PC0UWIRL PC0UWIRL ; 
      15 PC0UW2RC PC0UW2RC ; 
      15 * char(1) ; 
      15 PC0UWRCN PC0UWRCN ; 
      15 * char(8) ; 
      15 PC0UW2TA PC0UW2TA ; 
      15 * char(3) ; 
    10 PC0UW17Z PC0UW17Z ; 
      15 PC0UWORQ PC0UWORQ [40] ; 
end // end PC0UW17

//*** RECORD=PC0UW18 ****
// PC0um001 map intransit data and sizes record
//   This record is used to define the intransit data
//   that does not have a matching po item.
//   Record key is 18
// ***********************
Record PC0UW18 type basicRecord
  5 PC0UW18G PC0UW18G ; 
    10 * smallint ; 
    10 TSFSHPID TSFSHPID ; 
    10 TSIPLNBR TSIPLNBR ; 
    10 PC0UW18K PC0UW18K ; 
    10 PC0UW18D PC0UW18D ; 
      15 SY2CLRID SY2CLRID ; 
      15 * char(1) ; 
      15 XQACD XQACD ; 
      15 * char(1) ; 
      15 XOWCD XOWCD ; 
      15 PC0UW18I PC0UW18I ; 
      15 PC0UW18L PC0UW18L ; 
      15 XWHCD XWHCD ; 
      15 * char(1) ; 
      15 PC2CUXID PC2CUXID ; 
      15 * char(1) ; 
      15 TSISTAT TSISTAT ; 
      15 PC0UW-SLASH PC0UW-SLASH ; 
      15 YSTCD YSTCD ; 
      15 * char(1) ; 
      15 PC0UWSTD PC0UWSTD ; 
      15 * char(1) ; 
      15 TSACARCD TSACARCD ; 
      15 * char(1) ; 
      15 TS5CRAFT TS5CRAFT ; 
      15 * char(3) ; 
      15 PC0UWETS PC0UWETS ; 
      15 * char(1) ; 
      15 PC0UWTAL PC0UWTAL ; 
      15 * char(1) ; 
      15 PC0UWTAO PC0UWTAO ; 
      15 * char(1) ; 
    10 PC0UWQTY PC0UWQTY ; 
    10 PC0UWSC2 PC0UWSC2 ; 
      15 PC0UW-SC2-CLR PC0UW-SC2-CLR ; 
      15 PC0UWIRT PC0UWIRT ; 
      15 PC0UW-WS-RLBL PC0UW-WS-RLBL ; 
      15 * char(1) ; 
      15 PC0UWSHN PC0UWSHN ; 
      15 * char(3) ; 
      15 PC0UW2TS PC0UW2TS ; 
      15 * char(1) ; 
      15 PC0UW2TA PC0UW2TA ; 
      15 * char(3) ; 
    10 PC0UW18Z PC0UW18Z ; 
      15 PC0UWORQ PC0UWORQ [40] ; 
end // end PC0UW18

//*** RECORD=PC0UW19 ****
// PC0um001 map UNMATCHED TRANS REC HEADER
//   Record key is 19
// ***********************
Record PC0UW19 type basicRecord
  5 PC0UW19G PC0UW19G ; 
    10 * smallint ; 
    10 * int ; 
    10 * smallint ; 
    10 PC0UW19K PC0UW19K ; 
    10 PC0UW19D PC0UW19D ; 
      15 PC0UW-LABEL PC0UW-LABEL ; 
      15 * char(35) ; 
    10 * num(10) ; 
end // end PC0UW19

//*** RECORD=PC0UW20 ****
// ************* PRODUCTION ORDER MAP RECORD ******************
// **               JCL W.S. Pass record                     **
// **                   (DD * cards)                         **
// 
//    RECORD NAME:      PC0RW20
// 
//    COPYLIB    :      WPC400D (used by Batch programs)
// 
//       This record is a working storage record to save and
//    and load an array of data used for JCL submisson.
//       It holds information that the user has selected
//    by pressing PF20  and is load to the TA6REC enabling
//    the JOB SUBMITTER SUBROUTINE (XPTAOP) to submit the job
//    appropriatly.  The COPYLIB member is the ++include that
//    the batch programs use in there processing of the data
//    passed.
// 
//      It consists of the following:
//            Record Key     --> Type of Data
//            Record Seqence --> Partitioned Data (part 1 etc.)
//            Record Data    --> Actual P.O. Data.
// 
// **                                                        **
// **                                                        **
// ************* PRODUCTION ORDER MAP RECORD ******************
// ***********************
Record PC0UW20 type basicRecord
  5 PC0UWR20 PC0UWR20 [100] ; 
    10 PC0UWKEY PC0UWKEY ; 
    10 PC0UWSEQ PC0UWSEQ ; 
    10 PC0UWPAR PC0UWPAR ; 
end // end PC0UW20

//*** RECORD=PC0UW21 ****
// PC0RM001 map heading storage record, Reformatted for TAOP
//    and the batch application PC400D.
//    Note:
//           This record matched the include:
// 
//            COPYLIB:   WPC4001
// 
// 
// ***********************
Record PC0UW21 type basicRecord
  5 PC0UW21G PC0UW21G ; 
    10 PC0UW211 PC0UW211 ; 
      15 XX0XWTIM XX0XWTIM ; 
      15 PC0UWNBR PC0UWNBR ; 
      15 PC0UWPID PC0UWPID ; 
      15 XGPCD XGPCD ; 
      15 SY1STNBR SY1STNBR ; 
      15 SY2CLRID SY2CLRID ; 
      15 XQACD XQACD ; 
      15 PC2INSEG PC2INSEG ; 
      15 XPGCD XPGCD ; 
      15 XDMCD XDMCD ; 
      15 PC4ORTYP PC4ORTYP ; 
      15 PC0UMEDT PC0UMEDT ; 
      15 PC0UWBLK PC0UWBLK ; 
      15 * char(17) ; 
    10 PC0UW001 PC0UW001 ; 
      15 PC0UWSZ1 PC0UWSZ1 ; 
        20 PC0UWSD1 PC0UWSD1 [10] ; 
      15 * char(17) ; 
    10 PC0UW002 PC0UW002 ; 
      15 PC0UWSZ2 PC0UWSZ2 ; 
        20 PC0UWSD2 PC0UWSD2 [10] ; 
      15 * char(17) ; 
    10 PC0UW003 PC0UW003 ; 
      15 PC0UWSZ3 PC0UWSZ3 ; 
        20 PC0UWSD3 PC0UWSD3 [10] ; 
      15 * char(17) ; 
    10 PC0UW004 PC0UW004 ; 
      15 PC0UWSZ4 PC0UWSZ4 ; 
        20 PC0UWSD4 PC0UWSD4 [10] ; 
      15 * char(17) ; 
    10 PC0UWQL1 PC0UWQL1 ; 
      15 PC0UWQA1 PC0UWQA1 ; 
        20 PC0UWSQ1 PC0UWSQ1 [10] ; 
      15 PC0UWQTY PC0UWQTY ; 
      15 * char(7) ; 
end // end PC0UW21

//*** RECORD=PC0UW22 ****
// PC0um001 map plan data and sizes record.
//   This record is used for defining the plan item data
//   with s.o. on it. Record key is  22
// ***********************
Record PC0UW22 type basicRecord
  5 PC0UW02G PC0UW02G ; 
    10 PC6ITMNB PC6ITMNB ; 
    10 * int ; 
    10 * smallint ; 
    10 PC0UW02K PC0UW02K ; 
    10 PC0UW02D PC0UW02D ; 
      15 SY2CLRID SY2CLRID ; 
      15 * char(1) ; 
      15 XQACD XQACD ; 
      15 * char(1) ; 
      15 XOWCD XOWCD ; 
      15 * char(1) ; 
      15 PC2INSEG PC2INSEG ; 
      15 * char(1) ; 
      15 XPGCD XPGCD ; 
      15 * char(1) ; 
      15 XWHCD XWHCD ; 
      15 * char(1) ; 
      15 PC2CUXID PC2CUXID ; 
      15 * char(1) ; 
      15 PC6STAT PC6STAT ; 
      15 * char(1) ; 
      15 PC0UWUPD PC0UWUPD ; 
      15 * char(1) ; 
      15 PC0UWPLN PC0UWPLN ; 
      15 * char(1) ; 
      15 YMTCD YMTCD ; 
      15 * char(1) ; 
      15 PC0UWOTS PC0UWOTS ; 
      15 * char(1) ; 
      15 PC0UWETS PC0UWETS ; 
      15 * char(3) ; 
      15 PC0UWSNN PC0UWSNN ; 
        20 PC0UWCID PC0UWCID ; 
        20 PC0UWDOT PC0UWDOT ; 
        20 PC0UWNID PC0UWNID ; 
      15 * char(1) ; 
    10 PC0UWQTY PC0UWQTY ; 
    10 PC0UWSC2 PC0UWSC2 ; 
      15 PC0UW2CL PC0UW2CL ; 
      15 * char(1) ; 
      15 PC0UW2QA PC0UW2QA ; 
      15 * char(1) ; 
      15 PC0UW2OW PC0UW2OW ; 
      15 * char(1) ; 
      15 PC0UW2SP PC0UW2SP ; 
      15 * char(1) ; 
      15 PC0UW2PK PC0UW2PK ; 
      15 * char(1) ; 
      15 PC0UW2ST PC0UW2ST ; 
      15 * char(1) ; 
      15 PC0UW2PL PC0UW2PL ; 
      15 * char(1) ; 
      15 PC0UW2MT PC0UW2MT ; 
      15 * char(1) ; 
      15 PC0UW2ET PC0UW2ET ; 
      15 * char(1) ; 
      15 PC0UW2EA PC0UW2EA ; 
    10 PC0UW02Z PC0UW02Z ; 
      15 PC0UWORQ PC0UWORQ [40] ; 
end // end PC0UW22

//*** RECORD=PC0UW23 ****
// PC0um001 map intransit data and sizes record
//   This record is used to define the intransit data
//   with the s.o. data on the map
//   Record key is 23
// ***********************
Record PC0UW23 type basicRecord
  5 PC0UW03G PC0UW03G ; 
    10 * smallint ; 
    10 TSFSHPID TSFSHPID ; 
    10 TSIPLNBR TSIPLNBR ; 
    10 PC0UW03K PC0UW03K ; 
    10 PC0UW03D PC0UW03D ; 
      15 * char(2) ; 
      15 PC0UW03I PC0UW03I ; 
      15 PC0UW03L PC0UW03L ; 
      15 * char(2) ; 
      15 XWHCD XWHCD ; 
      15 * char(1) ; 
      15 PC2CUXID PC2CUXID ; 
      15 * char(1) ; 
      15 TSISTAT TSISTAT ; 
      15 PC0UW-SLASH PC0UW-SLASH ; 
      15 YSTCD YSTCD ; 
      15 * char(1) ; 
      15 PC0UWSTD PC0UWSTD ; 
      15 * char(1) ; 
      15 TSACARCD TSACARCD ; 
      15 * char(1) ; 
      15 TS5CRAFT TS5CRAFT ; 
      15 * char(3) ; 
      15 PC0UWETS PC0UWETS ; 
      15 * char(3) ; 
      15 PC0UWSNN PC0UWSNN ; 
        20 PC0UWCID PC0UWCID ; 
        20 PC0UWDOT PC0UWDOT ; 
        20 PC0UWNID PC0UWNID ; 
      15 * char(1) ; 
    10 PC0UWQTY PC0UWQTY ; 
    10 PC0UWSC2 PC0UWSC2 ; 
      15 PC0UWIRT PC0UWIRT ; 
      15 PC0UWIWL PC0UWIWL ; 
      15 PC0UWWHS PC0UWWHS ; 
      15 * char(1) ; 
      15 PC0UWSHN PC0UWSHN ; 
      15 * char(3) ; 
      15 PC0UW2TS PC0UW2TS ; 
      15 * char(1) ; 
      15 PC0UW2TA PC0UW2TA ; 
      15 * char(3) ; 
    10 PC0UW03Z PC0UW03Z ; 
      15 PC0UWORQ PC0UWORQ [40] ; 
end // end PC0UW23

//*** RECORD=PC0UW24 ****
// PC0um001 map receiving data and size record
//   This record is used to define the receiving data
//   with the s.o. on the map.
//   Record key is 24
// ***********************
Record PC0UW24 type basicRecord
  5 PC0UW04G PC0UW04G ; 
    10 * smallint ; 
    10 * int ; 
    10 * smallint ; 
    10 PC0UW04K PC0UW04K ; 
    10 PC0UW04D PC0UW04D ; 
      15 * char(4) ; 
      15 PC0UW04I PC0UW04I ; 
      15 PC0UW04L PC0UW04L ; 
      15 * char(2) ; 
      15 XWHCD XWHCD ; 
      15 * char(1) ; 
      15 PC2CUXID PC2CUXID ; 
      15 * char(1) ; 
      15 YRSCD YRSCD ; 
      15 * char(1) ; 
      15 PC0UWRNO PC0UWRNO ; 
      15 * char(2) ; 
      15 YMTCD YMTCD ; 
      15 * char(17) ; 
      15 PC0UWSNN PC0UWSNN ; 
        20 PC0UWCID PC0UWCID ; 
        20 PC0UWDOT PC0UWDOT ; 
        20 PC0UWNID PC0UWNID ; 
      15 * char(1) ; 
    10 PC0UWQTY PC0UWQTY ; 
    10 PC0UWSC2 PC0UWSC2 ; 
      15 PC0UWIRL PC0UWIRL ; 
      15 PC0UWRCL PC0UWRCL ; 
      15 * char(1) ; 
      15 PC0UWRCN PC0UWRCN ; 
      15 * char(8) ; 
      15 PC0UW2TA PC0UW2TA ; 
      15 * char(3) ; 
    10 PC0UW04Z PC0UW04Z ; 
      15 PC0UWORQ PC0UWORQ [40] ; 
end // end PC0UW24

//*** RECORD=PC0UW25 ****
// PC0um001 map intransit data and sizes record
//   This record is used to define the intransit data
//   that does not have a matching po item.
//   Record key is 25
// ***********************
Record PC0UW25 type basicRecord
  5 PC0UW18G PC0UW18G ; 
    10 * smallint ; 
    10 TSFSHPID TSFSHPID ; 
    10 TSIPLNBR TSIPLNBR ; 
    10 PC0UW18K PC0UW18K ; 
    10 PC0UW18D PC0UW18D ; 
      15 SY2CLRID SY2CLRID ; 
      15 * char(1) ; 
      15 XQACD XQACD ; 
      15 * char(1) ; 
      15 XOWCD XOWCD ; 
      15 PC0UW18I PC0UW18I ; 
      15 PC0UW18L PC0UW18L ; 
      15 XWHCD XWHCD ; 
      15 * char(1) ; 
      15 PC2CUXID PC2CUXID ; 
      15 * char(1) ; 
      15 TSISTAT TSISTAT ; 
      15 PC0UW-SLASH PC0UW-SLASH ; 
      15 YSTCD YSTCD ; 
      15 * char(1) ; 
      15 PC0UWSTD PC0UWSTD ; 
      15 * char(1) ; 
      15 TSACARCD TSACARCD ; 
      15 * char(1) ; 
      15 TS5CRAFT TS5CRAFT ; 
      15 * char(3) ; 
      15 PC0UWETS PC0UWETS ; 
      15 * char(3) ; 
      15 PC0UWSNN PC0UWSNN ; 
        20 PC0UWCID PC0UWCID ; 
        20 PC0UWDOT PC0UWDOT ; 
        20 PC0UWNID PC0UWNID ; 
      15 * char(1) ; 
    10 PC0UWQTY PC0UWQTY ; 
    10 PC0UWSC2 PC0UWSC2 ; 
      15 PC0UW-SC2-CLR PC0UW-SC2-CLR ; 
      15 PC0UWIRT PC0UWIRT ; 
      15 PC0UW-WS-RLBL PC0UW-WS-RLBL ; 
      15 * char(1) ; 
      15 PC0UWSHN PC0UWSHN ; 
      15 * char(3) ; 
      15 PC0UW2TS PC0UW2TS ; 
      15 * char(1) ; 
      15 PC0UW2TA PC0UW2TA ; 
      15 * char(3) ; 
    10 PC0UW18Z PC0UW18Z ; 
      15 PC0UWORQ PC0UWORQ [40] ; 
end // end PC0UW25

//*** RECORD=PC0UW26 ****
// PC0um001 map receiving data and size record
//   This record is used to define the receiving data
//   that does not match any existing PO Items
//   with s.o. data on it.
//   Record key is 26
// ***********************
Record PC0UW26 type basicRecord
  5 PC0UW17G PC0UW17G ; 
    10 * smallint ; 
    10 * int ; 
    10 * smallint ; 
    10 PC0UW17K PC0UW17K ; 
    10 PC0UW17D PC0UW17D ; 
      15 SY2CLRID SY2CLRID ; 
      15 * char(1) ; 
      15 XQACD XQACD ; 
      15 * char(1) ; 
      15 XOWCD XOWCD ; 
      15 PC0UW17I PC0UW17I ; 
      15 PC0UW17L PC0UW17L ; 
      15 XWHCD XWHCD ; 
      15 * char(1) ; 
      15 PC2CUXID PC2CUXID ; 
      15 * char(1) ; 
      15 YRSCD YRSCD ; 
      15 * char(1) ; 
      15 PC0UWRNO PC0UWRNO ; 
      15 * char(2) ; 
      15 YMTCD YMTCD ; 
      15 * char(17) ; 
      15 PC0UWSNN PC0UWSNN ; 
        20 PC0UWCID PC0UWCID ; 
        20 PC0UWDOT PC0UWDOT ; 
        20 PC0UWNID PC0UWNID ; 
      15 * char(1) ; 
    10 PC0UWQTY PC0UWQTY ; 
    10 PC0UWSC2 PC0UWSC2 ; 
      15 PC0UW2CR PC0UW2CR ; 
      15 PC0UWIRL PC0UWIRL ; 
      15 PC0UW2RC PC0UW2RC ; 
      15 * char(1) ; 
      15 PC0UWRCN PC0UWRCN ; 
      15 * char(8) ; 
      15 PC0UW2TA PC0UW2TA ; 
      15 * char(3) ; 
    10 PC0UW17Z PC0UW17Z ; 
      15 PC0UWORQ PC0UWORQ [40] ; 
end // end PC0UW26

//*** RECORD=PC0UW30 ****
// PC0um001 map plan data and sizes record.
//   This record is used for defining the plan item data
//   with SAP number in it.the record key is 30.
// ***********************
Record PC0UW30 type basicRecord
  5 PC0UW02G PC0UW02G ; 
    10 PC6ITMNB PC6ITMNB ; 
    10 * int ; 
    10 * smallint ; 
    10 PC0UW02K PC0UW02K ; 
    10 PC0UW02D PC0UW02D ; 
      15 SY2CLRID SY2CLRID ; 
      15 * char(1) ; 
      15 XQACD XQACD ; 
      15 * char(1) ; 
      15 XOWCD XOWCD ; 
      15 * char(1) ; 
      15 PC2INSEG PC2INSEG ; 
      15 * char(1) ; 
      15 XPGCD XPGCD ; 
      15 * char(1) ; 
      15 XWHCD XWHCD ; 
      15 * char(1) ; 
      15 PC2CUXID PC2CUXID ; 
      15 * char(1) ; 
      15 PC6STAT PC6STAT ; 
      15 * char(1) ; 
      15 PC0UWUPD PC0UWUPD ; 
      15 * char(1) ; 
      15 PC0UWPLN PC0UWPLN ; 
      15 * char(1) ; 
      15 YMTCD YMTCD ; 
      15 * char(1) ; 
      15 PC0UWOTS PC0UWOTS ; 
      15 * char(1) ; 
      15 PC0UWETS PC0UWETS ; 
      15 * char(4) ; 
      15 PC0UWSAP PC0UWSAP ; 
      15 * char(1) ; 
    10 PC0UWQTY PC0UWQTY ; 
    10 PC0UWSC2 PC0UWSC2 ; 
      15 PC0UW2CL PC0UW2CL ; 
      15 * char(1) ; 
      15 PC0UW2QA PC0UW2QA ; 
      15 * char(1) ; 
      15 PC0UW2OW PC0UW2OW ; 
      15 * char(1) ; 
      15 PC0UW2SP PC0UW2SP ; 
      15 * char(1) ; 
      15 PC0UW2PK PC0UW2PK ; 
      15 * char(1) ; 
      15 PC0UW2ST PC0UW2ST ; 
      15 * char(1) ; 
      15 PC0UW2PL PC0UW2PL ; 
      15 * char(1) ; 
      15 PC0UW2MT PC0UW2MT ; 
      15 * char(1) ; 
      15 PC0UW2ET PC0UW2ET ; 
      15 * char(1) ; 
      15 PC0UW2EA PC0UW2EA ; 
    10 PC0UW02Z PC0UW02Z ; 
      15 PC0UWORQ PC0UWORQ [40] ; 
end // end PC0UW30

// PC_PO_CRDT  (map format)
DataItem PC0UMEDT char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// FLAG FIRST TIME REC TYPE
DataItem PC0UW-FLG-1 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// item FOUND flag
DataItem PC0UW-ITM-FND char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem PC0UW-LABEL char(35)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem PC0UW-SC2-CLR char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Slash literal '/'
DataItem PC0UW-SLASH char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem PC0UW-TRANS-HDR char(32)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// HEADING FOR UNMTCH TRANS
DataItem PC0UW-TRANS-LBL char(35)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// warehouse lit
DataItem PC0UW-WS-RLBL char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// PC0UW21 size level (part 1)
DataItem PC0UW001 char(77)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// PC0UW21 size level (part 2)
DataItem PC0UW002 char(77)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// PC0UW21 size level (part 3)
DataItem PC0UW003 char(77)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// PC0UW21 size level (part 4)
DataItem PC0UW004 char(77)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pc0uw01 group level
DataItem PC0UW01G char(82)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// plan data
DataItem PC0UW02D char(70)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pc0uw01 group level
DataItem PC0UW02G char(285)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// record key
DataItem PC0UW02K num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// size data
DataItem PC0UW02Z char(160)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// intransit data
DataItem PC0UW03D char(70)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pc0uw01 group level
DataItem PC0UW03G char(285)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// irregular literal
DataItem PC0UW03I char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// record key
DataItem PC0UW03K num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// intransit literal
DataItem PC0UW03L char(11)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// size data
DataItem PC0UW03Z char(160)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Receiving data
DataItem PC0UW04D char(70)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pc0uw01 group level
DataItem PC0UW04G char(285)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// irregular literal
DataItem PC0UW04I char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// record key
DataItem PC0UW04K num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// receiving literal
DataItem PC0UW04L char(9)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// size data
DataItem PC0UW04Z char(160)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data
DataItem PC0UW05D char(70)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pc0uw01 group level
DataItem PC0UW05G char(285)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// record key
DataItem PC0UW05K num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// total order literal
DataItem PC0UW05L char(18)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// size data
DataItem PC0UW05Z char(160)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data
DataItem PC0UW06D char(70)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pc0uw01 group level
DataItem PC0UW06G char(285)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// record key
DataItem PC0UW06K num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// total balance to ship literal
DataItem PC0UW06L char(18)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// size data
DataItem PC0UW06Z char(160)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data
DataItem PC0UW07D char(70)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pc0uw01 group level
DataItem PC0UW07G char(285)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// record key
DataItem PC0UW07K num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// size data
DataItem PC0UW07Z char(160)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data
DataItem PC0UW08D char(70)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pc0uw01 group level
DataItem PC0UW08G char(285)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// record key
DataItem PC0UW08K num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// total literal
DataItem PC0UW08T char(9)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// size data
DataItem PC0UW08Z char(160)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data
DataItem PC0UW09D char(70)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pc0uw01 group level
DataItem PC0UW09G char(285)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// record key
DataItem PC0UW09K num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// total literal
DataItem PC0UW09T char(9)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// size data
DataItem PC0UW09Z char(160)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data
DataItem PC0UW10D char(70)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pc0uw01 group level
DataItem PC0UW10G char(285)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// record key
DataItem PC0UW10K num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// total literal
DataItem PC0UW10T char(9)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// size data
DataItem PC0UW10Z char(160)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data
DataItem PC0UW11D char(70)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pc0uw01 group level
DataItem PC0UW11G char(285)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// record key
DataItem PC0UW11K num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// total literal
DataItem PC0UW11T char(9)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// size data
DataItem PC0UW11Z char(160)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data
DataItem PC0UW12D char(70)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pc0uw01 group level
DataItem PC0UW12G char(3994)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// record key
DataItem PC0UW12K num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// pc0uw13 record data
DataItem PC0UW12R char(285)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// size data
DataItem PC0UW12Z char(160)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data
DataItem PC0UW14D char(70)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pc0uw01 group level
DataItem PC0UW14G char(285)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// record key
DataItem PC0UW14K num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// size data
DataItem PC0UW14Z char(160)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data
DataItem PC0UW15D char(70)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pc0uw01 group level
DataItem PC0UW15G char(285)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// record key
DataItem PC0UW15K num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// balance to cut literal
DataItem PC0UW15L char(18)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// size data
DataItem PC0UW15Z char(160)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Receiving data
DataItem PC0UW17D char(70)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// PC0UW17 group level
DataItem PC0UW17G char(285)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// irregular literal
DataItem PC0UW17I char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// record key
DataItem PC0UW17K num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// receiving literal
DataItem PC0UW17L char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// size data
DataItem PC0UW17Z char(160)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// intransit data
DataItem PC0UW18D char(70)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pc0uw01 group level
DataItem PC0UW18G char(285)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// irregular literal
DataItem PC0UW18I char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// record key
DataItem PC0UW18K num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// intransit literal
DataItem PC0UW18L char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// size data
DataItem PC0UW18Z char(160)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// intransit data
DataItem PC0UW19D char(70)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pc0uw01 group level
DataItem PC0UW19G char(90)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// record key
DataItem PC0UW19K num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// PC0UW21 header level (part 1)
DataItem PC0UW211 char(77)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// PC0UW21 group level
DataItem PC0UW21G char(462)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// screen two cut date
DataItem PC0UW2CD char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// screen two color
DataItem PC0UW2CL char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// SY_COLR_CD_ID
DataItem PC0UW2CR char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// screen two eta
DataItem PC0UW2EA char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// screen two ets
DataItem PC0UW2ET char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// screen two cut literal
DataItem PC0UW2LT char(10)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// screen two mode of trans
DataItem PC0UW2MT char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// screen two owner group
DataItem PC0UW2OW char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// screen two package type
DataItem PC0UW2PK char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// screen two plan
DataItem PC0UW2PL num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// screen two quality code
DataItem PC0UW2QA char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// receipt literal
DataItem PC0UW2RC char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// screen two spec code
DataItem PC0UW2SP char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// screen two status
DataItem PC0UW2ST char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// screen two etal
DataItem PC0UW2TA char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// screen two ets
DataItem PC0UW2TS char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// map total quantity
DataItem PC0UWAMT bin(9,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// balance to cut literal
DataItem PC0UWBCL char(23)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// PC_BLNK_PO_NBR (map format)
DataItem PC0UWBLK num(9)  {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// balance literal
DataItem PC0UWBLT char(17)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Confirm cancel flag
DataItem PC0UWCCF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// cut date
DataItem PC0UWCDT char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// character work array
DataItem PC0UWCHA char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// character work field
DataItem PC0UWCHW char(7)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Cust order nbr
DataItem PC0UWCID num(8)  {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// calc number of size pages
DataItem PC0UWCNP num(3,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Select field counter
DataItem PC0UWCNT num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Cust order nbr
DataItem PC0UWCOR num(8)  {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// total receive color size array
DataItem PC0UWCRZ int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Current size index
DataItem PC0UWCSI smallint {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Current size page
DataItem PC0UWCSP num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// total shipped color size array
DataItem PC0UWCSZ int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Cut literal
DataItem PC0UWCTL char(13)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// destination 1 planned qty
DataItem PC0UWD01 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// destination 2 planned qty
DataItem PC0UWD02 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// destination 3 planned qty
DataItem PC0UWD03 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// destination 4 planned qty
DataItem PC0UWD04 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// destination 5 planned qty
DataItem PC0UWD05 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// destination 6 planned qty
DataItem PC0UWD06 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// destination 7 planned qty
DataItem PC0UWD07 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// destination 8 planned qty
DataItem PC0UWD08 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// destination 9 planned qty
DataItem PC0UWD09 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// destination 10 planned qty
DataItem PC0UWD10 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// destination 11 planned qty
DataItem PC0UWD11 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// destination 12 planned qty
DataItem PC0UWD12 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// destination 13 planned qty
DataItem PC0UWD13 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// destination 14 planned qty
DataItem PC0UWD14 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// destination 15 planned qty
DataItem PC0UWD15 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// destination 16 planned qty
DataItem PC0UWD16 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// destination 17 planned qty
DataItem PC0UWD17 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// destination 18 planned qty
DataItem PC0UWD18 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// destination 19 planned qty
DataItem PC0UWD19 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// destination 20 planned qty
DataItem PC0UWD20 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Database date century
DataItem PC0UWDCR num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Total date cut quantity
DataItem PC0UWDCT int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// total date sizes array
DataItem PC0UWDCZ int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// database date day
DataItem PC0UWDDA num(2)  {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Database date
DataItem PC0UWDDT num(8)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = nullFill, inputRequired = no
}
end

// decimal number
DataItem PC0UWDEC num(2,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// decimal field
DataItem PC0UWDEF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// blank fill
DataItem PC0UWDFL char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Dash one
DataItem PC0UWDH1 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Dash two
DataItem PC0UWDH2 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Dash three
DataItem PC0UWDH3 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// destination index
DataItem PC0UWDIX smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// P.O. id second month
DataItem PC0UWDMO char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// database date month
DataItem PC0UWDMT num(2)  {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Max destinations
DataItem PC0UWDMX smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// decimal character work field
DataItem PC0UWDNM char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// period literal
DataItem PC0UWDOT char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// decimal point
DataItem PC0UWDPT char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// total receive dest size array
DataItem PC0UWDRZ int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// total shipped dest size array
DataItem PC0UWDSZ int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// destination table
DataItem PC0UWDTB char(460)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Etal/S.O. flag
DataItem PC0UWDTF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// database date year
DataItem PC0UWDYR num(2)  {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// % tens place
DataItem PC0UWDZ1 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// % ones place
DataItem PC0UWDZ2 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// ETALO day
DataItem PC0UWEDD char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// ETALO month
DataItem PC0UWEDM char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// ETALO date
DataItem PC0UWEDT char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// ETALO year
DataItem PC0UWEDY char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// ETA calculated
DataItem PC0UWETA smallint {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Entered ETALO date
DataItem PC0UWETO char(8)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// ets date
DataItem PC0UWETS char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Reformat century
DataItem PC0UWFCT num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Reformat day
DataItem PC0UWFDD num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Reformat date CCYYmmdd
DataItem PC0UWFDT num(8)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Reformat month
DataItem PC0UWFMM num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// from page number
DataItem PC0UWFRP num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// First size index
DataItem PC0UWFSI smallint {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Reformat year
DataItem PC0UWFYY num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// item close flag
DataItem PC0UWICF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// total irregular color received
DataItem PC0UWICR int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// total shipped irregular color
DataItem PC0UWICS int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Count item records
DataItem PC0UWICT num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// total item color size array
DataItem PC0UWICZ int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// total received irreg (dest)
DataItem PC0UWIDR int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// total shipped irregular (dest)
DataItem PC0UWIDS int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// integer number
DataItem PC0UWINT num(1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// irregular percent literal
DataItem PC0UWIPL char(16)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// total receive irreg color arra
DataItem PC0UWIRC int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// total receive irreg dest array
DataItem PC0UWIRD int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Irregular rec'd flag
DataItem PC0UWIRF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// irregular literal
DataItem PC0UWIRL char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// total receive irreg style arra
DataItem PC0UWIRS int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// irregular literal
DataItem PC0UWIRT char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// total shipped irreg color arra
DataItem PC0UWISC int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// total shipped irreg dest array
DataItem PC0UWISD int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Irregular shipped flag
DataItem PC0UWISF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// total received irreg style
DataItem PC0UWISR int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// total shipped irregular style
DataItem PC0UWISS int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// total items style size array
DataItem PC0UWISZ int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// warehouse lit
DataItem PC0UWIWL char(7)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// General index 1
DataItem PC0UWIX1 smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// General index 2
DataItem PC0UWIX2 smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// General index 3
DataItem PC0UWIX3 smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// General index 4
DataItem PC0UWIX4 smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// General index 5
DataItem PC0UWIX5 smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// General index 6 (TAOP usage)
DataItem PC0UWIX6 smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Map index
DataItem PC0UWIXM smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Passed data index
DataItem PC0UWIXP smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Temporary storage index
DataItem PC0UWIXT smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// 1st field of key char
DataItem PC0UWKA1 char(10)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// 2nd field of key char
DataItem PC0UWKA2 char(10)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// 3rd field of key char
DataItem PC0UWKA3 char(10)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// 4th field of key char
DataItem PC0UWKA4 char(10)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Record Key
DataItem PC0UWKEY char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// map literal
DataItem PC0UWLIT char(20)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Last size index
DataItem PC0UWLSI smallint {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Max lines per map
DataItem PC0UWMAX smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// map day
DataItem PC0UWMDD num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Map date
DataItem PC0UWMDT num(6)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// map month day
DataItem PC0UWMMD char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Map month
DataItem PC0UWMMM num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Max lines for DD* card allowed
DataItem PC0UWMXJ smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// map year
DataItem PC0UWMYY num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// PC_PO_NBR
DataItem PC0UWNBR num(6)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// decimal field
DataItem PC0UWNDE num(1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Negative flag
DataItem PC0UWNEF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem PC0UWNF0 num(3)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

DataItem PC0UWNF1 num(1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// % tens place
DataItem PC0UWNF2 num(1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// % ones place
DataItem PC0UWNF3 num(1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

DataItem PC0UWNFL num(6)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Nike order nbr
DataItem PC0UWNID num(2)  {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// numeric integer field
DataItem PC0UWNIN num(7)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// numeric integer field
DataItem PC0UWNN7 num(7)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Nike order nbr
DataItem PC0UWNOR num(2)  {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// numeric work field
DataItem PC0UWNUM num(7,1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Obtain data flag
DataItem PC0UWODF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Sales/Nike order number
DataItem PC0UWORD char(11)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// size quantity
DataItem PC0UWORQ bin(9,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Obtain size data flag
DataItem PC0UWOSD char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// oets date
DataItem PC0UWOTS char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// save Current T.S. page
DataItem PC0UWPAG num(4)  {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Record Parameter data
DataItem PC0UWPAR char(77)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Protect date flag
DataItem PC0UWPDF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Map PO ID
DataItem PC0UWPID char(13)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem PC0UWPLN num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// P.O. Id first month
DataItem PC0UWPMO char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Plan size quantity
DataItem PC0UWPZQ int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// size quantity array (part 1)
DataItem PC0UWQA1 char(60)  {
  align = right, fillCharacter = nullFill, inputRequired = no
}
end

// PC0UW21 qtys level (part 1)
DataItem PC0UWQL1 char(77)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// map total quantity
DataItem PC0UWQTY num(10,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Batch group level record
DataItem PC0UWR20 char(80)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// size buckets flag 10 per flag
DataItem PC0UWRC char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Received cursor flag
DataItem PC0UWRCF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// receipt literal
DataItem PC0UWRCL char(9)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// receipt number
DataItem PC0UWRCN char(8)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Received data flag
DataItem PC0UWRDF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// map receiving rpt nbr
DataItem PC0UWRNO char(8)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// screen two color
DataItem PC0UWS2C char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// SAP number
DataItem PC0UWSAP char(10)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// screen two data
DataItem PC0UWSC2 char(35)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// size description
DataItem PC0UWSD1 char(6)  {
  align = right, fillCharacter = nullFill, inputRequired = no
}
end

// size description
DataItem PC0UWSD2 char(6)  {
  align = right, fillCharacter = nullFill, inputRequired = no
}
end

// size description
DataItem PC0UWSD3 char(6)  {
  align = right, fillCharacter = nullFill, inputRequired = no
}
end

// size description
DataItem PC0UWSD4 char(6)  {
  align = right, fillCharacter = nullFill, inputRequired = no
}
end

// screen date day
DataItem PC0UWSDD num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Shipping data flag
DataItem PC0UWSDF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// size detail number
DataItem PC0UWSDN num(6)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Screen date
DataItem PC0UWSDT num(6)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Record Sequence Key
DataItem PC0UWSEQ num(1)  {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

DataItem PC0UWSHA char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// shipping number
DataItem PC0UWSHN char(8)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// TS_CPL_QTOT_SHP1
DataItem PC0UWSHQ int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

DataItem PC0UWSHW char(8)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem PC0UWSHX num(8)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// size detail id
DataItem PC0UWSID char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// size detail literal
DataItem PC0UWSLT char(9)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// screen date month
DataItem PC0UWSMM num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Sales/Nike order number
DataItem PC0UWSNN char(11)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Size page scroll counter
DataItem PC0UWSPG num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// size page index
DataItem PC0UWSPI smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Size page reqested
DataItem PC0UWSPR num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// sequence indicator for flag
DataItem PC0UWSQ num(1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// size quantity
DataItem PC0UWSQ1 num(6)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = nullFill, inputRequired = no
}
end

// decimal size quantity
DataItem PC0UWSQ2 num(7,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = nullFill, inputRequired = no
}
end

// size qty work array
DataItem PC0UWSQA char(60)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// decimal size qty work array
DataItem PC0UWSQB char(70)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Screen request flag
DataItem PC0UWSRF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// total receive style sizearray
DataItem PC0UWSRZ int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// total shipped irreg style arra
DataItem PC0UWSS int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// total shipped style sizearray
DataItem PC0UWSSZ int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// size table flag
DataItem PC0UWSTB char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// status date
DataItem PC0UWSTD char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// balance to ship literal
DataItem PC0UWSTL char(23)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// size work array
DataItem PC0UWSWA char(160)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Season or year
DataItem PC0UWSYR char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// screen date year
DataItem PC0UWSYY num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// size description grp (part 1)
DataItem PC0UWSZ1 char(60)  {
  align = right, fillCharacter = nullFill, inputRequired = no
}
end

// size description grp (part 2)
DataItem PC0UWSZ2 char(60)  {
  align = right, fillCharacter = nullFill, inputRequired = no
}
end

// size description grp (part 3)
DataItem PC0UWSZ3 char(60)  {
  align = right, fillCharacter = nullFill, inputRequired = no
}
end

// size description grp (part 4)
DataItem PC0UWSZ4 char(60)  {
  align = right, fillCharacter = nullFill, inputRequired = no
}
end

// etal date
DataItem PC0UWTAL char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// etal over date
DataItem PC0UWTAO char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// trans cursor flag
DataItem PC0UWTCF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// total received by color
DataItem PC0UWTCR int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// total shipped by color
DataItem PC0UWTCS int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Total cut quantity
DataItem PC0UWTCT int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// total cut sizes array
DataItem PC0UWTCZ int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// total received (by destination
DataItem PC0UWTDR int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// total shipped (by destination)
DataItem PC0UWTDS int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Total items (for a color)
DataItem PC0UWTIC int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// total item by destination
DataItem PC0UWTID int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// total irregular literal
DataItem PC0UWTIR char(20)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Total items (for a style)
DataItem PC0UWTIS int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// total items size array
DataItem PC0UWTIZ int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// thru page number
DataItem PC0UWTOP num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Total ordered quantity
DataItem PC0UWTOR int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Temporary storage page length
DataItem PC0UWTSL num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Increment and decrement page
DataItem PC0UWTSP num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// total received by style
DataItem PC0UWTSR int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// total shipped by style
DataItem PC0UWTSS int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// updated date
DataItem PC0UWUPD char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem PC0UWUSR char(41)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// WIP cursor flag
DataItem PC0UWWCF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// work field 1
DataItem PC0UWWF1 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// work field 2
DataItem PC0UWWF2 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// work field 3
DataItem PC0UWWF3 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// work field 4
DataItem PC0UWWF4 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// work field 5
DataItem PC0UWWF5 bin(9,4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// warehouse code
DataItem PC0UWWHS char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Size total work field
DataItem PC0UWWSZ int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// tent/hard error wk fld 1
DataItem PC0UWWT1 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Restrict access to ETALO flag
DataItem PC0UWXDF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Reformat date yymmdd
DataItem PC0UWYMD num(6)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

