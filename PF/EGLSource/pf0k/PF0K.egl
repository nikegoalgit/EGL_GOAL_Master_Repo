package pf0k;
import corpcom2.YSMREC;
import corpcom3.XPPF002;
import corpcom3.XPPF010;
import corpcom3.XPPF020;
import corpcom3.XPPF430;
import corpcom4.XSENTRY;
import corpcom4.XSEXIT;
import corpcom4.XSPF4;
import corpcom4.XSSEGTR;
import corpcom5.COMMAREA;
import corpcom5.ERRSQLCA;
import corpcom6.SQLCA;
import corpx1.XATTBL;
import corpx1.XAUTBL;
import corpx1.XBTTBL;
import corpx1.XCNTBL;
import corpx1.XDMCD;
import corpx1.XDRTBL;
import corpx1.XDVTBL;
import corpx1.XFCTBL;
import corpx1.XFMTBL;
import corpx1.XGATBL;
import corpx1.XGPCD;
import corpx1.XGPTBL;
import corpx1.XGSTBL;
import corpx1.XLCCD;
import corpx1.XLCTBL;
import corpx1.XMCTBL;
import corpx1.XOBTBL;
import corpx1.XPCTBL;
import corpx1.XPGTBL;
import corpx1.XPLTBL;
import corpx1.XPRTBL;
import corpx1.XQATBL;
import corpx1.XRDTBL;
import corpx1.XRYTBL;
import corpx1.XSPTBL;
import corpx1.XSUTBL;
import corpx1.XWHTBL;
import corpx2.XQACD;
import corpy2.YFATBL;
import corpy2.YFETBL;
import corpy2.YFFTBL;
import corpy2.YFGTBL;
import corpy2.YGRTBL;
import corpy2.YICTBL;
import corpy2.YISCD;
import corpy2.YISTBL;
import corpy2.YMATBL;
import corpy2.YMBTBL;
import corpy2.YMCTBL;
import corpy2.YPDTBL;
import corpy2.YSCTBL;
import corpy2.YSETBL;
import corpy2.YSFTBL;
import corpy2.YSYTBL;
import corpy2.YTPTBL;
import corpy2.YTYTBL;
import pf.common.*;
import pf.common.PF1REC;
import pf.common.PFAREC;
import pf.common.PFBREC;
import pf.common.PFCREC;
import pf.common.PFDREC;
import pf.common.PFEREC;
import pf.common.PFGREC;
import pf.common.PFWREC;
import sm.common.SM1REC;
import sy.common.SY1REC;
import sy.common.SY1STNBR;
import sy.common.SY2CLRID;
import sy.common.SYCREC;
import ta.common.TA1REC;

//*** PROGRAM=PF0K ****
// this application will display summaries that were generated
// to use a type 1 format. users are able to view the summaries
// in a summary, detail or explode format. users can also view
// 132 column-sized summaries by scrolling right or left on the
// screen that is displayed. finally, summaries can have up to
// 8 levels of information stored in a hierarchical fashion.
// this application will access the selected summary at a
// starting viewing position as determined in pf0b but the user
// has the capability to move up or down the levels easily by
// using predefined pf keys.
// 
// maintenance history:
//   date     by             description of change
// --------  -----  -------------------------------------------
//  1-03-89   mh    original transfer to production.
//  2-28-89   mh    change handling of overflow comparison
//                                      percentages.
//  3-13-89   mh    enhance display of partial summary
//                                      warning.  pf0k210
//  4-19-89   DLC   Change screen column descriptions:
//                  NET SALES to NET SHIP, DEF RTS to DEF RTN.
//  6-21-89   DLC   Change Summary Order Type to Base Order
//                  Type (XOBTBL).
//  7-13-89   DLC   Re-Gen for changes to YFATBL, YMATBL,
//                  YMBTBL, and YMCTBL.
// 11-30-89   TBG   Modify to load and pass data viewed back to
//                  Summary File View Selection (PF0B).
//  4-05-90   CVO   Transfer to PF0A if the expected summary
//                  is not passed.
//  6-13-91   CVO   Increased group level entries on pf0kw02
//                  from 200 to 500.
//  9-25-91   DLC     Added abend if pf0kw02 > 500 when loaded,
//                  & increased # of yis's searched for is grp
//                  literals from 200 to PFWLIMIT, in pf0k200.
//                  Was not displaying lits for last is grps.
//                    Increased rows searched in working stor
//                  for 'sum' level displ from 200 to PFWLIMIT,
//                  in pf0k310.  Was not displaying anything
//                  below gross margin for sums w/ > 200 yis's.
//  9-01-92   WES     Added initialization of attribute descr.,
//                  in pf0k210.
//  4-15-94   mjk   changed for new attributes.
//  3-01-96  MBUHIT Regen for GCOA changes to YICTBL.
// 11-19-97  mleabo Re-gen for table changes ysetbl, tsftbl.
// *********************
Program PF0K type textUIProgram //VAGen Info - main text program
  {
  includeReferencedFunctions = yes, allowUnqualifiedItemReferences = yes, 
  throwNrfEofExceptions = yes, handleHardIOErrors = no, V60ExceptionCompatibility = yes, 
  I4GLItemsNullable = no, textLiteralDefaultIsString = no, localSQLScope = yes, 
  msgTablePrefix = "PF00", inputRecord = COMMAREA, segmented = yes
  }

  // Data Declarations
  COMMAREA COMMAREA ; // record
  ERRSQLCA ERRSQLCA; // record
  PF0KW01 PF0KW01; // record
  PF0KW02 PF0KW02; // record
  PF1REC PF1REC; // record
  PF2REC PF2REC; // record
  PFAREC PFAREC; // record
  PFBREC PFBREC; // record
  PFCREC PFCREC; // record
  PFDREC PFDREC; // record
  PFEREC PFEREC; // record
  PFGREC PFGREC; // record
  PFWREC PFWREC; // record
  SM1REC SM1REC; // record
  SQLCA SQLCA; // record
  SY1REC SY1REC; // record
  SYCREC SYCREC; // record
  TA1REC TA1REC; // record
  YSMREC YSMREC; // record

  // VAGen Info - items needed for migration
  VAGen_EZESYS char(8);
  VAGen_EZEREPLY num(1);
  VAGen_EZE_WAIT_TIME bin(9,2);
  VAGen_EZE_ITEMLEN int;

  // Use Declarations
  use XATTBL {deleteAfterUse = yes}; // table
  use XAUTBL {deleteAfterUse = yes}; // table
  use XBTTBL {deleteAfterUse = yes}; // table
  use XCNTBL {deleteAfterUse = yes}; // table
  use XDRTBL {deleteAfterUse = yes}; // table
  use XDVTBL {deleteAfterUse = yes}; // table
  use XFCTBL {deleteAfterUse = yes}; // table
  use XFMTBL {deleteAfterUse = yes}; // table
  use XGATBL {deleteAfterUse = yes}; // table
  use XGPTBL {deleteAfterUse = yes}; // table
  use XGSTBL {deleteAfterUse = yes}; // table
  use XMCTBL {deleteAfterUse = yes}; // table
  use XLCTBL {deleteAfterUse = yes}; // table
  use XOBTBL {deleteAfterUse = yes}; // table
  use XPCTBL {deleteAfterUse = yes}; // table
  use XPGTBL {deleteAfterUse = yes}; // table
  use XPLTBL {deleteAfterUse = yes}; // table
  use XPRTBL {deleteAfterUse = yes}; // table
  use XQATBL {deleteAfterUse = yes}; // table
  use XRDTBL {deleteAfterUse = yes}; // table
  use XRYTBL {deleteAfterUse = yes}; // table
  use XSPTBL {deleteAfterUse = yes}; // table
  use XSUTBL {deleteAfterUse = yes}; // table
  use XWHTBL {deleteAfterUse = yes}; // table
  use YFATBL {deleteAfterUse = yes}; // table
  use YFETBL {deleteAfterUse = yes}; // table
  use YFFTBL {deleteAfterUse = yes}; // table
  use YFGTBL {deleteAfterUse = yes}; // table
  use YGRTBL {deleteAfterUse = yes}; // table
  use YICTBL {deleteAfterUse = yes}; // table
  use YISTBL {deleteAfterUse = yes}; // table
  use YMATBL {deleteAfterUse = yes}; // table
  use YMBTBL {deleteAfterUse = yes}; // table
  use YMCTBL {deleteAfterUse = yes}; // table
  use YPDTBL {deleteAfterUse = yes}; // table
  use YSCTBL {deleteAfterUse = yes}; // table
  use YSETBL {deleteAfterUse = yes}; // table
  use YSFTBL {deleteAfterUse = yes}; // table
  use YSYTBL {deleteAfterUse = yes}; // table
  use YTPTBL {deleteAfterUse = yes}; // table
  use YTYTBL {deleteAfterUse = yes}; // table
  use PF0KM.PF0KM001,  // forms
      PF0KM.PF0KM002
   {
    pfKeyEquate = no
  };

  function main()
    // VAGen Info - initialization needed for migration
    VAGen_EZESYS = VGLib.getVAGSysType();
    PF0K000: PF0K000();
  end // end main
end // end PF0K

// application mainline
Function PF0K000()
   /* ******************************************************/
   /* *    pf0k mainline logic                            **/
   /* ******************************************************/

  PF0K001(); /* application initialization routine*/

  while (PFWREC.PFWEOAF == "N") /* while application active,*/
    PF0K100(); /* converse display screens*/
  end

  XPPF002();
  COMMAREA.CAFROMAP = "PF0K";
  COMMAREA.CATOAP = "PF0A";
  XSEXIT();
end // end PF0K000

Function PF0K001()
   /* ****************************************************/
   /* *   this process will use information passed by   **/
   /* *   pf0b to access profitability db2 tables for   **/
   /* *   initializing a format 1 summary view. the     **/
   /* *   process will access the summary attribute     **/
   /* *   table(vsumat01) and the i/s group table       **/
   /* *   (visgrp01). the information provided by these **/
   /* *   tables will be used to setup the display      **/
   /* *   screens to used throughout the rest of the    **/
   /* *   application.                                  **/
   /* ****************************************************/

  XSENTRY(); /* check user security*/

  XSSEGTR();

  set PF0KM001 initial; /* initialize maps*/
  set PF0KM002 initial;

  set PF0KW01 empty; /* initialize w/s records*/

  PFWREC.PFWERRF = "N"; /* initialize flags*/
  PFWREC.PFWEOAF = "N";

  PF0KM001.XXXCURDT = VGVar.currentShortGregorianDate; /* move current date to maps*/
  PF0KM002.XXXCURDT = VGVar.currentShortGregorianDate;

  PF1REC.PF1PASS = COMMAREA.CAUSERA; /* move passed info. to w/s*/
                                          /* record*/
  COMMAREA.CAUSERA = " "; /* clear the commarea*/

  set PFEREC empty;
  set SQLCA empty;

  if (PF1REC.PFESUMNM == " ") /* <=== if no summary name passed*/
    COMMAREA.CAFROMAP = "PF0K"; /* to Profit. Menu*/
    COMMAREA.CATOAP = "PF0A";
    XSEXIT(); /* <=== Transfer to PF0A.*/
    PF0KM001.VAGen_EZEMSG = COMMAREA.CAMSG;
    PFWREC.PFWERRF = "Y";
  end

  PFEREC.PFESUMNM = PF1REC.PFESUMNM; /* move summary name to db2 key*/

  call "IO2770" ("S ", SQLCA, PFEREC) {isNoRefresh = yes, isExternal = yes}; /* access vsumat01 table*/

  if (SQLCA.VAGen_SQLCODE == +0) /* if summary found continue with the process*/
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
    TA1REC.TA1TBLVU = "VSUMAT01";
    TA1REC.TA1TBLKE = PF1REC.PFESUMNM;
    TA1REC.TA1LOCAT[3] = "PF0K001";
    TA1REC.TA1LOCAT[4] = "IO2770";
    XPPF010();
  end

  PF0KM001.PF0KMNAM = PFEREC.PFESUMNM; /* move summary name to screen*/
  PF0KM002.PF0KMNAM = PFEREC.PFESUMNM;
  PF0KM001.PF0KMDTC = PFEREC.PFECRTDT; /* move date created to maps*/
  PF0KM002.PF0KMDTC = PFEREC.PFECRTDT;
  PF0KM001.PF0KMBMM = PFEREC.PFABSPRM; /* move base per. mo. to maps*/
  PF0KM002.PF0KMBMM = PFEREC.PFABSPRM;
  PF0KM001.PF0KMCYY = PFEREC.PFABSPRY; /* move base per. yr. to maps*/
  PF0KM002.PF0KMCYY = PFEREC.PFABSPRY;
  PF0KM001.PF0KMFMT = PFEREC.PFCREF; /* move format # to maps*/
  PF0KM002.PF0KMFMT = PFEREC.PFCREF;
  PF0KM001.PF0KMISG = PFEREC.PFBREF; /* move i/s ref. # to maps*/
  PF0KM002.PF0KMISG = PFEREC.PFBREF;
  PF0KM001.PF0KMATT = PFEREC.PFDREF; /* move rpt. attr. # to maps*/
  PF0KM002.PF0KMATT = PFEREC.PFDREF;

  set PFAREC empty;
  set SQLCA empty;

  call "IO2670" ("S ", SQLCA, PFAREC) {isNoRefresh = yes, isExternal = yes}; /* access vpfctl01 table*/

  if (SQLCA.VAGen_SQLCODE == +0) /* if control rec. found continue with*/
                                   /* the process*/
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
    TA1REC.TA1TBLVU = "VPFCTL01";
    TA1REC.TA1TBLKE = PF1REC.PFESUMNM;
    TA1REC.TA1LOCAT[3] = "PF0K001";
    TA1REC.TA1LOCAT[4] = "IO2670";
    XPPF010();
  end

  if (PFAREC.PFASTBLF == "Y") /* if the summary file is locked due to an*/
    PFWREC.PFWERRF = "Y"; /* db2 batch load, send user a message*/
    converseLib.validationFailed(223);
  end

  PF0KW01.PF0KWKY1 = "18:"; /* setup pf key literals for*/
                                   /* 'sum,det,exp'*/
  PF0KW01.PF0KWKY2 = "19:";

  if (PF1REC.PF1DISP == "SUM")
                                   /* pf0b will pass the starting view type*/
     /* (sum,det,exp). move appropriate title heading to maps.*/
    PF0KM001.PF0KMLIT = "SUMMARY FILE SUMMARY VIEW";
    PF0KM002.PF0KMLIT = "SUMMARY FILE SUMMARY VIEW";
    PF0KW01.PF0KWDP1 = "DET"; /* move literals to pf keys*/
    PF0KW01.PF0KWDP2 = "EXP";
  else
    if (PF1REC.PF1DISP == "DET")
      PF0KM001.PF0KMLIT = "SUMMARY FILE DETAIL VIEW";
      PF0KM002.PF0KMLIT = "SUMMARY FILE DETAIL VIEW";
      PF0KW01.PF0KWDP1 = "SUM"; /* move literals to pf keys*/
      PF0KW01.PF0KWDP2 = "EXP";
    else
      if (PF1REC.PF1DISP == "EXP")
        PF0KM001.PF0KMLIT = "SUMMARY FILE EXPLODED VIEW";
        PF0KM002.PF0KMLIT = "SUMMARY FILE EXPLODED VIEW";
        PF0KW01.PF0KWDP1 = "SUM"; /* move literals to pf keys*/
        PF0KW01.PF0KWDP2 = "DET";
      end
    end
  end

  set PFDREC empty;
  set SQLCA empty;

  PFDREC.PFDREF = PFEREC.PFDREF; /* move rept. attr. ref # to db2 key*/

  call "IO2740" ("S ", SQLCA, PFDREC) {isNoRefresh = yes, isExternal = yes}; /* access vrptat01 table*/

  if (SQLCA.VAGen_SQLCODE == +0) /* if i/s group # found continue with the process*/
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
    TA1REC.TA1TBLVU = "VRPTAT01";
    PF0KW01.PF0KWABK = PFEREC.PFBREF;
    TA1REC.TA1TBLKE = PF0KW01.PF0KWAB2;
    TA1REC.TA1LOCAT[3] = "PF0K001";
    TA1REC.TA1LOCAT[4] = "IO2740";
    XPPF010();
  end

  set PFCREC empty;
  set SQLCA empty;

  PFCREC.PFCREF = PFEREC.PFCREF; /* move summary fmt # to db2 key*/

  call "IO2730" ("S ", SQLCA, PFCREC) {isNoRefresh = yes, isExternal = yes}; /* access vrptfm01 table*/

  if (SQLCA.VAGen_SQLCODE == +0) /* if format # found continue with the process*/
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
    TA1REC.TA1TBLVU = "VRPTFM01";
    PF0KW01.PF0KWABK = PFEREC.PFCREF;
    TA1REC.TA1TBLKE = PF0KW01.PF0KWAB2;
    TA1REC.TA1LOCAT[3] = "PF0K001";
    TA1REC.TA1LOCAT[4] = "IO2730";
    XPPF010();
  end

  if (PFCREC.YPDCD[1] in YPDTBL.YPDCD) /* move time period #1 to hold area*/
    PF0KW01.PF0KWTP1 = YPDTBL.YPDSDESC[sysVar.arrayIndex];
  end

  if (PFCREC.YTPCD[1] in YTPTBL.YTPCD)
                                   /* move data type #1 to hold area*/
    PF0KW01.PF0KWDT1 = YTPTBL.YTPSDESC[sysVar.arrayIndex];
  end

  if (PFCREC.YPDCD[2] in YPDTBL.YPDCD) /* move time period #2 to hold area*/
    PF0KW01.PF0KWTP2 = YPDTBL.YPDSDESC[sysVar.arrayIndex];
  end

  if (PFCREC.YTPCD[2] in YTPTBL.YTPCD)
                                   /* move data type #2 to hold area*/
    PF0KW01.PF0KWDT2 = YTPTBL.YTPSDESC[sysVar.arrayIndex];
  end

  PF0KW01.PF0KWTP3 = PFCREC.YTPCD[1];
  PF0KW01.PF0KWTP4 = PFCREC.YTPCD[2];
  PF0KW01.PF0KWDT3 = PFCREC.YPDCD[1];
  PF0KW01.PF0KWDT4 = PFCREC.YPDCD[2];
  PF0KW01.PF0KWF1 = "-";
  PF0KW01.PF0KWF2 = "-";

  PF0KM001.PF0KMDT1 = PF0KW01.PF0KWLT1;
                                   /* move dt/tp literals to maps*/
  PF0KM002.PF0KMDT1 = PF0KW01.PF0KWLT1;
  PF0KM001.PF0KMDT2 = PF0KW01.PF0KWLT2;
  PF0KM002.PF0KMDT2 = PF0KW01.PF0KWLT2;
  PF0KM002.PF0KMDT3 = PF0KW01.PF0KWCL1;
  PF0KM002.PF0KMDT4 = PF0KW01.PF0KWCL2;

  PF0KW01.PF0KWSTL = PF1REC.PF1STLVL; /* move passed starting inquiry*/
  PF0KW01.PF0KWSTS = PF1REC.PF1STSEQ; /* to hold db2 keys*/

  PFWREC.PFWSUB1 = 1; /* initialize subscript*/

  PF0K200(); /* routine to access summary file, load to w/s table*/

  PF0KW01.PF0KWDSP = PF1REC.PF1DISP; /* save display type*/

  PFWREC.PFWSUB1 = 1; /* initialize subscripts*/
  PFWREC.PFWSUB2 = 1;

  PF0K300(); /* determine display type*/

  PFWREC.PFWERRF = "N";

  PF0KW01.PF0KWLEF = "Y"; /* set map switch to display left side*/
  PF0KW01.PF0KWRIG = "N";
end // end PF0K001

// main converse logic loop
Function PF0K100()
   /* ****************************************************/
   /* *  this process will determine whether the left   **/
   /* *  or right display map is to be conversed and    **/
   /* *  will perform the appropriate converse routine. **/
   /* *  after conversing, the routine will check pf    **/
   /* *  keys for the next function to process.         **/
   /* ****************************************************/

  if (PF0KW01.PF0KWLEF == "Y") /* converse left side map*/
    PF0KM001.PF0KMPFK = PF0KW01.PF0KWPFK; /* move pf18,pf19 keys to map*/
    PF0K120();
    PF0KW01.PF0KWPFK = PF0KM001.PF0KMPFK; /* store pf18,pf19 values*/
  end

  if (PF0KW01.PF0KWRIG == "Y") /* converse right side map*/
    PF0KM002.PF0KMPFK = PF0KW01.PF0KWPFK; /* move pf18,pf19 keys to map*/
    PF0K130();
    PF0KW01.PF0KWPFK = PF0KM002.PF0KMPFK; /* store pf18,pf19 values*/
  end

  PF0K110(); /* check pf keys*/
end // end PF0K100

// check pf keys
Function PF0K110()
   /* *****************************************************/
   /* *  this process will check the pf keys entered by  **/
   /* *  the user and will take the appropriate course   **/
   /* *  of action.                                      **/
   /* *****************************************************/

  if (converseVar.eventKey is pf3) /* return to 'pf0b' application*/
    COMMAREA.CATOAP = "PF0B";
    PF1REC.PFDCDVAL[1] = PF0KM001.PF0KMAVD[1];
    PF1REC.PFDCDVAL[2] = PF0KM001.PF0KMAVD[2];
    PF1REC.PFDCDVAL[3] = PF0KM001.PF0KMAVD[3];
    PF1REC.PFDCDVAL[4] = PF0KM001.PF0KMAVD[4];
    PF1REC.PFDCDVAL[5] = PF0KM001.PF0KMAVD[5];
    PF1REC.PFDCDVAL[6] = PF0KM001.PF0KMAVD[6];
    PF1REC.PFDCDVAL[7] = PF0KM001.PF0KMAVD[7];
    COMMAREA.CAUSERA = PF1REC.PF1PASS;
    XSEXIT();
    PFWREC.PFWMSG = COMMAREA.CAMSG; /* handle a bad pass*/
    PFWREC.PFWERRF = "Y";
    return;
  end

  set PFAREC empty;
  set SQLCA empty;

  call "IO2670" ("S ", SQLCA, PFAREC) {isNoRefresh = yes, isExternal = yes}; /* access vpfctl01 table*/

  if (SQLCA.VAGen_SQLCODE == +0) /* if control rec. found continue with*/
                                   /* the process*/
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
    TA1REC.TA1TBLVU = "VPFCTL01";
    TA1REC.TA1TBLKE = PF1REC.PFESUMNM;
    TA1REC.TA1LOCAT[3] = "PF0K110";
    TA1REC.TA1LOCAT[4] = "IO2670";
    XPPF010();
  end

  if (PFAREC.PFASTBLF == "Y") /* if the summary file is locked due to an*/
    PFWREC.PFWERRF = "Y"; /* db2 batch load, send user a message*/
    converseLib.validationFailed(223);
    return;
  end

  if (converseVar.eventKey is pf5) /* move up a level*/
    PF0KW01.PF0KWSTL = PF0KW01.PF0KWSTL - 1;
    if (PF0KWSTL < 0)
      PFWREC.PFWERRF = "Y";
      converseLib.validationFailed(218);
      return;
    end
    PF0K260(); /* access vsumry01 table*/
    if (SQLCA.VAGen_SQLCODE == +100)
                                   /* if there are no more levels to go up,*/
      PFWREC.PFWERRF = "Y"; /* send user a message*/
      converseLib.validationFailed(218);
      PF0KW01.PF0KWSTL = PF0KW01.PF0KWSTL + 1; /* restore viewing level*/
      return;
    end
    PF0K200();
    PFWSUB1 = 1;
    PF0K300(); /* move w/s items to display screen*/
    return;
  end

  if (converseVar.eventKey is pf6) /* move down a level*/
    PF0KW01.PF0KWSTL = PF0KW01.PF0KWSTL + 1;
    if (PF0KWSTL > 8)
      PFWREC.PFWERRF = "Y";
      converseLib.validationFailed(219);
      return;
    end
    PF0K200(); /* access vsumry01 table*/
    if (SQLCA.VAGen_SQLCODE == +100) /* if the row was not found,*/
      PFWREC.PFWERRF = "Y"; /* send the user a message*/
      converseLib.validationFailed(251);
      PF0KW01.PF0KWSTL = PF0KW01.PF0KWSTL - 1; /* restore viewing level*/
      return;
    end
    PFWSUB1 = 1;
    PF0K300(); /* move w/s items to display screen*/
    return;
  end

  if (converseVar.eventKey is pf7 /* user can't scroll when a 'sum' is displayed*/
   && PF0KW01.PF0KWDSP == "SUM") 
    PFWREC.PFWERRF = "Y";
    converseLib.validationFailed(225);
    return;
  end

  if (converseVar.eventKey is pf7) /* scroll up within current summary*/
    if (PF0KW01.PF0KWDSP == "DET")
      PFWSUB1 = PFWREC.PFWSAVDX;
      PFWSUB1 = PFWSUB1 - 1;
      PF0K350();
      return;
    end
    if (PF0KW01.PF0KWDSP == "EXP")
      PFWSUB1 = PFWREC.PFWSAVDX;
      PFWSUB1 = PFWSUB1 - 1;
      PF0K360();
      return;
    end
  end

  if (converseVar.eventKey is pf8 /* user can't scroll when a 'sum' is displayed*/
   && PF0KW01.PF0KWDSP == "SUM") 
    PFWREC.PFWERRF = "Y";
    converseLib.validationFailed(225);
    return;
  end

  if (converseVar.eventKey is pf8) /* scroll down within current summary*/
    if (PFWNXTDX > PFWLIMIT)
                                   /* if user can't scroll forward anymore,*/
      PFWREC.PFWERRF = "Y"; /* send a message*/
      converseLib.validationFailed(032);
      return;
    end
    move PFWNXTDX to PFWSUB1 withV60Compat; /* set starting display subscript*/
    PF0K300();
    return;

  end

  if (converseVar.eventKey is pf10) /* shift to left-side map*/
    if (PF0KW01.PF0KWLEF == "N")
      PF0KW01.PF0KWLEF = "Y"; /* set map display indicator to left*/
      PF0KW01.PF0KWRIG = "N";
      return;
    else
      PFWREC.PFWERRF = "Y"; /* can't shift left if already on left*/
                                   /* map*/
      converseLib.validationFailed(198);
      return;
    end
  end

  if (converseVar.eventKey is pf11) /* shift to right-side map*/
    if (PF0KW01.PF0KWRIG == "N")
      PF0KW01.PF0KWRIG = "Y"; /* set map display indicator to right*/
      PF0KW01.PF0KWLEF = "N";
      return;
    else
      PFWREC.PFWERRF = "Y"; /* can't shift right if already on right map*/
      converseLib.validationFailed(192);
      return;
    end
  end

  if (converseVar.eventKey is pf18) /* user requested a change in display type*/
    PF0KW01.PF0KWHDP = PF0KW01.PF0KWDP1;
                                   /* switch pf key display type*/
    PF0KW01.PF0KWDP1 = PF0KW01.PF0KWDSP; /* with current display type*/
    PF0KW01.PF0KWDSP = PF0KW01.PF0KWHDP;
                                   /* and display maps from same*/
    PF1REC.PF1DISP = PF0KW01.PF0KWDSP;
    if (PF0KW01.PF0KWDSP == "SUM")
       /* (sum,det,exp). move appropriate title heading to maps.*/
      PF0KM001.PF0KMLIT = "SUMMARY FILE SUMMARY VIEW";
      PF0KM002.PF0KMLIT = "SUMMARY FILE SUMMARY VIEW";
    else
      if (PF0KW01.PF0KWDSP == "DET")
        PFWREC.PFWSUB1 = PFWREC.PFWSAVDX;
        PF0KM001.PF0KMLIT = "SUMMARY FILE DETAIL VIEW";
        PF0KM002.PF0KMLIT = "SUMMARY FILE DETAIL VIEW";
      else
        if (PF0KW01.PF0KWDSP == "EXP")
          PFWREC.PFWSUB1 = PFWREC.PFWSAVDX;
          PF0KM001.PF0KMLIT = "SUMMARY FILE EXPLODED VIEW";
          PF0KM002.PF0KMLIT = "SUMMARY FILE EXPLODED VIEW";
        end
      end
    end
    if (PF0KW01.PF0KWHDP == "SUM"
     || PF0KW01.PF0KWDSP == "SUM")
      PFWREC.PFWSAVDX = 1;
      PFWREC.PFWSUB1 = 1;
    end
    PF0K300();
    return;
  end

  if (converseVar.eventKey is pf19) /* user requested a change in display type*/
    PF0KW01.PF0KWHDP = PF0KW01.PF0KWDP2;
                                   /* switch pf key display type*/
    PF0KW01.PF0KWDP2 = PF0KW01.PF0KWDSP; /* with current display type*/
    PF0KW01.PF0KWDSP = PF0KW01.PF0KWHDP;
                                   /* and display maps from same*/
    PF1REC.PF1DISP = PF0KW01.PF0KWDSP;
    if (PF0KW01.PF0KWDSP == "SUM")
       /* (sum,det,exp). move appropriate title heading to maps.*/
      PF0KM001.PF0KMLIT = "SUMMARY FILE SUMMARY VIEW";
      PF0KM002.PF0KMLIT = "SUMMARY FILE SUMMARY VIEW";
    else
      if (PF0KW01.PF0KWDSP == "DET")
        PFWREC.PFWSUB1 = PFWREC.PFWSAVDX;
        PF0KM001.PF0KMLIT = "SUMMARY FILE DETAIL VIEW";
        PF0KM002.PF0KMLIT = "SUMMARY FILE DETAIL VIEW";
      else
        if (PF0KW01.PF0KWDSP == "EXP")
          PFWREC.PFWSUB1 = PFWREC.PFWSAVDX;
          PF0KM001.PF0KMLIT = "SUMMARY FILE EXPLODED VIEW";
          PF0KM002.PF0KMLIT = "SUMMARY FILE EXPLODED VIEW";
        end
      end
    end
    if (PF0KW01.PF0KWHDP == "SUM"
     || PF0KW01.PF0KWDSP == "SUM")
      PFWREC.PFWSAVDX = 1;
      PFWREC.PFWSUB1 = 1;
    end
    PF0K300();
    return;
  end

  if (converseVar.eventKey is pf20) /* move up within a level*/
    if (PF0KWSTS == 1) /* no more summaries within this level*/
      PFWREC.PFWERRF = "Y";
      converseLib.validationFailed(220);
      return;
    end
    PF0K260(); /* access vsumry01 table*/
    if (SQLCA.VAGen_SQLCODE == +100) /* if the row was not found,*/
      PFWREC.PFWERRF = "Y"; /* send the user a message*/
      converseLib.validationFailed(220);
      return;
    end
    PF0KW01.PF0KWFL2 = PF0KW01.PF0KWFL1;
    PF0K200(); /* read vsumry01/store rows in w/s area*/
    PF0K270(); /* see if hierarchy changed*/
    PFWSUB1 = 1;
    PF0K300(); /* move w/s items to display screen*/
    return;
  end

  if (converseVar.eventKey is pf21) /* move down within a level*/
    PF0KW01.PF0KWSTS = PF0KW01.PF0KWSTS + 1;
    PF0KW01.PF0KWFL2 = PF0KW01.PF0KWFL1;
    PF0K200(); /* access vsumry01 table*/
    if (SQLCA.VAGen_SQLCODE == +100) /* if the row was not found,*/
      PFWREC.PFWERRF = "Y"; /* send the user a message*/
      converseLib.validationFailed(220);
      PF0KW01.PF0KWSTS = PF0KW01.PF0KWSTS - 1;
      return;
    end
    PF0K270(); /* see if hierarchy changed*/
    PFWSUB1 = 1;
    PF0K300(); /* move w/s items to display screen*/

    return;
  end

  converseLib.validationFailed(001); /* invalid key was entered*/
  PFWREC.PFWERRF = "Y";
end // end PF0K110

// converse left side map
Function PF0K120()
   /* ********************************************************/
   /* *  the sole function of this process is to converse   **/
   /* *  the left side of the summary displays.             **/
   /* ********************************************************/

  set PF0KM001.XXXCURDT cursor;

  converse PF0KM001 ;

end // end PF0K120

// converse right side map
Function PF0K130()
   /* ********************************************************/
   /* *  the sole function of this process is to converse   **/
   /* *  the right side of the summary displays.            **/
   /* ********************************************************/

  set PF0KM001.XXXCURDT cursor;

  converse PF0KM002 ;

end // end PF0K130

// access vsumry01 table
Function PF0K200()
   /* ***********************************************************/
   /* *  this process will access the vsumry01 table using     **/
   /* *  the summary name, summary level, and summary sequence **/
   /* *  number as db2 keys.*/
   /* ***********************************************************/

  set PFGREC empty;
  set SQLCA empty;
  PFGREC.PFESUMNM = PFEREC.PFESUMNM; /* move summary name to db2 key*/
  PFGREC.PFGSUMN = PFEREC.PFGSUMN; /* move summary # to db2 key*/
  PFGREC.PFGLVLNO = PF0KW01.PF0KWSTL; /* move level # to db2 key*/
  PFGREC.PFGLVLSQ = PF0KW01.PF0KWSTS; /* move level seq # to db2 key*/

  call "IO2920" ("S1", SQLCA, PFGREC) {isNoRefresh = yes, isExternal = yes}; /* open vsumry01 cursor*/

  if (SQLCA.VAGen_SQLCODE == +0) /* if cursor open ok, continue with the process*/
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
    TA1REC.TA1TBLVU = "VSUMRY01";
    TA1REC.TA1TBLKE = PF1REC.PFESUMNM;
    TA1REC.TA1LOCAT[3] = "PF0K200";
    TA1REC.TA1LOCAT[4] = "IO2920";
    XPPF010();
  end


  set PFGREC empty;
  set SQLCA empty;

  call "IO2920" ("N1", SQLCA, PFGREC) {isNoRefresh = yes, isExternal = yes}; /* access vsumry01 table*/

  if (SQLCA.VAGen_SQLCODE == +0) /* if cursor open ok, continue with the process*/
    PF0KW01.PF0KWSTS = PFGREC.PFGLVLSQ; /* save seq. #*/
    PF0KW01.PF0KWSTL = PFGREC.PFGLVLNO;
    PF0KW01.PF0KWCD1 = PFGREC.PFDCDVAL[1];
    PF0KW01.PF0KWCD2 = PFGREC.PFDCDVAL[2];
    PF0KW01.PF0KWCD3 = PFGREC.PFDCDVAL[3];
    PF0KW01.PF0KWCD4 = PFGREC.PFDCDVAL[4];
    PF0KW01.PF0KWCD5 = PFGREC.PFDCDVAL[5];
    PF0KW01.PF0KWCD6 = PFGREC.PFDCDVAL[6];
    PF0KW01.PF0KWCD7 = PFGREC.PFDCDVAL[7];
  else
    if (SQLCA.VAGen_SQLCODE == +100)
      return;
    else
      TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
      TA1REC.TA1TBLVU = "VSUMRY01";
      TA1REC.TA1TBLKE = PF1REC.PFESUMNM;
      TA1REC.TA1LOCAT[3] = "PF0K200";
      TA1REC.TA1LOCAT[4] = "IO2920";
      XPPF010();
    end
  end


  PF0K210(); /* perform routine to get attribute literals*/


  set PF0KW02 empty;
  PFWSUB1 = 1;
  while (PFGREC.PFGLVLSQ == PF0KW01.PF0KWSTS
   && PFWSUB1 <= 500)

    PF0K220(); /* move summary rows to w/s area*/

    set SQLCA empty;
    set PFGREC empty;

    call "IO2920" ("N1", SQLCA, PFGREC) {isNoRefresh = yes, isExternal = yes}; /* access next vsumry01 row*/

    if (SQLCA.VAGen_SQLCODE == +0) /* if a row is found, continue with the process*/
       /* next sentence*/
    else
      if (SQLCA.VAGen_SQLCODE == +100) /* if a row isn't found, loop will terminate*/
        PFGREC.PFGLVLSQ = 9999; /* set condition to end loop*/
      else
        TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
        TA1REC.TA1TBLVU = "VSUMRY01";
        TA1REC.TA1TBLKE = PF1REC.PFESUMNM;
        TA1REC.TA1LOCAT[3] = "PF0K200";
        TA1REC.TA1LOCAT[4] = "IO2920";
        XPPF010();
      end
    end
    PFWSUB1 = PFWSUB1 + 1;
  end

  if (PFWSUB1 > 500)
    TA1REC.TA1TYPE = "APPL"; /* error type*/
    TA1REC.TA1FUNC = "RETN"; /* termination function*/
    TA1REC.TA1PGMNM = "PF0K"; /* program name*/
    TA1REC.TA1LOC = "PF0KW02 TBL OVERFLOW - PF0K200";
    SQLCA.SQLCAREC = " "; /* error information*/

    call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes}; /* error diagnostic routine*/

    COMMAREA.CAUSERA = " "; /* clear user commarea*/
    XSPF4(); /* master menu*/
    exit program; /* master menu failure*/
  end


  PFWREC.PFWLIMIT = PFWSUB1 - 1; /* set maximum index on w/s area*/


  PFWSUB1 = 1; /* initialize subscript*/
  while (PFWSUB1 <= PFWLIMIT)

    PF0K240(); /* perform routine get i/s group*/
                                   /* literals*/
    PFWSUB1 = PFWSUB1 + 1;
  end


  set PFGREC empty;
  set SQLCA empty;

  call "IO2920" ("C1", SQLCA, PFGREC) {isNoRefresh = yes, isExternal = yes}; /* close vsumry01 cursor*/

  if (SQLCA.VAGen_SQLCODE == +0) /* if cursor open ok, continue with the process*/
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
    TA1REC.TA1TBLVU = "VSUMRY01";
    TA1REC.TA1TBLKE = PF1REC.PFESUMNM;
    TA1REC.TA1LOCAT[3] = "PF0K200";
    TA1REC.TA1LOCAT[4] = "IO2920";
    XPPF010();
  end

end // end PF0K200

// determine attribute literals
Function PF0K210()
   /* ********************************************************/
   /* *  this process will determine the attribute field    **/
   /* *  literal for those attributes that are displayed    **/
   /* *  at the summary level to be viewed. the literal     **/
   /* *  be moved to the pf0lm001 screen fields from the    **/
   /* *  passed attribute descriptions in pf1rec.           **/
   /* ********************************************************/

  PF0KM001.PF0KMSTY = " "; /* clear product literals on maps*/
  PF0KM002.PF0KMSTY = " ";
  PF0KM001.PF0KMPRD = " ";
  PF0KM002.PF0KMPRD = " ";
  PF0KM001.PF0KMCLR = " ";
  PF0KM002.PF0KMCLR = " ";

  PFWSUB2 = 1;

  while (PFWSUB2 < 8) /* clear literals on maps*/
    PF0KM001.PF0KMAVD[PFWSUB2] = " ";
    PF0KM002.PF0KMAVD[PFWSUB2] = " ";
    PFWSUB2 = PFWSUB2 + 1;
  end

  PF0KM001.PF0KMPLT = " ";
  PF0KM002.PF0KMPLT = " ";

  PFWSUB2 = 1;

  while (PFWSUB2 < 8) /* move rept. attr. literals to maps*/
    PF0KW01.PF0KWAV1 = PF1REC.PFISDESC[PFWSUB2];
    if (PF0KW01.PF0KWAV1 > " ")
      PF0KW01.PF0KWAV2 = " :";
    else
      PF0KW01.PF0KWAV2 = "  ";
    end
    PF0KM001.PF0KMACA[PFWSUB2] = PF0KW01.PF0KWAVA;
    PF0KM002.PF0KMACA[PFWSUB2] = PF0KW01.PF0KWAVA;
    PFWSUB2 = PFWSUB2 + 1;
  end

  if (PF1REC.PFISDESC[1] > " ") /* if any attributes below this one*/
    if (PFDREC.PFDVALFL[2] == "Y" /* have selected values, mark this*/
     || PFDREC.PFDVALFL[3] == "Y" /* attribute with a highlighted "p"*/
     || PFDREC.PFDVALFL[4] == "Y" /* to warn user of a partial summary.*/
     || PFDREC.PFDVALFL[5] == "Y" 
     || PFDREC.PFDVALFL[6] == "Y" 
     || PFDREC.PFDVALFL[7] == "Y" 
     || PFDREC.PFDVALFL[8] == "Y")
      PF0KM001.PF0KMIND[1] = "P";
      PF0KM002.PF0KMIND[1] = "P";
      set PF0KM001.PF0KMIND[1] bold;
      set PF0KM002.PF0KMIND[1] bold;
    else
      PF0KM001.PF0KMIND[1] = " ";
      PF0KM002.PF0KMIND[1] = " ";
      set PF0KM001.PF0KMIND[1] normal;
      set PF0KM002.PF0KMIND[1] normal;
    end
  end

  if (PF1REC.PFISDESC[2] > " ")
    if (PFDREC.PFDVALFL[3] == "Y"
     || PFDREC.PFDVALFL[4] == "Y"
     || PFDREC.PFDVALFL[5] == "Y"
     || PFDREC.PFDVALFL[6] == "Y"
     || PFDREC.PFDVALFL[7] == "Y"
     || PFDREC.PFDVALFL[8] == "Y")
      PF0KM001.PF0KMIND[2] = "P";
      PF0KM002.PF0KMIND[2] = "P";
      set PF0KM001.PF0KMIND[2] bold;
      set PF0KM002.PF0KMIND[2] bold;
    else
      PF0KM001.PF0KMIND[2] = " ";
      PF0KM002.PF0KMIND[2] = " ";
      set PF0KM001.PF0KMIND[2] normal;
      set PF0KM002.PF0KMIND[2] normal;
    end
  end

  if (PF1REC.PFISDESC[3] > " ")
    if (PFDREC.PFDVALFL[4] == "Y"
     || PFDREC.PFDVALFL[5] == "Y"
     || PFDREC.PFDVALFL[6] == "Y"
     || PFDREC.PFDVALFL[7] == "Y"
     || PFDREC.PFDVALFL[8] == "Y")
      PF0KM001.PF0KMIND[3] = "P";
      PF0KM002.PF0KMIND[3] = "P";
      set PF0KM001.PF0KMIND[3] bold;
      set PF0KM002.PF0KMIND[3] bold;
    else
      PF0KM001.PF0KMIND[3] = " ";
      PF0KM002.PF0KMIND[3] = " ";
      set PF0KM001.PF0KMIND[3] normal;
      set PF0KM002.PF0KMIND[3] normal;
    end
  end

  if (PF1REC.PFISDESC[4] > " ")
    if (PFDREC.PFDVALFL[5] == "Y"
     || PFDREC.PFDVALFL[6] == "Y"
     || PFDREC.PFDVALFL[7] == "Y"
     || PFDREC.PFDVALFL[8] == "Y")
      PF0KM001.PF0KMIND[4] = "P";
      PF0KM002.PF0KMIND[4] = "P";
      set PF0KM001.PF0KMIND[4] bold;
      set PF0KM002.PF0KMIND[4] bold;
    else
      PF0KM001.PF0KMIND[4] = " ";
      PF0KM002.PF0KMIND[4] = " ";
      set PF0KM001.PF0KMIND[4] normal;
      set PF0KM002.PF0KMIND[4] normal;
    end
  end

  if (PF1REC.PFISDESC[5] > " ")
    if (PFDREC.PFDVALFL[6] == "Y"
     || PFDREC.PFDVALFL[7] == "Y"
     || PFDREC.PFDVALFL[8] == "Y")
      PF0KM001.PF0KMIND[5] = "P";
      PF0KM002.PF0KMIND[5] = "P";
      set PF0KM001.PF0KMIND[5] bold;
      set PF0KM002.PF0KMIND[5] bold;
    else
      PF0KM001.PF0KMIND[5] = " ";
      PF0KM002.PF0KMIND[5] = " ";
      set PF0KM001.PF0KMIND[5] normal;
      set PF0KM002.PF0KMIND[5] normal;
    end
  end

  if (PF1REC.PFISDESC[6] > " ")
    if (PFDREC.PFDVALFL[7] == "Y"
     || PFDREC.PFDVALFL[8] == "Y")
      PF0KM001.PF0KMIND[6] = "P";
      PF0KM002.PF0KMIND[6] = "P";
      set PF0KM001.PF0KMIND[6] bold;
      set PF0KM002.PF0KMIND[6] bold;
    else
      PF0KM001.PF0KMIND[6] = " ";
      PF0KM002.PF0KMIND[6] = " ";
      set PF0KM001.PF0KMIND[6] normal;
      set PF0KM002.PF0KMIND[6] normal;
    end
  end

  if (PF1REC.PFISDESC[7] > " ")
    if (PFDREC.PFDVALFL[8] == "Y")
      PF0KM001.PF0KMIND[7] = "P";
      PF0KM002.PF0KMIND[7] = "P";
      set PF0KM001.PF0KMIND[7] bold;
      set PF0KM002.PF0KMIND[7] bold;
    else
      PF0KM001.PF0KMIND[7] = " ";
      PF0KM002.PF0KMIND[7] = " ";
      set PF0KM001.PF0KMIND[7] normal;
      set PF0KM002.PF0KMIND[7] normal;
    end
  end


  PF0KM001.PF0KMPLT = PF1REC.PFIDESC[8];
  PF0KM002.PF0KMPLT = PF1REC.PFIDESC[8];

  PFWREC.XGPCD = PFGREC.XGPCD;
  PFWREC.SY1STNBR = PFGREC.SY1STNBR;
  PFWREC.SY2CLRID = PFGREC.SY2CLRID;
  PFWREC.XDMCD = PFGREC.XDMCD;
  PFWREC.XQACD = PFGREC.XQACD;
  PFWREC.XLCCD = PFGREC.XLCCD;
  PFWREC.PFDCDVAL[1] = PFGREC.PFDCDVAL[1];
  PFWREC.PFDCDVAL[2] = PFGREC.PFDCDVAL[2];
  PFWREC.PFDCDVAL[3] = PFGREC.PFDCDVAL[3];
  PFWREC.PFDCDVAL[4] = PFGREC.PFDCDVAL[4];
  PFWREC.PFDCDVAL[5] = PFGREC.PFDCDVAL[5];
  PFWREC.PFDCDVAL[6] = PFGREC.PFDCDVAL[6];
  PFWREC.PFDCDVAL[7] = PFGREC.PFDCDVAL[7];

  if (PFWREC.XGPCD > " ") /* move product attribute desc. to map*/
    PFWREC.PFWPRDAT = PFDREC.PFICD[8];
    PFWIDX = 8;
    XPPF020(); /* perform generic product routine to*/
                                   /* move product*/
    PF0KW01.XGPCD = PFWREC.XGPCD;
    PF0KW01.SY1STNBR = PFWREC.SY1STNBR;
    PF0KW01.SY2CLRID = PFWREC.SY2CLRID;
    PF0KW01.XDMCD = PFWREC.XDMCD;
    PF0KW01.XQACD = PFWREC.XQACD;
    PF0KW01.XLCCD = PFWREC.XLCCD;
    PF0KW01.PF0KWF4 = "/";
    PF0KW01.PF0KWF5 = "/";
    PF0KW01.PF0KWF6 = "/";
    PF0KW01.PF0KWF7 = "/";
    PF0KW01.PF0KWF8 = "/";
    PF0KM001.PF0KMSTY = PF0KW01.PF0KWSTY;
    PF0KM002.PF0KMSTY = PF0KW01.PF0KWSTY;
    PF0KM001.PF0KMPRD = PFWREC.PFWDESC[8];
    PF0KM002.PF0KMPRD = PFWREC.PFWDESC[8];
    PF0KM001.PF0KMCLR = PFWREC.SY2CLRAB;
    PF0KM002.PF0KMCLR = PFWREC.SY2CLRAB;
  end

  PFWREC.PFWIDX = 7; /* initialize index*/

  while (PFWIDX > 0)
    if (PFWREC.PFDCDVAL[PFWIDX] > " ")
                                   /* if an attribute has data, move desc.*/
      PFWREC.PFWDESC[PFWIDX] = "NO DESC        ";
      XPPF430(); /* perform edit routine to get code*/
                                   /* value literal*/
      PF0KW01.PF0KWAD1 = PFGREC.PFDCDVAL[PFWIDX];
      PF0KW01.PF0KWAD2 = PFWREC.PFWDESC[PFWIDX];
      PF0KM001.PF0KMAVD[PFWIDX] = PF0KW01.PF0KWAVD; /* description to map*/
      PF0KM002.PF0KMAVD[PFWIDX] = PF0KW01.PF0KWAVD; /* description to map*/
    end
    PFWIDX = PFWIDX - 1;
  end
end // end PF0K210

// load summary info. to w/s area
Function PF0K220()
   /* ************************************************************/
   /* *  this process will load the summary rows from vsumry01  **/
   /* *  table to a w/s area, pf0kw02. pf0k will then display   **/
   /* *  the information in pf0kw02 on screens. first, the      **/
   /* *  process will determine what type of display record     **/
   /* *  the current summary row is and find the literal that   **/
   /* *  is used to describe the row. then, the dollar or %     **/
   /* *  columns are then stored. the valid record types are:   **/
   /* *  record #      description                              **/
   /* *  --------   ----------------------                      **/
   /* *     1       summary level items                         **/
   /* *     2       special summary level items(i.e. dirsg&a)   **/
   /* *     3       i/s group total items                       **/
   /* *     4       i/s group items                             **/
   /* *     5       ungrouped i/s items                         **/
   /* ************************************************************/

  if (PFWSUB1 == 3) /* setup third w/s entry for spaces to display*/
    PF0KW02.PF0KWLIT[PFWSUB1] = " ";
    PF0KW02.PF0KWTYP[PFWSUB1] = "1";
    PF0KW02.PF0KWC1[PFWSUB1] = 0;
    PF0KW02.PF0KWC2[PFWSUB1] = 0;
    PF0KW02.PF0KWC3[PFWSUB1] = 0;
    PF0KW02.PF0KWC4[PFWSUB1] = 0;
    PF0KW02.PF0KWC5[PFWSUB1] = 0;
    PF0KW02.PF0KWC6[PFWSUB1] = 0;
    PF0KW02.PF0KWC7[PFWSUB1] = 0;
    PF0KW02.PF0KWC8[PFWSUB1] = 0;
    PF0KW02.PF0KWC9[PFWSUB1] = 0;
    PF0KW02.PF0KWC10[PFWSUB1] = 0;
    PF0KW02.PF0KWC11[PFWSUB1] = 0;
    PF0KW02.PF0KWC12[PFWSUB1] = 0;
    PF0KW02.PF0KWC13[PFWSUB1] = 0;
    PFWSUB1 = PFWSUB1 + 1;
  end

  if (PFGREC.YISCD[2] == 0) /* this is a summary level item*/
    if (PFGREC.YTYCD == "34"
     || PFGREC.YTYCD == "38") /* if it's a special summary level*/
      PF0KW02.PF0KWTYP[PFWSUB1] = "2"; /* set record type to 2*/
    else
      PF0KW02.PF0KWTYP[PFWSUB1] = "1";
    end
    PF0KW02.PF0KWIND[PFWSUB1] = " ";
    if (PFGREC.YTYCD in YTYTBL.YTYCD) /* move in summary literal*/
      PF0KW02.PF0KWABV[PFWSUB1] = YTYTBL.YTYSDESC[sysVar.arrayIndex];
    end
    PF0K230(); /* perform routine to move columnar*/
                                   /* info.*/
    return;
  end

  if (PFGREC.YISCD[1] == 0 /* this is an i/s grouped total item*/
   && PFGREC.YISCD[2] > 0)
    PF0KW02.PF0KWTYP[PFWSUB1] = "3";
    PF0KW02.YISCD[PFWSUB1] = PFGREC.YISCD[2];
    PF0KW02.PF0KWIND[PFWSUB1] = "*";
    PF0K230(); /* move columnar info. to pf0kw02 w/s area*/
    return;
  end

  if (PFGREC.PFBISGRP > 0 /* this is a grouped item*/
   && PFGREC.YISCD[1] > 0)
    PF0KW02.PF0KWTYP[PFWSUB1] = "4"; /* set record type to 4*/
    PF0KW02.YISCD[PFWSUB1] = PFGREC.YISCD[1];
    PF0KW02.PF0KWIND[PFWSUB1] = "-";
    if (PFGREC.YISCD[1] in YISTBL.YISCD)
      PF0KW02.PF0KWABV[PFWSUB1] = YISTBL.YISABRV[sysVar.arrayIndex];
    end
    PF0K230(); /* perform routine to move columnar*/
                                   /* info.*/
    return;
  end

  if (PFGREC.PFBISGRP == 0) /* this is a ungrouped item*/
    PF0KW02.PF0KWTYP[PFWSUB1] = "5"; /* set record type to 5*/
    PF0KW02.PF0KWIND[PFWSUB1] = " ";
    if (PFGREC.YISCD[1] in YISTBL.YISCD)
      PF0KW02.PF0KWABV[PFWSUB1] = YISTBL.YISABRV[sysVar.arrayIndex];
    end
    PF0K230(); /* perform routine to move columnar*/
                                   /* info.*/
    return;
  end
end // end PF0K220

// move columnar data to w/s
Function PF0K230()
   /* *****************************************************/
   /* *  this process will move the thirteen columns of  **/
   /* *  unit/dollar/percentage information from pfgrec  **/
   /* *  to the pf0kw02 w/s area.                        **/
   /* *****************************************************/
  if (PFGREC.YTYCD == "72"
   || PFGREC.YTYCD == "73")
    PF0KW01.PF0KWNUM = PFGREC.PFGQTY[1];
    if (PF0KW01.PF0KWNUM >= +999500.00)
      PF0KW02.PF0KWC1[PFWSUB1] = +999;
    else
      if (PF0KW01.PF0KWNUM <= -99500.00)
        PF0KW02.PF0KWC1[PFWSUB1] = -99;
      else
        PF0KW02.PF0KWC1[PFWSUB1] = mathLib.round(PF0KW01.PF0KWNUM * .001, -mathLib.decimals(PF0KW02.PF0KWC1[PFWSUB1]));
      end
    end
    PF0KW01.PF0KWNUM = PFGREC.PFGQTY[2];
    if (PF0KW01.PF0KWNUM >= +999.95)
      PF0KW02.PF0KWC2[PFWSUB1] = +999.9;
    else
      if (PF0KW01.PF0KWNUM <= -99.95)
        PF0KW02.PF0KWC2[PFWSUB1] = -99.9;
      else
        PF0KW02.PF0KWC2[PFWSUB1] = mathLib.round(PF0KW01.PF0KWNM2 * 1, -mathLib.decimals(PF0KW02.PF0KWC2[PFWSUB1]));
      end
    end
    PF0KW01.PF0KWNUM = PFGREC.PFGQTY[3];
    if (PF0KW01.PF0KWNUM >= +999500.00)
      PF0KW02.PF0KWC3[PFWSUB1] = +999;
    else
      if (PF0KW01.PF0KWNUM <= -99500.00)
        PF0KW02.PF0KWC3[PFWSUB1] = -99;
      else
        PF0KW02.PF0KWC3[PFWSUB1] = mathLib.round(PF0KW01.PF0KWNUM * .001, -mathLib.decimals(PF0KW02.PF0KWC3[PFWSUB1]));
      end
    end
    PF0KW01.PF0KWNUM = PFGREC.PFGQTY[4];
    if (PF0KW01.PF0KWNUM >= +999500.00)
      PF0KW02.PF0KWC4[PFWSUB1] = +999;
    else
      if (PF0KW01.PF0KWNUM <= -99500.00)
        PF0KW02.PF0KWC4[PFWSUB1] = -99;
      else
        PF0KW02.PF0KWC4[PFWSUB1] = mathLib.round(PF0KW01.PF0KWNUM * .001, -mathLib.decimals(PF0KW02.PF0KWC4[PFWSUB1]));
      end
    end
    PF0KW01.PF0KWNUM = PFGREC.PFGQTY[5];
    if (PF0KW01.PF0KWNUM >= +999500.00)
      PF0KW02.PF0KWC5[PFWSUB1] = +999;
    else
      if (PF0KW01.PF0KWNUM <= -99500.00)
        PF0KW02.PF0KWC5[PFWSUB1] = -99;
      else
        PF0KW02.PF0KWC5[PFWSUB1] = mathLib.round(PF0KW01.PF0KWNUM * .001, -mathLib.decimals(PF0KW02.PF0KWC5[PFWSUB1]));
      end
    end
    PF0KW01.PF0KWNUM = PFGREC.PFGQTY[6];
    if (PF0KW01.PF0KWNUM >= +999.95)
      PF0KW02.PF0KWC6[PFWSUB1] = +999.9;
    else
      if (PF0KW01.PF0KWNUM <= -99.95)
        PF0KW02.PF0KWC6[PFWSUB1] = -99.9;
      else
        PF0KW02.PF0KWC6[PFWSUB1] = mathLib.round(PF0KW01.PF0KWNM2 * 1, -mathLib.decimals(PF0KW02.PF0KWC6[PFWSUB1]));
      end
    end
    PF0KW01.PF0KWNUM = PFGREC.PFGQTY[7];
    if (PF0KW01.PF0KWNUM >= +999500.00)
      PF0KW02.PF0KWC7[PFWSUB1] = +999;
    else
      if (PF0KW01.PF0KWNUM <= -99500.00)
        PF0KW02.PF0KWC7[PFWSUB1] = -99;
      else
        PF0KW02.PF0KWC7[PFWSUB1] = mathLib.round(PF0KW01.PF0KWNUM * .001, -mathLib.decimals(PF0KW02.PF0KWC7[PFWSUB1]));
      end
    end
    PF0KW01.PF0KWNUM = PFGREC.PFGQTY[8];
    if (PF0KW01.PF0KWNUM >= +999.95)
      PF0KW02.PF0KWC8[PFWSUB1] = +999.9;
    else
      if (PF0KW01.PF0KWNUM <= -99.95)
        PF0KW02.PF0KWC8[PFWSUB1] = -99.9;
      else
        PF0KW02.PF0KWC8[PFWSUB1] = mathLib.round(PF0KW01.PF0KWNM2 * 1, -mathLib.decimals(PF0KW02.PF0KWC8[PFWSUB1]));
      end
    end
    PF0KW01.PF0KWNUM = PFGREC.PFGQTY[9];
    if (PF0KW01.PF0KWNUM >= +999500.00)
      PF0KW02.PF0KWC9[PFWSUB1] = +999;
    else
      if (PF0KW01.PF0KWNUM <= -99500.00)
        PF0KW02.PF0KWC9[PFWSUB1] = -99;
      else
        PF0KW02.PF0KWC9[PFWSUB1] = mathLib.round(PF0KW01.PF0KWNUM * .001, -mathLib.decimals(PF0KW02.PF0KWC9[PFWSUB1]));
      end
    end
    PF0KW01.PF0KWNUM = PFGREC.PFGQTY[10];
    if (PF0KW01.PF0KWNUM >= +999500.00)
      PF0KW02.PF0KWC10[PFWSUB1] = +999;
    else
      if (PF0KW01.PF0KWNUM <= -99500.00)
        PF0KW02.PF0KWC10[PFWSUB1] = -99;
      else
        PF0KW02.PF0KWC10[PFWSUB1] = mathLib.round(PF0KW01.PF0KWNUM * .001, -mathLib.decimals(PF0KW02.PF0KWC10[PFWSUB1]));
      end
    end
    PF0KW01.PF0KWNUM = PFGREC.PFGQTY[11];
    if (PF0KW01.PF0KWNUM >= +999500.00)
      PF0KW02.PF0KWC11[PFWSUB1] = +999;
    else
      if (PF0KW01.PF0KWNUM <= -99500.00)
        PF0KW02.PF0KWC11[PFWSUB1] = -99;
      else
        PF0KW02.PF0KWC11[PFWSUB1] = mathLib.round(PF0KW01.PF0KWNUM * .001, -mathLib.decimals(PF0KW02.PF0KWC11[PFWSUB1]));
      end
    end
    PF0KW01.PF0KWNUM = PFGREC.PFGQTY[12];
    if (PF0KW01.PF0KWNUM >= +999.95)
      PF0KW02.PF0KWC12[PFWSUB1] = +999.9;
    else
      if (PF0KW01.PF0KWNUM <= -99.95)
        PF0KW02.PF0KWC12[PFWSUB1] = -99.9;
      else
        PF0KW02.PF0KWC12[PFWSUB1] = mathLib.round(PF0KW01.PF0KWNM2 * 1, -mathLib.decimals(PF0KW02.PF0KWC12[PFWSUB1]));
      end
    end
    PF0KW01.PF0KWNUM = PFGREC.PFGQTY[13];
    if (PF0KW01.PF0KWNUM >= +999.95)
      PF0KW02.PF0KWC13[PFWSUB1] = +999.9;
    else
      if (PF0KW01.PF0KWNUM <= -99.95)
        PF0KW02.PF0KWC13[PFWSUB1] = -99.9;
      else
        PF0KW02.PF0KWC13[PFWSUB1] = mathLib.round(PF0KW01.PF0KWNM2 * 1, -mathLib.decimals(PF0KW02.PF0KWC13[PFWSUB1]));
      end
    end
  else
    PF0KW01.PF0KWNUM = PFGREC.PFGQTY[1];
    PF0KW02.PF0KWC1[PFWSUB1] = mathLib.round(PF0KW01.PF0KWNUM * .001, -mathLib.decimals(PF0KW02.PF0KWC1[PFWSUB1]));
    PF0KW01.PF0KWNUM = PFGREC.PFGQTY[2];
    if (PF0KW01.PF0KWNUM >= +999.95)
      PF0KW02.PF0KWC2[PFWSUB1] = +999.9;
    else
      if (PF0KW01.PF0KWNUM <= -99.95)
        PF0KW02.PF0KWC2[PFWSUB1] = -99.9;
      else
        PF0KW02.PF0KWC2[PFWSUB1] = mathLib.round(PF0KW01.PF0KWNM2 * 1, -mathLib.decimals(PF0KW02.PF0KWC2[PFWSUB1]));
      end
    end
    PF0KW01.PF0KWNUM = PFGREC.PFGQTY[3];
    PF0KW02.PF0KWC3[PFWSUB1] = mathLib.round(PF0KW01.PF0KWNUM * .001, -mathLib.decimals(PF0KW02.PF0KWC3[PFWSUB1]));
    PF0KW01.PF0KWNUM = PFGREC.PFGQTY[4];
    PF0KW02.PF0KWC4[PFWSUB1] = mathLib.round(PF0KW01.PF0KWNUM * .001, -mathLib.decimals(PF0KW02.PF0KWC4[PFWSUB1]));
    PF0KW01.PF0KWNUM = PFGREC.PFGQTY[5];
    PF0KW02.PF0KWC5[PFWSUB1] = mathLib.round(PF0KW01.PF0KWNUM * .001, -mathLib.decimals(PF0KW02.PF0KWC5[PFWSUB1]));
    PF0KW01.PF0KWNUM = PFGREC.PFGQTY[6];
    if (PF0KW01.PF0KWNUM >= +999.95)
      PF0KW02.PF0KWC6[PFWSUB1] = +999.9;
    else
      if (PF0KW01.PF0KWNUM <= -99.95)
        PF0KW02.PF0KWC6[PFWSUB1] = -99.9;
      else
        PF0KW02.PF0KWC6[PFWSUB1] = mathLib.round(PF0KW01.PF0KWNM2 * 1, -mathLib.decimals(PF0KW02.PF0KWC6[PFWSUB1]));
      end
    end
    PF0KW01.PF0KWNUM = PFGREC.PFGQTY[7];
    PF0KW02.PF0KWC7[PFWSUB1] = mathLib.round(PF0KW01.PF0KWNUM * .001, -mathLib.decimals(PF0KW02.PF0KWC7[PFWSUB1]));
    PF0KW01.PF0KWNUM = PFGREC.PFGQTY[8];
    if (PF0KW01.PF0KWNUM >= +999.95)
      PF0KW02.PF0KWC8[PFWSUB1] = +999.9;
    else
      if (PF0KW01.PF0KWNUM <= -99.95)
        PF0KW02.PF0KWC8[PFWSUB1] = -99.9;
      else
        PF0KW02.PF0KWC8[PFWSUB1] = mathLib.round(PF0KW01.PF0KWNM2 * 1, -mathLib.decimals(PF0KW02.PF0KWC8[PFWSUB1]));
      end
    end
    PF0KW01.PF0KWNUM = PFGREC.PFGQTY[9];
    PF0KW02.PF0KWC9[PFWSUB1] = mathLib.round(PF0KW01.PF0KWNUM * .001, -mathLib.decimals(PF0KW02.PF0KWC9[PFWSUB1]));
    PF0KW01.PF0KWNUM = PFGREC.PFGQTY[10];
    PF0KW02.PF0KWC10[PFWSUB1] = mathLib.round(PF0KW01.PF0KWNUM * .001, -mathLib.decimals(PF0KW02.PF0KWC10[PFWSUB1]));
    PF0KW01.PF0KWNUM = PFGREC.PFGQTY[11];
    PF0KW02.PF0KWC11[PFWSUB1] = mathLib.round(PF0KW01.PF0KWNUM * .001, -mathLib.decimals(PF0KW02.PF0KWC11[PFWSUB1]));
    PF0KW01.PF0KWNUM = PFGREC.PFGQTY[12];
    if (PF0KW01.PF0KWNUM >= +999.95)
      PF0KW02.PF0KWC12[PFWSUB1] = +999.9;
    else
      if (PF0KW01.PF0KWNUM <= -99.95)
        PF0KW02.PF0KWC12[PFWSUB1] = -99.9;
      else
        PF0KW02.PF0KWC12[PFWSUB1] = mathLib.round(PF0KW01.PF0KWNM2 * 1, -mathLib.decimals(PF0KW02.PF0KWC12[PFWSUB1]));
      end
    end
    PF0KW01.PF0KWNUM = PFGREC.PFGQTY[13];
    if (PF0KW01.PF0KWNUM >= +999.95)
      PF0KW02.PF0KWC13[PFWSUB1] = +999.9;
    else
      if (PF0KW01.PF0KWNUM <= -99.95)
        PF0KW02.PF0KWC13[PFWSUB1] = -99.9;
      else
        PF0KW02.PF0KWC13[PFWSUB1] = mathLib.round(PF0KW01.PF0KWNM2 * 1, -mathLib.decimals(PF0KW02.PF0KWC13[PFWSUB1]));
      end
    end
  end
end // end PF0K230

// get i/s group descriptions
Function PF0K240()
   /* *********************************************************/
   /* *  this process will scan through the pf0kw02 storage  **/
   /* *  and will get the i/s group descriptions for all i/s **/
   /* *  group total entires in pf0kw02(record type  = 3).   **/
   /* *  the i/s group desc. will be obtained by using the   **/
   /* *  yiscd of the record immediately following the group **/
   /* *  total record. this yiscd is combined with the i/s   **/
   /* *  group ref. # as a data base key to access the i/s   **/
   /* *  group table.                                        **/
   /* *********************************************************/

  if (PF0KW02.PF0KWTYP[PFWSUB1] != "3") /* if the entry isn't a group total,*/
    return; /* exit the routine*/
  end

  PFWSUB2 = PFWSUB1 + 1; /* set subscript to entry immediately following*/

  set SQLCA empty;
  set PFBREC empty;
  PFBREC.PFBREF = PFEREC.PFBREF;
                                   /* setup to access i/s group table*/
  PFBREC.YISCD[1] = PF0KW02.YISCD[PFWSUB2];
  call "IO2710" ("S ", SQLCA, PFBREC) {isNoRefresh = yes, isExternal = yes}; /* access visgrp01 table*/
  if (SQLCA.VAGen_SQLCODE == +0) /* if record found, move i/s group desc. to*/
    PF0KW02.PF0KWABV[PFWSUB1] = PFBREC.PFBISDSC; /* w/s area*/
  else
    TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
    TA1REC.TA1TBLVU = "VISGRP01";
    PF0KW01.PF0KWABK = PFBREC.PFBREF;
    TA1REC.TA1TBLKE = PF0KW01.PF0KWABK;
    TA1REC.TA1LOCAT[3] = "PF0K240";
    TA1REC.TA1LOCAT[4] = "IO2710";
    XPPF010();
  end
end // end PF0K240

// access vsumry01 table
Function PF0K260()
   /* ***********************************************************/
   /* *  this process will access the vsumry01 table using     **/
   /* *  the summary name, summary level, and summary sequence **/
   /* *  number as db2 keys. this process will be used to read **/
   /* *  the summary file in a backwards direction and will    **/
   /* *  read the first record of the requested summary only.  **/
   /* *  the level and seq. # keys will then be used by        **/
   /* *  pf0k200 to read the summary in a normal manner.       **/
   /* ***********************************************************/

  set PFGREC empty;
  set SQLCA empty;

  PFGREC.PFESUMNM = PFEREC.PFESUMNM; /* move summary name to db2 key*/
  PFGREC.PFGSUMN = PFEREC.PFGSUMN; /* move summary # to db2 key*/
  PFGREC.PFGLVLNO = PF0KW01.PF0KWSTL; /* move level # to db2 key*/
  PFGREC.PFGLVLSQ = PF0KW01.PF0KWSTS; /* move level seq # to db2 key*/

  call "IO2920" ("SF", SQLCA, PFGREC) {isNoRefresh = yes, isExternal = yes};
                                   /* read vsumry01 select/first*/

  if (SQLCA.VAGen_SQLCODE == +0) /* if cursor open ok, continue with the process*/
    PF0KW01.PF0KWSTS = PFGREC.PFGLVLSQ; /* save seq. #*/
  else
    if (SQLCA.VAGen_SQLCODE == +100)
      return;
    else
      TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
      TA1REC.TA1TBLVU = "VSUMRY01";
      TA1REC.TA1TBLKE = PF1REC.PFESUMNM;
      TA1REC.TA1LOCAT[3] = "PF0K200";
      TA1REC.TA1LOCAT[4] = "IO2920";
      XPPF010();
    end
  end

end // end PF0K260

// check for hierarchy change
Function PF0K270()
   /* ********************************************************/
   /* *  this process will check the reporting attribute    **/
   /* *  values of the previous and current summaries that  **/
   /* *  were displayed as a result of a pf20 or pf21 key.  **/
   /* *  if the result of of either key is a change in the  **/
   /* *  reporting attributes hierarchy as described below, **/
   /* *  then a warning message is sent to the terminal     **/
   /* *  operator. in the following example, if the user is **/
   /* *  viewing the summary indicated as point a and       **/
   /* *  enters pf20 (move up within a level) to move to    **/
   /* *  point b, the hierarchy level of '003 non-tech      **/
   /* *  running' has been bypassed.                        **/
   /* *  02  running                                        **/
   /* *      002  tecnical running                          **/
   /* *           21  national                              **/
   /* *           22  major                                 **/
   /* *           23  regular   ---- point b                **/
   /* *      003  non-tech running                          **/
   /* *           21  national  ---- point a                **/
   /* *           22  major                                 **/
   /* *           23  regular                               **/
   /* *  05  basketball                                     **/
   /* ********************************************************/

  if (PF0KW01.PF0KWSTL == 8) /* find current level # and compare attributes*/
    if (PF0KW01.PF0KWCD7 != PF0KW01.PF0KWCV7) /* from one level lower*/
        /* if they don't match, send warning to user*/
      PF0KW01.PF0KWRN1 = "BKWD/FRWD MOVEMENT AT \"";
      PF0KW01.PF0KWRV1 = PF1REC.PFISDESC[8];
      PF0KW01.PF0KWRN2 = "\" LEVEL HAS CAUSED \"";
      PF0KW01.PF0KWRV2 = PF1REC.PFISDESC[7];
      PF0KW01.PF0KWRN3 = "\" VALUE TO CHANGE";
      PF0KM001.VAGen_EZEMSG = PF0KW01.PF0KWRN; /* move warning message*/
      PF0KM002.VAGen_EZEMSG = PF0KW01.PF0KWRN; /* to screen*/
    end
    return;
  end

  if (PF0KW01.PF0KWSTL == 6) /* find current level # and compare attributes*/
    if (PF0KW01.PF0KWCD6 != PF0KW01.PF0KWCV6) /* from one level lower*/
        /* if they don't match, send warning to user*/
      PF0KW01.PF0KWRN1 = "BKWD/FRWD MOVEMENT AT \"";
      PF0KW01.PF0KWRV1 = PF1REC.PFISDESC[7];
      PF0KW01.PF0KWRN2 = "\" LEVEL HAS CAUSED \"";
      PF0KW01.PF0KWRV2 = PF1REC.PFISDESC[6];
      PF0KW01.PF0KWRN3 = "\" VALUE TO CHANGE";
      PF0KM001.VAGen_EZEMSG = PF0KW01.PF0KWRN; /* move warning message*/
      PF0KM002.VAGen_EZEMSG = PF0KW01.PF0KWRN; /* to screen*/
    end
    return;
  end

  if (PF0KW01.PF0KWSTL == 6) /* find current level # and compare attributes*/
    if (PF0KW01.PF0KWCD5 != PF0KW01.PF0KWCV5) /* from one level lower*/
        /* if they don't match, send warning to user*/
      PF0KW01.PF0KWRN1 = "BKWD/FRWD MOVEMENT AT \"";
      PF0KW01.PF0KWRV1 = PF1REC.PFISDESC[6];
      PF0KW01.PF0KWRN2 = "\" LEVEL HAS CAUSED \"";
      PF0KW01.PF0KWRV2 = PF1REC.PFISDESC[5];
      PF0KW01.PF0KWRN3 = "\" VALUE TO CHANGE";
      PF0KM001.VAGen_EZEMSG = PF0KW01.PF0KWRN; /* move warning message*/
      PF0KM002.VAGen_EZEMSG = PF0KW01.PF0KWRN; /* to screen*/
    end
    return;
  end

  if (PF0KW01.PF0KWSTL == 5) /* find current level # and compare attributes*/
    if (PF0KW01.PF0KWCD4 != PF0KW01.PF0KWCV4) /* from one level lower*/
        /* if they don't match, send warning to user*/
      PF0KW01.PF0KWRN1 = "BKWD/FRWD MOVEMENT AT \"";
      PF0KW01.PF0KWRV1 = PF1REC.PFISDESC[5];
      PF0KW01.PF0KWRN2 = "\" LEVEL HAS CAUSED \"";
      PF0KW01.PF0KWRV2 = PF1REC.PFISDESC[4];
      PF0KW01.PF0KWRN3 = "\" VALUE TO CHANGE";
      PF0KM001.VAGen_EZEMSG = PF0KW01.PF0KWRN; /* move warning message*/
      PF0KM002.VAGen_EZEMSG = PF0KW01.PF0KWRN; /* to screen*/
    end
    return;
  end

  if (PF0KW01.PF0KWSTL == 4) /* find current level # and compare attributes*/
    if (PF0KW01.PF0KWCD3 != PF0KW01.PF0KWCV3) /* from one level lower*/
        /* if they don't match, send warning to user*/
      PF0KW01.PF0KWRN1 = "BKWD/FRWD MOVEMENT AT \"";
      PF0KW01.PF0KWRV1 = PF1REC.PFISDESC[4];
      PF0KW01.PF0KWRN2 = "\" LEVEL HAS CAUSED \"";
      PF0KW01.PF0KWRV2 = PF1REC.PFISDESC[3];
      PF0KW01.PF0KWRN3 = "\" VALUE TO CHANGE";
      PF0KM001.VAGen_EZEMSG = PF0KW01.PF0KWRN; /* move warning message*/
      PF0KM002.VAGen_EZEMSG = PF0KW01.PF0KWRN; /* to screen*/
    end
    return;
  end

  if (PF0KW01.PF0KWSTL == 3) /* find current level # and compare attributes*/
    if (PF0KW01.PF0KWCD2 != PF0KW01.PF0KWCV2) /* from one level lower*/
        /* if they don't match, send warning to user*/
      PF0KW01.PF0KWRN1 = "BKWD/FRWD MOVEMENT AT \"";
      PF0KW01.PF0KWRV1 = PF1REC.PFISDESC[3];
      PF0KW01.PF0KWRN2 = "\" LEVEL HAS CAUSED \"";
      PF0KW01.PF0KWRV2 = PF1REC.PFISDESC[2];
      PF0KW01.PF0KWRN3 = "\" VALUE TO CHANGE";
      PF0KM001.VAGen_EZEMSG = PF0KW01.PF0KWRN; /* move warning message*/
      PF0KM002.VAGen_EZEMSG = PF0KW01.PF0KWRN; /* to screen*/
    end
    return;
  end

  if (PF0KW01.PF0KWSTL == 2) /* find current level # and compare attributes*/
    if (PF0KW01.PF0KWCD1 != PF0KW01.PF0KWCV1) /* from one level lower*/
        /* if they don't match, send warning to user*/
      PF0KW01.PF0KWRN1 = "BKWD/FRWD MOVEMENT AT \"";
      PF0KW01.PF0KWRV1 = PF1REC.PFISDESC[2];
      PF0KW01.PF0KWRN2 = "\" LEVEL HAS CAUSED \"";
      PF0KW01.PF0KWRV2 = PF1REC.PFISDESC[1];
      PF0KW01.PF0KWRN3 = "\" VALUE TO CHANGE";
      PF0KM001.VAGen_EZEMSG = PF0KW01.PF0KWRN; /* move warning message*/
      PF0KM002.VAGen_EZEMSG = PF0KW01.PF0KWRN; /* to screen*/
    end
    return;
  end

end // end PF0K270

// display summary type
Function PF0K300()
   /* ************************************************************/
   /* *  this process will determine the type of summary a user **/
   /* *  is viewing and will perform the appropriate routine to **/
   /* *  move summary records to the maps. the routines are :   **/
   /* *  summary type     routine                               **/
   /* *  ------------     -------------                         **/
   /* *    'sum'          pf0k310                               **/
   /* *    'det'          pf0k320                               **/
   /* *    'exp'          pf0k330                               **/
   /* ************************************************************/

  if (PF0KW01.PF0KWDSP == "SUM") /* summary display*/
    PF0K310();
  else
    if (PF0KW01.PF0KWDSP == "DET") /* detail display*/
      PF0K320();
    else
      if (PF0KW01.PF0KWDSP == "EXP") /* explode display*/
        PF0K330();
      end
    end
  end
end // end PF0K300

// move 'summary' items to maps
Function PF0K310()
   /* ***************************************************/
   /* *   this process will move all 'summary' items   **/
   /* *   from pf0kw02 record to the maps. summary     **/
   /* *   items are identified by the field pf0kwtyp   **/
   /* *   being = 1. the summary display will use one  **/
   /* *   screen only; no scrolling will be allowed.   **/
   /* *   both the right side(pf0km001) and the left   **/
   /* *   side(pf0km002) of the display will be        **/
   /* *   loaded in this process. the user can scroll  **/
   /* *   right and left using pf10 and pf11.          **/
   /* ***************************************************/

  PF0K340(); /* clear maps of previous data*/

  PFWREC.PFWSAVDX = PFWREC.PFWSUB1; /* save first w/s position*/

  PFWSUB2 = 1;

  while (PFWSUB2 < 11) /* browse through pf0kw02 and move all*/
    if (PF0KW02.PF0KWTYP[PFWSUB1] == "1") /* summary records to the maps*/
      PF0KM001.PF0KMISD[PFWSUB2] = PF0KW02.PF0KWLIT[PFWSUB1];
      PF0KM002.PF0KMISD[PFWSUB2] = PF0KW02.PF0KWLIT[PFWSUB1];

      PF0KM001.PF0KMGS1[PFWSUB2] = PF0KW02.PF0KWC1[PFWSUB1];
      PF0KM001.PF0KMGP1[PFWSUB2] = PF0KW02.PF0KWC2[PFWSUB1];
      PF0KM001.PF0KMNS1[PFWSUB2] = PF0KW02.PF0KWC5[PFWSUB1];
      PF0KM001.PF0KMNP1[PFWSUB2] = PF0KW02.PF0KWC6[PFWSUB1];
      PF0KM001.PF0KMGS2[PFWSUB2] = PF0KW02.PF0KWC7[PFWSUB1];
      PF0KM001.PF0KMGP2[PFWSUB2] = PF0KW02.PF0KWC8[PFWSUB1];
      PF0KM001.PF0KMNS2[PFWSUB2] = PF0KW02.PF0KWC11[PFWSUB1];
      PF0KM001.PF0KMNP2[PFWSUB2] = PF0KW02.PF0KWC12[PFWSUB1];

      PF0KM002.PF0KMGS1[PFWSUB2] = PF0KW02.PF0KWC1[PFWSUB1];
      PF0KM002.PF0KMRT1[PFWSUB2] = PF0KW02.PF0KWC3[PFWSUB1];
      PF0KM002.PF0KMOT1[PFWSUB2] = PF0KW02.PF0KWC4[PFWSUB1];
      PF0KM002.PF0KMGS2[PFWSUB2] = PF0KW02.PF0KWC7[PFWSUB1];
      PF0KM002.PF0KMRT2[PFWSUB2] = PF0KW02.PF0KWC9[PFWSUB1];
      PF0KM002.PF0KMOT2[PFWSUB2] = PF0KW02.PF0KWC10[PFWSUB1];
      PF0KM002.PF0KMPCT[PFWSUB2] = PF0KW02.PF0KWC13[PFWSUB1];
      PFWSUB2 = PFWSUB2 + 1; /* bump index for maps*/
    end
    PFWSUB1 = PFWSUB1 + 1; /* bump w/s index*/
    if (PFWSUB1 > PFWLIMIT)
      PFWSUB2 = 13;
    end
  end
end // end PF0K310

// move 'detail' items to maps
Function PF0K320()
   /* ***************************************************/
   /* *   this process will move all 'detail' items    **/
   /* *   from pf0kw02 record to the maps. detail      **/
   /* *   items are identified by the field pf0kwtyp   **/
   /* *   being = 1, 2, 3, or 5.  detail display will  **/
   /* *   scroll up and down the pf0kw02 w/s area.     **/
   /* *   the control of scrolling positioning will    **/
   /* *   be done by pf0kxxx.                          **/
   /* *   both the right side(pf0km001) and the left   **/
   /* *   side(pf0km002) of the display will be        **/
   /* *   loaded in this process. the user can shift   **/
   /* *   right and left using pf10 and pf11.          **/
   /* ***************************************************/

  PF0K340(); /* clear maps of previous data*/

  PFWREC.PFWSAVDX = PFWREC.PFWSUB1; /* save first w/s position*/

  PFWSUB2 = 1;

  while (PFWSUB2 < 11) /* browse through pf0kw02 and move all*/
    if (PF0KW02.PF0KWTYP[PFWSUB1] == "1" /* detail records to the maps*/
     || PF0KW02.PF0KWTYP[PFWSUB1] == "2" 
     || PF0KW02.PF0KWTYP[PFWSUB1] == "3" 
     || PF0KW02.PF0KWTYP[PFWSUB1] == "5")
      PF0KM001.PF0KMISD[PFWSUB2] = PF0KW02.PF0KWLIT[PFWSUB1];
      PF0KM002.PF0KMISD[PFWSUB2] = PF0KW02.PF0KWLIT[PFWSUB1];

      PF0KM001.PF0KMGS1[PFWSUB2] = PF0KW02.PF0KWC1[PFWSUB1];
      PF0KM001.PF0KMGP1[PFWSUB2] = PF0KW02.PF0KWC2[PFWSUB1];
      PF0KM001.PF0KMNS1[PFWSUB2] = PF0KW02.PF0KWC5[PFWSUB1];
      PF0KM001.PF0KMNP1[PFWSUB2] = PF0KW02.PF0KWC6[PFWSUB1];
      PF0KM001.PF0KMGS2[PFWSUB2] = PF0KW02.PF0KWC7[PFWSUB1];
      PF0KM001.PF0KMGP2[PFWSUB2] = PF0KW02.PF0KWC8[PFWSUB1];
      PF0KM001.PF0KMNS2[PFWSUB2] = PF0KW02.PF0KWC11[PFWSUB1];
      PF0KM001.PF0KMNP2[PFWSUB2] = PF0KW02.PF0KWC12[PFWSUB1];

      PF0KM002.PF0KMGS1[PFWSUB2] = PF0KW02.PF0KWC1[PFWSUB1];
      PF0KM002.PF0KMRT1[PFWSUB2] = PF0KW02.PF0KWC3[PFWSUB1];
      PF0KM002.PF0KMOT1[PFWSUB2] = PF0KW02.PF0KWC4[PFWSUB1];
      PF0KM002.PF0KMGS2[PFWSUB2] = PF0KW02.PF0KWC7[PFWSUB1];
      PF0KM002.PF0KMRT2[PFWSUB2] = PF0KW02.PF0KWC9[PFWSUB1];
      PF0KM002.PF0KMOT2[PFWSUB2] = PF0KW02.PF0KWC10[PFWSUB1];
      PF0KM002.PF0KMPCT[PFWSUB2] = PF0KW02.PF0KWC13[PFWSUB1];
      PFWSUB2 = PFWSUB2 + 1; /* bump index for maps*/
    end
    PFWSUB1 = PFWSUB1 + 1; /* bump w/s index*/
    if (PFWSUB1 > PFWLIMIT) /* if w/s end reached,*/
      PFWSUB2 = 13;
    end
  end

  PFWREC.PFWNXTDX = PFWREC.PFWSUB1; /* save next available index*/
end // end PF0K320

// move 'explode' items to maps
Function PF0K330()
   /* ***************************************************/
   /* *   this process will move all 'explode' items   **/
   /* *   from pf0kw02 record to the maps. explode     **/
   /* *   items are identified by the field pf0kwtyp   **/
   /* *   being = 1, 2, 4, or 5.  detail display will  **/
   /* *   scroll up and down the pf0kw02 w/s area.     **/
   /* *   the control of scrolling positioning will    **/
   /* *   be done by pf0kxxx.                          **/
   /* *   both the right side(pf0km001) and the left   **/
   /* *   side(pf0km002) of the display will be        **/
   /* *   loaded in this process. the user can shift   **/
   /* *   right and left using pf10 and pf11.          **/
   /* ***************************************************/

  PF0K340(); /* clear maps of previous data*/

  PFWREC.PFWSAVDX = PFWREC.PFWSUB1; /* save first w/s position*/

  PFWSUB2 = 1;

  while (PFWSUB2 < 11) /* browse through pf0kw02 and move all*/
    if (PF0KW02.PF0KWTYP[PFWSUB1] == "1" /* explode records to the maps*/
     || PF0KW02.PF0KWTYP[PFWSUB1] == "2" 
     || PF0KW02.PF0KWTYP[PFWSUB1] == "4" 
     || PF0KW02.PF0KWTYP[PFWSUB1] == "5")
      PF0KM001.PF0KMISD[PFWSUB2] = PF0KW02.PF0KWLIT[PFWSUB1];
      PF0KM002.PF0KMISD[PFWSUB2] = PF0KW02.PF0KWLIT[PFWSUB1];

      PF0KM001.PF0KMGS1[PFWSUB2] = PF0KW02.PF0KWC1[PFWSUB1];
      PF0KM001.PF0KMGP1[PFWSUB2] = PF0KW02.PF0KWC2[PFWSUB1];
      PF0KM001.PF0KMNS1[PFWSUB2] = PF0KW02.PF0KWC5[PFWSUB1];
      PF0KM001.PF0KMNP1[PFWSUB2] = PF0KW02.PF0KWC6[PFWSUB1];
      PF0KM001.PF0KMGS2[PFWSUB2] = PF0KW02.PF0KWC7[PFWSUB1];
      PF0KM001.PF0KMGP2[PFWSUB2] = PF0KW02.PF0KWC8[PFWSUB1];
      PF0KM001.PF0KMNS2[PFWSUB2] = PF0KW02.PF0KWC11[PFWSUB1];
      PF0KM001.PF0KMNP2[PFWSUB2] = PF0KW02.PF0KWC12[PFWSUB1];

      PF0KM002.PF0KMGS1[PFWSUB2] = PF0KW02.PF0KWC1[PFWSUB1];
      PF0KM002.PF0KMRT1[PFWSUB2] = PF0KW02.PF0KWC3[PFWSUB1];
      PF0KM002.PF0KMOT1[PFWSUB2] = PF0KW02.PF0KWC4[PFWSUB1];
      PF0KM002.PF0KMGS2[PFWSUB2] = PF0KW02.PF0KWC7[PFWSUB1];
      PF0KM002.PF0KMRT2[PFWSUB2] = PF0KW02.PF0KWC9[PFWSUB1];
      PF0KM002.PF0KMOT2[PFWSUB2] = PF0KW02.PF0KWC10[PFWSUB1];
      PF0KM002.PF0KMPCT[PFWSUB2] = PF0KW02.PF0KWC13[PFWSUB1];
      PFWSUB2 = PFWSUB2 + 1; /* bump index for maps*/
    end
    PFWSUB1 = PFWSUB1 + 1; /* bump w/s index*/
    if (PFWSUB1 > PFWLIMIT) /* if w/s end reached, end the routine*/
      PFWSUB2 = 13;
    end
  end

  PFWREC.PFWNXTDX = PFWREC.PFWSUB1; /* save next w/s position*/
end // end PF0K330

// clear screens
Function PF0K340()

  PFWSUB2 = 1;

  while (PFWSUB2 < 11)
    PF0KM001.PF0KMISD[PFWSUB2] = " ";
    PF0KM002.PF0KMISD[PFWSUB2] = " ";
    PF0KM001.PF0KMGS1[PFWSUB2] = 0;
    PF0KM001.PF0KMGP1[PFWSUB2] = 0;
    PF0KM001.PF0KMNS1[PFWSUB2] = 0;
    PF0KM001.PF0KMNP1[PFWSUB2] = 0;
    PF0KM001.PF0KMGS2[PFWSUB2] = 0;
    PF0KM001.PF0KMGP2[PFWSUB2] = 0;
    PF0KM001.PF0KMNS2[PFWSUB2] = 0;
    PF0KM001.PF0KMNP2[PFWSUB2] = 0;
    PF0KM002.PF0KMGS1[PFWSUB2] = 0;
    PF0KM002.PF0KMRT1[PFWSUB2] = 0;
    PF0KM002.PF0KMOT1[PFWSUB2] = 0;
    PF0KM002.PF0KMGS2[PFWSUB2] = 0;
    PF0KM002.PF0KMRT2[PFWSUB2] = 0;
    PF0KM002.PF0KMOT2[PFWSUB2] = 0;
    PF0KM002.PF0KMPCT[PFWSUB2] = 0;
    PFWSUB2 = PFWSUB2 + 1;
  end

end // end PF0K340

// scroll backwards thru 'det'
Function PF0K350()
   /* *****************************************************/
   /* *  this routine is nearly identical to pf0k320.    **/
   /* *  the difference is that this routine will scroll **/
   /* *  backwards through the w/s area, pf0kw02, by     **/
   /* *  decrementing the storage and screen subscripts. **/
   /* *  if the w/s subscript reaches zero after being   **/
   /* *  decremented, it is set to 1 and the scroll      **/
   /* *  forward routine, pf0k320, is performed.         **/
   /* *****************************************************/

  if (PFWSUB1 < 1)
    converseLib.validationFailed(085);
    return;
  end

  PF0K340(); /* clear maps of previous data*/


  PFWREC.PFWNXTDX = PFWREC.PFWSUB1; /* save last w/s position*/

  PFWSUB2 = 10;

  while (PFWSUB2 > 0) /* browse backwards through pf0kw02 and move all*/
    if (PF0KW02.PF0KWTYP[PFWSUB1] == "1" /* detail records to the maps*/
     || PF0KW02.PF0KWTYP[PFWSUB1] == "2" 
     || PF0KW02.PF0KWTYP[PFWSUB1] == "3" 
     || PF0KW02.PF0KWTYP[PFWSUB1] == "5")
      PF0KM001.PF0KMISD[PFWSUB2] = PF0KW02.PF0KWLIT[PFWSUB1];
      PF0KM002.PF0KMISD[PFWSUB2] = PF0KW02.PF0KWLIT[PFWSUB1];

      PF0KM001.PF0KMGS1[PFWSUB2] = PF0KW02.PF0KWC1[PFWSUB1];
      PF0KM001.PF0KMGP1[PFWSUB2] = PF0KW02.PF0KWC2[PFWSUB1];
      PF0KM001.PF0KMNS1[PFWSUB2] = PF0KW02.PF0KWC5[PFWSUB1];
      PF0KM001.PF0KMNP1[PFWSUB2] = PF0KW02.PF0KWC6[PFWSUB1];
      PF0KM001.PF0KMGS2[PFWSUB2] = PF0KW02.PF0KWC7[PFWSUB1];
      PF0KM001.PF0KMGP2[PFWSUB2] = PF0KW02.PF0KWC8[PFWSUB1];
      PF0KM001.PF0KMNS2[PFWSUB2] = PF0KW02.PF0KWC11[PFWSUB1];
      PF0KM001.PF0KMNP2[PFWSUB2] = PF0KW02.PF0KWC12[PFWSUB1];

      PF0KM002.PF0KMGS1[PFWSUB2] = PF0KW02.PF0KWC1[PFWSUB1];
      PF0KM002.PF0KMRT1[PFWSUB2] = PF0KW02.PF0KWC3[PFWSUB1];
      PF0KM002.PF0KMOT1[PFWSUB2] = PF0KW02.PF0KWC4[PFWSUB1];
      PF0KM002.PF0KMGS2[PFWSUB2] = PF0KW02.PF0KWC7[PFWSUB1];
      PF0KM002.PF0KMRT2[PFWSUB2] = PF0KW02.PF0KWC9[PFWSUB1];
      PF0KM002.PF0KMOT2[PFWSUB2] = PF0KW02.PF0KWC10[PFWSUB1];
      PF0KM002.PF0KMPCT[PFWSUB2] = PF0KW02.PF0KWC13[PFWSUB1];
      PFWSUB2 = PFWSUB2 - 1; /* decrement index for maps*/
    end
    PFWSUB1 = PFWSUB1 - 1; /* decrement w/s index*/
    if (PFWSUB1 <= 1) /* if w/s end reached,*/
      converseLib.validationFailed(085);
      PFWSUB1 = 1;
      PFWSUB2 = 1;
      PF0K320();
      return;
    end
  end

  PFWREC.PFWSAVDX = PFWREC.PFWSUB1; /* save first w/s index*/
end // end PF0K350

// scroll backwards thru 'exp'
Function PF0K360()
   /* *****************************************************/
   /* *  this routine is nearly identical to pf0k330.    **/
   /* *  the difference is that this routine will scroll **/
   /* *  backwards through the w/s area, pf0kw02, by     **/
   /* *  decrementing the storage and screen subscripts. **/
   /* *  if the w/s subscript reaches zero after being   **/
   /* *  decremented, it is set to 1 and the scroll      **/
   /* *  forward routine, pf0k330, is performed.         **/
   /* *****************************************************/

  if (PFWSUB1 < 1)
    converseLib.validationFailed(085);
    return;
  end

  PF0K340(); /* clear maps of previous data*/

  PFWREC.PFWNXTDX = PFWREC.PFWSUB1; /* save first w/s position*/

  PFWSUB2 = 10;

  while (PFWSUB2 > 0) /* browse backwards through pf0kw02 and move all*/
    if (PF0KW02.PF0KWTYP[PFWSUB1] == "1" /* explode records to the maps*/
     || PF0KW02.PF0KWTYP[PFWSUB1] == "2" 
     || PF0KW02.PF0KWTYP[PFWSUB1] == "4" 
     || PF0KW02.PF0KWTYP[PFWSUB1] == "5")
      PF0KM001.PF0KMISD[PFWSUB2] = PF0KW02.PF0KWLIT[PFWSUB1];
      PF0KM002.PF0KMISD[PFWSUB2] = PF0KW02.PF0KWLIT[PFWSUB1];

      PF0KM001.PF0KMGS1[PFWSUB2] = PF0KW02.PF0KWC1[PFWSUB1];
      PF0KM001.PF0KMGP1[PFWSUB2] = PF0KW02.PF0KWC2[PFWSUB1];
      PF0KM001.PF0KMNS1[PFWSUB2] = PF0KW02.PF0KWC5[PFWSUB1];
      PF0KM001.PF0KMNP1[PFWSUB2] = PF0KW02.PF0KWC6[PFWSUB1];
      PF0KM001.PF0KMGS2[PFWSUB2] = PF0KW02.PF0KWC7[PFWSUB1];
      PF0KM001.PF0KMGP2[PFWSUB2] = PF0KW02.PF0KWC8[PFWSUB1];
      PF0KM001.PF0KMNS2[PFWSUB2] = PF0KW02.PF0KWC11[PFWSUB1];
      PF0KM001.PF0KMNP2[PFWSUB2] = PF0KW02.PF0KWC12[PFWSUB1];

      PF0KM002.PF0KMGS1[PFWSUB2] = PF0KW02.PF0KWC1[PFWSUB1];
      PF0KM002.PF0KMRT1[PFWSUB2] = PF0KW02.PF0KWC3[PFWSUB1];
      PF0KM002.PF0KMOT1[PFWSUB2] = PF0KW02.PF0KWC4[PFWSUB1];
      PF0KM002.PF0KMGS2[PFWSUB2] = PF0KW02.PF0KWC7[PFWSUB1];
      PF0KM002.PF0KMRT2[PFWSUB2] = PF0KW02.PF0KWC9[PFWSUB1];
      PF0KM002.PF0KMOT2[PFWSUB2] = PF0KW02.PF0KWC10[PFWSUB1];
      PF0KM002.PF0KMPCT[PFWSUB2] = PF0KW02.PF0KWC13[PFWSUB1];
      PFWSUB2 = PFWSUB2 - 1; /* decrement index for maps*/
    end
    PFWSUB1 = PFWSUB1 - 1; /* decrement w/s index*/
    if (PFWSUB1 <= 1) /* if w/s end reached,*/
      converseLib.validationFailed(085);
      PFWSUB1 = 1;
      PFWSUB2 = 1;
      PF0K330();
      return;
    end
  end

  PFWREC.PFWSAVDX = PFWREC.PFWSUB1; /* save first w/s position*/
end // end PF0K360

//*** RECORD=PF0KW01 ****
// miscellaneous w/s area for pf0k application.
// ***********************
Record PF0KW01 type basicRecord
  10 PF0KWLT1 PF0KWLT1 ; 
    15 PF0KWDT1 PF0KWDT1 ; 
    15 PF0KWTP1 PF0KWTP1 ; 
  10 PF0KWLT2 PF0KWLT2 ; 
    15 PF0KWDT2 PF0KWDT2 ; 
    15 PF0KWTP2 PF0KWTP2 ; 
  10 PF0KWCL1 PF0KWCL1 ; 
    15 PF0KWDT3 PF0KWDT3 ; 
    15 PF0KWF1 PF0KWF1 ; 
    15 PF0KWTP3 PF0KWTP3 ; 
  10 PF0KWCL2 PF0KWCL2 ; 
    15 PF0KWDT4 PF0KWDT4 ; 
    15 PF0KWF2 PF0KWF2 ; 
    15 PF0KWTP4 PF0KWTP4 ; 
  10 PF0KWABK PF0KWABK ; 
    15 PF0KWAB2 PF0KWAB2 ; 
  10 PF0KWSTL PF0KWSTL ; 
  10 PF0KWSTS PF0KWSTS ; 
  10 PF0KWDSP PF0KWDSP ; 
  10 PF0KWHDP PF0KWHDP ; 
  10 PF0KWLEF PF0KWLEF ; 
  10 PF0KWRIG PF0KWRIG ; 
  10 PF0KWPFK PF0KWPFK ; 
    15 PF0KWKY1 PF0KWKY1 ; 
    15 PF0KWDP1 PF0KWDP1 ; 
    15 PF0KWKY2 PF0KWKY2 ; 
    15 PF0KWDP2 PF0KWDP2 ; 
  10 PF0KWFLG PF0KWFLG ; 
  10 PF0KWAVA PF0KWAVA ; 
    15 PF0KWAV1 PF0KWAV1 ; 
    15 PF0KWAV2 PF0KWAV2 ; 
  10 PF0KWAVD PF0KWAVD ; 
    15 PF0KWAD1 PF0KWAD1 ; 
    15 PF0KWAD2 PF0KWAD2 ; 
  10 PF0KWNUM PF0KWNUM ; 
    15 PF0KWNM1 PF0KWNM1 ; 
    15 PF0KWNM2 PF0KWNM2 ; 
  10 PF0KWFL1 PF0KWFL1 ; 
    15 PF0KWCD1 PF0KWCD1 ; 
    15 PF0KWCD2 PF0KWCD2 ; 
    15 PF0KWCD3 PF0KWCD3 ; 
    15 PF0KWCD4 PF0KWCD4 ; 
    15 PF0KWCD5 PF0KWCD5 ; 
    15 PF0KWCD6 PF0KWCD6 ; 
    15 PF0KWCD7 PF0KWCD7 ; 
  10 PF0KWFL2 PF0KWFL2 ; 
    15 PF0KWCV1 PF0KWCV1 ; 
    15 PF0KWCV2 PF0KWCV2 ; 
    15 PF0KWCV3 PF0KWCV3 ; 
    15 PF0KWCV4 PF0KWCV4 ; 
    15 PF0KWCV5 PF0KWCV5 ; 
    15 PF0KWCV6 PF0KWCV6 ; 
    15 PF0KWCV7 PF0KWCV7 ; 
  10 PF0KWSTY PF0KWSTY ; 
    15 XGPCD XGPCD ; 
    15 PF0KWF4 PF0KWF4 ; 
    15 SY1STNBR SY1STNBR ; 
    15 PF0KWF5 PF0KWF5 ; 
    15 SY2CLRID SY2CLRID ; 
    15 PF0KWF6 PF0KWF6 ; 
    15 XDMCD XDMCD ; 
    15 PF0KWF7 PF0KWF7 ; 
    15 XQACD XQACD ; 
    15 PF0KWF8 PF0KWF8 ; 
    15 XLCCD XLCCD ; 
  10 PF0KWRN PF0KWRN ; 
    15 PF0KWRN1 PF0KWRN1 ; 
    15 PF0KWRV1 PF0KWRV1 ; 
    15 PF0KWRN2 PF0KWRN2 ; 
    15 PF0KWRV2 PF0KWRV2 ; 
    15 PF0KWRN3 PF0KWRN3 ; 
end // end PF0KW01

//*** RECORD=PF0KW02 ****
// this w/s area is used to store rows of summary information
// to be displayed in this application. the rows are identified
// by the field pf0kwtyp as follows :
//  value          summary row type
// -------         --------------------------
//    1            summary total item (net rev.,etc.)
//    2            special summary total (dir sg&a, ind sg&a)
//    3            i/s grouped total
//    4            i/s grouped item
//    5            i/s ungrouped item
// 
// 
//  MAINTENANCE LOG:
//  DATE     INIT    Comments:
// --------  ------  ------------------------
// 06/13/91  CVO     Increased group level entries on ws from
//                   200 to 500.
// 
// ***********************
Record PF0KW02 type basicRecord
  5 PF0KWGRP PF0KWGRP [500] ; 
    10 YISCD YISCD ; 
    10 PF0KWLIT PF0KWLIT ; 
      15 PF0KWIND PF0KWIND ; 
      15 PF0KWABV PF0KWABV ; 
    10 PF0KWTYP PF0KWTYP ; 
    10 PF0KWC1 PF0KWC1 ; 
    10 PF0KWC2 PF0KWC2 ; 
    10 PF0KWC3 PF0KWC3 ; 
    10 PF0KWC4 PF0KWC4 ; 
    10 PF0KWC5 PF0KWC5 ; 
    10 PF0KWC6 PF0KWC6 ; 
    10 PF0KWC7 PF0KWC7 ; 
    10 PF0KWC8 PF0KWC8 ; 
    10 PF0KWC9 PF0KWC9 ; 
    10 PF0KWC10 PF0KWC10 ; 
    10 PF0KWC11 PF0KWC11 ; 
    10 PF0KWC12 PF0KWC12 ; 
    10 PF0KWC13 PF0KWC13 ; 
end // end PF0KW02

// CHARACTER db2 abend key
DataItem PF0KWAB2 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// numeric db2 abend key
DataItem PF0KWABK num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// yis-ist-cls-abrv
DataItem PF0KWABV char(16)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. code
DataItem PF0KWAD1 char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. code literal
DataItem PF0KWAD2 char(12)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attribute literal
DataItem PF0KWAV1 char(8)  {
  align = right, fillCharacter = nullFill, inputRequired = no
}
end

// attribute char.' :'
DataItem PF0KWAV2 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attribute literal group
DataItem PF0KWAVA char(10)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. code val. literal
DataItem PF0KWAVD char(17)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dt/tp 1 grs shp amt
DataItem PF0KWC1 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp 2 other amt
DataItem PF0KWC10 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp 2 net sales amt
DataItem PF0KWC11 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp 2 net sales %
DataItem PF0KWC12 bin(4,1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// as of percentage
DataItem PF0KWC13 bin(4,1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp 1 grs shp %
DataItem PF0KWC2 bin(4,1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp 1 rts amt
DataItem PF0KWC3 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp 1 other amt
DataItem PF0KWC4 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp 1 net sales amt
DataItem PF0KWC5 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp 1 net sales %
DataItem PF0KWC6 bin(4,1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp 2 grs shp amt
DataItem PF0KWC7 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp 2 grs shp %
DataItem PF0KWC8 bin(4,1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp 2 rts amt
DataItem PF0KWC9 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// rept. attr. 1
DataItem PF0KWCD1 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// rept. attr. 2
DataItem PF0KWCD2 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// rept. attr. 3
DataItem PF0KWCD3 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// rept. attr. 4
DataItem PF0KWCD4 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// rept. attr. 5
DataItem PF0KWCD5 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// rept. attr. 6
DataItem PF0KWCD6 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// rept. attr. 7
DataItem PF0KWCD7 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dt/tp pct. col. 1
DataItem PF0KWCL1 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dt/tp pct. col. 2
DataItem PF0KWCL2 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// rept. attr. 1
DataItem PF0KWCV1 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// rept. attr. 2
DataItem PF0KWCV2 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// rept. attr. 3
DataItem PF0KWCV3 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// rept. attr. 4
DataItem PF0KWCV4 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// rept. attr. 5
DataItem PF0KWCV5 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// rept. attr. 6
DataItem PF0KWCV6 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// rept. attr. 7
DataItem PF0KWCV7 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// display type-'sum,det,exp'
DataItem PF0KWDP1 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// display type-'sum,det,exp'
DataItem PF0KWDP2 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// display type - sum,det,exp
DataItem PF0KWDSP char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data type literal 1
DataItem PF0KWDT1 char(10)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data type literal 2
DataItem PF0KWDT2 char(10)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data type code 1
DataItem PF0KWDT3 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data type code 2
DataItem PF0KWDT4 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler value '-'
DataItem PF0KWF1 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler value '-'
DataItem PF0KWF2 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler-value '/'
DataItem PF0KWF4 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler-value '/'
DataItem PF0KWF5 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler-value '/'
DataItem PF0KWF6 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler-value '/'
DataItem PF0KWF7 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler-value '/'
DataItem PF0KWF8 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// rept. attributes hold area
DataItem PF0KWFL1 char(28)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// rept. attributes hold area
DataItem PF0KWFL2 char(28)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// vsumry01 sequence flag
DataItem PF0KWFLG char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// gourp level
DataItem PF0KWGRP char(62)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// hold display type
DataItem PF0KWHDP char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// '*' or '#' or ' '
DataItem PF0KWIND char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pf key literal-value '18:'
DataItem PF0KWKY1 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pf key literal-value '19:'
DataItem PF0KWKY2 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// display left map
DataItem PF0KWLEF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// map i/s class literal
DataItem PF0KWLIT char(17)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dt/tp column literal 1
DataItem PF0KWLT1 char(20)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dt/tp column literal 2
DataItem PF0KWLT2 char(20)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// numeric breakdown field
DataItem PF0KWNM1 num(8)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// numeric breakdown field
DataItem PF0KWNM2 num(5,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// numeric breakdown field
DataItem PF0KWNUM num(13,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// pf18, pf19 literal
DataItem PF0KWPFK char(13)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// display right map
DataItem PF0KWRIG char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// warning message
DataItem PF0KWRN char(76)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// warning literal 1
DataItem PF0KWRN1 char(23)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// warning literal 2
DataItem PF0KWRN2 char(20)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// warning literal 2
DataItem PF0KWRN3 char(17)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attribute value 1
DataItem PF0KWRV1 char(8)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attribute value 2
DataItem PF0KWRV2 char(8)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// hold level number
DataItem PF0KWSTL num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// hold sequence number
DataItem PF0KWSTS num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// product hold area
DataItem PF0KWSTY char(22)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// time period literal 1
DataItem PF0KWTP1 char(10)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// time period literal 2
DataItem PF0KWTP2 char(10)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// time period code 1
DataItem PF0KWTP3 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// time period code 2
DataItem PF0KWTP4 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// table entry type(1,2,3,4,5)
DataItem PF0KWTYP char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

