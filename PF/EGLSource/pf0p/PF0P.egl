package pf0p;
import corpcom3.XPPF002;
import corpcom3.XPPF010;
import corpcom3.XPPF030;
import corpcom3.XPPF200;
import corpcom4.XSENTRY;
import corpcom4.XSEXIT;
import corpcom4.XSPF1;
import corpcom4.XSPF4;
import corpcom4.XSSEGTR;
import corpcom5.COMMAREA;
import corpcom5.ERRSQLCA;
import corpcom6.SQLCA;
import corpcom7.XXXCURDT;
import corpcom7.XXXNBRCY;
import corpcom7.XXXNDTXT;
import corpcom7.XXXNLTXT;
import pf.common.*;
import sy.common.SY2CLRID;
import ta.common.TA1REC;
import ta.common.TA2REC;
import ta.common.TA5REC;
import ta.common.TA5TSQIX;
import ta.common.TAEREC;
import xx.common.*;
import xx.common.XGPCD;
import xx.common.XLCCD;
import xx.common.XQACD;
import xx.common.XXXUSRID;
import xx.common.YISCD;
import xx.common.ZZZCHGCT;
import xx.common.ZZZCHGDT;
import xx.common.ZZZCHGTM;
import xx.common.ZZZSDT;
import xx02.*;
import xx02.XDMCD;
import xx05.*;
import xx05.XROCD;
import xx08.*;
import xx08.SY1STNBR;
import xx10.*;
import xx10.XXXUNTXT;
//*** PROGRAM=PF0P ****
// PF0P: Print Request Directory
// Overview:
//          This application will display all of the report
//          parameters that are created by the user in pf0h.
//          Each report parameter will create 1 report.
// 
//          Viewing of the different attributes is allowed
//          by pressing a function key, which will pass control
//          to the appropriate application for more detailed
//          attribute information.  Scrolling left and right is
//          permitted thru pf10, pf11.
// 
//          Report parameters may also be deleted or placed on
//          hold.  This is accomplished thru the status field
//          on map 2.
// 
//          This application loads the 14 report parameters
//          at a time into a table, pf0pw02, and the entire
//          reporting attribute field descriprion table into
//          another csp table pf0pw03.  These working storage
//          tables are used to build the 14 data line map.
//          each built map is loaded into temporary storage
//          (pf0pw04) from pf0pw02.  temportary storage is used
//          because the user has exceded the csp table limit.
//          temp storage is written to a map at a time and read
//          back into pf0pw02 for each map display.  a purge
//          of temp storage (pf0pw04) is required before you
//          do any database processing or transfer out of the
//          application.  if a delete or change occurs, the
//          the database and the csp tables are also changed.
// 
//          The temporary storage max is 9,999 records with
//          record being able to contain 4k bytes.  this
//          application currently uses 2198 bytes, which
//          represents map 1 and map 2 information along with
//          data needing to be carried for xfer to other appl.
// 
//          ******  if pffrec changes, pf0pw02 must match in
//          ******  the corresponding part of the w02 record.
//          ******  pf0pw02 contains other info. needed for
//          ******  each report parameter and xfer'ing.
// Maintenance History:
//   Date       By        Description of change
// --------   -----       -----------------------
//  3/22/90   bmanil  use pffrec sort element instead
//                    of pferec for map 2
//  4/02/90   cvo     added 'W'eekly and 'Q'uarterly
//                    processing cycles.
//  9/16/90   cvo     Added all data items from vrptpm01 to
//                    temp. storage W04 for updates purposes.
//                    Fixed edits on cycle and priority fields.
// 10/10/90   cvo     change ws2 and ws4 records length due
//                    to October table changes, xrocd field
//                    changed from 2 to 4 bytes.
// 10/02/93   dcassi  Changed for the conversion from CSP V3.3
//                    to V4.1, which generates & executes
//                    Cobol 2 code.
//                      Added code to initialize PF1REC.PF1SORT
//                    to 0 if it is not numeric, to prevent an
//                    OC7 error, in PF0P100 and PF0P110.  Did
//                    the same for PF1REC.PF1TBLX in PF0P120.
//                    Changed PF1REC to add character fields
//                    that redefined these 2 fields.
//                      Changed PF0PM002.PF0PMSPP from numeric
//                    to character. (The same field on PF0PM001
//                    was already character.)  Stopped checking
//                    for this field being 0, in PF0P200.
//                      Changed the initialization of PF0PW02.
//                    PFFPRTYP from 0 to space, in PF0P228.
// 04/15/94  mjk      changes for new attributes.
// *********************
Program PF0P type textUIProgram //VAGen Info - main text program
  {
  includeReferencedFunctions = yes, allowUnqualifiedItemReferences = yes, 
  throwNrfEofExceptions = yes, handleHardIOErrors = no, V60ExceptionCompatibility = yes, 
  I4GLItemsNullable = no, textLiteralDefaultIsString = no, localSQLScope = yes, 
  msgTablePrefix = "PF00", inputRecord = COMMAREA, segmented = yes
  }

  // Data Declarations
  COMMAREA COMMAREA ; // record
  ERRSQLCA ERRSQLCA; // record
  PF0PW01 PF0PW01; // record
  PF0PW02 PF0PW02; // record
  PF0PW03 PF0PW03; // record
  PF0PW04 PF0PW04; // record
  PF1REC PF1REC; // record
  PFBREC PFBREC; // record
  PFCREC PFCREC; // record
  PFDREC PFDREC; // record
  PFEREC PFEREC; // record
  PFFREC PFFREC; // record
  PFIREC PFIREC; // record
  PFWREC PFWREC; // record
  SQLCA SQLCA; // record
  TA1REC TA1REC; // record
  TA2REC TA2REC; // record
  TA5REC TA5REC; // record
  TAEREC TAEREC; // record

  // VAGen Info - items needed for migration
  VAGen_EZESYS char(8);
  VAGen_EZEREPLY num(1);
  VAGen_EZE_WAIT_TIME bin(9,2);
  VAGen_EZE_ITEMLEN int;

  // Use Declarations
  use PF0PM.PF0PM001,  // forms
      PF0PM.PF0PM002
   {
    helpKey = pf1,
    pfKeyEquate = no
  };

  function main()
    // VAGen Info - initialization needed for migration
    VAGen_EZESYS = VGLib.getVAGSysType();
    PF0P000: PF0P000();
  end // end main
end // end PF0P

// application pf0p main logic
Function PF0P000()
   /* ***********************************************************/
   /* *  this is the 'mainline' of the application pf0p        **/
   /* *  general order of events is:                           **/
   /* *            pf0p100  -  initialization                  **/
   /* *            pf0p200  -  converse screen while not       **/
   /* *                        end-of-application              **/
   /* *            xppf002  -  exit application                **/
   /* ***********************************************************/

   /* JAMIT;*/

  PF0P100(); /* initialize application fields*/

  PFWREC.PFWEOAF = "N"; /* init appl active flag*/
  PFWREC.PFWEXT = "N"; /* init exit flag*/
  while (PFWREC.PFWEOAF == "N") /* while application is active,*/
    PF0P200(); /* converse screen menu*/
  end

  XPPF002(); /* exit appl*/
  COMMAREA.CAFROMAP = "PF0P";
  COMMAREA.CATOAP = "PF0A"; /* xfer to main menu*/
  XSEXIT();
end // end PF0P000

// Purge any temporary storage
Function PF0P001()
   /* ------------------------------------------------------------*/
   /* Initialize the storage areas and indicators to be used.*/
   /* ------------------------------------------------------------*/

  set PF0PW04 empty; /* M001 display storage*/

  TA5REC.TA5TSQIX = 0; /* Current page number*/
  PF0PW01.TA5TSQIX = 0; /* Highest page number*/

   /* ------------------------------------------------------------*/
   /* Purge any temporary storage for this application.*/
   /* ------------------------------------------------------------*/

  TA5REC.TA5APPID = COMMAREA.CACURRAP; /* Application identification*/
  TA5REC.TA5FNCCD = "P"; /* Function code*/

  try
    call "TA0050" (PF0PW04, TA5REC) {isNoRefresh = yes, isExternal = yes};
  end /* Temporary storage*/

   /* ------------------------------------------------------------*/
   /* If successful, return to previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && TA5REC.TA5RTNCD == 0)          /* and normal return code*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that a system error occurred.*/
   /* ------------------------------------------------------------*/

  TAEREC.TAEDESC1 = sysVar.errorCode; /* CSP return code*/
  TAEREC.TAEDESC2 = TA5REC.TA5DATA; /* Subroutine parameters*/

  TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  TA1REC.TA1TYPE = "APPL"; /* Type of error*/
  TA1REC.TA1LOC = "PURGE ANY TEMPORARY STORAGE";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1MAPAP = COMMAREA.CACURRAP; /* Map application*/
  TA1REC.TA1MAPNO = "M001"; /* Map number*/

  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

  return; /* Exit to display map*/


end // end PF0P001

// Add page to temporary storage
Function PF0P002()
   /* ------------------------------------------------------------*/
   /* Add the next page to temporary storage.*/
   /* ------------------------------------------------------------*/

  PF0PW04.PF0PWTSL = PF0PW01.PF0PWTSL; /* Temporary storage length*/

  TA5REC.TA5APPID = COMMAREA.CACURRAP; /* Application identification*/
  TA5REC.TA5FNCCD = "A"; /* Function code*/

  try
    call "TA0050" (PF0PW04, TA5REC) {isNoRefresh = yes, isExternal = yes};
  end /* Temporary storage*/

   /* ------------------------------------------------------------*/
   /* If successful, initialize the storage area and indicators*/
   /* to be used.  Return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && TA5REC.TA5RTNCD == 0)          /* and normal return code*/

    PF0PW01.TA5TSQIX = TA5REC.TA5TSQIX; /* Highest page number*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TAEREC.TAEDESC1 = sysVar.errorCode; /* CSP return code*/
  TAEREC.TAEDESC2 = TA5REC.TA5DATA; /* Subroutine parameters*/


  TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  TA1REC.TA1TYPE = "APPL"; /* Type of error*/
  TA1REC.TA1LOC = "ADD PAGE TO TEMPORARY STORAGE";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1MAPAP = COMMAREA.CACURRAP; /* Map application*/
  TA1REC.TA1MAPNO = "M001"; /* Map number*/

  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

  return; /* Exit to display map*/


end // end PF0P002

// init main menu,get table data
Function PF0P100()

    /* *************************************************/
    /* * PF0P100 -- initialization  process,determine **/
                 /* sort used, select 14 vrptpm01's   **/
                 /* add to temporary storage and read **/
                 /* temporary storage for map display **/
    /* *************************************************/

  XSENTRY();

  XSSEGTR(); /* SET SEGMENTED TRANSACTION ID*/

  PF1REC.PF1PASS = COMMAREA.CAUSERA;
  if (PF1REC.PF1XFERF == "Y") /* xfer'd back in*/
    if (PF1REC.PF1PRM != " " /* parameters entered*/
     || PF1REC.PF1CYC != " ") /* do not clear pf0pw01-parm flags*/
                                   /* needed*/

    else /* parameters blank*/
      set PF0PM001 initial; /* map 1 clear*/
      set PF0PM002 initial; /* map 2 clear*/
      set PF0PW01 empty; /* ws pf0p*/
    end
    if (PF1REC.PF1SIDE != "R") /* left side of map*/
      PF0PW01.PF0PWLEF = "Y"; /* display left side of map*/
      PF0PW01.PF0PWRIG = "N";
    else
      PF0PW01.PF0PWLEF = "N"; /* display right side of map*/
      PF0PW01.PF0PWRIG = "Y";
    end
  else
    set PF0PM001 initial; /* map 1 clear*/
    set PF0PM002 initial; /* map 2 clear*/
    set PF0PW01 empty; /* ws pf0p*/
    if (PF1REC.PF1SIDE != "R")
      PF0PW01.PF0PWLEF = "Y"; /* display left side of map*/
      PF0PW01.PF0PWRIG = "N";
    else
      PF0PW01.PF0PWLEF = "N"; /* display right side of map*/
      PF0PW01.PF0PWRIG = "Y";
    end
  end


    /* 9/93 conversion from CSP V3.3 to V4.1 (generates cob 2).*/
    /* The following code is to prevent a asra/oc7 due to spaces*/
    /* being in the numeric pf1sort data item (from causera).*/
    /* (The set empty csp stmt will always initialize the lowest*/
    /* level field, so it will put 0 in this field, in the*/
    /* SET PF1REC EMPTY further below.)*/

  if (PF1REC.PF1-SORT-CHAR-RDF not numeric) /* test char redefiniton*/
    PF1REC.PF1SORT = 0; /* move to numeric data item*/
  end

  if (PF1REC.PF1SORT < 1) /* sort will be filled in if from an*/
    PF0PW01.PF0PWSRT = 1; /* xfer.  default is pfesumnm,xxxuntxt*/
  else
    PF0PW01.PF0PWSRT = PF1REC.PF1SORT;
  end


  set PF0PW02 empty; /* pf0p ws clear*/
  set PF0PW03 empty; /* ws table of pfirec occurs 200 times*/
  set PF0PW04 empty; /* ws representation of map 1 and 2*/
  set PFWREC empty; /* general ws clear-spaces to appl*/
                                   /* active*/
  set PF1REC empty; /* bridge record clear*/
  set PFFREC empty; /* report parm table i/o clear*/
  set PFBREC empty; /* income stmt table i/o clear*/
  set PFCREC empty; /* report fmt table i/o clear*/
  set PFDREC empty; /* report attr table i/o clear*/
  set PFIREC empty; /* reporting attr desc table i/o clear*/
  set SQLCA empty; /* sql comm area clear*/
  set ERRSQLCA empty; /* sql comm area record clear*/
  set TA1REC empty;
                                   /* error diagnostic routine record clear*/
  set TA2REC empty; /* date routine record clear*/
  set TA5REC empty; /* temp storage record clear*/

  PFWREC.PFWMSG = " "; /* clear msg*/
  PFWREC.PFWEOAF = "N"; /* set end of appl flag to 'no'*/
  PFWREC.PFWERRF = "N"; /* set error flag  to 'no'*/
  PFWREC.PFWRECF = "N"; /* set record found to 'no'*/
  PF0PW01.PF0PWPRM = "N"; /* priority or cycle parm*/
  PF0PW01.PF0PWDCF = "N"; /* set delete confirm flag to no*/

  PF0PM001.XXXCURDT = VGVar.currentShortGregorianDate; /* system date to map*/


  PF0P110(); /* select entire vrptpm01 table*/

  if (PFWREC.PFWRECF == "Y")
    set PF0PM001 initial; /* map 1 clear*/
    set PF0PM002 initial; /* map 2 clear*/
    PF0PW01.PF0PWTSP = 1; /* current pg*/
    PF0PW01.PF0PWTSH = 1; /* hold pg*/

    PF0P121(); /* move rows from temp storage to scrn*/

  end
end // end PF0P100

// pf key index restore
Function PF0P101()
   /* **********************************************************/
   /* reestablish cursor position when xfering back in to pf0p*/
   /* **********************************************************/

  PF1REC.PF1PASS = COMMAREA.CAUSERA;
  if (PF1REC.PF1XFERF == "Y") /* entering from pf keys*/
    if (PF1REC.PF1ORIG != "PF0P"
     /* if originating pgm is not valid*/
     && PF1REC.PF1ORIG != "PF0C"
     && PF1REC.PF1ORIG != "PF0F"
     && PF1REC.PF1ORIG != "PF0G"
     && PF1REC.PF1ORIG != "PF0H")
      converseLib.validationFailed(001); /* invalid pf key pressed*/
      PF1REC.PF1IDX = 1; /* screen index*/
      PF1REC.PF1TBLX = 1; /* table index*/
      return;
    else
      PFWREC.PFWSUB = PF1REC.PF1TBLX - 1;
      PFWREC.PFWSUB = PFWREC.PFWSUB + PF1REC.PF1IDX;
      if (PF1REC.PF1TBLX >= 1                       /* passed table index valid*/
       && PF1REC.PF1TBLX <= PFWREC.PFWLIMIT         
       && PF1REC.PF1IDX >= 1                        /* screen index valid*/
       && PF1REC.PF1IDX <= 14                       
       && PF1REC.PF1IDX <= PFWREC.PFWLIMIT          
       && PF1REC.PF1NAM == PF0PW02.PFESUMNM[PFWSUB] /* sum nm matches*/
       && PF1REC.PF1ANX == PF0PW02.PFANXTNO[PFWSUB]) /* seq no matches*/
        set PF0PM001.PF0PMSEL[PF1IDX] cursor; /* set cursor to prev pos*/
        set PF0PM002.PF0PMSEL[PF1IDX] cursor; /* set cursor to prev pos*/
        PF0PM001.PF0PMSPP = PF1REC.PF1PRM;
        PF0PM002.PF0PMSPP = PF1REC.PF1PRM;
        PF0PM001.PF0PMSPC = PF1REC.PF1CYC;
        PF0PM002.PF0PMSPC = PF1REC.PF1CYC;
          /* ok*/
      else
        PF1REC.PF1IDX = 1; /* screen index*/
        PF1REC.PF1TBLX = 1; /* table index*/
      end
    end
  else
    PF1REC.PF1IDX = 1; /* screen index*/
    PF1REC.PF1TBLX = 1; /* table index*/
  end
end // end PF0P101

// select entire vrptpm01 table
Function PF0P110()
   /* *************************************************************/
   /*  */
   /* This process loads the entire vrptpm01 table into pf0pw02,*/
   /* along with the associated vsumat01 columns.*/
   /* it loads the vfield01 table into pf0pw03.*/
   /* when 14 vrptpm01's are loaded, it moves them from pf0pw02*/
   /* to the temp storage.*/
   /* it also checks fro a valid user for determining whether*/
   /* to show priority/cycle parameters, and calculates the total*/
   /* page count.*/
   /*  */
   /* *************************************************************/


  PFWREC.PFWRECF = "Y"; /* setting records found flag to yes*/
  PF0PW01.PF0PWADD = "N"; /* added to temp storage already*/
  PFFREC.PFANXTNO = -1; /* select all summary request numbers*/
   /* OVE 2198 TO PF0PW01.PF0PWTSL;temp storage length map1&2combi*/
  PF0PW01.PF0PWTSL = 3837; /* temp storage length map 1&2 combined*/
  PF0PW01.PF0PWTSP = 1; /* temp storage page 1*/

  PF0P001();
                                   /* temp storage purge*/

  if (converseVar.eventKey is pf19
   /* pf19 indicates a sort*/
   || PF0PW01.PF0PWPRM == "Y") /* or priority/cycle entered*/
    /* on a sort, values get moved to pf1rec. moving the causera to*/
    /* pf1pass will wipe out the new values needed for sorting.*/
  else
    PF1REC.PF1PASS = COMMAREA.CAUSERA;
  end


  if (COMMAREA.CACLVL[1] == "Y" /* user is valid*/
   || COMMAREA.CACLVL[2] == "Y")
    set PF0PM001.PF0PMSPP cursor;
                                   /* priority parameter top right of map*/
  else
    set PF0PM001.PF0PMPTX skip, invisible; /* set priority/cycle text and*/
    set PF0PM001.PF0PMSPP skip, invisible; /* user entered fields dark*/
    set PF0PM001.PF0PMSCT skip, invisible;
    set PF0PM001.PF0PMSPC skip, invisible;
    set PF0PM001.PF0PMSEL[1] cursor;
                                   /* cursor on first data line*/
  end


   /* 9/93 conversion from CSP V3.3 to V4.1 (generates cob2 code).*/

  if (PF1REC.PF1-SORT-CHAR-RDF not numeric) /* test char redefinition*/
    PF1REC.PF1SORT = 0; /* move to numeric data item*/
  end


  if (PF0PW01.PF0PWSRT == 2 /* sort xxxuntxt,pfesumnm open*/
   || PF1REC.PF1SORT == 2) 
    PFFREC.XXXUNTXT = " "; /* no particular report recipient*/

    call "IO2880" ("S3", SQLCA, PFFREC) {isNoRefresh = yes, isExternal = yes}; /* vrptpm01 select scan*/

  else
    PFFREC.PFESUMNM = " "; /* we have no particular summary name*/

    call "IO2880" ("S2", SQLCA, PFFREC) {isNoRefresh = yes, isExternal = yes}; /* vrptpm01 select scan*/

  end

  if (SQLCA.VAGen_SQLCODE == +0) /* if select successful*/
     /* this is okay*/
  else
    if (SQLCA.VAGen_SQLCODE == -911) /* if table page busy*/
      converseLib.validationFailed(114); /* db busy please retry*/
      PFWREC.PFWERRF = "Y"; /* error condition*/
      PFWREC.PFWRECF = "N"; /* no records found*/
      PF0PM001.XXXCURDT = PFWREC.PFWDTE;
      PF0PM001.PF0PMCPG = 1; /* pg 1 of 1 map 1*/
      PF0PM001.PF0PMTPG = 1;
      PF0PM002.PF0PMCPG = 1; /* pg 1 of 1 map 2*/
      PF0PM002.PF0PMTPG = 1;
      set PF0PM001.PF0PMSEL[1] cursor; /* cursor on first data line*/
      PFWREC.PFWIDX = 1; /* blank out select*/
      while (PFWREC.PFWIDX <= 14)
        set PF0PM001.PF0PMSEL[PFWIDX] skip, invisible;
        PFWREC.PFWIDX = PFWREC.PFWIDX + 1;
      end
    else /* fatal db2 error, transfer to ta*/
      TA1REC.TA1LOCAT[2] = " ";
      PF0PW01.PF0PWKEY = " "; /* clear key redefinition area*/
      PF0PW01.PF0PWKC1 = PFFREC.PFESUMNM; /* move to key char 1 area*/
      PF0PW01.PF0PWKB2 = PFFREC.PFANXTNO;
                                   /* move to key binary 2 area*/
      PFWREC.PFWHKEY = PF0PW01.PF0PWKEY; /* move key to hold key area*/
      PFWREC.PFWCPROC = "PF0P110"; /* pass calling process*/
      TA1REC.TA1LOCAT[4] = "IO2880"; /* pass i/o module name*/
      TA1REC.TA1DBASE = "DPROFT";
      TA1REC.TA1TBLVU = "VRPTPM01";
      XPPF010(); /* abend routine*/
    end
  end



  SQLCA.VAGen_SQLCODE = 0;
  PFWREC.PFWTBLX = 0; /* internal wo2 table index*/
  while (SQLCA.VAGen_SQLCODE == 0 /* good select next & abrv calls & lt 14*/
   && PFWREC.PFWTBLX < 14)
    if (PF0PW01.PF0PWSRT == 2 /* xxxuntxt,pfesumnm sort 2nd sort*/
     || PF1REC.PF1SORT == 2) 

      call "IO2880" ("N3", SQLCA, PFFREC) {isNoRefresh = yes, isExternal = yes}; /* vrptpm01 next*/

    else

      call "IO2880" ("N2", SQLCA, PFFREC) {isNoRefresh = yes, isExternal = yes}; /* vrptpm01 select next*/

    end

    if (SQLCA.VAGen_SQLCODE == +0) /* if select next is successful*/
      if (PF0PW01.PF0PWPRM == "Y" /* normal entry of parms*/
       || PF1REC.PF1PRM != " "    /* on a xfer back in pf0pw01 is lost,so*/
       || PF1REC.PF1CYC != " ")   /* pf1rec has to be checked for entered*/
        if (PF1REC.PF1PRM != " " /* parameters*/
         || PF1REC.PF1CYC != " ")

          PF0P113(); /* move pferec to w02 table if parms*/
                                   /* match*/
        else
          if (PF0PM001.PF0PMSPP != " " /* if priority and cycle parm entered*/
           && PF0PM001.PF0PMSPC != " ")
            if (PFFREC.PFFPRTYI == PF0PM001.PF0PMSPP
             /* record found eq scrn*/
             && PFFREC.PFECYCIN == PF0PM001.PF0PMSPC)

              PF0P115(); /* move pffrec & pferec to w02*/

              if (PFWREC.PFWERRF == "Y")
                return;
              end
            end
          else
            if (PF0PM001.PF0PMSPP != " ") /* priority only parm entered*/
              if (PFFREC.PFFPRTYI == PF0PM001.PF0PMSPP)

                PF0P115(); /* move pffrec & pferec to w02*/

                if (PFWREC.PFWERRF == "Y")
                  return;
                end
              end
            else
              if (PF0PM001.PF0PMSPC != " ") /* only cycle parm entered*/
                if (PFFREC.PFECYCIN == PF0PM001.PF0PMSPC)

                  PF0P115(); /* move pffrec & pferec to w02*/

                  if (PFWREC.PFWERRF == "Y")
                    return;
                  end
                end
              else

                PF0P115(); /* move pffrec & pferec to w02*/

                if (PFWREC.PFWERRF == "Y")
                  return;
                end
              end
            end
          end
        end
      else

        PF0P115(); /* move pffrec & pferec to w02*/

        if (PFWREC.PFWERRF == "Y")
          return;
        end
      end

      if (PFWREC.PFWTBLX == 14) /* full screen*/
        PFWREC.PFWLIMIT = PFWREC.PFWTBLX + PFWREC.PFWLIMIT;
        if (PF0PW01.PF0PWADD == "N") /* add to temp storage done*/

          PF0P114(); /* load vfield in w03 & abrv in w01.*/
                                   /* open*/
          PF0PW01.PF0PWADD = "Y"; /* set add to ts done*/
        else
          PF0PW01.PF0PWLMT = PFWREC.PFWTBLX; /* partial page count*/

          PF0P117(); /* load vfield in w03 & abrv in w01. no*/
                                   /* open*/
        end

        PF0P120(); /* move scrns worth of w02 into temp*/
                                   /* storage*/
        TA5REC.TA5TSQIX = PF0PW01.PF0PWTSP; /* temp stor current page*/

        PF0P002(); /* add page to temp storage*/

        PFWREC.PFWTBLX = 0; /* reset index for next group*/
        set PF0PW02 empty;
        PF0PW01.PF0PWTSP = PF0PW01.PF0PWTSP + 1; /* bump ts current page*/
      end

    else /* sqlcode is not 0*/

      if (SQLCA.VAGen_SQLCODE == +100) /* row not found end of table*/
         /* next sentence*/
      else
        if (SQLCA.VAGen_SQLCODE == -911) /* if table page busy*/
          converseLib.validationFailed(114); /* data base was busy, please retry*/
          PFWREC.PFWERRF = "Y";
          set PF0PW01 empty; /* general ws*/
          set PF0PW02 empty; /* table occuring 14 times*/
          set PF0PW04 empty; /* temp storage*/
          PFWREC.PFWRECF = "N"; /* record found*/
          PF0PM001.XXXCURDT = PFWREC.PFWDTE;
          PF0PM001.PF0PMCPG = 1; /* pg of pg*/
          PF0PM001.PF0PMTPG = 1;
          PF0PM002.PF0PMCPG = 1;
          PF0PM002.PF0PMTPG = 1;
          set PF0PM001.PF0PMSEL[1] cursor;
          PFWREC.PFWIDX = 1;
          while (PFWREC.PFWIDX <= 14) /* clear select*/
            set PF0PM001.PF0PMSEL[PFWIDX] skip, invisible;
            PFWREC.PFWIDX = PFWREC.PFWIDX + 1;
          end
        else
          TA1REC.TA1LOCAT[2] = " "; /* fatal error*/
          PF0PW01.PF0PWKEY = " "; /* clear key redefinition area*/
          PF0PW01.PF0PWKC1 = PFFREC.PFESUMNM; /* move to key area 1*/
          PF0PW01.PF0PWKB2 = PFFREC.PFANXTNO;
                                   /* move to key bin 2 area*/
          PFWREC.PFWHKEY = PF0PW01.PF0PWKEY; /* move to hold key*/
          PFWREC.PFWCPROC = "PF0P110A"; /* pass calling process*/
          TA1REC.TA1LOCAT[4] = "IO2880"; /* pass i/o module name*/
          TA1REC.TA1DBASE = "DPROFT";
          TA1REC.TA1TBLVU = "VRPTPM01";
          XPPF010(); /* abend routine*/
        end
      end
    end
  end /* end while*/



  if (PFWREC.PFWTBLX >= 1)
                                   /* partial page to add to temp storage*/
    if (PF0PW01.PF0PWADD == "N") /* add  to temp storage done*/
      PFWREC.PFWLIMIT = PFWREC.PFWTBLX + PFWREC.PFWLIMIT;

      PF0P114(); /* load vfield in w03 & abrv in w01.*/
                                   /* open*/
    else
      PF0PW01.PF0PWLMT = PFWREC.PFWTBLX; /* partial pg count*/

      PF0P117(); /* load vfield in w03 & abrv in w01. no*/
                                   /* open*/
    end

    PF0P116(); /* close vrptpm01 cursor*/

    PF0P118(); /* close vfield01 cursor*/

    PF0P120(); /* move scrns worth of w02 into temp*/
                                   /* storage*/
    TA5REC.TA5TSQIX = PF0PW01.PF0PWTSP; /* temp storage current pg*/

    PF0P002(); /* add page to temp storage*/

    PFWREC.PFWLIMIT = PF0PW01.PF0PWLMT + PFWREC.PFWLIMIT;
  else /* nothing more to add. close all*/
                                   /* cursors*/
    PF0P116(); /* close vrptpm01 cursor*/

  end



    /* compute total number of pages*/

  PFWREC.PFWTPG = PFWREC.PFWLIMIT / 14;
  PF0PW01.PF0PWREM = PFWREC.PFWLIMIT % 14; /* remainder pages*/
  if (PF0PWREM > 0) /* >add 1 for partial pg;*/
    PFWREC.PFWTPG = PFWREC.PFWTPG + 1; /* total table pages*/
  end
  if (PFWREC.PFWTPG == 0)
    PFWREC.PFWTPG = PFWREC.PFWTPG + 1; /* total table pages*/
  end
end // end PF0P110

// get abrv. load internal table
Function PF0P111()
   /* ************************************************************/
   /* if the pffrec attribute field code matches what was loaded*/
   /* into w03, move the abrv from pfirec to ws w01.  w01 is used*/
   /* to place an '*' in the first char of the abrv if the pffrec*/
   /* attribute code value is not 'all', and spaces in the first*/
   /* char if the attribute code value is 'all'.  it is then*/
   /* moved to w02 preparing for move to map.*/
   /* ************************************************************/


  PF0PW01.PF0PWFLG = "N"; /* found  flag*/
  PFWREC.PFWIDX = 1;
  while (PFWREC.PFWIDX <= 200
   && PF0PW01.PF0PWFLG == "N")
    if (PFFREC.PFICD[PFWSUB] == PF0PW03.PFICD[PFWIDX])
      if (PFFREC.PFDCDVAL[PFWSUB] == "ALL")
        PF0PW01.PF0PWSTR[PFWSUB] = " ";
      else
        PF0PW01.PF0PWSTR[PFWSUB] = "*";
      end
      PFIREC.PFIGROUP = PF0PW03.PF0PWTAB[PFWIDX]; /* abrv for map*/
      PF0PW01.PF0PWABR[PFWSUB] = PFIREC.PFIABRV;
      PF0PW01.PF0PWFLG = "Y";
      set PFDREC empty;
      PFDREC.PFDREF = PF0PW02.PFDREF[PFWTBLX];
      PF0P242(); /* check specific value flag-mark w/asterisk*/
      if (PFWREC.PFWERRF == "Y")
        return;
      end
    else
      PFWREC.PFWIDX = PFWREC.PFWIDX + 1;
    end
  end


  if (PFWREC.PFWSUB == 1)
    PF0PW02.PF0PWAT1[PFWTBLX] = PF0PW01.PF0PWATR[PFWSUB];
  else
    if (PFWREC.PFWSUB == 2)
      PF0PW02.PF0PWAT2[PFWTBLX] = PF0PW01.PF0PWATR[PFWSUB];
    else
      if (PFWREC.PFWSUB == 3)
        PF0PW02.PF0PWAT3[PFWTBLX] = PF0PW01.PF0PWATR[PFWSUB];
      else
        if (PFWREC.PFWSUB == 4)
          PF0PW02.PF0PWAT4[PFWTBLX] = PF0PW01.PF0PWATR[PFWSUB];
        else
          if (PFWREC.PFWSUB == 5)
            PF0PW02.PF0PWAT5[PFWTBLX] = PF0PW01.PF0PWATR[PFWSUB];
          else
            if (PFWREC.PFWSUB == 6)
              PF0PW02.PF0PWAT6[PFWTBLX] = PF0PW01.PF0PWATR[PFWSUB];
            else
              if (PFWREC.PFWSUB == 7)
                PF0PW02.PF0PWAT7[PFWTBLX] = PF0PW01.PF0PWATR[PFWSUB];
              else
                if (PFWREC.PFWSUB == 8)
                  PF0PW02.PF0PWAT8[PFWTBLX] = PF0PW01.PF0PWATR[PFWSUB];
                end /* 8*/
              end /* 7*/
            end /* 6*/
          end /* 5*/
        end /* 4*/
      end /* 3*/
    end /* 2*/
  end /* 1*/
end // end PF0P111

// no abrv. load internal table
Function PF0P112()
   /* ************************************************/
    /* pffrec.pfdcdval was spaces.  no abrv*/
   /* ************************************************/

  if (PFWREC.PFWSUB == 1)
    PF0PW02.PF0PWAT1[PFWTBLX] = " ";
    PF0PW01.PF0PWATR[PFWSUB] = " ";
  else
    if (PFWREC.PFWSUB == 2)
      PF0PW02.PF0PWAT2[PFWTBLX] = " ";
      PF0PW01.PF0PWATR[PFWSUB] = " ";
    else
      if (PFWREC.PFWSUB == 3)
        PF0PW02.PF0PWAT3[PFWTBLX] = " ";
        PF0PW01.PF0PWATR[PFWSUB] = " ";
      else
        if (PFWREC.PFWSUB == 4)
          PF0PW02.PF0PWAT4[PFWTBLX] = " ";
          PF0PW01.PF0PWATR[PFWSUB] = " ";
        else
          if (PFWREC.PFWSUB == 5)
            PF0PW02.PF0PWAT5[PFWTBLX] = " ";
            PF0PW01.PF0PWATR[PFWSUB] = " ";
          else
            if (PFWREC.PFWSUB == 6)
              PF0PW02.PF0PWAT6[PFWTBLX] = " ";
              PF0PW01.PF0PWATR[PFWSUB] = " ";
            else
              if (PFWREC.PFWSUB == 7)
                PF0PW02.PF0PWAT7[PFWTBLX] = " ";
                PF0PW01.PF0PWATR[PFWSUB] = " ";
              else
                if (PFWREC.PFWSUB == 8)
                  PF0PW02.PF0PWAT8[PFWTBLX] = " ";
                  PF0PW01.PF0PWATR[PFWSUB] = " ";
                end /* 8*/
              end /* 7*/
            end /* 6*/
          end /* 5*/
        end /* 4*/
      end /* 3*/
    end /* 2*/
  end /* 1*/
end // end PF0P112

// vsumat01 move to wrk storage
Function PF0P113()
   /* ********************************************************/
   /* this process is called when you xfer back in and*/
   /* parameters were entered before you left pf0p*/
   /* ********************************************************/

  set PFEREC empty;
  PFEREC.PFESUMNM = PFFREC.PFESUMNM;
  PF0P241(); /* get pferec for fmt, i/s and att*/
  if (PFWREC.PFWERRF == "Y")
    return;
  end

  if (PF1REC.PF1PRM != " " /* both parms entered, xfer'd back in*/
   && PF1REC.PF1CYC != " ")
    if (PFFREC.PFFPRTYI == PF1REC.PF1PRM /* priorities entered = record*/
     && PFFREC.PFECYCIN == PF1REC.PF1CYC) /* cycle equal record*/
      PFWREC.PFWTBLX = PFWREC.PFWTBLX + 1;
      PF0PW02.PF0PWGRP[PFWTBLX] = PFFREC.PFFGROUP;
      PF0PW02.PFCREF[PFWTBLX] = PFEREC.PFCREF; /* fmt*/
      PF0PW02.PFBREF[PFWTBLX] = PFEREC.PFBREF; /* is*/
      PF0PW02.PFDREF[PFWTBLX] = PFEREC.PFDREF; /* att*/
      PF0PW02.YISCD[PFWTBLX] = PFEREC.YISCD; /* is cls cd*/
      PF0PW02.PFBISGRP[PFWTBLX] = PFEREC.PFBISGRP; /* is group*/
      PF0PW02.PF0PWCYL[PFWTBLX] = PFEREC.PFECYCIN; /* sum cycle*/
      PF0PW02.PF0PWPRI[PFWTBLX] = PFEREC.PFEPRIND; /* sum priority*/
    end
  else
    if (PF1REC.PF1PRM != " ") /* priority entered*/
      if (PFFREC.PFFPRTYI == PF1REC.PF1PRM)
        PFWREC.PFWTBLX = PFWREC.PFWTBLX + 1;
        PF0PW02.PF0PWGRP[PFWTBLX] = PFFREC.PFFGROUP;
        PF0PW02.PFCREF[PFWTBLX] = PFEREC.PFCREF; /* fmt*/
        PF0PW02.PFBREF[PFWTBLX] = PFEREC.PFBREF; /* is*/
        PF0PW02.PFDREF[PFWTBLX] = PFEREC.PFDREF; /* att*/
        PF0PW02.YISCD[PFWTBLX] = PFEREC.YISCD; /* is cls cd*/
        PF0PW02.PFBISGRP[PFWTBLX] = PFEREC.PFBISGRP; /* is group*/
        PF0PW02.PF0PWCYL[PFWTBLX] = PFEREC.PFECYCIN; /* sum cycle*/
        PF0PW02.PF0PWPRI[PFWTBLX] = PFEREC.PFEPRIND; /* sum priority*/
      end
    else
      if (PF1REC.PF1CYC != " ") /* cycle entered*/
        if (PFFREC.PFECYCIN == PF1REC.PF1CYC)
          PFWREC.PFWTBLX = PFWREC.PFWTBLX + 1;
          PF0PW02.PF0PWGRP[PFWTBLX] = PFFREC.PFFGROUP;
          PF0PW02.PFCREF[PFWTBLX] = PFEREC.PFCREF; /* fmt*/
          PF0PW02.PFBREF[PFWTBLX] = PFEREC.PFBREF; /* is*/
          PF0PW02.PFDREF[PFWTBLX] = PFEREC.PFDREF; /* att*/
          PF0PW02.YISCD[PFWTBLX] = PFEREC.YISCD; /* is cls cd*/
          PF0PW02.PFBISGRP[PFWTBLX] = PFEREC.PFBISGRP; /* is group*/
          PF0PW02.PF0PWCYL[PFWTBLX] = PFEREC.PFECYCIN; /* sum cycle*/
          PF0PW02.PF0PWPRI[PFWTBLX] = PFEREC.PFEPRIND;
                                   /* sum priority*/
        end
      end
    end
  end
end // end PF0P113

// vfield01 selects
Function PF0P114()
   /* *************************************************************/
   /* loads the internal w03 vfield01 table used for*/
   /* attribute abreviations*/

   /* *************************************************************/

  SQLCA.VAGen_SQLCODE = 0;
  call "IO2890" ("S1", SQLCA, PFIREC) {isNoRefresh = yes, isExternal = yes}; /* vfield01 open*/

  if (SQLCA.VAGen_SQLCODE == +0) /* if open successful*/
     /* this is okay*/
  else /* fatal db2 error, transfer to ta*/
    TA1REC.TA1LOCAT[2] = " ";
    PF0PW01.PF0PWKEY = " "; /* clear key redefinition area*/
    PF0PW01.PF0PWKC1 = PFIREC.PFICD; /* move to key char 1 area*/
    PFWREC.PFWHKEY = PF0PW01.PF0PWKEY; /* move key to hold key area*/
    PFWREC.PFWCPROC = "PF0P110"; /* pass calling process*/
    TA1REC.TA1LOCAT[4] = "IO2890"; /* pass i/o module name*/
    TA1REC.TA1DBASE = "DPROFT";
    TA1REC.TA1TBLVU = "VFIELD01";
    XPPF010(); /* abend routine*/
  end


     /* load w03 with vfield01 data used for map 1 attribute abrv*/

  SQLCA.VAGen_SQLCODE = 0;
  PFWREC.PFWTBLX = 0;
  while (SQLCA.VAGen_SQLCODE == 0 /* good select next and abrv calls and*/
   /* le 240*/
   && PFWREC.PFWTBLX < 200)
    call "IO2890" ("N1", SQLCA, PFIREC) {isNoRefresh = yes, isExternal = yes}; /* vfield01 select next*/

    if (SQLCA.VAGen_SQLCODE == +0) /* if select next is successful*/
      PFWREC.PFWTBLX = PFWREC.PFWTBLX + 1;
      PF0PW03.PF0PWTAB[PFWTBLX] = PFIREC.PFIGROUP;
    else
      if (SQLCA.VAGen_SQLCODE == +100) /* row not found*/
         /* end of table*/
      else
        if (SQLCA.VAGen_SQLCODE == -911) /* if table page busy*/
          converseLib.validationFailed(114); /* data base was busy, please retry*/
          PFWREC.PFWERRF = "Y";
          set PF0PW03 empty;
          PFWREC.PFWRECF = "N";
          PF0PM001.XXXCURDT = PFWREC.PFWDTE;
        else
          TA1REC.TA1LOCAT[2] = " "; /* fatal error*/
          PF0PW01.PF0PWKEY = " "; /* clear key redefinition area*/
          PF0PW01.PF0PWKC1 = PFIREC.PFICD; /* move to key area 1*/
          PFWREC.PFWHKEY = PF0PW01.PF0PWKEY; /* move to hold key*/
          PFWREC.PFWCPROC = "PF0P110C"; /* pass calling process*/
          TA1REC.TA1LOCAT[4] = "IO2890"; /* pass i/o module name*/
          TA1REC.TA1DBASE = "DPROFT";
          TA1REC.TA1TBLVU = "VFIELD01";
          XPPF010(); /* abend routine*/
        end
      end
    end
  end /* end while*/

   /* move w03 abrv to w01 for move to map*/

  PFWREC.PFWSUB = 1; /* general index*/
  PFWREC.PFWTBLX = 1; /* table index*/
  PFWREC.PFWIDX = 1; /* table index*/
  while (PFWREC.PFWTBLX <= PFWREC.PFWLIMIT
   && PFWREC.PFWIDX < 240)
    PFWREC.PFWSUB = 1;
    PFFREC.PFFGROUP = PF0PW02.PF0PWGRP[PFWTBLX];
    while (PFWREC.PFWSUB <= 8)
      if (PFFREC.PFDCDVAL[PFWSUB] != " ")
        PF0P111(); /* move pfirec abrv to w01 for format*/
      else /* and move to w02 for move to map*/
        PF0P112(); /* move spaces to w01 attributes*/
      end
      if (PFWREC.PFWSUB == 8)
        if (PFFREC.SY1STNBR != " ") /* style number*/
          PFFREC.PFDCDVAL[8] = PFFREC.SY1STNBR;
          PF0P111();
        end
      end
      PFWREC.PFWSUB = PFWREC.PFWSUB + 1;
    end /* end while*/
    PFWREC.PFWTBLX = PFWREC.PFWTBLX + 1;
  end

end // end PF0P114

// vsumat01 select unique
Function PF0P115()
   /* *************************************************************/
   /* the process makes a call to the pferec and moves required*/
   /* data to w02.*/

   /* *************************************************************/
  set PFEREC empty;
  PFEREC.PFESUMNM = PFFREC.PFESUMNM;
  PF0P241();
                                   /* call pferec for fmt,i/s,att*/
  if (PFWREC.PFWERRF == "Y")
    return;
  end
  PFWREC.PFWTBLX = PFWREC.PFWTBLX + 1;
  PF0PW02.PF0PWGRP[PFWTBLX] = PFFREC.PFFGROUP;
  PF0PW02.PFCREF[PFWTBLX] = PFEREC.PFCREF; /* fmt*/
  PF0PW02.PFBREF[PFWTBLX] = PFEREC.PFBREF; /* i/s*/
  PF0PW02.PFDREF[PFWTBLX] = PFEREC.PFDREF; /* att*/
  PF0PW02.YISCD[PFWTBLX] = PFEREC.YISCD; /* is cls cd*/
  PF0PW02.PFBISGRP[PFWTBLX] = PFEREC.PFBISGRP; /* is group*/
  PF0PW02.PF0PWCYL[PFWTBLX] = PFEREC.PFECYCIN; /* sum cyc*/
  PF0PW02.PF0PWPRI[PFWTBLX] = PFEREC.PFEPRIND; /* sum pri*/
end // end PF0P115

// close all cursors
Function PF0P116()
   /* *************************************************************/
   /* close the vrptpm01 cursor*/

   /* *************************************************************/


  if (PF0PW01.PF0PWSRT == 2 /* xxxuntxt,pfesumnm*/
   || PF1REC.PF1SORT == 2)  /* xfer back in sort data*/
    call "IO2880" ("C3", SQLCA, PFFREC) {isNoRefresh = yes, isExternal = yes};
                                   /* vrptpm01 close 2nd sort*/
  else
    call "IO2880" ("C2", SQLCA, PFFREC) {isNoRefresh = yes, isExternal = yes}; /* vrptpm01 close cursor*/
  end

  if (SQLCA.VAGen_SQLCODE == +0) /* if select successful*/
     /* this is okay*/
  else /* fatal db2 error, transfer to ta*/
    TA1REC.TA1LOCAT[2] = " ";
    PF0PW01.PF0PWKEY = " "; /* clear key redefinition area*/
    PFWREC.PFWCPROC = "PF0P116"; /* pass calling process*/
    TA1REC.TA1LOCAT[4] = "IO2880"; /* pass i/o module name*/
    TA1REC.TA1DBASE = "DPROFT";
    TA1REC.TA1TBLVU = "VRPTPM01";
    XPPF010(); /* abend routine*/
  end

end // end PF0P116

// vfield01 selects
Function PF0P117()
   /* *************************************************************/
   /* on finding a value in pffrec.pfdcdval, the attr1-8 abrv*/
   /* is built in pf0p111 or moves spaces to the abrv in pf0p112.*/
   /* within pf0p111/112, the abrv is moved to w02. this process*/
   /* is performed because an add to temporary storage has*/
   /* occured. there is no need to reload the w03 csp table.*/
   /* *************************************************************/



   /* format abrv in w01 (pf0p111) for move to w02*/
   /* or move spaces to abrv (pf0p112) for move to w02*/

  PFWREC.PFWSUB = 1; /* general index*/
  PFWREC.PFWTBLX = 1; /* table index*/
  PFWREC.PFWIDX = 1; /* table index*/
  while (PFWREC.PFWTBLX <= PF0PW01.PF0PWLMT
   && PFWREC.PFWIDX < 200)
    PFWREC.PFWSUB = 1;
    PFFREC.PFFGROUP = PF0PW02.PF0PWGRP[PFWTBLX];
    while (PFWREC.PFWSUB <= 8)
      if (PFFREC.PFDCDVAL[PFWSUB] != " ")
        PF0P111(); /* move pfirec abrv to w01 for format*/
      else /* and move to w02 for move to map*/
        PF0P112(); /* move spaces to w01 attributes*/
      end
      if (PFWREC.PFWSUB == 8)
        if (PFFREC.SY1STNBR != " ")
          PFFREC.PFDCDVAL[8] = PFFREC.SY1STNBR;
          PF0P111();
        end
      end
      PFWREC.PFWSUB = PFWREC.PFWSUB + 1;
    end /* end while*/
    PFWREC.PFWTBLX = PFWREC.PFWTBLX + 1;
  end

end // end PF0P117

// close vfield01 cursor
Function PF0P118()
   /* *************************************************************/
   /* close the vfield01 cursors*/

   /* *************************************************************/



  SQLCA.VAGen_SQLCODE = 0;
  call "IO2890" ("C1", SQLCA, PFIREC) {isNoRefresh = yes, isExternal = yes}; /* vfield01 close cursor*/

  if (SQLCA.VAGen_SQLCODE == +0) /* if close successful*/
     /* this is okay*/
  else /* fatal db2 error, transfer to ta*/
    TA1REC.TA1LOCAT[2] = " ";
    PF0PW01.PF0PWKEY = " "; /* clear key redefinition area*/
    PFWREC.PFWCPROC = "PF0P116"; /* pass calling process*/
    TA1REC.TA1LOCAT[4] = "IO2890"; /* pass i/o module name*/
    TA1REC.TA1DBASE = "DPROFT";
    TA1REC.TA1TBLVU = "VFIELD01";
    XPPF010(); /* abend routine*/
  end
end // end PF0P118

// move rows frm table to ts
Function PF0P120()
   /* ***********************************************************/
   /* move w02 to temporary storage.  compute pages.*/
   /* ***********************************************************/

  PF0PW04.XXXCURDT = VGVar.currentShortGregorianDate; /* system date to map 1*/

  PFWREC.PFWIDX = 1;


    /* 9/3 conversion from CSP V3.3 to V4.1 (generates cob 2).*/
    /* The following code is to prevent a asra/0c7 due to spaces*/
    /* being in the numeric pf1sort data item (from causera).*/

  if (PF1REC.PF1-TBL-INDEX-CHAR-RDF not numeric) /* test char redefinition*/
    PF1REC.PF1TBLX = 0; /* move to numeric data item*/
  end

  if (PF1REC.PF1TBLX == 0) /* did not come in using pf keys*/
    PFWREC.PFWTBLX = 1; /* init table index;position on table*/
  else
    PFWREC.PFWTBLX = PF1REC.PF1TBLX;
  end

  if (PF0PW01.PF0PWSRT == 1)
    PF0PW04.PF0PMSRT = "*"; /* mark primary sort*/
    PF0PW04.PF0PMSR2 = " "; /* clear sort used*/
  else
    PF0PW04.PF0PMSRT = " "; /* clear sort*/
    PF0PW04.PF0PMSR2 = "*"; /* mark primary sort*/
  end

    /* move wo2 to temporary storage, w04*/

  while (PFWREC.PFWIDX <= 14)
    if (PFWREC.PFWTBLX <= PFWREC.PFWLIMIT)
                                   /* pfwtblx eq 1 even when no records*/
      PF0PW04.PFESUMNM[PFWIDX] = PF0PW02.PFESUMNM[PFWTBLX];
      PF0PW04.PFFPRTYP[PFWIDX] = PF0PW02.PFFPRTYP[PFWTBLX];
      PF0PW04.PF0PMAT1[PFWIDX] = PF0PW02.PF0PWAT1[PFWTBLX];
      PF0PW04.PF0PMAT2[PFWIDX] = PF0PW02.PF0PWAT2[PFWTBLX];
      PF0PW04.PF0PMAT3[PFWIDX] = PF0PW02.PF0PWAT3[PFWTBLX];
      PF0PW04.PF0PMAT4[PFWIDX] = PF0PW02.PF0PWAT4[PFWTBLX];
      PF0PW04.PF0PMAT5[PFWIDX] = PF0PW02.PF0PWAT5[PFWTBLX];
      PF0PW04.PF0PMAT6[PFWIDX] = PF0PW02.PF0PWAT6[PFWTBLX];
      PF0PW04.PF0PMAT7[PFWIDX] = PF0PW02.PF0PWAT7[PFWTBLX];
      PF0PW04.PF0PMAT8[PFWIDX] = PF0PW02.PF0PWAT8[PFWTBLX];
      PF0PW04.PF0PWCV1[PFWIDX] = PF0PW02.PF0PWCV1[PFWTBLX];
      PF0PW04.PF0PWCV2[PFWIDX] = PF0PW02.PF0PWCV2[PFWTBLX];
      PF0PW04.PF0PWCV3[PFWIDX] = PF0PW02.PF0PWCV3[PFWTBLX];
      PF0PW04.PF0PWCV4[PFWIDX] = PF0PW02.PF0PWCV4[PFWTBLX];
      PF0PW04.PF0PWCV5[PFWIDX] = PF0PW02.PF0PWCV5[PFWTBLX];
      PF0PW04.PF0PWCV6[PFWIDX] = PF0PW02.PF0PWCV6[PFWTBLX];
      PF0PW04.PF0PWCV7[PFWIDX] = PF0PW02.PF0PWCV7[PFWTBLX];
      PF0PW04.PF0PWCV8[PFWIDX] = PF0PW02.PF0PWCV8[PFWTBLX];
      PF0PW04.PFFSTIND[PFWIDX] = PF0PW02.PFFSTIND[PFWTBLX];
      PF0PW04.PFFPRTYI[PFWIDX] = PF0PW02.PFFPRTYI[PFWTBLX];
      PF0PW04.PFECYCIN[PFWIDX] = PF0PW02.PFECYCIN[PFWTBLX];
      PF0PW04.PFESUMNM[PFWIDX] = PF0PW02.PFESUMNM[PFWTBLX];
      PF0PW04.PFANXTNO[PFWIDX] = PF0PW02.PFANXTNO[PFWTBLX];
      PF0PW04.PFANXTNO[PFWIDX] = PF0PW02.PFANXTNO[PFWTBLX];
      PF0PW04.XXXUNTXT[PFWIDX] = PF0PW02.XXXUNTXT[PFWTBLX];
      PF0PW04.PFESQCOL[PFWIDX] = PF0PW02.PFESQCOL[PFWTBLX];
      PF0PW04.PFESEIND[PFWIDX] = PF0PW02.PFESEIND[PFWTBLX];
      PF0PW04.ZZZCHGDT[PFWIDX] = PF0PW02.ZZZCHGDT[PFWTBLX];
      PF0PW04.ZZZCHGTM[PFWIDX] = PF0PW02.ZZZCHGTM[PFWTBLX];
      PF0PW04.ZZZCHGCT[PFWIDX] = PF0PW02.ZZZCHGCT[PFWTBLX];
      PF0PW01.PF0PWDT = PF0PW02.ZZZSDT[PFWTBLX];
      PF0PW01.PF0PWMM = PF0PW01.PF0PWMTH;
      PF0PW01.PF0PWDD = PF0PW01.PF0PWDAY;
      PF0PW04.ZZZSDT[PFWIDX] = PF0PW01.PF0PWDAT;
      PF0PW04.PFCREF[PFWIDX] = PF0PW02.PFCREF[PFWTBLX];
      PF0PW04.PFBREF[PFWIDX] = PF0PW02.PFBREF[PFWTBLX];
      PF0PW04.PFDREF[PFWIDX] = PF0PW02.PFDREF[PFWTBLX];
      PF0PW04.YISCD[PFWIDX] = PF0PW02.YISCD[PFWTBLX];
      PF0PW04.PFBISGRP[PFWIDX] = PF0PW02.PFBISGRP[PFWTBLX];
      PF0PW04.PF0PWCYL[PFWIDX] = PF0PW02.PF0PWCYL[PFWTBLX];
      PF0PW04.PF0PWPRI[PFWIDX] = PF0PW02.PF0PWPRI[PFWTBLX];
      /* -------------------------------------*/
      /* cvo added 9/12/90   <=====  begin*/
      /* -------------------------------------*/
      PF0PW04.ZZZSDT[PFWIDX] = PF0PW02.ZZZSDT[PFWTBLX];
      PF0PW04.PFFRPTDS[PFWIDX] = PF0PW02.PFFRPTDS[PFWTBLX];
      PF0PW04.PFFPRLVL[PFWIDX] = PF0PW02.PFFPRLVL[PFWTBLX];
      PF0PW04.XROCD[PFWIDX] = PF0PW02.XROCD[PFWTBLX];
      PF0PW04.PFFDTFMI[PFWIDX] = PF0PW02.PFFDTFMI[PFWTBLX];
      PF0PW04.XXXNBRCY[PFWIDX] = PF0PW02.XXXNBRCY[PFWTBLX];
      PF0PW04.PFFPRFRS[PFWIDX] = PF0PW02.PFFPRFRS[PFWTBLX];
      PF0PW04.PF0PWMC1[PFWIDX] = PF0PW02.PF0PWMC1[PFWTBLX];
      PF0PW04.PF0PWMC2[PFWIDX] = PF0PW02.PF0PWMC2[PFWTBLX];
      PF0PW04.PF0PWMC3[PFWIDX] = PF0PW02.PF0PWMC3[PFWTBLX];
      PF0PW04.PF0PWMC4[PFWIDX] = PF0PW02.PF0PWMC4[PFWTBLX];
      PF0PW04.PF0PWMC5[PFWIDX] = PF0PW02.PF0PWMC5[PFWTBLX];
      PF0PW04.PF0PWMC6[PFWIDX] = PF0PW02.PF0PWMC6[PFWTBLX];
      PF0PW04.PF0PWMC7[PFWIDX] = PF0PW02.PF0PWMC7[PFWTBLX];
      PF0PW04.PF0PWMC8[PFWIDX] = PF0PW02.PF0PWMC8[PFWTBLX];
      PF0PW04.PF0PWCD1[PFWIDX] = PF0PW02.PF0PWCD1[PFWTBLX];
      PF0PW04.PF0PWCD2[PFWIDX] = PF0PW02.PF0PWCD2[PFWTBLX];
      PF0PW04.PF0PWCD3[PFWIDX] = PF0PW02.PF0PWCD3[PFWTBLX];
      PF0PW04.PF0PWCD4[PFWIDX] = PF0PW02.PF0PWCD4[PFWTBLX];
      PF0PW04.PF0PWCD5[PFWIDX] = PF0PW02.PF0PWCD5[PFWTBLX];
      PF0PW04.PF0PWCD6[PFWIDX] = PF0PW02.PF0PWCD6[PFWTBLX];
      PF0PW04.PF0PWCD7[PFWIDX] = PF0PW02.PF0PWCD7[PFWTBLX];
      PF0PW04.PF0PWCD8[PFWIDX] = PF0PW02.PF0PWCD8[PFWTBLX];
      PF0PW04.XGPCD[PFWIDX] = PF0PW02.XGPCD[PFWTBLX];
      PF0PW04.SY1STNBR[PFWIDX] = PF0PW02.SY1STNBR[PFWTBLX];
      PF0PW04.SY2CLRID[PFWIDX] = PF0PW02.SY2CLRID[PFWTBLX];
      PF0PW04.XDMCD[PFWIDX] = PF0PW02.XDMCD[PFWTBLX];
      PF0PW04.XQACD[PFWIDX] = PF0PW02.XQACD[PFWTBLX];
      PF0PW04.XLCCD[PFWIDX] = PF0PW02.XLCCD[PFWTBLX];
      PF0PW04.XXXUSRID[PFWIDX] = PF0PW02.XXXUSRID[PFWTBLX];
      PF0PW04.XXXNLTXT[PFWIDX] = PF0PW02.XXXNLTXT[PFWTBLX];
      PF0PW04.XXXNDTXT[PFWIDX] = PF0PW02.XXXNDTXT[PFWTBLX];
      /* -------------------------------------*/
      /* cvo added 9/12/90   <=====  end*/
      /* -------------------------------------*/
      if (PF0PW02.PFESRTEL[PFWTBLX] == "01") /* map 2 sequencing element*/
        PF0PW04.PFESRTEL[PFWIDX] = "01";
      else
        if (PF0PW02.PFESRTEL[PFWTBLX] == "02")
          PF0PW04.PFESRTEL[PFWIDX] = "02";
        else
          if (PF0PW02.PFESRTEL[PFWTBLX] == "03")
            PF0PW04.PFESRTEL[PFWIDX] = "03";
          else
            if (PF0PW02.PFESRTEL[PFWTBLX] == "04")
              PF0PW04.PFESRTEL[PFWIDX] = "04";
            else
              if (PF0PW02.PFESRTEL[PFWTBLX] == "05")
                PF0PW04.PFESRTEL[PFWIDX] = "05";
              else
                if (PF0PW02.PFESRTEL[PFWTBLX] == "06")
                  PF0PW04.PFESRTEL[PFWIDX] = "06";
                else
                  if (PF0PW02.PFESRTEL[PFWTBLX] == "07")
                    PF0PW04.PFESRTEL[PFWIDX] = "07";
                  else
                    if (PF0PW02.PFESRTEL[PFWTBLX] == "08")
                      PF0PW04.PFESRTEL[PFWIDX] = "08";
                    else
                      if (PF0PW02.PFESRTEL[PFWTBLX] == "09")
                        PF0PW04.PFESRTEL[PFWIDX] = "09";
                      else
                        if (PF0PW02.PFESRTEL[PFWTBLX] == "10")
                          PF0PW04.PFESRTEL[PFWIDX] = "10";
                        else
                          PF0PW04.PFESRTEL[PFWIDX] = PF0PW02.PFESRTEL[PFWTBLX];
                        end /* 10*/
                      end /* 9*/
                    end /* 8*/
                  end /* 7*/
                end /* 6*/
              end /* 5*/
            end /* 4*/
          end /* 3*/
        end /* 2*/
      end /* 1*/


      PFWREC.PFWTBLX = PFWREC.PFWTBLX + 1; /* increment table*/
    else /* short page*/

    end
    PFWREC.PFWIDX = PFWREC.PFWIDX + 1; /* increment screen*/
  end

    /* compute number of pages*/

  PFWREC.PFWCPG = PF1REC.PF1TBLX / 14; /* whole pgs*/
  PF0PW01.PF0PWREM = PF1REC.PF1TBLX % 14; /* partial pgs*/
  if (PF0PW01.PF0PWREM > 0)
    PFWREC.PFWCPG = PFWREC.PFWCPG + 1;
  end

  if (PFWREC.PFWCPG == 0) /* no records:pg 1 of 1*/
    PFWREC.PFWCPG = PFWREC.PFWCPG + 1;
    if (PFWREC.PFWTPG == 0)
      PFWREC.PFWTPG = PFWREC.PFWTPG + 1;
    end
  end
  PF0PW04.PF0PMCPG = PFWREC.PFWCPG; /* set current pg*/
  PF0PW04.PF0PMTPG = PFWREC.PFWTPG; /* set total pgs*/

  if (PF0PW01.PF0PWRIG == "Y")
    PFWREC.PFWIDX = 14;
    while (PFWREC.PFWIDX >= 1)
      if (PF0PM002.PFESUMNM[PFWIDX] == "*DELETED*")
        set PF0PM002.PF0PMSEL[PFWIDX] skip, invisible;
        set PF0PM002.PFFPRTYI[PFWIDX] skip, invisible;
        set PF0PM002.PFECYCIN[PFWIDX] skip, invisible;
        set PF0PM002.PFFSTIND[PFWIDX] skip, invisible;
      end
      PFWREC.PFWIDX = PFWREC.PFWIDX - 1;
    end
  end
end // end PF0P120

// move 14 rows frm temp to map
Function PF0P121()
   /* ***********************************************************/
   /* read temporary storage into pf0pw04. move what was read*/
   /* back into pf0pw02 for possible xfer out later*/
   /* move w02 to map 1 and map 2.  set short page data rows to*/
   /* dark.  compute pages*/
   /* ***********************************************************/

  if (PF1REC.PF1XFERF == "Y") /* if from a pf xfer*/
    PF0PW01.PF0PWTSP = PF1REC.PF1PAGE;
  end

  PF0P122(); /* read temp storage into w04*/

  set PF0PW02 empty; /* cvo added 9/12/90*/

  move PF0PW04 to PF0PW02 withV60Compat; /* temp storage read move to w02*/

  PF0PM001.XXXCURDT = VGVar.currentShortGregorianDate; /* system date to map 1*/
  PF0PM002.XXXCURDT = VGVar.currentShortGregorianDate; /* system date to map 2*/

  if (PF1REC.PF1TBLX == 0)
                                   /* did not come in using pf keys*/
    PFWREC.PFWTBLX = 1; /* init table index;position on table*/
    PF1REC.PF1TBLX = 1;
  else
    PFWREC.PFWTBLX = PF1REC.PF1TBLX;
  end

  if (PF1REC.PF1XFERF == "Y") /* if from a pf xfer*/
    PF0P101(); /* pf key index restore*/
  end

  PFWREC.PFWIDX = 1; /* screen index*/

  if (PF0PW01.PF0PWSRT == 1)
    PF0PM001.PF0PMSRT = PF0PW04.PF0PMSRT; /* mark primary sort*/
    PF0PM002.PF0PMSRT = PF0PW04.PF0PMSRT; /* mark primary sort*/
    PF0PM002.PF0PMSR2 = PF0PW04.PF0PMSR2; /* mark primary sort*/
    set PF0PM001.PF0PMSRT normal;
    set PF0PM002.PF0PMSRT normal;
    set PF0PM002.PF0PMSR2 invisible;
    set PF0PM002.PF0PMSR2 skip;
    set PF0PM001.PF0PMSRT skip;
    set PF0PM002.PF0PMSRT skip;
  else
    PF0PM001.PF0PMSRT = PF0PW04.PF0PMSRT; /* mark primary sort*/
    PF0PM002.PF0PMSRT = PF0PW04.PF0PMSRT; /* mark primary sort*/
    PF0PM002.PF0PMSR2 = PF0PW04.PF0PMSR2; /* mark primary sort*/
    set PF0PM001.PF0PMSRT invisible;
    set PF0PM002.PF0PMSRT invisible;
    set PF0PM002.PF0PMSR2 normal;
    set PF0PM002.PF0PMSR2 skip;
    set PF0PM001.PF0PMSRT skip;
    set PF0PM002.PF0PMSRT skip;
  end

    /* move temporary storage,wo4, to both maps*/

  while (PFWREC.PFWIDX <= 14)
    PF0PM001.PFESUMNM[PFWIDX] = PF0PW04.PFESUMNM[PFWTBLX];
    PF0PM001.PFFPRTYP[PFWIDX] = PF0PW04.PFFPRTYP[PFWTBLX];
    PF0PM001.PF0PMAT1[PFWIDX] = PF0PW04.PF0PMAT1[PFWTBLX];
    PF0PM001.PF0PMAT2[PFWIDX] = PF0PW04.PF0PMAT2[PFWTBLX];
    PF0PM001.PF0PMAT3[PFWIDX] = PF0PW04.PF0PMAT3[PFWTBLX];
    PF0PM001.PF0PMAT4[PFWIDX] = PF0PW04.PF0PMAT4[PFWTBLX];
    PF0PM001.PF0PMAT5[PFWIDX] = PF0PW04.PF0PMAT5[PFWTBLX];
    PF0PM001.PF0PMAT6[PFWIDX] = PF0PW04.PF0PMAT6[PFWTBLX];
    PF0PM001.PF0PMAT7[PFWIDX] = PF0PW04.PF0PMAT7[PFWTBLX];
    PF0PM001.PF0PMAT8[PFWIDX] = PF0PW04.PF0PMAT8[PFWTBLX];
    PF0PM002.PFFSTIND[PFWIDX] = PF0PW04.PFFSTIND[PFWTBLX];
    PF0PM002.PFFPRTYI[PFWIDX] = PF0PW04.PFFPRTYI[PFWTBLX];
    PF0PM002.PFECYCIN[PFWIDX] = PF0PW04.PFECYCIN[PFWTBLX];
    PF0PM002.PFESUMNM[PFWIDX] = PF0PW04.PFESUMNM[PFWTBLX];
    PF0PM002.PFANXTNO[PFWIDX] = PF0PW04.PFANXTNO[PFWTBLX];
    PF0PM001.PFANXTNO[PFWIDX] = PF0PW04.PFANXTNO[PFWTBLX];
    PF0PM002.XXXUNTXT[PFWIDX] = PF0PW04.XXXUNTXT[PFWTBLX];
    PF0PM002.PFESQCOL[PFWIDX] = PF0PW04.PFESQCOL[PFWTBLX];
    PF0PM002.PFESEIND[PFWIDX] = PF0PW04.PFESEIND[PFWTBLX];
    PF0PW01.PF0PWDT = PF0PW04.ZZZSDT[PFWTBLX];
    PF0PW01.PF0PWMM = PF0PW01.PF0PWMTH;
    PF0PW01.PF0PWDD = PF0PW01.PF0PWDAY;
    PF0PM002.ZZZSDT[PFWIDX] = PF0PW01.PF0PWDAT;
    PF0PM002.PFCREF[PFWIDX] = PF0PW04.PFCREF[PFWTBLX];
    PF0PM002.PFBREF[PFWIDX] = PF0PW04.PFBREF[PFWTBLX];
    PF0PM002.PFDREF[PFWIDX] = PF0PW04.PFDREF[PFWTBLX];
    set PF0PM002.PF0PMSEL[PFWIDX] normal;
    set PF0PM002.PFFSTIND[PFWIDX] normal;
    set PF0PM002.PFFPRTYI[PFWIDX] normal;
    set PF0PM002.PFECYCIN[PFWIDX] normal;
    set PF0PM001.PF0PMSEL[PFWIDX] normal;

    if (PF0PW04.PFESRTEL[PFWTBLX] == "01") /* map 2 sequencing element*/
      PF0PM002.PFESRTEL[PFWIDX] = "GR MRN%";
    else
      if (PF0PW04.PFESRTEL[PFWTBLX] == "02")
        PF0PM002.PFESRTEL[PFWIDX] = "GR MRGN";
      else
        if (PF0PW04.PFESRTEL[PFWTBLX] == "03")
          PF0PM002.PFESRTEL[PFWIDX] = "REVENUE";
        else
          if (PF0PW04.PFESRTEL[PFWTBLX] == "04")
            PF0PM002.PFESRTEL[PFWIDX] = "CONTRB%";
          else
            if (PF0PW04.PFESRTEL[PFWTBLX] == "05")
              PF0PM002.PFESRTEL[PFWIDX] = "CONTRIB";
            else
              if (PF0PW04.PFESRTEL[PFWTBLX] == "06")
                PF0PM002.PFESRTEL[PFWIDX] = "SHP UTS";
              else
                if (PF0PW04.PFESRTEL[PFWTBLX] == "07")
                  PF0PM002.PFESRTEL[PFWIDX] = "REV UTS";
                else
                  if (PF0PW04.PFESRTEL[PFWTBLX] == "08")
                    PF0PM002.PFESRTEL[PFWIDX] = "SEQUNTL";
                  else
                    if (PF0PW04.PFESRTEL[PFWTBLX] == "09")
                      PF0PW01.PF0PWISL = "IS ";
                      PF0PW01.PF0PWIS = PF0PW04.YISCD[PFWTBLX];
                      PF0PM002.PFESRTEL[PFWIDX] = PF0PW01.PF0PWISD;
                    else
                      if (PF0PW04.PFESRTEL[PFWTBLX] == "10")
                        PF0PW01.PF0PWISL = "IS ";
                        PF0PW01.PF0PWIS = PF0PW04.PFBISGRP[PFWTBLX];
                        PF0PM002.PFESRTEL[PFWIDX] = PF0PW01.PF0PWISD;
                      else
                        PF0PM002.PFESRTEL[PFWIDX] = PF0PW04.PFESRTEL[PFWTBLX];
                      end /* 10*/
                    end /* 9*/
                  end /* 8*/
                end /* 7*/
              end /* 6*/
            end /* 5*/
          end /* 4*/
        end /* 3*/
      end /* 2*/
    end /* 1*/


    if (PF0PW04.PFESUMNM[PFWTBLX] == " ")
      set PF0PM001.PF0PMSEL[PFWIDX] skip, invisible;
      set PF0PM001.PFESUMNM[PFWIDX] skip, invisible;
      set PF0PM001.PFFPRTYP[PFWIDX] skip, invisible;
      set PF0PM001.PF0PMAT1[PFWIDX] skip, invisible;
      set PF0PM001.PF0PMAT2[PFWIDX] skip, invisible;
      set PF0PM001.PF0PMAT3[PFWIDX] skip, invisible;
      set PF0PM001.PF0PMAT4[PFWIDX] skip, invisible;
      set PF0PM001.PF0PMAT5[PFWIDX] skip, invisible;
      set PF0PM001.PF0PMAT6[PFWIDX] skip, invisible;
      set PF0PM001.PF0PMAT7[PFWIDX] skip, invisible;
      set PF0PM001.PF0PMAT8[PFWIDX] skip, invisible;
      set PF0PM002.PF0PMSEL[PFWIDX] skip, invisible;
      set PF0PM002.PFFSTIND[PFWIDX] skip, invisible;
      set PF0PM002.PFFPRTYI[PFWIDX] skip, invisible;
      set PF0PM002.PFECYCIN[PFWIDX] skip, invisible;
      set PF0PM002.PFESUMNM[PFWIDX] skip, invisible;
      set PF0PM002.PFANXTNO[PFWIDX] skip, invisible;
      set PF0PM001.PFANXTNO[PFWIDX] skip, invisible;
      set PF0PM002.XXXUNTXT[PFWIDX] skip, invisible;
      set PF0PM002.PFESQCOL[PFWIDX] skip, invisible;
      set PF0PM002.PFESRTEL[PFWIDX] skip, invisible;
      set PF0PM002.PFESEIND[PFWIDX] skip, invisible;
      set PF0PM002.ZZZSDT[PFWIDX] skip, invisible;
      set PF0PM002.PFCREF[PFWIDX] skip, invisible;
      set PF0PM002.PFBREF[PFWIDX] skip, invisible;
      set PF0PM002.PFDREF[PFWIDX] skip, invisible;
    end
    PFWREC.PFWIDX = PFWREC.PFWIDX + 1; /* increment screen*/
    PFWREC.PFWTBLX = PFWREC.PFWTBLX + 1; /* increment table*/
  end

    /* compute number of pages*/

  PFWREC.PFWCPG = PF1REC.PF1TBLX / 14; /* whole pgs*/
  PF0PW01.PF0PWREM = PF1REC.PF1TBLX % 14; /* partial pgs*/
  if (PF0PW01.PF0PWREM > 0)
    PFWREC.PFWCPG = PFWREC.PFWCPG + 1;
  end

  if (PFWREC.PFWCPG == 0) /* no records:pg 1 of 1*/
    PFWREC.PFWCPG = PFWREC.PFWCPG + 1;
    if (PFWREC.PFWTPG == 0)
      PFWREC.PFWTPG = PFWREC.PFWTPG + 1;
    end
  end

  if (PFWREC.PFWTPG == 0)
    PFWREC.PFWTPG = PFWREC.PFWTPG + 1;
  end

  PF0PM001.PF0PMCPG = PF0PW01.PF0PWTSP; /* set current pg*/
  PF0PM002.PF0PMCPG = PF0PW01.PF0PWTSP; /* set current pg*/
  PF0PM001.PF0PMTPG = PF0PW01.TA5TSQIX; /* set total pgs*/
  PF0PM002.PF0PMTPG = PF0PW01.TA5TSQIX; /* set total pgs*/

  if (PF0PW01.TA5TSQIX < 1)
    PF0PM001.PF0PMTPG = 1; /* set total pgs to 1*/
    PF0PM002.PF0PMTPG = 1; /* set total pgs to 1*/
  end

  if (PF0PW01.PF0PWRIG == "Y")
    PFWREC.PFWIDX = 14;
    while (PFWREC.PFWIDX >= 1)
      if (PF0PM002.PFESUMNM[PFWIDX] == "*DELETED*")
        set PF0PM002.PF0PMSEL[PFWIDX] skip, invisible;
        set PF0PM002.PFFPRTYI[PFWIDX] skip, invisible;
        set PF0PM002.PFECYCIN[PFWIDX] skip, invisible;
        set PF0PM002.PFFSTIND[PFWIDX] skip, invisible;
      end
      PFWREC.PFWIDX = PFWREC.PFWIDX - 1;
    end
  end
end // end PF0P121

// Read temporary storage page
Function PF0P122()
   /* ------------------------------------------------------------*/
   /* Obtain the next page of data to display.*/
   /* ------------------------------------------------------------*/

  PF0PW04.PF0PWTSL = PF0PW01.PF0PWTSL; /* Temporary storage length*/

  TA5REC.TA5APPID = COMMAREA.CACURRAP; /* Application identification*/
  TA5REC.TA5TSQIX = PF0PW01.PF0PWTSP; /* Page number*/
  TA5REC.TA5FNCCD = "R"; /* Function code*/

  try
    call "TA0050" (PF0PW04, TA5REC) {isNoRefresh = yes, isExternal = yes};
  end /* Temporary storage*/

   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && TA5REC.TA5RTNCD == 0)          /* and normal return code*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* Otherwise, move spaces to map*/
   /* ------------------------------------------------------------*/

  set PF0PW04 empty;

  return; /* Exit to display map*/


end // end PF0P122

// converse print request dir
Function PF0P200()
   /* ****************************************************/
   /* determine which screen to show, check for fastpath,*/
   /* edit screen , check pf keys*/
   /* ****************************************************/


   /* process screen PF0PM001/002*/

  if (PF0PW01.PF0PWLEF == "Y" /* map 1*/
   || PF1REC.PF1SIDE == "L") 
    if (PF1REC.PF1XFERF == "Y") /* xfer in*/
      PF1REC.PF1XFERF = "N";

      PF0P201(); /* show map 1*/

    else

      PF0P201();

    end
  else
    if (PF0PW01.PF0PWRIG == "Y" /* map 2*/
     || PF1REC.PF1SIDE == "R")  /* xfer out from map 2*/
      if (PF1REC.PF1XFERF == "Y") /* xfer in*/
        PF1REC.PF1XFERF = "N";

        PF0P202(); /* show map 2*/

      else

        PF0P202();

        PF0PW01.PF0PWSDL = "N";
      end
    end
  end



  PFWREC.PFWERRF = "N";
  PF0PM001.VAGen_EZEMSG = " "; /* clear msg lines*/
  PFWREC.PFWMSG = " ";

  if (COMMAREA.CAMSG != " ")
    PFWREC.PFWMSG = COMMAREA.CAMSG;
  end

  if (PFWREC.PFWMSG != " ") /* some message*/
    PF0PM001.VAGen_EZEMSG = PFWREC.PFWMSG;
  end



  if (PFWREC.PFWRECF == "N") /* if not all records found*/
    if (converseVar.eventKey is enter)

      PF0P100(); /* force initialization again*/

      PFWREC.PFWEXT = "N"; /* reset exit flag cleared in init*/
      return;
    else
      if (converseVar.eventKey is pf1 /* help*/
       || converseVar.eventKey is pf3 /* exit*/
       || converseVar.eventKey is pf4) /* mstr menu*/
      else
        converseLib.validationFailed(1); /* invalid pf key pressed*/
        return;
      end
    end
  end



   /* ****************************************/
   /* fast path used ?*/
   /* ****************************************/

  PF0P210(); /* fastpath,pf1,pf3,pf4*/

  if (PFWREC.PFWERRF == "Y")
    return;
  end



   /* ****************************************/
   /* edit map 1 and  2*/
   /* ****************************************/

  PF0P220(); /* edit screen*/

  if (PFWREC.PFWERRF == "Y") /* error found*/
    return;
  end



  if (converseVar.eventKey is enter
   || converseVar.eventKey is pf18) /* refresh screen*/
    PFWREC.PFWLIMIT = 0;
    if (PF0PW01.PF0PWPRM == "N") /* priority or cycle parm entered*/
      set PF0PM001.PF0PMSEL[1] cursor;
      PFWREC.PFWIDX = 14;
      while (PFWREC.PFWIDX >= 1)
        if (PF0PW01.PF0PWLEF == "Y") /* map 1*/
          if (PF0PM001.PFESUMNM[PFWIDX] == " "
           || PF0PM001.PFESUMNM[PFWIDX] == "*DELETED*")
                                   /* from map2 status*/
            set PF0PM001.PF0PMSEL[PFWIDX] skip, invisible; /* delete*/
          end
        end
        if (PF0PW01.PF0PWRIG == "Y") /* map 2*/
          if (PF0PM002.PFESUMNM[PFWIDX] == " "
           || PF0PM002.PFESUMNM[PFWIDX] == "*DELETED*")
            set PF0PM002.PF0PMSEL[PFWIDX] skip, invisible;
          end
        end
        PFWREC.PFWIDX = PFWREC.PFWIDX - 1;
      end
    end
    set PFFREC empty;
    set PFIREC empty;
    if (PF0PW01.PF0PWDCF != "Y") /* delete confirm flag first time*/
      if (PF0PW01.PF0PWSDL != "Y") /* screen marked deleted*/
        set PF0PM002 initial; /* will be here if nothing marked for*/
                                   /* del*/
        set PF0PW02 empty;
        set PF0PW03 empty;
      else
        PFWREC.PFWIDX = 14; /* takes care of map 2 delete*/
        while (PFWREC.PFWIDX >= 1) /* with parms entered when it shows*/
          if (PF0PM002.PFESUMNM[PFWIDX] == " " /* summary parm deleted*/
           || PF0PM002.PFESUMNM[PFWIDX] == "*DELETED*")
            set PF0PM002.PF0PMSEL[PFWIDX] skip, invisible;
            set PF0PM002.PFECYCIN[PFWIDX] skip, invisible;
            set PF0PM002.PFFPRTYI[PFWIDX] skip, invisible;
            set PF0PM002.PFFSTIND[PFWIDX] skip, invisible;
          end
          if (PF0PM001.PFESUMNM[PFWIDX] == "*DELETED*")
            set PF0PM001.PF0PMSEL[PFWIDX] skip, invisible;
          end
          PFWREC.PFWIDX = PFWREC.PFWIDX - 1;
        end
      end
    else
      return;
    end

    PF0P110(); /* vrptpm01 select*/

    if (PFWREC.PFWRECF == "Y") /* records found*/
      PF0PM002.PF0PMSPP = PF0PM001.PF0PMSPP; /* show priority &*/
      PF0PM002.PF0PMSPC = PF0PM001.PF0PMSPC; /* cycle on map 2*/
      set PF0PM001 initial;
      if (PF0PM002.PF0PMSPP != " ") /* redisplay parms selected on map 1*/
        /* commented out the following line as*/
        /* part of the 9/93 conversion*/
        /* from CSP V3.3 to V4.1 (generates cob2).*/
        /* AND PF0PM002.PF0PMSPP NE 0;*/
        PF0PM001.PF0PMSPP = PF0PM002.PF0PMSPP;
      else
        PF0PM001.PF0PMSPP = " ";
      end
      if (PF0PM002.PF0PMSPC != " ")
        PF0PM001.PF0PMSPC = PF0PM002.PF0PMSPC;
      else
        PF0PM001.PF0PMSPC = " ";
      end
      PF0PW01.PF0PWTSP = PF0PW01.PF0PWTSH; /* holf to current pg*/

      PF0P121(); /* move 14 lines to map*/

    end
  end



  if (converseVar.eventKey is pf7
   || converseVar.eventKey is pf8)

    PF0P230(); /* pf7/8 scroll frwd and bkwd*/

    return;
  end



  if (converseVar.eventKey is pf10) /* show left map 1*/
    if (PF0PW01.PF0PWSLC > 0   /* select count*/
     || PF0PM001.CATOAP != " " /* fast path info*/
     || PF0PM001.CAITEM != " " 
     || PF0PM002.CATOAP != " " 
     || PF0PM002.CAITEM != " ")
      converseLib.validationFailed(068); /* can not enter data while scrolling*/
      PFWREC.PFWERRF = "Y";
      if (PF0PW01.PF0PWRIG == "Y") /* map 2*/
        PFWREC.PFWIDX = 14;
        while (PFWREC.PFWIDX >= 1)
          if (PF0PM002.PFESUMNM[PFWIDX] == " ") /* reset short pg select*/
            set PF0PM002.PF0PMSEL[PFWIDX] skip, invisible; /* it got set to*/
          end /* normal in edit scrn*/
          PFWREC.PFWIDX = PFWREC.PFWIDX - 1;
        end
      end
      return;
    end
    if (PF0PW01.PF0PWLEF == "N") /* on map 2 going to map 1*/
      PF0PW01.PF0PWLEF = "Y";
      PF1REC.PF1SIDE = "L";
      PF0PW01.PF0PWRIG = "N";
      PFWREC.PFWIDX = 14; /* on a short pg 2 of 2 coming back from*/
      while (PFWREC.PFWIDX >= 1)
                                   /* screen 2 the selects need to be dark.*/
        if (PF0PM001.PFESUMNM[PFWIDX] == " " /* they get set to normal from*/
         || PF0PM001.PFESUMNM[PFWIDX] == "*DELETED*")
          set PF0PM001.PF0PMSEL[PFWIDX] skip, invisible; /* edit screen above*/
        end
        PFWREC.PFWIDX = PFWREC.PFWIDX - 1;
      end
      return;
    else
      PFWREC.PFWERRF = "Y";
      converseLib.validationFailed(198); /* already on left map*/
      return;
    end
  end



  if (converseVar.eventKey is pf11) /* on map 1 going to map 2*/
    if (PF0PW01.PF0PWSLC > 0   
     || PF0PM001.CATOAP != " " /* fast path*/
     || PF0PM002.CATOAP != " " 
     || PF0PM001.CAITEM != " " 
     || PF0PM002.CAITEM != " ")
      converseLib.validationFailed(068); /* can not enter data while scrolling*/
      PFWREC.PFWERRF = "Y";
      return;
    end
    if (PF0PW01.PF0PWRIG == "N") /* map 1 wanting to go to map 2*/
      set PF0PM002.PF0PMSEL[1] cursor;
      PF0PW01.PF0PWRIG = "Y";
      PF0PW01.PF0PWLEF = "N";
      PF1REC.PF1SIDE = "R";
      PFWREC.PFWIDX = 14; /* will clear sel column on short pg*/
      while (PFWREC.PFWIDX >= 1)
        if (PF0PM002.PFESUMNM[PFWIDX] == " "
         || PF0PM002.PFESUMNM[PFWIDX] == "*DELETED*")
          set PF0PM002.PF0PMSEL[PFWIDX] skip, invisible;
        end
        PFWREC.PFWIDX = PFWREC.PFWIDX - 1;
      end
      if (PF1REC.PF1XFERF == "Y") /* xfer in*/
        if (PF1REC.PF1PRM != " " /* parms entered before xfer out*/
         || PF1REC.PF1CYC != " ")
          PF0PM002.PF0PMSPP = PF1REC.PF1PRM; /* display on map 2*/
          PF0PM002.PF0PMSPC = PF1REC.PF1CYC;
        end
      else
        if (PF0PW01.PF0PWPRM == "Y")
                                   /* display parms entered on map 2*/
          PF0PM002.PF0PMSPP = PF0PM001.PF0PMSPP;
          PF0PM002.PF0PMSPC = PF0PM001.PF0PMSPC;
        end
      end
      return;
    else
      PFWREC.PFWERRF = "Y";
      converseLib.validationFailed(192); /* already on right map*/
      if (PF1REC.PF1XFERF == "Y")
        if (PF1REC.PF1PRM != " "
         || PF1REC.PF1CYC != " ")
          PF0PM002.PF0PMSPP = PF1REC.PF1PRM;
          PF0PM002.PF0PMSPC = PF1REC.PF1CYC;
        end
      else
        if (PF0PW01.PF0PWPRM == "Y")
          PF0PM002.PF0PMSPP = PF0PM001.PF0PMSPP;
          PF0PM002.PF0PMSPC = PF0PM001.PF0PMSPC;
        end
      end
      return;
    end
  end



  if (converseVar.eventKey is pf14 /* xfer to pf0e*/
   || converseVar.eventKey is pf15 /* xfer to pf0f*/
   || converseVar.eventKey is pf16 /* xfer to pf0d*/
   || converseVar.eventKey is pf17) /* xfer to pf0h*/

    PF0P240(); /* pf14,15,16,17*/

    if (PFWREC.PFWERRF == "Y")
      return;
    end
  end



  if (converseVar.eventKey is pf19) /* sort*/
    if (PF0PW01.PF0PWSRT == 1 /* pfesumnm,xxxuntxt*/
     || PF1REC.PF1SORT == 1)  /* needed for pf3 back in. pf0pw01 is*/
                                   /* not kept*/
      PF0PW01.PF0PWSRT = 2; /* xxxuntxt,pfesumnm*/
      PF1REC.PF1SORT = 2; /* will override a previous sort 1*/
    else
      PF0PW01.PF0PWSRT = 1;
      PF1REC.PF1SORT = 1; /* will override a previous sort 2*/
    end
    set PFFREC empty;
    set PFIREC empty;
    PFWREC.PFWLIMIT = 0;

    PF0P110(); /* get data*/

    if (PFWREC.PFWRECF == "Y")
      PF0PW01.PF0PWTSP = PF0PW01.PF0PWTSH; /* hold to current pg*/

      PF0P121(); /* move 14 rows from ts to screen*/

      return;
    end
  end
end // end PF0P200

// left side of map
Function PF0P201()
  converse PF0PM001 ;
end // end PF0P201

// right side of map
Function PF0P202()
  converse PF0PM002 ;
end // end PF0P202

// validate pf keys,fastpath
Function PF0P210()

   /* **************************************************/
   /* *            validate pf keys                   **/
   /* **************************************************/

  PFWREC.PFWCPROC = "PF0P210"; /* set current process name*/

  if (PF0PW01.PF0PWLEF == "Y")
    if (PF0PM001.CATOAP != " " /* fast path*/
     || PF0PM001.CAITEM != " ")
      if (PF0PM001.CATOAP == "PF0P")
        set PF0PM001.CATOAP cursor, bold;
        converseLib.validationFailed(10); /* can not transfer to requested screen*/
        PFWREC.PFWERRF = "Y"; /* set error flag*/
      end
      PFWREC.PFWIDX = 14; /* start screen and table index at bottom*/
      PFWREC.PFWTBLX = PF1REC.PF1TBLX + 13;
      while (PFWREC.PFWIDX >= 1)
        if (PF0PM001.PF0PMSEL[PFWIDX] != " "
         || PF0PM001.PF0PMSEL[PFWIDX] is modified)
          PF0PM001.PF0PMSEL[PFWIDX] = " ";
          converseLib.validationFailed(2); /* do not enter data if using fastpath*/
          PFWREC.PFWERRF = "Y";
        end
        PFWREC.PFWIDX = PFWREC.PFWIDX - 1;
        PFWREC.PFWTBLX = PFWREC.PFWTBLX - 1;
      end

      if (converseVar.eventKey not enter)
        converseLib.validationFailed(190); /* press enter when using fastpath*/
        PFWREC.PFWERRF = "Y";
      end
      if (PFWREC.PFWERRF == "Y")
        return;
      else
        COMMAREA.CAUSERA = " ";
        COMMAREA.CAFROMAP = "PF0P";
        COMMAREA.CATOAP = PF0PM001.CATOAP;
        COMMAREA.CAITEM = PF0PM001.CAITEM;
        PF0P001(); /* purge temp storage*/
        XPPF002();
      end
    end

    if (PF0PM001.CATOAP == " " /* option*/
     && PF0PM001.CAITEM != " ") /* item*/
      converseLib.validationFailed(312);
      PFWREC.PFWERRF = "Y";
    end

    if (PFWREC.PFWERRF == "Y")
      return;
    end
  end /* end if left side of map*/



  if (PF0PW01.PF0PWRIG == "Y") /* map 2*/
    if (PF0PM002.CATOAP != " " /* fast path*/
     || PF0PM002.CAITEM != " ")
      if (PF0PM002.CATOAP == "PF0P")
        set PF0PM002.CATOAP cursor, bold;
        converseLib.validationFailed(10);
                                   /* can not transfer to requested screen*/
        PFWREC.PFWERRF = "Y"; /* set error flag*/
      end
      PFWREC.PFWIDX = 14; /* start screen and table index at bottom*/
      PFWREC.PFWTBLX = PF1REC.PF1TBLX + 13;
      while (PFWREC.PFWIDX >= 1)
        if (PF0PM002.PF0PMSEL[PFWIDX] != " "
         || PF0PM002.PF0PMSEL[PFWIDX] is modified)
          PF0PM002.PF0PMSEL[PFWIDX] = " ";
          converseLib.validationFailed(2); /* do not enter data if using fastpath*/
          PFWREC.PFWERRF = "Y";
        end
        PFWREC.PFWIDX = PFWREC.PFWIDX - 1;
        PFWREC.PFWTBLX = PFWREC.PFWTBLX - 1;
      end

      if (converseVar.eventKey not enter)
        converseLib.validationFailed(190); /* press enter when using fastpath*/
        PFWREC.PFWERRF = "Y";
      end
      if (PFWREC.PFWERRF == "Y")
        return;
      else
        COMMAREA.CAUSERA = " ";
        COMMAREA.CAFROMAP = "PF0P";
        COMMAREA.CATOAP = PF0PM002.CATOAP;
        COMMAREA.CAITEM = PF0PM002.CAITEM;
        PF0P001(); /* purge temp storage*/
        XPPF002();
      end
    end

    if (PF0PM002.CATOAP == " "
     && PF0PM002.CAITEM != " ")
      converseLib.validationFailed(312);
      PFWREC.PFWERRF = "Y";
    end

    if (PFWREC.PFWERRF == "Y")
      return;
    end
  end /* end if right side of map*/


  if (converseVar.eventKey is enter)
    return;
  end

  if (converseVar.eventKey is pf1) /* help*/
    PF0P001(); /* purge temp storage*/
    XSPF1();
    PF0PM001.VAGen_EZEMSG = COMMAREA.CAMSG;
    PFWREC.PFWERRF = "Y";
    return;
  end

  if (converseVar.eventKey is pf3) /* exit*/
    PF0P001(); /* purge temp storage*/
    COMMAREA.CAUSERA = " ";
    COMMAREA.CAFROMAP = "PF0P";
    COMMAREA.CATOAP = "PF0A";
    XSEXIT();
    PF0PM001.VAGen_EZEMSG = COMMAREA.CAMSG;
    PFWREC.PFWERRF = "Y";
    return;
  end

  if (converseVar.eventKey is pf4) /* master menu*/
    PF0P001(); /* purge temp storage*/
    COMMAREA.CAFROMAP = "PF0P";
    XSPF4();
    PF0PM001.VAGen_EZEMSG = COMMAREA.CAMSG;
    PFWREC.PFWERRF = "Y";
    return;
  end

  if (PF0PW01.PF0PWLEF == "Y") /* map 1*/
    if (converseVar.eventKey is pf7
     || converseVar.eventKey is pf8
     || converseVar.eventKey is pf11
     || converseVar.eventKey is pf14
     || converseVar.eventKey is pf15
     || converseVar.eventKey is pf16
     || converseVar.eventKey is pf17
     || converseVar.eventKey is pf18
     || converseVar.eventKey is pf19)
      return;
    end
  end

  if (PF0PW01.PF0PWRIG == "Y") /* map 2*/
    if (converseVar.eventKey is pf7
     || converseVar.eventKey is pf8
     || converseVar.eventKey is pf10
     || converseVar.eventKey is pf14
     || converseVar.eventKey is pf15
     || converseVar.eventKey is pf16
     || converseVar.eventKey is pf17
     || converseVar.eventKey is pf18
     || converseVar.eventKey is pf19)
      return;
    end
  end
  converseLib.validationFailed(001); /* invalid pf key*/
  PFWREC.PFWERRF = "Y"; /* set error flag*/
  return;
end // end PF0P210

// edit screen select
Function PF0P220()
   /* ************************************************************/
   /* count up selects- can not process more than one select at*/
   /* a time.  check for valid priority and cycle parms.  if on*/
   /* map 2, perform edit on those fields- if status, priority*/
   /* or cycle changed, process the appropriate function.*/
   /* ************************************************************/


  if (PF0PW01.PF0PWLEF == "Y") /* map 1*/
    set PF0PM001.CATOAP initialAttributes;
    set PF0PM001.CAITEM initialAttributes;
    PF1REC.PF1IDX = 1; /* initialize screen index save area*/
    PF0PW01.PF0PWSLC = 0; /* screen select counter*/
    PFWREC.PFWIDX = 14; /* start screen index at bottom*/
    while (PFWREC.PFWIDX >= 1)
      if (PF0PM001.PF0PMSEL[PFWIDX] != " ")
        PF0PW01.PF0PWSLC = PF0PW01.PF0PWSLC + 1;
      end
      set PF0PM001.PF0PMSEL[PFWIDX] normal; /* resets anything bright*/
      PFWREC.PFWIDX = PFWREC.PFWIDX - 1;
    end
    if (PF0PW01.PF0PWSLC > 1)
      PFWREC.PFWIDX = 14; /* start screen index at bottom*/
      while (PFWREC.PFWIDX >= 1)
        if (PF0PM001.PF0PMSEL[PFWIDX] != " ")
          PF0PM001.PF0PMSEL[PFWIDX] = " ";
          set PF0PM001.PF0PMSEL[PFWIDX] cursor, bold;
        end
        PFWREC.PFWIDX = PFWREC.PFWIDX - 1;
      end
      converseLib.validationFailed(034); /* can not process more than 1 screen*/
                                   /* sel at a time*/
      PFWREC.PFWERRF = "Y";
    end

    if (PFWREC.PFWERRF == "Y")
      return;
    end


    if (PF0PM001.PF0PMSPP == " "
     || PF0PM001.PF0PMSPP == "1"
     || PF0PM001.PF0PMSPP == "2")
      PF0PW01.PF0PWPRM = "Y";
      PF1REC.PF1PRM = " ";
      set PF0PM001.PF0PMSPP cursor, normal; /* resets if bright*/
    else
      converseLib.validationFailed(102); /* priority must be 1 or 2*/
      PFWREC.PFWERRF = "Y";
      set PF0PM001.PF0PMSPP cursor, bold;
    end

    if (PFWREC.PFWERRF == "Y")
      return;
    end

    if (PF0PM001.PF0PMSPC == " " 
     || PF0PM001.PF0PMSPC == "O" /* <=== on request*/
     || PF0PM001.PF0PMSPC == "B" /* <=== billing cutoff*/
     || PF0PM001.PF0PMSPC == "F" /* <=== first close*/
     || PF0PM001.PF0PMSPC == "P" /* <=== final (pf) close*/
     || PF0PM001.PF0PMSPC == "W" /* <=== weekly*/
     || PF0PM001.PF0PMSPC == "Q") /* <=== quarterly*/
      set PF0PM001.PF0PMSPC normal; /* reset if bright*/
      PF0PW01.PF0PWPRM = "Y";
      PF1REC.PF1CYC = " ";
    else
      converseLib.validationFailed(238); /* invalid cycle entry*/
      PFWREC.PFWERRF = "Y";
      set PF0PM001.PF0PMSPC cursor, bold;
    end

    if (PF0PM001.PF0PMSPC == " " /* no parm entered*/
     && PF0PM001.PF0PMSPP == " ")
      PF0PW01.PF0PWPRM = "N";
      PF1REC.PF1PRM = " ";
      PF1REC.PF1CYC = " ";
    end


    if (PFWREC.PFWERRF == "Y")
      return;
    end

    PFWREC.PFWIDX = 14;
    PFWREC.PFWTBLX = PF1REC.PF1TBLX + 13;
    while (PFWREC.PFWIDX >= 1)
      if (PF0PM001.PF0PMSEL[PFWIDX] == "S")
        set PF0PM001.PF0PMSEL[PFWIDX] cursor, modified;
        PF1REC.PF1IDX = PFWREC.PFWIDX; /* save screen position*/
        return; /* already determined it is only select*/
      else
        if (PF0PM001.PF0PMSEL[PFWIDX] != " ")
          set PF0PM001.PF0PMSEL[PFWIDX] cursor, bold;
          PFWREC.PFWERRF = "Y";
          PF1REC.PF1IDX = PFWREC.PFWIDX;
          converseLib.validationFailed(021); /* 's' to make selection*/
          return;
        end
      end
      PFWREC.PFWTBLX = PFWREC.PFWTBLX - 1;
      PFWREC.PFWIDX = PFWREC.PFWIDX - 1;
    end
  end


  if (PF0PW01.PF0PWRIG == "Y") /* map 2*/
    set PF0PM002.CATOAP initialAttributes;
    set PF0PM002.CAITEM initialAttributes;
    PF1REC.PF1IDX = 1; /* initialize screen index save area*/
    PF0PW01.PF0PWSLC = 0; /* screen select counter*/
    PFWREC.PFWIDX = 14; /* start screen index at bottom*/
    while (PFWREC.PFWIDX >= 1)
      if (PF0PM002.PF0PMSEL[PFWIDX] != " ")
        PF0PW01.PF0PWSLC = PF0PW01.PF0PWSLC + 1;
      end
      set PF0PM002.PF0PMSEL[PFWIDX] normal; /* resets anything bright*/
      PFWREC.PFWIDX = PFWREC.PFWIDX - 1;
    end
    if (PF0PW01.PF0PWSLC > 1)
      PFWREC.PFWIDX = 14; /* start screen index at bottom*/
      while (PFWREC.PFWIDX >= 1)
        if (PF0PM002.PF0PMSEL[PFWIDX] != " ")
          PF0PM002.PF0PMSEL[PFWIDX] = " ";
          set PF0PM002.PF0PMSEL[PFWIDX] cursor, bold;
        end
        PFWREC.PFWIDX = PFWREC.PFWIDX - 1;
      end
      converseLib.validationFailed(034); /* can not process more than 1 screen*/
                                   /* sel at a time*/
      PFWREC.PFWERRF = "Y";
    end

    if (PFWREC.PFWERRF == "Y")
      return;
    end


    PF0PW01.PF0PWSLC = 0;
    PFWREC.PFWIDX = 14;
    while (PFWREC.PFWIDX >= 1)
      if (PF0PW02.PFESUMNM[PFWIDX] == " ")
        PF0PW01.PF0PWSLC = PF0PW01.PF0PWSLC + 1;
      end
      PFWREC.PFWIDX = PFWREC.PFWIDX - 1;
    end
    if (PF0PW01.PF0PWSLC == 14)
                                   /* no records found, return to reshow*/
      PF0PW01.PF0PWSLC = 0; /* blank screen*/
      return;
    end

    PF0P221(); /* edit screen fields*/

    if (PFWREC.PFWERRF == "Y")
      PFWREC.PFWIDX = 14;
      while (PFWREC.PFWIDX >= 1)
        if (PF0PM002.PFESUMNM[PFWIDX] == " "
         || PF0PM002.PFESUMNM[PFWIDX] == "*DELETED*")
          set PF0PM002.PF0PMSEL[PFWIDX] skip, invisible;
        end
        PFWREC.PFWIDX = PFWREC.PFWIDX - 1;
      end
      return;
    else
      PFWREC.PFWIDX = 14;
      while (PFWREC.PFWIDX >= 1)
        if (PF0PM002.PFESUMNM[PFWIDX] == " "
         || PF0PM002.PFESUMNM[PFWIDX] == "*DELETED*")
          set PF0PM002.PF0PMSEL[PFWIDX] skip, invisible;
        end
        PFWREC.PFWIDX = PFWREC.PFWIDX - 1;
      end
    end

    if (PF0PW01.PF0PWSTC > 0 /* status count*/
     || PF0PW01.PF0PWPRC > 0 /* priority count*/
     || PF0PW01.PF0PWCYC > 0) /* cycle count*/
      PF0P225(); /* process status,priority and cycle*/
      if (PF0PW01.PF0PWERR == "Y")
        return;
      end
    else
      PF0PW01.PF0PWDCF = "N"; /* delete confirm flag*/
    end
  end /* if right side of map*/
end // end PF0P220

// edit screen fields
Function PF0P221()
   /* -----------------------------------------------------------;*/
     /* This routine edits the entries made by the user on      ;*/
     /* the screen.  Either a single selection may be made,     ;*/
     /* or any number of status, priority, and/or cycle changes ;*/
     /* may be made.                                            ;*/
   /* -----------------------------------------------------------;*/

  set PF0PM002.CATOAP initialAttributes;
  set PF0PM002.CAITEM initialAttributes;

  PF1REC.PF1IDX = 1; /* initialize screen index save area*/

  if (PF1REC.PF1TBLX < 1)
    PF1REC.PF1TBLX = 1;
  end

      /* Search the fields on the screen and*/
      /* determine the number of entries made.*/

  PF0PW01.PF0PWSLC = 0; /* Initialize the selection field*/
                                   /* counter*/
  PF0PW01.PF0PWSTC = 0; /* Initialize the status field chg counter*/
  PF0PW01.PF0PWPRC = 0; /* Initialize the priority field chg counter*/
  PF0PW01.PF0PWCYC = 0; /* Initialize the Cycle field change counter*/

  PFWREC.PFWIDX = 14; /* Start scrn index at bot of scrn*/
  PFWREC.PFWTBLX = PF1REC.PF1TBLX + 13; /* Start table index at bottom*/
  while (PFWREC.PFWIDX >= 1)
    if (PFWREC.PFWTBLX <= PFWREC.PFWLIMIT) /* leave unused rows dark*/
      if (PF0PW02.PFESUMNM[PFWTBLX] == "*DELETED*"
       || PF0PM002.PFESUMNM[PFWIDX] == " ")
        set PF0PM002.PF0PMSEL[PFWIDX] skip, invisible;
      else
        set PF0PM002.PFECYCIN[PFWIDX] normal; /* Reset any previous*/
        set PF0PM002.PFFPRTYI[PFWIDX] normal; /* field attribute changes*/
        set PF0PM002.PFFSTIND[PFWIDX] normal;
        set PF0PM002.PF0PMSEL[PFWIDX] normal;
      end
    end
    if (PF0PM002.PFECYCIN[PFWIDX] != PF0PW02.PFECYCIN[PFWTBLX])
      PF0PW01.PF0PWCYC = PF0PW01.PF0PWCYC + 1; /* increment cycle chg count*/
    end
    if (PF0PM002.PFFPRTYI[PFWIDX] != PF0PW02.PFFPRTYI[PFWTBLX])
      PF0PW01.PF0PWPRC = PF0PW01.PF0PWPRC + 1;
                                   /* increment priority chg cnt*/
    end
    if (PF0PM002.PFFSTIND[PFWIDX] != PF0PW02.PFFSTIND[PFWTBLX])
      PF0PW01.PF0PWSTC = PF0PW01.PF0PWSTC + 1;
                                   /* increment status chg count*/
    end
    if (PF0PM002.PF0PMSEL[PFWIDX] != " ")
      PF0PW01.PF0PWSLC = PF0PW01.PF0PWSLC + 1; /* increment selection count*/
    end
    PFWREC.PFWIDX = PFWREC.PFWIDX - 1;
    PFWREC.PFWTBLX = PFWREC.PFWTBLX - 1;
  end


      /* If both a selection and one or more status, priority,*/
      /* or cycle changes have been made, flag the error.*/

  if (PF0PW01.PF0PWSLC > 0) /* if selection count gt 0*/
    if (PF0PW01.PF0PWSTC > 0 /* if status chg count gt 0*/
     || PF0PW01.PF0PWPRC > 0 /* or priority chg count gt 0*/
     || PF0PW01.PF0PWCYC > 0) /* or cycle chg count gt 0*/
      PFWREC.PFWIDX = 14; /* Start scrn index at bot of scrn*/
      PFWREC.PFWTBLX = PF1REC.PF1TBLX + 13; /* Start table index at bottom*/
      while (PFWREC.PFWIDX >= 1)
        if (PF0PM002.PFECYCIN[PFWIDX] != PF0PW02.PFECYCIN[PFWTBLX])
          PF0PM002.PFECYCIN[PFWIDX] = PF0PW02.PFECYCIN[PFWTBLX];
          set PF0PM002.PFECYCIN[PFWIDX] cursor, bold;
        end
        if (PF0PM002.PFFPRTYI[PFWIDX] != PF0PW02.PFFPRTYI[PFWTBLX])
          PF0PM002.PFFPRTYI[PFWIDX] = PF0PW02.PFFPRTYI[PFWTBLX];
          set PF0PM002.PFFPRTYI[PFWIDX] cursor, bold;
        end
        if (PF0PM002.PFFSTIND[PFWIDX] != PF0PW02.PFFSTIND[PFWTBLX])
          PF0PM002.PFFSTIND[PFWIDX] = PF0PW02.PFFSTIND[PFWTBLX];
          set PF0PM002.PFFSTIND[PFWIDX] cursor, bold;
        end
        if (PF0PM002.PF0PMSEL[PFWIDX] != " ")
          set PF0PM002.PF0PMSEL[PFWIDX] cursor, bold;
        end
        PFWREC.PFWIDX = PFWREC.PFWIDX - 1;
        PFWREC.PFWTBLX = PFWREC.PFWTBLX - 1;
      end
      converseLib.validationFailed(064); /* if a selection is made, no other entries*/
      PFWREC.PFWERRF = "Y"; /* may be made*/
    end
  end


      /* If more than one selection has been made, flag the*/
      /* error.*/

  if (PF0PW01.PF0PWSLC > 1) /* if selection count gt 1*/
    PFWREC.PFWIDX = 14; /* Start scrn index at bot of scrn*/
    while (PFWREC.PFWIDX >= 1)
      if (PF0PM002.PF0PMSEL[PFWIDX] != " ")
        PF0PM002.PF0PMSEL[PFWIDX] = " ";
        set PF0PM002.PF0PMSEL[PFWIDX] cursor, bold;
      end
      PFWREC.PFWIDX = PFWREC.PFWIDX - 1;
    end
    converseLib.validationFailed(034); /* cannot process more than 1 selection at a time*/
    PFWREC.PFWERRF = "Y";
  end


      /* If an error has occured, return.*/

  if (PFWREC.PFWERRF == "Y")
    return;
  end


   /* -----------------------------------------------------------;*/
     /* At this point one of three conditions can exist: 1) No  ;*/
     /* changes were made to the screen.  2) A single selection ;*/
     /* field had an 'S' entry.  3) One or more status,         ;*/
     /* priority, and/or cycle changes have been made.          ;*/
     /* The valid statuses are blank, 'O', 'I', 'N', 'H', and   ;*/
     /* 'D'.  The valid priorities are 1 (immediate) and        ;*/
     /* 2 (overnight).  The valid cycles are 'o', 'b', 'f',     ;*/
     /* 'p', 'w', or 'q'.                                       ;*/
   /* -----------------------------------------------------------;*/


      /* Search the entire screen for valid entries.*/
      /* Flag those that are in error.*/

  PFWREC.PFWIDX = 14;
  PFWREC.PFWTBLX = PF1REC.PF1TBLX + 13;
  while (PFWREC.PFWIDX >= 1)

    PF0P222(); /* edit cycle field*/

    if (PF0PM002.PFFPRTYI[PFWIDX] != PF0PW02.PFFPRTYI[PFWTBLX])

      PF0P223(); /* edit priority field*/

    end
    if (PF0PM002.PFFSTIND[PFWIDX] != PF0PW02.PFFSTIND[PFWTBLX])

      PF0P224(); /* edit status field*/

    end
    if (PF0PM002.PF0PMSEL[PFWIDX] == "S")
      set PF0PM002.PF0PMSEL[PFWIDX] cursor, modified;
      PF1REC.PF1IDX = PFWREC.PFWIDX; /* Save screen position*/
      return; /* ok to exit because already determined this is only sel*/
    else
      if (PF0PM002.PF0PMSEL[PFWIDX] != " ")
        set PF0PM002.PF0PMSEL[PFWIDX] cursor, bold;
        converseLib.validationFailed(021); /* the letter 's' must be used to make a sel*/
        PFWREC.PFWERRF = "Y";
        PF1REC.PF1IDX = PFWREC.PFWIDX; /* Save screen position*/
        return; /* ok to exit because already determined this is only sel*/
      end
    end
    PFWREC.PFWIDX = PFWREC.PFWIDX - 1;
    PFWREC.PFWTBLX = PFWREC.PFWTBLX - 1;
  end
end // end PF0P221

// edit cycle field
Function PF0P222()
   /* ------------------------------------------------------------*/
   /* change processing cycles, 9/10/90, cvo  <=== begin*/
   /* ------------------------------------------------------------*/
  if (PF0PW02.PF0PWCYL[PFWTBLX] == "F") /* summary cycle is 'f'*/
    if (PF0PM002.PFECYCIN[PFWIDX] == "F"
     || PF0PM002.PFECYCIN[PFWIDX] == "O")
       /* this is ok*/
    else
      set PF0PM002.PFECYCIN[PFWIDX] cursor, bold;
      converseLib.validationFailed(266); /* sum cyc is f; prt cyc mst be 'f' or 'o'*/
      PFWREC.PFWERRF = "Y";
    end
  end

  if (PF0PW02.PF0PWCYL[PFWTBLX] == "B") /* summary cycle is 'b'*/
    if (PF0PM002.PFECYCIN[PFWIDX] == "B"
     || PF0PM002.PFECYCIN[PFWIDX] == "O")
       /* this is ok*/
    else
      set PF0PM002.PFECYCIN[PFWIDX] cursor, bold;
      converseLib.validationFailed(267); /* sum cyc is f; prt cyc mst be 'b' or 'o'*/
      PFWREC.PFWERRF = "Y";
    end
  end

  if (PF0PW02.PF0PWCYL[PFWTBLX] == "P") /* summary cycle is 'p'*/
    if (PF0PM002.PFECYCIN[PFWIDX] == "P"
     || PF0PM002.PFECYCIN[PFWIDX] == "O")
       /* this is ok*/
    else
      set PF0PM002.PFECYCIN[PFWIDX] cursor, bold;
      converseLib.validationFailed(268); /* sum cyc is f; prt cyc mst be 'p' or 'o'*/
      PFWREC.PFWERRF = "Y";
    end
  end

  if (PF0PW02.PF0PWCYL[PFWTBLX] == "W") /* summary cycle is 'w'*/
    if (PF0PM002.PFECYCIN[PFWIDX] == "W"
     || PF0PM002.PFECYCIN[PFWIDX] == "O")
       /* this is ok*/
    else
      set PF0PM002.PFECYCIN[PFWIDX] cursor, bold;
      converseLib.validationFailed(269); /* sum cyc is w; prt cyc mst be 'w' or 'o'*/
      PFWREC.PFWERRF = "Y";
    end
  end

  if (PF0PW02.PF0PWCYL[PFWTBLX] == "Q") /* summary cycle is 'q'*/
    if (PF0PM002.PFECYCIN[PFWIDX] == "Q"
     || PF0PM002.PFECYCIN[PFWIDX] == "O")
       /* this is ok*/
    else
      set PF0PM002.PFECYCIN[PFWIDX] cursor, bold;
      converseLib.validationFailed(345); /* sum cyc is f; prt cyc mst be 'q' or 'o'*/
      PFWREC.PFWERRF = "Y";
    end
  end

  if (PF0PW02.PF0PWCYL[PFWTBLX] == "O") /* summary cycle is 'o'*/
    if (PF0PM002.PFECYCIN[PFWIDX] == "O") /* param cycle must be 'o' only*/
       /* this is ok*/
    else
      set PF0PM002.PFECYCIN[PFWIDX] cursor, bold;
      converseLib.validationFailed(270); /* sum cyc is f; prt cyc mst be 'q' or 'o'*/
      PFWREC.PFWERRF = "Y";
    end
  end

   /* ------------------------------------------------------------*/
   /* change processing cycles, 9/10/90, cvo  <=== end*/
   /* ------------------------------------------------------------*/
end // end PF0P222

// edit priority field
Function PF0P223()

  if (PF0PM002.PFFPRTYI[PFWIDX] == "1" /* immediate*/
   || PF0PM002.PFFPRTYI[PFWIDX] == "2") /* overnight*/
     /* this is okay*/
  else
    set PF0PM002.PFFPRTYI[PFWIDX] cursor, bold;
    converseLib.validationFailed(102); /* priority mst be '1'(immed) or '2' (ovrnght)*/
    PFWREC.PFWERRF = "Y";
    return;
  end
end // end PF0P223

// edit status field
Function PF0P224()

  if (PF0PW02.PFFSTIND[PFWTBLX] == " ") /* if existing status is ' '*/
    if (PF0PM002.PFFSTIND[PFWIDX] == "H" /* if new status is 'h'*/
     || PF0PM002.PFFSTIND[PFWIDX] == "D") /* or new status is 'd'*/

      if (COMMAREA.CACLVL[1] == "Y" /* Security OK or*/
       || PF0PW02.XXXUSRID[PFWTBLX] == COMMAREA.CAUSERID) /* Same user*/
         /* this is okay*/
      else
        set PF0PM002.PFFSTIND[PFWIDX] cursor, bold;
        converseLib.validationFailed(119); /* userid not authorized to update this record*/
        PFWREC.PFWERRF = "Y";
      end
    else
      set PF0PM002.PFFSTIND[PFWIDX] cursor, bold;
      converseLib.validationFailed(065); /* status ' ' can be changed only to 'H' or 'D'*/
      PFWREC.PFWERRF = "Y";
    end
    return;
  end

  if (PF0PW02.PFFSTIND[PFWTBLX] == "H") /* if existing status is 'h'*/
    if (PF0PM002.PFFSTIND[PFWIDX] == " " /* if new status is ' '*/
     || PF0PM002.PFFSTIND[PFWIDX] == "D") /* or new status is 'd'*/
      if (COMMAREA.CACLVL[1] == "Y" /* Security OK or*/
       || PF0PW02.XXXUSRID[PFWTBLX] == COMMAREA.CAUSERID) /* Same user*/
         /* this is okay*/
      else
        set PF0PM002.PFFSTIND[PFWIDX] cursor, bold;
        converseLib.validationFailed(119);
        PFWREC.PFWERRF = "Y";
      end
    else
      set PF0PM002.PFFSTIND[PFWIDX] cursor, bold;
      converseLib.validationFailed(350); /* status 'h' can change only to ' ' or 'd'*/
      PFWREC.PFWERRF = "Y";
    end
  end

end // end PF0P224

// process status,priority,cycle
Function PF0P225()
   /* -----------------------------------------------------------;*/
     /* Process changes to the status, priority, & cycle fields.;*/
   /* -----------------------------------------------------------;*/


  PF0P226(); /* check stat, prty, & cycl secur*/

  if (PFWREC.PFWERRF == "Y")
    return;
  end


      /* Do the following unless there was a delete requested*/
      /* and this is the second time through for it.*/
      /* Brighten each status, priority, or cycle field changed.*/
      /* If a delete is requested, generate a delete*/
      /* confirmation needed message, set the delete*/
      /* confirmation message issued flag to yes, and return*/
      /* after processing the whole screen.  Also, if a delete is*/
      /* requested, leave the cursor on the upper-most 'D'*/
      /* entered on the screen.*/

  if (PF0PW01.PF0PWDCF == "N") /* delete confirm msg issued flag*/
    PFWREC.PFWIDX = 14;
    PFWREC.PFWTBLX = PF1REC.PF1TBLX + 13;
    while (PFWREC.PFWIDX >= 1)
      if (PF0PM002.PFECYCIN[PFWIDX] != PF0PW02.PFECYCIN[PFWTBLX])
        if (PF0PW01.PF0PWDCF == "Y") /* if found a 'd' already*/
          set PF0PM002.PFECYCIN[PFWIDX] bold; /* don't move cursor*/
        else
          set PF0PM002.PFECYCIN[PFWIDX] cursor, bold;
        end
      end
      if (PF0PM002.PFFPRTYI[PFWIDX] != PF0PW02.PFFPRTYI[PFWTBLX])
        if (PF0PW01.PF0PWDCF == "Y") /* if found a 'd' already*/
          set PF0PM002.PFFPRTYI[PFWIDX] bold; /* don't move cursor*/
        else
          set PF0PM002.PFFPRTYI[PFWIDX] cursor, bold;
        end
      end
      if (PF0PM002.PFFSTIND[PFWIDX] != PF0PW02.PFFSTIND[PFWTBLX])
        if (PF0PM002.PFFSTIND[PFWIDX] == "D")
          PF0PM002.PFFSTIND[PFWIDX] = PF0PW02.PFFSTIND[PFWTBLX];
          set PF0PM002.PFFSTIND[PFWIDX] cursor, bold;
          converseLib.validationFailed(304); /* del requested; re-enter 'd' stat to confirm*/
          PF0PW01.PF0PWDCF = "Y";
                                   /* delete confirm msg issued flag*/
        else
          if (PF0PW01.PF0PWDCF == "Y") /* if found a 'd' already*/
            set PF0PM002.PFFSTIND[PFWIDX] bold; /* don't move cursor*/
          else
            set PF0PM002.PFFSTIND[PFWIDX] cursor, bold;
          end
        end
      end
      PFWREC.PFWIDX = PFWREC.PFWIDX - 1;
      PFWREC.PFWTBLX = PFWREC.PFWTBLX - 1;
    end
     /* Note that when a delete is requested, if other changes*/
     /* are made on the screen, these other changes are not*/
     /* saved in the database until the delete is confirmed.*/
    if (PF0PW01.PF0PWDCF == "Y") /* delete confirm msg issued flag*/
      return;
    end
  end


      /* If this IS the second time through on a delete,*/
      /* (the delete confirmation message issued flag is yes),*/
      /* check that no fields on the screen have been modified,*/
      /* except for re-entering the 'D' to confirm the delete.*/
      /* If any are modified, brighten them, give an error*/
      /* message, reset the delete confirmation message issued*/
      /* flag, and return after processing the whole screen.*/

  if (PF0PW01.PF0PWDCF == "Y") /* delete confirm msg issued flag*/
    PFWREC.PFWIDX = 14;
    PFWREC.PFWTBLX = PF1REC.PF1TBLX + 13;
    while (PFWREC.PFWIDX >= 1)
      if (PF0PM002.PFECYCIN[PFWIDX] is modified)
        PF0PM002.PFECYCIN[PFWIDX] = PF0PW02.PFECYCIN[PFWTBLX];
        set PF0PM002.PFECYCIN[PFWIDX] cursor, bold;
        converseLib.validationFailed(196); /* cannot change data before confirming delete.*/
        PF0PW01.PF0PWDCF = "N"; /* reset dlt confirm msg issued flag*/
        PFWREC.PFWERRF = "Y";
      end
      if (PF0PM002.PFFPRTYI[PFWIDX] is modified)
        PF0PM002.PFFPRTYI[PFWIDX] = PF0PW02.PFFPRTYI[PFWTBLX];
        set PF0PM002.PFFPRTYI[PFWIDX] cursor, bold;
        converseLib.validationFailed(196); /* cannot change data before confirming delete*/
        PF0PW01.PF0PWDCF = "N"; /* reset dlt confirm msg issued flag*/
        PFWREC.PFWERRF = "Y";
      end
      if (PF0PM002.PFFSTIND[PFWIDX] is modified
       && PF0PM002.PFFSTIND[PFWIDX] != "D") /* and not confirming delete*/
        PF0PM002.PFFSTIND[PFWIDX] = PF0PW02.PFFSTIND[PFWTBLX];
        set PF0PM002.PFFSTIND[PFWIDX] cursor, bold;
        converseLib.validationFailed(196); /* cannot change data before confirming delete*/
        PF0PW01.PF0PWDCF = "N"; /* reset dlt confirm msg issued flag*/
        PFWREC.PFWERRF = "Y";
      end
      if (PF0PM002.PF0PMSEL[PFWIDX] is modified)
        PF0PM002.PF0PMSEL[PFWIDX] = " ";
        set PF0PM002.PF0PMSEL[PFWIDX] cursor, bold;
        converseLib.validationFailed(196); /* cannot change data before confirming delete*/
        PF0PW01.PF0PWDCF = "N"; /* reset dlt confirm msg issued flag*/
        PFWREC.PFWERRF = "Y";
      end
      PFWREC.PFWIDX = PFWREC.PFWIDX - 1;
      PFWREC.PFWTBLX = PFWREC.PFWTBLX - 1;
    end
    if (PFWREC.PFWERRF == "Y")
      return;
    end
  end


      /* Update summary attribute row in CSP table and*/
      /* database table for each summary with a status,*/
      /* priority, or cycle change.*/

  PFWREC.PFWIDX = 14;
  PFWREC.PFWTBLX = PF1REC.PF1TBLX + 13;
  while (PFWREC.PFWIDX >= 1
   && PFWREC.PFWERRF == "N")
    if (PF0PM002.PFFSTIND[PFWIDX] != PF0PW02.PFFSTIND[PFWTBLX]) /* stat chgd*/

      PF0P227(); /* perform status change*/

      if (PF0PW01.PF0PWERR == "Y") /* row not found in pf0p915 update.*/
        return; /* due to zzz chg count being different*/
      end /* back out & refresh*/

    end
     /* If status is changed, then any priority or cycle changes*/
       /* are processed above with the status change and the*/
       /* following is skipped.*/
     /* If status is not changed, but the priority or cycle IS*/
       /* changed, then these changes are processed in the*/
       /* following.*/
    if (PF0PM002.PFFSTIND[PFWIDX] == PF0PW02.PFFSTIND[PFWTBLX]) /* no st chg*/
      if (PF0PM002.PFFPRTYI[PFWIDX] != PF0PW02.PFFPRTYI[PFWTBLX] /* pry chg*/
       || PF0PM002.PFECYCIN[PFWIDX] != PF0PW02.PFECYCIN[PFWTBLX])
                                   /* cy chg*/
        PF0PW02.PFFPRTYI[PFWTBLX] = PF0PM002.PFFPRTYI[PFWIDX];
        PF0PW02.PFECYCIN[PFWTBLX] = PF0PM002.PFECYCIN[PFWIDX];

        PF0P915(); /* vrptpm01 table update*/

        if (PF0PW01.PF0PWERR == "Y") /* row not found from pf0p915 update*/
          return; /* zzz chg count different. back out*/
        end /* and refresh*/
      end
    end
    PFWREC.PFWIDX = PFWREC.PFWIDX - 1;
    PFWREC.PFWTBLX = PFWREC.PFWTBLX - 1;
  end

  PF0PW01.PF0PWDCF = "N"; /* reset dlt confirm msg issued flag*/
end // end PF0P225

// check stat, prty, & cycl secur
Function PF0P226()
   /* -----------------------------------------------------------;*/
      /* Check security for each status, priority, or cycle     ;*/
      /* changed.  Note that 'Change' security rather than      ;*/
      /* 'delete' security is checked.                          ;*/
   /* -----------------------------------------------------------;*/

  PFWREC.PFWIDX = 14;
  PFWREC.PFWTBLX = PF1REC.PF1TBLX + 13;
  while (PFWREC.PFWIDX >= 1)

    if (PF0PM002.PFECYCIN[PFWIDX] is modified
     || PF0PM002.PFECYCIN[PFWIDX] != PF0PW02.PFECYCIN[PFWTBLX])
      if (COMMAREA.CACHGFL == "Y") /* check change security*/
        if (COMMAREA.CAUSERID == PF0PW02.XXXUSRID[PFWTBLX]
         || COMMAREA.CACLVL[1] == "Y") /* check change security*/
           /* this is okay*/
        else
                                   /* cannot change this particular summary*/
          PF0PM002.PFECYCIN[PFWIDX] = PF0PW02.PFECYCIN[PFWTBLX];
          set PF0PM002.PFECYCIN[PFWIDX] cursor, bold;
          converseLib.validationFailed(119); /* userid not authorized to update this rec*/
          PFWREC.PFWERRF = "Y";
        end
      else /* cannot change any summary*/
        PF0PM002.PFECYCIN[PFWIDX] = PF0PW02.PFECYCIN[PFWTBLX];
        set PF0PM002.PFECYCIN[PFWIDX] cursor, bold;
        converseLib.validationFailed(71); /* user not authorized for this action*/
        PFWREC.PFWERRF = "Y";
      end
    end

    if (PF0PM002.PFFPRTYI[PFWIDX] is modified
     || PF0PM002.PFFPRTYI[PFWIDX] != PF0PW02.PFFPRTYI[PFWTBLX])
      if (COMMAREA.CACHGFL == "Y") /* check change security*/
        if (COMMAREA.CAUSERID == PF0PW02.XXXUSRID[PFWTBLX]
         || COMMAREA.CACLVL[1] == "Y") /* check change security*/
           /* this is okay*/
        else
                                   /* cannot change this particular summary*/
          PF0PM002.PFFPRTYI[PFWIDX] = PF0PW02.PFFPRTYI[PFWTBLX];
          set PF0PM002.PFFPRTYI[PFWIDX] cursor, bold;
          converseLib.validationFailed(119); /* userid not authorized to update this rec*/
          PFWREC.PFWERRF = "Y";
        end
      else /* cannot change any summary*/
        PF0PM002.PFFPRTYI[PFWIDX] = PF0PW02.PFFPRTYI[PFWTBLX];
        set PF0PM002.PFFPRTYI[PFWIDX] cursor, bold;
        converseLib.validationFailed(71); /* user not authorized for this action*/
        PFWREC.PFWERRF = "Y";
      end
    end

    if (PF0PM002.PFFSTIND[PFWIDX] is modified
     || PF0PM002.PFFSTIND[PFWIDX] != PF0PW02.PFFSTIND[PFWTBLX])
      if (COMMAREA.CACHGFL == "Y") /* check change security*/
        if (COMMAREA.CAUSERID == PF0PW02.XXXUSRID[PFWTBLX]
         || COMMAREA.CACLVL[1] == "Y") /* check change security*/
           /* this is okay*/
        else
                                   /* cannot change this particular summary*/
          PF0PM002.PFFSTIND[PFWIDX] = PF0PW02.PFFSTIND[PFWTBLX];
          set PF0PM002.PFFSTIND[PFWIDX] cursor, bold;
          converseLib.validationFailed(119); /* userid not authorized to update this rec*/
          PFWREC.PFWERRF = "Y";
        end
      else /* cannot change any summary*/
        PF0PM002.PFFSTIND[PFWIDX] = PF0PW02.PFFSTIND[PFWTBLX];
        set PF0PM002.PFFSTIND[PFWIDX] cursor, bold;
        converseLib.validationFailed(71); /* user not authorized for this action*/
        PFWREC.PFWERRF = "Y";
      end
    end
    PFWREC.PFWIDX = PFWREC.PFWIDX - 1;
    PFWREC.PFWTBLX = PFWREC.PFWTBLX - 1;
  end
end // end PF0P226

// perform status change
Function PF0P227()
  if (PF0PM002.PFFSTIND[PFWIDX] == "D") /* if the change is TO delete*/
    if (PF0PW01.PF0PWDCF == "Y") /* delete confirm msg issued flag*/
      PF0P228();
    end
     /* The dlt confirmation msg should have been issued if this*/
     /* process is performed. If it has not then do nothing.*/
  else /* status changed, but not to delete*/
    PF0PW02.PFFSTIND[PFWTBLX] = PF0PM002.PFFSTIND[PFWIDX];
    /* priority & cycle are saved because they may have changed too*/
    PF0PW02.PFFPRTYI[PFWTBLX] = PF0PM002.PFFPRTYI[PFWIDX];
    PF0PW02.PFECYCIN[PFWTBLX] = PF0PM002.PFECYCIN[PFWIDX];

    PF0P915(); /* vrptpm01 table update*/

    if (PF0PW01.PF0PWERR == "Y")
                                   /* row was not found in pf0p915. row was*/
      return; /* updated by another pgm(zzz chg count*/
    end /* is different).  back out & refresh.*/

  end
end // end PF0P227

// delete summary
Function PF0P228()
   /* -----------------------------------------------------------;*/
     /* set key up for delete of the parameter.  the key will   ;*/
     /* be summary name and sequence number.  delete parameter. ;*/
   /* -----------------------------------------------------------;*/

  set PFFREC empty;

  PFFREC.PFESUMNM = PF0PM002.PFESUMNM[PFWIDX]; /* summary name*/
  PFFREC.PFANXTNO = PF0PM002.PFANXTNO[PFWIDX]; /* sequence number*/

  PF0P820(); /* delete rptpm's for this sum*/

  if (PFWREC.PFWERRF == "Y")
    return;
  end

  converseLib.validationFailed(351); /* print parameter has been deleted*/


   /* -----------------------------------------------------------;*/
     /* Mark the screen row as '*DELETED*', clear the remainder ;*/
     /* of the row, and protect the input fields.               ;*/
   /* -----------------------------------------------------------;*/

  PF0PM002.PF0PMSEL[PFWIDX] = " ";
  PF0PM002.PFFSTIND[PFWIDX] = " ";
  PF0PM002.PFFPRTYI[PFWIDX] = " ";
  PF0PM002.PFECYCIN[PFWIDX] = " ";
  PF0PM002.PFESUMNM[PFWIDX] = "*DELETED*";
  PF0PM001.PFESUMNM[PFWIDX] = "*DELETED*";
  PF0PM002.XXXUNTXT[PFWIDX] = " ";
  PF0PM002.ZZZSDT[PFWIDX] = 0;
  PF0PM002.PFANXTNO[PFWIDX] = 0;
  PF0PM002.PFCREF[PFWIDX] = 0;
  PF0PM002.PFBREF[PFWIDX] = 0;
  PF0PM002.PFDREF[PFWIDX] = 0;
  PF0PM002.PFESQCOL[PFWIDX] = 0;
  PF0PM002.PFESRTEL[PFWIDX] = " ";
  PF0PM002.PFESEIND[PFWIDX] = " ";

  PF0PM001.PFANXTNO[PFWIDX] = 0;
  PF0PM001.PF0PMAT1[PFWIDX] = " ";
  PF0PM001.PF0PMAT2[PFWIDX] = " ";
  PF0PM001.PF0PMAT3[PFWIDX] = " ";
  PF0PM001.PF0PMAT4[PFWIDX] = " ";
  PF0PM001.PF0PMAT5[PFWIDX] = " ";
  PF0PM001.PF0PMAT6[PFWIDX] = " ";
  PF0PM001.PF0PMAT7[PFWIDX] = " ";
  PF0PM001.PF0PMAT8[PFWIDX] = " ";
  PF0PM001.PFFPRTYP[PFWIDX] = " ";

  set PF0PM002.PFECYCIN[PFWIDX] skip, invisible;
  set PF0PM002.PFFPRTYI[PFWIDX] skip, invisible;
  set PF0PM002.PFFSTIND[PFWIDX] skip, invisible;
  set PF0PM002.PF0PMSEL[PFWIDX] skip, invisible;
  PF0PW01.PF0PWSDL = "Y";


   /* -----------------------------------------------------------;*/
     /* Mark the PF0pW02 working storage table row as           ;*/
     /* '*DELETED*' and clear the remainder of the row.         ;*/
   /* -----------------------------------------------------------;*/

  PF0PW02.PFESUMNM[PFWTBLX] = "*DELETED*";
  PF0PW02.PFANXTNO[PFWTBLX] = 0;
   /*  */
     /* 9/93 changed the following line from moving 0 to moving space*/
     /* as part of the conversion from CSP V3.3 to V4.1 (gens cob 2).*/
  PF0PW02.PFFPRTYP[PFWTBLX] = " ";

  PF0PW02.PFCREF[PFWTBLX] = 0;
  PF0PW02.PFBREF[PFWTBLX] = 0;
  PF0PW02.PFDREF[PFWTBLX] = 0;
  PF0PW02.PFFRPTDS[PFWTBLX] = " ";
  PF0PW02.PFFPRLVL[PFWTBLX] = " ";
  PF0PW02.XROCD[PFWTBLX] = " ";
  PF0PW02.PFFDTFMI[PFWTBLX] = " ";
  PF0PW02.PFFPRTYI[PFWTBLX] = " ";
  PF0PW02.PFESRTEL[PFWTBLX] = " ";
  PF0PW02.PFESEIND[PFWTBLX] = " ";
  PF0PW02.PFESQCOL[PFWTBLX] = 0;
  PF0PW02.PFECYCIN[PFWTBLX] = " ";
  PF0PW02.XXXUSRID[PFWTBLX] = " ";
  PF0PW02.PFFSTIND[PFWTBLX] = " ";
  PF0PW02.PF0PWMC1[PFWTBLX] = " ";
  PF0PW02.PF0PWMC2[PFWTBLX] = " ";
  PF0PW02.PF0PWMC3[PFWTBLX] = " ";
  PF0PW02.PF0PWMC4[PFWTBLX] = " ";
  PF0PW02.PF0PWMC5[PFWTBLX] = " ";
  PF0PW02.PF0PWMC6[PFWTBLX] = " ";
  PF0PW02.PF0PWMC7[PFWTBLX] = " ";
  PF0PW02.PF0PWMC8[PFWTBLX] = " ";
  PF0PW02.PF0PWCD1[PFWTBLX] = " ";
  PF0PW02.PF0PWCD2[PFWTBLX] = " ";
  PF0PW02.PF0PWCD3[PFWTBLX] = " ";
  PF0PW02.PF0PWCD4[PFWTBLX] = " ";
  PF0PW02.PF0PWCD5[PFWTBLX] = " ";
  PF0PW02.PF0PWCD6[PFWTBLX] = " ";
  PF0PW02.PF0PWCD7[PFWTBLX] = " ";
  PF0PW02.PF0PWCD8[PFWTBLX] = " ";
  PF0PW02.PF0PWCV1[PFWTBLX] = " ";
  PF0PW02.PF0PWCV2[PFWTBLX] = " ";
  PF0PW02.PF0PWCV3[PFWTBLX] = " ";
  PF0PW02.PF0PWCV4[PFWTBLX] = " ";
  PF0PW02.PF0PWCV5[PFWTBLX] = " ";
  PF0PW02.PF0PWCV6[PFWTBLX] = " ";
  PF0PW02.PF0PWCV7[PFWTBLX] = " ";
  PF0PW02.PF0PWCV8[PFWTBLX] = " ";
  PF0PW02.XGPCD[PFWTBLX] = " ";
  PF0PW02.SY1STNBR[PFWTBLX] = " ";
  PF0PW02.SY2CLRID[PFWTBLX] = " ";
  PF0PW02.XDMCD[PFWTBLX] = " ";
  PF0PW02.XQACD[PFWTBLX] = " ";
  PF0PW02.XLCCD[PFWTBLX] = " ";
  PF0PW02.XXXUNTXT[PFWTBLX] = " ";
  PF0PW02.XXXNLTXT[PFWTBLX] = " ";
  PF0PW02.XXXNDTXT[PFWTBLX] = " ";
  PF0PW02.PF0PWAT1[PFWTBLX] = " ";
  PF0PW02.PF0PWAT2[PFWTBLX] = " ";
  PF0PW02.PF0PWAT3[PFWTBLX] = " ";
  PF0PW02.PF0PWAT4[PFWTBLX] = " ";
  PF0PW02.PF0PWAT5[PFWTBLX] = " ";
  PF0PW02.PF0PWAT6[PFWTBLX] = " ";
  PF0PW02.PF0PWAT7[PFWTBLX] = " ";
  PF0PW02.PF0PWAT8[PFWTBLX] = " ";
  PF0PW02.ZZZSDT[PFWTBLX] = 0;
  PF0PW02.ZZZCHGDT[PFWTBLX] = 0;
  PF0PW02.ZZZCHGTM[PFWTBLX] = 0;
  PF0PW02.ZZZCHGCT[PFWTBLX] = 0;
  PF0PW02.XXXNBRCY[PFWTBLX] = 0;
  PF0PW02.PFFPRFRS[PFWTBLX] = 0;
  PF0PW02.YISCD[PFWTBLX] = 0;
  PF0PW02.PFBISGRP[PFWTBLX] = 0;
  PF0PW02.PF0PWCYL[PFWTBLX] = " ";
  PF0PW02.PF0PWPRI[PFWTBLX] = " ";
end // end PF0P228

// process pf7 and pf8 scrolling
Function PF0P230()
  if (PF0PW01.PF0PWSLC > 0) /* select count*/
    PFWREC.PFWIDX = 14; /* start screen index at bottom*/
    while (PFWREC.PFWIDX >= 1)
      if (PF0PW01.PF0PWLEF == "Y") /* map 1*/
        if (PF0PM001.PF0PMSEL[PFWIDX] != " ")
          PF0PM001.PF0PMSEL[PFWIDX] = " ";
          set PF0PM001.PF0PMSEL[PFWIDX] cursor, bold;
        end
      end
      if (PF0PW01.PF0PWRIG == "Y") /* map 2*/
        if (PF0PM002.PF0PMSEL[PFWIDX] != " ")
          PF0PM002.PF0PMSEL[PFWIDX] = " ";
          set PF0PM002.PF0PMSEL[PFWIDX] cursor, bold;
        end
      end
      PFWREC.PFWIDX = PFWREC.PFWIDX - 1;
    end
    converseLib.validationFailed(68); /* can not enter data while scrolling*/
    PFWREC.PFWERRF = "Y";
    return;
  end

  if (converseVar.eventKey is pf7)
    if (PF0PW01.PF0PWTSP < 2)
      converseLib.validationFailed(195);
                                   /* can not scroll up; beginning of data*/
      PF1REC.PF1TBLX = 1;
      PFWREC.PFWIDX = 14; /* takes care of a short pg w/a pf8.*/
      while (PFWREC.PFWIDX >= 1) /* the select uscore was getting restored*/
        if (PF0PW01.PF0PWLEF == "Y")
          if (PF0PM001.PFESUMNM[PFWIDX] == " ") /* from edit screen reset of*/
            set PF0PM001.PF0PMSEL[PFWIDX] skip, invisible; /* bright*/
          end
        end
        if (PF0PW01.PF0PWRIG == "Y")
          if (PF0PM002.PFESUMNM[PFWIDX] == " ") /* from edit screen reset of*/
            set PF0PM002.PF0PMSEL[PFWIDX] skip, invisible; /* bright*/
          end
        end
        PFWREC.PFWIDX = PFWREC.PFWIDX - 1;
      end
      PFWREC.PFWERRF = "Y";
      return;
    end
    PF0PW01.PF0PWTSP = PF0PW01.PF0PWTSP - 1;
    PF0PW01.PF0PWTSH = PF0PW01.PF0PWTSP;
    PF0PW01.PF0PWHSP = PF0PM001.PF0PMSPP; /* priority parm to hold*/
    PF0PW01.PF0PWHSC = PF0PM001.PF0PMSPC; /* cycle parm to hold*/
    set PF0PM001 initial; /* clear screen*/
    set PF0PM002 initial; /* clear screen*/
    PF0PM001.PF0PMSPP = PF0PW01.PF0PWHSP; /* hold to map*/
    PF0PM002.PF0PMSPP = PF0PW01.PF0PWHSP; /* hold to map*/
    PF0PM001.PF0PMSPC = PF0PW01.PF0PWHSC; /* hold to map*/
    PF0PM002.PF0PMSPC = PF0PW01.PF0PWHSC; /* hold to map*/
    PF0P121();
                                   /* move 14 rows from csp table to screen*/
    return;
  end

  if (converseVar.eventKey is pf8) /* scroll down*/
    if (PF0PW01.PF0PWTSP >= PF0PW01.TA5TSQIX)
      converseLib.validationFailed(32); /* can not scroll down- end of data*/
      PFWREC.PFWIDX = 14; /* takes care of a short pg w/a pf8.*/
      while (PFWREC.PFWIDX >= 1) /* the select uscore was getting restored*/
        if (PF0PW01.PF0PWLEF == "Y")
          if (PF0PM001.PFESUMNM[PFWIDX] == " ") /* from edit screen reset of*/
            set PF0PM001.PF0PMSEL[PFWIDX] skip, invisible; /* bright*/
          end
        end
        if (PF0PW01.PF0PWRIG == "Y")
          if (PF0PM002.PFESUMNM[PFWIDX] == " ") /* from edit screen reset of*/
            set PF0PM002.PF0PMSEL[PFWIDX] skip, invisible; /* bright*/
          end
        end
        PFWREC.PFWIDX = PFWREC.PFWIDX - 1;
      end
      PFWREC.PFWERRF = "Y";
      return;
    end
    PF0PW01.PF0PWTSP = PF0PW01.PF0PWTSP + 1;
    PF0PW01.PF0PWTSH = PF0PW01.PF0PWTSP;
    PF0PW01.PF0PWHSP = PF0PM001.PF0PMSPP; /* priority parm to hold*/
    PF0PW01.PF0PWHSC = PF0PM001.PF0PMSPC; /* cycle parm to hold*/
    set PF0PM001 initial; /* clear screen*/
    set PF0PM002 initial; /* clear screen*/
    PF0PM001.PF0PMSPP = PF0PW01.PF0PWHSP; /* hold to map*/
    PF0PM002.PF0PMSPP = PF0PW01.PF0PWHSP; /* hold to map*/
    PF0PM001.PF0PMSPC = PF0PW01.PF0PWHSC; /* hold to map*/
    PF0PM002.PF0PMSPC = PF0PW01.PF0PWHSC; /* hold to map*/
    PF0P121(); /* move ts to w04 to screen*/
    return;
  end
end // end PF0P230

// process pf14 - 17 appl bridge
Function PF0P240()
   /* -----------------------------------------------------------;*/
     /* This routine sets up the data to be passed and then     ;*/
     /* bridges to another Profitablity application:            ;*/
        /* PF 14 goes to PF0E and back (Format)                 ;*/
        /* PF 15 goes to PF0F and back (Report Attribute)       ;*/
        /* PF 16 goes to PF0D and back (I/S Group)              ;*/
        /* PF 17 goes to PF0h and back (Summary View)           ;*/
   /* -----------------------------------------------------------;*/

  if (PF0PW01.PF0PWSLC != 1)
                                   /* if selection count ne 1 (no sel made)*/
    set PF0PM001.PF0PMSEL[1] cursor;
    converseLib.validationFailed(67); /* must select a summary for this pf function*/
    PFWREC.PFWERRF = "Y";
    PFWREC.PFWIDX = 14; /* short pg 2 needs to clear remaining*/
                                   /* selects*/
    while (PFWREC.PFWIDX >= 1) /* reset to normal from edit screen before*/
      if (PF0PM001.PFESUMNM[PFWIDX] == " ") /* reaching here.*/
        set PF0PM001.PF0PMSEL[PFWIDX] skip, invisible;
      end
      PFWREC.PFWIDX = PFWREC.PFWIDX - 1;
    end
    return;
  end

  set PFEREC empty;
  PFEREC.PFESUMNM = PF0PM001.PFESUMNM[PF1IDX]; /* needed for prerec key*/
  PF0P241();

   /* Move the attribute data from the screen to the PF1REC area*/
   /* to be passed to another application.*/

  PF1REC.PF1XFERF = "Y"; /* Transfer via PF key flag*/
  PF1REC.PF1PDEFF = "Y"; /* Predefined format flag*/
  PF1REC.PF1FMT = PFEREC.PFCREF; /* format reference number*/
  PF1REC.PF1ISG = PFEREC.PFBREF; /* i/s reference number*/
  PF1REC.PF1ATT = PFEREC.PFDREF; /* report attr ref num*/
  PF1REC.PF1NAM = PF0PM001.PFESUMNM[PF1IDX]; /* Summary Name*/
  PF1REC.PF1ATR1 = PF0PM001.PF0PMAT1[PF1IDX]; /* attr 1 scrn index*/
  PF1REC.PF1ATR2 = PF0PM001.PF0PMAT2[PF1IDX]; /* attribute 2*/
  PF1REC.PF1ATR3 = PF0PM001.PF0PMAT3[PF1IDX]; /* attribute 3*/
  PF1REC.PF1ATR4 = PF0PM001.PF0PMAT4[PF1IDX]; /* attribute 4*/
  PF1REC.PF1ATR5 = PF0PM001.PF0PMAT5[PF1IDX]; /* attribute 5*/
  PF1REC.PF1ATR6 = PF0PM001.PF0PMAT6[PF1IDX]; /* attribute 6*/
  PF1REC.PF1ATR7 = PF0PM001.PF0PMAT7[PF1IDX]; /* attribute 7*/
  PF1REC.PF1ATR8 = PF0PM001.PF0PMAT8[PF1IDX]; /* attribute 8*/
  PF1REC.PF1ANX = PF0PM002.PFANXTNO[PF1IDX]; /* sequence no.*/
  PF1REC.PF1SORT = PF0PW01.PF0PWSRT;
  PF1REC.PF1PAGE = PF0PW01.PF0PWTSP;
  PF1REC.PF1ORIG = "PF0P"; /* Originating Appl.*/
  PF1REC.PF1CURR = "PF0P"; /* Current Appl.*/
  if (PF0PW01.PF0PWLEF == "Y")
    PF1REC.PF1SIDE = "L";
  else
    PF1REC.PF1SIDE = "R";
  end

  if (converseVar.eventKey is pf17)
    COMMAREA.CAITEM = PF0PM001.PFFPRTYP[PF1IDX];
  end

  if (PF1REC.PF1PRM != " ")
      /* filled in already if using parameters thru the else stmt*/
  else
    PF1REC.PF1PRM = PF0PM001.PF0PMSPP; /* priority parameter*/
  end

  if (PF1REC.PF1CYC != " ")
    /* filled in already if using parameters*/
  else
    PF1REC.PF1CYC = PF0PM001.PF0PMSPC; /* cycle parameter*/
  end

  PFWREC.PFWSUB = 1;
  PF0PW01.PF0PWFND = "N";
  while (PFWREC.PFWSUB <= 14
   && PF0PW01.PF0PWFND == "N")
    if (PF0PM001.PFESUMNM[PF1IDX] == PF0PW02.PFESUMNM[PFWSUB]
     && PF0PM002.PFANXTNO[PF1IDX] == PF0PW02.PFANXTNO[PFWSUB])
      PF0PW01.PF0PWFND = "Y";
      PF1REC.PFDCDVAL[1] = PF0PW02.PF0PWCV1[PFWSUB];
      PF1REC.PFDCDVAL[2] = PF0PW02.PF0PWCV2[PFWSUB];
      PF1REC.PFDCDVAL[3] = PF0PW02.PF0PWCV3[PFWSUB];
      PF1REC.PFDCDVAL[4] = PF0PW02.PF0PWCV4[PFWSUB];
      PF1REC.PFDCDVAL[5] = PF0PW02.PF0PWCV5[PFWSUB];
      PF1REC.PFDCDVAL[6] = PF0PW02.PF0PWCV6[PFWSUB];
      PF1REC.PFDCDVAL[7] = PF0PW02.PF0PWCV7[PFWSUB];
      PF1REC.PFDCDVAL[8] = PF0PW02.PF0PWCV8[PFWSUB];
    end
    PFWREC.PFWSUB = PFWREC.PFWSUB + 1;
  end


  PF0P001(); /* purge temp storage*/
  XPPF200(); /* Bridge Routine*/

  if (PFWREC.PFWERRF == "Y") /* If xfer fails*/
    if (PF0PW01.PF0PWLEF == "Y")
      PFWREC.PFWIDX = 14; /* clear remaining selects*/
      while (PFWREC.PFWIDX >= 1) /* reset to normal from edit screen before*/
        if (PF0PM001.PFESUMNM[PFWIDX] == " ") /* reaching here.*/
          set PF0PM001.PF0PMSEL[PFWIDX] skip, invisible;
        end
        PFWREC.PFWIDX = PFWREC.PFWIDX - 1;
      end
    end
    if (PF0PW01.PF0PWRIG == "Y")
      PFWREC.PFWIDX = 14; /* clear remaining selects*/
      while (PFWREC.PFWIDX >= 1) /* reset to normal from edit screen before*/
        if (PF0PM002.PFESUMNM[PFWIDX] == " ") /* reaching here.*/
          set PF0PM002.PF0PMSEL[PFWIDX] skip, invisible;
        end
        if (PF0PM002.PFESUMNM[PFWIDX] == "*DELETED*") /* reaching here.*/
          set PF0PM002.PF0PMSEL[PFWIDX] skip, invisible;
          set PF0PM002.PFFPRTYI[PFWIDX] skip, invisible;
          set PF0PM002.PFECYCIN[PFWIDX] skip, invisible;
          set PF0PM002.PFFSTIND[PFWIDX] skip, invisible;
        end
        PFWREC.PFWIDX = PFWREC.PFWIDX - 1;
      end
    end
    PF0PM001.VAGen_EZEMSG = COMMAREA.CAMSG; /* handle bad transfer*/
    set PF0PM001.PF0PMSEL[PF1IDX] cursor;
    set PF0PM002.PF0PMSEL[PF1IDX] cursor;
    return;
  end
end // end PF0P240

// vsumat01 select unique
Function PF0P241()
   /* *****************************************************/
    /* get the fmt, i/s and att needed for map 2*/
   /* *****************************************************/

  call "IO2770" ("S ", SQLCA, PFEREC) {isNoRefresh = yes, isExternal = yes}; /* vsumat01 select unique*/

  if (SQLCA.VAGen_SQLCODE == +0) /* if row found*/
     /* this is okay - handle in calling process*/
  else
    if (SQLCA.VAGen_SQLCODE == +100) /* if row not found*/
      PFWREC.PFWERRF = "Y";
      return;
    else
      if (SQLCA.VAGen_SQLCODE == -911) /* if table page busy*/
        converseLib.validationFailed(114); /* data base was busy, please retry*/
        PFWREC.PFWERRF = "Y";
      else /* fatal db2 error, transfer to ta*/
        TA1REC.TA1LOCAT[2] = " ";
        PFWREC.PFWHKEY = PFEREC.PFESUMNM;
        PFWREC.PFWCPROC = "PF0P241"; /* pass calling process*/
        TA1REC.TA1LOCAT[4] = "IO2770"; /* pass i/o module name*/
        TA1REC.TA1DBASE = "DPROFT";
        TA1REC.TA1TBLVU = "VSUMAT01";
        XPPF010(); /* abend routine*/
      end
    end
  end
end // end PF0P241

// vrptat01 select unique
Function PF0P242()
   /* *****************************************************/
    /* select unique the att to check pfdvalfl*/
   /* *****************************************************/

  call "IO2740" ("S ", SQLCA, PFDREC) {isNoRefresh = yes, isExternal = yes}; /* vrptat01 select unique*/

  if (SQLCA.VAGen_SQLCODE == +0) /* if row found*/
    if (PFDREC.PFDVALFL[PFWSUB] == "Y")
      PF0PW01.PF0PWSTR[PFWSUB] = "*";
    end
  else
    if (SQLCA.VAGen_SQLCODE == +100) /* if row not found*/
      PFWREC.PFWERRF = "Y";
      return;
    else
      if (SQLCA.VAGen_SQLCODE == -911) /* if table page busy*/
        converseLib.validationFailed(114); /* data base was busy, please retry*/
        PFWREC.PFWERRF = "Y";
      else /* fatal db2 error, transfer to ta*/
        TA1REC.TA1LOCAT[2] = " ";
        PFWREC.PFWHKEY = PFEREC.PFESUMNM;
        PFWREC.PFWCPROC = "PF0P242"; /* pass calling process*/
        TA1REC.TA1LOCAT[4] = "IO2740"; /* pass i/o module name*/
        TA1REC.TA1DBASE = "DPROFT";
        TA1REC.TA1TBLVU = "VRPTAT01";
        XPPF010(); /* abend routine*/
      end
    end
  end
end // end PF0P242

// delete rptpm's for this sum
Function PF0P820()
   /* -----------------------------------------------------------;*/
     /* get requested parameter based on summary name and seq   ;*/
   /* -----------------------------------------------------------;*/

   /* key built in calling processes*/

   /* PERFORM PF0P921                 ; vrptpm01 select scan*/

   /* IF PFWREC.PFWERRF EQ 'Y'        ; if db2 access unsuccessful*/
    /* EZERTN;*/
   /* END ;*/


   /* -----------------------------------------------------------;*/
     /* Select and delete the parameter.*/
   /* -----------------------------------------------------------;*/

  PF0PW01.PF0PWRPF = "N"; /* init vrptpm01 select complete flag*/
  while (PF0PW01.PF0PWRPF == "N" /* vrptpm01 select complete flag*/
   && PFWREC.PFWERRF == "N")

    PF0P922(); /* vrptpm01 select unique*/

    if (PFWREC.PFWERRF == "N")

      PF0P924(); /* vrptpm01 delete*/

    end
  end

   /* -----------------------------------------------------------;*/
     /* Close the cursor.                                       ;*/
   /* -----------------------------------------------------------;*/

   /* PERFORM PF0P923                 ; vrptpm01 close scan*/
end // end PF0P820

// vrptpm01 table update
Function PF0P915()
   /* -----------------------------------------------------------;*/
     /* This process moves one row of the CSP table to the      ;*/
     /* corresponding fields of PFFREC and updates the data     ;*/
     /* base with that single row.  if the row is not found due ;*/
     /* to another pgm updating the report attributes, a message;*/
     /* stating the row was updated elsewhere will be issued &  ;*/
     /* a refresh map will occur.                               ;*/
   /* -----------------------------------------------------------;*/

  set PFFREC empty;
   /* ***** note: PF0pW02 must exactly match PFfREC*/
   /* truncation will occur on w02 for the part not matching*/
   /* pffrec*/

  PFFREC.PFFGROUP = PF0PW02.PF0PWGRP[PFWTBLX]; /* move group level*/
   /* --------------------------------------------------*/
   /* cvo added 9/12/90  <=====  begin*/
   /* --------------------------------------------------*/
  PFFREC.PFFFMCH[1] = PF0PW02.PF0PWMC1[PFWTBLX];
  PFFREC.PFFFMCH[2] = PF0PW02.PF0PWMC2[PFWTBLX];
  PFFREC.PFFFMCH[3] = PF0PW02.PF0PWMC3[PFWTBLX];
  PFFREC.PFFFMCH[4] = PF0PW02.PF0PWMC4[PFWTBLX];
  PFFREC.PFFFMCH[5] = PF0PW02.PF0PWMC5[PFWTBLX];
  PFFREC.PFFFMCH[6] = PF0PW02.PF0PWMC6[PFWTBLX];
  PFFREC.PFFFMCH[7] = PF0PW02.PF0PWMC7[PFWTBLX];
  PFFREC.PFFFMCH[8] = PF0PW02.PF0PWMC8[PFWTBLX];

  PFFREC.PFICD[1] = PF0PW02.PF0PWCD1[PFWTBLX];
  PFFREC.PFICD[2] = PF0PW02.PF0PWCD2[PFWTBLX];
  PFFREC.PFICD[3] = PF0PW02.PF0PWCD3[PFWTBLX];
  PFFREC.PFICD[4] = PF0PW02.PF0PWCD4[PFWTBLX];
  PFFREC.PFICD[5] = PF0PW02.PF0PWCD5[PFWTBLX];
  PFFREC.PFICD[6] = PF0PW02.PF0PWCD6[PFWTBLX];
  PFFREC.PFICD[7] = PF0PW02.PF0PWCD7[PFWTBLX];
  PFFREC.PFICD[8] = PF0PW02.PF0PWCD8[PFWTBLX];

  PFFREC.PFDCDVAL[1] = PF0PW02.PF0PWCV1[PFWTBLX];
  PFFREC.PFDCDVAL[2] = PF0PW02.PF0PWCV2[PFWTBLX];
  PFFREC.PFDCDVAL[3] = PF0PW02.PF0PWCV3[PFWTBLX];
  PFFREC.PFDCDVAL[4] = PF0PW02.PF0PWCV4[PFWTBLX];
  PFFREC.PFDCDVAL[5] = PF0PW02.PF0PWCV5[PFWTBLX];
  PFFREC.PFDCDVAL[6] = PF0PW02.PF0PWCV6[PFWTBLX];
  PFFREC.PFDCDVAL[7] = PF0PW02.PF0PWCV7[PFWTBLX];
  PFFREC.PFDCDVAL[8] = PF0PW02.PF0PWCV8[PFWTBLX];
   /* --------------------------------------------------*/
   /* cvo added 9/12/90  <=====  end*/
   /* --------------------------------------------------*/

  XPPF030(); /* ta0040 date/time call routine*/

  PFFREC.ZZZCHGDT = TA2REC.TA2GRGGN; /* move system date*/
  PFFREC.ZZZCHGTM = TA2REC.TA2TIMHM; /* move system time*/

  if (PFEREC.PFESTIND == " ")
    PFEREC.ZZNBRROW = 0; /* Active when new col defined*/
  end


  call "IO2880" ("U ", SQLCA, PFFREC) {isNoRefresh = yes, isExternal = yes}; /* table update*/

  if (SQLCA.VAGen_SQLCODE == +0) /* if table i/o successful*/
    converseLib.validationFailed(15); /* changes have been entered*/
    set PF0PM002.PFECYCIN[PFWIDX] initialAttributes; /* reset to normal intensity*/
    set PF0PM002.PFFPRTYI[PFWIDX] initialAttributes; /* reset to normal intensity*/
    set PF0PM002.PFFSTIND[PFWIDX] initialAttributes; /* reset to normal intensity*/
    PF0PW01.PF0PWERR = "N";
  else
    if (SQLCA.VAGen_SQLCODE == +100) /* if row not found*/
      converseLib.validationFailed(333); /* row has been updated by another pgm*/
      PF0PW01.PF0PWERR = "N"; /* this will cause a back out to pf0p200*/
      return; /* which will then refresh the map*/
    else
      if (SQLCA.VAGen_SQLCODE == -911) /* if table page busy*/
        converseLib.validationFailed(114); /* data base was busy, please retry*/
        PFWREC.PFWERRF = "N"; /* will reshow map*/
      else /* fatal db2 error, transfer to ta*/
        TA1REC.TA1LOCAT[2] = " ";
        PFWREC.PFWHKEY = PF0PW02.PFESUMNM;
        PFWREC.PFWCPROC = "PF0P915"; /* pass calling process*/
        TA1REC.TA1LOCAT[4] = "IO2880"; /* pass i/o module name*/
        TA1REC.TA1DBASE = "DPROFT";
        TA1REC.TA1TBLVU = "VRPTPM01";
        XPPF010(); /* abend routine*/
      end
    end
  end
end // end PF0P915

// vrptpm01 select next
Function PF0P922()
  call "IO2880" ("S ", SQLCA, PFFREC) {isNoRefresh = yes, isExternal = yes}; /* vrptpm01 select unique*/

  if (SQLCA.VAGen_SQLCODE == +0) /* if row found*/
    PF0PW01.PF0PWRPF = "Y"; /* set vrptpm01 select complete flag*/
  else
    if (SQLCA.VAGen_SQLCODE == +100) /* if row not found*/
      PF0PW01.PF0PWRPF = "Y"; /* set vrptpm01 select complete flag*/
    else
      if (SQLCA.VAGen_SQLCODE == -911) /* if table page busy*/
        converseLib.validationFailed(114); /* data base was busy, please retry*/
        PFWREC.PFWERRF = "Y";
      else /* fatal db2 error, transfer to ta*/
        TA1REC.TA1LOCAT[2] = " ";
        PF0PW01.PF0PWKEY = " "; /* clear key redefinition area*/
        PF0PW01.PF0PWKC1 = PFFREC.PFESUMNM; /* key char 1 area*/
        PF0PW01.PF0PWKB2 = PFFREC.PFANXTNO; /* key binary 2 area*/
        PFWREC.PFWHKEY = PF0PW01.PF0PWKEY;
                                   /* move key to hold key area*/
        PFWREC.PFWCPROC = "PF0P922"; /* pass calling process*/
        TA1REC.TA1LOCAT[4] = "IO2880"; /* pass i/o module name*/
        TA1REC.TA1DBASE = "DPROFT";
        TA1REC.TA1TBLVU = "VRPTPM01";
        XPPF010(); /* abend routine*/
      end
    end
  end
end // end PF0P922

// vrptpm01 delete
Function PF0P924()
  call "IO2880" ("D ", SQLCA, PFFREC) {isNoRefresh = yes, isExternal = yes}; /* vrptpm01 delete*/

  if (SQLCA.VAGen_SQLCODE == +0) /* if row found*/
     /* this is okay - handle in calling process*/
  else
    if (SQLCA.VAGen_SQLCODE == -911) /* if table page busy*/
      converseLib.validationFailed(114); /* data base was busy, please retry*/
      PFWREC.PFWERRF = "Y";
    else /* fatal db2 error, transfer to ta*/
      TA1REC.TA1LOCAT[2] = " ";
      PF0PW01.PF0PWKEY = " "; /* clear key redefinition area*/
      PF0PW01.PF0PWKC1 = PFFREC.PFESUMNM; /* move to key char 1 area*/
      PF0PW01.PF0PWKB2 = PFFREC.PFANXTNO;
                                   /* move to key binary 2 area*/
      PFWREC.PFWHKEY = PF0PW01.PF0PWKEY; /* move key to hold key area*/
      PFWREC.PFWCPROC = "PF0P924"; /* pass calling process*/
      TA1REC.TA1LOCAT[4] = "IO2880"; /* pass i/o module name*/
      TA1REC.TA1DBASE = "DPROFT";
      TA1REC.TA1TBLVU = "VRPTPM01";
      XPPF010(); /* abend routine*/
    end
  end
end // end PF0P924

//*** RECORD=PF0PW01 ****
//      working storage fields unique to application pf0p.
// 
// maintenance log
// date        init          comments
// --------   -------      ---------------------
// 2-15-90     bmanil      installed application
// ***********************
Record PF0PW01 type basicRecord
  10 PF0PWSLC PF0PWSLC ; 
  10 PF0PWKEY PF0PWKEY ; 
    15 PF0PWKC1 PF0PWKC1 ; 
      20 PF0PWKB1 PF0PWKB1 ; 
      20 PF0PWKF1 PF0PWKF1 ; 
    15 PF0PWKB2 PF0PWKB2 ; 
    15 PF0PWKF2 PF0PWKF2 ; 
  10 PF0PWATR PF0PWATR [8] ; 
    15 PF0PWSTR PF0PWSTR ; 
    15 PF0PWABR PF0PWABR ; 
  10 PF0PWREM PF0PWREM ; 
  10 PF0PWLEF PF0PWLEF ; 
  10 PF0PWRIG PF0PWRIG ; 
  10 PF0PWFLG PF0PWFLG ; 
  10 PF0PWPRM PF0PWPRM ; 
  10 PF0PWSRT PF0PWSRT ; 
  10 PF0PWSTC PF0PWSTC ; 
  10 PF0PWPRC PF0PWPRC ; 
  10 PF0PWCYC PF0PWCYC ; 
  10 PF0PWDCF PF0PWDCF ; 
  10 PF0PWRPF PF0PWRPF ; 
  10 PF0PWDT PF0PWDT ; 
    15 PF0PWCEN PF0PWCEN ; 
    15 PF0PWYR PF0PWYR ; 
    15 PF0PWMTH PF0PWMTH ; 
    15 PF0PWDAY PF0PWDAY ; 
  10 PF0PWDAT PF0PWDAT ; 
    15 PF0PWMM PF0PWMM ; 
    15 PF0PWDD PF0PWDD ; 
  10 PF0PWSAF PF0PWSAF ; 
  10 PF0PWSDL PF0PWSDL ; 
  10 PF0PWISD PF0PWISD ; 
    15 PF0PWISL PF0PWISL ; 
    15 PF0PWIS PF0PWIS ; 
  10 PF0PWFND PF0PWFND ; 
  10 PF0PWCYL PF0PWCYL ; 
  10 PF0PWPRI PF0PWPRI ; 
  10 PF0PWERR PF0PWERR ; 
  10 PF0PWADD PF0PWADD ; 
  10 PF0PWTSL PF0PWTSL ; 
  10 PF0PWTSP PF0PWTSP ; 
  10 PF0PWTSH PF0PWTSH ; 
  10 TA5TSQIX TA5TSQIX ; 
  10 PF0PWLMT PF0PWLMT ; 
  10 PF0PWHSP PF0PWHSP ; 
  10 PF0PWHSC PF0PWHSC ; 
end // end PF0PW01

//*** RECORD=PF0PW02 ****
// PF0PW02 is used as the internal table occuring 200 times
// for the loading of PFFREC.  It is assumed that PFFREC has
// at this time appromimately 200 records.
// The pfffmch, pfcid, pfdcdval are repeated 8 times as place
// holders to match pffrec occurs 8 times.
// 
// the first portion of this record must match pffrec & pf0pw04
// records.  this record also contains data besides pffrec.
// do not change anything following the pffrec portion.
// 
// maintenance log
//    date     init         comments
// --------   -------   ------------------
// 02-15-90   bmanil    installed application
// 10-10-90   cvo       increased record length from 272 to 274
//                      due to Oct. table changes on xrocd.
// ;
// ***********************
Record PF0PW02 type basicRecord
  10 PF0PWGRP PF0PWGRP [14] ; 
    15 PFESUMNM PFESUMNM ; 
    15 PFANXTNO PFANXTNO ; 
    15 PFFSTIND PFFSTIND ; 
    15 PFFRPTDS PFFRPTDS ; 
    15 PFFPRLVL PFFPRLVL ; 
    15 XROCD XROCD ; 
    15 PFFDTFMI PFFDTFMI ; 
    15 PFFPRTYP PFFPRTYP ; 
    15 XXXNBRCY XXXNBRCY ; 
    15 PFFPRTYI PFFPRTYI ; 
    15 PFFPRFRS PFFPRFRS ; 
    15 PFECYCIN PFECYCIN ; 
    15 PF0PWMC1 PF0PWMC1 ; 
    15 PF0PWMC2 PF0PWMC2 ; 
    15 PF0PWMC3 PF0PWMC3 ; 
    15 PF0PWMC4 PF0PWMC4 ; 
    15 PF0PWMC5 PF0PWMC5 ; 
    15 PF0PWMC6 PF0PWMC6 ; 
    15 PF0PWMC7 PF0PWMC7 ; 
    15 PF0PWMC8 PF0PWMC8 ; 
    15 PF0PWCD1 PF0PWCD1 ; 
    15 PF0PWCD2 PF0PWCD2 ; 
    15 PF0PWCD3 PF0PWCD3 ; 
    15 PF0PWCD4 PF0PWCD4 ; 
    15 PF0PWCD5 PF0PWCD5 ; 
    15 PF0PWCD6 PF0PWCD6 ; 
    15 PF0PWCD7 PF0PWCD7 ; 
    15 PF0PWCD8 PF0PWCD8 ; 
    15 PF0PWCV1 PF0PWCV1 ; 
    15 PF0PWCV2 PF0PWCV2 ; 
    15 PF0PWCV3 PF0PWCV3 ; 
    15 PF0PWCV4 PF0PWCV4 ; 
    15 PF0PWCV5 PF0PWCV5 ; 
    15 PF0PWCV6 PF0PWCV6 ; 
    15 PF0PWCV7 PF0PWCV7 ; 
    15 PF0PWCV8 PF0PWCV8 ; 
    15 XGPCD XGPCD ; 
    15 SY1STNBR SY1STNBR ; 
    15 SY2CLRID SY2CLRID ; 
    15 XDMCD XDMCD ; 
    15 XQACD XQACD ; 
    15 XLCCD XLCCD ; 
    15 PFESRTEL PFESRTEL ; 
    15 YISCD YISCD ; 
    15 PFBISGRP PFBISGRP ; 
    15 PFESEIND PFESEIND ; 
    15 PFESQCOL PFESQCOL ; 
    15 XXXUSRID XXXUSRID ; 
    15 XXXUNTXT XXXUNTXT ; 
    15 XXXNLTXT XXXNLTXT ; 
    15 XXXNDTXT XXXNDTXT ; 
    15 ZZZSDT ZZZSDT ; 
    15 ZZZCHGDT ZZZCHGDT ; 
    15 ZZZCHGTM ZZZCHGTM ; 
    15 ZZZCHGCT ZZZCHGCT ; 
    15 PF0PWAT1 PF0PWAT1 ; 
    15 PF0PWAT2 PF0PWAT2 ; 
    15 PF0PWAT3 PF0PWAT3 ; 
    15 PF0PWAT4 PF0PWAT4 ; 
    15 PF0PWAT5 PF0PWAT5 ; 
    15 PF0PWAT6 PF0PWAT6 ; 
    15 PF0PWAT7 PF0PWAT7 ; 
    15 PF0PWAT8 PF0PWAT8 ; 
    15 PFCREF PFCREF ; 
    15 PFBREF PFBREF ; 
    15 PFDREF PFDREF ; 
    15 PF0PWCYL PF0PWCYL ; 
    15 PF0PWPRI PF0PWPRI ; 
end // end PF0PW02

//*** RECORD=PF0PW03 ****
// pf0pw03 should mirror the pfirec to be used for loading
// the vfield01 table into working storage.  this is used for
// accessing the attribute field abreviation.
// 
// maintenance log
//    date        init         comments
// ---------     ------       ------------------
// 2-15-90       bmanil       installed application
// ***********************
Record PF0PW03 type basicRecord
  5 PF0PWTAB PF0PWTAB [200] ; 
    10 PFICD PFICD ; 
    10 PFIDESC PFIDESC ; 
    10 PFISDESC PFISDESC ; 
    10 PFIDB2NM PFIDB2NM ; 
    10 PFIABRV PFIABRV ; 
    10 ZZZSDT ZZZSDT ; 
    10 ZZZCHGDT ZZZCHGDT ; 
    10 ZZZCHGTM ZZZCHGTM ; 
    10 ZZZCHGCT ZZZCHGCT ; 
end // end PF0PW03

//*** RECORD=PF0PW04 ****
// PF0PW02 is used as the internal table occuring 200 times
// for the loading of PFFREC.  It is assumed that PFFREC has
// at this time appromimately 200 records.
// The pfffmch, pfcid, pfdcdval are repeated 8 times as place
// holders to match pffrec occurs 8 times.
// 
// the first portion of this record must match pffrec & pf0pw02
// records.  this record also contains data besides pffrec.
// do not delete anything following the pffrec portion.
// 
// maintenance log
//    date     init      comments
// --------   -------   ------------------
// 02-15-90   bmanil    installed application
// 09-12-90   cvo       added all items from db2 table vrptpm01
//                      for update purposes.
//                      (Data items pffrptds thru xxxndtxt)
// 10-10-90   cvo       increased record length due to xrocd
//                      field changed from 2 to 4 bytes during
//                      October table changes.
// ***********************
Record PF0PW04 type basicRecord
  5 PF0PWTSL PF0PWTSL ; 
  5 * char(3865) ; 
    10 XXXCURDT XXXCURDT ; 
    10 PF0PMSRT PF0PMSRT ; 
    10 PF0PMSR2 PF0PMSR2 ; 
    10 PF0PMCPG PF0PMCPG ; 
    10 PF0PMTPG PF0PMTPG ; 
    10 PF0PMSEL PF0PMSEL [14] ; 
    10 PFESUMNM PFESUMNM [14] ; 
    10 PFANXTNO PFANXTNO [14] ; 
    10 PF0PMAT1 PF0PMAT1 [14] ; 
    10 PF0PMAT2 PF0PMAT2 [14] ; 
    10 PF0PMAT3 PF0PMAT3 [14] ; 
    10 PF0PMAT4 PF0PMAT4 [14] ; 
    10 PF0PMAT5 PF0PMAT5 [14] ; 
    10 PF0PMAT6 PF0PMAT6 [14] ; 
    10 PF0PMAT7 PF0PMAT7 [14] ; 
    10 PF0PMAT8 PF0PMAT8 [14] ; 
    10 PFFPRTYP PFFPRTYP [14] ; 
    10 PFFSTIND PFFSTIND [14] ; 
    10 PFFPRTYI PFFPRTYI [14] ; 
    10 PFECYCIN PFECYCIN [14] ; 
    10 XXXUNTXT XXXUNTXT [14] ; 
    10 PFESQCOL PFESQCOL [14] ; 
    10 PFESRTEL PFESRTEL [14] ; 
    10 PFESEIND PFESEIND [14] ; 
    10 ZZZSDT ZZZSDT [14] ; 
    10 ZZZCHGDT ZZZCHGDT [14] ; 
    10 ZZZCHGTM ZZZCHGTM [14] ; 
    10 ZZZCHGCT ZZZCHGCT [14] ; 
    10 PFCREF PFCREF [14] ; 
    10 PFBREF PFBREF [14] ; 
    10 PFDREF PFDREF [14] ; 
    10 YISCD YISCD [14] ; 
    10 PFBISGRP PFBISGRP [14] ; 
    10 PF0PWCYL PF0PWCYL [14] ; 
    10 PF0PWPRI PF0PWPRI [14] ; 
    10 PF0PWCV1 PF0PWCV1 [14] ; 
    10 PF0PWCV2 PF0PWCV2 [14] ; 
    10 PF0PWCV3 PF0PWCV3 [14] ; 
    10 PF0PWCV4 PF0PWCV4 [14] ; 
    10 PF0PWCV5 PF0PWCV5 [14] ; 
    10 PF0PWCV6 PF0PWCV6 [14] ; 
    10 PF0PWCV7 PF0PWCV7 [14] ; 
    10 PF0PWCV8 PF0PWCV8 [14] ; 
    10 * char(1) ; 
    10 PFFRPTDS PFFRPTDS [14] ; 
    10 PFFPRLVL PFFPRLVL [14] ; 
    10 XROCD XROCD [14] ; 
    10 PFFDTFMI PFFDTFMI [14] ; 
    10 XXXNBRCY XXXNBRCY [14] ; 
    10 PFFPRFRS PFFPRFRS [14] ; 
    10 PF0PWMC1 PF0PWMC1 [14] ; 
    10 PF0PWMC2 PF0PWMC2 [14] ; 
    10 PF0PWMC3 PF0PWMC3 [14] ; 
    10 PF0PWMC4 PF0PWMC4 [14] ; 
    10 PF0PWMC5 PF0PWMC5 [14] ; 
    10 PF0PWMC6 PF0PWMC6 [14] ; 
    10 PF0PWMC7 PF0PWMC7 [14] ; 
    10 PF0PWMC8 PF0PWMC8 [14] ; 
    10 PF0PWCD1 PF0PWCD1 [14] ; 
    10 PF0PWCD2 PF0PWCD2 [14] ; 
    10 PF0PWCD3 PF0PWCD3 [14] ; 
    10 PF0PWCD4 PF0PWCD4 [14] ; 
    10 PF0PWCD5 PF0PWCD5 [14] ; 
    10 PF0PWCD6 PF0PWCD6 [14] ; 
    10 PF0PWCD7 PF0PWCD7 [14] ; 
    10 PF0PWCD8 PF0PWCD8 [14] ; 
    10 XGPCD XGPCD [14] ; 
    10 SY1STNBR SY1STNBR [14] ; 
    10 SY2CLRID SY2CLRID [14] ; 
    10 XDMCD XDMCD [14] ; 
    10 XQACD XQACD [14] ; 
    10 XLCCD XLCCD [14] ; 
    10 XXXUSRID XXXUSRID [14] ; 
    10 XXXNLTXT XXXNLTXT [14] ; 
    10 XXXNDTXT XXXNDTXT [14] ; 
end // end PF0PW04

// attribute 1
DataItem PF0PMAT1 char(6)  {
  align = none, fillCharacter = nullFill, inputRequired = no
}
end

// attribute 2
DataItem PF0PMAT2 char(6)  {
  align = none, fillCharacter = nullFill, inputRequired = no
}
end

// attribute 3
DataItem PF0PMAT3 char(6)  {
  align = none, fillCharacter = nullFill, inputRequired = no
}
end

// attribute 4
DataItem PF0PMAT4 char(6)  {
  align = none, fillCharacter = nullFill, inputRequired = no
}
end

// attribute5
DataItem PF0PMAT5 char(6)  {
  align = none, fillCharacter = nullFill, inputRequired = no
}
end

// attribute6
DataItem PF0PMAT6 char(6)  {
  align = none, fillCharacter = nullFill, inputRequired = no
}
end

// attribute7
DataItem PF0PMAT7 char(6)  {
  align = none, fillCharacter = nullFill, inputRequired = no
}
end

// attribute8
DataItem PF0PMAT8 char(6)  {
  align = none, fillCharacter = nullFill, inputRequired = no
}
end

// Current Page Of Data
DataItem PF0PMCPG num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = "0", inputRequired = no
}
end

DataItem PF0PMSEL char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// secondary sort used
DataItem PF0PMSR2 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// primary sort used
DataItem PF0PMSRT char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Max Number of Pages of Data
DataItem PF0PMTPG num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = "0", inputRequired = no
}
end

// prirec abrv
DataItem PF0PWABR char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// added to temp storage
DataItem PF0PWADD char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr desc 1
DataItem PF0PWAT1 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr desc 2
DataItem PF0PWAT2 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr desc 3
DataItem PF0PWAT3 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr desc 4
DataItem PF0PWAT4 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr desc 5
DataItem PF0PWAT5 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr desc 6
DataItem PF0PWAT6 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr desc 7
DataItem PF0PWAT7 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr desc 8
DataItem PF0PWAT8 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// reporting attr
DataItem PF0PWATR char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attribute field code
DataItem PF0PWCD1 char(2)  {
  align = right, fillCharacter = "0", inputRequired = no
}
end

// attr field code 2
DataItem PF0PWCD2 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr field code 3
DataItem PF0PWCD3 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr field code 4
DataItem PF0PWCD4 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr field code 5
DataItem PF0PWCD5 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr field code 6
DataItem PF0PWCD6 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr field code 7
DataItem PF0PWCD7 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr field code 8
DataItem PF0PWCD8 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// zzzsdt century
DataItem PF0PWCEN char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attribute code value 1
DataItem PF0PWCV1 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr code value 2
DataItem PF0PWCV2 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr code vale 3
DataItem PF0PWCV3 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr code value 4
DataItem PF0PWCV4 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr code value 5
DataItem PF0PWCV5 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr code value 6
DataItem PF0PWCV6 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr code value 7
DataItem PF0PWCV7 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr code value 8
DataItem PF0PWCV8 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// cycle count
DataItem PF0PWCYC num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// pferec summary cycle
DataItem PF0PWCYL char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// date for map
DataItem PF0PWDAT num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// zzzsdt day
DataItem PF0PWDAY num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// delete confirm flag
DataItem PF0PWDCF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// day for map
DataItem PF0PWDD num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// zzzsdt date
DataItem PF0PWDT num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// +100 rt from pf0p915 update
DataItem PF0PWERR char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pficd matches
DataItem PF0PWFLG char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pfdcdval found for pf0h
DataItem PF0PWFND char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pffrec table
DataItem PF0PWGRP char(274)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// hold cycle parm
DataItem PF0PWHSC char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// hold priority parm
DataItem PF0PWHSP char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// i/s group or class code
DataItem PF0PWIS num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// i/s description
DataItem PF0PWISD char(7)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// i/s literal
DataItem PF0PWISL char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// 1-2
DataItem PF0PWKB1 smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// 11-12
DataItem PF0PWKB2 smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// 1-10
DataItem PF0PWKC1 char(10)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// key redef for abend reporting
DataItem PF0PWKEY char(20)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler 3-10
DataItem PF0PWKF1 char(8)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler 13-20
DataItem PF0PWKF2 char(8)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// left side of map
DataItem PF0PWLEF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// partial pg record count
DataItem PF0PWLMT num(4)  {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// report format indicator 1
DataItem PF0PWMC1 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// report fmt indicator 2
DataItem PF0PWMC2 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// report fmt indicator 3
DataItem PF0PWMC3 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// report fmt indicator 4
DataItem PF0PWMC4 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// report fmt indicator 5
DataItem PF0PWMC5 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// report fmt indicator 6
DataItem PF0PWMC6 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// report fmt indicator 7
DataItem PF0PWMC7 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// report fmt indicator 8
DataItem PF0PWMC8 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// mth for map
DataItem PF0PWMM num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// zzzsdt mth
DataItem PF0PWMTH num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// priority count
DataItem PF0PWPRC num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// pferec summary priority
DataItem PF0PWPRI char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// priority cycle parm entered
DataItem PF0PWPRM char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// page calc remainder
DataItem PF0PWREM num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// right side of map
DataItem PF0PWRIG char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// vrptpm01 select complete
DataItem PF0PWRPF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// vsumat01 select complete
DataItem PF0PWSAF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// screen marked deleted
DataItem PF0PWSDL char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// select counter for screen
DataItem PF0PWSLC num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// pf19 toggle for sorting
DataItem PF0PWSRT num(1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// status count
DataItem PF0PWSTC num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// asterisk
DataItem PF0PWSTR char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// vfield internal table
DataItem PF0PWTAB char(75)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// temp storage hold pg
DataItem PF0PWTSH num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// temp storage pg length
DataItem PF0PWTSL num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// temp storage current pg
DataItem PF0PWTSP num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// zzzsdt yr
DataItem PF0PWYR num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

