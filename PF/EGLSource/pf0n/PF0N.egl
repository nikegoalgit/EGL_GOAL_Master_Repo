package pf0n;
import corpcom2.YSMREC;
import corpcom3.XPPF002;
import corpcom3.XPPF010;
import corpcom3.XPPF020;
import corpcom3.XPPF430;
import corpcom4.XSENTRY;
import corpcom4.XSEXIT;
import corpcom4.XSPF4;
import corpcom4.XSSEGTR;
import corpcom5.COMMAREA;
import corpcom5.ERRSQLCA;
import corpcom6.SQLCA;
import pf.common.PF1REC;
import pf.common.PF2REC;
import pf.common.PFAREC;
import pf.common.PFBREC;
import pf.common.PFCREC;
import pf.common.PFDREC;
import pf.common.PFEREC;
import pf.common.PFGREC;
import pf.common.PFWREC;
import sm.common.SM1REC;
import sy.common.SY1REC;
import sy.common.SY2CLRID;
import sy.common.SYCREC;
import ta.common.TA1REC;
import xx.common.*;
import xx.common.XGPCD;
import xx.common.XLCCD;
import xx.common.XQACD;
import xx.common.YISCD;
import xx01.*;
import xx02.*;
import xx02.XDMCD;
import xx03.*;
import xx04.*;
import xx05.*;
import xx06.*;
import xx07.*;
import xx08.*;
import xx08.SY1STNBR;
import xx08.YFTTBL;
import xx08.YISTBL;
import xx09.*;
import xx10.*;
import xx10.YTYTBL;
//*** PROGRAM=PF0N ****
// this application will display summaries that were generated
// to use a type 3 format. users are able to view the summaries
// in a summary, detail or explode format. users can also view
// 132 column-sized summaries by scrolling right or left on the
// screen that is displayed. finally, summaries can have up to
// 8 levels of information stored in a hierarchical pattern.
// this application will access the selected summary at a
// starting viewing position as determined in pf0b but the user
// has the capability to move up or down the levels easily by
// using predefined pf keys.
// 
// maintenance history:
//   date     by            description of change
// --------  -----  -------------------------------------------
//  1-03-89   mh    original transfer to production.
//  2-28-89   mh    change handling of overflow pcts.
//  3-13-89   mh    enhance display of partial summary
//                              warning. PF0N210
//  6-21-89   DLC   Change Summary Order Type to Base Order
//                  Type (XOBTBL).
//  7-13-89   DLC   Re-Gen for changes to YFATBL, YMATBL,
//                  YMBTBL, and YMCTBL.
// 11-30-89   TBG   Modify to load and pass data viewed back to
//                  Summary File View Selection (PF0B).
//  4-05-90   CVO   Transfer to PF0A if the expected summary
//                  name is not passed.
//  6-13-91   CVO   Increased group level entries from pf0nw02
//                  from 200 to 500.
//  9-25-91   DLC     Added abend if pf0nw02 > 500 when loaded,
//                  & increased # of yis's searched for is grp
//                  literals from 200 to PFWLIMIT, in pf0n200.
//                  Was not displaying lits for last is grps.
//                    Increased rows searched in working stor
//                  for 'sum' level displ from 200 to PFWLIMIT,
//                  in pf0n310.  Was not displaying anything
//                  below gross margin for sums w/ > 200 yis's.
//  9-02-92   WES     Added initialization of attribute descr.
//                  to 'NO DESC' in PF0N210.
//  4-15-94   MJK   changed for new attributes.
//  3-1-96   MBUHIT Regen for GCOA changes to YICTBL.
// 11-19-97  mleabo Re-gen for table changes ysetbl, ysftbl.
// *********************
Program PF0N type textUIProgram //VAGen Info - main text program
  {
  includeReferencedFunctions = yes, allowUnqualifiedItemReferences = yes, 
  throwNrfEofExceptions = yes, handleHardIOErrors = no, V60ExceptionCompatibility = yes, 
  I4GLItemsNullable = no, textLiteralDefaultIsString = no, localSQLScope = yes, 
  msgTablePrefix = "PF00", inputRecord = COMMAREA, segmented = yes
  }

  // Data Declarations
  COMMAREA COMMAREA ; // record
  ERRSQLCA ERRSQLCA; // record
  PF0NW01 PF0NW01; // record
  PF0NW02 PF0NW02; // record
  PF1REC PF1REC; // record
  PF2REC PF2REC; // record
  PFAREC PFAREC; // record
  PFBREC PFBREC; // record
  PFCREC PFCREC; // record
  PFDREC PFDREC; // record
  PFEREC PFEREC; // record
  PFGREC PFGREC; // record
  PFWREC PFWREC; // record
  SM1REC SM1REC; // record
  SQLCA SQLCA; // record
  SY1REC SY1REC; // record
  SYCREC SYCREC; // record
  TA1REC TA1REC; // record
  YSMREC YSMREC; // record

  // VAGen Info - items needed for migration
  VAGen_EZESYS char(8);
  VAGen_EZEREPLY num(1);
  VAGen_EZE_WAIT_TIME bin(9,2);
  VAGen_EZE_ITEMLEN int;

  // Use Declarations
  use XATTBL {deleteAfterUse = yes}; // table
  use XAUTBL {deleteAfterUse = yes}; // table
  use XBTTBL {deleteAfterUse = yes}; // table
  use XCNTBL {deleteAfterUse = yes}; // table
  use XDRTBL {deleteAfterUse = yes}; // table
  use XDVTBL {deleteAfterUse = yes}; // table
  use XFCTBL {deleteAfterUse = yes}; // table
  use XFMTBL {deleteAfterUse = yes}; // table
  use XGATBL {deleteAfterUse = yes}; // table
  use XGPTBL {deleteAfterUse = yes}; // table
  use XGSTBL {deleteAfterUse = yes}; // table
  use XLCTBL {deleteAfterUse = yes}; // table
  use XMCTBL {deleteAfterUse = yes}; // table
  use XOBTBL {deleteAfterUse = yes}; // table
  use XPCTBL {deleteAfterUse = yes}; // table
  use XPGTBL {deleteAfterUse = yes}; // table
  use XPLTBL {deleteAfterUse = yes}; // table
  use XPRTBL {deleteAfterUse = yes}; // table
  use XQATBL {deleteAfterUse = yes}; // table
  use XRDTBL {deleteAfterUse = yes}; // table
  use XRYTBL {deleteAfterUse = yes}; // table
  use XSPTBL {deleteAfterUse = yes}; // table
  use XSUTBL {deleteAfterUse = yes}; // table
  use XWHTBL {deleteAfterUse = yes}; // table
  use YFATBL {deleteAfterUse = yes}; // table
  use YFETBL {deleteAfterUse = yes}; // table
  use YFFTBL {deleteAfterUse = yes}; // table
  use YFGTBL {deleteAfterUse = yes}; // table
  use YFTTBL {deleteAfterUse = yes}; // table
  use YGRTBL {deleteAfterUse = yes}; // table
  use YICTBL {deleteAfterUse = yes}; // table
  use YISTBL {deleteAfterUse = yes}; // table
  use YMATBL {deleteAfterUse = yes}; // table
  use YMBTBL {deleteAfterUse = yes}; // table
  use YMCTBL {deleteAfterUse = yes}; // table
  use YPDTBL {deleteAfterUse = yes}; // table
  use YSCTBL {deleteAfterUse = yes}; // table
  use YSETBL {deleteAfterUse = yes}; // table
  use YSFTBL {deleteAfterUse = yes}; // table
  use YSYTBL {deleteAfterUse = yes}; // table
  use YTYTBL {deleteAfterUse = yes}; // table
  use PF0NM.PF0NM001,  // forms
      PF0NM.PF0NM002
   {
    pfKeyEquate = no
  };

  function main()
    // VAGen Info - initialization needed for migration
    VAGen_EZESYS = VGLib.getVAGSysType();
    PF0N000: PF0N000();
  end // end main
end // end PF0N

// application mainline
Function PF0N000()
   /* ******************************************************/
   /* *    pf0n mainline logic                            **/
   /* ******************************************************/
  ;
  PF0N001(); /* application initialization routine*/
  ;
  while (PFWREC.PFWEOAF == "N") /* while application active,*/
    PF0N100(); /* converse display screens*/
  end
  ;
  XPPF002();
  COMMAREA.CAFROMAP = "PF0N";
  COMMAREA.CATOAP = "PF0A";
  XSEXIT();
end // end PF0N000

// initialization process
Function PF0N001()
   /* ****************************************************/
   /* *   this process will use information passed by   **/
   /* *   pf0b to access profitablity db2 tables for    **/
   /* *   initializing a format 4 summary view. the     **/
   /* *   process will access the summary attribute     **/
   /* *   table(vsumat01) and the i/s group table       **/
   /* *   (visgrp01). the information provided by these **/
   /* *   tables will be used to setup the display      **/
   /* *   screens to used throughout the rest of the    **/
   /* *   application.                                  **/
   /* ****************************************************/
  ;
  XSENTRY(); /* check user security*/
  ;
  XSSEGTR();
  ;
  set PF0NM001 initial; /* initialize maps*/
  set PF0NM002 initial;
  ;
  set PF0NW01 empty; /* initialize w/s records*/
  ;
  PFWREC.PFWERRF = "N"; /* initialize flags*/
  PFWREC.PFWEOAF = "N";
  ;
  PF0NM001.XXXCURDT = VGVar.currentShortGregorianDate; /* move current date to maps*/
  PF0NM002.XXXCURDT = VGVar.currentShortGregorianDate;
  ;
  PF1REC.PF1PASS = COMMAREA.CAUSERA; /* move passed info. to w/s*/
                                          /* record*/
  COMMAREA.CAUSERA = " "; /* clear the commarea*/
  ;
  set PFEREC empty;
  set SQLCA empty;
  ;
  if (PF1REC.PFESUMNM == " ") /* <=== if no summary name passed*/
    COMMAREA.CAFROMAP = "PF0N"; /* to Profit. Menu*/
    COMMAREA.CATOAP = "PF0A";
    XSEXIT(); /* <=== Transfer to PF0A.*/
    PF0NM001.VAGen_EZEMSG = COMMAREA.CAMSG;
    PFWREC.PFWERRF = "Y";
  end
  ;
  PFEREC.PFESUMNM = PF1REC.PFESUMNM; /* move summary name to db2 key*/
  ;
  call "IO2770" ("S ", SQLCA, PFEREC) {isNoRefresh = yes, isExternal = yes}; /* access vsumat01 table*/
  ;
  if (SQLCA.VAGen_SQLCODE == +0) /* if summary found continue with the process*/
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
    TA1REC.TA1TBLVU = "VSUMAT01";
    TA1REC.TA1TBLKE = PF1REC.PFESUMNM;
    TA1REC.TA1LOCAT[3] = "PF0N001";
    TA1REC.TA1LOCAT[4] = "IO2770";
    XPPF010();
  end
  ;
  PF0NM001.PF0NMNAM = PFEREC.PFESUMNM; /* move summary name to screen*/
  PF0NM002.PF0NMNAM = PFEREC.PFESUMNM;
  PFWREC.PFWCDATE = PFEREC.PFECRTDT;
                                   /* move date created to conversion*/
  PFWREC.PFWMONTH = PFWREC.PFWCMO; /* area and reformat date*/
  PFWREC.PFWDAY = PFWREC.PFWCDA;
  PFWREC.PFWYEAR = PFWREC.PFWCYR;
  PF0NM001.PF0NMDTC = PFWREC.PFWDATE;
                                   /* move reformatted date to maps*/
  PF0NM002.PF0NMDTC = PFWREC.PFWDATE;
  PF0NM001.PF0NMBMM = PFEREC.PFABSPRM; /* move base per. mo. to maps*/
  PF0NM002.PF0NMBMM = PFEREC.PFABSPRM;
  PF0NM001.PF0NMCYY = PFEREC.PFABSPRY; /* move base per. yr. to maps*/
  PF0NM002.PF0NMCYY = PFEREC.PFABSPRY;
  PF0NM001.PF0NMFMT = PFEREC.PFCREF; /* move format # to maps*/
  PF0NM002.PF0NMFMT = PFEREC.PFCREF;
  PF0NM001.PF0NMISG = PFEREC.PFBREF; /* move i/s ref. # to maps*/
  PF0NM002.PF0NMISG = PFEREC.PFBREF;
  PF0NM001.PF0NMATT = PFEREC.PFDREF; /* move rpt. attr. # to maps*/
  PF0NM002.PF0NMATT = PFEREC.PFDREF;
  ;
  set PFAREC empty;
  set SQLCA empty;
  ;
  call "IO2670" ("S ", SQLCA, PFAREC) {isNoRefresh = yes, isExternal = yes}; /* access vpfctl01 table*/
  ;
  if (SQLCA.VAGen_SQLCODE == +0) /* if control rec. found continue with*/
                                   /* the process*/
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
    TA1REC.TA1TBLVU = "VPFCTL01";
    TA1REC.TA1TBLKE = PF1REC.PFESUMNM;
    TA1REC.TA1LOCAT[3] = "PF0N001";
    TA1REC.TA1LOCAT[4] = "IO2670";
    XPPF010();
  end
  ;
  if (PFAREC.PFASTBLF == "Y")
                                   /* if the summary file is locked due to*/
                                   /* a*/
    PFWREC.PFWERRF = "Y"; /* db2 batch load, send user a message*/
    converseLib.validationFailed(223);
  end
  ;
  PF0NW01.PF0NWKY1 = "18:"; /* setup pf key literals for*/
                                   /* 'sum,det,exp'*/
  PF0NW01.PF0NWKY2 = "19:";
  ;
  if (PF1REC.PF1DISP == "SUM")
                                   /* pf0b will pass the starting view type*/
     /* (sum,det,exp). move appropriate title heading to maps.*/
    PF0NM001.PF0NMLIT = "SUMMARY FILE SUMMARY VIEW";
    PF0NM002.PF0NMLIT = "SUMMARY FILE SUMMARY VIEW";
    PF0NW01.PF0NWDP1 = "DET"; /* move literals to pf keys*/
    PF0NW01.PF0NWDP2 = "EXP";
  else
    if (PF1REC.PF1DISP == "DET")
      PF0NM001.PF0NMLIT = "SUMMARY FILE DETAIL VIEW";
      PF0NM002.PF0NMLIT = "SUMMARY FILE DETAIL VIEW";
      PF0NW01.PF0NWDP1 = "SUM"; /* move literals to pf keys*/
      PF0NW01.PF0NWDP2 = "EXP";
    else
      if (PF1REC.PF1DISP == "EXP")
        PF0NM001.PF0NMLIT = "SUMMARY FILE EXPLODED VIEW";
        PF0NM002.PF0NMLIT = "SUMMARY FILE EXPLODED VIEW";
        PF0NW01.PF0NWDP1 = "SUM"; /* move literals to pf keys*/
        PF0NW01.PF0NWDP2 = "DET";
      end
    end
  end
  ;
  set PFDREC empty;
  set SQLCA empty;
  ;
  PFDREC.PFDREF = PFEREC.PFDREF; /* move rept. attr. ref # to db2 key*/
  ;
  call "IO2740" ("S ", SQLCA, PFDREC) {isNoRefresh = yes, isExternal = yes}; /* access vrptat01 table*/
  ;
  if (SQLCA.VAGen_SQLCODE == +0) /* if i/s group # found continue with the process*/
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
    TA1REC.TA1TBLVU = "VRPTAT01";
    PF0NW01.PF0NWABK = PFEREC.PFBREF;
    TA1REC.TA1TBLKE = PF0NW01.PF0NWAB2;
    TA1REC.TA1LOCAT[3] = "PF0N001";
    TA1REC.TA1LOCAT[4] = "IO2740";
    XPPF010();
  end
  ;
  set PFCREC empty;
  set SQLCA empty;
  ;
  PFCREC.PFCREF = PFEREC.PFCREF; /* move summary fmt # to db2 key*/
  ;
  call "IO2730" ("S ", SQLCA, PFCREC) {isNoRefresh = yes, isExternal = yes}; /* access vrptfm01 table*/
  ;
  if (SQLCA.VAGen_SQLCODE == +0) /* if format # found continue with the process*/
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
    TA1REC.TA1TBLVU = "VRPTFM01";
    PF0NW01.PF0NWABK = PFEREC.PFCREF;
    TA1REC.TA1TBLKE = PF0NW01.PF0NWAB2;
    TA1REC.TA1LOCAT[3] = "PF0N001";
    TA1REC.TA1LOCAT[4] = "IO2730";
    XPPF010();
  end
  ;
  if (PFCREC.YFTCD in YFTTBL.YFTCD) /* move finc. transaction type to maps*/
    PF0NM001.PF0NMYFT = YFTTBL.YFTDESC[sysVar.arrayIndex];
    PF0NM002.PF0NMYFT = YFTTBL.YFTDESC[sysVar.arrayIndex];
  else
    TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
    TA1REC.TA1TBLVU = "YFTTBL  ";
    PF0NW01.PF0NWABK = PFEREC.PFCREF;
    TA1REC.TA1TBLKE = PF0NW01.PF0NWAB2;
    TA1REC.TA1LOCAT[3] = "PF0N001";
    TA1REC.TA1LOCAT[4] = "******";
    XPPF010();
  end
  ;
  PF0NW01.PF0NWTP1 = PFCREC.YTPCD[1]; /* move dt/tp codes to w/s*/
  PF0NW01.PF0NWTP2 = PFCREC.YTPCD[2];
  PF0NW01.PF0NWTP3 = PFCREC.YTPCD[3];
  PF0NW01.PF0NWTP4 = PFCREC.YTPCD[4];
  PF0NW01.PF0NWTP5 = PFCREC.YTPCD[5];
  PF0NW01.PF0NWTP6 = PFCREC.YTPCD[6];
  PF0NW01.PF0NWTP7 = PFCREC.YTPCD[7];
  PF0NW01.PF0NWTP8 = PFCREC.YTPCD[8];
  PF0NW01.PF0NWDT1 = PFCREC.YPDCD[1];
  PF0NW01.PF0NWDT2 = PFCREC.YPDCD[2];
  PF0NW01.PF0NWDT3 = PFCREC.YPDCD[3];
  PF0NW01.PF0NWDT4 = PFCREC.YPDCD[4];
  PF0NW01.PF0NWDT5 = PFCREC.YPDCD[5];
  PF0NW01.PF0NWDT6 = PFCREC.YPDCD[6];
  PF0NW01.PF0NWDT7 = PFCREC.YPDCD[7];
  PF0NW01.PF0NWDT8 = PFCREC.YPDCD[8];
  PF0NW01.PF0NWF1 = " ";
  PF0NW01.PF0NWF2 = " ";
  PF0NW01.PF0NWF3 = " ";
  PF0NW01.PF0NWF4 = " ";
  PF0NW01.PF0NWF5 = " ";
  PF0NW01.PF0NWF6 = " ";
  PF0NW01.PF0NWF7 = " ";
  PF0NW01.PF0NWF8 = " ";
  ;
  PF0NW01.PF0NWH1 = PF0NW01.PF0NWCL1;
                                   /* string dt/tp literals for maps*/
  PF0NW01.PF0NWH2 = PF0NW01.PF0NWCL2;
  PF0NW01.PF0NWH3 = PF0NW01.PF0NWCL3;
  PF0NW01.PF0NWH4 = PF0NW01.PF0NWCL4;
  PF0NW01.PF0NWH5 = PF0NW01.PF0NWCL5;
  PF0NW01.PF0NWH6 = PF0NW01.PF0NWCL6;
  PF0NW01.PF0NWH7 = PF0NW01.PF0NWCL5;
  PF0NW01.PF0NWH8 = PF0NW01.PF0NWCL6;
  PF0NW01.PF0NWH9 = PF0NW01.PF0NWCL7;
  PF0NW01.PF0NWH10 = PF0NW01.PF0NWCL8;
  PF0NW01.PF0NWF21 = "--"; /* move spacing characters for literals*/
  PF0NW01.PF0NWF22 = "---";
  PF0NW01.PF0NWF23 = "---";
  PF0NW01.PF0NWF24 = "---";
  PF0NW01.PF0NWF25 = "---";
  PF0NW01.PF0NWF26 = "---";
  PF0NW01.PF0NWF28 = "--";
  PF0NW01.PF0NWF29 = "---";
  PF0NW01.PF0NWF30 = "---";
  PF0NW01.PF0NWF31 = "---";
  PF0NW01.PF0NWF32 = "-";
  PF0NM001.PF0NMHDR = PF0NW01.PF0NWHD1;
  PF0NM002.PF0NMHDR = PF0NW01.PF0NWHD2;
  ;
  if (PFCREC.PFCPCTC[1] == 1) /* move 'as % of' dt/tp fields to maps*/
    PF0NM001.PF0NMDT1 = PF0NW01.PF0NWCL1;
  else
    if (PFCREC.PFCPCTC[1] == 2)
      PF0NM001.PF0NMDT1 = PF0NW01.PF0NWCL2;
    else
      if (PFCREC.PFCPCTC[1] == 3)
        PF0NM001.PF0NMDT1 = PF0NW01.PF0NWCL3;
      else
        if (PFCREC.PFCPCTC[1] == 4)
          PF0NM001.PF0NMDT1 = PF0NW01.PF0NWCL4;
        else
          if (PFCREC.PFCPCTC[1] == 5)
            PF0NM001.PF0NMDT1 = PF0NW01.PF0NWCL5;
          else
            if (PFCREC.PFCPCTC[1] == 6)
              PF0NM001.PF0NMDT1 = PF0NW01.PF0NWCL6;
            else
              if (PFCREC.PFCPCTC[1] == 7)
                PF0NM001.PF0NMDT1 = PF0NW01.PF0NWCL7;
              else
                if (PFCREC.PFCPCTC[1] == 8)
                  PF0NM001.PF0NMDT1 = PF0NW01.PF0NWCL8;
                end
              end
            end
          end
        end
      end
    end
  end
  ;
  if (PFCREC.PFCPCTC[2] == 1) /* move 'as % of' dt/tp fields to maps*/
    PF0NM001.PF0NMDT2 = PF0NW01.PF0NWCL1;
  else
    if (PFCREC.PFCPCTC[2] == 2)
      PF0NM001.PF0NMDT2 = PF0NW01.PF0NWCL2;
    else
      if (PFCREC.PFCPCTC[2] == 3)
        PF0NM001.PF0NMDT2 = PF0NW01.PF0NWCL3;
      else
        if (PFCREC.PFCPCTC[2] == 4)
          PF0NM001.PF0NMDT2 = PF0NW01.PF0NWCL4;
        else
          if (PFCREC.PFCPCTC[2] == 5)
            PF0NM001.PF0NMDT2 = PF0NW01.PF0NWCL5;
          else
            if (PFCREC.PFCPCTC[2] == 6)
              PF0NM001.PF0NMDT2 = PF0NW01.PF0NWCL6;
            else
              if (PFCREC.PFCPCTC[2] == 7)
                PF0NM001.PF0NMDT2 = PF0NW01.PF0NWCL7;
              else
                if (PFCREC.PFCPCTC[2] == 8)
                  PF0NM001.PF0NMDT2 = PF0NW01.PF0NWCL8;
                end
              end
            end
          end
        end
      end
    end
  end
  ;
  if (PFCREC.PFCPCTC[3] == 1) /* move 'as % of' dt/tp fields to maps*/
    PF0NM002.PF0NMDT1 = PF0NW01.PF0NWCL1;
  else
    if (PFCREC.PFCPCTC[3] == 2)
      PF0NM002.PF0NMDT1 = PF0NW01.PF0NWCL2;
    else
      if (PFCREC.PFCPCTC[3] == 3)
        PF0NM002.PF0NMDT1 = PF0NW01.PF0NWCL3;
      else
        if (PFCREC.PFCPCTC[3] == 4)
          PF0NM002.PF0NMDT1 = PF0NW01.PF0NWCL4;
        else
          if (PFCREC.PFCPCTC[3] == 5)
            PF0NM002.PF0NMDT1 = PF0NW01.PF0NWCL5;
          else
            if (PFCREC.PFCPCTC[3] == 6)
              PF0NM002.PF0NMDT1 = PF0NW01.PF0NWCL6;
            else
              if (PFCREC.PFCPCTC[3] == 7)
                PF0NM002.PF0NMDT1 = PF0NW01.PF0NWCL7;
              else
                if (PFCREC.PFCPCTC[3] == 8)
                  PF0NM002.PF0NMDT1 = PF0NW01.PF0NWCL8;
                end
              end
            end
          end
        end
      end
    end
  end
  ;
  if (PFCREC.PFCPCTC[4] == 1) /* move 'as % of' dt/tp fields to maps*/
    PF0NM002.PF0NMDT4 = PF0NW01.PF0NWCL1;
  else
    if (PFCREC.PFCPCTC[4] == 2)
      PF0NM002.PF0NMDT4 = PF0NW01.PF0NWCL2;
    else
      if (PFCREC.PFCPCTC[4] == 3)
        PF0NM002.PF0NMDT4 = PF0NW01.PF0NWCL3;
      else
        if (PFCREC.PFCPCTC[4] == 4)
          PF0NM002.PF0NMDT4 = PF0NW01.PF0NWCL4;
        else
          if (PFCREC.PFCPCTC[4] == 5)
            PF0NM002.PF0NMDT4 = PF0NW01.PF0NWCL5;
          else
            if (PFCREC.PFCPCTC[4] == 6)
              PF0NM002.PF0NMDT4 = PF0NW01.PF0NWCL6;
            else
              if (PFCREC.PFCPCTC[4] == 7)
                PF0NM002.PF0NMDT4 = PF0NW01.PF0NWCL7;
              else
                if (PFCREC.PFCPCTC[4] == 8)
                  PF0NM002.PF0NMDT4 = PF0NW01.PF0NWCL8;
                end
              end
            end
          end
        end
      end
    end
  end
  ;
  if (PFCREC.PFCPCTC[5] == 1) /* move 'as % of' dt/tp fields to maps*/
    PF0NM002.PF0NMDT2 = PF0NW01.PF0NWCL1;
  else
    if (PFCREC.PFCPCTC[5] == 2)
      PF0NM002.PF0NMDT2 = PF0NW01.PF0NWCL2;
    else
      if (PFCREC.PFCPCTC[5] == 3)
        PF0NM002.PF0NMDT2 = PF0NW01.PF0NWCL3;
      else
        if (PFCREC.PFCPCTC[5] == 4)
          PF0NM002.PF0NMDT2 = PF0NW01.PF0NWCL4;
        else
          if (PFCREC.PFCPCTC[5] == 5)
            PF0NM002.PF0NMDT2 = PF0NW01.PF0NWCL5;
          else
            if (PFCREC.PFCPCTC[5] == 6)
              PF0NM002.PF0NMDT2 = PF0NW01.PF0NWCL6;
            else
              if (PFCREC.PFCPCTC[5] == 7)
                PF0NM002.PF0NMDT2 = PF0NW01.PF0NWCL7;
              else
                if (PFCREC.PFCPCTC[5] == 8)
                  PF0NM002.PF0NMDT2 = PF0NW01.PF0NWCL8;
                end
              end
            end
          end
        end
      end
    end
  end
  ;
  if (PFCREC.PFCPCTC[6] == 1) /* move 'as % of' dt/tp fields to maps*/
    PF0NM002.PF0NMDT5 = PF0NW01.PF0NWCL1;
  else
    if (PFCREC.PFCPCTC[6] == 2)
      PF0NM002.PF0NMDT5 = PF0NW01.PF0NWCL2;
    else
      if (PFCREC.PFCPCTC[6] == 3)
        PF0NM002.PF0NMDT5 = PF0NW01.PF0NWCL3;
      else
        if (PFCREC.PFCPCTC[6] == 4)
          PF0NM002.PF0NMDT5 = PF0NW01.PF0NWCL4;
        else
          if (PFCREC.PFCPCTC[6] == 5)
            PF0NM002.PF0NMDT5 = PF0NW01.PF0NWCL5;
          else
            if (PFCREC.PFCPCTC[6] == 6)
              PF0NM002.PF0NMDT5 = PF0NW01.PF0NWCL6;
            else
              if (PFCREC.PFCPCTC[6] == 7)
                PF0NM002.PF0NMDT5 = PF0NW01.PF0NWCL7;
              else
                if (PFCREC.PFCPCTC[6] == 8)
                  PF0NM002.PF0NMDT5 = PF0NW01.PF0NWCL8;
                end
              end
            end
          end
        end
      end
    end
  end
  ;
  if (PFCREC.PFCPCTC[7] == 1) /* move 'as % of' dt/tp fields to maps*/
    PF0NM002.PF0NMDT3 = PF0NW01.PF0NWCL1;
  else
    if (PFCREC.PFCPCTC[7] == 2)
      PF0NM002.PF0NMDT3 = PF0NW01.PF0NWCL2;
    else
      if (PFCREC.PFCPCTC[7] == 3)
        PF0NM002.PF0NMDT3 = PF0NW01.PF0NWCL3;
      else
        if (PFCREC.PFCPCTC[7] == 4)
          PF0NM002.PF0NMDT3 = PF0NW01.PF0NWCL4;
        else
          if (PFCREC.PFCPCTC[7] == 5)
            PF0NM002.PF0NMDT3 = PF0NW01.PF0NWCL5;
          else
            if (PFCREC.PFCPCTC[7] == 6)
              PF0NM002.PF0NMDT3 = PF0NW01.PF0NWCL6;
            else
              if (PFCREC.PFCPCTC[7] == 7)
                PF0NM002.PF0NMDT3 = PF0NW01.PF0NWCL7;
              else
                if (PFCREC.PFCPCTC[7] == 8)
                  PF0NM002.PF0NMDT3 = PF0NW01.PF0NWCL8;
                end
              end
            end
          end
        end
      end
    end
  end
  ;
  if (PFCREC.PFCPCTC[8] == 1) /* move 'as % of' dt/tp fields to maps*/
    PF0NM002.PF0NMDT6 = PF0NW01.PF0NWCL1;
  else
    if (PFCREC.PFCPCTC[8] == 2)
      PF0NM002.PF0NMDT6 = PF0NW01.PF0NWCL2;
    else
      if (PFCREC.PFCPCTC[8] == 3)
        PF0NM002.PF0NMDT6 = PF0NW01.PF0NWCL3;
      else
        if (PFCREC.PFCPCTC[8] == 4)
          PF0NM002.PF0NMDT6 = PF0NW01.PF0NWCL4;
        else
          if (PFCREC.PFCPCTC[8] == 5)
            PF0NM002.PF0NMDT6 = PF0NW01.PF0NWCL5;
          else
            if (PFCREC.PFCPCTC[8] == 6)
              PF0NM002.PF0NMDT6 = PF0NW01.PF0NWCL6;
            else
              if (PFCREC.PFCPCTC[8] == 7)
                PF0NM002.PF0NMDT6 = PF0NW01.PF0NWCL7;
              else
                if (PFCREC.PFCPCTC[8] == 8)
                  PF0NM002.PF0NMDT6 = PF0NW01.PF0NWCL8;
                end
              end
            end
          end
        end
      end
    end
  end
  ;
  ;
  PF0NW01.PF0NWSTL = PF1REC.PF1STLVL; /* move passed starting inquiry*/
  PF0NW01.PF0NWSTS = PF1REC.PF1STSEQ; /* to hold db2 keys*/
  ;
  PFWREC.PFWSUB1 = 1; /* initialize subscript*/
  ;
  PF0N200(); /* routine to access summary file, load to w/s table*/
  ;
  PF0NW01.PF0NWDSP = PF1REC.PF1DISP; /* save display type*/
  ;
  PFWREC.PFWSUB1 = 1; /* initialize subscripts*/
  PFWREC.PFWSUB2 = 1;
  ;
  PF0N300(); /* determine display type*/
  ;
  PFWREC.PFWERRF = "N";
  ;
  PF0NW01.PF0NWLEF = "Y"; /* set map switch to display left side*/
  PF0NW01.PF0NWRIG = "N";
end // end PF0N001

// main converse logic loop
Function PF0N100()
   /* ****************************************************/
   /* *  this process will determine whether the left   **/
   /* *  or right display map is to be conversed and    **/
   /* *  will perform the appropriate converse routine. **/
   /* *  after conversing, the routine will check pf    **/
   /* *  keys for the next function to process.         **/
   /* ****************************************************/
  ;
  if (PF0NW01.PF0NWLEF == "Y") /* converse left side map*/
    PF0NM001.PF0NMPFK = PF0NW01.PF0NWPFK; /* move pf18,pf19 keys to map*/
    PF0N120();
    PF0NW01.PF0NWPFK = PF0NM001.PF0NMPFK; /* store pf18,pf19 values*/
  end
  ;
  if (PF0NW01.PF0NWRIG == "Y") /* converse right side map*/
    PF0NM002.PF0NMPFK = PF0NW01.PF0NWPFK; /* move pf18,pf19 keys to map*/
    PF0N130();
    PF0NW01.PF0NWPFK = PF0NM002.PF0NMPFK; /* store pf18,pf19 values*/
  end
  ;
  PF0N110(); /* check pf keys*/
end // end PF0N100

// check pf keys
Function PF0N110()
   /* *****************************************************/
   /* *  this process will check the pf keys entered by  **/
   /* *  the user and will take the appropriate course   **/
   /* *  of action.                                      **/
   /* *****************************************************/
  ;
  if (converseVar.eventKey is pf3) /* return to 'pf0b' application*/
    PF1REC.PFDCDVAL[1] = PF0NM001.PF0NMAVD[1];
    PF1REC.PFDCDVAL[2] = PF0NM001.PF0NMAVD[2];
    PF1REC.PFDCDVAL[3] = PF0NM001.PF0NMAVD[3];
    PF1REC.PFDCDVAL[4] = PF0NM001.PF0NMAVD[4];
    PF1REC.PFDCDVAL[5] = PF0NM001.PF0NMAVD[5];
    PF1REC.PFDCDVAL[6] = PF0NM001.PF0NMAVD[6];
    PF1REC.PFDCDVAL[7] = PF0NM001.PF0NMAVD[7];
    COMMAREA.CAUSERA = PF1REC.PF1PASS;
    COMMAREA.CATOAP = "PF0B";
    XSEXIT();
    PFWREC.PFWMSG = COMMAREA.CAMSG; /* handle a bad pass*/
    PFWREC.PFWERRF = "Y";
    return;
  end
  ;
  set PFAREC empty;
  set SQLCA empty;
  ;
  call "IO2670" ("S ", SQLCA, PFAREC) {isNoRefresh = yes, isExternal = yes}; /* access vpfctl01 table*/
  ;
  if (SQLCA.VAGen_SQLCODE == +0) /* if control rec. found continue with*/
                                   /* the process*/
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
    TA1REC.TA1TBLVU = "VPFCTL01";
    TA1REC.TA1TBLKE = PF1REC.PFESUMNM;
    TA1REC.TA1LOCAT[3] = "PF0N110";
    TA1REC.TA1LOCAT[4] = "IO2670";
    XPPF010();
  end
  ;
  if (PFAREC.PFASTBLF == "Y") /* if the summary file is locked due to an*/
    PFWREC.PFWERRF = "Y"; /* db2 batch load, send user a message*/
    converseLib.validationFailed(223);
    return;
  end
  ;
  if (converseVar.eventKey is pf5) /* move up a level*/
    PF0NW01.PF0NWSTL = PF0NW01.PF0NWSTL - 1;
    if (PF0NWSTL < 0)
      PFWREC.PFWERRF = "Y";
      converseLib.validationFailed(218);
      return;
    end
    PF0N260(); /* access vsumry01 table*/
    if (SQLCA.VAGen_SQLCODE == +100)
                                   /* if there are no more levels to go up,*/
      PFWREC.PFWERRF = "Y"; /* send user a message*/
      converseLib.validationFailed(218);
      PF0NW01.PF0NWSTL = PF0NW01.PF0NWSTL + 1; /* restore viewing level*/
      return;
    end
    PF0N200();
    PFWSUB1 = 1;
    PF0N300(); /* move w/s items to display screen*/
    return;
  end
  ;
  if (converseVar.eventKey is pf6) /* move down a level*/
    PF0NW01.PF0NWSTL = PF0NW01.PF0NWSTL + 1;
    if (PF0NWSTL > 8)
      PFWREC.PFWERRF = "Y";
      converseLib.validationFailed(219);
      return;
    end
    PF0N200(); /* access vsumry01 table*/
    if (SQLCA.VAGen_SQLCODE == +100) /* if the row was not found,*/
      PFWREC.PFWERRF = "Y"; /* send the user a message*/
      converseLib.validationFailed(251);
      PF0NW01.PF0NWSTL = PF0NW01.PF0NWSTL - 1; /* restore viewing level*/
      return;
    end
    PFWSUB1 = 1;
    PF0N300(); /* move w/s items to display screen*/
    return;
  end
  ;
  if (converseVar.eventKey is pf7 /* user can't scroll when a 'sum' is displayed*/
   && PF0NW01.PF0NWDSP == "SUM") 
    PFWREC.PFWERRF = "Y";
    converseLib.validationFailed(225);
    return;
  end
  ;
  if (converseVar.eventKey is pf7) /* scroll up within current summary*/
    if (PF0NW01.PF0NWDSP == "DET")
      PFWSUB1 = PFWREC.PFWSAVDX;
      PFWSUB1 = PFWSUB1 - 1;
      PF0N350();
      return;
    end
    if (PF0NW01.PF0NWDSP == "EXP")
      PFWSUB1 = PFWREC.PFWSAVDX;
      PFWSUB1 = PFWSUB1 - 1;
      PF0N360();
      return;
    end
  end
  ;
  if (converseVar.eventKey is pf8 /* user can't scroll when a 'sum' is displayed*/
   && PF0NW01.PF0NWDSP == "SUM") 
    PFWREC.PFWERRF = "Y";
    converseLib.validationFailed(225);
    return;
  end
  ;
  if (converseVar.eventKey is pf8) /* scroll down within current summary*/
    if (PFWNXTDX > PFWLIMIT)
                                   /* if user can't scroll forward anymore,*/
      PFWREC.PFWERRF = "Y"; /* send a message*/
      converseLib.validationFailed(032);
      return;
    end
    move PFWNXTDX to PFWSUB1 withV60Compat; /* set starting display subscript*/
    PF0N300();
    return;
    ;
  end
  ;
  if (converseVar.eventKey is pf10) /* shift to left-side map*/
    if (PF0NW01.PF0NWLEF == "N")
      PF0NW01.PF0NWLEF = "Y"; /* set map display indicator to left*/
      PF0NW01.PF0NWRIG = "N";
      return;
    else
      PFWREC.PFWERRF = "Y"; /* can't shift left if already on left*/
                                   /* map*/
      converseLib.validationFailed(198);
      return;
    end
  end
  ;
  if (converseVar.eventKey is pf11) /* shift to right-side map*/
    if (PF0NW01.PF0NWRIG == "N")
      PF0NW01.PF0NWRIG = "Y"; /* set map display indicator to right*/
      PF0NW01.PF0NWLEF = "N";
      return;
    else
      PFWREC.PFWERRF = "Y"; /* can't shift right if already on right map*/
      converseLib.validationFailed(192);
      return;
    end
  end
  ;
  if (converseVar.eventKey is pf18) /* user requested a change in display type*/
    PF0NW01.PF0NWHDP = PF0NW01.PF0NWDP1;
                                   /* switch pf key display type*/
    PF0NW01.PF0NWDP1 = PF0NW01.PF0NWDSP; /* with current display type*/
    PF0NW01.PF0NWDSP = PF0NW01.PF0NWHDP;
                                   /* and display maps from same*/
    PF1REC.PF1DISP = PF0NW01.PF0NWDSP;
    if (PF0NW01.PF0NWDSP == "SUM")
       /* (sum,det,exp). move appropriate title heading to maps.*/
      PF0NM001.PF0NMLIT = "SUMMARY FILE SUMMARY VIEW";
      PF0NM002.PF0NMLIT = "SUMMARY FILE SUMMARY VIEW";
    else
      if (PF0NW01.PF0NWDSP == "DET")
        PFWREC.PFWSUB1 = PFWREC.PFWSAVDX;
        PF0NM001.PF0NMLIT = "SUMMARY FILE DETAIL VIEW";
        PF0NM002.PF0NMLIT = "SUMMARY FILE DETAIL VIEW";
      else
        if (PF0NW01.PF0NWDSP == "EXP")
          PFWREC.PFWSUB1 = PFWREC.PFWSAVDX;
          PF0NM001.PF0NMLIT = "SUMMARY FILE EXPLODED VIEW";
          PF0NM002.PF0NMLIT = "SUMMARY FILE EXPLODED VIEW";
        end
      end
    end
    if (PF0NW01.PF0NWHDP == "SUM"
     || PF0NW01.PF0NWDSP == "SUM")
      PFWREC.PFWSAVDX = 1;
      PFWREC.PFWSUB1 = 1;
    end
    PF0N300();
    return;
  end
  ;
  if (converseVar.eventKey is pf19) /* user requested a change in display type*/
    PF0NW01.PF0NWHDP = PF0NW01.PF0NWDP2;
                                   /* switch pf key display type*/
    PF0NW01.PF0NWDP2 = PF0NW01.PF0NWDSP; /* with current display type*/
    PF0NW01.PF0NWDSP = PF0NW01.PF0NWHDP;
                                   /* and display maps from same*/
    PF1REC.PF1DISP = PF0NW01.PF0NWDSP;
    if (PF0NW01.PF0NWDSP == "SUM")
       /* (sum,det,exp). move appropriate title heading to maps.*/
      PF0NM001.PF0NMLIT = "SUMMARY FILE SUMMARY VIEW";
      PF0NM002.PF0NMLIT = "SUMMARY FILE SUMMARY VIEW";
    else
      if (PF0NW01.PF0NWDSP == "DET")
        PFWREC.PFWSUB1 = PFWREC.PFWSAVDX;
        PF0NM001.PF0NMLIT = "SUMMARY FILE DETAIL VIEW";
        PF0NM002.PF0NMLIT = "SUMMARY FILE DETAIL VIEW";
      else
        if (PF0NW01.PF0NWDSP == "EXP")
          PFWREC.PFWSUB1 = PFWREC.PFWSAVDX;
          PF0NM001.PF0NMLIT = "SUMMARY FILE EXPLODED VIEW";
          PF0NM002.PF0NMLIT = "SUMMARY FILE EXPLODED VIEW";
        end
      end
    end
    if (PF0NW01.PF0NWHDP == "SUM"
     || PF0NW01.PF0NWDSP == "SUM")
      PFWREC.PFWSAVDX = 1;
      PFWREC.PFWSUB1 = 1;
    end
    PF0N300();
    return;
  end
  ;
  if (converseVar.eventKey is pf20) /* move up within a level*/
    if (PF0NWSTS == 1) /* no more summaries within this level*/
      PFWREC.PFWERRF = "Y";
      converseLib.validationFailed(220);
      return;
    end
    PF0N260(); /* access vsumry01 table*/
    if (SQLCA.VAGen_SQLCODE == +100) /* if the row was not found,*/
      PFWREC.PFWERRF = "Y"; /* send the user a message*/
      converseLib.validationFailed(220);
      return;
    end
    PF0NW01.PF0NWFL2 = PF0NW01.PF0NWFL1;
    PF0N200(); /* read vsumry01/store rows in w/s area*/
    PF0N270(); /* see if hierarchy changed*/
    PFWSUB1 = 1;
    PF0N300(); /* move w/s items to display screen*/
    return;
  end
  ;
  if (converseVar.eventKey is pf21) /* move down within a level*/
    PF0NW01.PF0NWSTS = PF0NW01.PF0NWSTS + 1;
    PF0NW01.PF0NWFL2 = PF0NW01.PF0NWFL1;
    PF0N200(); /* access vsumry01 table*/
    if (SQLCA.VAGen_SQLCODE == +100) /* if the row was not found,*/
      PFWREC.PFWERRF = "Y"; /* send the user a message*/
      converseLib.validationFailed(220);
      PF0NW01.PF0NWSTS = PF0NW01.PF0NWSTS - 1;
      return;
    end
    PF0N270(); /* see if hierarchy changed*/
    PFWSUB1 = 1;
    PF0N300(); /* move w/s items to display screen*/
    ;
    return;
  end
  ;
  converseLib.validationFailed(001); /* invalid key was entered*/
  PFWREC.PFWERRF = "Y";
end // end PF0N110

// converse left side map
Function PF0N120()
   /* ********************************************************/
   /* *  the sole function of this process is to converse   **/
   /* *  the left side of the summary displays.             **/
   /* ********************************************************/
  ;
  set PF0NM001.XXXCURDT cursor;
  ;
  converse PF0NM001 ;
  ;
end // end PF0N120

// converse right side map
Function PF0N130()
   /* ********************************************************/
   /* *  the sole function of this process is to converse   **/
   /* *  the right side of the summary displays.            **/
   /* ********************************************************/
  ;
  set PF0NM001.XXXCURDT cursor;
  ;
  converse PF0NM002 ;
  ;
end // end PF0N130

// access vsumry01 table
Function PF0N200()
   /* ***********************************************************/
   /* *  this process will access the vsumry01 table using     **/
   /* *  the summary name, summary level, and summary sequence **/
   /* *  number as db2 keys.*/
   /* ***********************************************************/
  ;
  set PFGREC empty;
  set SQLCA empty;
  PFGREC.PFESUMNM = PFEREC.PFESUMNM; /* move summary name to db2 key*/
  PFGREC.PFGSUMN = PFEREC.PFGSUMN; /* move summary # to db2 key*/
  PFGREC.PFGLVLNO = PF0NW01.PF0NWSTL; /* move level # to db2 key*/
  PFGREC.PFGLVLSQ = PF0NW01.PF0NWSTS; /* move level seq # to db2 key*/
  ;
  call "IO2920" ("S1", SQLCA, PFGREC) {isNoRefresh = yes, isExternal = yes}; /* open vsumry01 cursor*/
  ;
  if (SQLCA.VAGen_SQLCODE == +0) /* if cursor open ok, continue with the process*/
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
    TA1REC.TA1TBLVU = "VSUMRY01";
    TA1REC.TA1TBLKE = PF1REC.PFESUMNM;
    TA1REC.TA1LOCAT[3] = "PF0N200";
    TA1REC.TA1LOCAT[4] = "IO2920";
    XPPF010();
  end
  ;
  ;
  set PFGREC empty;
  set SQLCA empty;
  ;
  call "IO2920" ("N1", SQLCA, PFGREC) {isNoRefresh = yes, isExternal = yes}; /* access vsumry01 table*/
  ;
  if (SQLCA.VAGen_SQLCODE == +0) /* if cursor open ok, continue with the process*/
    PF0NW01.PF0NWSTS = PFGREC.PFGLVLSQ; /* save seq. #*/
    PF0NW01.PF0NWSTL = PFGREC.PFGLVLNO;
    PF0NW01.PF0NWCD1 = PFGREC.PFDCDVAL[1];
    PF0NW01.PF0NWCD2 = PFGREC.PFDCDVAL[2];
    PF0NW01.PF0NWCD3 = PFGREC.PFDCDVAL[3];
    PF0NW01.PF0NWCD4 = PFGREC.PFDCDVAL[4];
    PF0NW01.PF0NWCD5 = PFGREC.PFDCDVAL[5];
    PF0NW01.PF0NWCD6 = PFGREC.PFDCDVAL[6];
    PF0NW01.PF0NWCD7 = PFGREC.PFDCDVAL[7];
  else
    if (SQLCA.VAGen_SQLCODE == +100)
      return;
    else
      TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
      TA1REC.TA1TBLVU = "VSUMRY01";
      TA1REC.TA1TBLKE = PF1REC.PFESUMNM;
      TA1REC.TA1LOCAT[3] = "PF0N200";
      TA1REC.TA1LOCAT[4] = "IO2920";
      XPPF010();
    end
  end
  ;
  ;
  PF0N210(); /* perform routine to get attribute literals*/
  ;
  ;
  set PF0NW02 empty;
  PFWSUB1 = 1;
  while (PFGREC.PFGLVLSQ == PF0NW01.PF0NWSTS
   && PFWSUB1 <= 500)
    ;
    PF0N220(); /* move summary rows to w/s area*/
    ;
    set SQLCA empty;
    set PFGREC empty;
    ;
    call "IO2920" ("N1", SQLCA, PFGREC) {isNoRefresh = yes, isExternal = yes}; /* get next vsumry01*/
    ;
    if (SQLCA.VAGen_SQLCODE == +0) /* if a row is found, continue with the process*/
       /* next sentence*/
    else
      if (SQLCA.VAGen_SQLCODE == +100) /* if a row isn't found, loop will terminate*/
        PFGREC.PFGLVLSQ = 9999; /* set condition to end loop*/
      else
        TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
        TA1REC.TA1TBLVU = "VSUMRY01";
        TA1REC.TA1TBLKE = PF1REC.PFESUMNM;
        TA1REC.TA1LOCAT[3] = "PF0N200";
        TA1REC.TA1LOCAT[4] = "IO2920";
        XPPF010();
      end
    end
    PFWSUB1 = PFWSUB1 + 1;
  end
  ;
  if (PFWSUB1 > 500)
    TA1REC.TA1TYPE = "APPL"; /* error type*/
    TA1REC.TA1FUNC = "RETN"; /* termination function*/
    TA1REC.TA1PGMNM = "PF0N"; /* program name*/
    TA1REC.TA1LOC = "PF0NW02 TBL OVERFLOW - PF0N200";
    SQLCA.SQLCAREC = " "; /* error information*/
    ;
    call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes}; /* error diagnostic routine*/
    ;
    COMMAREA.CAUSERA = " "; /* clear user commarea*/
    XSPF4(); /* master menu*/
    exit program; /* master menu failure*/
  end
  ;
  ;
  PFWREC.PFWLIMIT = PFWSUB1 - 1; /* set maximum index on w/s area*/
  ;
  ;
  PFWSUB1 = 1; /* initialize subscript*/
  while (PFWSUB1 <= PFWLIMIT)
    ;
    PF0N240(); /* perform routine get i/s group*/
                                   /* literals*/
    PFWSUB1 = PFWSUB1 + 1;
  end
  ;
  ;
  set PFGREC empty;
  set SQLCA empty;
  ;
  call "IO2920" ("C1", SQLCA, PFGREC) {isNoRefresh = yes, isExternal = yes}; /* close vsumry01 cursor*/
  ;
  if (SQLCA.VAGen_SQLCODE == +0) /* if cursor open ok, continue with the process*/
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
    TA1REC.TA1TBLVU = "VSUMRY01";
    TA1REC.TA1TBLKE = PF1REC.PFESUMNM;
    TA1REC.TA1LOCAT[3] = "PF0N200";
    TA1REC.TA1LOCAT[4] = "IO2920";
    XPPF010();
  end
  ;
end // end PF0N200

// determine attribute literals
Function PF0N210()
   /* ********************************************************/
   /* *  this process will determine the attribute field    **/
   /* *  literal for those attributes that are displayed    **/
   /* *  at the summary level to be viewed. the literal     **/
   /* *  be moved to the pf0nm001 screen fields from the    **/
   /* *  passed attribute descriptions in pf1rec.           **/
   /* ********************************************************/
  ;
  PFWSUB2 = 1;
  ;
  while (PFWSUB2 < 8) /* clear literals on maps*/
    PF0NM001.PF0NMAVD[PFWSUB2] = " ";
    PF0NM002.PF0NMAVD[PFWSUB2] = " ";
    PFWSUB2 = PFWSUB2 + 1;
  end
  ;
  PF0NM001.PF0NMSTY = " "; /* clear product literal on maps*/
  PF0NM002.PF0NMSTY = " ";
  PF0NM001.PF0NMPRD = " ";
  PF0NM002.PF0NMPRD = " ";
  PF0NM001.PF0NMCLR = " ";
  PF0NM002.PF0NMCLR = " ";
  ;
  PF0NM001.PF0NMPLT = " ";
  PF0NM002.PF0NMPLT = " ";
  ;
  PFWSUB2 = 1;
  ;
  while (PFWSUB2 < 8) /* move rept. attr. literals to maps*/
    PF0NW01.PF0NWAV1 = PF1REC.PFISDESC[PFWSUB2];
    if (PF0NW01.PF0NWAV1 > " ")
      PF0NW01.PF0NWAV2 = " :";
    else
      PF0NW01.PF0NWAV2 = "  ";
    end
    PF0NM001.PF0NMACA[PFWSUB2] = PF0NW01.PF0NWAVA;
    PF0NM002.PF0NMACA[PFWSUB2] = PF0NW01.PF0NWAVA;
    PFWSUB2 = PFWSUB2 + 1;
  end
  ;
  if (PF1REC.PFISDESC[1] > " ") /* if any attributes below this one*/
    if (PFDREC.PFDVALFL[2] == "Y" /* have selected values, mark this*/
     || PFDREC.PFDVALFL[3] == "Y" /* attribute with a highlighted "p"*/
     || PFDREC.PFDVALFL[4] == "Y" /* to warn user of a partial summary.*/
     || PFDREC.PFDVALFL[5] == "Y" 
     || PFDREC.PFDVALFL[6] == "Y" 
     || PFDREC.PFDVALFL[7] == "Y" 
     || PFDREC.PFDVALFL[8] == "Y")
      PF0NM001.PF0NMIND[1] = "P";
      PF0NM002.PF0NMIND[1] = "P";
      set PF0NM001.PF0NMIND[1] bold;
      set PF0NM002.PF0NMIND[1] bold;
    else
      PF0NM001.PF0NMIND[1] = " ";
      PF0NM002.PF0NMIND[1] = " ";
      set PF0NM001.PF0NMIND[1] normal;
      set PF0NM002.PF0NMIND[1] normal;
    end
  end
  ;
  if (PF1REC.PFISDESC[2] > " ")
    if (PFDREC.PFDVALFL[3] == "Y"
     || PFDREC.PFDVALFL[4] == "Y"
     || PFDREC.PFDVALFL[5] == "Y"
     || PFDREC.PFDVALFL[6] == "Y"
     || PFDREC.PFDVALFL[7] == "Y"
     || PFDREC.PFDVALFL[8] == "Y")
      PF0NM001.PF0NMIND[2] = "P";
      PF0NM002.PF0NMIND[2] = "P";
      set PF0NM001.PF0NMIND[2] bold;
      set PF0NM002.PF0NMIND[2] bold;
    else
      PF0NM001.PF0NMIND[2] = " ";
      PF0NM002.PF0NMIND[2] = " ";
      set PF0NM001.PF0NMIND[2] normal;
      set PF0NM002.PF0NMIND[2] normal;
    end
  end
  ;
  if (PF1REC.PFISDESC[3] > " ")
    if (PFDREC.PFDVALFL[4] == "Y"
     || PFDREC.PFDVALFL[5] == "Y"
     || PFDREC.PFDVALFL[6] == "Y"
     || PFDREC.PFDVALFL[7] == "Y"
     || PFDREC.PFDVALFL[8] == "Y")
      PF0NM001.PF0NMIND[3] = "P";
      PF0NM002.PF0NMIND[3] = "P";
      set PF0NM001.PF0NMIND[3] bold;
      set PF0NM002.PF0NMIND[3] bold;
    else
      PF0NM001.PF0NMIND[3] = " ";
      PF0NM002.PF0NMIND[3] = " ";
      set PF0NM001.PF0NMIND[3] normal;
      set PF0NM002.PF0NMIND[3] normal;
    end
  end
  ;
  if (PF1REC.PFISDESC[4] > " ")
    if (PFDREC.PFDVALFL[5] == "Y"
     || PFDREC.PFDVALFL[6] == "Y"
     || PFDREC.PFDVALFL[7] == "Y"
     || PFDREC.PFDVALFL[8] == "Y")
      PF0NM001.PF0NMIND[4] = "P";
      PF0NM002.PF0NMIND[4] = "P";
      set PF0NM001.PF0NMIND[4] bold;
      set PF0NM002.PF0NMIND[4] bold;
    else
      PF0NM001.PF0NMIND[4] = " ";
      PF0NM002.PF0NMIND[4] = " ";
      set PF0NM001.PF0NMIND[4] normal;
      set PF0NM002.PF0NMIND[4] normal;
    end
  end
  ;
  if (PF1REC.PFISDESC[5] > " ")
    if (PFDREC.PFDVALFL[6] == "Y"
     || PFDREC.PFDVALFL[7] == "Y"
     || PFDREC.PFDVALFL[8] == "Y")
      PF0NM001.PF0NMIND[5] = "P";
      PF0NM002.PF0NMIND[5] = "P";
      set PF0NM001.PF0NMIND[5] bold;
      set PF0NM002.PF0NMIND[5] bold;
    else
      PF0NM001.PF0NMIND[5] = " ";
      PF0NM002.PF0NMIND[5] = " ";
      set PF0NM001.PF0NMIND[5] normal;
      set PF0NM002.PF0NMIND[5] normal;
    end
  end
  ;
  if (PF1REC.PFISDESC[6] > " ")
    if (PFDREC.PFDVALFL[7] == "Y"
     || PFDREC.PFDVALFL[8] == "Y")
      PF0NM001.PF0NMIND[6] = "P";
      PF0NM002.PF0NMIND[6] = "P";
      set PF0NM001.PF0NMIND[6] bold;
      set PF0NM002.PF0NMIND[6] bold;
    else
      PF0NM001.PF0NMIND[6] = " ";
      PF0NM002.PF0NMIND[6] = " ";
      set PF0NM001.PF0NMIND[6] normal;
      set PF0NM002.PF0NMIND[6] normal;
    end
  end
  ;
  if (PF1REC.PFISDESC[7] > " ")
    if (PFDREC.PFDVALFL[8] == "Y")
      PF0NM001.PF0NMIND[7] = "P";
      PF0NM002.PF0NMIND[7] = "P";
      set PF0NM001.PF0NMIND[7] bold;
      set PF0NM002.PF0NMIND[7] bold;
    else
      PF0NM001.PF0NMIND[7] = " ";
      PF0NM002.PF0NMIND[7] = " ";
      set PF0NM001.PF0NMIND[7] normal;
      set PF0NM002.PF0NMIND[7] normal;
    end
  end
  ;
  ;
  PF0NM001.PF0NMPLT = PF1REC.PFIDESC[8];
  PF0NM002.PF0NMPLT = PF1REC.PFIDESC[8];
  ;
  PFWREC.XGPCD = PFGREC.XGPCD;
  PFWREC.SY1STNBR = PFGREC.SY1STNBR;
  PFWREC.SY2CLRID = PFGREC.SY2CLRID;
  PFWREC.XDMCD = PFGREC.XDMCD;
  PFWREC.XQACD = PFGREC.XQACD;
  PFWREC.XLCCD = PFGREC.XLCCD;
  PFWREC.PFDCDVAL[1] = PFGREC.PFDCDVAL[1];
  PFWREC.PFDCDVAL[2] = PFGREC.PFDCDVAL[2];
  PFWREC.PFDCDVAL[3] = PFGREC.PFDCDVAL[3];
  PFWREC.PFDCDVAL[4] = PFGREC.PFDCDVAL[4];
  PFWREC.PFDCDVAL[5] = PFGREC.PFDCDVAL[5];
  PFWREC.PFDCDVAL[6] = PFGREC.PFDCDVAL[6];
  PFWREC.PFDCDVAL[7] = PFGREC.PFDCDVAL[7];
  ;
  if (PFWREC.XGPCD > " ") /* move product attribute desc. to map*/
    PFWIDX = 8;
    PFWREC.PFWPRDAT = PFDREC.PFICD[8];
    XPPF020(); /* perform generic product routine to*/
                                   /* move product*/
    PF0NW01.XGPCD = PFWREC.XGPCD;
    PF0NW01.SY1STNBR = PFWREC.SY1STNBR;
    PF0NW01.SY2CLRID = PFWREC.SY2CLRID;
    PF0NW01.XDMCD = PFWREC.XDMCD;
    PF0NW01.XQACD = PFWREC.XQACD;
    PF0NW01.XLCCD = PFWREC.XLCCD;
    PF0NW01.PF0NWF9 = "/";
    PF0NW01.PF0NWF10 = "/";
    PF0NW01.PF0NWF11 = "/";
    PF0NW01.PF0NWF12 = "/";
    PF0NW01.PF0NWF13 = "/";
    PF0NM001.PF0NMSTY = PF0NW01.PF0NWSTY;
    PF0NM002.PF0NMSTY = PF0NW01.PF0NWSTY;
    PF0NM001.PF0NMPRD = PFWREC.PFWDESC[8];
    PF0NM002.PF0NMPRD = PFWREC.PFWDESC[8];
    PF0NM001.PF0NMCLR = PFWREC.SY2CLRAB;
    PF0NM002.PF0NMCLR = PFWREC.SY2CLRAB;
  end
  ;
  PFWREC.PFWIDX = 7; /* initialize index*/
  ;
  while (PFWIDX > 0)
    if (PFWREC.PFDCDVAL[PFWIDX] > " ")
                                   /* if an attribute has data, move desc.*/
      PFWREC.PFWDESC[PFWIDX] = "NO DESC        ";
      XPPF430(); /* perform edit routine to get code*/
                                   /* value literal*/
      PF0NW01.PF0NWAD1 = PFGREC.PFDCDVAL[PFWIDX];
      PF0NW01.PF0NWAD2 = PFWREC.PFWDESC[PFWIDX];
      PF0NM001.PF0NMAVD[PFWIDX] = PF0NW01.PF0NWAVD; /* description to map*/
      PF0NM002.PF0NMAVD[PFWIDX] = PF0NW01.PF0NWAVD; /* description to map*/
    end
    PFWIDX = PFWIDX - 1;
  end
end // end PF0N210

// load summary info. to w/s area
Function PF0N220()
   /* ************************************************************/
   /* *  this process will load the summary rows from vsumry01  **/
   /* *  table to a w/s area, pf0nw02. pf0n will then display   **/
   /* *  the information in pf0nw02 on screens. first, the      **/
   /* *  process will determine what type of display record     **/
   /* *  the current summary row is and find the literal that   **/
   /* *  is used to describe the row. then, the dollar or %     **/
   /* *  columns are then stored. the valid record types are:   **/
   /* *  record #      description                              **/
   /* *  --------   ----------------------                      **/
   /* *     1       summary level items                         **/
   /* *     2       special summary level items(i.e. dirsg&a)   **/
   /* *     3       i/s group total items                       **/
   /* *     4       i/s group items                             **/
   /* *     5       ungrouped i/s items                         **/
   /* ************************************************************/
  ;
  if (PFWSUB1 == 3) /* setup third w/s entry for spaces to display*/
    PF0NW02.PF0NWLIT[PFWSUB1] = " ";
    PF0NW02.PF0NWTYP[PFWSUB1] = "1";
    PF0NW02.PF0NWC1[PFWSUB1] = 0;
    PF0NW02.PF0NWC2[PFWSUB1] = 0;
    PF0NW02.PF0NWC3[PFWSUB1] = 0;
    PF0NW02.PF0NWC4[PFWSUB1] = 0;
    PF0NW02.PF0NWC5[PFWSUB1] = 0;
    PF0NW02.PF0NWC6[PFWSUB1] = 0;
    PF0NW02.PF0NWC7[PFWSUB1] = 0;
    PF0NW02.PF0NWC8[PFWSUB1] = 0;
    PF0NW02.PF0NWC9[PFWSUB1] = 0;
    PF0NW02.PF0NWC10[PFWSUB1] = 0;
    PF0NW02.PF0NWC11[PFWSUB1] = 0;
    PF0NW02.PF0NWC12[PFWSUB1] = 0;
    PFWSUB1 = PFWSUB1 + 1;
  end
  ;
  if (PFGREC.YISCD[2] == 0) /* this is a summary level item*/
    if (PFGREC.YTYCD == "34"
     || PFGREC.YTYCD == "38") /* if it's a special summary level*/
      PF0NW02.PF0NWTYP[PFWSUB1] = "2"; /* set record type to 2*/
    else
      PF0NW02.PF0NWTYP[PFWSUB1] = "1";
    end
    PF0NW02.PF0NWIND[PFWSUB1] = " ";
    if (PFGREC.YTYCD in YTYTBL.YTYCD) /* move in summary literal*/
      PF0NW02.PF0NWABV[PFWSUB1] = YTYTBL.YTYSDESC[sysVar.arrayIndex];
    end
    PF0N230(); /* perform routine to move columnar*/
                                   /* info.*/
    return;
  end
  ;
  if (PFGREC.YISCD[1] == 0 /* this is an i/s grouped total item*/
   && PFGREC.YISCD[2] > 0)
    PF0NW02.PF0NWTYP[PFWSUB1] = "3";
    PF0NW02.YISCD[PFWSUB1] = PFGREC.YISCD[2];
    PF0NW02.PF0NWIND[PFWSUB1] = "*";
    PF0N230(); /* move columnar info. to pf0kw02 w/s area*/
    return;
  end
  ;
  if (PFGREC.PFBISGRP > 0 /* this is a grouped item*/
   && PFGREC.YISCD[1] > 0)
    PF0NW02.PF0NWTYP[PFWSUB1] = "4"; /* set record type to 4*/
    PF0NW02.YISCD[PFWSUB1] = PFGREC.YISCD[1];
    PF0NW02.PF0NWIND[PFWSUB1] = "-";
    if (PFGREC.YISCD[1] in YISTBL.YISCD)
      PF0NW02.PF0NWABV[PFWSUB1] = YISTBL.YISABRV[sysVar.arrayIndex];
    end
    PF0N230(); /* perform routine to move columnar*/
                                   /* info.*/
    return;
  end
  ;
  if (PFGREC.PFBISGRP == 0) /* this is a ungrouped item*/
    PF0NW02.PF0NWTYP[PFWSUB1] = "5"; /* set record type to 5*/
    PF0NW02.PF0NWIND[PFWSUB1] = " ";
    if (PFGREC.YISCD[1] in YISTBL.YISCD)
      PF0NW02.PF0NWABV[PFWSUB1] = YISTBL.YISABRV[sysVar.arrayIndex];
    end
    PF0N230(); /* perform routine to move columnar*/
                                   /* info.*/
    return;
  end
end // end PF0N220

// move columnar data to w/s
Function PF0N230()
   /* *****************************************************/
   /* *  this process will move the thirteen columns of  **/
   /* *  unit/dollar/percentage information from pfgrec  **/
   /* *  to the pf0nw02 w/s area. dollars are calculated **/
   /* *  in thousands rounded, percentages are rounded   **/
   /* *  to the nearest tenth. gross marg. % (ytycd =    **/
   /* *  '72') and cont. marg. % (ytycd = '73') are      **/
   /* *  calculated differently because percentages are  **/
   /* *  being displayed in map areas designed to        **/
   /* *  display dollars.                                **/
   /* *****************************************************/
  if (PFGREC.YTYCD == "72"
   || PFGREC.YTYCD == "73")
    PF0NW01.PF0NWNUM = PFGREC.PFGQTY[1];
    if (PF0NW01.PF0NWNUM >= +999500.00)
      PF0NW02.PF0NWC1[PFWSUB1] = +999;
    else
      if (PF0NW01.PF0NWNUM <= -99500.00)
        PF0NW02.PF0NWC1[PFWSUB1] = -99;
      else
        PF0NW02.PF0NWC1[PFWSUB1] = mathLib.round(PF0NW01.PF0NWNUM * .001, -mathLib.decimals(PF0NW02.PF0NWC1[PFWSUB1]));
      end
    end
    PF0NW01.PF0NWNUM = PFGREC.PFGQTY[2];
    if (PF0NW01.PF0NWNUM >= +999500.00)
      PF0NW02.PF0NWC2[PFWSUB1] = +999;
    else
      if (PF0NW01.PF0NWNUM <= -99500.00)
        PF0NW02.PF0NWC2[PFWSUB1] = -99;
      else
        PF0NW02.PF0NWC2[PFWSUB1] = mathLib.round(PF0NW01.PF0NWNUM * .001, -mathLib.decimals(PF0NW02.PF0NWC2[PFWSUB1]));
      end
    end
    PF0NW01.PF0NWNUM = PFGREC.PFGQTY[3];
    if (PF0NW01.PF0NWNUM >= +999500.00)
      PF0NW02.PF0NWC3[PFWSUB1] = +999;
    else
      if (PF0NW01.PF0NWNUM <= -99500.00)
        PF0NW02.PF0NWC3[PFWSUB1] = -99;
      else
        PF0NW02.PF0NWC3[PFWSUB1] = mathLib.round(PF0NW01.PF0NWNUM * .001, -mathLib.decimals(PF0NW02.PF0NWC3[PFWSUB1]));
      end
    end
    PF0NW01.PF0NWNUM = PFGREC.PFGQTY[4];
    if (PF0NW01.PF0NWNUM >= +999500.00)
      PF0NW02.PF0NWC4[PFWSUB1] = +999;
    else
      if (PF0NW01.PF0NWNUM <= -99500.00)
        PF0NW02.PF0NWC4[PFWSUB1] = -99;
      else
        PF0NW02.PF0NWC4[PFWSUB1] = mathLib.round(PF0NW01.PF0NWNUM * .001, -mathLib.decimals(PF0NW02.PF0NWC4[PFWSUB1]));
      end
    end
    PF0NW01.PF0NWNUM = PFGREC.PFGQTY[5];
    if (PF0NW01.PF0NWNUM >= +999500.00)
      PF0NW02.PF0NWC5[PFWSUB1] = +999;
    else
      if (PF0NW01.PF0NWNUM <= -99500.00)
        PF0NW02.PF0NWC5[PFWSUB1] = -99;
      else
        PF0NW02.PF0NWC5[PFWSUB1] = mathLib.round(PF0NW01.PF0NWNUM * .001, -mathLib.decimals(PF0NW02.PF0NWC5[PFWSUB1]));
      end
    end
    PF0NW01.PF0NWNUM = PFGREC.PFGQTY[6];
    if (PF0NW01.PF0NWNUM >= +999500.00)
      PF0NW02.PF0NWC6[PFWSUB1] = +999;
    else
      if (PF0NW01.PF0NWNUM <= -99500.00)
        PF0NW02.PF0NWC6[PFWSUB1] = -99;
      else
        PF0NW02.PF0NWC6[PFWSUB1] = mathLib.round(PF0NW01.PF0NWNUM * .001, -mathLib.decimals(PF0NW02.PF0NWC6[PFWSUB1]));
      end
    end
    PF0NW01.PF0NWNUM = PFGREC.PFGQTY[7];
    if (PF0NW01.PF0NWNUM >= +999500.00)
      PF0NW02.PF0NWC7[PFWSUB1] = +999;
    else
      if (PF0NW01.PF0NWNUM <= -99500.00)
        PF0NW02.PF0NWC7[PFWSUB1] = -99;
      else
        PF0NW02.PF0NWC7[PFWSUB1] = mathLib.round(PF0NW01.PF0NWNUM * .001, -mathLib.decimals(PF0NW02.PF0NWC7[PFWSUB1]));
      end
    end
    PF0NW01.PF0NWNUM = PFGREC.PFGQTY[8];
    if (PF0NW01.PF0NWNUM >= +999500.00)
      PF0NW02.PF0NWC8[PFWSUB1] = +999;
    else
      if (PF0NW01.PF0NWNUM <= -99500.00)
        PF0NW02.PF0NWC8[PFWSUB1] = -99;
      else
        PF0NW02.PF0NWC8[PFWSUB1] = mathLib.round(PF0NW01.PF0NWNUM * .001, -mathLib.decimals(PF0NW02.PF0NWC8[PFWSUB1]));
      end
    end
    PF0NW01.PF0NWNUM = PFGREC.PFGQTY[9];
    if (PF0NW01.PF0NWNUM >= +999.95)
      PF0NW02.PF0NWC9[PFWSUB1] = +999.99;
    else
      if (PF0NW01.PF0NWNUM <= -99.95)
        PF0NW02.PF0NWC9[PFWSUB1] = -99.99;
      else
        PF0NW02.PF0NWC9[PFWSUB1] = mathLib.round(PF0NW01.PF0NWNM2 * 1, -mathLib.decimals(PF0NW02.PF0NWC9[PFWSUB1]));
      end
    end
    PF0NW01.PF0NWNUM = PFGREC.PFGQTY[10];
    if (PF0NW01.PF0NWNUM >= +999.95)
      PF0NW02.PF0NWC10[PFWSUB1] = +999.99;
    else
      if (PF0NW01.PF0NWNUM <= -99.95)
        PF0NW02.PF0NWC10[PFWSUB1] = -99.99;
      else
        PF0NW02.PF0NWC10[PFWSUB1] = mathLib.round(PF0NW01.PF0NWNM2 * 1, -mathLib.decimals(PF0NW02.PF0NWC10[PFWSUB1]));
      end
    end
    PF0NW01.PF0NWNUM = PFGREC.PFGQTY[11];
    if (PF0NW01.PF0NWNUM >= +999.95)
      PF0NW02.PF0NWC11[PFWSUB1] = +999.99;
    else
      if (PF0NW01.PF0NWNUM <= -99.95)
        PF0NW02.PF0NWC11[PFWSUB1] = -99.99;
      else
        PF0NW02.PF0NWC11[PFWSUB1] = mathLib.round(PF0NW01.PF0NWNM2 * 1, -mathLib.decimals(PF0NW02.PF0NWC11[PFWSUB1]));
      end
    end
    PF0NW01.PF0NWNUM = PFGREC.PFGQTY[12];
    if (PF0NW01.PF0NWNUM >= +999.95)
      PF0NW02.PF0NWC12[PFWSUB1] = +999.99;
    else
      if (PF0NW01.PF0NWNUM <= -99.95)
        PF0NW02.PF0NWC12[PFWSUB1] = -99.99;
      else
        PF0NW02.PF0NWC12[PFWSUB1] = mathLib.round(PF0NW01.PF0NWNM2 * 1, -mathLib.decimals(PF0NW02.PF0NWC12[PFWSUB1]));
      end
    end
    PF0NW02.PF0NWC12[PFWSUB1] = mathLib.round(PF0NW01.PF0NWNM2 * 1, -mathLib.decimals(PF0NW02.PF0NWC12[PFWSUB1]));
  else
    PF0NW01.PF0NWNUM = PFGREC.PFGQTY[1];
    PF0NW02.PF0NWC1[PFWSUB1] = mathLib.round(PF0NW01.PF0NWNUM * .001, -mathLib.decimals(PF0NW02.PF0NWC1[PFWSUB1]));
    PF0NW01.PF0NWNUM = PFGREC.PFGQTY[2];
    PF0NW02.PF0NWC2[PFWSUB1] = mathLib.round(PF0NW01.PF0NWNUM * .001, -mathLib.decimals(PF0NW02.PF0NWC2[PFWSUB1]));
    PF0NW01.PF0NWNUM = PFGREC.PFGQTY[3];
    PF0NW02.PF0NWC3[PFWSUB1] = mathLib.round(PF0NW01.PF0NWNUM * .001, -mathLib.decimals(PF0NW02.PF0NWC3[PFWSUB1]));
    PF0NW01.PF0NWNUM = PFGREC.PFGQTY[4];
    PF0NW02.PF0NWC4[PFWSUB1] = mathLib.round(PF0NW01.PF0NWNUM * .001, -mathLib.decimals(PF0NW02.PF0NWC4[PFWSUB1]));
    PF0NW01.PF0NWNUM = PFGREC.PFGQTY[5];
    PF0NW02.PF0NWC5[PFWSUB1] = mathLib.round(PF0NW01.PF0NWNUM * .001, -mathLib.decimals(PF0NW02.PF0NWC5[PFWSUB1]));
    PF0NW01.PF0NWNUM = PFGREC.PFGQTY[6];
    PF0NW02.PF0NWC6[PFWSUB1] = mathLib.round(PF0NW01.PF0NWNUM * .001, -mathLib.decimals(PF0NW02.PF0NWC6[PFWSUB1]));
    PF0NW01.PF0NWNUM = PFGREC.PFGQTY[7];
    PF0NW02.PF0NWC7[PFWSUB1] = mathLib.round(PF0NW01.PF0NWNUM * .001, -mathLib.decimals(PF0NW02.PF0NWC7[PFWSUB1]));
    PF0NW01.PF0NWNUM = PFGREC.PFGQTY[8];
    PF0NW02.PF0NWC8[PFWSUB1] = mathLib.round(PF0NW01.PF0NWNUM * .001, -mathLib.decimals(PF0NW02.PF0NWC8[PFWSUB1]));
    PF0NW01.PF0NWNUM = PFGREC.PFGQTY[9];
    if (PF0NW01.PF0NWNUM >= +999.95)
      PF0NW02.PF0NWC9[PFWSUB1] = +999.99;
    else
      if (PF0NW01.PF0NWNUM <= -99.95)
        PF0NW02.PF0NWC9[PFWSUB1] = -99.99;
      else
        PF0NW02.PF0NWC9[PFWSUB1] = mathLib.round(PF0NW01.PF0NWNM2 * 1, -mathLib.decimals(PF0NW02.PF0NWC9[PFWSUB1]));
      end
    end
    PF0NW01.PF0NWNUM = PFGREC.PFGQTY[10];
    if (PF0NW01.PF0NWNUM >= +999.95)
      PF0NW02.PF0NWC10[PFWSUB1] = +999.99;
    else
      if (PF0NW01.PF0NWNUM <= -99.95)
        PF0NW02.PF0NWC10[PFWSUB1] = -99.99;
      else
        PF0NW02.PF0NWC10[PFWSUB1] = mathLib.round(PF0NW01.PF0NWNM2 * 1, -mathLib.decimals(PF0NW02.PF0NWC10[PFWSUB1]));
      end
    end
    PF0NW01.PF0NWNUM = PFGREC.PFGQTY[11];
    if (PF0NW01.PF0NWNUM >= +999.95)
      PF0NW02.PF0NWC11[PFWSUB1] = +999.99;
    else
      if (PF0NW01.PF0NWNUM <= -99.95)
        PF0NW02.PF0NWC11[PFWSUB1] = -99.99;
      else
        PF0NW02.PF0NWC11[PFWSUB1] = mathLib.round(PF0NW01.PF0NWNM2 * 1, -mathLib.decimals(PF0NW02.PF0NWC11[PFWSUB1]));
      end
    end
    PF0NW01.PF0NWNUM = PFGREC.PFGQTY[12];
    if (PF0NW01.PF0NWNUM >= +999.95)
      PF0NW02.PF0NWC12[PFWSUB1] = +999.99;
    else
      if (PF0NW01.PF0NWNUM <= -99.95)
        PF0NW02.PF0NWC12[PFWSUB1] = -99.99;
      else
        PF0NW02.PF0NWC12[PFWSUB1] = mathLib.round(PF0NW01.PF0NWNM2 * 1, -mathLib.decimals(PF0NW02.PF0NWC12[PFWSUB1]));
      end
    end
  end
end // end PF0N230

// get i/s group descriptions
Function PF0N240()
   /* *********************************************************/
   /* *  this process will scan through the pf0nw02 storage  **/
   /* *  and will get the i/s group descriptions for all i/s **/
   /* *  group total entires in pf0nw02(record type  = 3).   **/
   /* *  the i/s group desc. will be obtained by using the   **/
   /* *  yiscd of the record immediately following the group **/
   /* *  total record. this yiscd is combined with the i/s   **/
   /* *  group ref. # as a data base key to access the i/s   **/
   /* *  group table.                                        **/
   /* *********************************************************/
  ;
  if (PF0NW02.PF0NWTYP[PFWSUB1] != "3") /* if the entry isn't a group total,*/
    return; /* exit the routine*/
  end
  ;
  PFWSUB2 = PFWSUB1 + 1; /* set subscript to entry immediately following*/
  ;
  set SQLCA empty;
  set PFBREC empty;
  PFBREC.PFBREF = PFEREC.PFBREF;
                                   /* setup to access i/s group table*/
  PFBREC.YISCD[1] = PF0NW02.YISCD[PFWSUB2];
  call "IO2710" ("S ", SQLCA, PFBREC) {isNoRefresh = yes, isExternal = yes}; /* access visgrp01 table*/
  if (SQLCA.VAGen_SQLCODE == +0) /* if record found, move i/s group desc. to*/
    PF0NW02.PF0NWABV[PFWSUB1] = PFBREC.PFBISDSC; /* w/s area*/
  else
    TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
    TA1REC.TA1TBLVU = "VISGRP01";
    PF0NW01.PF0NWABK = PFBREC.PFBREF;
    TA1REC.TA1TBLKE = PF0NW01.PF0NWABK;
    TA1REC.TA1LOCAT[3] = "PF0N240";
    TA1REC.TA1LOCAT[4] = "IO2710";
    XPPF010();
  end
end // end PF0N240

// access vsumry01 table
Function PF0N260()
   /* ***********************************************************/
   /* *  this process will access the vsumry01 table using     **/
   /* *  the summary name, summary level, and summary sequence **/
   /* *  number as db2 keys. this process will be used to read **/
   /* *  the summary file in a backwards direction and will    **/
   /* *  read the first record of the requested summary only.  **/
   /* *  the level and seq. # keys will then be used by        **/
   /* *  pf0n200 to read the summary in a normal manner.       **/
   /* ***********************************************************/
  ;
  set PFGREC empty;
  set SQLCA empty;
  ;
  PFGREC.PFESUMNM = PFEREC.PFESUMNM; /* move summary name to db2 key*/
  PFGREC.PFGSUMN = PFEREC.PFGSUMN; /* move summary # to db2 key*/
  PFGREC.PFGLVLNO = PF0NW01.PF0NWSTL; /* move level # to db2 key*/
  PFGREC.PFGLVLSQ = PF0NW01.PF0NWSTS; /* move level seq # to db2 key*/
  ;
  call "IO2920" ("SF", SQLCA, PFGREC) {isNoRefresh = yes, isExternal = yes};
                                   /* read vsumry01 select/first*/
  ;
  if (SQLCA.VAGen_SQLCODE == +0) /* if cursor open ok, continue with the process*/
    PF0NW01.PF0NWSTS = PFGREC.PFGLVLSQ; /* save seq. #*/
  else
    if (SQLCA.VAGen_SQLCODE == +100)
      return;
    else
      TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
      TA1REC.TA1TBLVU = "VSUMRY01";
      TA1REC.TA1TBLKE = PF1REC.PFESUMNM;
      TA1REC.TA1LOCAT[3] = "PF0N200";
      TA1REC.TA1LOCAT[4] = "IO2920";
      XPPF010();
    end
  end
  ;
end // end PF0N260

// check for hierarchy change
Function PF0N270()
   /* ********************************************************/
   /* *  this process will check the reporting attribute    **/
   /* *  values of the previous and current summaries that  **/
   /* *  were displayed as a result of a pf20 or pf21 key.  **/
   /* *  if the result of of either key is a change in the  **/
   /* *  reporting attributes hierarchy as described below, **/
   /* *  then a warning message is sent to the terminal     **/
   /* *  operator. in the following example, if the user is **/
   /* *  viewing the summary indicated as point a and       **/
   /* *  enters pf20 (move up within a level) to move to    **/
   /* *  point b, the hierarchy level of '003 non-tech      **/
   /* *  running' has been bypassed.                        **/
   /* *  02  running                                        **/
   /* *      002  tecnical running                          **/
   /* *           21  national                              **/
   /* *           22  major                                 **/
   /* *           23  regular   ---- point b                **/
   /* *      003  non-tech running                          **/
   /* *           21  national  ---- point a                **/
   /* *           22  major                                 **/
   /* *           23  regular                               **/
   /* *  05  basketball                                     **/
   /* ********************************************************/
  ;
  if (PF0NW01.PF0NWSTL == 8) /* find current level # and compare attributes*/
    if (PF0NW01.PF0NWCD7 != PF0NW01.PF0NWCV7) /* from one level lower*/
        /* if they don't match, send warning to user*/
      PF0NW01.PF0NWRN1 = "BKWD/FRWD MOVEMENT AT \"";
      PF0NW01.PF0NWRV1 = PF1REC.PFISDESC[8];
      PF0NW01.PF0NWRN2 = "\" LEVEL HAS CAUSED \"";
      PF0NW01.PF0NWRV2 = PF1REC.PFISDESC[7];
      PF0NW01.PF0NWRN3 = "\" VALUE TO CHANGE";
      PF0NM001.VAGen_EZEMSG = PF0NW01.PF0NWRN; /* move warning message*/
      PF0NM002.VAGen_EZEMSG = PF0NW01.PF0NWRN; /* to screen*/
    end
    return;
  end
  ;
  if (PF0NW01.PF0NWSTL == 6) /* find current level # and compare attributes*/
    if (PF0NW01.PF0NWCD6 != PF0NW01.PF0NWCV6) /* from one level lower*/
        /* if they don't match, send warning to user*/
      PF0NW01.PF0NWRN1 = "BKWD/FRWD MOVEMENT AT \"";
      PF0NW01.PF0NWRV1 = PF1REC.PFISDESC[7];
      PF0NW01.PF0NWRN2 = "\" LEVEL HAS CAUSED \"";
      PF0NW01.PF0NWRV2 = PF1REC.PFISDESC[6];
      PF0NW01.PF0NWRN3 = "\" VALUE TO CHANGE";
      PF0NM001.VAGen_EZEMSG = PF0NW01.PF0NWRN; /* move warning message*/
      PF0NM002.VAGen_EZEMSG = PF0NW01.PF0NWRN; /* to screen*/
    end
    return;
  end
  ;
  if (PF0NW01.PF0NWSTL == 6) /* find current level # and compare attributes*/
    if (PF0NW01.PF0NWCD5 != PF0NW01.PF0NWCV5) /* from one level lower*/
        /* if they don't match, send warning to user*/
      PF0NW01.PF0NWRN1 = "BKWD/FRWD MOVEMENT AT \"";
      PF0NW01.PF0NWRV1 = PF1REC.PFISDESC[6];
      PF0NW01.PF0NWRN2 = "\" LEVEL HAS CAUSED \"";
      PF0NW01.PF0NWRV2 = PF1REC.PFISDESC[5];
      PF0NW01.PF0NWRN3 = "\" VALUE TO CHANGE";
      PF0NM001.VAGen_EZEMSG = PF0NW01.PF0NWRN; /* move warning message*/
      PF0NM002.VAGen_EZEMSG = PF0NW01.PF0NWRN; /* to screen*/
    end
    return;
  end
  ;
  if (PF0NW01.PF0NWSTL == 5) /* find current level # and compare attributes*/
    if (PF0NW01.PF0NWCD4 != PF0NW01.PF0NWCV4) /* from one level lower*/
        /* if they don't match, send warning to user*/
      PF0NW01.PF0NWRN1 = "BKWD/FRWD MOVEMENT AT \"";
      PF0NW01.PF0NWRV1 = PF1REC.PFISDESC[5];
      PF0NW01.PF0NWRN2 = "\" LEVEL HAS CAUSED \"";
      PF0NW01.PF0NWRV2 = PF1REC.PFISDESC[4];
      PF0NW01.PF0NWRN3 = "\" VALUE TO CHANGE";
      PF0NM001.VAGen_EZEMSG = PF0NW01.PF0NWRN; /* move warning message*/
      PF0NM002.VAGen_EZEMSG = PF0NW01.PF0NWRN; /* to screen*/
    end
    return;
  end
  ;
  if (PF0NW01.PF0NWSTL == 4) /* find current level # and compare attributes*/
    if (PF0NW01.PF0NWCD3 != PF0NW01.PF0NWCV3) /* from one level lower*/
        /* if they don't match, send warning to user*/
      PF0NW01.PF0NWRN1 = "BKWD/FRWD MOVEMENT AT \"";
      PF0NW01.PF0NWRV1 = PF1REC.PFISDESC[4];
      PF0NW01.PF0NWRN2 = "\" LEVEL HAS CAUSED \"";
      PF0NW01.PF0NWRV2 = PF1REC.PFISDESC[3];
      PF0NW01.PF0NWRN3 = "\" VALUE TO CHANGE";
      PF0NM001.VAGen_EZEMSG = PF0NW01.PF0NWRN; /* move warning message*/
      PF0NM002.VAGen_EZEMSG = PF0NW01.PF0NWRN; /* to screen*/
    end
    return;
  end
  ;
  if (PF0NW01.PF0NWSTL == 3) /* find current level # and compare attributes*/
    if (PF0NW01.PF0NWCD2 != PF0NW01.PF0NWCV2) /* from one level lower*/
        /* if they don't match, send warning to user*/
      PF0NW01.PF0NWRN1 = "BKWD/FRWD MOVEMENT AT \"";
      PF0NW01.PF0NWRV1 = PF1REC.PFISDESC[3];
      PF0NW01.PF0NWRN2 = "\" LEVEL HAS CAUSED \"";
      PF0NW01.PF0NWRV2 = PF1REC.PFISDESC[2];
      PF0NW01.PF0NWRN3 = "\" VALUE TO CHANGE";
      PF0NM001.VAGen_EZEMSG = PF0NW01.PF0NWRN; /* move warning message*/
      PF0NM002.VAGen_EZEMSG = PF0NW01.PF0NWRN; /* to screen*/
    end
    return;
  end
  ;
  if (PF0NW01.PF0NWSTL == 2) /* find current level # and compare attributes*/
    if (PF0NW01.PF0NWCD1 != PF0NW01.PF0NWCV1) /* from one level lower*/
        /* if they don't match, send warning to user*/
      PF0NW01.PF0NWRN1 = "BKWD/FRWD MOVEMENT AT \"";
      PF0NW01.PF0NWRV1 = PF1REC.PFISDESC[2];
      PF0NW01.PF0NWRN2 = "\" LEVEL HAS CAUSED \"";
      PF0NW01.PF0NWRV2 = PF1REC.PFISDESC[1];
      PF0NW01.PF0NWRN3 = "\" VALUE TO CHANGE";
      PF0NM001.VAGen_EZEMSG = PF0NW01.PF0NWRN; /* move warning message*/
      PF0NM002.VAGen_EZEMSG = PF0NW01.PF0NWRN; /* to screen*/
    end
    return;
  end
  ;
end // end PF0N270

// display summary type
Function PF0N300()
   /* ************************************************************/
   /* *  this process will determine the type of summary a user **/
   /* *  is viewing and will perform the appropriate routine to **/
   /* *  move summary records to the maps. the routines are :   **/
   /* *  summary type     routine                               **/
   /* *  ------------     -------------                         **/
   /* *    'sum'          pf0n310                               **/
   /* *    'det'          pf0n320                               **/
   /* *    'exp'          pf0n330                               **/
   /* ************************************************************/
  ;
  if (PF0NW01.PF0NWDSP == "SUM") /* summary display*/
    PF0N310();
  else
    if (PF0NW01.PF0NWDSP == "DET") /* detail display*/
      PF0N320();
    else
      if (PF0NW01.PF0NWDSP == "EXP") /* explode display*/
        PF0N330();
      end
    end
  end
end // end PF0N300

// move 'summary' items to maps
Function PF0N310()
   /* ***************************************************/
   /* *   this process will move all 'summary' items   **/
   /* *   from pf0nw02 record to the maps. summary     **/
   /* *   items are identified by the field pf0nwtyp   **/
   /* *   being = 1. the summary display will use one  **/
   /* *   screen only; no scrolling will be allowed.   **/
   /* *   both the right side(pf0nm001) and the left   **/
   /* *   side(pf0nm002) of the display will be        **/
   /* *   loaded in this process. the user can scroll  **/
   /* *   right and left using pf10 and pf11.          **/
   /* ***************************************************/
  ;
  PF0N340(); /* clear maps of previous data*/
  ;
  PFWREC.PFWSAVDX = PFWREC.PFWSUB1; /* save first w/s position*/
  ;
  PFWSUB2 = 1;
  while (PFWSUB2 < 11) /* browse through pf0nw02 and move all*/
    if (PF0NW02.PF0NWTYP[PFWSUB1] == "1") /* summary records to the maps*/
      PF0NM001.PF0NMISD[PFWSUB2] = PF0NW02.PF0NWLIT[PFWSUB1];
      PF0NM002.PF0NMISD[PFWSUB2] = PF0NW02.PF0NWLIT[PFWSUB1];
      ;
      PF0NM001.PF0NMAM1[PFWSUB2] = PF0NW02.PF0NWC1[PFWSUB1];
      PF0NM001.PF0NMAM2[PFWSUB2] = PF0NW02.PF0NWC2[PFWSUB1];
      PF0NM001.PF0NMAM3[PFWSUB2] = PF0NW02.PF0NWC3[PFWSUB1];
      PF0NM001.PF0NMAM4[PFWSUB2] = PF0NW02.PF0NWC4[PFWSUB1];
      PF0NM001.PF0NMAM5[PFWSUB2] = PF0NW02.PF0NWC5[PFWSUB1];
      PF0NM001.PF0NMAM6[PFWSUB2] = PF0NW02.PF0NWC6[PFWSUB1];
      PF0NM001.PF0NMPC1[PFWSUB2] = PF0NW02.PF0NWC9[PFWSUB1];
      ;
      PF0NM002.PF0NMAM1[PFWSUB2] = PF0NW02.PF0NWC5[PFWSUB1];
      PF0NM002.PF0NMAM2[PFWSUB2] = PF0NW02.PF0NWC6[PFWSUB1];
      PF0NM002.PF0NMAM3[PFWSUB2] = PF0NW02.PF0NWC7[PFWSUB1];
      PF0NM002.PF0NMAM4[PFWSUB2] = PF0NW02.PF0NWC8[PFWSUB1];
      PF0NM002.PF0NMPC1[PFWSUB2] = PF0NW02.PF0NWC10[PFWSUB1];
      PF0NM002.PF0NMPC2[PFWSUB2] = PF0NW02.PF0NWC11[PFWSUB1];
      PF0NM002.PF0NMPC3[PFWSUB2] = PF0NW02.PF0NWC12[PFWSUB1];
      PFWSUB2 = PFWSUB2 + 1; /* bump index for maps*/
    end
    PFWSUB1 = PFWSUB1 + 1; /* bump w/s index*/
    if (PFWSUB1 > PFWLIMIT)
      PFWSUB2 = 13;
    end
  end
end // end PF0N310

// move 'detail' items to maps
Function PF0N320()
   /* ***************************************************/
   /* *   this process will move all 'detail' items    **/
   /* *   from pf0nw02 record to the maps. detail      **/
   /* *   items are identified by the field pf0nwtyp   **/
   /* *   being = 1, 2, 3, or 5.  detail display will  **/
   /* *   scroll up and down the pf0nw02 w/s area.     **/
   /* *   the control of scrolling positioning will    **/
   /* *   be done by pf0nxxx.                          **/
   /* *   both the right side(pf0nm001) and the left   **/
   /* *   side(pf0nm002) of the display will be        **/
   /* *   loaded in this process. the user can shift   **/
   /* *   right and left using pf10 and pf11.          **/
   /* ***************************************************/
  ;
  PF0N340(); /* clear maps of previous data*/
  ;
  PFWREC.PFWSAVDX = PFWREC.PFWSUB1; /* save first w/s position*/
  ;
  PFWSUB2 = 1;
  ;
  while (PFWSUB2 < 11) /* browse through pf0nw02 and move all*/
    if (PF0NW02.PF0NWTYP[PFWSUB1] == "1" /* detail records to the maps*/
     || PF0NW02.PF0NWTYP[PFWSUB1] == "2" 
     || PF0NW02.PF0NWTYP[PFWSUB1] == "3" 
     || PF0NW02.PF0NWTYP[PFWSUB1] == "5")
      PF0NM001.PF0NMISD[PFWSUB2] = PF0NW02.PF0NWLIT[PFWSUB1];
      PF0NM002.PF0NMISD[PFWSUB2] = PF0NW02.PF0NWLIT[PFWSUB1];
      ;
      PF0NM001.PF0NMAM1[PFWSUB2] = PF0NW02.PF0NWC1[PFWSUB1];
      PF0NM001.PF0NMAM2[PFWSUB2] = PF0NW02.PF0NWC2[PFWSUB1];
      PF0NM001.PF0NMAM3[PFWSUB2] = PF0NW02.PF0NWC3[PFWSUB1];
      PF0NM001.PF0NMAM4[PFWSUB2] = PF0NW02.PF0NWC4[PFWSUB1];
      PF0NM001.PF0NMAM5[PFWSUB2] = PF0NW02.PF0NWC5[PFWSUB1];
      PF0NM001.PF0NMAM6[PFWSUB2] = PF0NW02.PF0NWC6[PFWSUB1];
      PF0NM001.PF0NMPC1[PFWSUB2] = PF0NW02.PF0NWC9[PFWSUB1];
      ;
      PF0NM002.PF0NMAM1[PFWSUB2] = PF0NW02.PF0NWC5[PFWSUB1];
      PF0NM002.PF0NMAM2[PFWSUB2] = PF0NW02.PF0NWC6[PFWSUB1];
      PF0NM002.PF0NMAM3[PFWSUB2] = PF0NW02.PF0NWC7[PFWSUB1];
      PF0NM002.PF0NMAM4[PFWSUB2] = PF0NW02.PF0NWC8[PFWSUB1];
      PF0NM002.PF0NMPC1[PFWSUB2] = PF0NW02.PF0NWC10[PFWSUB1];
      PF0NM002.PF0NMPC2[PFWSUB2] = PF0NW02.PF0NWC11[PFWSUB1];
      PF0NM002.PF0NMPC3[PFWSUB2] = PF0NW02.PF0NWC12[PFWSUB1];
      PFWSUB2 = PFWSUB2 + 1; /* bump index for maps*/
    end
    PFWSUB1 = PFWSUB1 + 1; /* bump w/s index*/
    if (PFWSUB1 > PFWLIMIT) /* if w/s end reached,*/
      PFWSUB2 = 13;
    end
  end
  ;
  PFWREC.PFWNXTDX = PFWREC.PFWSUB1; /* save next available index*/
end // end PF0N320

// move 'explode' items to maps
Function PF0N330()
   /* ***************************************************/
   /* *   this process will move all 'explode' items   **/
   /* *   from pf0nw02 record to the maps. explode     **/
   /* *   items are identified by the field pf0nwtyp   **/
   /* *   being = 1, 2, 4, or 5.  detail display will  **/
   /* *   scroll up and down the pf0nw02 w/s area.     **/
   /* *   the control of scrolling positioning will    **/
   /* *   be done by pf0nxxx.                          **/
   /* *   both the right side(pf0nm001) and the left   **/
   /* *   side(pf0nm002) of the display will be        **/
   /* *   loaded in this process. the user can shift   **/
   /* *   right and left using pf10 and pf11.          **/
   /* ***************************************************/
  ;
  PF0N340(); /* clear maps of previous data*/
  ;
  PFWREC.PFWSAVDX = PFWREC.PFWSUB1; /* save first w/s position*/
  ;
  PFWSUB2 = 1;
  ;
  while (PFWSUB2 < 11) /* browse through pf0nw02 and move all*/
    if (PF0NW02.PF0NWTYP[PFWSUB1] == "1" /* explode records to the maps*/
     || PF0NW02.PF0NWTYP[PFWSUB1] == "2" 
     || PF0NW02.PF0NWTYP[PFWSUB1] == "4" 
     || PF0NW02.PF0NWTYP[PFWSUB1] == "5")
      PF0NM001.PF0NMISD[PFWSUB2] = PF0NW02.PF0NWLIT[PFWSUB1];
      PF0NM002.PF0NMISD[PFWSUB2] = PF0NW02.PF0NWLIT[PFWSUB1];
      ;
      PF0NM001.PF0NMAM1[PFWSUB2] = PF0NW02.PF0NWC1[PFWSUB1];
      PF0NM001.PF0NMAM2[PFWSUB2] = PF0NW02.PF0NWC2[PFWSUB1];
      PF0NM001.PF0NMAM3[PFWSUB2] = PF0NW02.PF0NWC3[PFWSUB1];
      PF0NM001.PF0NMAM4[PFWSUB2] = PF0NW02.PF0NWC4[PFWSUB1];
      PF0NM001.PF0NMAM5[PFWSUB2] = PF0NW02.PF0NWC5[PFWSUB1];
      PF0NM001.PF0NMAM6[PFWSUB2] = PF0NW02.PF0NWC6[PFWSUB1];
      PF0NM001.PF0NMPC1[PFWSUB2] = PF0NW02.PF0NWC9[PFWSUB1];
      ;
      PF0NM002.PF0NMAM1[PFWSUB2] = PF0NW02.PF0NWC5[PFWSUB1];
      PF0NM002.PF0NMAM2[PFWSUB2] = PF0NW02.PF0NWC6[PFWSUB1];
      PF0NM002.PF0NMAM3[PFWSUB2] = PF0NW02.PF0NWC7[PFWSUB1];
      PF0NM002.PF0NMAM4[PFWSUB2] = PF0NW02.PF0NWC8[PFWSUB1];
      PF0NM002.PF0NMPC1[PFWSUB2] = PF0NW02.PF0NWC10[PFWSUB1];
      PF0NM002.PF0NMPC2[PFWSUB2] = PF0NW02.PF0NWC11[PFWSUB1];
      PF0NM002.PF0NMPC3[PFWSUB2] = PF0NW02.PF0NWC12[PFWSUB1];
      PFWSUB2 = PFWSUB2 + 1; /* bump index for maps*/
    end
    PFWSUB1 = PFWSUB1 + 1; /* bump w/s index*/
    if (PFWSUB1 > PFWLIMIT) /* if w/s end reached, end the routine*/
      PFWSUB2 = 13;
    end
  end
  ;
  PFWREC.PFWNXTDX = PFWREC.PFWSUB1; /* save next w/s position*/
end // end PF0N330

// clear map fields
Function PF0N340()
  ;
  PFWSUB2 = 1;
  ;
  while (PFWSUB2 < 11)
    PF0NM001.PF0NMISD[PFWSUB2] = " ";
    PF0NM002.PF0NMISD[PFWSUB2] = " ";
    PF0NM001.PF0NMAM1[PFWSUB2] = 0;
    PF0NM001.PF0NMAM2[PFWSUB2] = 0;
    PF0NM001.PF0NMAM3[PFWSUB2] = 0;
    PF0NM001.PF0NMAM4[PFWSUB2] = 0;
    PF0NM001.PF0NMAM5[PFWSUB2] = 0;
    PF0NM001.PF0NMAM6[PFWSUB2] = 0;
    PF0NM001.PF0NMPC1[PFWSUB2] = 0;
    PF0NM002.PF0NMAM1[PFWSUB2] = 0;
    PF0NM002.PF0NMAM2[PFWSUB2] = 0;
    PF0NM002.PF0NMAM3[PFWSUB2] = 0;
    PF0NM002.PF0NMAM4[PFWSUB2] = 0;
    PF0NM002.PF0NMPC1[PFWSUB2] = 0;
    PF0NM002.PF0NMPC2[PFWSUB2] = 0;
    PF0NM002.PF0NMPC3[PFWSUB2] = 0;
    PFWSUB2 = PFWSUB2 + 1;
  end
  ;
end // end PF0N340

// scroll backwards thru 'det'
Function PF0N350()
   /* *****************************************************/
   /* *  this routine is nearly identical to pf0n320.    **/
   /* *  the difference is that this routine will scroll **/
   /* *  backwards through the w/s area, pf0nw02, by     **/
   /* *  decrementing the storage and screen subscripts. **/
   /* *  if the w/s subscript reaches zero after being   **/
   /* *  decremented, it is set to 1 and the scroll      **/
   /* *  forward routine, pf0n320, is performed.         **/
   /* *****************************************************/
  ;
  if (PFWSUB1 < 1)
    converseLib.validationFailed(085);
    return;
  end
  ;
  PF0N340(); /* clear maps of previous data*/
  ;
  ;
  PFWREC.PFWNXTDX = PFWREC.PFWSUB1; /* save last w/s position*/
  ;
  PFWSUB2 = 10;
  ;
  while (PFWSUB2 > 0) /* browse backwards through pf0nw02 and move all*/
    if (PF0NW02.PF0NWTYP[PFWSUB1] == "1" /* detail records to the maps*/
     || PF0NW02.PF0NWTYP[PFWSUB1] == "2" 
     || PF0NW02.PF0NWTYP[PFWSUB1] == "3" 
     || PF0NW02.PF0NWTYP[PFWSUB1] == "5")
      PF0NM001.PF0NMISD[PFWSUB2] = PF0NW02.PF0NWLIT[PFWSUB1];
      PF0NM002.PF0NMISD[PFWSUB2] = PF0NW02.PF0NWLIT[PFWSUB1];
      ;
      PF0NM001.PF0NMAM1[PFWSUB2] = PF0NW02.PF0NWC1[PFWSUB1];
      PF0NM001.PF0NMAM2[PFWSUB2] = PF0NW02.PF0NWC2[PFWSUB1];
      PF0NM001.PF0NMAM3[PFWSUB2] = PF0NW02.PF0NWC3[PFWSUB1];
      PF0NM001.PF0NMAM4[PFWSUB2] = PF0NW02.PF0NWC4[PFWSUB1];
      PF0NM001.PF0NMAM5[PFWSUB2] = PF0NW02.PF0NWC5[PFWSUB1];
      PF0NM001.PF0NMAM6[PFWSUB2] = PF0NW02.PF0NWC6[PFWSUB1];
      PF0NM001.PF0NMPC1[PFWSUB2] = PF0NW02.PF0NWC9[PFWSUB1];
      ;
      PF0NM002.PF0NMAM1[PFWSUB2] = PF0NW02.PF0NWC5[PFWSUB1];
      PF0NM002.PF0NMAM2[PFWSUB2] = PF0NW02.PF0NWC6[PFWSUB1];
      PF0NM002.PF0NMAM3[PFWSUB2] = PF0NW02.PF0NWC7[PFWSUB1];
      PF0NM002.PF0NMAM4[PFWSUB2] = PF0NW02.PF0NWC8[PFWSUB1];
      PF0NM002.PF0NMPC1[PFWSUB2] = PF0NW02.PF0NWC10[PFWSUB1];
      PF0NM002.PF0NMPC2[PFWSUB2] = PF0NW02.PF0NWC11[PFWSUB1];
      PF0NM002.PF0NMPC3[PFWSUB2] = PF0NW02.PF0NWC12[PFWSUB1];
      PFWSUB2 = PFWSUB2 - 1; /* decrement index for maps*/
    end
    PFWSUB1 = PFWSUB1 - 1; /* decremennet w/s index*/
    if (PFWSUB1 <= 1) /* if w/s end reached,*/
      converseLib.validationFailed(085);
      PFWSUB1 = 1;
      PFWSUB2 = 1;
      PF0N320();
      return;
    end
  end
  ;
  PFWREC.PFWSAVDX = PFWREC.PFWSUB1; /* save first w/s index*/
end // end PF0N350

// scroll backwards thru 'exp'
Function PF0N360()
   /* *****************************************************/
   /* *  this routine is nearly identical to pf0n330.    **/
   /* *  the difference is that this routine will scroll **/
   /* *  backwards through the w/s area, pf0nw02, by     **/
   /* *  decrementing the storage and screen subscripts. **/
   /* *  if the w/s subscript reaches zero after being   **/
   /* *  decremented, it is set to 1 and the scroll      **/
   /* *  forward routine, pf0n330, is performed.         **/
   /* *****************************************************/
  ;
  if (PFWSUB1 < 1)
    converseLib.validationFailed(085);
    return;
  end
  ;
  PF0N340(); /* clear maps of previous data*/
  ;
  PFWREC.PFWNXTDX = PFWREC.PFWSUB1; /* save first w/s position*/
  ;
  PFWSUB2 = 10;
  ;
  while (PFWSUB2 > 0) /* browse backwards through pf0nw02 and move all*/
    if (PF0NW02.PF0NWTYP[PFWSUB1] == "1" /* explode records to the maps*/
     || PF0NW02.PF0NWTYP[PFWSUB1] == "2" 
     || PF0NW02.PF0NWTYP[PFWSUB1] == "4" 
     || PF0NW02.PF0NWTYP[PFWSUB1] == "5")
      PF0NM001.PF0NMISD[PFWSUB2] = PF0NW02.PF0NWLIT[PFWSUB1];
      PF0NM002.PF0NMISD[PFWSUB2] = PF0NW02.PF0NWLIT[PFWSUB1];
      ;
      PF0NM001.PF0NMAM1[PFWSUB2] = PF0NW02.PF0NWC1[PFWSUB1];
      PF0NM001.PF0NMAM2[PFWSUB2] = PF0NW02.PF0NWC2[PFWSUB1];
      PF0NM001.PF0NMAM3[PFWSUB2] = PF0NW02.PF0NWC3[PFWSUB1];
      PF0NM001.PF0NMAM4[PFWSUB2] = PF0NW02.PF0NWC4[PFWSUB1];
      PF0NM001.PF0NMAM5[PFWSUB2] = PF0NW02.PF0NWC5[PFWSUB1];
      PF0NM001.PF0NMAM6[PFWSUB2] = PF0NW02.PF0NWC6[PFWSUB1];
      PF0NM001.PF0NMPC1[PFWSUB2] = PF0NW02.PF0NWC9[PFWSUB1];
      ;
      PF0NM002.PF0NMAM1[PFWSUB2] = PF0NW02.PF0NWC5[PFWSUB1];
      PF0NM002.PF0NMAM2[PFWSUB2] = PF0NW02.PF0NWC6[PFWSUB1];
      PF0NM002.PF0NMAM3[PFWSUB2] = PF0NW02.PF0NWC7[PFWSUB1];
      PF0NM002.PF0NMAM4[PFWSUB2] = PF0NW02.PF0NWC8[PFWSUB1];
      PF0NM002.PF0NMPC1[PFWSUB2] = PF0NW02.PF0NWC10[PFWSUB1];
      PF0NM002.PF0NMPC2[PFWSUB2] = PF0NW02.PF0NWC11[PFWSUB1];
      PF0NM002.PF0NMPC3[PFWSUB2] = PF0NW02.PF0NWC12[PFWSUB1];
      PFWSUB2 = PFWSUB2 - 1; /* decrement index for maps*/
    end
    PFWSUB1 = PFWSUB1 - 1; /* decrement w/s index*/
    if (PFWSUB1 <= 1) /* if w/s end reached,*/
      converseLib.validationFailed(085);
      PFWSUB1 = 1;
      PFWSUB2 = 1;
      PF0N330();
      return;
    end
  end
  ;
  PFWREC.PFWSAVDX = PFWREC.PFWSUB1; /* save first w/s position*/
end // end PF0N360

//*** RECORD=PF0NW01 ****
// miscellaneous storage area for pf0o application
// ***********************
Record PF0NW01 type basicRecord
  10 PF0NWCL1 PF0NWCL1 ; 
    15 PF0NWDT1 PF0NWDT1 ; 
    15 PF0NWF1 PF0NWF1 ; 
    15 PF0NWTP1 PF0NWTP1 ; 
  10 PF0NWCL2 PF0NWCL2 ; 
    15 PF0NWDT2 PF0NWDT2 ; 
    15 PF0NWF2 PF0NWF2 ; 
    15 PF0NWTP2 PF0NWTP2 ; 
  10 PF0NWCL3 PF0NWCL3 ; 
    15 PF0NWDT3 PF0NWDT3 ; 
    15 PF0NWF3 PF0NWF3 ; 
    15 PF0NWTP3 PF0NWTP3 ; 
  10 PF0NWCL4 PF0NWCL4 ; 
    15 PF0NWDT4 PF0NWDT4 ; 
    15 PF0NWF4 PF0NWF4 ; 
    15 PF0NWTP4 PF0NWTP4 ; 
  10 PF0NWCL5 PF0NWCL5 ; 
    15 PF0NWDT5 PF0NWDT5 ; 
    15 PF0NWF5 PF0NWF5 ; 
    15 PF0NWTP5 PF0NWTP5 ; 
  10 PF0NWCL6 PF0NWCL6 ; 
    15 PF0NWDT6 PF0NWDT6 ; 
    15 PF0NWF6 PF0NWF6 ; 
    15 PF0NWTP6 PF0NWTP6 ; 
  10 PF0NWCL7 PF0NWCL7 ; 
    15 PF0NWDT7 PF0NWDT7 ; 
    15 PF0NWF7 PF0NWF7 ; 
    15 PF0NWTP7 PF0NWTP7 ; 
  10 PF0NWCL8 PF0NWCL8 ; 
    15 PF0NWDT8 PF0NWDT8 ; 
    15 PF0NWF8 PF0NWF8 ; 
    15 PF0NWTP8 PF0NWTP8 ; 
  10 PF0NWABK PF0NWABK ; 
    15 PF0NWAB2 PF0NWAB2 ; 
  10 PF0NWSTL PF0NWSTL ; 
  10 PF0NWSTS PF0NWSTS ; 
  10 PF0NWDSP PF0NWDSP ; 
  10 PF0NWHDP PF0NWHDP ; 
  10 PF0NWLEF PF0NWLEF ; 
  10 PF0NWRIG PF0NWRIG ; 
  10 PF0NWPFK PF0NWPFK ; 
    15 PF0NWKY1 PF0NWKY1 ; 
    15 PF0NWDP1 PF0NWDP1 ; 
    15 PF0NWKY2 PF0NWKY2 ; 
    15 PF0NWDP2 PF0NWDP2 ; 
  10 PF0NWFLG PF0NWFLG ; 
  10 PF0NWAVA PF0NWAVA ; 
    15 PF0NWAV1 PF0NWAV1 ; 
    15 PF0NWAV2 PF0NWAV2 ; 
  10 PF0NWAVD PF0NWAVD ; 
    15 PF0NWAD1 PF0NWAD1 ; 
    15 PF0NWAD2 PF0NWAD2 ; 
  10 PF0NWNUM PF0NWNUM ; 
    15 PF0NWNM1 PF0NWNM1 ; 
    15 PF0NWNM2 PF0NWNM2 ; 
  10 PF0NWFL1 PF0NWFL1 ; 
    15 PF0NWCD1 PF0NWCD1 ; 
    15 PF0NWCD2 PF0NWCD2 ; 
    15 PF0NWCD3 PF0NWCD3 ; 
    15 PF0NWCD4 PF0NWCD4 ; 
    15 PF0NWCD5 PF0NWCD5 ; 
    15 PF0NWCD6 PF0NWCD6 ; 
    15 PF0NWCD7 PF0NWCD7 ; 
  10 PF0NWFL2 PF0NWFL2 ; 
    15 PF0NWCV1 PF0NWCV1 ; 
    15 PF0NWCV2 PF0NWCV2 ; 
    15 PF0NWCV3 PF0NWCV3 ; 
    15 PF0NWCV4 PF0NWCV4 ; 
    15 PF0NWCV5 PF0NWCV5 ; 
    15 PF0NWCV6 PF0NWCV6 ; 
    15 PF0NWCV7 PF0NWCV7 ; 
  10 PF0NWSTY PF0NWSTY ; 
    15 XGPCD XGPCD ; 
    15 PF0NWF9 PF0NWF9 ; 
    15 SY1STNBR SY1STNBR ; 
    15 PF0NWF10 PF0NWF10 ; 
    15 SY2CLRID SY2CLRID ; 
    15 PF0NWF11 PF0NWF11 ; 
    15 XDMCD XDMCD ; 
    15 PF0NWF12 PF0NWF12 ; 
    15 XQACD XQACD ; 
    15 PF0NWF13 PF0NWF13 ; 
    15 XLCCD XLCCD ; 
  10 PF0NWHD1 PF0NWHD1 ; 
    15 PF0NWF21 PF0NWF21 ; 
    15 PF0NWH1 PF0NWH1 ; 
    15 PF0NWF22 PF0NWF22 ; 
    15 PF0NWH2 PF0NWH2 ; 
    15 PF0NWF23 PF0NWF23 ; 
    15 PF0NWH3 PF0NWH3 ; 
    15 PF0NWF24 PF0NWF24 ; 
    15 PF0NWH4 PF0NWH4 ; 
    15 PF0NWF25 PF0NWF25 ; 
    15 PF0NWH5 PF0NWH5 ; 
    15 PF0NWF26 PF0NWF26 ; 
    15 PF0NWH6 PF0NWH6 ; 
  10 PF0NWHD2 PF0NWHD2 ; 
    15 PF0NWF28 PF0NWF28 ; 
    15 PF0NWH7 PF0NWH7 ; 
    15 PF0NWF29 PF0NWF29 ; 
    15 PF0NWH8 PF0NWH8 ; 
    15 PF0NWF30 PF0NWF30 ; 
    15 PF0NWH9 PF0NWH9 ; 
    15 PF0NWF31 PF0NWF31 ; 
    15 PF0NWH10 PF0NWH10 ; 
    15 PF0NWF32 PF0NWF32 ; 
  10 PF0NWRN PF0NWRN ; 
    15 PF0NWRN1 PF0NWRN1 ; 
    15 PF0NWRV1 PF0NWRV1 ; 
    15 PF0NWRN2 PF0NWRN2 ; 
    15 PF0NWRV2 PF0NWRV2 ; 
    15 PF0NWRN3 PF0NWRN3 ; 
end // end PF0NW01

//*** RECORD=PF0NW02 ****
// this w/s area is used to store rows of summary information
// to be displayed in this application. the rows are identified
// by the field pf0owtyp as follows :
//  value         summary row type
//  -----         ---------------------------
//    1           summary total item (net rev, etc.)
//    2           special summary total (dir sg&a, ind sg&a)
//    3           i/s grouped totals
//    4           i/s grouped items
//    5           i/s ungrouped items
// 
// MAINTENANCE LOG:
//   DATE      INIT     COMMENTS
// --------    ------   --------------------
// 06/13/91    cvo      Increased group level entries on ws
//                      from 200 to 500.
// 
// ***********************
Record PF0NW02 type basicRecord
  5 PF0NWGRP PF0NWGRP [500] ; 
    10 YISCD YISCD ; 
    10 PF0NWLIT PF0NWLIT ; 
      15 PF0NWIND PF0NWIND ; 
      15 PF0NWABV PF0NWABV ; 
    10 PF0NWTYP PF0NWTYP ; 
    10 PF0NWC1 PF0NWC1 ; 
    10 PF0NWC2 PF0NWC2 ; 
    10 PF0NWC3 PF0NWC3 ; 
    10 PF0NWC4 PF0NWC4 ; 
    10 PF0NWC5 PF0NWC5 ; 
    10 PF0NWC6 PF0NWC6 ; 
    10 PF0NWC7 PF0NWC7 ; 
    10 PF0NWC8 PF0NWC8 ; 
    10 PF0NWC9 PF0NWC9 ; 
    10 PF0NWC10 PF0NWC10 ; 
    10 PF0NWC11 PF0NWC11 ; 
    10 PF0NWC12 PF0NWC12 ; 
end // end PF0NW02

// CHARACTER db2 abend key
DataItem PF0NWAB2 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// numeric db2 abend key
DataItem PF0NWABK num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// yis-ist-cls-abrv
DataItem PF0NWABV char(16)  {
  align = none, fillCharacter = nullFill, inputRequired = no
}
end

// attr. code
DataItem PF0NWAD1 char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. code literal
DataItem PF0NWAD2 char(12)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attribute literal
DataItem PF0NWAV1 char(8)  {
  align = right, fillCharacter = nullFill, inputRequired = no
}
end

// attribute char.' :'
DataItem PF0NWAV2 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attribute literal group
DataItem PF0NWAVA char(10)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. code val. literal
DataItem PF0NWAVD char(17)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dt/tp 1 amt
DataItem PF0NWC1 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp pct comparison 2
DataItem PF0NWC10 bin(4,1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp pct comparison 3
DataItem PF0NWC11 bin(4,1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp pct comparison 4
DataItem PF0NWC12 bin(4,1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp 2 amt
DataItem PF0NWC2 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp 3 amt
DataItem PF0NWC3 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp 4 amt
DataItem PF0NWC4 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp 5 amt
DataItem PF0NWC5 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp 6 amt
DataItem PF0NWC6 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp 7 amt
DataItem PF0NWC7 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp 8 amt
DataItem PF0NWC8 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp pct comparison 1
DataItem PF0NWC9 bin(4,1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// attr. field 1
DataItem PF0NWCD1 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. field 2
DataItem PF0NWCD2 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. field 3
DataItem PF0NWCD3 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. field 4
DataItem PF0NWCD4 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. field 5
DataItem PF0NWCD5 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. field 6
DataItem PF0NWCD6 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. field 7
DataItem PF0NWCD7 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dt/tp pct. col. 1
DataItem PF0NWCL1 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dt/tp pct. col. 2
DataItem PF0NWCL2 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dt/tp pct. col. 3
DataItem PF0NWCL3 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dt/tp pct. col. 4
DataItem PF0NWCL4 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dt/tp pct. col. 5
DataItem PF0NWCL5 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dt/tp pct. col. 6
DataItem PF0NWCL6 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dt/tp pct. col. 7
DataItem PF0NWCL7 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dt/tp pct. col. 8
DataItem PF0NWCL8 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. field 1
DataItem PF0NWCV1 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. field 2
DataItem PF0NWCV2 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. field 3
DataItem PF0NWCV3 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. field 4
DataItem PF0NWCV4 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. field 5
DataItem PF0NWCV5 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. field 6
DataItem PF0NWCV6 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. field 7
DataItem PF0NWCV7 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// display type-'sum,det,exp'
DataItem PF0NWDP1 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// display type-'sum,det,exp'
DataItem PF0NWDP2 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// display type - sum,det,exp
DataItem PF0NWDSP char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data type code 1
DataItem PF0NWDT1 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data type code 2
DataItem PF0NWDT2 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data type code 3
DataItem PF0NWDT3 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data type code 4
DataItem PF0NWDT4 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data type code 5
DataItem PF0NWDT5 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data type code 6
DataItem PF0NWDT6 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data type code 7
DataItem PF0NWDT7 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data type code 8
DataItem PF0NWDT8 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler value ' '
DataItem PF0NWF1 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler-value '/'
DataItem PF0NWF10 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler - value '/'
DataItem PF0NWF11 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler - value '/'
DataItem PF0NWF12 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler - value '/'
DataItem PF0NWF13 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler value ' '
DataItem PF0NWF2 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler - value '--'
DataItem PF0NWF21 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler - value '---'
DataItem PF0NWF22 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler - value '---'
DataItem PF0NWF23 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler - value '---'
DataItem PF0NWF24 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler - value '---'
DataItem PF0NWF25 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler - value '---'
DataItem PF0NWF26 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler - value '--'
DataItem PF0NWF28 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler - value '---'
DataItem PF0NWF29 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler value ' '
DataItem PF0NWF3 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler - value '---'
DataItem PF0NWF30 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler - value '---'
DataItem PF0NWF31 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler - value '-'
DataItem PF0NWF32 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler value ' '
DataItem PF0NWF4 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler value ' '
DataItem PF0NWF5 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler-value '/'
DataItem PF0NWF6 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler-value '/'
DataItem PF0NWF7 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler-value '/'
DataItem PF0NWF8 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler-value '/'
DataItem PF0NWF9 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. values hold area
DataItem PF0NWFL1 char(28)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. values hold area
DataItem PF0NWFL2 char(28)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// vsumry01 sequence flag
DataItem PF0NWFLG char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// gourp level
DataItem PF0NWGRP char(60)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// column 1 heading
DataItem PF0NWH1 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// column 5 heading
DataItem PF0NWH10 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// column 2 heading
DataItem PF0NWH2 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// column 3 heading
DataItem PF0NWH3 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// column 4 heading
DataItem PF0NWH4 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// column 5 heading
DataItem PF0NWH5 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// column 1 heading
DataItem PF0NWH6 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// column 2 heading
DataItem PF0NWH7 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// column 3 heading
DataItem PF0NWH8 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// column 4 heading
DataItem PF0NWH9 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pf0nm001 column headings
DataItem PF0NWHD1 char(53)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pf0mm002 column headings
DataItem PF0NWHD2 char(36)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// hold display type
DataItem PF0NWHDP char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// '*' or '#' or ' '
DataItem PF0NWIND char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pf key literal-value '18:'
DataItem PF0NWKY1 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pf key literal-value '19:'
DataItem PF0NWKY2 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// display left map
DataItem PF0NWLEF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// map i/s class literal
DataItem PF0NWLIT char(17)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// numeric breakdown field
DataItem PF0NWNM1 num(8)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// numeric breakdown field
DataItem PF0NWNM2 num(5,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// numeric breakdown field
DataItem PF0NWNUM num(13,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// pf18, pf19 literal
DataItem PF0NWPFK char(13)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// display right map
DataItem PF0NWRIG char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// warning message
DataItem PF0NWRN char(76)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// warning literal 1
DataItem PF0NWRN1 char(23)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// warning literal 2
DataItem PF0NWRN2 char(20)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// warning literal 3
DataItem PF0NWRN3 char(17)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// warning attribute 1
DataItem PF0NWRV1 char(8)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// warning attribute 2
DataItem PF0NWRV2 char(8)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// hold level number
DataItem PF0NWSTL num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// hold sequence number
DataItem PF0NWSTS num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// product hold area
DataItem PF0NWSTY char(22)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end


// time period code 1
DataItem PF0NWTP1 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// time period code 2
DataItem PF0NWTP2 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// time period code 3
DataItem PF0NWTP3 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// time period code 4
DataItem PF0NWTP4 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// time period code 5
DataItem PF0NWTP5 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// time period code 6
DataItem PF0NWTP6 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// time period code 7
DataItem PF0NWTP7 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// time period code 8
DataItem PF0NWTP8 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// table entry type(1,2,3,4,5)
DataItem PF0NWTYP char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

