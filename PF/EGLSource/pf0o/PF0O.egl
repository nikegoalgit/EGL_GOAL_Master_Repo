package pf0o;
import corpcom2.YSMREC;
import corpcom3.XPPF002;
import corpcom3.XPPF010;
import corpcom3.XPPF020;
import corpcom3.XPPF430;
import corpcom4.XSENTRY;
import corpcom4.XSEXIT;
import corpcom4.XSPF4;
import corpcom4.XSSEGTR;
import corpcom5.COMMAREA;
import corpcom5.ERRSQLCA;
import corpcom6.SQLCA;
import pf.common.*;
import sm.common.SM1REC;
import sy.common.SY1REC;
import sy.common.SY2CLRID;
import sy.common.SYCREC;
import ta.common.TA1REC;
import xx.common.*;
import xx.common.XGPCD;
import xx.common.XLCCD;
import xx.common.XQACD;
import xx.common.YISCD;
import xx01.*;
import xx02.*;
import xx02.XDMCD;
import xx03.*;
import xx04.*;
import xx05.*;
import xx06.*;
import xx07.*;
import xx08.*;
import xx08.SY1STNBR;
import xx08.YFTTBL;
import xx08.YISTBL;
import xx09.*;
import xx10.*;
import xx10.YTYTBL;
//*** PROGRAM=PF0O ****
// this application will display summaries that were generated
// to use a type 5 format. users are able to view the summaries
// in a summary, detail or explode format. users can also view
// 132 column-sized summaries by scrolling right or left on the
// screen that is displayed. finally, summaries can have up to
// 8 levels of information stored in a hierarchical pattern.
// this application will access the selected summary at a
// starting viewing position as determined in pf0b but the user
// has the capability to move up or down the levels easily by
// using predefined pf keys.
// 
// maintenance history:
//   date     by             description of change
// --------  -----  -------------------------------------------
//  1-03-89   mh    original transfer to production.
//  2-28-89   mh    change handling of overflow pcts.
//  4-19-89   DLC   Display 'P' partial summary warning on all
//                  attr levels above the lowest level with a
//                  selected attr, making PF0O consistent with
//                  the other applications called by PF0B.
//  6-21-89   DLC   Change Summary Order Type to Base Order
//                  Type (XOBTBL).
//  7-13-89   DLC   Re-Gen for changes to YFATBL, YMATBL,
//                  YMBTBL, and YMCTBL.
// 11-30-89   TBG   Modify to load and pass data viewed back to
//                  Summary File View Selection (PF0B).
//  4-05-90   CVO   Transfer to PF0A if the expected summary
//                  name is not passed.
//  6-13-91   CVO   Increased group level entries from pf0ow02
//                  from 200 to 500.
//  9-25-91   DLC     Added abend if pf0ow02 > 500 when loaded,
//                  & increased # of yis's searched for is grp
//                  literals from 200 to PFWLIMIT, in pf0o200.
//                  Was not displaying lits for last is grps.
//                    Increased rows searched in working stor
//                  for 'sum' level displ from 200 to PFWLIMIT,
//                  in pf0o310.  Was not displaying anything
//                  below gross margin for sums w/ > 200 yis's.
//  9-02-92   WES     Added initialization of attribute descr.
//                  to 'NO DESC' in PF0O210.
//  4-15-94   MJK   changes for new attributes.
//  3-01-96  MBUHIT Regen for GCOA changes to YICTBL.
// 11-19-97  mleabo Re-gen for table changes ysetbl, ysftbl.
// *********************
Program PF0O type textUIProgram //VAGen Info - main text program
  {
  includeReferencedFunctions = yes, allowUnqualifiedItemReferences = yes, 
  throwNrfEofExceptions = yes, handleHardIOErrors = no, V60ExceptionCompatibility = yes, 
  I4GLItemsNullable = no, textLiteralDefaultIsString = no, localSQLScope = yes, 
  msgTablePrefix = "PF00", inputRecord = COMMAREA, segmented = yes
  }

  // Data Declarations
  COMMAREA COMMAREA ; // record
  ERRSQLCA ERRSQLCA; // record
  PF0OW01 PF0OW01; // record
  PF0OW02 PF0OW02; // record
  PF1REC PF1REC; // record
  PF2REC PF2REC; // record
  PFAREC PFAREC; // record
  PFBREC PFBREC; // record
  PFCREC PFCREC; // record
  PFDREC PFDREC; // record
  PFEREC PFEREC; // record
  PFGREC PFGREC; // record
  PFWREC PFWREC; // record
  SM1REC SM1REC; // record
  SQLCA SQLCA; // record
  SY1REC SY1REC; // record
  SYCREC SYCREC; // record
  TA1REC TA1REC; // record
  YSMREC YSMREC; // record

  // VAGen Info - items needed for migration
  VAGen_EZESYS char(8);
  VAGen_EZEREPLY num(1);
  VAGen_EZE_WAIT_TIME bin(9,2);
  VAGen_EZE_ITEMLEN int;

  // Use Declarations
  use XATTBL {deleteAfterUse = yes}; // table
  use XAUTBL {deleteAfterUse = yes}; // table
  use XBTTBL {deleteAfterUse = yes}; // table
  use XCNTBL {deleteAfterUse = yes}; // table
  use XDRTBL {deleteAfterUse = yes}; // table
  use XDVTBL {deleteAfterUse = yes}; // table
  use XFCTBL {deleteAfterUse = yes}; // table
  use XFMTBL {deleteAfterUse = yes}; // table
  use XGATBL {deleteAfterUse = yes}; // table
  use XGPTBL {deleteAfterUse = yes}; // table
  use XGSTBL {deleteAfterUse = yes}; // table
  use XLCTBL {deleteAfterUse = yes}; // table
  use XMCTBL {deleteAfterUse = yes}; // table
  use XOBTBL {deleteAfterUse = yes}; // table
  use XPCTBL {deleteAfterUse = yes}; // table
  use XPGTBL {deleteAfterUse = yes}; // table
  use XPLTBL {deleteAfterUse = yes}; // table
  use XPRTBL {deleteAfterUse = yes}; // table
  use XQATBL {deleteAfterUse = yes}; // table
  use XRDTBL {deleteAfterUse = yes}; // table
  use XRYTBL {deleteAfterUse = yes}; // table
  use XSPTBL {deleteAfterUse = yes}; // table
  use XSUTBL {deleteAfterUse = yes}; // table
  use XWHTBL {deleteAfterUse = yes}; // table
  use YFATBL {deleteAfterUse = yes}; // table
  use YFETBL {deleteAfterUse = yes}; // table
  use YFFTBL {deleteAfterUse = yes}; // table
  use YFGTBL {deleteAfterUse = yes}; // table
  use YFTTBL {deleteAfterUse = yes}; // table
  use YGRTBL {deleteAfterUse = yes}; // table
  use YICTBL {deleteAfterUse = yes}; // table
  use YISTBL {deleteAfterUse = yes}; // table
  use YMATBL {deleteAfterUse = yes}; // table
  use YMBTBL {deleteAfterUse = yes}; // table
  use YMCTBL {deleteAfterUse = yes}; // table
  use YPDTBL {deleteAfterUse = yes}; // table
  use YSCTBL {deleteAfterUse = yes}; // table
  use YSETBL {deleteAfterUse = yes}; // table
  use YSFTBL {deleteAfterUse = yes}; // table
  use YSYTBL {deleteAfterUse = yes}; // table
  use YTYTBL {deleteAfterUse = yes}; // table
  use PF0OM.PF0OM001,  // forms
      PF0OM.PF0OM002
   {
    pfKeyEquate = no
  };

  function main()
    // VAGen Info - initialization needed for migration
    VAGen_EZESYS = VGLib.getVAGSysType();
    PF0O000: PF0O000();
  end // end main
end // end PF0O

// application mainline
Function PF0O000()
   /* ******************************************************/
   /* *    pf0o mainline logic                            **/
   /* ******************************************************/

  PF0O001(); /* application initialization routine*/

  while (PFWREC.PFWEOAF == "N") /* while application active,*/
    PF0O100(); /* converse display screens*/
  end

  XPPF002();
  COMMAREA.CAFROMAP = "PF0O";
  COMMAREA.CATOAP = "PF0A";
  XSEXIT();
end // end PF0O000

// initialization process
Function PF0O001()
   /* ****************************************************/
   /* *   this process will use information passed by   **/
   /* *   pf0b to access profitablity db2 tables for    **/
   /* *   initializing a format 5 summary view. the     **/
   /* *   process will access the summary attribute     **/
   /* *   table(vsumat01) and the i/s group table       **/
   /* *   (visgrp01). the information provided by these **/
   /* *   tables will be used to setup the display      **/
   /* *   screens to used throughout the rest of the    **/
   /* *   application.                                  **/
   /* ****************************************************/

  XSENTRY(); /* check user security*/

  XSSEGTR();

  set PF0OM001 initial; /* initialize maps*/
  set PF0OM002 initial;

  set PF0OW01 empty; /* initialize w/s records*/

  PFWREC.PFWERRF = "N"; /* initialize flags*/
  PFWREC.PFWEOAF = "N";

  PF0OM001.XXXCURDT = VGVar.currentShortGregorianDate; /* move current date to maps*/
  PF0OM002.XXXCURDT = VGVar.currentShortGregorianDate;

  PF1REC.PF1PASS = COMMAREA.CAUSERA; /* move passed info. to w/s*/
                                          /* record*/
  COMMAREA.CAUSERA = " "; /* clear the commarea*/

  set PFEREC empty;
  set SQLCA empty;

  if (PF1REC.PFESUMNM == " ") /* <=== if no summary name passed*/
    COMMAREA.CAFROMAP = "PF0O"; /* to Profit. Menu*/
    COMMAREA.CATOAP = "PF0A";
    XSEXIT(); /* <=== Transfer to PF0A.*/
    PF0OM001.VAGen_EZEMSG = COMMAREA.CAMSG;
    PFWREC.PFWERRF = "Y";
  end

  PFEREC.PFESUMNM = PF1REC.PFESUMNM; /* move summary name to db2 key*/

  call "IO2770" ("S ", SQLCA, PFEREC) {isNoRefresh = yes, isExternal = yes}; /* access vsumat01 table*/

  if (SQLCA.VAGen_SQLCODE == +0) /* if summary found continue with the process*/
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
    TA1REC.TA1TBLVU = "VSUMAT01";
    TA1REC.TA1TBLKE = PF1REC.PFESUMNM;
    TA1REC.TA1LOCAT[3] = "PF0O001";
    TA1REC.TA1LOCAT[4] = "IO2770";
    XPPF010();
  end

  PF0OM001.PF0OMNAM = PFEREC.PFESUMNM; /* move summary name to screen*/
  PF0OM002.PF0OMNAM = PFEREC.PFESUMNM;
  PFWREC.PFWCDATE = PFEREC.PFECRTDT;
                                   /* move date created to conversion*/
  PFWREC.PFWMONTH = PFWREC.PFWCMO; /* area and reformat date*/
  PFWREC.PFWDAY = PFWREC.PFWCDA;
  PFWREC.PFWYEAR = PFWREC.PFWCYR;
  PF0OM001.PF0OMDTC = PFWREC.PFWDATE;
                                   /* move reformatted date to maps*/
  PF0OM002.PF0OMDTC = PFWREC.PFWDATE;
  PF0OM001.PF0OMBMM = PFEREC.PFABSPRM; /* move base per. mo. to maps*/
  PF0OM002.PF0OMBMM = PFEREC.PFABSPRM;
  PF0OM001.PF0OMCYY = PFEREC.PFABSPRY; /* move base per. yr. to maps*/
  PF0OM002.PF0OMCYY = PFEREC.PFABSPRY;
  PF0OM001.PF0OMFMT = PFEREC.PFCREF; /* move format # to maps*/
  PF0OM002.PF0OMFMT = PFEREC.PFCREF;
  PF0OM001.PF0OMISG = PFEREC.PFBREF; /* move i/s ref. # to maps*/
  PF0OM002.PF0OMISG = PFEREC.PFBREF;
  PF0OM001.PF0OMATT = PFEREC.PFDREF; /* move rpt. attr. # to maps*/
  PF0OM002.PF0OMATT = PFEREC.PFDREF;

  set PFAREC empty;
  set SQLCA empty;

  call "IO2670" ("S ", SQLCA, PFAREC) {isNoRefresh = yes, isExternal = yes}; /* access vpfctl01 table*/

  if (SQLCA.VAGen_SQLCODE == +0) /* if control rec. found continue with*/
                                   /* the process*/
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
    TA1REC.TA1TBLVU = "VPFCTL01";
    TA1REC.TA1TBLKE = PF1REC.PFESUMNM;
    TA1REC.TA1LOCAT[3] = "PF0O001";
    TA1REC.TA1LOCAT[4] = "IO2670";
    XPPF010();
  end

  if (PFAREC.PFASTBLF == "Y")
                                   /* if the summary file is locked due to*/
                                   /* a*/
    PFWREC.PFWERRF = "Y"; /* db2 batch load, send user a message*/
    converseLib.validationFailed(223);
  end

  PF0OW01.PF0OWKY1 = "18:"; /* setup pf key literals for*/
                                   /* 'sum,det,exp'*/
  PF0OW01.PF0OWKY2 = "19:";

  if (PF1REC.PF1DISP == "SUM")
                                   /* pf0b will pass the starting view type*/
     /* (sum,det,exp). move appropriate title heading to maps.*/
    PF0OM001.PF0OMLIT = "SUMMARY FILE SUMMARY VIEW";
    PF0OM002.PF0OMLIT = "SUMMARY FILE SUMMARY VIEW";
    PF0OW01.PF0OWDP1 = "DET"; /* move literals to pf keys*/
    PF0OW01.PF0OWDP2 = "EXP";
  else
    if (PF1REC.PF1DISP == "DET")
      PF0OM001.PF0OMLIT = "SUMMARY FILE DETAIL VIEW";
      PF0OM002.PF0OMLIT = "SUMMARY FILE DETAIL VIEW";
      PF0OW01.PF0OWDP1 = "SUM"; /* move literals to pf keys*/
      PF0OW01.PF0OWDP2 = "EXP";
    else
      if (PF1REC.PF1DISP == "EXP")
        PF0OM001.PF0OMLIT = "SUMMARY FILE EXPLODED VIEW";
        PF0OM002.PF0OMLIT = "SUMMARY FILE EXPLODED VIEW";
        PF0OW01.PF0OWDP1 = "SUM"; /* move literals to pf keys*/
        PF0OW01.PF0OWDP2 = "DET";
      end
    end
  end

  set PFDREC empty;
  set SQLCA empty;

  PFDREC.PFDREF = PFEREC.PFDREF; /* move rept. attr. ref # to db2 key*/

  call "IO2740" ("S ", SQLCA, PFDREC) {isNoRefresh = yes, isExternal = yes}; /* access vrptat01 table*/

  if (SQLCA.VAGen_SQLCODE == +0) /* if i/s group # found continue with the process*/
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
    TA1REC.TA1TBLVU = "VRPTAT01";
    PF0OW01.PF0OWABK = PFEREC.PFBREF;
    TA1REC.TA1TBLKE = PF0OW01.PF0OWAB2;
    TA1REC.TA1LOCAT[3] = "PF0O001";
    TA1REC.TA1LOCAT[4] = "IO2740";
    XPPF010();
  end

  set PFCREC empty;
  set SQLCA empty;

  PFCREC.PFCREF = PFEREC.PFCREF; /* move summary fmt # to db2 key*/

  call "IO2730" ("S ", SQLCA, PFCREC) {isNoRefresh = yes, isExternal = yes}; /* access vrptfm01 table*/

  if (SQLCA.VAGen_SQLCODE == +0) /* if format # found continue with the process*/
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
    TA1REC.TA1TBLVU = "VRPTFM01";
    PF0OW01.PF0OWABK = PFEREC.PFCREF;
    TA1REC.TA1TBLKE = PF0OW01.PF0OWAB2;
    TA1REC.TA1LOCAT[3] = "PF0O001";
    TA1REC.TA1LOCAT[4] = "IO2730";
    XPPF010();
  end

  if (PFCREC.YFTCD in YFTTBL.YFTCD) /* move finc. transaction type to maps*/
    PF0OM001.PF0OMYFT = YFTTBL.YFTDESC[sysVar.arrayIndex];
    PF0OM002.PF0OMYFT = YFTTBL.YFTDESC[sysVar.arrayIndex];
  else
    TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
    TA1REC.TA1TBLVU = "YFTTBL  ";
    PF0OW01.PF0OWABK = PFEREC.PFCREF;
    TA1REC.TA1TBLKE = PF0OW01.PF0OWAB2;
    TA1REC.TA1LOCAT[3] = "PF0O001";
    TA1REC.TA1LOCAT[4] = "******";
    XPPF010();
  end

  PF0OW01.PF0OWTP1 = PFCREC.YTPCD[1]; /* move dt/tp codes to w/s*/
  PF0OW01.PF0OWDT1 = PFCREC.YPDCD[1];
  PF0OW01.PF0OWF1 = " ";
  PF0OW01.PF0OWH1 = PF0OW01.PF0OWCL1;
                                   /* string dt/tp literals for maps*/

  PF0OW01.PF0OWTP1 = PFCREC.YTPCD[2]; /* move dt/tp codes to w/s*/
  PF0OW01.PF0OWDT1 = PFCREC.YPDCD[2];
  PF0OW01.PF0OWF1 = " ";
  PF0OW01.PF0OWH2 = PF0OW01.PF0OWCL1;

  PF0OW01.PF0OWTP1 = PFCREC.YTPCD[3]; /* move dt/tp codes to w/s*/
  PF0OW01.PF0OWDT1 = PFCREC.YPDCD[3];
  PF0OW01.PF0OWF1 = " ";
  PF0OW01.PF0OWH3 = PF0OW01.PF0OWCL1;

  PF0OW01.PF0OWTP1 = PFCREC.YTPCD[4]; /* move dt/tp codes to w/s*/
  PF0OW01.PF0OWDT1 = PFCREC.YPDCD[4];
  PF0OW01.PF0OWF1 = " ";
  PF0OW01.PF0OWH4 = PF0OW01.PF0OWCL1;

  PF0OW01.PF0OWTP1 = PFCREC.YTPCD[5]; /* move dt/tp codes to w/s*/
  PF0OW01.PF0OWDT1 = PFCREC.YPDCD[5];
  PF0OW01.PF0OWF1 = " ";
  PF0OW01.PF0OWH5 = PF0OW01.PF0OWCL1;

  PF0OW01.PF0OWTP1 = PFCREC.YTPCD[6]; /* move dt/tp codes to w/s*/
  PF0OW01.PF0OWDT1 = PFCREC.YPDCD[6];
  PF0OW01.PF0OWF1 = " ";
  PF0OW01.PF0OWH6 = PF0OW01.PF0OWCL1;

  PF0OW01.PF0OWTP1 = PFCREC.YTPCD[13]; /* move dt/tp codes to w/s*/
  PF0OW01.PF0OWDT1 = PFCREC.YPDCD[13];
  PF0OW01.PF0OWF1 = " ";
  PF0OW01.PF0OWH7 = PF0OW01.PF0OWCL1;

  PF0OW01.PF0OWTP1 = PFCREC.YTPCD[7]; /* move dt/tp codes to w/s*/
  PF0OW01.PF0OWDT1 = PFCREC.YPDCD[7];
  PF0OW01.PF0OWF1 = " ";
  PF0OW01.PF0OWH9 = PF0OW01.PF0OWCL1;

  PF0OW01.PF0OWTP1 = PFCREC.YTPCD[8]; /* move dt/tp codes to w/s*/
  PF0OW01.PF0OWDT1 = PFCREC.YPDCD[8];
  PF0OW01.PF0OWF1 = " ";
  PF0OW01.PF0OWH10 = PF0OW01.PF0OWCL1;

  PF0OW01.PF0OWTP1 = PFCREC.YTPCD[9]; /* move dt/tp codes to w/s*/
  PF0OW01.PF0OWDT1 = PFCREC.YPDCD[9];
  PF0OW01.PF0OWF1 = " ";
  PF0OW01.PF0OWH11 = PF0OW01.PF0OWCL1;

  PF0OW01.PF0OWTP1 = PFCREC.YTPCD[10]; /* move dt/tp codes to w/s*/
  PF0OW01.PF0OWDT1 = PFCREC.YPDCD[10];
  PF0OW01.PF0OWF1 = " ";
  PF0OW01.PF0OWH12 = PF0OW01.PF0OWCL1;

  PF0OW01.PF0OWTP1 = PFCREC.YTPCD[11]; /* move dt/tp codes to w/s*/
  PF0OW01.PF0OWDT1 = PFCREC.YPDCD[11];
  PF0OW01.PF0OWF1 = " ";
  PF0OW01.PF0OWH13 = PF0OW01.PF0OWCL1;

  PF0OW01.PF0OWTP1 = PFCREC.YTPCD[12]; /* move dt/tp codes to w/s*/
  PF0OW01.PF0OWDT1 = PFCREC.YPDCD[12];
  PF0OW01.PF0OWF1 = " ";
  PF0OW01.PF0OWH14 = PF0OW01.PF0OWCL1;

  PF0OW01.PF0OWTP1 = PFCREC.YTPCD[13]; /* move dt/tp codes to w/s*/
  PF0OW01.PF0OWDT1 = PFCREC.YPDCD[13];
  PF0OW01.PF0OWF1 = " ";
  PF0OW01.PF0OWH15 = PF0OW01.PF0OWCL1;

  PF0OW01.PF0OWF21 = "--"; /* move spacing characters for literals*/
  PF0OW01.PF0OWF22 = "---";
  PF0OW01.PF0OWF23 = "---";
  PF0OW01.PF0OWF24 = "---";
  PF0OW01.PF0OWF25 = "---";
  PF0OW01.PF0OWF26 = "---";
  PF0OW01.PF0OWF27 = "---";
  PF0OW01.PF0OWF28 = "--";
  PF0OW01.PF0OWF29 = "---";
  PF0OW01.PF0OWF30 = "---";
  PF0OW01.PF0OWF31 = "---";
  PF0OW01.PF0OWF32 = "---";
  PF0OW01.PF0OWF33 = "---";
  PF0OW01.PF0OWF34 = "---";
  PF0OM001.PF0OMHDR = PF0OW01.PF0OWHD1;
  PF0OM002.PF0OMHDR = PF0OW01.PF0OWHD2;

  PF0OW01.PF0OWSTL = PF1REC.PF1STLVL; /* move passed starting inquiry*/
  PF0OW01.PF0OWSTS = PF1REC.PF1STSEQ; /* to hold db2 keys*/

  PFWREC.PFWSUB1 = 1; /* initialize subscript*/

  PF0O200(); /* routine to access summary file, load to w/s table*/

  PF0OW01.PF0OWDSP = PF1REC.PF1DISP; /* save display type*/

  PFWREC.PFWSUB1 = 1; /* initialize subscripts*/
  PFWREC.PFWSUB2 = 1;

  PF0O300(); /* determine display type*/

  PFWREC.PFWERRF = "N";

  PF0OW01.PF0OWLEF = "Y"; /* set map switch to display left side*/
  PF0OW01.PF0OWRIG = "N";
end // end PF0O001

// main converse logic loop
Function PF0O100()
   /* ****************************************************/
   /* *  this process will determine whether the left   **/
   /* *  or right display map is to be conversed and    **/
   /* *  will perform the appropriate converse routine. **/
   /* *  after conversing, the routine will check pf    **/
   /* *  keys for the next function to process.         **/
   /* ****************************************************/

  if (PF0OW01.PF0OWLEF == "Y") /* converse left side map*/
    PF0OM001.PF0OMPFK = PF0OW01.PF0OWPFK; /* move pf18,pf19 keys to map*/
    PF0O120();
    PF0OW01.PF0OWPFK = PF0OM001.PF0OMPFK; /* store pf18,pf19 values*/
  end

  if (PF0OW01.PF0OWRIG == "Y") /* converse right side map*/
    PF0OM002.PF0OMPFK = PF0OW01.PF0OWPFK; /* move pf18,pf19 keys to map*/
    PF0O130();
    PF0OW01.PF0OWPFK = PF0OM002.PF0OMPFK; /* store pf18,pf19 values*/
  end

  PF0O110(); /* check pf keys*/
end // end PF0O100

// check pf keys
Function PF0O110()
   /* *****************************************************/
   /* *  this process will check the pf keys entered by  **/
   /* *  the user and will take the appropriate course   **/
   /* *  of action.                                      **/
   /* *****************************************************/

  if (converseVar.eventKey is pf3) /* return to 'pf0b' application*/
    PF1REC.PFDCDVAL[1] = PF0OM001.PF0OMAVD[1];
    PF1REC.PFDCDVAL[2] = PF0OM001.PF0OMAVD[2];
    PF1REC.PFDCDVAL[3] = PF0OM001.PF0OMAVD[3];
    PF1REC.PFDCDVAL[4] = PF0OM001.PF0OMAVD[4];
    PF1REC.PFDCDVAL[5] = PF0OM001.PF0OMAVD[5];
    PF1REC.PFDCDVAL[6] = PF0OM001.PF0OMAVD[6];
    PF1REC.PFDCDVAL[7] = PF0OM001.PF0OMAVD[7];
    COMMAREA.CAUSERA = PF1REC.PF1PASS;
    COMMAREA.CATOAP = "PF0B";
    XSEXIT();
    PFWREC.PFWMSG = COMMAREA.CAMSG; /* handle a bad pass*/
    PFWREC.PFWERRF = "Y";
    return;
  end

  set PFAREC empty;
  set SQLCA empty;

  call "IO2670" ("S ", SQLCA, PFAREC) {isNoRefresh = yes, isExternal = yes}; /* access vpfctl01 table*/

  if (SQLCA.VAGen_SQLCODE == +0) /* if control rec. found continue with*/
                                   /* the process*/
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
    TA1REC.TA1TBLVU = "VPFCTL01";
    TA1REC.TA1TBLKE = PF1REC.PFESUMNM;
    TA1REC.TA1LOCAT[3] = "PF0O110";
    TA1REC.TA1LOCAT[4] = "IO2670";
    XPPF010();
  end

  if (PFAREC.PFASTBLF == "Y") /* if the summary file is locked due to an*/
    PFWREC.PFWERRF = "Y"; /* db2 batch load, send user a message*/
    converseLib.validationFailed(223);
    return;
  end

  if (converseVar.eventKey is pf5) /* move up a level*/
    PF0OW01.PF0OWSTL = PF0OW01.PF0OWSTL - 1;
    if (PF0OWSTL < 0)
      PFWREC.PFWERRF = "Y";
      converseLib.validationFailed(218);
      return;
    end
    PF0O260(); /* access vsumry01 table*/
    if (SQLCA.VAGen_SQLCODE == +100)
                                   /* if there are no more levels to go up,*/
      PFWREC.PFWERRF = "Y"; /* send user a message*/
      converseLib.validationFailed(218);
      PF0OW01.PF0OWSTL = PF0OW01.PF0OWSTL + 1; /* restore viewing level*/
      return;
    end
    PF0O200();
    PFWSUB1 = 1;
    PF0O300(); /* move w/s items to display screen*/
    return;
  end

  if (converseVar.eventKey is pf6) /* move down a level*/
    PF0OW01.PF0OWSTL = PF0OW01.PF0OWSTL + 1;
    if (PF0OWSTL > 8)
      PFWREC.PFWERRF = "Y";
      converseLib.validationFailed(219);
      return;
    end
    PF0O200(); /* access vsumry01 table*/
    if (SQLCA.VAGen_SQLCODE == +100) /* if the row was not found,*/
      PFWREC.PFWERRF = "Y"; /* send the user a message*/
      converseLib.validationFailed(251);
      PF0OW01.PF0OWSTL = PF0OW01.PF0OWSTL - 1; /* restore viewing level*/
      return;
    end
    PFWSUB1 = 1;
    PF0O300(); /* move w/s items to display screen*/
    return;
  end

  if (converseVar.eventKey is pf7 /* user can't scroll when a 'sum' is displayed*/
   && PF0OW01.PF0OWDSP == "SUM") 
    PFWREC.PFWERRF = "Y";
    converseLib.validationFailed(225);
    return;
  end

  if (converseVar.eventKey is pf7) /* scroll up within current summary*/
    if (PF0OW01.PF0OWDSP == "DET")
      PFWSUB1 = PFWREC.PFWSAVDX;
      PFWSUB1 = PFWSUB1 - 1;
      PF0O350();
      return;
    end
    if (PF0OW01.PF0OWDSP == "EXP")
      PFWSUB1 = PFWREC.PFWSAVDX;
      PFWSUB1 = PFWSUB1 - 1;
      PF0O360();
      return;
    end
  end

  if (converseVar.eventKey is pf8 /* user can't scroll when a 'sum' is displayed*/
   && PF0OW01.PF0OWDSP == "SUM") 
    PFWREC.PFWERRF = "Y";
    converseLib.validationFailed(225);
    return;
  end

  if (converseVar.eventKey is pf8) /* scroll down within current summary*/
    if (PFWNXTDX > PFWLIMIT)
                                   /* if user can't scroll forward anymore,*/
      PFWREC.PFWERRF = "Y"; /* send a message*/
      converseLib.validationFailed(032);
      return;
    end
    move PFWNXTDX to PFWSUB1 withV60Compat; /* set starting display subscript*/
    PF0O300();
    return;

  end

  if (converseVar.eventKey is pf10) /* shift to left-side map*/
    if (PF0OW01.PF0OWLEF == "N")
      PF0OW01.PF0OWLEF = "Y"; /* set map display indicator to left*/
      PF0OW01.PF0OWRIG = "N";
      return;
    else
      PFWREC.PFWERRF = "Y"; /* can't shift left if already on left*/
                                   /* map*/
      converseLib.validationFailed(198);
      return;
    end
  end

  if (converseVar.eventKey is pf11) /* shift to right-side map*/
    if (PF0OW01.PF0OWRIG == "N")
      PF0OW01.PF0OWRIG = "Y"; /* set map display indicator to right*/
      PF0OW01.PF0OWLEF = "N";
      return;
    else
      PFWREC.PFWERRF = "Y"; /* can't shift right if already on right map*/
      converseLib.validationFailed(192);
      return;
    end
  end

  if (converseVar.eventKey is pf18) /* user requested a change in display type*/
    PF0OW01.PF0OWHDP = PF0OW01.PF0OWDP1;
                                   /* switch pf key display type*/
    PF0OW01.PF0OWDP1 = PF0OW01.PF0OWDSP; /* with current display type*/
    PF0OW01.PF0OWDSP = PF0OW01.PF0OWHDP;
                                   /* and display maps from same*/
    PF1REC.PF1DISP = PF0OW01.PF0OWDSP;
    if (PF0OW01.PF0OWDSP == "SUM")
       /* (sum,det,exp). move appropriate title heading to maps.*/
      PF0OM001.PF0OMLIT = "SUMMARY FILE SUMMARY VIEW";
      PF0OM002.PF0OMLIT = "SUMMARY FILE SUMMARY VIEW";
    else
      if (PF0OW01.PF0OWDSP == "DET")
        PFWREC.PFWSUB1 = PFWREC.PFWSAVDX;
        PF0OM001.PF0OMLIT = "SUMMARY FILE DETAIL VIEW";
        PF0OM002.PF0OMLIT = "SUMMARY FILE DETAIL VIEW";
      else
        if (PF0OW01.PF0OWDSP == "EXP")
          PFWREC.PFWSUB1 = PFWREC.PFWSAVDX;
          PF0OM001.PF0OMLIT = "SUMMARY FILE EXPLODED VIEW";
          PF0OM002.PF0OMLIT = "SUMMARY FILE EXPLODED VIEW";
        end
      end
    end
    if (PF0OW01.PF0OWHDP == "SUM"
     || PF0OW01.PF0OWDSP == "SUM")
      PFWREC.PFWSAVDX = 1;
      PFWREC.PFWSUB1 = 1;
    end
    PF0O300();
    return;
  end

  if (converseVar.eventKey is pf19) /* user requested a change in display type*/
    PF0OW01.PF0OWHDP = PF0OW01.PF0OWDP2;
                                   /* switch pf key display type*/
    PF0OW01.PF0OWDP2 = PF0OW01.PF0OWDSP; /* with current display type*/
    PF0OW01.PF0OWDSP = PF0OW01.PF0OWHDP;
                                   /* and display maps from same*/
    PF1REC.PF1DISP = PF0OW01.PF0OWDSP;
    if (PF0OW01.PF0OWDSP == "SUM")
       /* (sum,det,exp). move appropriate title heading to maps.*/
      PF0OM001.PF0OMLIT = "SUMMARY FILE SUMMARY VIEW";
      PF0OM002.PF0OMLIT = "SUMMARY FILE SUMMARY VIEW";
    else
      if (PF0OW01.PF0OWDSP == "DET")
        PFWREC.PFWSUB1 = PFWREC.PFWSAVDX;
        PF0OM001.PF0OMLIT = "SUMMARY FILE DETAIL VIEW";
        PF0OM002.PF0OMLIT = "SUMMARY FILE DETAIL VIEW";
      else
        if (PF0OW01.PF0OWDSP == "EXP")
          PFWREC.PFWSUB1 = PFWREC.PFWSAVDX;
          PF0OM001.PF0OMLIT = "SUMMARY FILE EXPLODED VIEW";
          PF0OM002.PF0OMLIT = "SUMMARY FILE EXPLODED VIEW";
        end
      end
    end
    if (PF0OW01.PF0OWHDP == "SUM"
     || PF0OW01.PF0OWDSP == "SUM")
      PFWREC.PFWSAVDX = 1;
      PFWREC.PFWSUB1 = 1;
    end
    PF0O300();
    return;
  end

  if (converseVar.eventKey is pf20) /* move up within a level*/
    if (PF0OWSTS == 1) /* no more summaries within this level*/
      PFWREC.PFWERRF = "Y";
      converseLib.validationFailed(220);
      return;
    end
    PF0O260(); /* access vsumry01 table*/
    if (SQLCA.VAGen_SQLCODE == +100) /* if the row was not found,*/
      PFWREC.PFWERRF = "Y"; /* send the user a message*/
      converseLib.validationFailed(220);
      return;
    end
    PF0OW01.PF0OWFL2 = PF0OW01.PF0OWFL1;
    PF0O200(); /* read vsumry01/store rows in w/s area*/
    PF0O270(); /* see if hierarchy changed*/
    PFWSUB1 = 1;
    PF0O300(); /* move w/s items to display screen*/
    return;
  end

  if (converseVar.eventKey is pf21) /* move down within a level*/
    PF0OW01.PF0OWSTS = PF0OW01.PF0OWSTS + 1;
    PF0OW01.PF0OWFL2 = PF0OW01.PF0OWFL1;
    PF0O200(); /* access vsumry01 table*/
    if (SQLCA.VAGen_SQLCODE == +100) /* if the row was not found,*/
      PFWREC.PFWERRF = "Y"; /* send the user a message*/
      converseLib.validationFailed(220);
      PF0OW01.PF0OWSTS = PF0OW01.PF0OWSTS - 1;
      return;
    end
    PF0O270(); /* see if hierarchy changed*/
    PFWSUB1 = 1;
    PF0O300(); /* move w/s items to display screen*/

    return;
  end

  converseLib.validationFailed(001); /* invalid key was entered*/
  PFWREC.PFWERRF = "Y";
end // end PF0O110

// converse left side map
Function PF0O120()
   /* ********************************************************/
   /* *  the sole function of this process is to converse   **/
   /* *  the left side of the summary displays.             **/
   /* ********************************************************/

  set PF0OM001.XXXCURDT cursor;

  converse PF0OM001 ;

end // end PF0O120

// converse right side map
Function PF0O130()
   /* ********************************************************/
   /* *  the sole function of this process is to converse   **/
   /* *  the right side of the summary displays.            **/
   /* ********************************************************/

  set PF0OM001.XXXCURDT cursor;

  converse PF0OM002 ;

end // end PF0O130

// access vsumry01 table
Function PF0O200()
   /* ***********************************************************/
   /* *  this process will access the vsumry01 table using     **/
   /* *  the summary name, summary level, and summary sequence **/
   /* *  number as db2 keys.*/
   /* ***********************************************************/

  set PFGREC empty;
  set SQLCA empty;
  PFGREC.PFESUMNM = PFEREC.PFESUMNM; /* move summary name to db2 key*/
  PFGREC.PFGSUMN = PFEREC.PFGSUMN; /* move summary # to db2 key*/
  PFGREC.PFGLVLNO = PF0OW01.PF0OWSTL; /* move level # to db2 key*/
  PFGREC.PFGLVLSQ = PF0OW01.PF0OWSTS; /* move level seq # to db2 key*/

  call "IO2920" ("S1", SQLCA, PFGREC) {isNoRefresh = yes, isExternal = yes}; /* open vsumry01 cursor*/

  if (SQLCA.VAGen_SQLCODE == +0) /* if cursor open ok, continue with the process*/
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
    TA1REC.TA1TBLVU = "VSUMRY01";
    TA1REC.TA1TBLKE = PF1REC.PFESUMNM;
    TA1REC.TA1LOCAT[3] = "PF0O200";
    TA1REC.TA1LOCAT[4] = "IO2920";
    XPPF010();
  end


  set PFGREC empty;
  set SQLCA empty;

  call "IO2920" ("N1", SQLCA, PFGREC) {isNoRefresh = yes, isExternal = yes}; /* access vsumry01 table*/

  if (SQLCA.VAGen_SQLCODE == +0) /* if cursor open ok, continue with the process*/
    PF0OW01.PF0OWSTS = PFGREC.PFGLVLSQ; /* save seq. #*/
    PF0OW01.PF0OWSTL = PFGREC.PFGLVLNO;
    PF0OW01.PF0OWCD1 = PFGREC.PFDCDVAL[1];
    PF0OW01.PF0OWCD2 = PFGREC.PFDCDVAL[2];
    PF0OW01.PF0OWCD3 = PFGREC.PFDCDVAL[3];
    PF0OW01.PF0OWCD4 = PFGREC.PFDCDVAL[4];
    PF0OW01.PF0OWCD5 = PFGREC.PFDCDVAL[5];
    PF0OW01.PF0OWCD6 = PFGREC.PFDCDVAL[6];
    PF0OW01.PF0OWCD7 = PFGREC.PFDCDVAL[7];
  else
    if (SQLCA.VAGen_SQLCODE == +100)
      return;
    else
      TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
      TA1REC.TA1TBLVU = "VSUMRY01";
      TA1REC.TA1TBLKE = PF1REC.PFESUMNM;
      TA1REC.TA1LOCAT[3] = "PF0O200";
      TA1REC.TA1LOCAT[4] = "IO2920";
      XPPF010();
    end
  end


  PF0O210(); /* perform routine to get attribute literals*/


  set PF0OW02 empty;
  PFWSUB1 = 1;
  while (PFGREC.PFGLVLSQ == PF0OW01.PF0OWSTS
   && PFWSUB1 <= 500)

    PF0O220(); /* move summary rows to w/s area*/

    set SQLCA empty;
    set PFGREC empty;

    call "IO2920" ("N1", SQLCA, PFGREC) {isNoRefresh = yes, isExternal = yes}; /* get next vsumry01*/

    if (SQLCA.VAGen_SQLCODE == +0) /* if a row is found, continue with the process*/
       /* next sentence*/
    else
      if (SQLCA.VAGen_SQLCODE == +100) /* if a row isn't found, loop will terminate*/
        PFGREC.PFGLVLSQ = 9999; /* set condition to end loop*/
      else
        TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
        TA1REC.TA1TBLVU = "VSUMRY01";
        TA1REC.TA1TBLKE = PF1REC.PFESUMNM;
        TA1REC.TA1LOCAT[3] = "PF0O200";
        TA1REC.TA1LOCAT[4] = "IO2920";
        XPPF010();
      end
    end
    PFWSUB1 = PFWSUB1 + 1;
  end

  if (PFWSUB1 > 500)
    TA1REC.TA1TYPE = "APPL"; /* error type*/
    TA1REC.TA1FUNC = "RETN"; /* termination function*/
    TA1REC.TA1PGMNM = "PF0O"; /* program name*/
    TA1REC.TA1LOC = "PF0OW02 TBL OVERFLOW - PF0O200";
    SQLCA.SQLCAREC = " "; /* error information*/

    call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes}; /* error diagnostic routine*/

    COMMAREA.CAUSERA = " "; /* clear user commarea*/
    XSPF4(); /* master menu*/
    exit program; /* master menu failure*/
  end


  PFWREC.PFWLIMIT = PFWSUB1 - 1; /* set maximum index on w/s area*/


  PFWSUB1 = 1; /* initialize subscript*/
  while (PFWSUB1 <= PFWLIMIT)

    PF0O240(); /* perform routine get i/s group*/
                                   /* literals*/
    PFWSUB1 = PFWSUB1 + 1;
  end


  set PFGREC empty;
  set SQLCA empty;

  call "IO2920" ("C1", SQLCA, PFGREC) {isNoRefresh = yes, isExternal = yes}; /* close vsumry01 cursor*/

  if (SQLCA.VAGen_SQLCODE == +0) /* if cursor open ok, continue with the process*/
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
    TA1REC.TA1TBLVU = "VSUMRY01";
    TA1REC.TA1TBLKE = PF1REC.PFESUMNM;
    TA1REC.TA1LOCAT[3] = "PF0O200";
    TA1REC.TA1LOCAT[4] = "IO2920";
    XPPF010();
  end

end // end PF0O200

// determine attribute literals
Function PF0O210()
   /* ********************************************************/
   /* *  this process will determine the attribute field    **/
   /* *  literal for those attributes that are displayed    **/
   /* *  at the summary level to be viewed. the literal     **/
   /* *  be moved to the pf0om001 screen fields from the    **/
   /* *  passed attribute descriptions in pf1rec.           **/
   /* ********************************************************/

  PFWSUB2 = 1;

  while (PFWSUB2 < 8) /* clear literals on maps*/
    PF0OM001.PF0OMAVD[PFWSUB2] = " ";
    PF0OM002.PF0OMAVD[PFWSUB2] = " ";
    PFWSUB2 = PFWSUB2 + 1;
  end

  PF0OM001.PF0OMSTY = " "; /* clear product literal on maps*/
  PF0OM002.PF0OMSTY = " ";
  PF0OM001.PF0OMPRD = " ";
  PF0OM002.PF0OMPRD = " ";
  PF0OM001.PF0OMCLR = " ";
  PF0OM002.PF0OMCLR = " ";

  PF0OM001.PF0OMPLT = " ";
  PF0OM002.PF0OMPLT = " ";

  PFWSUB2 = 1;

  while (PFWSUB2 < 8) /* move rept. attr. literals to maps*/
    PF0OW01.PF0OWAV1 = PF1REC.PFISDESC[PFWSUB2];
    if (PF0OW01.PF0OWAV1 > " ")
      PF0OW01.PF0OWAV2 = " :";
    else
      PF0OW01.PF0OWAV2 = "  ";
    end
    PF0OM001.PF0OMACA[PFWSUB2] = PF0OW01.PF0OWAVA;
    PF0OM002.PF0OMACA[PFWSUB2] = PF0OW01.PF0OWAVA;
    PFWSUB2 = PFWSUB2 + 1;
  end


  if (PF1REC.PFISDESC[1] > " ") /* if any attributes below this one*/
    if (PFDREC.PFDVALFL[2] == "Y" /* have selected values, mark this*/
     || PFDREC.PFDVALFL[3] == "Y" /* attribute with a highlighted "p"*/
     || PFDREC.PFDVALFL[4] == "Y" /* to warn user of a partial summary.*/
     || PFDREC.PFDVALFL[5] == "Y" 
     || PFDREC.PFDVALFL[6] == "Y" 
     || PFDREC.PFDVALFL[7] == "Y" 
     || PFDREC.PFDVALFL[8] == "Y")
      PF0OM001.PF0OMIND[1] = "P";
      PF0OM002.PF0OMIND[1] = "P";
      set PF0OM001.PF0OMIND[1] bold;
      set PF0OM002.PF0OMIND[1] bold;
    else
      PF0OM001.PF0OMIND[1] = " ";
      PF0OM002.PF0OMIND[1] = " ";
      set PF0OM001.PF0OMIND[1] normal;
      set PF0OM002.PF0OMIND[1] normal;
    end
  end

  if (PF1REC.PFISDESC[2] > " ")
    if (PFDREC.PFDVALFL[3] == "Y"
     || PFDREC.PFDVALFL[4] == "Y"
     || PFDREC.PFDVALFL[5] == "Y"
     || PFDREC.PFDVALFL[6] == "Y"
     || PFDREC.PFDVALFL[7] == "Y"
     || PFDREC.PFDVALFL[8] == "Y")
      PF0OM001.PF0OMIND[2] = "P";
      PF0OM002.PF0OMIND[2] = "P";
      set PF0OM001.PF0OMIND[2] bold;
      set PF0OM002.PF0OMIND[2] bold;
    else
      PF0OM001.PF0OMIND[2] = " ";
      PF0OM002.PF0OMIND[2] = " ";
      set PF0OM001.PF0OMIND[2] normal;
      set PF0OM002.PF0OMIND[2] normal;
    end
  end

  if (PF1REC.PFISDESC[3] > " ")
    if (PFDREC.PFDVALFL[4] == "Y"
     || PFDREC.PFDVALFL[5] == "Y"
     || PFDREC.PFDVALFL[6] == "Y"
     || PFDREC.PFDVALFL[7] == "Y"
     || PFDREC.PFDVALFL[8] == "Y")
      PF0OM001.PF0OMIND[3] = "P";
      PF0OM002.PF0OMIND[3] = "P";
      set PF0OM001.PF0OMIND[3] bold;
      set PF0OM002.PF0OMIND[3] bold;
    else
      PF0OM001.PF0OMIND[3] = " ";
      PF0OM002.PF0OMIND[3] = " ";
      set PF0OM001.PF0OMIND[3] normal;
      set PF0OM002.PF0OMIND[3] normal;
    end
  end

  if (PF1REC.PFISDESC[4] > " ")
    if (PFDREC.PFDVALFL[5] == "Y"
     || PFDREC.PFDVALFL[6] == "Y"
     || PFDREC.PFDVALFL[7] == "Y"
     || PFDREC.PFDVALFL[8] == "Y")
      PF0OM001.PF0OMIND[4] = "P";
      PF0OM002.PF0OMIND[4] = "P";
      set PF0OM001.PF0OMIND[4] bold;
      set PF0OM002.PF0OMIND[4] bold;
    else
      PF0OM001.PF0OMIND[4] = " ";
      PF0OM002.PF0OMIND[4] = " ";
      set PF0OM001.PF0OMIND[4] normal;
      set PF0OM002.PF0OMIND[4] normal;
    end
  end

  if (PF1REC.PFISDESC[5] > " ")
    if (PFDREC.PFDVALFL[6] == "Y"
     || PFDREC.PFDVALFL[7] == "Y"
     || PFDREC.PFDVALFL[8] == "Y")
      PF0OM001.PF0OMIND[5] = "P";
      PF0OM002.PF0OMIND[5] = "P";
      set PF0OM001.PF0OMIND[5] bold;
      set PF0OM002.PF0OMIND[5] bold;
    else
      PF0OM001.PF0OMIND[5] = " ";
      PF0OM002.PF0OMIND[5] = " ";
      set PF0OM001.PF0OMIND[5] normal;
      set PF0OM002.PF0OMIND[5] normal;
    end
  end

  if (PF1REC.PFISDESC[6] > " ")
    if (PFDREC.PFDVALFL[7] == "Y"
     || PFDREC.PFDVALFL[8] == "Y")
      PF0OM001.PF0OMIND[6] = "P";
      PF0OM002.PF0OMIND[6] = "P";
      set PF0OM001.PF0OMIND[6] bold;
      set PF0OM002.PF0OMIND[6] bold;
    else
      PF0OM001.PF0OMIND[6] = " ";
      PF0OM002.PF0OMIND[6] = " ";
      set PF0OM001.PF0OMIND[6] normal;
      set PF0OM002.PF0OMIND[6] normal;
    end
  end

  if (PF1REC.PFISDESC[7] > " ")
    if (PFDREC.PFDVALFL[8] == "Y")
      PF0OM001.PF0OMIND[7] = "P";
      PF0OM002.PF0OMIND[7] = "P";
      set PF0OM001.PF0OMIND[7] bold;
      set PF0OM002.PF0OMIND[7] bold;
    else
      PF0OM001.PF0OMIND[7] = " ";
      PF0OM002.PF0OMIND[7] = " ";
      set PF0OM001.PF0OMIND[7] normal;
      set PF0OM002.PF0OMIND[7] normal;
    end
  end


  PF0OM001.PF0OMPLT = PF1REC.PFIDESC[8];
  PF0OM002.PF0OMPLT = PF1REC.PFIDESC[8];

  PFWREC.XGPCD = PFGREC.XGPCD;
  PFWREC.SY1STNBR = PFGREC.SY1STNBR;
  PFWREC.SY2CLRID = PFGREC.SY2CLRID;
  PFWREC.XDMCD = PFGREC.XDMCD;
  PFWREC.XQACD = PFGREC.XQACD;
  PFWREC.XLCCD = PFGREC.XLCCD;
  PFWREC.PFDCDVAL[1] = PFGREC.PFDCDVAL[1];
  PFWREC.PFDCDVAL[2] = PFGREC.PFDCDVAL[2];
  PFWREC.PFDCDVAL[3] = PFGREC.PFDCDVAL[3];
  PFWREC.PFDCDVAL[4] = PFGREC.PFDCDVAL[4];
  PFWREC.PFDCDVAL[5] = PFGREC.PFDCDVAL[5];
  PFWREC.PFDCDVAL[6] = PFGREC.PFDCDVAL[6];
  PFWREC.PFDCDVAL[7] = PFGREC.PFDCDVAL[7];

  PF1REC.PFDCDVAL[1] = PFGREC.PFDCDVAL[1];
  PF1REC.PFDCDVAL[2] = PFGREC.PFDCDVAL[2];
  PF1REC.PFDCDVAL[3] = PFGREC.PFDCDVAL[3];
  PF1REC.PFDCDVAL[4] = PFGREC.PFDCDVAL[4];
  PF1REC.PFDCDVAL[5] = PFGREC.PFDCDVAL[5];
  PF1REC.PFDCDVAL[6] = PFGREC.PFDCDVAL[6];
  PF1REC.PFDCDVAL[7] = PFGREC.PFDCDVAL[7];

  if (PFWREC.XGPCD > " ") /* move product attribute desc. to map*/
    PFWIDX = 8;
    PFWREC.PFWPRDAT = PFDREC.PFICD[8];
    XPPF020(); /* perform generic product routine to*/
                                   /* move product*/
    PF0OW01.XGPCD = PFWREC.XGPCD;
    PF0OW01.SY1STNBR = PFWREC.SY1STNBR;
    PF0OW01.SY2CLRID = PFWREC.SY2CLRID;
    PF0OW01.XDMCD = PFWREC.XDMCD;
    PF0OW01.XQACD = PFWREC.XQACD;
    PF0OW01.XLCCD = PFWREC.XLCCD;
    PF0OW01.PF0OWF9 = "/";
    PF0OW01.PF0OWF10 = "/";
    PF0OW01.PF0OWF11 = "/";
    PF0OW01.PF0OWF12 = "/";
    PF0OW01.PF0OWF13 = "/";
    PF0OM001.PF0OMSTY = PF0OW01.PF0OWSTY;
    PF0OM002.PF0OMSTY = PF0OW01.PF0OWSTY;
    PF0OM001.PF0OMPRD = PFWREC.PFWDESC[8];
    PF0OM002.PF0OMPRD = PFWREC.PFWDESC[8];
    PF0OM001.PF0OMCLR = PFWREC.SY2CLRAB;
    PF0OM002.PF0OMCLR = PFWREC.SY2CLRAB;
  end

  PFWREC.PFWIDX = 7; /* initialize index*/

  while (PFWIDX > 0)
    if (PFWREC.PFDCDVAL[PFWIDX] > " ")
                                   /* if an attribute has data, move desc.*/
      PFWREC.PFWDESC[PFWIDX] = "NO DESC        ";
      XPPF430(); /* perform edit routine to get code*/
                                   /* value literal*/
      PF0OW01.PF0OWAD1 = PFGREC.PFDCDVAL[PFWIDX];
      PF0OW01.PF0OWAD2 = PFWREC.PFWDESC[PFWIDX];
      PF0OM001.PF0OMAVD[PFWIDX] = PF0OW01.PF0OWAVD; /* description to map*/
      PF0OM002.PF0OMAVD[PFWIDX] = PF0OW01.PF0OWAVD; /* description to map*/
    end
    PFWIDX = PFWIDX - 1;
  end
end // end PF0O210

// load summary info. to w/s area
Function PF0O220()
   /* ************************************************************/
   /* *  this process will load the summary rows from vsumry01  **/
   /* *  table to a w/s area, pf0ow02. pf0o will then display   **/
   /* *  the information in pf0ow02 on screens. first, the      **/
   /* *  process will determine what type of display record     **/
   /* *  the current summary row is and find the literal that   **/
   /* *  is used to describe the row. then, the dollar or %     **/
   /* *  columns are then stored. the valid record types are:   **/
   /* *  record #      description                              **/
   /* *  --------   ----------------------                      **/
   /* *     1       summary level items                         **/
   /* *     2       special summary level items(i.e. dirsg&a)   **/
   /* *     3       i/s group total items                       **/
   /* *     4       i/s group items                             **/
   /* *     5       ungrouped i/s items                         **/
   /* ************************************************************/

  if (PFWSUB1 == 3) /* setup third w/s entry for spaces to display*/
    PF0OW02.PF0OWLIT[PFWSUB1] = " ";
    PF0OW02.PF0OWTYP[PFWSUB1] = "1";
    PF0OW02.PF0OWC1[PFWSUB1] = 0;
    PF0OW02.PF0OWC2[PFWSUB1] = 0;
    PF0OW02.PF0OWC3[PFWSUB1] = 0;
    PF0OW02.PF0OWC4[PFWSUB1] = 0;
    PF0OW02.PF0OWC5[PFWSUB1] = 0;
    PF0OW02.PF0OWC6[PFWSUB1] = 0;
    PF0OW02.PF0OWC7[PFWSUB1] = 0;
    PF0OW02.PF0OWC8[PFWSUB1] = 0;
    PF0OW02.PF0OWC9[PFWSUB1] = 0;
    PF0OW02.PF0OWC10[PFWSUB1] = 0;
    PFWSUB1 = PFWSUB1 + 1;
  end

  if (PFGREC.YISCD[2] == 0) /* this is a summary level item*/
    if (PFGREC.YTYCD == "34"
     || PFGREC.YTYCD == "38") /* if it's a special summary level*/
      PF0OW02.PF0OWTYP[PFWSUB1] = "2"; /* set record type to 2*/
    else
      PF0OW02.PF0OWTYP[PFWSUB1] = "1";
    end
    PF0OW02.PF0OWIND[PFWSUB1] = " ";
    if (PFGREC.YTYCD in YTYTBL.YTYCD) /* move in summary literal*/
      PF0OW02.PF0OWABV[PFWSUB1] = YTYTBL.YTYSDESC[sysVar.arrayIndex];
    end
    PF0O230(); /* perform routine to move columnar*/
                                   /* info.*/
    return;
  end

  if (PFGREC.YISCD[1] == 0 /* this is an i/s grouped total item*/
   && PFGREC.YISCD[2] > 0)
    PF0OW02.PF0OWTYP[PFWSUB1] = "3";
    PF0OW02.YISCD[PFWSUB1] = PFGREC.YISCD[2];
    PF0OW02.PF0OWIND[PFWSUB1] = "*";
    PF0O230(); /* move columnar info. to pf0kw02 w/s area*/
    return;
  end

  if (PFGREC.PFBISGRP > 0 /* this is a grouped item*/
   && PFGREC.YISCD[1] > 0)
    PF0OW02.PF0OWTYP[PFWSUB1] = "4"; /* set record type to 4*/
    PF0OW02.YISCD[PFWSUB1] = PFGREC.YISCD[1];
    PF0OW02.PF0OWIND[PFWSUB1] = "-";
    if (PFGREC.YISCD[1] in YISTBL.YISCD)
      PF0OW02.PF0OWABV[PFWSUB1] = YISTBL.YISABRV[sysVar.arrayIndex];
    end
    PF0O230(); /* perform routine to move columnar*/
                                   /* info.*/
    return;
  end

  if (PFGREC.PFBISGRP == 0) /* this is a ungrouped item*/
    PF0OW02.PF0OWTYP[PFWSUB1] = "5"; /* set record type to 5*/
    PF0OW02.PF0OWIND[PFWSUB1] = " ";
    if (PFGREC.YISCD[1] in YISTBL.YISCD)
      PF0OW02.PF0OWABV[PFWSUB1] = YISTBL.YISABRV[sysVar.arrayIndex];
    end
    PF0O230(); /* perform routine to move columnar*/
                                   /* info.*/
    return;
  end
end // end PF0O220

// move columnar data to w/s
Function PF0O230()
   /* *****************************************************/
   /* *  this process will move the thirteen columns of  **/
   /* *  unit/dollar/percentage information from pfgrec  **/
   /* *  to the pf0nw02 w/s area.                        **/
   /* *****************************************************/
  if (PFGREC.YTYCD == "72"
   || PFGREC.YTYCD == "73")
    PF0OW01.PF0OWNUM = PFGREC.PFGQTY[1];
    if (PF0OW01.PF0OWNUM >= +999500.00)
      PF0OW02.PF0OWC1[PFWSUB1] = +999.9;
    else
      if (PF0OW01.PF0OWNUM <= -99500.00)
        PF0OW02.PF0OWC1[PFWSUB1] = -99.9;
      else
        PF0OW02.PF0OWC1[PFWSUB1] = mathLib.round(PF0OW01.PF0OWNUM * .001, -mathLib.decimals(PF0OW02.PF0OWC1[PFWSUB1]));
      end
    end
    PF0OW01.PF0OWNUM = PFGREC.PFGQTY[2];
    if (PF0OW01.PF0OWNUM >= +999500.00)
      PF0OW02.PF0OWC2[PFWSUB1] = +999.9;
    else
      if (PF0OW01.PF0OWNUM <= -99500.00)
        PF0OW02.PF0OWC2[PFWSUB1] = -99.9;
      else
        PF0OW02.PF0OWC2[PFWSUB1] = mathLib.round(PF0OW01.PF0OWNUM * .001, -mathLib.decimals(PF0OW02.PF0OWC2[PFWSUB1]));
      end
    end
    PF0OW01.PF0OWNUM = PFGREC.PFGQTY[3];
    if (PF0OW01.PF0OWNUM >= +999500.00)
      PF0OW02.PF0OWC3[PFWSUB1] = +999.9;
    else
      if (PF0OW01.PF0OWNUM <= -99500.00)
        PF0OW02.PF0OWC3[PFWSUB1] = -99.9;
      else
        PF0OW02.PF0OWC3[PFWSUB1] = mathLib.round(PF0OW01.PF0OWNUM * .001, -mathLib.decimals(PF0OW02.PF0OWC3[PFWSUB1]));
      end
    end
    PF0OW01.PF0OWNUM = PFGREC.PFGQTY[4];
    if (PF0OW01.PF0OWNUM >= +999500.00)
      PF0OW02.PF0OWC4[PFWSUB1] = +999.9;
    else
      if (PF0OW01.PF0OWNUM <= -99500.00)
        PF0OW02.PF0OWC4[PFWSUB1] = -99.9;
      else
        PF0OW02.PF0OWC4[PFWSUB1] = mathLib.round(PF0OW01.PF0OWNUM * .001, -mathLib.decimals(PF0OW02.PF0OWC4[PFWSUB1]));
      end
    end
    PF0OW01.PF0OWNUM = PFGREC.PFGQTY[5];
    if (PF0OW01.PF0OWNUM >= +999500.00)
      PF0OW02.PF0OWC5[PFWSUB1] = +999.9;
    else
      if (PF0OW01.PF0OWNUM <= -99500.00)
        PF0OW02.PF0OWC5[PFWSUB1] = -99.9;
      else
        PF0OW02.PF0OWC5[PFWSUB1] = mathLib.round(PF0OW01.PF0OWNUM * .001, -mathLib.decimals(PF0OW02.PF0OWC5[PFWSUB1]));
      end
    end
    PF0OW01.PF0OWNUM = PFGREC.PFGQTY[6];
    if (PF0OW01.PF0OWNUM >= +999500.00)
      PF0OW02.PF0OWC6[PFWSUB1] = +999.9;
    else
      if (PF0OW01.PF0OWNUM <= -99500.00)
        PF0OW02.PF0OWC6[PFWSUB1] = -99.9;
      else
        PF0OW02.PF0OWC6[PFWSUB1] = mathLib.round(PF0OW01.PF0OWNUM * .001, -mathLib.decimals(PF0OW02.PF0OWC6[PFWSUB1]));
      end
    end
    PF0OW01.PF0OWNUM = PFGREC.PFGQTY[7];
    if (PF0OW01.PF0OWNUM >= +999500.00)
      PF0OW02.PF0OWC7[PFWSUB1] = +999.9;
    else
      if (PF0OW01.PF0OWNUM <= -99500.00)
        PF0OW02.PF0OWC7[PFWSUB1] = -99.9;
      else
        PF0OW02.PF0OWC7[PFWSUB1] = mathLib.round(PF0OW01.PF0OWNUM * .001, -mathLib.decimals(PF0OW02.PF0OWC7[PFWSUB1]));
      end
    end
    PF0OW01.PF0OWNUM = PFGREC.PFGQTY[8];
    if (PF0OW01.PF0OWNUM >= +999500.00)
      PF0OW02.PF0OWC8[PFWSUB1] = +999.9;
    else
      if (PF0OW01.PF0OWNUM <= -99500.00)
        PF0OW02.PF0OWC8[PFWSUB1] = -99.9;
      else
        PF0OW02.PF0OWC8[PFWSUB1] = mathLib.round(PF0OW01.PF0OWNUM * .001, -mathLib.decimals(PF0OW02.PF0OWC8[PFWSUB1]));
      end
    end
    PF0OW01.PF0OWNUM = PFGREC.PFGQTY[9];
    if (PF0OW01.PF0OWNUM >= +999500.00)
      PF0OW02.PF0OWC9[PFWSUB1] = +999.9;
    else
      if (PF0OW01.PF0OWNUM <= -99500.00)
        PF0OW02.PF0OWC9[PFWSUB1] = -99.9;
      else
        PF0OW02.PF0OWC9[PFWSUB1] = mathLib.round(PF0OW01.PF0OWNUM * .001, -mathLib.decimals(PF0OW02.PF0OWC9[PFWSUB1]));
      end
    end
    PF0OW01.PF0OWNUM = PFGREC.PFGQTY[10];
    if (PF0OW01.PF0OWNUM >= +999500.00)
      PF0OW02.PF0OWC10[PFWSUB1] = +999.9;
    else
      if (PF0OW01.PF0OWNUM <= -99500.00)
        PF0OW02.PF0OWC10[PFWSUB1] = -99.9;
      else
        PF0OW02.PF0OWC10[PFWSUB1] = mathLib.round(PF0OW01.PF0OWNUM * .001, -mathLib.decimals(PF0OW02.PF0OWC10[PFWSUB1]));
      end
    end
    PF0OW01.PF0OWNUM = PFGREC.PFGQTY[11];
    if (PF0OW01.PF0OWNUM >= +999500.00)
      PF0OW02.PF0OWC11[PFWSUB1] = +999.9;
    else
      if (PF0OW01.PF0OWNUM <= -99500.00)
        PF0OW02.PF0OWC11[PFWSUB1] = -99.9;
      else
        PF0OW02.PF0OWC11[PFWSUB1] = mathLib.round(PF0OW01.PF0OWNUM * .001, -mathLib.decimals(PF0OW02.PF0OWC11[PFWSUB1]));
      end
    end
    PF0OW01.PF0OWNUM = PFGREC.PFGQTY[12];
    if (PF0OW01.PF0OWNUM >= +999500.00)
      PF0OW02.PF0OWC12[PFWSUB1] = +999.9;
    else
      if (PF0OW01.PF0OWNUM <= -99500.00)
        PF0OW02.PF0OWC12[PFWSUB1] = -99.9;
      else
        PF0OW02.PF0OWC12[PFWSUB1] = mathLib.round(PF0OW01.PF0OWNUM * .001, -mathLib.decimals(PF0OW02.PF0OWC12[PFWSUB1]));
      end
    end
    PF0OW01.PF0OWNUM = PFGREC.PFGQTY[13];
    if (PF0OW01.PF0OWNUM >= +999500.00)
      PF0OW02.PF0OWC13[PFWSUB1] = +999.9;
    else
      if (PF0OW01.PF0OWNUM <= -99500.00)
        PF0OW02.PF0OWC13[PFWSUB1] = -99.9;
      else
        PF0OW02.PF0OWC13[PFWSUB1] = mathLib.round(PF0OW01.PF0OWNUM * .001, -mathLib.decimals(PF0OW02.PF0OWC13[PFWSUB1]));
      end
    end
  else
    PF0OW01.PF0OWNUM = PFGREC.PFGQTY[1];
    PF0OW02.PF0OWC1[PFWSUB1] = mathLib.round(PF0OW01.PF0OWNUM * .001, -mathLib.decimals(PF0OW02.PF0OWC1[PFWSUB1]));
    PF0OW01.PF0OWNUM = PFGREC.PFGQTY[2];
    PF0OW02.PF0OWC2[PFWSUB1] = mathLib.round(PF0OW01.PF0OWNUM * .001, -mathLib.decimals(PF0OW02.PF0OWC2[PFWSUB1]));
    PF0OW01.PF0OWNUM = PFGREC.PFGQTY[3];
    PF0OW02.PF0OWC3[PFWSUB1] = mathLib.round(PF0OW01.PF0OWNUM * .001, -mathLib.decimals(PF0OW02.PF0OWC3[PFWSUB1]));
    PF0OW01.PF0OWNUM = PFGREC.PFGQTY[4];
    PF0OW02.PF0OWC4[PFWSUB1] = mathLib.round(PF0OW01.PF0OWNUM * .001, -mathLib.decimals(PF0OW02.PF0OWC4[PFWSUB1]));
    PF0OW01.PF0OWNUM = PFGREC.PFGQTY[5];
    PF0OW02.PF0OWC5[PFWSUB1] = mathLib.round(PF0OW01.PF0OWNUM * .001, -mathLib.decimals(PF0OW02.PF0OWC5[PFWSUB1]));
    PF0OW01.PF0OWNUM = PFGREC.PFGQTY[6];
    PF0OW02.PF0OWC6[PFWSUB1] = mathLib.round(PF0OW01.PF0OWNUM * .001, -mathLib.decimals(PF0OW02.PF0OWC6[PFWSUB1]));
    PF0OW01.PF0OWNUM = PFGREC.PFGQTY[7];
    PF0OW02.PF0OWC7[PFWSUB1] = mathLib.round(PF0OW01.PF0OWNUM * .001, -mathLib.decimals(PF0OW02.PF0OWC7[PFWSUB1]));
    PF0OW01.PF0OWNUM = PFGREC.PFGQTY[8];
    PF0OW02.PF0OWC8[PFWSUB1] = mathLib.round(PF0OW01.PF0OWNUM * .001, -mathLib.decimals(PF0OW02.PF0OWC8[PFWSUB1]));
    PF0OW01.PF0OWNUM = PFGREC.PFGQTY[9];
    PF0OW02.PF0OWC9[PFWSUB1] = mathLib.round(PF0OW01.PF0OWNUM * .001, -mathLib.decimals(PF0OW02.PF0OWC9[PFWSUB1]));
    PF0OW01.PF0OWNUM = PFGREC.PFGQTY[10];
    PF0OW02.PF0OWC10[PFWSUB1] = mathLib.round(PF0OW01.PF0OWNUM * .001, -mathLib.decimals(PF0OW02.PF0OWC10[PFWSUB1]));
    PF0OW01.PF0OWNUM = PFGREC.PFGQTY[11];
    PF0OW02.PF0OWC11[PFWSUB1] = mathLib.round(PF0OW01.PF0OWNUM * .001, -mathLib.decimals(PF0OW02.PF0OWC11[PFWSUB1]));
    PF0OW01.PF0OWNUM = PFGREC.PFGQTY[12];
    PF0OW02.PF0OWC12[PFWSUB1] = mathLib.round(PF0OW01.PF0OWNUM * .001, -mathLib.decimals(PF0OW02.PF0OWC12[PFWSUB1]));
    PF0OW01.PF0OWNUM = PFGREC.PFGQTY[13];
    PF0OW02.PF0OWC13[PFWSUB1] = mathLib.round(PF0OW01.PF0OWNUM * .001, -mathLib.decimals(PF0OW02.PF0OWC13[PFWSUB1]));
  end
end // end PF0O230

// get i/s group descriptions
Function PF0O240()
   /* *********************************************************/
   /* *  this process will scan through the pf0ow02 storage  **/
   /* *  and will get the i/s group descriptions for all i/s **/
   /* *  group total entires in pf0ow02(record type  = 3).   **/
   /* *  the i/s group desc. will be obtained by using the   **/
   /* *  yiscd of the record immediately following the group **/
   /* *  total record. this yiscd is combined with the i/s   **/
   /* *  group ref. # as a data base key to access the i/s   **/
   /* *  group table.                                        **/
   /* *********************************************************/

  if (PF0OW02.PF0OWTYP[PFWSUB1] != "3") /* if the entry isn't a group total,*/
    return; /* exit the routine*/
  end

  PFWSUB2 = PFWSUB1 + 1; /* set subscript to entry immediately following*/

  set SQLCA empty;
  set PFBREC empty;
  PFBREC.PFBREF = PFEREC.PFBREF;
                                   /* setup to access i/s group table*/
  PFBREC.YISCD[1] = PF0OW02.YISCD[PFWSUB2];
  call "IO2710" ("S ", SQLCA, PFBREC) {isNoRefresh = yes, isExternal = yes}; /* access visgrp01 table*/
  if (SQLCA.VAGen_SQLCODE == +0) /* if record found, move i/s group desc. to*/
    PF0OW02.PF0OWABV[PFWSUB1] = PFBREC.PFBISDSC; /* w/s area*/
  else
    TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
    TA1REC.TA1TBLVU = "VISGRP01";
    PF0OW01.PF0OWABK = PFBREC.PFBREF;
    TA1REC.TA1TBLKE = PF0OW01.PF0OWABK;
    TA1REC.TA1LOCAT[3] = "PF0O240";
    TA1REC.TA1LOCAT[4] = "IO2710";
    XPPF010();
  end
end // end PF0O240

// access vsumry01 table
Function PF0O260()
   /* ***********************************************************/
   /* *  this process will access the vsumry01 table using     **/
   /* *  the summary name, summary level, and summary sequence **/
   /* *  number as db2 keys. this process will be used to read **/
   /* *  the summary file in a backwards direction and will    **/
   /* *  read the first record of the requested summary only.  **/
   /* *  the level and seq. # keys will then be used by        **/
   /* *  pf0o200 to read the summary in a normal manner.       **/
   /* ***********************************************************/

  set PFGREC empty;
  set SQLCA empty;

  PFGREC.PFESUMNM = PFEREC.PFESUMNM; /* move summary name to db2 key*/
  PFGREC.PFGSUMN = PFEREC.PFGSUMN; /* move summary # to db2 key*/
  PFGREC.PFGLVLNO = PF0OW01.PF0OWSTL; /* move level # to db2 key*/
  PFGREC.PFGLVLSQ = PF0OW01.PF0OWSTS; /* move level seq # to db2 key*/

  call "IO2920" ("SF", SQLCA, PFGREC) {isNoRefresh = yes, isExternal = yes};
                                   /* read vsumry01 select/first*/

  if (SQLCA.VAGen_SQLCODE == +0) /* if cursor open ok, continue with the process*/
    PF0OW01.PF0OWSTS = PFGREC.PFGLVLSQ; /* save seq. #*/
  else
    if (SQLCA.VAGen_SQLCODE == +100)
      return;
    else
      TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
      TA1REC.TA1TBLVU = "VSUMRY01";
      TA1REC.TA1TBLKE = PF1REC.PFESUMNM;
      TA1REC.TA1LOCAT[3] = "PF0O200";
      TA1REC.TA1LOCAT[4] = "IO2920";
      XPPF010();
    end
  end

end // end PF0O260

// check for hierarchy change
Function PF0O270()
   /* ********************************************************/
   /* *  this process will check the reporting attribute    **/
   /* *  values of the previous and current summaries that  **/
   /* *  were displayed as a result of a pf20 or pf21 key.  **/
   /* *  if the result of of either key is a change in the  **/
   /* *  reporting attributes hierarchy as described below, **/
   /* *  then a warning message is sent to the terminal     **/
   /* *  operator. in the following example, if the user is **/
   /* *  viewing the summary indicated as point a and       **/
   /* *  enters pf20 (move up within a level) to move to    **/
   /* *  point b, the hierarchy level of '003 non-tech      **/
   /* *  running' has been bypassed.                        **/
   /* *  02  running                                        **/
   /* *      002  tecnical running                          **/
   /* *           21  national                              **/
   /* *           22  major                                 **/
   /* *           23  regular   ---- point b                **/
   /* *      003  non-tech running                          **/
   /* *           21  national  ---- point a                **/
   /* *           22  major                                 **/
   /* *           23  regular                               **/
   /* *  05  basketball                                     **/
   /* ********************************************************/

  if (PF0OW01.PF0OWSTL == 8) /* find current level # and compare attributes*/
    if (PF0OW01.PF0OWCD7 != PF0OW01.PF0OWCV7) /* from one level lower*/
        /* if they don't match, send warning to user*/
      PF0OW01.PF0OWRN1 = "BKWD/FRWD MOVEMENT AT \"";
      PF0OW01.PF0OWRV1 = PF1REC.PFISDESC[8];
      PF0OW01.PF0OWRN2 = "\" LEVEL HAS CAUSED \"";
      PF0OW01.PF0OWRV2 = PF1REC.PFISDESC[7];
      PF0OW01.PF0OWRN3 = "\" VALUE TO CHANGE";
      PF0OM001.VAGen_EZEMSG = PF0OW01.PF0OWRN; /* move warning message*/
      PF0OM002.VAGen_EZEMSG = PF0OW01.PF0OWRN; /* to screen*/
    end
    return;
  end

  if (PF0OW01.PF0OWSTL == 6) /* find current level # and compare attributes*/
    if (PF0OW01.PF0OWCD6 != PF0OW01.PF0OWCV6) /* from one level lower*/
        /* if they don't match, send warning to user*/
      PF0OW01.PF0OWRN1 = "BKWD/FRWD MOVEMENT AT \"";
      PF0OW01.PF0OWRV1 = PF1REC.PFISDESC[7];
      PF0OW01.PF0OWRN2 = "\" LEVEL HAS CAUSED \"";
      PF0OW01.PF0OWRV2 = PF1REC.PFISDESC[6];
      PF0OW01.PF0OWRN3 = "\" VALUE TO CHANGE";
      PF0OM001.VAGen_EZEMSG = PF0OW01.PF0OWRN; /* move warning message*/
      PF0OM002.VAGen_EZEMSG = PF0OW01.PF0OWRN; /* to screen*/
    end
    return;
  end

  if (PF0OW01.PF0OWSTL == 6) /* find current level # and compare attributes*/
    if (PF0OW01.PF0OWCD5 != PF0OW01.PF0OWCV5) /* from one level lower*/
        /* if they don't match, send warning to user*/
      PF0OW01.PF0OWRN1 = "BKWD/FRWD MOVEMENT AT \"";
      PF0OW01.PF0OWRV1 = PF1REC.PFISDESC[6];
      PF0OW01.PF0OWRN2 = "\" LEVEL HAS CAUSED \"";
      PF0OW01.PF0OWRV2 = PF1REC.PFISDESC[5];
      PF0OW01.PF0OWRN3 = "\" VALUE TO CHANGE";
      PF0OM001.VAGen_EZEMSG = PF0OW01.PF0OWRN; /* move warning message*/
      PF0OM002.VAGen_EZEMSG = PF0OW01.PF0OWRN; /* to screen*/
    end
    return;
  end

  if (PF0OW01.PF0OWSTL == 5) /* find current level # and compare attributes*/
    if (PF0OW01.PF0OWCD4 != PF0OW01.PF0OWCV4) /* from one level lower*/
        /* if they don't match, send warning to user*/
      PF0OW01.PF0OWRN1 = "BKWD/FRWD MOVEMENT AT \"";
      PF0OW01.PF0OWRV1 = PF1REC.PFISDESC[5];
      PF0OW01.PF0OWRN2 = "\" LEVEL HAS CAUSED \"";
      PF0OW01.PF0OWRV2 = PF1REC.PFISDESC[4];
      PF0OW01.PF0OWRN3 = "\" VALUE TO CHANGE";
      PF0OM001.VAGen_EZEMSG = PF0OW01.PF0OWRN; /* move warning message*/
      PF0OM002.VAGen_EZEMSG = PF0OW01.PF0OWRN; /* to screen*/
    end
    return;
  end

  if (PF0OW01.PF0OWSTL == 4) /* find current level # and compare attributes*/
    if (PF0OW01.PF0OWCD3 != PF0OW01.PF0OWCV3) /* from one level lower*/
        /* if they don't match, send warning to user*/
      PF0OW01.PF0OWRN1 = "BKWD/FRWD MOVEMENT AT \"";
      PF0OW01.PF0OWRV1 = PF1REC.PFISDESC[4];
      PF0OW01.PF0OWRN2 = "\" LEVEL HAS CAUSED \"";
      PF0OW01.PF0OWRV2 = PF1REC.PFISDESC[3];
      PF0OW01.PF0OWRN3 = "\" VALUE TO CHANGE";
      PF0OM001.VAGen_EZEMSG = PF0OW01.PF0OWRN; /* move warning message*/
      PF0OM002.VAGen_EZEMSG = PF0OW01.PF0OWRN; /* to screen*/
    end
    return;
  end

  if (PF0OW01.PF0OWSTL == 3) /* find current level # and compare attributes*/
    if (PF0OW01.PF0OWCD2 != PF0OW01.PF0OWCV2) /* from one level lower*/
        /* if they don't match, send warning to user*/
      PF0OW01.PF0OWRN1 = "BKWD/FRWD MOVEMENT AT \"";
      PF0OW01.PF0OWRV1 = PF1REC.PFISDESC[3];
      PF0OW01.PF0OWRN2 = "\" LEVEL HAS CAUSED \"";
      PF0OW01.PF0OWRV2 = PF1REC.PFISDESC[2];
      PF0OW01.PF0OWRN3 = "\" VALUE TO CHANGE";
      PF0OM001.VAGen_EZEMSG = PF0OW01.PF0OWRN; /* move warning message*/
      PF0OM002.VAGen_EZEMSG = PF0OW01.PF0OWRN; /* to screen*/
    end
    return;
  end

  if (PF0OW01.PF0OWSTL == 2) /* find current level # and compare attributes*/
    if (PF0OW01.PF0OWCD1 != PF0OW01.PF0OWCV1) /* from one level lower*/
        /* if they don't match, send warning to user*/
      PF0OW01.PF0OWRN1 = "BKWD/FRWD MOVEMENT AT \"";
      PF0OW01.PF0OWRV1 = PF1REC.PFISDESC[2];
      PF0OW01.PF0OWRN2 = "\" LEVEL HAS CAUSED \"";
      PF0OW01.PF0OWRV2 = PF1REC.PFISDESC[1];
      PF0OW01.PF0OWRN3 = "\" VALUE TO CHANGE";
      PF0OM001.VAGen_EZEMSG = PF0OW01.PF0OWRN; /* move warning message*/
      PF0OM002.VAGen_EZEMSG = PF0OW01.PF0OWRN; /* to screen*/
    end
    return;
  end

end // end PF0O270

// display summary type
Function PF0O300()
   /* ************************************************************/
   /* *  this process will determine the type of summary a user **/
   /* *  is viewing and will perform the appropriate routine to **/
   /* *  move summary records to the maps. the routines are :   **/
   /* *  summary type     routine                               **/
   /* *  ------------     -------------                         **/
   /* *    'sum'          pf0o310                               **/
   /* *    'det'          pf0o320                               **/
   /* *    'exp'          pf0o330                               **/
   /* ************************************************************/

  if (PF0OW01.PF0OWDSP == "SUM") /* summary display*/
    PF0O310();
  else
    if (PF0OW01.PF0OWDSP == "DET") /* detail display*/
      PF0O320();
    else
      if (PF0OW01.PF0OWDSP == "EXP") /* explode display*/
        PF0O330();
      end
    end
  end
end // end PF0O300

// move 'summary' items to maps
Function PF0O310()
   /* ***************************************************/
   /* *   this process will move all 'summary' items   **/
   /* *   from pf0ow02 record to the maps. summary     **/
   /* *   items are identified by the field pf0owtyp   **/
   /* *   being = 1. the summary display will use one  **/
   /* *   screen only; no scrolling will be allowed.   **/
   /* *   both the right side(pf0om001) and the left   **/
   /* *   side(pf0om002) of the display will be        **/
   /* *   loaded in this process. the user can scroll  **/
   /* *   right and left using pf10 and pf11.          **/
   /* ***************************************************/

  PF0O340(); /* clear maps of previous data*/

  PFWREC.PFWSAVDX = PFWREC.PFWSUB1; /* save first w/s position*/

  PFWSUB2 = 1;
  while (PFWSUB2 < 11) /* browse through pf0ow02 and move all*/
    if (PF0OW02.PF0OWTYP[PFWSUB1] == "1") /* summary records to the maps*/
      PF0OM001.PF0OMISD[PFWSUB2] = PF0OW02.PF0OWLIT[PFWSUB1];
      PF0OM002.PF0OMISD[PFWSUB2] = PF0OW02.PF0OWLIT[PFWSUB1];

      PF0OM001.PF0OMAM1[PFWSUB2] = PF0OW02.PF0OWC1[PFWSUB1];
      PF0OM001.PF0OMAM2[PFWSUB2] = PF0OW02.PF0OWC2[PFWSUB1];
      PF0OM001.PF0OMAM3[PFWSUB2] = PF0OW02.PF0OWC3[PFWSUB1];
      PF0OM001.PF0OMAM4[PFWSUB2] = PF0OW02.PF0OWC4[PFWSUB1];
      PF0OM001.PF0OMAM5[PFWSUB2] = PF0OW02.PF0OWC5[PFWSUB1];
      PF0OM001.PF0OMAM6[PFWSUB2] = PF0OW02.PF0OWC6[PFWSUB1];
      PF0OM001.PF0OMAM7[PFWSUB2] = PF0OW02.PF0OWC13[PFWSUB1];

      PF0OM002.PF0OMAM1[PFWSUB2] = PF0OW02.PF0OWC7[PFWSUB1];
      PF0OM002.PF0OMAM2[PFWSUB2] = PF0OW02.PF0OWC8[PFWSUB1];
      PF0OM002.PF0OMAM3[PFWSUB2] = PF0OW02.PF0OWC9[PFWSUB1];
      PF0OM002.PF0OMAM4[PFWSUB2] = PF0OW02.PF0OWC10[PFWSUB1];
      PF0OM002.PF0OMAM5[PFWSUB2] = PF0OW02.PF0OWC11[PFWSUB1];
      PF0OM002.PF0OMAM6[PFWSUB2] = PF0OW02.PF0OWC12[PFWSUB1];
      PF0OM002.PF0OMAM7[PFWSUB2] = PF0OW02.PF0OWC13[PFWSUB1];
      PFWSUB2 = PFWSUB2 + 1; /* bump index for maps*/
    end
    PFWSUB1 = PFWSUB1 + 1; /* bump w/s index*/
    if (PFWSUB1 > PFWLIMIT)
      PFWSUB2 = 13;
    end
  end
end // end PF0O310

// move 'detail' items to maps
Function PF0O320()
   /* ***************************************************/
   /* *   this process will move all 'detail' items    **/
   /* *   from pf0ow02 record to the maps. detail      **/
   /* *   items are identified by the field pf0owtyp   **/
   /* *   being = 1, 2, 3, or 5.  detail display will  **/
   /* *   scroll up and down the pf0ow02 w/s area.     **/
   /* *   the control of scrolling positioning will    **/
   /* *   be done by pf0oxxx.                          **/
   /* *   both the right side(pf0om001) and the left   **/
   /* *   side(pf0om002) of the display will be        **/
   /* *   loaded in this process. the user can shift   **/
   /* *   right and left using pf10 and pf11.          **/
   /* ***************************************************/

  PF0O340(); /* clear maps of previous data*/

  PFWREC.PFWSAVDX = PFWREC.PFWSUB1; /* save first w/s position*/

  PFWSUB2 = 1;

  while (PFWSUB2 < 11) /* browse through pf0ow02 and move all*/
    if (PF0OW02.PF0OWTYP[PFWSUB1] == "1" /* detail records to the maps*/
     || PF0OW02.PF0OWTYP[PFWSUB1] == "2" 
     || PF0OW02.PF0OWTYP[PFWSUB1] == "3" 
     || PF0OW02.PF0OWTYP[PFWSUB1] == "5")
      PF0OM001.PF0OMISD[PFWSUB2] = PF0OW02.PF0OWLIT[PFWSUB1];
      PF0OM002.PF0OMISD[PFWSUB2] = PF0OW02.PF0OWLIT[PFWSUB1];

      PF0OM001.PF0OMAM1[PFWSUB2] = PF0OW02.PF0OWC1[PFWSUB1];
      PF0OM001.PF0OMAM2[PFWSUB2] = PF0OW02.PF0OWC2[PFWSUB1];
      PF0OM001.PF0OMAM3[PFWSUB2] = PF0OW02.PF0OWC3[PFWSUB1];
      PF0OM001.PF0OMAM4[PFWSUB2] = PF0OW02.PF0OWC4[PFWSUB1];
      PF0OM001.PF0OMAM5[PFWSUB2] = PF0OW02.PF0OWC5[PFWSUB1];
      PF0OM001.PF0OMAM6[PFWSUB2] = PF0OW02.PF0OWC6[PFWSUB1];
      PF0OM001.PF0OMAM7[PFWSUB2] = PF0OW02.PF0OWC13[PFWSUB1];

      PF0OM002.PF0OMAM1[PFWSUB2] = PF0OW02.PF0OWC7[PFWSUB1];
      PF0OM002.PF0OMAM2[PFWSUB2] = PF0OW02.PF0OWC8[PFWSUB1];
      PF0OM002.PF0OMAM3[PFWSUB2] = PF0OW02.PF0OWC9[PFWSUB1];
      PF0OM002.PF0OMAM4[PFWSUB2] = PF0OW02.PF0OWC10[PFWSUB1];
      PF0OM002.PF0OMAM5[PFWSUB2] = PF0OW02.PF0OWC11[PFWSUB1];
      PF0OM002.PF0OMAM6[PFWSUB2] = PF0OW02.PF0OWC12[PFWSUB1];
      PF0OM002.PF0OMAM7[PFWSUB2] = PF0OW02.PF0OWC13[PFWSUB1];
      PFWSUB2 = PFWSUB2 + 1; /* bump index for maps*/
    end
    PFWSUB1 = PFWSUB1 + 1; /* bump w/s index*/
    if (PFWSUB1 > PFWLIMIT) /* if w/s end reached,*/
      PFWSUB2 = 13;
    end
  end

  PFWREC.PFWNXTDX = PFWREC.PFWSUB1; /* save next available index*/
end // end PF0O320

// move 'explode' items to maps
Function PF0O330()
   /* ***************************************************/
   /* *   this process will move all 'explode' items   **/
   /* *   from pf0ow02 record to the maps. explode     **/
   /* *   items are identified by the field pf0owtyp   **/
   /* *   being = 1, 2, 4, or 5.  detail display will  **/
   /* *   scroll up and down the pf0ow02 w/s area.     **/
   /* *   the control of scrolling positioning will    **/
   /* *   be done by pf0oxxx.                          **/
   /* *   both the right side(pf0om001) and the left   **/
   /* *   side(pf0om002) of the display will be        **/
   /* *   loaded in this process. the user can shift   **/
   /* *   right and left using pf10 and pf11.          **/
   /* ***************************************************/

  PF0O340(); /* clear maps of previous data*/

  PFWREC.PFWSAVDX = PFWREC.PFWSUB1; /* save first w/s position*/

  PFWSUB2 = 1;

  while (PFWSUB2 < 11) /* browse through pf0ow02 and move all*/
    if (PF0OW02.PF0OWTYP[PFWSUB1] == "1" /* explode records to the maps*/
     || PF0OW02.PF0OWTYP[PFWSUB1] == "2" 
     || PF0OW02.PF0OWTYP[PFWSUB1] == "4" 
     || PF0OW02.PF0OWTYP[PFWSUB1] == "5")
      PF0OM001.PF0OMISD[PFWSUB2] = PF0OW02.PF0OWLIT[PFWSUB1];
      PF0OM002.PF0OMISD[PFWSUB2] = PF0OW02.PF0OWLIT[PFWSUB1];

      PF0OM001.PF0OMAM1[PFWSUB2] = PF0OW02.PF0OWC1[PFWSUB1];
      PF0OM001.PF0OMAM2[PFWSUB2] = PF0OW02.PF0OWC2[PFWSUB1];
      PF0OM001.PF0OMAM3[PFWSUB2] = PF0OW02.PF0OWC3[PFWSUB1];
      PF0OM001.PF0OMAM4[PFWSUB2] = PF0OW02.PF0OWC4[PFWSUB1];
      PF0OM001.PF0OMAM5[PFWSUB2] = PF0OW02.PF0OWC5[PFWSUB1];
      PF0OM001.PF0OMAM6[PFWSUB2] = PF0OW02.PF0OWC6[PFWSUB1];
      PF0OM001.PF0OMAM7[PFWSUB2] = PF0OW02.PF0OWC13[PFWSUB1];

      PF0OM002.PF0OMAM1[PFWSUB2] = PF0OW02.PF0OWC7[PFWSUB1];
      PF0OM002.PF0OMAM2[PFWSUB2] = PF0OW02.PF0OWC8[PFWSUB1];
      PF0OM002.PF0OMAM3[PFWSUB2] = PF0OW02.PF0OWC9[PFWSUB1];
      PF0OM002.PF0OMAM4[PFWSUB2] = PF0OW02.PF0OWC10[PFWSUB1];
      PF0OM002.PF0OMAM5[PFWSUB2] = PF0OW02.PF0OWC11[PFWSUB1];
      PF0OM002.PF0OMAM6[PFWSUB2] = PF0OW02.PF0OWC12[PFWSUB1];
      PF0OM002.PF0OMAM7[PFWSUB2] = PF0OW02.PF0OWC13[PFWSUB1];
      PFWSUB2 = PFWSUB2 + 1; /* bump index for maps*/
    end
    PFWSUB1 = PFWSUB1 + 1; /* bump w/s index*/
    if (PFWSUB1 > PFWLIMIT) /* if w/s end reached, end the routine*/
      PFWSUB2 = 13;
    end
  end

  PFWREC.PFWNXTDX = PFWREC.PFWSUB1; /* save next w/s position*/
end // end PF0O330

// clear map fields
Function PF0O340()

  PFWSUB2 = 1;

  while (PFWSUB2 < 11)
    PF0OM001.PF0OMISD[PFWSUB2] = " ";
    PF0OM002.PF0OMISD[PFWSUB2] = " ";
    PF0OM001.PF0OMAM1[PFWSUB2] = 0;
    PF0OM001.PF0OMAM2[PFWSUB2] = 0;
    PF0OM001.PF0OMAM3[PFWSUB2] = 0;
    PF0OM001.PF0OMAM4[PFWSUB2] = 0;
    PF0OM001.PF0OMAM5[PFWSUB2] = 0;
    PF0OM001.PF0OMAM6[PFWSUB2] = 0;
    PF0OM001.PF0OMAM7[PFWSUB2] = 0;
    PF0OM002.PF0OMAM1[PFWSUB2] = 0;
    PF0OM002.PF0OMAM2[PFWSUB2] = 0;
    PF0OM002.PF0OMAM3[PFWSUB2] = 0;
    PF0OM002.PF0OMAM4[PFWSUB2] = 0;
    PF0OM002.PF0OMAM5[PFWSUB2] = 0;
    PF0OM002.PF0OMAM6[PFWSUB2] = 0;
    PF0OM002.PF0OMAM7[PFWSUB2] = 0;
    PFWSUB2 = PFWSUB2 + 1;
  end

end // end PF0O340

// scroll backwards thru 'det'
Function PF0O350()
   /* *****************************************************/
   /* *  this routine is nearly identical to pf0o320.    **/
   /* *  the difference is that this routine will scroll **/
   /* *  backwards through the w/s area, pf0ow02, by     **/
   /* *  decrementing the storage and screen subscripts. **/
   /* *  if the w/s subscript reaches zero after being   **/
   /* *  decremented, it is set to 1 and the scroll      **/
   /* *  forward routine, pf0o320, is performed.         **/
   /* *****************************************************/

  if (PFWSUB1 < 1)
    converseLib.validationFailed(085);
    return;
  end

  PF0O340(); /* clear maps of previous data*/


  PFWREC.PFWNXTDX = PFWREC.PFWSUB1; /* save last w/s position*/

  PFWSUB2 = 10;

  while (PFWSUB2 > 0) /* browse backwards through pf0ow02 and move all*/
    if (PF0OW02.PF0OWTYP[PFWSUB1] == "1" /* detail records to the maps*/
     || PF0OW02.PF0OWTYP[PFWSUB1] == "2" 
     || PF0OW02.PF0OWTYP[PFWSUB1] == "3" 
     || PF0OW02.PF0OWTYP[PFWSUB1] == "5")
      PF0OM001.PF0OMISD[PFWSUB2] = PF0OW02.PF0OWLIT[PFWSUB1];
      PF0OM002.PF0OMISD[PFWSUB2] = PF0OW02.PF0OWLIT[PFWSUB1];

      PF0OM001.PF0OMAM1[PFWSUB2] = PF0OW02.PF0OWC1[PFWSUB1];
      PF0OM001.PF0OMAM2[PFWSUB2] = PF0OW02.PF0OWC2[PFWSUB1];
      PF0OM001.PF0OMAM3[PFWSUB2] = PF0OW02.PF0OWC3[PFWSUB1];
      PF0OM001.PF0OMAM4[PFWSUB2] = PF0OW02.PF0OWC4[PFWSUB1];
      PF0OM001.PF0OMAM5[PFWSUB2] = PF0OW02.PF0OWC5[PFWSUB1];
      PF0OM001.PF0OMAM6[PFWSUB2] = PF0OW02.PF0OWC6[PFWSUB1];
      PF0OM001.PF0OMAM7[PFWSUB2] = PF0OW02.PF0OWC13[PFWSUB1];

      PF0OM002.PF0OMAM1[PFWSUB2] = PF0OW02.PF0OWC7[PFWSUB1];
      PF0OM002.PF0OMAM2[PFWSUB2] = PF0OW02.PF0OWC8[PFWSUB1];
      PF0OM002.PF0OMAM3[PFWSUB2] = PF0OW02.PF0OWC9[PFWSUB1];
      PF0OM002.PF0OMAM4[PFWSUB2] = PF0OW02.PF0OWC10[PFWSUB1];
      PF0OM002.PF0OMAM5[PFWSUB2] = PF0OW02.PF0OWC11[PFWSUB1];
      PF0OM002.PF0OMAM6[PFWSUB2] = PF0OW02.PF0OWC12[PFWSUB1];
      PF0OM002.PF0OMAM7[PFWSUB2] = PF0OW02.PF0OWC13[PFWSUB1];
      PFWSUB2 = PFWSUB2 - 1; /* decrement index for maps*/
    end
    PFWSUB1 = PFWSUB1 - 1; /* decremennet w/s index*/
    if (PFWSUB1 <= 1) /* if w/s end reached,*/
      converseLib.validationFailed(085);
      PFWSUB1 = 1;
      PFWSUB2 = 1;
      PF0O320();
      return;
    end
  end

  PFWREC.PFWSAVDX = PFWREC.PFWSUB1; /* save first w/s index*/
end // end PF0O350

// scroll backwards thru 'exp'
Function PF0O360()
   /* *****************************************************/
   /* *  this routine is nearly identical to pf0o330.    **/
   /* *  the difference is that this routine will scroll **/
   /* *  backwards through the w/s area, pf0ow02, by     **/
   /* *  decrementing the storage and screen subscripts. **/
   /* *  if the w/s subscript reaches zero after being   **/
   /* *  decremented, it is set to 1 and the scroll      **/
   /* *  forward routine, pf0o330, is performed.         **/
   /* *****************************************************/

  if (PFWSUB1 < 1)
    converseLib.validationFailed(085);
    return;
  end

  PF0O340(); /* clear maps of previous data*/

  PFWREC.PFWNXTDX = PFWREC.PFWSUB1; /* save first w/s position*/

  PFWSUB2 = 10;

  while (PFWSUB2 > 0) /* browse backwards through pf0ow02 and move all*/
    if (PF0OW02.PF0OWTYP[PFWSUB1] == "1" /* explode records to the maps*/
     || PF0OW02.PF0OWTYP[PFWSUB1] == "2" 
     || PF0OW02.PF0OWTYP[PFWSUB1] == "4" 
     || PF0OW02.PF0OWTYP[PFWSUB1] == "5")
      PF0OM001.PF0OMISD[PFWSUB2] = PF0OW02.PF0OWLIT[PFWSUB1];
      PF0OM002.PF0OMISD[PFWSUB2] = PF0OW02.PF0OWLIT[PFWSUB1];

      PF0OM001.PF0OMAM1[PFWSUB2] = PF0OW02.PF0OWC1[PFWSUB1];
      PF0OM001.PF0OMAM2[PFWSUB2] = PF0OW02.PF0OWC2[PFWSUB1];
      PF0OM001.PF0OMAM3[PFWSUB2] = PF0OW02.PF0OWC3[PFWSUB1];
      PF0OM001.PF0OMAM4[PFWSUB2] = PF0OW02.PF0OWC4[PFWSUB1];
      PF0OM001.PF0OMAM5[PFWSUB2] = PF0OW02.PF0OWC5[PFWSUB1];
      PF0OM001.PF0OMAM6[PFWSUB2] = PF0OW02.PF0OWC6[PFWSUB1];
      PF0OM001.PF0OMAM7[PFWSUB2] = PF0OW02.PF0OWC13[PFWSUB1];

      PF0OM002.PF0OMAM1[PFWSUB2] = PF0OW02.PF0OWC7[PFWSUB1];
      PF0OM002.PF0OMAM2[PFWSUB2] = PF0OW02.PF0OWC8[PFWSUB1];
      PF0OM002.PF0OMAM3[PFWSUB2] = PF0OW02.PF0OWC9[PFWSUB1];
      PF0OM002.PF0OMAM4[PFWSUB2] = PF0OW02.PF0OWC10[PFWSUB1];
      PF0OM002.PF0OMAM5[PFWSUB2] = PF0OW02.PF0OWC11[PFWSUB1];
      PF0OM002.PF0OMAM6[PFWSUB2] = PF0OW02.PF0OWC12[PFWSUB1];
      PF0OM002.PF0OMAM7[PFWSUB2] = PF0OW02.PF0OWC13[PFWSUB1];
      PFWSUB2 = PFWSUB2 - 1; /* decrement index for maps*/
    end
    PFWSUB1 = PFWSUB1 - 1; /* decrement w/s index*/
    if (PFWSUB1 <= 1) /* if w/s end reached,*/
      converseLib.validationFailed(085);
      PFWSUB1 = 1;
      PFWSUB2 = 1;
      PF0O330();
      return;
    end
  end

  PFWREC.PFWSAVDX = PFWREC.PFWSUB1; /* save first w/s position*/
end // end PF0O360

//*** RECORD=PF0OW01 ****
// miscellaneous storage area for pf0o application
// ***********************
Record PF0OW01 type basicRecord
  10 PF0OWCL1 PF0OWCL1 ; 
    15 PF0OWDT1 PF0OWDT1 ; 
    15 PF0OWF1 PF0OWF1 ; 
    15 PF0OWTP1 PF0OWTP1 ; 
  10 PF0OWCL2 PF0OWCL2 ; 
    15 PF0OWDT2 PF0OWDT2 ; 
    15 PF0OWF2 PF0OWF2 ; 
    15 PF0OWTP2 PF0OWTP2 ; 
  10 PF0OWCL3 PF0OWCL3 ; 
    15 PF0OWDT3 PF0OWDT3 ; 
    15 PF0OWF3 PF0OWF3 ; 
    15 PF0OWTP3 PF0OWTP3 ; 
  10 PF0OWCL4 PF0OWCL4 ; 
    15 PF0OWDT4 PF0OWDT4 ; 
    15 PF0OWF4 PF0OWF4 ; 
    15 PF0OWTP4 PF0OWTP4 ; 
  10 PF0OWCL5 PF0OWCL5 ; 
    15 PF0OWDT5 PF0OWDT5 ; 
    15 PF0OWF5 PF0OWF5 ; 
    15 PF0OWTP5 PF0OWTP5 ; 
  10 PF0OWCL6 PF0OWCL6 ; 
    15 PF0OWDT6 PF0OWDT6 ; 
    15 PF0OWF6 PF0OWF6 ; 
    15 PF0OWTP6 PF0OWTP6 ; 
  10 PF0OWCL7 PF0OWCL7 ; 
    15 PF0OWDT7 PF0OWDT7 ; 
    15 PF0OWF7 PF0OWF7 ; 
    15 PF0OWTP7 PF0OWTP7 ; 
  10 PF0OWCL8 PF0OWCL8 ; 
    15 PF0OWDT8 PF0OWDT8 ; 
    15 PF0OWF8 PF0OWF8 ; 
    15 PF0OWTP8 PF0OWTP8 ; 
  10 PF0OWCL9 PF0OWCL9 ; 
    15 PF0OWDT9 PF0OWDT9 ; 
    15 PF0OWF9 PF0OWF9 ; 
    15 PF0OWTP9 PF0OWTP9 ; 
  10 PF0OWCL0 PF0OWCL0 ; 
    15 PF0OWDT0 PF0OWDT0 ; 
    15 PF0OWF10 PF0OWF10 ; 
    15 PF0OWTP0 PF0OWTP0 ; 
  10 PF0OWABK PF0OWABK ; 
    15 PF0OWAB2 PF0OWAB2 ; 
  10 PF0OWSTL PF0OWSTL ; 
  10 PF0OWSTS PF0OWSTS ; 
  10 PF0OWDSP PF0OWDSP ; 
  10 PF0OWHDP PF0OWHDP ; 
  10 PF0OWLEF PF0OWLEF ; 
  10 PF0OWRIG PF0OWRIG ; 
  10 PF0OWPFK PF0OWPFK ; 
    15 PF0OWKY1 PF0OWKY1 ; 
    15 PF0OWDP1 PF0OWDP1 ; 
    15 PF0OWKY2 PF0OWKY2 ; 
    15 PF0OWDP2 PF0OWDP2 ; 
  10 PF0OWFLG PF0OWFLG ; 
  10 PF0OWAVA PF0OWAVA ; 
    15 PF0OWAV1 PF0OWAV1 ; 
    15 PF0OWAV2 PF0OWAV2 ; 
  10 PF0OWAVD PF0OWAVD ; 
    15 PF0OWAD1 PF0OWAD1 ; 
    15 PF0OWAD2 PF0OWAD2 ; 
  10 PF0OWNUM PF0OWNUM ; 
    15 PF0OWNM1 PF0OWNM1 ; 
    15 PF0OWNM2 PF0OWNM2 ; 
  10 PF0OWFL1 PF0OWFL1 ; 
    15 PF0OWCD1 PF0OWCD1 ; 
    15 PF0OWCD2 PF0OWCD2 ; 
    15 PF0OWCD3 PF0OWCD3 ; 
    15 PF0OWCD4 PF0OWCD4 ; 
    15 PF0OWCD5 PF0OWCD5 ; 
    15 PF0OWCD6 PF0OWCD6 ; 
    15 PF0OWCD7 PF0OWCD7 ; 
  10 PF0OWFL2 PF0OWFL2 ; 
    15 PF0OWCV1 PF0OWCV1 ; 
    15 PF0OWCV2 PF0OWCV2 ; 
    15 PF0OWCV3 PF0OWCV3 ; 
    15 PF0OWCV4 PF0OWCV4 ; 
    15 PF0OWCV5 PF0OWCV5 ; 
    15 PF0OWCV6 PF0OWCV6 ; 
    15 PF0OWCV7 PF0OWCV7 ; 
  10 PF0OWSTY PF0OWSTY ; 
    15 XGPCD XGPCD ; 
    15 PF0OWF11 PF0OWF11 ; 
    15 SY1STNBR SY1STNBR ; 
    15 PF0OWF12 PF0OWF12 ; 
    15 SY2CLRID SY2CLRID ; 
    15 PF0OWF13 PF0OWF13 ; 
    15 XDMCD XDMCD ; 
    15 PF0OWF14 PF0OWF14 ; 
    15 XQACD XQACD ; 
    15 PF0OWF15 PF0OWF15 ; 
    15 XLCCD XLCCD ; 
  10 PF0OWHD1 PF0OWHD1 ; 
    15 PF0OWF21 PF0OWF21 ; 
    15 PF0OWH1 PF0OWH1 ; 
    15 PF0OWF22 PF0OWF22 ; 
    15 PF0OWH2 PF0OWH2 ; 
    15 PF0OWF23 PF0OWF23 ; 
    15 PF0OWH3 PF0OWH3 ; 
    15 PF0OWF24 PF0OWF24 ; 
    15 PF0OWH4 PF0OWH4 ; 
    15 PF0OWF25 PF0OWF25 ; 
    15 PF0OWH5 PF0OWH5 ; 
    15 PF0OWF26 PF0OWF26 ; 
    15 PF0OWH6 PF0OWH6 ; 
    15 PF0OWF27 PF0OWF27 ; 
    15 PF0OWH7 PF0OWH7 ; 
  10 PF0OWHD2 PF0OWHD2 ; 
    15 PF0OWF28 PF0OWF28 ; 
    15 PF0OWH9 PF0OWH9 ; 
    15 PF0OWF29 PF0OWF29 ; 
    15 PF0OWH10 PF0OWH10 ; 
    15 PF0OWF30 PF0OWF30 ; 
    15 PF0OWH11 PF0OWH11 ; 
    15 PF0OWF31 PF0OWF31 ; 
    15 PF0OWH12 PF0OWH12 ; 
    15 PF0OWF32 PF0OWF32 ; 
    15 PF0OWH13 PF0OWH13 ; 
    15 PF0OWF33 PF0OWF33 ; 
    15 PF0OWH14 PF0OWH14 ; 
    15 PF0OWF34 PF0OWF34 ; 
    15 PF0OWH15 PF0OWH15 ; 
  10 PF0OWRN PF0OWRN ; 
    15 PF0OWRN1 PF0OWRN1 ; 
    15 PF0OWRV1 PF0OWRV1 ; 
    15 PF0OWRN2 PF0OWRN2 ; 
    15 PF0OWRV2 PF0OWRV2 ; 
    15 PF0OWRN3 PF0OWRN3 ; 
end // end PF0OW01

//*** RECORD=PF0OW02 ****
// this w/s area is used to store rows of summary information
// to be displayed in this application. the rows are identified
// by the field pf0owtyp as follows :
//  value         summary row type
//  -----         ---------------------------
//    1           summary total item (net rev, etc.)
//    2           special summary total (dir sg&a, ind sg&a)
//    3           i/s grouped totals
//    4           i/s grouped items
//    5           i/s ungrouped items
// 
// MAINTENANCE LOG:
//   DATE      INIT     COMMENTS
// --------    ------   --------------------
// 06/13/91    cvo      Increased group level entries on ws
//                      from 200 to 500.
// ***********************
Record PF0OW02 type basicRecord
  5 PF0OWGRP PF0OWGRP [500] ; 
    10 YISCD YISCD ; 
    10 PF0OWLIT PF0OWLIT ; 
      15 PF0OWIND PF0OWIND ; 
      15 PF0OWABV PF0OWABV ; 
    10 PF0OWTYP PF0OWTYP ; 
    10 PF0OWC1 PF0OWC1 ; 
    10 PF0OWC2 PF0OWC2 ; 
    10 PF0OWC3 PF0OWC3 ; 
    10 PF0OWC4 PF0OWC4 ; 
    10 PF0OWC5 PF0OWC5 ; 
    10 PF0OWC6 PF0OWC6 ; 
    10 PF0OWC7 PF0OWC7 ; 
    10 PF0OWC8 PF0OWC8 ; 
    10 PF0OWC9 PF0OWC9 ; 
    10 PF0OWC10 PF0OWC10 ; 
    10 PF0OWC11 PF0OWC11 ; 
    10 PF0OWC12 PF0OWC12 ; 
    10 PF0OWC13 PF0OWC13 ; 
end // end PF0OW02

// CHARACTER db2 abend key
DataItem PF0OWAB2 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// numeric db2 abend key
DataItem PF0OWABK num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// yis-ist-cls-abrv
DataItem PF0OWABV char(16)  {
  align = none, fillCharacter = nullFill, inputRequired = no
}
end

// attr. code
DataItem PF0OWAD1 char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. code literal
DataItem PF0OWAD2 char(12)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attribute literal
DataItem PF0OWAV1 char(8)  {
  align = right, fillCharacter = nullFill, inputRequired = no
}
end

// attribute char.' :'
DataItem PF0OWAV2 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attribute literal group
DataItem PF0OWAVA char(10)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. code val. literal
DataItem PF0OWAVD char(17)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dt/tp 1 amt
DataItem PF0OWC1 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp 10 amt
DataItem PF0OWC10 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp 11 amt
DataItem PF0OWC11 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp 12 amt
DataItem PF0OWC12 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp 13 amt
DataItem PF0OWC13 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp 2 amt
DataItem PF0OWC2 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp 3 amt
DataItem PF0OWC3 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp 4 amt
DataItem PF0OWC4 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp 5 amt
DataItem PF0OWC5 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp 6 amt
DataItem PF0OWC6 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp 7 amt
DataItem PF0OWC7 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp 8 amt
DataItem PF0OWC8 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp 9 amt
DataItem PF0OWC9 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// attr. field 1
DataItem PF0OWCD1 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. field 2
DataItem PF0OWCD2 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. field 3
DataItem PF0OWCD3 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. field 4
DataItem PF0OWCD4 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. field 5
DataItem PF0OWCD5 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. field 6
DataItem PF0OWCD6 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. field 7
DataItem PF0OWCD7 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dt/tp pct. col. 10
DataItem PF0OWCL0 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dt/tp pct. col. 1
DataItem PF0OWCL1 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dt/tp pct. col. 2
DataItem PF0OWCL2 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dt/tp pct. col. 3
DataItem PF0OWCL3 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dt/tp pct. col. 4
DataItem PF0OWCL4 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dt/tp pct. col. 5
DataItem PF0OWCL5 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dt/tp pct. col. 6
DataItem PF0OWCL6 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dt/tp pct. col. 7
DataItem PF0OWCL7 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dt/tp pct. col. 8
DataItem PF0OWCL8 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dt/tp pct. col. 9
DataItem PF0OWCL9 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. field 1
DataItem PF0OWCV1 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. field 2
DataItem PF0OWCV2 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. field 3
DataItem PF0OWCV3 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. field 4
DataItem PF0OWCV4 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. field 5
DataItem PF0OWCV5 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. field 6
DataItem PF0OWCV6 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. field 7
DataItem PF0OWCV7 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// display type-'sum,det,exp'
DataItem PF0OWDP1 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// display type-'sum,det,exp'
DataItem PF0OWDP2 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// display type - sum,det,exp
DataItem PF0OWDSP char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data type code 10
DataItem PF0OWDT0 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data type code 1
DataItem PF0OWDT1 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data type code 2
DataItem PF0OWDT2 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data type code 3
DataItem PF0OWDT3 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data type code 4
DataItem PF0OWDT4 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data type code 5
DataItem PF0OWDT5 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data type code 6
DataItem PF0OWDT6 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data type code 7
DataItem PF0OWDT7 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data type code 8
DataItem PF0OWDT8 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data type code 9
DataItem PF0OWDT9 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler value ' '
DataItem PF0OWF1 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler-value ' '
DataItem PF0OWF10 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler - value '/'
DataItem PF0OWF11 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler - value '/'
DataItem PF0OWF12 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler - value '/'
DataItem PF0OWF13 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler - value '/'
DataItem PF0OWF14 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler - value '/'
DataItem PF0OWF15 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler value ' '
DataItem PF0OWF2 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler - value '--'
DataItem PF0OWF21 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler - value '---'
DataItem PF0OWF22 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler - value '---'
DataItem PF0OWF23 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler - value '---'
DataItem PF0OWF24 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler - value '---'
DataItem PF0OWF25 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler - value '---'
DataItem PF0OWF26 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler - value '---'
DataItem PF0OWF27 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler - value '--'
DataItem PF0OWF28 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler - value '---'
DataItem PF0OWF29 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler value ' '
DataItem PF0OWF3 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler - value '---'
DataItem PF0OWF30 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler - value '---'
DataItem PF0OWF31 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler - value '---'
DataItem PF0OWF32 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler - value '---'
DataItem PF0OWF33 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler - value '---'
DataItem PF0OWF34 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler value ' '
DataItem PF0OWF4 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler value ' '
DataItem PF0OWF5 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler-value ' '
DataItem PF0OWF6 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler-value ' '
DataItem PF0OWF7 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler-value ' '
DataItem PF0OWF8 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler-value ' '
DataItem PF0OWF9 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. values hold area
DataItem PF0OWFL1 char(28)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. values hold area
DataItem PF0OWFL2 char(28)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// vsumry01 sequence flag
DataItem PF0OWFLG char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// gourp level
DataItem PF0OWGRP char(72)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// column 1 heading
DataItem PF0OWH1 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// column 5 heading
DataItem PF0OWH10 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// column 3 heading
DataItem PF0OWH11 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// column 4 heading
DataItem PF0OWH12 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// column 5 heading
DataItem PF0OWH13 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// column 6 heading
DataItem PF0OWH14 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// column 7 heading
DataItem PF0OWH15 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// column 2 heading
DataItem PF0OWH2 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// column 3 heading
DataItem PF0OWH3 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// column 4 heading
DataItem PF0OWH4 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// column 5 heading
DataItem PF0OWH5 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// column 6 heading
DataItem PF0OWH6 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// column 7 heading
DataItem PF0OWH7 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// column 4 heading
DataItem PF0OWH9 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pf00m001 column headings
DataItem PF0OWHD1 char(62)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pf0mm002 column headings
DataItem PF0OWHD2 char(62)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// hold display type
DataItem PF0OWHDP char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// '*' or '#' or ' '
DataItem PF0OWIND char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pf key literal-value '18:'
DataItem PF0OWKY1 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pf key literal-value '19:'
DataItem PF0OWKY2 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// display left map
DataItem PF0OWLEF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// map i/s class literal
DataItem PF0OWLIT char(17)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// numeric breakdown field
DataItem PF0OWNM1 num(8)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// numeric breakdown field
DataItem PF0OWNM2 num(5,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// numeric breakdown field
DataItem PF0OWNUM num(13,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// pf18, pf19 literal
DataItem PF0OWPFK char(13)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// display right map
DataItem PF0OWRIG char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// warning message
DataItem PF0OWRN char(76)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// warning literal 1
DataItem PF0OWRN1 char(23)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// warning literal 2
DataItem PF0OWRN2 char(20)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// warning literal 3
DataItem PF0OWRN3 char(17)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// warning attribute 1
DataItem PF0OWRV1 char(8)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// warning attribute 2
DataItem PF0OWRV2 char(8)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// hold level number
DataItem PF0OWSTL num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// hold sequence number
DataItem PF0OWSTS num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// product hold area
DataItem PF0OWSTY char(22)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// time period code 10
DataItem PF0OWTP0 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// time period code 1
DataItem PF0OWTP1 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// time period code 2
DataItem PF0OWTP2 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// time period code 3
DataItem PF0OWTP3 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// time period code 4
DataItem PF0OWTP4 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// time period code 5
DataItem PF0OWTP5 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// time period code 6
DataItem PF0OWTP6 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// time period code 7
DataItem PF0OWTP7 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// time period code 8
DataItem PF0OWTP8 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// time period code 9
DataItem PF0OWTP9 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// table entry type(1,2,3,4,5)
DataItem PF0OWTYP char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

