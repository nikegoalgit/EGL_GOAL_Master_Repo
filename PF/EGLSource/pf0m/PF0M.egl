package pf0m;
import corpcom2.YSMREC;
import corpcom3.XPPF002;
import corpcom3.XPPF010;
import corpcom3.XPPF020;
import corpcom3.XPPF430;
import corpcom4.XSENTRY;
import corpcom4.XSEXIT;
import corpcom4.XSPF4;
import corpcom4.XSSEGTR;
import corpcom5.COMMAREA;
import corpcom5.ERRSQLCA;
import corpcom6.SQLCA;
import pf.common.PF1REC;
import pf.common.PF2REC;
import pf.common.PFAREC;
import pf.common.PFBREC;
import pf.common.PFCREC;
import pf.common.PFDREC;
import pf.common.PFEREC;
import pf.common.PFGREC;
import pf.common.PFWREC;
import sm.common.SM1REC;
import sy.common.SY1REC;
import sy.common.SY2CLRID;
import sy.common.SYCREC;
import ta.common.TA1REC;
import xx.common.*;
import xx.common.XGPCD;
import xx.common.XLCCD;
import xx.common.XQACD;
import xx.common.YISCD;
import xx.common.YTYCD;
import xx01.*;
import xx02.*;
import xx02.XDMCD;
import xx03.*;
import xx04.*;
import xx05.*;
import xx06.*;
import xx07.*;
import xx08.*;
import xx08.SY1STNBR;
import xx08.YFTTBL;
import xx08.YISTBL;
import xx09.*;
import xx10.*;
import xx10.YTYTBL;
//*** PROGRAM=PF0M ****
// this application will display summaries that were generated
// to use a type 3 format. users are able to view the summaries
// in a summary, detail or explode format. users can also view
// 132 column-sized summaries by scrolling right or left on the
// screen that is displayed. finally, summaries can have up to
// 8 levels of information stored in a hierarchical pattern.
// this application will access the selected summary at a
// starting viewing position as determined in pf0b but the user
// has the capability to move up or down the levels easily by
// using predefined pf keys.
// 
// maintenance history:
//   date     by             description of change
// --------  -----  -------------------------------------------
//  1-03-89   mh    original transfer to production.
//  2-28-89   mh    change handling of overflow pcts.
//  3-13-89   mh    enhance display of partial summary
//                                 warning.   PF0M210
//  6-21-89   DLC   Change Summary Order Type to Base Order
//                  Type (XOBTBL).
//  7-13-89   DLC   Re-Gen for changes to YFATBL, YMATBL,
//                  YMBTBL, and YMCTBL.
// 11-30-89   TBG   Modify to load and pass data viewed back to
//                  Summary File View Selection (PF0B).
//  4-05-90   CVO   Transfer to PF0A if the expected summary
//                  name is not passed.
//  6-13-91   CVO   Increased group level entries on pf0mw02
//                  from 200 to 500.
//  9-25-91   DLC     Added abend if pf0mw02 > 500 when loaded,
//                  & increased # of yis's searched for is grp
//                  literals from 200 to PFWLIMIT, in pf0m200.
//                  Was not displaying lits for last is grps.
//                    Increased rows searched in working stor
//                  for 'sum' level displ from 200 to PFWLIMIT,
//                  in pf0m310.  Was not displaying anything
//                  below gross margin for sums w/ > 200 yis's.
//  9-02-92   WES     Added initialization of attribute descr.
//                  to 'NO DESC' in PF0M210.
//  4-15-94   MJK   changes for new attributes.
//  3-01-96  MBUHIT Regen for GCOA changes to YICTBL.
// 11-19-97  mleabo Re-gen for table changes ysetbl, ysftbl.
// *********************
Program PF0M type textUIProgram //VAGen Info - main text program
  {
  includeReferencedFunctions = yes, allowUnqualifiedItemReferences = yes, 
  throwNrfEofExceptions = yes, handleHardIOErrors = no, V60ExceptionCompatibility = yes, 
  I4GLItemsNullable = no, textLiteralDefaultIsString = no, localSQLScope = yes, 
  msgTablePrefix = "PF00", inputRecord = COMMAREA, segmented = yes
  }

  // Data Declarations
  COMMAREA COMMAREA ; // record
  ERRSQLCA ERRSQLCA; // record
  PF0MW01 PF0MW01; // record
  PF0MW02 PF0MW02; // record
  PF1REC PF1REC; // record
  PF2REC PF2REC; // record
  PFAREC PFAREC; // record
  PFBREC PFBREC; // record
  PFCREC PFCREC; // record
  PFDREC PFDREC; // record
  PFEREC PFEREC; // record
  PFGREC PFGREC; // record
  PFWREC PFWREC; // record
  SM1REC SM1REC; // record
  SQLCA SQLCA; // record
  SY1REC SY1REC; // record
  SYCREC SYCREC; // record
  TA1REC TA1REC; // record
  YSMREC YSMREC; // record

  // VAGen Info - items needed for migration
  VAGen_EZESYS char(8);
  VAGen_EZEREPLY num(1);
  VAGen_EZE_WAIT_TIME bin(9,2);
  VAGen_EZE_ITEMLEN int;

  // Use Declarations
  use XATTBL {deleteAfterUse = yes}; // table
  use XAUTBL {deleteAfterUse = yes}; // table
  use XBTTBL {deleteAfterUse = yes}; // table
  use XCNTBL {deleteAfterUse = yes}; // table
  use XDRTBL {deleteAfterUse = yes}; // table
  use XDVTBL {deleteAfterUse = yes}; // table
  use XFCTBL {deleteAfterUse = yes}; // table
  use XFMTBL {deleteAfterUse = yes}; // table
  use XGATBL {deleteAfterUse = yes}; // table
  use XGPTBL {deleteAfterUse = yes}; // table
  use XGSTBL {deleteAfterUse = yes}; // table
  use XLCTBL {deleteAfterUse = yes}; // table
  use XMCTBL {deleteAfterUse = yes}; // table
  use XOBTBL {deleteAfterUse = yes}; // table
  use XPCTBL {deleteAfterUse = yes}; // table
  use XPGTBL {deleteAfterUse = yes}; // table
  use XPLTBL {deleteAfterUse = yes}; // table
  use XPRTBL {deleteAfterUse = yes}; // table
  use XQATBL {deleteAfterUse = yes}; // table
  use XRDTBL {deleteAfterUse = yes}; // table
  use XRYTBL {deleteAfterUse = yes}; // table
  use XSPTBL {deleteAfterUse = yes}; // table
  use XSUTBL {deleteAfterUse = yes}; // table
  use XWHTBL {deleteAfterUse = yes}; // table
  use YFATBL {deleteAfterUse = yes}; // table
  use YFETBL {deleteAfterUse = yes}; // table
  use YFFTBL {deleteAfterUse = yes}; // table
  use YFGTBL {deleteAfterUse = yes}; // table
  use YFTTBL {deleteAfterUse = yes}; // table
  use YGRTBL {deleteAfterUse = yes}; // table
  use YICTBL {deleteAfterUse = yes}; // table
  use YISTBL {deleteAfterUse = yes}; // table
  use YMATBL {deleteAfterUse = yes}; // table
  use YMBTBL {deleteAfterUse = yes}; // table
  use YMCTBL {deleteAfterUse = yes}; // table
  use YPDTBL {deleteAfterUse = yes}; // table
  use YSCTBL {deleteAfterUse = yes}; // table
  use YSETBL {deleteAfterUse = yes}; // table
  use YSFTBL {deleteAfterUse = yes}; // table
  use YSYTBL {deleteAfterUse = yes}; // table
  use YTYTBL {deleteAfterUse = yes}; // table
  use PF0MM.PF0MM001,  // forms
      PF0MM.PF0MM002
   {
    pfKeyEquate = no
  };

  function main()
    // VAGen Info - initialization needed for migration
    VAGen_EZESYS = VGLib.getVAGSysType();
    PF0M000: PF0M000();
  end // end main
end // end PF0M

// application mainline
Function PF0M000()
   /* ******************************************************/
   /* *    pf0m mainline logic                            **/
   /* ******************************************************/
  ;
  PF0M001(); /* application initialization routine*/
  ;
  while (PFWREC.PFWEOAF == "N") /* while application active,*/
    PF0M100(); /* converse display screens*/
  end
  ;
  XPPF002();
  COMMAREA.CAFROMAP = "PF0L";
  COMMAREA.CATOAP = "PF0A";
  XSEXIT();
end // end PF0M000

Function PF0M001()
   /* ****************************************************/
   /* *   this process will use information passed by   **/
   /* *   pf0b to access profitablity db2 tables for    **/
   /* *   initializing a format 3 summary view. the     **/
   /* *   process will access the summary attribute     **/
   /* *   table(vsumat01) and the i/s group table       **/
   /* *   (visgrp01). the information provided by these **/
   /* *   tables will be used to setup the display      **/
   /* *   screens to used throughout the rest of the    **/
   /* *   application.                                  **/
   /* ****************************************************/
  ;
  XSENTRY(); /* check user security*/
  ;
  XSSEGTR();
  ;
  set PF0MM001 initial; /* initialize maps*/
  set PF0MM002 initial;
  ;
  set PF0MW01 empty; /* initialize w/s records*/
  ;
  PFWREC.PFWERRF = "N"; /* initialize flags*/
  PFWREC.PFWEOAF = "N";
  ;
  PF0MM001.XXXCURDT = VGVar.currentShortGregorianDate; /* move current date to maps*/
  PF0MM002.XXXCURDT = VGVar.currentShortGregorianDate;
  ;
  PF1REC.PF1PASS = COMMAREA.CAUSERA; /* move passed info. to w/s*/
                                          /* record*/
  COMMAREA.CAUSERA = " "; /* clear the commarea*/
  ;
  set PFEREC empty;
  set SQLCA empty;
  ;
  if (PF1REC.PFESUMNM == " ") /* <=== if no summary name passed*/
    COMMAREA.CAFROMAP = "PF0M"; /* to Profit. Menu*/
    COMMAREA.CATOAP = "PF0A";
    XSEXIT(); /* <=== Transfer to PF0A.*/
    PF0MM001.VAGen_EZEMSG = COMMAREA.CAMSG;
    PFWREC.PFWERRF = "Y";
  end
  ;
  PFEREC.PFESUMNM = PF1REC.PFESUMNM; /* move summary name to db2 key*/
  ;
  call "IO2770" ("S ", SQLCA, PFEREC) {isNoRefresh = yes, isExternal = yes}; /* access vsumat01 table*/
  ;
  if (SQLCA.VAGen_SQLCODE == +0) /* if summary found continue with the process*/
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
    TA1REC.TA1TBLVU = "VSUMAT01";
    TA1REC.TA1TBLKE = PF1REC.PFESUMNM;
    TA1REC.TA1LOCAT[3] = "PF0M001";
    TA1REC.TA1LOCAT[4] = "IO2770";
    XPPF010();
  end
  ;
  PF0MM001.PF0MMNAM = PFEREC.PFESUMNM; /* move summary name to screen*/
  PF0MM002.PF0MMNAM = PFEREC.PFESUMNM;
  PFWREC.PFWCDATE = PFEREC.PFECRTDT;
                                   /* move date created to conversion*/
  PFWREC.PFWMONTH = PFWREC.PFWCMO; /* area and reformat date*/
  PFWREC.PFWDAY = PFWREC.PFWCDA;
  PFWREC.PFWYEAR = PFWREC.PFWCYR;
  PF0MM001.PF0MMDTC = PFWREC.PFWDATE;
                                   /* move reformatted date to maps*/
  PF0MM002.PF0MMDTC = PFWREC.PFWDATE;
  PF0MM001.PF0MMBMM = PFEREC.PFABSPRM; /* move base per. mo. to maps*/
  PF0MM002.PF0MMBMM = PFEREC.PFABSPRM;
  PF0MM001.PF0MMCYY = PFEREC.PFABSPRY; /* move base per. yr. to maps*/
  PF0MM002.PF0MMCYY = PFEREC.PFABSPRY;
  PF0MM001.PF0MMFMT = PFEREC.PFCREF; /* move format # to maps*/
  PF0MM002.PF0MMFMT = PFEREC.PFCREF;
  PF0MM001.PF0MMISG = PFEREC.PFBREF; /* move i/s ref. # to maps*/
  PF0MM002.PF0MMISG = PFEREC.PFBREF;
  PF0MM001.PF0MMATT = PFEREC.PFDREF; /* move rpt. attr. # to maps*/
  PF0MM002.PF0MMATT = PFEREC.PFDREF;
  ;
  set PFAREC empty;
  set SQLCA empty;
  ;
  call "IO2670" ("S ", SQLCA, PFAREC) {isNoRefresh = yes, isExternal = yes}; /* access vpfctl01 table*/
  ;
  if (SQLCA.VAGen_SQLCODE == +0) /* if control rec. found continue with*/
                                   /* the process*/
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
    TA1REC.TA1TBLVU = "VPFCTL01";
    TA1REC.TA1TBLKE = PF1REC.PFESUMNM;
    TA1REC.TA1LOCAT[3] = "PF0M001";
    TA1REC.TA1LOCAT[4] = "IO2670";
    XPPF010();
  end
  ;
  if (PFAREC.PFASTBLF == "Y")
                                   /* if the summary file is locked due to*/
                                   /* a*/
    PFWREC.PFWERRF = "Y"; /* db2 batch load, send user a message*/
    converseLib.validationFailed(223);
  end
  ;
  PF0MW01.PF0MWKY1 = "18:"; /* setup pf key literals for*/
                                   /* 'sum,det,exp'*/
  PF0MW01.PF0MWKY2 = "19:";
  ;
  if (PF1REC.PF1DISP == "SUM")
                                   /* pf0b will pass the starting view type*/
     /* (sum,det,exp). move appropriate title heading to maps.*/
    PF0MM001.PF0MMLIT = "SUMMARY FILE SUMMARY VIEW";
    PF0MM002.PF0MMLIT = "SUMMARY FILE SUMMARY VIEW";
    PF0MW01.PF0MWDP1 = "DET"; /* move literals to pf keys*/
    PF0MW01.PF0MWDP2 = "EXP";
  else
    if (PF1REC.PF1DISP == "DET")
      PF0MM001.PF0MMLIT = "SUMMARY FILE DETAIL VIEW";
      PF0MM002.PF0MMLIT = "SUMMARY FILE DETAIL VIEW";
      PF0MW01.PF0MWDP1 = "SUM"; /* move literals to pf keys*/
      PF0MW01.PF0MWDP2 = "EXP";
    else
      if (PF1REC.PF1DISP == "EXP")
        PF0MM001.PF0MMLIT = "SUMMARY FILE EXPLODED VIEW";
        PF0MM002.PF0MMLIT = "SUMMARY FILE EXPLODED VIEW";
        PF0MW01.PF0MWDP1 = "SUM"; /* move literals to pf keys*/
        PF0MW01.PF0MWDP2 = "DET";
      end
    end
  end
  ;
  set PFDREC empty;
  set SQLCA empty;
  ;
  PFDREC.PFDREF = PFEREC.PFDREF; /* move rept. attr. ref # to db2 key*/
  ;
  call "IO2740" ("S ", SQLCA, PFDREC) {isNoRefresh = yes, isExternal = yes}; /* access vrptat01 table*/
  ;
  if (SQLCA.VAGen_SQLCODE == +0) /* if i/s group # found continue with the process*/
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
    TA1REC.TA1TBLVU = "VRPTAT01";
    PF0MW01.PF0MWABK = PFEREC.PFBREF;
    TA1REC.TA1TBLKE = PF0MW01.PF0MWAB2;
    TA1REC.TA1LOCAT[3] = "PF0M001";
    TA1REC.TA1LOCAT[4] = "IO2740";
    XPPF010();
  end
  ;
  set PFCREC empty;
  set SQLCA empty;
  ;
  PFCREC.PFCREF = PFEREC.PFCREF; /* move summary fmt # to db2 key*/
  ;
  call "IO2730" ("S ", SQLCA, PFCREC) {isNoRefresh = yes, isExternal = yes}; /* access vrptfm01 table*/
  ;
  if (SQLCA.VAGen_SQLCODE == +0) /* if format # found continue with the process*/
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
    TA1REC.TA1TBLVU = "VRPTFM01";
    PF0MW01.PF0MWABK = PFEREC.PFCREF;
    TA1REC.TA1TBLKE = PF0MW01.PF0MWAB2;
    TA1REC.TA1LOCAT[3] = "PF0M001";
    TA1REC.TA1LOCAT[4] = "IO2730";
    XPPF010();
  end
  ;
  if (PFCREC.YFTCD in YFTTBL.YFTCD) /* move finc. transaction type to maps*/
    PF0MM001.PF0MMYFT = YFTTBL.YFTDESC[sysVar.arrayIndex];
    PF0MM002.PF0MMYFT = YFTTBL.YFTDESC[sysVar.arrayIndex];
  else
    TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
    TA1REC.TA1TBLVU = "YFTTBL  ";
    PF0MW01.PF0MWABK = PFEREC.PFCREF;
    TA1REC.TA1TBLKE = PF0MW01.PF0MWAB2;
    TA1REC.TA1LOCAT[3] = "PF0M001";
    TA1REC.TA1LOCAT[4] = "******";
    XPPF010();
  end
  ;
  PF0MW01.PF0MWTP1 = PFCREC.YTPCD[1]; /* move dt/tp codes to w/s*/
  PF0MW01.PF0MWTP2 = PFCREC.YTPCD[2];
  PF0MW01.PF0MWTP3 = PFCREC.YTPCD[3];
  PF0MW01.PF0MWTP4 = PFCREC.YTPCD[4];
  PF0MW01.PF0MWTP5 = PFCREC.YTPCD[5];
  PF0MW01.PF0MWDT1 = PFCREC.YPDCD[1];
  PF0MW01.PF0MWDT2 = PFCREC.YPDCD[2];
  PF0MW01.PF0MWDT3 = PFCREC.YPDCD[3];
  PF0MW01.PF0MWDT4 = PFCREC.YPDCD[4];
  PF0MW01.PF0MWDT5 = PFCREC.YPDCD[5];
  PF0MW01.PF0MWF1 = " ";
  PF0MW01.PF0MWF2 = " ";
  PF0MW01.PF0MWF3 = " ";
  PF0MW01.PF0MWF4 = " ";
  PF0MW01.PF0MWF5 = " ";
  ;
  PF0MW01.PF0MWH1 = PF0MW01.PF0MWCL1;
                                   /* string dt/tp literals for maps*/
  PF0MW01.PF0MWH6 = PF0MW01.PF0MWCL1;
  PF0MW01.PF0MWH2 = PF0MW01.PF0MWCL2;
  PF0MW01.PF0MWH7 = PF0MW01.PF0MWCL2;
  PF0MW01.PF0MWH3 = PF0MW01.PF0MWCL3;
  PF0MW01.PF0MWH8 = PF0MW01.PF0MWCL3;
  PF0MW01.PF0MWH4 = PF0MW01.PF0MWCL4;
  PF0MW01.PF0MWH9 = PF0MW01.PF0MWCL4;
  PF0MW01.PF0MWH5 = PF0MW01.PF0MWCL5;
  PF0MW01.PF0MWH10 = PF0MW01.PF0MWCL5;
  PF0MW01.PF0MWF11 = "--"; /* move spacing characters for literals*/
  PF0MW01.PF0MWF12 = "---";
  PF0MW01.PF0MWF13 = "---";
  PF0MW01.PF0MWF14 = "---";
  PF0MW01.PF0MWF15 = "---";
  PF0MW01.PF0MWF16 = "-";
  PF0MW01.PF0MWF17 = "-------";
  PF0MW01.PF0MWF18 = "-----";
  PF0MW01.PF0MWF19 = "-";
  PF0MW01.PF0MWF20 = "-";
  PF0MW01.PF0MWF21 = "-";
  PF0MM001.PF0MMHDR = PF0MW01.PF0MWHD1;
  PF0MM002.PF0MMHDR = PF0MW01.PF0MWHD2;
  ;
  if (PFCREC.PFCPCTC[1] == 1 /* move 'as % of' dt/tp fields to maps*/
   || PFCREC.PFCPCTC[1] == 2)
    PF0MM001.PF0MMDT1 = PF0MW01.PF0MWCL1;
    PF0MM002.PF0MMDT1 = PF0MW01.PF0MWCL1;
  else
    if (PFCREC.PFCPCTC[1] == 3
     || PFCREC.PFCPCTC[1] == 4)
      PF0MM001.PF0MMDT1 = PF0MW01.PF0MWCL2;
      PF0MM002.PF0MMDT1 = PF0MW01.PF0MWCL2;
    else
      if (PFCREC.PFCPCTC[1] == 5
       || PFCREC.PFCPCTC[1] == 6)
        PF0MM001.PF0MMDT1 = PF0MW01.PF0MWCL3;
        PF0MM002.PF0MMDT1 = PF0MW01.PF0MWCL3;
      else
        if (PFCREC.PFCPCTC[1] == 7
         || PFCREC.PFCPCTC[1] == 8)
          PF0MM001.PF0MMDT1 = PF0MW01.PF0MWCL4;
          PF0MM002.PF0MMDT1 = PF0MW01.PF0MWCL4;
        else
          if (PFCREC.PFCPCTC[1] == 9
           || PFCREC.PFCPCTC[1] == 10)
            PF0MM001.PF0MMDT1 = PF0MW01.PF0MWCL5;
            PF0MM002.PF0MMDT1 = PF0MW01.PF0MWCL5;
          end
        end
      end
    end
  end
  ;
  if (PFCREC.PFCPCTC[2] == 1 /* move 'as % of' dt/tp fields to maps*/
   || PFCREC.PFCPCTC[2] == 2)
    PF0MM001.PF0MMDT3 = PF0MW01.PF0MWCL1;
    PF0MM002.PF0MMDT3 = PF0MW01.PF0MWCL1;
  else
    if (PFCREC.PFCPCTC[2] == 3
     || PFCREC.PFCPCTC[2] == 4)
      PF0MM001.PF0MMDT3 = PF0MW01.PF0MWCL2;
      PF0MM002.PF0MMDT3 = PF0MW01.PF0MWCL2;
    else
      if (PFCREC.PFCPCTC[2] == 5
       || PFCREC.PFCPCTC[2] == 6)
        PF0MM001.PF0MMDT3 = PF0MW01.PF0MWCL3;
        PF0MM002.PF0MMDT3 = PF0MW01.PF0MWCL3;
      else
        if (PFCREC.PFCPCTC[2] == 6
         || PFCREC.PFCPCTC[2] == 7)
          PF0MM001.PF0MMDT3 = PF0MW01.PF0MWCL4;
          PF0MM002.PF0MMDT3 = PF0MW01.PF0MWCL4;
        else
          if (PFCREC.PFCPCTC[2] == 9
           || PFCREC.PFCPCTC[2] == 10)
            PF0MM001.PF0MMDT3 = PF0MW01.PF0MWCL5;
            PF0MM002.PF0MMDT3 = PF0MW01.PF0MWCL5;
          end
        end
      end
    end
  end
  ;
  if (PFCREC.PFCPCTC[3] == 1 /* move 'as % of' dt/tp fields to maps*/
   || PFCREC.PFCPCTC[3] == 2)
    PF0MM001.PF0MMDT2 = PF0MW01.PF0MWCL1;
    PF0MM002.PF0MMDT2 = PF0MW01.PF0MWCL1;
  else
    if (PFCREC.PFCPCTC[3] == 3
     || PFCREC.PFCPCTC[3] == 4)
      PF0MM001.PF0MMDT2 = PF0MW01.PF0MWCL2;
      PF0MM002.PF0MMDT2 = PF0MW01.PF0MWCL2;
    else
      if (PFCREC.PFCPCTC[3] == 5
       || PFCREC.PFCPCTC[3] == 6)
        PF0MM001.PF0MMDT2 = PF0MW01.PF0MWCL3;
        PF0MM002.PF0MMDT2 = PF0MW01.PF0MWCL3;
      else
        if (PFCREC.PFCPCTC[3] == 7
         || PFCREC.PFCPCTC[3] == 8)
          PF0MM001.PF0MMDT2 = PF0MW01.PF0MWCL4;
          PF0MM002.PF0MMDT2 = PF0MW01.PF0MWCL4;
        else
          if (PFCREC.PFCPCTC[3] == 9
           || PFCREC.PFCPCTC[3] == 10)
            PF0MM001.PF0MMDT2 = PF0MW01.PF0MWCL5;
            PF0MM002.PF0MMDT2 = PF0MW01.PF0MWCL5;
          end
        end
      end
    end
  end
  ;
  if (PFCREC.PFCPCTC[4] == 1 /* move 'as % of' dt/tp fields to maps*/
   || PFCREC.PFCPCTC[4] == 2)
    PF0MM001.PF0MMDT4 = PF0MW01.PF0MWCL1;
    PF0MM002.PF0MMDT4 = PF0MW01.PF0MWCL1;
  else
    if (PFCREC.PFCPCTC[4] == 3
     || PFCREC.PFCPCTC[4] == 4)
      PF0MM001.PF0MMDT4 = PF0MW01.PF0MWCL2;
      PF0MM002.PF0MMDT4 = PF0MW01.PF0MWCL2;
    else
      if (PFCREC.PFCPCTC[4] == 5
       || PFCREC.PFCPCTC[4] == 6)
        PF0MM001.PF0MMDT4 = PF0MW01.PF0MWCL3;
        PF0MM002.PF0MMDT4 = PF0MW01.PF0MWCL3;
      else
        if (PFCREC.PFCPCTC[4] == 7
         || PFCREC.PFCPCTC[4] == 8)
          PF0MM001.PF0MMDT4 = PF0MW01.PF0MWCL4;
          PF0MM002.PF0MMDT4 = PF0MW01.PF0MWCL4;
        else
          if (PFCREC.PFCPCTC[4] == 9
           || PFCREC.PFCPCTC[4] == 10)
            PF0MM001.PF0MMDT4 = PF0MW01.PF0MWCL5;
            PF0MM002.PF0MMDT4 = PF0MW01.PF0MWCL5;
          end
        end
      end
    end
  end
  ;
  PF0MW01.PF0MWSTL = PF1REC.PF1STLVL; /* move passed starting inquiry*/
  PF0MW01.PF0MWSTS = PF1REC.PF1STSEQ; /* to hold db2 keys*/
  ;
  PFWREC.PFWSUB1 = 1; /* initialize subscript*/
  ;
  PF0M200(); /* routine to access summary file, load to w/s table*/
  ;
  PF0MW01.PF0MWDSP = PF1REC.PF1DISP; /* save display type*/
  ;
  PFWREC.PFWSUB1 = 1; /* initialize subscripts*/
  PFWREC.PFWSUB2 = 1;
  ;
  PF0M300(); /* determine display type*/
  ;
  PFWREC.PFWERRF = "N";
  ;
  PF0MW01.PF0MWLEF = "Y"; /* set map switch to display left side*/
  PF0MW01.PF0MWRIG = "N";
end // end PF0M001

// main converse logic loop
Function PF0M100()
   /* ****************************************************/
   /* *  this process will determine whether the left   **/
   /* *  or right display map is to be conversed and    **/
   /* *  will perform the appropriate converse routine. **/
   /* *  after conversing, the routine will check pf    **/
   /* *  keys for the next function to process.         **/
   /* ****************************************************/
  ;
  if (PF0MW01.PF0MWLEF == "Y") /* converse left side map*/
    PF0MM001.PF0MMPFK = PF0MW01.PF0MWPFK; /* move pf18,pf19 keys to map*/
    PF0M120();
    PF0MW01.PF0MWPFK = PF0MM001.PF0MMPFK; /* store pf18,pf19 values*/
  end
  ;
  if (PF0MW01.PF0MWRIG == "Y") /* converse right side map*/
    PF0MM002.PF0MMPFK = PF0MW01.PF0MWPFK; /* move pf18,pf19 keys to map*/
    PF0M130();
    PF0MW01.PF0MWPFK = PF0MM002.PF0MMPFK; /* store pf18,pf19 values*/
  end
  ;
  PF0M110(); /* check pf keys*/
end // end PF0M100

// check pf keys
Function PF0M110()
   /* *****************************************************/
   /* *  this process will check the pf keys entered by  **/
   /* *  the user and will take the appropriate course   **/
   /* *  of action.                                      **/
   /* *****************************************************/
  ;
  if (converseVar.eventKey is pf3) /* return to 'pf0b' application*/
    PF1REC.PFDCDVAL[1] = PF0MM001.PF0MMAVD[1];
    PF1REC.PFDCDVAL[2] = PF0MM001.PF0MMAVD[2];
    PF1REC.PFDCDVAL[3] = PF0MM001.PF0MMAVD[3];
    PF1REC.PFDCDVAL[4] = PF0MM001.PF0MMAVD[4];
    PF1REC.PFDCDVAL[5] = PF0MM001.PF0MMAVD[5];
    PF1REC.PFDCDVAL[6] = PF0MM001.PF0MMAVD[6];
    PF1REC.PFDCDVAL[7] = PF0MM001.PF0MMAVD[7];
    COMMAREA.CAUSERA = PF1REC.PF1PASS;
    COMMAREA.CATOAP = "PF0B";
    XSEXIT();
    PFWREC.PFWMSG = COMMAREA.CAMSG; /* handle a bad pass*/
    PFWREC.PFWERRF = "Y";
    return;
  end
  ;
  set PFAREC empty;
  set SQLCA empty;
  ;
  call "IO2670" ("S ", SQLCA, PFAREC) {isNoRefresh = yes, isExternal = yes}; /* access vpfctl01 table*/
  ;
  if (SQLCA.VAGen_SQLCODE == +0) /* if control rec. found continue with*/
                                   /* the process*/
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
    TA1REC.TA1TBLVU = "VPFCTL01";
    TA1REC.TA1TBLKE = PF1REC.PFESUMNM;
    TA1REC.TA1LOCAT[3] = "PF0M110";
    TA1REC.TA1LOCAT[4] = "IO2670";
    XPPF010();
  end
  ;
  if (PFAREC.PFASTBLF == "Y") /* if the summary file is locked due to an*/
    PFWREC.PFWERRF = "Y"; /* db2 batch load, send user a message*/
    converseLib.validationFailed(223);
    return;
  end
  ;
  if (converseVar.eventKey is pf5) /* move up a level*/
    PF0MW01.PF0MWSTL = PF0MW01.PF0MWSTL - 1;
    if (PF0MWSTL < 0)
      PFWREC.PFWERRF = "Y";
      converseLib.validationFailed(218);
      return;
    end
    PF0M260(); /* access vsumry01 table*/
    if (SQLCA.VAGen_SQLCODE == +100)
                                   /* if there are no more levels to go up,*/
      PFWREC.PFWERRF = "Y"; /* send user a message*/
      converseLib.validationFailed(218);
      PF0MW01.PF0MWSTL = PF0MW01.PF0MWSTL + 1; /* restore viewing level*/
      return;
    end
    PF0M200();
    PFWSUB1 = 1;
    PF0M300(); /* move w/s items to display screen*/
    return;
  end
  ;
  if (converseVar.eventKey is pf6) /* move down a level*/
    PF0MW01.PF0MWSTL = PF0MW01.PF0MWSTL + 1;
    if (PF0MWSTL > 8)
      PFWREC.PFWERRF = "Y";
      converseLib.validationFailed(219);
      return;
    end
    PF0M200(); /* access vsumry01 table*/
    if (SQLCA.VAGen_SQLCODE == +100) /* if the row was not found,*/
      PFWREC.PFWERRF = "Y"; /* send the user a message*/
      converseLib.validationFailed(251);
      PF0MW01.PF0MWSTL = PF0MW01.PF0MWSTL - 1; /* restore viewing level*/
      return;
    end
    PFWSUB1 = 1;
    PF0M300(); /* move w/s items to display screen*/
    return;
  end
  ;
  if (converseVar.eventKey is pf7 /* user can't scroll when a 'sum' is displayed*/
   && PF0MW01.PF0MWDSP == "SUM") 
    PFWREC.PFWERRF = "Y";
    converseLib.validationFailed(225);
    return;
  end
  ;
  if (converseVar.eventKey is pf7) /* scroll up within current summary*/
    if (PF0MW01.PF0MWDSP == "DET")
      PFWSUB1 = PFWREC.PFWSAVDX;
      PFWSUB1 = PFWSUB1 - 1;
      PF0M350();
      return;
    end
    if (PF0MW01.PF0MWDSP == "EXP")
      PFWSUB1 = PFWREC.PFWSAVDX;
      PFWSUB1 = PFWSUB1 - 1;
      PF0M360();
      return;
    end
  end
  ;
  if (converseVar.eventKey is pf8 /* user can't scroll when a 'sum' is displayed*/
   && PF0MW01.PF0MWDSP == "SUM") 
    PFWREC.PFWERRF = "Y";
    converseLib.validationFailed(225);
    return;
  end
  ;
  if (converseVar.eventKey is pf8) /* scroll down within current summary*/
    if (PFWNXTDX > PFWLIMIT)
                                   /* if user can't scroll forward anymore,*/
      PFWREC.PFWERRF = "Y"; /* send a message*/
      converseLib.validationFailed(032);
      return;
    end
    move PFWNXTDX to PFWSUB1 withV60Compat; /* set starting display subscript*/
    PF0M300();
    return;
    ;
  end
  ;
  if (converseVar.eventKey is pf10) /* shift to left-side map*/
    if (PF0MW01.PF0MWLEF == "N")
      PF0MW01.PF0MWLEF = "Y"; /* set map display indicator to left*/
      PF0MW01.PF0MWRIG = "N";
      return;
    else
      PFWREC.PFWERRF = "Y"; /* can't shift left if already on left*/
                                   /* map*/
      converseLib.validationFailed(198);
      return;
    end
  end
  ;
  if (converseVar.eventKey is pf11) /* shift to right-side map*/
    if (PF0MW01.PF0MWRIG == "N")
      PF0MW01.PF0MWRIG = "Y"; /* set map display indicator to right*/
      PF0MW01.PF0MWLEF = "N";
      return;
    else
      PFWREC.PFWERRF = "Y"; /* can't shift right if already on right map*/
      converseLib.validationFailed(192);
      return;
    end
  end
  ;
  if (converseVar.eventKey is pf18) /* user requested a change in display type*/
    PF0MW01.PF0MWHDP = PF0MW01.PF0MWDP1;
                                   /* switch pf key display type*/
    PF0MW01.PF0MWDP1 = PF0MW01.PF0MWDSP; /* with current display type*/
    PF0MW01.PF0MWDSP = PF0MW01.PF0MWHDP;
                                   /* and display maps from same*/
    PF1REC.PF1DISP = PF0MW01.PF0MWDSP;
    if (PF0MW01.PF0MWDSP == "SUM")
       /* (sum,det,exp). move appropriate title heading to maps.*/
      PF0MM001.PF0MMLIT = "SUMMARY FILE SUMMARY VIEW";
      PF0MM002.PF0MMLIT = "SUMMARY FILE SUMMARY VIEW";
    else
      if (PF0MW01.PF0MWDSP == "DET")
        PFWREC.PFWSUB1 = PFWREC.PFWSAVDX;
        PF0MM001.PF0MMLIT = "SUMMARY FILE DETAIL VIEW";
        PF0MM002.PF0MMLIT = "SUMMARY FILE DETAIL VIEW";
      else
        if (PF0MW01.PF0MWDSP == "EXP")
          PFWREC.PFWSUB1 = PFWREC.PFWSAVDX;
          PF0MM001.PF0MMLIT = "SUMMARY FILE EXPLODED VIEW";
          PF0MM002.PF0MMLIT = "SUMMARY FILE EXPLODED VIEW";
        end
      end
    end
    if (PF0MW01.PF0MWHDP == "SUM"
     || PF0MW01.PF0MWDSP == "SUM")
      PFWREC.PFWSAVDX = 1;
      PFWREC.PFWSUB1 = 1;
    end
    PF0M300();
    return;
  end
  ;
  if (converseVar.eventKey is pf19) /* user requested a change in display type*/
    PF0MW01.PF0MWHDP = PF0MW01.PF0MWDP2;
                                   /* switch pf key display type*/
    PF0MW01.PF0MWDP2 = PF0MW01.PF0MWDSP; /* with current display type*/
    PF0MW01.PF0MWDSP = PF0MW01.PF0MWHDP;
                                   /* and display maps from same*/
    PF1REC.PF1DISP = PF0MW01.PF0MWDSP;
    if (PF0MW01.PF0MWDSP == "SUM")
       /* (sum,det,exp). move appropriate title heading to maps.*/
      PF0MM001.PF0MMLIT = "SUMMARY FILE SUMMARY VIEW";
      PF0MM002.PF0MMLIT = "SUMMARY FILE SUMMARY VIEW";
    else
      if (PF0MW01.PF0MWDSP == "DET")
        PFWREC.PFWSUB1 = PFWREC.PFWSAVDX;
        PF0MM001.PF0MMLIT = "SUMMARY FILE DETAIL VIEW";
        PF0MM002.PF0MMLIT = "SUMMARY FILE DETAIL VIEW";
      else
        if (PF0MW01.PF0MWDSP == "EXP")
          PFWREC.PFWSUB1 = PFWREC.PFWSAVDX;
          PF0MM001.PF0MMLIT = "SUMMARY FILE EXPLODED VIEW";
          PF0MM002.PF0MMLIT = "SUMMARY FILE EXPLODED VIEW";
        end
      end
    end
    if (PF0MW01.PF0MWHDP == "SUM"
     || PF0MW01.PF0MWDSP == "SUM")
      PFWREC.PFWSAVDX = 1;
      PFWREC.PFWSUB1 = 1;
    end
    PF0M300();
    return;
  end
  ;
  if (converseVar.eventKey is pf20) /* move up within a level*/
    if (PF0MWSTS == 1) /* no more summaries within this level*/
      PFWREC.PFWERRF = "Y";
      converseLib.validationFailed(220);
      return;
    end
    PF0M260(); /* access vsumry01 table*/
    if (SQLCA.VAGen_SQLCODE == +100) /* if the row was not found,*/
      PFWREC.PFWERRF = "Y"; /* send the user a message*/
      converseLib.validationFailed(220);
      return;
    end
    PF0MW01.PF0MWFL2 = PF0MW01.PF0MWFL1;
    PF0M200(); /* read vsumry01/store rows in w/s area*/
    PF0M270(); /* see if hierarchy changed*/
    PFWSUB1 = 1;
    PF0M300(); /* move w/s items to display screen*/
    return;
  end
  ;
  if (converseVar.eventKey is pf21) /* move down within a level*/
    PF0MW01.PF0MWSTS = PF0MW01.PF0MWSTS + 1;
    PF0MW01.PF0MWFL2 = PF0MW01.PF0MWFL1;
    PF0M200(); /* access vsumry01 table*/
    if (SQLCA.VAGen_SQLCODE == +100) /* if the row was not found,*/
      PFWREC.PFWERRF = "Y"; /* send the user a message*/
      converseLib.validationFailed(220);
      PF0MW01.PF0MWSTS = PF0MW01.PF0MWSTS - 1;
      return;
    end
    PF0M270(); /* see if hierarchy changed*/
    PFWSUB1 = 1;
    PF0M300(); /* move w/s items to display screen*/
    ;
    return;
  end
  ;
  converseLib.validationFailed(001); /* invalid key was entered*/
  PFWREC.PFWERRF = "Y";
end // end PF0M110

// converse left side map
Function PF0M120()
   /* ********************************************************/
   /* *  the sole function of this process is to converse   **/
   /* *  the left side of the summary displays.             **/
   /* ********************************************************/
  ;
  set PF0MM001.XXXCURDT cursor;
  ;
  converse PF0MM001 ;
  ;
end // end PF0M120

// converse right side map
Function PF0M130()
   /* ********************************************************/
   /* *  the sole function of this process is to converse   **/
   /* *  the right side of the summary displays.            **/
   /* ********************************************************/
  ;
  set PF0MM001.XXXCURDT cursor;
  ;
  converse PF0MM002 ;
  ;
end // end PF0M130

// access vsumry01 table
Function PF0M200()
   /* ***********************************************************/
   /* *  this process will access the vsumry01 table using     **/
   /* *  the summary name, summary level, and summary sequence **/
   /* *  number as db2 keys.*/
   /* ***********************************************************/
  ;
  set PFGREC empty;
  set SQLCA empty;
  PFGREC.PFESUMNM = PFEREC.PFESUMNM; /* move summary name to db2 key*/
  PFGREC.PFGSUMN = PFEREC.PFGSUMN; /* move summary # to db2 key*/
  PFGREC.PFGLVLNO = PF0MW01.PF0MWSTL; /* move level # to db2 key*/
  PFGREC.PFGLVLSQ = PF0MW01.PF0MWSTS; /* move level seq # to db2 key*/
  ;
  call "IO2920" ("S1", SQLCA, PFGREC) {isNoRefresh = yes, isExternal = yes}; /* open vsumry01 cursor*/
  ;
  if (SQLCA.VAGen_SQLCODE == +0) /* if cursor open ok, continue with the process*/
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
    TA1REC.TA1TBLVU = "VSUMRY01";
    TA1REC.TA1TBLKE = PF1REC.PFESUMNM;
    TA1REC.TA1LOCAT[3] = "PF0M200";
    TA1REC.TA1LOCAT[4] = "IO2920";
    XPPF010();
  end
  ;
  ;
  set PFGREC empty;
  set SQLCA empty;
  ;
  call "IO2920" ("N1", SQLCA, PFGREC) {isNoRefresh = yes, isExternal = yes}; /* access vsumry01 table*/
  ;
  if (SQLCA.VAGen_SQLCODE == +0) /* if cursor open ok, continue with the process*/
    PF0MW01.PF0MWSTS = PFGREC.PFGLVLSQ; /* save seq. #*/
    PF0MW01.PF0MWSTL = PFGREC.PFGLVLNO;
    PF0MW01.PF0MWCD1 = PFGREC.PFDCDVAL[1];
    PF0MW01.PF0MWCD2 = PFGREC.PFDCDVAL[2];
    PF0MW01.PF0MWCD3 = PFGREC.PFDCDVAL[3];
    PF0MW01.PF0MWCD4 = PFGREC.PFDCDVAL[4];
    PF0MW01.PF0MWCD5 = PFGREC.PFDCDVAL[5];
    PF0MW01.PF0MWCD6 = PFGREC.PFDCDVAL[6];
    PF0MW01.PF0MWCD7 = PFGREC.PFDCDVAL[7];
  else
    if (SQLCA.VAGen_SQLCODE == +100)
      return;
    else
      TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
      TA1REC.TA1TBLVU = "VSUMRY01";
      TA1REC.TA1TBLKE = PF1REC.PFESUMNM;
      TA1REC.TA1LOCAT[3] = "PF0M200";
      TA1REC.TA1LOCAT[4] = "IO2920";
      XPPF010();
    end
  end
  ;
  ;
  PF0M210(); /* perform routine to get attribute literals*/
  ;
  ;
  set PF0MW02 empty;
  PFWSUB1 = 1;
  while (PFGREC.PFGLVLSQ == PF0MW01.PF0MWSTS
   && PFWSUB1 <= 500)
    ;
    PF0M220(); /* move summary rows to w/s area*/
    ;
    set SQLCA empty;
    set PFGREC empty;
    ;
    call "IO2920" ("N1", SQLCA, PFGREC) {isNoRefresh = yes, isExternal = yes}; /* get next vsumry01*/
    ;
    if (SQLCA.VAGen_SQLCODE == +0) /* if a row is found, continue with the process*/
       /* next sentence*/
    else
      if (SQLCA.VAGen_SQLCODE == +100) /* if a row isn't found, loop will terminate*/
        PFGREC.PFGLVLSQ = 9999; /* set condition to end loop*/
      else
        TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
        TA1REC.TA1TBLVU = "VSUMRY01";
        TA1REC.TA1TBLKE = PF1REC.PFESUMNM;
        TA1REC.TA1LOCAT[3] = "PF0M200";
        TA1REC.TA1LOCAT[4] = "IO2920";
        XPPF010();
      end
    end
    PFWSUB1 = PFWSUB1 + 1;
  end
  ;
  if (PFWSUB1 > 500)
    TA1REC.TA1TYPE = "APPL"; /* error type*/
    TA1REC.TA1FUNC = "RETN"; /* termination function*/
    TA1REC.TA1PGMNM = "PF0M"; /* program name*/
    TA1REC.TA1LOC = "PF0MW02 TBL OVERFLOW - PF0M200";
    SQLCA.SQLCAREC = " "; /* error information*/
    ;
    call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes}; /* error diagnostic routine*/
    ;
    COMMAREA.CAUSERA = " "; /* clear user commarea*/
    XSPF4(); /* master menu*/
    exit program; /* master menu failure*/
  end
  ;
  ;
  PFWREC.PFWLIMIT = PFWSUB1 - 1; /* set maximum index on w/s area*/
  ;
  ;
  PFWSUB1 = 1; /* initialize subscript*/
  while (PFWSUB1 <= PFWLIMIT)
    ;
    PF0M240(); /* perform routine get i/s group*/
                                  /* literals*/
    PFWSUB1 = PFWSUB1 + 1;
  end
  ;
  ;
  set PFGREC empty;
  set SQLCA empty;
  ;
  call "IO2920" ("C1", SQLCA, PFGREC) {isNoRefresh = yes, isExternal = yes}; /* close vsumry01 cursor*/
  ;
  if (SQLCA.VAGen_SQLCODE == +0) /* if cursor open ok, continue with the process*/
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
    TA1REC.TA1TBLVU = "VSUMRY01";
    TA1REC.TA1TBLKE = PF1REC.PFESUMNM;
    TA1REC.TA1LOCAT[3] = "PF0M200";
    TA1REC.TA1LOCAT[4] = "IO2920";
    XPPF010();
  end
  ;
end // end PF0M200

// determine attribute literals
Function PF0M210()
   /* ********************************************************/
   /* *  this process will determine the attribute field    **/
   /* *  literal for those attributes that are displayed    **/
   /* *  at the summary level to be viewed. the literal     **/
   /* *  be moved to the pf0mm001 screen fields from the    **/
   /* *  passed attribute descriptions in pf1rec.           **/
   /* ********************************************************/
  ;
  PFWSUB2 = 1;
  ;
  while (PFWSUB2 < 8) /* clear literals on maps*/
    PF0MM001.PF0MMAVD[PFWSUB2] = " ";
    PF0MM002.PF0MMAVD[PFWSUB2] = " ";
    PFWSUB2 = PFWSUB2 + 1;
  end
  ;
  PF0MM001.PF0MMSTY = " "; /* clear product literal on maps*/
  PF0MM002.PF0MMSTY = " ";
  PF0MM001.PF0MMPRD = " ";
  PF0MM002.PF0MMPRD = " ";
  PF0MM001.PF0MMCLR = " ";
  PF0MM002.PF0MMCLR = " ";
  ;
  PF0MM001.PF0MMPLT = " ";
  PF0MM002.PF0MMPLT = " ";
  ;
  PFWSUB2 = 1;
  ;
  while (PFWSUB2 < 8) /* move rept. attr. literals to maps*/
    PF0MW01.PF0MWAV1 = PF1REC.PFISDESC[PFWSUB2];
    if (PF0MW01.PF0MWAV1 > " ")
      PF0MW01.PF0MWAV2 = " :";
    else
      PF0MW01.PF0MWAV2 = "  ";
    end
    PF0MM001.PF0MMACA[PFWSUB2] = PF0MW01.PF0MWAVA;
    PF0MM002.PF0MMACA[PFWSUB2] = PF0MW01.PF0MWAVA;
    PFWSUB2 = PFWSUB2 + 1;
  end
  ;
  if (PF1REC.PFISDESC[1] > " ") /* if any attributes below this one*/
    if (PFDREC.PFDVALFL[2] == "Y" /* have selected values, mark this*/
     || PFDREC.PFDVALFL[3] == "Y" /* attribute with a highlighted "p"*/
     || PFDREC.PFDVALFL[4] == "Y" /* to warn user of a partial summary.*/
     || PFDREC.PFDVALFL[5] == "Y" 
     || PFDREC.PFDVALFL[6] == "Y" 
     || PFDREC.PFDVALFL[7] == "Y" 
     || PFDREC.PFDVALFL[8] == "Y")
      PF0MM001.PF0MMIND[1] = "P";
      PF0MM002.PF0MMIND[1] = "P";
      set PF0MM001.PF0MMIND[1] bold;
      set PF0MM002.PF0MMIND[1] bold;
    else
      PF0MM001.PF0MMIND[1] = " ";
      PF0MM002.PF0MMIND[1] = " ";
      set PF0MM001.PF0MMIND[1] normal;
      set PF0MM002.PF0MMIND[1] normal;
    end
  end
  ;
  if (PF1REC.PFISDESC[2] > " ")
    if (PFDREC.PFDVALFL[3] == "Y"
     || PFDREC.PFDVALFL[4] == "Y"
     || PFDREC.PFDVALFL[5] == "Y"
     || PFDREC.PFDVALFL[6] == "Y"
     || PFDREC.PFDVALFL[7] == "Y"
     || PFDREC.PFDVALFL[8] == "Y")
      PF0MM001.PF0MMIND[2] = "P";
      PF0MM002.PF0MMIND[2] = "P";
      set PF0MM001.PF0MMIND[2] bold;
      set PF0MM002.PF0MMIND[2] bold;
    else
      PF0MM001.PF0MMIND[2] = " ";
      PF0MM002.PF0MMIND[2] = " ";
      set PF0MM001.PF0MMIND[2] normal;
      set PF0MM002.PF0MMIND[2] normal;
    end
  end
  ;
  if (PF1REC.PFISDESC[3] > " ")
    if (PFDREC.PFDVALFL[4] == "Y"
     || PFDREC.PFDVALFL[5] == "Y"
     || PFDREC.PFDVALFL[6] == "Y"
     || PFDREC.PFDVALFL[7] == "Y"
     || PFDREC.PFDVALFL[8] == "Y")
      PF0MM001.PF0MMIND[3] = "P";
      PF0MM002.PF0MMIND[3] = "P";
      set PF0MM001.PF0MMIND[3] bold;
      set PF0MM002.PF0MMIND[3] bold;
    else
      PF0MM001.PF0MMIND[3] = " ";
      PF0MM002.PF0MMIND[3] = " ";
      set PF0MM001.PF0MMIND[3] normal;
      set PF0MM002.PF0MMIND[3] normal;
    end
  end
  ;
  if (PF1REC.PFISDESC[4] > " ")
    if (PFDREC.PFDVALFL[5] == "Y"
     || PFDREC.PFDVALFL[6] == "Y"
     || PFDREC.PFDVALFL[7] == "Y"
     || PFDREC.PFDVALFL[8] == "Y")
      PF0MM001.PF0MMIND[4] = "P";
      PF0MM002.PF0MMIND[4] = "P";
      set PF0MM001.PF0MMIND[4] bold;
      set PF0MM002.PF0MMIND[4] bold;
    else
      PF0MM001.PF0MMIND[4] = " ";
      PF0MM002.PF0MMIND[4] = " ";
      set PF0MM001.PF0MMIND[4] normal;
      set PF0MM002.PF0MMIND[4] normal;
    end
  end
  ;
  if (PF1REC.PFISDESC[5] > " ")
    if (PFDREC.PFDVALFL[6] == "Y"
     || PFDREC.PFDVALFL[7] == "Y"
     || PFDREC.PFDVALFL[8] == "Y")
      PF0MM001.PF0MMIND[5] = "P";
      PF0MM002.PF0MMIND[5] = "P";
      set PF0MM001.PF0MMIND[5] bold;
      set PF0MM002.PF0MMIND[5] bold;
    else
      PF0MM001.PF0MMIND[5] = " ";
      PF0MM002.PF0MMIND[5] = " ";
      set PF0MM001.PF0MMIND[5] normal;
      set PF0MM002.PF0MMIND[5] normal;
    end
  end
  ;
  if (PF1REC.PFISDESC[6] > " ")
    if (PFDREC.PFDVALFL[7] == "Y"
     || PFDREC.PFDVALFL[8] == "Y")
      PF0MM001.PF0MMIND[6] = "P";
      PF0MM002.PF0MMIND[6] = "P";
      set PF0MM001.PF0MMIND[6] bold;
      set PF0MM002.PF0MMIND[6] bold;
    else
      PF0MM001.PF0MMIND[6] = " ";
      PF0MM002.PF0MMIND[6] = " ";
      set PF0MM001.PF0MMIND[6] normal;
      set PF0MM002.PF0MMIND[6] normal;
    end
  end
  ;
  if (PF1REC.PFISDESC[7] > " ")
    if (PFDREC.PFDVALFL[8] == "Y")
      PF0MM001.PF0MMIND[7] = "P";
      PF0MM002.PF0MMIND[7] = "P";
      set PF0MM001.PF0MMIND[7] bold;
      set PF0MM002.PF0MMIND[7] bold;
    else
      PF0MM001.PF0MMIND[7] = " ";
      PF0MM002.PF0MMIND[7] = " ";
      set PF0MM001.PF0MMIND[7] normal;
      set PF0MM002.PF0MMIND[7] normal;
    end
  end
  ;
  ;
  PF0MM001.PF0MMPLT = PF1REC.PFIDESC[8];
  PF0MM002.PF0MMPLT = PF1REC.PFIDESC[8];
  ;
  PFWREC.XGPCD = PFGREC.XGPCD;
  PFWREC.SY1STNBR = PFGREC.SY1STNBR;
  PFWREC.SY2CLRID = PFGREC.SY2CLRID;
  PFWREC.XDMCD = PFGREC.XDMCD;
  PFWREC.XQACD = PFGREC.XQACD;
  PFWREC.XLCCD = PFGREC.XLCCD;
  PFWREC.PFDCDVAL[1] = PFGREC.PFDCDVAL[1];
  PFWREC.PFDCDVAL[2] = PFGREC.PFDCDVAL[2];
  PFWREC.PFDCDVAL[3] = PFGREC.PFDCDVAL[3];
  PFWREC.PFDCDVAL[4] = PFGREC.PFDCDVAL[4];
  PFWREC.PFDCDVAL[5] = PFGREC.PFDCDVAL[5];
  PFWREC.PFDCDVAL[6] = PFGREC.PFDCDVAL[6];
  PFWREC.PFDCDVAL[7] = PFGREC.PFDCDVAL[7];
  ;
  if (PFWREC.XGPCD > " ") /* move product attribute desc. to map*/
    PFWIDX = 8;
    PFWREC.PFWPRDAT = PFDREC.PFICD[8];
    XPPF020(); /* perform generic product routine to*/
                                   /* move product*/
    PF0MW01.XGPCD = PFWREC.XGPCD;
    PF0MW01.SY1STNBR = PFWREC.SY1STNBR;
    PF0MW01.SY2CLRID = PFWREC.SY2CLRID;
    PF0MW01.XDMCD = PFWREC.XDMCD;
    PF0MW01.XQACD = PFWREC.XQACD;
    PF0MW01.XLCCD = PFWREC.XLCCD;
    PF0MW01.PF0MWF6 = "/";
    PF0MW01.PF0MWF7 = "/";
    PF0MW01.PF0MWF8 = "/";
    PF0MW01.PF0MWF9 = "/";
    PF0MW01.PF0MWF10 = "/";
    PF0MM001.PF0MMSTY = PF0MW01.PF0MWSTY;
    PF0MM002.PF0MMSTY = PF0MW01.PF0MWSTY;
    PF0MM001.PF0MMPRD = PFWREC.PFWDESC[8];
    PF0MM002.PF0MMPRD = PFWREC.PFWDESC[8];
    PF0MM001.PF0MMCLR = PFWREC.SY2CLRAB;
    PF0MM002.PF0MMCLR = PFWREC.SY2CLRAB;
  end
  ;
  PFWREC.PFWIDX = 7; /* initialize index*/
  ;
  while (PFWIDX > 0)
    if (PFWREC.PFDCDVAL[PFWIDX] > " ")
                                   /* if an attribute has data, move desc.*/
      PFWREC.PFWDESC[PFWIDX] = "NO DESC        ";
      XPPF430(); /* perform edit routine to get code*/
                                   /* value literal*/
      PF0MW01.PF0MWAD1 = PFGREC.PFDCDVAL[PFWIDX];
      PF0MW01.PF0MWAD2 = PFWREC.PFWDESC[PFWIDX];
      PF0MM001.PF0MMAVD[PFWIDX] = PF0MW01.PF0MWAVD; /* description to map*/
      PF0MM002.PF0MMAVD[PFWIDX] = PF0MW01.PF0MWAVD; /* description to map*/
    end
    PFWIDX = PFWIDX - 1;
  end
end // end PF0M210

// load summary info. to w/s area
Function PF0M220()
   /* ************************************************************/
   /* *  this process will load the summary rows from vsumry01  **/
   /* *  table to a w/s area, pf0mw02. pf0m will then display   **/
   /* *  the information in pf0mw02 on screens. first, the      **/
   /* *  process will determine what type of display record     **/
   /* *  the current summary row is and find the literal that   **/
   /* *  is used to describe the row. then, the dollar or %     **/
   /* *  columns are then stored. the valid record types are:   **/
   /* *  record #      description                              **/
   /* *  --------   ----------------------                      **/
   /* *     1       summary level items                         **/
   /* *     2       special summary level items(i.e. dirsg&a)   **/
   /* *     3       i/s group total items                       **/
   /* *     4       i/s group items                             **/
   /* *     5       ungrouped i/s items                         **/
   /* ************************************************************/
  ;
  if (PFWSUB1 == 3) /* setup third w/s entry for spaces to display*/
    PF0MW02.PF0MWLIT[PFWSUB1] = " ";
    PF0MW02.PF0MWTYP[PFWSUB1] = "1";
    PF0MW02.PF0MWC1[PFWSUB1] = 0;
    PF0MW02.PF0MWC2[PFWSUB1] = 0;
    PF0MW02.PF0MWC3[PFWSUB1] = 0;
    PF0MW02.PF0MWC4[PFWSUB1] = 0;
    PF0MW02.PF0MWC5[PFWSUB1] = 0;
    PF0MW02.PF0MWC6[PFWSUB1] = 0;
    PF0MW02.PF0MWC7[PFWSUB1] = 0;
    PF0MW02.PF0MWC8[PFWSUB1] = 0;
    PF0MW02.PF0MWC9[PFWSUB1] = 0;
    PF0MW02.PF0MWC10[PFWSUB1] = 0;
    PF0MW02.PF0MWC11[PFWSUB1] = 0;
    PF0MW02.PF0MWC12[PFWSUB1] = 0;
    PFWSUB1 = PFWSUB1 + 1;
  end
  ;
  if (PFGREC.YISCD[2] == 0) /* this is a summary level item*/
    if (PFGREC.YTYCD == "34"
     || PFGREC.YTYCD == "38") /* if it's a special summary level*/
      PF0MW02.PF0MWTYP[PFWSUB1] = "2"; /* set record type to 2*/
    else
      PF0MW02.PF0MWTYP[PFWSUB1] = "1";
    end
    PF0MW02.PF0MWIND[PFWSUB1] = " ";
    if (PFGREC.YTYCD in YTYTBL.YTYCD) /* move in summary literal*/
      PF0MW02.PF0MWABV[PFWSUB1] = YTYTBL.YTYSDESC[sysVar.arrayIndex];
    end
    PF0M230(); /* perform routine to move columnar*/
                                   /* info.*/
    return;
  end
  ;
  if (PFGREC.YISCD[1] == 0 /* this is an i/s grouped total item*/
   && PFGREC.YISCD[2] > 0)
    PF0MW02.PF0MWTYP[PFWSUB1] = "3";
    PF0MW02.YISCD[PFWSUB1] = PFGREC.YISCD[2];
    PF0MW02.YTYCD[PFWSUB1] = PFGREC.YTYCD;
    PF0MW02.PF0MWIND[PFWSUB1] = "*";
    PF0M230(); /* move columnar info. to pf0kw02 w/s area*/
    return;
  end
  ;
  if (PFGREC.PFBISGRP > 0 /* this is a grouped item*/
   && PFGREC.YISCD[1] > 0)
    PF0MW02.PF0MWTYP[PFWSUB1] = "4"; /* set record type to 4*/
    PF0MW02.YISCD[PFWSUB1] = PFGREC.YISCD[1];
    PF0MW02.PF0MWIND[PFWSUB1] = "-";
    if (PFGREC.YISCD[1] in YISTBL.YISCD)
      PF0MW02.PF0MWABV[PFWSUB1] = YISTBL.YISABRV[sysVar.arrayIndex];
    else
      PF0MW01.PF0MWDSC = "UNDEF. I/S ";
      PF0MW01.PF0MWCLS = PFGREC.YISCD[1];
      PF0MW02.PF0MWABV[PFWSUB1] = PF0MW01.PF0MWABV;
    end
    PF0M230(); /* perform routine to move columnar*/
                                   /* info.*/
    return;
  end
  ;
  if (PFGREC.PFBISGRP == 0) /* this is a ungrouped item*/
    PF0MW02.PF0MWTYP[PFWSUB1] = "5"; /* set record type to 5*/
    PF0MW02.PF0MWIND[PFWSUB1] = " ";
    if (PFGREC.YISCD[1] in YISTBL.YISCD)
      PF0MW02.PF0MWABV[PFWSUB1] = YISTBL.YISABRV[sysVar.arrayIndex];
    end
    PF0M230(); /* perform routine to move columnar*/
                                   /* info.*/
    return;
  end
end // end PF0M220

// move columnar data to w/s
Function PF0M230()
   /* *****************************************************/
   /* *  this process will move the thirteen columns of  **/
   /* *  unit/dollar/percentage information from pfgrec  **/
   /* *  to the pf0mw02 w/s area.                        **/
   /* *  if percentage fields overflow, move 999.9 to    **/
   /* *  positive overflows and -99.9 to negatives.      **/
   /* *****************************************************/
  if (PFGREC.YTYCD == "72"
   || PFGREC.YTYCD == "73")
    PF0MW01.PF0MWNUM = PFGREC.PFGQTY[1];
    if (PF0MW01.PF0MWNUM >= +999500.00)
      PF0MW02.PF0MWC1[PFWSUB1] = +999;
    else
      if (PF0MW01.PF0MWNUM <= -99500.00)
        PF0MW02.PF0MWC1[PFWSUB1] = -99;
      else
        PF0MW02.PF0MWC1[PFWSUB1] = mathLib.round(PF0MW01.PF0MWNUM * .001, -mathLib.decimals(PF0MW02.PF0MWC1[PFWSUB1]));
      end
    end
    PF0MW01.PF0MWNUM = PFGREC.PFGQTY[2];
    if (PF0MW01.PF0MWNUM >= +999.95)
      PF0MW02.PF0MWC2[PFWSUB1] = +999.99;
    else
      if (PF0MW01.PF0MWNUM <= -99.95)
        PF0MW02.PF0MWC2[PFWSUB1] = -99.99;
      else
        PF0MW02.PF0MWC2[PFWSUB1] = mathLib.round(PF0MW01.PF0MWNM2 * 1, -mathLib.decimals(PF0MW02.PF0MWC2[PFWSUB1]));
      end
    end
    PF0MW01.PF0MWNUM = PFGREC.PFGQTY[3];
    if (PF0MW01.PF0MWNUM >= +999500.00)
      PF0MW02.PF0MWC3[PFWSUB1] = +999;
    else
      if (PF0MW01.PF0MWNUM <= -99500.00)
        PF0MW02.PF0MWC3[PFWSUB1] = -99;
      else
        PF0MW02.PF0MWC3[PFWSUB1] = mathLib.round(PF0MW01.PF0MWNUM * .001, -mathLib.decimals(PF0MW02.PF0MWC3[PFWSUB1]));
      end
    end
    PF0MW01.PF0MWNUM = PFGREC.PFGQTY[4];
    if (PF0MW01.PF0MWNUM >= +999.95)
      PF0MW02.PF0MWC4[PFWSUB1] = +999.9;
    else
      if (PF0MW01.PF0MWNUM <= -99.95)
        PF0MW02.PF0MWC4[PFWSUB1] = -99.9;
      else
        PF0MW02.PF0MWC4[PFWSUB1] = mathLib.round(PF0MW01.PF0MWNM2 * 1, -mathLib.decimals(PF0MW02.PF0MWC4[PFWSUB1]));
      end
    end
    PF0MW01.PF0MWNUM = PFGREC.PFGQTY[5];
    if (PF0MW01.PF0MWNUM >= +999500.00)
      PF0MW02.PF0MWC5[PFWSUB1] = +999;
    else
      if (PF0MW01.PF0MWNUM <= -99500.00)
        PF0MW02.PF0MWC5[PFWSUB1] = -99;
      else
        PF0MW02.PF0MWC5[PFWSUB1] = mathLib.round(PF0MW01.PF0MWNUM * .001, -mathLib.decimals(PF0MW02.PF0MWC5[PFWSUB1]));
      end
    end
    PF0MW01.PF0MWNUM = PFGREC.PFGQTY[6];
    if (PF0MW01.PF0MWNUM >= +999.95)
      PF0MW02.PF0MWC6[PFWSUB1] = +999.9;
    else
      if (PF0MW01.PF0MWNUM <= -99.95)
        PF0MW02.PF0MWC6[PFWSUB1] = -99.9;
      else
        PF0MW02.PF0MWC6[PFWSUB1] = mathLib.round(PF0MW01.PF0MWNM2 * 1, -mathLib.decimals(PF0MW02.PF0MWC6[PFWSUB1]));
      end
    end
    PF0MW01.PF0MWNUM = PFGREC.PFGQTY[7];
    if (PF0MW01.PF0MWNUM >= +999500.00)
      PF0MW02.PF0MWC7[PFWSUB1] = +999;
    else
      if (PF0MW01.PF0MWNUM <= -99500.00)
        PF0MW02.PF0MWC7[PFWSUB1] = -99;
      else
        PF0MW02.PF0MWC7[PFWSUB1] = mathLib.round(PF0MW01.PF0MWNUM * .001, -mathLib.decimals(PF0MW02.PF0MWC7[PFWSUB1]));
      end
    end
    PF0MW01.PF0MWNUM = PFGREC.PFGQTY[8];
    if (PF0MW01.PF0MWNUM >= +999.95)
      PF0MW02.PF0MWC8[PFWSUB1] = +999.9;
    else
      if (PF0MW01.PF0MWNUM <= -99.95)
        PF0MW02.PF0MWC8[PFWSUB1] = -99.9;
      else
        PF0MW02.PF0MWC8[PFWSUB1] = mathLib.round(PF0MW01.PF0MWNM2 * 1, -mathLib.decimals(PF0MW02.PF0MWC8[PFWSUB1]));
      end
    end
    PF0MW01.PF0MWNUM = PFGREC.PFGQTY[9];
    if (PF0MW01.PF0MWNUM >= +999500.00)
      PF0MW02.PF0MWC9[PFWSUB1] = +999;
    else
      if (PF0MW01.PF0MWNUM <= -99500.00)
        PF0MW02.PF0MWC9[PFWSUB1] = -99;
      else
        PF0MW02.PF0MWC9[PFWSUB1] = mathLib.round(PF0MW01.PF0MWNUM * .001, -mathLib.decimals(PF0MW02.PF0MWC9[PFWSUB1]));
      end
    end
    PF0MW01.PF0MWNUM = PFGREC.PFGQTY[10];
    if (PF0MW01.PF0MWNUM >= +999.95)
      PF0MW02.PF0MWC10[PFWSUB1] = +999.9;
    else
      if (PF0MW01.PF0MWNUM <= -99.95)
        PF0MW02.PF0MWC10[PFWSUB1] = -99.9;
      else
        PF0MW02.PF0MWC10[PFWSUB1] = mathLib.round(PF0MW01.PF0MWNM2 * 1, -mathLib.decimals(PF0MW02.PF0MWC10[PFWSUB1]));
      end
    end
    PF0MW01.PF0MWNUM = PFGREC.PFGQTY[11];
    if (PF0MW01.PF0MWNUM >= +999.95)
      PF0MW02.PF0MWC11[PFWSUB1] = +999.9;
    else
      if (PF0MW01.PF0MWNUM <= -99.95)
        PF0MW02.PF0MWC11[PFWSUB1] = -99.9;
      else
        PF0MW02.PF0MWC11[PFWSUB1] = mathLib.round(PF0MW01.PF0MWNM2 * 1, -mathLib.decimals(PF0MW02.PF0MWC11[PFWSUB1]));
      end
    end
    PF0MW01.PF0MWNUM = PFGREC.PFGQTY[12];
    if (PF0MW01.PF0MWNUM >= +999.95)
      PF0MW02.PF0MWC12[PFWSUB1] = +999.9;
    else
      if (PF0MW01.PF0MWNUM <= -99.95)
        PF0MW02.PF0MWC12[PFWSUB1] = -99.9;
      else
        PF0MW02.PF0MWC12[PFWSUB1] = mathLib.round(PF0MW01.PF0MWNM2 * 1, -mathLib.decimals(PF0MW02.PF0MWC12[PFWSUB1]));
      end
    end
  else /* ****/
    PF0MW01.PF0MWNUM = PFGREC.PFGQTY[1];
    PF0MW02.PF0MWC1[PFWSUB1] = mathLib.round(PF0MW01.PF0MWNUM * .001, -mathLib.decimals(PF0MW02.PF0MWC1[PFWSUB1]));
    PF0MW01.PF0MWNUM = PFGREC.PFGQTY[2];
    if (PF0MW01.PF0MWNUM >= +999.95)
      PF0MW02.PF0MWC2[PFWSUB1] = +999.9;
    else
      if (PF0MW01.PF0MWNUM <= -99.95)
        PF0MW02.PF0MWC2[PFWSUB1] = -99.9;
      else
        PF0MW02.PF0MWC2[PFWSUB1] = mathLib.round(PF0MW01.PF0MWNM2 * 1, -mathLib.decimals(PF0MW02.PF0MWC2[PFWSUB1]));
      end
    end
    PF0MW01.PF0MWNUM = PFGREC.PFGQTY[3];
    PF0MW02.PF0MWC3[PFWSUB1] = mathLib.round(PF0MW01.PF0MWNUM * .001, -mathLib.decimals(PF0MW02.PF0MWC3[PFWSUB1]));
    PF0MW01.PF0MWNUM = PFGREC.PFGQTY[4];
    if (PF0MW01.PF0MWNUM >= +999.95)
      PF0MW02.PF0MWC4[PFWSUB1] = +999.9;
    else
      if (PF0MW01.PF0MWNUM <= -99.95)
        PF0MW02.PF0MWC4[PFWSUB1] = -99.9;
      else
        PF0MW02.PF0MWC4[PFWSUB1] = mathLib.round(PF0MW01.PF0MWNM2 * 1, -mathLib.decimals(PF0MW02.PF0MWC4[PFWSUB1]));
      end
    end
    PF0MW01.PF0MWNUM = PFGREC.PFGQTY[5];
    PF0MW02.PF0MWC5[PFWSUB1] = mathLib.round(PF0MW01.PF0MWNUM * .001, -mathLib.decimals(PF0MW02.PF0MWC5[PFWSUB1]));
    PF0MW01.PF0MWNUM = PFGREC.PFGQTY[6];
    if (PF0MW01.PF0MWNUM >= +999.95)
      PF0MW02.PF0MWC6[PFWSUB1] = +999.9;
    else
      if (PF0MW01.PF0MWNUM <= -99.95)
        PF0MW02.PF0MWC6[PFWSUB1] = -99.9;
      else
        PF0MW02.PF0MWC6[PFWSUB1] = mathLib.round(PF0MW01.PF0MWNM2 * 1, -mathLib.decimals(PF0MW02.PF0MWC6[PFWSUB1]));
      end
    end
    PF0MW01.PF0MWNUM = PFGREC.PFGQTY[7];
    PF0MW02.PF0MWC7[PFWSUB1] = mathLib.round(PF0MW01.PF0MWNUM * .001, -mathLib.decimals(PF0MW02.PF0MWC7[PFWSUB1]));
    PF0MW01.PF0MWNUM = PFGREC.PFGQTY[8];
    if (PF0MW01.PF0MWNUM >= +999.95)
      PF0MW02.PF0MWC8[PFWSUB1] = +999.9;
    else
      if (PF0MW01.PF0MWNUM <= -99.95)
        PF0MW02.PF0MWC8[PFWSUB1] = -99.9;
      else
        PF0MW02.PF0MWC8[PFWSUB1] = mathLib.round(PF0MW01.PF0MWNM2 * 1, -mathLib.decimals(PF0MW02.PF0MWC8[PFWSUB1]));
      end
    end
    PF0MW01.PF0MWNUM = PFGREC.PFGQTY[9];
    PF0MW02.PF0MWC9[PFWSUB1] = mathLib.round(PF0MW01.PF0MWNUM * .001, -mathLib.decimals(PF0MW02.PF0MWC9[PFWSUB1]));
    PF0MW01.PF0MWNUM = PFGREC.PFGQTY[10];
    if (PF0MW01.PF0MWNUM >= +999.95)
      PF0MW02.PF0MWC10[PFWSUB1] = +999.9;
    else
      if (PF0MW01.PF0MWNUM <= -99.95)
        PF0MW02.PF0MWC10[PFWSUB1] = -99.9;
      else
        PF0MW02.PF0MWC10[PFWSUB1] = mathLib.round(PF0MW01.PF0MWNM2 * 1, -mathLib.decimals(PF0MW02.PF0MWC10[PFWSUB1]));
      end
    end
    PF0MW01.PF0MWNUM = PFGREC.PFGQTY[11];
    if (PF0MW01.PF0MWNUM >= +999.95)
      PF0MW02.PF0MWC11[PFWSUB1] = +999.9;
    else
      if (PF0MW01.PF0MWNUM <= -99.95)
        PF0MW02.PF0MWC11[PFWSUB1] = -99.9;
      else
        PF0MW02.PF0MWC11[PFWSUB1] = mathLib.round(PF0MW01.PF0MWNM2 * 1, -mathLib.decimals(PF0MW02.PF0MWC11[PFWSUB1]));
      end
    end
    PF0MW01.PF0MWNUM = PFGREC.PFGQTY[12];
    if (PF0MW01.PF0MWNUM >= +999.95)
      PF0MW02.PF0MWC12[PFWSUB1] = +999.9;
    else
      if (PF0MW01.PF0MWNUM <= -99.95)
        PF0MW02.PF0MWC12[PFWSUB1] = -99.9;
      else
        PF0MW02.PF0MWC12[PFWSUB1] = mathLib.round(PF0MW01.PF0MWNM2 * 1, -mathLib.decimals(PF0MW02.PF0MWC12[PFWSUB1]));
      end
    end
  end
end // end PF0M230

// get i/s group descriptions
Function PF0M240()
   /* *********************************************************/
   /* *  this process will scan through the pf0mw02 storage  **/
   /* *  and will get the i/s group descriptions for all i/s **/
   /* *  group total entires in pf0mw02(record type  = 3).   **/
   /* *  the i/s group desc. will be obtained by using the   **/
   /* *  yiscd of the record immediately following the group **/
   /* *  total record. this yiscd is combined with the i/s   **/
   /* *  group ref. # as a data base key to access the i/s   **/
   /* *  group table.                                        **/
   /* *********************************************************/
  ;
  if (PF0MW02.PF0MWTYP[PFWSUB1] != "3") /* if the entry isn't a group total,*/
    return; /* exit the routine*/
  end
  ;
  PFWSUB2 = PFWSUB1 + 1; /* set subscript to entry immediately following*/
  ;
  if (PF0MW02.YTYCD[PFWSUB1] == "35" /* group '9999' in i/s type '35' is*/
   && PF0MW02.YISCD[PFWSUB1] == 9999)
                                   /* reserved for undefined i/s classes*/
    PF0MW02.PF0MWABV[PFWSUB1] = "UNDEF. I/S TOTAL";
    return;
  end
  ;
  set SQLCA empty;
  set PFBREC empty;
  PFBREC.PFBREF = PFEREC.PFBREF;
                                   /* setup to access i/s group table*/
  PFBREC.YISCD[1] = PF0MW02.YISCD[PFWSUB2];
  call "IO2710" ("S ", SQLCA, PFBREC) {isNoRefresh = yes, isExternal = yes}; /* access visgrp01 table*/
  if (SQLCA.VAGen_SQLCODE == +0) /* if record found, move i/s group desc. to*/
    PF0MW02.PF0MWABV[PFWSUB1] = PFBREC.PFBISDSC; /* w/s area*/
  else
    TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
    TA1REC.TA1TBLVU = "VISGRP01";
    PF0MW01.PF0MWABK = PFBREC.PFBREF;
    TA1REC.TA1TBLKE = PF0MW01.PF0MWABK;
    TA1REC.TA1LOCAT[3] = "PF0M240";
    TA1REC.TA1LOCAT[4] = "IO2710";
    XPPF010();
  end
end // end PF0M240

// access vsumry01 table
Function PF0M260()
   /* ***********************************************************/
   /* *  this process will access the vsumry01 table using     **/
   /* *  the summary name, summary level, and summary sequence **/
   /* *  number as db2 keys. this process will be used to read **/
   /* *  the summary file in a backwards direction and will    **/
   /* *  read the first record of the requested summary only.  **/
   /* *  the level and seq. # keys will then be used by        **/
   /* *  pf0m200 to read the summary in a normal manner.       **/
   /* ***********************************************************/
  ;
  set PFGREC empty;
  set SQLCA empty;
  ;
  PFGREC.PFESUMNM = PFEREC.PFESUMNM; /* move summary name to db2 key*/
  PFGREC.PFGSUMN = PFEREC.PFGSUMN; /* move summary # to db2 key*/
  PFGREC.PFGLVLNO = PF0MW01.PF0MWSTL; /* move level # to db2 key*/
  PFGREC.PFGLVLSQ = PF0MW01.PF0MWSTS; /* move level seq # to db2 key*/
  ;
  call "IO2920" ("SF", SQLCA, PFGREC) {isNoRefresh = yes, isExternal = yes};
                                   /* read vsumry01 select/first*/
  ;
  if (SQLCA.VAGen_SQLCODE == +0) /* if cursor open ok, continue with the process*/
    PF0MW01.PF0MWSTS = PFGREC.PFGLVLSQ; /* save seq. #*/
  else
    if (SQLCA.VAGen_SQLCODE == +100)
      return;
    else
      TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
      TA1REC.TA1TBLVU = "VSUMRY01";
      TA1REC.TA1TBLKE = PF1REC.PFESUMNM;
      TA1REC.TA1LOCAT[3] = "PF0M200";
      TA1REC.TA1LOCAT[4] = "IO2920";
      XPPF010();
    end
  end
  ;
end // end PF0M260

// check for hierarchy change
Function PF0M270()
   /* ********************************************************/
   /* *  this process will check the reporting attribute    **/
   /* *  values of the previous and current summaries that  **/
   /* *  were displayed as a result of a pf20 or pf21 key.  **/
   /* *  if the result of of either key is a change in the  **/
   /* *  reporting attributes hierarchy as described below, **/
   /* *  then a warning message is sent to the terminal     **/
   /* *  operator. in the following example, if the user is **/
   /* *  viewing the summary indicated as point a and       **/
   /* *  enters pf20 (move up within a level) to move to    **/
   /* *  point b, the hierarchy level of '003 non-tech      **/
   /* *  running' has been bypassed.                        **/
   /* *  02  running                                        **/
   /* *      002  tecnical running                          **/
   /* *           21  national                              **/
   /* *           22  major                                 **/
   /* *           23  regular   ---- point b                **/
   /* *      003  non-tech running                          **/
   /* *           21  national  ---- point a                **/
   /* *           22  major                                 **/
   /* *           23  regular                               **/
   /* *  05  basketball                                     **/
   /* ********************************************************/
  ;
  if (PF0MW01.PF0MWSTL == 8) /* find current level # and compare attributes*/
    if (PF0MW01.PF0MWCD7 != PF0MW01.PF0MWCV7) /* from one level lower*/
        /* if they don't match, send warning to user*/
      PF0MW01.PF0MWRN1 = "BKWD/FRWD MOVEMENT AT \"";
      PF0MW01.PF0MWRV1 = PF1REC.PFISDESC[8];
      PF0MW01.PF0MWRN2 = "\" LEVEL HAS CAUSED \"";
      PF0MW01.PF0MWRV2 = PF1REC.PFISDESC[7];
      PF0MW01.PF0MWRN3 = "\" VALUE TO CHANGE";
      PF0MM001.VAGen_EZEMSG = PF0MW01.PF0MWRN; /* move warning message*/
      PF0MM002.VAGen_EZEMSG = PF0MW01.PF0MWRN; /* to screen*/
    end
    return;
  end
  ;
  if (PF0MW01.PF0MWSTL == 7) /* find current level # and compare attributes*/
    if (PF0MW01.PF0MWCD6 != PF0MW01.PF0MWCV6) /* from one level lower*/
        /* if they don't match, send warning to user*/
      PF0MW01.PF0MWRN1 = "BKWD/FRWD MOVEMENT AT \"";
      PF0MW01.PF0MWRV1 = PF1REC.PFISDESC[7];
      PF0MW01.PF0MWRN2 = "\" LEVEL HAS CAUSED \"";
      PF0MW01.PF0MWRV2 = PF1REC.PFISDESC[6];
      PF0MW01.PF0MWRN3 = "\" VALUE TO CHANGE";
      PF0MM001.VAGen_EZEMSG = PF0MW01.PF0MWRN; /* move warning message*/
      PF0MM002.VAGen_EZEMSG = PF0MW01.PF0MWRN; /* to screen*/
    end
    return;
  end
  ;
  if (PF0MW01.PF0MWSTL == 6) /* find current level # and compare attributes*/
    if (PF0MW01.PF0MWCD5 != PF0MW01.PF0MWCV5) /* from one level lower*/
        /* if they don't match, send warning to user*/
      PF0MW01.PF0MWRN1 = "BKWD/FRWD MOVEMENT AT \"";
      PF0MW01.PF0MWRV1 = PF1REC.PFISDESC[6];
      PF0MW01.PF0MWRN2 = "\" LEVEL HAS CAUSED \"";
      PF0MW01.PF0MWRV2 = PF1REC.PFISDESC[5];
      PF0MW01.PF0MWRN3 = "\" VALUE TO CHANGE";
      PF0MM001.VAGen_EZEMSG = PF0MW01.PF0MWRN; /* move warning message*/
      PF0MM002.VAGen_EZEMSG = PF0MW01.PF0MWRN; /* to screen*/
    end
    return;
  end
  ;
  if (PF0MW01.PF0MWSTL == 5) /* find current level # and compare attributes*/
    if (PF0MW01.PF0MWCD4 != PF0MW01.PF0MWCV4) /* from one level lower*/
        /* if they don't match, send warning to user*/
      PF0MW01.PF0MWRN1 = "BKWD/FRWD MOVEMENT AT \"";
      PF0MW01.PF0MWRV1 = PF1REC.PFISDESC[5];
      PF0MW01.PF0MWRN2 = "\" LEVEL HAS CAUSED \"";
      PF0MW01.PF0MWRV2 = PF1REC.PFISDESC[4];
      PF0MW01.PF0MWRN3 = "\" VALUE TO CHANGE";
      PF0MM001.VAGen_EZEMSG = PF0MW01.PF0MWRN; /* move warning message*/
      PF0MM002.VAGen_EZEMSG = PF0MW01.PF0MWRN; /* to screen*/
    end
    return;
  end
  ;
  if (PF0MW01.PF0MWSTL == 4) /* find current level # and compare attributes*/
    if (PF0MW01.PF0MWCD3 != PF0MW01.PF0MWCV3) /* from one level lower*/
        /* if they don't match, send warning to user*/
      PF0MW01.PF0MWRN1 = "BKWD/FRWD MOVEMENT AT \"";
      PF0MW01.PF0MWRV1 = PF1REC.PFISDESC[4];
      PF0MW01.PF0MWRN2 = "\" LEVEL HAS CAUSED \"";
      PF0MW01.PF0MWRV2 = PF1REC.PFISDESC[3];
      PF0MW01.PF0MWRN3 = "\" VALUE TO CHANGE";
      PF0MM001.VAGen_EZEMSG = PF0MW01.PF0MWRN; /* move warning message*/
      PF0MM002.VAGen_EZEMSG = PF0MW01.PF0MWRN; /* to screen*/
    end
    return;
  end
  ;
  if (PF0MW01.PF0MWSTL == 3) /* find current level # and compare attributes*/
    if (PF0MW01.PF0MWCD2 != PF0MW01.PF0MWCV2) /* from one level lower*/
        /* if they don't match, send warning to user*/
      PF0MW01.PF0MWRN1 = "BKWD/FRWD MOVEMENT AT \"";
      PF0MW01.PF0MWRV1 = PF1REC.PFISDESC[3];
      PF0MW01.PF0MWRN2 = "\" LEVEL HAS CAUSED \"";
      PF0MW01.PF0MWRV2 = PF1REC.PFISDESC[2];
      PF0MW01.PF0MWRN3 = "\" VALUE TO CHANGE";
      PF0MM001.VAGen_EZEMSG = PF0MW01.PF0MWRN; /* move warning message*/
      PF0MM002.VAGen_EZEMSG = PF0MW01.PF0MWRN; /* to screen*/
    end
    return;
  end
  ;
  if (PF0MW01.PF0MWSTL == 2) /* find current level # and compare attributes*/
    if (PF0MW01.PF0MWCD1 != PF0MW01.PF0MWCV1) /* from one level lower*/
        /* if they don't match, send warning to user*/
      PF0MW01.PF0MWRN1 = "BKWD/FRWD MOVEMENT AT \"";
      PF0MW01.PF0MWRV1 = PF1REC.PFISDESC[2];
      PF0MW01.PF0MWRN2 = "\" LEVEL HAS CAUSED \"";
      PF0MW01.PF0MWRV2 = PF1REC.PFISDESC[1];
      PF0MW01.PF0MWRN3 = "\" VALUE TO CHANGE";
      PF0MM001.VAGen_EZEMSG = PF0MW01.PF0MWRN; /* move warning message*/
      PF0MM002.VAGen_EZEMSG = PF0MW01.PF0MWRN; /* to screen*/
    end
    return;
  end
  ;
end // end PF0M270

// display summary type
Function PF0M300()
   /* ************************************************************/
   /* *  this process will determine the type of summary a user **/
   /* *  is viewing and will perform the appropriate routine to **/
   /* *  move summary records to the maps. the routines are :   **/
   /* *  summary type     routine                               **/
   /* *  ------------     -------------                         **/
   /* *    'sum'          pf0m310                               **/
   /* *    'det'          pf0m320                               **/
   /* *    'exp'          pf0m330                               **/
   /* ************************************************************/
  ;
  if (PF0MW01.PF0MWDSP == "SUM") /* summary display*/
    PF0M310();
  else
    if (PF0MW01.PF0MWDSP == "DET") /* detail display*/
      PF0M320();
    else
      if (PF0MW01.PF0MWDSP == "EXP") /* explode display*/
        PF0M330();
      end
    end
  end
end // end PF0M300

// move 'summary' items to maps
Function PF0M310()
   /* ***************************************************/
   /* *   this process will move all 'summary' items   **/
   /* *   from pf0mw02 record to the maps. summary     **/
   /* *   items are identified by the field pf0mwtyp   **/
   /* *   being = 1. the summary display will use one  **/
   /* *   screen only; no scrolling will be allowed.   **/
   /* *   both the right side(pf0mm001) and the left   **/
   /* *   side(pf0mm002) of the display will be        **/
   /* *   loaded in this process. the user can scroll  **/
   /* *   right and left using pf10 and pf11.          **/
   /* ***************************************************/
  ;
  PF0M340(); /* clear maps of previous data*/
  ;
  PFWREC.PFWSAVDX = PFWREC.PFWSUB1; /* save first w/s position*/
  ;
  PFWSUB2 = 1;
  while (PFWSUB2 < 11) /* browse through pf0mw02 and move all*/
    if (PF0MW02.PF0MWTYP[PFWSUB1] == "1") /* summary records to the maps*/
      PF0MM001.PF0MMISD[PFWSUB2] = PF0MW02.PF0MWLIT[PFWSUB1];
      PF0MM002.PF0MMISD[PFWSUB2] = PF0MW02.PF0MWLIT[PFWSUB1];
      ;
      PF0MM001.PF0MMAM1[PFWSUB2] = PF0MW02.PF0MWC1[PFWSUB1];
      PF0MM001.PF0MMAM2[PFWSUB2] = PF0MW02.PF0MWC3[PFWSUB1];
      PF0MM001.PF0MMAM3[PFWSUB2] = PF0MW02.PF0MWC5[PFWSUB1];
      PF0MM001.PF0MMAM4[PFWSUB2] = PF0MW02.PF0MWC7[PFWSUB1];
      PF0MM001.PF0MMAM5[PFWSUB2] = PF0MW02.PF0MWC9[PFWSUB1];
      PF0MM001.PF0MMPC1[PFWSUB2] = PF0MW02.PF0MWC11[PFWSUB1];
      PF0MM001.PF0MMPC2[PFWSUB2] = PF0MW02.PF0MWC12[PFWSUB1];
      ;
      PF0MM002.PF0MMAM1[PFWSUB2] = PF0MW02.PF0MWC1[PFWSUB1];
      PF0MM002.PF0MMPC1[PFWSUB2] = PF0MW02.PF0MWC2[PFWSUB1];
      PF0MM002.PF0MMPC2[PFWSUB2] = PF0MW02.PF0MWC4[PFWSUB1];
      PF0MM002.PF0MMPC3[PFWSUB2] = PF0MW02.PF0MWC6[PFWSUB1];
      PF0MM002.PF0MMPC4[PFWSUB2] = PF0MW02.PF0MWC8[PFWSUB1];
      PF0MM002.PF0MMPC5[PFWSUB2] = PF0MW02.PF0MWC10[PFWSUB1];
      PF0MM002.PF0MMPC6[PFWSUB2] = PF0MW02.PF0MWC11[PFWSUB1];
      PF0MM002.PF0MMPC7[PFWSUB2] = PF0MW02.PF0MWC12[PFWSUB1];
      PFWSUB2 = PFWSUB2 + 1; /* bump index for maps*/
    end
    PFWSUB1 = PFWSUB1 + 1; /* bump w/s index*/
    if (PFWSUB1 > PFWLIMIT)
      PFWSUB2 = 13;
    end
  end
end // end PF0M310

// move 'detail' items to maps
Function PF0M320()
   /* ***************************************************/
   /* *   this process will move all 'detail' items    **/
   /* *   from pf0mw02 record to the maps. detail      **/
   /* *   items are identified by the field pf0mwtyp   **/
   /* *   being = 1, 2, 3, or 5.  detail display will  **/
   /* *   scroll up and down the pf0mw02 w/s area.     **/
   /* *   the control of scrolling positioning will    **/
   /* *   be done by pf0mxxx.                          **/
   /* *   both the right side(pf0mm001) and the left   **/
   /* *   side(pf0mm002) of the display will be        **/
   /* *   loaded in this process. the user can shift   **/
   /* *   right and left using pf10 and pf11.          **/
   /* ***************************************************/
  ;
  PF0M340(); /* clear maps of previous data*/
  ;
  PFWREC.PFWSAVDX = PFWREC.PFWSUB1; /* save first w/s position*/
  ;
  PFWSUB2 = 1;
  ;
  while (PFWSUB2 < 11) /* browse through pf0lw02 and move all*/
    if (PF0MW02.PF0MWTYP[PFWSUB1] == "1" /* detail records to the maps*/
     || PF0MW02.PF0MWTYP[PFWSUB1] == "2" 
     || PF0MW02.PF0MWTYP[PFWSUB1] == "3" 
     || PF0MW02.PF0MWTYP[PFWSUB1] == "5")
      PF0MM001.PF0MMISD[PFWSUB2] = PF0MW02.PF0MWLIT[PFWSUB1];
      PF0MM002.PF0MMISD[PFWSUB2] = PF0MW02.PF0MWLIT[PFWSUB1];
      ;
      PF0MM001.PF0MMAM1[PFWSUB2] = PF0MW02.PF0MWC1[PFWSUB1];
      PF0MM001.PF0MMAM2[PFWSUB2] = PF0MW02.PF0MWC3[PFWSUB1];
      PF0MM001.PF0MMAM3[PFWSUB2] = PF0MW02.PF0MWC5[PFWSUB1];
      PF0MM001.PF0MMAM4[PFWSUB2] = PF0MW02.PF0MWC7[PFWSUB1];
      PF0MM001.PF0MMAM5[PFWSUB2] = PF0MW02.PF0MWC9[PFWSUB1];
      PF0MM001.PF0MMPC1[PFWSUB2] = PF0MW02.PF0MWC11[PFWSUB1];
      PF0MM001.PF0MMPC2[PFWSUB2] = PF0MW02.PF0MWC12[PFWSUB1];
      ;
      PF0MM002.PF0MMAM1[PFWSUB2] = PF0MW02.PF0MWC1[PFWSUB1];
      PF0MM002.PF0MMPC1[PFWSUB2] = PF0MW02.PF0MWC2[PFWSUB1];
      PF0MM002.PF0MMPC2[PFWSUB2] = PF0MW02.PF0MWC4[PFWSUB1];
      PF0MM002.PF0MMPC3[PFWSUB2] = PF0MW02.PF0MWC6[PFWSUB1];
      PF0MM002.PF0MMPC4[PFWSUB2] = PF0MW02.PF0MWC8[PFWSUB1];
      PF0MM002.PF0MMPC5[PFWSUB2] = PF0MW02.PF0MWC10[PFWSUB1];
      PF0MM002.PF0MMPC6[PFWSUB2] = PF0MW02.PF0MWC11[PFWSUB1];
      PF0MM002.PF0MMPC7[PFWSUB2] = PF0MW02.PF0MWC12[PFWSUB1];
      PFWSUB2 = PFWSUB2 + 1; /* bump index for maps*/
    end
    PFWSUB1 = PFWSUB1 + 1; /* bump w/s index*/
    if (PFWSUB1 > PFWLIMIT) /* if w/s end reached,*/
      PFWSUB2 = 13;
    end
  end
  ;
  PFWREC.PFWNXTDX = PFWREC.PFWSUB1; /* save next available index*/
end // end PF0M320

// move 'explode' items to maps
Function PF0M330()
   /* ***************************************************/
   /* *   this process will move all 'explode' items   **/
   /* *   from pf0mw02 record to the maps. explode     **/
   /* *   items are identified by the field pf0mwtyp   **/
   /* *   being = 1, 2, 4, or 5.  detail display will  **/
   /* *   scroll up and down the pf0mw02 w/s area.     **/
   /* *   the control of scrolling positioning will    **/
   /* *   be done by pf0mxxx.                          **/
   /* *   both the right side(pf0mm001) and the left   **/
   /* *   side(pf0mm002) of the display will be        **/
   /* *   loaded in this process. the user can shift   **/
   /* *   right and left using pf10 and pf11.          **/
   /* ***************************************************/
  ;
  PF0M340(); /* clear maps of previous data*/
  ;
  PFWREC.PFWSAVDX = PFWREC.PFWSUB1; /* save first w/s position*/
  ;
  PFWSUB2 = 1;
  ;
  while (PFWSUB2 < 11) /* browse through pf0lw02 and move all*/
    if (PF0MW02.PF0MWTYP[PFWSUB1] == "1" /* explode records to the maps*/
     || PF0MW02.PF0MWTYP[PFWSUB1] == "2" 
     || PF0MW02.PF0MWTYP[PFWSUB1] == "4" 
     || PF0MW02.PF0MWTYP[PFWSUB1] == "5")
      PF0MM001.PF0MMISD[PFWSUB2] = PF0MW02.PF0MWLIT[PFWSUB1];
      PF0MM002.PF0MMISD[PFWSUB2] = PF0MW02.PF0MWLIT[PFWSUB1];
      ;
      PF0MM001.PF0MMAM1[PFWSUB2] = PF0MW02.PF0MWC1[PFWSUB1];
      PF0MM001.PF0MMAM2[PFWSUB2] = PF0MW02.PF0MWC3[PFWSUB1];
      PF0MM001.PF0MMAM3[PFWSUB2] = PF0MW02.PF0MWC5[PFWSUB1];
      PF0MM001.PF0MMAM4[PFWSUB2] = PF0MW02.PF0MWC7[PFWSUB1];
      PF0MM001.PF0MMAM5[PFWSUB2] = PF0MW02.PF0MWC9[PFWSUB1];
      PF0MM001.PF0MMPC1[PFWSUB2] = PF0MW02.PF0MWC11[PFWSUB1];
      PF0MM001.PF0MMPC2[PFWSUB2] = PF0MW02.PF0MWC12[PFWSUB1];
      ;
      PF0MM002.PF0MMAM1[PFWSUB2] = PF0MW02.PF0MWC1[PFWSUB1];
      PF0MM002.PF0MMPC1[PFWSUB2] = PF0MW02.PF0MWC2[PFWSUB1];
      PF0MM002.PF0MMPC2[PFWSUB2] = PF0MW02.PF0MWC4[PFWSUB1];
      PF0MM002.PF0MMPC3[PFWSUB2] = PF0MW02.PF0MWC6[PFWSUB1];
      PF0MM002.PF0MMPC4[PFWSUB2] = PF0MW02.PF0MWC8[PFWSUB1];
      PF0MM002.PF0MMPC5[PFWSUB2] = PF0MW02.PF0MWC10[PFWSUB1];
      PF0MM002.PF0MMPC6[PFWSUB2] = PF0MW02.PF0MWC11[PFWSUB1];
      PF0MM002.PF0MMPC7[PFWSUB2] = PF0MW02.PF0MWC12[PFWSUB1];
      PFWSUB2 = PFWSUB2 + 1; /* bump index for maps*/
    end
    PFWSUB1 = PFWSUB1 + 1; /* bump w/s index*/
    if (PFWSUB1 > PFWLIMIT) /* if w/s end reached, end the routine*/
      PFWSUB2 = 13;
    end
  end
  ;
  PFWREC.PFWNXTDX = PFWREC.PFWSUB1; /* save next w/s position*/
end // end PF0M330

// clear map fields
Function PF0M340()
  ;
  PFWSUB2 = 1;
  ;
  while (PFWSUB2 < 11)
    PF0MM001.PF0MMISD[PFWSUB2] = " ";
    PF0MM002.PF0MMISD[PFWSUB2] = " ";
    PF0MM001.PF0MMAM1[PFWSUB2] = 0;
    PF0MM001.PF0MMAM2[PFWSUB2] = 0;
    PF0MM001.PF0MMAM3[PFWSUB2] = 0;
    PF0MM001.PF0MMAM4[PFWSUB2] = 0;
    PF0MM001.PF0MMAM5[PFWSUB2] = 0;
    PF0MM001.PF0MMPC1[PFWSUB2] = 0;
    PF0MM001.PF0MMPC2[PFWSUB2] = 0;
    PF0MM002.PF0MMAM1[PFWSUB2] = 0;
    PF0MM002.PF0MMPC1[PFWSUB2] = 0;
    PF0MM002.PF0MMPC2[PFWSUB2] = 0;
    PF0MM002.PF0MMPC3[PFWSUB2] = 0;
    PF0MM002.PF0MMPC4[PFWSUB2] = 0;
    PF0MM002.PF0MMPC5[PFWSUB2] = 0;
    PF0MM002.PF0MMPC6[PFWSUB2] = 0;
    PF0MM002.PF0MMPC7[PFWSUB2] = 0;
    PFWSUB2 = PFWSUB2 + 1;
  end
  ;
end // end PF0M340

// scroll backwards thru 'det'
Function PF0M350()
   /* *****************************************************/
   /* *  this routine is nearly identical to pf0m320.    **/
   /* *  the difference is that this routine will scroll **/
   /* *  backwards through the w/s area, pf0mw02, by     **/
   /* *  decrementing the storage and screen subscripts. **/
   /* *  if the w/s subscript reaches zero after being   **/
   /* *  decremented, it is set to 1 and the scroll      **/
   /* *  forward routine, pf0m320, is performed.         **/
   /* *****************************************************/
  ;
  if (PFWSUB1 < 1)
    converseLib.validationFailed(085);
    return;
  end
  ;
  PF0M340(); /* clear maps of previous data*/
  ;
  ;
  PFWREC.PFWNXTDX = PFWREC.PFWSUB1; /* save last w/s position*/
  ;
  PFWSUB2 = 10;
  ;
  while (PFWSUB2 > 0) /* browse backwards through pf0mw02 and move all*/
    if (PF0MW02.PF0MWTYP[PFWSUB1] == "1" /* detail records to the maps*/
     || PF0MW02.PF0MWTYP[PFWSUB1] == "2" 
     || PF0MW02.PF0MWTYP[PFWSUB1] == "3" 
     || PF0MW02.PF0MWTYP[PFWSUB1] == "5")
      PF0MM001.PF0MMISD[PFWSUB2] = PF0MW02.PF0MWLIT[PFWSUB1];
      PF0MM002.PF0MMISD[PFWSUB2] = PF0MW02.PF0MWLIT[PFWSUB1];
      ;
      PF0MM001.PF0MMAM1[PFWSUB2] = PF0MW02.PF0MWC1[PFWSUB1];
      PF0MM001.PF0MMAM2[PFWSUB2] = PF0MW02.PF0MWC3[PFWSUB1];
      PF0MM001.PF0MMAM3[PFWSUB2] = PF0MW02.PF0MWC5[PFWSUB1];
      PF0MM001.PF0MMAM4[PFWSUB2] = PF0MW02.PF0MWC7[PFWSUB1];
      PF0MM001.PF0MMAM5[PFWSUB2] = PF0MW02.PF0MWC9[PFWSUB1];
      PF0MM001.PF0MMPC1[PFWSUB2] = PF0MW02.PF0MWC11[PFWSUB1];
      PF0MM001.PF0MMPC2[PFWSUB2] = PF0MW02.PF0MWC12[PFWSUB1];
      ;
      PF0MM002.PF0MMAM1[PFWSUB2] = PF0MW02.PF0MWC1[PFWSUB1];
      PF0MM002.PF0MMPC1[PFWSUB2] = PF0MW02.PF0MWC2[PFWSUB1];
      PF0MM002.PF0MMPC2[PFWSUB2] = PF0MW02.PF0MWC4[PFWSUB1];
      PF0MM002.PF0MMPC3[PFWSUB2] = PF0MW02.PF0MWC6[PFWSUB1];
      PF0MM002.PF0MMPC4[PFWSUB2] = PF0MW02.PF0MWC8[PFWSUB1];
      PF0MM002.PF0MMPC5[PFWSUB2] = PF0MW02.PF0MWC10[PFWSUB1];
      PF0MM002.PF0MMPC6[PFWSUB2] = PF0MW02.PF0MWC11[PFWSUB1];
      PF0MM002.PF0MMPC7[PFWSUB2] = PF0MW02.PF0MWC12[PFWSUB1];
      PFWSUB2 = PFWSUB2 - 1; /* decrement index for maps*/
    end
    PFWSUB1 = PFWSUB1 - 1; /* decremennet w/s index*/
    if (PFWSUB1 <= 1) /* if w/s end reached,*/
      converseLib.validationFailed(085);
      PFWSUB1 = 1;
      PFWSUB2 = 1;
      PF0M320();
      return;
    end
  end
  ;
  PFWREC.PFWSAVDX = PFWREC.PFWSUB1; /* save first w/s index*/
end // end PF0M350

// scroll backwards thru 'exp'
Function PF0M360()
   /* *****************************************************/
   /* *  this routine is nearly identical to pf0m330.    **/
   /* *  the difference is that this routine will scroll **/
   /* *  backwards through the w/s area, pf0mw02, by     **/
   /* *  decrementing the storage and screen subscripts. **/
   /* *  if the w/s subscript reaches zero after being   **/
   /* *  decremented, it is set to 1 and the scroll      **/
   /* *  forward routine, pf0m330, is performed.         **/
   /* *****************************************************/
  ;
  if (PFWSUB1 < 1)
    converseLib.validationFailed(085);
    return;
  end
  ;
  PF0M340(); /* clear maps of previous data*/
  ;
  PFWREC.PFWNXTDX = PFWREC.PFWSUB1; /* save first w/s position*/
  ;
  PFWSUB2 = 10;
  ;
  while (PFWSUB2 > 0) /* browse backwards through pf0mw02 and move all*/
    if (PF0MW02.PF0MWTYP[PFWSUB1] == "1" /* explode records to the maps*/
     || PF0MW02.PF0MWTYP[PFWSUB1] == "2" 
     || PF0MW02.PF0MWTYP[PFWSUB1] == "4" 
     || PF0MW02.PF0MWTYP[PFWSUB1] == "5")
      PF0MM001.PF0MMISD[PFWSUB2] = PF0MW02.PF0MWLIT[PFWSUB1];
      PF0MM002.PF0MMISD[PFWSUB2] = PF0MW02.PF0MWLIT[PFWSUB1];
      ;
      PF0MM001.PF0MMAM1[PFWSUB2] = PF0MW02.PF0MWC1[PFWSUB1];
      PF0MM001.PF0MMAM2[PFWSUB2] = PF0MW02.PF0MWC3[PFWSUB1];
      PF0MM001.PF0MMAM3[PFWSUB2] = PF0MW02.PF0MWC5[PFWSUB1];
      PF0MM001.PF0MMAM4[PFWSUB2] = PF0MW02.PF0MWC7[PFWSUB1];
      PF0MM001.PF0MMAM5[PFWSUB2] = PF0MW02.PF0MWC9[PFWSUB1];
      PF0MM001.PF0MMPC1[PFWSUB2] = PF0MW02.PF0MWC11[PFWSUB1];
      PF0MM001.PF0MMPC2[PFWSUB2] = PF0MW02.PF0MWC12[PFWSUB1];
      ;
      PF0MM002.PF0MMAM1[PFWSUB2] = PF0MW02.PF0MWC1[PFWSUB1];
      PF0MM002.PF0MMPC1[PFWSUB2] = PF0MW02.PF0MWC2[PFWSUB1];
      PF0MM002.PF0MMPC2[PFWSUB2] = PF0MW02.PF0MWC4[PFWSUB1];
      PF0MM002.PF0MMPC3[PFWSUB2] = PF0MW02.PF0MWC6[PFWSUB1];
      PF0MM002.PF0MMPC4[PFWSUB2] = PF0MW02.PF0MWC8[PFWSUB1];
      PF0MM002.PF0MMPC5[PFWSUB2] = PF0MW02.PF0MWC10[PFWSUB1];
      PF0MM002.PF0MMPC6[PFWSUB2] = PF0MW02.PF0MWC11[PFWSUB1];
      PF0MM002.PF0MMPC7[PFWSUB2] = PF0MW02.PF0MWC12[PFWSUB1];
      PFWSUB2 = PFWSUB2 - 1; /* decrement index for maps*/
    end
    PFWSUB1 = PFWSUB1 - 1; /* decrement w/s index*/
    if (PFWSUB1 <= 1) /* if w/s end reached,*/
      converseLib.validationFailed(085);
      PFWSUB1 = 1;
      PFWSUB2 = 1;
      PF0M330();
      return;
    end
  end
  ;
  PFWREC.PFWSAVDX = PFWREC.PFWSUB1; /* save first w/s position*/
end // end PF0M360

//*** RECORD=PF0MW01 ****
// miscellaneous storage area for pf0m application
// ***********************
Record PF0MW01 type basicRecord
  10 PF0MWABV PF0MWABV ; 
    15 PF0MWDSC PF0MWDSC ; 
    15 PF0MWCLS PF0MWCLS ; 
  10 PF0MWCL1 PF0MWCL1 ; 
    15 PF0MWDT1 PF0MWDT1 ; 
    15 PF0MWF1 PF0MWF1 ; 
    15 PF0MWTP1 PF0MWTP1 ; 
  10 PF0MWCL2 PF0MWCL2 ; 
    15 PF0MWDT2 PF0MWDT2 ; 
    15 PF0MWF2 PF0MWF2 ; 
    15 PF0MWTP2 PF0MWTP2 ; 
  10 PF0MWCL3 PF0MWCL3 ; 
    15 PF0MWDT3 PF0MWDT3 ; 
    15 PF0MWF3 PF0MWF3 ; 
    15 PF0MWTP3 PF0MWTP3 ; 
  10 PF0MWCL4 PF0MWCL4 ; 
    15 PF0MWDT4 PF0MWDT4 ; 
    15 PF0MWF4 PF0MWF4 ; 
    15 PF0MWTP4 PF0MWTP4 ; 
  10 PF0MWCL5 PF0MWCL5 ; 
    15 PF0MWDT5 PF0MWDT5 ; 
    15 PF0MWF5 PF0MWF5 ; 
    15 PF0MWTP5 PF0MWTP5 ; 
  10 PF0MWABK PF0MWABK ; 
    15 PF0MWAB2 PF0MWAB2 ; 
  10 PF0MWSTL PF0MWSTL ; 
  10 PF0MWSTS PF0MWSTS ; 
  10 PF0MWDSP PF0MWDSP ; 
  10 PF0MWHDP PF0MWHDP ; 
  10 PF0MWLEF PF0MWLEF ; 
  10 PF0MWRIG PF0MWRIG ; 
  10 PF0MWPFK PF0MWPFK ; 
    15 PF0MWKY1 PF0MWKY1 ; 
    15 PF0MWDP1 PF0MWDP1 ; 
    15 PF0MWKY2 PF0MWKY2 ; 
    15 PF0MWDP2 PF0MWDP2 ; 
  10 PF0MWFLG PF0MWFLG ; 
  10 PF0MWAVA PF0MWAVA ; 
    15 PF0MWAV1 PF0MWAV1 ; 
    15 PF0MWAV2 PF0MWAV2 ; 
  10 PF0MWAVD PF0MWAVD ; 
    15 PF0MWAD1 PF0MWAD1 ; 
    15 PF0MWAD2 PF0MWAD2 ; 
  10 PF0MWNUM PF0MWNUM ; 
    15 PF0MWNM1 PF0MWNM1 ; 
    15 PF0MWNM2 PF0MWNM2 ; 
  10 PF0MWFL1 PF0MWFL1 ; 
    15 PF0MWCD1 PF0MWCD1 ; 
    15 PF0MWCD2 PF0MWCD2 ; 
    15 PF0MWCD3 PF0MWCD3 ; 
    15 PF0MWCD4 PF0MWCD4 ; 
    15 PF0MWCD5 PF0MWCD5 ; 
    15 PF0MWCD6 PF0MWCD6 ; 
    15 PF0MWCD7 PF0MWCD7 ; 
  10 PF0MWFL2 PF0MWFL2 ; 
    15 PF0MWCV1 PF0MWCV1 ; 
    15 PF0MWCV2 PF0MWCV2 ; 
    15 PF0MWCV3 PF0MWCV3 ; 
    15 PF0MWCV4 PF0MWCV4 ; 
    15 PF0MWCV5 PF0MWCV5 ; 
    15 PF0MWCV6 PF0MWCV6 ; 
    15 PF0MWCV7 PF0MWCV7 ; 
  10 PF0MWSTY PF0MWSTY ; 
    15 XGPCD XGPCD ; 
    15 PF0MWF6 PF0MWF6 ; 
    15 SY1STNBR SY1STNBR ; 
    15 PF0MWF7 PF0MWF7 ; 
    15 SY2CLRID SY2CLRID ; 
    15 PF0MWF8 PF0MWF8 ; 
    15 XDMCD XDMCD ; 
    15 PF0MWF9 PF0MWF9 ; 
    15 XQACD XQACD ; 
    15 PF0MWF10 PF0MWF10 ; 
    15 XLCCD XLCCD ; 
  10 PF0MWHD1 PF0MWHD1 ; 
    15 PF0MWF11 PF0MWF11 ; 
    15 PF0MWH1 PF0MWH1 ; 
    15 PF0MWF12 PF0MWF12 ; 
    15 PF0MWH2 PF0MWH2 ; 
    15 PF0MWF13 PF0MWF13 ; 
    15 PF0MWH3 PF0MWH3 ; 
    15 PF0MWF14 PF0MWF14 ; 
    15 PF0MWH4 PF0MWH4 ; 
    15 PF0MWF15 PF0MWF15 ; 
    15 PF0MWH5 PF0MWH5 ; 
    15 PF0MWF16 PF0MWF16 ; 
  10 PF0MWHD2 PF0MWHD2 ; 
    15 PF0MWF17 PF0MWF17 ; 
    15 PF0MWH6 PF0MWH6 ; 
    15 PF0MWF18 PF0MWF18 ; 
    15 PF0MWH7 PF0MWH7 ; 
    15 PF0MWF19 PF0MWF19 ; 
    15 PF0MWH8 PF0MWH8 ; 
    15 PF0MWF20 PF0MWF20 ; 
    15 PF0MWH9 PF0MWH9 ; 
    15 PF0MWF21 PF0MWF21 ; 
    15 PF0MWH10 PF0MWH10 ; 
  10 PF0MWRN PF0MWRN ; 
    15 PF0MWRN1 PF0MWRN1 ; 
    15 PF0MWRV1 PF0MWRV1 ; 
    15 PF0MWRN2 PF0MWRN2 ; 
    15 PF0MWRV2 PF0MWRV2 ; 
    15 PF0MWRN3 PF0MWRN3 ; 
end // end PF0MW01

//*** RECORD=PF0MW02 ****
// this w/s area is used to store rows of summary information
// to be displayed in this application. the rows are identified
// by the field pf0mwtyp as follows :
//  value         summary row type
//  -----         ---------------------------
//    1           summary total item (net rev, etc.)
//    2           special summary total (dir sg&a, ind sg&a)
//    3           i/s grouped totals
//    4           i/s grouped items
//    5           i/s ungrouped items
// 
// MAINTENANCE LOG:
//   DATE   INIT     COMMENTS:
// -------- ------   ---------------
// 06/13/91 CVO      Increased group level entries on ws from
//                   200 to 500.
// ***********************
Record PF0MW02 type basicRecord
  5 PF0MWGRP PF0MWGRP [500] ; 
    10 YISCD YISCD ; 
    10 YTYCD YTYCD ; 
    10 PF0MWLIT PF0MWLIT ; 
      15 PF0MWIND PF0MWIND ; 
      15 PF0MWABV PF0MWABV ; 
    10 PF0MWTYP PF0MWTYP ; 
    10 PF0MWC1 PF0MWC1 ; 
    10 PF0MWC2 PF0MWC2 ; 
    10 PF0MWC3 PF0MWC3 ; 
    10 PF0MWC4 PF0MWC4 ; 
    10 PF0MWC5 PF0MWC5 ; 
    10 PF0MWC6 PF0MWC6 ; 
    10 PF0MWC7 PF0MWC7 ; 
    10 PF0MWC8 PF0MWC8 ; 
    10 PF0MWC9 PF0MWC9 ; 
    10 PF0MWC10 PF0MWC10 ; 
    10 PF0MWC11 PF0MWC11 ; 
    10 PF0MWC12 PF0MWC12 ; 
end // end PF0MW02

// CHARACTER db2 abend key
DataItem PF0MWAB2 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// numeric db2 abend key
DataItem PF0MWABK num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// yis-ist-cls-abrv
DataItem PF0MWABV char(16)  {
  align = none, fillCharacter = nullFill, inputRequired = no
}
end

// attr. code
DataItem PF0MWAD1 char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. code literal
DataItem PF0MWAD2 char(12)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attribute literal
DataItem PF0MWAV1 char(8)  {
  align = right, fillCharacter = nullFill, inputRequired = no
}
end

// attribute char.' :'
DataItem PF0MWAV2 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attribute literal group
DataItem PF0MWAVA char(10)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. code val. literal
DataItem PF0MWAVD char(17)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dt/tp 1 amt
DataItem PF0MWC1 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp 4 %
DataItem PF0MWC10 bin(4,1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp pct comparison 1
DataItem PF0MWC11 bin(4,1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp pct comparison 2
DataItem PF0MWC12 bin(4,1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp 1 %
DataItem PF0MWC2 bin(4,1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp 2 amt
DataItem PF0MWC3 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp 2 %
DataItem PF0MWC4 bin(4,1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp 3 amt
DataItem PF0MWC5 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp 3 %
DataItem PF0MWC6 bin(4,1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp 4 amt
DataItem PF0MWC7 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp 4 %
DataItem PF0MWC8 bin(4,1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp 4 amt
DataItem PF0MWC9 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// attr. field 1
DataItem PF0MWCD1 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. field 2
DataItem PF0MWCD2 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. field 3
DataItem PF0MWCD3 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. field 4
DataItem PF0MWCD4 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. field 5
DataItem PF0MWCD5 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. field 6
DataItem PF0MWCD6 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. field 7
DataItem PF0MWCD7 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dt/tp pct. col. 1
DataItem PF0MWCL1 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dt/tp pct. col. 2
DataItem PF0MWCL2 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dt/tp pct. col. 3
DataItem PF0MWCL3 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dt/tp pct. col. 4
DataItem PF0MWCL4 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dt/tp pct. col. 5
DataItem PF0MWCL5 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// undef. i/s class
DataItem PF0MWCLS num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// attr. field 1
DataItem PF0MWCV1 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. field 2
DataItem PF0MWCV2 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. field 3
DataItem PF0MWCV3 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. field 4
DataItem PF0MWCV4 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. field 5
DataItem PF0MWCV5 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. field 6
DataItem PF0MWCV6 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. field 7
DataItem PF0MWCV7 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// display type-'sum,det,exp'
DataItem PF0MWDP1 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// display type-'sum,det,exp'
DataItem PF0MWDP2 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// undef. class literal
DataItem PF0MWDSC char(12)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// display type - sum,det,exp
DataItem PF0MWDSP char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data type code 1
DataItem PF0MWDT1 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data type code 2
DataItem PF0MWDT2 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data type code 3
DataItem PF0MWDT3 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data type code 4
DataItem PF0MWDT4 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data type code 5
DataItem PF0MWDT5 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler value ' '
DataItem PF0MWF1 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler-value '/'
DataItem PF0MWF10 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler - value '--'
DataItem PF0MWF11 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler - value '---'
DataItem PF0MWF12 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler - value '---'
DataItem PF0MWF13 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler - value '---'
DataItem PF0MWF14 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler - value '---'
DataItem PF0MWF15 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler - value '-'
DataItem PF0MWF16 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler - value '---------'
DataItem PF0MWF17 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler - value '-----'
DataItem PF0MWF18 char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler - value '-'
DataItem PF0MWF19 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler value ' '
DataItem PF0MWF2 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler - value '-'
DataItem PF0MWF20 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler - value '-'
DataItem PF0MWF21 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler value ' '
DataItem PF0MWF3 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler value ' '
DataItem PF0MWF4 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler value ' '
DataItem PF0MWF5 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler-value '/'
DataItem PF0MWF6 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler-value '/'
DataItem PF0MWF7 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler-value '/'
DataItem PF0MWF8 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler-value '/'
DataItem PF0MWF9 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. values hold area
DataItem PF0MWFL1 char(28)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. values hold area
DataItem PF0MWFL2 char(28)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// vsumry01 sequence flag
DataItem PF0MWFLG char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// gourp level
DataItem PF0MWGRP char(56)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// column 1 heading
DataItem PF0MWH1 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// column 5 heading
DataItem PF0MWH10 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// column 2 heading
DataItem PF0MWH2 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// column 3 heading
DataItem PF0MWH3 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// column 4 heading
DataItem PF0MWH4 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// column 5 heading
DataItem PF0MWH5 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// column 1 heading
DataItem PF0MWH6 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// column 2 heading
DataItem PF0MWH7 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// column 3 heading
DataItem PF0MWH8 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// column 4 heading
DataItem PF0MWH9 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pf0mm001 column headings
DataItem PF0MWHD1 char(45)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pf0mm002 column headings
DataItem PF0MWHD2 char(44)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// hold display type
DataItem PF0MWHDP char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// '*' or '#' or ' '
DataItem PF0MWIND char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pf key literal-value '18:'
DataItem PF0MWKY1 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pf key literal-value '19:'
DataItem PF0MWKY2 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// display left map
DataItem PF0MWLEF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// map i/s class literal
DataItem PF0MWLIT char(17)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// numeric breakdown field
DataItem PF0MWNM1 num(8)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// numeric breakdown field
DataItem PF0MWNM2 num(5,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// numeric breakdown field
DataItem PF0MWNUM num(13,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// pf18, pf19 literal
DataItem PF0MWPFK char(13)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// display right map
DataItem PF0MWRIG char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// warning message
DataItem PF0MWRN char(76)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// warning literal 1
DataItem PF0MWRN1 char(23)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// warning literal 2
DataItem PF0MWRN2 char(20)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// warning literal 3
DataItem PF0MWRN3 char(17)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// warning attribute 1
DataItem PF0MWRV1 char(8)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// warning attribute 2
DataItem PF0MWRV2 char(8)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// hold level number
DataItem PF0MWSTL num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// hold sequence number
DataItem PF0MWSTS num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// product hold area
DataItem PF0MWSTY char(22)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// time period code 1
DataItem PF0MWTP1 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// time period code 2
DataItem PF0MWTP2 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// time period code 3
DataItem PF0MWTP3 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// time period code 4
DataItem PF0MWTP4 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// time period code 5
DataItem PF0MWTP5 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// table entry type(1,2,3,4,5)
DataItem PF0MWTYP char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

