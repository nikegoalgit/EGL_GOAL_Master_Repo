package pf0r;
import corpcom2.XX0XW02;
import corpcom3.XPPF002;
import corpcom3.XPPF010;
import corpcom3.XPPF030;
import corpcom3.XPXAT01;
import corpcom3.XPXGP01;
import corpcom3.XPXX001;
import corpcom4.XSENTRY;
import corpcom4.XSEXIT;
import corpcom4.XSPF1;
import corpcom4.XSPF4;
import corpcom4.XSSEGTR;
import corpcom5.COMMAREA;
import corpcom5.ERRSQLCA;
import corpcom5.GLACD;
import corpcom5.GLADESC;
import corpcom5.GLASDESC;
import corpcom6.SQLCA;
import corpcom6.UT2REC;
import pf.common.*;
import ta.common.TA1REC;
import ta.common.TA2REC;
import xx.common.*;
import xx.common.COCMFL;
import xx.common.XXXSTAT;
import xx.common.YISCD;
import xx.common.ZZZCHGCT;
import xx.common.ZZZCHGDT;
import xx.common.ZZZCHGTM;
import xx.common.ZZZSDT;
import xx01.*;
import xx01.XATTBL;
import xx02.*;
import xx02.XGPTBL;
import xx06.*;
import xx06.XGPCD1;
import xx06.XGPCD2;
import xx06.XGPCD3;
import xx06.XGPCD4;
import xx06.XGPCD5;
import xx06.XGPCD6;
import xx07.*;
import xx07.PFJXREF;
import xx08.*;
import xx08.XXXGLAC1;
import xx08.XXXGLAC2;
import xx08.YISTBL;
//*** PROGRAM=PF0R ****
// This application will perform all of the maintenance
// to the General Ledger Code Table.  It allows the users
// to:
//      1.  Add, change, or replicate rows
//      2.  Submit trigger batch job to print GL Code report
//          (print the entire db2 table (DPROFIT.VGLCDS01))
// 
//      3.  Scroll backward (PF7)
//      4.  Scroll forward (PF8)
//      5.  Cancel changes (PA2)
//      6.  Locate GL code entered
// 
//      7.  Edit screen fields with no updating (PF12)
//      8.  Display pop-up window to view or select valid
//          GP or AT codes.  (Pop-up window is invoked
//          when a '?' is entered at GP or AT code field)
// 
// 
// 
// DB2 TABLE          IO MOD    SELECT  INSERT  UPDATE  DELETE
// ----------------   ------    ------  ------  ------  ------
// DPROFT.VGLCDS01    IO4360      Y       Y       Y       N
// 
// 
// 
// 
// 
// ------------------------------------------------------------
//  MAINTENANCE HISTORY:
//    DATE      BY              DESCRIPTION OF CHANGE
// ---------  ------    ---------------------------------------
//  3/01/90    cvo      New application
//  5/15/90   dcassi    Corrected PFJXREF so it is displayed
//                      and updated.
//  6/05/92   mkamin    Changed pfwrec.pfwtblx from 250 to
//                      500 for index on glcds01 table.
//  3/15/93   mkamin    Changed JCL table PF0RT01 for online-
//                      submitted job PF1291, due to change
//                      in scheduler package from UCC7 to ESP.
// *********************
Program PF0R type textUIProgram //VAGen Info - main text program
  {
  includeReferencedFunctions = yes, allowUnqualifiedItemReferences = yes, 
  throwNrfEofExceptions = yes, handleHardIOErrors = no, V60ExceptionCompatibility = yes, 
  I4GLItemsNullable = no, textLiteralDefaultIsString = no, localSQLScope = yes, 
  msgTablePrefix = "PF00", inputRecord = COMMAREA, segmented = yes
  }

  // Data Declarations
  COMMAREA COMMAREA ; // record
  ERRSQLCA ERRSQLCA; // record
  PF0RW01 PF0RW01; // record
  PF0RW02 PF0RW02; // record
  PF0RW90 PF0RW90; // record
  PFJREC PFJREC; // record
  PFWREC PFWREC; // record
  SQLCA SQLCA; // record
  TA1REC TA1REC; // record
  TA2REC TA2REC; // record
  UT2REC UT2REC; // record
  XX0XW02 XX0XW02; // record

  // VAGen Info - items needed for migration
  VAGen_EZESYS char(8);
  VAGen_EZEREPLY num(1);
  VAGen_EZE_WAIT_TIME bin(9,2);
  VAGen_EZE_ITEMLEN int;

  // Use Declarations
  use YISTBL {deleteAfterUse = yes}; // table
  use XGPTBL {deleteAfterUse = yes}; // table
  use XATTBL {deleteAfterUse = yes}; // table
  use PF0RT01; // table
  use PF0RM.PF0RM001, // form
  	PF0RM.XX0XM001
   {
    pfKeyEquate = no
  };

  function main()
    // VAGen Info - initialization needed for migration
    VAGen_EZESYS = VGLib.getVAGSysType();
    PF0R000: PF0R000();
  end // end main
end // end PF0R

// Driver
Function PF0R000()
   /* -----------------------------------------------------**/
    /* This is the main logic for the application.        **/
   /* -----------------------------------------------------**/

  PF0R001(); /* <=== initialize the application*/

  while (PFWREC.PFWEOAF == "N") /* <=== while not end-of-application*/
    PF0R050(); /* <=== converse screen m001*/
  end

  XPPF002(); /* <=== exit application*/

  COMMAREA.CATOAP = "PF0A"; /* <=== return to Profit. main menu*/
  XSEXIT();

  exit program;


end // end PF0R000

// Initialization routine
Function PF0R001()
   /* -----------------------------------------------**/
   /* PF0R001 -initialize application               **/
   /* -----------------------------------------------**/
  XSENTRY(); /* <=== check security clearance*/

  XSSEGTR(); /* <=== set cics start trans. id*/

  set PFWREC empty; /* <=== init. pf common working*/
  PFWREC.PFWEOAF = "N"; /* <=== End of application*/
  PFWREC.PFWERRF = "N"; /* <=== Error found flag*/
  PFWREC.PFW1STF = "Y"; /* <=== First time flag*/

  set PF0RW01 empty; /* <=== init. appl. ws*/
  PF0RW01.PF0RWBYP = "N"; /* <=== by pass editing flag*/
  PF0RW01.PF0RWEDT = "N"; /* <=== body edit*/
  PF0RW01.PF0RWDB2 = "N"; /* <=== update db2 table*/
  PF0RW01.PF0RWDBZ = "N"; /* <=== db2 busy flag*/

  set PF0RW02 empty; /* <=== init. ws2 table*/

  PF0R010(); /* <=== Load VGLCDS01 table*/

  if (PFWREC.PFWRECF == "Y")
    PFWREC.PFWTBLX = 1; /* <=== point to first row to disp.*/

    PF0R040(); /* <=== setup data for display*/

  end
end // end PF0R001

// Select data from VGLCDS01
Function PF0R010()
   /* --------------------------------------------------------*/
   /* This process loads the entire GL code table from      **/
   /* DB2 into Working Storage table (pf0rw02).             **/
   /* It opens a cursor, fetchs and loads the entire db2    **/
   /* table, and closes the cursor.  If a deadlock has      **/
   /* occurred during the loading process, this process     **/
   /* will stop and the 'data base was busy flag (pf0rwdbz)'**/
   /* is set to 'Y' to allow restart of the application.    **/
   /* -------------------------------------------------------**/
  PFWREC.PFWRECF = "Y";

  SQLCA.VAGen_SQLCODE = 0;

  PF0R012(); /* <=== Open cursor, Vglcds01, io4360*/

  if (SQLCA.VAGen_SQLCODE == +0)
    /* <=== Fetch through entire db2 table*/
    SQLCA.VAGen_SQLCODE = 0;
    PFWREC.PFWTBLX = 0;
    PFWREC.PFWLIMIT = 0;

    while (SQLCA.VAGen_SQLCODE == 0
     && PFWREC.PFWTBLX < 500) /* <=== max rows allowed*/

      call "IO4360" ("N1", SQLCA, PFJREC) {isNoRefresh = yes, isExternal = yes}; /* <=== Fetch row*/

      if (SQLCA.VAGen_SQLCODE == +0)
        PFWREC.PFWTBLX = PFWREC.PFWTBLX + 1; /* <=== Ws table index*/
        PF0R014(); /* <=== Move row to WS table*/

      else
        if (SQLCA.VAGen_SQLCODE == +100) /* <=== if row not found*/
          if (PFWREC.PFWTBLX == 0) /* <=== if vglcds01 contains no data*/
            PFWREC.PFWCPROC = "PF0R010B"; /* <=== pass calling process*/
            PFWREC.PFWHKEY = "NO GL CODES FOUND";
            TA1REC.TA1LOCAT[4] = "IO4360";
                                   /* <=== pass i/o module name*/
            TA1REC.TA1DBASE = "DPROFT";
            TA1REC.TA1TBLVU = "VGLCDS01";
            XPPF010(); /* <=== abend routine*/
          end
        else
          if (SQLCA.VAGen_SQLCODE == -911) /* <=== if table page busy*/
            converseLib.validationFailed(340); /* <=== db busy, re-try again*/
            PFWREC.PFWRECF = "N"; /* <=== no rows found for display*/
            PFWREC.PFWERRF = "Y";
            PF0RW01.PF0RWDBZ = "Y";
            set PF0RM001 empty;
            set PF0RM001.GLACD protect;
            set PF0RM001.PF0RMACT protect;
            set PF0RM001.CATOAP cursor;
          else
                                   /* ;<=== fatal DB2 error,*/
            TA1REC.TA1LOCAT[2] = " "; /* transfer to TA*/
            PFWREC.PFWHKEY = " ";
            PFWREC.PFWCPROC = "PF0R010B"; /* <=== pass calling process*/
            TA1REC.TA1LOCAT[4] = "IO4360";
                                   /* <=== pass i/o module name*/
            TA1REC.TA1DBASE = "DPROFT";
            TA1REC.TA1TBLVU = "VGLCDS01";
            XPPF010(); /* <=== abend routine*/
          end
        end
      end
    end
  end

  PF0R016(); /* <=== Check ws2 table for overflow*/

  PF0R018(); /* <=== close cursor, vglcds01*/
end // end PF0R010

// Open cursor, VGLCDS01
Function PF0R012()
   /* --------------------------------------------------*/
   /* Open cursor (setinq) via IO4360.                **/
                                                   /* **/
   /* Select *                                        **/
     /* from DPROFT.VGLCDS01                          **/
   /* where                                           **/
     /* GL_GEN_LEDGER_CD >= :GL-GEN-LEDGER-CD         **/
   /* order by                                        **/
     /* GL_GEN_LEDGER_CD                              **/
   /* --------------------------------------------------*/

  set PFJREC empty;

  PFJREC.GLACD = " "; /* <=== set key to space*/

  call "IO4360" ("S1", SQLCA, PFJREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == +0)
    /* Next Sentence*/
  else /* <=== fatal db2 error,*/
    TA1REC.TA1LOCAT[2] = " "; /* <=== transfer to TA*/
    PFWREC.PFWHKEY = " ";
    PFWREC.PFWCPROC = "PF0R010A"; /* <=== pass calling process*/
    TA1REC.TA1LOCAT[4] = "IO4360"; /* <=== pass i/o module name*/
    TA1REC.TA1DBASE = "DPROFT";
    TA1REC.TA1TBLVU = "VGLCDS01";
    XPPF010(); /* <=== abend routine*/
  end

end // end PF0R012

// move row to ws2 arrays
Function PF0R014()
   /* --------------------------------------------------------*/
   /* This process moves row fetched from db2 to ws2-array  **/
   /* for scrolling and rows manipulation purposes.         **/
   /* --------------------------------------------------------*/

  PF0RW02.GLACD[PFWTBLX] = PFJREC.GLACD;
  PF0RW02.GLASDESC[PFWTBLX] = PFJREC.GLASDESC;
  PF0RW02.GLADESC[PFWTBLX] = PFJREC.GLADESC;

  PF0RW02.XXXSTAT[PFWTBLX] = PFJREC.XXXSTAT;
  PF0RW02.PFJXREF[PFWTBLX] = PFJREC.PFJXREF;
  PF0RW02.YISCD[PFWTBLX] = PFJREC.YISCD;
  PF0RW02.XXXGLAC1[PFWTBLX] = PFJREC.XXXGLAC1;
  PF0RW02.XXXGLAC2[PFWTBLX] = PFJREC.XXXGLAC2;

  PF0RW02.PFJARFL[PFWTBLX] = PFJREC.PFJARFL;
  PF0RW02.PFJBNKIF[PFWTBLX] = PFJREC.PFJBNKIF;
  PF0RW02.COCMFL[PFWTBLX] = PFJREC.COCMFL;
  PF0RW02.PFJRESFL[PFWTBLX] = PFJREC.PFJRESFL;
  PF0RW02.PFJPCTFL[PFWTBLX] = PFJREC.PFJPCTFL;

  PF0RW02.XGPCD1[PFWTBLX] = PFJREC.XGPCD[1];
  PF0RW02.XGPCD2[PFWTBLX] = PFJREC.XGPCD[2];
  PF0RW02.XGPCD3[PFWTBLX] = PFJREC.XGPCD[3];
  PF0RW02.XGPCD4[PFWTBLX] = PFJREC.XGPCD[4];
  PF0RW02.XGPCD5[PFWTBLX] = PFJREC.XGPCD[5];
  PF0RW02.XGPCD6[PFWTBLX] = PFJREC.XGPCD[6];

  PF0RW02.XATCD1[PFWTBLX] = PFJREC.XATCD[1];
  PF0RW02.XATCD2[PFWTBLX] = PFJREC.XATCD[2];
  PF0RW02.XATCD3[PFWTBLX] = PFJREC.XATCD[3];
  PF0RW02.XATCD4[PFWTBLX] = PFJREC.XATCD[4];
  PF0RW02.XATCD5[PFWTBLX] = PFJREC.XATCD[5];

  PF0RW02.ZZZSDT[PFWTBLX] = PFJREC.ZZZSDT;
  PF0RW02.ZZZCHGCT[PFWTBLX] = PFJREC.ZZZCHGCT;
  PF0RW02.ZZZCHGTM[PFWTBLX] = PFJREC.ZZZCHGTM;
  PF0RW02.ZZZCHGCT[PFWTBLX] = PFJREC.ZZZCHGCT;
end // end PF0R014

// check ws2 table for overflow
Function PF0R016()

  if (SQLCA.VAGen_SQLCODE == 0) /* <=== If more data*/
    if (PFWREC.PFWTBLX >= 500) /* <=== table overflow abend*/
      PFWREC.PFWCPROC = "PF0R016"; /* <=== pass calling process*/
      PFWREC.PFWHKEY = "CSP TABLE OVERFLOW";
      TA1REC.TA1LOCAT[4] = "PF0RW02"; /* <=== pass table name*/
      TA1REC.TA1DBASE = " ";
      TA1REC.TA1TBLVU = " ";
      XPPF010(); /* <=== abend routine*/
    end
  end

end // end PF0R016

// Close cursor
Function PF0R018()

  call "IO4360" ("C1", SQLCA, PFJREC) {isNoRefresh = yes, isExternal = yes}; /* <=== table close scan*/

  if (SQLCA.VAGen_SQLCODE == +0)
    PFWREC.PFWLIMIT = PFWREC.PFWTBLX; /* <=== save table size*/
  else /* <=== fatal db2 error,*/
    TA1REC.TA1LOCAT[2] = " "; /* transfer to TA*/
    PFWREC.PFWHKEY = " ";
    PFWREC.PFWCPROC = "PF0R010D"; /* <=== pass calling process*/
    TA1REC.TA1LOCAT[4] = "IO4360"; /* <=== pass i/o module name*/
    TA1REC.TA1DBASE = "DPROFT";
    TA1REC.TA1TBLVU = "VGLCDS01";
    XPPF010(); /* <=== abend routine*/
  end

end // end PF0R018

// Load WS2 data to map
Function PF0R040()

  set PF0RM001 empty;
  PF0R042();

  PF0RM001.GLACD = PF0RW02.GLACD[PFWTBLX];
  PF0RM001.GLASDESC = PF0RW02.GLASDESC[PFWTBLX];
  PF0RM001.GLADESC = PF0RW02.GLADESC[PFWTBLX];

  PF0RM001.XXXSTAT = PF0RW02.XXXSTAT[PFWTBLX];
  if (PF0RW02.XXXSTAT[PFWTBLX] == "A")
    PF0RM001.PF0RMSTA = "ACTIVE";
  else
    if (PF0RW02.XXXSTAT[PFWTBLX] == "I")
      PF0RM001.PF0RMSTA = "INACTIVE";
    end
  end

  PF0RM001.PFJXREF = PF0RW02.PFJXREF[PFWTBLX];

  PF0RM001.YISCD = PF0RW02.YISCD[PFWTBLX];
  if (PF0RW02.YISCD[PFWTBLX] in YISTBL.YISCD)
    PF0RM001.YISABRV = YISTBL.YISABRV[sysVar.arrayIndex];
  end

  PF0RM001.XXXGLAC1 = PF0RW02.XXXGLAC1[PFWTBLX];
  PF0RM001.XXXGLAC2 = PF0RW02.XXXGLAC2[PFWTBLX];
  PF0RM001.PFJARFL = PF0RW02.PFJARFL[PFWTBLX];
  PF0RM001.PFJBNKIF = PF0RW02.PFJBNKIF[PFWTBLX];
  PF0RM001.COCMFL = PF0RW02.COCMFL[PFWTBLX];
  PF0RM001.PFJRESFL = PF0RW02.PFJRESFL[PFWTBLX];
  PF0RM001.PFJPCTFL = PF0RW02.PFJPCTFL[PFWTBLX];

  if (PF0RW02.XGPCD1[PFWTBLX] != " ")
    PF0RM001.XGPCD[1] = PF0RW02.XGPCD1[PFWTBLX];
    if (PF0RW02.XGPCD1[PFWTBLX] in XGPTBL.XGPCD)
      PF0RM001.XGPABRV[1] = XGPTBL.XGPABRV[sysVar.arrayIndex];
    end
  end

  if (PF0RW02.XGPCD2[PFWTBLX] != " ")
    PF0RM001.XGPCD[2] = PF0RW02.XGPCD2[PFWTBLX];
    if (PF0RW02.XGPCD2[PFWTBLX] in XGPTBL.XGPCD)
      PF0RM001.XGPABRV[2] = XGPTBL.XGPABRV[sysVar.arrayIndex];
    end
  end

  if (PF0RW02.XGPCD3[PFWTBLX] != " ")
    PF0RM001.XGPCD[3] = PF0RW02.XGPCD3[PFWTBLX];
    if (PF0RW02.XGPCD3[PFWTBLX] in XGPTBL.XGPCD)
      PF0RM001.XGPABRV[3] = XGPTBL.XGPABRV[sysVar.arrayIndex];
    end
  end

  if (PF0RW02.XGPCD4[PFWTBLX] != " ")
    PF0RM001.XGPCD[4] = PF0RW02.XGPCD4[PFWTBLX];
    if (PF0RW02.XGPCD4[PFWTBLX] in XGPTBL.XGPCD)
      PF0RM001.XGPABRV[4] = XGPTBL.XGPABRV[sysVar.arrayIndex];
    end
  end

  if (PF0RW02.XGPCD5[PFWTBLX] != " ")
    PF0RM001.XGPCD[5] = PF0RW02.XGPCD5[PFWTBLX];
    if (PF0RW02.XGPCD5[PFWTBLX] in XGPTBL.XGPCD)
      PF0RM001.XGPABRV[5] = XGPTBL.XGPABRV[sysVar.arrayIndex];
    end
  end

  if (PF0RW02.XGPCD6[PFWTBLX] != " ")
    PF0RM001.XGPCD[6] = PF0RW02.XGPCD6[PFWTBLX];
    if (PF0RW02.XGPCD6[PFWTBLX] in XGPTBL.XGPCD)
      PF0RM001.XGPABRV[6] = XGPTBL.XGPABRV[sysVar.arrayIndex];
    end
  end

  if (PF0RW02.XATCD1[PFWTBLX] != " ")
    PF0RM001.XATCD[1] = PF0RW02.XATCD1[PFWTBLX];
    if (PF0RW02.XATCD1[PFWTBLX] in XATTBL.XATCD)
      PF0RM001.XATABRV[1] = XATTBL.XATABRV[sysVar.arrayIndex];
    end
  end

  if (PF0RW02.XATCD2[PFWTBLX] != " ")
    PF0RM001.XATCD[2] = PF0RW02.XATCD2[PFWTBLX];
    if (PF0RW02.XATCD2[PFWTBLX] in XATTBL.XATCD)
      PF0RM001.XATABRV[2] = XATTBL.XATABRV[sysVar.arrayIndex];
    end
  end

  if (PF0RW02.XATCD3[PFWTBLX] != " ")
    PF0RM001.XATCD[3] = PF0RW02.XATCD3[PFWTBLX];
    if (PF0RW02.XATCD3[PFWTBLX] in XATTBL.XATCD)
      PF0RM001.XATABRV[3] = XATTBL.XATABRV[sysVar.arrayIndex];
    end
  end

  if (PF0RW02.XATCD4[PFWTBLX] != " ")
    PF0RM001.XATCD[4] = PF0RW02.XATCD4[PFWTBLX];
    if (PF0RW02.XATCD4[PFWTBLX] in XATTBL.XATCD)
      PF0RM001.XATABRV[4] = XATTBL.XATABRV[sysVar.arrayIndex];
    end
  end

  if (PF0RW02.XATCD5[PFWTBLX] != " ")
    PF0RM001.XATCD[5] = PF0RW02.XATCD5[PFWTBLX];
    if (PF0RW02.XATCD5[PFWTBLX] in XATTBL.XATCD)
      PF0RM001.XATABRV[5] = XATTBL.XATABRV[sysVar.arrayIndex];
    end
  end

end // end PF0R040

// reset attr. to orig.
Function PF0R042()
  set PF0RM001.GLACD cursor, normal;
  set PF0RM001.PF0RMACT normal;
  set PF0RM001.GLASDESC protect;
  set PF0RM001.GLADESC protect;
  set PF0RM001.XXXSTAT protect;
  set PF0RM001.PFJXREF protect;
  set PF0RM001.YISCD protect;
  set PF0RM001.XXXGLAC1 protect;
  set PF0RM001.XXXGLAC2 protect;
  set PF0RM001.PFJARFL protect;
  set PF0RM001.PFJBNKIF protect;
  set PF0RM001.COCMFL protect;
  set PF0RM001.PFJRESFL protect;
  set PF0RM001.PFJPCTFL protect;

  PFWREC.PFWSUB1 = 1;
  while (PFWREC.PFWSUB1 <= 6)

    set PF0RM001.XGPCD[PFWSUB1] protect;
    PFWREC.PFWSUB1 = PFWREC.PFWSUB1 + 1;

  end


  PFWREC.PFWSUB1 = 1;
  while (PFWREC.PFWSUB1 <= 5)

    set PF0RM001.XATCD[PFWSUB1] protect;
    PFWREC.PFWSUB1 = PFWREC.PFWSUB1 + 1;

  end

end // end PF0R042

// Mainline
Function PF0R050()
   /* ------------------------------------------------------**/
    /* Main logic loop for program                         **/
   /* ------------------------------------------------------**/

  PF0R100(); /* <=== Converse map*/

  if (PFWREC.PFWERRF == "Y")
    if (PF0RW01.PF0RWEDT == "Y")
      PF0R139(); /* <=== retain attr. as unpr.*/
    end
    return;
  end

  if (PF0RM001.PF0RMACT == " "
   || converseVar.eventKey is pa2
   || converseVar.eventKey is pf7
   || converseVar.eventKey is pf8)
    if (converseVar.eventKey not pf12)
      PF0R150(); /* <=== Get data for display*/
      return;
    end
  end

  if (PF0RW01.PF0RWEDT == "Y" /* <=== Update data*/
   && PFWREC.PFW1STF == "N") 

    PF0R200(); /* <=== Body validation*/

    /* The following codes will be executed only if a DB2 update*/
    /* is requested*/

    if (PFWREC.PFWERRF == "N" /* <=== if no errors found*/
     && PF0RW01.PF0RWDB2 == "Y") /* <=== and db2 update was requested*/

         /* IF EZEAID IS ENTER;*/
      if (PF0RM001.PF0RMACT == "A" /* <=== if add action requested*/
       || PF0RM001.PF0RMACT == "R") /* or Replicate action*/
        PF0R400(); /* <=== DO INSERT ROUTINE*/
      else
        if (PF0RM001.PF0RMACT == "C") /* <=== if change action*/
          PF0R500(); /* <=== DO UPDATE ROUTINE*/
        end
      end

      if (SQLCA.VAGen_SQLCODE == +0 /* <=== if DB2 update successful*/
       && PFWREC.PFWERRF == "N")   
        converseLib.validationFailed(330); /* <=== update successful*/
        PF0RM001.PF0RMACT = " ";
        PFWREC.PFW1STF = "Y"; /* <=== reset first time flag*/
        PF0RW01.PF0RWEDT = "N"; /* <=== reset edit flag*/
        PF0RW01.PF0RWDB2 = "N"; /* <=== update successful flag*/
        PF0R042(); /* ;<=== reset attr. to orig.*/
      end
    end
                                   /* ;<=== If ezeaid is ENTER*/
     /* END ;*/
  end
end // end PF0R050

// Converse map
Function PF0R100()

  PF0RM001.XXXCURDT = VGVar.currentShortGregorianDate;

  PF0RM001.XXXPRCNM = "PF0R100";

  PF0RW01.PF0RMACT = PF0RM001.PF0RMACT;

  PFWREC.PFWERRF = "N";
  converse PF0RM001 ;

  PF0R102(); /* <=== check pf-key pressed*/

  if (PF0RW01.PF0RWDBZ == "Y") /* <=== if data was busy, restart appl.*/
    if (converseVar.eventKey is enter
     || converseVar.eventKey is pa2
     || converseVar.eventKey is pf7
     || converseVar.eventKey is pf8
     || converseVar.eventKey is pf12)

      PF0R001(); /* <=== restart application*/

      PFWREC.PFWERRF = "Y"; /* <=== force exit*/
      return;
    end
  end

  PF0R130(); /* <=== check header changes*/

end // end PF0R100

// Check pf-key pressed
Function PF0R102()
   /* ----------------------------------------------------------*;*/
   /* ** This process performs the following functions:         *;*/
   /* **    FASTPATH  If no errors, transfer to specified appl. *;*/
   /* **    PA2  By-pass all changes and redisplay previous     *;*/
   /* **         screen.                                        *;*/
   /* **    PF1  Transfer to the Help Application.              *;*/
   /* **    PF3  Transfer to the Profitability Menu.            *;*/
   /* **    PF4  Transfer to the Main Menu.                     *;*/
   /* **    PF7  scroll backward.                               *;*/
   /* **    PF8  scroll forward.                                *;*/
   /* **    PF12 validate screen fields.                        *;*/
   /* **--------------------------------------------------------*;*/

  if (converseVar.eventKey is pa2)
    converseLib.validationFailed(189); /* <=== pa2 pressed; screen changes aborted*/
    PF0RW01.PF0RWBYP = "Y";
    return;
  end


      /* FASTPATH transfer OUT*/

  if (PF0RM001.CATOAP != " " /* <=== If FASTpath*/
   || PF0RM001.CAITEM != " ")
    PF0R104(); /* <=== Do FASTpath routine*/
    if (PFWREC.PFWERRF == "Y")
      set PF0RM001.CATOAP cursor, bold;
      return; /* ;     requested screen*/
    end
  end

   /* =====>  Validate PF Key   <=====*/

  if (converseVar.eventKey is enter
   || converseVar.eventKey is pa2)
    return;
  else
    if (converseVar.eventKey is pf7
     || converseVar.eventKey is pf8)
      if (PF0RM001.PF0RMACT != " ") /* Action must be blank to scroll*/
        converseLib.validationFailed(328); /* <=== action field must be blank to scroll*/
        set PF0RM001.PF0RMACT cursor, bold;
        PFWREC.PFWERRF = "Y";
      end
    else
      if (converseVar.eventKey is pf1) /* <=== Bypass changes and transfer*/
        XSPF1(); /* to common HELP screen*/
        PF0RM001.VAGen_EZEMSG = COMMAREA.CAMSG;
        PFWREC.PFWERRF = "Y"; /* <=== Handle bad transfer*/
      else
        if (converseVar.eventKey is pf3) /* <=== Bypass changes and transfer*/
          COMMAREA.CAFROMAP = "PF0R"; /* to Profit. Menu*/
          COMMAREA.CATOAP = "PF0A";
          XSEXIT(); /* <=== Transfer to PF0A.*/
          PF0RM001.VAGen_EZEMSG = COMMAREA.CAMSG;
          PFWREC.PFWERRF = "Y"; /* <=== Handle bad transfer*/
        else
          if (converseVar.eventKey is pf4) /* <=== Bypass changes and transfer*/
            COMMAREA.CAFROMAP = "PF0R"; /* Goal(Main) Menu*/
            XSPF4();
            PF0RM001.VAGen_EZEMSG = COMMAREA.CAMSG;
            PFWREC.PFWERRF = "Y"; /* <=== Handle a bad transfer*/
          else
            if (converseVar.eventKey is pf12)
              PF0RW01.PF0RWDB2 = "N"; /* <=== no db2 update*/
            else
              converseLib.validationFailed(1); /* <=== Invalid PF Key*/
              PFWREC.PFWERRF = "Y";
            end
          end
        end
      end
    end
  end

end // end PF0R102

// Val. FASTpath for data entry
Function PF0R104()
   /* -------------------------------------------------------**/
   /* ** Validate FASTpath exit request.  Data entry is not  **/
   /* ** allowed when using fastpath.                        **/
   /* -------------------------------------------------------**/

  PF0R106(); /* <=== Check scr. fields modified*/

  if (PF0RM001.CATOAP == "PF0R") /* <=== FASTpath into same appl.*/
    converseLib.validationFailed(10); /* <=== cannot transfer to requested screen*/
    PFWREC.PFWERRF = "Y";
  end

  if (PFWREC.PFWERRF == "Y")
    converseLib.validationFailed(02); /* <=== do not enter data if using fastpath*/
    PFWREC.PFWERRF = "Y";
  end

  if (converseVar.eventKey not enter)
    converseLib.validationFailed(190); /* <=== must press ENTER when using*/
                                   /* fpath*/
    PFWREC.PFWERRF = "Y";
  end

  if (PFWREC.PFWERRF == "Y") /* <=== if any errors occured*/
    return;
  else
    COMMAREA.CAFROMAP = "PF0R"; /* <=== allow fastpath*/
    COMMAREA.CATOAP = PF0RM001.CATOAP;
    COMMAREA.CAITEM = PF0RM001.CAITEM;

    XPPF002(); /* <=== pf common exit routine*/

    return;
  end
end // end PF0R104

// Ck. scr. fields mod. for FASTP
Function PF0R106()
   /* --------------------------------------------------------**/
   /* This process highlights all the modified screen fields.**/
   /* --------------------------------------------------------**/

  PF0R107(); /* <=== Check xgpcd/xatcd modified*/

  if (PF0RM001.PFJPCTFL is modified)
    set PF0RM001.PFJPCTFL bold;
    PFWREC.PFWERRF = "Y";
  end

  if (PF0RM001.PFJRESFL is modified)
    set PF0RM001.PFJRESFL bold;
    PFWREC.PFWERRF = "Y";
  end

  if (PF0RM001.COCMFL is modified)
    set PF0RM001.COCMFL bold;
    PFWREC.PFWERRF = "Y";
  end

  if (PF0RM001.PFJBNKIF is modified)
    set PF0RM001.PFJBNKIF bold;
    PFWREC.PFWERRF = "Y";
  end

  if (PF0RM001.PFJARFL is modified)
    set PF0RM001.PFJARFL bold;
    PFWREC.PFWERRF = "Y";
  end

  if (PF0RM001.XXXGLAC2 is modified)
    set PF0RM001.XXXGLAC2 bold;
    PFWREC.PFWERRF = "Y";
  end

  if (PF0RM001.XXXGLAC1 is modified)
    set PF0RM001.XXXGLAC1 bold;
    PFWREC.PFWERRF = "Y";
  end

  if (PF0RM001.YISCD is modified)
    set PF0RM001.YISCD bold;
    PFWREC.PFWERRF = "Y";
  end

  if (PF0RM001.PFJXREF is modified)
    set PF0RM001.PFJXREF bold;
    PFWREC.PFWERRF = "Y";
  end

  if (PF0RM001.XXXSTAT is modified)
    set PF0RM001.XXXSTAT bold;
    PFWREC.PFWERRF = "Y";
  end

  if (PF0RM001.GLASDESC is modified)
    set PF0RM001.GLASDESC bold;
    PFWREC.PFWERRF = "Y";
  end

  if (PF0RM001.GLADESC is modified)
    set PF0RM001.GLADESC bold;
    PFWREC.PFWERRF = "Y";
  end

  if (PF0RM001.PF0RMACT is modified)
    set PF0RM001.PF0RMACT bold;
    PFWREC.PFWERRF = "Y";
  end

  if (PF0RM001.GLACD is modified)
    set PF0RM001.GLACD bold;
    PFWREC.PFWERRF = "Y";
  end

  if (PFWREC.PFWERRF == "Y")
    converseLib.validationFailed(2); /* <=== Do not enter data if using FASTpath*/
    set PF0RM001.CATOAP cursor, bold;
  end

end // end PF0R106

// Ck. scr. fields modified
Function PF0R107()

  PFWREC.PFWSUB = 6; /* <=== common index*/
  while (PFWREC.PFWSUB >= 1)
    if (PF0RM001.XGPCD[PFWSUB] is modified)
      set PF0RM001.XGPCD[PFWSUB] bold;
      PFWREC.PFWERRF = "Y";
    end
    PFWREC.PFWSUB = PFWREC.PFWSUB - 1;
  end

  PFWREC.PFWSUB = 5; /* <=== common index*/
  while (PFWREC.PFWSUB >= 1)
    if (PF0RM001.XATCD[PFWSUB] is modified)
      set PF0RM001.XATCD[PFWSUB] cursor, bold;
      PFWREC.PFWERRF = "Y";
    end
    PFWREC.PFWSUB = PFWREC.PFWSUB - 1;
  end
end // end PF0R107

// Val. header fields (gl&action)
Function PF0R130()
   /* -------------------------------------------------------**/
   /* This process validates the GL and Action code fields. **/
   /* -------------------------------------------------------**/

  if (PFWREC.PFWERRF == "Y"
   || PF0RW01.PF0RWBYP == "Y") /* <=== by-pass everything and redisplay*/
    return; /* ;     previous screen*/
  end

  PF0R131(); /* <=== set rows defined*/

  PF0R132(); /* <=== Validate GL/action cds & ck sec.*/

  if (PFWREC.PFWERRF == "N")

    if (PF0RW01.PF0RWEDT == "Y") /* <=== this is second time thru*/
      PFWREC.PFW1STF = "N"; /* <=== signal 2nd time thru*/
      PF0RW01.PF0RWDB2 = "Y";
                                   /* <=== set db2 update flag to 'y'*/
      if (converseVar.eventKey is pf12) /* <=== if editing only*/
        PF0RW01.PF0RWDB2 = "N"; /* <=== reset update db2 flag to 'n'*/
      end
    end

    PF0R134(); /* <=== search gl code entered*/

    PF0R136(); /* <=== Validate action requested*/

    if (PFWREC.PFWERRF == "Y")
      if (PFWREC.PFW1STF == "Y") /* <=== retain screen attr. protected*/
        return;
      end
    end

    if (PF0RM001.PF0RMACT == "A"
     || PF0RM001.PF0RMACT == "C"
     || PF0RM001.PF0RMACT == "R"
     || converseVar.eventKey is pf12)
      if (PFWREC.PFWERRF == "N")
        if (PF0RM001.PF0RMACT == "A") /* <=== init. map*/
          if (PFWREC.PFW1STF == "Y" /* <=== if first time thru, init. scrn.*/
           || PF0RM001.PF0RMACT != PF0RW01.PF0RMACT)
            PF0RW01.GLACD = PF0RM001.GLACD; /* save gl code*/
            PF0RW01.PF0RMACT = PF0RM001.PF0RMACT; /* save action code*/
            set PF0RM001 empty; /* <=== init. map*/
            PF0RM001.GLACD = PF0RW01.GLACD; /* restore glacd entered*/
            PF0RM001.PF0RMACT = PF0RW01.PF0RMACT;
            set PF0RM001.GLACD protect; /* reset attr. set at pf0r136*/
            set PF0RM001.GLASDESC cursor, normal;
          end
        end
        PF0R139(); /* <=== Set body attr. unprotect*/
      end
    end

    if (converseVar.eventKey is pf12)
      return;
    end

    if (PF0RW01.PF0RWEDT == "Y"
     && PFWREC.PFW1STF == "N") /* <=== 2nd time through*/
      PF0R140(); /* <=== Check body changed*/
      if (PF0RM001.PF0RMACT == " "
       || PF0RM001.PF0RMACT == "P") /* <=== print option*/
        if (PF0RW01.PF0RWCHG == "Y") /* <=== Body was changed*/
          converseLib.validationFailed(335); /* <=== screen was modified, action*/
                                   /* a,c,r*/
          PFWREC.PFWERRF = "Y"; /* is required, pa2 to cancel*/
          set PF0RM001.PF0RMACT cursor, bold;
          return;
        end
      end
    end

    if (PF0RM001.PF0RMACT == "P") /* <=== if action = 'print'*/
      PF0R900(); /* <=== submit the trigger batch job*/
      if (PFWREC.PFWERRF == "N")
        converseLib.validationFailed(331); /* <=== gl code table print has been submitted*/
        PFWREC.PFWERRF = "Y"; /* <=== force exit*/
        PF0RM001.PF0RMACT = " ";
      end
    end

  end /* <=== if pfwerrf = 'n'*/
end // end PF0R130

// Set rows defined
Function PF0R131()
  set PF0RM001.GLACD initialAttributes;
  set PF0RM001.PF0RMACT initialAttributes;
  set PF0RM001.GLASDESC initialAttributes;
  set PF0RM001.GLADESC initialAttributes;
  set PF0RM001.XXXSTAT initialAttributes;
  set PF0RM001.PFJXREF initialAttributes;
  set PF0RM001.YISCD initialAttributes;
  set PF0RM001.XXXGLAC1 initialAttributes;
  set PF0RM001.XXXGLAC2 initialAttributes;
  set PF0RM001.PFJARFL initialAttributes;
  set PF0RM001.PFJBNKIF initialAttributes;
  set PF0RM001.COCMFL initialAttributes;
  set PF0RM001.PFJRESFL initialAttributes;
  set PF0RM001.PFJPCTFL initialAttributes;


  PFWREC.PFWSUB1 = 1;
  while (PFWREC.PFWSUB1 <= 6)

    set PF0RM001.XGPCD[PFWSUB1] initialAttributes;
    PFWREC.PFWSUB1 = PFWREC.PFWSUB1 + 1;

  end


  PFWREC.PFWSUB1 = 1;
  while (PFWREC.PFWSUB1 <= 5)

    set PF0RM001.XATCD[PFWSUB1] initialAttributes;
    PFWREC.PFWSUB1 = PFWREC.PFWSUB1 + 1;

  end

  set PF0RM001.CATOAP initialAttributes;
  set PF0RM001.CAITEM initialAttributes;

end // end PF0R131

// Validate GL/action & check sec
Function PF0R132()
   /* ----------------------------------------------------------**/
   /* Action code entered must be ' ' 'a' 'c' 'r' or 'p'.      **/
   /* If action code is 'a', 'c', or 'r', GL code is required  **/
   /* ----------------------------------------------------------**/

  if (PF0RM001.PF0RMACT != " " 
   && PF0RM001.PF0RMACT != "A" /* <=== If add*/
   && PF0RM001.PF0RMACT != "C" /* <=== If change*/
   && PF0RM001.PF0RMACT != "R" /* <=== If replicate*/
   && PF0RM001.PF0RMACT != "P") /* <=== If print*/
    converseLib.validationFailed(334); /* <=== Invalid action*/
    PFWREC.PFWERRF = "Y";
    set PF0RM001.PF0RMACT cursor, bold;
    return;
  end

  if (PF0RM001.PF0RMACT != "P")

    if (PF0RM001.GLACD == " ")
      converseLib.validationFailed(318); /* <=== Gl code is required*/
      PFWREC.PFWERRF = "Y";
      set PF0RM001.GLACD cursor, bold;
      return;
    end
  end

   /* -----------------------------------------------------------**/
   /* Check security in commarea for action code requested.     **/
   /* -----------------------------------------------------------**/

  if (PF0RM001.PF0RMACT == "A" /* <=== if insert a row is requested*/
   || PF0RM001.PF0RMACT == "R")
    if (COMMAREA.CAADDFL == "N")
      converseLib.validationFailed(71); /* <=== lack of auth. to perform*/
                                   /* function*/
      PFWREC.PFWERRF = "Y";
      return;
    end
  end

  if (PF0RM001.PF0RMACT == "C") /* <=== if update a row is requested*/
    if (COMMAREA.CACHGFL == "N")
      converseLib.validationFailed(71);
      PFWREC.PFWERRF = "Y";
      return;
    end
  end

end // end PF0R132

// Search GL Code entered
Function PF0R134()
   /* -------------------------------------------------------**/
   /* This process searches through pf0rw02 table to find   **/
   /* the GL Code entered.  If found, the record found      **/
   /* flag (pfwrecf) will be set to 'Y'.                    **/
   /* -------------------------------------------------------**/

  PFWREC.PFWRECF = "N"; /* <=== set found flag to 'N'*/
  PFWREC.PFWIDX = 1;

  while (PF0RM001.GLACD > PF0RW02.GLACD[PFWIDX]
   && PF0RW02.GLACD[PFWIDX] != " " /* <=== end of data*/
   && PFWREC.PFWIDX <= 500)

    PFWREC.PFWIDX = PFWREC.PFWIDX + 1;

  end

  if (PF0RM001.GLACD == PF0RW02.GLACD[PFWIDX]) /* <=== record found*/
    PFWREC.PFWRECF = "Y";
  end

end // end PF0R134

// validate action requested
Function PF0R136()
   /* --------------------------------------------------*/
   /* Validates action code 'A' and sets appropriate  **/
   /* flags/attr.                                     **/
   /* --------------------------------------------------*/
  if (PF0RM001.PF0RMACT == "A")
    if (PFWREC.PFWRECF == "Y")
      converseLib.validationFailed(329); /* <=== Row already exists*/
      PFWREC.PFWERRF = "Y";
      set PF0RM001.GLACD cursor, bold; /* <=== set cursor at glacd*/
      return;
    else
      set PF0RM001.GLACD protect; /* <=== changes to GL Code is not*/
                                   /* allowed*/
      set PF0RM001.GLASDESC cursor, normal; /* <=== set cursor at gl desc*/
      PF0RW01.PF0RWEDT = "Y"; /* <=== row is to be inserted*/
      return;
    end
  end /* ;<=== if PF0RM001.PF0RMACT = 'A'*/

   /* --------------------------------------------------*/
   /* Validates action code 'C' and sets flags/attr.  **/
   /* --------------------------------------------------*/
  if (PF0RM001.PF0RMACT == "C")
    if (PFWREC.PFWRECF == "N")
      converseLib.validationFailed(336); /* <=== NRF for change*/
      PFWREC.PFWERRF = "Y";
      set PF0RM001.GLACD cursor, bold; /* <=== set cursor at glacd*/
      return;
    else
      if (PF0RM001.GLACD != PF0RW02.GLACD[PFWTBLX] /* if not same data*/
       || PF0RM001.PF0RMACT != PF0RW01.PF0RMACT)  
        PF0RW01.PF0RMACT = PF0RM001.PF0RMACT; /* save action code*/
        PFWREC.PFWTBLX = PFWREC.PFWIDX;
                                   /* save index loc. from pf0r134*/
        PF0R040(); /* <=== get data for change*/
        PF0RM001.PF0RMACT = PF0RW01.PF0RMACT; /* restore action code*/
        PFWREC.PFWERRF = "Y"; /* <=== force exit*/
      end

      set PF0RM001.GLACD protect; /* <=== changes to GL Code is not*/
                                   /* allowed*/
      set PF0RM001.GLASDESC cursor, normal; /* <=== set cursor at gl desc*/
      PF0RW01.PF0RWEDT = "Y"; /* <=== row is to be inserted*/
      return;
    end
  end

   /* --------------------------------------------------*/
   /* Validates action code 'R' and sets flags/attr.  **/
   /* --------------------------------------------------*/
  if (PF0RM001.PF0RMACT == "R")
    if (PFWREC.PFW1STF == "Y") /* <=== If 1st time thru*/
      if (PFWREC.PFWRECF == "N") /* <=== if no rows found to replicate*/
        converseLib.validationFailed(337); /* <=== NRF to replicate*/
        PFWREC.PFWERRF = "Y";
        set PF0RM001.GLACD cursor, bold;
        return;
      end
      PF0RM001.GLACD = " ";
    else
      if (PFWREC.PFWRECF == "Y")
        converseLib.validationFailed(329); /* <=== Row already exists*/
        PFWREC.PFWERRF = "Y";
        set PF0RM001.GLACD cursor, bold;
        return;
      end
    end
    PF0RW01.PF0RWEDT = "Y"; /* <=== edit data = 'y'*/
    set PF0RM001.GLACD cursor, normal; /* <=== set cursor at gl code*/
  end

  if (converseVar.eventKey is pf12)
    PF0RW01.PF0RWEDT = "Y"; /* <=== edit data = 'y'*/
  end
end // end PF0R136

// Set screen attr. unprotected
Function PF0R139()
  set PF0RM001.GLASDESC normal;

  set PF0RM001.GLADESC normal;
  set PF0RM001.XXXSTAT normal;
  set PF0RM001.PFJXREF normal;
  set PF0RM001.YISCD normal;
  set PF0RM001.XXXGLAC1 normal;
  set PF0RM001.XXXGLAC2 normal;
  set PF0RM001.PFJARFL normal;
  set PF0RM001.PFJBNKIF normal;
  set PF0RM001.COCMFL normal;
  set PF0RM001.PFJRESFL normal;
  set PF0RM001.PFJPCTFL normal;

  PFWREC.PFWSUB1 = 1;
  while (PFWREC.PFWSUB1 <= 6)

    set PF0RM001.XGPCD[PFWSUB1] normal;
    PFWREC.PFWSUB1 = PFWREC.PFWSUB1 + 1;

  end


  PFWREC.PFWSUB1 = 1;
  while (PFWREC.PFWSUB1 <= 5)

    set PF0RM001.XATCD[PFWSUB1] normal;
    PFWREC.PFWSUB1 = PFWREC.PFWSUB1 + 1;

  end

end // end PF0R139

// Check scr. fields for changes
Function PF0R140()

  PF0RW01.PF0RWCHG = "N"; /* <=== Set body changed flag to 'n'*/

  if (PF0RM001.GLASDESC != " "
   || PF0RM001.GLADESC != " "
   || PF0RM001.XXXSTAT != " "
   || PF0RM001.PFJXREF != " "
   || PF0RM001.YISCD != 0
   || PF0RM001.XXXGLAC1 != " "
   || PF0RM001.XXXGLAC2 != " "
   || PF0RM001.PFJARFL != " "
   || PF0RM001.PFJBNKIF != " "
   || PF0RM001.COCMFL != " "
   || PF0RM001.PFJRESFL != " "
   || PF0RM001.PFJPCTFL != " ")
    PF0RW01.PF0RWCHG = "Y"; /* <=== Set body changed flag to 'y'*/
    return;
  end

  PFWREC.PFWSUB1 = 1;
  while (PF0RW01.PF0RWCHG == "N"
   && PFWREC.PFWSUB1 <= 6)

    if (PF0RM001.XGPCD[PFWSUB1] != " ")
      PF0RW01.PF0RWCHG = "Y";
      return;
    end
    PFWREC.PFWSUB1 = PFWREC.PFWSUB1 + 1;

  end


  PFWREC.PFWSUB1 = 1;
  while (PF0RW01.PF0RWCHG == "N"
   && PFWREC.PFWSUB1 <= 5)

    if (PF0RM001.XATCD[PFWSUB1] != " ")
      PF0RW01.PF0RWCHG = "Y";
      return;
    end
    PFWREC.PFWSUB1 = PFWREC.PFWSUB1 + 1;

  end

end // end PF0R140

// Get data for display
Function PF0R150()

   /* --------------------------------------------------------*/
   /* This process gets data from pf0rw02 table for display. **/
   /* --------------------------------------------------------*/

  PFWREC.PFW1STF = "Y"; /* <=== first row is displayed,*/
                                 /* ;     body is protected*/
  PF0RW01.PF0RWEDT = "N"; /* <=== edit flag*/
  PF0RW01.PF0RWDB2 = "N"; /* <=== edit flag*/

  PF0R152(); /* <=== setup pointer to get*/

  if (PFWREC.PFWERRF == "Y")
    return;
  end

  if (converseVar.eventKey is enter
   || converseVar.eventKey is pf7
   || converseVar.eventKey is pf8
   || converseVar.eventKey is pa2)
    PF0R040(); /* <=== move data to map*/
  end

end // end PF0R150

// Set pointer for data access
Function PF0R152()

  if (converseVar.eventKey is pa2) /* <=== bypass everything*/
    PF0RW01.PF0RWBYP = "N"; /* <=== reset by-pass flag to 'n'*/
    return;
  end

  if (PF0RM001.GLACD is modified)
    if (PF0RM001.GLACD == PF0RW02.GLACD[PFWTBLX]) /* <=== if same glacd*/
      /* next sentence                        ;<=== bypass key search*/
    else
      PF0RW01.GLACD = PF0RM001.GLACD; /* <=== save glacd entered*/
      PF0R134(); /* <=== find gl code entered*/
      if (PFWREC.PFWRECF == "Y") /* <=== if row found*/
        PFWREC.PFWTBLX = PFWREC.PFWIDX; /* <=== save pointer*/
        return;
      else
        converseLib.validationFailed(313); /* <=== NRF for specified GL Code*/
        PFWREC.PFWERRF = "Y";
        set PF0RM001 empty; /* <=== init. map*/
        PF0R042(); /* <=== set rows protected*/
        PF0RM001.GLACD = PF0RW01.GLACD; /* <=== disp. invalid glacd*/
        set PF0RM001.GLACD cursor, modified, bold;
        return;
      end
    end
  end


  if (converseVar.eventKey is pf7)
    if (PFWREC.PFWTBLX <= 1) /* <=== at top of data*/
      converseLib.validationFailed(195); /* <=== already at top of data*/
      PFWREC.PFWERRF = "Y";
    else
      PFWREC.PFWTBLX = PFWREC.PFWTBLX - 1; /* <=== point to previous row*/
    end /* for access*/
  end

  if (converseVar.eventKey is pf8)
    if (PFWREC.PFWTBLX >= PFWREC.PFWLIMIT) /* <=== bottom of data reached*/
      converseLib.validationFailed(32);
      PFWREC.PFWERRF = "Y";
    else
      PFWREC.PFWTBLX = PFWREC.PFWTBLX + 1; /* <=== point to next row*/
    end /* or access*/
  end

end // end PF0R152

// Body validation
Function PF0R200()
   /* -------------------------------------------------------*/
   /* This process does the body validation.                   **/
   /* -------------------------------------------------------*/

  PF0R202(); /* <=== val. dissallowed XAT*/

  PF0R210(); /* <=== val. dissallowed GPC*/

  if (PF0RM001.PFJPCTFL != "N" /* <=== percent required*/
   && PF0RM001.PFJPCTFL != "Y")
    converseLib.validationFailed(323);
    set PF0RM001.PFJPCTFL cursor, bold;
  end

  PF0R220(); /* <=== val. restrict indicator*/

  if (PF0RM001.COCMFL != "N" /* <=== Commissionable flag*/
   && PF0RM001.COCMFL != "Y")
    converseLib.validationFailed(321);
    set PF0RM001.COCMFL cursor, bold;
  end

  PF0R222(); /* <=== val. GL to Bank ind.*/

  if (PF0RM001.PFJARFL != "N" /* <=== val. GL to AR indicator*/
   && PF0RM001.PFJARFL != "Y")
    converseLib.validationFailed(319);
    set PF0RM001.PFJARFL cursor, modified, bold;
  end

  if (PF0RM001.XXXGLAC2 == " ") /* <=== GL acct #2 is required*/
    converseLib.validationFailed(318);
    set PF0RM001.XXXGLAC2 cursor, bold;
  end

  if (PF0RM001.XXXGLAC1 == " ") /* <=== GL acct #2 is required*/
    converseLib.validationFailed(318);
    set PF0RM001.XXXGLAC1 cursor, bold;
  end

  PF0R230(); /* <=== val IS class*/

  PF0R234(); /* <=== val. status*/

  if (PF0RM001.GLADESC == " ") /* <=== GL long description*/
    converseLib.validationFailed(314);
    set PF0RM001.GLADESC cursor, bold;
  end

  if (PF0RM001.GLASDESC == " ") /* ;<=== GL short description*/
    converseLib.validationFailed(314);
    set PF0RM001.GLASDESC cursor, modified, bold;
  end


  if (converseVar.validationMsgNum == 0) /* <=== edit successful*/
    if (converseVar.eventKey is pf12)
      if (PF0RM001.PF0RMACT == " ") /* edit completed and successful*/
        converseLib.validationFailed(338); /* <=== enter action and ENTER to update*/
        set PF0RM001.PF0RMACT cursor, normal;
      else
        converseLib.validationFailed(339); /* <=== press enter to perform update*/
      end
    end
  else
    if (converseVar.validationMsgNum != 0)
      PFWREC.PFWERRF = "Y";
      if (converseVar.eventKey is enter)
        PF0RW01.PF0RWDB2 = "N";
      end
    end
  end

   /* ----------------------------------------**/
    /* END OF ... PF0R200-Body Validation    **/
   /* ----------------------------------------**/
end // end PF0R200

// val. disallow. acct type (xat)
Function PF0R202()

   /* ------------------------------------------------------**/
    /* This process validates the XAT codes                **/
   /* ------------------------------------------------------**/

  if (PF0RM001.XATCD[1] == " "
   && PF0RM001.XATCD[2] == " "
   && PF0RM001.XATCD[3] == " "
   && PF0RM001.XATCD[4] == " "
   && PF0RM001.XATCD[5] == " ")
    return;
  end


  PF0R800(); /* <=== check for pop-up window*/

  PF0R204(); /* <=== Validate Acct. Type Code*/

  PF0R208(); /* <=== Check blank between xatcds*/

  if (converseVar.validationMsgNum != 0)
    PFWREC.PFWERRF = "Y";
  end

end // end PF0R202

// val. xatcd against csp xattbl
Function PF0R204()
   /* ----------------------------------------------------**/
   /* This process validates the XATCD against XATTBLE   **/
   /* csp table, it must exist on this table.            **/
   /* ----------------------------------------------------**/

  PFWREC.PFWSUB1 = 5;

  while (PFWREC.PFWSUB1 >= 1)

    if (PF0RM001.XATCD[PFWSUB1] != " ")

      if (PF0RM001.XATCD[PFWSUB1] in XATTBL.XATCD)
        PF0RM001.XATABRV[PFWSUB1] = XATTBL.XATABRV[sysVar.arrayIndex];
        PF0R205(); /* check dup xat*/
        PFWREC.PFWSUB2 = 1;
        while (PFWREC.PFWSUB2 <= 5
         && PFWREC.PFWSUB1 != PFWREC.PFWSUB1)
          if (PF0RM001.XATCD[PFWSUB1] == PF0RM001.XATCD[PFWSUB2])
            converseLib.validationFailed(343); /* duplicate XAT*/
            set PF0RM001.XATCD[PFWSUB1] cursor, bold;
          end
        end
      else
        PF0RM001.XATABRV[PFWSUB1] = " ";
        converseLib.validationFailed(341); /* <=== invalid ATc, enter '?'*/
        set PF0RM001.XATCD[PFWSUB1] cursor, bold;
      end

    else
      PF0RM001.XATABRV[PFWSUB1] = " ";

    end /* <=== if xatcd(pfwsub1) NE ' '*/

    PFWREC.PFWSUB1 = PFWREC.PFWSUB1 - 1;

  end /* <=== while pfwsub1 GE 1*/

end // end PF0R204

// check duplicate xatcd
Function PF0R205()
   /* --------------------------------------------------**/
   /* This process checks for duplicate XATCD codes,   **/
   /* it is not allowed.                               **/
   /* --------------------------------------------------**/

  PFWREC.PFWSUB2 = 1;
  while (PFWREC.PFWSUB2 <= 5)
    if (PFWREC.PFWSUB1 != PFWREC.PFWSUB2)
      if (PF0RM001.XATCD[PFWSUB1] == PF0RM001.XATCD[PFWSUB2])
        converseLib.validationFailed(343); /* duplicate XAT*/
        set PF0RM001.XATCD[PFWSUB1] cursor, bold;
      end
    end

    PFWREC.PFWSUB2 = PFWREC.PFWSUB2 + 1;

  end
end // end PF0R205

// check blanks between xatcd
Function PF0R208()
   /* ------------------------------------------------------**/
   /* An Account Type Code is not required, however        **/
   /* if ATs are entered, they must be entered so that     **/
   /* there are no blank ATs between them.                 **/
   /* ------------------------------------------------------**/

  PFWREC.PFWSUB1 = 5; /* <=== val. from bottom up*/

  while (PFWREC.PFWSUB1 >= 1)

    if (PF0RM001.XATCD[PFWSUB1] != " " /* <=== if Acct. Code exists*/
     && PFWREC.PFWSUB1 > 1)           
      PFWREC.PFWSUB1 = PFWREC.PFWSUB1 - 1;

      while (PFWREC.PFWSUB1 >= 1
       && PF0RM001.XATCD[PFWSUB1] == " ")
        converseLib.validationFailed(327); /* <=== blank bet. ATs not allowed*/
        set PF0RM001.XATCD[PFWSUB1] cursor, bold;
        PFWREC.PFWSUB1 = PFWREC.PFWSUB1 - 1;
      end

    else /* <=== if xatcd ^= ' '*/
      PFWREC.PFWSUB1 = PFWREC.PFWSUB1 - 1;
    end

  end /* ;<=== while pfwrec.pfwsub1 > 1*/
end // end PF0R208

// val. disallow. GPC
Function PF0R210()
   /* ------------------------------------------------------**/
    /* This process validates the XGPC codes               **/
   /* ------------------------------------------------------**/


  if (PF0RM001.XGPCD[1] == " "
   && PF0RM001.XGPCD[2] == " "
   && PF0RM001.XGPCD[3] == " "
   && PF0RM001.XGPCD[4] == " "
   && PF0RM001.XGPCD[5] == " "
   && PF0RM001.XGPCD[6] == " ")
    return;
  end

  PF0R810(); /* <=== check for pop-up window*/

  PF0R212(); /* <=== Validate GPC*/

  PF0R216(); /* <=== Check blank between xgpcds*/

  if (converseVar.validationMsgNum != 0)
    PFWREC.PFWERRF = "Y";
  end

end // end PF0R210

// val. GPC
Function PF0R212()
   /* ----------------------------------------------------**/
   /* This process validates the XGPCD against XgpTBLE   **/
   /* csp table, it must exist on this table.            **/
   /* ----------------------------------------------------**/

  PFWREC.PFWSUB1 = 6;

  while (PFWREC.PFWSUB1 >= 1)

    if (PF0RM001.XGPCD[PFWSUB1] != " ")

      if (PF0RM001.XGPCD[PFWSUB1] in XGPTBL.XGPCD)
        PF0RM001.XGPABRV[PFWSUB1] = XGPTBL.XGPABRV[sysVar.arrayIndex];
        PF0R213(); /* <=== check dup. xgpc*/
      else
        PF0RM001.XGPABRV[PFWSUB1] = " ";
        converseLib.validationFailed(342);
                                   /* ;<=== invalid GPc, enter '?'*/
        set PF0RM001.XGPCD[PFWSUB1] cursor, bold;
      end

    else
      PF0RM001.XGPABRV[PFWSUB1] = " ";
    end /* ;<=== if xgpcd(pfwsub1) ne ' '*/

    PFWREC.PFWSUB1 = PFWREC.PFWSUB1 - 1;

  end /* ;<=== while pfwsub1 GE 1*/


end // end PF0R212

// check duplicate xgpc codes
Function PF0R213()
   /* --------------------------------------------------**/
   /* This process checks for duplicate XGPCD codes,   **/
   /* it is not allowed.                               **/
   /* --------------------------------------------------**/


  PFWREC.PFWSUB2 = 1;
  while (PFWREC.PFWSUB2 <= 6)
    if (PFWREC.PFWSUB1 != PFWREC.PFWSUB2)
      if (PF0RM001.XGPCD[PFWSUB1] == PF0RM001.XGPCD[PFWSUB2])
        converseLib.validationFailed(344); /* duplicate XGP*/
        set PF0RM001.XGPCD[PFWSUB1] cursor, bold;
      end
    end

    PFWREC.PFWSUB2 = PFWREC.PFWSUB2 + 1;

  end
end // end PF0R213

// Check blank between xgpcds
Function PF0R216()
   /* ------------------------------------------------------**/
   /* A GPC code is not required, however if GPC codes are **/
   /* entered, they must be entered so that there are no   **/
   /* blank GPC codes between them.                        **/
   /* ------------------------------------------------------**/


  PFWREC.PFWSUB1 = 6; /* <=== val. from bottom up*/

  while (PFWREC.PFWSUB1 >= 1)

    if (PF0RM001.XGPCD[PFWSUB1] != " " /* <=== if GPC exists*/
     && PFWREC.PFWSUB1 > 1)           
      PFWREC.PFWSUB1 = PFWREC.PFWSUB1 - 1;

      while (PFWREC.PFWSUB1 >= 1
       && PF0RM001.XGPCD[PFWSUB1] == " ")
        converseLib.validationFailed(325); /* <=== blank bet. GPCs not allowed*/
        set PF0RM001.XGPCD[PFWSUB1] cursor, bold;
        PFWREC.PFWSUB1 = PFWREC.PFWSUB1 - 1;
      end

    else /* <=== if xgpcd ^= ' '*/
      PFWREC.PFWSUB1 = PFWREC.PFWSUB1 - 1;
    end

  end /* ;<=== while pfwrec.pfwsub1 > 1*/
end // end PF0R216

// val. restricted indicator
Function PF0R220()
  if (PF0RM001.PFJRESFL != "N" /* <===*/
   && PF0RM001.PFJRESFL != "P" 
   && PF0RM001.PFJRESFL != "A" 
   && PF0RM001.PFJRESFL != "B")
    converseLib.validationFailed(322);
    set PF0RM001.PFJRESFL cursor, bold;
  end

end // end PF0R220

// Val. GL to Bank indicator
Function PF0R222()
  if (PF0RM001.PFJBNKIF != "A"
   && PF0RM001.PFJBNKIF != "C"
   && PF0RM001.PFJBNKIF != "N"
   && PF0RM001.PFJBNKIF != "F")
    converseLib.validationFailed(320);
    set PF0RM001.PFJBNKIF cursor, bold;
  end

end // end PF0R222

// val. IS Class
Function PF0R230()
   /* ----------------------------------------------------**/
   /* This process validates the YISCD against YISTBL    **/
   /* csp table, it must exist on this table.            **/
   /* ----------------------------------------------------**/

  if (PF0RM001.YISCD in YISTBL.YISCD)

    if (YISTBL.XXXSTAT[sysVar.arrayIndex] != "A") /* <=== Inactive IS Class*/
      converseLib.validationFailed(317);
      set PF0RM001.YISCD cursor, bold;
    else
      PF0RM001.YISABRV = YISTBL.YISABRV[sysVar.arrayIndex];
    end

  else
    PF0RM001.YISABRV = " ";
    converseLib.validationFailed(316); /* <=== IS Class not found*/
    set PF0RM001.YISCD cursor, bold;
  end
end // end PF0R230

// val status
Function PF0R234()

  if (PF0RM001.XXXSTAT == "A")
    PF0RM001.PF0RMSTA = "ACTIVE";
  else
    if (PF0RM001.XXXSTAT == "I")
      PF0RM001.PF0RMSTA = "INACTIVE";
    else
      PF0RM001.PF0RMSTA = " ";
      converseLib.validationFailed(315); /* <=== value must 'A'ctive, 'I'nactive*/
      set PF0RM001.XXXSTAT cursor, bold;
    end
  end
end // end PF0R234

// do ADD/REPLICATE Routine
Function PF0R400()
   /* ---------------------------------------------------------**/
   /* This process inserts a row into VGLCDS01 DB2 table.     **/
   /* If successful, it also inserts that same row into       **/
   /* pf0rw02 table so that pf0rw02 exactly match with DB2    **/
   /* table VGLCDS01.                                        **/
   /* ---------------------------------------------------------**/

  set PFJREC empty; /* <=== clear passing w/s record*/

  PF0R402(); /* <=== setup data for add*/

  XPPF030(); /* <=== get current date/time*/
  PFJREC.ZZZSDT = TA2REC.TA2GRGGN;
  PFJREC.ZZZCHGDT = TA2REC.TA2GRGGN;
  PFJREC.ZZZCHGTM = TA2REC.TA2TIMHM;
  PFJREC.ZZZCHGCT = 0;

  call "IO4360" ("A ", SQLCA, PFJREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == +0)
    converseLib.validationFailed(330); /* <=== add successful*/
  else
    if (SQLCA.VAGen_SQLCODE == -911) /* <=== deadlock occurred*/
      converseLib.validationFailed(340); /* <=== data base was busy, re-try*/
      PFWREC.PFWERRF = "Y";
    else
      TA1REC.TA1DBASE = "DPROFT"; /* abend the application*/
      TA1REC.TA1TBLVU = "VGLCDS01";
      TA1REC.TA1TBLKE = PF0RM001.GLACD; /* save key*/
      TA1REC.TA1LOCAT[3] = "PF0R400";
      TA1REC.TA1LOCAT[4] = "IO4360";
      XPPF010(); /* <=== abend application*/
    end
  end

   /* -------------------------------------------------------**/
   /* If insert was successful, checks for pf0rw02 table    **/
   /* for overflow.  If no errors, add row to pf0rw02 table.**/
   /* -------------------------------------------------------**/

  if (SQLCA.VAGen_SQLCODE == +0)
    PFWREC.PFWSUB1 = 500; /* <=== set index at bottom of array*/

    if (PF0RW02.GLACD[PFWSUB1] != " ") /* <=== row exists at bottom of array*/
      PFWREC.PFWCPROC = "PF0R410C"; /* <=== pass calling process*/
      PFWREC.PFWHKEY = "CSP TABLE OVERFLOW";
      TA1REC.TA1LOCAT[4] = " ";
      TA1REC.TA1DBASE = " ";
      TA1REC.TA1TBLVU = "VGLCDS01";
      XPPF010(); /* <=== abend routine*/
    end

    PF0R410(); /* <=== update ws2 array*/
    PF0RW02.ZZZSDT[PFWTBLX] = PFJREC.ZZZSDT;
    PF0RW02.ZZZCHGDT[PFWTBLX] = PFJREC.ZZZCHGDT;
    PF0RW02.ZZZCHGTM[PFWTBLX] = PFJREC.ZZZCHGTM;
    PF0RW02.ZZZCHGCT[PFWTBLX] = 0;

  end
end // end PF0R400

// setup data for update
Function PF0R402()
   /* -----------------------------------------------------------**/
   /* This process moves the current screen information to      **/
   /* PFJREC to update db2 table VGLCDS01.                      **/
   /* -----------------------------------------------------------**/

  PFJREC.GLACD = PF0RM001.GLACD;
  PFJREC.GLASDESC = PF0RM001.GLASDESC;
  PFJREC.GLADESC = PF0RM001.GLADESC;

  PFJREC.XXXSTAT = PF0RM001.XXXSTAT;
  PFJREC.YISCD = PF0RM001.YISCD;
  PFJREC.PFJXREF = PF0RM001.PFJXREF;
  PFJREC.XXXGLAC1 = PF0RM001.XXXGLAC1;
  PFJREC.XXXGLAC2 = PF0RM001.XXXGLAC2;

  PFJREC.PFJARFL = PF0RM001.PFJARFL;
  PFJREC.PFJBNKIF = PF0RM001.PFJBNKIF;
  PFJREC.COCMFL = PF0RM001.COCMFL;
  PFJREC.PFJRESFL = PF0RM001.PFJRESFL;
  PFJREC.PFJPCTFL = PF0RM001.PFJPCTFL;

  PFWREC.PFWSUB1 = 1;

  while (PFWREC.PFWSUB1 <= 6)
    PFJREC.XGPCD[PFWSUB1] = PF0RM001.XGPCD[PFWSUB1];
    PFWREC.PFWSUB1 = PFWREC.PFWSUB1 + 1;
  end

  PFWREC.PFWSUB1 = 1;

  while (PFWREC.PFWSUB1 <= 5)
    PFJREC.XATCD[PFWSUB1] = PF0RM001.XATCD[PFWSUB1];
    PFWREC.PFWSUB1 = PFWREC.PFWSUB1 + 1;
  end

end // end PF0R402

// update ws2 arrays
Function PF0R410()
   /* -------------------------------------------------------**/
   /* This process adds a row into pf0rw02 table so that    **/
   /* it is the mirror image of the DB2 table vglcds01.     **/
   /* It also add 1 to pf0rw02 table limit (PFWLIMIT).      **/
   /* -------------------------------------------------------**/

  PFWREC.PFWSUB1 = 500;
                                   /* ;<=== point to last row in array*/
  while (PF0RW02.GLACD[PFWSUB1] == " " /* <=== eliminate empty row*/
   && PFWREC.PFWSUB1 >= 1)
    PFWREC.PFWSUB1 = PFWREC.PFWSUB1 - 1;
  end

  PFWREC.PFWSUB2 = PFWREC.PFWSUB1 + 1;
  while (PFWREC.PFWSUB1 >= 1
   && PF0RM001.GLACD < PF0RW02.GLACD[PFWSUB1])
    PF0R412(); /* <=== move ws2 row down*/
    PFWREC.PFWSUB2 = PFWREC.PFWSUB2 - 1;
    PFWREC.PFWSUB1 = PFWREC.PFWSUB1 - 1;
  end

  PFWREC.PFWTBLX = PFWREC.PFWSUB2;
  PFWREC.PFWLIMIT = PFWREC.PFWLIMIT + 1;

  PF0R414(); /* <=== update ws2 data = db2 data*/
end // end PF0R410

// move ws2 entry down
Function PF0R412()
   /* -----------------------------------------------------------**/
   /* This process shifts ws2 row to the next location in array **/
   /* to allow space to insert the new row added.               **/
   /* ------------------------------------------------------------*/

  PF0RW02.GLACD[PFWSUB2] = PF0RW02.GLACD[PFWSUB1];
  PF0RW02.GLASDESC[PFWSUB2] = PF0RW02.GLASDESC[PFWSUB1];
  PF0RW02.GLADESC[PFWSUB2] = PF0RW02.GLADESC[PFWSUB1];

  PF0RW02.XXXSTAT[PFWSUB2] = PF0RW02.XXXSTAT[PFWSUB1];
  PF0RW02.PFJXREF[PFWSUB2] = PF0RW02.PFJXREF[PFWSUB1];
  PF0RW02.YISCD[PFWSUB2] = PF0RW02.YISCD[PFWSUB1];
  PF0RW02.XXXGLAC1[PFWSUB2] = PF0RW02.XXXGLAC1[PFWSUB1];
  PF0RW02.XXXGLAC2[PFWSUB2] = PF0RW02.XXXGLAC2[PFWSUB1];

  PF0RW02.PFJARFL[PFWSUB2] = PF0RW02.PFJARFL[PFWSUB1];
  PF0RW02.PFJBNKIF[PFWSUB2] = PF0RW02.PFJBNKIF[PFWSUB1];
  PF0RW02.COCMFL[PFWSUB2] = PF0RW02.COCMFL[PFWSUB1];
  PF0RW02.PFJRESFL[PFWSUB2] = PF0RW02.PFJRESFL[PFWSUB1];
  PF0RW02.PFJPCTFL[PFWSUB2] = PF0RW02.PFJPCTFL[PFWSUB1];

  PF0RW02.XGPCD1[PFWSUB2] = PF0RW02.XGPCD1[PFWSUB1];
  PF0RW02.XGPCD2[PFWSUB2] = PF0RW02.XGPCD2[PFWSUB1];
  PF0RW02.XGPCD3[PFWSUB2] = PF0RW02.XGPCD3[PFWSUB1];
  PF0RW02.XGPCD4[PFWSUB2] = PF0RW02.XGPCD4[PFWSUB1];
  PF0RW02.XGPCD5[PFWSUB2] = PF0RW02.XGPCD5[PFWSUB1];
  PF0RW02.XGPCD6[PFWSUB2] = PF0RW02.XGPCD6[PFWSUB1];

  PF0RW02.XATCD1[PFWSUB2] = PF0RW02.XATCD1[PFWSUB1];
  PF0RW02.XATCD2[PFWSUB2] = PF0RW02.XATCD2[PFWSUB1];
  PF0RW02.XATCD3[PFWSUB2] = PF0RW02.XATCD3[PFWSUB1];
  PF0RW02.XATCD4[PFWSUB2] = PF0RW02.XATCD4[PFWSUB1];
  PF0RW02.XATCD5[PFWSUB2] = PF0RW02.XATCD5[PFWSUB1];

  PF0RW02.ZZZSDT[PFWSUB2] = PF0RW02.ZZZSDT[PFWSUB1];
  PF0RW02.ZZZCHGDT[PFWSUB2] = PF0RW02.ZZZCHGDT[PFWSUB1];
  PF0RW02.ZZZCHGTM[PFWSUB2] = PF0RW02.ZZZCHGTM[PFWSUB1];
  PF0RW02.ZZZCHGCT[PFWSUB2] = PF0RW02.ZZZCHGCT[PFWSUB1];

end // end PF0R412

// set ws2 row = db2 row
Function PF0R414()
   /* -----------------------------------------------------**/
   /* This process sets row in pf0rw02 table equals to    **/
   /* updated row in DB2 table VGLCDS01.                  **/
   /* -----------------------------------------------------**/

  PF0RW02.GLACD[PFWTBLX] = PF0RM001.GLACD;
  PF0RW02.GLASDESC[PFWTBLX] = PF0RM001.GLASDESC;
  PF0RW02.GLADESC[PFWTBLX] = PF0RM001.GLADESC;

  PF0RW02.XXXSTAT[PFWTBLX] = PF0RM001.XXXSTAT;
  PF0RW02.PFJXREF[PFWTBLX] = PF0RM001.PFJXREF;
  PF0RW02.YISCD[PFWTBLX] = PF0RM001.YISCD;
  PF0RW02.XXXGLAC1[PFWTBLX] = PF0RM001.XXXGLAC1;
  PF0RW02.XXXGLAC2[PFWTBLX] = PF0RM001.XXXGLAC2;

  PF0RW02.PFJARFL[PFWTBLX] = PF0RM001.PFJARFL;
  PF0RW02.PFJBNKIF[PFWTBLX] = PF0RM001.PFJBNKIF;
  PF0RW02.COCMFL[PFWTBLX] = PF0RM001.COCMFL;
  PF0RW02.PFJRESFL[PFWTBLX] = PF0RM001.PFJRESFL;
  PF0RW02.PFJPCTFL[PFWTBLX] = PF0RM001.PFJPCTFL;

  PF0RW02.XGPCD1[PFWTBLX] = PF0RM001.XGPCD[1];
  PF0RW02.XGPCD2[PFWTBLX] = PF0RM001.XGPCD[2];
  PF0RW02.XGPCD3[PFWTBLX] = PF0RM001.XGPCD[3];
  PF0RW02.XGPCD4[PFWTBLX] = PF0RM001.XGPCD[4];
  PF0RW02.XGPCD5[PFWTBLX] = PF0RM001.XGPCD[5];
  PF0RW02.XGPCD6[PFWTBLX] = PF0RM001.XGPCD[6];

  PF0RW02.XATCD1[PFWTBLX] = PF0RM001.XATCD[1];
  PF0RW02.XATCD2[PFWTBLX] = PF0RM001.XATCD[2];
  PF0RW02.XATCD3[PFWTBLX] = PF0RM001.XATCD[3];
  PF0RW02.XATCD4[PFWTBLX] = PF0RM001.XATCD[4];
  PF0RW02.XATCD5[PFWTBLX] = PF0RM001.XATCD[5];


end // end PF0R414

// Do UPDATE VGLCDS01 Routine
Function PF0R500()
   /* -------------------------------------------------------**/
   /* This process updates a row onto VGLCDS01 DB2 table.   **/
   /* If successful, it also updates the pf0rw02 table so   **/
   /* that pf0rw02 exactly match with db2 table vglcds01.   **/
   /* -------------------------------------------------------**/

  set PFJREC empty;

  PF0R402(); /* <=== set up data for update*/

  XPPF030(); /* <=== get current date/time*/
  PFJREC.ZZZCHGDT = TA2REC.TA2GRGGN;
  PFJREC.ZZZCHGTM = TA2REC.TA2TIMHM;
  PFJREC.ZZZCHGCT = PF0RW02.ZZZCHGCT[PFWTBLX];
  PFJREC.ZZZSDT = PF0RW02.ZZZSDT[PFWTBLX];

  call "IO4360" ("U ", SQLCA, PFJREC) {isNoRefresh = yes, isExternal = yes}; /* <=== DB2 UPDATE*/

  if (SQLCA.VAGen_SQLCODE == +0)
    converseLib.validationFailed(330); /* <=== update successful msg*/
  else
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(340); /* <=== deadlock occurred,*/
      PFWREC.PFWERRF = "Y"; /* try again*/
    else
      TA1REC.TA1LOCAT[2] = " ";
      PFWREC.PFWCPROC = "PF0R500";
      TA1REC.TA1LOCAT[4] = "IO4360";
      TA1REC.TA1DBASE = "DPROFT";
      TA1REC.TA1TBLVU = "VGLCDS01";
      XPPF010(); /* <=== abend routine*/
    end
  end

  if (SQLCA.VAGen_SQLCODE == +0)

    PF0R414(); /* <=== update ws2 array using current*/
                                   /* screen info.*/
    PF0RW02.ZZZSDT[PFWTBLX] = PFJREC.ZZZSDT;
    PF0RW02.ZZZCHGDT[PFWTBLX] = PFJREC.ZZZCHGDT;
    PF0RW02.ZZZCHGTM[PFWTBLX] = PFJREC.ZZZCHGTM;
    PF0RW02.ZZZCHGCT[PFWTBLX] = PF0RW02.ZZZCHGCT[PFWTBLX] + 1;

  end
end // end PF0R500

// xattbl pop-up window
Function PF0R800()
  PFWREC.PFDCDVAL[1] = PF0RM001.XATCD[1];
  PFWREC.PFDCDVAL[2] = PF0RM001.XATCD[2];
  PFWREC.PFDCDVAL[3] = PF0RM001.XATCD[3];
  PFWREC.PFDCDVAL[4] = PF0RM001.XATCD[4];
  PFWREC.PFDCDVAL[5] = PF0RM001.XATCD[5];


  PFWREC.PFWSUB = 1;
  while (PFWREC.PFWSUB < 6)
    if (PFWREC.PFDCDVAL[PFWSUB] == "?") /* <=== if help window requested*/

      XPXX001(); /* <=== initialize pop-up window*/

      PF0R802(); /* <=== get value and disp. wind.*/

      PF0RM001.XATCD[PFWSUB] = PFWREC.PFWCD2[PFWSUB];

    end

    PFWREC.PFWSUB = PFWREC.PFWSUB + 1;
  end

  set XX0XM001 empty;
end // end PF0R800

// Select xatcd & display window
Function PF0R802()

  XX0XW02.XX0XWHDR = "      ACCOUNT TYPE CODE       ";

  while (XX0XW02.XX0XWEND == "N") /* <=== while window active*/

    XPXAT01(); /* <=== converse xattbl pop-up window*/

  end

  if (XX0XW02.XX0XWPIX > 0)
    PFWREC.PFDCDVAL[PFWSUB] = XATTBL.XATCD[XX0XWPIX];
  else
    PFWREC.PFDCDVAL[PFWSUB] = " "; /* <=== pass back spaces*/
  end

end // end PF0R802

// xgptbl pop-up window
Function PF0R810()
  PFWREC.PFDCDVAL[1] = PF0RM001.XGPCD[1];
  PFWREC.PFDCDVAL[2] = PF0RM001.XGPCD[2];
  PFWREC.PFDCDVAL[3] = PF0RM001.XGPCD[3];
  PFWREC.PFDCDVAL[4] = PF0RM001.XGPCD[4];
  PFWREC.PFDCDVAL[5] = PF0RM001.XGPCD[5];
  PFWREC.PFDCDVAL[6] = PF0RM001.XGPCD[6];


  PFWREC.PFWSUB = 1;
  while (PFWREC.PFWSUB < 7)
    if (PFWREC.PFDCDVAL[PFWSUB] == "?") /* <=== if window requested*/

      XPXX001(); /* <=== initialize pop-up window*/

      PF0R812(); /* <=== get value and disp. wind.*/

      PF0RM001.XGPCD[PFWSUB] = PFWREC.PFWCD2[PFWSUB];

    end

    PFWREC.PFWSUB = PFWREC.PFWSUB + 1;
  end

  converseLib.clearScreen();

end // end PF0R810

// Select xgpcd & display window
Function PF0R812()
  XX0XW02.XX0XWHDR = "    GENERAL PRODUCT CLASS     ";

  while (XX0XW02.XX0XWEND == "N") /* <=== while window active*/

    XPXGP01(); /* <=== converse xgptbl pop-up window*/

  end

  if (XX0XW02.XX0XWPIX > 0)
    PFWREC.PFDCDVAL[PFWSUB] = XGPTBL.XGPCD[XX0XWPIX];
  else
    PFWREC.PFDCDVAL[PFWSUB] = " "; /* <=== pass back spaces*/
  end

end // end PF0R812

// submit the trigger job
Function PF0R900()
   /* -----------------------------------------------------------;*/
      /* Submit the trigger job.                                ;*/
   /* -----------------------------------------------------------;*/

  PF0R902(); /* <=== open the internal reader*/

  PFWREC.PFWSUB = 1; /* <=== set table index*/

  while (PF0RT01.PF0RTJCL[PFWSUB] != "###END OF TABLE###"
   && PFWREC.PFWERRF == "N")
    PF0RW90.PF0RWJCL = PF0RT01.PF0RTJCL[PFWSUB]; /* <=== jcl card*/

    PF0R904(); /* <=== add row to internal reader*/

    PFWREC.PFWSUB = PFWREC.PFWSUB + 1; /* <=== increment table index*/
  end

  PF0R906(); /* <=== close internal table*/

  converseLib.validationFailed(331); /* <=== print GL Code request submitted*/
end // end PF0R900

// open internal reader
Function PF0R902()
   /* -----------------------------------------------------------;*/
     /* Enque the Internal Reader queue for job submission.     ;*/
   /* -----------------------------------------------------------;*/

  set UT2REC empty; /* Initialize subroutine parameters*/

  UT2REC.UT2FUNCT = "E"; /* Subroutine function*/
  UT2REC.UT2RSCLN = 8; /* Resource identification length*/
  UT2REC.UT2RSCID = "INTR"; /* Resource identification*/

  call "UT0220" (UT2REC) {isNoRefresh = yes, isExternal = yes}; /* Enque reader*/

  if (UT2REC.UT2RETCD != 0) /* Non-zero return code*/
    converseLib.validationFailed(114); /* database was busy; please retry*/
    PFWREC.PFWERRF = "Y";
  end
end // end PF0R902

// add row to internal reader
Function PF0R904()
  try
    add PF0RW90 ;
  end

  if (sysVar.errorCode != "00000000") /* Non-zero return code*/
    TA1REC.TA1TYPE = "APPL"; /* Type of error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    TA1REC.TA1PGMNM = "PF0R904 "; /* Process name*/
    TA1REC.TA1LOC = "WRITE JCL TO INTERNAL READER";
    TA1REC.TA1MAP = sysVar.errorCode; /* Return code*/
    SQLCA.SQLCAREC = PF0RW90.PF0RWJCL; /* Error information*/

    call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    converseLib.validationFailed(114); /* Indicate system error*/
    PFWREC.PFWERRF = "Y";
  end
end // end PF0R904

// close internal reader
Function PF0R906()
   /* -----------------------------------------------------------;*/
     /* Deque the Internal Reader queue after job submission.   ;*/
   /* -----------------------------------------------------------;*/
  set UT2REC empty; /* Initialize subroutine parameters*/

  UT2REC.UT2FUNCT = "D"; /* Subroutine function*/
  UT2REC.UT2RSCLN = 8; /* Resource identification length*/
  UT2REC.UT2RSCID = "INTR"; /* Resource identification*/

  call "UT0220" (UT2REC) {isNoRefresh = yes, isExternal = yes}; /* Enque reader*/

  if (UT2REC.UT2RETCD != 0) /* Non-zero return code*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    TA1REC.TA1TYPE = "APPL"; /* Type of error*/
    TA1REC.TA1PGMNM = "PF0R906"; /* Process name*/
    TA1REC.TA1LOC = "DEQUE THE SYSTEM INTERNAL READER";
    SQLCA.SQLCAREC = UT2REC.UT2GRPLV; /* Error information*/

    call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    converseLib.validationFailed(114); /* database was busy; please retry*/
    PFWREC.PFWERRF = "Y";
  end
end // end PF0R906

//*** RECORD=PF0RW01 ****
// Application PF0R main working storage.
// ***********************
Record PF0RW01 type basicRecord
  10 GLACD GLACD ; 
  10 PF0RMACT PF0RMACT ; 
  10 PF0RWEDT PF0RWEDT ; 
  10 PF0RWDB2 PF0RWDB2 ; 
  10 PF0RWBYP PF0RWBYP ; 
  10 PF0RWCHG PF0RWCHG ; 
  10 PF0RWDBZ PF0RWDBZ ; 
end // end PF0RW01

//*** RECORD=PF0RW02 ****
// This working storage contains the entire GL code table
// loaded from VGLCDS01 DB2 table.
// 06/05/92  mkamin  increased occurs to 500 from 250.
// ***********************
Record PF0RW02 type basicRecord
  10 GLACD GLACD [500] ; 
  10 GLADESC GLADESC [500] ; 
  10 GLASDESC GLASDESC [500] ; 
  10 PFJXREF PFJXREF [500] ; 
  10 YISCD YISCD [500] ; 
  10 PFJARFL PFJARFL [500] ; 
  10 PFJBNKIF PFJBNKIF [500] ; 
  10 COCMFL COCMFL [500] ; 
  10 PFJRESFL PFJRESFL [500] ; 
  10 PFJPCTFL PFJPCTFL [500] ; 
  10 XATCD1 XATCD1 [500] ; 
  10 XATCD2 XATCD2 [500] ; 
  10 XATCD3 XATCD3 [500] ; 
  10 XATCD4 XATCD4 [500] ; 
  10 XATCD5 XATCD5 [500] ; 
  10 XGPCD1 XGPCD1 [500] ; 
  10 XGPCD2 XGPCD2 [500] ; 
  10 XGPCD3 XGPCD3 [500] ; 
  10 XGPCD4 XGPCD4 [500] ; 
  10 XGPCD5 XGPCD5 [500] ; 
  10 XGPCD6 XGPCD6 [500] ; 
  10 XXXGLAC1 XXXGLAC1 [500] ; 
  10 XXXGLAC2 XXXGLAC2 [500] ; 
  10 XXXSTAT XXXSTAT [500] ; 
  10 ZZZSDT ZZZSDT [500] ; 
  10 ZZZCHGDT ZZZCHGDT [500] ; 
  10 ZZZCHGTM ZZZCHGTM [500] ; 
  10 ZZZCHGCT ZZZCHGCT [500] ; 
end // end PF0RW02

//*** RECORD=PF0RW90 ****
// System internal reader queue (INTR) record definition.
// ***********************
Record PF0RW90 type serialRecord  {
  fileName = "INTR"
  }
  10 PF0RWJCL PF0RWJCL ; 
end // end PF0RW90

// Action code
DataItem PF0RMACT char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// By pass editing flag
DataItem PF0RWBYP char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Body changed flag
DataItem PF0RWCHG char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Update db2 flag
DataItem PF0RWDB2 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Data base flag
DataItem PF0RWDBZ char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Edit body.. pf12/action coded
DataItem PF0RWEDT char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// jcl card image for reader
DataItem PF0RWJCL char(80)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// XAT_ACCT_TYP_CD1
DataItem XATCD1 char(2)  {
  align = none, fillCharacter = nullFill, inputRequired = no
}
end

// XAT_ACCT_TYP_CD2
DataItem XATCD2 char(2)  {
  align = none, fillCharacter = nullFill, inputRequired = no
}
end

// XAT_ACCT_TYP_CD3
DataItem XATCD3 char(2)  {
  align = none, fillCharacter = nullFill, inputRequired = no
}
end

// XAT_ACCT_TYP_CD4
DataItem XATCD4 char(2)  {
  align = none, fillCharacter = nullFill, inputRequired = no
}
end

// XAT_ACCT_TYP_CD5
DataItem XATCD5 char(2)  {
  align = none, fillCharacter = nullFill, inputRequired = no
}
end

