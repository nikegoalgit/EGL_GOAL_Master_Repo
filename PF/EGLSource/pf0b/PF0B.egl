package pf0b;
import corpcom2.XX0XW01;
import corpcom2.XX0XW02;
import corpcom2.YSMREC;
import corpcom3.XPPF002;
import corpcom3.XPPF010;
import corpcom3.XPPF200;
import corpcom3.XPPF300;
import corpcom3.XPPF400;
import corpcom4.XSENTRY;
import corpcom4.XSEXIT;
import corpcom4.XSPF1;
import corpcom4.XSPF4;
import corpcom4.XSSEGTR;
import corpcom5.COMMAREA;
import corpcom5.ERRSQLCA;
import corpcom6.SQLCA;
import pf.common.*;
import sm.common.SM1REC;
import sy.common.SY1REC;
import sy.common.SYCREC;
import ta.common.TA1REC;
import ta.common.TA2REC;
import xx.common.*;
import xx01.*;
import xx02.*;
import xx03.*;
import xx04.*;
import xx05.*;
import xx06.*;
import xx07.*;
import xx08.*;
import xx09.*;
import xx10.*;
//*** PROGRAM=PF0B ****
// this application is the main driver for users to view
// summaries. the user will enter a summary name; pf0b will
// return a screen with the reporting attributes of that
// summary. the user will then enter source code value(s) for
// those reporting attributes that are to be used as a starting
// position for viewing. the source codes will be edited using
// the reporting attribute record(dproft.vrptat01) or the csp
// table corresponding to the attribute. once the entered
// values are edited, pf0b will verify that the starting
// viewing position is in the summary(dproft.vsumry01). pf0b
// then transfers the starting position to the application
// that displays the format requested as follows :
//  format #         application to transfer to
//  --------         --------------------------
//     1               pf0k
//     2               pf0l
//     3               pf0m
//     4               pf0n
//     5               pf0o
// 
// maintenance history:
//   date     by           description of change
// --------  -----  -------------------------------------------
//  1-03-89   mh    original transfer to production.
//  2-16-89   mh    move attr. code value returned from edit
//                  routine(xppf400) back to map.
//  3-13-89   mh    chg. default viewing level from
//                              'sum' to 'det'.
//  3-16-89   mh    chg. default viewing level back to
//                              'sum' from 'det'.
//  4-19-89   DLC   Set cursor to first value field before
//                  second converse.  EZERTN if summary not
//                  found.  Highlight sum name if sum is not
//                  created.
//  6-21-89   DLC   Change Summary Order Type to Base Order
//                  Type (XOBTBL).
//  7-13-89   DLC   Re-Gen for changes to YFATBL, YMATBL,
//                  YMBTBL, and YMCTBL.
//  8-31-89  jwood  removed ypgtbl from tbl list as per dc
// 11-29-89   TBG   loaded commarea properly before return
//                  to pf0c with pf1rec.
//  4-05-90  cvo    Init. body fields when a new summary
//                  name is entered.
//  4-15-94  mjk    changes for new attributes.
//  3-01-96  MBUHIT Regen for GCOA mod to YICTBL.
// 11-19-97  mleabo Re-gen for changes to YSETBL, YSFTBL.
// *********************
Program PF0B type textUIProgram //VAGen Info - main text program
  {
  includeReferencedFunctions = yes, allowUnqualifiedItemReferences = yes, 
  throwNrfEofExceptions = yes, handleHardIOErrors = no, V60ExceptionCompatibility = yes, 
  I4GLItemsNullable = no, textLiteralDefaultIsString = no, localSQLScope = yes, 
  msgTablePrefix = "PF00", inputRecord = COMMAREA, segmented = yes
  }

  // Data Declarations
  COMMAREA COMMAREA ; // record
  ERRSQLCA ERRSQLCA; // record
  PF0BW01 PF0BW01; // record
  PF1REC PF1REC; // record
  PF2REC PF2REC; // record
  PFAREC PFAREC; // record
  PFBREC PFBREC; // record
  PFCREC PFCREC; // record
  PFDREC PFDREC; // record
  PFEREC PFEREC; // record
  PFGREC PFGREC; // record
  PFIREC PFIREC; // record
  PFWREC PFWREC; // record
  SM1REC SM1REC; // record
  SQLCA SQLCA; // record
  SY1REC SY1REC; // record
  SYCREC SYCREC; // record
  TA1REC TA1REC; // record
  TA2REC TA2REC; // record
  XX0XW01 XX0XW01; // record
  XX0XW02 XX0XW02; // record
  YSMREC YSMREC; // record

  // VAGen Info - items needed for migration
  VAGen_EZESYS char(8);
  VAGen_EZEREPLY num(1);
  VAGen_EZE_WAIT_TIME bin(9,2);
  VAGen_EZE_ITEMLEN int;

  // Use Declarations
  use XATTBL {deleteAfterUse = yes}; // table
  use XAUTBL {deleteAfterUse = yes}; // table
  use XBTTBL {deleteAfterUse = yes}; // table
  use XCNTBL {deleteAfterUse = yes}; // table
  use XDRTBL {deleteAfterUse = yes}; // table
  use XDVTBL {deleteAfterUse = yes}; // table
  use XFCTBL {deleteAfterUse = yes}; // table
  use XFMTBL {deleteAfterUse = yes}; // table
  use XGATBL {deleteAfterUse = yes}; // table
  use XGPTBL {deleteAfterUse = yes}; // table
  use XGSTBL {deleteAfterUse = yes}; // table
  use XLCTBL {deleteAfterUse = yes}; // table
  use XMCTBL {deleteAfterUse = yes}; // table
  use XOBTBL {deleteAfterUse = yes}; // table
  use XPCTBL {deleteAfterUse = yes}; // table
  use XPLTBL {deleteAfterUse = yes}; // table
  use XPRTBL {deleteAfterUse = yes}; // table
  use XQATBL {deleteAfterUse = yes}; // table
  use XRDTBL {deleteAfterUse = yes}; // table
  use XRYTBL {deleteAfterUse = yes}; // table
  use XSPTBL {deleteAfterUse = yes}; // table
  use XSUTBL {deleteAfterUse = yes}; // table
  use XWHTBL {deleteAfterUse = yes}; // table
  use YFATBL {deleteAfterUse = yes}; // table
  use YFETBL {deleteAfterUse = yes}; // table
  use YFFTBL {deleteAfterUse = yes}; // table
  use YFGTBL {deleteAfterUse = yes}; // table
  use YGRTBL {deleteAfterUse = yes}; // table
  use YICTBL {deleteAfterUse = yes}; // table
  use YMATBL {deleteAfterUse = yes}; // table
  use YMBTBL {deleteAfterUse = yes}; // table
  use YMCTBL {deleteAfterUse = yes}; // table
  use YSCTBL {deleteAfterUse = yes}; // table
  use YSETBL {deleteAfterUse = yes}; // table
  use YSFTBL {deleteAfterUse = yes}; // table
  use YSYTBL {deleteAfterUse = yes}; // table
  use PF0BM.PF0BM001, // form
  		PF0BM.XX0XM001
   {
    pfKeyEquate = no
  };

  function main()
    // VAGen Info - initialization needed for migration
    VAGen_EZESYS = VGLib.getVAGSysType();
    PF0B000: PF0B000();
  end // end main
end // end PF0B

// pf0b mainline
Function PF0B000()
   /* -----------------------------------------------------------;*/
     /* pf0b   mainline logic                                   ;*/
   /* -----------------------------------------------------------;*/
  ;
  PF0B001(); /* initialize maps, wkg storage, set flags*/
  ;
  while (PFWREC.PFWEOAF == "N") /* while application is active*/
    PF0B100(); /* converse pf0b main screen*/
  end
  ;
  XPPF002();
  COMMAREA.CAFROMAP = "PF0B";
  COMMAREA.CATOAP = "PF0A";
  XSEXIT();
  ;
end // end PF0B000

// initialization for pf0b
Function PF0B001()
  ;
  XSENTRY();
  ;
  XSSEGTR();
  ;
  set PF0BM001 initial;
  ;
  set PF0BM001.PF0BMELE[1] protect, invisible;
  set PF0BM001.PF0BMELE[2] protect, invisible;
  set PF0BM001.PF0BMELE[3] protect, invisible;
  set PF0BM001.PF0BMELE[4] protect, invisible;
  set PF0BM001.PF0BMELE[5] protect, invisible;
  set PF0BM001.PF0BMELE[6] protect, invisible;
  set PF0BM001.PF0BMELE[7] protect, invisible;
  set PF0BM001.XGPCD protect, invisible;
  set PF0BM001.SY1STNBR protect, invisible;
  set PF0BM001.SY2CLRID protect, invisible;
  set PF0BM001.XDMCD protect, invisible;
  set PF0BM001.XQACD protect, invisible;
  set PF0BM001.XLCCD protect, invisible;
  ;
  set PF1REC empty;
  set PFWREC empty;
  set PF0BW01 empty;
  ;
  PFWREC.PFWEOAF = "N"; /* signal application active*/
  PFWREC.PFWERRF = "N"; /* set error flag to 'no'*/
  PFWREC.PFW1STF = "N";
  ;
  PF0BM001.PF0BMLEV = "SUM";
  ;
  PF0BM001.XXXCURDT = VGVar.currentShortGregorianDate;
  ;
  PF1REC.PF1PASS = COMMAREA.CAUSERA; /* save commmarea passed info*/
  COMMAREA.CAUSERA = " "; /* clear commarea user fields*/
  ;
  if (PF1REC.PF1XFERF == "Y") /* if another application is*/
    PF0BM001.PF0BMSTV = PF1REC.PF1NAM; /* bridging thru pf keys,*/
    PF0B200(); /* see if summary exists and has*/
    if (PFWREC.PFWERRF == "Y") /* ; been created yet*/
      return;
    end
    if (COMMAREA.CAFROMAP == "PF0F"
     /* if returning from transfer to 'pf0f',*/
     || COMMAREA.CAFROMAP == "PF0K"
     || COMMAREA.CAFROMAP == "PF0L"
     || COMMAREA.CAFROMAP == "PF0M"
     || COMMAREA.CAFROMAP == "PF0N"
     || COMMAREA.CAFROMAP == "PF0O")
      PF0BM001.PF0BMLEV = PF1REC.PF1DISP;
      PF0BM001.PF0BMELE[1] = PF1REC.PFDCDVAL[1]; /* move input saved*/
      PF0BM001.PF0BMELE[2] = PF1REC.PFDCDVAL[2]; /* from before transfer*/
      PF0BM001.PF0BMELE[3] = PF1REC.PFDCDVAL[3];
                                   /* back to the screen*/
      PF0BM001.PF0BMELE[4] = PF1REC.PFDCDVAL[4];
      PF0BM001.PF0BMELE[5] = PF1REC.PFDCDVAL[5];
      PF0BM001.PF0BMELE[6] = PF1REC.PFDCDVAL[6];
      PF0BM001.PF0BMELE[7] = PF1REC.PFDCDVAL[7];
      PF0BM001.XGPCD = PF1REC.XGPCD;
      PF0BM001.SY1STNBR = PF1REC.SY1STNBR;
      PF0BM001.SY2CLRID = PF1REC.SY2CLRID;
      PF0BM001.XDMCD = PF1REC.XDMCD;
      PF0BM001.XQACD = PF1REC.XQACD;
      PF0BM001.XLCCD = PF1REC.XLCCD;
    end
    PF0BW01.PF0BWNAM = PF0BM001.PF0BMSTV; /* save summary name*/
    set PF0BM001.PF0BMELE[1] cursor;
    return;
  end
  ;
  if (COMMAREA.CAITEM != " ") /* if another application is*/
    PF0BM001.PF0BMSTV = COMMAREA.CAITEM;
                                   /* fast pathing to this appl.,*/
    PF0B200(); /* see if summary exists and has*/
    if (PFWREC.PFWERRF == "Y") /* ; been created yet*/
      return;
    end
    PF0BW01.PF0BWNAM = PF0BM001.PF0BMSTV; /* save summary name*/
  end
  ;
  set PFAREC empty;
  set SQLCA empty;
  ;
  call "IO2670" ("S ", SQLCA, PFAREC) {isNoRefresh = yes, isExternal = yes}; /* access vpfctl01 table*/
  ;
  if (SQLCA.VAGen_SQLCODE == +0) /* if control rec. found continue with*/
                                   /* the process*/
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
    TA1REC.TA1TBLVU = "VPFCTL01";
    TA1REC.TA1TBLKE = PF1REC.PFESUMNM;
    TA1REC.TA1LOCAT[3] = "PF0B001";
    TA1REC.TA1LOCAT[4] = "IO2670";
    XPPF010();
  end
  ;
  if (PFAREC.PFASTBLF == "Y") /* if the summary file is locked due to an*/
    PFWREC.PFWERRF = "Y"; /* db2 batch load, send user a message*/
    converseLib.validationFailed(223);
  end
end // end PF0B001

// main converse logic
Function PF0B100()
  converse PF0BM001 ;
  ;
  PFWREC.PFWERRF = " "; /* clear error flag*/
  ;
  PF0B910(); /* check pf keys*/
  ;
  if (PFWREC.PFWEOAF == "Y" /* end the application?*/
   || PFWREC.PFWEOSF == "Y") /* or end the screen?*/
    return;
  end
  ;
  if (PFWREC.PFWERRF == "Y") /* if any errors encountered, exit routine*/
    return;
  end
  ;
  if (PF0BM001.PF0BMSTV == " ") /* user must enter a summary name*/
    converseLib.validationFailed(035);
    return;
  end
  ;
  set PF0BM001.PF0BMSTV initialAttributes;
  set PF0BM001.PF0BMLEV initialAttributes;
  ;
  if (PF0BM001.PF0BMSTV != PFEREC.PFESUMNM
   /* if a new summary name is entered*/
   || PF0BM001.PF0BMSTV != PF0BW01.PF0BWSN1)
    PF0BW01.PF0BWSN2 = PF0BM001.PF0BMSTV;
    PF0BW01.PF0BWLEV = PF0BM001.PF0BMLEV;
    set PF0BM001 empty;
    PF0BM001.PF0BMSTV = PF0BW01.PF0BWSN2;
    PF0BM001.PF0BMLEV = PF0BW01.PF0BWLEV;
    PF0B200(); /* verify summary name*/
    PFWREC.PFW1STF = "N";
    return;
  end
  ;
  PF0B230(); /* set rows defined*/
  ;
  if (PF0BM001.PF0BMLEV == "SUM" /* print level must be sum,det, or exp*/
   || PF0BM001.PF0BMLEV == "DET" 
   || PF0BM001.PF0BMLEV == "EXP")
     /* next sentence*/
  else
    PFWREC.PFWERRF = "Y";
    converseLib.validationFailed(057);
    set PF0BM001.PF0BMLEV cursor, bold;
    return;
  end
  ;
  PF0B240(); /* move entered attribute values to*/
                                   /* pfwrec w/s area*/
  ;
  XPPF300(); /* perform windowing routine*/
  ;
  converseLib.clearScreen();
  
  ;
  PF0BM001.PF0BMELE[1] = PFWREC.PFDCDVAL[1]; /* move windowing rtn.*/
  PF0BM001.PF0BMELE[2] = PFWREC.PFDCDVAL[2]; /* results to map*/
  PF0BM001.PF0BMELE[3] = PFWREC.PFDCDVAL[3];
  PF0BM001.PF0BMELE[4] = PFWREC.PFDCDVAL[4];
  PF0BM001.PF0BMELE[5] = PFWREC.PFDCDVAL[5];
  PF0BM001.PF0BMELE[6] = PFWREC.PFDCDVAL[6];
  PF0BM001.PF0BMELE[7] = PFWREC.PFDCDVAL[7];
  ;
  PFWREC.PFWPRDAT = PFDREC.PFICD[8]; /* save field code # for common rtn.*/
  XPPF400(); /* perform code value editing routine*/
  ;
  if (PFWREC.PFWERRF == "Y") /* if any errors encountered,*/
    PF0B250(); /* perform routine to highlight map fields*/
    return;
  end
  ;
  PF0BM001.PF0BMDSC[1] = PFWREC.PFWDESC[1]; /* move abbreviations to*/
  PF0BM001.PF0BMDSC[2] = PFWREC.PFWDESC[2]; /* map fields*/
  PF0BM001.PF0BMDSC[3] = PFWREC.PFWDESC[3];
  PF0BM001.PF0BMDSC[4] = PFWREC.PFWDESC[4];
  PF0BM001.PF0BMDSC[5] = PFWREC.PFWDESC[5];
  PF0BM001.PF0BMDSC[6] = PFWREC.PFWDESC[6];
  PF0BM001.PF0BMDSC[7] = PFWREC.PFWDESC[7];
  PF0BM001.SY2CLRAB = PFWREC.PFWDESC[8];
  PF0BM001.PF0BMCLR = PFWREC.SY2CLRAB;
  PF0BM001.PF0BMELE[1] = PFWREC.PFDCDVAL[1]; /* move attribute code*/
  PF0BM001.PF0BMELE[2] = PFWREC.PFDCDVAL[2]; /* value back to screen*/
  PF0BM001.PF0BMELE[3] = PFWREC.PFDCDVAL[3];
  PF0BM001.PF0BMELE[4] = PFWREC.PFDCDVAL[4];
  PF0BM001.PF0BMELE[5] = PFWREC.PFDCDVAL[5];
  PF0BM001.PF0BMELE[6] = PFWREC.PFDCDVAL[6];
  PF0BM001.PF0BMELE[7] = PFWREC.PFDCDVAL[7];
  ;
  PF0B300(); /* verify summary starting position*/
  ;
  if (PFWREC.PFWERRF == "Y") /* if any errors encountered, exit routine*/
    return;
  end
  ;
  if (PFWREC.PFW1STF == "N")
    PFWREC.PFW1STF = "Y";
    converseLib.validationFailed(200);
    return;
  else
    PF0B400(); /* transfer control to appropriate*/
                                      /* format application*/
  end
end // end PF0B100

// access dproft.vsumat01 table
Function PF0B200()
   /* *******************************************************/
   /* *  this process will take the entered, bridged or    **/
   /* *  fastpathed summary name and access the vsumat01   **/
   /* *  table to verify the summary name. the vrptat01    **/
   /* *  table will be accessed by using the reporting     **/
   /* *  attribute reference # in the vsumat01 row. the    **/
   /* *  vfield01 table will be accessed using the pficd   **/
   /* *  fields in the vrptat01 row. the reporting         **/
   /* *  attribute descriptions will be moved from the     **/
   /* *  vfield01 table to the pf0bm001 screen.            **/
   /* *******************************************************/
  ;
  set PFEREC empty;
  set SQLCA empty;
  ;
  PFEREC.PFESUMNM = PF0BM001.PF0BMSTV; /* move summ. name to key*/
  ;
  call "IO2770" ("S ", SQLCA, PFEREC) {isNoRefresh = yes, isExternal = yes}; /* access vsumat01 table*/
  ;
  if (SQLCA.VAGen_SQLCODE == +0) /* if summary found continue with the process*/
    PF0BW01.PF0BWSN1 = PFEREC.PFESUMNM; /* save valid sum name*/
  else
    if (SQLCA.VAGen_SQLCODE == +100) /* if summary not found, send error message*/
      PFWREC.PFWERRF = "Y";
      converseLib.validationFailed(048); /* summary name not on file*/
      PF0B202(); /* set data entry fields dark*/
      set PF0BM001.PF0BMSTV cursor, bold;
      return;
    else
      TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
      TA1REC.TA1TBLVU = "VSUMAT01";
      TA1REC.TA1TBLKE = PF0BM001.PF0BMSTV;
      TA1REC.TA1LOCAT[3] = "PF0B200";
      TA1REC.TA1LOCAT[4] = "IO2770";
      XPPF010();
    end
  end
  ;
  if (PFEREC.PFECRTDT == 0) /* if the creation date indicates that*/
                                   /* the summary*/
    PFWREC.PFWERRF = "Y"; /* hasn't been created, send an error msg.*/
    converseLib.validationFailed(199); /* summary has not been created yet*/
    set PF0BM001.PF0BMSTV cursor, bold;
    return;
  end
  ;
  set PFDREC empty;
  set SQLCA empty;
  ;
  PFDREC.PFDREF = PFEREC.PFDREF; /* move attr. ref # to db2 key*/
  ;
  call "IO2740" ("S ", SQLCA, PFDREC) {isNoRefresh = yes, isExternal = yes}; /* access vrptat01 table*/
  ;
  if (SQLCA.VAGen_SQLCODE == +0) /* if attr. ref. # found continue with*/
                                   /* the process*/
     /* next sentence*/
  else /* if attr. ref. # not on file, application can't continue*/
    TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;abend it*/
    TA1REC.TA1TBLVU = "VRPTAT01";
    PF0BW01.PF0BWABK = PFEREC.PFDREF;
    TA1REC.TA1TBLKE = PF0BW01.PF0BWABK;
    TA1REC.TA1LOCAT[3] = "PF0B200";
    TA1REC.TA1LOCAT[4] = "IO2740";
    XPPF010();
  end
  ;
   /* SET PF0BM001 DEFINED;*/
  ;
  move " " to PF1REC.PFISDESC[1] for all;
  PFWIDX = 1;
  ;
  while (PFWIDX < 9) /* check for data in pficd fields in vrptat01*/
    if (PFDREC.PFICD[PFWIDX] > "  ") /* if there data in the field*/
      PF0B210(); /* perform process to get attribute*/
    else /* descriptions*/
      if (PFWIDX < 8)
        set PF0BM001.PF0BMELE[PFWIDX] protect, invisible; /* otherwise,*/
      else
        set PF0BM001.XGPCD protect, invisible;
        set PF0BM001.SY1STNBR protect, invisible;
        set PF0BM001.SY2CLRID protect, invisible;
        set PF0BM001.XDMCD protect, invisible;
        set PF0BM001.XQACD protect, invisible;
        set PF0BM001.XLCCD protect, invisible;
      end
    end /* darken the map field*/
    PFWIDX = PFWIDX + 1; /* increment subscript*/
  end
  ;
  ;
  set PFCREC empty;
  set SQLCA empty;
  ;
  PFCREC.PFCREF = PFEREC.PFCREF; /* move summary fmt # to db2 key*/
  ;
  call "IO2730" ("S ", SQLCA, PFCREC) {isNoRefresh = yes, isExternal = yes};
                                   /* access vrptfm01 db2 table*/
  ;
  if (SQLCA.VAGen_SQLCODE == +0) /* if format # found continue with the process*/
     /* next sentence*/
  else /* if format # not on file, application can't continue*/
    TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;abend it*/
    TA1REC.TA1TBLVU = "VRPTFM01";
    PF0BW01.PF0BWABK = PFEREC.PFCREF;
    TA1REC.TA1TBLKE = PF0BW01.PF0BWABK;
    TA1REC.TA1LOCAT[3] = "PF0B200";
    TA1REC.TA1LOCAT[4] = "IO2730";
    XPPF010();
  end
  ;
  set PF0BM001.PF0BMELE[1] cursor;
end // end PF0B200

// set data entry fields dark
Function PF0B202()
  set PF0BM001.PF0BMELE[1] protect, invisible; /* otherwise,*/
  set PF0BM001.PF0BMELE[2] protect, invisible; /* otherwise,*/
  set PF0BM001.PF0BMELE[3] protect, invisible; /* otherwise,*/
  set PF0BM001.PF0BMELE[4] protect, invisible; /* otherwise,*/
  set PF0BM001.PF0BMELE[5] protect, invisible; /* otherwise,*/
  set PF0BM001.PF0BMELE[6] protect, invisible; /* otherwise,*/
  set PF0BM001.PF0BMELE[7] protect, invisible; /* otherwise,*/
  ;
  set PF0BM001.XGPCD protect, invisible;
  set PF0BM001.SY1STNBR protect, invisible;
  set PF0BM001.SY2CLRID protect, invisible;
  set PF0BM001.XDMCD protect, invisible;
  set PF0BM001.XQACD protect, invisible;
  set PF0BM001.XLCCD protect, invisible;
end // end PF0B202

// move vfield01 desc. to screen
Function PF0B210()
   /* *****************************************************/
   /* *   this process will use the pficd field in the   **/
   /* *   vrptat01 row as a key into the vfield01 table. **/
   /* *   the attribute description will then be moved   **/
   /* *   to the screen and the data entry area assoc-   **/
   /* *   iated with the attribute will unprotected and  **/
   /* *   underscored to permit data entry.              **/
   /* *****************************************************/
  ;
  set PFIREC empty;
  set SQLCA empty;
  ;
  PFIREC.PFICD = PFDREC.PFICD[PFWIDX]; /* move pficd to db2 key*/
  ;
  call "IO2890" ("S ", SQLCA, PFIREC) {isNoRefresh = yes, isExternal = yes}; /* access vfield01 table*/
  ;
  if (SQLCA.VAGen_SQLCODE == +0) /* if row found continue with the*/
                                   /* process*/
     /* next sentence*/
  else /* if row not on file, application can't continue*/
    TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;abend it*/
    TA1REC.TA1TBLVU = "VFIELD01";
    TA1REC.TA1TBLKE = PFDREC.PFICD[PFWIDX];
    TA1REC.TA1LOCAT[3] = "PF0B210";
    TA1REC.TA1LOCAT[4] = "IO2890";
  end
  ;
  PF1REC.PFISDESC[PFWIDX] = PFIREC.PFISDESC; /* move short desc. to pass*/
                                                    /* record*/
  PFWREC.PFIDESC[PFWIDX] = PFIREC.PFIDESC; /* move description to w/s*/
                                                    /* record*/
  ;
  if (PFWIDX == 8)
    PF0BM001.PF0BMPRD = PFIREC.PFIDESC; /* move prod desc. to map*/
    set PF0BM001.XGPCD normal;
    set PF0BM001.SY1STNBR normal;
    set PF0BM001.SY2CLRID normal;
    set PF0BM001.XDMCD normal;
    set PF0BM001.XQACD normal;
    set PF0BM001.XLCCD normal;
  else
    PF0BM001.PF0BMATT[PFWIDX] = PFIREC.PFIDESC; /* move desc. to map*/
    set PF0BM001.PF0BMELE[PFWIDX] normal;
  end
end // end PF0B210

// set rows defined
Function PF0B230()
  if (PF0BM001.PF0BMELE[1] != " ")
    set PF0BM001.PF0BMELE[1] initialAttributes;
  end
  if (PF0BM001.PF0BMELE[2] != " ")
    set PF0BM001.PF0BMELE[2] initialAttributes;
  end
  if (PF0BM001.PF0BMELE[3] != " ")
    set PF0BM001.PF0BMELE[3] initialAttributes;
  end
  if (PF0BM001.PF0BMELE[4] != " ")
    set PF0BM001.PF0BMELE[4] initialAttributes;
  end
  if (PF0BM001.PF0BMELE[5] != " ")
    set PF0BM001.PF0BMELE[5] initialAttributes;
  end
  if (PF0BM001.PF0BMELE[6] != " ")
    set PF0BM001.PF0BMELE[6] initialAttributes;
  end
  if (PF0BM001.PF0BMELE[7] != " ")
    set PF0BM001.PF0BMELE[7] initialAttributes;
  end
  ;
  if (PF0BM001.XGPCD != " ")
    set PF0BM001.XGPCD initialAttributes;
  end
  if (PF0BM001.SY1STNBR != " ")
    set PF0BM001.SY1STNBR initialAttributes;
  end
  if (PF0BM001.SY2CLRID != " ")
    set PF0BM001.SY2CLRID initialAttributes;
  end
  if (PF0BM001.XDMCD != " ")
    set PF0BM001.XDMCD initialAttributes;
  end
  if (PF0BM001.XQACD != " ")
    set PF0BM001.XQACD initialAttributes;
  end
  if (PF0BM001.XLCCD != " ")
    set PF0BM001.XLCCD initialAttributes;
  end
end // end PF0B230

// prepare window and edit rtn
Function PF0B240()
   /* **********************************************************/
   /* *  this process will move fields from the map pf0bm001  **/
   /* *  to pfwrec for use in the generic windowing and       **/
   /* *  editing routines. the process will also clear the    **/
   /* *  pfwrec edit flags used in the generic routines.      **/
   /* **********************************************************/
  ;
  PFWREC.PFDCDVAL[1] = PF0BM001.PF0BMELE[1]; /* move entered data*/
  PFWREC.PFDCDVAL[2] = PF0BM001.PF0BMELE[2]; /* to common w/s for*/
  PFWREC.PFDCDVAL[3] = PF0BM001.PF0BMELE[3]; /* common windowing and*/
  PFWREC.PFDCDVAL[4] = PF0BM001.PF0BMELE[4]; /* edit routines*/
  PFWREC.PFDCDVAL[5] = PF0BM001.PF0BMELE[5];
  PFWREC.PFDCDVAL[6] = PF0BM001.PF0BMELE[6];
  PFWREC.PFDCDVAL[7] = PF0BM001.PF0BMELE[7];
  PFWREC.XGPCD = PF0BM001.XGPCD;
  PFWREC.SY1STNBR = PF0BM001.SY1STNBR;
  PFWREC.SY2CLRID = PF0BM001.SY2CLRID;
  PFWREC.XDMCD = PF0BM001.XDMCD;
  PFWREC.XQACD = PF0BM001.XQACD;
  PFWREC.XLCCD = PF0BM001.XLCCD;
  ;
  PFWREC.PFWHGPCF = "N";
  PFWREC.PFWHSTYF = "N";
  PFWREC.PFWHLFCF = "N";
  PFWREC.PFWHDIMF = "N";
  PFWREC.PFWHQUAF = "N";
  PFWREC.PFWHLFCF = "N";
  ;
  PFWREC.PFWVALER[1] = "N";
  PFWREC.PFWVALER[2] = "N";
  PFWREC.PFWVALER[3] = "N";
  PFWREC.PFWVALER[4] = "N";
  PFWREC.PFWVALER[5] = "N";
  PFWREC.PFWVALER[6] = "N";
  PFWREC.PFWVALER[7] = "N";
end // end PF0B240

// highlight erroneous map fields
Function PF0B250()
   /* **********************************************************/
   /* *  if any errors were found in the windowing routine    **/
   /* *  (xppf300) or the editing routine (xppf400), this     **/
   /* *  routine will highlight the error map fields and      **/
   /* *  set the cursor on the error field. the cursor will   **/
   /* *  be set from the bottom of the screen to the top.     **/
   /* **********************************************************/
  ;
  if (PFWREC.PFWHLFCF == "Y") /* if life cycle field in error,*/
    set PF0BM001.XLCCD cursor, bold; /* highlight it.*/
  end
  ;
  if (PFWREC.PFWHQUAF == "Y") /* if quality field in error,*/
    set PF0BM001.XQACD cursor, bold; /* highlight it.*/
  end
  ;
  if (PFWREC.PFWHDIMF == "Y") /* if dimension field in error,*/
    set PF0BM001.XDMCD cursor, bold; /* highlight it.*/
  end
  ;
  if (PFWREC.PFWHCOLF == "Y") /* if color field in error,*/
    set PF0BM001.SY2CLRID cursor, bold; /* highlight it.*/
  end
  ;
  if (PFWREC.PFWHSTYF == "Y") /* if style field in error,*/
    set PF0BM001.SY1STNBR cursor, bold; /* highlight it.*/
  end
  ;
  if (PFWREC.PFWHGPCF == "Y") /* if gpc field in error,*/
    set PF0BM001.XGPCD cursor, bold; /* highlight it.*/
  end
  ;
  PFWSUB2 = 7; /* initialize subscript*/
  ;
  while (PFWSUB2 >= 1)
    if (PFWREC.PFWVALER[PFWSUB2] == "Y") /* if attribute field in error,*/
      set PF0BM001.PF0BMELE[PFWSUB2] cursor, bold; /* highlight it.*/
    end
    PFWSUB2 = PFWSUB2 - 1;
  end
end // end PF0B250

// verify summary in vsumry01
Function PF0B300()
   /* *********************************************************/
   /* *   this process will use the attribute code values    **/
   /* *   entered on screen pf0bm001 as keys to the vsumry01 **/
   /* *   TABLE. the process will verify that the code       **/
   /* *   values are valid as a beginning viewing point for  **/
   /* *   summary format display. if the code values are     **/
   /* *   valid, the pfglvlno and pfglvlsq data fields will  **/
   /* *   passed to the format display application (pf0l,    **/
   /* *   pf0m, pf0m, pf0n, pf0o) to be used as a db2 key.   **/
   /* *********************************************************/
  ;
  set PFGREC empty;
  set SQLCA empty;
  ;
  PFGREC.PFGSUMN = PFEREC.PFGSUMN;
  PFGREC.PFESUMNM = PF0BM001.PF0BMSTV; /* move screen items to db2 keys*/
  PFGREC.PFGLVLNO = 0;
  if (PFWREC.PFDCDVAL[1] > "  ") /* determine summary level for inquiry*/
    PFGREC.PFGLVLNO = 1;
  end
  ;
  if (PFWREC.PFDCDVAL[2] > "  ") /* determine summary level for inquiry*/
    PFGREC.PFGLVLNO = 2;
  end
  ;
  if (PFWREC.PFDCDVAL[3] > "  ") /* determine summary level for inquiry*/
    PFGREC.PFGLVLNO = 3;
  end
  ;
  if (PFWREC.PFDCDVAL[4] > "  ") /* determine summary level for inquiry*/
    PFGREC.PFGLVLNO = 4;
  end
  ;
  if (PFWREC.PFDCDVAL[5] > "  ") /* determine summary level for inquiry*/
    PFGREC.PFGLVLNO = 5;
  end
  ;
  if (PFWREC.PFDCDVAL[6] > "  ") /* determine summary level for inquiry*/
    PFGREC.PFGLVLNO = 6;
  end
  ;
  if (PFWREC.PFDCDVAL[7] > "  ") /* determine summary level for inquiry*/
    PFGREC.PFGLVLNO = 7;
  end
  ;
  if (PFWREC.XGPCD > "  ") /* determine summary level for inquiry*/
    PFGREC.PFGLVLNO = PFGREC.PFGLVLNO + 1;
  end
  ;
  PFGREC.PFDCDVAL[1] = PF0BM001.PF0BMELE[1];
  PFGREC.PFDCDVAL[2] = PF0BM001.PF0BMELE[2];
  PFGREC.PFDCDVAL[3] = PF0BM001.PF0BMELE[3];
  PFGREC.PFDCDVAL[4] = PF0BM001.PF0BMELE[4];
  PFGREC.PFDCDVAL[5] = PF0BM001.PF0BMELE[5];
  PFGREC.PFDCDVAL[6] = PF0BM001.PF0BMELE[6];
  PFGREC.PFDCDVAL[7] = PF0BM001.PF0BMELE[7];
  PFGREC.XGPCD = PF0BM001.XGPCD;
  PFGREC.SY1STNBR = PF0BM001.SY1STNBR;
  PFGREC.SY2CLRID = PF0BM001.SY2CLRID;
  PFGREC.XDMCD = PF0BM001.XDMCD;
  PFGREC.XQACD = PF0BM001.XQACD;
  PFGREC.XLCCD = PF0BM001.XLCCD;
  ;
  call "IO2920" ("S2", SQLCA, PFGREC) {isNoRefresh = yes, isExternal = yes}; /* open cursor*/
  ;
  if (SQLCA.VAGen_SQLCODE == +0)
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DPROFT"; /* else, fatal db2 error*/
    TA1REC.TA1TBLVU = "VSUMRY01";
    TA1REC.TA1TBLKE = PFGREC.PFESUMNM;
    TA1REC.TA1LOCAT[3] = "PF0B300";
    TA1REC.TA1LOCAT[4] = "IO2920";
    XPPF010(); /* perform profitability abend routine*/
  end
  ;
  call "IO2920" ("N2", SQLCA, PFGREC) {isNoRefresh = yes, isExternal = yes}; /* open cursor*/
  ;
  if (SQLCA.VAGen_SQLCODE == +0)
     /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == +100) /* if record not found, send error message*/
      PFWERRF = "Y";
      converseLib.validationFailed(239);
    else
      TA1REC.TA1DBASE = "DPROFT"; /* else, fatal db2 error*/
      TA1REC.TA1TBLVU = "VSUMRY01";
      TA1REC.TA1TBLKE = PFGREC.PFESUMNM;
      TA1REC.TA1LOCAT[3] = "PF0B300";
      TA1REC.TA1LOCAT[4] = "IO2920";
      XPPF010(); /* perform profitability abend routine*/
    end
  end
  ;
  call "IO2920" ("C2", SQLCA, PFGREC) {isNoRefresh = yes, isExternal = yes}; /* close cursor*/
  ;
  if (SQLCA.VAGen_SQLCODE == +0)
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DPROFT"; /* else, fatal db2 error*/
    TA1REC.TA1TBLVU = "VSUMRY01";
    TA1REC.TA1TBLKE = PFGREC.PFESUMNM;
    TA1REC.TA1LOCAT[3] = "PF0B300";
    TA1REC.TA1LOCAT[4] = "IO2920";
    XPPF010(); /* perform profitability abend routine*/
  end
  ;
  PF1REC.PF1STLVL = PFGREC.PFGLVLNO; /* move starting level #*/
  PF1REC.PF1STSEQ = PFGREC.PFGLVLSQ; /* starting seq. #*/
  PF1REC.PFESUMNM = PFGREC.PFESUMNM; /* summary name*/
  PF1REC.PF1NAM = PFGREC.PFESUMNM; /* summary name*/
  PF1REC.PF1DISP = PF0BM001.PF0BMLEV; /* display type*/
  PF1REC.PFIDESC[8] = PFWREC.PFIDESC[8]; /* product desc.*/
end // end PF0B300

// transfer to format application
Function PF0B400()
   /* *********************************************************/
   /* *   this process will transfer control to the format   **/
   /* *   application that corresponds to the format of the  **/
   /* *   summary name entered. the applications are as      **/
   /* *   follows :                                          **/
   /* *   format #        application                        **/
   /* *   --------        -----------                        **/
   /* *      1              pf0k                             **/
   /* *      2              pf0l                             **/
   /* *      3              pf0m                             **/
   /* *      4              pf0n                             **/
   /* *      5              pf0o                             **/
   /* *                                                      **/
   /* *   when the transfer is made, a w/s area (pfxxxxx)    **/
   /* *   will be passed. pfxxxx will contain the following  **/
   /* *   information :                                      **/
   /* *   field name       field description                 **/
   /* *   ----------       -----------------                 **/
   /* *********************************************************/
  ;
   /* move items to pass record*/
  ;
  if (PFCREC.PFCFMNBR == "01") /* if format number is 1,*/
    COMMAREA.CATOAP = "PF0K"; /* setup transfer to 'pf0k'*/
    COMMAREA.CAUSERA = PF1REC.PF1PASS; /* move passed data to commarea*/
    XSEXIT(); /* transfer*/
    PF0BM001.VAGen_EZEMSG = COMMAREA.CAMSG; /* bad pass*/
    PFWREC.PFWERRF = "Y";
    return;
  else
    if (PFCREC.PFCFMNBR == "02") /* if format number is 2,*/
      COMMAREA.CATOAP = "PF0L"; /* setup transfer to 'pf0l'*/
      COMMAREA.CAUSERA = PF1REC.PF1PASS; /* move passed data to commarea*/
      XSEXIT(); /* transfer*/
      PF0BM001.VAGen_EZEMSG = COMMAREA.CAMSG; /* bad pass*/
      PFWREC.PFWERRF = "Y";
      return;
    else
      if (PFCREC.PFCFMNBR == "03") /* if format number is 3,*/
        COMMAREA.CATOAP = "PF0M"; /* setup transfer to 'pf0m'*/
        COMMAREA.CAUSERA = PF1REC.PF1PASS; /* move passed data to commarea*/
        XSEXIT(); /* transfer*/
        PF0BM001.VAGen_EZEMSG = COMMAREA.CAMSG; /* bad pass*/
        PFWREC.PFWERRF = "Y";
        return;
      else
        if (PFCREC.PFCFMNBR == "04") /* if format number is 4,*/
          COMMAREA.CATOAP = "PF0N"; /* setup transfer to 'pf0m'*/
          COMMAREA.CAUSERA = PF1REC.PF1PASS; /* move passed data to commarea*/
          XSEXIT(); /* transfer*/
          PF0BM001.VAGen_EZEMSG = COMMAREA.CAMSG; /* bad pass*/
          PFWREC.PFWERRF = "Y";
          return;
        else
          if (PFCREC.PFCFMNBR == "05") /* if format number is 5,*/
            COMMAREA.CATOAP = "PF0O"; /* setup transfer to 'pf0o'*/
            COMMAREA.CAUSERA = PF1REC.PF1PASS; /* move passed data to commarea*/
            XSEXIT(); /* transfer*/
            PF0BM001.VAGen_EZEMSG = COMMAREA.CAMSG; /* bad pass*/
            PFWREC.PFWERRF = "Y";
            return;
          else
            PFWREC.PFWERRF = "Y"; /* bad format #, cannot transfer*/
            converseLib.validationFailed(240);
          end
        end
      end
    end
  end
end // end PF0B400

// check pa/pf keys
Function PF0B910()
   /* --------------------------------------------------------;*/
          /* Validate PF keys                                ;*/
   /* --------------------------------------------------------;*/
  ;
  if (converseVar.eventKey is pf17) /* transfer to 'PF0C' summary directory application*/
    COMMAREA.CATOAP = "PF0C";
    COMMAREA.CAITEM = " ";
    XSPF4();
    PF0BM001.VAGen_EZEMSG = COMMAREA.CAMSG;
    PFWREC.PFWERRF = "Y";
    return;
  end
  ;
  ;
  if (PF0BM001.CATOAP != " " /* user has requested fastpath out of appl.*/
   || PF0BM001.CAITEM != " ")
    PF0B912(); /* make sure user hasn't entered any*/
                                   /* data*/
    if (PFWREC.PFWERRF == "Y")
      set PF0BM001.CATOAP cursor, bold;
      return;
    else
      COMMAREA.CAFROMAP = "PF0B";
      COMMAREA.CATOAP = PF0BM001.CATOAP; /* transfer to entered appl.*/
      COMMAREA.CAITEM = PF0BM001.CAITEM;
      XPPF002();
      return;
    end
  end
  ;
  if (converseVar.eventKey is pf1) /* help*/
    XSPF1();
    PFWREC.PFWMSG = COMMAREA.CAMSG; /* result of bad pass*/
    PFWREC.PFWERRF = "Y"; /* set error flag*/
    return;
  end
  ;
  ;
  if (converseVar.eventKey is pf3) /* if pf3 pressed*/
    if (PF1REC.PF1ORIG == "PF0C")
      COMMAREA.CAUSERA = PF1REC.PF1PASS;
      COMMAREA.CATOAP = "PF0C";
    else
      COMMAREA.CATOAP = "PF0A"; /* retrun to main profit menu*/
    end
    XSEXIT();
    PFWREC.PFWMSG = COMMAREA.CAMSG; /* result of bad pass*/
    PFWREC.PFWERRF = "Y"; /* set error flag*/
    return;
  end
  ;
  if (converseVar.eventKey is pf4) /* return to main system menu*/
    XSPF4();
    PFWREC.PFWMSG = COMMAREA.CAMSG; /* result of bad pass*/
    PFWREC.PFWERRF = "Y"; /* set error flag*/
    return;
  end
  ;
  ;
  set PFAREC empty;
  set SQLCA empty;
  ;
  call "IO2670" ("S ", SQLCA, PFAREC) {isNoRefresh = yes, isExternal = yes}; /* access vpfctl01 table*/
  ;
  if (SQLCA.VAGen_SQLCODE == +0) /* if control rec. found continue with*/
                                   /* the process*/
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
    TA1REC.TA1TBLVU = "VPFCTL01";
    TA1REC.TA1TBLKE = PF1REC.PFESUMNM;
    TA1REC.TA1LOCAT[3] = "PF0B001";
    TA1REC.TA1LOCAT[4] = "IO2670";
    XPPF010();
  end
  ;
  if (PFAREC.PFASTBLF == "Y") /* if the summary file is locked due to an*/
    PFWREC.PFWERRF = "Y"; /* db2 batch load, send user a message*/
    converseLib.validationFailed(223);
    return;
  end
  ;
  if (converseVar.eventKey is pf12) /* edit only*/
    return;
  end
  ;
  if (converseVar.eventKey is pf15) /* ; pf15 transfer to pf0f*/
    PF1REC.PF1NAM = PF0BM001.PF0BMSTV; /* save screen fields for*/
    PF1REC.PF1DISP = PF0BM001.PF0BMLEV; /* returning after transfer*/
    PF1REC.PFDCDVAL[1] = PF0BM001.PF0BMELE[1];
    PF1REC.PFDCDVAL[2] = PF0BM001.PF0BMELE[2];
    PF1REC.PFDCDVAL[3] = PF0BM001.PF0BMELE[3];
    PF1REC.PFDCDVAL[4] = PF0BM001.PF0BMELE[4];
    PF1REC.PFDCDVAL[5] = PF0BM001.PF0BMELE[5];
    PF1REC.PFDCDVAL[6] = PF0BM001.PF0BMELE[6];
    PF1REC.PFDCDVAL[7] = PF0BM001.PF0BMELE[7];
    PF1REC.XGPCD = PF0BM001.XGPCD;
    PF1REC.SY1STNBR = PF0BM001.SY1STNBR;
    PF1REC.SY2CLRID = PF0BM001.SY2CLRID;
    PF1REC.XDMCD = PF0BM001.XDMCD;
    PF1REC.XQACD = PF0BM001.XQACD;
    PF1REC.XLCCD = PF0BM001.XLCCD;
    PF1REC.PF1ATT = PFDREC.PFDREF;
    PF1REC.PF1CURR = "PF0B";
    PF1REC.PF1ORIG = "PF0B";
    PF1REC.PF1XFERF = "Y";
    XPPF200();
    return;
  end
  ;
  ;
  if (converseVar.eventKey is enter) /* enter ok*/
    return;
  end
  ;
  if (converseVar.eventKey is pf17) /* if bridging back to PF0C*/
    if (PF1REC.PF1ORIG == "PF0C") /* ensure came from valid appl*/
      PF1REC.PF1CURR = "PF0B"; /* signal pf0b current appl*/
      PF1REC.PF1XFERF = "Y"; /* signal xfer again*/
      PF1REC.PF1NAM = PF0BM001.PF0BMSTV; /* remember summ name*/
      XPPF200(); /* bridge routine*/
      if (PFWREC.PFWERRF == "Y") /* if xfer no good*/
        return; /* goback*/
      end
    else /* orig appl not valid*/
      converseLib.validationFailed(1);
      PFWREC.PFWERRF = "Y";
      return;
    end
  end
  ;
  if (converseVar.eventKey is pa1) /* escape route*/
    converseLib.clearScreen();
    
    return;
  end
  ;
  converseLib.validationFailed(1); /* fall through error - invalid pfkey*/
  PFWREC.PFWERRF = "Y"; /* signal error*/
  ;
end // end PF0B910

// check screen fields mod.
Function PF0B912()
  ;
  if (PF0BM001.PF0BMSTV is modified)
    set PF0BM001.PF0BMSTV bold;
    PFWREC.PFWERRF = "Y";
  end
  if (PF0BM001.PF0BMLEV is modified)
    set PF0BM001.PF0BMLEV bold;
    PFWREC.PFWERRF = "Y";
  end
  ;
  if (PF0BM001.PF0BMELE[1] is modified)
    set PF0BM001.PF0BMELE[1] bold;
    PFWREC.PFWERRF = "Y";
  end
  if (PF0BM001.PF0BMELE[2] is modified)
    set PF0BM001.PF0BMELE[2] bold;
    PFWREC.PFWERRF = "Y";
  end
  if (PF0BM001.PF0BMELE[3] is modified)
    set PF0BM001.PF0BMELE[3] bold;
    PFWREC.PFWERRF = "Y";
  end
  if (PF0BM001.PF0BMELE[4] is modified)
    set PF0BM001.PF0BMELE[4] bold;
    PFWREC.PFWERRF = "Y";
  end
  if (PF0BM001.PF0BMELE[5] is modified)
    set PF0BM001.PF0BMELE[5] bold;
    PFWREC.PFWERRF = "Y";
  end
  if (PF0BM001.PF0BMELE[6] is modified)
    set PF0BM001.PF0BMELE[6] bold;
    PFWREC.PFWERRF = "Y";
  end
  if (PF0BM001.PF0BMELE[7] is modified)
    set PF0BM001.PF0BMELE[7] bold;
    PFWREC.PFWERRF = "Y";
  end
  ;
  if (PF0BM001.XGPCD is modified)
    set PF0BM001.XGPCD bold;
    PFWREC.PFWERRF = "Y";
  end
  if (PF0BM001.SY1STNBR is modified)
    set PF0BM001.SY1STNBR bold;
    PFWREC.PFWERRF = "Y";
  end
  if (PF0BM001.SY2CLRID is modified)
    set PF0BM001.SY2CLRID bold;
    PFWREC.PFWERRF = "Y";
  end
  if (PF0BM001.XDMCD is modified)
    set PF0BM001.XDMCD bold;
    PFWREC.PFWERRF = "Y";
  end
  if (PF0BM001.XQACD is modified)
    set PF0BM001.XQACD bold;
    PFWREC.PFWERRF = "Y";
  end
  if (PF0BM001.XLCCD is modified)
    set PF0BM001.XLCCD bold;
    PFWREC.PFWERRF = "Y";
  end
  ;
  if (PFWREC.PFWERRF == "Y")
    converseLib.validationFailed(02); /* <=== do not enter data if using fastpath*/
    return;
  end
  ;
  if (converseVar.eventKey not enter)
    converseLib.validationFailed(190); /* <=== must press ENTER when using*/
                                   /* fpath*/
    PFWREC.PFWERRF = "Y";
    return;
  end
  ;
  if (PF0BM001.CATOAP == "PF0B") /* <=== FASTpath into same appl.*/
    converseLib.validationFailed(10); /* <=== cannot transfer to requested screen*/
    PFWREC.PFWERRF = "Y";
  end
end // end PF0B912

Record PF0BW01 type basicRecord
  10 PF0BWNAM PF0BWNAM ; 
  10 PF0BWABK PF0BWABK ; 
  10 PF0BWSN1 PF0BWSN1 ; 
  10 PF0BWSN2 PF0BWSN2 ; 
  10 PF0BWLEV PF0BWLEV ; 
end // end PF0BW01

// numeric db2 abend key
DataItem PF0BWABK num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// current view level from scr.
DataItem PF0BWLEV char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// summary name hold area
DataItem PF0BWNAM char(10)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// valid prev. sum. name
DataItem PF0BWSN1 char(10)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// current summary name from scr
DataItem PF0BWSN2 char(10)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

