package pf0d;
import corpcom3.XPPF002;
import corpcom3.XPPF010;
import corpcom3.XPPF030;
import corpcom4.XSENTRY;
import corpcom4.XSEXIT;
import corpcom4.XSPF1;
import corpcom4.XSPF4;
import corpcom4.XSSEGTR;
import corpcom5.COMMAREA;
import corpcom5.ERRSQLCA;
import corpcom6.SQLCA;
import pf.common.PF1REC;
import pf.common.PFBISDSC;
import pf.common.PFBISGRP;
import pf.common.PFBREC;
import pf.common.PFBREF;
import pf.common.PFEREC;
import pf.common.PFWREC;
import ta.common.TA1REC;
import ta.common.TA2REC;
import xx.common.*;
import xx.common.YISCD;
import xx.common.ZZZCHGCT;
import xx.common.ZZZSDT;
import xx08.*;
import xx08.YISSDESC;
import xx08.YISTBL;
import xx10.*;
import xx10.YTYABRV;
import xx10.YTYTBL;
//*** PROGRAM=PF0D ****
//   this application is designed to perform maintenance on the
//   income/statement group table (dprof.visgrp01). it will
//   allow users the ability to add, change, delete or inquire
//   i/s group table rows.
//   maintenance history:
//     date      by            description of change
//   --------  ------  ----------------------------------------
//    1-03-89    mh    original transfer to production.
//    2-21-89    mh    correct edit in pf0d420.
//   11-30-89   tbg    modify to transfer control on PF3
//                     to 'PF0C' if that was this app's origin
//    5-30-91  dcassi  increased size of pf0dw01 from 200 to
//                     500 and increased the limit on the while
//                     loops that use it to 500.  this was done
//                     because now up to 500 yis's and isgrp's
//                     can be used.
// *********************
Program PF0D type textUIProgram //VAGen Info - main text program
  {
  includeReferencedFunctions = yes, allowUnqualifiedItemReferences = yes, 
  throwNrfEofExceptions = yes, handleHardIOErrors = no, V60ExceptionCompatibility = yes, 
  I4GLItemsNullable = no, textLiteralDefaultIsString = no, localSQLScope = yes, 
  msgTablePrefix = "PF00", inputRecord = COMMAREA, segmented = yes
  }

  // Data Declarations
  COMMAREA COMMAREA ; // record
  ERRSQLCA ERRSQLCA; // record
  PF0DW01 PF0DW01; // record
  PF0DW02 PF0DW02; // record
  PF1REC PF1REC; // record
  PFBREC PFBREC; // record
  PFEREC PFEREC; // record
  PFWREC PFWREC; // record
  SQLCA SQLCA; // record
  TA1REC TA1REC; // record
  TA2REC TA2REC; // record

  // VAGen Info - items needed for migration
  VAGen_EZESYS char(8);
  VAGen_EZEREPLY num(1);
  VAGen_EZE_WAIT_TIME bin(9,2);
  VAGen_EZE_ITEMLEN int;

  // Use Declarations
  use YISTBL {deleteAfterUse = yes}; // table
  use YTYTBL {deleteAfterUse = yes}; // table
  use PF0DM.PF0DM001 // form
   {
    pfKeyEquate = no
  };

  function main()
    // VAGen Info - initialization needed for migration
    VAGen_EZESYS = VGLib.getVAGSysType();
    PF0D000: PF0D000();
  end // end main
end // end PF0D

// application main logic
Function PF0D000()
   /* *******************************************************/
   /* *   this is the main logic for the program.          **/
   /* *******************************************************/
  ;
  PF0D001(); /* initialize the application*/
  ;
  while (PFWREC.PFWEOAF == "N") /* while not end-of-application*/
    PF0D100(); /* converse screen m001*/
  end
  ;
  XPPF002(); /* exit application*/
  ;
   /* in case of trouble,transfer to pf0a*/
  COMMAREA.CATOAP = "PF0A";
  XSEXIT();
  ;
  exit program;
  ;
  ;
end // end PF0D000

// initialization routine
Function PF0D001()
   /* ************************************************************/
   /* *  pf0d001 -initialize program - handle incoming fastpath **/
   /* ************************************************************/
  ;
  XSENTRY();
  ;
  XSSEGTR();
  ;
  PFWREC.PFW1STF = "N"; /* clear applications flags*/
  PFWREC.PFWEOAF = "N";
  PF0DW02.PF0DWNTR = "Y";
  PF0DW02.PF0DWCLF = "N";
  PFWREC.PFWSUB1 = 1;
  PFWREC.PFWSUB2 = 1;
  set PF0DW02 empty;
  ;
  set PF0DM001 initial; /* initialize screen*/
  ;
  while (PFWSUB1 <= 12) /* move i/s class table data to screen*/
    if (YISTBL.YTYCD[PFWSUB1] in YTYTBL.YTYCD) /* get i/s type(rev,cogs,etc.)*/
      PF0DM001.YTYABRV[PFWSUB1] = YTYTBL.YTYABRV[sysVar.arrayIndex];
    else
      PF0DM001.YTYABRV[PFWSUB1] = "    ";
    end
    PF0DM001.YISCD[PFWSUB1] = YISTBL.YISCD[PFWSUB1];
    PF0DM001.YISSDESC[PFWSUB1] = YISTBL.YISSDESC[PFWSUB1];
    PFWSUB1 = PFWSUB1 + 1;
  end
  ;
  PF0DM001.PF0DMDTE = VGVar.currentShortGregorianDate; /* move date to screen*/
  ;
  PF1REC.PF1PASS = COMMAREA.CAUSERA;
  ;
  if (PF1REC.PF1XFERF == "Y") /* if another application is*/
    PF0DM001.PF0DMREF = PF1REC.PF1ISG; /* bridging thru pf keys,*/
    PF0DM001.PF0DMACT = "I"; /* process an inquiry for the attribute*/
    /* ref # in the bridge record*/
    PF0D150(); /* see if ref # is in data base*/
    if (PFWREC.PFWRECF == "N") /* if ref # that was passed not on file,*/
      PFWREC.PFWERRF = "Y"; /* send the user an error message.*/
      converseLib.validationFailed(049);
      return;
    end
    set PF0DM001.PF0DMREF cursor;
    set PF0DM001.PF0DMACT protect; /* don't let the user change the action*/
                                   /* code*/
    return;
  end
  ;
  if (COMMAREA.CAITEM != " ") /* if another application is*/
    PF0DM001.PF0DMREF = COMMAREA.CAITEM;
                                   /* fast pathing to this appl.,*/
    PF0DM001.PF0DMACT = "I"; /* process an inquiry*/
    /* for the attribute ref # that was passed*/
    ;
    PF0D170(); /* see if ref # is in data base*/
    if (PFWREC.PFWRECF == "N") /* if not on file, send a error message*/
      PFWREC.PFWERRF = "Y";
      converseLib.validationFailed(049);
      return;
    end
    return;
  end
  ;
end // end PF0D001

// converse screen-main logic
Function PF0D100()
   /* *********************************************************/
   /* *  main logic loop for program - converse screen here  **/
   /* *********************************************************/
  ;
     /* before stage*/
  ;
  ;
  if (PFWERRF == "N")
    set PF0DM001.PF0DMREF cursor;
  end
  ;
  if (PF1REC.PF1XFERF == "Y")
    PF0DM001.PF0DMACT = "I";
    set PF0DM001.PF0DMACT protect;
  end
  ;
  PFWSUB3 = 1;
  ;
  while (PFWSUB3 < 13)
    if (PF0DM001.PF0DMACT == " "
     || PF0DM001.PF0DMACT == "I"
     || PF0DM001.PF0DMACT == "D")
      set PF0DM001.PFBISGRP[PFWSUB3] skip;
      set PF0DM001.PFBISDSC[PFWSUB3] skip;
    end
    PFWSUB3 = PFWSUB3 + 1;
  end
  ;
  if (PF1REC.PF1ORIG == "PF0C") /* if "pf key" bridge was used,*/
    PF0DM001.PF0DMPFK = "16:SUM MAINT";
                                   /* place the appropriate pf key*/
    set PF0DM001.PF0DMPFK normal;
    set PF0DM001.PF0DMPFK skip;
  else /* and prompt on the bottom of*/
    if (PF1REC.PF1ORIG == "PF0G") /* the screen.*/
      PF0DM001.PF0DMPFK = "16:SUM REQ";
      set PF0DM001.PF0DMPFK normal;
      set PF0DM001.PF0DMPFK skip;
    else
      if (PF1REC.PF1ORIG == "PF0H")
        PF0DM001.PF0DMPFK = "16:SUM PRT";
        set PF0DM001.PF0DMPFK normal;
        set PF0DM001.PF0DMPFK skip;
      else
        if (PF1REC.PF1ORIG == "PF0P")
          PF0DM001.PF0DMPFK = "16:PRNT DIR";
          set PF0DM001.PF0DMPFK normal;
          set PF0DM001.PF0DMPFK skip;
        end
      end
    end
  end
  ;
  PFWREC.PFWERRF = "N";
  ;
  converse PF0DM001 ;
  ;
     /* after stage*/
  ;
  PF0DS01(); /* check pf keys*/
  ;
  set PF0DM001.PF0DMREF initialAttributes; /* reset screen fields that*/
  set PF0DM001.PF0DMACT initialAttributes; /* may have been highlighted*/
  PFWSUB3 = 1; /* due to previous errors*/
  while (PFWSUB3 < 13)
    set PF0DM001.YTYABRV[PFWSUB3] initialAttributes;
    set PF0DM001.YISCD[PFWSUB3] initialAttributes;
    set PF0DM001.YISSDESC[PFWSUB3] initialAttributes;
    set PF0DM001.PFBISGRP[PFWSUB3] initialAttributes;
    set PF0DM001.PFBISDSC[PFWSUB3] initialAttributes;
    PFWSUB3 = PFWSUB3 + 1;
  end
  ;
  if (PFWREC.PFWEOAF == "Y") /* end the application?*/
    return;
  end
  ;
  if (PFWREC.PFWEOSF == "Y") /* return to menu screen*/
    COMMAREA.CATOAP = "PF0A";
    PFWREC.PFWEOAF = "Y";
    return;
  end
  ;
  if (PFWREC.PFWERRF == "N")
    if (PF0DM001.PF0DMREF == " ") /* if they didn't enter a ref #*/
      converseLib.validationFailed(027); /* it's an error*/
      PFWREC.PFWERRF = "Y";
    end
  end
  ;
  if (converseVar.eventKey is pf19 /* if user has requested to view next perform*/
   && PF0DM001.PF0DMACT == "C")    /* to check if the prior ref #*/
    PF0D210(); /* was modified*/
  end
  ;
  if (PFWERRF != "Y")
    if (PF0DM001.PF0DMACT == "K") /* user has requested a 'clone' of*/
      if (PF0DM001.PF0DMREF != PF0DW02.PF0DWISN) /* the previously displayed*/
        PF0D150(); /* ref #*/
        if (PFWREC.PFWERRF != "Y")
          PF0DW02.PF0DWACT = "A";
          PF0DW02.PF0DWCLF = "Y"; /* set clone flag*/
          PFW1STF = "Y";
        end
      else
        PFW1STF = "N";
        PFWERRF = "Y"; /* user must change ref # entered in order to*/
        converseLib.validationFailed(134); /* use the 'cloning' feature*/
      end
    end
  end
  ;
  if (PFWERRF != "Y")
    if (PF0DM001.PF0DMREF != PF0DW02.PF0DWISN
     || PF0DM001.PF0DMACT != PF0DW02.PF0DWACT
     || converseVar.eventKey is pf19
     || PFW1STF == "N")
      /* OR PF0DW02.PF0DWNTR EQ 'Y';*/
      PF0DWNTR = "N";
      PFW1STF = "N";
      PF0D150(); /* check action code*/
    end
    if (PF0DM001.PF0DMACT == " "
     || PF0DM001.PF0DMACT == "I")
      PF0D300();
    end
    if (PF0DM001.PF0DMACT == "C")
      PF0D400();
    end
    if (PF0DM001.PF0DMACT == "A")
      PF0D500();
    end
    if (PF0DM001.PF0DMACT == "D")
      PF0D600();
    end
  end
end // end PF0D100

// check for valid action code
Function PF0D150()
  ;
   /* **********************************************************/
   /* *  action code entered must be ' ' 'i' 'a' 'c' 'd'.     **/
   /* *  if ' ' 'i' 'c' 'd' was entered, record must be on    **/
   /* *  file. if 'a' was entered, record can't be on file.   **/
   /* **********************************************************/
  ;
  if (PFWREC.PFWERRF == "Y") /* if there is already an error,*/
    return; /* don't bother performing this*/
  end /* routine.*/
  ;
  ;
  if (PF0DM001.PF0DMACT == " " /* check for valid action code*/
   || PF0DM001.PF0DMACT == "I" 
   || PF0DM001.PF0DMACT == "A" 
   || PF0DM001.PF0DMACT == "K" 
   || PF0DM001.PF0DMACT == "C" 
   || PF0DM001.PF0DMACT == "D")
  else
    PFWREC.PFWERRF = "Y";
    converseLib.validationFailed(005);
    set PF0DM001.PF0DMACT bold;
    return;
  end
  ;
   /* -----------------------------------------------------------;*/
   /* Check action against security flag in commarea.  Reject   ;*/
   /* if user is not authorized to do the chosen action.        ;*/
   /* -----------------------------------------------------------;*/
  ;
  if (PF0DM001.PF0DMACT == "A"
   || PF0DM001.PF0DMACT == "K")
    if (COMMAREA.CAADDFL == "Y")
       /* this is okay*/
    else
      converseLib.validationFailed(71);
      PFWREC.PFWERRF = "Y";
      return;
    end
  end
  ;
  if (PF0DM001.PF0DMACT == "I"
   || PF0DM001.PF0DMACT == " ")
    if (COMMAREA.CAINQFL == "Y")
       /* this is okay*/
    else
      converseLib.validationFailed(71);
      PFWREC.PFWERRF = "Y";
      return;
    end
  end
  ;
  if (PF0DM001.PF0DMACT == " ")
    if (COMMAREA.CAINQFL == "Y")
       /* this is okay*/
    else
      converseLib.validationFailed(71);
      PFWREC.PFWERRF = "Y";
      return;
    end
  end
  ;
  if (PF0DM001.PF0DMACT == "C")
    if (COMMAREA.CACHGFL == "Y")
       /* this is okay*/
    else
      converseLib.validationFailed(71);
      PFWREC.PFWERRF = "Y";
      return;
    end
  end
  ;
  if (PF0DM001.PF0DMACT == "D")
    if (COMMAREA.CADELFL == "Y")
       /* this is okay*/
    else
      converseLib.validationFailed(71);
      PFWREC.PFWERRF = "Y";
      return;
    end
  end
  PF0DW02.PF0DWACT = PF0DM001.PF0DMACT;
  PF0DW02.PF0DWISN = PF0DM001.PF0DMREF;
  ;
  if (PF0DM001.PF0DMACT == "K") /* change a 'clone' activity code to an add*/
    PF0DM001.PF0DMACT = "A"; /* on the screen*/
  end
  ;
  PF0D170(); /* see if record is already*/
   /* on file*/
  ;
  if (converseVar.eventKey not pf19)
    if (PF0DM001.PF0DMACT == " " /* if record not on file*/
     || PF0DM001.PF0DMACT == "I" /* and action code is ' ' or*/
     || PF0DM001.PF0DMACT == "C" /* 'i' or 'c' or 'd', it's*/
     || PF0DM001.PF0DMACT == "D") /* an error.*/
      if (PFWREC.PFWRECF == "N")
        PFWREC.PFWERRF = "Y";
        converseLib.validationFailed(049);
        set PF0DM001.PF0DMREF bold;
        set PF0DM001.PF0DMACT bold;
        return;
      end
    end
  end
  ;
  if (PF0DM001.PF0DMACT == "A" /* if record on file and*/
   && PFWREC.PFWRECF == "Y")   /* action code is 'a',*/
    PFWREC.PFWERRF = "Y"; /* it's an error.*/
    converseLib.validationFailed(050);
    set PF0DM001.PF0DMREF bold;
    set PF0DM001.PF0DMACT bold;
    return;
  end
  ;
end // end PF0D150

// clear data screen
Function PF0D160()
  ;
  if (PFWSUB1 == PFWLIMIT) /* pfwlimit is the last storage entry. if the*/
    return;
                                   /* index = the limit, exit the routine.*/
  end
  ;
  PFWREC.PFWSUB3 = 1;
  ;
  while (PFWSUB3 < 13) /* clear screen of previous data*/
    PF0DM001.YTYABRV[PFWSUB3] = " ";
    PF0DM001.YISCD[PFWSUB3] = " ";
    PF0DM001.YISSDESC[PFWSUB3] = " ";
    PF0DM001.PFBISGRP[PFWSUB3] = " ";
    PF0DM001.PFBISDSC[PFWSUB3] = " ";
    PF0DM001.PF0DMSUB[PFWSUB3] = 0;
    PFWSUB3 = PFWSUB3 + 1;
  end
  ;
end // end PF0D160

// check for valid action code
Function PF0D170()
  ;
   /* **********************************************************/
   /* *  see if entered attribute reference # is on file.     **/
   /* *  set flag accordingly.                                **/
   /* *  check logic of activity code and the results of the  **/
   /* *  flag(i.e. if activity is an add and ref # is already **/
   /* *  on file).                                            **/
   /* *  if ref # is in data base, move the data to the       **/
   /* *  screen. otherwise, move default i/s class info.      **/
   /* *  from the yistbl.                                     **/
   /* **********************************************************/
  ;
  PF0DW02.PF0DWMOD = "N"; /* initialize screen modification flag*/
  set PFBREC empty; /* clear record*/
  PFWREC.PFWRECF = "N"; /* initialize record found flag*/
  ;
  if (converseVar.eventKey is pf19) /* user has requested to view the next*/
                                   /* i/s group #*/
    if (PF0DM001.PF0DMREF == PFWREC.PFWREF) /* increment the group # by 1*/
      PFWREC.PFWREF = PFWREC.PFWREF + 1; /* to setup key for db2 access*/
    else
      PFWREC.PFWREF = PF0DM001.PF0DMREF; /* pf19 for 1st time*/
    end
    PFBREC.PFBREF = PFWREC.PFWREF;
  end
  ;
  if (converseVar.eventKey not pf19)
    PFBREC.PFBREF = PF0DM001.PF0DMREF; /* move in key to access db2*/
    PFWREC.PFWREF = PF0DM001.PF0DMREF;
  end
  ;
  set SQLCA empty;
  ;
  call "IO2710" ("SS", SQLCA, PFBREC) {isNoRefresh = yes, isExternal = yes}; /* open DB2 cursor*/
  ;
  if (SQLCA.VAGen_SQLCODE != 0) /* if unsuccessful, abend the program*/
    TA1REC.TA1DBASE = "DPROFT";
    TA1REC.TA1TBLVU = "VISGRP01";
    PF0DW02.PF0DWISG = PFBREC.PFBREF;
    TA1REC.TA1TBLKE = PF0DW02.PF0DWISG;
    TA1REC.TA1LOCAT[3] = "PF0D170";
    TA1REC.TA1LOCAT[4] = "IO2710";
    XPPF010();
  end
  ;
  set SQLCA empty;
  ;
  call "IO2710" ("SN", SQLCA, PFBREC) {isNoRefresh = yes, isExternal = yes}; /* read first db2 row*/
  ;
  if (SQLCA.VAGen_SQLCODE == +0) /* if successful and returned record*/
    if (PF0DM001.PF0DMREF == PFBREC.PFBREF)
                                   /* is the same as requested record*/
      PFWREC.PFWRECF = "Y"; /* set record found flag*/
    end
    if (converseVar.eventKey is pf19) /* if view next logic and a record is*/
      PFWREC.PFWRECF = "Y"; /* found, set the rec found flag*/
    end
  else
    if (SQLCA.VAGen_SQLCODE == +100) /* if record not found,*/
      PFWREC.PFWRECF = "N"; /* set record flag not found*/
      call "IO2710" ("CS", SQLCA, PFBREC) {isNoRefresh = yes, isExternal = yes}; /* close db2 cursor*/
      if (SQLCA.VAGen_SQLCODE != +0) /* if cursor close errors, abend*/
        TA1REC.TA1DBASE = "DPROFT";
        TA1REC.TA1TBLVU = "VISGRP01";
        PF0DW02.PF0DWISG = PFBREC.PFBREF;
        TA1REC.TA1TBLKE = PF0DW02.PF0DWISG;
        TA1REC.TA1LOCAT[3] = "PF0D170";
        TA1REC.TA1LOCAT[4] = "IO2710";
        XPPF010();
      end
    else
      if (SQLCA.VAGen_SQLCODE == -911) /* if data base busy, send user a*/
                                   /* message*/
        PFWREC.PFWERRF = "Y"; /* set error flag*/
        converseLib.validationFailed(114); /* send busy signal*/
        PFWREC.PFWRECF = "N"; /* set record flag not found*/
        call "IO2710" ("CS", SQLCA, PFBREC) {isNoRefresh = yes, isExternal = yes}; /* close db2 cursor*/
        if (SQLCA.VAGen_SQLCODE != +0) /* if cursor close errors, abend*/
          TA1REC.TA1DBASE = "DPROFT";
          TA1REC.TA1TBLVU = "VISGRP01";
          PF0DW02.PF0DWISG = PFBREC.PFBREF;
          TA1REC.TA1TBLKE = PF0DW02.PF0DWISG;
          TA1REC.TA1LOCAT[3] = "PF0D170";
          TA1REC.TA1LOCAT[4] = "IO2710";
          XPPF010();
        end
        return;
      else
        TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error, abend prog*/
        TA1REC.TA1TBLVU = "VISGRP01";
        PF0DW02.PF0DWISG = PFBREC.PFBREF;
        TA1REC.TA1TBLKE = PF0DW02.PF0DWISG;
        TA1REC.TA1LOCAT[3] = "PF0D170";
        TA1REC.TA1LOCAT[4] = "IO2710";
        XPPF010();
      end
    end
  end
  ;
  PFWREC.XXXUSRID = PFBREC.XXXUSRID;
  ;
  if (converseVar.eventKey is pf19 /* if user has requested to view next and*/
   && PFWREC.PFWRECF == "N")       /* it's end of file, send error message.*/
    PFWREC.PFWERRF = "Y";
    converseLib.validationFailed(120);
    return;
  end
  ;
  if (converseVar.eventKey not pf19)
    if (PF0DMACT == " " /* if user has requested an inquiry*/
     || PF0DMACT == "I" /* and the i/s group # isn't on file*/
     || PF0DMACT == "C" 
     || PF0DMACT == "D")
      if (PFWRECF == "N") /* send an error message*/
        PFWERRF = "Y";
        converseLib.validationFailed(049);
        return;
      end
    end
  end
  ;
  if (converseVar.eventKey is pf19) /* move the next sequential ref # to screen*/
    PF0DM001.PF0DMREF = PFBREC.PFBREF;
    PFWREC.PFWREF = PFBREC.PFBREF;
  end
  ;
  PF0DW02.PF0DWISN = PFWREC.PFWREF; /* move current ref # to hold #*/
  ;
  if (PF0DM001.PF0DMACT == "A" /* if record on file and*/
   && PFWREC.PFWRECF == "Y")   /* action code is 'a',*/
    PFWREC.PFWERRF = "Y"; /* it's an error.*/
    converseLib.validationFailed(050);
    PFWREC.PFW1STF = "N";
    set PF0DM001.PF0DMREF bold;
    set PF0DM001.PF0DMACT bold;
    return;
  end
  ;
  if (PF0DM001.PF0DMACT == "C")
                                   /* if user wasn't the original userid or*/
    if (COMMAREA.CAUSERID != PFWREC.XXXUSRID)
                                   /* doesn't have global authority*/
      if (COMMAREA.CACLVL[1] == "Y") /* to update records, send error message*/
         /* next sentence*/
      else
        PFWREC.PFWERRF = "Y";
        converseLib.validationFailed(119);
        return;
      end
    end
  end
  ;
  if (PF0DM001.PF0DMACT == "D")
                                   /* if user wasn't the original userid or*/
    if (COMMAREA.CAUSERID != PFBREC.XXXUSRID)
                                   /* doesn't have global authority*/
      if (COMMAREA.CADLVL[1] == "Y") /* to update records, send error message*/
         /* next sentence*/
      else
        PFWREC.PFWERRF = "Y";
        converseLib.validationFailed(119);
      end
    end
  end
  ;
  if (PF0DW02.PF0DWACT == "K") /* if this is a 'clone' activity, exit this*/
    return; /* routine prior to clearing the previously displayed w/s*/
  end /* storage area*/
  ;
  set PF0DW01 empty; /* clear w/s storage area*/
                                         /* preload w/s record*/
  PF0DW01.PFBREF = PF0DM001.PF0DMREF; /* with default i/s classes*/
  PFWLIMIT = 1; /* from yistbl.*/
  while (YISTBL.YISCD[PFWLIMIT] != 9999)
    PF0DW01.YISCD[PFWLIMIT] = YISTBL.YISCD[PFWLIMIT];
    PF0DW01.PFBISGRP[PFWLIMIT] = YISTBL.YISCD[PFWLIMIT];
    PF0DW01.YISSDESC[PFWLIMIT] = YISTBL.YISSDESC[PFWLIMIT];
    PF0DW01.PFBISDSC[PFWLIMIT] = " ";
    if (YISTBL.YTYCD[PFWLIMIT] in YTYTBL.YTYCD)
      PF0DW01.YTYABRV[PFWLIMIT] = YTYTBL.YTYABRV[sysVar.arrayIndex];
    end
    PFWLIMIT = PFWLIMIT + 1;
  end
  ;
  ;
  PFWREC.PFWREF = PFBREC.PFBREF; /* save i/s group #*/
  ;
  if (PFWREC.PFWRECF == "Y") /* ;if there are db2 rows, load the db2*/
    while (SQLCA.VAGen_SQLCODE == +0) /* data elements to w/s record*/
      PFWREC.PFWSUB1 = 1; /* reset index*/
      while (PFWREC.PFWSUB1 < 501) /* locate the correct i/s class # and*/
        if (PFBREC.YISCD[1] == PF0DW01.YISCD[PFWSUB1]) /* move grp. and desc.*/
          PF0DW02.PF0DWGR = PFBREC.YISCD[2] + PFBREC.PFBISGRP;
          PF0DW01.PFBISGRP[PFWSUB1] = PF0DW02.PF0DWGR;
          PF0DW01.PFBISDSC[PFWSUB1] = PFBREC.PFBISDSC;
          PF0DW01.PF0DDB2F[PFWSUB1] = "Y"; /* place flag that this entry in*/
          PF0DW01.ZZZSDT[PFWSUB1] = PFBREC.ZZZSDT;
          PF0DW01.ZZZCHGCT[PFWSUB1] = PFBREC.ZZZCHGCT;
          /* the w/s record was already a db2 row.*/
          PFWSUB1 = 501;
        end
        PFWSUB1 = PFWSUB1 + 1;
      end
      set PFBREC empty; /* clear w/s record*/
      call "IO2710" ("SN", SQLCA, PFBREC) {isNoRefresh = yes, isExternal = yes}; /* get next db2 record*/
      if (SQLCA.VAGen_SQLCODE == +0)
        if (PFBREC.PFBREF == PFWREC.PFWREF) /* if the returned db2 row =*/
          /* next sentence              to i/s grp # we want, ok.*/
        else
          SQLCA.VAGen_SQLCODE = +100; /* if not, set condition to*/
        end /* terminate loop.*/
      else
        if (SQLCA.VAGen_SQLCODE == +100)
          /* next sentence*/
        else
          TA1REC.TA1DBASE = "DPROF1";
          TA1REC.TA1TBLVU = "VISGRP01";
          PF0DW02.PF0DWISG = PFBREC.PFBREF;
          TA1REC.TA1TBLKE = PF0DW02.PF0DWISG;
          TA1REC.TA1LOCAT[3] = "PF0D170";
          TA1REC.TA1LOCAT[4] = "IO2710";
          XPPF010();
        end
      end
    end
  end
  ;
  set SQLCA empty;
  ;
  if (PFWREC.PFWRECF == "Y") /* if cursor is still open,*/
    call "IO2710" ("CS", SQLCA, PFBREC) {isNoRefresh = yes, isExternal = yes}; /* close DB2 cursor*/
    if (SQLCA.VAGen_SQLCODE != 0) /* if unsuccessful, abend the program*/
      TA1REC.TA1DBASE = "DPROF2";
      TA1REC.TA1TBLVU = "VISGRP01";
      PF0DW02.PF0DWISG = PFBREC.PFBREF;
      TA1REC.TA1TBLKE = PF0DW02.PF0DWISG;
      TA1REC.TA1LOCAT[3] = "PF0D170";
      TA1REC.TA1LOCAT[4] = "IO2710";
      XPPF010();
    end
  end
  ;
  move PFWLIMIT to PFWSAVDX withV60Compat;
  PFWREC.PFWTPG = PFWLIMIT / 12;
  PFWREC.PFWTPG = PFWREC.PFWTPG + 1;
  ;
  PFWREC.PFWSUB1 = 1;
  PFWREC.PFWSUB2 = 1;
  ;
  while (PFWSUB2 < 13)
    PF0D190();
  end
end // end PF0D170

// backward scrolling routine
Function PF0D180()
   /* ********************************************************/
   /* *    the user has entered pf7 to scroll backward on   **/
   /* *    the display.                                     **/
   /* ********************************************************/
  ;
  ;
  PFWREC.PFWIDX = PFWREC.PFWIDX - 12; /* decrement the index*/
   /* to the start of the previous screen*/
  ;
  if (PFWIDX < 0) /* can't scroll any further?*/
    converseLib.validationFailed(085); /* let the user know with a message*/
    return;
  end
  ;
  move PFWIDX to PFWSUB1 withV60Compat; /* set starting position for scrolling*/
  PFWSUB2 = 1; /* set screen index to the first position*/
  ;
  while (PFWSUB2 < 13) /* move data to screen until screen is full*/
    PF0D185();
  end
  ;
end // end PF0D180

// fill (pf7) backward scroll
Function PF0D185()
  ;
  PF0DM001.YISCD[PFWSUB2] = PF0DW01.YISCD[PFWSUB1];
  PF0DM001.YTYABRV[PFWSUB2] = PF0DW01.YTYABRV[PFWSUB1];
  PF0DM001.YISSDESC[PFWSUB2] = PF0DW01.YISSDESC[PFWSUB1];
  PF0DM001.PFBISGRP[PFWSUB2] = PF0DW01.PFBISGRP[PFWSUB1]; /* group #*/
  PF0DM001.PFBISDSC[PFWSUB2] = PF0DW01.PFBISDSC[PFWSUB1]; /* group desc.*/
  PF0DM001.PF0DMSUB[PFWSUB2] = PFWSUB1; /* pf0dw01 subscript*/
  ;
  if (PFWSUB2 == 1) /* if this is the first line of the screen,*/
    PFWCPG = PFWIDX / 12; /* calculate the current page #*/
    PFWCPG = PFWCPG + 1;
    PF0DM001.PF0DMPG1 = PFWCPG;
    PF0DM001.PF0DMPG2 = PFWTPG;
  end
  ;
  PFWSUB1 = PFWSUB1 + 1; /* increment storage index*/
  PFWSUB2 = PFWSUB2 + 1; /* increment screen index*/
end // end PF0D185

// scroll forward
Function PF0D190()
  ;
   /* ********************************************************/
   /* *    this is the initial display of a data record or  **/
   /* *    the user has entered pf8 to scroll forward on    **/
   /* *    the display. use the current value for ezetst and **/
   /* *    fill display screen.                             **/
   /* ********************************************************/
  ;
  if (PFWSUB1 == PFWSAVDX)
    converseLib.validationFailed(032);
    PFWSUB2 = 13;
    return;
  end
  ;
  PF0DM001.YTYABRV[PFWSUB2] = PF0DW01.YTYABRV[PFWSUB1];
  PF0DM001.PF0DMSUB[PFWSUB2] = PFWSUB1;
  PF0DM001.YISCD[PFWSUB2] = PF0DW01.YISCD[PFWSUB1];
  PF0DM001.YISSDESC[PFWSUB2] = PF0DW01.YISSDESC[PFWSUB1];
  PF0DM001.PFBISGRP[PFWSUB2] = PF0DW01.PFBISGRP[PFWSUB1];
  PF0DM001.PFBISDSC[PFWSUB2] = PF0DW01.PFBISDSC[PFWSUB1];
  ;
  if (PFWSUB2 == 1)
    PFWCPG = PFWSUB1 / 12;
    PFWCPG = PFWCPG + 1;
    PFWREC.PFWIDX = PFWSUB1;
    PF0DM001.PF0DMPG1 = PFWCPG;
    PF0DM001.PF0DMPG2 = PFWTPG;
  end
  ;
  PFWSUB1 = PFWSUB1 + 1;
  PFWSUB2 = PFWSUB2 + 1;
  ;
end // end PF0D190

// check for screen mod. for pf19
Function PF0D210()
   /* ********************************************************/
   /* *  user has pressed pf19 which will access the next   **/
   /* *  sequential ref # in the data base. if the user has **/
   /* *  changed the prior ref #, those changes will not    **/
   /* *  be updated on the data base. therefore, if the     **/
   /* *  screen was modified, send a message to the user    **/
   /* *  warning of the pending loss of data entry.         **/
   /* ********************************************************/
  ;
  if (PF0DM001 is modified) /* if the first screen sent had data other*/
    if (PF0DM001.PF0DMREF == PF0DW02.PF0DWISN /* than the ref # and*/
     && PF0DM001.PF0DMACT == PF0DW02.PF0DWACT) /* activity code modified,*/
      PFWERRF = "Y"; /* send message to warn that changes*/
                                   /* will be lost*/
      converseLib.validationFailed(135);
      PF0DW02.PF0DWMOD = "N";
    end
  end
  ;
  if (PF0DW02.PF0DWMOD == "Y") /* if prior ref # modified, send a*/
                                   /* message*/
    PFWERRF = "Y"; /* to warn that changes will be lost*/
    converseLib.validationFailed(135);
    PF0DW02.PF0DWMOD = "N";
  end
end // end PF0D210

// process inquiry requests
Function PF0D300()
   /* *****************************************************/
   /* **/
   /* **/
   /* **/
   /* **/
  ;
  if (converseVar.eventKey is enter /* if enter, exit the routine*/
   || converseVar.eventKey is pf19)
    return;
  end
  ;
  if (PFWREC.PFWERRF == "Y") /* if there are previous errors, exit*/
                                   /* the routine*/
    return;
  end
  ;
  PFW1STF = "Y";
  ;
  if (converseVar.eventKey is pf7) /* if pf7 was pressed, perform routine to scroll*/
    PF0D180(); /* backward*/
    return;
  end
  ;
  if (converseVar.eventKey is pf8) /* if pf8 was pressed,*/
    PFWSUB2 = 1;
    PF0D160(); /* clear data from previously conversed screenand*/
    while (PFWSUB2 < 13)
      PF0D190(); /* perform scroll forward routine*/
    end
    return;
  end
  ;
  PF0D160(); /* clear data from previously conversed map*/
  PFWSUB2 = 1; /* to reach this point of this process*/
                                   /* this must be*/
  while (PFWSUB2 < 13) /* the first screen of a fresh inquiry. so,*/
    PF0D190(); /* perform scroll forward routine.*/
  end
  ;
end // end PF0D300

// process change requests
Function PF0D400()
   /* ******************************************************/
   /* *  this routine is performed when the user has      **/
   /* *  entered an action code of 'c'. initial appli-    **/
   /* *  cation logic has found the db2 record, loaded    **/
   /* *  the w/s storage area, setup the first 12 items   **/
   /* *  to the screen, sent the screen and arrived       **/
   /* *  here. first time through, the process will exit  **/
   /* *  because the user has yet to update the data.     **/
   /* *  in this process, the user can scroll and change  **/
   /* *  the w/s storage data using the pf7 and pf8 keys. **/
   /* *  pf12 will edit only. enter will initiate a db2   **/
   /* *  update.                                          **/
   /* ******************************************************/
  ;
  if (PFWREC.PFWERRF == "Y") /* if there are previous errors,*/
    return; /* exit immediately*/
  end
  ;
  set PFEREC empty;
  set SQLCA empty;
  ;
  PFEREC.PFCREF = -1; /* set wild card search keys for*/
  PFEREC.PFDREF = -1; /* delete verification*/
  PFEREC.PFBREF = PF0DW01.PFBREF; /* set specific search key*/
  ;
   /* ************************************/
   /* Scan Summary Attribute table*/
   /* ************************************/
  ;
  PFEREC.PFESUMNM = " "; /* set low-value for scan*/
  PFWREC.PFWERRF = "N"; /* set general error-flag off*/
  ;
  call "IO2770" ("S1", SQLCA, PFEREC) {isNoRefresh = yes, isExternal = yes}; /* Open cursor 1*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0) /* If cursor sucessfully 'Open'ed*/
    ;
    while (PFWREC.PFWERRF != "Y" /* While no errors found*/
     && SQLCA.VAGen_SQLCODE == 0) /* and last fetch successful*/
      ;
      call "IO2770" ("N1", SQLCA, PFEREC) {isNoRefresh = yes, isExternal = yes}; /* Get next row*/
      ;
      if (SQLCA.VAGen_SQLCODE == 0) /* Row found...*/
        ;
        if (PF0DM001.PF0DMREF == PFEREC.PFBREF) /* Right Ref #?*/
          ;
          if (PFEREC.PFESTIND == "N" /* Status is 'normal'*/
           || PFEREC.PFESTIND == "I" /* Status is 'in process'*/
           || PFEREC.PFESTIND == "O") /* Status is 'in process'*/
            PFWREC.PFWERRF = "Y"; /* Set general error-flag on*/
            ;
          else
            ;
            if (PFEREC.PFESTIND == "H" /* Status is 'on hold'*/
             && PFEREC.PFECRTDT > 0)   /* Creation date exists*/
              PFWREC.PFWERRF = "Y"; /* Set error-flag on*/
            end
          end
        end
      else
        if (SQLCA.VAGen_SQLCODE != 100)
          TA1REC.TA1DBASE = "DPROFT"; /* abend the program*/
          TA1REC.TA1TBLVU = "VSUMAT01";
          PF0DW02.PF0DWREF = PFEREC.PFBREF;
          TA1REC.TA1TBLKE = PF0DW02.PF0DWREF;
          TA1REC.TA1LOCAT[1] = "PF0D400";
          TA1REC.TA1LOCAT[2] = "IO2770";
          XPPF010();
        end
      end
    end
    ;
    call "IO2770" ("C1", SQLCA, PFEREC) {isNoRefresh = yes, isExternal = yes}; /* Close cursor*/
    ;
    if (PFWREC.PFWERRF == "Y") /* Was an error found?*/
      ;
      converseLib.validationFailed(124); /* Ref # cannot be changed...*/
      ;
    end
    ;
  else /* Non-0 return code on 'open'*/
    ;
    TA1REC.TA1DBASE = "DPROFT"; /* abend the program*/
    TA1REC.TA1TBLVU = "VSUMAT01";
    PF0DW02.PF0DWREF = PFEREC.PFBREF;
    TA1REC.TA1TBLKE = PF0DW02.PF0DWREF;
    TA1REC.TA1LOCAT[1] = "PF0D400";
    TA1REC.TA1LOCAT[2] = "IO2770";
    XPPF010();
    ;
  end
  ;
  if (PFWREC.PFW1STF == "N") /* first time thru, exit routine*/
    if (converseVar.eventKey is enter)
      PFWREC.PFW1STF = "Y";
      return;
    end
    if (converseVar.eventKey is pf19)
      PFWREC.PFW1STF = "Y";
      return;
    end
  end
  ;
  if (PF0DM001 is modified)
                                   /* if user entered changes, set mod flag*/
    PF0DW02.PF0DWMOD = "Y";
  end
  ;
  if (converseVar.eventKey is enter) /* user has requested an update.*/
    PFWSUB = 1;
    while (PFWSUB < 13)
      if (PF0DM001.YISCD[PFWSUB] == 0)
        PFWSUB = 13;
      else
        PF0D420(); /* first, edit screen data*/
        PFWSUB = PFWSUB + 1;
      end
    end
    if (PFWREC.PFWERRF != "Y") /* if edit ok, then update record*/
      PF0D450();
      converseLib.validationFailed(015);
      PF0DW02.PF0DWNTR = "Y";
      PF0DW02.PF0DWMOD = "N";
    end
    return;
  end
  ;
  if (converseVar.eventKey is pf7) /* user has requested to scroll*/
    PFWREC.PFWSUB = 1;
    while (PFWSUB < 13)
      if (PF0DM001.YISCD[PFWSUB] == 0)
        PFWSUB = 13;
      else
        PF0D420(); /* backward. edit screen data,*/
        PFWSUB = PFWSUB + 1;
      end
    end
    if (PFWREC.PFWERRF != "Y") /* update the w/s record, then*/
      PF0D180(); /* scroll backward.*/
    end
    return;
  end
  ;
  if (converseVar.eventKey is pf8) /* user has requested to scroll*/
    PFWSUB = 1;
    while (PFWSUB < 13)
      if (PF0DM001.YISCD[PFWSUB] == 0)
        PFWSUB = 13;
      else
        PF0D420(); /* first, edit screen data*/
        PFWSUB = PFWSUB + 1;
      end
    end
    if (PFWREC.PFWERRF == "Y") /* if an error is found, edit entered*/
      PFWSUB = 1;
      while (PFWSUB <= 12)
        set PF0DM001.PFBISGRP[PFWSUB] initialAttributes;
        set PF0DM001.PFBISDSC[PFWSUB] initialAttributes;
        PFWSUB = PFWSUB + 1;
      end
      PFWREC.PFWERRF = "N";
      PFWSUB = 12; /* data in a backwards direction. this*/
      while (PFWSUB > 0) /* will permit more flexibility in data*/
        if (PF0DM001.YISCD[PFWSUB] == 0)
          PFWSUB = 0;
        else
          PF0D420(); /* entry.*/
          PFWSUB = PFWSUB - 1;
        end
      end
    end
    if (PFWREC.PFWERRF != "Y") /* update the w/s record, then*/
      PFWSUB3 = 1; /* scroll forward.*/
      PF0D160();
      PFWSUB2 = 1;
      while (PFWSUB2 < 13)
        PF0D190();
      end
    end
    return;
  end
  ;
  if (converseVar.eventKey is pf12) /* user has requested to edit*/
    PFWSUB = 1;
    while (PFWSUB < 13)
      if (PF0DM001.YISCD[PFWSUB] == 0)
        PFWSUB = 13;
      else
        PF0D420(); /* screen data*/
        PFWSUB = PFWSUB + 1;
      end
    end
    if (PFWERRF == "N")
      converseLib.validationFailed(051);
    end
  end
  ;
end // end PF0D400

// edit update screen data
Function PF0D420()
   /* *********************************************************/
   /* *  in this process, see if entered group # already     **/
   /* *  exists. if the group # exists, compare i/s types    **/
   /* *  to make sure they are the same(i.e., don't group    **/
   /* *  'rev' and 'cogs' because that's illogical.). if     **/
   /* *  the group # doesn't exist and the group # is the    **/
   /* *  same as the i/s class # and the group description   **/
   /* *  is blank, this i/s class item isn't being grouped.  **/
   /* *  if the group # doesn't exist and the group # is     **/
   /* *  different from the i/s class #, a new group # is    **/
   /* *  being created. the group description field must     **/
   /* *  have an entry or it's an error. if the entry has    **/
   /* *  no errors, update the w/s storage slot.             **/
   /* *********************************************************/
  ;
  PF0DW02.PF0DWABR = PF0DM001.YTYABRV[PFWSUB];
                                   /* save abbrev. in hold area*/
  ;
  if (PF0DM001.PFBISGRP[PFWSUB] == 0 /* if user cleared the i/s group field*/
   /* or*/
   || PF0DM001.YISCD[PFWSUB] == PF0DM001.PFBISGRP[PFWSUB]) /* ungrouped the*/
    /* group #, move the i/s class code to the i/s group*/
    /* field and blank out the i/s group desc.*/
    PF0DM001.PFBISGRP[PFWSUB] = PF0DM001.YISCD[PFWSUB];
    PF0DM001.PFBISDSC[PFWSUB] = " ";
    PFWSUB3 = PF0DM001.PF0DMSUB[PFWSUB];
    PF0DW01.PFBISGRP[PFWSUB3] = PF0DM001.YISCD[PFWSUB];
    PF0DW01.PFBISDSC[PFWSUB3] = " ";
  end
  ;
  PFWREC.PFWRECF = " ";
  PF0DW02.PF0DWGRP = PF0DM001.PFBISGRP[PFWSUB]; /* save group # in*/
                                                 /* hold area*/
  ;
  if (PF0DW02.PF0DWGR2 == 0 /* user has tried to enter a group # that*/
   && PF0DM001.PFBISGRP[PFWSUB] != PF0DM001.YISCD[PFWSUB]) /* ends with*/
    PFWREC.PFWERRF = "Y"; /* a zero. that's an error.*/
    converseLib.validationFailed(280);
    set PF0DM001.PFBISGRP[PFWSUB] cursor, bold;
    return;
  end
  ;
  while (PFWREC.PFWRECF == " ") /* perform a routine to determine if*/
    PF0D430();
                                   /* the entered group # exists.*/
  end
  ;
  if (PFWRECF == "Y") /* if the group # already exists, check to see*/
    if (PF0DW01.YTYABRV[PFWSUB3] == PF0DW02.PF0DWABR) /* if the i/s class types*/
      PFWSUB2 = PF0DM001.PF0DMSUB[PFWSUB];
      PF0DW01.PFBISDSC[PFWSUB2] = PF0DW01.PFBISDSC[PFWSUB3];
       /* are the same. if they are, move*/
      /* the group description from existing group # to entered group*/
    else
      converseLib.validationFailed(097); /* if the i/s class types aren't the same, send*/
      PFWREC.PFWERRF = "Y"; /* the user a message that i/s types*/
      set PF0DM001.YTYABRV[PFWSUB] skip, bold; /* must be the same.*/
      set PF0DM001.PFBISGRP[PFWSUB] bold;
      set PF0DM001.PFBISGRP[PFWSUB] cursor;
    end
  end
  ;
  if (PFWRECF == "N") /* if group # doesn't exist, check to see if a*/
    if (PF0DM001.PFBISGRP[PFWSUB] == PF0DM001.YISCD[PFWSUB])
       /* group # was entered. if not entered,*/
       /* i/s class code isn't being grouped. bypass it.*/
    else
       /* if group # doesn't exist and a group was entered, the group*/
       /* desc. must be entered.*/
      if (PF0DM001.PFBISGRP[PFWSUB] != PF0DM001.YISCD[PFWSUB])
        if (PF0DM001.PFBISDSC[PFWSUB] == " ")
          converseLib.validationFailed(098);
          PFWERRF = "Y";
          set PF0DM001.PFBISDSC[PFWSUB] bold;
          set PF0DM001.PFBISDSC[PFWSUB] cursor;
        end
      end
    end
  end
  ;
  if (PFWERRF == "N") /* if there are no errors on this i/s entry,*/
    PFWSUB3 = PF0DM001.PF0DMSUB[PFWSUB]; /* move screen fields*/
    /* to w/s area pending db2 update.*/
    PF0DW01.PFBISGRP[PFWSUB3] = PF0DM001.PFBISGRP[PFWSUB];
    PF0DW01.PFBISDSC[PFWSUB3] = PF0DM001.PFBISDSC[PFWSUB];
    if (PF0DM001.PFBISGRP[PFWSUB] == PF0DM001.YISCD[PFWSUB])
      PF0DM001.PFBISDSC[PFWSUB] = " "; /* if not being grouped, make*/
      PF0DW01.PFBISDSC[PFWSUB3] = " "; /* sure desc. is blank*/
    end
  end
end // end PF0D420

// search for entered group #
Function PF0D430()
   /* *******************************************************/
   /* * search thru the existing pf0dw01 record to see if  **/
   /* * the entered group # exists. if the group # is not **/
   /* * found, decrement and search for the group # until  **/
   /* * a group # is found or the group # ends in a zero.  **/
   /* * (i.e. grp # 0033 is entered, search for 0033, then **/
   /* * 0032, then 0031 and stop at 0030 because it is not **/
   /* * a valid group #). make sure that i/s class types   **/
   /* * are the same(rev = rev).                           **/
   /* *******************************************************/
  ;
  if (PF0DWGR2 == 0) /* no group # found, exit the routine*/
    PFWRECF = "N";
    return;
  end
  ;
  PFWSUB2 = 1;
  ;
  while (PFWREC.PFWSUB2 < 501)
                                   /* search thru the pf0dw01 record for*/
    if (PF0DW02.PF0DWGRP == PF0DW01.PFBISGRP[PFWSUB2]) /* the entered group #*/
      move PFWSUB2 to PFWSUB3 withV60Compat; /* save the subscript of found group #*/
      PFWRECF = "Y"; /* set the flag*/
      PFWSUB2 = 500; /* set subscript to terminate loop*/
      if (PF0DM001.PFBISDSC[PFWSUB] > " ") /* if a desc. entered on screen*/
        PFWREC.PFWRECF = "N"; /* reset flag*/
        PFWSUB2 = 550; /* set subscript to trip*/
        PF0D440(); /* check for global change*/
      else
        PF0DM001.PFBISDSC[PFWSUB] = PF0DW01.PFBISDSC[PFWSUB3];
      end
    end
    PFWSUB2 = PFWSUB2 + 1;
  end
  ;
  PF0DWGR2 = PF0DWGR2 - 1; /* decrement the group #*/
  ;
  if (PFWREC.PFWSUB2 > 549)
    PFWREC.PFWRECF = "N";
    if (PF0DW01.YTYABRV[PFWSUB3] == PF0DM001.YTYABRV[PFWSUB])
                                   /* if screen i/s*/
       /* class is the same as the pf0dw01 record i/s class*/
       /* next sentence*/
    else
      converseLib.validationFailed(097); /* send error message*/
      PFWREC.PFWERRF = "Y";
      set PF0DM001.YTYABRV[PFWSUB] skip, bold;
      set PF0DM001.PFBISGRP[PFWSUB] bold;
      set PF0DM001.PFBISGRP[PFWSUB] cursor;
    end
  end
end // end PF0D430

// check for global change
Function PF0D440()
   /* **********************************************************/
   /* *  if the group desc. entered on the screen is          **/
   /* *  different from the group desc. for the first entry   **/
   /* *  for that group # in the w/s storage record, check    **/
   /* *  for the following :                                  **/
   /* *  if the group # entered on the screen is the first    **/
   /* *  occurrence of that group # in the w/s storage area,  **/
   /* *  this is a global change. change the group desc. of   **/
   /* *  all occurrences of that group # to the group desc.   **/
   /* *  entered on the screen.                               **/
   /* *  if the group # entered on the screen is not the      **/
   /* *  first occurence of that group # in the w/s storage   **/
   /* *  area, it's an error. only the first occurence can    **/
   /* *  be used to make a global change.                     **/
   /* **********************************************************/
  ;
  if (PF0DM001.PFBISGRP[PFWSUB] != PF0DW01.PFBISGRP[PFWSUB3])
    return; /* the group #'s must be the same for global changes*/
  end
  ;
   /* ************************************************************/
   /* * compare saved screen subscript to w/s storage subscript **/
   /* * to determine if this the first occurrence of the group #**/
   /* ************************************************************/
  ;
  if (PF0DM001.PF0DMSUB[PFWSUB] <= PFWSUB3) /* if this is the 1st occur.,*/
    if (PF0DM001.PFBISDSC[PFWSUB] == PF0DW01.PFBISDSC[PFWSUB3])
       /* next sentence-- if the desc. are =, nothing changed bypass*/
    else
      PFWSUB2 = 1; /* reset subscript*/
      while (PFWSUB2 < 501)
                                   /* if group #'s =, globally change desc.*/
        if (PF0DM001.PFBISGRP[PFWSUB] == PF0DW01.PFBISGRP[PFWSUB2])
          PF0DW01.PFBISDSC[PFWSUB2] = PF0DM001.PFBISDSC[PFWSUB];
        end
        PFWSUB2 = PFWSUB2 + 1;
      end
      PFWSUB2 = 1; /* change the desc. on the screen as well*/
      while (PFWSUB2 < 13)
        if (PF0DM001.PFBISGRP[PFWSUB] == PF0DM001.PFBISGRP[PFWSUB2])
          PF0DM001.PFBISDSC[PFWSUB2] = PF0DM001.PFBISDSC[PFWSUB];
        end
        PFWSUB2 = PFWSUB2 + 1;
      end
    end
  else
    if (PF0DM001.PFBISDSC[PFWSUB] != PF0DW01.PFBISDSC[PFWSUB3])
      PFWERRF = "Y";
                                   /* send message that only 1st occur. can*/
      converseLib.validationFailed(121); /* be used to globally change group desc.*/
      set PF0DM001.PFBISDSC[PFWSUB] cursor, bold;
    end
  end
end // end PF0D440

// update table
Function PF0D450()
   /* ***************************************************/
   /* *  determine what activity code was entered and  **/
   /* *  perform the appropriate db2 update routine    **/
   /* *  while browsing through the pfodw01 w/s record **/
   /* ***************************************************/
  ;
  if (PF0DM001.PF0DMACT == "C") /* if action code is 'change',*/
    PFWSUB = 1; /* reset subscript*/
    while (PFWSUB < 501)
      PF0D460(); /* perform db2 change routine*/
    end
  end
  ;
  if (PF0DM001.PF0DMACT == "A") /* if action code is 'add',*/
    PFWSUB = 1; /* reset subscript*/
    while (PFWSUB < 501)
      PF0D470(); /* perform db2 add routine*/
    end
  end
  ;
  if (PF0DM001.PF0DMACT == "D") /* if action code is 'delete',*/
    PFWSUB = 1; /* reset subscript*/
    while (PFWSUB < 501)
      PF0D480(); /* perform db2 delete routine*/
    end
  end
  ;
end // end PF0D450

// db2 change routine
Function PF0D460()
   /* ******************************************************/
   /* * to change an existing i/s group db2 entry the     **/
   /* * pf0dw01.pf0ddb2f flag and pf0dw01.pfbisgrp fields **/
   /* * must be checked. the pf0ddb2f is set to 'y' when  **/
   /* * that i/s class was already a db2 row. when the    **/
   /* * i/s group # is not = to the pf0dw01.yiscd field   **/
   /* * that i/s class is being grouped. bearing that in  **/
   /* * mind, the change matrix is as follows:            **/
   /* *  pf0ddb2f         i/s group #      db2 action     **/
   /* *  --------         -----------      -----------    **/
   /* *   'y'                =             delete row     **/
   /* *   'y'                not =         update row     **/
   /* *   ' '                not =         add row        **/
   /* *   ' '                =             no action      **/
   /* ******************************************************/
  ;
  set PFBREC empty; /* clear w/s record*/
  ;
  if (PF0DW01.YISCD[PFWSUB] == PF0DW01.PFBISGRP[PFWSUB]) /* if group # not =*/
    if (PF0DW01.PF0DDB2F[PFWSUB] == "Y") /* and the db2 flag is 'y',*/
      PFBREC.PFBREF = PF0DM001.PF0DMREF; /* delete the row*/
      PFBREC.YISCD = PF0DW01.YISCD[PFWSUB];
      PF0DW01.PF0DDB2F[PFWSUB] = " ";
      call "IO2710" ("D ", SQLCA, PFBREC) {isNoRefresh = yes, isExternal = yes};
      if (SQLCA.VAGen_SQLCODE != +0) /* if there is an error deleting the record,*/
        TA1REC.TA1DBASE = "DPROFT"; /* abend the application*/
        TA1REC.TA1TBLVU = "VISGRP01";
        PF0DW02.PF0DWISG = PFBREC.PFBREF;
        TA1REC.TA1TBLKE = PF0DW02.PF0DWISG;
        TA1REC.TA1LOCAT[3] = "PF0D4601";
        TA1REC.TA1LOCAT[4] = "IO2710";
        XPPF010();
      end
    end
  end
  ;
  if (PF0DW01.YISCD[PFWSUB] != PF0DW01.PFBISGRP[PFWSUB]) /* if group # not =*/
    if (PF0DW01.PF0DDB2F[PFWSUB] == "Y") /* and the db2 flag is 'y',*/
      PFBREC.PFBREF = PF0DM001.PF0DMREF; /* update the row*/
      PFBREC.YISCD[1] = PF0DW01.YISCD[PFWSUB];
      PF0DW02.PF0DWGRP = PF0DW01.PFBISGRP[PFWSUB];
      PFBREC.PFBISGRP = PF0DW02.PF0DWGR2;
      PF0DW01.PF0DDB2F[PFWSUB] = "Y";
      PF0DW02.PF0DWGR2 = 0;
      PFBREC.YISCD[2] = PF0DW02.PF0DWGRP;
      PFBREC.PFBISDSC = PF0DW01.PFBISDSC[PFWSUB];
      PFBREC.XXXUSRID = PFWREC.XXXUSRID;
      PFBREC.ZZZSDT = PF0DW01.ZZZSDT[PFWSUB];
      PFBREC.ZZZCHGCT = PF0DW01.ZZZCHGCT[PFWSUB];
      PF0DW01.ZZZCHGCT[PFWSUB] = PF0DW01.ZZZCHGCT[PFWSUB] + 1;
      XPPF030(); /* perform date/time routine*/
      PFBREC.ZZZCHGDT = TA2REC.TA2GRGGN;
      PFBREC.ZZZCHGTM = TA2REC.TA2TIMHM;
      call "IO2710" ("U ", SQLCA, PFBREC) {isNoRefresh = yes, isExternal = yes};
      if (SQLCA.VAGen_SQLCODE != +0) /* if there is an error updating the record,*/
        TA1REC.TA1DBASE = "DPROFT"; /* abend the application*/
        TA1REC.TA1TBLVU = "VISGRP01";
        PF0DW02.PF0DWISG = PFBREC.PFBREF;
        TA1REC.TA1TBLKE = PF0DW02.PF0DWISG;
        TA1REC.TA1LOCAT[3] = "PF0D4602";
        TA1REC.TA1LOCAT[4] = "IO2710";
        XPPF010();
      end
    else /* if the db2 flag isn't = 'y',*/
      PFBREC.PFBREF = PF0DM001.PF0DMREF; /* add this new row*/
      PFBREC.YISCD = PF0DW01.YISCD[PFWSUB];
      PF0DW02.PF0DWGRP = PF0DW01.PFBISGRP[PFWSUB];
      PFBREC.PFBISGRP = PF0DW02.PF0DWGR2;
      PF0DW02.PF0DWGR2 = 0;
      PFBREC.YISCD[2] = PF0DW02.PF0DWGRP;
      PFBREC.PFBISDSC = PF0DW01.PFBISDSC[PFWSUB];
      PF0DW01.PF0DDB2F[PFWSUB] = "Y";
      PFBREC.XXXUSRID = PFWREC.XXXUSRID;
      PFBREC.ZZZSDT = TA2REC.TA2GRGGN;
      PFBREC.ZZZCHGDT = TA2REC.TA2GRGGN;
      PFBREC.ZZZCHGTM = TA2REC.TA2TIMHM;
      PFBREC.ZZZCHGCT = 0;
      call "IO2710" ("A ", SQLCA, PFBREC) {isNoRefresh = yes, isExternal = yes};
      if (SQLCA.VAGen_SQLCODE != +0) /* if there is an error adding the*/
                                   /* record,*/
        TA1REC.TA1DBASE = "DPROFT"; /* abend the application*/
        TA1REC.TA1TBLVU = "VISGRP01";
        PF0DW02.PF0DWISG = PFBREC.PFBREF;
        TA1REC.TA1TBLKE = PF0DW02.PF0DWISG;
        TA1REC.TA1LOCAT[3] = "PF0D4603";
        TA1REC.TA1LOCAT[4] = "IO2710";
        XPPF010();
      end
    end
  end
  ;
  PFWSUB = PFWSUB + 1; /* increment subscript*/
  ;
  if (PF0DW01.YISCD[PFWSUB] == 0)
    PFWSUB = 501;
  end
end // end PF0D460

// db2 add routine
Function PF0D470()
   /* ******************************************************/
   /* * to add a i/s group db2 entry, loop through the    **/
   /* * pf0dw01 record and add a db2 row wherever the     **/
   /* * i/s class and i/s group # are not the same.       **/
   /* ******************************************************/
  ;
  set PFBREC empty; /* clear w/s record*/
  ;
  if (PF0DW01.YISCD[PFWSUB] != PF0DW01.PFBISGRP[PFWSUB]) /* if class # not =*/
    PFBREC.PFBREF = PF0DM001.PF0DMREF; /* group #, add the row*/
    PFBREC.YISCD[1] = PF0DW01.YISCD[PFWSUB];
    PF0DW02.PF0DWGRP = PF0DW01.PFBISGRP[PFWSUB];
    PFBREC.PFBISGRP = PF0DW02.PF0DWGR2;
    PF0DW02.PF0DWGR2 = 0;
    PFBREC.YISCD[2] = PF0DW02.PF0DWGRP;
    PFBREC.PFBISDSC = PF0DW01.PFBISDSC[PFWSUB];
    PFBREC.XXXUSRID = COMMAREA.CAUSERID;
    XPPF030(); /* perform system date/time routine*/
    PFBREC.ZZZSDT = TA2REC.TA2GRGGN;
    PFBREC.ZZZCHGDT = TA2REC.TA2GRGGN;
    PFBREC.ZZZCHGTM = TA2REC.TA2TIMHM;
    PFBREC.ZZZCHGCT = 0;
    call "IO2710" ("A ", SQLCA, PFBREC) {isNoRefresh = yes, isExternal = yes};
    if (SQLCA.VAGen_SQLCODE != +0) /* if there is an error adding the*/
                                   /* record,*/
      TA1REC.TA1DBASE = "DPROFT"; /* abend the application*/
      TA1REC.TA1TBLVU = "VISGRP01";
      PF0DW02.PF0DWISG = PFBREC.PFBREF;
      TA1REC.TA1TBLKE = PF0DW02.PF0DWISG;
      TA1REC.TA1LOCAT[3] = "PF0D460";
      TA1REC.TA1LOCAT[4] = "IO2710";
      XPPF010();
    end
  end
  ;
  PFWSUB = PFWSUB + 1; /* increment subscript*/
  ;
  if (PF0DW01.YISCD[PFWSUB] == 0)
    PFWSUB = 501;
  end
end // end PF0D470

// delete db2 row
Function PF0D480()
   /* ******************************************************/
   /* * to delete a i/s group db2 entry, loop through the **/
   /* * pf0dw01 record and delete the db2 row wherever    **/
   /* * the pf0ddb2f flag is 'y'.                         **/
   /* ******************************************************/
  ;
  set PFBREC empty; /* clear w/s record*/
  ;
  if (PF0DW01.PF0DDB2F[PFWSUB] == "Y") /* if the db2 flag = 'y',*/
    PFBREC.PFBREF = PF0DM001.PF0DMREF; /* delete the row*/
    PFBREC.YISCD = PF0DW01.YISCD[PFWSUB];
    PFBREC.XXXUSRID = COMMAREA.CAUSERID;
    call "IO2710" ("D ", SQLCA, PFBREC) {isNoRefresh = yes, isExternal = yes};
    if (SQLCA.VAGen_SQLCODE != +0) /* if there is an error deleting the record,*/
      TA1REC.TA1DBASE = "DPROFT"; /* abend the application*/
      TA1REC.TA1TBLVU = "VISGRP01";
      PF0DW02.PF0DWISG = PFBREC.PFBREF;
      TA1REC.TA1TBLKE = PF0DW02.PF0DWISG;
      TA1REC.TA1LOCAT[3] = "PF0D460";
      TA1REC.TA1LOCAT[4] = "IO2710";
      XPPF010();
    end
  end
  ;
  PFWSUB = PFWSUB + 1; /* increment subscript*/
  ;
end // end PF0D480

// process add requests
Function PF0D500()
   /* *****************************************************/
   /* **/
   /* **/
   /* **/
   /* **/
  ;
  if (PFWREC.PFWERRF == "Y")
    return;
  end
  ;
  if (PF0DW02.PF0DWCLF == "Y") /* 'clone' request. change the activity to*/
     /* 'a' and resend screen to allow user to modify the i/s group*/
    PF0DW02.PF0DWCLF = "N";
    return;
  end
  ;
  if (converseVar.eventKey is enter
   && PFWREC.PFW1STF == "N")
    PFWREC.PFW1STF = "Y";
    return;
  end
  ;
  if (converseVar.eventKey is enter) /* user has requested an update.*/
    PFWSUB = 1;
    while (PFWSUB < 13)
      if (PF0DM001.YISCD[PFWSUB] == 0)
        PFWSUB = 13;
      else
        PF0D420(); /* first, edit screen data*/
        PFWSUB = PFWSUB + 1;
      end
    end
    if (PFWREC.PFWERRF != "Y") /* if edit ok, then update record*/
      PF0D450();
      converseLib.validationFailed(024);
      PFWREC.PFW1STF = "N";
      set PF0DW01 empty;
    end
    return;
  end
  ;
  if (converseVar.eventKey is pf7) /* user has requested to scroll*/
    PFWREC.PFWSUB = 1;
    while (PFWSUB < 13)
      if (PF0DM001.YISCD[PFWSUB] == 0)
        PFWSUB = 13;
      else
        PF0D420(); /* backward. edit screen data,*/
        PFWSUB = PFWSUB + 1;
      end
    end
    if (PFWREC.PFWERRF != "Y") /* update the w/s record, then*/
      PF0D180(); /* scroll backward.*/
    end
    return;
  end
  ;
  if (converseVar.eventKey is pf8) /* user has requested to scroll*/
    PFWSUB = 1;
    while (PFWSUB < 13)
      if (PF0DM001.YISCD[PFWSUB] == 0)
        PFWSUB = 13;
      else
        PF0D420(); /* first, edit screen data*/
        PFWSUB = PFWSUB + 1;
      end
    end
    if (PFWREC.PFWERRF != "Y") /* update the w/s record, then*/
      PFWSUB3 = 1; /* scroll forward.*/
      PF0D160();
      PFWSUB2 = 1;
      while (PFWSUB2 < 13)
        PF0D190();
      end
    end
    return;
  end
  ;
  if (converseVar.eventKey is pf12) /* user has requested to edit*/
    PFWSUB = 1;
    while (PFWSUB < 13)
      if (PF0DM001.YISCD[PFWSUB] == 0)
        PFWSUB = 13;
      else
        PF0D420(); /* screen data*/
        PFWSUB = PFWSUB + 1;
      end
    end
    if (PFWERRF == "N")
      converseLib.validationFailed(051);
    end
  end
  ;
end // end PF0D500

// delete routine
Function PF0D600()
   /* ***************************************************/
   /* *  delete routine functions :                    **/
   /* *  1) check predefined summaries. same reason as **/
   /* *     above.                                     **/
   /* *  2) check existing summaries. a i/s group that **/
   /* *     is part of an existing summary cannot be   **/
   /* *     deleted.                                   **/
   /* *  3) first time thru, blank the action code     **/
   /* *     field and re-converse the screen with a    **/
   /* *     message warning the user that the i/s      **/
   /* *     group will be deleted when the user        **/
   /* *     re-inputs the 'd' in the action code field.**/
   /* *  4) if all of the previous conditions are met, **/
   /* *     browse thru the w/s storage area and       **/
   /* *     delete all slots that were on the data     **/
   /* *     base (pf0ddb2f = 'y').                     **/
   /* ***************************************************/
  ;
  if (PFWREC.PFWERRF == "Y") /* if there are any prior errors, exit*/
    return;
  end
  ;
   /* IF PF0DW01.PFBREF IN PF0GT.PFBREF      ; see if ref # is par*/
    /* MOVE 137 TO EZEMNO            ; predefined summary*/
    /* MOVE 'Y' TO PFWERRF;*/
    /* EZERTN;*/
   /* END ;*/
  ;
  set PFEREC empty;
  set SQLCA empty;
  ;
  PFEREC.PFCREF = -1; /* set wild card search keys for*/
  PFEREC.PFDREF = -1; /* delete verification*/
  PFEREC.PFBREF = PF0DW01.PFBREF; /* set specific search key*/
  ;
  call "IO2770" ("SE", SQLCA, PFEREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE == +100) /* if ref # not found*/
     /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == +0 /* if a row or multiple rows are found,*/
     || SQLCA.VAGen_SQLCODE == -811) /* this ref # can't be deleted because*/
                                   /* it*/
      PFWERRF = "Y"; /* is part of an existing summary*/
      converseLib.validationFailed(123);
      return;
    else
      TA1REC.TA1DBASE = "DPROFT"; /* abend the program*/
      TA1REC.TA1TBLVU = "VSUMAT01";
      PF0DW02.PF0DWREF = PFEREC.PFBREF;
      TA1REC.TA1TBLKE = PF0DW02.PF0DWREF;
      TA1REC.TA1LOCAT[1] = "PF0D600";
      TA1REC.TA1LOCAT[2] = "IO2770";
      XPPF010();
    end
  end
  ;
  if (PFWREC.PFW1STF == "N") /* if first time thru,*/
    PF0DM001.PF0DMACT = " "; /* clear action code field*/
    converseLib.validationFailed(122); /* send message about pending delete*/
    PFWERRF = "Y"; /* set error flag*/
    PFWREC.PFW1STF = "Y";
    return;
  end
  ;
  PFWSUB1 = 1;
  ;
  while (PFWSUB1 < 501) /* browse thru w/s storage area*/
    if (PF0DW01.PF0DDB2F[PFWSUB1] == "Y") /* delete previous db2 rows*/
      PFBREC.PFBREF = PF0DW01.PFBREF;
      PFBREC.YISCD[1] = PF0DW01.YISCD[PFWSUB1];
      call "IO2710" ("D ", SQLCA, PFBREC) {isNoRefresh = yes, isExternal = yes};
      if (SQLCA.VAGen_SQLCODE != +0)
        TA1REC.TA1DBASE = "DPROFT";
        TA1REC.TA1TBLVU = "VISGRP01";
        PF0DW02.PF0DWISG = PFBREC.PFBREF;
        TA1REC.TA1TBLKE = PF0DW02.PF0DWISG;
        TA1REC.TA1LOCAT[3] = "PF0D600";
        TA1REC.TA1LOCAT[4] = "IO2710";
        XPPF010();
      end
    end
    PFWSUB1 = PFWSUB1 + 1;
  end
  ;
  converseLib.validationFailed(026); /* send user message that delete was successful*/
  PFWREC.PFW1STF = "N";
  set PF0DW01 empty;
  PF0DM001.PF0DMREF = "   ";
  PF0DM001.PF0DMACT = " ";
end // end PF0D600

// check pf keys
Function PF0DS01()
   /* ************************************************************/
   /* *   process the pf keys that might have been entered      **/
   /* ************************************************************/
  ;
  PFWREC.PFWCPROC = "PF0DS01"; /* set current process name*/
  ;
  if (PF1REC.PF1XFERF == "Y") /* if this request was via the*/
    if (converseVar.eventKey is enter) /* "pf keys" bridge, the only pf*/
      return; /* allowed are 'enter' or 'pf4'*/
    end
    if (converseVar.eventKey is pf4)
      XSPF4();
      PF0DM001.VAGen_EZEMSG = COMMAREA.CAMSG;
      PFWREC.PFWERRF = "Y";
      return;
    end
    if (converseVar.eventKey is pf7)
      return;
    end
    if (converseVar.eventKey is pf8)
      return;
    end
    if (converseVar.eventKey is pf16)
      COMMAREA.CATOAP = PF1REC.PF1ORIG;
      PFWREC.PFWEOAF = "Y";
      PFWREC.PFWEOSF = "Y";
      return;
    end
    converseLib.validationFailed(001);
    PFWREC.PFWERRF = "Y";
  end
  ;
  if (converseVar.eventKey is enter) /* normal 'enter'*/
    if (PF0DM001.CATOAP != " ") /* if fastpath entered- screen #1*/
      if (PF0DM001.PF0DMREF != 0) /* if an attribute is entered*/
        converseLib.validationFailed(002); /* it's an error*/
        PFWREC.PFWERRF = "Y";
      else
        COMMAREA.CATOAP = PF0DM001.CATOAP;
        COMMAREA.CAITEM = PF0DM001.CAITEM;
        XSEXIT();
        PF0DM001.VAGen_EZEMSG = COMMAREA.CAMSG;
        PFWREC.PFWERRF = "Y";
      end
    end
    return;
  end
  ;
  if (converseVar.eventKey is pf1) /* 'help'*/
    XSPF1();
    PF0DM001.VAGen_EZEMSG = COMMAREA.CAMSG;
    PFWREC.PFWERRF = "Y";
    return;
  end
  ;
  if (converseVar.eventKey is pf3)
    PFWREC.PFWEOAF = "Y";
    if (PF1REC.PF1ORIG == "PF0C")
      COMMAREA.CATOAP = "PF0C";
    else
      if (PF1REC.PF1ORIG == "PF0P")
        COMMAREA.CATOAP = "PF0P";
      else
        COMMAREA.CATOAP = "PF0A"; /* go to profitability menu*/
      end
    end
    return;
  end
  ;
  if (converseVar.eventKey is pf4) /* ;go to master menu*/
    XSPF4();
    PF0DM001.VAGen_EZEMSG = COMMAREA.CAMSG;
    PFWREC.PFWERRF = "Y";
    return;
  end
  ;
  if (converseVar.eventKey is pf19 /* view next logic not allowed with deletes*/
   && PF0DM001.PF0DMACT == "D")   
    converseLib.validationFailed(125);
    PFWERRF = "Y";
    return;
  end
  ;
  if (converseVar.eventKey is pf19 /* view next logic not allowed with adds*/
   && PF0DM001.PF0DMACT == "A")   
    converseLib.validationFailed(126);
    PFWERRF = "Y";
    return;
  end
  ;
  if (converseVar.eventKey is pf19 /* view next logic not allowed with adds*/
   && PF0DM001.PF0DMACT == "K")   
    converseLib.validationFailed(136);
    PFWERRF = "Y";
    return;
  end
  ;
  if (converseVar.eventKey is pf7
   || converseVar.eventKey is pf8
   || converseVar.eventKey is pf12
   || converseVar.eventKey is pf19)
    return;
  end
  ;
  if (converseVar.eventKey is pa1 /* cancel request and*/
   || converseVar.eventKey is pa2) /* send a clear screen*/
    converseLib.clearScreen();
    
    PFWREC.PFWERRF = "Y";
    converseLib.validationFailed(189);
    return;
  end
  ;
  converseLib.validationFailed(1); /* invalid pf key entered*/
  PFWREC.PFWERRF = "Y";
end // end PF0DS01

//*** RECORD=PF0DW01 ****
// Application PF0D Working Storage Record 1.
// 
// Maintenance:
// 
//   Date     Init     Comments
// --------  ------  ------------------------------------------
//  5-30-91  DCassi  Increased PF0DWLVL occurs from 200 to 500.
// 
// ***********************
Record PF0DW01 type basicRecord
  10 PFBREF PFBREF ; 
  10 PF0DWLVL PF0DWLVL [500] ; 
    15 YTYABRV YTYABRV ; 
    15 YISCD YISCD ; 
    15 YISSDESC YISSDESC ; 
    15 PFBISGRP PFBISGRP ; 
    15 PFBISDSC PFBISDSC ; 
    15 PF0DDB2F PF0DDB2F ; 
    15 ZZZSDT ZZZSDT ; 
    15 ZZZCHGCT ZZZCHGCT ; 
end // end PF0DW01

Record PF0DW02 type basicRecord
  10 PF0DWGRP PF0DWGRP ; 
    15 PF0DWGR1 PF0DWGR1 ; 
    15 PF0DWGR2 PF0DWGR2 ; 
  10 PF0DWISG PF0DWISG ; 
  10 PF0DWACT PF0DWACT ; 
  10 PF0DWISN PF0DWISN ; 
  10 PF0DWGR PF0DWGR ; 
  10 PF0DWABR PF0DWABR ; 
  10 PF0DWREF PF0DWREF ; 
  10 PF0DWNTR PF0DWNTR ; 
  10 PF0DWCLF PF0DWCLF ; 
  10 PF0DWMOD PF0DWMOD ; 
end // end PF0DW02

// db2 flag
DataItem PF0DDB2F char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// hold abbreviation
DataItem PF0DWABR char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// hold action code
DataItem PF0DWACT char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// clone flag
DataItem PF0DWCLF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// hold i/s group #
DataItem PF0DWGR smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

//       group area
DataItem PF0DWGR1 num(3)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

//       group computation num
DataItem PF0DWGR2 num(1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// group hold area
DataItem PF0DWGRP num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// hold i/s ref # for abends
DataItem PF0DWISG num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

//      i/s class number
DataItem PF0DWISN num(3)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// item level desc.
DataItem PF0DWLVL char(67)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// modified flag
DataItem PF0DWMOD char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// new transaction flag
DataItem PF0DWNTR char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// abend ref key
DataItem PF0DWREF num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

