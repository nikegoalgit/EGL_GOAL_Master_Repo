package pf0l;
import corpcom2.YSMREC;
import corpcom3.XPPF002;
import corpcom3.XPPF010;
import corpcom3.XPPF020;
import corpcom3.XPPF430;
import corpcom4.XSENTRY;
import corpcom4.XSEXIT;
import corpcom4.XSPF4;
import corpcom4.XSSEGTR;
import corpcom5.COMMAREA;
import corpcom5.ERRSQLCA;
import corpcom6.SQLCA;
import pf.common.PF1REC;
import pf.common.PF2REC;
import pf.common.PFAREC;
import pf.common.PFBREC;
import pf.common.PFCREC;
import pf.common.PFDREC;
import pf.common.PFEREC;
import pf.common.PFGREC;
import pf.common.PFWREC;
import sm.common.SM1REC;
import sy.common.SY1REC;
import sy.common.SY2CLRID;
import sy.common.SYCREC;
import ta.common.TA1REC;
import xx.common.*;
import xx.common.XGPCD;
import xx.common.XLCCD;
import xx.common.XQACD;
import xx.common.YISCD;
import xx01.*;
import xx02.*;
import xx02.XDMCD;
import xx03.*;
import xx04.*;
import xx05.*;
import xx06.*;
import xx07.*;
import xx08.*;
import xx08.SY1STNBR;
import xx08.YISTBL;
import xx09.*;
import xx09.YPDTBL;
import xx10.*;
import xx10.YTPTBL;
import xx10.YTYTBL;
//*** PROGRAM=PF0L ****
// this application will display summaries that were generated
// to use a type 2 format. users are able to view the summaries
// in a summary, detail or explode format. users can also view
// 132 column-sized summaries by scrolling right or left on the
// screen that is displayed. finally, summaries can have up to
// 8 levels of information stored in a hierarchical pattern.
// this application will access the selected summary at a
// starting viewing position as determined in pf0b but the user
// has the capability to move up or down the levels easily by
// using predefined pf keys.
// 
// maintenance history:
//   date     by             description of change
// --------  -----  -------------------------------------------
//  1-03-89   mh    Original transfer to production.
//  2-28-89   mh    Change handling of overflow
//                                    percentages.
//  3-13-89   mh    Enhance display of partial summary
//                                    warning.  PF0L210
//  4-19-89   DLC   Change screen column descriptions: DEF RTS
//                  to DEF RTN, and NET SALES to NET SHIP.
//  6-21-89   DLC   Change Summary Order Type to Base Order
//                  Type (XOBTBL).
//  7-13-89   DLC   Re-Gen for changes to YFATBL, YMATBL,
//                  YMBTBL, and YMCTBL.
// 11-30-89   TBG   Modify to load and pass data viewed back to
//                  Summary File View Selection (PF0B).
//  4-05-90   CVO   Transfer to PF0A if the expected summary
//                  name is not passed.
//  6-13-91   CVO   Increased group level entries on pf0lw02
//                  from 200 to 500.
//  9-25-91   DLC     Added abend if pf0lw02 > 500 when loaded,
//                  & increased # of yis's searched for is grp
//                  literals from 200 to PFWLIMIT, pf0l200.
//                  Was not displaying lits from last is grps.
//                    Increased rows searched in working stor
//                  for 'sum' level displ from 200 to PFWLIMIT,
//                  in pf0l310.  Was not displaying anything
//                  below gross margin for sums w/ > 200 yis's.
//  9-02-92   WES     Added initialization of attribute descr.
//                  within PF0K210 to 'NO DESC'.
//  4-15-94   mjk   changes for new attributes.
//  3-1-96   MBUHIT Regen for GCOA chantes to YICTBL.
// 11-19-97  mleabo Re-gen for table changes ysftbl, ysetbl.
// *********************
Program PF0L type textUIProgram //VAGen Info - main text program
  {
  includeReferencedFunctions = yes, allowUnqualifiedItemReferences = yes, 
  throwNrfEofExceptions = yes, handleHardIOErrors = no, V60ExceptionCompatibility = yes, 
  I4GLItemsNullable = no, textLiteralDefaultIsString = no, localSQLScope = yes, 
  msgTablePrefix = "PF00", inputRecord = COMMAREA, segmented = yes
  }

  // Data Declarations
  COMMAREA COMMAREA ; // record
  ERRSQLCA ERRSQLCA; // record
  PF0LW01 PF0LW01; // record
  PF0LW02 PF0LW02; // record
  PF1REC PF1REC; // record
  PF2REC PF2REC; // record
  PFAREC PFAREC; // record
  PFBREC PFBREC; // record
  PFCREC PFCREC; // record
  PFDREC PFDREC; // record
  PFEREC PFEREC; // record
  PFGREC PFGREC; // record
  PFWREC PFWREC; // record
  SM1REC SM1REC; // record
  SQLCA SQLCA; // record
  SY1REC SY1REC; // record
  SYCREC SYCREC; // record
  TA1REC TA1REC; // record
  YSMREC YSMREC; // record

  // VAGen Info - items needed for migration
  VAGen_EZESYS char(8);
  VAGen_EZEREPLY num(1);
  VAGen_EZE_WAIT_TIME bin(9,2);
  VAGen_EZE_ITEMLEN int;

  // Use Declarations
  use XATTBL {deleteAfterUse = yes}; // table
  use XAUTBL {deleteAfterUse = yes}; // table
  use XBTTBL {deleteAfterUse = yes}; // table
  use XCNTBL {deleteAfterUse = yes}; // table
  use XDRTBL {deleteAfterUse = yes}; // table
  use XDVTBL {deleteAfterUse = yes}; // table
  use XFCTBL {deleteAfterUse = yes}; // table
  use XFMTBL {deleteAfterUse = yes}; // table
  use XGATBL {deleteAfterUse = yes}; // table
  use XGPTBL {deleteAfterUse = yes}; // table
  use XGSTBL {deleteAfterUse = yes}; // table
  use XLCTBL {deleteAfterUse = yes}; // table
  use XMCTBL {deleteAfterUse = yes}; // table
  use XOBTBL {deleteAfterUse = yes}; // table
  use XPCTBL {deleteAfterUse = yes}; // table
  use XPGTBL {deleteAfterUse = yes}; // table
  use XPLTBL {deleteAfterUse = yes}; // table
  use XPRTBL {deleteAfterUse = yes}; // table
  use XQATBL {deleteAfterUse = yes}; // table
  use XRDTBL {deleteAfterUse = yes}; // table
  use XRYTBL {deleteAfterUse = yes}; // table
  use XSPTBL {deleteAfterUse = yes}; // table
  use XSUTBL {deleteAfterUse = yes}; // table
  use XWHTBL {deleteAfterUse = yes}; // table
  use YFATBL {deleteAfterUse = yes}; // table
  use YFETBL {deleteAfterUse = yes}; // table
  use YFFTBL {deleteAfterUse = yes}; // table
  use YFGTBL {deleteAfterUse = yes}; // table
  use YGRTBL {deleteAfterUse = yes}; // table
  use YICTBL {deleteAfterUse = yes}; // table
  use YISTBL {deleteAfterUse = yes}; // table
  use YMATBL {deleteAfterUse = yes}; // table
  use YMBTBL {deleteAfterUse = yes}; // table
  use YMCTBL {deleteAfterUse = yes}; // table
  use YPDTBL {deleteAfterUse = yes}; // table
  use YSCTBL {deleteAfterUse = yes}; // table
  use YSETBL {deleteAfterUse = yes}; // table
  use YSFTBL {deleteAfterUse = yes}; // table
  use YSYTBL {deleteAfterUse = yes}; // table
  use YTPTBL {deleteAfterUse = yes}; // table
  use YTYTBL {deleteAfterUse = yes}; // table
  use PF0LM.PF0LM001,  // forms
      PF0LM.PF0LM002
   {
    pfKeyEquate = no
  };

  function main()
    // VAGen Info - initialization needed for migration
    VAGen_EZESYS = VGLib.getVAGSysType();
    PF0L000: PF0L000();
  end // end main
end // end PF0L

// application mainline
Function PF0L000()
   /* ******************************************************/
   /* *    pf0k mainline logic                            **/
   /* ******************************************************/
  ;
  PF0L001(); /* application initialization routine*/
  ;
  while (PFWREC.PFWEOAF == "N") /* while application active,*/
    PF0L100(); /* converse display screens*/
  end
  ;
  XPPF002();
  COMMAREA.CAFROMAP = "PF0L";
  COMMAREA.CATOAP = "PF0A";
  XSEXIT();
end // end PF0L000

Function PF0L001()
   /* ****************************************************/
   /* *   this process will use information passed by   **/
   /* *   pf0b to access profitablity db2 tables for    **/
   /* *   initializing a format 2 summary view. the     **/
   /* *   process will access the summary attribute     **/
   /* *   table(vsumat01) and the i/s group table       **/
   /* *   (visgrp01). the information provided by these **/
   /* *   tables will be used to setup the display      **/
   /* *   screens to used throughout the rest of the    **/
   /* *   application.                                  **/
   /* ****************************************************/
  ;
  XSENTRY(); /* check user security*/
  ;
  XSSEGTR();
  ;
  set PF0LM001 initial; /* initialize maps*/
  set PF0LM002 initial;
  ;
  set PF0LW01 empty; /* initialize w/s records*/
  ;
  PFWREC.PFWERRF = "N"; /* initialize flags*/
  PFWREC.PFWEOAF = "N";
  ;
  PF0LM001.XXXCURDT = VGVar.currentShortGregorianDate; /* move current date to maps*/
  PF0LM002.XXXCURDT = VGVar.currentShortGregorianDate;
  ;
  PF1REC.PF1PASS = COMMAREA.CAUSERA; /* move passed info. to w/s*/
                                          /* record*/
  COMMAREA.CAUSERA = " "; /* clear the commarea*/
  ;
  set PFEREC empty;
  set SQLCA empty;
  ;
  if (PF1REC.PFESUMNM == " ") /* <=== if no summary name passed*/
    COMMAREA.CAFROMAP = "PF0L"; /* to Profit. Menu*/
    COMMAREA.CATOAP = "PF0A";
    XSEXIT(); /* <=== Transfer to PF0A.*/
    PF0LM001.VAGen_EZEMSG = COMMAREA.CAMSG;
    PFWREC.PFWERRF = "Y";
  end
  ;
  PFEREC.PFESUMNM = PF1REC.PFESUMNM; /* move summary name to db2 key*/
  ;
  call "IO2770" ("S ", SQLCA, PFEREC) {isNoRefresh = yes, isExternal = yes}; /* access vsumat01 table*/
  ;
  if (SQLCA.VAGen_SQLCODE == +0) /* if summary found continue with the process*/
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
    TA1REC.TA1TBLVU = "VSUMAT01";
    TA1REC.TA1TBLKE = PF1REC.PFESUMNM;
    TA1REC.TA1LOCAT[3] = "PF0L001";
    TA1REC.TA1LOCAT[4] = "IO2770";
    XPPF010();
  end
  ;
  PF0LM001.PF0LMNAM = PFEREC.PFESUMNM; /* move summary name to screen*/
  PF0LM002.PF0LMNAM = PFEREC.PFESUMNM;
  PF0LM001.PF0LMDTC = PFEREC.PFECRTDT; /* move date created to maps*/
  PF0LM002.PF0LMDTC = PFEREC.PFECRTDT;
  PF0LM001.PF0LMBMM = PFEREC.PFABSPRM; /* move base per. mo. to maps*/
  PF0LM002.PF0LMBMM = PFEREC.PFABSPRM;
  PF0LM001.PF0LMCYY = PFEREC.PFABSPRY; /* move base per. yr. to maps*/
  PF0LM002.PF0LMCYY = PFEREC.PFABSPRY;
  PF0LM001.PF0LMFMT = PFEREC.PFCREF; /* move format # to maps*/
  PF0LM002.PF0LMFMT = PFEREC.PFCREF;
  PF0LM001.PF0LMISG = PFEREC.PFBREF; /* move i/s ref. # to maps*/
  PF0LM002.PF0LMISG = PFEREC.PFBREF;
  PF0LM001.PF0LMATT = PFEREC.PFDREF; /* move rpt. attr. # to maps*/
  PF0LM002.PF0LMATT = PFEREC.PFDREF;
  ;
  set PFAREC empty;
  set SQLCA empty;
  ;
  call "IO2670" ("S ", SQLCA, PFAREC) {isNoRefresh = yes, isExternal = yes}; /* access vpfctl01 table*/
  ;
  if (SQLCA.VAGen_SQLCODE == +0) /* if control rec. found continue with*/
                                   /* the process*/
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
    TA1REC.TA1TBLVU = "VPFCTL01";
    TA1REC.TA1TBLKE = PF1REC.PFESUMNM;
    TA1REC.TA1LOCAT[3] = "PF0L001";
    TA1REC.TA1LOCAT[4] = "IO2670";
    XPPF010();
  end
  ;
  if (PFAREC.PFASTBLF == "Y") /* if the summary file is locked due to an*/
    PFWREC.PFWERRF = "Y"; /* db2 batch load, send user a message*/
    converseLib.validationFailed(223);
  end
  ;
  PF0LW01.PF0LWKY1 = "18:"; /* setup pf key literals for*/
                                   /* 'sum,det,exp'*/
  PF0LW01.PF0LWKY2 = "19:";
  ;
  if (PF1REC.PF1DISP == "SUM")
                                   /* pf0b will pass the starting view type*/
     /* (sum,det,exp). move appropriate title heading to maps.*/
    PF0LM001.PF0LMLIT = "SUMMARY FILE SUMMARY VIEW";
    PF0LM002.PF0LMLIT = "SUMMARY FILE SUMMARY VIEW";
    PF0LW01.PF0LWDP1 = "DET"; /* move literals to pf keys*/
    PF0LW01.PF0LWDP2 = "EXP";
  else
    if (PF1REC.PF1DISP == "DET")
      PF0LM001.PF0LMLIT = "SUMMARY FILE DETAIL VIEW";
      PF0LM002.PF0LMLIT = "SUMMARY FILE DETAIL VIEW";
      PF0LW01.PF0LWDP1 = "SUM"; /* move literals to pf keys*/
      PF0LW01.PF0LWDP2 = "EXP";
    else
      if (PF1REC.PF1DISP == "EXP")
        PF0LM001.PF0LMLIT = "SUMMARY FILE EXPLODED VIEW";
        PF0LM002.PF0LMLIT = "SUMMARY FILE EXPLODED VIEW";
        PF0LW01.PF0LWDP1 = "SUM"; /* move literals to pf keys*/
        PF0LW01.PF0LWDP2 = "DET";
      end
    end
  end
  ;
  set PFDREC empty;
  set SQLCA empty;
  ;
  PFDREC.PFDREF = PFEREC.PFDREF; /* move rept. attr. ref # to db2 key*/
  ;
  call "IO2740" ("S ", SQLCA, PFDREC) {isNoRefresh = yes, isExternal = yes}; /* access vrptat01 table*/
  ;
  if (SQLCA.VAGen_SQLCODE == +0) /* if i/s group # found continue with the process*/
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
    TA1REC.TA1TBLVU = "VRPTAT01";
    PF0LW01.PF0LWABK = PFEREC.PFBREF;
    TA1REC.TA1TBLKE = PF0LW01.PF0LWAB2;
    TA1REC.TA1LOCAT[3] = "PF0L001";
    TA1REC.TA1LOCAT[4] = "IO2740";
    XPPF010();
  end
  ;
  set PFCREC empty;
  set SQLCA empty;
  ;
  PFCREC.PFCREF = PFEREC.PFCREF; /* move summary fmt # to db2 key*/
  ;
  call "IO2730" ("S ", SQLCA, PFCREC) {isNoRefresh = yes, isExternal = yes}; /* access vrptfm01 table*/
  ;
  if (SQLCA.VAGen_SQLCODE == +0) /* if format # found continue with the process*/
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
    TA1REC.TA1TBLVU = "VRPTFM01";
    PF0LW01.PF0LWABK = PFEREC.PFCREF;
    TA1REC.TA1TBLKE = PF0LW01.PF0LWAB2;
    TA1REC.TA1LOCAT[3] = "PF0L001";
    TA1REC.TA1LOCAT[4] = "IO2730";
    XPPF010();
  end
  ;
  if (PFCREC.YPDCD[1] in YPDTBL.YPDCD) /* move time period #1 to hold area*/
    PF0LW01.PF0LWDT1 = YPDTBL.YPDSDESC[sysVar.arrayIndex];
  end
  ;
  if (PFCREC.YTPCD[1] in YTPTBL.YTPCD)
                                   /* move data type #1 to hold area*/
    PF0LW01.PF0LWTP1 = YTPTBL.YTPSDESC[sysVar.arrayIndex];
  end
  ;
  PF0LW01.PF0LWTP2 = PFCREC.YTPCD[1];
  PF0LW01.PF0LWTP3 = PFCREC.YTPCD[2];
  PF0LW01.PF0LWTP4 = PFCREC.YTPCD[3];
  PF0LW01.PF0LWDT2 = PFCREC.YPDCD[1];
  PF0LW01.PF0LWDT3 = PFCREC.YPDCD[2];
  PF0LW01.PF0LWDT4 = PFCREC.YPDCD[3];
  PF0LW01.PF0LWF1 = " ";
  PF0LW01.PF0LWF2 = " ";
  PF0LW01.PF0LWF3 = " ";
  ;
  PF0LM001.PF0LMDT1 = PF0LW01.PF0LWLT1;
                                   /* move dt/tp literals to maps*/
  PF0LM002.PF0LMDT1 = PF0LW01.PF0LWCL1;
  PF0LM002.PF0LMDT2 = PF0LW01.PF0LWCL2;
  PF0LM002.PF0LMDT3 = PF0LW01.PF0LWCL3;
  ;
  if (PFCREC.PFCPCTC[1] == 1
   || PFCREC.PFCPCTC[1] == 2
   || PFCREC.PFCPCTC[1] == 3
   || PFCREC.PFCPCTC[1] == 4
   || PFCREC.PFCPCTC[1] == 5
   || PFCREC.PFCPCTC[1] == 6)
    PF0LM001.PF0LMDT2 = PF0LW01.PF0LWCL1;
    PF0LM002.PF0LMDT4 = PF0LW01.PF0LWCL1;
  else
    if (PFCREC.PFCPCTC[1] == 7
     || PFCREC.PFCPCTC[1] == 8)
      PF0LM001.PF0LMDT2 = PF0LW01.PF0LWCL2;
      PF0LM002.PF0LMDT4 = PF0LW01.PF0LWCL2;
    else
      if (PFCREC.PFCPCTC[1] == 9
       || PFCREC.PFCPCTC[1] == 10)
        PF0LM001.PF0LMDT2 = PF0LW01.PF0LWCL3;
        PF0LM002.PF0LMDT4 = PF0LW01.PF0LWCL3;
      end
    end
  end
  ;
  if (PFCREC.PFCPCTC[2] == 1
   || PFCREC.PFCPCTC[2] == 2
   || PFCREC.PFCPCTC[2] == 3
   || PFCREC.PFCPCTC[2] == 4
   || PFCREC.PFCPCTC[2] == 5
   || PFCREC.PFCPCTC[2] == 6)
    PF0LM001.PF0LMDT3 = PF0LW01.PF0LWCL1;
    PF0LM002.PF0LMDT6 = PF0LW01.PF0LWCL1;
  else
    if (PFCREC.PFCPCTC[2] == 7
     || PFCREC.PFCPCTC[2] == 8)
      PF0LM001.PF0LMDT3 = PF0LW01.PF0LWCL2;
      PF0LM002.PF0LMDT6 = PF0LW01.PF0LWCL2;
    else
      if (PFCREC.PFCPCTC[2] == 9
       || PFCREC.PFCPCTC[2] == 10)
        PF0LM001.PF0LMDT3 = PF0LW01.PF0LWCL3;
        PF0LM002.PF0LMDT6 = PF0LW01.PF0LWCL3;
      end
    end
  end
  ;
  if (PFCREC.PFCPCTC[3] == 1
   || PFCREC.PFCPCTC[3] == 2
   || PFCREC.PFCPCTC[3] == 3
   || PFCREC.PFCPCTC[3] == 4
   || PFCREC.PFCPCTC[3] == 5
   || PFCREC.PFCPCTC[3] == 6)
    PF0LM002.PF0LMDT5 = PF0LW01.PF0LWCL1;
  else
    if (PFCREC.PFCPCTC[3] == 7
     || PFCREC.PFCPCTC[3] == 8)
      PF0LM002.PF0LMDT5 = PF0LW01.PF0LWCL2;
    else
      if (PFCREC.PFCPCTC[3] == 9
       || PFCREC.PFCPCTC[3] == 10)
        PF0LM002.PF0LMDT5 = PF0LW01.PF0LWCL3;
      end
    end
  end
  ;
  if (PFCREC.PFCPCTC[4] == 1
   || PFCREC.PFCPCTC[4] == 2
   || PFCREC.PFCPCTC[4] == 3
   || PFCREC.PFCPCTC[4] == 4
   || PFCREC.PFCPCTC[4] == 5
   || PFCREC.PFCPCTC[4] == 6)
    PF0LM002.PF0LMDT7 = PF0LW01.PF0LWCL1;
  else
    if (PFCREC.PFCPCTC[4] == 7
     || PFCREC.PFCPCTC[4] == 8)
      PF0LM002.PF0LMDT7 = PF0LW01.PF0LWCL2;
    else
      if (PFCREC.PFCPCTC[4] == 9
       || PFCREC.PFCPCTC[4] == 10)
        PF0LM002.PF0LMDT7 = PF0LW01.PF0LWCL3;
      end
    end
  end
  ;
  PF0LW01.PF0LWSTL = PF1REC.PF1STLVL; /* move passed starting inquiry*/
  PF0LW01.PF0LWSTS = PF1REC.PF1STSEQ; /* to hold db2 keys*/
  ;
  PFWREC.PFWSUB1 = 1; /* initialize subscript*/
  ;
  PF0L200(); /* routine to access summary file, load to w/s table*/
  ;
  PF0LW01.PF0LWDSP = PF1REC.PF1DISP; /* save display type*/
  ;
  PFWREC.PFWSUB1 = 1; /* initialize subscripts*/
  PFWREC.PFWSUB2 = 1;
  ;
  PF0L300(); /* determine display type*/
  ;
  PFWREC.PFWERRF = "N";
  ;
  PF0LW01.PF0LWLEF = "Y"; /* set map switch to display left side*/
  PF0LW01.PF0LWRIG = "N";
end // end PF0L001

// main converse logic loop
Function PF0L100()
   /* ****************************************************/
   /* *  this process will determine whether the left   **/
   /* *  or right display map is to be conversed and    **/
   /* *  will perform the appropriate converse routine. **/
   /* *  after conversing, the routine will check pf    **/
   /* *  keys for the next function to process.         **/
   /* ****************************************************/
  ;
  if (PF0LW01.PF0LWLEF == "Y") /* converse left side map*/
    PF0LM001.PF0LMPFK = PF0LW01.PF0LWPFK; /* move pf18,pf19 keys to map*/
    PF0L120();
    PF0LW01.PF0LWPFK = PF0LM001.PF0LMPFK; /* store pf18,pf19 values*/
  end
  ;
  if (PF0LW01.PF0LWRIG == "Y") /* converse right side map*/
    PF0LM002.PF0LMPFK = PF0LW01.PF0LWPFK; /* move pf18,pf19 keys to map*/
    PF0L130();
    PF0LW01.PF0LWPFK = PF0LM002.PF0LMPFK; /* store pf18,pf19 values*/
  end
  ;
  PF0L110(); /* check pf keys*/
end // end PF0L100

// check pf keys
Function PF0L110()
   /* *****************************************************/
   /* *  this process will check the pf keys entered by  **/
   /* *  the user and will take the appropriate course   **/
   /* *  of action.                                      **/
   /* *****************************************************/
  ;
  if (converseVar.eventKey is pf3) /* return to 'pf0b' application*/
    PF1REC.PFDCDVAL[1] = PF0LM001.PF0LMAVD[1];
    PF1REC.PFDCDVAL[2] = PF0LM001.PF0LMAVD[2];
    PF1REC.PFDCDVAL[3] = PF0LM001.PF0LMAVD[3];
    PF1REC.PFDCDVAL[4] = PF0LM001.PF0LMAVD[4];
    PF1REC.PFDCDVAL[5] = PF0LM001.PF0LMAVD[5];
    PF1REC.PFDCDVAL[6] = PF0LM001.PF0LMAVD[6];
    PF1REC.PFDCDVAL[7] = PF0LM001.PF0LMAVD[7];
    COMMAREA.CAUSERA = PF1REC.PF1PASS;
    COMMAREA.CATOAP = "PF0B";
    XSEXIT();
    PFWREC.PFWMSG = COMMAREA.CAMSG; /* handle a bad pass*/
    PFWREC.PFWERRF = "Y";
    return;
  end
  ;
  set PFAREC empty;
  set SQLCA empty;
  ;
  call "IO2670" ("S ", SQLCA, PFAREC) {isNoRefresh = yes, isExternal = yes}; /* access vpfctl01 table*/
  ;
  if (SQLCA.VAGen_SQLCODE == +0) /* if control rec. found continue with*/
                                   /* the process*/
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
    TA1REC.TA1TBLVU = "VPFCTL01";
    TA1REC.TA1TBLKE = PF1REC.PFESUMNM;
    TA1REC.TA1LOCAT[3] = "PF0L110";
    TA1REC.TA1LOCAT[4] = "IO2670";
    XPPF010();
  end
  ;
  if (PFAREC.PFASTBLF == "Y") /* if the summary file is locked due to an*/
    PFWREC.PFWERRF = "Y"; /* db2 batch load, send user a message*/
    converseLib.validationFailed(223);
    return;
  end
  ;
  if (converseVar.eventKey is pf5) /* move up a level*/
    PF0LW01.PF0LWSTL = PF0LW01.PF0LWSTL - 1;
    if (PF0LWSTL < 0)
      PFWREC.PFWERRF = "Y";
      converseLib.validationFailed(218);
      return;
    end
    PF0L260(); /* access vsumry01 table*/
    if (SQLCA.VAGen_SQLCODE == +100)
                                   /* if there are no more levels to go up,*/
      PFWREC.PFWERRF = "Y"; /* send user a message*/
      converseLib.validationFailed(218);
      PF0LW01.PF0LWSTL = PF0LW01.PF0LWSTL + 1; /* restore viewing level*/
      return;
    end
    PF0L200();
    PFWSUB1 = 1;
    PF0L300(); /* move w/s items to display screen*/
    return;
  end
  ;
  if (converseVar.eventKey is pf6) /* move down a level*/
    PF0LW01.PF0LWSTL = PF0LW01.PF0LWSTL + 1;
    if (PF0LWSTL > 8)
      PFWREC.PFWERRF = "Y";
      converseLib.validationFailed(219);
      return;
    end
    PF0L200(); /* access vsumry01 table*/
    if (SQLCA.VAGen_SQLCODE == +100) /* if the row was not found,*/
      PFWREC.PFWERRF = "Y"; /* send the user a message*/
      converseLib.validationFailed(251);
      PF0LW01.PF0LWSTL = PF0LW01.PF0LWSTL - 1; /* restore viewing level*/
      return;
    end
    PFWSUB1 = 1;
    PF0L300(); /* move w/s items to display screen*/
    return;
  end
  ;
  if (converseVar.eventKey is pf7 /* user can't scroll when a 'sum' is displayed*/
   && PF0LW01.PF0LWDSP == "SUM") 
    PFWREC.PFWERRF = "Y";
    converseLib.validationFailed(225);
    return;
  end
  ;
  if (converseVar.eventKey is pf7) /* scroll up within current summary*/
    if (PF0LW01.PF0LWDSP == "DET")
      PFWSUB1 = PFWREC.PFWSAVDX;
      PFWSUB1 = PFWSUB1 - 1;
      PF0L350();
      return;
    end
    if (PF0LW01.PF0LWDSP == "EXP")
      PFWSUB1 = PFWREC.PFWSAVDX;
      PFWSUB1 = PFWSUB1 - 1;
      PF0L360();
      return;
    end
  end
  ;
  if (converseVar.eventKey is pf8 /* user can't scroll when a 'sum' is displayed*/
   && PF0LW01.PF0LWDSP == "SUM") 
    PFWREC.PFWERRF = "Y";
    converseLib.validationFailed(225);
    return;
  end
  ;
  if (converseVar.eventKey is pf8) /* scroll down within current summary*/
    if (PFWNXTDX > PFWLIMIT)
                                   /* if user can't scroll forward anymore,*/
      PFWREC.PFWERRF = "Y"; /* send a message*/
      converseLib.validationFailed(032);
      return;
    end
    move PFWNXTDX to PFWSUB1 withV60Compat; /* set starting display subscript*/
    PF0L300();
    return;
    ;
  end
  ;
  if (converseVar.eventKey is pf10) /* shift to left-side map*/
    if (PF0LW01.PF0LWLEF == "N")
      PF0LW01.PF0LWLEF = "Y"; /* set map display indicator to left*/
      PF0LW01.PF0LWRIG = "N";
      return;
    else
      PFWREC.PFWERRF = "Y"; /* can't shift left if already on left*/
                                   /* map*/
      converseLib.validationFailed(198);
      return;
    end
  end
  ;
  if (converseVar.eventKey is pf11) /* shift to right-side map*/
    if (PF0LW01.PF0LWRIG == "N")
      PF0LW01.PF0LWRIG = "Y"; /* set map display indicator to right*/
      PF0LW01.PF0LWLEF = "N";
      return;
    else
      PFWREC.PFWERRF = "Y"; /* can't shift right if already on right map*/
      converseLib.validationFailed(192);
      return;
    end
  end
  ;
  if (converseVar.eventKey is pf18) /* user requested a change in display type*/
    PF0LW01.PF0LWHDP = PF0LW01.PF0LWDP1;
                                   /* switch pf key display type*/
    PF0LW01.PF0LWDP1 = PF0LW01.PF0LWDSP; /* with current display type*/
    PF0LW01.PF0LWDSP = PF0LW01.PF0LWHDP;
                                   /* and display maps from same*/
    PF1REC.PF1DISP = PF0LW01.PF0LWDSP;
    if (PF0LW01.PF0LWDSP == "SUM")
       /* (sum,det,exp). move appropriate title heading to maps.*/
      PF0LM001.PF0LMLIT = "SUMMARY FILE SUMMARY VIEW";
      PF0LM002.PF0LMLIT = "SUMMARY FILE SUMMARY VIEW";
    else
      if (PF0LW01.PF0LWDSP == "DET")
        PFWREC.PFWSUB1 = PFWREC.PFWSAVDX;
        PF0LM001.PF0LMLIT = "SUMMARY FILE DETAIL VIEW";
        PF0LM002.PF0LMLIT = "SUMMARY FILE DETAIL VIEW";
      else
        if (PF0LW01.PF0LWDSP == "EXP")
          PFWREC.PFWSUB1 = PFWREC.PFWSAVDX;
          PF0LM001.PF0LMLIT = "SUMMARY FILE EXPLODED VIEW";
          PF0LM002.PF0LMLIT = "SUMMARY FILE EXPLODED VIEW";
        end
      end
    end
    if (PF0LW01.PF0LWHDP == "SUM"
     || PF0LW01.PF0LWDSP == "SUM")
      PFWREC.PFWSAVDX = 1;
      PFWREC.PFWSUB1 = 1;
    end
    PF0L300();
    return;
  end
  ;
  if (converseVar.eventKey is pf19) /* user requested a change in display type*/
    PF0LW01.PF0LWHDP = PF0LW01.PF0LWDP2;
                                   /* switch pf key display type*/
    PF0LW01.PF0LWDP2 = PF0LW01.PF0LWDSP; /* with current display type*/
    PF0LW01.PF0LWDSP = PF0LW01.PF0LWHDP;
                                   /* and display maps from same*/
    PF1REC.PF1DISP = PF0LW01.PF0LWDSP;
    if (PF0LW01.PF0LWDSP == "SUM")
       /* (sum,det,exp). move appropriate title heading to maps.*/
      PF0LM001.PF0LMLIT = "SUMMARY FILE SUMMARY VIEW";
      PF0LM002.PF0LMLIT = "SUMMARY FILE SUMMARY VIEW";
    else
      if (PF0LW01.PF0LWDSP == "DET")
        PFWREC.PFWSUB1 = PFWREC.PFWSAVDX;
        PF0LM001.PF0LMLIT = "SUMMARY FILE DETAIL VIEW";
        PF0LM002.PF0LMLIT = "SUMMARY FILE DETAIL VIEW";
      else
        if (PF0LW01.PF0LWDSP == "EXP")
          PFWREC.PFWSUB1 = PFWREC.PFWSAVDX;
          PF0LM001.PF0LMLIT = "SUMMARY FILE EXPLODED VIEW";
          PF0LM002.PF0LMLIT = "SUMMARY FILE EXPLODED VIEW";
        end
      end
    end
    if (PF0LW01.PF0LWHDP == "SUM"
     || PF0LW01.PF0LWDSP == "SUM")
      PFWREC.PFWSAVDX = 1;
      PFWREC.PFWSUB1 = 1;
    end
    PF0L300();
    return;
  end
  ;
  if (converseVar.eventKey is pf20) /* move up within a level*/
    if (PF0LWSTS == 1) /* no more summaries within this level*/
      PFWREC.PFWERRF = "Y";
      converseLib.validationFailed(220);
      return;
    end
    PF0L260(); /* access vsumry01 table*/
    if (SQLCA.VAGen_SQLCODE == +100) /* if the row was not found,*/
      PFWREC.PFWERRF = "Y"; /* send the user a message*/
      converseLib.validationFailed(220);
      return;
    end
    PF0LW01.PF0LWFL2 = PF0LW01.PF0LWFL1;
    PF0L200(); /* read vsumry01/store rows in w/s area*/
    PF0L270(); /* see if hierarchy changed*/
    PFWSUB1 = 1;
    PF0L300(); /* move w/s items to display screen*/
    return;
  end
  ;
  if (converseVar.eventKey is pf21) /* move down within a level*/
    PF0LW01.PF0LWSTS = PF0LW01.PF0LWSTS + 1;
    PF0LW01.PF0LWFL2 = PF0LW01.PF0LWFL1;
    PF0L200(); /* access vsumry01 table*/
    if (SQLCA.VAGen_SQLCODE == +100) /* if the row was not found,*/
      PFWREC.PFWERRF = "Y"; /* send the user a message*/
      converseLib.validationFailed(220);
      PF0LW01.PF0LWSTS = PF0LW01.PF0LWSTS - 1;
      return;
    end
    PF0L270(); /* see if hierarchy changed*/
    PFWSUB1 = 1;
    PF0L300(); /* move w/s items to display screen*/
    ;
    return;
  end
  ;
  converseLib.validationFailed(001); /* invalid key was entered*/
  PFWREC.PFWERRF = "Y";
end // end PF0L110

// converse left side map
Function PF0L120()
   /* ********************************************************/
   /* *  the sole function of this process is to converse   **/
   /* *  the left side of the summary displays.             **/
   /* ********************************************************/
  ;
  set PF0LM001.XXXCURDT cursor;
  ;
  converse PF0LM001 ;
  ;
end // end PF0L120

// converse right side map
Function PF0L130()
   /* ********************************************************/
   /* *  the sole function of this process is to converse   **/
   /* *  the right side of the summary displays.            **/
   /* ********************************************************/
  ;
  set PF0LM001.XXXCURDT cursor;
  ;
  converse PF0LM002 ;
  ;
end // end PF0L130

// access vsumry01 table
Function PF0L200()
   /* ***********************************************************/
   /* *  this process will access the vsumry01 table using     **/
   /* *  the summary name, summary level, and summary sequence **/
   /* *  number as db2 keys.*/
   /* ***********************************************************/
  ;
  set PFGREC empty;
  set SQLCA empty;
  PFGREC.PFESUMNM = PFEREC.PFESUMNM; /* move summary name to db2 key*/
  PFGREC.PFGSUMN = PFEREC.PFGSUMN; /* move summary # to db2 key*/
  PFGREC.PFGLVLNO = PF0LW01.PF0LWSTL; /* move level # to db2 key*/
  PFGREC.PFGLVLSQ = PF0LW01.PF0LWSTS; /* move level seq # to db2 key*/
  ;
  call "IO2920" ("S1", SQLCA, PFGREC) {isNoRefresh = yes, isExternal = yes}; /* open vsumry01 cursor*/
  ;
  if (SQLCA.VAGen_SQLCODE == +0) /* if cursor open ok, continue with the process*/
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
    TA1REC.TA1TBLVU = "VSUMRY01";
    TA1REC.TA1TBLKE = PF1REC.PFESUMNM;
    TA1REC.TA1LOCAT[3] = "PF0L200";
    TA1REC.TA1LOCAT[4] = "IO2920";
    XPPF010();
  end
  ;
  ;
  set PFGREC empty;
  set SQLCA empty;
  ;
  call "IO2920" ("N1", SQLCA, PFGREC) {isNoRefresh = yes, isExternal = yes}; /* access vsumry01 table*/
  ;
  if (SQLCA.VAGen_SQLCODE == +0) /* if cursor open ok, continue with the process*/
    PF0LW01.PF0LWSTS = PFGREC.PFGLVLSQ; /* save seq. #*/
    PF0LW01.PF0LWSTL = PFGREC.PFGLVLNO;
    PF0LW01.PF0LWCD1 = PFGREC.PFDCDVAL[1];
    PF0LW01.PF0LWCD2 = PFGREC.PFDCDVAL[2];
    PF0LW01.PF0LWCD3 = PFGREC.PFDCDVAL[3];
    PF0LW01.PF0LWCD4 = PFGREC.PFDCDVAL[4];
    PF0LW01.PF0LWCD5 = PFGREC.PFDCDVAL[5];
    PF0LW01.PF0LWCD6 = PFGREC.PFDCDVAL[6];
    PF0LW01.PF0LWCD7 = PFGREC.PFDCDVAL[7];
  else
    if (SQLCA.VAGen_SQLCODE == +100)
      return;
    else
      TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
      TA1REC.TA1TBLVU = "VSUMRY01";
      TA1REC.TA1TBLKE = PF1REC.PFESUMNM;
      TA1REC.TA1LOCAT[3] = "PF0L200";
      TA1REC.TA1LOCAT[4] = "IO2920";
      XPPF010();
    end
  end
  ;
  ;
  PF0L210(); /* perform routine to get attribute literals*/
  ;
  ;
  set PF0LW02 empty;
  PFWSUB1 = 1;
  while (PFGREC.PFGLVLSQ == PF0LW01.PF0LWSTS
   && PFWSUB1 <= 500)
    ;
    PF0L220(); /* move summary rows to w/s area*/
    ;
    set SQLCA empty;
    set PFGREC empty;
    ;
    call "IO2920" ("N1", SQLCA, PFGREC) {isNoRefresh = yes, isExternal = yes}; /* get vsumry01 row*/
    ;
    if (SQLCA.VAGen_SQLCODE == +0) /* if a row is found, continue with the process*/
       /* next sentence*/
    else
      if (SQLCA.VAGen_SQLCODE == +100) /* if a row isn't found, loop will terminate*/
        PFGREC.PFGLVLSQ = 9999; /* set condition to end loop*/
      else
        TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
        TA1REC.TA1TBLVU = "VSUMRY01";
        TA1REC.TA1TBLKE = PF1REC.PFESUMNM;
        TA1REC.TA1LOCAT[3] = "PF0L200";
        TA1REC.TA1LOCAT[4] = "IO2920";
        XPPF010();
      end
    end
    PFWSUB1 = PFWSUB1 + 1;
  end
  ;
  if (PFWSUB1 > 500)
    TA1REC.TA1TYPE = "APPL"; /* error type*/
    TA1REC.TA1FUNC = "RETN"; /* termination function*/
    TA1REC.TA1PGMNM = "PF0L"; /* program name*/
    TA1REC.TA1LOC = "PF0LW02 TBL OVERFLOW - PF0L200";
    SQLCA.SQLCAREC = " "; /* error information*/
    ;
    call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes}; /* error diagnostic routine*/
    ;
    COMMAREA.CAUSERA = " "; /* clear user commarea*/
    XSPF4(); /* master menu*/
    exit program; /* master menu failure*/
  end
  ;
  ;
  PFWREC.PFWLIMIT = PFWSUB1 - 1; /* set maximum index on w/s area*/
  ;
  ;
  PFWSUB1 = 1; /* initialize subscript*/
  while (PFWSUB1 <= PFWLIMIT)
    ;
    PF0L240(); /* perform routine get i/s group*/
                                    /* literals*/
    PFWSUB1 = PFWSUB1 + 1;
  end
  ;
  ;
  set PFGREC empty;
  set SQLCA empty;
  ;
  call "IO2920" ("C1", SQLCA, PFGREC) {isNoRefresh = yes, isExternal = yes}; /* close vsumry01 cursor*/
  ;
  if (SQLCA.VAGen_SQLCODE == +0) /* if cursor open ok, continue with the process*/
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
    TA1REC.TA1TBLVU = "VSUMRY01";
    TA1REC.TA1TBLKE = PF1REC.PFESUMNM;
    TA1REC.TA1LOCAT[3] = "PF0L200";
    TA1REC.TA1LOCAT[4] = "IO2920";
    XPPF010();
  end
  ;
end // end PF0L200

// determine attribute literals
Function PF0L210()
   /* ********************************************************/
   /* *  this process will determine the attribute field    **/
   /* *  literal for those attributes that are displayed    **/
   /* *  at the summary level to be viewed. the literal     **/
   /* *  be moved to the pf0lm001 screen fields from the    **/
   /* *  passed attribute descriptions in pf1rec.           **/
   /* ********************************************************/
  ;
  PF0LM001.PF0LMSTY = " "; /* clear product literals on maps*/
  PF0LM002.PF0LMSTY = " ";
  PF0LM001.PF0LMPRD = " ";
  PF0LM002.PF0LMPRD = " ";
  PF0LM001.PF0LMCLR = " ";
  PF0LM002.PF0LMCLR = " ";
  ;
  PFWSUB2 = 1;
  ;
  while (PFWSUB2 < 8) /* clear literals on maps*/
    PF0LM001.PF0LMAVD[PFWSUB2] = " ";
    PF0LM002.PF0LMAVD[PFWSUB2] = " ";
    PFWSUB2 = PFWSUB2 + 1;
  end
  ;
  PF0LM001.PF0LMPLT = " ";
  PF0LM002.PF0LMPLT = " ";
  ;
  PFWSUB2 = 1;
  ;
  while (PFWSUB2 < 8) /* move rept. attr. literals to maps*/
    PF0LW01.PF0LWAV1 = PF1REC.PFISDESC[PFWSUB2];
    if (PF0LW01.PF0LWAV1 > " ")
      PF0LW01.PF0LWAV2 = " :";
    else
      PF0LW01.PF0LWAV2 = "  ";
    end
    PF0LM001.PF0LMACA[PFWSUB2] = PF0LW01.PF0LWAVA;
    PF0LM002.PF0LMACA[PFWSUB2] = PF0LW01.PF0LWAVA;
    PFWSUB2 = PFWSUB2 + 1;
  end
  ;
  if (PF1REC.PFISDESC[1] > " ") /* if any attributes below this one*/
    if (PFDREC.PFDVALFL[2] == "Y" /* have selected values, mark this*/
     || PFDREC.PFDVALFL[3] == "Y" /* attribute with a highlighted "p"*/
     || PFDREC.PFDVALFL[4] == "Y" /* to warn user of a partial summary.*/
     || PFDREC.PFDVALFL[5] == "Y" 
     || PFDREC.PFDVALFL[6] == "Y" 
     || PFDREC.PFDVALFL[7] == "Y" 
     || PFDREC.PFDVALFL[8] == "Y")
      PF0LM001.PF0LMIND[1] = "P";
      PF0LM002.PF0LMIND[1] = "P";
      set PF0LM001.PF0LMIND[1] bold;
      set PF0LM002.PF0LMIND[1] bold;
    else
      PF0LM001.PF0LMIND[1] = " ";
      PF0LM002.PF0LMIND[1] = " ";
      set PF0LM001.PF0LMIND[1] normal;
      set PF0LM002.PF0LMIND[1] normal;
    end
  end
  ;
  if (PF1REC.PFISDESC[2] > " ")
    if (PFDREC.PFDVALFL[3] == "Y"
     || PFDREC.PFDVALFL[4] == "Y"
     || PFDREC.PFDVALFL[5] == "Y"
     || PFDREC.PFDVALFL[6] == "Y"
     || PFDREC.PFDVALFL[7] == "Y"
     || PFDREC.PFDVALFL[8] == "Y")
      PF0LM001.PF0LMIND[2] = "P";
      PF0LM002.PF0LMIND[2] = "P";
      set PF0LM001.PF0LMIND[2] bold;
      set PF0LM002.PF0LMIND[2] bold;
    else
      PF0LM001.PF0LMIND[2] = " ";
      PF0LM002.PF0LMIND[2] = " ";
      set PF0LM001.PF0LMIND[2] normal;
      set PF0LM002.PF0LMIND[2] normal;
    end
  end
  ;
  if (PF1REC.PFISDESC[3] > " ")
    if (PFDREC.PFDVALFL[4] == "Y"
     || PFDREC.PFDVALFL[5] == "Y"
     || PFDREC.PFDVALFL[6] == "Y"
     || PFDREC.PFDVALFL[7] == "Y"
     || PFDREC.PFDVALFL[8] == "Y")
      PF0LM001.PF0LMIND[3] = "P";
      PF0LM002.PF0LMIND[3] = "P";
      set PF0LM001.PF0LMIND[3] bold;
      set PF0LM002.PF0LMIND[3] bold;
    else
      PF0LM001.PF0LMIND[3] = " ";
      PF0LM002.PF0LMIND[3] = " ";
      set PF0LM001.PF0LMIND[3] normal;
      set PF0LM002.PF0LMIND[3] normal;
    end
  end
  ;
  if (PF1REC.PFISDESC[4] > " ")
    if (PFDREC.PFDVALFL[5] == "Y"
     || PFDREC.PFDVALFL[6] == "Y"
     || PFDREC.PFDVALFL[7] == "Y"
     || PFDREC.PFDVALFL[8] == "Y")
      PF0LM001.PF0LMIND[4] = "P";
      PF0LM002.PF0LMIND[4] = "P";
      set PF0LM001.PF0LMIND[4] bold;
      set PF0LM002.PF0LMIND[4] bold;
    else
      PF0LM001.PF0LMIND[4] = " ";
      PF0LM002.PF0LMIND[4] = " ";
      set PF0LM001.PF0LMIND[4] normal;
      set PF0LM002.PF0LMIND[4] normal;
    end
  end
  ;
  if (PF1REC.PFISDESC[5] > " ")
    if (PFDREC.PFDVALFL[6] == "Y"
     || PFDREC.PFDVALFL[7] == "Y"
     || PFDREC.PFDVALFL[8] == "Y")
      PF0LM001.PF0LMIND[5] = "P";
      PF0LM002.PF0LMIND[5] = "P";
      set PF0LM001.PF0LMIND[5] bold;
      set PF0LM002.PF0LMIND[5] bold;
    else
      PF0LM001.PF0LMIND[5] = " ";
      PF0LM002.PF0LMIND[5] = " ";
      set PF0LM001.PF0LMIND[5] normal;
      set PF0LM002.PF0LMIND[5] normal;
    end
  end
  ;
  if (PF1REC.PFISDESC[6] > " ")
    if (PFDREC.PFDVALFL[7] == "Y"
     || PFDREC.PFDVALFL[8] == "Y")
      PF0LM001.PF0LMIND[6] = "P";
      PF0LM002.PF0LMIND[6] = "P";
      set PF0LM001.PF0LMIND[6] bold;
      set PF0LM002.PF0LMIND[6] bold;
    else
      PF0LM001.PF0LMIND[6] = " ";
      PF0LM002.PF0LMIND[6] = " ";
      set PF0LM001.PF0LMIND[6] normal;
      set PF0LM002.PF0LMIND[6] normal;
    end
  end
  ;
  if (PF1REC.PFISDESC[7] > " ")
    if (PFDREC.PFDVALFL[8] == "Y")
      PF0LM001.PF0LMIND[7] = "P";
      PF0LM002.PF0LMIND[7] = "P";
      set PF0LM001.PF0LMIND[7] bold;
      set PF0LM002.PF0LMIND[7] bold;
    else
      PF0LM001.PF0LMIND[7] = " ";
      PF0LM002.PF0LMIND[7] = " ";
      set PF0LM001.PF0LMIND[7] normal;
      set PF0LM002.PF0LMIND[7] normal;
    end
  end
  ;
  ;
  PF0LM001.PF0LMPLT = PF1REC.PFIDESC[8];
  PF0LM002.PF0LMPLT = PF1REC.PFIDESC[8];
  ;
  PFWREC.XGPCD = PFGREC.XGPCD;
  PFWREC.SY1STNBR = PFGREC.SY1STNBR;
  PFWREC.SY2CLRID = PFGREC.SY2CLRID;
  PFWREC.XDMCD = PFGREC.XDMCD;
  PFWREC.XQACD = PFGREC.XQACD;
  PFWREC.XLCCD = PFGREC.XLCCD;
  PFWREC.PFDCDVAL[1] = PFGREC.PFDCDVAL[1];
  PFWREC.PFDCDVAL[2] = PFGREC.PFDCDVAL[2];
  PFWREC.PFDCDVAL[3] = PFGREC.PFDCDVAL[3];
  PFWREC.PFDCDVAL[4] = PFGREC.PFDCDVAL[4];
  PFWREC.PFDCDVAL[5] = PFGREC.PFDCDVAL[5];
  PFWREC.PFDCDVAL[6] = PFGREC.PFDCDVAL[6];
  PFWREC.PFDCDVAL[7] = PFGREC.PFDCDVAL[7];
  ;
  if (PFWREC.XGPCD > " ") /* move product attribute desc. to map*/
    PFWREC.PFWPRDAT = PFDREC.PFICD[8];
    PFWIDX = 8;
    XPPF020(); /* perform generic product routine to*/
                                   /* move product*/
    PF0LW01.XGPCD = PFWREC.XGPCD;
    PF0LW01.SY1STNBR = PFWREC.SY1STNBR;
    PF0LW01.SY2CLRID = PFWREC.SY2CLRID;
    PF0LW01.XDMCD = PFWREC.XDMCD;
    PF0LW01.XQACD = PFWREC.XQACD;
    PF0LW01.XLCCD = PFWREC.XLCCD;
    PF0LW01.PF0LWF4 = "/";
    PF0LW01.PF0LWF5 = "/";
    PF0LW01.PF0LWF6 = "/";
    PF0LW01.PF0LWF7 = "/";
    PF0LW01.PF0LWF8 = "/";
    PF0LM001.PF0LMSTY = PF0LW01.PF0LWSTY;
    PF0LM002.PF0LMSTY = PF0LW01.PF0LWSTY;
    PF0LM001.PF0LMPRD = PFWREC.PFWDESC[8];
    PF0LM002.PF0LMPRD = PFWREC.PFWDESC[8];
    PF0LM001.PF0LMCLR = PFWREC.SY2CLRAB;
    PF0LM002.PF0LMCLR = PFWREC.SY2CLRAB;
  end
  ;
  PFWREC.PFWIDX = 7; /* initialize index*/
  ;
  while (PFWIDX > 0)
    if (PFWREC.PFDCDVAL[PFWIDX] > " ")
                                   /* if an attribute has data, move desc.*/
      PFWREC.PFWDESC[PFWIDX] = "NO DESC        ";
      XPPF430(); /* perform edit routine to get code*/
                                   /* value literal*/
      PF0LW01.PF0LWAD1 = PFGREC.PFDCDVAL[PFWIDX];
      PF0LW01.PF0LWAD2 = PFWREC.PFWDESC[PFWIDX];
      PF0LM001.PF0LMAVD[PFWIDX] = PF0LW01.PF0LWAVD; /* description to map*/
      PF0LM002.PF0LMAVD[PFWIDX] = PF0LW01.PF0LWAVD; /* description to map*/
    end
    PFWIDX = PFWIDX - 1;
  end
end // end PF0L210

// load summary info. to w/s area
Function PF0L220()
   /* ************************************************************/
   /* *  this process will load the summary rows from vsumry01  **/
   /* *  table to a w/s area, pf0lw02. pf0l will then display   **/
   /* *  the information in pf0lw02 on screens. first, the      **/
   /* *  process will determine what type of display record     **/
   /* *  the current summary row is and find the literal that   **/
   /* *  is used to describe the row. then, the dollar or %     **/
   /* *  columns are then stored. the valid record types are:   **/
   /* *  record #      description                              **/
   /* *  --------   ----------------------                      **/
   /* *     1       summary level items                         **/
   /* *     2       special summary level items(i.e. dirsg&a)   **/
   /* *     3       i/s group total items                       **/
   /* *     4       i/s group items                             **/
   /* *     5       ungrouped i/s items                         **/
   /* ************************************************************/
  ;
  if (PFWSUB1 == 3) /* setup third w/s entry for spaces to display*/
    PF0LW02.PF0LWLIT[PFWSUB1] = " ";
    PF0LW02.PF0LWTYP[PFWSUB1] = "1";
    PF0LW02.PF0LWC1[PFWSUB1] = 0;
    PF0LW02.PF0LWC2[PFWSUB1] = 0;
    PF0LW02.PF0LWC3[PFWSUB1] = 0;
    PF0LW02.PF0LWC4[PFWSUB1] = 0;
    PF0LW02.PF0LWC5[PFWSUB1] = 0;
    PF0LW02.PF0LWC6[PFWSUB1] = 0;
    PF0LW02.PF0LWC7[PFWSUB1] = 0;
    PF0LW02.PF0LWC8[PFWSUB1] = 0;
    PF0LW02.PF0LWC9[PFWSUB1] = 0;
    PF0LW02.PF0LWC10[PFWSUB1] = 0;
    PF0LW02.PF0LWC11[PFWSUB1] = 0;
    PF0LW02.PF0LWC12[PFWSUB1] = 0;
    PFWSUB1 = PFWSUB1 + 1;
  end
  ;
  if (PFGREC.YISCD[2] == 0) /* this is a summary level item*/
    if (PFGREC.YTYCD == "34"
     || PFGREC.YTYCD == "38") /* if it's a special summary level*/
      PF0LW02.PF0LWTYP[PFWSUB1] = "2"; /* set record type to 2*/
    else
      PF0LW02.PF0LWTYP[PFWSUB1] = "1";
    end
    PF0LW02.PF0LWIND[PFWSUB1] = " ";
    if (PFGREC.YTYCD in YTYTBL.YTYCD) /* move in summary literal*/
      PF0LW02.PF0LWABV[PFWSUB1] = YTYTBL.YTYSDESC[sysVar.arrayIndex];
    end
    PF0L230(); /* perform routine to move columnar*/
                                   /* info.*/
    return;
  end
  ;
  if (PFGREC.YISCD[1] == 0 /* this is an i/s grouped total item*/
   && PFGREC.YISCD[2] > 0)
    PF0LW02.PF0LWTYP[PFWSUB1] = "3";
    PF0LW02.YISCD[PFWSUB1] = PFGREC.YISCD[2];
    PF0LW02.PF0LWIND[PFWSUB1] = "*";
    PF0L230(); /* move columnar info. to pf0kw02 w/s area*/
    return;
  end
  ;
  if (PFGREC.PFBISGRP > 0 /* this is a grouped item*/
   && PFGREC.YISCD[1] > 0)
    PF0LW02.PF0LWTYP[PFWSUB1] = "4"; /* set record type to 4*/
    PF0LW02.YISCD[PFWSUB1] = PFGREC.YISCD[1];
    PF0LW02.PF0LWIND[PFWSUB1] = "-";
    if (PFGREC.YISCD[1] in YISTBL.YISCD)
      PF0LW02.PF0LWABV[PFWSUB1] = YISTBL.YISABRV[sysVar.arrayIndex];
    end
    PF0L230(); /* perform routine to move columnar*/
                                   /* info.*/
    return;
  end
  ;
  if (PFGREC.PFBISGRP == 0) /* this is a ungrouped item*/
    PF0LW02.PF0LWTYP[PFWSUB1] = "5"; /* set record type to 5*/
    PF0LW02.PF0LWIND[PFWSUB1] = " ";
    if (PFGREC.YISCD[1] in YISTBL.YISCD)
      PF0LW02.PF0LWABV[PFWSUB1] = YISTBL.YISABRV[sysVar.arrayIndex];
    end
    PF0L230(); /* perform routine to move columnar*/
                                   /* info.*/
    return;
  end
end // end PF0L220

// move columnar data to w/s
Function PF0L230()
   /* *****************************************************/
   /* *  this process will move the thirteen columns of  **/
   /* *  unit/dollar/percentage information from pfgrec  **/
   /* *  to the pf0kw02 w/s area.                        **/
   /* *****************************************************/
  if (PFGREC.YTYCD == "72"
   || PFGREC.YTYCD == "73")
    PF0LW01.PF0LWNUM = PFGREC.PFGQTY[1];
    if (PF0LW01.PF0LWNUM >= +999500.00)
      PF0LW02.PF0LWC1[PFWSUB1] = +999;
    else
      if (PF0LW01.PF0LWNUM <= -99500.00)
        PF0LW02.PF0LWC1[PFWSUB1] = -99;
      else
        PF0LW02.PF0LWC1[PFWSUB1] = mathLib.round(PF0LW01.PF0LWNUM * .001, -mathLib.decimals(PF0LW02.PF0LWC1[PFWSUB1]));
      end
    end
    PF0LW01.PF0LWNUM = PFGREC.PFGQTY[2];
    if (PF0LW01.PF0LWNUM >= +999.95)
      PF0LW02.PF0LWC2[PFWSUB1] = +999.9;
    else
      if (PF0LW01.PF0LWNUM <= -99.95)
        PF0LW02.PF0LWC2[PFWSUB1] = -99.9;
      else
        PF0LW02.PF0LWC2[PFWSUB1] = mathLib.round(PF0LW01.PF0LWNM2 * 1, -mathLib.decimals(PF0LW02.PF0LWC2[PFWSUB1]));
      end
    end
    PF0LW01.PF0LWNUM = PFGREC.PFGQTY[3];
    if (PF0LW01.PF0LWNUM >= +999500.00)
      PF0LW02.PF0LWC3[PFWSUB1] = +999;
    else
      if (PF0LW01.PF0LWNUM <= -99500.00)
        PF0LW02.PF0LWC3[PFWSUB1] = -99;
      else
        PF0LW02.PF0LWC3[PFWSUB1] = mathLib.round(PF0LW01.PF0LWNUM * .001, -mathLib.decimals(PF0LW02.PF0LWC3[PFWSUB1]));
      end
    end
    PF0LW01.PF0LWNUM = PFGREC.PFGQTY[4];
    if (PF0LW01.PF0LWNUM >= +999500.00)
      PF0LW02.PF0LWC4[PFWSUB1] = +999;
    else
      if (PF0LW01.PF0LWNUM <= -99500.00)
        PF0LW02.PF0LWC4[PFWSUB1] = -99;
      else
        PF0LW02.PF0LWC4[PFWSUB1] = mathLib.round(PF0LW01.PF0LWNUM * .001, -mathLib.decimals(PF0LW02.PF0LWC4[PFWSUB1]));
      end
    end
    PF0LW01.PF0LWNUM = PFGREC.PFGQTY[5];
    if (PF0LW01.PF0LWNUM >= +999500.00)
      PF0LW02.PF0LWC5[PFWSUB1] = +999;
    else
      if (PF0LW01.PF0LWNUM <= -99500.00)
        PF0LW02.PF0LWC5[PFWSUB1] = -99;
      else
        PF0LW02.PF0LWC5[PFWSUB1] = mathLib.round(PF0LW01.PF0LWNUM * .001, -mathLib.decimals(PF0LW02.PF0LWC5[PFWSUB1]));
      end
    end
    PF0LW01.PF0LWNUM = PFGREC.PFGQTY[6];
    if (PF0LW01.PF0LWNUM >= +999.95)
      PF0LW02.PF0LWC6[PFWSUB1] = +999.9;
    else
      if (PF0LW01.PF0LWNUM <= -99.95)
        PF0LW02.PF0LWC6[PFWSUB1] = -99.9;
      else
        PF0LW02.PF0LWC6[PFWSUB1] = mathLib.round(PF0LW01.PF0LWNM2 * 1, -mathLib.decimals(PF0LW02.PF0LWC6[PFWSUB1]));
      end
    end
    PF0LW01.PF0LWNUM = PFGREC.PFGQTY[7];
    if (PF0LW01.PF0LWNUM >= +999500.00)
      PF0LW02.PF0LWC7[PFWSUB1] = +999;
    else
      if (PF0LW01.PF0LWNUM <= -99500.00)
        PF0LW02.PF0LWC7[PFWSUB1] = -99;
      else
        PF0LW02.PF0LWC7[PFWSUB1] = mathLib.round(PF0LW01.PF0LWNUM * .001, -mathLib.decimals(PF0LW02.PF0LWC7[PFWSUB1]));
      end
    end
    PF0LW01.PF0LWNUM = PFGREC.PFGQTY[8];
    if (PF0LW01.PF0LWNUM >= +999.95)
      PF0LW02.PF0LWC8[PFWSUB1] = +999.9;
    else
      if (PF0LW01.PF0LWNUM <= -99.95)
        PF0LW02.PF0LWC8[PFWSUB1] = -99.9;
      else
        PF0LW02.PF0LWC8[PFWSUB1] = mathLib.round(PF0LW01.PF0LWNM2 * 1, -mathLib.decimals(PF0LW02.PF0LWC8[PFWSUB1]));
      end
    end
    PF0LW01.PF0LWNUM = PFGREC.PFGQTY[9];
    if (PF0LW01.PF0LWNUM >= +999500.00)
      PF0LW02.PF0LWC9[PFWSUB1] = +999;
    else
      if (PF0LW01.PF0LWNUM <= -99500.00)
        PF0LW02.PF0LWC9[PFWSUB1] = -99;
      else
        PF0LW02.PF0LWC9[PFWSUB1] = mathLib.round(PF0LW01.PF0LWNUM * .001, -mathLib.decimals(PF0LW02.PF0LWC9[PFWSUB1]));
      end
    end
    PF0LW01.PF0LWNUM = PFGREC.PFGQTY[10];
    if (PF0LW01.PF0LWNUM >= +999.95)
      PF0LW02.PF0LWC10[PFWSUB1] = +999.9;
    else
      if (PF0LW01.PF0LWNUM <= -99.95)
        PF0LW02.PF0LWC10[PFWSUB1] = -99.9;
      else
        PF0LW02.PF0LWC10[PFWSUB1] = mathLib.round(PF0LW01.PF0LWNM2 * 1, -mathLib.decimals(PF0LW02.PF0LWC10[PFWSUB1]));
      end
    end
    PF0LW01.PF0LWNUM = PFGREC.PFGQTY[11];
    if (PF0LW01.PF0LWNUM >= +999.95)
      PF0LW02.PF0LWC11[PFWSUB1] = +999.9;
    else
      if (PF0LW01.PF0LWNUM <= -99.95)
        PF0LW02.PF0LWC11[PFWSUB1] = -99.9;
      else
        PF0LW02.PF0LWC11[PFWSUB1] = mathLib.round(PF0LW01.PF0LWNM2 * 1, -mathLib.decimals(PF0LW02.PF0LWC11[PFWSUB1]));
      end
    end
    PF0LW01.PF0LWNUM = PFGREC.PFGQTY[12];
    if (PF0LW01.PF0LWNUM >= +999.95)
      PF0LW02.PF0LWC12[PFWSUB1] = +999.9;
    else
      if (PF0LW01.PF0LWNUM <= -99.95)
        PF0LW02.PF0LWC12[PFWSUB1] = -99.9;
      else
        PF0LW02.PF0LWC12[PFWSUB1] = mathLib.round(PF0LW01.PF0LWNM2 * 1, -mathLib.decimals(PF0LW02.PF0LWC12[PFWSUB1]));
      end
    end
  else
    PF0LW01.PF0LWNUM = PFGREC.PFGQTY[1];
    PF0LW02.PF0LWC1[PFWSUB1] = mathLib.round(PF0LW01.PF0LWNUM * .001, -mathLib.decimals(PF0LW02.PF0LWC1[PFWSUB1]));
    PF0LW01.PF0LWNUM = PFGREC.PFGQTY[2];
    if (PF0LW01.PF0LWNUM >= +999.95)
      PF0LW02.PF0LWC2[PFWSUB1] = +999.9;
    else
      if (PF0LW01.PF0LWNUM <= -99.95)
        PF0LW02.PF0LWC2[PFWSUB1] = -99.9;
      else
        PF0LW02.PF0LWC2[PFWSUB1] = mathLib.round(PF0LW01.PF0LWNM2 * 1, -mathLib.decimals(PF0LW02.PF0LWC2[PFWSUB1]));
      end
    end
    PF0LW01.PF0LWNUM = PFGREC.PFGQTY[3];
    PF0LW02.PF0LWC3[PFWSUB1] = mathLib.round(PF0LW01.PF0LWNUM * .001, -mathLib.decimals(PF0LW02.PF0LWC3[PFWSUB1]));
    PF0LW01.PF0LWNUM = PFGREC.PFGQTY[4];
    PF0LW02.PF0LWC4[PFWSUB1] = mathLib.round(PF0LW01.PF0LWNUM * .001, -mathLib.decimals(PF0LW02.PF0LWC4[PFWSUB1]));
    PF0LW01.PF0LWNUM = PFGREC.PFGQTY[5];
    PF0LW02.PF0LWC5[PFWSUB1] = mathLib.round(PF0LW01.PF0LWNUM * .001, -mathLib.decimals(PF0LW02.PF0LWC5[PFWSUB1]));
    PF0LW01.PF0LWNUM = PFGREC.PFGQTY[6];
    if (PF0LW01.PF0LWNUM >= +999.95)
      PF0LW02.PF0LWC6[PFWSUB1] = +999.9;
    else
      if (PF0LW01.PF0LWNUM <= -99.95)
        PF0LW02.PF0LWC6[PFWSUB1] = -99.9;
      else
        PF0LW02.PF0LWC6[PFWSUB1] = mathLib.round(PF0LW01.PF0LWNM2 * 1, -mathLib.decimals(PF0LW02.PF0LWC6[PFWSUB1]));
      end
    end
    PF0LW01.PF0LWNUM = PFGREC.PFGQTY[7];
    PF0LW02.PF0LWC7[PFWSUB1] = mathLib.round(PF0LW01.PF0LWNUM * .001, -mathLib.decimals(PF0LW02.PF0LWC7[PFWSUB1]));
    PF0LW01.PF0LWNUM = PFGREC.PFGQTY[8];
    if (PF0LW01.PF0LWNUM >= +999.95)
      PF0LW02.PF0LWC8[PFWSUB1] = +999.9;
    else
      if (PF0LW01.PF0LWNUM <= -99.95)
        PF0LW02.PF0LWC8[PFWSUB1] = -99.9;
      else
        PF0LW02.PF0LWC8[PFWSUB1] = mathLib.round(PF0LW01.PF0LWNM2 * 1, -mathLib.decimals(PF0LW02.PF0LWC8[PFWSUB1]));
      end
    end
    PF0LW01.PF0LWNUM = PFGREC.PFGQTY[9];
    PF0LW02.PF0LWC9[PFWSUB1] = mathLib.round(PF0LW01.PF0LWNUM * .001, -mathLib.decimals(PF0LW02.PF0LWC9[PFWSUB1]));
    PF0LW01.PF0LWNUM = PFGREC.PFGQTY[10];
    if (PF0LW01.PF0LWNUM >= +999.95)
      PF0LW02.PF0LWC10[PFWSUB1] = +999.9;
    else
      if (PF0LW01.PF0LWNUM <= -99.95)
        PF0LW02.PF0LWC10[PFWSUB1] = -99.9;
      else
        PF0LW02.PF0LWC10[PFWSUB1] = mathLib.round(PF0LW01.PF0LWNM2 * 1, -mathLib.decimals(PF0LW02.PF0LWC10[PFWSUB1]));
      end
    end
    PF0LW01.PF0LWNUM = PFGREC.PFGQTY[11];
    if (PF0LW01.PF0LWNUM >= +999.95)
      PF0LW02.PF0LWC11[PFWSUB1] = +999.9;
    else
      if (PF0LW01.PF0LWNUM <= -99.95)
        PF0LW02.PF0LWC11[PFWSUB1] = -99.9;
      else
        PF0LW02.PF0LWC11[PFWSUB1] = mathLib.round(PF0LW01.PF0LWNM2 * 1, -mathLib.decimals(PF0LW02.PF0LWC11[PFWSUB1]));
      end
    end
    PF0LW01.PF0LWNUM = PFGREC.PFGQTY[12];
    if (PF0LW01.PF0LWNUM >= +999.95)
      PF0LW02.PF0LWC12[PFWSUB1] = +999.9;
    else
      if (PF0LW01.PF0LWNUM <= -99.95)
        PF0LW02.PF0LWC12[PFWSUB1] = -99.9;
      else
        PF0LW02.PF0LWC12[PFWSUB1] = mathLib.round(PF0LW01.PF0LWNM2 * 1, -mathLib.decimals(PF0LW02.PF0LWC12[PFWSUB1]));
      end
    end
  end
end // end PF0L230

// get i/s group descriptions
Function PF0L240()
   /* *********************************************************/
   /* *  this process will scan through the pf0lw02 storage  **/
   /* *  and will get the i/s group descriptions for all i/s **/
   /* *  group total entires in pf0lw02(record type  = 3).   **/
   /* *  the i/s group desc. will be obtained by using the   **/
   /* *  yiscd of the record immediately following the group **/
   /* *  total record. this yiscd is combined with the i/s   **/
   /* *  group ref. # as a data base key to access the i/s   **/
   /* *  group table.                                        **/
   /* *********************************************************/
  ;
  if (PF0LW02.PF0LWTYP[PFWSUB1] != "3") /* if the entry isn't a group total,*/
    return; /* exit the routine*/
  end
  ;
  PFWSUB2 = PFWSUB1 + 1; /* set subscript to entry immediately following*/
  ;
  set SQLCA empty;
  set PFBREC empty;
  PFBREC.PFBREF = PFEREC.PFBREF;
                                   /* setup to access i/s group table*/
  PFBREC.YISCD[1] = PF0LW02.YISCD[PFWSUB2];
  call "IO2710" ("S ", SQLCA, PFBREC) {isNoRefresh = yes, isExternal = yes}; /* access visgrp01 table*/
  if (SQLCA.VAGen_SQLCODE == +0) /* if record found, move i/s group desc. to*/
    PF0LW02.PF0LWABV[PFWSUB1] = PFBREC.PFBISDSC; /* w/s area*/
  else
    TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
    TA1REC.TA1TBLVU = "VISGRP01";
    PF0LW01.PF0LWABK = PFBREC.PFBREF;
    TA1REC.TA1TBLKE = PF0LW01.PF0LWABK;
    TA1REC.TA1LOCAT[3] = "PF0L240";
    TA1REC.TA1LOCAT[4] = "IO2710";
    XPPF010();
  end
end // end PF0L240

// access vsumry01 table
Function PF0L260()
   /* ***********************************************************/
   /* *  this process will access the vsumry01 table using     **/
   /* *  the summary name, summary level, and summary sequence **/
   /* *  number as db2 keys. this process will be used to read **/
   /* *  the summary file in a backwards direction and will    **/
   /* *  read the first record of the requested summary only.  **/
   /* *  the level and seq. # keys will then be used by        **/
   /* *  pf0l200 to read the summary in a normal manner.       **/
   /* ***********************************************************/
  ;
  set PFGREC empty;
  set SQLCA empty;
  ;
  PFGREC.PFESUMNM = PFEREC.PFESUMNM; /* move summary name to db2 key*/
  PFGREC.PFGSUMN = PFEREC.PFGSUMN; /* move summary # to db2 key*/
  PFGREC.PFGLVLNO = PF0LW01.PF0LWSTL; /* move level # to db2 key*/
  PFGREC.PFGLVLSQ = PF0LW01.PF0LWSTS; /* move level seq # to db2 key*/
  ;
  call "IO2920" ("SF", SQLCA, PFGREC) {isNoRefresh = yes, isExternal = yes};
                                   /* read vsumry01 select/first*/
  ;
  if (SQLCA.VAGen_SQLCODE == +0) /* if cursor open ok, continue with the process*/
    PF0LW01.PF0LWSTS = PFGREC.PFGLVLSQ; /* save seq. #*/
  else
    if (SQLCA.VAGen_SQLCODE == +100)
      return;
    else
      TA1REC.TA1DBASE = "DPROFT"; /* fatal db2 error;*/
      TA1REC.TA1TBLVU = "VSUMRY01";
      TA1REC.TA1TBLKE = PF1REC.PFESUMNM;
      TA1REC.TA1LOCAT[3] = "PF0L200";
      TA1REC.TA1LOCAT[4] = "IO2920";
      XPPF010();
    end
  end
  ;
end // end PF0L260

// check for hierarchy change
Function PF0L270()
   /* ********************************************************/
   /* *  this process will check the reporting attribute    **/
   /* *  values of the previous and current summaries that  **/
   /* *  were displayed as a result of a pf20 or pf21 key.  **/
   /* *  if the result of of either key is a change in the  **/
   /* *  reporting attributes hierarchy as described below, **/
   /* *  then a warning message is sent to the terminal     **/
   /* *  operator. in the following example, if the user is **/
   /* *  viewing the summary indicated as point a and       **/
   /* *  enters pf20 (move up within a level) to move to    **/
   /* *  point b, the hierarchy level of '003 non-tech      **/
   /* *  running' has been bypassed.                        **/
   /* *  02  running                                        **/
   /* *      002  tecnical running                          **/
   /* *           21  national                              **/
   /* *           22  major                                 **/
   /* *           23  regular   ---- point b                **/
   /* *      003  non-tech running                          **/
   /* *           21  national  ---- point a                **/
   /* *           22  major                                 **/
   /* *           23  regular                               **/
   /* *  05  basketball                                     **/
   /* ********************************************************/
  ;
  if (PF0LW01.PF0LWSTL == 8) /* find current level # and compare attributes*/
    if (PF0LW01.PF0LWCD7 != PF0LW01.PF0LWCV7) /* from one level lower*/
        /* if they don't match, send warning to user*/
      PF0LW01.PF0LWRN1 = "BKWD/FRWD MOVEMENT AT \"";
      PF0LW01.PF0LWRV1 = PF1REC.PFISDESC[8];
      PF0LW01.PF0LWRN2 = "\" LEVEL HAS CAUSED \"";
      PF0LW01.PF0LWRV2 = PF1REC.PFISDESC[7];
      PF0LW01.PF0LWRN3 = "\" VALUE TO CHANGE";
      PF0LM001.VAGen_EZEMSG = PF0LW01.PF0LWRN; /* move warning message*/
      PF0LM002.VAGen_EZEMSG = PF0LW01.PF0LWRN; /* to screen*/
    end
    return;
  end
  ;
  if (PF0LW01.PF0LWSTL == 6) /* find current level # and compare attributes*/
    if (PF0LW01.PF0LWCD6 != PF0LW01.PF0LWCV6) /* from one level lower*/
        /* if they don't match, send warning to user*/
      PF0LW01.PF0LWRN1 = "BKWD/FRWD MOVEMENT AT \"";
      PF0LW01.PF0LWRV1 = PF1REC.PFISDESC[7];
      PF0LW01.PF0LWRN2 = "\" LEVEL HAS CAUSED \"";
      PF0LW01.PF0LWRV2 = PF1REC.PFISDESC[6];
      PF0LW01.PF0LWRN3 = "\" VALUE TO CHANGE";
      PF0LM001.VAGen_EZEMSG = PF0LW01.PF0LWRN; /* move warning message*/
      PF0LM002.VAGen_EZEMSG = PF0LW01.PF0LWRN; /* to screen*/
    end
    return;
  end
  ;
  if (PF0LW01.PF0LWSTL == 6) /* find current level # and compare attributes*/
    if (PF0LW01.PF0LWCD5 != PF0LW01.PF0LWCV5) /* from one level lower*/
        /* if they don't match, send warning to user*/
      PF0LW01.PF0LWRN1 = "BKWD/FRWD MOVEMENT AT \"";
      PF0LW01.PF0LWRV1 = PF1REC.PFISDESC[6];
      PF0LW01.PF0LWRN2 = "\" LEVEL HAS CAUSED \"";
      PF0LW01.PF0LWRV2 = PF1REC.PFISDESC[5];
      PF0LW01.PF0LWRN3 = "\" VALUE TO CHANGE";
      PF0LM001.VAGen_EZEMSG = PF0LW01.PF0LWRN; /* move warning message*/
      PF0LM002.VAGen_EZEMSG = PF0LW01.PF0LWRN; /* to screen*/
    end
    return;
  end
  ;
  if (PF0LW01.PF0LWSTL == 5) /* find current level # and compare attributes*/
    if (PF0LW01.PF0LWCD4 != PF0LW01.PF0LWCV4) /* from one level lower*/
        /* if they don't match, send warning to user*/
      PF0LW01.PF0LWRN1 = "BKWD/FRWD MOVEMENT AT \"";
      PF0LW01.PF0LWRV1 = PF1REC.PFISDESC[5];
      PF0LW01.PF0LWRN2 = "\" LEVEL HAS CAUSED \"";
      PF0LW01.PF0LWRV2 = PF1REC.PFISDESC[4];
      PF0LW01.PF0LWRN3 = "\" VALUE TO CHANGE";
      PF0LM001.VAGen_EZEMSG = PF0LW01.PF0LWRN; /* move warning message*/
      PF0LM002.VAGen_EZEMSG = PF0LW01.PF0LWRN; /* to screen*/
    end
    return;
  end
  ;
  if (PF0LW01.PF0LWSTL == 4) /* find current level # and compare attributes*/
    if (PF0LW01.PF0LWCD3 != PF0LW01.PF0LWCV3) /* from one level lower*/
        /* if they don't match, send warning to user*/
      PF0LW01.PF0LWRN1 = "BKWD/FRWD MOVEMENT AT \"";
      PF0LW01.PF0LWRV1 = PF1REC.PFISDESC[4];
      PF0LW01.PF0LWRN2 = "\" LEVEL HAS CAUSED \"";
      PF0LW01.PF0LWRV2 = PF1REC.PFISDESC[3];
      PF0LW01.PF0LWRN3 = "\" VALUE TO CHANGE";
      PF0LM001.VAGen_EZEMSG = PF0LW01.PF0LWRN; /* move warning message*/
      PF0LM002.VAGen_EZEMSG = PF0LW01.PF0LWRN; /* to screen*/
    end
    return;
  end
  ;
  if (PF0LW01.PF0LWSTL == 3) /* find current level # and compare attributes*/
    if (PF0LW01.PF0LWCD2 != PF0LW01.PF0LWCV2) /* from one level lower*/
        /* if they don't match, send warning to user*/
      PF0LW01.PF0LWRN1 = "BKWD/FRWD MOVEMENT AT \"";
      PF0LW01.PF0LWRV1 = PF1REC.PFISDESC[3];
      PF0LW01.PF0LWRN2 = "\" LEVEL HAS CAUSED \"";
      PF0LW01.PF0LWRV2 = PF1REC.PFISDESC[2];
      PF0LW01.PF0LWRN3 = "\" VALUE TO CHANGE";
      PF0LM001.VAGen_EZEMSG = PF0LW01.PF0LWRN; /* move warning message*/
      PF0LM002.VAGen_EZEMSG = PF0LW01.PF0LWRN; /* to screen*/
    end
    return;
  end
  ;
  if (PF0LW01.PF0LWSTL == 2) /* find current level # and compare attributes*/
    if (PF0LW01.PF0LWCD1 != PF0LW01.PF0LWCV1) /* from one level lower*/
        /* if they don't match, send warning to user*/
      PF0LW01.PF0LWRN1 = "BKWD/FRWD MOVEMENT AT \"";
      PF0LW01.PF0LWRV1 = PF1REC.PFISDESC[2];
      PF0LW01.PF0LWRN2 = "\" LEVEL HAS CAUSED \"";
      PF0LW01.PF0LWRV2 = PF1REC.PFISDESC[1];
      PF0LW01.PF0LWRN3 = "\" VALUE TO CHANGE";
      PF0LM001.VAGen_EZEMSG = PF0LW01.PF0LWRN; /* move warning message*/
      PF0LM002.VAGen_EZEMSG = PF0LW01.PF0LWRN; /* to screen*/
    end
    return;
  end
  ;
end // end PF0L270

// display summary type
Function PF0L300()
   /* ************************************************************/
   /* *  this process will determine the type of summary a user **/
   /* *  is viewing and will perform the appropriate routine to **/
   /* *  move summary records to the maps. the routines are :   **/
   /* *  summary type     routine                               **/
   /* *  ------------     -------------                         **/
   /* *    'sum'          pf0l310                               **/
   /* *    'det'          pf0l320                               **/
   /* *    'exp'          pf0l330                               **/
   /* ************************************************************/
  ;
  if (PF0LW01.PF0LWDSP == "SUM") /* summary display*/
    PF0L310();
  else
    if (PF0LW01.PF0LWDSP == "DET") /* detail display*/
      PF0L320();
    else
      if (PF0LW01.PF0LWDSP == "EXP") /* explode display*/
        PF0L330();
      end
    end
  end
end // end PF0L300

// move 'summary' items to maps
Function PF0L310()
   /* ***************************************************/
   /* *   this process will move all 'summary' items   **/
   /* *   from pf0lw02 record to the maps. summary     **/
   /* *   items are identified by the field pf0lwtyp   **/
   /* *   being = 1. the summary display will use one  **/
   /* *   screen only; no scrolling will be allowed.   **/
   /* *   both the right side(pf0lm001) and the left   **/
   /* *   side(pf0lm002) of the display will be        **/
   /* *   loaded in this process. the user can scroll  **/
   /* *   right and left using pf10 and pf11.          **/
   /* ***************************************************/
  ;
  PF0L340(); /* clear maps of previous data*/
  ;
  PFWREC.PFWSAVDX = PFWREC.PFWSUB1; /* save first w/s position*/
  ;
  PFWSUB2 = 1;
  while (PFWSUB2 < 11) /* browse through pf0lw02 and move all*/
    if (PF0LW02.PF0LWTYP[PFWSUB1] == "1") /* summary records to the maps*/
      PF0LM001.PF0LMISD[PFWSUB2] = PF0LW02.PF0LWLIT[PFWSUB1];
      PF0LM002.PF0LMISD[PFWSUB2] = PF0LW02.PF0LWLIT[PFWSUB1];
      ;
      PF0LM001.PF0LMGSA[PFWSUB2] = PF0LW02.PF0LWC1[PFWSUB1];
      PF0LM001.PF0LMGSP[PFWSUB2] = PF0LW02.PF0LWC2[PFWSUB1];
      PF0LM001.PF0LMRTS[PFWSUB2] = PF0LW02.PF0LWC3[PFWSUB1];
      PF0LM001.PF0LMOTH[PFWSUB2] = PF0LW02.PF0LWC4[PFWSUB1];
      PF0LM001.PF0LMNS1[PFWSUB2] = PF0LW02.PF0LWC5[PFWSUB1];
      PF0LM001.PF0LMNP1[PFWSUB2] = PF0LW02.PF0LWC6[PFWSUB1];
      PF0LM001.PF0LMPC1[PFWSUB2] = PF0LW02.PF0LWC11[PFWSUB1];
      ;
      PF0LM002.PF0LMGSA[PFWSUB2] = PF0LW02.PF0LWC5[PFWSUB1];
      PF0LM002.PF0LMNS2[PFWSUB2] = PF0LW02.PF0LWC7[PFWSUB1];
      PF0LM002.PF0LMNP2[PFWSUB2] = PF0LW02.PF0LWC8[PFWSUB1];
      PF0LM002.PF0LMNS3[PFWSUB2] = PF0LW02.PF0LWC9[PFWSUB1];
      PF0LM002.PF0LMNP3[PFWSUB2] = PF0LW02.PF0LWC10[PFWSUB1];
      PF0LM002.PF0LMPC1[PFWSUB2] = PF0LW02.PF0LWC11[PFWSUB1];
      PF0LM002.PF0LMPC2[PFWSUB2] = PF0LW02.PF0LWC12[PFWSUB1];
      PFWSUB2 = PFWSUB2 + 1; /* bump index for maps*/
    end
    PFWSUB1 = PFWSUB1 + 1; /* bump w/s index*/
    if (PFWSUB1 > PFWLIMIT)
      PFWSUB2 = 13;
    end
  end
end // end PF0L310

// move 'detail' items to maps
Function PF0L320()
   /* ***************************************************/
   /* *   this process will move all 'detail' items    **/
   /* *   from pf0lw02 record to the maps. detail      **/
   /* *   items are identified by the field pf0lwtyp   **/
   /* *   being = 1, 2, 3, or 5.  detail display will  **/
   /* *   scroll up and down the pf0lw02 w/s area.     **/
   /* *   the control of scrolling positioning will    **/
   /* *   be done by pf0lxxx.                          **/
   /* *   both the right side(pf0lm001) and the left   **/
   /* *   side(pf0lm002) of the display will be        **/
   /* *   loaded in this process. the user can shift   **/
   /* *   right and left using pf10 and pf11.          **/
   /* ***************************************************/
  ;
  PF0L340(); /* clear maps of previous data*/
  ;
  PFWREC.PFWSAVDX = PFWREC.PFWSUB1; /* save first w/s position*/
  ;
  PFWSUB2 = 1;
  ;
  while (PFWSUB2 < 11) /* browse through pf0lw02 and move all*/
    if (PF0LW02.PF0LWTYP[PFWSUB1] == "1" /* detail records to the maps*/
     || PF0LW02.PF0LWTYP[PFWSUB1] == "2" 
     || PF0LW02.PF0LWTYP[PFWSUB1] == "3" 
     || PF0LW02.PF0LWTYP[PFWSUB1] == "5")
      PF0LM001.PF0LMISD[PFWSUB2] = PF0LW02.PF0LWLIT[PFWSUB1];
      PF0LM002.PF0LMISD[PFWSUB2] = PF0LW02.PF0LWLIT[PFWSUB1];
      ;
      PF0LM001.PF0LMGSA[PFWSUB2] = PF0LW02.PF0LWC1[PFWSUB1];
      PF0LM001.PF0LMGSP[PFWSUB2] = PF0LW02.PF0LWC2[PFWSUB1];
      PF0LM001.PF0LMRTS[PFWSUB2] = PF0LW02.PF0LWC3[PFWSUB1];
      PF0LM001.PF0LMOTH[PFWSUB2] = PF0LW02.PF0LWC4[PFWSUB1];
      PF0LM001.PF0LMNS1[PFWSUB2] = PF0LW02.PF0LWC5[PFWSUB1];
      PF0LM001.PF0LMNP1[PFWSUB2] = PF0LW02.PF0LWC6[PFWSUB1];
      PF0LM001.PF0LMPC1[PFWSUB2] = PF0LW02.PF0LWC12[PFWSUB1];
      ;
      PF0LM002.PF0LMGSA[PFWSUB2] = PF0LW02.PF0LWC5[PFWSUB1];
      PF0LM002.PF0LMNS2[PFWSUB2] = PF0LW02.PF0LWC7[PFWSUB1];
      PF0LM002.PF0LMNP2[PFWSUB2] = PF0LW02.PF0LWC8[PFWSUB1];
      PF0LM002.PF0LMNS3[PFWSUB2] = PF0LW02.PF0LWC9[PFWSUB1];
      PF0LM002.PF0LMNP3[PFWSUB2] = PF0LW02.PF0LWC10[PFWSUB1];
      PF0LM002.PF0LMPC1[PFWSUB2] = PF0LW02.PF0LWC11[PFWSUB1];
      PF0LM002.PF0LMPC2[PFWSUB2] = PF0LW02.PF0LWC12[PFWSUB1];
      PFWSUB2 = PFWSUB2 + 1; /* bump index for maps*/
    end
    PFWSUB1 = PFWSUB1 + 1; /* bump w/s index*/
    if (PFWSUB1 > PFWLIMIT) /* if w/s end reached,*/
      PFWSUB2 = 13;
    end
  end
  ;
  PFWREC.PFWNXTDX = PFWREC.PFWSUB1; /* save next available index*/
end // end PF0L320

// move 'explode' items to maps
Function PF0L330()
   /* ***************************************************/
   /* *   this process will move all 'explode' items   **/
   /* *   from pf0lw02 record to the maps. explode     **/
   /* *   items are identified by the field pf0lwtyp   **/
   /* *   being = 1, 2, 4, or 5.  detail display will  **/
   /* *   scroll up and down the pf0lw02 w/s area.     **/
   /* *   the control of scrolling positioning will    **/
   /* *   be done by pf0kxxx.                          **/
   /* *   both the right side(pf0lm001) and the left   **/
   /* *   side(pf0lm002) of the display will be        **/
   /* *   loaded in this process. the user can shift   **/
   /* *   right and left using pf10 and pf11.          **/
   /* ***************************************************/
  ;
  PF0L340(); /* clear maps of previous data*/
  ;
  PFWREC.PFWSAVDX = PFWREC.PFWSUB1; /* save first w/s position*/
  ;
  PFWSUB2 = 1;
  ;
  while (PFWSUB2 < 11) /* browse through pf0lw02 and move all*/
    if (PF0LW02.PF0LWTYP[PFWSUB1] == "1" /* explode records to the maps*/
     || PF0LW02.PF0LWTYP[PFWSUB1] == "2" 
     || PF0LW02.PF0LWTYP[PFWSUB1] == "4" 
     || PF0LW02.PF0LWTYP[PFWSUB1] == "5")
      PF0LM001.PF0LMISD[PFWSUB2] = PF0LW02.PF0LWLIT[PFWSUB1];
      PF0LM002.PF0LMISD[PFWSUB2] = PF0LW02.PF0LWLIT[PFWSUB1];
      ;
      PF0LM001.PF0LMGSA[PFWSUB2] = PF0LW02.PF0LWC1[PFWSUB1];
      PF0LM001.PF0LMGSP[PFWSUB2] = PF0LW02.PF0LWC2[PFWSUB1];
      PF0LM001.PF0LMRTS[PFWSUB2] = PF0LW02.PF0LWC3[PFWSUB1];
      PF0LM001.PF0LMOTH[PFWSUB2] = PF0LW02.PF0LWC4[PFWSUB1];
      PF0LM001.PF0LMNS1[PFWSUB2] = PF0LW02.PF0LWC5[PFWSUB1];
      PF0LM001.PF0LMNP1[PFWSUB2] = PF0LW02.PF0LWC6[PFWSUB1];
      PF0LM001.PF0LMPC1[PFWSUB2] = PF0LW02.PF0LWC11[PFWSUB1];
      ;
      PF0LM002.PF0LMGSA[PFWSUB2] = PF0LW02.PF0LWC5[PFWSUB1];
      PF0LM002.PF0LMNS2[PFWSUB2] = PF0LW02.PF0LWC7[PFWSUB1];
      PF0LM002.PF0LMNP2[PFWSUB2] = PF0LW02.PF0LWC8[PFWSUB1];
      PF0LM002.PF0LMNS3[PFWSUB2] = PF0LW02.PF0LWC9[PFWSUB1];
      PF0LM002.PF0LMNP3[PFWSUB2] = PF0LW02.PF0LWC10[PFWSUB1];
      PF0LM002.PF0LMPC1[PFWSUB2] = PF0LW02.PF0LWC11[PFWSUB1];
      PF0LM002.PF0LMPC2[PFWSUB2] = PF0LW02.PF0LWC12[PFWSUB1];
      PFWSUB2 = PFWSUB2 + 1; /* bump index for maps*/
    end
    PFWSUB1 = PFWSUB1 + 1; /* bump w/s index*/
    if (PFWSUB1 > PFWLIMIT) /* if w/s end reached, end the routine*/
      PFWSUB2 = 13;
    end
  end
  ;
  PFWREC.PFWNXTDX = PFWREC.PFWSUB1; /* save next w/s position*/
end // end PF0L330

// t
Function PF0L340()
  ;
  PFWSUB2 = 1;
  ;
  while (PFWSUB2 < 11)
    PF0LM001.PF0LMISD[PFWSUB2] = " ";
    PF0LM002.PF0LMISD[PFWSUB2] = " ";
    PF0LM001.PF0LMGSA[PFWSUB2] = 0;
    PF0LM001.PF0LMGSP[PFWSUB2] = 0;
    PF0LM001.PF0LMRTS[PFWSUB2] = 0;
    PF0LM001.PF0LMOTH[PFWSUB2] = 0;
    PF0LM001.PF0LMNS1[PFWSUB2] = 0;
    PF0LM001.PF0LMNP1[PFWSUB2] = 0;
    PF0LM001.PF0LMPC1[PFWSUB2] = 0;
    PF0LM002.PF0LMGSA[PFWSUB2] = 0;
    PF0LM002.PF0LMNS2[PFWSUB2] = 0;
    PF0LM002.PF0LMNP2[PFWSUB2] = 0;
    PF0LM002.PF0LMNS3[PFWSUB2] = 0;
    PF0LM002.PF0LMNP3[PFWSUB2] = 0;
    PF0LM002.PF0LMPC1[PFWSUB2] = 0;
    PF0LM002.PF0LMPC2[PFWSUB2] = 0;
    PFWSUB2 = PFWSUB2 + 1;
  end
  ;
end // end PF0L340

// scroll backwards thru 'det'
Function PF0L350()
   /* *****************************************************/
   /* *  this routine is nearly identical to pf0l320.    **/
   /* *  the difference is that this routine will scroll **/
   /* *  backwards through the w/s area, pf0lw02, by     **/
   /* *  decrementing the storage and screen subscripts. **/
   /* *  if the w/s subscript reaches zero after being   **/
   /* *  decremented, it is set to 1 and the scroll      **/
   /* *  forward routine, pf0l320, is performed.         **/
   /* *****************************************************/
  ;
  if (PFWSUB1 < 1)
    converseLib.validationFailed(085);
    return;
  end
  ;
  PF0L340(); /* clear maps of previous data*/
  ;
  ;
  PFWREC.PFWNXTDX = PFWREC.PFWSUB1; /* save last w/s position*/
  ;
  PFWSUB2 = 10;
  ;
  while (PFWSUB2 > 0) /* browse backwards through pf0mw02 and move all*/
    if (PF0LW02.PF0LWTYP[PFWSUB1] == "1" /* detail records to the maps*/
     || PF0LW02.PF0LWTYP[PFWSUB1] == "2" 
     || PF0LW02.PF0LWTYP[PFWSUB1] == "3" 
     || PF0LW02.PF0LWTYP[PFWSUB1] == "5")
      PF0LM001.PF0LMISD[PFWSUB2] = PF0LW02.PF0LWLIT[PFWSUB1];
      PF0LM002.PF0LMISD[PFWSUB2] = PF0LW02.PF0LWLIT[PFWSUB1];
      ;
      PF0LM001.PF0LMGSA[PFWSUB2] = PF0LW02.PF0LWC1[PFWSUB1];
      PF0LM001.PF0LMGSP[PFWSUB2] = PF0LW02.PF0LWC2[PFWSUB1];
      PF0LM001.PF0LMRTS[PFWSUB2] = PF0LW02.PF0LWC3[PFWSUB1];
      PF0LM001.PF0LMOTH[PFWSUB2] = PF0LW02.PF0LWC4[PFWSUB1];
      PF0LM001.PF0LMNS1[PFWSUB2] = PF0LW02.PF0LWC5[PFWSUB1];
      PF0LM001.PF0LMNP1[PFWSUB2] = PF0LW02.PF0LWC6[PFWSUB1];
      PF0LM001.PF0LMPC1[PFWSUB2] = PF0LW02.PF0LWC11[PFWSUB1];
      ;
      PF0LM002.PF0LMGSA[PFWSUB2] = PF0LW02.PF0LWC5[PFWSUB1];
      PF0LM002.PF0LMNS2[PFWSUB2] = PF0LW02.PF0LWC7[PFWSUB1];
      PF0LM002.PF0LMNP2[PFWSUB2] = PF0LW02.PF0LWC8[PFWSUB1];
      PF0LM002.PF0LMNS3[PFWSUB2] = PF0LW02.PF0LWC9[PFWSUB1];
      PF0LM002.PF0LMNP3[PFWSUB2] = PF0LW02.PF0LWC10[PFWSUB1];
      PF0LM002.PF0LMPC1[PFWSUB2] = PF0LW02.PF0LWC11[PFWSUB1];
      PF0LM002.PF0LMPC2[PFWSUB2] = PF0LW02.PF0LWC12[PFWSUB1];
      PFWSUB2 = PFWSUB2 - 1; /* decrement index for maps*/
    end
    PFWSUB1 = PFWSUB1 - 1; /* decremennet w/s index*/
    if (PFWSUB1 <= 1) /* if w/s end reached,*/
      converseLib.validationFailed(085);
      PFWSUB1 = 1;
      PFWSUB2 = 1;
      PF0L320();
      return;
    end
  end
  ;
  PFWREC.PFWSAVDX = PFWREC.PFWSUB1; /* save first w/s index*/
end // end PF0L350

// scroll backwards thru 'exp'
Function PF0L360()
   /* *****************************************************/
   /* *  this routine is nearly identical to pf0l330.    **/
   /* *  the difference is that this routine will scroll **/
   /* *  backwards through the w/s area, pf0lw02, by     **/
   /* *  decrementing the storage and screen subscripts. **/
   /* *  if the w/s subscript reaches zero after being   **/
   /* *  decremented, it is set to 1 and the scroll      **/
   /* *  forward routine, pf0l330, is performed.         **/
   /* *****************************************************/
  ;
  if (PFWSUB1 < 1)
    converseLib.validationFailed(085);
    return;
  end
  ;
  PF0L340(); /* clear maps of previous data*/
  ;
  PFWREC.PFWNXTDX = PFWREC.PFWSUB1; /* save first w/s position*/
  ;
  PFWSUB2 = 10;
  ;
  while (PFWSUB2 > 0) /* browse backwards through pf0lw02 and move all*/
    if (PF0LW02.PF0LWTYP[PFWSUB1] == "1" /* explode records to the maps*/
     || PF0LW02.PF0LWTYP[PFWSUB1] == "2" 
     || PF0LW02.PF0LWTYP[PFWSUB1] == "4" 
     || PF0LW02.PF0LWTYP[PFWSUB1] == "5")
      PF0LM001.PF0LMISD[PFWSUB2] = PF0LW02.PF0LWLIT[PFWSUB1];
      PF0LM002.PF0LMISD[PFWSUB2] = PF0LW02.PF0LWLIT[PFWSUB1];
      ;
      PF0LM001.PF0LMGSA[PFWSUB2] = PF0LW02.PF0LWC1[PFWSUB1];
      PF0LM001.PF0LMGSP[PFWSUB2] = PF0LW02.PF0LWC2[PFWSUB1];
      PF0LM001.PF0LMRTS[PFWSUB2] = PF0LW02.PF0LWC3[PFWSUB1];
      PF0LM001.PF0LMOTH[PFWSUB2] = PF0LW02.PF0LWC4[PFWSUB1];
      PF0LM001.PF0LMNS1[PFWSUB2] = PF0LW02.PF0LWC5[PFWSUB1];
      PF0LM001.PF0LMNP1[PFWSUB2] = PF0LW02.PF0LWC6[PFWSUB1];
      PF0LM001.PF0LMPC1[PFWSUB2] = PF0LW02.PF0LWC11[PFWSUB1];
      ;
      PF0LM002.PF0LMGSA[PFWSUB2] = PF0LW02.PF0LWC5[PFWSUB1];
      PF0LM002.PF0LMNS2[PFWSUB2] = PF0LW02.PF0LWC7[PFWSUB1];
      PF0LM002.PF0LMNP2[PFWSUB2] = PF0LW02.PF0LWC8[PFWSUB1];
      PF0LM002.PF0LMNS3[PFWSUB2] = PF0LW02.PF0LWC9[PFWSUB1];
      PF0LM002.PF0LMNS3[PFWSUB2] = PF0LW02.PF0LWC10[PFWSUB1];
      PF0LM002.PF0LMPC1[PFWSUB2] = PF0LW02.PF0LWC11[PFWSUB1];
      PF0LM002.PF0LMPC2[PFWSUB2] = PF0LW02.PF0LWC12[PFWSUB1];
      PFWSUB2 = PFWSUB2 - 1; /* decrement index for maps*/
    end
    PFWSUB1 = PFWSUB1 - 1; /* decrement w/s index*/
    if (PFWSUB1 <= 1) /* if w/s end reached,*/
      converseLib.validationFailed(085);
      PFWSUB1 = 1;
      PFWSUB2 = 1;
      PF0L330();
      return;
    end
  end
  ;
  PFWREC.PFWSAVDX = PFWREC.PFWSUB1; /* save first w/s position*/
end // end PF0L360

//*** RECORD=PF0LW01 ****
// miscellaneous w/s area for pf0l application.
// ***********************
Record PF0LW01 type basicRecord
  10 PF0LWLT1 PF0LWLT1 ; 
    15 PF0LWDT1 PF0LWDT1 ; 
    15 PF0LWTP1 PF0LWTP1 ; 
  10 PF0LWCL1 PF0LWCL1 ; 
    15 PF0LWDT2 PF0LWDT2 ; 
    15 PF0LWF1 PF0LWF1 ; 
    15 PF0LWTP2 PF0LWTP2 ; 
  10 PF0LWCL2 PF0LWCL2 ; 
    15 PF0LWDT3 PF0LWDT3 ; 
    15 PF0LWF2 PF0LWF2 ; 
    15 PF0LWTP3 PF0LWTP3 ; 
  10 PF0LWCL3 PF0LWCL3 ; 
    15 PF0LWDT4 PF0LWDT4 ; 
    15 PF0LWF3 PF0LWF3 ; 
    15 PF0LWTP4 PF0LWTP4 ; 
  10 PF0LWABK PF0LWABK ; 
    15 PF0LWAB2 PF0LWAB2 ; 
  10 PF0LWSTL PF0LWSTL ; 
  10 PF0LWSTS PF0LWSTS ; 
  10 PF0LWDSP PF0LWDSP ; 
  10 PF0LWHDP PF0LWHDP ; 
  10 PF0LWLEF PF0LWLEF ; 
  10 PF0LWRIG PF0LWRIG ; 
  10 PF0LWPFK PF0LWPFK ; 
    15 PF0LWKY1 PF0LWKY1 ; 
    15 PF0LWDP1 PF0LWDP1 ; 
    15 PF0LWKY2 PF0LWKY2 ; 
    15 PF0LWDP2 PF0LWDP2 ; 
  10 PF0LWFLG PF0LWFLG ; 
  10 PF0LWAVA PF0LWAVA ; 
    15 PF0LWAV1 PF0LWAV1 ; 
    15 PF0LWAV2 PF0LWAV2 ; 
  10 PF0LWAVD PF0LWAVD ; 
    15 PF0LWAD1 PF0LWAD1 ; 
    15 PF0LWAD2 PF0LWAD2 ; 
  10 PF0LWNUM PF0LWNUM ; 
    15 PF0LWNM1 PF0LWNM1 ; 
    15 PF0LWNM2 PF0LWNM2 ; 
  10 PF0LWFL1 PF0LWFL1 ; 
    15 PF0LWCD1 PF0LWCD1 ; 
    15 PF0LWCD2 PF0LWCD2 ; 
    15 PF0LWCD3 PF0LWCD3 ; 
    15 PF0LWCD4 PF0LWCD4 ; 
    15 PF0LWCD5 PF0LWCD5 ; 
    15 PF0LWCD6 PF0LWCD6 ; 
    15 PF0LWCD7 PF0LWCD7 ; 
  10 PF0LWFL2 PF0LWFL2 ; 
    15 PF0LWCV1 PF0LWCV1 ; 
    15 PF0LWCV2 PF0LWCV2 ; 
    15 PF0LWCV3 PF0LWCV3 ; 
    15 PF0LWCV4 PF0LWCV4 ; 
    15 PF0LWCV5 PF0LWCV5 ; 
    15 PF0LWCV6 PF0LWCV6 ; 
    15 PF0LWCV7 PF0LWCV7 ; 
  10 PF0LWSTY PF0LWSTY ; 
    15 XGPCD XGPCD ; 
    15 PF0LWF4 PF0LWF4 ; 
    15 SY1STNBR SY1STNBR ; 
    15 PF0LWF5 PF0LWF5 ; 
    15 SY2CLRID SY2CLRID ; 
    15 PF0LWF6 PF0LWF6 ; 
    15 XDMCD XDMCD ; 
    15 PF0LWF7 PF0LWF7 ; 
    15 XQACD XQACD ; 
    15 PF0LWF8 PF0LWF8 ; 
    15 XLCCD XLCCD ; 
  10 PF0LWRN PF0LWRN ; 
    15 PF0LWRN1 PF0LWRN1 ; 
    15 PF0LWRV1 PF0LWRV1 ; 
    15 PF0LWRN2 PF0LWRN2 ; 
    15 PF0LWRV2 PF0LWRV2 ; 
    15 PF0LWRN3 PF0LWRN3 ; 
end // end PF0LW01

//*** RECORD=PF0LW02 ****
// this w/s area is used to store rows of summary information
// to be displayed in this application. the rows are identified
// by the field pf0lwtyp as follows :
//  value           summary row type
// -------          ----------------------
//    1             summary total item (net rev., etc.)
//    2             special summary total (dir sg&a, ind sg&a)
//    3             i/s grouped totals
//    4             i/s grouped items
//    5             i/s ungrouped items
// 
// MAINTENANCE LOG:
//  DATE     INIT     COMMENTS
// --------  ------   ----------
// 06/13/91  CVO      Increased group level entries on ws from
//                    200 to 500.
// ***********************
Record PF0LW02 type basicRecord
  5 PF0LWGRP PF0LWGRP [500] ; 
    10 YISCD YISCD ; 
    10 PF0LWLIT PF0LWLIT ; 
      15 PF0LWIND PF0LWIND ; 
      15 PF0LWABV PF0LWABV ; 
    10 PF0LWTYP PF0LWTYP ; 
    10 PF0LWC1 PF0LWC1 ; 
    10 PF0LWC2 PF0LWC2 ; 
    10 PF0LWC3 PF0LWC3 ; 
    10 PF0LWC4 PF0LWC4 ; 
    10 PF0LWC5 PF0LWC5 ; 
    10 PF0LWC6 PF0LWC6 ; 
    10 PF0LWC7 PF0LWC7 ; 
    10 PF0LWC8 PF0LWC8 ; 
    10 PF0LWC9 PF0LWC9 ; 
    10 PF0LWC10 PF0LWC10 ; 
    10 PF0LWC11 PF0LWC11 ; 
    10 PF0LWC12 PF0LWC12 ; 
end // end PF0LW02

// CHARACTER db2 abend key
DataItem PF0LWAB2 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// numeric db2 abend key
DataItem PF0LWABK num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// yis-ist-cls-abrv
DataItem PF0LWABV char(16)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. code
DataItem PF0LWAD1 char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. code literal
DataItem PF0LWAD2 char(12)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attribute literal
DataItem PF0LWAV1 char(8)  {
  align = right, fillCharacter = nullFill, inputRequired = no
}
end

// attribute char.' :'
DataItem PF0LWAV2 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attribute literal group
DataItem PF0LWAVA char(10)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. code val. literal
DataItem PF0LWAVD char(17)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dt/tp 1 grs shp amt
DataItem PF0LWC1 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp 3 net sales %
DataItem PF0LWC10 bin(4,1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp 2 pct comparison 1
DataItem PF0LWC11 bin(4,1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp 2 pct comparison 2
DataItem PF0LWC12 bin(4,1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp 1 grs shp %
DataItem PF0LWC2 bin(4,1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp 1 rts amt
DataItem PF0LWC3 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp 1 other amt
DataItem PF0LWC4 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp 1 net sales amt
DataItem PF0LWC5 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp 1 net sales %
DataItem PF0LWC6 bin(4,1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp 2 net sales amt
DataItem PF0LWC7 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp 2 net sales %
DataItem PF0LWC8 bin(4,1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dt/tp 3 net sales amt
DataItem PF0LWC9 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// attr. field 1
DataItem PF0LWCD1 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. field 2
DataItem PF0LWCD2 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. field 3
DataItem PF0LWCD3 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. field 4
DataItem PF0LWCD4 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. field 5
DataItem PF0LWCD5 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. field 6
DataItem PF0LWCD6 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. field 7
DataItem PF0LWCD7 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dt/tp pct. col. 1
DataItem PF0LWCL1 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dt/tp pct. col. 2
DataItem PF0LWCL2 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dt/tp pct. col. 3
DataItem PF0LWCL3 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. field 1
DataItem PF0LWCV1 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. field 2
DataItem PF0LWCV2 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. field 3
DataItem PF0LWCV3 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. field 4
DataItem PF0LWCV4 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. field 5
DataItem PF0LWCV5 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. field 6
DataItem PF0LWCV6 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. field 7
DataItem PF0LWCV7 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// display type-'sum,det,exp'
DataItem PF0LWDP1 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// display type-'sum,det,exp'
DataItem PF0LWDP2 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// display type - sum,det,exp
DataItem PF0LWDSP char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data type literal 1
DataItem PF0LWDT1 char(10)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data type code 1
DataItem PF0LWDT2 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data type code 2
DataItem PF0LWDT3 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data type code 3
DataItem PF0LWDT4 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler value ' '
DataItem PF0LWF1 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler value ' '
DataItem PF0LWF2 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler value ' '
DataItem PF0LWF3 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler-value '/'
DataItem PF0LWF4 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler-value '/'
DataItem PF0LWF5 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler-value '/'
DataItem PF0LWF6 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler-value '/'
DataItem PF0LWF7 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler-value '/'
DataItem PF0LWF8 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. values hold area
DataItem PF0LWFL1 char(28)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// attr. values hold area
DataItem PF0LWFL2 char(28)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// vsumry01 sequence flag
DataItem PF0LWFLG char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// gourp level
DataItem PF0LWGRP char(56)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// hold display type
DataItem PF0LWHDP char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// '*' or '#' or ' '
DataItem PF0LWIND char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pf key literal-value '18:'
DataItem PF0LWKY1 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pf key literal-value '19:'
DataItem PF0LWKY2 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// display left map
DataItem PF0LWLEF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// map i/s class literal
DataItem PF0LWLIT char(17)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dt/tp column literal 1
DataItem PF0LWLT1 char(20)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// numeric breakdown field
DataItem PF0LWNM1 num(8)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// numeric breakdown field
DataItem PF0LWNM2 num(5,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// numeric breakdown field
DataItem PF0LWNUM num(13,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// pf18, pf19 literal
DataItem PF0LWPFK char(13)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// display right map
DataItem PF0LWRIG char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

//  warning message
DataItem PF0LWRN char(76)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// warning literal 1
DataItem PF0LWRN1 char(23)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// warning literal 2
DataItem PF0LWRN2 char(20)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// warning literal 3
DataItem PF0LWRN3 char(17)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// warning attribute 1
DataItem PF0LWRV1 char(8)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// warning attribute 2
DataItem PF0LWRV2 char(8)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// hold level number
DataItem PF0LWSTL num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// hold sequence number
DataItem PF0LWSTS num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// product hold area
DataItem PF0LWSTY char(22)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// time period literal 1
DataItem PF0LWTP1 char(10)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// time period code 1
DataItem PF0LWTP2 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// time period code 2
DataItem PF0LWTP3 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// time period code 3
DataItem PF0LWTP4 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// table entry type(1,2,3,4,5)
DataItem PF0LWTYP char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

