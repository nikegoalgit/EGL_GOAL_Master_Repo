package av0l;
import av.common.*;
import corpcom1.*;
import corpcom2.*;
import corpcom3.*;
import corpcom4.*;
import corpcom5.*;
import corpcom6.*;
import corpcom7.*;
import corpx1.*;
import corpx2.*;
import corpy2.*;
import corpz3.*;
import fk.common.*;
import fy.common.*;
import ku.common.*;
import op.common.*;
import os.common.*;
import pc.common.*;
import pg.common.*;
import sy.common.*;
import ta.common.*;
//*** PROGRAM=AV0L ****
// This application allows a user to inquire and select product
// information to use to secure a substitution product.
// 
// The user may 'S'elect a product on the list screen, which
// transfers them to the detail screen basically showing all
// the sizes. the user may also 's'elect a product from the
// list screen and return to O/E with that product information
// to use as a substitute product.
// 
// No data may be modified in this application.
// 
// Paging is available. only 1 product may be selected and
// taken back to order entry.
// 
// The user may exit to any allowed application, via FAST PATH
// or PF key, at any time. The execption to this is if the
// application was entered from O/E, in that case they may
// xfer to AV0K to change selection criteria, but must in any
// event always return to Order Entry.
// 
// -------  --------  ------  ---------------------------------
// CONTROL    DATE     NAME   DESCRIPTION OF CHANGE
// -------  --------  ------  ---------------------------------
// PA030    01/15/90  MBLAIL  New application.
// e#001    06/06/90  MBLAIL  Changed default need date to end
//                            of sesn date for gpc 03 as
//                            requested by dguthr and cbean.
//          08/15/90  MADAMS  Fixed logic to handle color,
//                            product category, and gender/age
//                            wildcards.
//          08/16/90  MADAMS  Will now transfer back to AV0K if
//                            nothing is found in both the
//                            search of the mktg table or the
//                            criteria search.
//          08/21/90  MADAMS  Changed logic to not allow more
//                            than one substitute product to be
//                            selected when requesting a return
//                            to order processing.
//          08/23/90  dbruih  fixed to show viewed products
//                            when returning from detail
//                            display
//          08/23/90  dbruih  set map option and item fields
//                            underscore and darkened pf6
//                            option when not from order entry
//          08/23/90  dbruih  corrected routine to obtain
//                            wholesale and retail prices
//          08/23/90  MADAMS  Will now get color description
//                            from color table for overrides.
//          10/01/90  MADAMS  Will now allow overrides of the
//                            season from av0k.
//          10/22/90  MADAMS  corrected bug that wouldnt clear
//                            screen before filling with next
//                            screens information if the first
//                            screen was filled exactly from
//                            the marketing table search.
//          01/15/91  MADAMS  Made changes to program as
//                            follows:
//                             - remove criteria srch restart
//                             - 200 fetch maximum
//                             - open up color for footwear
//                             - add dim to map (hdr and dtl)
//                             - color description srch
//                             - color match for footwear
//                             - allow use of dimension and
//                               override
//                             - warehouse 51 for apparel
//                             - diff colors of orig - color
//                               desc in desc field for ftwr
//                             - open up life cycle
//          01/17/91  dbruih  added product category range
//                            to averec and move of values
//                            to these fields in av0ls50
//          02/20/91  RHETRI  Fixed AV0L000 call to S65 problem
//          07/22/91  madams  added some more logic to other
//                            colors of same product and mark-
//                            eting table displays to make them
//                            work more like the criteria, as
//                            far as what is displayed.
//                             - life cycle is now checked
//                             - color description is checked
//                             - several others also, but not
//                               all so the result is not re-
//                               stricted too much.
//          12/12/91  madams  removed references to season.
//          04/17/92  bantho  fixed size range & qty problem.
//                            also added check for allow new
//                            orders flag. bypass if = 'n'.
//          12/15/92  madams  changed order of catalog search.
//          03/12/93  DFRANC  Added PF17 processing.  Allows
//                            wildcarding of color, silhouette
//                            code, and wholesale price.
//          06/18/93  MSMIT2  REPLACE CALL TO SY1120 WITH
//                            PG1050.
//          05/01/97  IDICKI  Get Canada pricing if user is
//                            Canadian. See AV0LS03.
//          11/24/97  DBETTR  Y2KFIX
//                            CHANGES TO PROCS AVOL000,AV0LS26
//                            WORKING STORAGE RECORD AV0LW01
//                            added Y2K date fields
//                            ALL CHANGES IDENTIFIED BY
//                            Y2K BRACKETS
//          01/15/98  ddaugh  Deleted av0ls22 and changed
//                            av0l112 to remove call to av0ls22
//                            This was done to eliminate using
//                            an old table dfcty.vlast001 that
//                            is no longer used.
//          07/18/01  KKARLA  mODIFIED AV0LS112 TO AVOID ABEND
//                            WHEN SILH CODE IS SPACES.
// *********************
Program AV0L type textUIProgram //VAGen Info - main text program
  {
  includeReferencedFunctions = yes, allowUnqualifiedItemReferences = yes, 
  throwNrfEofExceptions = yes, handleHardIOErrors = no, V60ExceptionCompatibility = yes, 
  I4GLItemsNullable = no, textLiteralDefaultIsString = no, localSQLScope = yes, 
  msgTablePrefix = "AV00", inputRecord = COMMAREA, segmented = yes
  }

  // Data Declarations
  AV0LW00 AV0LW00; // record
  AV0LW01 AV0LW01; // record
  AV0LW02 AV0LW02; // record
  AV5REC AV5REC; // record
  AV6REC AV6REC; // record
  AV7REC AV7REC; // record
  AVAREC AVAREC; // record
  AVBREC AVBREC; // record
  AVCREC AVCREC; // record
  AVEREC AVEREC; // record
  AVFREC AVFREC; // record
  AVWREC AVWREC; // record
  COMMAREA COMMAREA ; // record
  KUMREC KUMREC; // record
  OSGREC OSGREC; // record
  PG2REC PG2REC; // record
  PG3REC PG3REC; // record
  SQLCA SQLCA; // record
  SY1REC SY1REC; // record
  SY2REC SY2REC; // record
  SY4REC SY4REC; // record
  SY5REC SY5REC; // record
  SYCREC SYCREC; // record
  SYNREC SYNREC; // record
  TA1REC TA1REC; // record
  TA5REC TA5REC; // record
  TA9REC TA9REC; // record
  TAEREC TAEREC; // record
  XX0XW01 XX0XW01; // record
  YSMREC YSMREC; // record

  // VAGen Info - items needed for migration
  VAGen_EZESYS char(8);
  VAGen_EZEREPLY num(1);
  VAGen_EZE_WAIT_TIME bin(9,2);
  VAGen_EZE_ITEMLEN int;

  // Use Declarations
  use XOTTBL {deleteAfterUse = yes}; // table
  use XSETBL {deleteAfterUse = yes}; // table
  use XSNTBL {deleteAfterUse = yes}; // table
  use XDMTBL {deleteAfterUse = yes}; // table
  use AV01TBL {deleteAfterUse = yes}; // table
  use AV0LM.AV0LM001 // form
   {
    pfKeyEquate = no
  };

  function main()
    // VAGen Info - initialization needed for migration
    VAGen_EZESYS = VGLib.getVAGSysType();
    XPAV001: XPAV001();
     /* ------------------------------------------------------------*/
     /* Initialize working storage and display storage areas.*/
     /* ------------------------------------------------------------*/

    set AV0LM001 initial; /* M001 input/output*/
    set AV0LW00 empty; /* Working storage*/
    set AV0LW01 empty; /* M001 display storage*/
    set AV0LW02 empty; /* working storage for table*/
    set SQLCA empty; /* SQL communication area*/
    set TAEREC empty; /* Error diagnosis information*/
    set TA1REC empty; /* Error diagnosis parameters*/
    set TA5REC empty; /* Temporary storage parameters*/
    set XX0XW01 empty; /* Date/time subroutine parameters*/


    AV0LW00.AV0LWSWD = "1"; /* Map to be displayed switch*/
    AV0LW00.AV0LWSWF = "Y"; /* Format the map switch*/
    AV0LW00.AV0LWSWR = "Y"; /* Request for data switch*/


     /* ------------------------------------------------------------*/
     /* Flow to converse the special initialization.*/
     /* ------------------------------------------------------------*/

    goto AV0L000; /* Converse the special initialization*/


    AV0L000: AV0L000();
    goto AV0L001;
    AV0L001: AV0L001();
     /* ------------------------------------------------------------*/
     /* Flow to converse the main process used to display a map.*/
     /* ------------------------------------------------------------*/

    goto AV0L001; /* Converse the main process*/


  end // end main
end // end AV0L

// Check the FROM application
Function AV0L000()
   /* ------------------------------------------------------------*/
   /* THE FOLLOWING SECTION OF CODE IS FOR TESTING PURPOSES.*/
   /* please do not remove, because at this time we can't trace*/
   /* from order processing to substitutions and this simulates*/
   /* the record being passed.*/
   /* ------------------------------------------------------------*/
   /* MOVE 'OP0H' TO COMMAREA.CAFROMAP;/* From application*/
   /* MOVE 'OP0H' TO OSGREC.XSRSYSID;  /* From application*/
   /* MOVE 'DEMO' TO OSGREC.XSRSUBID;  /* Sub id*/
   /* MOVE 602 TO OSGREC.XSRSQNBR;     /* Seq number*/
   /* MOVE 1 TO OSGREC.OSGPRSUB;       /* pointer*/

   /* MOVE 726670 TO OSGREC.KUCCOID;   /* company id*/
   /* MOVE 0 TO OSGREC.KUMSTRID;       /* STORE ID*/
   /* MOVE 000 TO OSGREC.XNXCD;        /* nike dept code*/
   /* MOVE 'RC' TO OSGREC.OP1ORDBY;    /* ordered by*/
   /* MOVE '03' TO OSGREC.XGPCD;       /* general product class*/
   /* MOVE '1AB0' TO OSGREC.SY1STNBR;/* style number*/
   /* MOVE '010' TO OSGREC.SY2CLRID;    /* color code*/
   /* MOVE '00' TO OSGREC.XDMCD;       /* dim code*/
   /* MOVE '00' TO OSGREC.XOWCD;       /* owner group*/
   /* MOVE '   ' TO OSGREC.XSDCD;      /* spec code*/
   /* MOVE '   ' TO OSGREC.XSACD;      /* shade code*/
   /* MOVE '  ' TO OSGREC.XPGCD;       /* pkg. type*/
   /* MOVE '  ' TO OSGREC.XUMCD;       /* unit of measure*/
   /* MOVE '  ' TO OSGREC.XLCCD;       /* life cycle code*/
   /* MOVE '  ' TO OSGREC.XQACD;       /* quality code*/
   /* MOVE '  ' TO OSGREC.XOTCD;       /* order type code ftw a/o*/
   /* MOVE '  ' TO OSGREC.XOTCD;       /* order type code ftw a/o*/
   /* MOVE '  ' TO OSGREC.XOTCD;       /* order type code aprl a/o*/
   /* MOVE 00000000 TO OSGREC.OP1CUNDT;/* cust need date*/
   /* MOVE 20000131 TO OSGREC.OP1CUNDT;/* Need dt not furnished*/
   /* MOVE '  ' TO OSGREC.XWHCD;       /* warehouse*/
   /* MOVE 00 TO OSGREC.OPWRQSZF;      /* ftwr size - first*/
   /* MOVE 00 TO OSGREC.OPWRQSZL;      /* ftwr size - last*/
   /* MOVE 3 TO OSGREC.OPWRQSZF;       /* aprl size - first*/
   /* MOVE 6 TO OSGREC.OPWRQSZL;       /* aprl size - last*/
   /* MOVE OSGREC.OSGGROUP TO COMMAREA.CAUSERA;*/
   /* ------------------------------------------------------------*/
    /* **************** END OF TEST ********************/
   /* ------------------------------------------------------------*/
   /* ------------------------------------------------------------*/
   /* If entered by fast path from other than an allowed appl.*/
    /* exit to av0k, the criteria screen, so that valid data*/
    /* may be entered and a search conducted.*/
   /* ------------------------------------------------------------*/


  if (COMMAREA.CAFROMAP == "OP0I" /* From allowed application*/
   || COMMAREA.CAFROMAP == "OP0H" /* From allowed application*/
   || COMMAREA.CAFROMAP == "AV0K" /* From allowed application*/
   || COMMAREA.CAFROMAP == "AV0Q" /* From allowed application*/
   || COMMAREA.CAFROMAP == "AV0R" /* From allowed application*/
   || COMMAREA.CAFROMAP == "AV0L" /* From allowed application*/
   || COMMAREA.CAFROMAP == "AV0A" /* From allowed application*/
   || COMMAREA.CAFROMAP == "AV0I" /* From allowed application*/
   || COMMAREA.CAFROMAP == "AV0P") /* From allowed application*/

    /* NEXT SENTENCE*/

  else

    COMMAREA.CATOAP = "AV0K"; /* Go to criteria application*/
    set AVWREC empty; /* Clear system record*/

    XPAV002(); /* Exit to AV0K*/

  end


   /* ------------------------------------------------------------*/
   /* If fast path from av0a, av0i or av0p check that gpc and*/
    /* style are provided, else exit to av0k.*/
   /* ------------------------------------------------------------*/

  if (COMMAREA.CAFROMAP == "AV0A" /* From allowed application*/
   || COMMAREA.CAFROMAP == "AV0I" /* From allowed application*/
   || COMMAREA.CAFROMAP == "AV0P") /* From allowed application*/

    AVWREC.CAUSERA = COMMAREA.CAUSERA;

    AVWREC.XSRSYSID = COMMAREA.CAFROMAP; /* Save from app. id.*/

    if (AVWREC.XGPCD > "  "
     && AVWREC.SY1STNBR > "      ")

      /* NEXT SENTENCE*/

    else

      COMMAREA.CATOAP = "AV0K"; /* Go to criteria application*/
      set AVWREC empty; /* Clear system record*/

      XPAV002(); /* Exit to AV0K*/

    end
  end


   /* ------------------------------------------------------------*/
   /* Set first time thru flag if not returning from detail*/
     /* screen. this is used to skip the current page reset*/
     /* routine in av0l116.*/
   /* ------------------------------------------------------------*/

  if (COMMAREA.CAFROMAP == "AV0Q" /* From footwear detail appl.*/
   || COMMAREA.CAFROMAP == "AV0R") /* Or from apparel detail appl.*/

    AV0LW00.AV0LWFTF = "N"; /* Turn off first time flag.*/

  else

    AV0LW00.AV0LWFTF = "Y"; /* Turn on first time flag.*/

  end


   /* ------------------------------------------------------------*/
   /* Determine whether control came from order entry*/
   /* if so:   set order entry flag to 'y'*/
            /* set new product flag to 'y'*/
            /* move osgrec data to avwrec*/
            /* get customer heading data*/
            /* move customer heading data to avwrec*/
            /* get date routine*/
   /* ------------------------------------------------------------*/


  if (COMMAREA.CAFROMAP == "OP0I" /* From allowed application*/
   || COMMAREA.CAFROMAP == "OP0H") /* From allowed application*/

    OSGREC.OSGGROUP = COMMAREA.CAUSERA;

    AVWREC.OSGGROUP = OSGREC.OSGGROUP; /* Group level save*/

    AVWREC.AVWORDFL = "Y"; /* Set from order entry flag*/

    AVWREC.XSRSYSID = OSGREC.XSRSYSID; /* Order entry application*/
    AVWREC.XSRSUBID = OSGREC.XSRSUBID; /* Order entry key*/
    AVWREC.XSRSQNBR = OSGREC.XSRSQNBR; /* Order entry key*/
    AVWREC.OSGPRSUB = OSGREC.OSGPRSUB; /* Order entry key*/

  end


  if (COMMAREA.CAFROMAP == "OP0I" /* From order entry application*/
   || COMMAREA.CAFROMAP == "OP0H") /* From order entry applicagion*/

    AVWREC.KUCCOID = OSGREC.KUCCOID; /* company id*/
    AVWREC.KUMSTRID = OSGREC.KUMSTRID; /* store id*/
    AVWREC.XNXCD = OSGREC.XNXCD; /* nike dept code*/
    AVWREC.OP1ORDBY = OSGREC.OP1ORDBY; /* ordered by*/
    AVWREC.XGPCD = OSGREC.XGPCD; /* general product class*/
    AVWREC.SY1STNBR = OSGREC.SY1STNBR; /* style number*/
    AVWREC.SY2CLRID = OSGREC.SY2CLRID; /* color code*/
    AVWREC.XDMCD = OSGREC.XDMCD; /* dim code*/
    AVWREC.XOWCD = OSGREC.XOWCD; /* owner group code*/
    AVWREC.XSDCD = OSGREC.XSDCD; /* spec difference*/
    AVWREC.XSACD = OSGREC.XSACD; /* shade code*/
    AVWREC.XPGCD = OSGREC.XPGCD; /* pkg. type code*/
    AVWREC.XUMCD = OSGREC.XUMCD; /* unit of measure*/
    AVWREC.XLCCD = OSGREC.XLCCD; /* life cycle code*/
    AVWREC.XQACD = OSGREC.XQACD; /* quality code*/
    AVWREC.XOTCD = OSGREC.XOTCD; /* order type code*/
    AVWREC.OP1CUNDT = OSGREC.OP1CUNDT; /* cust need date*/
    AVWREC.XWHCD[1] = OSGREC.XWHCD; /* Original warehouse*/
    AVWREC.XWHCD[2] = "* "; /* Wildcard warehouse*/
    AVWREC.OPWRQSZF = OSGREC.OPWRQSZF; /* requested size - first*/
    AVWREC.OPWRQSZL = OSGREC.OPWRQSZL; /* requested size - last*/


    AV0LS01(); /* get customer heading data*/


    AVWREC.KUMSTRNM = KUMREC.KUMSTRNM; /* store name*/
    AVWREC.KUMCITYS = KUMREC.KUMCITYS; /* customer city*/
    AVWREC.KUMXSTCD = KUMREC.KUMXSTCD; /* customer state*/

  end


  if (COMMAREA.CAFROMAP == "AV0Q" /* From footwear detail*/
   || COMMAREA.CAFROMAP == "AV0R") /* From apparel detail*/

    AV0LW00.AV0LWSWR = "N"; /* Turn off request for data*/

  end


   /* ------------------------------------------------------------*/
   /* Format ezedte into yyyymmdd format.*/
   /* ------------------------------------------------------------*/

  XX0XS01(); /* Get date routine*/


   /* ------------------------------------------------------------*/
   /* Check if any default codes needed.*/
   /* ------------------------------------------------------------*/


  AV0LS76(); /* Plug in default codes*/



   /* ------------------------------------------------------------*/
   /* Check if warehouse furnished.*/
   /* ------------------------------------------------------------*/


  if (AVWREC.XWHCD[2] > "  ") /* Got override warehouse*/

    /* NEXT SENTENCE*/

  else

    if (AVWREC.XWHCD[1] > "  ") /* Got default warehouse*/

      /* NEXT SENTENCE*/

    else

      AVWREC.XWHCD[2] = "* "; /* Use wildcard whse*/

    end
  end


   /* ------------------------------------------------------------*/
   /* Check if last code furnished for footwear.*/
   /* ------------------------------------------------------------*/

  if (AVWREC.XGPCD == "02") /* For footwear product*/
    if (AVWREC.XLTCD[2] > "  ") /* Got override last code*/

      /* NEXT SENTENCE*/

    else

      if (AVWREC.XLTCD[1] > "  ") /* Got default last code*/

        /* NEXT SENTENCE*/

      else

        if (AVWREC.XLTCD[1] == "  ") /* Got NO last code*/

          AVWREC.XLTCD[1] = "* "; /* Use wildcard last code*/

        end
      end
    end
  end

   /* ------------------------------------------------------------*/
   /* Reset new product flag which may have been set to y in av0k*/
   /* ------------------------------------------------------------*/

  AVWREC.AVWNWPRD = "N"; /* Reset new product flag*/

   /* ------------------------------------------------------------*/
   /* If size furnished, get external size descriptions, else*/
   /* get defaults.*/
   /* ------------------------------------------------------------*/
  if (AVWREC.AVWRQSZF > 0
   || AVWREC.OPWRQSZF > 0)

   /* ------------------------------------------------------------*/
    /* get size scale record*/
   /* ------------------------------------------------------------*/

    if (AVWREC.XGPCD > " "    /* If GPC passed*/
     && AVWREC.SY1STNBR > " " /* and style passed*/
     && AVWREC.XDMCD > " ")   /* and dim passed*/
      if (AVWREC.SY2CLRID[1] > "  ") /* If color passed*/
        set PG3REC empty;
        PG3REC.XGPCD = AVWREC.XGPCD;
        PG3REC.SY1STNBR = AVWREC.SY1STNBR;
        PG3REC.SY2CLRID = AVWREC.SY2CLRID[1];
        PG3REC.XDMCD = AVWREC.XDMCD[1];

        PG3REC.PG3RETCD = " "; /* clear return code field*/
        PG3REC.XQACD = "**"; /* Use first quality*/
        PG3REC.PG3FUNCD = "PC"; /* All valid sizes*/
        PG3REC.PG3DATFM = "N"; /* NOT Compressed sizes*/

   /* ---------------------------------------------------------*/
    /* call pg1050*/
   /* ---------------------------------------------------------*/

        try
          call "PG1050" (SQLCA, PG3REC) {isNoRefresh = yes, isExternal = yes};
        end /* get size record*/

        if (sysVar.errorCode == "00000000" /* if no errors found*/
         && PG3REC.PG3RETCD == "00")      

          if (AVWREC.AVWRQSZF > 0)
            if (AVWREC.AVWRQSZF in PG3REC.SY5SZID)
              AVWREC.AVWOREXF = PG3REC.SY4IDDSC[sysVar.arrayIndex];
              AV0LW00.AV0LWORF = PG3REC.SY4IDDSC[sysVar.arrayIndex];
            end
          else
            if (AVWREC.OPWRQSZF in PG3REC.SY5SZID)
              AVWREC.AVWOREXF = PG3REC.SY4IDDSC[sysVar.arrayIndex];
              AV0LW00.AV0LWORF = PG3REC.SY4IDDSC[sysVar.arrayIndex];
            end
          end
          if (AVWREC.AVWRQSZL > 0)
            if (AVWREC.AVWRQSZL in PG3REC.SY5SZID)
              AVWREC.AVWOREXL = PG3REC.SY4IDDSC[sysVar.arrayIndex];
              AV0LW00.AV0LWORF = PG3REC.SY4IDDSC[sysVar.arrayIndex];
            end
          else
            if (AVWREC.OPWRQSZL in PG3REC.SY5SZID)
              AVWREC.AVWOREXL = PG3REC.SY4IDDSC[sysVar.arrayIndex];
              AV0LW00.AV0LWORF = PG3REC.SY4IDDSC[sysVar.arrayIndex];
            end
          end

        else

     /* ------------------------------------------------------------*/
      /* If data not available, post an error message and return.*/
      /* Otherwise, indicate that a system error has occurred.*/
     /* ------------------------------------------------------------*/

          if (sysVar.errorCode == "00000000" /* Call successful*/
           && PG3REC.PG3RETCD == "09")       /* and resource not available*/

            TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
            TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

            TA1REC.TA1FUNC = "POST"; /* Termination function*/
            TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
            TA1REC.TA1DBASE = "DPRODG  "; /* Data base name*/
            TA1REC.TA1TBLVU = "VSYCLR01"; /* Table view name*/
            TA1REC.TA1LOC = "AV0L000";
            TA1REC.TA1TBLKE = PG3REC.PG3KEY; /* Table key*/

            call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes};
                                   /* Error diagnosis routine*/

          else

            if (sysVar.errorCode == "00000000" /* Call successful*/
             && PG3REC.PG3RETCD == "99")       /* and negative SQL error*/

              TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
              TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

              TA1REC.TA1FUNC = "RETN"; /* Termination function*/
              TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
              TA1REC.TA1DBASE = "DPRODG  "; /* Data base name*/
              TA1REC.TA1TBLVU = "VSYCLR01"; /* Table view name*/
              TA1REC.TA1TBLKE = PG3REC.PG3KEY; /* Table key*/
              TA1REC.TA1LOC = "AV0L000";

              call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

            else

              TAEREC.TAEDESC1 = sysVar.errorCode; /* CSP return code*/
              TAEREC.TAEDESC2 = PG3REC.PG3GROUP;
                                   /* Subroutine parameters*/

              TA1REC.TA1FUNC = "RETN"; /* Termination function*/
              TA1REC.TA1TYPE = "APPL"; /* Type of error*/
              TA1REC.TA1LOC = "AV0L000";

              call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

            end
          end
        end
      end
    end


   /* ------------------------------------------------------------*/
  else

    if (AVWREC.XGPCD > " "    /* If GPC passed*/
     && AVWREC.SY1STNBR > " " /* and style passed*/
     && AVWREC.XDMCD > " ")   /* and dim passed*/
      if (AVWREC.SY2CLRID[1] > "  ") /* If color passed*/

        set PG3REC empty; /* Size translation record*/

        PG3REC.XGPCD = AVWREC.XGPCD; /* GPC*/
        PG3REC.SY1STNBR = AVWREC.SY1STNBR; /* STYLE*/
        PG3REC.SY2CLRID = AVWREC.SY2CLRID[1]; /* color*/
        PG3REC.XDMCD = AVWREC.XDMCD; /* DIM*/

        PG3REC.XQACD = "**"; /* Quality*/
        PG3REC.PG3FUNCD = "PC"; /* Function code*/
        PG3REC.PG3DATFM = "C"; /* Compression switch*/

        AV0LS65(); /* call PG1050*/

   /* ------------------------------------------------------------*/
    /* save external size descriptions for later use.*/
   /* ------------------------------------------------------------*/
        AV0LW00.AV0LWORF = AVWREC.AVWSZFD;
        AV0LW00.AV0LWORL = AVWREC.AVWSZLD;

      end
    end
  end

   /* ------------------------------------------------------------*/
   /* save external size descriptions for later use.*/
   /* ------------------------------------------------------------*/

  if (AVWREC.AVWOREXF > " "
   && AVWREC.AVWOREXL > " ")
    AV0LW00.AV0LWORF = AVWREC.AVWOREXF;
    AV0LW00.AV0LWORL = AVWREC.AVWOREXL;
  else
    AV0LW00.AV0LWORF = AVWREC.AVWSZFD;
    AV0LW00.AV0LWORL = AVWREC.AVWSZLD;
  end

   /* ------------------------------------------------------------*/
   /* Purge any existing pages from the temporary storage queue.*/
   /* ------------------------------------------------------------*/

  if (COMMAREA.CAFROMAP == "AV0Q" /* If from footwear detail*/
   || COMMAREA.CAFROMAP == "AV0R") /* If from apparel detail*/

    /* NEXT SENTENCE*/
  else

    AV0L115(); /* Purge any temporary storage*/
  end

   /* ------------------------------------------------------------*/
   /* Restore criteria search records from avwrec,*/
     /* and the temporary storage data to av0lw00.*/
   /* ------------------------------------------------------------*/

  set AVCREC empty;
  if (COMMAREA.CAFROMAP == "AV0Q" /* Returning from footwear detail appl*/
   || COMMAREA.CAFROMAP == "AV0R") /* Returning from apparel detail appl.*/

    AVBREC.AVBGPR = AVWREC.AVWBREC; /* AVBREC*/

    AVCREC.AVCGPR = AVWREC.AVWCREC; /* AVCREC*/

    AVEREC.AVEGPR = AVWREC.AVWEREC; /* AVEREC*/

    AVFREC.AVFGPR = AVWREC.AVWFREC; /* AVFREC*/

    AV0LW00.XXXTSLEN = AVWREC.XXXTSLEN; /* Temp. stg. length*/
    AV0LW00.XXXTSPAG = AVWREC.XXXTSPAG; /* Current page nbr*/
    AV0LW00.TA5TSQIX = AVWREC.TA5TSQIX; /* Max page number*/

  end


   /* ------------------------------------------------------------*/
   /* Get current date plus 30 days based on 6 day work week.*/
   /* ------------------------------------------------------------*/

  AV0LS29(); /* Get current date + 30 days*/


   /* ------------------------------------------------------------*/
   /* If no need date use the current date.*/
   /* ------------------------------------------------------------*/


  if (AVWREC.OP1CUNDT < 1) /* Need dt not furnished*/

    AV0LW00.AV0LWNDT = XX0XW01.XX0XWDAT; /* Use current date*/
    AVWREC.OP1CUNDT = XX0XW01.XX0XWDAT; /* Use current date*/

  else

    AV0LW00.AV0LWNDT = AVWREC.OP1CUNDT; /* Need dt to work*/

  end

   /* ---------------------------------------------------------*/
     /* If this is for gpc 03 the date used to calculate*/
     /* availability is set to the end of the month following*/
     /* the need date month.*/
   /* ---------------------------------------------------------*/
  if (AVWREC.XGPCD == "03") /* If apparel product*/

    AV0LW00.AV0LWNDD = 99; /* calc date day*/
    AV0LW00.AV0LWNMM = AV0LW00.AV0LWNMM + 1; /* increment month*/

  /* -------------------- Y2K OUT BEGIN -----------/**/
    /* IF AV0LW00.AV0LWNMM GT 12;*/
     /* AV0LW00.AV0LWNYY = AV0LW00.AV0LWNYY + 1;/* rolls into next yr*/
     /* MOVE 1 TO AV0LW00.AV0LWNMM;  /* set month*/
    /* END;*/
  /* -------------------- Y2K OUT END -------------/**/

  /* --------------------- Y2K IN BEGIN -----------/**/
    if (AV0LW00.AV0LWNMM > 12)
      if (AV0LW00.AV0LWNYY == 99)
        AV0LW00.AV0LWNYY = 0; /* set year*/
        AV0LW00.AV0LWNCC = 20; /* set century*/
      else
        AV0LW00.AV0LWNYY = AV0LW00.AV0LWNYY + 1; /* rolls into next yr*/
      end
      AV0LW00.AV0LWNMM = 1; /* set month*/
    end
  /* --------------------- Y2K IN END -------------/**/
  end

   /* ------------------------------------------------------------*/
   /* Check for override from size for the range starting point.*/
   /* ------------------------------------------------------------*/

  if (AVWREC.AVWRQSZF > 0) /* Got override from size*/

    AV0LW00.AV0LWSZF = AVWREC.AVWRQSZF; /* move to work area*/
    AVWREC.AVWRHSZF = AVWREC.AVWRQSZF; /* move to work area*/

  else

    AV0LW00.AV0LWSZF = AVWREC.OPWRQSZF; /* move to work area*/
    AVWREC.AVWRHSZF = AVWREC.OPWRQSZF; /* move to work area*/

  end

   /* ------------------------------------------------------------*/
   /* Check for override to size for the range ending point.*/
   /* ------------------------------------------------------------*/

  if (AVWREC.AVWRQSZL > 0) /* Got override to size*/

    AV0LW00.AV0LWSZL = AVWREC.AVWRQSZL; /* move to work area*/
    AVWREC.AVWRHSZL = AVWREC.AVWRQSZL; /* move to hold area*/

  else

    AV0LW00.AV0LWSZL = AVWREC.OPWRQSZL; /* move to work area*/
    AVWREC.AVWRHSZL = AVWREC.OPWRQSZL; /* move to hold area*/

  end


   /* ------------------------------------------------------------*/
   /* Determine current season and year for catalog purposes.*/
   /* ------------------------------------------------------------*/
  if (AVWREC.XGPCD == "02") /* For footwear product*/
    AV0LW00.AV0LWCDY = AV0LW00.AV0LWDY1; /* move year to curr*/
    AV0LW00.AV0LWNDY = AV0LW00.AV0LWDY1; /* move year to next*/
    if (AV0LW00.AV0LWDM1 == 12
     || AV0LW00.AV0LWDM1 < 6)
      AV0LW00.AV0LWCSN = "SP"; /* move spring to search sesn*/
      AV0LW00.AV0LWNSN = "FA"; /* move fall to next sesn srch*/
      if (AV0LW00.AV0LWDM1 == 12)

  /* --------------------- Y2K OUT BEGIN -------/**/
        /* AV0LW00.AV0LWCDY = AV0LW00.AV0LWCDY + 1;/* increment year*/
        /* AV0LW00.AV0LWNDY = AV0LW00.AV0LWNDY + 1;/* increment year*/
  /* --------------------- Y2K OUT END   ----------/**/

  /* --------------------- Y2K IN BEGIN -----------/**/
        if (AV0LW00.AV0LWNYY == 99)
          AV0LW00.AV0LWCDY = 0; /* set year*/
          AV0LW00.AV0LWNDY = 0; /* set year*/
        else
          AV0LW00.AV0LWCDY = AV0LW00.AV0LWCDY + 1; /* increment year*/
          AV0LW00.AV0LWNDY = AV0LW00.AV0LWNDY + 1; /* rolls into next yr*/
        end
  /* --------------------- Y2K IN END -------------/**/

      end
    else
      AV0LW00.AV0LWCSN = "FA"; /* move fall to search sesn*/
      AV0LW00.AV0LWNSN = "SP"; /* move spring to next sesn srch*/

  /* --------------------- Y2K IN BEGIN -----------/**/
      if (AV0LW00.AV0LWNDY == 99)
        AV0LW00.AV0LWNDY = 0; /* set year*/
      else
        AV0LW00.AV0LWNDY = AV0LW00.AV0LWNDY + 1; /* increment year*/
      end
  /* --------------------- Y2K IN END -------------/**/

  /* --------------------- Y2K OUT BEGIN ----------/**/
      /* AV0LW00.AV0LWNDY = AV0LW00.AV0LWNDY + 1;/* increment year*/
  /* --------------------- Y2K OUT END ------------/**/

    end
  else
    sysVar.arrayIndex = 1;

    while (XSNTBL.XSECD[sysVar.arrayIndex] != "99") /* loop until end*/
      if (AV0LW00.AV0LWCSN == "  ") /* if still empty*/
        if (XSNTBL.XSNBDT[sysVar.arrayIndex] > 0                 /* no footwear seasons allowed*/
         && XSNTBL.XSNBDT[sysVar.arrayIndex] <= AV0LW00.AV0LWDT1 /* le todays date*/
         && XSNTBL.XSNXDT[sysVar.arrayIndex] >=                  
        AV0LW00.AV0LWDT1)                                        /* ge todays date*/
          AV0LW00.AV0LWSCT = XSNTBL.XSNABRV[sysVar.arrayIndex]; /* curr sesn*/
        end
      end
      sysVar.arrayIndex = sysVar.arrayIndex + 1; /* increment subscript*/
    end
    AV0LW00.AV0LWNCT = AV0LW00.AV0LWSCT; /* init next sesn with curr*/
    if (AV0LW00.AV0LWNSN == "SP")
      AV0LW00.AV0LWNSN = "FA"; /* move spring to next sesn srch*/
    else
      if (AV0LW00.AV0LWNSN == "FA")
        AV0LW00.AV0LWNSN = "HO"; /* move spring to next sesn srch*/
      else
        if (AV0LW00.AV0LWNSN == "HO")
          AV0LW00.AV0LWNSN = "SP"; /* move spring to next sesn srch*/

  /* --------------------- Y2K IN BEGIN -----------/**/
          if (AV0LW00.AV0LWNDY == 99)
            AV0LW00.AV0LWNDY = 0; /* set year*/
          else
            AV0LW00.AV0LWNDY = AV0LW00.AV0LWNDY + 1; /* increment year*/
          end
  /* --------------------- Y2K IN END -------------/**/

  /* --------------------- Y2K OUT BEGIN ----------/**/
          /* AV0LW00.AV0LWNDY = AV0LW00.AV0LWNDY + 1;/* increment year*/
  /* --------------------- Y2K OUT END ------------/**/

        end
      end
    end
  end

end // end AV0L000

// Main process to display a map
Function AV0L001()
   /* ------------------------------------------------------------*/
   /* This is the main process used to display a map.  Processing*/
   /* always returns to the top of this process and falls through*/
   /* subordinate processes until an error is found or a valid*/
   /* request is processed.  Processing sequence is as follows:*/

   /* 1) Display the map (av0lm001).*/

   /* In all subordinate processes, "EZEFLO" is used to exit to*/
   /* redisplay the map when an error is found.  This is done to*/
   /* minimize the coding effort required to skip subsequent*/
   /* processing under error conditions.*/
   /* ------------------------------------------------------------*/

  if (AV0LW00.AV0LWSWD == "1") /* Map 1 was requested*/

    AV0L100(); /* Display map 1 (list/detail)*/

  else

    /* ------------------------------------------------------------*/
     /* Write the error to the Error Diagnosis Reporting Facility.*/
    /* ------------------------------------------------------------*/

    AVWREC.XXXMODID = "001"; /* Module identification*/
    AVWREC.XXXMSGNO = "76"; /* Indicate system error*/

    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    TA1REC.TA1TYPE = "APPL"; /* Type of error*/
    TA1REC.TA1LOC = "INVALID MAP NUMBER WAS REQUESTED";
    TA1REC.TA1MAPNO = AV0LW00.AV0LWSWD; /* Map number*/
    TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
    TA1REC.TA1PGMNO = AVWREC.XXXMODID; /* Program number*/

    call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

    /* ------------------------------------------------------------*/
     /* Exit to display the application system menu.*/
    /* ------------------------------------------------------------*/

    COMMAREA.CATOAP = "AV0L"; /* TO application*/

    XPAV002(); /* Exit to another application*/

    /* ------------------------------------------------------------*/
     /* Abnormally terminate the transaction if the exit failed.*/
    /* ------------------------------------------------------------*/

    TA1REC.TA1FUNC = "ABND"; /* Termination function*/

    call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/


  end


end // end AV0L001

// Driver for av0lm001
Function AV0L100()
   /* ------------------------------------------------------------*/
   /* Processing sequence is as follows:*/

   /* 1) Obtain the data to display.*/
   /* 2) Format the map output area and display the map.*/
   /* 3) Check the attention identifier used to respond.*/
   /* 4) Reset highlighted fields to normal intensity.*/
   /* 5) Verify the data that was entered.*/
   /* 6) Process a valid input request.*/

   /* In all subordinate processes, "EZEFLO" is used to exit to*/
   /* redisplay the map when an error is found.  This is done to*/
   /* minimize the coding effort required to skip subsequent*/
   /* processing under error conditions.*/
   /* ------------------------------------------------------------*/

  AV0L110(); /* Obtain the data to display*/

  AV0L120(); /* Format and display the map*/

  AV0L130(); /* Check attention identifier*/

  AV0L140(); /* Reset fields to normal intensity*/

  AV0L150(); /* Verify the entered data*/

  AV0L160(); /* Process valid input request*/


end // end AV0L100

// Obtain the data to display
Function AV0L110()
   /* ------------------------------------------------------------*/
   /* If data was not requested or an error was found, return to*/
   /* the previous process.*/
   /* ------------------------------------------------------------*/

  if (AV0LW00.AV0LWSWR != "Y" /* Data was not requested*/
   || converseVar.validationMsgNum != 0) /* or an error was found*/

    return; /* Return to previous process*/

  end


   /* ------------------------------------------------------------*/
   /* Establish the temporary storage queue page length.*/
   /* ------------------------------------------------------------*/

  AV0LW00.XXXTSLEN = 926; /* Temporary storage page length*/


   /* ------------------------------------------------------------*/
   /* If no message to display, reset the desired page number*/
   /* ------------------------------------------------------------*/

  if (AVWREC.XXXMSGNO == 0) /* No message to display*/

    AV0LW00.XXXTSPAG = 1; /* Desired page number*/

  end /* No message to display*/


   /* ------------------------------------------------------------*/
    /* Do initial lookups and search of marketing table.*/
    /* Also load table to check possible duplicate products*/
    /* from the criteria search against.*/
   /* ------------------------------------------------------------*/


  AV0L111(); /* Do initial lookups and search*/


  AV0LW00.AV0LWIXL = 1; /* Set subscript to load mkt/style tbl*/

  while (AV0LW00.AV0LWIXL <= 31) /* While within subscript range*/

    AVWREC.AVASBSTY[AV0LWIXL] = "000000"; /* Initialize mkt table*/

    AV0LW00.AV0LWIXL = AV0LW00.AV0LWIXL + 1; /* Increment subscript*/

  end


  AV0LW00.AV0LWIXL = 1; /* Set subscript to load mkt/style tbl*/

  AV0LW00.AV0LWSWC = "N"; /* End of cursor switch*/

  AV0LS04(); /* Select set and open cursor*/

  AV0LS05(); /* Fetch next row in vsubsy01*/

  while (AV0LW00.AV0LWSWC == "N" /* Until end of vsubsy01*/
   && AV0LW00.AV0LWIXL <= 31) /* While within subscript range*/

    AVWREC.AVASBSTY[AV0LWIXL] = AVAREC.AVASBSTY; /* Load product*/

    AV0LW00.AV0LWIXL = AV0LW00.AV0LWIXL + 1; /* Increment subscript*/

    AV0LS05(); /* Fetch next row in vsubsy01*/

  end


  AV0LS30(); /* Close cursor for vsubsy01*/


   /* ------------------------------------------------------------*/
   /* Do criteria pass.*/
   /* ------------------------------------------------------------*/

  AV0L116(); /* Criteria search*/


   /* ------------------------------------------------------------*/
   /* Add any partially formatted last page to the queue.*/
   /* ------------------------------------------------------------*/

  if (AV0LW00.AV0LWIXM > 1 /* Page was formatted*/
   && AV0LW00.AV0LWFPF == "P") /* Page was partial before*/

    AV0LS19(); /* Update page to temp. storage*/

  else

    if (AV0LW00.AV0LWIXM > 1) /* Page was formatted*/

      AV0LS25(); /* Add page to temporary storage*/

    end

  end


   /* ------------------------------------------------------------*/
   /* If no pages were formatted, indicate no data to display.*/
   /* ------------------------------------------------------------*/

  if (AV0LW00.TA5TSQIX == 0) /* No pages formatted*/

    if (AVWREC.XLTCD[1] == "  ") /* No last code*/

      AVWREC.XLTCD[1] = "* "; /* Wildcard last code*/

    end

    AVWREC.XXXMSGNO = 194;

    COMMAREA.CATOAP = "AV0K";

    COMMAREA.CAUSERA = AVWREC.CAUSERA; /* Return order entry rec*/

    AV0L115();

    XPAV002(); /* Exit to AV0K*/

  end

   /* ------------------------------------------------------------*/
   /* Indicate that the request for data is complete.*/
   /* ------------------------------------------------------------*/


  AV0LW00.AV0LWSWR = "N"; /* Request for data switch*/


end // end AV0L110

// Initial Substitute Search
Function AV0L111()
   /* ------------------------------------------------------------*/
   /* This leg gets codes/colors etc and searches the marketing*/
     /* table (davail.vsubsy01).*/
   /* ------------------------------------------------------------*/
   /* ------------------------------------------------------------*/
   /* Get product default codes.*/
   /* ------------------------------------------------------------*/


  AV0L112(); /* Get product code defaults*/


   /* ------------------------------------------------------------*/
   /* Initialize work table in av0lw00.*/
   /* ------------------------------------------------------------*/

  set AV0LW02 empty;


  AV0LWIXT = +1; /* Set product table subscript*/


   /* ------------------------------------------------------------*/
   /* Get valid colors for the original product and substitutes*/
   /* from the marketing table (davail.vsubsy01).*/
   /* Only for APPAREL PRODUCTS.*/
   /* ------------------------------------------------------------*/

  if (AVWREC.XGPCD == "03" /* Apparel product*/
   || AVWREC.XGPCD == "02") /* or Footwear product*/

    AV0L118(); /* Get valid colors*/

  else

    AV0LS43(); /* Load other product*/

  end


   /* ------------------------------------------------------------*/
   /* Check work table (just built with other colors of original*/
   /* product and products from the marketing table) for*/
   /* availability, etc.*/
   /* ------------------------------------------------------------*/

  AV0LW00.AV0LWIXM = 1; /* Display line index*/

   /* ------------------------------------------------------------*/
   /* This searches the marketing product table in working*/
     /* storage (av0lw02) and determines availability.*/
   /* Those products which meet the availability criteria will be*/
     /* further processed. Those that don't, won't.*/
   /* ------------------------------------------------------------*/

  AV0LW00.SY1STNBR = AVWREC.SY1STNBR; /* initiate style nbr control*/

  AV0LW00.AV0LWIXT = +1; /* Set table subscript*/

  while (AV0LW02.XGPCD[AV0LWIXT] > "  " /* Have a product*/
   && AV0LW00.AV0LWIXT <= 300) /* Sub in range*/

    AV0LS06(); /* Check availability*/

    AV0LS28(); /* Check for further processing*/

    AV0LW00.AV0LWIXT = AV0LW00.AV0LWIXT + 1; /* increment subscript*/

  end

   /* ------------------------------------------------------------*/
   /* Add any partially formatted last page to the queue.*/
   /* ------------------------------------------------------------*/

  if (AV0LW00.AV0LWIXM > 1) /* Page was formatted*/

    AV0LS25(); /* Add page to temporary storage*/

  end

   /* ------------------------------------------------------------*/
   /* Compute the 15% upper range allowable for footwear*/
    /* substitutes based on wholesale price.*/
   /* ------------------------------------------------------------*/

  if (AVWREC.XGPCD == "02") /* If footwear*/

    AV0LW00.AV0LW3 = AVWREC.AVWWSP * .15; /* Calculate 15% of whsl prc*/

    AV0LW00.AV0LWWPR = AVWREC.AVWWSP + AV0LW00.AV0LW3; /* FTWR prc limit*/

    if (AVWREC.AVWPHI > 0 /* have override upper range price*/
     && AVWREC.AVWPHI != 99999.99)
      /* NEXT SENTENCE*/

    else

      AVWREC.AVWPHI = AV0LW00.AV0LWWPR; /* Move to upper range field*/

    end
  end

   /* ------------------------------------------------------------*/
    /* If not a footwear product and the high range price is zero*/
     /* set it to the max of 99999.99.*/
   /* ------------------------------------------------------------*/
  if (AVWREC.AVWPHI == 0) /* If not footwear and high price = 0*/

    AVWREC.AVWPHI = 99999.99; /* Set upper range  to max amt.*/

  end

end // end AV0L111

// Get criteria codes
Function AV0L112()
   /* ------------------------------------------------------------*/
   /* Determine override color.*/
   /* ------------------------------------------------------------*/

  if (AVWREC.SY2CLRID[2] > "  ") /* color override*/
    if (AVWREC.SY2CLRID[2] == "*") /* color is wildcard*/
      AVWREC.SY2CLRAB = "*** A L L ***"; /* color abrv*/
    else
      AV0LS83();
      AVWREC.SY2CLRAB = SYCREC.SY2CLRAB; /* color abrv*/
    end
  end

   /* ------------------------------------------------------------*/
   /* Get codes from DPROD.VCOLOR02.*/
   /* ------------------------------------------------------------*/

  AV0LS02(); /* Get dprod.vcolor02 codes*/

   /* ------------------------------------------------------------*/
   /* Move codes and short names to AVWREC.*/
   /* ------------------------------------------------------------*/

  AVWREC.SY4SZSCL = SYCREC.SY4SZSCL; /* Size scale*/
  AVWREC.XSUCD[1] = SYCREC.XSUCD; /* Silhouette*/
  AVWREC.XGACD[1] = SYCREC.XGACD; /* Gender/Age*/
  AVWREC.SY1SSTNM = SYCREC.SY1SSTNM; /* Short style name*/
  AVWREC.XPCCD[1] = SYCREC.XPCCD; /* Product category*/
  AVWREC.XPLCD[1] = SYCREC.XPLCD; /* Product line*/
  AVWREC.XDVCD = SYCREC.XDVCD1; /* Division code*/
  AVWREC.XUMCD[1] = SYCREC.XUMCD; /* Unit of measure*/


   /* -----------------------------------------------------------*/
   /* If from order entry the life cycle is set to in line (10)*/
   /* otherwise the current active life cycle from the product*/
   /* file is used.*/
   /* -----------------------------------------------------------*/

  AV0LS79(); /* Get current life cycle*/

  if (AVWREC.AVWORDFL == "Y" /* From order entry*/
                             
   && AVWREC.XLCCD[1] != "10") /* source prod. not in line*/

    AVWREC.XLCCD[2] = "10"; /* override with in line life cycle*/

  end



  AVWREC.YCQCD[1] = SYCREC.YCQCD; /* Collection code*/
  if (AVWREC.SY2CLRID[2] == "  ") /* color override*/
    AVWREC.SY2CLRAB = SYCREC.SY2CLRAB; /* color abrv*/
  end


   /* ------------------------------------------------------------*/
   /* The last code is no longer used so spaces are moved to the*/
   /* last code field.*/
   /* ------------------------------------------------------------*/

  AVWREC.XLTCD[1] = "  "; /* No last code available*/

   /* ------------------------------------------------------------*/
   /* Get wholesale price from DPROD.VPRICE01.*/
   /* The xottbl check is made to keep the price in sync*/
     /* order entry.*/
   /* ------------------------------------------------------------*/

  sysVar.arrayIndex = 1;

  while (XOTTBL.XOTCD[sysVar.arrayIndex] != "99") /* Not end of table*/

    if (XOTTBL.XOTCD[sysVar.arrayIndex] == AVWREC.XOTCD /* Order type code*/
     && XOTTBL.XOTPRCDT[sysVar.arrayIndex] == "B")      /* Book date price*/

      AV0LW00.AV0LWPDT = XX0XW01.XX0XWDAT; /* Use current date*/

    end

    sysVar.arrayIndex = sysVar.arrayIndex + 1;
  end


   /* ------------------------------------------------------------*/
   /* If no hit on the xottbl use the need date.*/
   /* The need date may be the current date if no need date was*/
     /* furnished. (see AV0L000)*/
   /* ------------------------------------------------------------*/

  if (XOTTBL.XOTCD[sysVar.arrayIndex] == "99") /* End of table*/
    if (AV0LW00.AV0LWPDT == 0) /* And didn't get a hit*/

      AV0LW00.AV0LWPDT = AVWREC.OP1CUNDT; /* Use need date*/

    end
  end


   /* ------------------------------------------------------------*/
   /* Get wholesale price from DPROD.VPRICE01.*/
   /* ------------------------------------------------------------*/

  set SY5REC empty; /* set record clear*/


  SY5REC.XPYCD = "01"; /* For wholesale price*/

  AV0LS03(); /* Get dprod.vprice01*/

  AV0LW00.AV0LWIXP = 1; /* Set price field index*/


  if (AV0LW00.AV0LWPRF == "N") /* Price row NOT found*/
    AVWREC.AVWWSP = 000000000; /* zero Wholesale price*/

  else /* Price row found*/

    while (AV0LW00.AV0LWIXP <= 6         /* Check all price fields with*/
     && SY5REC.SY5PCEDT[AV0LWIXP] > 0 /* date greater than zero*/
     && AVWREC.AVWWSP == 0) /* Haven't got valid price yet*/
      if (SY5REC.SY5PCEDT[AV0LWIXP] <= AV0LW00.AV0LWPDT) /* Within date*/
        AVWREC.AVWWSP = SY5REC.SY5PRCUN[AV0LWIXP]; /* Whsl price*/
        AV0LW00.AV0LWIXP = AV0LW00.AV0LWIXP + 1; /* increment index*/

      else

        AV0LW00.AV0LWIXP = AV0LW00.AV0LWIXP + 1; /* increment index*/
      end
    end
  end


   /* ------------------------------------------------------------*/
   /* Get retail price from DPROD.VPRICE01.*/
   /* ------------------------------------------------------------*/

  set SY5REC empty; /* set record clear*/

  SY5REC.XPYCD = "02"; /* For retail price*/

  AV0LS03(); /* Get dprod.vprice01*/

  AV0LW00.AV0LWIXP = 1; /* Set price field index*/


  if (AV0LW00.AV0LWPRF == "N") /* Price row NOT found*/
    AVWREC.AVWRTL = 000000000; /* Retail price*/
  else /* Price row found*/
    while (AV0LW00.AV0LWIXP <= 6         /* Check all price fields with*/
     && SY5REC.SY5PCEDT[AV0LWIXP] > 0 /* date greater than zero*/
     && AVWREC.AVWRTL == 0) /* Haven't got valid price yet*/
      if (SY5REC.SY5PCEDT[AV0LWIXP] <= AV0LW00.AV0LWPDT) /* Within date*/
        AVWREC.AVWRTL = SY5REC.SY5PRCUN[AV0LWIXP]; /* Retail price*/
        AV0LW00.AV0LWIXP = AV0LW00.AV0LWIXP + 1; /* increment index*/
      else
        AV0LW00.AV0LWIXP = AV0LW00.AV0LWIXP + 1; /* increment index*/
      end
    end
  end


   /* ------------------------------------------------------------*/
   /* For apparel product get the silhouette group code.*/
   /* ------------------------------------------------------------*/

  if (AVWREC.XGPCD == "03") /* If apparel product*/
    if (AVWREC.XSUCD[1] != "00"
     && AVWREC.XSUCD[1] != "  ")

      AV0LS21(); /* Set cursor for silh group cd.*/

      AV0LS23(); /* Fetch silhouette group code*/

      AV0LS24(); /* Close cursor for silh grp. cd.*/

    end
  end


end // end AV0L112

// Purge temporary storage
Function AV0L115()
   /* ------------------------------------------------------------*/
   /* Initialize the storage areas and indicators to be used.*/
   /* ------------------------------------------------------------*/

  set AV0LW01 empty; /* M001 display storage*/

  AV0LW00.AV0LWSWU = "N"; /* Storage update switch*/

  TA5REC.TA5TSQIX = 0; /* Current page number*/
  AV0LW00.TA5TSQIX = 0; /* Highest page number*/

   /* ------------------------------------------------------------*/
   /* Purge any temporary storage for this application.*/
   /* ------------------------------------------------------------*/

  TA5REC.TA5APPID = COMMAREA.CACURRAP; /* Application identification*/
  TA5REC.TA5FNCCD = "P"; /* Function code*/

  try
    call "TA0050" (AV0LW01, TA5REC) {isNoRefresh = yes, isExternal = yes};
  end /* Temporary storage*/

   /* ------------------------------------------------------------*/
   /* If successful, return to previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && TA5REC.TA5RTNCD == 0)          /* and normal return code*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that a system error occurred.*/
   /* ------------------------------------------------------------*/

  TAEREC.TAEDESC1 = sysVar.errorCode; /* CSP return code*/
  TAEREC.TAEDESC2 = TA5REC.TA5DATA; /* Subroutine parameters*/

  AVWREC.XXXMODID = "115"; /* Module identification*/
  converseLib.validationFailed(10); /* Indicate system error*/

  TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  TA1REC.TA1TYPE = "APPL"; /* Type of error*/
  TA1REC.TA1LOC = "PURGE ANY TEMPORARY STORAGE";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = AVWREC.XXXMODID; /* Program number*/
  TA1REC.TA1MAPAP = COMMAREA.CACURRAP; /* Map application*/
  TA1REC.TA1MAPNO = "M001"; /* Map number*/

  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end AV0L115

// Criteria Search
Function AV0L116()
   /* ----------------------------------------------------------*/
   /* First check temporary storage to see if last page written*/
     /* was a partial or full page.*/
   /* If it was a full page continue normal processing.*/
   /* If it was a partial, determine where the products left off*/
     /* and use that as a starting point for the criteria*/
     /* processing.*/
   /* ----------------------------------------------------------*/

  if (AV0LW00.TA5TSQIX > 0) /* There is a last page to ck.*/

    AV0LW00.XXXTSPAG = AV0LW00.TA5TSQIX; /* Desired page to max*/

    AV0LS20(); /* Obtain temp. storage page*/

    AV0LW00.AV0LWIXK = 14; /* Set search index to max row*/

    AV0LW00.AV0LWFPF = " "; /* Set full or partial flag*/

    while (AV0LW00.AV0LWIXK >= 1 /* Search not complete*/
     && AV0LW00.AV0LWFPF == " ") /* Not full or partial yet*/

      AV0LS49(); /* Check if page full or partial*/

    end

  end


  if (AV0LW00.AV0LWFPF == "P") /* Last page is partially full*/

    AV0LW00.AV0LWIXM = AV0LW00.AV0LWIXK + 1; /* Position map index*/

  end


   /* ----------------------------------------------------------*/
   /* This leg controls the extract file search.*/
   /* There are 2 extract tables:*/
                 /* davail.vsubfw01 - GPC 01 and 02 products*/
                 /* davail.vsubap01 - GPC 03 products*/
   /* ----------------------------------------------------------*/

  if (AVWREC.XGPCD == "01" /* For promo*/
   || AVWREC.XGPCD == "02") /* For footwear*/
    AV0LS41(); /* Search footwear table*/

  else

    if (AVWREC.XGPCD == "03") /* For apparel*/
      AV0LS42(); /* Search apparel table*/

    end
  end


end // end AV0L116

// Get valid colors
Function AV0L118()
   /* ------------------------------------------------------------*/
   /* Get original product colors.*/
   /* ------------------------------------------------------------*/
   /* Get colors from DPROD.VCOLOR01.*/
   /* Select and open the cursor. (dprod.vcolor01)*/
   /* ------------------------------------------------------------*/

  set SY2REC empty; /* Clear row storage area*/

  SY2REC.XGPCD = AVWREC.XGPCD; /* GPC*/
  SY2REC.SY1STNBR = AVWREC.SY1STNBR; /* Style*/
  SY2REC.SY2CLRID = "***"; /* color*/
  if (AVWREC.XDMCD[2] > "  ") /* override present*/
    SY2REC.XDMCD = AVWREC.XDMCD[2]; /* dimension*/
  else
    SY2REC.XDMCD = AVWREC.XDMCD[1]; /* dimension*/
  end

  AV0LS14(); /* Open cursor*/

   /* ------------------------------------------------------------*/
   /* Fetch and load valid colors into working storage table.*/
   /* ------------------------------------------------------------*/

  AV0LW00.AV0LWEC1 = "N"; /* Set end of cursor switch*/

  AV0LS15(); /* Fetch next row in the cursor*/

  while (AV0LW00.AV0LWEC1 == "N") /* Until end of cursor*/

    /* ------------------------------------------------------------*/
     /* Valid colors are determined here. The filter for color*/
     /* description is done first, then life cycle is checked*/
     /* against override if present, else against product life cyc.*/
    /* ------------------------------------------------------------*/
     /* Compare the color desc search field and the desc from the*/
     /* database.*/
    /* ------------------------------------------------------------*/

    AV0LW00.AV0LWSB = SY2REC.SY2CLRDS; /* move color desc from db*/

    AV0LS88(); /* compare description fields*/

    if (AV0LW00.AV0LWFND != "Y") /* doesnt match description*/
       /* next sentence*/
    else

      AV0LS38();
    end



    AV0LS15(); /* Fetch next row in the cursor*/

  end

   /* ------------------------------------------------------------*/
   /* Close the cursor for Dprod.vcolor01.*/
   /* ------------------------------------------------------------*/

  AV0LS35(); /* Close the selected set cursor*/

   /* ------------------------------------------------------------*/
   /* Get marketing table products.*/
   /* ------------------------------------------------------------*/
   /* Select and open the cursor for davail.vsubsy01.*/
   /* ------------------------------------------------------------*/

  AV0LW00.AV0LWSWC = "N"; /* End of cursor switch*/

  AV0LS04(); /* Select set and open cursor*/

   /* ------------------------------------------------------------*/
   /* Fetch and load product table until end of cursor.*/
   /* ------------------------------------------------------------*/

  AV0LS05(); /* Fetch next row in vsubsy01*/

  while (AV0LW00.AV0LWSWC == "N") /* Until end of vsubsy01*/

    AV0LS40(); /* Get colors*/

    AV0LS05(); /* Fetch next row in vsubsy01*/

  end

   /* ------------------------------------------------------------*/
   /* Close the cursor for the selected set. (davail.vsubsy01)*/
   /* ------------------------------------------------------------*/

  AV0LS30(); /* Close cursor for vsubsy01*/

end // end AV0L118

// Format and converse the map
Function AV0L120()
   /* ------------------------------------------------------------*/
   /* If no error was found, format the data to be displayed.*/
   /* ------------------------------------------------------------*/

  if (converseVar.validationMsgNum == 0) /* No error found*/

    if (AV0LW00.AV0LWSWF == "Y") /* Map must be formatted*/
      AV0L121(); /* Format the data on the map*/
      if (AVWREC.AVWSIPF == "Y") /* Search in progress*/
        AVWREC.XXXMSGNO = 218; /* Msg. search in progress*/
      else
        AVWREC.XXXMSGNO = 217; /* Msg. search complete*/
      end
    end

  else

    AVWREC.XXXMSGNO = converseVar.validationMsgNum; /* Message number*/

  end

   /* ------------------------------------------------------------*/
   /* Format the current date and any FAST PATH information.*/
   /* ------------------------------------------------------------*/

  AV0LM001.XXXCURDT = VGVar.currentShortGregorianDate; /* Current date*/

  if (AVWREC.AVWORDFL == "Y") /* From order entry*/

    set AV0LM001.AV0LMCAT invisible, skip; /* Blank out 'OPTION'*/
    set AV0LM001.CATOAP skip, invisible; /* Don't allow fastpath appl.*/
    set AV0LM001.AV0LMCAI invisible, skip; /* Blank out 'ITEM'*/
    set AV0LM001.CAITEM skip, invisible; /* Don't allow fastpath item*/

  else

    set AV0LM001.AV0LMPF6 invisible, skip;
    AV0LM001.CATOAP = COMMAREA.CATOAP; /* TO application*/
    AV0LM001.CAITEM = COMMAREA.CAITEM; /* Application data*/

  end


   /* ------------------------------------------------------------*/
   /* If a message to display, indicate sound audible alarm.*/
   /* ------------------------------------------------------------*/

  if (AVWREC.XXXMSGNO != 0 /* Message to display*/
   || COMMAREA.CAMSG != " ") /* or message text*/


    if (AVWREC.XXXMSGNO != 0) /* Message to display*/

      if (AVWREC.XXXMSGNO == 9999)
        converseLib.validationFailed();
      else
        converseLib.validationFailed(AVWREC.XXXMSGNO);
      end /* Message number*/
    else
      AV0LM001.VAGen_EZEMSG = COMMAREA.CAMSG; /* Message text*/

    end


    AV0LM001.XXXMODID = AVWREC.XXXMODID; /* Module identification*/


    if (AVWREC.XXXMSGNO != 217 /* Search complete msg.*/
     && AVWREC.XXXMSGNO != 218) /* Search in progress msg.*/
      set AV0LM001 alarm; /* Indicate sound alarm*/

    end


  end

  converse AV0LM001 ;

   /* ------------------------------------------------------------*/
   /* Clear the message fields and save FAST PATH information.*/
   /* ------------------------------------------------------------*/

  AVWREC.XXXMSGNO = 0; /* Message number*/
  AVWREC.XXXMODID = " "; /* Module identification*/
  COMMAREA.CAMSG = " "; /* Message text*/

  COMMAREA.CATOAP = AV0LM001.CATOAP; /* TO application*/
  COMMAREA.CAITEM = AV0LM001.CAITEM; /* Application data*/


end // end AV0L120

// Format the display data
Function AV0L121()
   /* ------------------------------------------------------------*/
   /* Clear the fields in the map storage area to be formatted.*/
   /* ------------------------------------------------------------*/

  set AV0LM001 initial; /* M001 input/output area*/

  AV0LW00.AV0LWSWF = "N"; /* Format the map switch*/

   /* ------------------------------------------------------------*/
   /* Check if first time thru, if so insure current page is #1*/
   /* ------------------------------------------------------------*/

  if (AV0LW00.AV0LWFTF == "Y") /* This is first pass*/

    AV0LW00.XXXTSPAG = 1; /* Set current page to 1*/

    AV0LW00.AV0LWFTF = "N"; /* Reset first time flag.*/

  end


   /* ------------------------------------------------------------*/
   /* If the page in storage is not the page to be displayed,*/
   /* obtain the desired page from temporary storage.*/
   /* ------------------------------------------------------------*/

  if (AV0LW00.TA5TSQIX > 0) /* Pages were formatted*/


    /* ------------------------------------------------------------*/
     /* If the desired page number is greater than the highest page*/
     /* in storage, default to the highest page number.*/
    /* ------------------------------------------------------------*/

    if (AV0LW00.XXXTSPAG > AV0LW00.TA5TSQIX) /* Desired greater highest*/
      AV0LW00.XXXTSPAG = AV0LW00.TA5TSQIX; /* Default to highest*/

    end

    AV0LS20(); /* Obtain temporary storage page*/

    AVWREC.XXXTSLEN = AV0LW00.XXXTSLEN; /* Save temp. stg. length*/
    AVWREC.XXXTSPAG = AV0LW00.XXXTSPAG; /* Save current page*/
    AVWREC.TA5TSQIX = AV0LW00.TA5TSQIX; /* Save max page*/


    /* ------------------------------------------------------------*/
     /* Display the page information on the screen.*/
    /* ------------------------------------------------------------*/

    AV0LM001.XXXTSPAG = AV0LW00.XXXTSPAG; /* Current page*/
    AV0LM001.TA5TSQIX = AV0LW00.TA5TSQIX; /* Highest page*/

  end

   /* ------------------------------------------------------------*/
   /* Format the data in the map from the display storage.*/
   /* ------------------------------------------------------------*/

  AV0LM001.OP1ORDBY = AV0LW01.OP1ORDBY; /* Ordered by*/
  AV0LM001.KUMSTRNM = AV0LW01.KUMSTRNM; /* Store name*/
  AV0LM001.KUMCITYS = AV0LW01.KUMCITYS; /* City name*/
  AV0LM001.KUMXSTCD = AV0LW01.KUMXSTCD; /* State abbrevation*/
  AV0LM001.SY1STNBR = AV0LW01.SY1STNBR; /* Original style nbr*/
  AV0LM001.SY1SSTNM = AV0LW01.SY1SSTNM; /* Original style name*/
  AV0LM001.XQACD = AV0LW01.XQACD; /* Original quality cd*/
  AV0LM001.SY2CLRID = AV0LW01.SY2CLRID; /* Original color code*/
  AV0LM001.SY2CLRAB = AV0LW01.SY2CLRAB; /* Original color name*/
  AV0LM001.XDMCD = AV0LW01.XDMCD; /* Original dimension*/
  AV0LM001.XDMDESC = AV0LW01.XDMDESC; /* Original dim description*/
  AV0LM001.XGACD = AV0LW01.XGACD; /* Original gend/age*/
  AV0LM001.XPCCD = AV0LW01.XPCCD; /* Original prod category*/

  AV0LW00.AV0LWIXM = 1; /* Initialize line index*/

  while (AV0LW00.AV0LWIXM <= 14 /* While in subscript range*/
   && AV0LW01.AVASBSTY[AV0LWIXM] > " ") /* and have data*/

    if (AV0LW00.AV0LWIXM == 1) /* First select field*/

      set AV0LM001.AV0LMSEL[AV0LWIXM] cursor, normal; /* Position cursor*/
    else
      set AV0LM001.AV0LMSEL[AV0LWIXM] normal; /* Unprotect*/

    end

    /* ---------------------------------------------------------*/
     /* move working storage fields to map:*/
                                         /* Select*/
                                         /* Style*/
                                         /* Color*/
                                         /* Dim*/
                                         /* Color short name*/
                                         /* From size*/
                                         /* To size*/
                                         /* Total quantity*/
                                         /* Catalog page nbr.*/
                                         /* Color match ind.*/
                                         /* At once avail. ind.*/
    /* ---------------------------------------------------------*/
    if (AV0LW01.AV0LMSEL[AV0LWIXM] == "S" /* if product has been selected*/
     || AV0LW01.AV0LMSEL[AV0LWIXM] == "V") /* or indicated viewed*/
      AV0LM001.AV0LMSEL[AV0LWIXM] = "V"; /* indicate as viewed*/
    end
    AV0LM001.AVASBSTY[AV0LWIXM] = AV0LW01.AVASBSTY[AV0LWIXM];
    AV0LM001.AVASBCLR[AV0LWIXM] = AV0LW01.AVASBCLR[AV0LWIXM];
    AV0LM001.AVASBDIM[AV0LWIXM] = AV0LW01.AVASBDIM[AV0LWIXM];
    AV0LM001.AV0LWSND[AV0LWIXM] = AV0LW01.AV0LWSND[AV0LWIXM];
    AV0LM001.AV0LWFSZ[AV0LWIXM] = AV0LW01.AV0LWFSZ[AV0LWIXM];
    AV0LM001.AV0LWTSZ[AV0LWIXM] = AV0LW01.AV0LWTSZ[AV0LWIXM];
    AV0LM001.AV0LWTLQ[AV0LWIXM] = AV0LW01.AV0LWTLQ[AV0LWIXM];
    AV0LM001.AV0LWCPN[AV0LWIXM] = AV0LW01.AV0LWCPN[AV0LWIXM];
    AV0LM001.AV0LWCLM[AV0LWIXM] = AV0LW01.AV0LWCLM[AV0LWIXM];
    AV0LM001.AV0LWAOI[AV0LWIXM] = AV0LW01.AV0LWAOI[AV0LWIXM];

    AV0L122(); /* Check if from marketing table and highlight*/

    AV0LW00.AV0LWIXM = AV0LW00.AV0LWIXM + 1; /* Increment line index*/

  end


   /* ---------------------------------------------------------*/
   /* If page not full set select field askip for blank lines.*/
   /* ---------------------------------------------------------*/

  AV0LW00.AV0LWIXN = 1; /* Initialize line index*/

  while (AV0LW00.AV0LWIXN <= 14) /* While in subscript range*/
    if (AV0LW01.AVASBSTY[AV0LWIXN] == " ") /* and have no data*/

      set AV0LM001.AV0LMSEL[AV0LWIXN] skip, invisible; /* Don't allow selection*/

    end

    AV0LW00.AV0LWIXN = AV0LW00.AV0LWIXN + 1; /* Increment line index*/

  end


end // end AV0L121

// Check if subst. from mkt. tbl.
Function AV0L122()
   /* ------------------------------------------------------------*/
   /* Check the marketing table indicator to verify if from the*/
    /* marketing table.*/
   /* ------------------------------------------------------------*/


  if (AV0LW01.AV0LWMTS[AV0LWIXM] == "Y") /* Substitute from MKT. TBL.*/

    set AV0LM001.AVASBSTY[AV0LWIXM] protect, bold;
    set AV0LM001.AVASBCLR[AV0LWIXM] protect, bold;
    set AV0LM001.AVASBDIM[AV0LWIXM] protect, bold;
    set AV0LM001.AV0LWSND[AV0LWIXM] protect, bold;
    set AV0LM001.AV0LWFSZ[AV0LWIXM] protect, bold;
    set AV0LM001.AV0LWTSZ[AV0LWIXM] protect, bold;
    set AV0LM001.AV0LWTLQ[AV0LWIXM] protect, bold;
    set AV0LM001.AV0LWCPN[AV0LWIXM] protect, bold;
    set AV0LM001.AV0LWCLM[AV0LWIXM] protect, bold;
    set AV0LM001.AV0LWAOI[AV0LWIXM] protect, bold;

  else

    set AV0LM001.AVASBSTY[AV0LWIXM] protect;
    set AV0LM001.AVASBCLR[AV0LWIXM] protect;
    set AV0LM001.AVASBDIM[AV0LWIXM] protect;
    set AV0LM001.AV0LWSND[AV0LWIXM] protect;
    set AV0LM001.AV0LWFSZ[AV0LWIXM] protect;
    set AV0LM001.AV0LWTSZ[AV0LWIXM] protect;
    set AV0LM001.AV0LWTLQ[AV0LWIXM] protect;
    set AV0LM001.AV0LWCPN[AV0LWIXM] protect;
    set AV0LM001.AV0LWCLM[AV0LWIXM] protect;
    set AV0LM001.AV0LWAOI[AV0LWIXM] protect;

  end


end // end AV0L122

// Check attention identifier
Function AV0L130()
   /* ------------------------------------------------------------*/
   /* Depending on from which system this application was invoked*/
   /* , certain function keys are disabled to maintain the flow*/
   /* and data integrity of order entry.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is enter
   || converseVar.eventKey is pf7
   || converseVar.eventKey is pf8)
    AV0L134(); /* CHECK TO VALIDATE SELECT CODES*/
    if (converseVar.validationMsgNum == 215) /* INVALID CODE DETECTED*/
      exit stack;
    end
  end

  if (AVWREC.AVWORDFL == "Y") /* Order entry mode (no exits)*/
    if (converseVar.eventKey is enter /* Enter was pressed*/
     || converseVar.eventKey is pf3   /* Return to order entry appl.*/
     || converseVar.eventKey is pf5   /* Return to av0k (criteria)*/
     || converseVar.eventKey is pf6   /* Select substitute for op0i*/
     || converseVar.eventKey is pf7   /* Page backward 1 page*/
     || converseVar.eventKey is pf8   /* Page forward 1 page*/
     || converseVar.eventKey is pf17) /* Wildcard selection*/
       /* next sentence*/
    else
      converseLib.validationFailed(15); /* Invalid pf key*/
      exit stack;
    end
  else /* Availability mode (exits allowed)*/
    if (converseVar.eventKey is enter /* Enter was pressed*/
     || converseVar.eventKey is pf1   /* Goal help screen*/
     || converseVar.eventKey is pf3   /* Return to either av0a,av0i,av0p*/
     || converseVar.eventKey is pf4   /* Return to master menu*/
     || converseVar.eventKey is pf5   /* Return to av0k (criteria)*/
     || converseVar.eventKey is pf7   /* Page backward 1 page*/
     || converseVar.eventKey is pf8   /* Page forward 1 page*/
     || converseVar.eventKey is pf17) /* Wildcard selection*/
       /* next sentence*/
    else
      converseLib.validationFailed(15); /* Invalid pfkey*/

      exit stack;
    end
  end

   /* ------------------------------------------------------------*/
   /* If CRITERIA was requested, close cursor and xfer to av0k.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf5) /* PF5 was pressed*/

    if (AVWREC.XLTCD[1] == "  ") /* No last code*/

      AVWREC.XLTCD[1] = "* "; /* Wildcard last code*/

    end

    COMMAREA.CATOAP = "AV0K";

    /* ------------------------------------------------------------*/
     /* restore original internal sizes to avwrec*/
    /* ------------------------------------------------------------*/

    AVWREC.AVWRQSZF = AVWREC.AVWRHSZF;
    AVWREC.AVWRQSZL = AVWREC.AVWRHSZL;

    COMMAREA.CAUSERA = AVWREC.CAUSERA; /* Return order entry rec*/

    AV0L115(); /* Purge temp storage*/

    XPAV002(); /* Exit to AV0K*/

  end

   /* ------------------------------------------------------------*/
   /* If SELECT  was requested, rebuild OSGREC from avwrec and*/
     /* selected substitute data and return to order entry*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf6) /* PF6 was pressed*/

    if (AVWREC.AVWORDFL == "Y") /* Order entry mode (no exits)*/

      set OSGREC empty; /* Clear record for order entry*/

      AV0LW00.AV0LWIXE = 1; /* Set edit subscript*/

      while (AV0LW00.AV0LWIXE <= 14 /* Subscript in range*/
       && AV0LM001.AV0LMSEL[AV0LWIXE] != "S") /* Look for selected*/

        AV0LW00.AV0LWIXE = AV0LW00.AV0LWIXE + 1; /* increment subscript*/

      end

      if (AV0LW00.AV0LWIXE <= 14) /* One has been selected*/

        AV0L131(); /* Move selected product info*/

        AV0LW00.AV0LWIXE = AV0LW00.AV0LWIXE + 1; /* increment subscript*/

        while (AV0LW00.AV0LWIXE <= 14 /* Subscript in range*/
         && AV0LM001.AV0LMSEL[AV0LWIXE] != "S")
                                   /* Look for another select*/

          AV0LW00.AV0LWIXE = AV0LW00.AV0LWIXE + 1; /* increment subscript*/

        end

        if (AV0LW00.AV0LWIXE <= 14) /* Found another select*/

          set OSGREC empty; /* Clear record for order entry*/

          converseLib.validationFailed(216); /* may only select one at a time*/

          exit stack;

        else /* otherwise exit with first selected*/

          COMMAREA.CATOAP = AVWREC.XSRSYSID; /* Order entry appl.*/

          COMMAREA.CAUSERA = OSGREC.OSGGROUP; /* move osgrec to comm*/

          AV0L115(); /* Purge temp storage*/

          AV0LS80(); /* Exit to another application*/

        end
      end
    end
  end


  if (converseVar.eventKey is pf6) /* PF6 was pressed*/

    converseLib.validationFailed(258); /* PF6 invalid without selection*/

    exit stack;

  end

   /* ------------------------------------------------------------*/
   /* If PF3 was pressed and from order entry rebuild OSGREC and*/
     /* return to appropriate order entry application without a*/
     /* substitute product.*/
   /* If not from order entry return to appropriate availability*/
     /* application.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf3) /* PF3 was pressed*/

    if (AVWREC.AVWORDFL == "Y") /* Order entry mode (no exits)*/

      set OSGREC empty; /* Clear record for order entry*/

      COMMAREA.CATOAP = AVWREC.XSRSYSID; /* Order entry appl.*/
      OSGREC.OSGGROUP = AVWREC.OSGGROUP;
      COMMAREA.CAUSERA = OSGREC.OSGGROUP; /* move osgrec to comm*/

      AV0L115(); /* Purge Temp storage*/

      AV0LS80(); /* Exit to order entry*/

    else

      if (AVWREC.XSRSYSID > "    ") /* Got appl. to retn. to*/

        COMMAREA.CATOAP = AVWREC.XSRSYSID; /* Go to orig. appl.*/
        COMMAREA.CAUSERA = AVWREC.CAUSERA; /* Move avwrec to comm*/

        AV0L115(); /* Purge Temp storage*/

        AV0LS80(); /* Exit to either av0a,av0i,av0p*/

      else

        COMMAREA.CATOAP = "AV0M"; /* Go to availability menu*/
        COMMAREA.CAUSERA = AVWREC.CAUSERA; /* Move avwrec to comm*/

        AV0L115(); /* Purge Temp storage*/

        XPAV002(); /* Exit to another application*/

      end

    end

  end

   /* ------------------------------------------------------------*/
   /* When PF17 is pressed the program wildcards the Color, Whare-*/
   /* house price and silhouette code.  The program exits and re-*/
   /* enters.  This is done to reinitialize all of the flags and*/
   /* records.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf17) /* PF17 was pressed*/

    if (AVWREC.XLTCD[1] == "  ") /* No last code*/

      AVWREC.XLTCD[1] = "* "; /* Wildcard last code*/

    end

    /* ------------------------------------------------------------*/
     /* Restore original internal sizes to AVWREC*/
    /* ------------------------------------------------------------*/

    AVWREC.AVWRQSZF = AVWREC.AVWRHSZF;
    AVWREC.AVWRQSZL = AVWREC.AVWRHSZL;

    AVWREC.SY2CLRID[2] = "*"; /* Color override*/
    AVWREC.XSUCD[2] = "*"; /* Silhouette override*/
    AVWREC.AVWPLO = 0; /* Wholesale low price*/
    AVWREC.AVWPHI = 99999.99; /* Wholesale high price*/

    COMMAREA.CAUSERA = AVWREC.CAUSERA; /* Return order entry rec*/

    AV0L115(); /* Purge temp storage*/

    AV0LW00.AV0LWSWF = "Y"; /* Format map switch*/
    AV0LW00.AV0LWSWR = "Y"; /* Request for data switch*/

    exit stack;

  end

   /* ------------------------------------------------------------*/
   /* If substitute was requested for detail viewing,*/
    /* load current substitutes into avwrec, determine gpc and*/
    /* transfer to either AV0Q for footwear or AV0R for apparel.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is enter) /* ENTER was pressed*/

    AV0LW00.AV0LWIXI = 1; /* Set load subscript*/

    while (AV0LW00.AV0LWIXI <= 14) /* Subscript in range*/

      AV0L132(); /* Check if an 'S' was entered*/

      if (AV0LW00.AV0LWIXI == 99) /* Got selected substitute*/
        AV0L133(); /* update temporary storage page*/
        /* ------------------------------------------------------------*/
         /* restore original internal & external sizes to avwrec*/
        /* ------------------------------------------------------------*/

        AVWREC.AVWOREXF = AV0LW00.AV0LWORF;
        AVWREC.AVWOREXL = AV0LW00.AV0LWORL;
        AVWREC.AVWRQSZF = AVWREC.AVWRHSZF;
        AVWREC.AVWRQSZL = AVWREC.AVWRHSZL;

        if (AVWREC.XGPCD == "01" /* PROMO*/
         || AVWREC.XGPCD == "02") /* FOOTWEAR*/
          COMMAREA.CATOAP = "AV0Q"; /* Footwear Detail Screen*/
          AVWREC.XXXTSLEN = AV0LW00.XXXTSLEN; /* Save page length*/
          AVWREC.XXXTSPAG = AV0LW00.XXXTSPAG; /* Save page number*/
          AVWREC.TA5TSQIX = AV0LW00.TA5TSQIX; /* Max pages written*/

          XPAV002(); /* Exit to another application*/

        else

          if (AVWREC.XGPCD == "03") /* APPAREL*/
            COMMAREA.CATOAP = "AV0R"; /* Apparel Detail Screen*/
            AVWREC.XXXTSLEN = AV0LW00.XXXTSLEN; /* Save page length*/
            AVWREC.XXXTSPAG = AV0LW00.XXXTSPAG; /* Save page number*/
            AVWREC.TA5TSQIX = AV0LW00.TA5TSQIX; /* Max pages written*/

            XPAV002(); /* Exit to another application*/

          end
        end
      end
    end
  end


   /* ------------------------------------------------------------*/
   /* If FAST PATH was requested, transfer to the application.*/
   /* ------------------------------------------------------------*/

  if (AV0LM001.CATOAP > " ") /* FAST PATH was requested*/

    if (converseVar.eventKey is enter) /* ENTER was pressed*/

      AV0L115(); /* Purge any temporary storage*/

      XPAV002(); /* Exit to another application*/

      set AV0LM001.CATOAP cursor, bold; /* Highlight*/

    else

      AVWREC.XXXMODID = "130"; /* Module identification*/
      converseLib.validationFailed(23); /* Indicate PF key not valid*/

    end

    exit stack; /* Exit to display map*/

  else
    if (AV0LM001.CAITEM > " ") /* FAST PATH item but no option*/

      AVWREC.XXXMODID = "130"; /* Module identification*/
      converseLib.validationFailed(28); /* Indicate option required*/
      set AV0LM001.CAITEM cursor, bold;

      exit stack; /* Exit to display map*/

    end

  end

   /* ------------------------------------------------------------*/
   /* If HELP, exit to the previous level or exit to the Master*/
   /* Menu was requested, exit to another application.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf1) /* PF1 (help)*/

    if (AVWREC.AVWORDFL == "Y") /* Order entry mode (no exits)*/

      converseLib.validationFailed(15); /* Invalid pfkey*/

      exit stack; /* Exit to display map*/

    else

      XPAV002(); /* Exit to another application*/

    end
  end


   /* ------------------------------------------------------------*/
   /* If PF4, exit to the main menu.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf4) /* or PF4 (main menu)*/

    if (AVWREC.AVWORDFL == "Y") /* Order entry mode (no exits)*/

      converseLib.validationFailed(15); /* Invalid pfkey*/

      exit stack; /* Exit to display map*/

    else

      COMMAREA.CATOAP = "MN0M"; /* Go to Availability menu*/

      AV0L115(); /* Purge Temp storage*/

      XPAV002(); /* Exit to another application*/

    end
  end


end // end AV0L130

// Check for selected product
Function AV0L131()
   /* ------------------------------------------------------------*/
   /* Check select fields for 's' and move data to osgrec.*/
    /* The first 's' product selected will be taken back to*/
    /* order entry.*/
   /* ------------------------------------------------------------*/

  if (AV0LM001.AV0LMSEL[AV0LWIXE] == "S") /* Select this product*/
    OSGREC.XSRSYSID = AVWREC.XSRSYSID; /* XSR-SCRPD-OWN-ID*/
    OSGREC.XSRSUBID = AVWREC.XSRSUBID; /* XSR-SCRPD-SUB-ID*/
    OSGREC.XSRSQNBR = AVWREC.XSRSQNBR; /* XSR-SCRPD-SEQ-NBR*/
    OSGREC.OSGPRSUB = AVWREC.OSGPRSUB; /* OPWREC pointer*/
    OSGREC.KUCCOID = AVWREC.KUCCOID; /* Company id*/
    OSGREC.KUMSTRID = AVWREC.KUMSTRID; /* Store id*/
    OSGREC.XNXCD = AVWREC.XNXCD; /* Nike dept code*/
    OSGREC.OP1ORDBY = AVWREC.OP1ORDBY; /* OP_ORDERED_BY*/
    OSGREC.XGPCD = AVWREC.XGPCD; /* GPC*/
    OSGREC.SY1STNBR = AVWREC.SY1STNBR; /* Style*/
    OSGREC.SY2CLRID = AVWREC.SY2CLRID[1]; /* Color*/
    OSGREC.XDMCD = AVWREC.XDMCD[1]; /* Dim*/
    OSGREC.XOWCD = AVWREC.XOWCD; /* Owner group*/
    OSGREC.XSDCD = AVWREC.XSDCD; /* Spec difference*/
    OSGREC.XSACD = AVWREC.XSACD; /* Shade*/
    OSGREC.XPGCD = AVWREC.XPGCD; /* Pkg. type*/
    OSGREC.XUMCD = AVWREC.XUMCD[1]; /* UOM*/
    OSGREC.XLCCD = AVWREC.XLCCD[1]; /* Life cycle*/
    OSGREC.XQACD = AVWREC.XQACD[1]; /* Quality*/
    OSGREC.XOTCD = AVWREC.XOTCD; /* Order type*/
    OSGREC.OP1CUNDT = AVWREC.OP1CUNDT; /* Cust need date*/
    OSGREC.XWHCD = AVWREC.XWHCD[1]; /* Warehouse*/
    OSGREC.OPWRQSZF = AVWREC.OPWRQSZF; /* Request first size*/
    OSGREC.OPWRQSZL = AVWREC.OPWRQSZL; /* Request last size*/
    OSGREC.OP2SSTYN = AV0LM001.AVASBSTY[AV0LWIXE]; /* Sub style*/
    OSGREC.OP2SCLCD = AV0LM001.AVASBCLR[AV0LWIXE]; /* Sub color*/
    OSGREC.OP2SDMCD = AV0LM001.AVASBDIM[AV0LWIXE]; /* Dim*/

  else

    AV0LW00.AV0LWIXE = AV0LW00.AV0LWIXE + 1; /* Increment sub*/

  end


end // end AV0L131

// Ck. for select for detail
Function AV0L132()
   /* ------------------------------------------------------------*/
   /* Check select fields for 'S'. At least 1 must be select*/
    /* to view any detail.*/
   /* ------------------------------------------------------------*/

  if (AV0LM001.AV0LMSEL[AV0LWIXI] == "S") /* Select this product*/

    AV0LWIXI = 1; /* Set subscript to load product*/

    while (AV0LWIXI <= 14) /* Subscript in range*/
      AVWREC.OP2SSTYN[AV0LWIXI] = AV0LM001.AVASBSTY[AV0LWIXI];
      AVWREC.OP2SCLCD[AV0LWIXI] = AV0LM001.AVASBCLR[AV0LWIXI];
      AVWREC.OP2SDMCD[AV0LWIXI] = AV0LM001.AVASBDIM[AV0LWIXI];
      AVWREC.AVWCATLG[AV0LWIXI] = AV0LM001.AV0LWCPN[AV0LWIXI];

       /* the following move marks the viewed product, but will keep*/
       /* the product from being viewed again in the detail display*/
      if (AV0LM001.AV0LMSEL[AV0LWIXI] == "V") /* if selected style*/
        AVWREC.AVWSEL[AV0LWIXI] = " ";
      else
        AVWREC.AVWSEL[AV0LWIXI] = AV0LM001.AV0LMSEL[AV0LWIXI];
      end

      AVWREC.AVWCLMI[AV0LWIXI] = AV0LM001.AV0LWCLM[AV0LWIXI];

      AV0LW00.AV0LWIXI = AV0LW00.AV0LWIXI + 1; /* Increment sub*/

    end

    AV0LW00.AV0LWIXI = 99; /* End of search*/

    return; /* Return to prior process*/

  end

  AV0LW00.AV0LWIXI = AV0LW00.AV0LWIXI + 1; /* Increment sub*/


end // end AV0L132

// update temp storage w select
Function AV0L133()
   /* ------------------------------------------------------------*/
   /* move selection indicator to temp storage page and update*/
   /* ------------------------------------------------------------*/

  AV0LWIXI = 1; /* Set subscript to load product*/

  while (AV0LWIXI <= 14) /* Subscript in range*/
    if (AV0LM001.AV0LMSEL[AV0LWIXI] > " ") /* if selected or viewed*/
      AV0LW01.AV0LMSEL[AV0LWIXI] = AV0LM001.AV0LMSEL[AV0LWIXI];
    end
    AV0LW00.AV0LWIXI = AV0LW00.AV0LWIXI + 1; /* Increment sub*/
  end

   /* update temporary storage*/
  AV0LS19();

end // end AV0L133

// CHECK SELECT VALUES MAP 1
Function AV0L134()
   /* -----------------------------------------------------------*/
    /* THE PURPOSE OF THIS MODULE IS TO INSURE THAT THE USER*/
    /* DOES NOT KEY IN AN INVALID VALUE TO THE SELECT FIELD*/
    /* ON MAP ONE. VALID VALUES    THE USER MAY ENTER IS*/
    /* 'S'. THE OTHER VALID VALUES ARE SPACE AND 'V' THAT*/
    /* HAVE BEEN SYSTEM GENERATED.*/
   /* -----------------------------------------------------------*/

  sysVar.arrayIndex = 14; /* LAST SELECT INDEX*/

  while (sysVar.arrayIndex >= 1) /* UNTIL FIRST SELECT IS CURRENT*/

    if (AV0LM001.AV0LMSEL[sysVar.arrayIndex] != "S" /* USER ENTERED*/
     && AV0LM001.AV0LMSEL[sysVar.arrayIndex] != " " /* SYSTEM DEFAULT*/
     && AV0LM001.AV0LMSEL[sysVar.arrayIndex] != "V") /* SET BY AV0Q/R*/
      converseLib.validationFailed(215); /* INVALID CODE MESSAGE NUMBER*/
      AV0LM001.XXXMODID = "134"; /* THIS MODULE NUMBER*/
      set AV0LM001.AV0LMSEL[sysVar.arrayIndex] cursor, modified, bold;
    end

    sysVar.arrayIndex = sysVar.arrayIndex - 1; /* DECREMENT INDEX*/
  end

end // end AV0L134

// Reset highlighted fields
Function AV0L140()
   /* ------------------------------------------------------------*/
   /* Reset all modifiable field attributes to normal intensity.*/
   /* ------------------------------------------------------------*/

  AV0LW00.AV0LWIXM = 1; /* Initialize line index*/

  while (AV0LW00.AV0LWIXM <= 14) /* Until end of lines*/
     /* AND AV0LM001.XGPCD(AV0LWIXM) GT ' '  ; or end of display*/

    set AV0LM001.AV0LMSEL[AV0LWIXM] normal; /* Reset select flag*/

    AV0LW00.AV0LWIXM = AV0LW00.AV0LWIXM + 1; /* Increment line index*/

  end

  set AV0LM001.CATOAP initialAttributes; /* TO application*/
  set AV0LM001.CAITEM initialAttributes; /* Application data*/


end // end AV0L140

// Verify the entered data
Function AV0L150()
   /* ------------------------------------------------------------*/
   /* Highlight any application data that was entered.*/
   /* ------------------------------------------------------------*/

  if (AV0LM001.CAITEM > " ") /* Application data was enter*/

    AVWREC.XXXMODID = "150"; /* Module identification*/
    set AV0LM001.CAITEM cursor, bold; /* Highlight*/
    converseLib.validationFailed(23); /* Enter only with FAST PATH*/

  end

   /* ------------------------------------------------------------*/
   /* Determine whether a valid request to scroll was entered.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf7 /* Scroll back request*/
   || converseVar.eventKey is pf8) /* or scroll forward request*/

    AV0L151(); /* Verify scroll request*/

  else

    /* ------------------------------------------------------------*/
     /* Otherwise, if page was formatted, verify data in the line.*/
    /* ------------------------------------------------------------*/

    if (AV0LW00.TA5TSQIX > 0) /* Page was formatted*/

      AV0LW00.AV0LWIXM = 14; /* Initialize line index*/

      while (AV0LW00.AV0LWIXM > 0) /* Until end of lines*/

        AV0L152(); /* Verify data in the line*/

        AV0LW00.AV0LWIXM = AV0LW00.AV0LWIXM - 1; /* Decrement lin*/

      end

    end

  end

   /* ------------------------------------------------------------*/
   /* If any errors were found, exit to display the map.*/
   /* ------------------------------------------------------------*/

  if (converseVar.validationMsgNum != 0) /* Errors were found*/

    exit stack; /* Exit to display map*/

  end


end // end AV0L150

// Verify scroll request
Function AV0L151()
   /* ------------------------------------------------------------*/
   /* If scroll back was requested, ensure that pages exist.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf7 /* Scroll back request*/
   && AV0LW00.XXXTSPAG < 2)       /* and no previous pages*/

    AVWREC.XXXMODID = "151"; /* Module identification*/
    converseLib.validationFailed(10); /* At the top*/

  end

   /* ------------------------------------------------------------*/
   /* If scroll forward was requested, ensure that pages exist.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf8 /* Scroll forward request*/
   && AV0LW00.XXXTSPAG >= AV0LW00.TA5TSQIX) /* and no more page*/

    AVWREC.XXXMODID = "151"; /* Module identification*/
    converseLib.validationFailed(11); /* At the bottom*/

  end

   /* ------------------------------------------------------------*/
   /* Indicate an error for any data that was modified.*/
   /* ------------------------------------------------------------*/

  AV0LW00.AV0LWIXM = 14; /* Initialize line index*/

  while (AV0LW00.AV0LWIXM > 0) /* Until end of lines*/

    if (AV0LM001.AV0LMSEL[AV0LWIXM] == "S")

      AVWREC.XXXMODID = "151"; /* Module identificati*/
      set AV0LM001.AV0LMSEL[AV0LWIXM] cursor, bold; /* Highlight*/
      converseLib.validationFailed(272); /* Modifications not allowed*/

    end

    AV0LW00.AV0LWIXM = AV0LW00.AV0LWIXM - 1; /* Decrement line nu*/

  end


end // end AV0L151

// Verify data in the line
Function AV0L152()
   /* ------------------------------------------------------------*/
   /* If selection was entered and is not a "S", indicate that*/
   /* only "S" may be used to select a line. "V" is valid to*/
   /* indicate what has been viewed in the detail screen.*/
   /* ------------------------------------------------------------*/

  if (AV0LM001.AV0LMSEL[AV0LWIXM] != AV0LW01.AV0LMSEL[AV0LWIXM])
    if (AV0LM001.AV0LMSEL[AV0LWIXM] != "S" /* and is not a "S"*/
     && AV0LM001.AV0LMSEL[AV0LWIXM] != "V") /* and is not a "V"*/

      AVWREC.XXXMODID = "152"; /* Module identification*/
      set AV0LM001.AV0LMSEL[AV0LWIXM] cursor, bold; /* Highlight*/
      converseLib.validationFailed(215); /* Only "s" or 'v' or ' ' valid*/

    end
  end


end // end AV0L152

// Process valid input request
Function AV0L160()
   /* ------------------------------------------------------------*/
   /* Indicate that the map must be formatted before display.*/
   /* ------------------------------------------------------------*/

  AV0LW00.AV0LWSWF = "Y"; /* Format the map switch*/


   /* ------------------------------------------------------------*/
   /* If a scroll backward was requested, decrement the page*/
   /* number and return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf7) /* Scroll back requested*/

    AV0LW00.XXXTSPAG = AV0LW00.XXXTSPAG - 1; /* Decrement page number*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* If a scroll forward was requested, increment the page*/
   /* number and return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf8) /* Scroll forward requested*/

    AV0LW00.XXXTSPAG = AV0LW00.XXXTSPAG + 1; /* Increment page nbr*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* Save the select fields and clear the map input/output area.*/
   /* ------------------------------------------------------------*/

  AV0LW00.AV0LWIXM = 1; /* Initialize line index*/

  while (AV0LW00.AV0LWIXM <= 14) /* Until end of lines*/

    if (AV0LM001.AV0LMSEL[AV0LWIXM] != AV0LW01.AV0LMSEL[AV0LWIXM])

      AV0LW01.AV0LMSEL[AV0LWIXM] = AV0LM001.AV0LMSEL[AV0LWIXM];
      AV0LW00.AV0LWSWU = "Y"; /* Storage update switch*/

    end

    AV0LW00.AV0LWIXM = AV0LW00.AV0LWIXM + 1; /* Increment line in*/

  end


end // end AV0L160

// Get customer store name
Function AV0LS01()
   /* ------------------------------------------------------------*/
   /* Select the requested row from the table. (dcust.vstore01)*/
   /* ------------------------------------------------------------*/

  set KUMREC empty; /* Clear row storage area*/

  KUMREC.KUCCOID = AVWREC.KUCCOID; /* company id*/
  KUMREC.KUMSTRID = AVWREC.KUMSTRID; /* store id*/

  try
    call "IO0340" ("S ", SQLCA, KUMREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select table row*/

   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/

    if (SQLCA.VAGen_SQLCODE == 0) /* Normal return code*/

      return; /* Return to previous process*/

    end

    if (SQLCA.VAGen_SQLCODE == 100) /* Row not found*/

      AVWREC.KUMSTRNM = "* NOT FOUND *"; /* Store name*/

      return; /* Return to previous process*/

    end

  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  AVWREC.XXXMODID = "S01"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(75); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(76); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    converseLib.clearScreen();
     /* Clear screen before display*/

  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "OBTAIN CUST. NAME FOR HEADING";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = AVWREC.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DCUST   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VSTORE01"; /* Table view name*/
  TA1REC.TA1TBLKE = KUMREC.KUMGRP; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end AV0LS01

// Get codes from vcolor02
Function AV0LS02()
   /* ------------------------------------------------------------*/
   /* Get the product style/color record.*/
   /* ------------------------------------------------------------*/

  set SYCREC empty; /* Clear row storage area*/

  SYCREC.XGPCD = AVWREC.XGPCD; /* GPC code*/
  SYCREC.SY1STNBR = AVWREC.SY1STNBR; /* Style code*/
  SYCREC.SY2CLRID = AVWREC.SY2CLRID[1]; /* Color code*/
  SYCREC.XDMCD = AVWREC.XDMCD[1]; /* Dim code*/

  try
    call "IO0560" ("S ", SQLCA, SYCREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

   /* ------------------------------------------------------------*/
   /* If the call was successful, return to the previous precess.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/
    if (SQLCA.VAGen_SQLCODE == 0 /* Normal return code*/
     || SQLCA.VAGen_SQLCODE == 100) /* Row not found*/
      return; /* Return to previous process*/
    end
  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user*/
   /* otherwise, indicate that an unexpected error has occured.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL Commarea*/

  AVWREC.XXXMODID = "S02"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(75); /* Data was not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(76); /* Unexpected error occurred*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    converseLib.clearScreen();
     /* Clear screen before display*/

  end

  TA1REC.TA1TYPE = "DB2"; /* Type of error*/
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = AVWREC.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DPROD   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCOLOR02"; /* Table view name*/
  TA1REC.TA1TBLKE = SYCREC.SYCKEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  return; /* Exit to display map*/


end // end AV0LS02

// Get prices from vprice01
Function AV0LS03()
   /* ------------------------------------------------------------*/
   /* Get the product wholesale or retail price depending on*/
   /* sy5rec.xpycd set in av0l112.*/
   /* ------------------------------------------------------------*/

   /* ------------------------------------------------------------*/
   /* If Canadian logon, get Canadian pricing*/
   /* ------------------------------------------------------------*/

  sysVar.arrayIndex = 1; /* initialize subscript*/
  if (COMMAREA.XSOCD != "  ") /* logon Sales Office not blank*/
    while (AV01TBL.XSOCD[sysVar.arrayIndex] != "99" /* not end of table*/
     && AVWREC.XWHCD != "42") /* exit 'WHILE' if Canadian logon found*/
      if (COMMAREA.XSOCD == AV01TBL.XSOCD[sysVar.arrayIndex]) /* logon SO = table SO*/
        SY5REC.XCT-CTRY-CD = "CANA"; /* load Canada*/
        SY5REC.ZFC-CRCY-CD = "CAD"; /* load Canadian currency*/
      end
      sysVar.arrayIndex = sysVar.arrayIndex + 1; /* increment subscript*/
    end
  end
  if (SYCREC.SY1PRCZS == "S") /* Price at style level*/
    SY5REC.SY2CLRID = "***"; /* Splat to color code*/
    SY5REC.XDMCD = "**"; /* Splat to dim code*/

  else
    if (SYCREC.SY1PRCZS == "C") /* Price at colr/dim level*/
      SY5REC.SY2CLRID = AVWREC.SY2CLRID; /* Color code*/
      SY5REC.XDMCD = AVWREC.XDMCD; /* Dim code*/

    end
  end


  SY5REC.XGPCD = AVWREC.XGPCD; /* GPC code*/
  SY5REC.SY1STNBR = AVWREC.SY1STNBR; /* Style code*/
  SY5REC.SY5SZID = 0; /* Size id*/

  if (AVWREC.XQACD[2] > "  ") /* Check override Qual*/
    SY5REC.XQACD = AVWREC.XQACD[2]; /* Quality*/
  else
    SY5REC.XQACD = AVWREC.XQACD[1]; /* Quality*/
  end

   /* ------------------- SY5REC.XPYCD is moved in  AV0L112*/

  try
    call "IO0380" ("S ", SQLCA, SY5REC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

   /* ------------------------------------------------------------*/
   /* If the call was successful, return to the previous precess.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Normal return code*/
      AV0LW00.AV0LWPRF = "Y"; /* Row available*/
      return; /* Return to previous process*/
    end
  end

   /* if product is price by color and product not found*/
   /* try getting product by style*/

  if (SYCREC.SY1PRCZS == "C") /* Price at colr/dim level*/
    if (sysVar.errorCode == "00000000" /* call successful*/
     && SQLCA.VAGen_SQLCODE == 100)    /* if product not found*/
      SY5REC.SY2CLRID = "***"; /* Splat to color code*/
      SY5REC.XDMCD = "**"; /* Splat to dim code*/
      try
        call "IO0380" ("S ", SQLCA, SY5REC) {isNoRefresh = yes, isExternal = yes};
      end /* Select row*/

      if (sysVar.errorCode == "00000000") /* Call successful*/
        if (SQLCA.VAGen_SQLCODE == 0) /* Normal return code*/
          AV0LW00.AV0LWPRF = "Y"; /* Row available*/
          return; /* Return to previous process*/
        end
      end
    end
  end


   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user*/
   /* otherwise, indicate that an unexpected error has occured.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL Commarea*/

  AVWREC.XXXMODID = "S03"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(75); /* Data was not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else
    if (sysVar.errorCode == "00000000" /* Call successful*/
     && SQLCA.VAGen_SQLCODE == +100)   /* price not found*/

      AV0LW00.AV0LWPRF = "N"; /* Row not available*/
      return;

    else

      converseLib.validationFailed(76); /* Unexpected error occurred*/
      TA1REC.TA1FUNC = "RETN"; /* Termination function*/

      converseLib.clearScreen();
       /* Clear screen before display*/

    end
  end

  TA1REC.TA1TYPE = "DB2"; /* Type of error*/
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = AVWREC.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DPROD   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VPRICE01"; /* Table view name*/
  TA1REC.TA1TBLKE = SY5REC.SY5KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  return; /* Exit to display map*/


end // end AV0LS03

// Select the requested rows
Function AV0LS04()

   /* ------------------------------------------------------------*/
   /* Select the requested set of rows from DAVAIL.VSUBSY01.*/
   /* This is the marketing table.*/
   /* ------------------------------------------------------------*/

  set AVAREC empty; /* Clear row storage area*/

  AVAREC.XGPCD = AVWREC.XGPCD; /* GPC*/
  AVAREC.SY1STNBR = AVWREC.SY1STNBR; /* Style*/
  AVAREC.SY2CLRID = AVWREC.SY2CLRID[1]; /* Color*/
  AVAREC.XDMCD = AVWREC.XDMCD[1]; /* Dim*/

  try
    call "IO4840" ("S1", SQLCA, AVAREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select table set*/

   /* ------------------------------------------------------------*/
   /* If successful continue processing.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/

    return; /* Return to previous process*/

  end


   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that an unexpected error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  AVWREC.XXXMODID = "S04"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(75); /* Data was not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(76); /* Unexpected error occurred*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    converseLib.clearScreen();
     /* Clear screen before display*/

  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "AV0LS04";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = AVWREC.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DAVAIL  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VSUBSY01"; /* Table view name*/
  TA1REC.TA1TBLKE = AVAREC.AVAGPR; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end AV0LS04

// Fetch next row in the cursor
Function AV0LS05()
   /* ------------------------------------------------------------*/
   /* Fetch the next row to display. (davail.vsubsy01)*/
   /* ------------------------------------------------------------*/

  try
    call "IO4840" ("N1", SQLCA, AVAREC) {isNoRefresh = yes, isExternal = yes};
  end /* Fetch next row*/

   /* ------------------------------------------------------------*/
   /* If the call was successful, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Normal return code*/

      return; /* Return to previous process*/

    end

  end
   /* ------------------------------------------------------------*/
   /* If end of the selected set, indicate end of cursor.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/
    if (SQLCA.VAGen_SQLCODE == +100) /* End of selected set*/

      AV0LW00.AV0LWSWC = "Y"; /* Indicate end of cursor*/

      return; /* Return to previous process*/

    end

  end


   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  AVWREC.XXXMODID = "S05"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(75); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(76); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    converseLib.clearScreen();
     /* Clear screen before display*/

  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "AV0LS05";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = AVWREC.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DAVAIL  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VSUBSY01"; /* Table view name*/
  TA1REC.TA1TBLKE = AVAREC.AVAGPR; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end AV0LS05

// Check availability for subst
Function AV0LS06()
   /* ------------------------------------------------------------*/
   /* Zero accumulators.*/
   /* ------------------------------------------------------------*/

  AV0LW00.AV0LWAOQ = 00000; /* Zero at-once accumulator.*/
  AV0LW00.AV0LWFAQ = 00000; /* Zero first available accum.*/

  AV0LW00.AV0LWLO = 99; /* Set save low size bucket*/
  AV0LW00.AV0LWHI = 00; /* Set save high size bucket*/
  AV0LW00.AV0LWSLO = 41; /* Set save low size bucket*/
  AV0LW00.AV0LWSHI = 00; /* Set save high size bucket*/

   /* ------------------------------------------------------------*/
   /* get size scale record*/
   /* ------------------------------------------------------------*/

  set PG3REC empty;
  PG3REC.XGPCD = AV0LW02.XGPCD[AV0LWIXT];
  PG3REC.SY1STNBR = AV0LW02.SY1STNBR[AV0LWIXT];
  PG3REC.SY2CLRID = AV0LW02.SY2CLRID[AV0LWIXT];
  PG3REC.XDMCD = "00";

  AV0LS44(); /* check size scale record*/

   /* ------------------------------------------------------------*/
   /* Check availability.*/
   /* ------------------------------------------------------------*/

  AV0LS07(); /* check for at-once in range.*/

   /* ------------------------------------------------------------*/
   /* Check if at-once meets minimum quantity.*/
   /* If it doesn't, zero the accumulator.*/
   /* ------------------------------------------------------------*/

  if (AV0LW00.AV0LWAOQ >= AVWREC.AVWMNQTY) /* Qty. at least minimum*/

    /* NEXT SENTENCE*/

  else

    AV0LW00.AV0LWAOQ = 00000; /* Reset to zero*/

  end


   /* ------------------------------------------------------------*/
   /* Check for first available quantities then,*/
   /* Check if first-available meets minimum quantity.*/
   /* If it doesn't, zero the accumulator.*/
   /* ------------------------------------------------------------*/


  AV0LS12(); /* check for first available*/

  if (AV0LW00.AV0LWFAQ >= AVWREC.AVWMNQTY) /* Qty. at least minimum*/

    /* NEXT SENTENCE*/

  else

    AV0LW00.AV0LWFAQ = 00000; /* Reset to zero*/

  end

  AV0LW00.AV0LWLO = AV0LW00.AV0LWSLO; /* Set save low size bucket*/
  AV0LW00.AV0LWHI = AV0LW00.AV0LWSHI; /* Set save high size bucket*/
end // end AV0LS06

// Check for at-once qty.
Function AV0LS07()
   /* ------------------------------------------------------------*/
   /* Initialize the save low range. high range will be*/
     /* incremented from low range as buckets are searched.*/
   /* These ranges are used in size conversion for list screen.*/
   /* ------------------------------------------------------------*/

  AV0LW00.AV0LWSLO = 41; /* Set save low range*/

   /* ------------------------------------------------------------*/
   /* Select and open the cursor. (davail.vavqty02)*/
   /* ------------------------------------------------------------*/

  AV0LS08(); /* Select set and open cursor*/


   /* ------------------------------------------------------------*/
   /* Fetch and sum the at-once quantity which falls between the*/
     /* specified size range.*/
   /* Set the size bucket index to the low size in the range*/
     /* then search for at-once qty. until index > the high*/
     /* size in the range.*/
   /* ------------------------------------------------------------*/


   /* ------------------------------------------------------------*/
   /* Check for override from size for the range starting point.*/
   /* ------------------------------------------------------------*/

  if (AVWREC.AVWRQSZF > 0) /* Got override from size*/

    AV0LW00.AV0LWSZF = AVWREC.AVWRQSZF; /* move to work area*/

  else

    AV0LW00.AV0LWSZF = AVWREC.OPWRQSZF; /* move to work area*/

  end


   /* ------------------------------------------------------------*/
   /* Check for override to size for the range ending point.*/
   /* ------------------------------------------------------------*/

  if (AVWREC.AVWRQSZL > 0) /* Got override to size*/

    AV0LW00.AV0LWSZL = AVWREC.AVWRQSZL; /* move to work area*/

  else

    AV0LW00.AV0LWSZL = AVWREC.OPWRQSZL; /* move to work area*/

  end


   /* ------------------------------------------------------------*/
   /* Now go get those sizes within the range.*/
   /* ------------------------------------------------------------*/

  AV0LW00.AV0LWEFA = "N"; /* Set end of cursor switch*/

  while (AV0LW00.AV0LWEFA == "N") /* Until end of cursor*/

    AV0LS09(); /* Fetch next row in the cursor*/

    if (AV0LW00.AV0LWEFA == "N") /* Until end of cursor*/
      AV0LW00.AV0LWIXS = AV0LW00.AV0LWSZF; /* Index to first sz.*/

      while (AV0LW00.AV0LWIXS <= AV0LW00.AV0LWSZL /* While in range*/
       && AV7REC.AV5NQTY == "Y") /* and a 'n' record (at once)*/

        AV0LS10(); /* Sum at-once quantity*/

      end
    end
  end

   /* ------------------------------------------------------------*/
   /* Close the cursor for davail.vavqty02.*/
   /* ------------------------------------------------------------*/

  AV0LS11(); /* Close the selected set cursor*/


end // end AV0LS07

// Select set for availability
Function AV0LS08()
   /* ------------------------------------------------------------*/
   /* Select set for davail.vavqty02*/
   /* ------------------------------------------------------------*/


  set AV7REC empty; /* Clear row storage area*/


  if (AVWREC.XWHCD[2] > "  ") /* Got override warehouse*/

    AV7REC.XWHCD = AVWREC.XWHCD[2]; /* Use override whse*/

  else

    if (AVWREC.XWHCD[1] > "  ") /* Got override warehouse*/

      AV7REC.XWHCD = AVWREC.XWHCD[1]; /* Use override whse*/

    end
  end


  if (AV7REC.XWHCD == "* ") /* If wildcarded in av0k*/

    AV7REC.XWHCD = "**"; /* WHSE*/

  end

  AV7REC.XGPCD = AV0LW02.XGPCD[AV0LWIXT]; /* GPC*/
  AV7REC.SY1STNBR = AV0LW02.SY1STNBR[AV0LWIXT]; /* Style*/
  AV7REC.SY2CLRID = AV0LW02.SY2CLRID[AV0LWIXT]; /* Color*/
  AV7REC.XDMCD = AV0LW02.XDMCD[AV0LWIXT]; /* Dim*/
  AV7REC.XQACD = AV0LW02.XQACD[AV0LWIXT]; /* Qual*/
  AV7REC.XOWCD = AV0LW02.XOWCD[AV0LWIXT]; /* Owner grp*/
  AV7REC.XSDCD = AV0LW02.XSDCD[AV0LWIXT]; /* Spec*/
  AV7REC.XSACD = AV0LW02.XSACD[AV0LWIXT]; /* Shade*/
  AV7REC.XPGCD = AV0LW02.XPGCD[AV0LWIXT]; /* Pkg. type*/
  AV7REC.XUMCD = AV0LW02.XUMCD[AV0LWIXT]; /* UOM*/
  AV7REC.AV6RECTY = "F"; /* Rec type*/

  if (AV7REC.XGPCD == "03" /* If Apparel product*/
   && AV0LW02.XLCCD[AV0LWIXT] == "10")
    AV7REC.AV4PRDBD = 0; /* Period begin date*/
  else
    AV7REC.AV4PRDBD = -1; /* Period begin date*/
  end


  if (AVWREC.XGPCD == "03" /* apparel*/
   && AVWREC.XWHCD[2] == "* ") /* warehouse wildcarded*/
    try
      call "IO2370" ("S2", SQLCA, AV7REC) {isNoRefresh = yes, isExternal = yes};
    end /* Select table set*/
  else
    try
      call "IO2370" ("SS", SQLCA, AV7REC) {isNoRefresh = yes, isExternal = yes};
    end /* Select table set*/
  end


   /* ------------------------------------------------------------*/
   /* If successful, initialize the cursor switch.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that an unexpected error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  AVWREC.XXXMODID = "S08"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(75); /* Data was not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(76); /* Unexpected error occurred*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    converseLib.clearScreen();
     /* Clear screen before display*/

  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "SELECT SET OF TABLE ROWS";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = AVWREC.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DAVAIL  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VAVQTY02"; /* Table view name*/
  TA1REC.TA1TBLKE = AV7REC.AV7GRP; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end AV0LS08

// Fetch next availability row
Function AV0LS09()
   /* ------------------------------------------------------------*/
   /* Fetch the next row to display from the table.*/
   /* ------------------------------------------------------------*/

  if (AVWREC.XGPCD == "03" /* apparel*/
   && AVWREC.XWHCD[2] == "* ") /* warehouse wildcarded*/
    try
      call "IO2370" ("N2", SQLCA, AV7REC) {isNoRefresh = yes, isExternal = yes};
    end /* Fetch next row*/
  else
    try
      call "IO2370" ("SN", SQLCA, AV7REC) {isNoRefresh = yes, isExternal = yes};
    end /* Fetch next row*/
  end

   /* ------------------------------------------------------------*/
   /* If the call was successful, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/

    if (SQLCA.VAGen_SQLCODE == 0) /* Normal return code*/
      return; /* Return to previous process*/
    end

    /* ------------------------------------------------------------*/
     /* If end of the selected set, indicate end of cursor.*/
    /* ------------------------------------------------------------*/

    if (SQLCA.VAGen_SQLCODE == +100) /* End of selected set*/

      AV0LW00.AV0LWEFA = "Y"; /* Indicate end of cursor*/

      return; /* Return to previous process*/

    end

  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  AVWREC.XXXMODID = "S09"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(75); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(76); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    converseLib.clearScreen();
     /* Clear screen before display*/

  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "FETCH NEXT TABLE ROW";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = AVWREC.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DAVAIL  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VAVQTY02"; /* Table view name*/
  TA1REC.TA1TBLKE = AV7REC.AV7GRP; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end AV0LS09

// Sum at-once quantity
Function AV0LS10()
   /* ---------------------------------------------------------*/
   /* If condition code '01' (at-once) add to qty. sum bucket.*/
   /* Save the low and high size buckets to use to show the*/
     /* range on the list screen.*/
   /* Then increment the size bucket index by +1.*/
   /* ---------------------------------------------------------*/

  if (AV7REC.XCDCD[AV0LWIXS] == "01") /* At once cond. code*/
    AV0LW00.AV0LW1 = AV0LW00.AV0LWAOQ + AV7REC.AV1AVQTY[AV0LWIXS];
    AV0LW00.AV0LWAOQ = AV0LW00.AV0LW1;

    if (AV0LW00.AV0LWIXS > AV0LW00.AV0LWSHI) /* if higher than high*/
      AV0LW00.AV0LWSHI = AV0LW00.AV0LWIXS; /* Set high range*/
    end

    if (AV0LW00.AV0LWIXS < AV0LW00.AV0LWSLO) /* Bucket idx < low*/
      AV0LW00.AV0LWSLO = AV0LW00.AV0LWIXS; /* Set low range*/

    end
  end

   /* ---------------------------------------------------------*/
   /* Increment the size bucket index.*/
   /* ---------------------------------------------------------*/

  AV0LW00.AV0LWIXS = AV0LW00.AV0LWIXS + 1; /* Increment sz. bucket*/


end // end AV0LS10

// Close avail. qty. cursor
Function AV0LS11()
   /* ------------------------------------------------------------*/
   /* Close the selected set of table rows. (davail.vavqty02)*/
   /* ------------------------------------------------------------*/

  if (AVWREC.XGPCD == "03" /* apparel*/
   && AVWREC.XWHCD[2] == "* ") /* warehouse wildcarded*/
    try
      call "IO2370" ("C2", SQLCA, AV7REC) {isNoRefresh = yes, isExternal = yes};
    end /* Close table set*/
  else
    try
      call "IO2370" ("CS", SQLCA, AV7REC) {isNoRefresh = yes, isExternal = yes};
    end /* Close table set*/
  end

   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  AVWREC.XXXMODID = "S11"; /* Module identification*/
  converseLib.validationFailed(76); /* Indicate system error*/

  TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "CLOSE SELECTED SET OF TABLE ROWS";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = AVWREC.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DAVAIL  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VAVQTY02"; /* Table view name*/
  TA1REC.TA1TBLKE = AV7REC.AV7GRP; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end AV0LS11

// Check first available qty
Function AV0LS12()
   /* ------------------------------------------------------------*/
   /* Select and open the cursor. (davail.vavqty02)*/
   /* ------------------------------------------------------------*/

  AV0LS08(); /* Select set and open cursor*/


   /* ------------------------------------------------------------*/
   /* Fetch and sum the first avail quantity which falls between*/
     /* the specified size range.*/
     /* then search for book date or open book quantity until*/
     /* index > the high size in the range.*/
   /* ------------------------------------------------------------*/

   /* ------------------------------------------------------------*/
   /* Check for override from size for the range starting point.*/
   /* ------------------------------------------------------------*/

  if (AVWREC.AVWRQSZF > 0) /* Got override from size*/

    AV0LW00.AV0LWSZF = AVWREC.AVWRQSZF; /* move to work area*/

  else

    AV0LW00.AV0LWSZF = AVWREC.OPWRQSZF; /* move to work area*/

  end


   /* ------------------------------------------------------------*/
   /* Check for override to size for the range ending point.*/
   /* ------------------------------------------------------------*/

  if (AVWREC.AVWRQSZL > 0) /* Got override to size*/

    AV0LW00.AV0LWSZL = AVWREC.AVWRQSZL; /* move to work area*/

  else

    AV0LW00.AV0LWSZL = AVWREC.OPWRQSZL; /* move to work area*/

  end


   /* ------------------------------------------------------------*/
   /* Now go get those sizes within the range.*/
   /* ------------------------------------------------------------*/

  AV0LW00.AV0LWEFA = "N"; /* Set end of cursor switch*/

  while (AV0LW00.AV0LWEFA == "N") /* Until end of cursor*/

    AV0LS09(); /* Fetch next row in the cursor*/

    if (AV0LW00.AV0LWEFA == "N") /* Until end of cursor*/
      AV0LW00.AV0LWIXS = AV0LW00.AV0LWSZF; /* Index to first sz.*/

      while (AV0LW00.AV0LWIXS <= AV0LW00.AV0LWSZL /* While in range*/
       && AV7REC.AV5PQTY == "Y") /* And a 'P' rec*/

        AV0LS31(); /* Sum first avail quantity*/

      end
    end
  end

   /* ------------------------------------------------------------*/
   /* Close the cursor for davail.vavqty02.*/
   /* ------------------------------------------------------------*/

  AV0LS11(); /* Close the  cursor*/


end // end AV0LS12

// Select set for vcolor01
Function AV0LS14()
   /* ------------------------------------------------------------*/
   /* Select set for dprod.vcolor01*/
   /* ------------------------------------------------------------*/


  try
    call "IO0130" ("S2", SQLCA, SY2REC) {isNoRefresh = yes, isExternal = yes};
  end /* Select table set*/


   /* ------------------------------------------------------------*/
   /* If successful, initialize the cursor switch.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that an unexpected error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  AVWREC.XXXMODID = "S14"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(75); /* Data was not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(76); /* Unexpected error occurred*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    converseLib.clearScreen();
     /* Clear screen before display*/

  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "SELECT SET OF TABLE ROWS";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = AVWREC.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DPROD   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCOLOR01"; /* Table view name*/
  TA1REC.TA1TBLKE = SY2REC.SY2KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end AV0LS14

// Fetch next color row
Function AV0LS15()
   /* ------------------------------------------------------------*/
   /* Fetch the next row to display from dprod.vcolor01.*/
   /* ------------------------------------------------------------*/

  try
    call "IO0130" ("N2", SQLCA, SY2REC) {isNoRefresh = yes, isExternal = yes};
  end /* Fetch next row*/

   /* ------------------------------------------------------------*/
   /* If the call was successful, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/

    if (SQLCA.VAGen_SQLCODE == 0) /* Normal return code*/
      return; /* Return to previous process*/
    end

    /* ------------------------------------------------------------*/
     /* If end of the selected set, indicate end of cursor.*/
    /* ------------------------------------------------------------*/

    if (SQLCA.VAGen_SQLCODE == +100) /* End of selected set*/

      AV0LW00.AV0LWEC1 = "Y"; /* Indicate end of cursor*/

      return; /* Return to previous process*/

    end

  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  AVWREC.XXXMODID = "S15"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(75); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(76); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    converseLib.clearScreen();
     /* Clear screen before display*/

  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "FETCH NEXT TABLE ROW";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = AVWREC.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DPROD   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCOLOR01"; /* Table view name*/
  TA1REC.TA1TBLKE = SY2REC.SY2KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end AV0LS15

// Get substitute description
Function AV0LS16()
   /* ----------------------------------------------------------*/
   /* Get description for substitute style. (dprodg.vsyclr01)*/
   /* ----------------------------------------------------------*/

  if (AV0LW02.SY1STNBR[AV0LWIXT] == AVWREC.SY1STNBR)
    return;
  end

  PG2REC.XGPCD = AVWREC.XGPCD; /* GPC*/
  PG2REC.SY1STNBR = AV0LW02.SY1STNBR[AV0LWIXT]; /* Style*/
  PG2REC.SY2CLRID = AV0LW02.SY2CLRID[AV0LWIXT]; /* Color*/
  PG2REC.XDMCD = "00";

  call "IO3120" ("S ", SQLCA, PG2REC) {isNoRefresh = yes, isExternal = yes}; /* INQUIRY ONLY*/

  if (SQLCA.VAGen_SQLCODE == 100)
    AVWREC.XXXMODID = "S16"; /* Module identification*/
    converseLib.validationFailed(006); /* Style does not exist*/

  else

    if (SQLCA.VAGen_SQLCODE < 0)
      TA1REC.TA1TYPE = "DB2";
      TA1REC.TA1FUNC = "RETN";
      TA1REC.TA1DBASE = "DPRODG  "; /* DATA BASE NAME*/
      TA1REC.TA1TBLVU = "VSYCLR01"; /* TABLE NAME*/
      TA1REC.TA1LOCAT[3] = "AV0LS16 "; /* STATEMENT GROUP*/
      TA1REC.TA1LOCAT[4] = "IO3120  "; /* I/O MOD NAME*/
      TA1REC.TA1TBLKE = PG2REC.PG2KEY; /* Table key*/

      call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes}; /* CALL ABEND FORMATTER*/

      exit stack; /* Exit to display map*/

    else

      AV0LW02.SY2CLRAB[AV0LWIXT] = PG2REC.SY1SSTNM;

    end
  end


end // end AV0LS16

// Set cursor for catlg page nbr
Function AV0LS18()
   /* ------------------------------------------------------------*/
   /* Set the cursor for catalog page number (dprod.vcatlg01)*/
   /* ------------------------------------------------------------*/

  set SYNREC empty; /* Clear row storage area*/

  SYNREC.XGPCD = AV0LW02.XGPCD[AV0LWIXT]; /* GPC*/
  SYNREC.SY1STNBR = AV0LW02.SY1STNBR[AV0LWIXT]; /* STYLE*/
  SYNREC.SY2CLRID = AV0LW02.SY2CLRID[AV0LWIXT]; /* COLOR*/
  SYNREC.XDMCD = AVWREC.XDMCD; /* DIM*/

  if (SYNREC.XDMCD == "  ") /* No valid DIM*/

    SYNREC.XDMCD = "00"; /* DIM*/

  end


  try
    call "IO4880" ("S1", SQLCA, SYNREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select table set*/


   /* ------------------------------------------------------------*/
   /* If successful, initialize the line index and cursor switch.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that an unexpected error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

   /* MOVE 'S18' TO AVWREC.XXXMODID   ; Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(75); /* Data was not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(76); /* Unexpected error occurred*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    converseLib.clearScreen();
     /* Clear screen before display*/

  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "AV0LS18";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
   /* mOVE SYNREC.XXXMODID TO TA1REC.TA1PGMNO; Program number*/
  TA1REC.TA1DBASE = "DPROD   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCATLG01"; /* Table view name*/
  TA1REC.TA1TBLKE = SYNREC.SYNDATA; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end AV0LS18

// Update temporary storage page
Function AV0LS19()
   /* ------------------------------------------------------------*/
   /* Update the page in temporary storage.*/
   /* ------------------------------------------------------------*/

  TA5REC.TA5FNCCD = "U"; /* Function code*/

  try
    call "TA0050" (AV0LW01, TA5REC) {isNoRefresh = yes, isExternal = yes};
  end /* Temporary storage*/

   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && TA5REC.TA5RTNCD == 0)          /* and normal return code*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TAEREC.TAEDESC1 = sysVar.errorCode; /* CSP return code*/
  TAEREC.TAEDESC2 = TA5REC.TA5DATA; /* Subroutine parameters*/

  AVWREC.XXXMODID = "S19"; /* Module identification*/
  converseLib.validationFailed(76); /* Indicate system error*/

  TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  TA1REC.TA1TYPE = "APPL"; /* Type of error*/
  TA1REC.TA1LOC = "UPDATE PAGE IN TEMPORARY STORAGE";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = AVWREC.XXXMODID; /* Program number*/
  TA1REC.TA1MAPAP = COMMAREA.CACURRAP; /* Map application*/
  TA1REC.TA1MAPNO = "M001"; /* Map number*/

  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end AV0LS19

// Obtain temporary storage page
Function AV0LS20()
   /* ------------------------------------------------------------*/
   /* Obtain the next page of data to display.*/
   /* ------------------------------------------------------------*/

  AV0LW01.XXXTSLEN = AV0LW00.XXXTSLEN; /* Temporary storage length*/

  TA5REC.TA5APPID = COMMAREA.CACURRAP; /* Application identification*/
  TA5REC.TA5TSQIX = AV0LW00.XXXTSPAG; /* Page number*/
  TA5REC.TA5FNCCD = "R"; /* Function code*/

  try
    call "TA0050" (AV0LW01, TA5REC) {isNoRefresh = yes, isExternal = yes};
  end /* Temporary storage*/

   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && TA5REC.TA5RTNCD == 0)          /* and normal return code*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TAEREC.TAEDESC1 = sysVar.errorCode; /* CSP return code*/
  TAEREC.TAEDESC2 = TA5REC.TA5DATA; /* Subroutine parameters*/

  AVWREC.XXXMODID = "S20"; /* Module identification*/
  converseLib.validationFailed(76); /* Indicate system error*/

  TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  TA1REC.TA1TYPE = "APPL"; /* Type of error*/
  TA1REC.TA1LOC = "READ PAGE FROM TEMPORARY STORAGE";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = AVWREC.XXXMODID; /* Program number*/
  TA1REC.TA1MAPAP = COMMAREA.CACURRAP; /* Map application*/
  TA1REC.TA1MAPNO = "M001"; /* Map number*/

  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end AV0LS20

// Set cursor for silh grp code
Function AV0LS21()
   /* ------------------------------------------------------------*/
   /* Set cursor for silhouette group code. (dcorp.vsumcd01)*/
   /* ------------------------------------------------------------*/

  set YSMREC empty; /* Clear row storage area*/

  YSMREC.YSMTBLPF = "XSU"; /* Table prefix*/
  YSMREC.YSMSYSPF = "AV"; /* System prefix*/
  YSMREC.YSMSUMID = 1; /* Summary id*/
  YSMREC.YSMSUMCD = "**"; /* Summary code*/
  YSMREC.YSMSRCVL = AVWREC.XSUCD; /* silhouette code*/


  try
    call "IO2640" ("S1", SQLCA, YSMREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

   /* ------------------------------------------------------------*/
   /* If the call was successful, move silhouette group code to*/
   /* Avwrec else check for errors.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* Normal return code*/
    return; /* ; Return to previous process.*/

  else

    /* ------------------------------------------------------------*/
     /* If data not available, return an error message to the user*/
     /* otherwise, indicate that an unexpected error has occured.*/
    /* ------------------------------------------------------------*/

    TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
    TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL Commarea*/

    AVWREC.XXXMODID = "S21"; /* Module identification*/

    if (sysVar.errorCode == "00000000" /* Call successful*/
     && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

      converseLib.validationFailed(75); /* Data was not available*/
      TA1REC.TA1FUNC = "POST"; /* Termination function*/

    else

      converseLib.validationFailed(76); /* Unexpected error occurred*/
      TA1REC.TA1FUNC = "RETN"; /* Termination function*/

      converseLib.clearScreen();
       /* Clear screen before display*/

    end

    TA1REC.TA1TYPE = "DB2"; /* Type of error*/
    TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
    TA1REC.TA1PGMNO = AVWREC.XXXMODID; /* Program number*/
    TA1REC.TA1DBASE = "DCORP   "; /* Data base name*/
    TA1REC.TA1TBLVU = "VSUMCD01"; /* Table view name*/
    TA1REC.TA1TBLKE = YSMREC.YSMGRP; /* Table key*/

    call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    return; /* Exit to display map*/

  end


end // end AV0LS21

// Fetch silhouette group code
Function AV0LS23()
   /* ------------------------------------------------------------*/
   /* Fetch silhouette group code from Dcorp.vsumcd01*/
   /* ------------------------------------------------------------*/


  try
    call "IO2640" ("N1", SQLCA, YSMREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

   /* ------------------------------------------------------------*/
   /* If the call was successful, move silhouette group code to*/
   /* Avwrec else check for errors.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* Normal return code*/
    AVWREC.YSMXSU = YSMREC.YSMSUMCD; /* silhouette group code*/

  else

    /* ------------------------------------------------------------*/
     /* If data not available, return an error message to the user*/
     /* otherwise, indicate that an unexpected error has occured.*/
    /* ------------------------------------------------------------*/

    TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
    TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL Commarea*/

    AVWREC.XXXMODID = "S23"; /* Module identification*/

    if (sysVar.errorCode == "00000000" /* Call successful*/
     && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

      converseLib.validationFailed(75); /* Data was not available*/
      TA1REC.TA1FUNC = "POST"; /* Termination function*/

    else

      converseLib.validationFailed(76); /* Unexpected error occurred*/
      TA1REC.TA1FUNC = "RETN"; /* Termination function*/

      converseLib.clearScreen();
       /* Clear screen before display*/

    end

    TA1REC.TA1TYPE = "DB2"; /* Type of error*/
    TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
    TA1REC.TA1PGMNO = AVWREC.XXXMODID; /* Program number*/
    TA1REC.TA1DBASE = "DCORP   "; /* Data base name*/
    TA1REC.TA1TBLVU = "VSUMCD01"; /* Table view name*/
    TA1REC.TA1TBLKE = YSMREC.YSMGRP; /* Table key*/

    call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    return; /* Exit to display map*/

  end


end // end AV0LS23

// Close cursor for silh grp cd.
Function AV0LS24()
   /* ------------------------------------------------------------*/
   /* Close cursor for Dcorp.vsumcd01. (silh group code)*/
   /* ------------------------------------------------------------*/


  try
    call "IO2640" ("C1", SQLCA, YSMREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

   /* ------------------------------------------------------------*/
   /* If the call was successful, move silhouette group code to*/
   /* Avwrec else check for errors.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* Normal return code*/
    return; /* Return to previous process*/

  else

    /* ------------------------------------------------------------*/
     /* If data not available, return an error message to the user*/
     /* otherwise, indicate that an unexpected error has occured.*/
    /* ------------------------------------------------------------*/

    TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
    TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL Commarea*/

    AVWREC.XXXMODID = "S24"; /* Module identification*/

    if (sysVar.errorCode == "00000000" /* Call successful*/
     && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

      converseLib.validationFailed(75); /* Data was not available*/
      TA1REC.TA1FUNC = "POST"; /* Termination function*/

    else

      converseLib.validationFailed(76); /* Unexpected error occurred*/
      TA1REC.TA1FUNC = "RETN"; /* Termination function*/

      converseLib.clearScreen();
       /* Clear screen before display*/

    end

    TA1REC.TA1TYPE = "DB2"; /* Type of error*/
    TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
    TA1REC.TA1PGMNO = AVWREC.XXXMODID; /* Program number*/
    TA1REC.TA1DBASE = "DCORP   "; /* Data base name*/
    TA1REC.TA1TBLVU = "VSUMCD01"; /* Table view name*/
    TA1REC.TA1TBLKE = YSMREC.YSMGRP; /* Table key*/

    call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    return; /* Exit to display map*/

  end


end // end AV0LS24

// Add page to display storage
Function AV0LS25()
   /* ------------------------------------------------------------*/
   /* Add the next page to temporary storage.*/
   /* ------------------------------------------------------------*/

  AV0LW01.XXXTSLEN = AV0LW00.XXXTSLEN; /* Temporary storage length*/

  TA5REC.TA5APPID = COMMAREA.CACURRAP; /* Application identification*/
  TA5REC.TA5FNCCD = "A"; /* Function code*/

  try
    call "TA0050" (AV0LW01, TA5REC) {isNoRefresh = yes, isExternal = yes};
  end /* Temporary storage*/

   /* ------------------------------------------------------------*/
   /* If successful, initialize the storage area and indicators*/
   /* to be used.  Return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && TA5REC.TA5RTNCD == 0)          /* and normal return code*/

    set AV0LW01 empty; /* M001 display storage*/

    AV0LW00.AV0LWIXM = 1; /* Display line index*/

    AV0LW00.TA5TSQIX = TA5REC.TA5TSQIX; /* Highest page number*/
    TA5REC.TA5TSQIX = 0; /* Current page number*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TAEREC.TAEDESC1 = sysVar.errorCode; /* CSP return code*/
  TAEREC.TAEDESC2 = TA5REC.TA5DATA; /* Subroutine parameters*/

  AVWREC.XXXMODID = "S25"; /* Module identification*/
  converseLib.validationFailed(76); /* Indicate system error*/

  TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  TA1REC.TA1TYPE = "APPL"; /* Type of error*/
  TA1REC.TA1LOC = "ADD PAGE TO TEMPORARY STORAGE";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = AVWREC.XXXMODID; /* Program number*/
  TA1REC.TA1MAPAP = COMMAREA.CACURRAP; /* Map application*/
  TA1REC.TA1MAPNO = "M001"; /* Map number*/

  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end AV0LS25

// Get catalog entry
Function AV0LS26()
   /* ------------------------------------------------------------*/
   /* Calculate the catalog seasons and years.*/
   /* ------------------------------------------------------------*/
   /* Use the available catalog information as follows:*/
     /* 1.  Use the current season catalog (if available)*/
     /* 2.  otherwise, use the next season catalog (if available)*/
     /* 3.  otherwise, use the latest catalog found (if present)*/
     /* 4.  otherwise, move 'n/a' (not applicable) to catalog.*/
   /* To accomplish this move the default (#4) to the catalog*/
   /* field then loop through the catalog entries once, until*/
   /* the end of them or the current season catalog is found.*/
   /* While we are looping fill the fields with the catalog data*/
   /* found, overlaying only if the data is higher on the list.*/
   /* ------------------------------------------------------------*/

  AV0LW00.AV0LWEFC = "N"; /* Init end of cursor flag*/
  AV0LW00.AV0LWCPN = "N/A"; /* Default to this*/
  AV0LS84();
  if (AV0LW00.AV0LWEFC != "Y") /* first one found*/
    AV0LW00.AV0LWCID = SYNREC.SYRCATID; /* Catalog identifier*/
    AV0LW00.AV0LWPNB = SYNREC.SYNCTPGN; /* Catalog page number*/
  end

  while (AV0LW00.AV0LWEFC != "Y")
    AV0LW00.AV0LWCWA = SYNREC.SYRCATID; /* move to work area*/
    if (AV0LW00.AV0LWCW2 == AV0LW00.AV0LWSCT) /* current season cat*/
      AV0LW00.AV0LWCID = SYNREC.SYRCATID; /* Catalog identifier*/
      AV0LW00.AV0LWPNB = SYNREC.SYNCTPGN; /* Catalog page number*/
      AV0LW00.AV0LWEFC = "Y"; /* stop loop*/
    else
      if (AV0LW00.AV0LWCW2 == AV0LW00.AV0LWNCT) /* next season catalog*/
        AV0LW00.AV0LWCID = SYNREC.SYRCATID; /* Catalog identifier*/
        AV0LW00.AV0LWPNB = SYNREC.SYNCTPGN; /* Catalog page number*/
      else

        /* ------------- Y2K OUT BEGIN -------------*/

        /* MOVE AV0LW00.AV0LWCID TO AV0LW00.AV0LW-SYRCATID1;/* mve to work*/
        /* MOVE SYNREC.SYRCATID TO AV0LW00.AV0LW-SYRCATID2;/* mve to work*/

        /* IF AV0LW00.AV0LW-SYRCATYY2 > AV0LW00.AV0LW-SYRCATYY1;/**/

        /* ------------- Y2K OUT END   -------------*/

        /* --------------------- Y2K IN BEGIN -----------/**/

        AV0LW00.AV0LW-SYRCATID1 = AV0LW00.AV0LWCID;
        AV0LW00.AV0LW-SYRCATID2 = SYNREC.SYRCATID;
        AV0LW00.AV0LW-YY1 = AV0LW00.AV0LW-SYRCATYY1;
        AV0LW00.AV0LW-YY2 = AV0LW00.AV0LW-SYRCATYY2;

        /* initialize first date*/

        if (AV0LW00.AV0LW-SYRCATYY1 < 60)
          AV0LW-CC1 = 20;
        else
          AV0LW-CC1 = 19;
        end

        /* Can't be certain about comparison unless both dates are*/
        /* initialized.*/

        if (AV0LW00.AV0LW-SYRCATYY2 < 60)
          AV0LW-CC2 = 20;
        else
          AV0LW-CC2 = 19;
        end

           /* do the comparison now using century/year*/

        if (AV0LW00.AV0LW-DATE1 > AV0LW00.AV0LW-DATE2)

          /* --------------------- Y2K IN END -------------/**/

          AV0LW00.AV0LWCID = SYNREC.SYRCATID; /* Catalog identifier*/
          AV0LW00.AV0LWPNB = SYNREC.SYNCTPGN; /* Catalog page number*/
        else
          if (AV0LW00.AV0LW-SYRCATYY2 == AV0LW00.AV0LW-SYRCATYY1) /**/
            if (AV0LW00.AV0LW-SYRCATSS2 != AV0LW00.AV0LW-SYRCATSS1)
              if (AV0LW00.AV0LW-SYRCATSS2 == "HO")
                AV0LW00.AV0LWCID = SYNREC.SYRCATID; /**/
                AV0LW00.AV0LWPNB = SYNREC.SYNCTPGN; /**/
              else
                if (AV0LW00.AV0LW-SYRCATSS2 == "FA"
                 && AV0LW00.AV0LW-SYRCATSS1 != "HO")
                  AV0LW00.AV0LWCID = SYNREC.SYRCATID; /**/
                  AV0LW00.AV0LWPNB = SYNREC.SYNCTPGN; /**/
                end
              end
            end
          end
        end
      end
    end
    AV0LS84();
  end

  return;

end // end AV0LS26

// Close catlg. pg. cursor
Function AV0LS27()
   /* ------------------------------------------------------------*/
   /* Close cursor for dprod.vcatlg01  (catalog page number)*/
   /* ------------------------------------------------------------*/

  try
    call "IO4880" ("C1", SQLCA, SYNREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select table set*/

   /* ------------------------------------------------------------*/
   /* If successful, return to previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that an unexpected error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  AVWREC.XXXMODID = "S27"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(75); /* Data was not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(76); /* Unexpected error occurred*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    converseLib.clearScreen();
     /* Clear screen before display*/

  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "AV0LS27";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = AVWREC.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DPROD   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCATLG01"; /* Table view name*/
  TA1REC.TA1TBLKE = SYNREC.SYNDATA; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end AV0LS27

// Check to continue processing
Function AV0LS28()
   /* ----------------------------------------------------------*/
   /* Check to see if substitute available, continue if so,*/
    /* else return to fetch another substitute.*/
   /* ----------------------------------------------------------*/

  if (AV0LW00.AV0LWAOQ == 00000 /* No at-once quantity*/
   && AV0LW00.AV0LWFAQ == 00000) /* And no first avail qty.*/

    return;

  end


  AV0LS16(); /* Get the product description*/

  if (PG2REC.SY2ALNOR == "N") /* if new orders not being taken*/
    return; /* bypass this product*/
  end

   /* ---------------------------------------------------------*/
   /* Find and move size description for the start*/
   /* and end of the range.*/
   /* ---------------------------------------------------------*/
  AV0LW00.AV0LWIXF = AV0LW00.AV0LWLO; /* Set start size sub*/
  AV0LW01.AV0LWFSZ[AV0LWIXM] = PG3REC.SY4IDDSC[AV0LWIXF];
  AV0LW00.AV0LWIXF = AV0LW00.AV0LWHI; /* Set end size sub*/
  AV0LW01.AV0LWTSZ[AV0LWIXM] = PG3REC.SY4IDDSC[AV0LWIXF];

  AV0LS18(); /* Set cursor for catlg page*/

  AV0LS26(); /* Fetch 1st row for catlg pg.*/

  AV0LS27(); /* Close cursor for catlg page*/

  AV0LS32(); /* Save data in display storage*/


   /* ------------------------------------------------------------*/
   /* Add any full page to temporary storage.*/
   /* ------------------------------------------------------------*/

  if (AV0LW00.AV0LWIXM > 14) /* Full page is formatted*/

    AV0LS25(); /* Add page to temporary storage*/

  end


end // end AV0LS28

// Get curr date + 30 days
Function AV0LS29()
   /* ---------------------------------------------------------*/
   /* Get the date 30 working days out for a six day work week.*/
   /* This will be used for the first available date cutoff for*/
   /* footwear and promo.*/
   /* ------------------------------------------------------------*/

  set TA9REC empty; /* Clear row storage area*/

  AV0LW00.AV0LWDT1 = VGVar.currentShortGregorianDate; /* Sys dt to work area*/
  if (AV0LW00.AV0LWDY1 > 70) /**/
    AV0LW00.AV0LW-WDC1 = 19; /* Set century*/
  else
    AV0LW00.AV0LW-WDC1 = 20; /* Set century*/
  end
  TA9REC.TA9BEGCC = AV0LW00.AV0LW-WDC1; /* Century to ta9rec*/
  TA9REC.TA9BEGYY = AV0LW00.AV0LWDY1; /* Year to ta9rec*/
  TA9REC.TA9BEGMM = AV0LW00.AV0LWDM1; /* Month to ta9rec*/
  TA9REC.TA9BEGDD = AV0LW00.AV0LWDD1; /* Day to ta9rec*/

  TA9REC.TA9ENDDT = 000000000; /* Set end date to 0*/

  TA9REC.TA9OFSET = +30; /* date + 30 days*/

  call "TA0190" (TA9REC) {isNoRefresh = yes, isExternal = yes}; /* Call date routine*/

   /* ------------------------------------------------------------*/
   /* If the call was not successful, return error message.*/
     /* Else move date + 30 days to working storage area.*/
   /* ------------------------------------------------------------*/

  if (TA9REC.TA9RTNFL != 0)
    AV0LM001.XXXMODID = "AV0LS12";
    converseLib.validationFailed(112); /* problem with ta0190*/
    return;

  else

     /* date + 30 days is moved to working storage area (ccyymmdd)*/

    AV0LW00.AV0LWDTP = TA9REC.TA9RTNDT;

  end


end // end AV0LS29

// Close cursor  - vsubsy01
Function AV0LS30()
   /* ------------------------------------------------------------*/
   /* Close cursor for davail.vsubsy01. (marketing table)*/
   /* ------------------------------------------------------------*/

  try
    call "IO4840" ("C1", SQLCA, AVAREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select table set*/

   /* ------------------------------------------------------------*/
   /* If successful, return to previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that an unexpected error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  AVWREC.XXXMODID = "S30"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(75); /* Data was not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(76); /* Unexpected error occurred*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    converseLib.clearScreen();
     /* Clear screen before display*/

  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "AV0LS30";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = AVWREC.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DAVAIL  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VSUBSY01"; /* Table view name*/
  TA1REC.TA1TBLKE = AVAREC.AVAGPR; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end AV0LS30

// Sum first avail quantity
Function AV0LS31()
   /* ---------------------------------------------------------*/
   /* If condition code '02' (book date) or '04' (open book)*/
     /* and valid period date add to qty. sum bucket*/
     /* and > or = the minimum quantity needed.*/
   /* Save the low and high size buckets to use to show the*/
     /* range on the list screen.*/
   /* Then increment the size bucket index by +1.*/
   /* ---------------------------------------------------------*/

   /* ---------------------------------------------------------*/
   /* if valid for gpc 01 within 30 days.*/
   /* ---------------------------------------------------------*/

  if (AV7REC.XGPCD == "01") /* If PROMO*/
    if (AV7REC.AV5CDDT[AV0LWIXS] <= AV0LW00.AV0LWDTP) /* within 30 days*/
      if (AV7REC.XCDCD[AV0LWIXS] == "02" /* Book date cond. code*/
       || AV7REC.XCDCD[AV0LWIXS] == "04") /* Open book cond. code*/

        AV0LW00.AV0LW1 = AV0LW00.AV0LWFAQ + AV7REC.AV1AVQTY[AV0LWIXS];
        AV0LW00.AV0LWFAQ = AV0LW00.AV0LW1; /* First avail updated*/
        if (AV0LW00.AV0LWIXS > AV0LW00.AV0LWSHI) /* if higher than high*/
          AV0LW00.AV0LWSHI = AV0LW00.AV0LWIXS; /* Set high range*/
        end
        if (AV0LW00.AV0LWIXS < AV0LW00.AV0LWSLO) /* Bucket idx < low*/
          AV0LW00.AV0LWSLO = AV0LW00.AV0LWIXS; /* Set low range*/
        end
      end
    end
  end


   /* ---------------------------------------------------------*/
   /* if valid for gpc 02 within 30 days.*/
   /* ---------------------------------------------------------*/

  if (AV7REC.XGPCD == "02") /* If FOOTWEAR*/
    if (AV7REC.AV5CDDT[AV0LWIXS] <= AV0LW00.AV0LWDTP) /* within 30 days*/
      if (AV7REC.XCDCD[AV0LWIXS] == "02" /* Book date cond. code*/
       || AV7REC.XCDCD[AV0LWIXS] == "04") /* Open book cond. code*/

        AV0LW00.AV0LW1 = AV0LW00.AV0LWFAQ + AV7REC.AV1AVQTY[AV0LWIXS];
        AV0LW00.AV0LWFAQ = AV0LW00.AV0LW1; /* First avail updated*/
        if (AV0LW00.AV0LWIXS > AV0LW00.AV0LWSHI) /* if higher than high*/
          AV0LW00.AV0LWSHI = AV0LW00.AV0LWIXS; /* Set high range*/
        end
        if (AV0LW00.AV0LWIXS < AV0LW00.AV0LWSLO) /* Bucket idx < low*/
          AV0LW00.AV0LWSLO = AV0LW00.AV0LWIXS; /* Set low range*/
        end
      end
    end
  end


   /* ------------------------------------------------------------*/
   /* if valid for gpc 03 within season and need dte*/
   /* ------------------------------------------------------------*/

  if (AV7REC.XGPCD == "03") /* If APPAREL*/
    if (AV7REC.AV5CDDT[AV0LWIXS] <= AV0LW00.AV0LWNDT) /* within range*/
      if (AV7REC.XCDCD[AV0LWIXS] == "02" /* Book date cond. code*/
       || AV7REC.XCDCD[AV0LWIXS] == "04") /* Open book cond. code*/

        AV0LW00.AV0LW1 = AV0LW00.AV0LWFAQ + AV7REC.AV1AVQTY[AV0LWIXS];
        AV0LW00.AV0LWFAQ = AV0LW00.AV0LW1; /* First avail updated*/
        if (AV0LW00.AV0LWIXS > AV0LW00.AV0LWSHI) /* if higher than high*/
          AV0LW00.AV0LWSHI = AV0LW00.AV0LWIXS; /* Set high range*/
        end
        if (AV0LW00.AV0LWIXS < AV0LW00.AV0LWSLO) /* Bucket idx < low*/
          AV0LW00.AV0LWSLO = AV0LW00.AV0LWIXS; /* Set low range*/
        end
      end
    end
  end




   /* ---------------------------------------------------------*/
   /* Increment the size bucket index.*/
   /* ---------------------------------------------------------*/

  AV0LW00.AV0LWIXS = AV0LW00.AV0LWIXS + 1; /* Increment sz. bucket*/


end // end AV0LS31

// Save data in display storage
Function AV0LS32()
   /* ------------------------------------------------------------*/
   /* If the first line on a page, save the heading information.*/
   /* ------------------------------------------------------------*/

  if (AV0LW00.AV0LWIXM == 1) /* First line on page*/

    AV0LW01.OP1ORDBY = AVWREC.OP1ORDBY; /* Contact*/
    AV0LW01.KUMSTRNM = AVWREC.KUMSTRNM; /* Store name*/
    AV0LW01.KUMCITYS = AVWREC.KUMCITYS; /* City name*/
    AV0LW01.KUMXSTCD = AVWREC.KUMXSTCD; /* State abrv.*/
    AV0LW01.SY1STNBR = AVWREC.SY1STNBR; /* Orig. style*/
    AV0LW01.SY1SSTNM = AVWREC.SY1SSTNM; /* Style desc*/
    AV0LW01.XQACD = AVWREC.XQACD; /* Quality*/

    if (AVWREC.SY2CLRID[2] > "  ") /* Orig. color ovrd.*/
      AV0LW01.SY2CLRID = AVWREC.SY2CLRID[2]; /* Orig. color*/
      AV0LW01.SY2CLRAB = AVWREC.SY2CLRAB; /* Color desc.*/
    else
      AV0LW01.SY2CLRID = AVWREC.SY2CLRID[1]; /* Orig. color*/
      AV0LW01.SY2CLRAB = AVWREC.SY2CLRAB; /* Color desc.*/

    end


    if (AVWREC.XGACD[2] > "  ") /* Orig. gend/age ovrd.*/
      AV0LW01.XGACD = AVWREC.XGACD[2]; /* Orig. gend/age*/
    else
      AV0LW01.XGACD = AVWREC.XGACD[1]; /* Orig. gend/age*/

    end

    if (AVWREC.XPCCD[2] > "  ") /* Orig. prod cat ovrd.*/
      AV0LW01.XPCCD = AVWREC.XPCCD[2]; /* Orig. prod cat*/
    else
      AV0LW01.XPCCD = AVWREC.XPCCD[1]; /* Orig. prod cat*/

    end

    if (AVWREC.XDMCD[2] > "  ") /* Orig dimension override*/
      AV0LW01.XDMCD = AVWREC.XDMCD[2]; /* move overried*/
    else
      AV0LW01.XDMCD = AVWREC.XDMCD[1]; /* move original*/
    end

    if (AV0LW01.XDMCD in XDMTBL.XDMCD)
      AV0LW01.XDMDESC = XDMTBL.XDMDESC[sysVar.arrayIndex];
    end /* get description*/

  end


   /* ------------------------------------------------------------*/
   /* Save the data from the table row in display storage.*/
   /* ------------------------------------------------------------*/

  AV0LW01.AV0LMSEL[AV0LWIXM] = " "; /* Select field*/

   /* --------------------------------------- Style*/
  AV0LW01.AVASBSTY[AV0LWIXM] = AV0LW02.SY1STNBR[AV0LWIXT];

   /* --------------------------------------- Color*/
  AV0LW01.AVASBCLR[AV0LWIXM] = AV0LW02.SY2CLRID[AV0LWIXT];

   /* --------------------------------------- Dimension*/
  AV0LW01.AVASBDIM[AV0LWIXM] = AV0LW02.XDMCD[AV0LWIXT];

   /* --------------------------------------- Description*/
  AV0LW01.AV0LWSND[AV0LWIXM] = AV0LW02.SY2CLRAB[AV0LWIXT];

   /* --------------------------------------- Catalog page number*/
  AV0LW01.AV0LWCPN[AV0LWIXM] = AV0LW00.AV0LWCPN;

   /* ----------------------------------- Color Match indicator*/
  AV0LW01.AV0LWCLM[AV0LWIXM] = AV0LW02.AV0LWCM[AV0LWIXT];


  if (AV0LW00.AV0LWAOQ > 00000) /* Got at-once quantity*/

    AV0LW01.AV0LWAOI[AV0LWIXM] = "*"; /* at-once indicator*/

  end


   /* -------------------------------- Total quantity calculated*/
   /* -------------------------------- at once + first available*/
  AV0LW00.AV0LW2 = AV0LW00.AV0LWAOQ + AV0LW00.AV0LWFAQ;
  AV0LW01.AV0LWTLQ[AV0LWIXM] = AV0LW00.AV0LW2;


   /* ------------------------------------------------------------*/
   /* Turn on flag to indicate this substitute from the marketing*/
    /* table so that it can be highlighted on the map.*/
   /* ------------------------------------------------------------*/

  AV0LW01.AV0LWMTS[AV0LWIXM] = "Y"; /* Indicate from MKT. TABLE*/


  AV0LW00.AV0LWIXM = AV0LW00.AV0LWIXM + 1; /* Increment line idx*/


end // end AV0LS32

// Load product table
Function AV0LS34()
   /* ------------------------------------------------------------*/
   /* This expands the original product information to include*/
     /* all the valid colors for that product as potential*/
     /* substitutes. The original color is not used because that*/
     /* is why where here in the first place to find a*/
     /* substitute for it.*/
   /* ------------------------------------------------------------*/

  if (SY2REC.SY2CLRID == AVWREC.SY2CLRID[1]) /* And orig. color same*/

    return; /* Skip loading*/

  end


  AV0LW02.XGPCD[AV0LWIXT] = SY2REC.XGPCD; /* GPC*/
  AV0LW02.SY1STNBR[AV0LWIXT] = SY2REC.SY1STNBR; /* Style*/
  AV0LW02.SY2CLRID[AV0LWIXT] = SY2REC.SY2CLRID; /* Color*/
  AV0LW02.SY2CLRAB[AV0LWIXT] = SY2REC.SY2CLRAB; /* Color desc*/

  AV0LW02.XQACD[AV0LWIXT] = AVWREC.XQACD[1]; /* Qual*/
  AV0LW02.XOWCD[AV0LWIXT] = AVWREC.XOWCD; /* Own Grp*/
  AV0LW02.XSDCD[AV0LWIXT] = AVWREC.XSDCD; /* Spec*/
  AV0LW02.XSACD[AV0LWIXT] = AVWREC.XSACD; /* Shade*/
  AV0LW02.XPGCD[AV0LWIXT] = AVWREC.XPGCD; /* Pkg Typ*/
  if (AVWREC.XLCCD[2] > "  ") /* override exists*/
    AV0LW02.XLCCD[AV0LWIXT] = AVWREC.XLCCD[2]; /* life cycle*/
  else
    AV0LW02.XLCCD[AV0LWIXT] = AVWREC.XLCCD[1]; /* life cycle*/
  end
  if (AVWREC.XDMCD[2] > "  ") /* override exists*/
    AV0LW02.XDMCD[AV0LWIXT] = AVWREC.XDMCD[2]; /* Dim*/
  else
    AV0LW02.XDMCD[AV0LWIXT] = AVWREC.XDMCD[1]; /* Dim*/
  end
  if (AVWREC.XUMCD[2] > "  ") /* override exists*/
    AV0LW02.XUMCD[AV0LWIXT] = AVWREC.XUMCD[2]; /* UOM*/
  else
    AV0LW02.XUMCD[AV0LWIXT] = AVWREC.XUMCD[1]; /* UOM*/
  end


  AV0LWIXT = AV0LWIXT + 1; /* Increment subscript*/


end // end AV0LS34

// Close color01 cursor
Function AV0LS35()
   /* ------------------------------------------------------------*/
   /* Close the selected set of table rows. (dprod.vcolor01)*/
   /* ------------------------------------------------------------*/

  try
    call "IO0130" ("C2", SQLCA, SY2REC) {isNoRefresh = yes, isExternal = yes};
  end /* Close table set*/

   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  AVWREC.XXXMODID = "S35"; /* Module identification*/
  converseLib.validationFailed(76); /* Indicate system error*/

  TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "CLOSE SELECTED SET OF TABLE ROWS";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = AVWREC.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DPROD   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCOLOR01"; /* Table view name*/
  TA1REC.TA1TBLKE = SY2REC.SY2KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end AV0LS35

// Get product attributes - gpc03
Function AV0LS36()
   /* ------------------------------------------------------------*/
   /* Go to the apparel criteria table (davail.vsubap02) to get*/
   /* all of the products for a certain style, color, dim.  The*/
   /* set of products returned will be used to compare the*/
   /* attributes of the products to the override attributes to*/
   /* ensure that only matching entries are displayed.*/
   /* ------------------------------------------------------------*/
   /* Set up for the call to the IOMOD.*/
   /* ------------------------------------------------------------*/

  AVCREC.SY1STNBR = SY2REC.SY1STNBR; /* style*/
  AVCREC.SY2CLRID = SY2REC.SY2CLRID; /* color*/
  AVCREC.XDMCD = SY2REC.XDMCD; /* dim*/

   /* ------------------------------------------------------------*/
   /* Select and open the cursor. (davail.vsubap02)*/
   /* ------------------------------------------------------------*/

  AVFREC.AVFIOTSK = "S2"; /* Select set 2*/

  AV0LS62(); /* Open cursor*/

   /* ------------------------------------------------------------*/
   /* Fetch and process valid criteria substitutes.*/
   /* ------------------------------------------------------------*/

   /* --------------------------------------IO-TASK*/
  AVFREC.AVFIOTSK = "N2"; /* Fetch next row*/

  AV0LW00.AV0LWEC2 = "N"; /* Set end of cursor switch*/

  AV0LS63(); /* Fetch next row in the cursor*/

  while (AV0LW00.AV0LWEC2 == "N") /* While not end of file*/

    if (AVCREC.XSECD == "  ") /* If new seasonless record*/

      AV0LW00.AV0LWFNF = "N"; /* set found/not found to not*/

      AV0LS86();

      if (AV0LW00.AV0LWFNF == "N")
       /* next sentence*/
      else

        if (AVCREC.SY1STNBR == AVWREC.SY1STNBR) /* Product = orig. prod.*/

         /* NEXT SENTENCE*/

        else

         /* ------------------------------------------------------------*/
          /* Check for color match between marketing table and color tbl*/
         /* ------------------------------------------------------------*/

          if (AVAREC.AVASBCLR == SY2REC.SY2CLRID) /* Got color match*/

            AV0LW02.AV0LWCM[AV0LWIXT] = "*"; /* Set color match ind.*/

          else

            AV0LW02.AV0LWCM[AV0LWIXT] = " "; /* Set color match ind.*/

          end

         /* ------------------------------------------------------------*/
          /* Load the work table entry*/
         /* ------------------------------------------------------------*/

          AV0LW02.XGPCD[AV0LWIXT] = SY2REC.XGPCD; /* GPC*/
          AV0LW02.SY1STNBR[AV0LWIXT] = SY2REC.SY1STNBR; /* Style*/
          AV0LW02.SY2CLRID[AV0LWIXT] = SY2REC.SY2CLRID; /* Color*/
          AV0LW02.SY2CLRAB[AV0LWIXT] = SY2REC.SY2CLRAB; /* Color desc*/
          AV0LW02.XDMCD[AV0LWIXT] = SY2REC.XDMCD; /* Dim*/
          AV0LW02.XQACD[AV0LWIXT] = AVCREC.XQACD; /* Qual*/
          AV0LW02.XOWCD[AV0LWIXT] = AVWREC.XOWCD; /* Own Grp*/
          AV0LW02.XSDCD[AV0LWIXT] = AVWREC.XSDCD; /* Spec*/
          AV0LW02.XSACD[AV0LWIXT] = AVWREC.XSACD; /* Shade*/
          AV0LW02.XPGCD[AV0LWIXT] = AVWREC.XPGCD; /* Pkg Typ*/
          AV0LW02.XUMCD[AV0LWIXT] = AVCREC.XUMCD; /* UOM*/

          AV0LWIXT = AV0LWIXT + 1; /* increment subscript*/

        end

      end

    end

    AV0LS63(); /* Fetch next row in the cursor*/

  end

   /* ------------------------------------------------------------*/
   /* Close the cursor for Davail.vsubap02*/
   /* ------------------------------------------------------------*/

  AVFREC.AVFIOTSK = "C2"; /* Close cursor 2*/

  AV0LS70(); /* Close the selected set cursor*/


end // end AV0LS36

// Check life cycle of color
Function AV0LS37()
   /* ------------------------------------------------------------*/
   /* Go to the footwear criteria table (davail.vsubfw02) to get*/
   /* all of the products for a certain gpc, style, color, dim.*/
   /* The set of products returned will be used to compare the*/
   /* attributes of the products to the override attributes to*/
   /* ensure that only matching entries are displayed.*/
   /* ------------------------------------------------------------*/
   /* Set up for the call to the IOMOD.*/
   /* ------------------------------------------------------------*/

  AVBREC.XGPCD = SY2REC.XGPCD; /* gpc*/
  AVBREC.SY1STNBR = SY2REC.SY1STNBR; /* style*/
  AVBREC.SY2CLRID = SY2REC.SY2CLRID; /* color*/
  AVBREC.XDMCD = SY2REC.XDMCD; /* dim*/

   /* ------------------------------------------------------------*/
   /* Select and open the cursor. (davail.vsubfw02)*/
   /* ------------------------------------------------------------*/

  AVEREC.AVEIOTSK = "S2"; /* Select Set 2*/

  AV0LS45(); /* Open cursor*/

   /* ------------------------------------------------------------*/
   /* Fetch and process valid criteria substitutes.*/
   /* ------------------------------------------------------------*/

   /* --------------------------------------IO-TASK*/

  AVEREC.AVEIOTSK = "N2"; /* Fetch net row*/
  AV0LW00.AV0LWFNF = "N"; /* Set found/not found flag*/
  AV0LW00.AV0LWEC2 = "N"; /* Set end of cursor switch*/

  AV0LS46(); /* Fetch next row in the cursor*/

  while (AV0LW00.AV0LWEC2 == "N") /* While not end of file*/

    AV0LW00.AV0LWFNF = "N"; /* set found/not-found to no*/

    AV0LS87();

    if (AV0LW00.AV0LWFNF == "N")
      /* next sentence*/
    else

      if (AVBREC.SY1STNBR == AVWREC.SY1STNBR) /* Product = orig. prod.*/

        /* NEXT SENTENCE*/

      else

        /* ------------------------------------------------------------*/
         /* Check for color match between marketing table and color tbl*/
        /* ------------------------------------------------------------*/

        if (AVAREC.AVASBCLR == SY2REC.SY2CLRID) /* Got color match*/

          AV0LW02.AV0LWCM[AV0LWIXT] = "*"; /* Set color match ind.*/

        else

          AV0LW02.AV0LWCM[AV0LWIXT] = " "; /* Set color match ind.*/

        end

        /* ------------------------------------------------------------*/
         /* Load the work table entry*/
        /* ------------------------------------------------------------*/

        AV0LW02.XGPCD[AV0LWIXT] = SY2REC.XGPCD; /* GPC*/
        AV0LW02.SY1STNBR[AV0LWIXT] = SY2REC.SY1STNBR; /* Style*/
        AV0LW02.SY2CLRID[AV0LWIXT] = SY2REC.SY2CLRID; /* Color*/
        AV0LW02.SY2CLRAB[AV0LWIXT] = SY2REC.SY2CLRAB; /* Color desc*/
        AV0LW02.XDMCD[AV0LWIXT] = SY2REC.XDMCD; /* Dim*/
        AV0LW02.XQACD[AV0LWIXT] = AVBREC.XQACD; /* Qual*/
        AV0LW02.XOWCD[AV0LWIXT] = AVWREC.XOWCD; /* Own Grp*/
        AV0LW02.XSDCD[AV0LWIXT] = AVWREC.XSDCD; /* Spec*/
        AV0LW02.XSACD[AV0LWIXT] = AVWREC.XSACD; /* Shade*/
        AV0LW02.XPGCD[AV0LWIXT] = AVWREC.XPGCD; /* Pkg Typ*/
        AV0LW02.XUMCD[AV0LWIXT] = AVBREC.XUMCD; /* UOM*/

        AV0LWIXT = AV0LWIXT + 1; /* increment subscript*/

      end

    end

    AV0LS46(); /* Fetch next row in the cursor*/

  end

   /* ------------------------------------------------------------*/
   /* Close the cursor for Davail.vsubfw02*/
   /* ------------------------------------------------------------*/

  AVEREC.AVEIOTSK = "C2"; /* Close Cursor 1*/

  AV0LS47(); /* Close the selected set cursor*/

end // end AV0LS37

// Load product table
Function AV0LS38()
   /* ------------------------------------------------------------*/
   /* Filter by life cycle for other colors of orig product*/
   /* ------------------------------------------------------------*/

  if (AVWREC.XLCCD[2] > "  ") /* life cycle override exists*/
    if (SY2REC.XLCCD1 == AVWREC.XLCCD[2] /* override life cycle*/
     && SY2REC.SY2CEDT1 <= XX0XW01.XX0XWDAT) /* And date current*/
      AV0LS34(); /* Load work table*/

    else
      if (SY2REC.XLCCD2 == AVWREC.XLCCD[2]    /* override life cycle*/
       && SY2REC.SY2CEDT2 <= XX0XW01.XX0XWDAT /* Current date*/
       && SY2REC.SY2CEDT1 > XX0XW01.XX0XWDAT) /* Future date*/
        AV0LS34(); /* Load work table*/

      else
        if (SY2REC.XLCCD3 == AVWREC.XLCCD[2]    /* override life cycle*/
         && SY2REC.SY2CEDT3 <= XX0XW01.XX0XWDAT /* Current date*/
         && SY2REC.SY2CEDT1 > XX0XW01.XX0XWDAT  /* Future date*/
         && SY2REC.SY2CEDT2 > XX0XW01.XX0XWDAT) /* Future date*/
          AV0LS34(); /* Load work table*/

        else
          if (SY2REC.XLCCD4 == AVWREC.XLCCD[2]    /* override life cycle*/
           && SY2REC.SY2CEDT4 <= XX0XW01.XX0XWDAT /* Current date*/
           && SY2REC.SY2CEDT1 > XX0XW01.XX0XWDAT  /* Future date*/
           && SY2REC.SY2CEDT2 > XX0XW01.XX0XWDAT  /* Future date*/
           && SY2REC.SY2CEDT3 > XX0XW01.XX0XWDAT) /* Future date*/
            AV0LS34(); /* Load work table*/

          end
        end
      end
    end
  else
    if (SY2REC.XLCCD1 == "10" /* only life cycle 10*/
     && SY2REC.SY2CEDT1 <= XX0XW01.XX0XWDAT) /* And date current*/
      AV0LS34(); /* Load work table*/

    else
      if (SY2REC.XLCCD2 == "10"               /* only life cycle 10*/
       && SY2REC.SY2CEDT2 <= XX0XW01.XX0XWDAT /* Current date*/
       && SY2REC.SY2CEDT1 > XX0XW01.XX0XWDAT) /* Future date*/
        AV0LS34(); /* Load work table*/

      else
        if (SY2REC.XLCCD3 == "10"               /* only life cycle 10*/
         && SY2REC.SY2CEDT3 <= XX0XW01.XX0XWDAT /* Current date*/
         && SY2REC.SY2CEDT1 > XX0XW01.XX0XWDAT  /* Future date*/
         && SY2REC.SY2CEDT2 > XX0XW01.XX0XWDAT) /* Future date*/
          AV0LS34(); /* Load work table*/

        else
          if (SY2REC.XLCCD4 == "10"               /* only life cycle 10*/
           && SY2REC.SY2CEDT4 <= XX0XW01.XX0XWDAT /* Current date*/
           && SY2REC.SY2CEDT1 > XX0XW01.XX0XWDAT  /* Future date*/
           && SY2REC.SY2CEDT2 > XX0XW01.XX0XWDAT  /* Future date*/
           && SY2REC.SY2CEDT3 > XX0XW01.XX0XWDAT) /* Future date*/
            AV0LS34(); /* Load work table*/

          end
        end
      end
    end
  end
end // end AV0LS38

// Get mkt. tbl. subst colors
Function AV0LS40()
   /* ------------------------------------------------------------*/
   /* Select and open the cursor. (dprod.vcolor01)*/
   /* ------------------------------------------------------------*/

  set SY2REC empty; /* Clear row storage area*/

  SY2REC.XGPCD = AVAREC.XGPCD; /* GPC*/
  SY2REC.SY1STNBR = AVAREC.AVASBSTY; /* Style*/
  SY2REC.SY2CLRID = "***"; /* color*/
  SY2REC.XDMCD = AVAREC.AVASBDIM; /* dimension*/

  AV0LS14(); /* Open cursor*/


   /* ------------------------------------------------------------*/
   /* Fetch and load valid colors into working storage table.*/
   /* ------------------------------------------------------------*/

  AV0LW00.AV0LWEC1 = "N"; /* Set end of cursor switch*/

  AV0LS15(); /* Fetch next row in the cursor*/

  while (AV0LW00.AV0LWEC1 == "N") /* Until end of cursor*/
    /* ------------------------------------------------------------*/
     /* Determine life cycle.*/
    /* ------------------------------------------------------------*/
    if (SY2REC.SY2CEDT1 <= XX0XW01.XX0XWDAT) /* curr life cycle dt*/
      AV0LW02.XLCCD[AV0LWIXT] = SY2REC.XLCCD1; /* move code*/
    else
      if (SY2REC.SY2CEDT2 <= XX0XW01.XX0XWDAT) /* curr life cycle dt*/
        AV0LW02.XLCCD[AV0LWIXT] = SY2REC.XLCCD2; /* move code*/
      else
        if (SY2REC.SY2CEDT3 <= XX0XW01.XX0XWDAT) /* curr life cycle dt*/
          AV0LW02.XLCCD[AV0LWIXT] = SY2REC.XLCCD3; /* move code*/
        else
          if (SY2REC.SY2CEDT4 <= XX0XW01.XX0XWDAT) /* curr life cycle dt*/
            AV0LW02.XLCCD[AV0LWIXT] = SY2REC.XLCCD4; /* move code*/
          else
            AV0LW02.XLCCD[AV0LWIXT] = "10"; /* move code*/
          end
        end
      end
    end

    if (SY2REC.XGPCD == "03") /* if apparel*/
      AV0LS36(); /* process apparel products*/
    else
      AV0LS37(); /* process non-apparel products*/
    end

    AV0LS15(); /* Fetch next row in the cursor*/

  end

   /* ------------------------------------------------------------*/
   /* Close the cursor for Dprod.vcolor01.*/
   /* ------------------------------------------------------------*/

  AV0LS35(); /* Close the selected set cursor*/


end // end AV0LS40

// Footwear Path
Function AV0LS41()
   /* ------------------------------------------------------------*/
   /* Set up criteria for select set.*/
   /* ------------------------------------------------------------*/

  set AVBREC empty; /* Clear row storage area*/

  AV0LS50(); /* Start of search set-up*/

   /* ------------------------------------------------------------*/
   /* Check for full page while doing more than the first pass*/
   /* (first 20 rows). If full, clear and set subscript for any*/
   /* further substitutes.*/
   /* ------------------------------------------------------------*/

  if (AV0LW00.AV0LWFPF == "F") /* Have a full page in work area*/

    set AV0LW01 empty; /* Clear work area for map*/
    AV0LW00.AV0LWIXM = 1; /* Reset subscript for map*/

  end


   /* ------------------------------------------------------------*/
   /* Select and open the cursor. (davail.vsubfw02)*/
   /* ------------------------------------------------------------*/

  AVEREC.AVEIOTSK = "S1"; /* Select Set 1*/

  AV0LS45(); /* Open cursor*/

   /* ------------------------------------------------------------*/
   /* Fetch and process valid criteria substitutes.*/
   /* ------------------------------------------------------------*/
   /* --------------------------------------IO-TASK*/
  AVEREC.AVEIOTSK = "N1"; /* Fetch net row*/
  AV0LW00.AV0LWFNF = "N"; /* Set found/not found flag*/
  AV0LW00.AV0LWEC2 = "N"; /* Set end of cursor switch*/

  AV0LS46(); /* Fetch next row in the cursor*/

  AV0LW00.AV0LWIXG = 1; /* Set fetch counter*/

  while (AV0LW00.AV0LWEC2 == "N" /* While not end of file*/
   && AV0LW00.AV0LWIXG <= 200) /* Only fetch 200 rows per pass*/

    AV0LS77(); /* Check if duplicate substitute*/

    if (AV0LW00.AV0LWFNF == "F" /* Product is a duplicate*/
     || AVBREC.SY1STNBR == AVWREC.SY1STNBR) /* product =  orig. prod.*/
      /* next sentence*/
    else
      if (AVBREC.XPCCD > AVWREC.AVWSPC) /* Prod. Cat. out of range*/
        AV0LW00.AV0LWEC2 = "Y"; /* Set end of file flag*/
      else

        AV0LS52(); /* Check availability*/
        AV0LS60(); /* Process substitute*/

      end
    end

    AV0LS46(); /* Fetch next row in the cursor*/

    AV0LW00.AV0LWIXG = AV0LW00.AV0LWIXG + 1; /* Increment fetch cntr.*/

  end

   /* ------------------------------------------------------------*/
   /* Close the cursor for Davail.vsubfw02*/
   /* ------------------------------------------------------------*/

  AVEREC.AVEIOTSK = "C1"; /* Close Cursor 1*/

  AV0LS47(); /* Close the selected set cursor*/

end // end AV0LS41

// Apparel Path
Function AV0LS42()
   /* ------------------------------------------------------------*/
   /* Set up criteria for select set.*/
   /* ------------------------------------------------------------*/


  set AVCREC empty; /* Clear row storage area*/

  AV0LS61(); /* Start of search set-up*/


   /* ------------------------------------------------------------*/
   /* Check for full page while doing more than the first pass*/
   /* (first 20 rows). If full, clear and set subscript for any*/
   /* further substitutes.*/
   /* ------------------------------------------------------------*/

  if (AV0LW00.AV0LWFPF == "F") /* Have a full page in work area*/

    set AV0LW01 empty; /* Clear work area for map*/

    AV0LW00.AV0LWIXM = 1; /* Reset subscript for map*/

  end

   /* ------------------------------------------------------------*/
   /* Select and open the cursor. (davail.vsubap02)*/
   /* ------------------------------------------------------------*/

  AVFREC.AVFIOTSK = "S1"; /* Fetch net row*/

  AV0LS62(); /* Open cursor*/

   /* ------------------------------------------------------------*/
   /* Fetch and process valid criteria substitutes.*/
   /* ------------------------------------------------------------*/

   /* --------------------------------------IO-TASK*/
  AVFREC.AVFIOTSK = "N1"; /* Fetch net row*/

  AV0LW00.AV0LWEC2 = "N"; /* Set end of cursor switch*/

  AV0LS63(); /* Fetch next row in the cursor*/

  AV0LW00.AV0LWIXG = 1; /* Set fetch counter*/

  while (AV0LW00.AV0LWEC2 == "N" /* While not end of file*/
   && AV0LW00.AV0LWIXG <= 200) /* Only fetch 200 rows per pass*/

    AV0LS78(); /* Check for duplicate sub (crit/mkt)*/

    if (AVCREC.AV1CUPRC < AVWREC.AVWPLO    /* Price less than range*/
     || AVCREC.AV1CUPRC > AVWREC.AVWPHI    /* Price more than range*/
     || AVCREC.SY1STNBR == AVWREC.SY1STNBR /* Product = orig. prod.*/
     || AV0LW00.AV0LWFNF == "F")           /* Product is duplicate*/

      /* NEXT SENTENCE*/

    else

      AV0LS73(); /* Check availability*/

      AV0LS74(); /* Process substitute*/

    end

    AV0LS63(); /* Fetch next row in the cursor*/

    AV0LW00.AV0LWIXG = AV0LW00.AV0LWIXG + 1; /* Increment fetch cntr.*/

  end

   /* ------------------------------------------------------------*/
   /* Close the cursor for Davail.vsubap02*/
   /* ------------------------------------------------------------*/

  AVFREC.AVFIOTSK = "C1"; /* Fetch net row*/

  AV0LS70(); /* Close the selected set cursor*/

end // end AV0LS42

// Get non-aprl/ftwr mktg tbl prd
Function AV0LS43()
   /* ------------------------------------------------------------*/
   /* Search the marketing table (davail.vsubsy01) for substitute*/
    /* for a non-apparel-ftwr source product.*/
   /* ------------------------------------------------------------*/
   /* ------------------------------------------------------------*/
   /* Select and open the cursor for davail.vsubsy01.*/
   /* ------------------------------------------------------------*/

  AV0LW00.AV0LWSWC = "N"; /* End of cursor switch*/

  AV0LS04(); /* Select set and open cursor*/


   /* ------------------------------------------------------------*/
   /* Fetch and load product table until end of cursor.*/
   /* ------------------------------------------------------------*/

  AV0LS05(); /* Fetch next row in vsubsy01*/

  while (AV0LW00.AV0LWSWC == "N") /* Until end of vsubsy01*/

    /* ------------------------------------------------------------*/
     /* This loads non-aprl/ftwr substitute products as found on*/
     /* the marketing table (davail.vsubsy01).*/
    /* ------------------------------------------------------------*/

    AV0LW02.XGPCD[AV0LWIXT] = AVAREC.XGPCD; /* GPC*/
    AV0LW02.SY1STNBR[AV0LWIXT] = AVAREC.AVASBSTY; /* Style*/
    AV0LW02.SY2CLRID[AV0LWIXT] = "00"; /* Color*/
    AV0LW02.XDMCD[AV0LWIXT] = AVWREC.XDMCD[1]; /* Dim*/
    AV0LW02.XQACD[AV0LWIXT] = AVWREC.XQACD[1]; /* Qual*/
    AV0LW02.XOWCD[AV0LWIXT] = AVWREC.XOWCD; /* Own Grp*/
    AV0LW02.XSDCD[AV0LWIXT] = AVWREC.XSDCD; /* Spec*/
    AV0LW02.XSACD[AV0LWIXT] = AVWREC.XSACD; /* Shade*/
    AV0LW02.XPGCD[AV0LWIXT] = AVWREC.XPGCD; /* Pkg Typ*/
    AV0LW02.XUMCD[AV0LWIXT] = AVWREC.XUMCD[1]; /* UOM*/

    AV0LWIXT = AV0LWIXT + 1; /* Increment subscript*/

    AV0LS05(); /* Fetch next row in vsubsy01*/

  end

   /* ------------------------------------------------------------*/
   /* Close the cursor for the selected set. (davail.vsubsy01)*/
   /* ------------------------------------------------------------*/

  AV0LS30(); /* Close cursor for vsubsy01*/



end // end AV0LS43

// find closest sizes
Function AV0LS44()
   /* ---------------------------------------------------------*/
     /* we're here to get the beginning and ending sizes, both*/
     /* internal and external. we will take the ones that*/
     /* are closest to the parameters given.*/
   /* ---------------------------------------------------------*/

  PG3REC.PG3RETCD = " "; /* clear return code field*/
  PG3REC.XQACD = "**"; /* Use first quality*/
  PG3REC.PG3FUNCD = "PC"; /* All valid sizes*/
  PG3REC.PG3DATFM = "N"; /* NOT Compressed sizes*/

   /* ---------------------------------------------------------*/
   /* call pg1050*/
   /* ---------------------------------------------------------*/

  try
    call "PG1050" (SQLCA, PG3REC) {isNoRefresh = yes, isExternal = yes};
  end /* get size record*/

  if (sysVar.errorCode == "00000000" /* if no errors found*/
   && PG3REC.PG3RETCD == "00")      

    if (PG3REC.XGPCD == "02")

      AV0LS51(); /* footwear*/

    else

      AV0LS48(); /* apparel*/

    end

    return; /* Return to calling process*/

  else

    /* ------------------------------------------------------------*/
     /* If data not available, post an error message and return.*/
     /* Otherwise, indicate that a system error has occurred.*/
    /* ------------------------------------------------------------*/

    if (sysVar.errorCode == "00000000" /* Call successful*/
     && PG3REC.PG3RETCD == "09")       /* and resource not available*/

      TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
      TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

      TA1REC.TA1FUNC = "POST"; /* Termination function*/
      TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
      TA1REC.TA1DBASE = "DPRODG  "; /* Data base name*/
      TA1REC.TA1TBLVU = "VSYCLR01"; /* Table view name*/
      TA1REC.TA1LOC = "AV0LS44";
      TA1REC.TA1TBLKE = PG3REC.PG3KEY; /* Table key*/

      call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    else

      if (sysVar.errorCode == "00000000" /* Call successful*/
       && PG3REC.PG3RETCD == "99")       /* and negative SQL error*/

        TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
        TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

        TA1REC.TA1FUNC = "RETN"; /* Termination function*/
        TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
        TA1REC.TA1DBASE = "DPRODG  "; /* Data base name*/
        TA1REC.TA1TBLVU = "VSYCLR01"; /* Table view name*/
        TA1REC.TA1TBLKE = PG3REC.PG3KEY; /* Table key*/
        TA1REC.TA1LOC = "AV0LS44";

        call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

      else

        TAEREC.TAEDESC1 = sysVar.errorCode; /* CSP return code*/
        TAEREC.TAEDESC2 = PG3REC.PG3GROUP; /* Subroutine parameters*/

        TA1REC.TA1FUNC = "RETN"; /* Termination function*/
        TA1REC.TA1TYPE = "APPL"; /* Type of error*/
        TA1REC.TA1LOC = "AV0LS44";

        call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

      end

    end
  end
end // end AV0LS44

// Select set for vsubfw02
Function AV0LS45()
   /* ------------------------------------------------------------*/
   /* Select set for davail.vsubfw02*/
   /* ------------------------------------------------------------*/

   /* --------------------------------------IO-TASK*/

  try
    call "IO4850" (AVEREC, SQLCA, AVBREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select set*/

   /* ------------------------------------------------------------*/
   /* If successful, initialize the cursor switch.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that an unexpected error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  AVWREC.XXXMODID = "S45"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(75); /* Data was not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(76); /* Unexpected error occurred*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    converseLib.clearScreen();
     /* Clear screen before display*/

  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "SELECT SET OF TABLE ROWS";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = AVWREC.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DAVAIL  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VSUBFW02"; /* Table view name*/
  TA1REC.TA1TBLKE = AVBREC.AVBGPR; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end AV0LS45

// Fetch next FTWR extract rec
Function AV0LS46()
   /* ------------------------------------------------------------*/
   /* Fetch the next row to display from davail.vsubfw02*/
   /* ------------------------------------------------------------*/

  try
    call "IO4850" (AVEREC, SQLCA, AVBREC) {isNoRefresh = yes, isExternal = yes};
  end /* Fetch next row*/

   /* ------------------------------------------------------------*/
   /* If the call was successful, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/

    if (SQLCA.VAGen_SQLCODE == 0) /* Normal return code*/
      return; /* Return to previous process*/
    end

    /* ------------------------------------------------------------*/
     /* If end of the selected set, indicate end of cursor.*/
    /* ------------------------------------------------------------*/

    if (SQLCA.VAGen_SQLCODE == +100) /* End of selected set*/

      AV0LW00.AV0LWEC2 = "Y"; /* Indicate end of cursor*/

      return; /* Return to previous process*/

    end

  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  AVWREC.XXXMODID = "S46"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(75); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(76); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    converseLib.clearScreen();
     /* Clear screen before display*/

  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "FETCH NEXT TABLE ROW";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = AVWREC.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DAVAIL  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VSUBFW02"; /* Table view name*/
  TA1REC.TA1TBLKE = AVBREC.AVBGPR; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end AV0LS46

// Close cursor for vsubfw02
Function AV0LS47()
   /* ------------------------------------------------------------*/
   /* Close the selected set of table rows. (davail.vsubfw02)*/
   /* ------------------------------------------------------------*/

   /* --------------------------------------IO-TASK*/

  try
    call "IO4850" (AVEREC, SQLCA, AVBREC) {isNoRefresh = yes, isExternal = yes};
  end /* Close table set*/

   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  AVWREC.XXXMODID = "S47"; /* Module identification*/
  converseLib.validationFailed(76); /* Indicate system error*/

  TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "CLOSE SELECTED SET OF TABLE ROWS";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = AVWREC.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DAVAIL  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VSUBFW02"; /* Table view name*/
  TA1REC.TA1TBLKE = AVBREC.AVBGPR; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end AV0LS47

// find apparel size ranges
Function AV0LS48()
   /* for apparel - if the beginning size is in the array, use it.*/
   /* and others    if not in the array, use the first non-blank one.*/
                   /* - if the ending size is in the array, use it.*/
                     /* if not in the array, use the last one that's*/
                     /* not zeros.*/


      /* beginning size*/


  if (AV0LW00.AV0LWORF in PG3REC.SY4IDDSC)
    AVWREC.AVWRQSZF = PG3REC.SY5SZID[sysVar.arrayIndex]; /* use it if there*/
    AV0LW01.AV0LWFSZ[AV0LWIXM] = PG3REC.SY4IDDSC[sysVar.arrayIndex];
  else
    AV0LW00.AV0LWIXJ = 1; /* find first non-blank size*/
    while (AV0LW00.AV0LWIXJ <= 40) /* While in range*/
      if (PG3REC.SY4IDDSC[AV0LWIXJ] > " ")
        AVWREC.AVWRQSZF = PG3REC.SY5SZID[AV0LWIXJ];
        AV0LW01.AV0LWFSZ[AV0LWIXM] = PG3REC.SY4IDDSC[AV0LWIXJ];
        AV0LW00.AV0LWIXJ = 41; /* end loop*/
      else
        AV0LW00.AV0LWIXJ = AV0LW00.AV0LWIXJ + 1; /* decrement subscript*/
      end
    end
  end

      /* ending size*/

  if (AV0LW00.AV0LWORL in PG3REC.SY4IDDSC)
    AVWREC.AVWRQSZL = PG3REC.SY5SZID[sysVar.arrayIndex]; /* use it if there*/
    AV0LW01.AV0LWTSZ[AV0LWIXM] = PG3REC.SY4IDDSC[sysVar.arrayIndex];
  else
    AV0LW00.AV0LWIXJ = 40; /* find ending size*/
    while (AV0LW00.AV0LWIXJ >= 1) /* While in range*/
      if (PG3REC.SY5SZID[AV0LWIXJ] == 0) /* if end of valid sizes*/
        AV0LW00.AV0LWIXJ = AV0LW00.AV0LWIXJ - 1; /* decrement subscript*/
      else
        AVWREC.AVWRQSZL = PG3REC.SY5SZID[AV0LWIXJ]; /* Last valid sz.*/
        AV0LW01.AV0LWTSZ[AV0LWIXM] = PG3REC.SY4IDDSC[AV0LWIXJ];
        AV0LW00.AV0LWIXJ = 0; /* Set end of routine*/
      end
    end
  end

  return; /* Return to previous process*/
end // end AV0LS48

// Check if page full or partial
Function AV0LS49()
   /* ------------------------------------------------------------*/
   /* If last row on map has data then page is full.*/
   /* ------------------------------------------------------------*/

  if (AV0LW00.AV0LWIXK == 14) /* Last row on map*/

    if (AV0LW01.AVASBSTY[AV0LWIXK] > "      ") /* Got style data*/

      AV0LW00.AV0LWFPF = "F"; /* Set partial flag OFF*/

      return; /* Return to prior processing*/

    end

  end


   /* ------------------------------------------------------------*/
   /* When data is found set flag to indicate map partial full.*/
   /* ------------------------------------------------------------*/

  if (AV0LW01.AVASBSTY[AV0LWIXK] > "      ") /* Got style data*/

    AV0LW00.AV0LWFPF = "P"; /* Set partial flag ON*/

    return; /* Return to prior processing*/

  end


  AV0LW00.AV0LWIXK = AV0LW00.AV0LWIXK - 1; /* Decrement line idx*/


end // end AV0LS49

// Start of FTWR criteria search
Function AV0LS50()
   /* ------------------------------------------------------------*/
   /* Set up criteria for select set.*/
   /* ------------------------------------------------------------*/

   /* --------------------------------------PRODUCT CATEGORY HIGH*/
  if (AVWREC.XPCCD[2] > "  ") /* If override Prod Cat*/
    AVEREC.AVECTHI = AVWREC.XPCCD[2]; /* move override*/
  else
    AVEREC.AVECTHI = AVWREC.XPCCD[1]; /* move original*/
  end

  if (AVEREC.AVECTHI == "* ") /* If category wildcarded*/
    AVWREC.AVWSPC = "99"; /* Save product categorymax*/
    AVEREC.AVECTHI = "99"; /* catagory hi*/
  else
    AVWREC.AVWSPC = AVEREC.AVECTHI; /* Save product categorymax*/
  end

   /* --------------------------------------PRODUCT CATEGORY LOW*/
  if (AVWREC.XPCCD[2] > "  ") /* If override Prod Cat*/
    AVEREC.AVECTLO = AVWREC.XPCCD[2]; /* move override*/
  else
    AVEREC.AVECTLO = AVWREC.XPCCD[1]; /* move original*/
  end

  if (AVEREC.AVECTLO == "* ") /* If category wildcarded*/
    AVEREC.AVECTLO = "  "; /* catagory lo*/
  end

   /* --------------------------------------PRODUCT LINE*/
  if (AVWREC.XPLCD[2] > "  ") /* If override Prod Line*/
    AVBREC.XPLCD = AVWREC.XPLCD[2]; /* Product Line*/

  else

    AVBREC.XPLCD = AVWREC.XPLCD[1]; /* Product Line*/
  end


   /* --------------------------------------GENDER/AGE*/
  if (AVWREC.XGACD[2] > "  ") /* If override Gend/Age*/
    AVBREC.XGACD = AVWREC.XGACD[2]; /* Gender/Age*/

  else

    AVBREC.XGACD = AVWREC.XGACD[1]; /* Gender/Age*/
  end


   /* --------------------------------------WHOLESALE PRICE LOW*/
  if (AVWREC.AVWPLO > 0) /* If override Wholesale price*/
    AVEREC.AVEWPLO = AVWREC.AVWPLO; /* Wholesale price low*/

  else

    AVEREC.AVEWPLO = 0; /* Lowest wholesale price*/

  end


   /* --------------------------------------WHOLESALE PRICE HIGH*/
  if (AVWREC.AVWPHI > 0) /* If override Wholesale price*/
    AVEREC.AVEWPHI = AVWREC.AVWPHI; /* Wholesale price high*/

  else

    AVEREC.AVEWPHI = 99999; /* Highest wholesale price*/

  end


   /* --------------------------------------STYLE NUMBER*/

  AVBREC.SY1STNBR = "      "; /* Style number*/


   /* --------------------------------------SILHOUETTE CODE LOW*/
  if (AVWREC.XSUCD[2] > "  ") /* If override Silhouette code*/
    AVEREC.AVESULO = AVWREC.XSUCD[2]; /* Silhouette code low*/

  else

    AVEREC.AVESULO = AVWREC.XSUCD[1]; /* Silhouette code low*/

  end


  if (AVEREC.AVESULO == "* ") /* If Wildcard Silhouette*/

    AVEREC.AVESULO = "00"; /* Lowest Silhouette*/

  end


   /* --------------------------------------SILHOUETTE CODE HIGH*/
  if (AVWREC.XSUCD[2] > "  ") /* If override Silhouette code*/
    AVEREC.AVESUHI = AVWREC.XSUCD[2]; /* Silhouette code high*/

  else

    AVEREC.AVESUHI = AVWREC.XSUCD[1]; /* Silhouette code high*/

  end


  if (AVEREC.AVESUHI == "* ") /* If Wildcard Silhouette*/

    AVEREC.AVESUHI = "99"; /* HIghest Silhouette*/

  end


   /* --------------------------------------LAST CODE LOW*/
  if (AVWREC.XLTCD[2] > "  ") /* If override Last code*/
    AVEREC.AVELTLO = AVWREC.XLTCD[2]; /* Last code low*/

  else

    AVEREC.AVELTLO = AVWREC.XLTCD[1]; /* Last code low*/

  end


  if (AVEREC.AVELTLO == "* ") /* If Wildcard Last Code*/

    AVEREC.AVELTLO = "  "; /* Lowest Last Code*/

  end


   /* --------------------------------------LAST CODE HIGH*/
  if (AVWREC.XLTCD[2] > "  ") /* If override Last code*/
    AVEREC.AVELTHI = AVWREC.XLTCD[2]; /* Last code high*/

  else

    AVEREC.AVELTHI = AVWREC.XLTCD[1]; /* Last code high*/

  end


  if (AVEREC.AVELTHI == "* " /* If Wildcard Last Code*/
   || AVEREC.AVELTHI == "  ") /* If Wildcard Last Code*/

    AVEREC.AVELTHI = "99"; /* Highest Last Code*/

  end


   /* --------------------------------------UNIT OF MEASURE*/
  if (AVWREC.XUMCD[2] > "  ") /* If override UOM*/
    AVBREC.XUMCD = AVWREC.XUMCD[2]; /* UOM*/

  else

    AVBREC.XUMCD = AVWREC.XUMCD[1]; /* UOM*/
  end


   /* --------------------------------------LIFE CYCLE*/
  if (AVWREC.XLCCD[2] > "  ") /* If override Life cycle*/
    AVBREC.XLCCD = AVWREC.XLCCD[2]; /* Life cycle*/

  else

    AVBREC.XLCCD = AVWREC.XLCCD[1]; /* Life cycle*/
  end


   /* --------------------------------------QUALITY*/
  if (AVWREC.XQACD[2] > "  ") /* If override Quality*/
    AVBREC.XQACD = AVWREC.XQACD[2]; /* Quality*/

  else

    AVBREC.XQACD = AVWREC.XQACD[1]; /* Quality*/
  end


   /* --------------------------------------COLLECTION CODE LOW*/
  if (AVWREC.YCQCD[2] > "  ") /* If override Collection*/
    AVEREC.AVECOLO = AVWREC.YCQCD[2]; /* Lowest Collection*/

  else

    AVEREC.AVECOLO = AVWREC.YCQCD[1]; /* Lowest Collection*/

  end


  if (AVEREC.AVECOLO == "* ") /* If Wildcard Collection*/

    AVEREC.AVECOLO = "00"; /* Lowest Collection*/

  end


   /* --------------------------------------COLLECTION CODE HIGH*/
  if (AVWREC.YCQCD[2] > "  ") /* If override Collection*/
    AVEREC.AVECOHI = AVWREC.YCQCD[2]; /* Highest Collection*/

  else

    AVEREC.AVECOHI = AVWREC.YCQCD[1]; /* Highest Collection*/

  end


  if (AVEREC.AVECOHI == "* ") /* If Wildcard Collection*/

    AVEREC.AVECOHI = "99"; /* Highest Collection*/

  end


   /* --------------------------------------DIVISION*/
  AVBREC.XDVCD = AVWREC.XDVCD; /* Division*/


   /* --------------------------------------GENERAL PRODUCT CODE*/
  AVBREC.XGPCD = AVWREC.XGPCD; /* GPC*/


   /* --------------------------------------COLOR CODE*/
  if (AVWREC.SY2CLRID[2] > "  ") /* If override Color code*/
    AVEREC.AVECLLO = AVWREC.SY2CLRID[2]; /* Color code low*/

  else

    AVEREC.AVECLLO = AVWREC.SY2CLRID[1]; /* Color code low*/

  end

  if (AVWREC.SY2CLRID[2] == "* ") /* If Wildcard Color*/

    AVEREC.AVECLLO = "00"; /* Lowest Color*/

  end


   /* --------------------------------------COLOR CODE HIGH*/
  if (AVWREC.SY2CLRID[2] > "  ") /* If override Color code*/
    AVEREC.AVECLHI = AVWREC.SY2CLRID[2]; /* Color code high*/

  else

    AVEREC.AVECLHI = AVWREC.SY2CLRID[1]; /* Color code high*/

  end

  if (AVWREC.SY2CLRID[2] == "* ") /* If Wildcard Color*/

    AVEREC.AVECLHI = "99"; /* Highest Color*/

  end


   /* --------------------------------------DIMENSION CODE*/
  if (AVWREC.XDMCD[2] > "  ") /* If override Dimension code*/
    AVBREC.XDMCD = AVWREC.XDMCD[2]; /* Dimension override*/

  else

    AVBREC.XDMCD = AVWREC.XDMCD[1]; /* Original Dimension*/

  end

   /* --------------------------------------COLOR DESCRIPTION SRCH*/
   /* Examine color desc search field to find the last character*/
   /* then put percent signs (%) on either side of it.  This will*/
   /* be used in the iomod in a 'like' statement.*/


  AV0LS85(); /* examine and reformat color desc search field*/

  AVBREC.SY2CLRDS = AV0LW00.AV0LWSB; /* move work field*/

end // end AV0LS50

// find footwear size ranges
Function AV0LS51()
   /* for footwear - if the either size is in the array, use it.*/
   /* if not in the array, we need to convert the*/
   /* size wanted to numeric to compare with the*/
   /* array size.*/
   /* - for the beginning size, start from the beginning*/
   /* of the array. for the ending size, start from*/
   /* the end.*/


      /* beginning size*/

   /* init output*/
  AVWREC.AVWRQSZF = 99; /* default to low*/
  AV0LW01.AV0LWFSZ[AV0LWIXM] = "   99";

  if (AV0LW00.AV0LWORF in PG3REC.SY4IDDSC)
    AVWREC.AVWRQSZF = PG3REC.SY5SZID[sysVar.arrayIndex]; /* use it if there*/
    AV0LW01.AV0LWFSZ[AV0LWIXM] = PG3REC.SY4IDDSC[sysVar.arrayIndex];
  else
    AV0LW00.AV0LW-CHAR-FLD = AV0LW00.AV0LWORF; /* convert size*/
    AV0LS69(); /* wanted, then*/
    AV0LW00.AV0LW-COMP-FLD = AV0LW00.AV0LW-NUM-FLD; /* save*/
    AV0LW00.AV0LWIX2 = 1;
    while (AV0LW00.AV0LWIX2 <= 40)
      if (PG3REC.SY4IDDSC[AV0LWIX2] > " ")
        AV0LW00.AV0LW-CHAR-FLD = PG3REC.SY4IDDSC[AV0LWIX2]; /* convert*/
        AV0LS69(); /* to num*/
        if (AV0LW00.AV0LW-COMP-FLD <= AV0LW00.AV0LW-NUM-FLD) /* if this is*/
          AVWREC.AVWRQSZF = PG3REC.SY5SZID[AV0LWIX2]; /* the one, save*/
          AV0LW01.AV0LWFSZ[AV0LWIXM] = PG3REC.SY4IDDSC[AV0LWIX2];
          AV0LW00.AV0LWIX2 = 41; /* end loop*/
        else
          AV0LW00.AV0LWIX2 = AV0LW00.AV0LWIX2 + 1; /* increment subscript*/
        end
      else
        AV0LW00.AV0LWIX2 = AV0LW00.AV0LWIX2 + 1; /* increment subscript*/
      end
    end
  end


      /* ending size*/

   /* init output*/
  AVWREC.AVWRQSZL = 0; /* use it if there*/
  AV0LW01.AV0LWTSZ[AV0LWIXM] = "    0";

  if (AV0LW00.AV0LWORL in PG3REC.SY4IDDSC)
    AVWREC.AVWRQSZL = PG3REC.SY5SZID[sysVar.arrayIndex]; /* use it if there*/
    AV0LW01.AV0LWTSZ[AV0LWIXM] = PG3REC.SY4IDDSC[sysVar.arrayIndex];
  else
    AV0LW00.AV0LW-CHAR-FLD = AV0LW00.AV0LWORL; /* convert size*/
    AV0LS69(); /* wanted, then*/
    AV0LW00.AV0LW-COMP-FLD = AV0LW00.AV0LW-NUM-FLD; /* save*/
    AV0LW00.AV0LWIX2 = 40;
    while (AV0LW00.AV0LWIX2 >= 1)
      if (PG3REC.SY4IDDSC[AV0LWIX2] > " ")
        AV0LW00.AV0LW-CHAR-FLD = PG3REC.SY4IDDSC[AV0LWIX2]; /* convert*/
        AV0LS69(); /* to num*/
        if (AV0LW00.AV0LW-COMP-FLD >= AV0LW00.AV0LW-NUM-FLD) /* if this is*/
          AVWREC.AVWRQSZL = PG3REC.SY5SZID[AV0LWIX2]; /* the one, save*/
          AV0LW01.AV0LWTSZ[AV0LWIXM] = PG3REC.SY4IDDSC[AV0LWIX2];
          AV0LW00.AV0LWIX2 = 0; /* end loop*/
        else
          AV0LW00.AV0LWIX2 = AV0LW00.AV0LWIX2 - 1; /* increment subscript*/
        end
      else
        AV0LW00.AV0LWIX2 = AV0LW00.AV0LWIX2 - 1; /* increment subscript*/
      end
    end
  end

  return; /* Return to previous process*/
end // end AV0LS51

// Check avail for FTWR criteria
Function AV0LS52()
   /* ------------------------------------------------------------*/
   /* Zero accumulators.*/
   /* ------------------------------------------------------------*/

  AV0LW00.AV0LWAOQ = 00000; /* Zero at-once accumulator.*/
  AV0LW00.AV0LWFAQ = 00000; /* Zero first available accum.*/

  AV0LW00.AV0LWLO = 99; /* Set save low size bucket*/
  AV0LW00.AV0LWHI = 00; /* Set save high size bucket*/
  AV0LW00.AV0LWSLO = 41; /* Set save low size bucket*/
  AV0LW00.AV0LWSHI = 00; /* Set save high size bucket*/

   /* ------------------------------------------------------------*/
   /* get size scale record*/
   /* ------------------------------------------------------------*/

  set PG3REC empty;
  PG3REC.XGPCD = AVBREC.XGPCD;
  PG3REC.SY1STNBR = AVBREC.SY1STNBR;
  PG3REC.SY2CLRID = AVBREC.SY2CLRID;
  PG3REC.XDMCD = "00";
  AV0LS44();

   /* ------------------------------------------------------------*/
   /* Check availability.*/
   /* ------------------------------------------------------------*/

  AV0LS53(); /* check for at-once in range.*/


   /* ------------------------------------------------------------*/
   /* Check if at-once meets minimum quantity.*/
   /* If it doesn't, zero the accumulator.*/
   /* ------------------------------------------------------------*/

  if (AV0LW00.AV0LWAOQ >= AVWREC.AVWMNQTY) /* Qty. at least minimum*/

    /* NEXT SENTENCE*/

  else

    AV0LW00.AV0LWAOQ = 00000; /* Reset to zero*/

  end


   /* ------------------------------------------------------------*/
   /* Check if first-available meets minimum quantity.*/
   /* If it doesn't, zero the accumulator.*/
   /* ------------------------------------------------------------*/


  AV0LS55(); /* check for first available*/


  if (AV0LW00.AV0LWFAQ >= AVWREC.AVWMNQTY) /* Qty. at least minimum*/

    /* NEXT SENTENCE*/

  else

    AV0LW00.AV0LWFAQ = 00000; /* Reset to zero*/

  end

  AV0LW00.AV0LWLO = AV0LW00.AV0LWSLO; /* Set save low size bucket*/
  AV0LW00.AV0LWHI = AV0LW00.AV0LWSHI; /* Set save high size bucket*/
end // end AV0LS52

// Check for at-once qty.
Function AV0LS53()
   /* ------------------------------------------------------------*/
   /* Initialize the save low range. high range will be*/
     /* incremented from low range as buckets are searched.*/
   /* These ranges are used in size conversion for list screen.*/
   /* ------------------------------------------------------------*/

  AV0LW00.AV0LWSLO = 41; /* Set save low range*/

   /* ------------------------------------------------------------*/
   /* Select and open the cursor. (davail.vavqty02)*/
   /* ------------------------------------------------------------*/

  AV0LS54(); /* Select set and open cursor*/


   /* ------------------------------------------------------------*/
   /* Fetch and sum the at-once quantity which falls between the*/
     /* specified size range.*/
   /* Set the size bucket index to the low size in the range*/
     /* then search for at-once qty. until index > the high*/
     /* size in the range.*/
   /* ------------------------------------------------------------*/

   /* ------------------------------------------------------------*/
   /* Check for override from size for the range starting point.*/
   /* ------------------------------------------------------------*/

  if (AVWREC.AVWRQSZF > 0) /* Got override from size*/

    AV0LW00.AV0LWSZF = AVWREC.AVWRQSZF; /* move to work area*/

  else

    AV0LW00.AV0LWSZF = AVWREC.OPWRQSZF; /* move to work area*/

  end


   /* ------------------------------------------------------------*/
   /* Check for override to size for the range ending point.*/
   /* ------------------------------------------------------------*/

  if (AVWREC.AVWRQSZL > 0) /* Got override to size*/

    AV0LW00.AV0LWSZL = AVWREC.AVWRQSZL; /* move to work area*/

  else

    AV0LW00.AV0LWSZL = AVWREC.OPWRQSZL; /* move to work area*/

  end


   /* ------------------------------------------------------------*/
   /* Now go get those sizes within the range.*/
   /* ------------------------------------------------------------*/

  AV0LW00.AV0LWEFA = "N"; /* Set end of cursor switch*/

  while (AV0LW00.AV0LWEFA == "N") /* Until end of cursor*/

    AV0LS09(); /* Fetch next row in the cursor*/

    if (AV0LW00.AV0LWEFA == "N") /* Until end of cursor*/
      AV0LW00.AV0LWIXS = AV0LW00.AV0LWSZF; /* Index to first sz.*/

      while (AV0LW00.AV0LWIXS <= AV0LW00.AV0LWSZL /* While in range*/
       && AV7REC.AV5NQTY == "Y") /* and a 'n' record (at once)*/

        AV0LS81(); /* Sum at-once quantity*/

      end
    end
  end

   /* ------------------------------------------------------------*/
   /* Close the cursor for davail.vavqty02.*/
   /* ------------------------------------------------------------*/

  AV0LS11(); /* Close the selected set cursor*/


end // end AV0LS53

// Select set avail. FTWR extract
Function AV0LS54()
   /* ------------------------------------------------------------*/
   /* Select set for davail.vavqty02*/
    /* for the FTWR criteria substitute.*/
    /* AVWREC AND AVAREC DATA ARE USED TO SELECT THE SET.*/
   /* ------------------------------------------------------------*/


  set AV7REC empty; /* Clear row storage area*/


  if (AVWREC.XWHCD[2] > "  ") /* Got override warehouse*/

    AV7REC.XWHCD = AVWREC.XWHCD[2]; /* Use override whse*/

  else

    if (AVWREC.XWHCD[1] > "  ") /* Got override warehouse*/

      AV7REC.XWHCD = AVWREC.XWHCD[1]; /* Use override whse*/

    end
  end


  if (AV7REC.XWHCD == "* ") /* If wildcarded in av0k*/

    AV7REC.XWHCD = "**"; /* WHSE*/

  end


  AV7REC.XGPCD = AVBREC.XGPCD; /* GPC*/
  AV7REC.SY1STNBR = AVBREC.SY1STNBR; /* Style*/
  AV7REC.SY2CLRID = AVBREC.SY2CLRID; /* Color*/
  AV7REC.XDMCD = AVBREC.XDMCD; /* Dim*/
  AV7REC.XQACD = AVBREC.XQACD; /* Qual*/
  AV7REC.XOWCD = AVWREC.XOWCD; /* Owner grp*/
  AV7REC.XSDCD = AVWREC.XSDCD; /* Spec*/
  AV7REC.XSACD = AVWREC.XSACD; /* Shade*/
  AV7REC.XPGCD = AVWREC.XPGCD; /* Pkg. type*/
  AV7REC.XUMCD = AVBREC.XUMCD; /* UOM*/
  AV7REC.AV6RECTY = "F"; /* Rec type*/

  if (AV7REC.XGPCD == "03") /* If Apparel product*/
    AV7REC.AV4PRDBD = 0; /* Period begin date*/

  else

    AV7REC.AV4PRDBD = -1; /* Period begin date*/

  end


  if (AVWREC.XGPCD == "03"
   && AVWREC.XWHCD[2] == "* ")
    try
      call "IO2370" ("S2", SQLCA, AV7REC) {isNoRefresh = yes, isExternal = yes};
    end /* Select table set*/
  else
    try
      call "IO2370" ("SS", SQLCA, AV7REC) {isNoRefresh = yes, isExternal = yes};
    end /* Select table set*/
  end


   /* ------------------------------------------------------------*/
   /* If successful, initialize the cursor switch.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that an unexpected error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  AVWREC.XXXMODID = "S54"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(75); /* Data was not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(76); /* Unexpected error occurred*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    converseLib.clearScreen();
     /* Clear screen before display*/

  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "SELECT SET OF TABLE ROWS";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = AVWREC.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DAVAIL  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VAVQTY02"; /* Table view name*/
  TA1REC.TA1TBLKE = AV7REC.AV7GRP; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end AV0LS54

// Check F/A Qty for FTWR extract
Function AV0LS55()
   /* ------------------------------------------------------------*/
   /* Select and open the cursor. (davail.vavqty02)*/
   /* for FTWR extract substitute.*/
   /* ------------------------------------------------------------*/

  AV0LS54(); /* Select set and open cursor*/


   /* ------------------------------------------------------------*/
   /* Fetch and sum the first avail quantity which falls between*/
     /* the specified size range.*/
   /* Set the size bucket index to the low size in the range*/
     /* then search for book date or open book quantity until*/
     /* index > the high size in the range.*/
   /* ------------------------------------------------------------*/

   /* ------------------------------------------------------------*/
   /* Check for override from size for the range starting point.*/
   /* ------------------------------------------------------------*/

  if (AVWREC.AVWRQSZF > 0) /* Got override from size*/

    AV0LW00.AV0LWSZF = AVWREC.AVWRQSZF; /* move to work area*/

  else

    AV0LW00.AV0LWSZF = AVWREC.OPWRQSZF; /* move to work area*/

  end


   /* ------------------------------------------------------------*/
   /* Check for override to size for the range ending point.*/
   /* ------------------------------------------------------------*/

  if (AVWREC.AVWRQSZL > 0) /* Got override to size*/

    AV0LW00.AV0LWSZL = AVWREC.AVWRQSZL; /* move to work area*/

  else

    AV0LW00.AV0LWSZL = AVWREC.OPWRQSZL; /* move to work area*/

  end


   /* ------------------------------------------------------------*/
   /* Now go get those sizes within the range.*/
   /* ------------------------------------------------------------*/

  AV0LW00.AV0LWEFA = "N"; /* Set end of cursor switch*/

  while (AV0LW00.AV0LWEFA == "N") /* Until end of cursor*/

    AV0LS09(); /* Fetch next row in the cursor*/

    if (AV0LW00.AV0LWEFA == "N") /* Until end of cursor*/
      AV0LW00.AV0LWIXS = AV0LW00.AV0LWSZF; /* Index to first sz.*/

      while (AV0LW00.AV0LWIXS <= AV0LW00.AV0LWSZL /* While in range*/
       && AV7REC.AV5PQTY == "Y") /* And a 'P' rec*/

        AV0LS82(); /* Sum first avail quantity*/

      end
    end
  end

   /* ------------------------------------------------------------*/
   /* Close the cursor for davail.vavqty02.*/
   /* ------------------------------------------------------------*/

  AV0LS11(); /* Close the  cursor*/


end // end AV0LS55

// Get FTWR extract description
Function AV0LS56()
   /* ----------------------------------------------------------*/
   /* Get description for substitute style. (dprodg.vsyclr01)*/
   /* ----------------------------------------------------------*/

  PG2REC.XGPCD = AVBREC.XGPCD; /* GPC*/
  PG2REC.SY1STNBR = AVBREC.SY1STNBR; /* Style*/
  PG2REC.SY2CLRID = AVBREC.SY2CLRID; /* Color*/
  PG2REC.XDMCD = "00";

  call "IO3120" ("S ", SQLCA, PG2REC) {isNoRefresh = yes, isExternal = yes}; /* INQUIRY ONLY*/


  if (SQLCA.VAGen_SQLCODE == 100)
    converseLib.validationFailed(006); /* Style does not exist*/

  else

    if (SQLCA.VAGen_SQLCODE < 0)
      TA1REC.TA1TYPE = "DB2";
      TA1REC.TA1FUNC = "RETN";
      TA1REC.TA1DBASE = "DPRODG  "; /* DATA BASE NAME*/
      TA1REC.TA1TBLVU = "VSYCLR01"; /* TABLE NAME*/
      TA1REC.TA1LOCAT[3] = "AV0LS56 "; /* STATEMENT GROUP*/
      TA1REC.TA1LOCAT[4] = "IO3120  "; /* I/O MOD NAME*/
      TA1REC.TA1TBLKE = PG2REC.PG2KEY; /* Table key*/

      call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes}; /* CALL ABEND FORMATTER*/

      exit stack; /* Exit to display map*/

    else

      AV0LW01.AV0LWSND[AV0LWIXM] = PG2REC.SY1SSTNM;

    end
  end


end // end AV0LS56

// Set cursor for catlg page nbr
Function AV0LS58()
   /* ------------------------------------------------------------*/
   /* Set the cursor for catalog page number (dprod.vcatlg01)*/
    /* For FTWR extract substitute.*/
   /* ------------------------------------------------------------*/

  set SYNREC empty; /* Clear row storage area*/

  SYNREC.XGPCD = AVBREC.XGPCD; /* GPC*/
  SYNREC.SY1STNBR = AVBREC.SY1STNBR; /* STYLE*/
  SYNREC.SY2CLRID = AVBREC.SY2CLRID; /* COLOR*/
  SYNREC.XDMCD = AVBREC.XDMCD; /* DIM*/

  try
    call "IO4880" ("S1", SQLCA, SYNREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select table set*/

   /* ------------------------------------------------------------*/
   /* If successful, initialize the line index and cursor switch.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that an unexpected error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  AVWREC.XXXMODID = "S58"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(75); /* Data was not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(76); /* Unexpected error occurred*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    converseLib.clearScreen();
     /* Clear screen before display*/

  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "AV0LS58";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = AVWREC.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DPROD   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCATLG01"; /* Table view name*/
  TA1REC.TA1TBLKE = SYNREC.SYNDATA; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end AV0LS58

// Save FTWR extract in disp strg
Function AV0LS59()
   /* ------------------------------------------------------------*/
   /* If the first line on a page, save the heading information.*/
   /* ------------------------------------------------------------*/

  if (AV0LW00.AV0LWIXM == 1) /* First line on page*/

    AV0LW01.OP1ORDBY = AVWREC.OP1ORDBY; /* Contact*/
    AV0LW01.KUMSTRNM = AVWREC.KUMSTRNM; /* Store name*/
    AV0LW01.KUMCITYS = AVWREC.KUMCITYS; /* City name*/
    AV0LW01.KUMXSTCD = AVWREC.KUMXSTCD; /* State abrv.*/
    AV0LW01.SY1STNBR = AVWREC.SY1STNBR; /* Orig. style*/
    AV0LW01.SY1SSTNM = AVWREC.SY1SSTNM; /* Style desc*/
    AV0LW01.XQACD = AVWREC.XQACD; /* Quality*/

    if (AVWREC.SY2CLRID[2] > "  ") /* Orig. color ovrd.*/
      AV0LW01.SY2CLRID = AVWREC.SY2CLRID[2]; /* Orig. color*/
      AV0LW01.SY2CLRAB = AVWREC.SY2CLRAB; /* Color desc.*/
    else
      AV0LW01.SY2CLRID = AVWREC.SY2CLRID[1]; /* Orig. color*/
      AV0LW01.SY2CLRAB = AVWREC.SY2CLRAB; /* Color desc.*/

    end


    if (AVWREC.XGACD[2] > "  ") /* Orig. gend/age ovrd.*/
      AV0LW01.XGACD = AVWREC.XGACD[2]; /* Orig. gend/age*/
    else
      AV0LW01.XGACD = AVWREC.XGACD[1]; /* Orig. gend/age*/

    end

    if (AVWREC.XPCCD[2] > "  ") /* Orig. prod cat ovrd.*/
      AV0LW01.XPCCD = AVWREC.XPCCD[2]; /* Orig. prod cat*/
    else
      AV0LW01.XPCCD = AVWREC.XPCCD[1]; /* Orig. prod cat*/

    end

    if (AVWREC.XDMCD[2] > "  ")
      AV0LW01.XDMCD = AVWREC.XDMCD[2]; /* override dim*/
    else
      AV0LW01.XDMCD = AVWREC.XDMCD[1]; /* dim*/
    end

    if (AV0LW01.XDMCD in XDMTBL.XDMCD)
      AV0LW01.XDMDESC = XDMTBL.XDMDESC[sysVar.arrayIndex];
    end /* lookup dim desc*/

  end


   /* ------------------------------------------------------------*/
   /* Save the data from the table row in display storage.*/
   /* ------------------------------------------------------------*/

  AV0LW01.AV0LMSEL[AV0LWIXM] = " "; /* Select field*/

   /* --------------------------------------- Style*/
  AV0LW01.AVASBSTY[AV0LWIXM] = AVBREC.SY1STNBR;

   /* --------------------------------------- Color*/
  AV0LW01.AVASBCLR[AV0LWIXM] = AVBREC.SY2CLRID;

   /* --------------------------------------- Dimension*/
  AV0LW01.AVASBDIM[AV0LWIXM] = AVBREC.XDMCD;

   /* --------------------------------------- Description*/
   /* MOVE AV0LW00.SY2ABTB(AV0LWIXT) TO AV0LW01.AV0LWSND(AV0LWIXM)*/

   /* --------------------------------------- Catalog page number*/
  AV0LW01.AV0LWCPN[AV0LWIXM] = AV0LW00.AV0LWCPN;


  if (AV0LW00.AV0LWAOQ > 00000) /* Got at-once quantity*/

    AV0LW01.AV0LWAOI[AV0LWIXM] = "*"; /* at-once indicator*/

  end


   /* -------------------------------- Total quantity calculated*/
   /* -------------------------------- at once + first available*/
  AV0LW00.AV0LW2 = AV0LW00.AV0LWAOQ + AV0LW00.AV0LWFAQ;
  AV0LW01.AV0LWTLQ[AV0LWIXM] = AV0LW00.AV0LW2;


  AV0LW00.AV0LWIXM = AV0LW00.AV0LWIXM + 1; /* Increment line idx*/


end // end AV0LS59

// Check to continue processing
Function AV0LS60()
   /* ----------------------------------------------------------*/
   /* Check to see if substitute available, continue if so,*/
    /* else return to fetch another substitute.*/
   /* ----------------------------------------------------------*/

  if (AV0LW00.AV0LWAOQ == 00000 /* No at-once quantity*/
   && AV0LW00.AV0LWFAQ == 00000) /* And no first avail qty.*/

    return;

  end


  AV0LS56(); /* Get the product description*/

  if (PG2REC.SY2ALNOR == "N") /* if new orders not being taken*/
    return; /* bypass this product*/
  end

   /* ---------------------------------------------------------*/
   /* Find and move size description for the start*/
   /* and end of the range.*/
   /* ---------------------------------------------------------*/
  AV0LW00.AV0LWIXF = AV0LW00.AV0LWLO; /* Set start size sub*/
  AV0LW01.AV0LWFSZ[AV0LWIXM] = PG3REC.SY4IDDSC[AV0LWIXF];
  AV0LW00.AV0LWIXF = AV0LW00.AV0LWHI; /* Set end size sub*/
  AV0LW01.AV0LWTSZ[AV0LWIXM] = PG3REC.SY4IDDSC[AV0LWIXF];

  AV0LS58(); /* Set cursor for catlg page*/

  AV0LS26(); /* Fetch 1st row for catlg pg.*/

  AV0LS27(); /* Close cursor for catlg page*/

  AV0LS59(); /* Save data in display storage*/


   /* ------------------------------------------------------------*/
   /* Add any full page to temporary storage.*/
   /* ------------------------------------------------------------*/

  if (AV0LW00.AV0LWIXM > 14) /* Full page is formatted*/

    if (AV0LW00.AV0LWFPF == "P") /* Page was partially full*/

      AV0LS19(); /* Update page in temporary storage*/

      AV0LW00.AV0LWIXM = 1; /* Reset map pointer*/
      AV0LW00.AV0LWFPF = "F"; /* Reset full/partial flag*/
      set AV0LW01 empty; /* Clear map working storage*/

    else

      AV0LS25(); /* Add page to temporary storage*/

    end
  end


end // end AV0LS60

// Start of APRL criteria search
Function AV0LS61()
   /* ------------------------------------------------------------*/
   /* Set up criteria for select set if search just starting.*/
   /* This is for apparel.*/
   /* ------------------------------------------------------------*/

   /* --------------------------------------GENDER/AGE*/
  if (AVWREC.XGACD[2] > "  ") /* If override Gend/Age*/

    if (AVWREC.XGACD[2] == "* ") /* If wildcard Gend/Age*/
      AVCREC.XGACD = "  "; /* Gender/Age*/

    else

      AVCREC.XGACD = AVWREC.XGACD[2]; /* Gender/Age*/
    end

  else

    AVCREC.XGACD = AVWREC.XGACD[1]; /* Gender/Age*/
  end


   /* --------------------------------------PRODUCT CATEGORY*/
  if (AVWREC.XPCCD[2] > "  ") /* If override Prod Cat*/

    if (AVWREC.XPCCD[2] == "* ") /* If wildcard Prod Cat*/
      AVCREC.XPCCD = "  "; /* Product Category*/

    else

      AVCREC.XPCCD = AVWREC.XPCCD[2]; /* Product Category*/
    end

  else
    AVCREC.XPCCD = AVWREC.XPCCD[1]; /* Product Category*/
  end


   /* --------------------------------------SILHOUETTE GROUP CODE*/
  if (AVWREC.YSMXSU[2] > "  ") /* If override Silh group cd*/
    AVCREC.YSMXSU = AVWREC.YSMXSU[2]; /* Silhouette Group cd*/

  else

    AVCREC.YSMXSU = AVWREC.YSMXSU[1]; /* Silhouette Group cd*/
  end


   /* --------------------------------------UNIT OF MEASURE*/
  if (AVWREC.XUMCD[2] > "  ") /* If override UOM*/
    AVCREC.XUMCD = AVWREC.XUMCD[2]; /* UOM*/

  else

    AVCREC.XUMCD = AVWREC.XUMCD[1]; /* UOM*/
  end


   /* --------------------------------------SEASON*/
  AVCREC.XSECD = "  "; /* dummy out season*/

   /* --------------------------------------LIFE CYCLE*/
  if (AVWREC.XLCCD[2] > "  ") /* If override Life cycle*/
    AVCREC.XLCCD = AVWREC.XLCCD[2]; /* Life cycle*/

  else

    AVCREC.XLCCD = AVWREC.XLCCD[1]; /* Life cycle*/
  end


   /* --------------------------------------QUALITY*/
  if (AVWREC.XQACD[2] > "  ") /* If override Quality*/
    AVCREC.XQACD = AVWREC.XQACD[2]; /* Quality*/

  else

    AVCREC.XQACD = AVWREC.XQACD[1]; /* Quality*/
  end


   /* --------------------------------------COLLECTION CODE LOW*/
  if (AVWREC.YCQCD[2] > "  ") /* If override Collection*/
    AVFREC.AVFCOLO = AVWREC.YCQCD[2]; /* Lowest Collection*/

  else

    AVFREC.AVFCOLO = AVWREC.YCQCD[1]; /* Lowest Collection*/

  end

  if (AVWREC.YCQCD[2] == "* ") /* If Wildcard Collection*/

    AVFREC.AVFCOLO = "00"; /* Lowest Collection*/

  end


   /* --------------------------------------COLLECTION CODE HIGH*/
  if (AVWREC.YCQCD[2] > "  ") /* If override Collection*/
    AVFREC.AVFCOHI = AVWREC.YCQCD[2]; /* Highest Collection*/

  else

    AVFREC.AVFCOHI = AVWREC.YCQCD[1]; /* Highest Collection*/

  end

  if (AVWREC.YCQCD[2] == "* ") /* If Wildcard Collection*/

    AVFREC.AVFCOHI = "99"; /* Highest Collection*/

  end


   /* --------------------------------------DIVISION*/
  AVCREC.XDVCD = AVWREC.XDVCD; /* Division*/


   /* --------------------------------------WHOLESALE PRICE LOW*/
  if (AVWREC.AVWPLO > 0) /* If override Wholesale price*/
    AVFREC.AVFWPLO = AVWREC.AVWPLO; /* Wholesale price low*/

  else

    AVFREC.AVFWPLO = 0; /* Lowest wholesale price*/

  end


   /* --------------------------------------WHOLESALE PRICE HIGH*/
  if (AVWREC.AVWPHI > 0) /* If override Wholesale price*/
    AVFREC.AVFWPHI = AVWREC.AVWPHI; /* Wholesale price high*/

  else

    AVFREC.AVFWPHI = 99999; /* Highest wholesale price*/

  end


   /* --------------------------------------STYLE NUMBER*/

  AVCREC.SY1STNBR = "      "; /* Style number*/


   /* --------------------------------------COLOR CODE*/
  if (AVWREC.SY2CLRID[2] > "  ") /* If override Color code*/
    AVFREC.AVFCLLO = AVWREC.SY2CLRID[2]; /* Color code low*/

  else

    AVFREC.AVFCLLO = AVWREC.SY2CLRID[1]; /* Color code low*/

  end

  if (AVWREC.SY2CLRID[2] == "* ") /* If Wildcard Color*/

    AVFREC.AVFCLLO = "00"; /* Lowest Color*/

  end


   /* --------------------------------------COLOR CODE HIGH*/
  if (AVWREC.SY2CLRID[2] > "  ") /* If override Color code*/
    AVFREC.AVFCLHI = AVWREC.SY2CLRID[2]; /* Color code high*/

  else

    AVFREC.AVFCLHI = AVWREC.SY2CLRID[1]; /* Color code high*/

  end

  if (AVWREC.SY2CLRID[2] == "* ") /* If Wildcard Color*/

    AVFREC.AVFCLHI = "99"; /* Highest Color*/

  end


   /* --------------------------------------DIMENSION CODE*/
  if (AVWREC.XDMCD[2] > "  ") /* If override Dimension*/
    AVCREC.XDMCD = AVWREC.XDMCD[2]; /* Dimension override*/

  else

    AVCREC.XDMCD = AVWREC.XDMCD[1]; /* Original Dimension*/

  end

   /* --------------------------------------SILHOUETTE CODE LOW*/
  if (AVWREC.XSUCD[2] > "  ") /* If override Silhouette code*/
    AVFREC.AVFSULO = AVWREC.XSUCD[2]; /* Silhouette code low*/

  else

    AVFREC.AVFSULO = AVWREC.XSUCD[1]; /* Silhouette code low*/

  end

  if (AVWREC.XSUCD[2] == "* ") /* If Wildcard Silhouette*/

    AVFREC.AVFSULO = "00"; /* Lowest Silhouette*/

  end


   /* --------------------------------------SILHOUETTE CODE HIGH*/
  if (AVWREC.XSUCD[2] > "  ") /* If override Silhouette code*/
    AVFREC.AVFSUHI = AVWREC.XSUCD[2]; /* Silhouette code high*/

  else

    AVFREC.AVFSUHI = AVWREC.XSUCD[1]; /* Silhouette code high*/

  end

  if (AVWREC.XSUCD[2] == "* ") /* If Wildcard Silhouette*/

    AVFREC.AVFSUHI = "99"; /* Highest Silhouette*/

  end


   /* -----------------------------GENDER/AGE PROD CAT INDICATOR*/
  if (AVCREC.XGACD > "  " /* If Gender/Age furnished*/
   && AVCREC.XPCCD > "  ") /* and Product Category furnished*/

    AVFREC.AVFGAIND = "B"; /* Set gender/age prod cat to both*/

  else

    if (AVCREC.XGACD > "  ") /* If Gender/Age furnished*/

      AVFREC.AVFGAIND = "G"; /* Set indicator to gend/age only*/

    else

      if (AVCREC.XPCCD > "  ") /* If Product Category furnished*/

        AVFREC.AVFGAIND = "P";
                                   /* Set indicator to prod cat only*/

      end
    end
  end

  AV0LS85();

  AVCREC.SY2CLRDS = AV0LW00.AV0LWSB; /* move work field*/

end // end AV0LS61

// Select set for vsubap02
Function AV0LS62()
   /* ------------------------------------------------------------*/
   /* Select set for davail.vsubap02*/
   /* ------------------------------------------------------------*/

   /* --------------------------------------IO-TASK*/

  try
    call "IO4860" (AVFREC, SQLCA, AVCREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select set*/

   /* ------------------------------------------------------------*/
   /* If successful, initialize the cursor switch.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that an unexpected error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  AVWREC.XXXMODID = "S62"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(75); /* Data was not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(76); /* Unexpected error occurred*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    converseLib.clearScreen();
     /* Clear screen before display*/

  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "SELECT SET OF TABLE ROWS";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = AVWREC.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DAVAIL  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VSUBAP02"; /* Table view name*/
  TA1REC.TA1TBLKE = AVCREC.AVCGPR; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end AV0LS62

// Fetch next APRL extract rec
Function AV0LS63()
   /* ------------------------------------------------------------*/
   /* Fetch the next row to display from davail.vsubap02*/
   /* ------------------------------------------------------------*/

  try
    call "IO4860" (AVFREC, SQLCA, AVCREC) {isNoRefresh = yes, isExternal = yes};
  end /* Fetch next row*/

   /* ------------------------------------------------------------*/
   /* If the call was successful, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/

    if (SQLCA.VAGen_SQLCODE == 0) /* Normal return code*/
      return; /* Return to previous process*/
    end

    /* ------------------------------------------------------------*/
     /* If end of the selected set, indicate end of cursor.*/
    /* ------------------------------------------------------------*/

    if (SQLCA.VAGen_SQLCODE == +100) /* End of selected set*/

      AV0LW00.AV0LWEC2 = "Y"; /* Indicate end of cursor*/

      return; /* Return to previous process*/

    end

  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  AVWREC.XXXMODID = "S63"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(75); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(76); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    converseLib.clearScreen();
     /* Clear screen before display*/

  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "FETCH NEXT TABLE ROW";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = AVWREC.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DAVAIL  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VSUBAP02"; /* Table view name*/
  TA1REC.TA1TBLKE = AVCREC.AVCGPR; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end AV0LS63

// Select set avail. APRL extract
Function AV0LS64()
   /* ------------------------------------------------------------*/
   /* Select set for davail.vavqty02*/
    /* for the APRL criteria substitute.*/
    /* AVWREC AND AVAREC DATA ARE USED TO SELECT THE SET.*/
   /* ------------------------------------------------------------*/


  set AV7REC empty; /* Clear row storage area*/


  if (AVWREC.XWHCD[2] > "  ") /* Got override warehouse*/

    AV7REC.XWHCD = AVWREC.XWHCD[2]; /* Use override whse*/

  else

    if (AVWREC.XWHCD[1] > "  ") /* no got override warehouse*/

      AV7REC.XWHCD = AVWREC.XWHCD[1]; /* Use override whse*/

    end
  end


  if (AV7REC.XWHCD == "* ") /* If wildcarded in av0k*/

    AV7REC.XWHCD = "**"; /* WHSE*/

  end


  AV7REC.XGPCD = "03"; /* GPC*/
  AV7REC.SY1STNBR = AVCREC.SY1STNBR; /* Style*/
  AV7REC.SY2CLRID = AVCREC.SY2CLRID; /* Color*/
  AV7REC.XDMCD = AVCREC.XDMCD; /* Dim*/
  AV7REC.XQACD = AVCREC.XQACD; /* Qual*/
  AV7REC.XOWCD = AVWREC.XOWCD; /* Owner grp*/
  AV7REC.XSDCD = AVWREC.XSDCD; /* Spec*/
  AV7REC.XSACD = AVWREC.XSACD; /* Shade*/
  AV7REC.XPGCD = AVWREC.XPGCD; /* Pkg. type*/
  AV7REC.XUMCD = AVCREC.XUMCD; /* UOM*/
  AV7REC.AV6RECTY = "F"; /* Rec type*/

  if (AV7REC.XGPCD == "03" /* If Apparel product*/
   && AVCREC.XLCCD == "10")
    AV7REC.AV4PRDBD = 0; /* Period begin date*/

  else

    AV7REC.AV4PRDBD = -1; /* Period begin date*/

  end


  if (AVWREC.XGPCD == "03"
   && AVWREC.XWHCD[2] == "* ")
    try
      call "IO2370" ("S2", SQLCA, AV7REC) {isNoRefresh = yes, isExternal = yes};
    end /* Select table set*/
  else
    try
      call "IO2370" ("SS", SQLCA, AV7REC) {isNoRefresh = yes, isExternal = yes};
    end /* Select table set*/
  end


   /* ------------------------------------------------------------*/
   /* If successful, initialize the cursor switch.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that an unexpected error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  AVWREC.XXXMODID = "S64"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(75); /* Data was not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(76); /* Unexpected error occurred*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    converseLib.clearScreen();
     /* Clear screen before display*/

  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "SELECT SET OF TABLE ROWS";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = AVWREC.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DAVAIL  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VAVQTY02"; /* Table view name*/
  TA1REC.TA1TBLKE = AV7REC.AV7GRP; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end AV0LS64

// Get size translation PG1050
Function AV0LS65()
   /* ------------------------------------------------------------*/
   /* GET size default low size.*/
   /* ------------------------------------------------------------*/

  try
    call "PG1050" (SQLCA, PG3REC) {isNoRefresh = yes, isExternal = yes};
  end

   /* ------------------------------------------------------------*/
   /* If successful, return to previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/

    AVWREC.OPWRQSZF = PG3REC.SY5SZID[1]; /* Low size range*/
    AVWREC.AVWSZFD = PG3REC.SY4IDDSC[1]; /* Low size description*/

    AV0LW00.AV0LWIXJ = 1; /* Index for PG3REC search*/

    while (AV0LW00.AV0LWIXJ <= 40) /* WHile in range*/

      if (PG3REC.SY5SZID[AV0LWIXJ] == 0) /* End of valid sizes*/

        AV0LW00.AV0LWIXJ = AV0LW00.AV0LWIXJ - 1; /* Use last valid bucket*/

        AVWREC.OPWRQSZL = PG3REC.SY5SZID[AV0LWIXJ]; /* Last valid sz.*/
        AVWREC.AVWSZLD = PG3REC.SY4IDDSC[AV0LWIXJ];
                                   /* Last size desc.*/

        AV0LW00.AV0LWIXJ = 41; /* Set end of routine*/

      else

        AV0LW00.AV0LWIXJ = AV0LW00.AV0LWIXJ + 1; /* Increment subscript*/

      end

    end

    return; /* Return to previous process*/
  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that an unexpected error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  AV0LM001.XXXMODID = "S65"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(75); /* Data was not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(76); /* Unexpected error occurred*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    converseLib.clearScreen();
     /* Clear screen before display*/

  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "AV0LS65";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1DBASE = "DPRODG  "; /* Data base name*/
  TA1REC.TA1TBLVU = "PG1050  "; /* Table view name*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end AV0LS65

// Set cursor for catlg page nbr
Function AV0LS67()
   /* ------------------------------------------------------------*/
   /* Set the cursor for catalog page number (dprod.vcatlg01)*/
    /* For APRL extract substitute.*/
   /* ------------------------------------------------------------*/

  set SYNREC empty; /* Clear row storage area*/

  SYNREC.XGPCD = "03"; /* GPC*/
  SYNREC.SY1STNBR = AVCREC.SY1STNBR; /* STYLE*/
  SYNREC.SY2CLRID = AVCREC.SY2CLRID; /* COLOR*/
  SYNREC.XDMCD = AVCREC.XDMCD; /* DIM*/

  try
    call "IO4880" ("S1", SQLCA, SYNREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select table set*/

   /* ------------------------------------------------------------*/
   /* If successful, initialize the line index and cursor switch.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that an unexpected error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  AVWREC.XXXMODID = "S67"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(75); /* Data was not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(76); /* Unexpected error occurred*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    converseLib.clearScreen();
     /* Clear screen before display*/

  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "AV0LS67";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = AVWREC.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DPROD   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCATLG01"; /* Table view name*/
  TA1REC.TA1TBLKE = SYNREC.SYNDATA; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end AV0LS67

// Save APRL extract in disp strg
Function AV0LS68()
   /* ------------------------------------------------------------*/
   /* If the first line on a page, save the heading information.*/
   /* ------------------------------------------------------------*/

  if (AV0LW00.AV0LWIXM == 1) /* First line on page*/

    AV0LW01.OP1ORDBY = AVWREC.OP1ORDBY; /* Contact*/
    AV0LW01.KUMSTRNM = AVWREC.KUMSTRNM; /* Store name*/
    AV0LW01.KUMCITYS = AVWREC.KUMCITYS; /* City name*/
    AV0LW01.KUMXSTCD = AVWREC.KUMXSTCD; /* State abrv.*/
    AV0LW01.SY1STNBR = AVWREC.SY1STNBR; /* Orig. style*/
    AV0LW01.SY1SSTNM = AVWREC.SY1SSTNM; /* Style desc*/
    AV0LW01.XQACD = AVWREC.XQACD; /* Quality*/

    if (AVWREC.SY2CLRID[2] > "  ") /* Orig. color ovrd.*/
      AV0LW01.SY2CLRID = AVWREC.SY2CLRID[2]; /* Orig. color*/
      AV0LW01.SY2CLRAB = AVWREC.SY2CLRAB; /* Color desc.*/
    else
      AV0LW01.SY2CLRID = AVWREC.SY2CLRID[1]; /* Orig. color*/
      AV0LW01.SY2CLRAB = AVWREC.SY2CLRAB; /* Color desc.*/

    end


    if (AVWREC.XGACD[2] > "  ") /* Orig. gend/age ovrd.*/
      AV0LW01.XGACD = AVWREC.XGACD[2]; /* Orig. gend/age*/
    else
      AV0LW01.XGACD = AVWREC.XGACD[1]; /* Orig. gend/age*/

    end

    if (AVWREC.XPCCD[2] > "  ") /* Orig. prod cat ovrd.*/
      AV0LW01.XPCCD = AVWREC.XPCCD[2]; /* Orig. prod cat*/
    else
      AV0LW01.XPCCD = AVWREC.XPCCD[1]; /* Orig. prod cat*/

    end

    if (AVWREC.XDMCD[2] > "  ") /* Orig dimension override*/
      AV0LW01.XDMCD = AVWREC.XDMCD[2]; /* move override*/
    else
      AV0LW01.XDMCD = AVWREC.XDMCD[1]; /* move original*/
    end

    if (AV0LW01.XDMCD in XDMTBL.XDMCD)
      AV0LW01.XDMDESC = XDMTBL.XDMDESC[sysVar.arrayIndex];
    end /* get dim description*/

  end


   /* ------------------------------------------------------------*/
   /* Save the data from the table row in display storage.*/
   /* ------------------------------------------------------------*/

  AV0LW01.AV0LMSEL[AV0LWIXM] = " "; /* Select field*/

   /* --------------------------------------- Style*/
  AV0LW01.AVASBSTY[AV0LWIXM] = AVCREC.SY1STNBR;

   /* --------------------------------------- Color*/
  AV0LW01.AVASBCLR[AV0LWIXM] = AVCREC.SY2CLRID;

   /* --------------------------------------- Dimension*/
  AV0LW01.AVASBDIM[AV0LWIXM] = AVCREC.XDMCD;

   /* --------------------------------------- Description*/
   /* MOVE AV0LW00.SY2ABTB(AV0LWIXT) TO AV0LW01.AV0LWSND(AV0LWIXM)*/

   /* --------------------------------------- Catalog page number*/
  AV0LW01.AV0LWCPN[AV0LWIXM] = AV0LW00.AV0LWCPN;


  if (AV0LW00.AV0LWAOQ > 00000) /* Got at-once quantity*/

    AV0LW01.AV0LWAOI[AV0LWIXM] = "*"; /* at-once indicator*/

  end


   /* -------------------------------- Total quantity calculated*/
   /* -------------------------------- at once + first available*/
  AV0LW00.AV0LW2 = AV0LW00.AV0LWAOQ + AV0LW00.AV0LWFAQ;
  AV0LW01.AV0LWTLQ[AV0LWIXM] = AV0LW00.AV0LW2;


  AV0LW00.AV0LWIXM = AV0LW00.AV0LWIXM + 1; /* Increment line idx*/


end // end AV0LS68

// convert alpha to numeric
Function AV0LS69()
   /* ------------------------------------------------------------*/
   /* this routine reformats the external size range to a numeric*/
   /* field for comparison purposes.*/
   /* ------------------------------------------------------------*/

  if (AV0LW00.AV0LW-CHAR-BYTE[4] == ".")
    AV0LW00.AV0LW-NUM-BYTE[5] = AV0LW00.AV0LW-CHAR-BYTE[5];
    if (AV0LW00.AV0LW-CHAR-BYTE[3] == " ")
      AV0LW00.AV0LW-NUM-BYTE[4] = "0";
    else
      AV0LW00.AV0LW-NUM-BYTE[4] = AV0LW00.AV0LW-CHAR-BYTE[3];
    end
    if (AV0LW00.AV0LW-CHAR-BYTE[2] == " ")
      AV0LW00.AV0LW-NUM-BYTE[3] = "0";
    else
      AV0LW00.AV0LW-NUM-BYTE[3] = AV0LW00.AV0LW-CHAR-BYTE[2];
    end
    AV0LW00.AV0LW-NUM-BYTE[2] = "0";
    AV0LW00.AV0LW-NUM-BYTE[1] = "0";
  else
    AV0LW00.AV0LW-NUM-BYTE[5] = "0";
    AV0LW00.AV0LW-NUM-BYTE[4] = AV0LW00.AV0LW-CHAR-BYTE[5];
    if (AV0LW00.AV0LW-CHAR-BYTE[4] == " ")
      AV0LW00.AV0LW-NUM-BYTE[3] = "0";
    else
      AV0LW00.AV0LW-NUM-BYTE[3] = AV0LW00.AV0LW-CHAR-BYTE[4];
    end
    AV0LW00.AV0LW-NUM-BYTE[2] = "0";
    AV0LW00.AV0LW-NUM-BYTE[1] = "0";
  end
end // end AV0LS69

// Close cursor for vsubfw02
Function AV0LS70()
   /* ------------------------------------------------------------*/
   /* Close the selected set of table rows. (davail.vsubap02)*/
   /* ------------------------------------------------------------*/

   /* --------------------------------------IO-TASK*/

  try
    call "IO4860" (AVFREC, SQLCA, AVCREC) {isNoRefresh = yes, isExternal = yes};
  end /* Close table set*/

   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  AVWREC.XXXMODID = "S70"; /* Module identification*/
  converseLib.validationFailed(76); /* Indicate system error*/

  TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "CLOSE SELECTED SET OF TABLE ROWS";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = AVWREC.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DAVAIL  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VSUBAP02"; /* Table view name*/
  TA1REC.TA1TBLKE = AVCREC.AVCGPR; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end AV0LS70

// Check for at-once qty.
Function AV0LS71()
   /* ------------------------------------------------------------*/
   /* Initialize the save low range. high range will be*/
     /* incremented from low range as buckets are searched.*/
   /* These ranges are used in size conversion for list screen.*/
   /* ------------------------------------------------------------*/

  AV0LW00.AV0LWSLO = 41; /* Set save low range*/

   /* ------------------------------------------------------------*/
   /* Select and open the cursor. (davail.vavqty02)*/
   /* ------------------------------------------------------------*/

  AV0LS64(); /* Select set and open cursor*/


   /* ------------------------------------------------------------*/
   /* Fetch and sum the at-once quantity which falls between the*/
     /* specified size range.*/
   /* Set the size bucket index to the low size in the range*/
     /* then search for at-once qty. until index > the high*/
     /* size in the range.*/
   /* ------------------------------------------------------------*/

   /* ------------------------------------------------------------*/
   /* Check for override from size for the range starting point.*/
   /* ------------------------------------------------------------*/

  if (AVWREC.AVWRQSZF > 0) /* Got override from size*/

    AV0LW00.AV0LWSZF = AVWREC.AVWRQSZF; /* move to work area*/

  else

    AV0LW00.AV0LWSZF = AVWREC.OPWRQSZF; /* move to work area*/

  end


   /* ------------------------------------------------------------*/
   /* Check for override to size for the range ending point.*/
   /* ------------------------------------------------------------*/

  if (AVWREC.AVWRQSZL > 0) /* Got override to size*/

    AV0LW00.AV0LWSZL = AVWREC.AVWRQSZL; /* move to work area*/

  else

    AV0LW00.AV0LWSZL = AVWREC.OPWRQSZL; /* move to work area*/

  end


   /* ------------------------------------------------------------*/
   /* Now go get those sizes within the range.*/
   /* ------------------------------------------------------------*/

  AV0LW00.AV0LWEFA = "N"; /* Set end of cursor switch*/

  while (AV0LW00.AV0LWEFA == "N") /* Until end of cursor*/

    AV0LS09(); /* Fetch next row in the cursor*/

    if (AV0LW00.AV0LWEFA == "N") /* Until end of cursor*/
      AV0LW00.AV0LWIXS = AV0LW00.AV0LWSZF; /* Index to first sz.*/

      while (AV0LW00.AV0LWIXS <= AV0LW00.AV0LWSZL /* While in range*/
       && AV7REC.AV5NQTY == "Y") /* and a 'n' record (at once)*/

        AV0LS10(); /* Sum at-once quantity*/

      end
    end
  end

   /* ------------------------------------------------------------*/
   /* Close the cursor for davail.vavqty02.*/
   /* ------------------------------------------------------------*/

  AV0LS11(); /* Close the selected set cursor*/


end // end AV0LS71

// Check F/A Qty for APRL extract
Function AV0LS72()
   /* ------------------------------------------------------------*/
   /* Select and open the cursor. (davail.vavqty02)*/
   /* for APRL extract substitute.*/
   /* ------------------------------------------------------------*/

  AV0LS64(); /* Select set and open cursor*/


   /* ------------------------------------------------------------*/
   /* Fetch and sum the first avail quantity which falls between*/
     /* the specified size range.*/
   /* Set the size bucket index to the low size in the range*/
     /* then search for book date or open book quantity until*/
     /* index > the high size in the range.*/
   /* ------------------------------------------------------------*/

   /* ------------------------------------------------------------*/
   /* Check for override from size for the range starting point.*/
   /* ------------------------------------------------------------*/

  if (AVWREC.AVWRQSZF > 0) /* Got override from size*/

    AV0LW00.AV0LWSZF = AVWREC.AVWRQSZF; /* move to work area*/

  else

    AV0LW00.AV0LWSZF = AVWREC.OPWRQSZF; /* move to work area*/

  end


   /* ------------------------------------------------------------*/
   /* Check for override to size for the range ending point.*/
   /* ------------------------------------------------------------*/

  if (AVWREC.AVWRQSZL > 0) /* Got override to size*/

    AV0LW00.AV0LWSZL = AVWREC.AVWRQSZL; /* move to work area*/

  else

    AV0LW00.AV0LWSZL = AVWREC.OPWRQSZL; /* move to work area*/

  end


   /* ------------------------------------------------------------*/
   /* Now go get those sizes within the range.*/
   /* ------------------------------------------------------------*/

  AV0LW00.AV0LWEFA = "N"; /* Set end of cursor switch*/

  while (AV0LW00.AV0LWEFA == "N") /* Until end of cursor*/

    AV0LS09(); /* Fetch next row in the cursor*/

    if (AV0LW00.AV0LWEFA == "N") /* Until end of cursor*/
      AV0LW00.AV0LWIXS = AV0LW00.AV0LWSZF; /* Index to first sz.*/

      while (AV0LW00.AV0LWIXS <= AV0LW00.AV0LWSZL /* While in range*/
       && AV7REC.AV5PQTY == "Y") /* And a 'P' rec*/

        AV0LS31(); /* Sum first avail quantity*/

      end
    end
  end

   /* ------------------------------------------------------------*/
   /* Close the cursor for davail.vavqty02.*/
   /* ------------------------------------------------------------*/

  AV0LS11(); /* Close the  cursor*/


end // end AV0LS72

// Check avail for APRL criteria
Function AV0LS73()
   /* ------------------------------------------------------------*/
   /* Zero accumulators.*/
   /* ------------------------------------------------------------*/

  AV0LW00.AV0LWAOQ = 00000; /* Zero at-once accumulator.*/
  AV0LW00.AV0LWFAQ = 00000; /* Zero first available accum.*/

  AV0LW00.AV0LWLO = 99; /* Set save low size bucket*/
  AV0LW00.AV0LWHI = 00; /* Set save high size bucket*/
  AV0LW00.AV0LWSLO = 41; /* Set save low size bucket*/
  AV0LW00.AV0LWSHI = 00; /* Set save high size bucket*/

   /* ------------------------------------------------------------*/
   /* get size scale record*/
   /* ------------------------------------------------------------*/

  set PG3REC empty;
  PG3REC.XGPCD = "03";
  PG3REC.SY1STNBR = AVCREC.SY1STNBR;
  PG3REC.SY2CLRID = AVCREC.SY2CLRID;
  PG3REC.XDMCD = "00";
  AV0LS44();

   /* ------------------------------------------------------------*/
   /* Check availability.*/
   /* ------------------------------------------------------------*/

  AV0LS71(); /* check for at-once in range.*/

   /* ------------------------------------------------------------*/
   /* Check if at-once meets minimum quantity.*/
   /* If it doesn't, zero the accumulator.*/
   /* ------------------------------------------------------------*/

  if (AV0LW00.AV0LWAOQ >= AVWREC.AVWMNQTY) /* Qty. at least minimum*/

    /* NEXT SENTENCE*/

  else

    AV0LW00.AV0LWAOQ = 00000; /* Reset to zero*/

  end


   /* ------------------------------------------------------------*/
   /* Check if first-available meets minimum quantity.*/
   /* If it doesn't, zero the accumulator.*/
   /* ------------------------------------------------------------*/


  AV0LS72(); /* check for first available*/

  if (AV0LW00.AV0LWFAQ >= AVWREC.AVWMNQTY) /* Qty. at least minimum*/

    /* NEXT SENTENCE*/

  else

    AV0LW00.AV0LWFAQ = 00000; /* Reset to zero*/

  end

  AV0LW00.AV0LWLO = AV0LW00.AV0LWSLO; /* Set save low size bucket*/
  AV0LW00.AV0LWHI = AV0LW00.AV0LWSHI; /* Set save high size bucket*/
end // end AV0LS73

// Check to continue processing
Function AV0LS74()
   /* ----------------------------------------------------------*/
   /* Check to see if substitute available, continue if so,*/
    /* else return to fetch another substitute.*/
   /* ----------------------------------------------------------*/

  if (AV0LW00.AV0LWAOQ == 00000 /* No at-once quantity*/
   && AV0LW00.AV0LWFAQ == 00000) /* And no first avail qty.*/

    return;

  end


  AV0LS75(); /* Get the product description*/

  if (PG2REC.SY2ALNOR == "N") /* if new orders not being taken*/
    return; /* bypass product*/
  end

   /* ---------------------------------------------------------*/
   /* Find and move size description for the start*/
   /* and end of the range.*/
   /* ---------------------------------------------------------*/
  AV0LW00.AV0LWIXF = AV0LW00.AV0LWLO; /* Set start size sub*/
  AV0LW01.AV0LWFSZ[AV0LWIXM] = PG3REC.SY4IDDSC[AV0LWIXF];
  AV0LW00.AV0LWIXF = AV0LW00.AV0LWHI; /* Set end size sub*/
  AV0LW01.AV0LWTSZ[AV0LWIXM] = PG3REC.SY4IDDSC[AV0LWIXF];

  AV0LS67(); /* Set cursor for catlg page*/

  AV0LS26(); /* Fetch 1st row for catlg pg.*/

  AV0LS27(); /* Close cursor for catlg page*/

  AV0LS68(); /* Save data in display storage*/


   /* ------------------------------------------------------------*/
   /* Add any full page to temporary storage.*/
   /* ------------------------------------------------------------*/

  if (AV0LW00.AV0LWIXM > 14) /* Full page is formatted*/

    if (AV0LW00.AV0LWFPF == "P") /* Page was partially full*/

      AV0LS19(); /* Update page in temporary storage*/

      AV0LW00.AV0LWIXM = 1; /* Reset map pointer*/
      AV0LW00.AV0LWFPF = "F"; /* Reset full/partial flag*/
      set AV0LW01 empty; /* Clear map working storage*/

    else

      AV0LS25(); /* Add page to temporary storage*/

    end
  end


end // end AV0LS74

// Get APRL extract description
Function AV0LS75()
   /* ----------------------------------------------------------*/
   /* Get description for substitute style. (dprodg.vsyclr01)*/
   /* ----------------------------------------------------------*/

  PG2REC.XGPCD = "03"; /* GPC*/
  PG2REC.SY1STNBR = AVCREC.SY1STNBR; /* Style*/
  PG2REC.SY2CLRID = AVCREC.SY2CLRID; /* Color*/
  PG2REC.XDMCD = "00";

  call "IO3120" ("S ", SQLCA, PG2REC) {isNoRefresh = yes, isExternal = yes}; /* INQUIRY ONLY*/


  if (SQLCA.VAGen_SQLCODE == 100)
    converseLib.validationFailed(006); /* Style does not exist*/

  else

    if (SQLCA.VAGen_SQLCODE < 0)
      TA1REC.TA1TYPE = "DB2";
      TA1REC.TA1FUNC = "RETN";
      TA1REC.TA1DBASE = "DPRODG  "; /* DATA BASE NAME*/
      TA1REC.TA1TBLVU = "VSYCLR01"; /* TABLE NAME*/
      TA1REC.TA1LOCAT[3] = "AV0LS75 "; /* STATEMENT GROUP*/
      TA1REC.TA1LOCAT[4] = "IO3120  "; /* I/O MOD NAME*/
      TA1REC.TA1TBLKE = SY1REC.SY1KEY; /* Table key*/

      call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes}; /* CALL ABEND FORMATTER*/

      exit stack; /* Exit to display map*/

    else

      AV0LW01.AV0LWSND[AV0LWIXM] = PG2REC.SY1SSTNM;

    end
  end


end // end AV0LS75

// Furnish default codes
Function AV0LS76()
   /* ------------------------------------------------------------*/
   /* Set up default codes not furnished when not coming from*/
     /* order entry or the substitution criteria screen.*/
   /* ------------------------------------------------------------*/

  if (AVWREC.XDMCD[1] > "  ") /* Got dim code*/

     /* NEXT SENTENCE*/

  else

    AVWREC.XDMCD[1] = "00"; /* dim code*/

  end


  if (AVWREC.XOWCD > "  ") /* Got owner group code*/

     /* NEXT SENTENCE*/

  else

    AVWREC.XOWCD = "00"; /* owner group code*/

  end


  if (AVWREC.XSDCD > "   ") /* Got spec difference*/

     /* NEXT SENTENCE*/

  else

    AVWREC.XSDCD = "000"; /* spec difference*/

  end


  if (AVWREC.XSACD > "   ") /* Got shade code*/

     /* NEXT SENTENCE*/

  else

    AVWREC.XSACD = "000"; /* shade code*/

  end


  if (AVWREC.XPGCD > "  ") /* Got pkg. type code*/

     /* NEXT SENTENCE*/

  else

    AVWREC.XPGCD = "00"; /* pkg. type code*/

  end


  if (AVWREC.XQACD[2] > "  " /* Got quality override*/
   || AVWREC.XQACD[1] > "  ") /* Got quality code*/

     /* NEXT SENTENCE*/

  else

    AVWREC.XQACD[1] = "01"; /* quality*/

  end


end // end AV0LS76

// Check for FTWR duplicate subst
Function AV0LS77()
   /* -----------------------------------------------------------*/
     /* THIS IS FOR FOOTWEAR.*/
   /* Search the market table styles to see if criteria subst.*/
     /* is a duplicate. If so it will not be processed.*/
   /* -----------------------------------------------------------*/

  AV0LW00.AV0LWIXL = 1; /* Set subscript to load mkt/style tbl*/

  while (AV0LW00.AV0LWIXL <= 31) /* While within subscript range*/

    if (AVWREC.AVASBSTY[AV0LWIXL] == AVBREC.SY1STNBR)

      AV0LW00.AV0LWFNF = "F"; /* Found duplicate on table*/

      AV0LW00.AV0LWIXL = 99; /* Set subscript to end*/

    else
      if (AVWREC.AVASBSTY[AV0LWIXL] == "000000") /* End of table data*/

        AV0LW00.AV0LWFNF = "N"; /* Not/Found duplicate on table*/

        AV0LW00.AV0LWIXL = 99; /* Set subscript to end*/

      else

        AV0LW00.AV0LWFNF = "N"; /* Not/Found duplicate on table*/

        AV0LW00.AV0LWIXL = AV0LW00.AV0LWIXL + 1; /* Increment subscript*/

      end
    end
  end


end // end AV0LS77

// check for APRL duplicate subst
Function AV0LS78()
   /* -----------------------------------------------------------*/
     /* THIS IS FOR APPAREL.*/
   /* Search the market table styles to see if criteria subst.*/
     /* is a duplicate. If so it will not be processed.*/
   /* -----------------------------------------------------------*/

  AV0LW00.AV0LWIXL = 1; /* Set subscript to load mkt/style tbl*/

  while (AV0LW00.AV0LWIXL <= 31) /* While within subscript range*/

    if (AVWREC.AVASBSTY[AV0LWIXL] == AVCREC.SY1STNBR)

      AV0LW00.AV0LWFNF = "F"; /* Found duplicate on table*/

      AV0LW00.AV0LWIXL = 99; /* Set subscript to end*/

    else
      if (AVWREC.AVASBSTY[AV0LWIXL] == "000000") /* End of table data*/

        AV0LW00.AV0LWFNF = "N"; /* Not/Found duplicate on table*/

        AV0LW00.AV0LWIXL = 99; /* Set subscript to end*/

      else

        AV0LW00.AV0LWFNF = "N"; /* Not/Found duplicate on table*/

        AV0LW00.AV0LWIXL = AV0LW00.AV0LWIXL + 1; /* Increment subscript*/

      end
    end
  end


end // end AV0LS78

// Plug in defaults for op0h
Function AV0LS79()
   /* ------------------------------------------------------------*/
   /* Check date to determine current life cycle.*/
   /* ------------------------------------------------------------*/


  if (SYCREC.SY2CEDT1 > XX0XW01.XX0XWDAT) /* Effective data > current*/
    /* NEXT SENTENCE*/

  else

    AVWREC.XLCCD[1] = SYCREC.XLCCD1; /* Got good life cycle code*/
    return; /* Return to previous process*/

  end


  if (SYCREC.SY2CEDT2 > XX0XW01.XX0XWDAT) /* Effective data > current*/
    /* NEXT SENTENCE*/

  else

    AVWREC.XLCCD[1] = SYCREC.XLCCD2; /* Got good life cycle code*/
    return; /* Return to previous process*/

  end


  if (SYCREC.SY2CEDT3 > XX0XW01.XX0XWDAT) /* Effective data > current*/
    /* NEXT SENTENCE*/

  else

    AVWREC.XLCCD[1] = SYCREC.XLCCD3; /* Got good life cycle code*/
    return; /* Return to previous process*/

  end


  if (SYCREC.SY2CEDT4 > XX0XW01.XX0XWDAT) /* Effective data > current*/
    /* NEXT SENTENCE*/

  else

    AVWREC.XLCCD[1] = SYCREC.XLCCD4; /* Got good life cycle code*/
    return; /* Return to previous process*/

  end


end // end AV0LS79

// transfer to the requested appl
Function AV0LS80()
   /* *************************************************************/
      /* this is a clone of xsexit without the call to mn0s,*/
       /* because security not set up for op0h in &op.*/
   /* *************************************************************/

  if (COMMAREA.CACURSYS == COMMAREA.CATOSYS)
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.commit();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
    
    COMMAREA.CAFROMAP = COMMAREA.CACURRAP;
    COMMAREA.CACURRAP = COMMAREA.CATOAP;
    COMMAREA.CATOAP = " ";
    sysVar.transferName = COMMAREA.CACURRAP;
    transfer to program sysVar.transferName passing COMMAREA;
  else
    COMMAREA.CAFROMAP = COMMAREA.CACURRAP;
    COMMAREA.CACURRAP = COMMAREA.CATOAP;
    COMMAREA.CATOAP = " ";
    sysVar.transferName = COMMAREA.CACURRAP;
    transfer to transaction sysVar.transferName passing COMMAREA;
  end


end // end AV0LS80

// Sum at-once quantity
Function AV0LS81()
   /* ---------------------------------------------------------*/
   /* If GPC 02 (footwear) and substitute is out of price*/
     /* range, force size range search to end and ezertn to*/
     /* fetch next row.*/
   /* ---------------------------------------------------------*/

  if (AVWREC.XGPCD == "02" /* Footwear product*/
   && AV7REC.AV1CUPRC > AVWREC.AVWPHI) /* Price > price range*/

    AV0LW00.AV0LWIXS = 99; /* Force end of size search*/

    return; /* Return to previous statement group*/

  end


   /* ---------------------------------------------------------*/
   /* If condition code '01' (at-once) add to qty. sum bucket.*/
   /* Save the low and high size buckets to use to show the*/
     /* range on the list screen.*/
   /* Then increment the size bucket index by +1.*/
   /* ---------------------------------------------------------*/

  if (AV7REC.XCDCD[AV0LWIXS] == "01") /* At once cond. code*/
    AV0LW00.AV0LW1 = AV0LW00.AV0LWAOQ + AV7REC.AV1AVQTY[AV0LWIXS];
    AV0LW00.AV0LWAOQ = AV0LW00.AV0LW1;

    if (AV0LW00.AV0LWIXS > AV0LW00.AV0LWSHI) /* higher than high*/
      AV0LW00.AV0LWSHI = AV0LW00.AV0LWIXS; /* Set high range*/
    end

    if (AV0LW00.AV0LWIXS < AV0LW00.AV0LWSLO) /* Bucket idx < low*/
      AV0LW00.AV0LWSLO = AV0LW00.AV0LWIXS; /* Set low range*/

    end
  end


   /* ---------------------------------------------------------*/
   /* Increment the size bucket index.*/
   /* ---------------------------------------------------------*/

  AV0LW00.AV0LWIXS = AV0LW00.AV0LWIXS + 1; /* Increment sz. bucket*/


end // end AV0LS81

// Sum first avail quantity
Function AV0LS82()
   /* ---------------------------------------------------------*/
   /* If GPC 02 (footwear) and substitute is out of price*/
     /* range, force size range search to end and ezertn to*/
     /* fetch next row.*/
   /* ---------------------------------------------------------*/

  if (AVWREC.XGPCD == "02" /* Footwear product*/
   && AV7REC.AV1CUPRC > AVWREC.AVWPHI) /* Price > price range*/

    AV0LW00.AV0LWIXS = 99; /* Force end of size search*/

    return; /* Return to previous statement group*/

  end


   /* ---------------------------------------------------------*/
   /* If condition code '02' (book date) or '04' (open book)*/
     /* and valid period date add to qty. sum bucket*/
     /* and > or = the minimum quantity needed.*/
   /* Save the low and high size buckets to use to show the*/
     /* range on the list screen.*/
   /* Then increment the size bucket index by +1.*/
   /* ---------------------------------------------------------*/

   /* ---------------------------------------------------------*/
   /* if valid for gpc 01 within 30 days.*/
   /* ---------------------------------------------------------*/

  if (AV7REC.XGPCD == "01") /* If PROMO*/
    if (AV7REC.AV5CDDT[AV0LWIXS] <= AV0LW00.AV0LWDTP) /* within 30 days*/
      if (AV7REC.XCDCD[AV0LWIXS] == "02" /* Book date cond. code*/
       || AV7REC.XCDCD[AV0LWIXS] == "04") /* Open book cond. code*/
        AV0LW00.AV0LW1 = AV0LW00.AV0LWFAQ + AV7REC.AV1AVQTY[AV0LWIXS];
        AV0LW00.AV0LWFAQ = AV0LW00.AV0LW1; /* First avail updated*/

        if (AV0LW00.AV0LWIXS > AV0LW00.AV0LWSHI) /* higher than high*/
          AV0LW00.AV0LWSHI = AV0LW00.AV0LWIXS; /* Set high range*/
        end

        if (AV0LW00.AV0LWIXS < AV0LW00.AV0LWSLO) /* Bucket idx < low*/
          AV0LW00.AV0LWSLO = AV0LW00.AV0LWIXS; /* Set low range*/

        end
      end
    end
  end


   /* ---------------------------------------------------------*/
   /* if valid for gpc 02 within 30 days.*/
   /* ---------------------------------------------------------*/

  if (AV7REC.XGPCD == "02") /* If FOOTWEAR*/
    if (AV7REC.AV5CDDT[AV0LWIXS] <= AV0LW00.AV0LWDTP) /* within 30 days*/
      if (AV7REC.XCDCD[AV0LWIXS] == "02" /* Book date cond. code*/
       || AV7REC.XCDCD[AV0LWIXS] == "04") /* Open book cond. code*/
        AV0LW00.AV0LW1 = AV0LW00.AV0LWFAQ + AV7REC.AV1AVQTY[AV0LWIXS];
        AV0LW00.AV0LWFAQ = AV0LW00.AV0LW1; /* First avail updated*/

        if (AV0LW00.AV0LWIXS > AV0LW00.AV0LWSHI) /* higher than high*/
          AV0LW00.AV0LWSHI = AV0LW00.AV0LWIXS; /* Set high range*/
        end

        if (AV0LW00.AV0LWIXS < AV0LW00.AV0LWSLO) /* Bucket idx < low*/
          AV0LW00.AV0LWSLO = AV0LW00.AV0LWIXS; /* Set low range*/

        end
      end
    end
  end


   /* ---------------------------------------------------------*/
   /* Increment the size bucket index.*/
   /* ---------------------------------------------------------*/

  AV0LW00.AV0LWIXS = AV0LW00.AV0LWIXS + 1; /* Increment sz. bucket*/


end // end AV0LS82

// Get color desc for override
Function AV0LS83()
   /* ------------------------------------------------------------*/
   /* Get the color description for override.*/
   /* ------------------------------------------------------------*/

  set SYCREC empty; /* Clear row storage area*/

  SYCREC.XGPCD = AVWREC.XGPCD; /* GPC code*/
  SYCREC.SY1STNBR = AVWREC.SY1STNBR; /* Style code*/
  SYCREC.SY2CLRID = AVWREC.SY2CLRID[2]; /* Color code*/
  if (AVWREC.XDMCD[2] > "  ") /* override dimension present*/
    SYCREC.XDMCD = AVWREC.XDMCD[2]; /* use override*/
  else
    SYCREC.XDMCD = AVWREC.XDMCD[1]; /* use original*/
  end

  try
    call "IO0560" ("S ", SQLCA, SYCREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

   /* ------------------------------------------------------------*/
   /* If the call was successful, return to the previous precess.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/
    if (SQLCA.VAGen_SQLCODE == 0 /* Normal return code*/
     || SQLCA.VAGen_SQLCODE == 100) /* Row not found*/
      return; /* Return to previous process*/
    end
  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user*/
   /* otherwise, indicate that an unexpected error has occured.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL Commarea*/

  AVWREC.XXXMODID = "S83"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(75); /* Data was not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(76); /* Unexpected error occurred*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    converseLib.clearScreen();
     /* Clear screen before display*/

  end

  TA1REC.TA1TYPE = "DB2"; /* Type of error*/
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = AVWREC.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DPROD   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCOLOR02"; /* Table view name*/
  TA1REC.TA1TBLKE = SYCREC.SYCKEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  return; /* Exit to display map*/


end // end AV0LS83

// Fetch catalog page row
Function AV0LS84()
   /* ------------------------------------------------------------*/
   /* Fetch catalog row.*/
   /* ------------------------------------------------------------*/

  try
    call "IO4880" ("N1", SQLCA, SYNREC) {isNoRefresh = yes, isExternal = yes};
  end /* Fetch next row*/

   /* ------------------------------------------------------------*/
   /* If the call was successful, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Normal return code*/

      return; /* Return to previous process*/

    end

  end

   /* ------------------------------------------------------------*/
   /* If not found, indicate n/a.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/
    if (SQLCA.VAGen_SQLCODE == 100) /* End of selected set*/

      AV0LW00.AV0LWEFC = "Y"; /* Indicate end of cursor*/

      return; /* Return to previous process*/

    end

  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

   /* MOVE 'S26' TO AVWREC.XXXMODID   ; Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(75); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(76); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    converseLib.clearScreen();
     /* Clear screen before display*/

  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "AV0LS26";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
   /* MOVE SYNREC.XXXMODID TO TA1REC.TA1PGMNO; Program number*/
  TA1REC.TA1DBASE = "DPROD   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCATLG01"; /* Table view name*/
  TA1REC.TA1TBLKE = SYNREC.SYNDATA; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end AV0LS84

// Format color desc search field
Function AV0LS85()
   /* ------------------------------------------------------------*/
   /* Format the color description search field so it may be used*/
   /* by the iomod in a 'like' statement.*/
   /* find the last char of the search stmt passed to this pgm.*/
   /* then move only that portion to the second work field,*/
   /* leaving room at the front and rear of it for the % signs.*/
   /* ------------------------------------------------------------*/


  AV0LW00.AV0LWSA = AVWREC.AVWWCSE; /* move to work field*/

  AV0LW00.AV0LWSB = "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%";

  AV0LW00.AV0LWIXY = 28;

  while (AV0LW00.AV0LWIXY >= 1) /* look backwards thru field*/

    if (AV0LW00.AV0LWSAE[AV0LWIXY] == " ") /* last char not found yet*/

      AV0LW00.AV0LWIXY = AV0LW00.AV0LWIXY - 1; /* decrement*/

    else
       /* last char found.  set second work field index to 1 greater*/
       /* than the first work index to make room for the first %.*/

      AV0LW00.AV0LWIXZ = AV0LW00.AV0LWIXY + 1; /* set second work index*/

      while (AV0LW00.AV0LWIXY >= 1) /* still have chars to move*/

        AV0LW00.AV0LWSBE[AV0LWIXZ] = AV0LW00.AV0LWSAE[AV0LWIXY];

        AV0LW00.AV0LWIXY = AV0LW00.AV0LWIXY - 1; /* decrement index*/
        AV0LW00.AV0LWIXZ = AV0LW00.AV0LWIXZ - 1; /* decrement index*/

      end

      AV0LW00.AV0LWSBE[1] = "%"; /* ensure first char is %*/

    end
  end
end // end AV0LS85

// Ck attributes of mktg tbl prod
Function AV0LS86()
   /* ------------------------------------------------------------*/
   /* Check the attributes of the product from the marketing*/
   /* table against the overrides.*/
   /* This is for apparel.*/
   /* ------------------------------------------------------------*/

   /* --------------------------------------LIFE CYCLE*/
  if (AVWREC.XLCCD[2] > "  ") /* If override Life cycle*/
    if (AVWREC.XLCCD[2] == AVCREC.XLCCD) /* attribute match*/
       /* next sentence*/
    else
      return;
    end
  else
    if (AVCREC.XLCCD == "10") /* only life cycle 10*/
       /* next sentence*/
    else
      return;
    end
  end

   /* --------------------------------------QUALITY*/
  if (AVCREC.XQACD == "01") /* only first quality*/
     /* next sentence*/
  else
    return;
  end

   /* --------------------------------------UNIT OF MEASURE*/
  if (AVWREC.XUMCD[2] > "  ") /* override uom*/
    if (AVWREC.XUMCD[2] == AVCREC.XUMCD) /* attribute match*/
       /* next sentence*/
    else
      return;
    end
  else
    if (AVWREC.XUMCD[1] == AVCREC.XUMCD) /* match to orig product*/
       /* next sentence*/
    else
      return;
    end
  end

   /* --------------------------------------WHOLESALE PRICE LOW*/
  if (AVWREC.AVWPLO > 0) /* If override Wholesale price*/
    if (AVWREC.AVWPLO <= AVCREC.AV1CUPRC) /* within low range*/
       /* next sentence*/
    else
      return;
    end
  end

   /* --------------------------------------WHOLESALE PRICE HIGH*/
  if (AVWREC.AVWPHI > 0) /* If override Wholesale price*/
    if (AVWREC.AVWPHI >= AVCREC.AV1CUPRC) /* within high range*/
       /* next sentence*/
    else
      return;
    end
  end

   /* --------------------------------------COLOR DESCRIPTION SRCH*/
   /* Compare the color desc search field and the desc from the*/
   /* database.*/

  AV0LW00.AV0LWSB = AVCREC.SY2CLRDS; /* move color desc from db*/

  AV0LS88(); /* compare description fields*/

  if (AV0LW00.AV0LWFND != "Y")
    return;
  end

  AV0LW00.AV0LWFNF = "Y"; /* everything matches*/

end // end AV0LS86

// Ck attributes of mktg tbl prod
Function AV0LS87()
   /* ------------------------------------------------------------*/
   /* Check the attributes of the product from the marketing*/
   /* table against the overrides.*/
   /* This is for footwear*/
   /* ------------------------------------------------------------*/

   /* --------------------------------------QUALITY*/
  if (AVBREC.XQACD == "01") /* only first quality*/
     /* next sentence*/
  else
    return;
  end

   /* --------------------------------------UNIT OF MEASURE*/
  if (AVBREC.XUMCD == "01") /* only each*/
     /* next sentence*/
  else
    return;
  end

   /* --------------------------------------WHOLESALE PRICE LOW*/
  if (AVWREC.AVWPLO > 0) /* If override Wholesale price*/
    if (AVWREC.AVWPLO <= AVBREC.AV1CUPRC) /* within low range*/
       /* next sentence*/
    else
      return;
    end
  end

   /* --------------------------------------WHOLESALE PRICE HIGH*/
  if (AVWREC.AVWPHI > 0) /* If override Wholesale price*/
    if (AVWREC.AVWPHI >= AVBREC.AV1CUPRC) /* within high range*/
       /* next sentence*/
    else
      return;
    end
  end

   /* --------------------------------------LAST CODE*/
  if (AVWREC.XLTCD[2] > "  ") /* If override Last code*/
    if (AVWREC.XLTCD[2] == "* ") /* If wildcard Last code*/
       /* next sentence*/
    else
      if (AVWREC.XLTCD[2] == AVBREC.XLTCD) /* attribute match*/
         /* next sentence*/
      else
        return;
      end
    end
  end

   /* --------------------------------------LIFE CYCLE*/
  if (AVWREC.XLCCD[2] > "  ") /* If override Life cycle*/
    if (AVWREC.XLCCD[2] == AVBREC.XLCCD) /* attribute match*/
       /* next sentence*/
    else
      return;
    end
  else
    if (AVBREC.XLCCD == "10") /* only life cycle 10*/
       /* next sentence*/
    else
      return;
    end
  end

   /* --------------------------------------DIMENSION CODE*/
  if (AVWREC.XDMCD[2] > "  ") /* If override Dimension code*/
    if (AVWREC.XDMCD[2] == AVBREC.XDMCD) /* match*/
       /* next sentence*/
    else
      return;
    end
  end

   /* --------------------------------------COLOR DESCRIPTION SRCH*/
   /* Compare the color desc search field and the desc from the*/
   /* database.*/

  AV0LW00.AV0LWSB = AVBREC.SY2CLRDS; /* move color desc from db*/

  AV0LS88(); /* compare description fields*/

  if (AV0LW00.AV0LWFND != "Y")
    return;
  end

  AV0LW00.AV0LWFNF = "Y"; /* everything matches*/

end // end AV0LS87

// Compare color desc with db
Function AV0LS88()
   /* ------------------------------------------------------------*/
   /* Compare the color description search field with the color*/
   /* description stored in the database record.  The search*/
   /* will be one character at a time, and will look for the*/
   /* string anywhere within the database record field.*/
   /* ------------------------------------------------------------*/

   /* find the last character in the first table.*/

  AV0LW00.AV0LWSA = AVWREC.AVWWCSE; /* move to work field*/
  AV0LW00.AV0LWLN1 = 0; /* init length of search field*/
  AV0LW00.AV0LWIXY = 28; /* set to max length*/

  while (AV0LW00.AV0LWIXY >= 1) /* look backwards thru field*/
    if (AV0LW00.AV0LWSAE[AV0LWIXY] == " ") /* last char not found yet*/
      AV0LW00.AV0LWIXY = AV0LW00.AV0LWIXY - 1; /* decrement*/
    else
       /* last char found.  set first work field length to index*/
      AV0LW00.AV0LWLN1 = AV0LW00.AV0LWIXY; /* set length*/
      AV0LW00.AV0LWIXY = 0; /* get out of loop*/
    end
  end

  if (AV0LW00.AV0LWLN1 == 0) /* color desc search field empty*/
    AV0LW00.AV0LWFND = "Y"; /* empty is like wildcard, so it is*/
                                   /* found*/
    return; /* nothing to search for*/
  end

   /* find the last character in the second table.*/

  AV0LW00.AV0LWLN2 = 0; /* init length of desc field*/
  AV0LW00.AV0LWIXZ = 30; /* set to max length*/

  while (AV0LW00.AV0LWIXZ >= 1) /* look backwards thru field*/
    if (AV0LW00.AV0LWSBE[AV0LWIXZ] == " ") /* last char not found yet*/
      AV0LW00.AV0LWIXZ = AV0LW00.AV0LWIXZ - 1; /* decrement*/
    else
       /* last char found.  set second work field length to index*/
      AV0LW00.AV0LWLN2 = AV0LW00.AV0LWIXZ; /* set length*/
      AV0LW00.AV0LWIXZ = 0; /* get out of loop*/
    end
  end

  if (AV0LW00.AV0LWLN2 == 0) /* color desc database field empty*/
    AV0LW00.AV0LWFND = "Y"; /* this should never happen*/
    return; /* nothing to search*/
  end

   /* now the compare begins*/
   /* this will compare the first table byte by byte with the*/
   /* second table starting in the first position of both.*/
   /* when the first non match between characters is found*/
   /* that part of the search stops.  the search starts over*/
   /* starting in the 2nd position of the 2nd table looking*/
   /* for the string...if not found it starts over starting*/
   /* at the 3rd position of the 2nd table...and so on, until*/
   /* a match is found or the 2nd table has been thoroughly*/
   /* searched.*/

  AV0LW00.AV0LWEND = "N"; /* init end flag*/
  AV0LW00.AV0LWFND = "N"; /* init found flag (for loop)*/
  AV0LW00.AV0LWSTR = 0; /* init starting position in 2nd work area*/

  while (AV0LW00.AV0LWFND == "N"
   && AV0LW00.AV0LWEND == "N")
    AV0LW00.AV0LWIXY = 1; /* reset 1st work area sub to 1*/
    AV0LW00.AV0LWIXZ = AV0LW00.AV0LWSTR + 1; /* set start position, 2nd tbl*/
    AV0LW00.AV0LWFND = "Y"; /* set to found*/

    while (AV0LW00.AV0LWFND == "Y"
     && AV0LW00.AV0LWEND == "N")
      if (AV0LW00.AV0LWSAE[AV0LWIXY] != AV0LW00.AV0LWSBE[AV0LWIXZ])
        AV0LW00.AV0LWFND = "N"; /* set to not found*/
        AV0LW00.AV0LWSTR = AV0LW00.AV0LWSTR + 1;
                                   /* increment start position*/
      else
        AV0LW00.AV0LWIXY = AV0LW00.AV0LWIXY + 1; /* increment 1st tbl index*/
        AV0LW00.AV0LWIXZ = AV0LW00.AV0LWIXZ + 1; /* increment 2nd tbl index*/
      end
      if (AV0LW00.AV0LWIXY > AV0LW00.AV0LWLN1) /* at end of field*/
        if (AV0LW00.AV0LWFND == "Y")
                                   /* all characters matched so it is found*/
          AV0LW00.AV0LWEND = "Y"; /* end the search loop*/
        end
      end
    end
    if (AV0LW00.AV0LWFND != "Y") /* not found*/
      AV0LW00.AV0LWLN3 = AV0LW00.AV0LWSTR + AV0LW00.AV0LWLN1;
      if (AV0LW00.AV0LWLN3 > AV0LW00.AV0LWLN2)
                                   /* searched to end of 2nd tbl*/
        AV0LW00.AV0LWEND = "Y"; /* end the search loop*/
      end
    else
      if (AV0LW00.AV0LWIXZ > AV0LW00.AV0LWLN2) /* at end of field*/
        if (AV0LW00.AV0LWIXY > AV0LW00.AV0LWLN1) /* at end of field*/
          AV0LW00.AV0LWEND = "Y"; /* end the search loop*/
        else
          AV0LW00.AV0LWFND = "N"; /* set to not found*/
          AV0LW00.AV0LWEND = "Y"; /* end the search loop*/
        end
      end
    end
  end

end // end AV0LS88

//*** RECORD=AV0LW00 ****
// ----------------------------
// Application working storage.
// ----------------------------
// ***********************
Record AV0LW00 type basicRecord
  10 AV0LWIX1 AV0LWIX1 ; 
  10 AV0LWIX2 AV0LWIX2 ; 
  10 AV0LWIXE AV0LWIXE ; 
  10 AV0LWIXF AV0LWIXF ; 
  10 AV0LWIXG AV0LWIXG ; 
  10 AV0LWIXH AV0LWIXH ; 
  10 AV0LWIXI AV0LWIXI ; 
  10 AV0LWIXJ AV0LWIXJ ; 
  10 AV0LWIXK AV0LWIXK ; 
  10 AV0LWIXL AV0LWIXL ; 
  10 AV0LWIXM AV0LWIXM ; 
  10 AV0LWIXN AV0LWIXN ; 
  10 AV0LWIXP AV0LWIXP ; 
  10 AV0LWIXS AV0LWIXS ; 
  10 AV0LWIXT AV0LWIXT ; 
  10 AV0LWIXX AV0LWIXX ; 
  10 AV0LWIXY AV0LWIXY ; 
  10 AV0LWIXZ AV0LWIXZ ; 
  10 AV0LWSWC AV0LWSWC ; 
  10 AV0LWEFA AV0LWEFA ; 
  10 AV0LWEFC AV0LWEFC ; 
  10 AV0LWEC1 AV0LWEC1 ; 
  10 AV0LWEC2 AV0LWEC2 ; 
  10 AV0LWEC3 AV0LWEC3 ; 
  10 AV0LWFTF AV0LWFTF ; 
  10 AV0LWSWD AV0LWSWD ; 
  10 AV0LWFPF AV0LWFPF ; 
  10 AV0LWFNF AV0LWFNF ; 
  10 AV0LWSWE AV0LWSWE ; 
  10 AV0LWSWF AV0LWSWF ; 
  10 AV0LWSWR AV0LWSWR ; 
  10 AV0LWPDT AV0LWPDT ; 
  10 AV0LWSZF AV0LWSZF ; 
  10 AV0LWSZL AV0LWSZL ; 
  10 AV0LWPRF AV0LWPRF ; 
  10 AV0LWSWU AV0LWSWU ; 
  10 XXXTSLEN XXXTSLEN ; 
  10 XXXTSPAG XXXTSPAG ; 
  10 TA5TSQIX TA5TSQIX ; 
  10 AV0LWCKE AV0LWCKE ; 
    15 KUCCOID KUCCOID ; 
    15 KUMSTRID KUMSTRID ; 
  10 AV0LWNDT AV0LWNDT ; 
    15 AV0LWNCC AV0LWNCC ; 
    15 AV0LWNYY AV0LWNYY ; 
    15 AV0LWNMM AV0LWNMM ; 
    15 AV0LWNDD AV0LWNDD ; 
  10 XSECD XSECD ; 
  10 AV0LWDTP AV0LWDTP ; 
  10 AV0LWDT1 AV0LWDT1 ; 
    15 AV0LW-WDC1 AV0LW-WDC1 ; 
    15 AV0LWDY1 AV0LWDY1 ; 
    15 AV0LWDM1 AV0LWDM1 ; 
    15 AV0LWDD1 AV0LWDD1 ; 
  10 AV0LWAOQ AV0LWAOQ ; 
  10 AV0LWFAQ AV0LWFAQ ; 
  10 AV0LWSFS AV0LWSFS ; 
  10 AV0LWSYR AV0LWSYR ; 
    15 AV0LWSCC AV0LWSCC ; 
    15 AV0LWSYY AV0LWSYY ; 
  10 XSNYR XSNYR ; 
  10 AV0LWSK AV0LWSK ; 
    15 XGPCD XGPCD ; 
    15 SY1STNBR SY1STNBR ; 
    15 SY2CLRID SY2CLRID ; 
    15 XPCCD XPCCD ; 
    15 XPLCD XPLCD ; 
    15 XGACD XGACD ; 
    15 AV1CUPRC AV1CUPRC ; 
    15 AVBSBQTY AVBSBQTY ; 
    15 XSUCD XSUCD ; 
    15 XLTCD XLTCD ; 
    15 XUMCD XUMCD ; 
    15 XLCCD XLCCD ; 
    15 XQACD XQACD ; 
    15 YCQCD YCQCD ; 
    15 XDVCD XDVCD ; 
    15 YSMXSU YSMXSU ; 
  10 AV0LWSLO AV0LWSLO ; 
  10 AV0LWSHI AV0LWSHI ; 
  10 AV0LWHI AV0LWHI ; 
  10 AV0LWLO AV0LWLO ; 
  10 AV0LWPFP AV0LWPFP ; 
  10 AV0LWCPN AV0LWCPN ; 
    15 AV0LWCID AV0LWCID ; 
    15 AV0LWPNB AV0LWPNB ; 
  10 AV0LWWPR AV0LWWPR ; 
  10 AV0LW1 AV0LW1 ; 
  10 AV0LW2 AV0LW2 ; 
  10 AV0LW3 AV0LW3 ; 
  10 AV0LWSCT AV0LWSCT ; 
    15 AV0LWCSN AV0LWCSN ; 
    15 AV0LWCDY AV0LWCDY ; 
  10 AV0LWNCT AV0LWNCT ; 
    15 AV0LWNSN AV0LWNSN ; 
    15 AV0LWNDY AV0LWNDY ; 
  10 AV0LWCWA AV0LWCWA ; 
    15 AV0LWCW1 AV0LWCW1 ; 
    15 AV0LWCW2 AV0LWCW2 ; 
  10 AV0LWSA AV0LWSA ; 
    15 AV0LWSAE AV0LWSAE [28] ; 
  10 AV0LWSB AV0LWSB ; 
    15 AV0LWSBE AV0LWSBE [30] ; 
  10 AV0LWFND AV0LWFND ; 
  10 AV0LWEND AV0LWEND ; 
  10 AV0LWLN1 AV0LWLN1 ; 
  10 AV0LWLN2 AV0LWLN2 ; 
  10 AV0LWLN3 AV0LWLN3 ; 
  10 AV0LWSTR AV0LWSTR ; 
  10 AV0LWORF AV0LWORF ; 
  10 AV0LWORL AV0LWORL ; 
  10 AV0LWFST AV0LWFST ; 
  10 AV0LWLST AV0LWLST ; 
  10 AV0LW-CHAR-FLD AV0LW-CHAR-FLD ; 
    15 AV0LW-CHAR-BYTE AV0LW-CHAR-BYTE [5] ; 
  10 AV0LW-NUM-FLD AV0LW-NUM-FLD ; 
    15 AV0LW-NUM-BYTE AV0LW-NUM-BYTE [5] ; 
  10 AV0LW-COMP-FLD AV0LW-COMP-FLD ; 
  10 AV0LW-SYRCATID1 AV0LW-SYRCATID1 ; 
    15 AV0LW-SYRCATXX1 AV0LW-SYRCATXX1 ; 
    15 AV0LW-SYRCATSS1 AV0LW-SYRCATSS1 ; 
    15 AV0LW-SYRCATYY1 AV0LW-SYRCATYY1 ; 
  10 AV0LW-SYRCATID2 AV0LW-SYRCATID2 ; 
    15 AV0LW-SYRCATXX2 AV0LW-SYRCATXX2 ; 
    15 AV0LW-SYRCATSS2 AV0LW-SYRCATSS2 ; 
    15 AV0LW-SYRCATYY2 AV0LW-SYRCATYY2 ; 
  10 * char(3) ; 
  10 AV0LW-DATE1 AV0LW-DATE1 ; 
    15 AV0LW-CC1 AV0LW-CC1 ; 
    15 AV0LW-YY1 AV0LW-YY1 ; 
  10 AV0LW-DATE2 AV0LW-DATE2 ; 
    15 AV0LW-CC2 AV0LW-CC2 ; 
    15 AV0LW-YY2 AV0LW-YY2 ; 
end // end AV0LW00

//*** RECORD=AV0LW01 ****
// --------------------------------------
// Map 001 display storage. product list.
// --------------------------------------
// ***********************
Record AV0LW01 type basicRecord
  5 XXXTSLEN XXXTSLEN ; 
  5 * char(926) ; 
    10 OP1ORDBY OP1ORDBY ; 
    10 KUMSTRNM KUMSTRNM ; 
    10 KUMCITYS KUMCITYS ; 
    10 KUMXSTCD KUMXSTCD ; 
    10 SY1STNBR SY1STNBR ; 
    10 SY1SSTNM SY1SSTNM ; 
    10 XQACD XQACD ; 
    10 SY2CLRID SY2CLRID ; 
    10 SY2CLRAB SY2CLRAB ; 
    10 XDMCD XDMCD ; 
    10 XDMDESC XDMDESC ; 
    10 XGACD XGACD ; 
    10 XPCCD XPCCD ; 
    10 * char(58) [14] ; 
      15 AV0LMSEL AV0LMSEL ; 
      15 AVASBSTY AVASBSTY ; 
      15 AVASBCLR AVASBCLR ; 
      15 AVASBDIM AVASBDIM ; 
      15 AV0LWSND AV0LWSND ; 
      15 AV0LWFSZ AV0LWFSZ ; 
      15 AV0LWTSZ AV0LWTSZ ; 
      15 AV0LWTLQ AV0LWTLQ ; 
      15 AV0LWCPN AV0LWCPN ; 
        20 AV0LWCID AV0LWCID ; 
        20 AV0LWPNB AV0LWPNB ; 
      15 AV0LWCLM AV0LWCLM ; 
      15 AV0LWAOI AV0LWAOI ; 
      15 AV0LWMTS AV0LWMTS ; 
end // end AV0LW01

//*** RECORD=AV0LW02 ****
// ----------------------------
// Application working storage.
// ----------------------------
// ***********************
Record AV0LW02 type basicRecord
  10 * char(12900) ; 
    15 XGPCD XGPCD [300] ; 
    15 SY1STNBR SY1STNBR [300] ; 
    15 SY2CLRID SY2CLRID [300] ; 
    15 SY2CLRAB SY2CLRAB [300] ; 
    15 XDMCD XDMCD [300] ; 
    15 XQACD XQACD [300] ; 
    15 XOWCD XOWCD [300] ; 
    15 XSDCD XSDCD [300] ; 
    15 XSACD XSACD [300] ; 
    15 XPGCD XPGCD [300] ; 
    15 XUMCD XUMCD [300] ; 
    15 AV0LWCM AV0LWCM [300] ; 
    15 XLCCD XLCCD [300] ; 
end // end AV0LW02

//*** RECORD=AVAREC ****
// *************** marketing substitution table ***************
// 
// db2 table:         davail.vsubsy01
// 
// copylib member:    dcl00787
// iomod:             io4840
// 
// key to db2 table:  xgpcd
//                    sy1stnbr
//                    sy2clrid
// 
// 
// maintenance log:
// date        init      comments
// --------    ------    --------------------------------------
// 12-04-89    mblail    created csp record
// 12/5/90     chyde     Changed item descriptions to DB elemt.
// ************************************************************
// **********************
Record AVAREC type basicRecord
  5 AVAGPR AVAGPR ; 
    10 XGPCD XGPCD ; 
    10 SY1STNBR SY1STNBR ; 
    10 SY2CLRID SY2CLRID ; 
    10 XDMCD XDMCD ; 
    10 AVASBPRI AVASBPRI ; 
    10 AVASBSTY AVASBSTY ; 
    10 AVASBCLR AVASBCLR ; 
    10 AVASBDIM AVASBDIM ; 
    10 ZZZCHGDT ZZZCHGDT ; 
    10 ZZZCHGTM ZZZCHGTM ; 
    10 ZZZCHGCT ZZZCHGCT ; 
end // end AVAREC

//*** RECORD=AVBREC ****
// *************** substitution ftwr/promo table **************
// 
// db2 table:         davail.vsubfw02
// 
// copylib member:    dcl00789
// iomod:             io4850
// 
// key to db2 table:  style number
// 
// 
// maintenance log:
// date        init      comments
// --------    ------    --------------------------------------
// 12-04-89    mblail    created csp record
// 12/5/90     chyde     Changed item descriptions to DB elemt.
// ************************************************************
// **********************
Record AVBREC type basicRecord
  5 AVBGPR AVBGPR ; 
    10 XPCCD XPCCD ; 
    10 XPLCD XPLCD ; 
    10 XGACD XGACD ; 
    10 AV1CUPRC AV1CUPRC ; 
    10 AVBSBQTY AVBSBQTY ; 
    10 SY1STNBR SY1STNBR ; 
    10 SY2CLRID SY2CLRID ; 
    10 XDMCD XDMCD ; 
    10 SY2CLRDS SY2CLRDS ; 
    10 XSUCD XSUCD ; 
    10 XLTCD XLTCD ; 
    10 XUMCD XUMCD ; 
    10 XLCCD XLCCD ; 
    10 XQACD XQACD ; 
    10 YCQCD YCQCD ; 
    10 XDVCD XDVCD ; 
    10 XGPCD XGPCD ; 
end // end AVBREC

//*** RECORD=AVCREC ****
// *************** substitution apparel table  ****************
// 
// db2 table:         davail.vsubap02
// 
// copylib member:    dcl00791
// iomod:             io4860
// 
// key to db2 table:  style number
//                    color code
// 
// maintenance log:
// date        init      comments
// --------    ------    --------------------------------------
// 12-04-89    mblail    created csp record
// ************************************************************
// **********************
Record AVCREC type basicRecord
  5 AVCGPR AVCGPR ; 
    10 XGACD XGACD ; 
    10 XPCCD XPCCD ; 
    10 YSMXSU YSMXSU ; 
    10 XSUCD XSUCD ; 
    10 AV1CUPRC AV1CUPRC ; 
    10 AVBSBQTY AVBSBQTY ; 
    10 SY1STNBR SY1STNBR ; 
    10 SY2CLRID SY2CLRID ; 
    10 XDMCD XDMCD ; 
    10 SY2CLRDS SY2CLRDS ; 
    10 XUMCD XUMCD ; 
    10 XLCCD XLCCD ; 
    10 XQACD XQACD ; 
    10 YCQCD YCQCD ; 
    10 XDVCD XDVCD ; 
    10 XSECD XSECD ; 
end // end AVCREC

//*** RECORD=AVEREC ****
// *************** substitution io4850 pass record ************
// 
// db2 table:         davail.vsubfw02
// 
// iomod:             io4850
// 
// 
// maintenance log:
// date        init      comments
// --------    ------    --------------------------------------
// 02-26-90    mblail    This record is used to pass parameters
//                       from a csp appl. to IO4850, which is
//                       used to access davail.vsubfw02
// ************************************************************
// **********************
Record AVEREC type basicRecord
  5 AVEGPR AVEGPR ; 
    10 AVEIOTSK AVEIOTSK ; 
    10 AVECOLO AVECOLO ; 
    10 AVECOHI AVECOHI ; 
    10 AVESULO AVESULO ; 
    10 AVESUHI AVESUHI ; 
    10 AVELTLO AVELTLO ; 
    10 AVELTHI AVELTHI ; 
    10 AVEWPLO AVEWPLO ; 
    10 AVEWPHI AVEWPHI ; 
    10 AVECLLO AVECLLO ; 
    10 AVECLHI AVECLHI ; 
    10 AVECTLO AVECTLO ; 
    10 AVECTHI AVECTHI ; 
end // end AVEREC

//*** RECORD=AVFREC ****
// *************** substitution io4860 pass record ************
// 
// db2 table:         davail.vsubap02
// 
// iomod:             io4860
// 
// 
// maintenance log:
// date        init      comments
// --------    ------    --------------------------------------
// 02-26-90    mblail    This record is used to pass parameters
//                       from a csp appl. to IO4860, which is
//                       used to access davail.vsubap02
// ************************************************************
// **********************
Record AVFREC type basicRecord
  5 AVFGPR AVFGPR ; 
    10 AVFIOTSK AVFIOTSK ; 
    10 AVFCLLO AVFCLLO ; 
    10 AVFCLHI AVFCLHI ; 
    10 AVFCOLO AVFCOLO ; 
    10 AVFCOHI AVFCOHI ; 
    10 AVFSULO AVFSULO ; 
    10 AVFSUHI AVFSUHI ; 
    10 AVFWPLO AVFWPLO ; 
    10 AVFWPHI AVFWPHI ; 
    10 AVFGAIND AVFGAIND ; 
end // end AVFREC

// line selection indicator
DataItem AV0LMSEL char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Y2k date field (see AV0LS26)
DataItem AV0LW-CC1 num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Y2k date field (see AV0LS26)
DataItem AV0LW-CC2 num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// work field
DataItem AV0LW-CHAR-BYTE char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// work field
DataItem AV0LW-CHAR-FLD char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// work field
DataItem AV0LW-COMP-FLD num(5,1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Y2K date field (see AV0LS26)
DataItem AV0LW-DATE1 num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Y2K date field (see AV0LS26)
DataItem AV0LW-DATE2 num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// work field
DataItem AV0LW-NUM-BYTE char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// work field
DataItem AV0LW-NUM-FLD num(5,1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// work catalog id
DataItem AV0LW-SYRCATID1 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// work catalog id
DataItem AV0LW-SYRCATID2 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// work catalog season
DataItem AV0LW-SYRCATSS1 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// work catalog season
DataItem AV0LW-SYRCATSS2 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// work catalog filler
DataItem AV0LW-SYRCATXX1 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// work catalog filler
DataItem AV0LW-SYRCATXX2 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// work catalog year
DataItem AV0LW-SYRCATYY1 num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// work catalog year
DataItem AV0LW-SYRCATYY2 num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Work area for century
DataItem AV0LW-WDC1 num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Y2K date field (see AV0LS26)
DataItem AV0LW-YY1 num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Y2K date field (see AV0LS26)
DataItem AV0LW-YY2 num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Work field
DataItem AV0LW1 num(5)  {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Work field 2
DataItem AV0LW2 num(5)  {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Work field 3
DataItem AV0LW3 decimal(7,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// subst. audit indicator
DataItem AV0LWAOI char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// At-once qty. accumulator
DataItem AV0LWAOQ num(5)  {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Work area for catalog year
DataItem AV0LWCDY num(2)  {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Catalog Identifier
DataItem AV0LWCID char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Customer key
DataItem AV0LWCKE num(6)  {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// substitute color match ind.
DataItem AV0LWCLM char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Color match indicator
DataItem AV0LWCM char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// substitute catalog page number
DataItem AV0LWCPN char(10)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Work area for catalog sesn
DataItem AV0LWCSN char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Catalog Id - first 2 bytes
DataItem AV0LWCW1 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Catalog Id - season/year
DataItem AV0LWCW2 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Catalog Identifier - work area
DataItem AV0LWCWA char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Work area for day
DataItem AV0LWDD1 num(2)  {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Work area for month
DataItem AV0LWDM1 num(2)  {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Work area for date
DataItem AV0LWDT1 num(8)  {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Current date + 30 days
DataItem AV0LWDTP int {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Work area for year
DataItem AV0LWDY1 num(2)  {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// EOF dprod.vcolor01
DataItem AV0LWEC1 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// EOF davail.vsubfw02
DataItem AV0LWEC2 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// EOF davail.vsubap02
DataItem AV0LWEC3 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// EOF davail.vavqty02
DataItem AV0LWEFA char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// EOF dprod.vcatlg01
DataItem AV0LWEFC char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Search End flag
DataItem AV0LWEND char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// First avail. accumulator
DataItem AV0LWFAQ num(5)  {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Color description found flag
DataItem AV0LWFND char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Found/not found duplicate flag
DataItem AV0LWFNF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Page full or partial flag
DataItem AV0LWFPF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// first external size
DataItem AV0LWFST char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// substitute from size
DataItem AV0LWFSZ char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// First time flag
DataItem AV0LWFTF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Save A/O high size
DataItem AV0LWHI smallint {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Index for pg3rec routine
DataItem AV0LWIX1 smallint {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Index for pg3rec routine
DataItem AV0LWIX2 smallint {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Index for selected subst.
DataItem AV0LWIXE smallint {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Index for size range search
DataItem AV0LWIXF smallint {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Index for FTWR criteria fetch
DataItem AV0LWIXG smallint {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Index for APRL criteria fetch
DataItem AV0LWIXH smallint {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Index for saving AV0LWIXM
DataItem AV0LWIXI smallint {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Index for searching syprec
DataItem AV0LWIXJ smallint {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Index for inspecting temp rec.
DataItem AV0LWIXK smallint {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Index for cking. dup prod tbl.
DataItem AV0LWIXL smallint {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Index for map fields
DataItem AV0LWIXM smallint {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Index for blank map lines
DataItem AV0LWIXN smallint {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Index for price fields
DataItem AV0LWIXP smallint {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Index for size buckets
DataItem AV0LWIXS smallint {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Index for product table
DataItem AV0LWIXT smallint {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Index for season table
DataItem AV0LWIXX smallint {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Index for color search field 1
DataItem AV0LWIXY smallint {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Index for color search field 2
DataItem AV0LWIXZ smallint {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Length of data in work fld 1
DataItem AV0LWLN1 num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Length of data in work fld 2
DataItem AV0LWLN2 num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Length work field
DataItem AV0LWLN3 num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Save A/O low size
DataItem AV0LWLO smallint {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// last external size
DataItem AV0LWLST char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Marketing tbl. indicator
DataItem AV0LWMTS char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Need date century
DataItem AV0LWNCC num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = "0", inputRequired = no
}
end

// search catalog next sesn/year
DataItem AV0LWNCT char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Need date day
DataItem AV0LWNDD num(2)  {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Customer need date
DataItem AV0LWNDT num(8)  {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Work area for cat next year
DataItem AV0LWNDY num(2)  {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Need date month
DataItem AV0LWNMM num(2)  {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Work area for cat next sesn
DataItem AV0LWNSN char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Need date year
DataItem AV0LWNYY num(2)  {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// from ovrd external size
DataItem AV0LWORF char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// to ovrd external size
DataItem AV0LWORL char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Date for checking eff. price
DataItem AV0LWPDT int {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Products found per pass
DataItem AV0LWPFP smallint {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Catalog Page Number
DataItem AV0LWPNB num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Found price row flag
DataItem AV0LWPRF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Color search work field 1
DataItem AV0LWSA char(28)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Color search work fld 1 char
DataItem AV0LWSAE char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Color search work field 2
DataItem AV0LWSB char(30)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Color search work fld 2 char
DataItem AV0LWSBE char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Century
DataItem AV0LWSCC num(2)  {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// search catalog season/year
DataItem AV0LWSCT char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Search finished switch
DataItem AV0LWSFS char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Save high size
DataItem AV0LWSHI smallint {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Search key
DataItem AV0LWSK char(38)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Save low size
DataItem AV0LWSLO smallint {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// subst. color short name
DataItem AV0LWSND char(18)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Start pos in work fld 2 search
DataItem AV0LWSTR num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// EOF davail.vsubsy01
DataItem AV0LWSWC char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Map to be displayed switch
DataItem AV0LWSWD char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// end of fetch counter
DataItem AV0LWSWE char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Format the map switch
DataItem AV0LWSWF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Request for data switch
DataItem AV0LWSWR char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Storage page update switch
DataItem AV0LWSWU char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Search year
DataItem AV0LWSYR num(4)  {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// Year
DataItem AV0LWSYY num(2)  {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// From date for avail range
DataItem AV0LWSZF smallint {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// To date for avail range
DataItem AV0LWSZL smallint {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// substitute total quantity
DataItem AV0LWTLQ char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// substitute to size
DataItem AV0LWTSZ char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// FTWR price limit
DataItem AV0LWWPR decimal(7,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// mktg. substitution record
DataItem AVAGPR char(34)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// AV_SUBS_COLR_CD_ID
DataItem AVASBCLR char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// AV_SUBS_DIM_CD
DataItem AVASBDIM char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// AV_SUBS_PRTY
DataItem AVASBPRI smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = nullFill, inputRequired = no
}
end

// footwear subst. record
DataItem AVBGPR char(68)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// AV_SUBS_QTY_IND
DataItem AVBSBQTY char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// apparel subst. record
DataItem AVCGPR char(66)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// IO-HI-COLOR
DataItem AVECLHI char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// IO-LO-COLOR
DataItem AVECLLO char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// IO-HI-COLL
DataItem AVECOHI char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// IO-LO-COLL
DataItem AVECOLO char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// IO-HI-catagory
DataItem AVECTHI char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// IO-LO-catagory
DataItem AVECTLO char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// IO4850 pass record
DataItem AVEGPR char(32)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// IO-TASK
DataItem AVEIOTSK char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// IO-HI-LAST
DataItem AVELTHI char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// IO-LO-LAST
DataItem AVELTLO char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// IO-HI-SILH
DataItem AVESUHI char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// IO-LO-SILH
DataItem AVESULO char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// IO-HI-PRICE
DataItem AVEWPHI decimal(7,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = nullFill, inputRequired = no
}
end

// IO-LO-PRICE
DataItem AVEWPLO decimal(7,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = nullFill, inputRequired = no
}
end

// IO-HI-COLR
DataItem AVFCLHI char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// IO-LO-COLR
DataItem AVFCLLO char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// IO-HI-COLL
DataItem AVFCOHI char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// IO-LO-COLL
DataItem AVFCOLO char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// IO-XGA-XPC-IND
DataItem AVFGAIND char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// IO4860 pass record
DataItem AVFGPR char(25)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// IO-TASK
DataItem AVFIOTSK char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// IO-HI-SILH
DataItem AVFSUHI char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// IO-LO-SILH
DataItem AVFSULO char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// IO-HI-PRICE
DataItem AVFWPHI decimal(7,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = nullFill, inputRequired = no
}
end

// IO-LO-PRICE
DataItem AVFWPLO decimal(7,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = nullFill, inputRequired = no
}
end

