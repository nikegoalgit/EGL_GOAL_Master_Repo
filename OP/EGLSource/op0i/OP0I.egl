package op0i;
import av.common.*;
import corpcom1.*;
import corpcom2.*;
import corpcom3.*;
import corpcom4.*;
import corpcom5.*;
import corpcom6.*;
import corpcom7.*;
import corpx1.*;
import corpx2.*;
import corpy2.*;
import corpz3.*;
import dg.common.*;
import fb.common.*;
import fk.common.*;
import fy.common.*;
import in1.common.*;
import iv.common.*;
import ko.common.*;
import ku.common.*;
import ni.common.*;
import nl.common.*;
import ob.common.*;
import oi.common.*;
import op.common.*;
import os.common.*;
import pc.common.*;
import pg.common.*;
import pk.common.*;
import pw.common.*;
import sm.common.*;
import sp.common.*;
import sy.common.*;
import ta.common.*;
import tf.common.*;
import ts.common.*;
import vv.common.*;
import ww.common.*;
//*** PROGRAM=OP0I ****
// nike order entry - product size detail
// 
// this process allows the user to enter the size quantities
// for products. they can also specify which warehouse and
// need date to ship each product.
// 
// overview: user keys in quantity by size for up to 40 sizes
// on the product.  the screen contains only 20 sizes, so
// we may show the screen twice.  then we edit screen 1
// top part only, and edit the entire screen 2.
// 
// this application may be executed for up to 6 products sent
// from the multiple product header screen.  the minimum
// number products is 1, from the single product header screen.
// 
// the screen data may come from 'initialization' of a new
// product, or from a product already entered - 'review' mode.
// both build data into op3rec in working-storage.
// the map is always built from op3rec.
// 
// there is no required data on this screen.  quantities in the
// requested first size & last size fields are edited as a
// warning only.  when quantity is entered, and this applic.
// came from the multiple product header (data entry form flow)
// then the quantity entered must equal the requested qty.
// either the qty entered or the qty requested may be changed
// to ensure the match.
// 
// the statement groups are numbered as follows:
//      s1x - first used in process p010
// 
//      s2x - first used in process p020
// 
//      s3x - first used in process p030
// 
//      s5x - first used in process p050
// 
//      s4x - first used in process p060 -
//            edits the top half of the screen -
//            requested total qty, qty by size & price by size.
//      s6x - first used in process p060
//      s7x - first used in process p060
//            edits the bottom half of the screen -
//            'price for all' through 'forecast'.
// 
//      s8x - exit flows, out of this application
// 
//      s9x - db2 data base access
// 
// 
//   note: program contains hard coding for promo so that they
//         can skip the 1-whs model edit. looks for xdvcd of
//         '03' in whs tbl. coded into op0i020 and op0is79.
// 
//                                             --- jim v.
//         Hard coding for owner group also. if value is '00'
//         show spaces on map.
// 
// ***********************************************************
// sub-programs called;
// 
//    db1000    io0560   io4500    op0a
//    db1030    io0570   io4590    op0h
//    in9010    io0580             op0j
//    io0040    io0890             op0k
//    io0080    io0900             ta0020
//    io0110    io0910             ta0040
//    io0360    io0960             mn0s
//    io0380    io1450             op04
//    io0430    io1660
//    io0440    io2640
// 
// ************************************************************
// 
// files updated;
// 
//    inzrec   inventory & availability qty chgs
//    oebrec   nil zero price audit record
//    opfrec   audit report table
//    pk1rec   picking transaction record
//    opirec   picking item record (new)
//    op3rec   item table
//    opbrec   formatter size run rtn cd
//    op0iw03  w/s view of item/size
//    optrec   lost demand record
// 
// ***********************************************************
// 
// date created: june 1986
//       author: bcourt
// 
// maintenance history:
// 
//    date     by whom     overview of changes made
//  --------  ----------  ------------------------------------
//  06-01-86  bcourt      initial code
//  09-16-86  jvande      changed to use warehouse required
//                        from xds table when editing the
//                        warehouse code.
//  10-10-86  jvande      bulk/draw phase 2 project
//  11-13-86  jvande      avail/alloc phase 2 project
//  01-15-87  jvande      bulk/draw bug - init qty flags in s10
//                        avail bug - don't let order if old
//                        avail date and at-once and today's
//                        need date.
//  01-19-87 **** jdv     hard coded s21 and s79 for special
//                        sales skip of 1-whs edit
//  02/10/87  jvande      added s2b to default more info from
//                        bulk. called in 020 and 040.
//  02/13/87  sjob        reset mdt's from op0i060 on errors.
//  02/17/87  jvande      overlayed defaulted xowcd from bulk
//                        with opwrec.xow. 020,030,040 changed.
//  02/19/87  craine      futures availability enhancement.
//                        changed the following:
//                        op0i020, op0i030, op0i040, op0i050
//                        op0isga, op0is40, op0is52, op0is6e
//                        op0is7c and op0is78. will show and
//                        edit qtys for futures order types
//                        that have the xotdsavl = 'a' and
//                        and production add on = 'y'. av1rec
//                        is not read from 020, 030 or 040
//                        (thru op0isga) anymore....
// 03/03/87   jvande      chnged 020,030,040 so won't let user
//                        dup prev prd if xum differ. caused
//                        wierd prices.
// 03/05/87   jvande      changed s47 and s40 so that won't let
//                        user add sizes that are unallocatable
//                        in review mode.
// 03/05/87   jvande      changed sai,adi,sci, added sei - chng
//                        in in9010 return codes. soft error
//                        traps put into code.
// 03/18/87   tmai        changed program to allow any service
//                        rep to enter promo orders with the
//                        universal owner group code - op0is81
// 03/30/87   jvande      changed s7c, pulled xow edit out to
//                        stand alone. let whs orders thru with
//                        out xow codes.
// 04/01/87   jvande      changed s90, when deadlock, skipped
//                        line item array cell. op0k thought
//                        cell active and blew on read. fixed
//                        so on deadlock, marks cell as rejctd.
// 04/02/87   jvande      rev mode overlayed enter xow with opw
//                        xowcd. bad news (030)
// 04/03/87   jvande      fixed two bugs: 1) in rev mode if
//                        used any pf key, unportected xow.
//                        if changed xow, would unpro whs and
//                        ND. chngd to not edit xow in revm-s7c
//                        2) if drew from bulk that had resv qt
//                        on one size with next size not being
//                        RSVED, would set stat op instead of
//                        pr. chngd sub and suc.
// 04/09/87   jvande      change s90,s6e, and s40. can alloc in
//                        rev mode if eliminate size with date
//                        condition code. changed program to
//                        support.
// 04/10/87   craine      change s81 to show error  when owner
//                        group is ' ' or '00' and required
//                        for warehouse.
// 04/13/87   ssayew      change s78 and 050 so that production
//                        add on flag would be calculated and
//                        set for draw-set-aside (ds) records.
// 04/13/87   ssayew      inserted order type, need date, and
//                        warehouse in opfrec.opfalpha (s83).
//                        w-s fields added to op0iw01.
// 04/13/87   ssayew      change so that audit record is
//                        written when futures order booked
//                        after production deadline and either
//                        a regular order, set-aside-draw, or
//                        customer bulk order (s82).
// 04/14/87   craine      change s81 to show error  when owner
//                        group is not in the owner group table
//                        for warehouse.
// 04/15/87   jvande      changed s89,s63 so zero op2lninb aftr
//                        decide to go back to op0k for phone
//                        flow and prd rejtd. s40,050,s7c so
//                        keep whs/nd/xow protected in rev mode
// 05/04/87   craine      product substitution enhancement
// 05/05/87   jvande      chngd s7c, needed to restore orig sub
//                        ord subscript if maxed out sub array.
// 05/06/87   jvande      chngd s7c, wouldn't put nd chng to
//                        different sub-ord for dir shp orders.
// 05/07/87   ssayew      chngd s79 so that correct warehouse
//                        abbreviation appeared on screen.
// 05/26/87   craine      changed the following to not move ' '
//                        to xdmcd - op0is63, op0is95, op0i020
//                        and op0i050.
// 06/11/87   jvande      chngd s29 to detect draw prods from
//                        different bulk sub-ords. prog will
//                        get whs for new bulk sub-ord.
// 07/22/87   obecke      cursor set for pf6, pf21.  added
//                        avail msg, qual abrv to screen. chg
//                        pf24 to ask for dmnd qty first time
//                        thru.
// 08/04/87   t.fox       added edits to stmt grp s78. new fut
//                        with a need date 30 days past can
//                        only be entered by authorized person.
// 08/10/87   jvande      added reset call to s91,s90. also
//                        excluded draws from 1-whs edit. were
//                        seeing rsrv qty against wrong whs.
// 08/20/87   tfox        chngd sai,sei,sci to do chking for
//                        neg qty's.
// 08/25/87   jvande      new order edits, ndt,whs.
// 08/26/87   jvande      relax nd=furthest avail date for a
//                        few days until production set for it.
// 08/31/87   jvande      put edits back. = avail dt chngd to
//                        atonce only. advance can enter any
//                        need date = or > avail date.
// 09/14/87   jvande      support xsdcd - sai,sci,020,050,m001.
// 09/30/87   jvande      uncorked pick chngs. hrd cd for whs
//                        on new picking system.
// 10/06/87   tfox        added code to s78,050,s6e,s47 for
//                        changes to org ord qty definition
//                        for futures orders.
// 10/12/87   tfox        added code to s6e and s9a to stop
//                        need date changes in review mode.
// 10/12/87   tfox        chg code in sga to allow show of
//                        avail for bulk orders.
// 10/14/87   jvande      chng to trap pa keys. set ndt mod so
//                        edit good. also only write pd rec
//                        for ot's w/dmnd rpt flag on.
// 10/29/87   jvande      when switch to new bulk sub, carry
//                        over new need date as well as whs.s29
// 11/05/87   jvande      2 bugs - 1. would let order when cant
//                        find avail rec(s6c). 2. would reject
//                        product for neg aloc qty in revm(sei)
// 11/09/87   jvande      2 bugs - 1. change message for sei.
//                        2. only get new bulk need date for
//                        customer draws.(s29)
// 11/11/87   tfox        in s29 chg code to move new need date
//                        on all draw orders.
// 11/12/87   jvande      changed to not default nd from bulk.
//                        also fixed nd edit between bulk nd
//                        and dsa dt, didn't have dts for edit.
// 11/25/87   jvande      hooked up whs 02 for picking.
// 12/04/87   jvande      hooked up whs 07 for picking.
// 01/06/88   tfox        hooked up whs 3,9,12 for picking
// 01/15/88   jhh         added flexible bulk/draw to sga/s10/
//                        s47/s52/s6c/s6e/s61/s70/s78/s82/s9a/
//                        s93/020/030/040/050
// 02/15/88   tfox        phased availability processing added.
//                        stmt grps affected sai/sdi/sei/sga/
//                        sg1/sg4/sg5/sg6/s40/s41/s47/s52/s7c/
//                        s79/060 op0iw01 op0iw04.
// 02/15/88   jhh         added av5->av1 conversion to sci/sdi
// 02/16/88   jhh         suppress re-chk at-once avail to s7c
// 02/17/88   tfox        add sqlcd=-100 in avhdr select to sg4
// 02/17/88   tfox        corrected abend msg in sg1
// 02/17/88   jhh         use avhdr dt if found/else cd to sg4
// 02/17/88   craine      fixed s29 commented out code checking
//                        for product from same sub order has
//                        the last product - didn't work, was
//                        using the wrong whse and need date
//                        because op0iwsbs was always set to 1.
// 02/18/88  tfox         add life cycle to conditions for
//                        building date parms in sg1
//                        chg conditions for errors and fix dia
//                        info in sei.
// 02/19/88  jhh          removed 25/20 day override in sg6
// 02/23/88  craine       moved op1rec.op1cundtto opawdt before
//                        moving opwrec back to op1rec in s29
//                        so s27 would use the correct need dt.
// 02/23/88  tfox         remove old get comment code(sgl) and
//                        put logic in sga,sg1,sg4.
//                        sai,sci,sdi chg code to move w/h
//                        after record move
// 02/25/88 tfox         chg default for pkgcd in sg1 sg4 to 0
// 03m01/88 tfox         removed xcdtbl.xcdentfl flag logic in
//                       s40,s47,s52. chg date fields used to
//                       read hdr in sga,sg1,sg4,sg6.
//                       added op0iw01.op0iwetn to w/s
// 03/02/88 tfox         init dtn in sga. init avq ava sg1
// 03/09/88 tfox         reset 1st/last sizes and init qtc and
//                       ndc flags for dup-product size/qty's
//                       in s60/040
// 03/24/88 scass        took out code that read the xcdtbl
//                       that checked xcdoaloc flag.
//                       this flag caused availibility to be
//                       checked only when an atonce ot occured
// 03/25/88 craine       chg s29 to use draw op1cundt for ds &
//                       dx draws, use bulk op1cundt for dc.
// 04/10/88 craine       added db1000 return code to abend msg
//                       in s29.
// 04/14/88 gwells       production deadline table - s78 & 050
//                         replaced xpdtbl with call to
//                         io2560 - dorder.vcutof01.  edit
//                         need date versus prod deadline via
//                         this module.  added opjrec & oplrec.
// 04/27/88 obecke       op0i060: chgd pf21 edit to call s30
//                       instead of s60. 'edit pf21' (s60)
//                       deleted, as both phone & form should
//                       provide full size range,not just form.
// 05/02/88 gwells       diagnostic fix - if sqlcode = 100 in
//                       's32', do not abend; post error and
//                       write out key (o.t. & need date).
// 06/01/88 tfox         chg s24 slspgm price logic
// 06/02/88 craine       chg s52 to set qty on map to value in
//                       op3rec - may be qty entered for size
//                       or zero if nothing entered - fixes bug
//                       causing 1 size qty in second screen to
//                       be defaulted qty from 1st screen.
// 06/08/88 scass        add complete information to diag.
//                       op0isei.
// 06/30/88 obecke       fixed pf21&dup problem where prices
//                       by size were not all displaying. took
//                       out logic 'if sales program read db
//                       product file.' chgd to always read
//                       file.  030,040.
// 07/26/88 obecke       log#9: s29 fixed info passed to ta1rec
//                       key so can read it. chgd w01 op0iwprt
//                       to character (was numeric).
// 09/22/88 tfox         apparel that crosses seasons now shows
//                       avail date as the cond cd date from
//                       the header instead of the period rec.
//                       added new stmt grps sgb,sgc,sgd. also
//                       changed s40 (cursor position only) and
//                        added 2 new items to op0iw01,
//                        sed, season end date and crs cross
//                        season switch.
// 10/04/88 dwalke       added smart/fles avail by-pass in sga
// 10/25/88 skott        availability - add hooks to call op02
//                         or op1610 to decrement availability-
//                         s6e, s6k, s47, s6l, 010, op0iw01.
// 10/27/88 skott        availability - changed s6l & op0iw01.
//                         added sgrp s6m.
// 10/28/88  gwells      rebooking - added code to accomodate
//                         the new 'rebook draw' type - s10,
//                         s24, s29, s32, s47, s52, s6c, s6e,
//                         s70, s78, s9a, s93, 020, 030, 040,
//                         050, 060.
// 11/04/88 JWOOD        NONCSP OPT ADDED TO CALLS
// 11/18/88 skott        availability - changed sgb to show
//                         period rec for apparel orders xing
//                         seasons instead of header date.
// 11/18/88 obecke       availability - added order class to
//                         opprec and op1610 (linkage section)
//                         adjusted call logic -s6k
// 12/06/88 jjohns       bl#91 - s52 now moves message 385
//                         only if ezemno eq 0.
// 12/13/88 dwalke       allow two year in acvance need date -
//                         s78, bug #101
// 12/13/88 obecke       do not abend when avail recs not
//                       available.  show msg and post error.
//                       #105.  s6l.
// 01/04/89 craine       add ssa,ssc,ssd,ssi to allocate smart
//                       reservation draws.also change s6e,sga
//                       s40,s93 and s6c. added opsrec - passed
//                       to in9030 (in9020 clone).
// 01/06/89 skott        check offering date in op0i instead
//                       of op0h so need date can be changed
//                       added s4b,sdz,sdw,sdx,sdy; changed
//                       s40,s47,s70,050,w01
// 01/09/89 dwalke       add segmented transaction id to appl.
// 01/12/89 rdavis       change test if sample order from hard
//                       coded order types to use sample flag
//                       from order type table - sdz
// 01/19/89 skott        report lost demand.  added optrec.
//                       s20, s63, s85, s86, s82
// 01/20/89 skott        if xdvcd = '03' (promo) or draw order
//                       skip offering date check -sdz.
// 01/25/89 craine       fix ssa to move size qtys to pick item
//                       and pick tran only when size active
//                       else move zero.
// 01/26/89 skott        fix s8a to accum on order qtys to
//                       opfrec, not op2tonoq. s63,s82, 050
// 01/27/89 obecke       added oppdecav flag and order class
//                       code to opprec for calling op1610.
//                       s6k. #111, #112.
// 01/30/89 dwalke       ADDED IF STATEMENT IN SEI AND SSI TO
//                       BYPASS POSTING OF ERRORS 1021, 1024,
//                       1050 and 1060 return codes.
// 02/02/89 craine       chg sub, suc to zero orig qty for
//                       rebook draws.
// 03/01/89 skott        highlight all qty fields when pf24
//                       cancel is requested.  s54, s63
// 03/06/89 skott        bug #147, get availability hdr with
//                       period begin date for all apparel
//                       orders that have need date outside
//                       product offering date so that comment
//                       will be displayed.  sg4,sgb,sgd, sgc,
//                       added sge, sgf, sgg
// 03/17/89 skott        added op1tbrep to optrec s86
// 03/20/89 skott        added opurec for dorder.voraud01 audit
//                       s8a,s8c,s8d,s8e,s82,s86
// 03/20/89 rdavis       bug # 153 too large qtys on bulk rsrvd
//                       when draw decreased. suc
// 03/27/89 gwells       bug #147, get availability hdr comment
//                       with op0iwsbd (period or needdate
//                       season begin date ) first. if no
//                       comment, get hdr with current season
//                       begin date for comments - sg1,sg4,sgb,
//                       sgc,sgf.
// 04/01/89 tfox         added hot model logic to s64,050,060.
//                       changed sycrec to sy2tmp in sdw,sdx,
//                       sdy,sgl,s22,s23,s24,s32,s4b,s40,s77,
//                       s64,s79,s94,s95,s96,s21.
// 04/10/89 tfox         added logic to force recheck of hot
//                       model when need date is pushed out
//                       shm,sov,s64,s78.
// 04/11/89 mbarna       move zero to store and department on
//                       select to dorder.vhotcu01-shm.
// 04/24/89 skott        added code to display xdmcd.   s82,050
//                       s95, s70, s32, s6k
// 05/17/89 obecke       divisions added to xottbl. s23.
// 05/30/89 dwalke       op0is6e removed if statement so that
//                       op1610 would always be called, this is
//                       in conjuction with the changes to
//                       in9020 to bypass availability when
//                       called by an "op" application.
// 05/30/89 mbarna       added code to make sure wh is not
//                       blank when a wh is requried. s79
// 06/05/89 rdavis       move defaults of zero to spec, shade
//                       and package code when updating avail.
//                       call op1610. s6k
// 06/07/89 scantr       added call reset to fix bug (op0is6l)
// 06/15/89 skott        allow zero price if on saleprogram
//                       and raw material. s61,s6h,s6z
//                       bug #189.
// 06/27/89 rdavis       move ' ' to availability header record
//                       type when getting header for second
//                       season avialability. sge. bug #202.
//                       when getting comments from avail.
//                       header, do not use season begin date
//                       for closeouts - sg1, sg4.
// 07/24/89 rdavis       if warehouse '03', default to owner
//                       group code of '00' if none entered.
//                       se # 203. s81.
// 08/01/89 rdavis       change call of io0960 to io0580 for
//                       reading inventory header because view
//                       used in io0960 is being deinstalled.
//                       fix #218. sai,sci,sdi.
// 08/03/89 rdavis       show avialability condition codes
//                       for advanced prop apparel. new state-
//                       ment group to get comments from avail
//                       header for clarity. fix #186. sg4,sgh.
// 08/04/89 craine       wrong qty being moved to opirec total
//                       qty in op0issa. was moving op3rec
//                       reserved qty (always 0) now moving
//                       op3rec on-ord qty.
// 08/07/89 jbecke       bypass hot model logic if division
//                       is '03' or prod quality is not '01'.
// 08/23/89 rcoron       fixed inappropriate message (397) in
//                       review mode.  fixed bug to validate
//                       only the incremented amount in the
//                       ordered quantity against what's avail-
//                       able in review mode.
// 08/28/89 craine       use opwrec.xwhcd(sub) for audit record
//                        s8d.
// 09/01/89 craine       remove opfrec code (dorder.vopaud01)
// 09/05/89 schase       for NIL orders with first quality and
//                       '05' or '10' life cycles, check the
//                       product offering restriction table.
//                       050, s70, created sod, op0iw05.
// 09/06/89 gwells       display and decrement availablilty
//                       for futures if the order class code
//                       is 'gf'(golf)-sga. move xoccd to
//                       to the opprec - s6k.
// 09/06/89 rcoron       #224 allow entry of duplicate product-
//                       id's within the same sub-order number
//                       as long as the user-id used is under
//                       division code 03 (promo),  the order
//                       is regular -- not bulk nor drawn, and
//                       that either the unit of measure or the
//                       group owner have to be different.
//                       changes were done to op0is9a.
// 09/12/89 gwells       golf - get futures footwear availa-
//                       bility using the needdate (like appa-
//                       rel) so all available qtys up to the
//                       needdate are displayed - sga,sg4,sgb.
// 09/26/89 rcoron       #244  added the facility to read
//                       all colors from the sales program
//                       product file (op0is99).
// 10/23/89 rcoron       modified op0is78 to allow flexible
//                       draw orders to have need dates earlier
//                       than the flex-bulk order need date it
//                       is drawing from.  see also op0c/
//                       op0cs18.
// 10/31/89 scantr       added code for nil pricing.
//                       changed s20,s22,s24,s6e,s61,s97,w01,
//                       010. added s9b-s9k.
// 11/09/89 rdavis       added lost demand entry process. when
//                       pf24 hit to record lost demand, new
//                       map is conversed displaying the
//                       sizes requested and any quantities
//                       from op0im001. hitting enter causes
//                       lost demand to be entered and regular
//                       op0i processsing continues. lost
//                       demand edit module (op04) is called
//                       to edit new screen. modified op0i060,
//                       s63, s86. new processes op0i070,
//                       op0i080. new statement groups sbm,seb,
//                       seo,sew,sra,sym,syt,s01. new op0iw01
//                       items, new map op0im002.
// 11/10/89 skott        keep pf24 flag for deleting picking
//                       recs.  s63, s93, 060.
// 11/13/89 craine       db2 chg's - renamed av1rec.xwhparnt to
//                       xwhcd and av1rec.xsncd to xsecd.
//                       removed xwhparnt from opsrec. opwrec &
//                       op0iw02, op0iw03, op1rec chg'd to have
//                       new fields. new fields are not used
//                       yet for op2rec chg's.
// 11/27/89 rdavis       #272. get need date from oparec
//                       for lost demand. sbm.
// 11/29/89 oricha       3265. allow cust bulks & cust draws
//                       to have coord groups & change at will.
//                       s70,s9a,050.
// 11/30/89 oricha       don't display availability for direct
//                       and indirect ships.  sga.
// 11/30/89 rcoron       allow price by size changes to smart
//                       bulk/draw orders as well as nil orders
//                       for in-development products.
// 12/05/89 scantr       added comp nbr logic to s20,s21,s22,
//                       s6a,s6e,s6h,s6n,s6o,s7c,s7h,s24,s9c,
//                       s9g,s97,w01,s61,020.
// 12/06/89 rdavis       #271. don't allow reporting of lost
//                       demand if in review mode and if item
//                       has been allocated. 050,060.
// 12/06/89 tfox         added code to zero price indevelopment
//                       products to s22
// 12/12/89 oricha       default backorder flag from customer
//                       fro rebook draws. s2b
// 12/14/89 dwalke       dont allow salesman orders to ovrde
//                       prices s61.
// 12/18/89 rcoron       modified op0is21 to force the whse cd
//                       of draws to default to the bulks' whse
//                       code regardless of warehouse - product
//                       restrictions.
// 01/08/90 cgrice       bug #222 - cancelled bulk draws were
//                       added to wrong suborder.  s2b
// 01/09/90 schase       added review mode check in edit need
//                       date - s78, before need date was set
//                       defined. for more info. see bug #280.
// 01/24/90 rcoron       Reactivated routines to allow product
//                       substitution. -- Added records osgrec,
//                       xsrrec, and oskrec to the record list.
//                       Modified op0iw01 to add a pf5-allowed-
//                       flag.  010, 060, sav, sa1, s20, ssp,
//                       s67, s6p, s6s, and s82.
// 02/16/90 oricha       add 'fill lost demand' to map and
//                       code. m001,s62,s7d,s70,s8f,s82,s87,
//                       050.
// 03/06/90 rcoron       moved xsacd from op3rec instead of
//                       opwrec when transfering to the substi-
//                       tion system. s67.
// 03/07/90 schase       bug #305 - allow price overrides on
//                       sales programs if division = '02'. s61
// 03/08/90 rcoron       remove the flag that keeps op0i from
//                       going to product substituion.
//                       Changed the checks on CAFROMAP for
//                       AV0K and AV0L.  Since product substi-
//                       tution can come back to order proces-
//                       sing from AV0K, AV0L, AV0R, or AV0Q,
//                       the test instead was changed to check-
//                       ing CAFRMSYS for just 'AV'. s20, 010,
//                       050 and 060.
//  3/14/90 BWATSO       Bug 308
//                       Modified to display the phone number
//                       from the store record on screen when
//                       when reporting lost demand.
//                       Areas affected: Added KUMREC, and SPH;
//                       changed M002, W01, SBM, and SEW.
// 03/15/90 rcoron       Added routines to restrict access to
//                       product substitution depending
//                       on the status of the customer in
//                       kucrec.kuccnssx. op0i060
// 03/23/90 rcoron       Modified s67 and 010 to always use the
//                       original product when control is pass-
//                       ed to the substitution system as the
//                       'source' product, rather than the
//                       'substitute' product when going to
//                       AV0L the second time around.
// 04/04/90 BWATSO       Data base changes.  Changed KUCCNSSX
//                       to KUCPSFL in 060, and changed
//                       OP1BLKCD to XBDCD in S10, SGA, SDZ,
//                       and S9A.
// 05/15/90 mgatre       Added order adjustment validation
//                       logic - ( #E220)
//                       new records: pazrec, pagrec
//                       new code:    soa
//                       changes:     050, 060, s78
// 05/30/90 BWATSO       Brand code changes - S6K.
// 06/14/90 mgatre       eliminated invoice only orders from
//                       order adjustment requirements - 050,
//                       s78
// 05/15/90 mgatre       Add order adjustment number override
//                       new record: fb9rec (IO3650)
//                       new code:    sob
//                       changes:     050, s78
// 09/24/90 tfox         Add code to 060 to bypass hot model
//                       edit for pf23. init pf23 flag in s20
// 11/06/90 skott        database changes - xsdcd to pc2inseg,
//                       xsacd to xegcd - 020, 050, s2b, s6k,
//                       sci, s62, sgi, sai, ssa, ssc, sg4,
//                       s70, s7e, s67,ssd, sdi, m001
// 12/12/90 craine       reformat of spec code and package
//                       code for display availability. s6k.
//                       log #460.
// 12/17/90 dflesh       added code for whse '51' in s7c.
//                       deleted commentsin sai, sci, sdi,
//                       ssc, ssd.  log #469.
// 12/29/90 jloyer       modified to process blank bulks...
//                       op0isga, s10, s70, 050
//                       blank bulks don't show availability
//                       and don't allow changes to need-date
//                       or xowcd
// 01/08/91 craine       fix to check availability when owner
//                       group changed on map. Also, changed to
//                       default '00' for warehouse '51'.Chg's
//                       sai, sg1, sg4, s6k, s7c, s81, 020, 030
//                       040.
// 02/13/91 jloyer       db changes: following changes...
//                       rename sy5rec.sy5prcfl to sy5rec.xqacd
//                       rename opirec.xsdcd to opirec.pc2inseg
//                       rename opirec.xsacd to opirec.xegcd
//                       move   op3rec.xqacd to opurec.xqacd
//                       chgd op0iw02 to reflect op2rec chgs
//                       chgd: s97, sci, sai, ssc, ssa, s8d.
// 02/13/91 jloyer       t-shirts blank bulk draw logic added.
//                       op0i010, 020, 040, 050, s10, s20, s24,
//                       s70, s78, Blank bulk draws require new
//                       need-date edits which are done by s7i,
//                       s7j and s7k.  Xowcd is also protected.
// 03/15/91 jloyer       use op1rec.xsocd instead of
//                       commarea.xsocd; swr, s67.
// 03/28/91 jloyer       Assure lost demand qtys are moved to
//                       the correct OPTREC size buckets. Also,
//                       corrected a bug which was moving blank
//                       style nbrs to OPTREC when a customer
//                       had their own style nbrs.  SEB, SWR.
// 04/03/91 tfox         menu services.m001,sai,sci,ssa,ssc,s2b
//                       s6d,s6e,s62,s70,020,050.
// 04/17/91 dmeier       log 604 - check draw by date for draws
//                       agains blank bulks only (not draws
//                       against finished bulks). s78.
// 05/20/91 dflesh       log 535 - expand price for all sizes
//                       field on map 1, code change in s53.
// 05/23/91 dflesh       log 645 change msg #547 to #687 -
//                       if pf6 and order is for slsmn, don't
//                       allow price chg.
// 06/10/91 bbake2       database changes - kucrec, op1rec,
//                       op2rec, op3rec, sp1rec, sycrec, xbdtbl
//                       op0iw02, op0iw03
//                       rename ylbcd to pwrlbcd - 020, s2b,
//                            s6e, sci, sai, ssc, ssa
// 06/17/91 craine       log #650 - chg OP0ISOD to check offer
//                       ing dates for nil futures orders.
//                       log # 651 - chg OP0ISDZ to NOTcheck
//                       offering dates if futures and sales
//                       program is 'EARL' and needdate 12/1/91
// 06/19/91  bbake2      screened products - changed sge, sg4
//                       s20, s6k, s62, s67, s7c, s7i, s7j,
//                       s7k, s70, s78, 020, 030, w01
//                       added sta, stb, stc, std, st0, st1,
//                       st2, st3, st4.  added xprtbl to appl
// 06/19/91  bbake2      screened products fixes to skip
//                       screened prod processing for draws
//                       from non-blank bulks - st1
//                       to value owner group in s2b for
//                       all draws
// 06/24/91  bbake2      and more screened products fixes,
//                       to allow blank styles to back up into
//                       previous season - sga
//                       to set error on quantities instead of
//                       need date when requested quantities
//                       are unavailable for blank style - s4b,
//                       s47
// 06/26/91  bbake2      st2: don't let prop orders w/styles
//                       fitting into xow pgms do 60-day
//                       calc for blank avail.
// 07/09/91  bbake2      log#664 - availability fixes
//                        s47 - correction to valueing of
//                         quantity on opprec in review mode to
//                         use net change over all converses
//                         instead of just the last one
//                        s20, s52, s7c, w01 - change to
//                         prevent overwriting of quantity
//                         fields on map when availability
//                         routines are called for
//                         changes to owner group, need date
//                         or warehouse.
// 07/09/91  bbake2      log#665 - 050, 060, s70, s7c, s40
//                         changed to protect owner group
//                         for all draw orders.  Also relocated
//                         set protect to preconverse.
// 07/19/91  oricha       ssa, ssc, sai.  don't allow t-shirts
//                        (whse 51) to pass xowcd to opirec
//                        picking pool. was messing up picking.
// 07/21/91  oricha       sci.  same as above.
// 07/25/91  ORICHA       prevent smart and flex bulks from
//                        getting into screened prod processing
//                        020,030.
// 07/26/91  ORICHA       open up need date to allow split
//                        orders for smart,flex & blank bulks.
//                        050.
// 10/08/91  dmeier       db changes - renamed opurec.xxxpgmno
//                        opurec.xxxpgmnb and populated
//                        opurec.xowcd (op0is8d)
//                        added xgp to xhdtbl for key, s73, 050
//                        , w01.
// 10/25/91  dmeier       log #695 - don't allow orders to be
//                        placed for draws against blank bulks
//                        for sizes that are valid for the
//                        blank but not the finished style
//                        (020, 030, 040).
// 12/09/91  JJOHN2       References to WPDT has been removed
//                        due to a change in availability that
//                        returns available quantities by need
//                        date with regard to the "lead time
//                        to screen". STC, ST3, ST2, SGA, SGE,
//                        SG4, S7C, S40, S47, S4B, S6K, W01.
// 12/19/91  jwils1       Modified availability routines to
//                        include checking the availability
//                        control table for the level indicator
//                        av4cntid.
//                        Also removed references to WPDT that
//                        were commented out in above change.
//                        STC, ST3, ST2, SGA, SGE,
//                        SG4, S7C, S40, S47, S4B, S6K, W01.
// 
//                        added code to bypass offering date
//                        edits for 09 (promo) or 03 (protek)
//                        warehouse in SDZ.
//  01/14/92  gwells      731 - iseg defaults for nil - s70,
//                              050,s7e(chg comment only)
//  01/28/92  trober      removed order adjustment number from
//                        the map.  instead of displaying the
//                        order adjustment number a warning
//                        message will be displayed.  deleted
//                        i/o mod io5140, pagrec, pazrec, and
//                        op0isoa.  changed statement groups
//                        s78, 050, and 060.
//  02/04/92  trober      added label codes to the map and
//                        related edits in op0i020, op0i050,
//                        op0is62, and op0is70.  Added new
//                        statement group op0is-edit-labl-cd.
//                        also, added record pwrrec to records
//                        table list for application.
//  02/07/92  jwils1      added custom logo prd processing.
//                        custom logo will always dispaly avail
//                        ability, and calculate an adj. need
//                        dt = -45 days. sga, sge, sg4, s7c,
//                        s49,s47,s4b,s6k,sg1,sgc, s40, s52,
//                        s53, s6c, and sg6.
//  02/24/92  jwils1      use 0 instead of op0iwsbd to access
//                        av4,5 &6rec - sg1,sg4,sgh,get-lev-ind
//  03/04/92  jwils1      use xprcd instead of wpdt when
//                        processing custom logo. - sge,sg4,s40
//                        s47,s4b,s6k.
//  03/12/92  trober      table changes, added i/o mod io04600
//                        call to dnilo.vdstrb01 for acct
//                        region code.  added statment group
//                        op0is9l (call to table above).
//  04/27/92  jhecke      changed one line of code because only
//                        one occurance of the label codes was
//                        being moved to the picking database.
//                        log #807. sci.
//  06/08/92  jhecke      database changes. 020,s79.
//  06/16/92  bbake2      log#813, change timing for adjusting
//                        original quantity fields from 30 to
//                        60 days.  W01, s32, s47, s6e
//  08/12/92  JLoyer      log#774: Add booking seasons logic to
//                        s10, s2b, s20, s62, s70, s78, 010,
//                        020, 030, 050, op0iw01, op0im001.
//                        new: op0is-call-ob1470, OBSREC,
//                             op0is-edit-bk-sesn,
//                             op0is-map-bk-sesn,
//                             op0is-updt-nil-sub/itm, OP6REC.
//  08/14/92  DHARRI      log#893: CUSTOM LOGO CHANGE CALC NEED
//                        DATE FROM TODAY -45 TO TODAY -30
//                        OP0IS-CALC-NEED-DT, SGA, SGE, SG4,
//                        S6K.
//  11/10/92  dcaust      log #850.  change in s22, s6a.  allow
//                        pricing for nil footwear sample in
//                        development.
//  11/13/92  dcaust      log #847. chg for nil b-grade pricing
//                        s97, s9i, s22, s24, 060, s79, w01.
//                        new stmt grp op0i-add-1-dollar.
//  11/30/92  tfox        log #888/920 new screened product
//                        processing.  s-av1750-xow, s-calc-
//                        need-dt, s-calc-xowcd, s-chk-flyer,
//                        s-chk-promo, sga, s6k, s7c, s7j,
//                        w01, 020, 030
//  12/10/92  dcaust      log #855.  if international order and
//                        order class = 'in', protect warehouse
//                        & owner grp codes on map.  060.
//  01/13/93  dcaust      log #934.  if international order and
//                        b-grade product, round product price
//                        up to the nickel  (after any discount
//                        s24, w01.
//  02/26/93  bbake2      log #868.  airborne edit s-airborne,
//                        s78, w01, voppgm01, xs0mw01, xs0ms-
//                        chk-airborne.
//  03/03/93  clenni      log #842.  allocation sales pgm edit
//                        s61
//  05/01/93  dlegg       log #937. NSG changes. Add whse 25 to
//                        some current whse 51 processing.
//                        Changes to custom logo processing.
//                        020, 030, 040, 050, op0is-calc-need-
//                        dt, sga, sg4, s70, s7c, s81,
//                        sci, sai, sge, s4b, s40, s47, s6k.
//  05/13/93  dcaust      log #964.  international airborne
//                        phase II. if international and
//                        order class = 'as', protect warehouse
//                        & owner grp codes on map.  060.
//  06/28/93  sjob        log #926:when no price is in effect,
//                        use oldest eff date for domest.(s28).
//                        Also,reset work date OPAWDT (s78);
//  07/06/93  sjob        log #977:expand eff-prc-dt-fl to
//                        include 'N'=need date (op0is6i)
//  07/12/93  gcalki      log #848 international divert orders
//                        protect warehouse & need date
//                        060, s78
//  09/10/93  schase      CSP 4.1 Change - Added check for
//                        valid size prior to formatting the
//                        price on OP3REC. Resolved SOC7 Abend.
//                        S24.
//  10/08/93  schase      CSP 4.1 Change - Added initialization
//                        of all numeric fields within the size
//                        run for non-active sizes only.
//                        Follows all DB1000 "Selects". s29,
//                        s91, sub, suc.
//  10/19/93  bbake2      CSP 4.1 another change to pricing
//                        to format price using size active
//                        flag from W03 record when moving
//                        prices from W03 rec.  this prevents
//                        zero pricing on draws when adding
//                        sizes in review mode.  s24
//  11/02/93  craine      Removed all reference to AV1REC and
//                        INCREC. INCREC replaced with IN2REC
//                        a long time ago. IN9REC, INZREC,
//                        IN2REC and OPSREC keys are built from
//                        same fields used to build AV5REC,
//                        instead of using AV1REC, INCREC or
//                        IN9REC. sai,sci,sdi,sga,sgc,sgd,ssa,
//                        ssc,ssd,s6e.
// 11//15/93  craine      Added move of current AV6REC key to
//                        key in OP0ISG4, before calling SGB.
// 11/22/93   gcalki      log#980 - perform screened product
//                        processing only for 1st quality,
//                        active life cycle. 020, s7c
// 12/13/93   CRAINE      Log #971 - changes to allow musical
//                        size runs for footwear.
// 03/01/94   schase      DATABASE CHGS (MARCH): Renamed
//                        SY6CSTFL to XQACD in s9i. Also resize
//                        op0iw-save-price-1, op0iw-save-price-
//                        2, op0iwclp, op0iwipc, op0iwnsn,
//                        op0iwphc, op0iwprc, op0iwprn,
//                        op0iwpro, op0iwpr1, op0iwpr2,
//                        op0iwstp, op0iw01, op0iw01g, op0iw02,
//                        and op0iw03. changed s9i and s97 to
//                        include currency and country codes
//                        when calling sy5rec and sy6rec.
// 04/01/94   gcalki      Log #1003 - Renamed causera to
//                        ca-user-workarea-4k so it can hold
//                        opwrec which is now 3072 bytes. (ALL)
//                        Changed oskrec.causera to oskrec.
//                        os-user-workarea-3k so it can pass
//                        the causera to xsrrec. (sav,s67)
//                        Changed the limit of the number of
//                        items allowed on an order from 200
//                        to 900. (020,s6e)
// 06/15/95   mmcgol      Changed to accomodate addition of
//                        Canada to system. Changed: op0is7c,
//                        op0is-call-ob1470, op0is73, op0is79,
//                        op0is9i, op0is94, op0is95, op0is97,
//                        op0i050, op0i020 and record op0iw01.
//                        added op0is-sel-sy2000.
//  03/14/96  DLIDDL      fixed handling code table lookup in
//                        OP0I050
//  06/24/96  MVALBU      Changed to use regional data for US
//                        apparel. Changed OP0IS94, OP0IS95,
//                        and OP0IS-SEL-SY2000.
//  07/31/96  MVALBU      Changed to add new nike initiated
//                        bulk and draw. Changed OP0ISDZ,
//                        OP0ISGA, OP0IS10, OP0IS7C, OP0I020,
//                        OP0I060, OP0IS2B, OP0IS21, OP0IS24,
//                        OP0IS29, OP0IS32, OP0IS47, OP0IS52,
//                        OP0IS6E, OP0IS70, OP0IS78, OP0IS93,
//                        OP0I030, OP0I040, OP0I050.
//                        Added OP0IS2C.
//  10/17/96  MVALBU      keep on displaying edit msg 901 until
//                        correction has been made. Changed
//                        op0i050, op0i060.
//  11/12/96  wleong      removed musical size run logic
//   1/23/96  SLARSE      Prevent the HNG code from being
//                        placed on order if style begins with
//                        a 5 or 6 or the silhouette code is
//                        14 or 19.
//  07/16/97  wleong      added new msr edits
//  08/27/97  jnaemu      added whse 27
//  09/04/97  jnaemu      allow direct ship for apparel to
//                        decrement availability.
//  09/08/97  wleong      regen for yostbl structure change
//  10/06/97  wleong      do not display availability if nil
//                        gpc '03' orders. op0isga.
//  10/23/97  wleong      include cu orders for msr edits.
//                        op0is40. regen to pick up opmzrec
//                        changes.
//  01/15/98  KLEE        dont edit intl orders for style
//  06/03/98  JFLOR1      bypassed call to SY2000 for div codes
//                        '02' and '03' in OP0IS95.
//  09/16/98  JFLOR1      modified OP0IS10 to move 'y' to
//                        OP0IW-BK-SESN-REQUIRED for apparel
//                        promo.
//  03/24/99  SCHAPY      modified OP0IS7C to fix Y2K bug
//  04/01/99  MGOEL       added Y2K century check to OP0IS67
//  11/02/99  BBAHUL      included the validation for special
//                        promo so that offer date validation
//                        is done if the YOSSCTYI is 'P'
//  03/29/00  JJOSEP      TT#4752-BSSA PROJECT
//                        BSSA product categories have changed
//                        from GPC 03 to GPC 02 and because of
//                        this in 'US' the handling code and
//                        Pack codes for some customers are
//                        not getting assigned correctly.
//                        Modified to assign the proper
//                        handling, Label code to BSSA
//                        products.
//                        Changed stgrp OP0I050
//                        Added stgrps
//                        OP0IS-CHK-IF-BSSA,OP0IS-EDT-BSSA-LBL
//                        OP0IS-EDT-BSSA-HND,
//                        OP0IS-MOV-BSSA-HND. Search for
//                        TT#4752 to find all changes.
//  04/09/00  rharat TT#4752-BSSA PROJECT
//                   Following are the new rules:
//                   Handling codes, charges, override flags
//                   for non-customer draw orders will first
//                   default from customer file. Handling codes
//                   thar are on bulk and not on customer wil
//                   be added to item along with with charges,
//                   override flags. Label codes and pack codes
//                   will always default from customer file.
//                   At last if it a bssa product, BSSA edits
//                   should be run to override the defaulted
//                   values with hardcoded values.
//                   Changed stgrp OP0I050,OP0I020,OP0IS2B
//                                 OP0IS2C, OP0IS6D.
//                   Added stgrps
//                   OP0IS-ADD-BLK-DFLT,OP0IS-BLANK-BS-HND
//                   OP0IS-ADD-BLK-HND.
//                   Search for TT#4752 to find changes.
//  05/18/00  rharat TT#4752-BSSA PROJECT - phase II
//                   Following are the new rules:
//                   1. Even though BSSA products are equipment
//                   GPC '02' products, apparel handling
//                   exceptions should be applied to these ords
//                   2. Business is going to set up GPC 03 rows
//                   for all the BSSA customers if they already
//                   don't exist.
//                   3. Business is OK that all the apparal ord
//                   will get these handling exceptions.
//                   ***** To comply with the new rules all the
//                   BSSA customer specific logic put in as
//                   part of Phase I is deleted ***************
//                   modified sgrps:
//                   OP0IS2B & OP0IS2C.
//                   Search for TT#4752 to find changes.
//  02/28/00  gsunda Modified application to list the
//  TT#10546         product sizes for all the users when Whse
//                   is changhed in OP0IM001 screen.
//                   Changes made in OP0IS64 statement group.
//  07/11/01  kshiva carton ratio edit for DS Orders. Changes
//  TT#12895         made to include Direct ship code to the
//                   passing record used to call the sub-pgm
//                   OP3850. Search for TT#12895 to find change
// *********************
Program OP0I type textUIProgram //VAGen Info - main text program
  {
  includeReferencedFunctions = yes, allowUnqualifiedItemReferences = yes, 
  throwNrfEofExceptions = yes, handleHardIOErrors = no, V60ExceptionCompatibility = yes, 
  I4GLItemsNullable = no, textLiteralDefaultIsString = no, localSQLScope = yes, 
  msgTablePrefix = "OP00", inputRecord = COMMAREA, segmented = no
  }

  // Data Declarations
  AV4REC AV4REC; // record
  AV5REC AV5REC; // record
  AV6REC AV6REC; // record
  AVGREC AVGREC; // record
  AVHREC AVHREC; // record
  AVIREC AVIREC; // record
  AVOREC AVOREC; // record
  COMMAREA COMMAREA ; // record
  ERRSQLCA ERRSQLCA; // record
  FB9REC FB9REC; // record
  IN2REC IN2REC; // record
  IN9REC IN9REC; // record
  INQREC INQREC; // record
  INZREC INZREC; // record
  IVEREC IVEREC; // record
  KUCREC KUCREC; // record
  KUFREC KUFREC; // record
  KUMREC KUMREC; // record
  KUYREC KUYREC; // record
  OBSREC OBSREC; // record
  OEBREC OEBREC; // record
  OECREC OECREC; // record
  OP0IW01 OP0IW01; // record
  OP0IW02 OP0IW02; // record
  OP0IW03 OP0IW03; // record
  OP0IW04 OP0IW04; // record
  OP0IW05 OP0IW05; // record
  OP1REC OP1REC; // record
  OP2REC OP2REC; // record
  OP3REC OP3REC; // record
  OP6REC OP6REC; // record
  OP8REC OP8REC; // record
  OPAREC OPAREC; // record
  OPBREC OPBREC; // record
  OPCREC OPCREC; // record
  OPIREC OPIREC; // record
  OPJREC OPJREC; // record
  OPLREC OPLREC; // record
  OPMZREC OPMZREC; // record
  OPNREC OPNREC; // record
  OPPREC OPPREC; // record
  OPSREC OPSREC; // record
  OPTREC OPTREC; // record
  OPUREC OPUREC; // record
  OPWREC OPWREC; // record
  OPYREC OPYREC; // record
  OPZREC OPZREC; // record
  OSBREC OSBREC; // record
  OSEREC OSEREC; // record
  OSGREC OSGREC; // record
  OSKREC OSKREC; // record
  PC2REC PC2REC; // record
  PK1REC PK1REC; // record
  PWRREC PWRREC; // record
  SP1REC SP1REC; // record
  SP2REC SP2REC; // record
  SP5REC SP5REC; // record
  SQLCA SQLCA; // record
  SY4REC SY4REC; // record
  SY5REC SY5REC; // record
  SY6REC SY6REC; // record
  SYCREC SYCREC; // record
  TA1REC TA1REC; // record
  TA2REC TA2REC; // record
  TAEREC TAEREC; // record
  VDSTRB01 VDSTRB01; // record
  VNILSY01 VNILSY01; // record
  VNLXPY01 VNLXPY01; // record
  VOPPGM01 VOPPGM01; // record
  WSY2000 WSY2000; // record
  XOWREC XOWREC; // record
  XS0MW01 XS0MW01; // record
  XSRREC XSRREC; // record
  XX0XW01 XX0XW01; // record
  YSMREC YSMREC; // record

  // VAGen Info - items needed for migration
  VAGen_EZESYS char(8);
  VAGen_EZEREPLY num(1);
  VAGen_EZE_WAIT_TIME bin(9,2);
  VAGen_EZE_ITEMLEN int;

  // Use Declarations
  use XAUTBL {deleteAfterUse = yes}; // table
  use XBDTBL {deleteAfterUse = yes}; // table
  use XCDTBL {deleteAfterUse = yes}; // table
  use XGPTBL {deleteAfterUse = yes}; // table
  use XHDTBL {deleteAfterUse = yes}; // table
  use XOBTBL {deleteAfterUse = yes}; // table
  use XOLTBL {deleteAfterUse = yes}; // table
  use XOTTBL {deleteAfterUse = yes}; // table
  use XOWTBL {deleteAfterUse = yes}; // table
  use XPRTBL {deleteAfterUse = yes}; // table
  use XSNTBL {deleteAfterUse = yes}; // table
  use XUMTBL {deleteAfterUse = yes}; // table
  use XWHTBL {deleteAfterUse = yes}; // table
  use XDSTBL {deleteAfterUse = yes}; // table
  use XSZTBL {deleteAfterUse = yes}; // table
  use XQATBL {deleteAfterUse = yes}; // table
  use YOSTBL {deleteAfterUse = yes}; // table
  use OP0IM.OP0IM001,  // forms
      OP0IM.OP0IM002
   {
    pfKeyEquate = no
  };

  function main()
    // VAGen Info - initialization needed for migration
    VAGen_EZESYS = VGLib.getVAGSysType();
    OP0I010: OP0I010();


        /* check add/review mode*/

    if (OP0IW01.OP0IWREJ == "Y") /* reject product, missing order typ,*/
      goto OP0I050; /* go setup & show message on map*/
    end


    if (OPWREC.OPWREVM == 7 /* if in product summary review mode*/
     || OPWREC.OP2LNINB > 0) /* or selected product during reg flow*/
      goto OP0I030; /* go to review old product*/
    else /* else*/
      goto OP0I020; /* go to add new product.*/
    end


     /* ******************************************************/
    OP0I020: OP0I020();



    if (OPWREC.OPWDUPSZ[OP0IWSBP] == "Y") /* dup.sizes*/
      goto OP0I040; /* ; then return to build prod line item*/
    else
      goto OP0I050; /* normal flow to build map*/
    end



     /* ********************************************************/
    OP0I030: OP0I030();



        /* go to initial map set-up, using op3rec*/

    goto OP0I050; /* set-up map data*/



     /* ***********************************************************/
    OP0I040: OP0I040();



        /* decide where to go*/

    if (OP0IW01.OP0IWREJ == "Y") /* if had db2 error*/
      goto OP0I050; /* show screen with error*/
    else
      goto OP0I020; /* go back to build product line data*/
    end



    OP0I050: OP0I050();



        /* go to converse the map*/

     /* OP0I060;    comment for speed & csp efficiency*/


     /* ***********************************************************/
    OP0I060: OP0I060();




    if (OP0IW01.OP0IWNXT == "Y" /* go to start next product*/
     || OP0IW01.OP0IWRST == "Y") /* or if need to restart product*/
      goto OP0I020;
    else
      goto OP0I060; /* go back to converse screen*/
    end




    OP0I070: OP0I070();
    OP0I080: OP0I080();
  end // end main
end // end OP0I

// ck sec,init w-s, prod add/rev?
Function OP0I010()


     /* **********************************************************/
     /* * first process in application -                        **/
     /* *                 - security check                      **/
     /* *                 - start w-s product array at entry #1 **/
     /* *                 - decide mode - new product or review **/
     /* *********************************************************/

  VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
  VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
  sysLib.commit();
  VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value

  set OP3REC empty;
  set PK1REC empty;
  set OPIREC empty; /* 7-23-87*/
  set OPPREC empty;
  set OP0IW01 empty;
  set OP0IW02 empty;
  set OP0IW03 empty;
  set KUCREC empty;
  set VNLXPY01 empty;
  set YSMREC empty;
  set IVEREC empty;
  set OSGREC empty;
  set AVGREC empty;
  set AVHREC empty;
  set AVIREC empty;
  set OECREC empty;
  set OBSREC empty;


      /* *************************/
      /* * check entry security*/
      /* *************************/



  XSENTRY();


   /* ****************************************************/
   /* *** set segmented trans id                      ****/
   /* ****************************************************/

  COMMAREA.CAEZSAP = sysVar.transactionID;
  COMMAREA.CAEZSG12 = "OP";
  COMMAREA.CAEZSG4 = "I";
  sysVar.transactionID = COMMAREA.CAEZSAP;

   /* *************************************************************/

      /* *******************************/
      /* * retrieve user common area*/
      /* *******************************/

      /* * if comming from substitution, commarea contents*/
      /* * is in osgrec format.  using this, reset opwrec*/
      /* * from xsrrec.*/


  if (COMMAREA.CAFRMSYS == "AV") /* product substitution*/

    OP0ISAV(); /* restore commarea from xsrrec*/

  end


  XSOPS01(); /* check order entry security*/
  OP1REC.OP1GROUP = OPWREC.OP1GROUP; /* hold order header data*/


      /* *****************************/
      /* * init error diag areas*/
      /* *****************************/

  TA1REC.TA1TYPE = "DB2 "; /* abend type*/
  TA1REC.TA1FUNC = "RETN"; /* abend function (return)*/
  TA1REC.TA1PGMNM = "OP0I"; /* program name*/
  TA1REC.TA1MAP = "OP0IM001"; /* current map name*/
  TA1REC.TA1LOCAT[1] = "OP0I010 "; /* process name*/


      /* ********************************/
      /* * initialize working-storage*/
      /* ********************************/

  OP0IS10(); /* init oparec,opwrec,op0iws*/
               /* ; get order type table xottbl*/
               /* ; get sales program order type table sp2rec*/


  if (COMMAREA.CAFRMSYS == "AV")
    OP0IW01.OP0IWSBP = OSGREC.OSGPRSUB; /* saved product subscript*/
    OP0IM001.XWHCD = OSGREC.XWHCD; /* set up warehouse*/
    OPAREC.OPAWDT = OSGREC.OP1CUNDT; /* set up need date*/

    OP0IS27(); /* put whse/need-date in suborder array*/

    if (OPWREC.SY1STNBR[OP0IWSBP] == OSGREC.SY1STNBR
     && OPWREC.SY2CLRID[OP0IWSBP] == OSGREC.SY2CLRID
     && OPWREC.XDMCD[OP0IWSBP] == OSGREC.XDMCD)
        /* ***********************************************************/
        /* ** current product is the same as the original source*/
        /* ** product.  this means that the currently held product*/
        /* ** had not been replaced by the substitution system.*/
        /* ***********************************************************/
      if (OSGREC.OP2SSTYN == " " /* no substitute product*/
       && OSGREC.OP2SCLCD == " " /* returned by the substitution*/
       && OSGREC.OP2SDMCD == " ") /* system*/
        OPWREC.OPWDUPSZ[OP0IWSBP] = "N";
        OP0IW01.OP2PRDSF = "N";
        converseLib.validationFailed(195);
                                   /* note - NO substitute product selected*/

      else
        if (OSGREC.OP2SSTYN == OSGREC.SY1STNBR /* the original source*/
         && OSGREC.OP2SCLCD == OSGREC.SY2CLRID /* product was selected*/
         && OSGREC.OP2SDMCD == OSGREC.XDMCD)   /* by the subs. system*/
          OPWREC.OPWDUPSZ[OP0IWSBP] = "N";
          OP0IW01.OP2PRDSF = "N";
          converseLib.validationFailed(195);
                                   /* note - NO substitute product selected*/

        else /* there is a product substitute*/
          OP0IW01.OP2PRDSF = "Y"; /* product substitution flag*/
          OP0IW01.OP2SSTYN = OSGREC.SY1STNBR;
          OP0IW01.OP2SCLCD = OSGREC.SY2CLRID;
          OP0IW01.OP2SDMCD = OSGREC.XDMCD;
          OPWREC.SY1STNBR[OP0IWSBP] = OSGREC.OP2SSTYN;
          OPWREC.SY2CLRID[OP0IWSBP] = OSGREC.OP2SCLCD;
          OPWREC.XDMCD[OP0IWSBP] = OSGREC.OP2SDMCD;
          OPWREC.OPWRQSZF[OP0IWSBP] = 0; /* to def sizes by style*/
          OPWREC.OPWDUPSZ[OP0IWSBP] = "N";
          converseLib.validationFailed(196); /* note - This is the substitute prod*/
                                   /* selected*/
          OP0ISA1(); /* set-up unit of measure and size run*/

        end
      end

    else
        /* ***********************************************************/
        /* ** current product is not the same as the original source*/
        /* ** product.  this means that the currently held product*/
        /* ** had been replaced by the substitution system.*/
        /* ***********************************************************/
      if (OSGREC.OP2SSTYN == " " /* no substitute product*/
       && OSGREC.OP2SCLCD == " " /* returned by the substitution*/
       && OSGREC.OP2SDMCD == " ") /* system*/
        OP0IW01.OP2PRDSF = "Y"; /* product substitution flag*/
        OP0IW01.OP2SSTYN = OSGREC.SY1STNBR;
        OP0IW01.OP2SCLCD = OSGREC.SY2CLRID;
        OP0IW01.OP2SDMCD = OSGREC.XDMCD;
        OPWREC.OPWRQSZF[OP0IWSBP] = 0; /* to def sizes by style*/
        OPWREC.OPWDUPSZ[OP0IWSBP] = "N";
        converseLib.validationFailed(196); /* note - This is the substitute prod selected*/
        OP0ISA1(); /* set-up unit of measure and size run*/

      else
        if (OSGREC.OP2SSTYN == OSGREC.SY1STNBR /* the original source*/
         && OSGREC.OP2SCLCD == OSGREC.SY2CLRID /* product was selected*/
         && OSGREC.OP2SDMCD == OSGREC.XDMCD)   /* by the subs. system*/
          OP0IW01.OP2PRDSF = "N"; /* product substitution flag*/
          OP0IW01.OP2SSTYN = " ";
          OP0IW01.OP2SCLCD = " ";
          OP0IW01.OP2SDMCD = " ";
          OPWREC.SY1STNBR[OP0IWSBP] = OSGREC.OP2SSTYN;
          OPWREC.SY2CLRID[OP0IWSBP] = OSGREC.OP2SCLCD;
          OPWREC.XDMCD[OP0IWSBP] = OSGREC.OP2SDMCD;
          OPWREC.OPWRQSZF[OP0IWSBP] = 0; /* to def sizes by style*/
          OPWREC.OPWDUPSZ[OP0IWSBP] = "N";
          converseLib.validationFailed(195);
                                   /* note - NO substitute product selected*/
          OP0ISA1(); /* set-up unit of measure and size run*/

        else /* there is a product substitute*/
          OP0IW01.OP2PRDSF = "Y"; /* product substitution flag*/
          OP0IW01.OP2SSTYN = OSGREC.SY1STNBR;
          OP0IW01.OP2SCLCD = OSGREC.SY2CLRID;
          OP0IW01.OP2SDMCD = OSGREC.XDMCD;
          OPWREC.SY1STNBR[OP0IWSBP] = OSGREC.OP2SSTYN;
          OPWREC.SY2CLRID[OP0IWSBP] = OSGREC.OP2SCLCD;
          OPWREC.XDMCD[OP0IWSBP] = OSGREC.OP2SDMCD;
          OPWREC.OPWRQSZF[OP0IWSBP] = 0; /* to def sizes by style*/
          OPWREC.OPWDUPSZ[OP0IWSBP] = "N";
          converseLib.validationFailed(196); /* note - This is the substitute prod*/
                                   /* selected*/
          OP0ISA1(); /* set-up unit of measure and size run*/

        end
      end
    end
  else
    OP0IW01.OP2PRDSF = "N"; /* product substitution flag*/
  end



  OP0ISDS(); /* edit direct ship to see if warehouse is required*/



end // end OP0I010

// add product (INIT. DEFAULTS)
Function OP0I020()


      /* *********************************************************/
      /* * create new product record                            **/
      /* * consisting of product line item and 40 sizes.        **/
      /* * use hard-coded defaults,                             **/
      /* * and product array (from product header screen)       **/
      /* * and data from order header (op1rec)                  **/
      /* * and data from prod style, color, dim & size (sycrec) **/
      /* * and data from sales program (sp5rec)                 **/
      /* *********************************************************/


  TA1REC.TA1LOCAT[1] = "OP0I020"; /* error diag -process name*/
  TA1REC.TA1LOCAT[2] = " "; /* - group name*/


      /* **************************************************/
      /* * re-set flags for next product to be created*/
      /* **************************************************/

  if (OPWREC.OPWDUPSZ[OP0IWSBP] == "D") /* if dup done*/
    /* next sentence               (already init w-s)*/
  else
    OP0IS20(); /* init. work-storage,*/
  end /* get spgm prod pricing,if any*/


      /* ********************************************************/
      /* * check if sizes are to be duplicated from prev. product*/
      /* ********************************************************/

      /* dupsz values are n - dont dup*/
                       /* y - duplicate sizes from prev prod,all*/
                           /* sizes(&scale)must be good 4 new prd*/
                       /* d - done with duplicating sizes*/
                           /* now build rest of product line item*/

  if (OPWREC.OPWDUPSZ[OP0IWSBP] == "Y") /* go to duplicate sizes*/
    exit stack;
  end

  if (converseVar.validationMsgNum == 0) /* dup prod has its own messg,*/
    if (OP0IW01.OP0IWSBP > 1) /* let user know changing prod*/
      converseLib.validationFailed(184); /* next prod in array*/
      OPAREC.OPAERR = "Y";
    end
  end


      /* *********************************************************/
      /* * start at top of record and create each field until end*/
      /* *********************************************************/


      /* ******************/
      /* * product code*/
      /* ******************/

  OP3REC.XGPCD = OP1REC.XGPCD;
  OP3REC.SY1STNBR = OPWREC.SY1STNBR[OP0IWSBP];
  OP3REC.SY2CLRID = OPWREC.SY2CLRID[OP0IWSBP];
  OP3REC.XDMCD = OPWREC.XDMCD[OP0IWSBP];
  OP3REC.KUIPRDID = OPWREC.KUIPRDID[OP0IWSBP];
  OP3REC.PC2INSEG = OPWREC.PC2INSEG[OP0IWSBP];

   /* added with Canadian changes*/
  OP3REC.XDZ-DATA-DIST-CD = OP1REC.XDZ-DATA-DIST-CD;


      /* *********************************************************/
      /* * move key of partition number & customer order number*/
      /* *********************************************************/

  OP3REC.OP1PARTN = OP1REC.OP1PARTN;
  OP3REC.OP1CUOID = OP1REC.OP1CUOID;


      /* move nike sub-order number to record key before write*/

      /* move product line item number to record key before write*/

  sysVar.arrayIndex = OPWREC.OPWLSTLI; /* verify product line item # lt 901*/
  sysVar.arrayIndex = sysVar.arrayIndex + 1; /* max prodts per customer order = 900*/
  if (sysVar.arrayIndex > 900) /* the real line item # is made just*/
    converseLib.validationFailed(188); /* just before the write record.*/
    OPAREC.OPAERR = "Y";
    OP0IW01.OP0IWREJ = "Y";
    exit stack;
  end


      /* *************************************/
      /* * move general product descriptors*/
      /* *************************************/

      /* note - unit of measure done below, with backorder*/

  OP3REC.OP2PRDSF = "N"; /* product substitution = n*/
  OP3REC.OP2KSTYF = "N";
  OP3REC.OP2GTSZF = "N"; /* gut sizes not required*/

  OP3REC.XPGCD = OPWREC.XPGCD[OP0IWSBP]; /* packaging type code*/
      /* phase 2 - package type will default from inventory*/
       /* and opwrec will be the user entered override value.*/

  OP3REC.OP2MSCDP = 000.00; /* maximum scaledown percent*/
  OP3REC.XEGCD = "000"; /* shade code*/
  OP3REC.OP2GBLOF = "N"; /* global override flag*/
  OP3REC.OP2PGRPF = "N"; /* process group flag*/
  OP3REC.OP2PRCOF = "N"; /* price override flag*/
  OP3REC.OP2FSTFL = "Y"; /* forecast flag*/
  OP3REC.OP2PRDSF = "N"; /* prd subst flag*/
  OP3REC.OP2SSTYN = " "; /* subst style num*/
  OP3REC.OP2SCLCD = " "; /* subst color code*/
  OP3REC.OP2SDMCD = " "; /* subst dim*/
  OP3REC.OP2CGPCD = " "; /* co-or grp*/
  OP3REC.XAFCD = " "; /* allocation force code*/
  OP3REC.OP2SUBQT = 0; /* subst qty*/
  OP3REC.OP1ALFDT = 0; /* allocation force date*/

  OP3REC.XQACD = OPWREC.XQACD[OP0IWSBP]; /* quality code*/

  OP3REC.OP2LNIST = "OP"; /* line item status = open*/

  OP3REC.OP2LNSDT = OPAREC.OPACDT; /* status date=current*/

  if (OP0IW01.OP2PRDSF == "Y")
    OP3REC.OP2PRDSF = OP0IW01.OP2PRDSF;
    OP3REC.OP2SSTYN = OP0IW01.OP2SSTYN;
    OP3REC.OP2SCLCD = OP0IW01.OP2SCLCD;
    if (OP0IW01.OP2SDMCD == "  ")
      OP0IW01.OP2SDMCD = "00";
    end
    OP3REC.OP2SDMCD = OP0IW01.OP2SDMCD;
    OP3REC.OP2SUBQT = OPWREC.OP2TONOQ[OP0IWSBP];
  end



      /* *********************************************************/
      /* * set up backorder flag*/
      /* * get product data into sycrec*/
      /* * style desc, color desc, prcng by sz fl, sz scl cd*/
      /* *********************************************************/

  OP3REC.OP1BOFL = OP1REC.OP1BOFL; /* backorder allowed flag*/

    /* bssa changes * begin * TT#4752 * * moved later ************/
   /* label codes are item specific*/

   /* MOVE OPWREC.PWRLBCD(1) TO OP3REC.PWRLBCD(1);/* labl cd*/
   /* MOVE OPWREC.PWRLBCD(2) TO OP3REC.PWRLBCD(2);/* labl cd*/
    /* bssa changes *  end  * TT#4752 * * moved later ************/

      /* if have sycrec from dup.size routine, skip get*/

  if (OPWREC.OPWDUPSZ[OP0IWSBP] == "D") /* done with dup sizes*/
    /* next sentence*/
  else
    OP0IS94(); /* get db2 for style data in sycrec*/
    OP0IW01.OP0IWPSC = SYCREC.SY4SZSCL; /* hold as prev prod size scale*/
    OP0IW01.OP0IWPUM = SYCREC.XUMCD; /* hold prev unit of measure*/
  end


  if (SYCREC.SY2BOSWI == "N" /* if product has backorder switch*/
   && SYCREC.SY2BOEDT <= OPAREC.OPACDT) /* effective today*/
    OP3REC.OP1BOFL = SYCREC.SY2BOSWI; /* use it*/
  end


      /* *************************************************/
      /* * unit of measure from screen, or style file*/
      /* * for draw orders, xumcd is defaulted from bulk*/
      /* *************************************************/


  if (OP0IW01.OP0IWBDF == "DC" /* if cust draw order*/
   || OP0IW01.OP0IWBDF == "DN" /* nike draw order*/
   || OP0IW01.OP0IWBDF == "DR" /* rebook draw order*/
   || OP0IW01.OP0IWBDF == "DS" /* smart draw order*/
   || OP0IW01.OP0IWBDF == "DX") /* flexible draw order*/
     /* next sentence  -- will catch after bulk read*/
  else
    if (OPWREC.XUMCD[OP0IWSBP] == " " /* default uom from product*/
     || OPWREC.XUMCD[OP0IWSBP] == SYCREC.XUMCD)
      OP3REC.XUMCD = SYCREC.XUMCD;
    else /* user override uom*/
      OP3REC.XUMCD = OPWREC.XUMCD[OP0IWSBP];
    end
  end



     /* note - set override flag for use in calculating price*/
     /* per unit.  need to carry price per uom, so when it*/
     /* changes, we need to change prices.*/


      /* **********************************/
      /* * move package handling data*/
      /* **********************************/

   /* bssa changes * begin * TT#4752 * following are the new rules **/
   /* handling codes, charges, override flags for non DC will first**/
   /* default from customer file. For draw orders handling codes on**/
   /* bulk and not on the customer will be added to item along will**/
   /* handling charges, override flag. Label codes and pack codes  **/
   /* will always default from customer for non Custmer draws.     **/
   /* After defaulting values BSSA hardcode logic will be applied. **/
   /* Changes will be made in Airspeed and maint to get all systems**/
   /* in sync.                                                     **/
   /* check for BSSA products by calling the IO Mod IO2640*/
   /* (DCORP.VSUMCD01)*/

  OP0IW01.OP0IW-SYST-HNDCHG-OVRD = "N"; /* initialize values*/
  OP0IW01.OP0IW-USER-HNDCHG-OVRD = "N"; /* initialize values*/

  OP0IS-CHK-IF-BSSA(); /* check for BSSA products*/

  if (OP0IW01.OP0IW-BSSA-PRODUCT == "Y") /* if BSSA product*/
    OP0IS2C(); /**/
  end
    /* bssa changes *  end  * TT#4752 * **************************/

  if (OP0IW01.OP0IWBDF == "DC" /* cust draw*/
   || OP0IW01.OP0IWBDF == "DN" /* nike draw*/
   || OP0IW01.OP0IWBDF == "DR" /* rebook draw*/
   || OP0IW01.OP0IWBDF == "DS" /* smart draw*/
   || OP0IW01.OP0IWBDF == "DX") /* flexible draw*/
         /* next sentence*/
  else
    if (OP0IW01.OP0IW-BSSA-PRODUCT == "Y") /* if BSSA product*/
      /* moved hndl codes in OP0IS2C*/
    else /* not Bssa product*/
      sysVar.arrayIndex = 1;
      while (sysVar.arrayIndex < 6) /* set to values from order header*/
        OP3REC.XHDCD[sysVar.arrayIndex] = OPWREC.XHDCD[sysVar.arrayIndex];
        OP3REC.XHDCHG[sysVar.arrayIndex] = OPWREC.XHDCHG[sysVar.arrayIndex];
        OP3REC.OP2HCHGO[sysVar.arrayIndex] = OPWREC.OP2HCHGO[sysVar.arrayIndex];
        sysVar.arrayIndex = sysVar.arrayIndex + 1;
      end
    end
  end

  if (OP0IW01.OP0IWBDF == "DC" /* cust draw*/
   || OP0IW01.OP0IWBDF == "DN" /* nike draw*/
   || OP0IW01.OP0IWBDF == "DR" /* rebook draw*/
   || OP0IW01.OP0IWBDF == "DS" /* smart draw*/
   || OP0IW01.OP0IWBDF == "DX") /* flexible draw*/
         /* next sentence*/
  else
    if (OP0IW01.OP0IW-BSSA-PRODUCT == "Y") /* if BSSA product*/
      /* moved hndl codes in OP0IS2C*/
    else /* not Bssa product*/
      sysVar.arrayIndex = 1;
      while (sysVar.arrayIndex < 3) /* set to values from order header*/
        OP3REC.PWRLBCD[sysVar.arrayIndex] = OPWREC.PWRLBCD[sysVar.arrayIndex];
        sysVar.arrayIndex = sysVar.arrayIndex + 1;
      end
    end
  end

      /* ********************************/
      /* * clear maintenance fields*/
      /* ********************************/

  sysVar.arrayIndex = 1; /* start at 1, go through 4*/
  while (sysVar.arrayIndex < 5)
    OP3REC.XOMCD[sysVar.arrayIndex] = " "; /* order maint reason code*/
    OP3REC.OP2OMQTY[sysVar.arrayIndex] = 0; /* quantity changed*/
    OP3REC.OP2OMDT[sysVar.arrayIndex] = 0; /* date changed*/
    OP3REC.OP1MTREP[sysVar.arrayIndex] = 0;
                                   /* service rep who did the change*/
    sysVar.arrayIndex = sysVar.arrayIndex + 1;
  end


      /* *********************/
      /* * pricing flags*/
      /* *********************/

  if (OPWREC.OPWDUPSZ[OP0IWSBP] != "D") /* already set in p40 duplicate*/
    OP3REC.OP2PRCOF = "N"; /* price override on any size*/
    OP3REC.OP2PRCVF = "N"; /* price vary flag*/
  end


      /* *********************************************************/
      /* * 08/12/92 Jloyer: add booking seasons to new product  **/
      /* *********************************************************/

  OP3REC.XBK-BK-SESN-CD = "  "; /* init xbk-bk-sesn-cd to spaces*/
  OP3REC.OP-BK-YR = 0; /* init op-bk-yr to zeroes*/
  OP3REC.OP-BK-MO = 0; /* init op-bk-mo to zeroes*/

  if (OP0IW01.OP0IW-BK-SESN-REQUIRED == "Y") /* if booking seasons required*/
    if (OP0IW01.OP0IW-DEFAULT-BK-SESN == "Y") /* if default bk-sesn*/
      if (OP1REC.XDVCD == "01") /* if domestic*/
        OP0IW01.OP0IW-OB1470-OP1CUNDT = OPWREC.OP1CUNDT[OP0IWSBS];
        OP0IS-CALL-OB1470(); /* call ob1470*/
        if (OBSREC.OBS-RETN-CD == "00" /* if single bkg-sesn*/
         || OBSREC.OBS-RETN-CD == "01") /* or multiple bkg-sesns*/
          OP3REC.OP-BK-MO = OBSREC.OP-BK-MO[1]; /* set bk-month*/
        end /* (bk-mo does not*/
      end /* default)*/
    else /* else not defaulting bk-sesn*/
      OP0IW01.OP0IW-OB1470-OP1CUNDT = OPWREC.OP1CUNDT[OP0IWSBS];
      OP0IS-CALL-OB1470(); /* call ob1470*/
      if (OBSREC.OBS-RETN-CD == "00") /* if single bkg-sesn*/
        OP3REC.XBK-BK-SESN-CD = OBSREC.XBK-BK-SESN-CD[1]; /* use 1st*/
        OP3REC.OP-BK-YR = OBSREC.OP-BK-YR[1]; /* occurance*/
        if (OP1REC.XDVCD == "01") /* only dom*/
          OP3REC.OP-BK-MO = OBSREC.OP-BK-MO[1]; /* uses*/
        end /* bk-mo*/
      else
        if (OBSREC.OBS-RETN-CD == "01") /* if multi-bk-sesns*/
          OP3REC.XBK-BK-SESN-CD = OBSREC.XBK-BK-SESN-CD[2]; /* use*/
          OP3REC.OP-BK-YR = OBSREC.OP-BK-YR[2]; /* 2nd occur*/
          if (OP1REC.XDVCD == "01") /* only dom*/
            OP3REC.OP-BK-MO = OBSREC.OP-BK-MO[2]; /* uses*/
          end /* bk-mo*/
          OP0IW01.OP0IW-MULTI-BK-SESN-MSG = "Y"; /* set multi-msg fl*/
        end
      end
    end
  end

  if (OP0IW01.OP0IWREJ == "Y") /* if a problem occurred in bk-sesns*/
    exit stack; /* go to end of flow*/
  end

      /* *********************************************************/
      /* * next fields are summaries, created in the formatter*/
      /* * program.  they are all in the line item record.*/
      /* * the cobol program takes op3rec and writes the*/
      /* * product line item record and the size record(s)*/
      /* *********************************************************/

      /* op3rec.op2prcvf  price vary flag*/
            /* .op2torgq  total original quantity*/
            /* .op2tondq    "   on-order    "*/
            /* .op2talcq    "   allocated   "*/
            /* .op2tohrq    "   on-hand reserved quantity*/
            /* .op2twipq    "   work-in-process reserved quantity*/
            /* .op2tshpq    "   shipped     "*/
            /* .op2tcnlq    "   cancelled   "*/
            /* .op2auprc  average unit price*/
            /* .op2lnivl  line item value*/
            /* .op2nsize  number of sizes on product*/
            /* .zzzszchg  size change count*/
      /* note -setup date & time put into record*/
            /* before writing.*/

      /* change count = 0 for add record*/

  OP3REC.ZZZCHGCT = 0;


      /* ***********************************************/
      /* initialize 40 sizes and associated fields*/
      /* ***********************************************/

      /* edit for 1 warehouse model*/
      /* let promo get around 1 whs model check.*/



   /* skip 1-whs edit for draws. don't want to redirect whs from*/
   /* bulk warehouse. -- jdv 9/10/87*/

  if (OP0IW01.OP0IWBDF == "DC" /* if cust draw*/
   || OP0IW01.OP0IWBDF == "DN" /* or nike draw*/
   || OP0IW01.OP0IWBDF == "DR" /* or rebook draw*/
   || OP0IW01.OP0IWBDF == "DS" /* or smart draw*/
   || OP0IW01.OP0IWBDF == "DX") /* or flexible draw*/
     /* next sentence*/
  else
    if (OPWREC.XWHCD[OP0IWSBS] in XWHTBL.XWHCD)
      if (XWHTBL.XDVCD1[sysVar.arrayIndex] == "03") /* if promo division*/
        OPWREC.OP1OWHMF[OP0IWSBS] = "N"; /* set flag*/
      else
        OP0IS21(); /* send msg if change warehouse*/
      end
    else
      OP0IS21(); /* check anyway*/
    end
  end


      /* if warehouse change, may recalculate price type codes*/

  if (OP0IW01.OP0IWNWH == "Y" /* if warehouse changed by s21*/
   && OP1REC.XDVCD == "02"    /* and a nil order*/
   && OP1REC.XOBCD == "S1")   /* and a sample order type*/
    if (OP0IW01.XAUCD == "31" /* and customer's account class*/
     || OP0IW01.XAUCD == "32") /* is nike owned or export co.*/
      if (OP0IM001.XWHCD == "12") /* if new warehouse is 12, nil whse*/
        OP0IS6O(); /* get prc type cd based on co.*/
      else /* else (xwhcd now entered but not 12)*/
        OP0IS6N(); /* get price typ cd based on comp nbr*/
      end
      if (OPWREC.OPWDUPSZ[OP0IWSBP] == "D") /* if dup sizing already done*/
        OP0IS7H(); /* redo pricing (else done later)*/
      end
    end
  end

    /* set up map owner group code*/

  if (OP0IW01.OP0IWBBD == "B" /* if blank bulk draw order*/
   || OP0IW01.OP0IWBBD == "F") /* or draw from blank bulk*/
    if (OP1REC.XOBCD == "M1") /* the owner group code of*/
      OP3REC.XOWCD = "SM"; /* the blank bulk is always*/
    else /* used for the item records*/
      OP3REC.XOWCD = "MR"; /* (op3rec).  Any value passed*/
    end /* by op0h is ignored.*/
    OP0IM001.XOWCD = OP3REC.XOWCD;
  else
    if (OP0IW01.OP0IWBDF == "DC" /* if draw, use bulk xowcd*/
     || OP0IW01.OP0IWBDF == "DN" 
     || OP0IW01.OP0IWBDF == "DR" 
     || OP0IW01.OP0IWBDF == "DS" 
     || OP0IW01.OP0IWBDF == "DX")
      OP0IM001.XOWCD = OP3REC.XOWCD;
    else
      OP3REC.XOWCD = OPWREC.XOWCD;
      if (OPWREC.XOWCD == "00"
       || OPWREC.XOWCD == "  ")
        if (OP0IM001.XWHCD == "51"
         || OP0IM001.XWHCD == "03"
         || OP0IM001.XWHCD == "25"
         || OP0IM001.XWHCD == "27")
          OP0IM001.XOWCD = "00";
        else
          OP0IM001.XOWCD = " ";
        end
      else
        OP0IM001.XOWCD = OPWREC.XOWCD;
      end
    end
  end


   /* the following is special set up for screen products*/

  if (OP1REC.XWHCD == "51" /* WAREHOUSE 51 or*/
   || OP1REC.XWHCD == "25" /* Warehouse 25 (NSG)*/
   || OP1REC.XWHCD == "27") /* Warehouse 25 (NSG)*/
    if (SYCREC.SY1BSTNB > " " /* There is a blank style*/
     && SYCREC.XPRCD != "22") /* and not a custom logo product*/
      if (OP1REC.XBDCD == "0" /* REG ORDER*/
       || OP1REC.XBDCD == "1" /* CUSTOMER BULK*/
       || OP1REC.XBDCD == "N") /* nike BULK*/
        OP0IS-CHK-FLYER(); /* CHECK IF FLYER PROGRAM*/
        if (SQLCA.VAGen_SQLCODE == 0 /* THIS IS SCRND PROD & FLYER PGM*/
         || SQLCA.VAGen_SQLCODE == -811) /* MORE THAN 1 ROW FOUND*/
          OP0IS-PROCES-FLYR();
        end
      end
    end
  end

  if (OP0IW01.OP0IWBBD == "B")
    OP0IST0();
  end

      /* if sizes duplicated from prev.prod, skip rest*/

  if (OPWREC.OPWDUPSZ[OP0IWSBP] == "D") /* dupli.size done?*/
    if (OP0IW01.OP0IWBDF == "DC" /* if cust draw*/
     || OP0IW01.OP0IWBDF == "DN" /* or nike draw*/
     || OP0IW01.OP0IWBDF == "DR" /* or rebook draw*/
     || OP0IW01.OP0IWBDF == "DS" /* or smart draw*/
     || OP0IW01.OP0IWBDF == "DX") /* or flexible draw*/
      OP0IS2B(); /* default fields from bulk*/
    end
    exit stack;
  end



  OP3REC.OP2TONOQ = 0; /* zero qty for prod verify*/
      /* also done in p30 for review*/
      /* and in p40 for duplication*/


      /* don't need product prices if have sales pgm prices*/
      /* get style and style/color price defaults to use*/
      /* when there is no price by size for the product*/

   /* IF OP0IW01.OP0IWSPP = 'N'       ; if no sales pgm prices*/
  OP0IS22(); /* db2 read product tables*/
   /* END ;*/


  if (OP0IW01.OP0IWBDF == "DC" /* cust draw*/
   || OP0IW01.OP0IWBDF == "DN" /* nike draw*/
   || OP0IW01.OP0IWBDF == "DR" /* rebook draw*/
   || OP0IW01.OP0IWBDF == "DS" /* smart draw*/
   || OP0IW01.OP0IWBDF == "DX") /* flexible draw*/
    OPAREC.OPAORDN = OP1REC.OP1BLKID;
    OP0IW02.OP1PARTN = OPAREC.OP1PARTN;
    OP0IW02.OP1CUOID = OP1REC.OP1BLKID;
    OP0IW02.OP2LNINB = OPWREC.OPWBKLIN[OP0IWSBP];
    OP0IW02.OP1NORID = OPWREC.OP1NORID[OP0IWSBP];
    OP0IS29(); /* read bulk order item record*/
    OP0IS2B(); /* set up draw default fields*/
  end

   /* begin slarse*/
  if (OP1REC.KUCCOID == 2000215) /* Nike Retail*/
    OP0IS2D(); /* check on hang codes*/
  end
   /* end slarse*/

  if (OP0IW01.OP0IWBDF == "DC" /* cust draw*/
   && OP0IW01.OP0IWBBD == "B") /* draw from a blank bulk*/
    OP0IW01.OP0IWSBR = 1; /* for all 40 sizes*/
    while (OP0IW01.OP0IWSBR < 41)
      OP3REC.OP3SZARY[OP0IWSBR] = OP0IW01.OP3SZARY;
      if (OP0IW03.OP3SZAFL[OP0IWSBR] == "Y")
        OP0IW01.OP0IWVSZ = "N";

        OP0IS23(); /* validate size*/

        if (OP0IW01.OP0IWVSZ == "Y")
          OP3REC.OP3SZAFL[OP0IWSBR] = "Y";
          OP0IS24(); /* set size price*/
          OP0IS25(); /* chk price variance*/
          OP0IS26(); /* chk-set full range min/max*/
        end
      end

      OP0IW01.OP0IWSBR = OP0IW01.OP0IWSBR + 1;
    end
  end


  if (OP0IW01.OP0IWBDF == "DC" /* cust draw*/
   || OP0IW01.OP0IWBDF == "DN" /* nike draw*/
   || OP0IW01.OP0IWBDF == "DR" /* rebook draw*/
   || OP0IW01.OP0IWBDF == "DS" /* smart draw*/
   || OP0IW01.OP0IWBDF == "DX") /* flexible draw*/
    if (OP0IW01.OP0IWBBD != "B") /* not a draw from a blank bulk*/
      OP0IW01.OP0IWSBR = 1; /* for all 40 sizes*/
      while (OP0IW01.OP0IWSBR < 41)
        OP3REC.OP3SZARY[OP0IWSBR] = OP0IW01.OP3SZARY;
        if (OP0IW03.OP3SZAFL[OP0IWSBR] == "Y")
          OP3REC.OP3SZAFL[OP0IWSBR] = "Y";
          OP0IS24(); /* set size price*/
          OP0IS25(); /* chk price variance*/
          OP0IS26(); /* chk-set full range min/max*/
        end

        OP0IW01.OP0IWSBR = OP0IW01.OP0IWSBR + 1;
      end
    end
  end

  if (OP0IW01.OP0IWBDF != "DC" /* not a cust draw*/
   && OP0IW01.OP0IWBDF != "DN" /* not a nike draw*/
   && OP0IW01.OP0IWBDF != "DR" /* not a rebook draw*/
   && OP0IW01.OP0IWBDF != "DS" /* not a smart draw*/
   && OP0IW01.OP0IWBDF != "DX") /* not a flexible draw*/
    OP0IW01.OP0IWSBR = 1; /* for all 40 sizes*/
    while (OP0IW01.OP0IWSBR < 41)
      OP3REC.OP3SZARY[OP0IWSBR] = OP0IW01.OP3SZARY;
      OP0IW01.OP0IWVSZ = "N";

      OP0IS23(); /* validate size*/

      if (OP0IW01.OP0IWVSZ == "Y")
        OP3REC.OP3SZAFL[OP0IWSBR] = "Y";
        OP0IS24(); /* set size price*/
        OP0IS25(); /* chk price variance*/
        OP0IS26(); /* chk-set full range min/max*/
      end

      OP0IW01.OP0IWSBR = OP0IW01.OP0IWSBR + 1;
    end
  end


      /* *********************************************************/
      /* * move key of partition number & customer order number*/
      /* *********************************************************/

  OP3REC.OP1PARTN = OP1REC.OP1PARTN;
  OP3REC.OP1CUOID = OP1REC.OP1CUOID;




      /* if reqsted range = 0, then move full range to reqst*/

  if (OPWREC.OPWRQSZF[OP0IWSBP] == 0) /* first requested size = 0*/
    OPWREC.OPWRQSZF[OP0IWSBP] = OP0IW01.OP0IWSZF; /* set req=full range*/
    OPWREC.OPWRQSZL[OP0IWSBP] = OP0IW01.OP0IWSZL;
  end

      /* move reqst range to chosen range, first & last size*/

  OP0IW01.OP0IWSMF = OPWREC.OPWRQSZF[OP0IWSBP];
  OP0IW01.OP0IWSML = OPWREC.OPWRQSZL[OP0IWSBP];


   /* if a standard size dist code was entered, apply qtys*/

   /* F OPWREC.XSZCD(OP0IWSBP) GT ' ';/* if code entered*/
   /* IF OP1REC.XGPCD = '02';*/
     /* OP0IS-GET-MSR;               /* distribute footwear quantities*/
   /* ELSE;*/
                                  /* OP0IS2A;                     /**/
                                   /* distribute apparel and other gpc qtys*/
   /* END;*/
   /* ND;*/



   /* ******************************************************/
end // end OP0I020

// review product (use db2)
Function OP0I030()

      /* ********************************************************/
      /* * get the existing db2 product record                 **/
      /* * for product line item and all 40 sizes,             **/
      /* * data goes into op3rec.                              **/
      /* * use product array table(1) for product number.      **/
      /* ********************************************************/

  TA1REC.TA1LOCAT[1] = "OP0I030"; /* error diag - process name*/
  TA1REC.TA1LOCAT[2] = " "; /* group name*/


      /* *************************************************/
      /* * re-set flags for this product to be reviewed*/
      /* *************************************************/

  OP0IS20(); /* re-set for next product*/


      /* *******************************************/
      /* * set up key to read data base, read db2*/
      /* *******************************************/

      /* note - partition # and customer order id set in select*/

      /* convert opwrec.opwhexno(op2lninb) to*/
      /* nike sub-order id=op3rec.op1norid*/

  sysVar.arrayIndex = OPWREC.OP2LNINB; /* pick up selected product*/
  OPAREC.OPWHEXNO = OPWREC.OPWHEXNO[sysVar.arrayIndex]; /* enlarge hex #*/
  OP3REC.OP1NORID = OPAREC.OP1NORID; /* use as sub-order nbr*/
  OP3REC.OP2LNINB = OPWREC.OP2LNINB; /* product line item number*/


  OP0IS91(); /* data base select of prod to review*/



            /* ; get spgm prod pricing, if any*/

  OP0IW01.OP0IWSBP = 1; /* set 6 product array = 1*/

   /* 'nike sub-order original' used to tell if chngs are really*/
    /* updates, or if the key chngd and need to do delete & add.*/

  OP0IW01.OP0IWSBS = OP3REC.OP1NORID; /* hold sub-order index*/
  OP0IW01.OP0IWNSO = OP3REC.OP1NORID; /* use when update or del&add*/
  OP0IW01.OP2CGPCD = OP3REC.OP2CGPCD; /* use for io0570 call*/


   /* save the subst style qty for reporting in op0is82.*/

  OP0IW01.OP2SUBQT = OP3REC.OP2SUBQT;

      /* subtract units and dollars from sub-order array,*/
      /* use original sub-order, in case it changes during review*/
      /* note - units/dollars add into sub-order array*/
        /* when record is re-written.*/


  OPWREC.OP1OTUNT[OP0IWSBS] = OPWREC.OP1OTUNT[OP0IWSBS] - OP3REC.OP2TONOQ;
  OPWREC.OP1OVALU[OP0IWSBS] = OPWREC.OP1OVALU[OP0IWSBS] - OP3REC.OP2LNIVL;



    /* get the bulk order item record for possible update*/

  if (OP0IW01.OP0IWBDF == "DC"
   || OP0IW01.OP0IWBDF == "DR"
   || OP0IW01.OP0IWBDF == "DN"
   || OP0IW01.OP0IWBDF == "DS"
   || OP0IW01.OP0IWBDF == "DX")
    OPAREC.OPAORDN = OP1REC.OP1BLKID;
    OP0IW02.OP1PARTN = OPAREC.OP1PARTN;
    OP0IW02.OP1CUOID = OP1REC.OP1BLKID;
    OP0IW02.OP2LNINB = OPWREC.OPWBKLIN[1];
    OP0IW02.OP1NORID = OPWREC.OP1NORID[1];
    OP0IS29(); /* read bulk order line item record*/
  end


      /* *********************************************************/
      /* * get product data into sycrec*/
      /* * style desc, color desc, prcng by sz fl, sz scl cd*/
      /* *********************************************************/

  OP0IS94();
  OP0IW01.OP0IWPSC = SYCREC.SY4SZSCL; /* hold as prev.prod size scale*/
  OP0IW01.OP0IWPUM = SYCREC.XUMCD; /* hold as prev.prod unit of measure*/


      /* ********************/
      /* * get other data*/
      /* ********************/

  OP0IS22(); /* db2 read product tables*/



      /* get full size range for product, use sycrec*/

  OP3REC.OP2TONOQ = 0; /* zero tot on-ord units for prod*/

  if (OP0IW01.OP0IWBDF == "DC" /* cust draw*/
   && OP0IW01.OP0IWBBD == "B") /* draw from a blank bulk*/
    OP0IW01.OP0IWSBR = 1; /* loop all 40 sizes*/
    while (OP0IW01.OP0IWSBR < 41)
      if (OP3REC.OP3SZAFL[OP0IWSBR] == "Y") /* if size valid for bulk*/
        OP0IW01.OP0IWVSZ = "N";

        OP0IS23(); /* validate finished size*/

        if (OP0IW01.OP0IWVSZ == "Y")
          OP0IS26(); /* chk-set full range min/max*/
           /* calc total units on-order for product*/
          if (OP3REC.OP3SZAFL[OP0IWSBR] == "Y") /* if size valid, sum qty*/
            OP3REC.OP2TONOQ = OP3REC.OP2TONOQ + OP3REC.OP3ONOQT[OP0IWSBR];
          else /* if size valid but not active,*/
            OP3REC.OP3SZARY[OP0IWSBR] = OP0IW01.OP3SZARY;
            OP3REC.OP3SZAFL[OP0IWSBR] = "V"; /* mark with 'v'*/
          end
        else
          OP3REC.OP3SZARY[OP0IWSBR] = OP0IW01.OP3SZARY;
        end
      end

      OP0IW01.OP0IWSBR = OP0IW01.OP0IWSBR + 1;
    end
  end

  if (OP0IW01.OP0IWBDF == "DC" /* cust draw*/
   || OP0IW01.OP0IWBDF == "DN" /* nike draw*/
   || OP0IW01.OP0IWBDF == "DR" /* rebook draw*/
   || OP0IW01.OP0IWBDF == "DS" /* smart draw*/
   || OP0IW01.OP0IWBDF == "DX") /* flexible draw*/
    if (OP0IW01.OP0IWBBD != "B") /* not a draw from a blank bulk*/
      OP0IW01.OP0IWSBR = 1; /* loop all 40 sizes*/
      while (OP0IW01.OP0IWSBR < 41)
        if (OP3REC.OP3SZAFL[OP0IWSBR] == "Y") /* if size valid, sum qty*/
          OP0IS26(); /* chk-set full range min/max*/
          OP3REC.OP2TONOQ = OP3REC.OP2TONOQ + OP3REC.OP3ONOQT[OP0IWSBR];
        else /* if size valid but not active,*/
          if (OP0IW03.OP3SZAFL[OP0IWSBR] == "Y")
            OP0IS26(); /* chk-set full range min/max*/
            OP3REC.OP3SZARY[OP0IWSBR] = OP0IW01.OP3SZARY;
            OP3REC.OP3SZAFL[OP0IWSBR] = "V"; /* mark with 'v'*/
          end
        end

        OP0IW01.OP0IWSBR = OP0IW01.OP0IWSBR + 1;
      end
    end
  end

  if (OP0IW01.OP0IWBDF != "DC" /* not a cust draw*/
   && OP0IW01.OP0IWBDF != "DN" /* not a nike draw*/
   && OP0IW01.OP0IWBDF != "DR" /* not a rebook draw*/
   && OP0IW01.OP0IWBDF != "DS" /* not a smart draw*/
   && OP0IW01.OP0IWBDF != "DX") /* not a flexible draw*/
    OP0IW01.OP0IWSBR = 1; /* loop all 40 sizes*/
    while (OP0IW01.OP0IWSBR < 41)

      OP0IW01.OP0IWVSZ = "N";

      OP0IS23(); /* if size is valid*/

      if (OP0IW01.OP0IWVSZ == "Y")
        OP0IS26(); /* chk-set full range min/max*/
        /* calc total units on-order for product*/
        if (OP3REC.OP3SZAFL[OP0IWSBR] == "Y") /* if size valid, sum qty*/
          OP3REC.OP2TONOQ = OP3REC.OP2TONOQ + OP3REC.OP3ONOQT[OP0IWSBR];
        else /* if size valid but not active,*/
          OP3REC.OP3SZARY[OP0IWSBR] = OP0IW01.OP3SZARY;
          OP3REC.OP3SZAFL[OP0IWSBR] = "V"; /* mark with 'v'*/
        end
      else
        OP3REC.OP3SZARY[OP0IWSBR] = OP0IW01.OP3SZARY;
      end
      OP0IW01.OP0IWSBR = OP0IW01.OP0IWSBR + 1;
    end
  end



      /* get availability. note: variables used in*/
      /* avail routine need to be loaded for review*/
      /* mode since the 6 element product array*/
      /* doesn't pretain to the product being reviewed.*/

  OPWREC.SY1STNBR[OP0IWSBP] = OP3REC.SY1STNBR;
  OPWREC.SY2CLRID[OP0IWSBP] = OP3REC.SY2CLRID;
  OPWREC.XDMCD[OP0IWSBP] = OP3REC.XDMCD;
  OPWREC.XUMCD[OP0IWSBP] = OP3REC.XUMCD;
  OPWREC.XQACD[OP0IWSBP] = OP3REC.XQACD;

  OP0IW01.OP1CUNDT = OPWREC.OP1CUNDT[OP0IWSBS]; /* init w-s*/

  if (OP0IW01.OP0IWBDF == "DC" /* if draw xowcd already defaulted*/
   || OP0IW01.OP0IWBDF == "DN" 
   || OP0IW01.OP0IWBDF == "DR" 
   || OP0IW01.OP0IWBDF == "DS" 
   || OP0IW01.OP0IWBDF == "DX")
    OP0IM001.XOWCD = OP3REC.XOWCD;
  else
    if (OP3REC.XOWCD == "00"
     || OP3REC.XOWCD == "  ")
      if (OPWREC.XWHCD[OP0IWSBS] == "51"
       || OPWREC.XWHCD[OP0IWSBS] == "03"
       || OPWREC.XWHCD[OP0IWSBS] == "25"
       || OPWREC.XWHCD[OP0IWSBS] == "27")
        OP0IM001.XOWCD = "00";
      else
        OP0IM001.XOWCD = " ";
      end
    else
      OP0IM001.XOWCD = OP3REC.XOWCD;
    end
  end

      /* get actual (requested) range in product*/

  OP0IS30();


      /* move reqst range to chosen range, first & last size*/

  OP0IW01.OP0IWSMF = OPWREC.OPWRQSZF[OP0IWSBP];
  OP0IW01.OP0IWSML = OPWREC.OPWRQSZL[OP0IWSBP];


      /* ********************************************************/
      /* * 08/12/92 JLoyer:  display available booking seasons **/
      /* ********************************************************/

  if (OP0IW01.OP0IW-BK-SESN-REQUIRED == "Y") /* if bk-sesn required*/
    if (OP0IW01.OP0IW-DEFAULT-BK-SESN == "N") /* if not defaulting*/
      OP0IW01.OP0IW-OB1470-OP1CUNDT = OPWREC.OP1CUNDT[OP0IWSBS];
      OP0IS-CALL-OB1470(); /* call ob1470*/
      if (OBSREC.OBS-RETN-CD == "01") /* if multi-bk-sesn*/
        OP0IW01.OP0IW-MULTI-BK-SESN-MSG = "Y"; /* move 'y' to*/
      end /* disp msg-flag*/
    end
  end

      /* ********************************************************/
end // end OP0I030

// dup size run, before add prod
Function OP0I040()


      /* ********************************************************/
      /* * check that all sizes from prev. product are valid*/
      /* * for the new product number.*/
      /* * if valid - keep sizes and quantities for new product*/
      /* *   but get new prices.*/
      /* * if not valid - keep size range for new product, but*/
      /* *   use only valid sizes for this product. zero qty*/
      /* *   and get new prices.*/
      /* ********************************************************/

  TA1REC.TA1LOCAT[1] = "OP0I040"; /* error diag process name*/
  TA1REC.TA1LOCAT[2] = " "; /* and group name*/


      /* pre-set flag to skip dup, in case error on db2 access*/
      /* good dup sets flag to 'd' for dup done.*/

  OPWREC.OPWDUPSZ[OP0IWSBP] = "N"; /* no,don't dup*/
  OP0IW01.OP0IWNDC = "N";
  OP0IW01.OP0IWQTC = "N";


      /* **************************************************/
      /* * if first product in 6 product array*/
      /* * get previous product by reading data base*/
      /* * else, the current op3rec = previous product.*/
      /* * this happens on multiple product headers.*/
      /* **************************************************/

  if (OP0IW01.OP0IWSBP == 1)
     /* set up key to read data base*/
     /* convert opwrec.opwhexno(opwlstli) to*/
     /* nike sub-order id=op3rec.op1norid*/
    sysVar.arrayIndex = OPWREC.OPWLSTLI; /* pick up product array entry*/
    OPAREC.OPWHEXNO = OPWREC.OPWHEXNO[sysVar.arrayIndex]; /* enlarge hex #*/
    OP3REC.OP1NORID = OPAREC.OP1NORID; /* use as sub-order nbr*/
    OP3REC.OP2LNINB = OPWREC.OPWLSTLI; /* product line item number*/
    OP0IS91(); /* db2 select of prev product*/
    OP0IS94(); /* db2 for style data in sycrec*/
    OP0IW01.OP0IWPSC = SYCREC.SY4SZSCL; /* hold prev.prod size scale*/
    OP0IW01.OP0IWPUM = SYCREC.XUMCD; /* hold prev.prod unit of measur*/
  end


  if (OP3REC.SY1STNBR == "999999")
    OPAREC.OPAERR = "Y";
    converseLib.validationFailed(186); /* can not dup, prev. prod rejected*/
    OPWREC.OPWRQSZF[OP0IWSBP] = 0; /* so reject reqstd range*/
    OPWREC.OPWRQSZL[OP0IWSBP] = 0;
    exit stack;
  end


      /* *****************************************/
      /* * move current new product data to key*/
      /* *****************************************/

  OP3REC.XGPCD = OP1REC.XGPCD; /* general product class*/
  OP3REC.SY1STNBR = OPWREC.SY1STNBR[OP0IWSBP]; /* style #*/
  OP3REC.SY2CLRID = OPWREC.SY2CLRID[OP0IWSBP]; /* color*/
  OP3REC.XDMCD = OPWREC.XDMCD[OP0IWSBP]; /* dimension*/


      /* get product data into sycrec*/
      /* style desc,color desc, prcng by sz fl, sz scl cd*/

  OP0IS94(); /* DB2 FOR STYLE DATA IN SYCREC*/

  if (SYCREC.SY4SZSCL != OP0IW01.OP0IWPSC) /* compare size scale codes*/
    OPAREC.OPAERR = "Y";
    converseLib.validationFailed(182); /* can not dup, diff size scale codes*/
    OPWREC.OPWRQSZF[OP0IWSBP] = 0; /* so reject reqstd range*/
    OPWREC.OPWRQSZL[OP0IWSBP] = 0;
    exit stack;
  end


   /* for pricing reasons - don't let dup if diff xumcd's.*/

  if (SYCREC.XUMCD != OP0IW01.OP0IWPUM) /* compare unit of measures*/
    OPAREC.OPAERR = "Y";
    converseLib.validationFailed(183); /* can not dup, diff unit of measures*/
    OPWREC.OPWRQSZF[OP0IWSBP] = 0; /* so reject reqstd range*/
    OPWREC.OPWRQSZL[OP0IWSBP] = 0;
    exit stack;
  end



      /* ***********************************************/
      /* * get ranges, validate sizes in old product*/
      /* * they must all be valid, or skip duplicate*/
      /* ***********************************************/


      /* get actual (requested) range in product*/

  OP0IS30();


      /* move reqst range to chosen range, first & last size*/

  OP0IW01.OP0IWSMF = OPWREC.OPWRQSZF[OP0IWSBP];
  OP0IW01.OP0IWSML = OPWREC.OPWRQSZL[OP0IWSBP];


  OP3REC.OP2TONOQ = 0; /* zero tot on-order units in prod*/

  if (OP0IW01.OP0IWBDF == "DC"
   || OP0IW01.OP0IWBDF == "DN"
   || OP0IW01.OP0IWBDF == "DR"
   || OP0IW01.OP0IWBDF == "DS"
   || OP0IW01.OP0IWBDF == "DX")
    OPAREC.OPAORDN = OP1REC.OP1BLKID;
    OP0IW02.OP1PARTN = OPAREC.OP1PARTN;
    OP0IW02.OP1CUOID = OP1REC.OP1BLKID;
    OP0IW02.OP2LNINB = OPWREC.OPWBKLIN[OP0IWSBP];
    OP0IW02.OP1NORID = OPWREC.OP1NORID[OP0IWSBP];
    OP0IS29(); /* read bulk order item record*/
  end

  if (OP0IW01.OP0IWBDF == "DC" /* customer draw*/
   && OP0IW01.OP0IWBBD == "B") /* draw from a blank bulk*/

    OP0IW01.OP0IWSBR = 1;
    while (OP0IW01.OP0IWSBR <= 40)

      if (OP3REC.OP3SZAFL[OP0IWSBR] == "Y")
        OP0IW01.OP0IWVSZ = "N"; /* init valid size flag*/

        OP0IS23(); /* if size is valid*/

        if (OP0IW01.OP0IWVSZ == "Y")
           /* calc total units in product, for verify*/
          OP3REC.OP2TONOQ = OP3REC.OP2TONOQ + OP3REC.OP3ONOQT[OP0IWSBR];
          OP3REC.OP3ALQT[OP0IWSBR] = 0; /* init aloc qty*/
          OP0IS26(); /* chk-set full range min/max*/
        else
          OPAREC.OPAERR = "Y";
          converseLib.validationFailed(183); /* dup sizes not valid, so cant dup*/
          OPWREC.OPWRQSZF[OP0IWSBP] = 0; /* reject reqstd range*/
          OPWREC.OPWRQSZL[OP0IWSBP] = 0;
          exit stack;
        end
      else
        OP0IW01.OP0IWVSZ = "N"; /* size not active on product*/
        OP0IS23(); /* but may be valid size*/
        if (OP0IW01.OP0IWVSZ == "Y") /* and need to get full range*/
          OP0IS26(); /* chk-set full range min/max*/
          OP3REC.OP3SZARY[OP0IWSBR] = OP0IW01.OP3SZARY;
          OP3REC.OP3SZAFL[OP0IWSBR] = "V"; /* mark with 'v'*/
        else
          OP3REC.OP3SZARY[OP0IWSBR] = OP0IW01.OP3SZARY;
        end
      end

      OP0IW01.OP0IWSBR = OP0IW01.OP0IWSBR + 1;
    end
  end

  if (OP0IW01.OP0IWBDF == "DC" /* customer draw*/
   || OP0IW01.OP0IWBDF == "DN" /* nike draw*/
   || OP0IW01.OP0IWBDF == "DR" /* rebook draw*/
   || OP0IW01.OP0IWBDF == "DS" /* smart draw*/
   || OP0IW01.OP0IWBDF == "DX") /* fkexible draw*/
    if (OP0IW01.OP0IWBBD != "B") /* not a draw from a blank bulk*/

      OP0IW01.OP0IWSBR = 1;
      while (OP0IW01.OP0IWSBR <= 40)
        if (OP3REC.OP3SZAFL[OP0IWSBR] == "Y") /* if size active on bulk*/
          if (OP0IW03.OP3SZAFL[OP0IWSBR] == "Y") /* if prev prod size active*/
            OP0IS26(); /* chk-set min/max size*/
            OP3REC.OP2TONOQ = OP3REC.OP2TONOQ + OP3REC.OP3ONOQT[OP0IWSBR];
            OP3REC.OP3OHRQT[OP0IWSBR] = 0; /* init resv qty*/
          else
            OPAREC.OPAERR = "Y";
            converseLib.validationFailed(183); /* dup sizes not valid, so cant dup*/
            OPWREC.OPWRQSZF[OP0IWSBP] = 0; /* reject reqstd range*/
            OPWREC.OPWRQSZL[OP0IWSBP] = 0;
            exit stack;
          end
        else
          if (OP0IW03.OP3SZAFL[OP0IWSBR] == "Y")
            OP3REC.OP3SZARY[OP0IWSBR] = OP0IW01.OP3SZARY;
            OP3REC.OP3SZAFL[OP0IWSBR] = "V";
            OP0IS26(); /* chk-set min/max size*/
          end
        end

        OP0IW01.OP0IWSBR = OP0IW01.OP0IWSBR + 1;

      end
    end
  end

  if (OP0IW01.OP0IWBDF != "DC"
   && OP0IW01.OP0IWBDF != "DN"
   && OP0IW01.OP0IWBDF != "DR"
   && OP0IW01.OP0IWBDF != "DS"
   && OP0IW01.OP0IWBDF != "DX")
    OP0IW01.OP0IWSBR = 1;
    while (OP0IW01.OP0IWSBR < 41) /* loop all 40 sizes*/
      if (OP3REC.OP3SZAFL[OP0IWSBR] == "Y")
        OP0IW01.OP0IWVSZ = "N"; /* init valid size flag*/
        OP0IS23(); /* if size is valid*/
        if (OP0IW01.OP0IWVSZ == "Y")
           /* calc total units in product, for verify*/
          OP3REC.OP2TONOQ = OP3REC.OP2TONOQ + OP3REC.OP3ONOQT[OP0IWSBR];
          OP3REC.OP3ALQT[OP0IWSBR] = 0; /* init aloc qty*/
          OP0IS26(); /* chk-set full range min/max*/
        else
          OPAREC.OPAERR = "Y";
          converseLib.validationFailed(183); /* dup sizes not valid, so cant dup*/
          OPWREC.OPWRQSZF[OP0IWSBP] = 0; /* reject reqstd range*/
          OPWREC.OPWRQSZL[OP0IWSBP] = 0;
          exit stack;
        end
      else
        OP0IW01.OP0IWVSZ = "N"; /* size not active on product*/
        OP0IS23(); /* but may be valid size*/
        if (OP0IW01.OP0IWVSZ == "Y") /* and need to get full range*/
          OP0IS26(); /* chk-set full range min/max*/
          OP3REC.OP3SZARY[OP0IWSBR] = OP0IW01.OP3SZARY;
          OP3REC.OP3SZAFL[OP0IWSBR] = "V"; /* mark with 'v'*/
        else
          OP3REC.OP3SZARY[OP0IWSBR] = OP0IW01.OP3SZARY;
        end
      end

      OP0IW01.OP0IWSBR = OP0IW01.OP0IWSBR + 1;
    end
  end



     /* get availability.*/

  if (OP0IW01.OP0IWBBD == "B" /* if blank bulk draw or*/
   || OP0IW01.OP0IWBBD == "F") /* or finished bulk draw*/
    OP3REC.XOWCD = OPWREC.XOWCD; /* use xowcd passed from opwrec*/
    if (OPWREC.XOWCD == "00"
     || OPWREC.XOWCD == "  ")
      if (OP0IM001.XWHCD == "51"
       || OP0IM001.XWHCD == "03"
       || OP0IM001.XWHCD == "25"
       || OP0IM001.XWHCD == "27")
        OP0IM001.XOWCD = "00";
      else
        OP0IM001.XOWCD = " ";
      end
    else
      OP0IM001.XOWCD = OPWREC.XOWCD;
    end
  else
    if (OP0IW01.OP0IWBDF == "DC" /* if draw xowcd already defaulted*/
     || OP0IW01.OP0IWBDF == "DN" 
     || OP0IW01.OP0IWBDF == "DR" 
     || OP0IW01.OP0IWBDF == "DS" 
     || OP0IW01.OP0IWBDF == "DX")
      OP0IM001.XOWCD = OP3REC.XOWCD;
    else
      OP3REC.XOWCD = OPWREC.XOWCD;
      if (OPWREC.XOWCD == "00"
       || OPWREC.XOWCD == "  ")
        if (OP0IM001.XWHCD == "51"
         || OP0IM001.XWHCD == "03"
         || OP0IM001.XWHCD == "25"
         || OP0IM001.XWHCD == "27")
          OP0IM001.XOWCD = "00";
        else
          OP0IM001.XOWCD = " ";
        end
      else
        OP0IM001.XOWCD = OPWREC.XOWCD;
      end
    end
  end




      /* *************************************/
      /* * got here, so valid to dup sizes*/
      /* *************************************/

  OPWREC.OPWDUPSZ[OP0IWSBP] = "D"; /* done dup sizes*/

  converseLib.validationFailed(180); /* size run duplicated*/
  OPAREC.OPAERR = "Y";


      /* initialize pricing flags*/
      /* (op2prcvf set by db2 szrun formatter*/
      /* but need to use it during program)*/

  OP3REC.OP2PRCOF = "N"; /* price override on any size*/
  OP3REC.OP2PRCVF = "N"; /* price vary flag*/


  OP0IS22(); /* db2 read product tables*/


  OP0IW01.OP0IWSBR = OP0IW01.OP0IWSMF; /* for actual range*/
  while (OP0IW01.OP0IWSBR < 41
   && OP0IW01.OP0IWSBR <= OP0IW01.OP0IWSML)
    if (OP3REC.OP3SZAFL[OP0IWSBR] == "Y")
      OP3REC.OP3PRCOF[OP0IWSBR] = "N"; /* init override flag*/
      OP0IS24(); /* set-up size price*/
      OP0IS25(); /* chk-move y to prc vary flag*/
    end
    OP0IW01.OP0IWSBR = OP0IW01.OP0IWSBR + 1;
  end



end // end OP0I040

// initial map set-up, use op3rec
Function OP0I050()


      /* ******************************************/
      /* * move data to all fields on the map,*/
      /* * use data from op3rec*/
      /* * which may be initial default values*/
      /* * or previously entered product data.*/
      /* ******************************************/


  TA1REC.TA1LOCAT[1] = "OP0I050"; /* error diag data-process name*/
  TA1REC.TA1LOCAT[2] = " "; /* - group name*/


      /* ***************************************/
      /* * MAp line 1 - process name & date*/
      /* ***************************************/

      /* application data for map*/

  OP0IM001.OPMPRC = "OP0I060";
  OP0IM001.OPMMAP = "OP0IM001";
  OP0IM001.OPMRVN = 04; /* revision number 7-22-87*/


      /* today's date*/

  OP0IM001.OPMDT = VGVar.currentShortGregorianDate;


      /* ***************************************/
      /* * map line 2 - customer & ordered by*/
      /* ***************************************/

      /* format customer number for display*/

  OPAREC.OPACUCO = OP1REC.KUCCOID;
  OPAREC.OPACUSR = OP1REC.KUMSTRID;
  OPAREC.OPACUDP = OP1REC.XNXCD;

  OP0IM001.OPACUNO = OPAREC.OPACUNO; /* full cust number*/

  OP0IM001.KUMSTRNM = OPWREC.KUMSTRNM; /* store name*/


      /* move 'ordered by' to the map*/

  if (OP1REC.OP1ORDBY != " ") /* if present, show on map*/
    set OP0IM001.OP0IMWDO initialAttributes;
    OP0IM001.OP1ORDBY = OP1REC.OP1ORDBY;
  else
    set OP0IM001.OP0IMWDO skip, invisible;
  end


      /* ********************************************************/
      /* * MAp line 3 - product (nike or cust) & full size range*/
      /* ********************************************************/

  if (OP3REC.KUIPRDID == " ") /* if no cust product*/
    OP0IW01.SY1STNBR = OP3REC.SY1STNBR; /* format nike product*/
    OP0IW01.SY2CLRID = OP3REC.SY2CLRID;
    OP0IW01.XDMCD = OP3REC.XDMCD;
    OP0IM001.OP0IMPRD = OP0IW01.OP0IWPRD; /* nike prod code*/
  else
    OP0IM001.OP0IMPRD = OP3REC.KUIPRDID; /* cust prod #*/
  end


  OP0IM001.SY1SSTNM = SYCREC.SY1SSTNM; /* product style name*/
  OP0IM001.SY2CLRAB = SYCREC.SY2CLRAB; /* and color name*/

      /* ********************************************/
      /* * if rejecting product, skip rest of screen,*/
      /* * go show map with error message*/
      /* ********************************************/

  if (OP0IW01.OP0IWREJ == "Y") /* skip rest if reject prod.*/
    exit stack;
  end


      /* ***************************************************/
      /* * if not rejecting product, finish rest of screen*/
      /* ***************************************************/

  if (OP0IW01.OP0IWSCR == 1) /* if on screen 1*/
    OP0IS96(); /* get product size scale record*/
                                 /* ;   for size descriptions*/
  end

      /* use w-s first/last sizes as index to product size scale*/
      /* record for size description*/

  OP0IM001.OP0IMSZF = SY4REC.SY4IDDSC[OP0IWSZF];
                                   /* first & last sizes*/
  OP0IM001.OP0IMSZL = SY4REC.SY4IDDSC[OP0IWSZL]; /* for prod full range*/


   /* ************************************************************/
   /* * map line 4 - 1st show blank, verify err shown after edits*/
   /* ************************************************************/

      /* blank words, size descrp*/
      /* for requested first/last sizes, and quantity.*/

  OP0IS50(); /* set line clear*/


      /* **************************************/
      /* * map lines 5 - 14  all 20 sizes*/
      /* **************************************/

    /* set up availability labels*/

  if (OP0IW01.OP0IWBDF == "DC"
   || OP0IW01.OP0IWBDF == "DN"
   || OP0IW01.OP0IWBDF == "DR"
   || OP0IW01.OP0IWBDF == "DS"
   || OP0IW01.OP0IWBDF == "DX")
    OP0IM001.OP0IMLAV[1] = "BLK AVL:";
    OP0IM001.OP0IMLAV[2] = "BLK AVL:";
  else
    OP0IM001.OP0IMLAV[1] = "  AVAIL:";
    OP0IM001.OP0IMLAV[2] = "  AVAIL:";
  end



      /* calc if order is production add-on after*/
      /* the production deadline date.*/
        /* prod add-on -*/
          /* if ord.type & needdate in xpd table*/
          /* and current date > prod.deadline*/
      /* order maintenance definition is different:*/
        /* prod add-on -*/
          /* if (same as order entry)*/
          /* or not in xpd table*/
          /* ***/

   /* skip production test for customer draw orders*/

  set OPLREC empty; /* cutoff pass record*/
  OPLREC.OPJCNDTB = OPWREC.OP1CUNDT[OP0IWSBS]; /* need date*/
  OP0IS32(); /* check production deadline*/

    /* see if order adjustment number required*/

  OP0IW01.OP0IWOAF = "N"; /* initialize order adj flag*/

  if (OP1REC.XOCCD == "IN") /* invoice only order*/
     /* next sentence*/
  else
    if (OP1REC.XDVCD == "02" /* if nil*/
     && OP1REC.XGPCD == "02" /* and footwear*/
     && OP0IW01.OP0IWP20 == "Y") /* and 20 days past cutoff date*/
      OP0ISOB(); /* test for o/a validation override*/
      if (OP0IW01.OP0IWOAO == "N") /* o/a validation override?*/
        converseLib.validationFailed(614);
        OP0IW01.OP0IWOAF = "Y"; /* order adj required*/
      end
    end
  end

  OP0ISGA(); /* get availability*/

     /* 9/5/89  -  for all nil orders with first quality products*/
     /* and active or in development life cycles, verify if there*/
     /* is a restriction on the customer ordering the specific*/
     /* product for the need date requested.*/
     /* Determine product's life cycle for future nil orders so*/
     /* life cycle will be known for further edit checks.*/

  if (XOTTBL.XOTFUTRF[OP0IWSBO] == "Y" /* future order*/
   && OP1REC.XDVCD == "02")            /* nil order*/
    OP0ISGL(); /* determine life cycle*/
  end

  if (OP1REC.XDVCD == "02") /* nil order*/
    if (OP3REC.XQACD == "01") /* and first quality*/
      if (OP0IW01.XLCCD == "10" /* active life cycle*/
       || OP0IW01.XLCCD == "05") /* or in development life cycle*/
        OP0IW05.OP0IWDTE = OP1REC.OP1CUNDT; /* frmt need date*/
        OP0ISOD(); /* verify customer/product elig.*/
      end
    end
  else
    OP0ISDZ(); /* check offering dates*/
  end




  OP0IS51(); /* move sizes,qty,(maybe avail),(maybe*/
                                   /* price) to map*/
        /* ; 'more sizes' done there*/

      /* ****************************************/
      /* * map line 15 - pricing & more sizes*/
      /* ****************************************/

      /* move price for all sizes, if appropriate*/

  if (OP3REC.OP2PRCOF == "N" /* no price override*/
   && OP3REC.OP2PRCVF == "N") /* and no price varies by size*/
    OP0IM001.OP0IMPAL = OP3REC.OP2AUPRC;
  else
    if (OP3REC.OP2PRCVF == "N") /* price override but no vary*/
      OP0IM001.OP0IMPAL = OP3REC.OP2AUPRC;
    end
  end

   /* Added for Canada 7/10/95*/

  if (OP1REC.XDZ-DATA-DIST-CD == "CA")
    OP0IM001.ZFCCD = OP1REC.ZFC-CRCY-CD;
  end

      /* set up 'more sizes' flag*/
      /* see lines 5 - 14*/


      /* ********************************************************/
      /* * map line 16 - warehouse, needdate and backorder flag**/
      /* ********************************************************/

      /* move warehouse & needdate from sub-order array*/

  if (OP0IW01.OP0IWSBS <= 10) /* if subscript valid*/
    OP0IM001.XWHCD = OPWREC.XWHCD[OP0IWSBS];
    /* get warehouse short abbreviation from csp table*/
    OP0IM001.XWHSABRV = OPWREC.XWHCD[OP0IWSBS];
                                   /* init abbrev to code*/
    if (OPWREC.XWHCD[OP0IWSBS] in XWHTBL.XWHCD)
      OP0IM001.XWHSABRV = XWHTBL.XWHSABRV[sysVar.arrayIndex];
    end
    /* reformat need date from 19yymmdd to mmddyy for map*/
    OPAREC.OPAWDT = OPWREC.OP1CUNDT[OP0IWSBS]; /* need date*/
    OPAREC.OPAFYY = OPAREC.OPAWYY;
    OPAREC.OPAFMM = OPAREC.OPAWMM;
    OPAREC.OPAFDD = OPAREC.OPAWDD;
    OP0IM001.OP0IMNDT = OPAREC.OPAFDT;
  else
    /* subscript error, whse & needdate already on map*/
  end


  if (OP0IM001.XWHCD == " " /* warehouse required field*/
   && OP0IW01.XDSWHSEF == "Y") /* for direct ship*/
    OPAREC.OPAERR = "Y";
    converseLib.validationFailed(098);
    set OP0IM001.XWHCD cursor, modified, bold;
  end



  if (OP0IM001.XOWCD != " ") /* owner group abbrev*/
    XOWREC.XWHCD = OP0IM001.XWHCD;
    XOWREC.XOWCD = OP0IM001.XOWCD;
    if (XOWREC.XOWKEY in XOWTBL.XOWKEY) /* if in table*/
      if (XOWTBL.XXXSTAT[sysVar.arrayIndex] == "A")
        OP0IM001.XOWABRV = XOWTBL.XOWABRV[sysVar.arrayIndex];
      end
    end
  end


   /* protect warehouse and need date for bulk/draw*/

  if (OP0IW01.OP0IWBDF > " ") /* if bulk or draw protect xwhcd*/
    set OP0IM001.XWHCD protect;
    if (OP0IW01.OP0IWBDF == "DR" /* if rebook draw or*/
     || OP0IW01.OP0IWBDF == "BC") /* bulk, also protect needdate*/
         /* OR OP0IW01.OP0IWBDF EQ 'BS';*/
         /* OR OP0IW01.OP0IWBDF EQ 'BX';*/
         /* OR OP0IW01.OP0IWBDF EQ 'BB' ;  if blank bulk*/
      set OP0IM001.OP0IMNDT protect;
    end
  end


    /* if review mode and product was allocated, protect*/
    /* warehouse and need date and owner group.*/

  if (OPWREC.OPWREVM == 7
   || OPWREC.OP2LNINB > 0
   || OP3REC.OP2LNIST == "AL")
    set OP0IM001.XWHCD protect;
    set OP0IM001.OP0IMNDT protect;
  end

      /* move backorder flag (from customer or product default)*/

  OP0IM001.OP1BOFL = OP3REC.OP1BOFL;

  OP0IM001.PWRLBCD[1] = OP3REC.PWRLBCD[1]; /* labl cd #1*/
  OP0IM001.PWRLBCD[2] = OP3REC.PWRLBCD[2]; /* labl cd #2*/

  OP0IW01.OP0IW-LABL-CD-SUB = 2; /* initialize sub-script*/

  while (OP0IW01.OP0IW-LABL-CD-SUB > 0) /* loop through labl cd*/
    OP0IS-EDIT-LABL-CD(); /* edit labl cd & fill in abrv*/
   /* dcrement sub-script*/
    OP0IW01.OP0IW-LABL-CD-SUB = OP0IW01.OP0IW-LABL-CD-SUB - 1;
  end

   /* TT#4752 * bssa changes * begin * move lbl cds to comm rec*/
  OPWREC.PWRLBCD[1] = OP3REC.PWRLBCD[1]; /* labl cd #1*/
  OPWREC.PWRLBCD[2] = OP3REC.PWRLBCD[2]; /* labl cd #2*/
   /* TT#4752 * bssa changes *  end  * move lbl cds to comm rec*/

      /* ******************************************************/
      /* * map line 17 - availability comment, spec code*/
      /* ******************************************************/
       /* availability comment*/
      /* handled in process op0i060 (op0isga, op0isgc)*/


   /* spec code*/

  OP0IM001.PC2INSEG = OP3REC.PC2INSEG;

  if (OPWREC.OPWREVM == 7  /* if review mode*/
   && OP1REC.XDVCD == "02" /* international*/
   && OP1REC.XOBCD == "F1" /* futures*/
   && OP1REC.XGPCD == "03" /* apparel*/
   && OP1REC.XDSCD == " ") /* ship from whse*/
    if (OP1REC.XWHCD == "51" /* Memphis aprl whse*/
     || OP1REC.XWHCD == "25" /* NSG aprl whse*/
     || OP1REC.XWHCD == "27") /* NSG aprl whse*/
      if (OP3REC.OP2LNIST == "OP") /* can only change if open*/
        set OP0IM001.PC2INSEG initialAttributes;
      else
        set OP0IM001.PC2INSEG protect;
      end
    else
      set OP0IM001.PC2INSEG protect;
    end
  else
    set OP0IM001.PC2INSEG protect;
  end


      /* ********************************************************/
      /* * map line 18 - coord group, key style, gut size & uom**/
      /* ********************************************************/

      /* move customer defined coordinate group & key style*/

  OP0IM001.OP2CGPCD = OP3REC.OP2CGPCD;
  OP0IM001.OP2KSTYF = OP3REC.OP2KSTYF;


      /* move gut size flag*/

  OP0IM001.OP2GTSZF = OP3REC.OP2GTSZF;


      /* move unit of measure description*/

  OP0IM001.XUMDESC = OP3REC.XUMCD; /* init descrip to code*/
  if (OP3REC.XUMCD in XUMTBL.XUMCD)
    OP0IM001.XUMDESC = XUMTBL.XUMDESC[sysVar.arrayIndex];
  end



    /* set coordinate group field protect if bulk order.*/

  if (OP0IW01.OP0IWBDF == "BS"
   || OP0IW01.OP0IWBDF == "BX")
    set OP0IM001.OP2CGPCD protect;
  end

      /* ********************************************************/
      /* * map line 19 -five package handling codes & data    **/
      /* ********************************************************/

  OP0IW01.OP0IWSBH = 1; /* start at first handling code*/

  if (OP3REC.XHDCD[1] != " ")
    OP0IM001.XHDCD[1] = OP3REC.XHDCD[1];
  end

  if (OP3REC.XHDCD[2] != " ")
    OP0IM001.XHDCD[2] = OP3REC.XHDCD[2];
  end

  if (OP3REC.XHDCD[3] != " ")
    OP0IM001.XHDCD[3] = OP3REC.XHDCD[3];
  end

  if (OP3REC.XHDCD[4] != " ")
    OP0IM001.XHDCD[4] = OP3REC.XHDCD[4];
  end

  if (OP3REC.XHDCD[5] != " ")
    OP0IM001.XHDCD[5] = OP3REC.XHDCD[5];
  end

  if (OP1REC.ZFC-CRCY-CD == " ")
    OP1REC.ZFC-CRCY-CD = "USD";
  end


  while (OP0IW01.OP0IWSBH < 6)
    OP0IW01.OP0IWHTP = " "; /* init ws building area*/
    if (OP3REC.XHDCD[OP0IWSBH] != " ")
      sysVar.arrayIndex = 1;
      OP0IW01.XHDCD = OP3REC.XHDCD[OP0IWSBH];
      OP0IW01.XGPCD = OP3REC.XGPCD;
      if (OP0IW01.XHDKEY in XHDTBL.XHDKEY)
        if (OP1REC.ZFC-CRCY-CD
         == XHDTBL.ZFC-CRCY-CD[sysVar.arrayIndex]) /* Canada 6/95*/
          OP0IW01.XHDUCHFL = XHDTBL.XHDUCHFL[sysVar.arrayIndex];
        else
          converseLib.validationFailed(901); /* crcy cd unmatched*/
          OPAREC.OPAERR = "Y";
          set OP0IM001.XHDCD bold, cursor;
          exit stack;
        end
      end
      OP0IM001.XHDCHG[OP0IWSBH] = OP3REC.XHDCHG[OP0IWSBH];
      if (OP3REC.OP2HCHGO[OP0IWSBH] == "Y") /* if charge was overridden*/
        OP0IW01.OP2HCHGO = "*"; /* move '*' to map*/
      end
      OP0IM001.OP0IMHTP[OP0IWSBH] = OP0IW01.OP0IWHTP;
    end
    OP0IW01.OP0IWSBH = OP0IW01.OP0IWSBH + 1; /* look at next handling code*/
  end

  if (OP1REC.XDZ-DATA-DIST-CD != "CA")
    OP1REC.ZFC-CRCY-CD = " ";
  end

      /* ********************************************************/
      /* * 08/12/92 JLoyer display booking seasons on map      **/
      /* ********************************************************/

  if (OP0IW01.OP0IW-BK-SESN-REQUIRED == "Y") /* if bk-sesns required*/
    OP0IS-MAP-BK-SESN(); /* move bk-sesn/mo to map*/
    set OP0IM001.XBK-BK-SESN-CD initialAttributes; /* map defined as askip*/
    set OP0IM001.OP0IM-OP-BK-YR-YY initialAttributes; /**/
    set OP0IM001.OP0IM-OP-BK-MO-MM initialAttributes; /**/
    if (OP0IW01.OP0IW-MULTI-BK-SESN-MSG == "Y") /* if multi bk-sesn avail*/
      set OP0IM001.XBK-BK-SESN-CD normal; /* allow entry*/
      set OP0IM001.OP0IM-OP-BK-YR-YY normal; /* on bk-sesns*/
      if (OPAREC.OPAERR == "Y") /* if other errors exist*/
                                  /* don't overlay msg*/
      else /* else*/
        if (converseVar.validationMsgNum == 0) /* if no other msgs*/
          converseLib.validationFailed(776); /* display multi bs*/
          OP0IW01.OP0IW-MULTI-BK-SESN-MSG = "N"; /* set multi-msg fl*/
        end
      end
    end
  end

      /* ********************************************************/
      /* * map line 20 - substitution product & qty,& forecast **/
      /* ********************************************************/

      /* if the current product was substituted for another*/
      /* nike product, then show the product number first wanted.*/

  OP0IM001.OP2SSTYN = OP3REC.OP2SSTYN;
  OP0IM001.OP2SCLCD = OP3REC.OP2SCLCD;
  if (OP0IM001.OP2SCLCD > " ") /* if something there*/
    /* next sentence*/
  else
    if (OP1REC.XGPCD != "03") /* if not apparel*/
      OP0IM001.OP2SCLCD = "00"; /* default color code*/
    end
  end

  OP0IM001.OP2SDMCD = OP3REC.OP2SDMCD;
  OP0IM001.OP2SUBQT = OP3REC.OP2SUBQT;


      /* show quality abbreviation for the product*/

  if (OPWREC.XQACD[OP0IWSBP] in XQATBL.XQACD)
    OP0IM001.XQAABRV = XQATBL.XQAABRV[sysVar.arrayIndex];
  else
    OP0IM001.XQAABRV = " ";
  end

      /* show flag if qty should be sent to forecasting dept.*/

  OP0IM001.OP2FSTFL = OP3REC.OP2FSTFL;


     /* **********************************************************/
     /* *  if this product is hot check for customer eligibility*/
     /* *********************************************************/
  if (SYCREC.OPZHMIND == "Y" /* product is hot*/
   && OP0IW01.OP0IWBDF == "  ") /* not a bulk or draw*/
    if (XOTTBL.XOTPROPF[OP0IWSBO] == "Y" /* is a prop ot*/
     && XOTTBL.XOTFUTRF[OP0IWSBO] == "N" /* not a futures ot*/
     && XOTTBL.XOTSMPLF[OP0IWSBO] == "N") /* not a sample*/
      OP0ISHM();
    end
  end
      /* ********************************************************/
      /* * map line 21 - 24  ezemsg, ~~~~~, two pf key lines   **/
      /* ********************************************************/


   /* cannot report lost demand in review mode if item has*/
   /* been allocated 12/06/89 rmd*/

  if (COMMAREA.CAFRMSYS == "AV") /* if coming from substitution*/
    set OP0IM001.OP0IMP24 skip, invisible; /* darken Mf24*/
    set OP0IM001.OP0IMFLD skip, invisible; /* darken fill lost demand label*/
    set OP0IM001.OP0IMFIL skip, invisible; /* darken fill lost demand flag*/
  else
    if (OP0IW01.OP0IWBDF == "DR" /* if rebook or cust draw*/
     || OP0IW01.OP0IWBDF == "DN" /* OR NIKE DRAW*/
     || OP0IW01.OP0IWBDF == "DC") /* set dark*/
      set OP0IM001.OP0IMFLD skip, invisible; /* darken fill lost demand label*/
      set OP0IM001.OP0IMFIL skip, invisible; /* darken fill lost demand flag*/
    else
      if (XOTTBL.XOTDMRPF[OP0IWSBO] == "N") /* if not rept lost demand*/
        set OP0IM001.OP0IMP24 skip, invisible; /* darken pf24*/
        set OP0IM001.OP0IMFLD skip, invisible; /* Fill lost demand label*/
        set OP0IM001.OP0IMFIL skip, invisible;
                                   /* darken fill lost demand flag*/
      else
        if (OPWREC.OPWREVM == 7 /* if in product summary review mode*/
         || OPWREC.OP2LNINB > 0) /* or selected product*/
          if (OP3REC.OP2LNIST == "AL")
            set OP0IM001.OP0IMP24 skip, invisible; /* darken pf24*/
            set OP0IM001.OP0IMFLD skip, invisible; /* fill lost demand label*/
            set OP0IM001.OP0IMFIL skip, invisible; /* fill lost demand flag*/
          else
            OP0IM001.OP0IMP24 = "24:REJECT PRODUCT-REPORT DEMAND";
            OP0IM001.OP0IMFLD = "FILL LOST DEMAND(Y/N):";
            OP0IM001.OP0IMFIL = "N";
          end
        else
          OP0IM001.OP0IMP24 = "24:REJECT PRODUCT-REPORT DEMAND";
          OP0IM001.OP0IMFLD = "FILL LOST DEMAND(Y/N):";
          OP0IM001.OP0IMFIL = "N";
        end
      end
    end
  end

  OP0IM001.OP0IMP23 = "23:REJECT PRODUCT-SKIP DEMAND RPT";


   /* *********************************************************/
end // end OP0I050

// converse the map, edit, exit
Function OP0I060()


  TA1REC.TA1LOCAT[1] = "OP0I060"; /* error diag -process*/
  TA1REC.TA1LOCAT[2] = " "; /* -group name*/


      /* add second message for forcibly rejected prod*/
      /* reason for rej appears in ezemsg*/

  if (OP0IW01.OP0IWREJ == "Y")
    OP0IM001.SY1SSTNM = "PROD.REJECTD";
    OP0IM001.SY2CLRAB = " -- HIT ENTER";
    set OP0IM001.SY1SSTNM cursor, bold;
    set OP0IM001.SY2CLRAB bold;
  end

      /* *  pf 5 - product substitution*/

  if (OPWREC.OPWREVM == 7 /* product review mode*/
   || OPWREC.OP2LNINB > 0 /* line item number*/
   || OPWREC.OPWFUNC == "4") /* order is a draw*/
    set OP0IM001.OP0IMPF5 skip, invisible;
    OP0IW01.OP0IWPF5 = "N"; /* pf5 not allowed*/
  else
    if (XOTTBL.XOTDSAVL[OP0IWSBO] == "Y") /* order type uses availability*/
      if (OP1REC.SP1ID > " ") /* there is a sales program*/

            /* *** if a sales program is present, check if the sales*/
            /* *** program is applicable to all products -- a '**'*/
            /* *** is found in an sp1rec.xspcd bucket.  this is so*/
            /* *** as to insured that any product comming back is*/
            /* *** allowed for the sales program.*/

        set SP1REC empty;
        SP1REC.SP1ID = OP1REC.SP1ID;
        OP0ISSP(); /* get sp1rec*/

        if ("**" in SP1REC.XSPCD)
          set OP0IM001.OP0IMPF5 initialAttributes;
          OP0IW01.OP0IWPF5 = "Y"; /* pf5 allowed*/
        else
          set OP0IM001.OP0IMPF5 skip, invisible;
          OP0IW01.OP0IWPF5 = "N"; /* pf5 not allowed*/
        end
      else
        set OP0IM001.OP0IMPF5 initialAttributes;
        OP0IW01.OP0IWPF5 = "Y"; /* pf5 allowed*/
      end
    else
      set OP0IM001.OP0IMPF5 skip, invisible;
      OP0IW01.OP0IWPF5 = "N"; /* pf5 not allowed*/
    end
  end


   /* *********************************************************/
   /* ** Note if after the above tests to determine if access*/
   /* ** to substitution is still allowed, KUCREC or the cus-*/
   /* ** tomer company record will indicate if the customer*/
   /* ** placing the order is eligible to do product substi-*/
   /* ** tution.*/
   /* *********************************************************/

  if (OP0IW01.OP0IWPF5 == "Y") /* pf5 was allowed*/
    KUCREC.KUCCOID = OP1REC.KUCCOID;
    OP0IS9C(); /* get kucrec*/
    if (KUCREC.KUCPSFL == "N") /* customer not allowed*/
      OP0IW01.OP0IWPF5 = "N";
      set OP0IM001.OP0IMPF5 skip, invisible;
    end
  end


   /* *********************************************************/
   /* ** Note that the following two statements override*/
   /* ** whatever value is determined from the previous*/
   /* ** routine.  These two statements will be deleted*/
   /* ** when AV0K and AV0L are installed in production to*/
   /* ** activate product substitution in order entry.*/
   /* *********************************************************/

   /* SET OP0IM001.OP0IMPF5 AUTOSKIP,DARK;*/
   /* MOVE 'N' TO OP0IW01.OP0IWPF5    ; pf5 not allowed*/


    /* Owner group is protected for*/
               /* - review mode*/
               /* - product is allocated*/
               /* - blank bulks*/
               /* - all draws except smart reservations*/
    /* This logic has been moved from 050, s7c, s40 to*/
    /* preconverse to re-protect the screen if any processing*/
    /* in the availability routines caused owner group*/
    /* to be set modified*/

  if (OPWREC.OPWREVM == 7      /* review mode*/
   || OPWREC.OP2LNINB > 0      /* review mode*/
   || OP3REC.OP2LNIST == "AL"  /* product is allocated*/
   || OP1REC.XBDCD == "B"      /* blank bulk*/
   || OP0IW01.OP0IWBDF == "DC" /* cust draw, blank bulk draw*/
   || OP0IW01.OP0IWBDF == "DN" /* nike draw*/
   || OP0IW01.OP0IWBDF == "DS" /* smart reservation draw*/
   || OP0IW01.OP0IWBDF == "DR" /* rebook draw*/
   || OP0IW01.OP0IWBDF == "DX") /* flexible draw*/
    set OP0IM001.XOWCD protect; /* don't allow xowcd changes*/
  end

   /* *********************************************************/

   /* *********************************************************/
   /* ** Note that the following two statements override*/
   /* ** whatever value is determined from the previous*/
   /* ** routine.  This will prevent the warehouse from*/
   /* ** changing when NIL Order being entered for warehouse*/
   /* ** '15'. Must remain '15'!!!!*/
   /* *********************************************************/

  if (OP1REC.XDVCD == "02" /* International Order*/
   && OP1REC.XWHCD == "15") /* and consol delivery warehouse*/
    set OP0IM001.XWHCD protect; /* protect the field*/
  end


   /* ************************************************************/
   /* ** the following will protect the warehouse and owner group*/
   /* ** fields when the order is NIL and the order class used is*/
   /* ** 'international' (IN) or NIL Airborne order (AS).*/
   /* ************************************************************/

  if (OP1REC.XDVCD == "02") /* International Order*/
    if (OP1REC.XOCCD == "IN" /* order class 'international'*/
     || OP1REC.XOCCD == "AS") /* International Airborne order*/
      set OP0IM001.XWHCD protect; /* protect the warehouse field*/
      set OP0IM001.XOWCD protect; /* protect the owner group field*/
    end
  end


   /* ************************************************************/
   /* divert order processing                   **/
   /* ************************************************************/
   /* the following will protect the warehouse and need date   **/
   /* fields when the order qualifies as a divert order.       **/
   /* ************************************************************/

  if (OP1REC.XDVCD == "02" /* international order*/
   && OP1REC.XOBCD == "F1" /* futures order*/
   && OP1REC.XDSCD == "1"  /* direct ship*/
   && OP1REC.OP1CUNDT < OPAREC.OPACDT) /* implies divert order*/
    set OP0IM001.XWHCD protect; /* protect the warehouse*/
    set OP0IM001.OP0IMNDT protect; /* protect the need date*/
  end

   /* ****************** end divert order processing *************/

   /* reset restart flag*/
  OP0IW01.OP0IWRST = "N";



      /* force segmented converse execution mode*/

  converseVar.segmentedMode = 1;


  converse OP0IM001 ;

     /* ***************************************************/
     /* * hot model eligible cust check*/
     /* ***************************************************/

    /* 08/07/89  bypass hot model logic if promo division*/
              /* or product is not first quality*/

  if (OP1REC.XDVCD == "03" /* if promo*/
   || OPWREC.XQACD != "01") /* or not first quality*/
      /* next sentence         bypass hot model logic*/
  else
    if (SYCREC.OPZHMIND == "Y")
      if (OP0IW01.OP0IWELI == "N"
       && OP0IW01.OP0IWAUT == "N")
        if (converseVar.eventKey is pf24
         || converseVar.eventKey is pf23)
               /* NEXT SENTENCE*/
        else
          converseLib.validationFailed(469);
          exit stack;
        end
      end
    end
  end

      /* **********************************/
      /* * re-set messages and flags*/
      /* **********************************/

  OP0IM001.VAGen_EZEMSG = " "; /* clear error message*/
  OPAREC.OPAERR = "N"; /* no error flag*/


      /* ***********************************************/
      /* * check & process valid pf aid key request*/
      /* ***********************************************/

      /* enter - continue*/
       /* pf 5 - product substitution*/
       /* pf 6 - change size price(s)*/
      /* pf 12 - edit only*/
      /* pf 13 - exit product loop*/
      /* pf 21 - add sizes*/
      /* pf 23 - reject product - skip demand report*/
      /* pf 24 - reject product - report lost demand*/



  if (converseVar.eventKey is enter /* valid pf keys in seq usually used*/
   || converseVar.eventKey is pf12  
   || converseVar.eventKey is pf13  
   || converseVar.eventKey is pf23  
   || converseVar.eventKey is pf24)
    OP0IS62();
  else
    if (converseVar.eventKey is pf21)
      OP0IS30(); /* get full size range*/
    else
      if (converseVar.eventKey is pf6)
        OP0IS61(); /* validate pf 6 chg size price*/
      else
        if (converseVar.eventKey is pf5 /* pf5 is pressed*/
         && OP0IW01.OP0IWPF5 == "Y")    /* pf5 is allowed*/
          OP0IS67(); /* process pf5 product substitution*/
        else
          OP0IS62(); /* re-set mdt's for changed fields*/
          converseLib.validationFailed(008); /* invalid key pressed*/
          OPAREC.OPAERR = "Y"; /* re-show screen*/
          if (converseVar.eventKey is pa1
           || converseVar.eventKey is pa2
           || converseVar.eventKey is pa3)
            if (OP0IW01.OP0IWBDF == "DR") /* rebook draw*/
              set OP0IM001.OP0IMNDT protect;
            else
              set OP0IM001.OP0IMNDT modified;
            end
          end
          exit stack;
        end
      end
    end
  end

      /* ****************************************************/
      /* * bad data base access causes reject of product*/
      /* ****************************************************/

  if (OP0IW01.OP0IWREJ == "Y")
    OP0IS89(); /* common exit to other applic.*/
  end




   /* new process for lost demand entry 11/09/89 rmd*/

   /* cannot report lost demand in review mode if line item*/
   /* is allocated 12/06/89 rmd*/

  if (converseVar.eventKey is pf24) /* report lost demand*/
    if (OPWREC.OPWREVM == 7 /* if in review mode*/
     || OPWREC.OP2LNINB > 0) /* or if product selected*/
      if (OP3REC.OP2LNIST == "AL")
        converseLib.validationFailed(543); /* cannot rept lst demnd for al item on*/
                                   /* order*/
        OPAREC.OPAERR = "Y";
        exit stack;
      else
        if (XOTTBL.XOTDMRPF[OP0IWSBO] == "Y")
          OP0I070(); /* lost demand entry process*/
        end
      end
    else
      if (XOTTBL.XOTDMRPF[OP0IWSBO] == "Y")
        OP0I070(); /* lost demand entry process*/
      end
    end
    OP0IW01.OP0IWP24 = "Y"; /* init pf24 fl*/
    OP0IS63(); /* pf 23, 24 processing*/
  end

  if (converseVar.eventKey is pf23) /* reject product*/
    OP0IS63(); /* pf 23, 24 processing*/
  end




   /* ***********************************************************/

      /* *****************************************************/
      /* * control edits for all fields entered on the map*/
      /* *****************************************************/

     /* *****************************************************/
     /* * map line 19 - five package handling codes & data **/
      /* *****************************************************/

  OP0IW01.OP0IWSBH = 1; /* start at first handling code*/

  if (OP1REC.ZFC-CRCY-CD == " ")
    OP1REC.ZFC-CRCY-CD = "USD";
  end

  while (OP0IW01.OP0IWSBH < 6)
    OP0IW01.OP0IWHTP = " "; /* init ws building area*/
    if (OP0IM001.XHDCD[OP0IWSBH] != " ")
      sysVar.arrayIndex = 1;
      OP0IW01.XHDCD = OP0IM001.XHDCD[OP0IWSBH];
      OP0IW01.XGPCD = OP3REC.XGPCD;
      if (OP0IW01.XHDKEY in XHDTBL.XHDKEY)
        if (OP1REC.ZFC-CRCY-CD
         == XHDTBL.ZFC-CRCY-CD[sysVar.arrayIndex])
          OP0IW01.XHDUCHFL = XHDTBL.XHDUCHFL[sysVar.arrayIndex];
        else
          converseLib.validationFailed(901); /* crcy cd unmatched*/
          OPAREC.OPAERR = "Y";
          set OP0IM001.XHDCD bold, cursor;
          exit stack;
        end
      end
      if (OP3REC.OP2HCHGO[OP0IWSBH] == "Y") /* if charge was overriden*/
        OP0IW01.OP2HCHGO = "*"; /* move '*' to map*/
      end
    end
    OP0IW01.OP0IWSBH = OP0IW01.OP0IWSBH + 1; /* look at next handling code*/
  end

  if (OP1REC.XDZ-DATA-DIST-CD != "CA")
    OP1REC.ZFC-CRCY-CD = " ";
  end
      /* edit 'more sizes' before any other field*/

  if (OP0IM001.OP0IWMOR is modified) /* if 'more sizes' changed*/
    if (OP0IM001.OP0IWMOR == "N") /* only 'n' is valid*/
      OP0IW01.OP0IWMOR = OP0IM001.OP0IWMOR;
      set OP0IM001.OP0IWMOR initialAttributes;
    else
      if (OP0IM001.OP0IWMOR == "Y" /* y is valid on screen 1*/
       && OP0IW01.OP0IWSCR == 1)  
        OP0IW01.OP0IWMOR = OP0IM001.OP0IWMOR;
        set OP0IM001.OP0IWMOR initialAttributes;
      else
        OPAREC.OPAERR = "Y";
        converseLib.validationFailed(165); /* else message-correct response*/
        set OP0IM001.OP0IWMOR cursor, modified, bold;
        OP0IS62(); /* re-set mdt's on chgd flds*/
        exit stack; /* skip other edits*/
      end
    end
  end

  OP0IW01.OP0IWEDT = "F"; /* set full edit*/
  if (OP0IW01.OP0IWMOR == "Y") /* determine amount of editing*/
    if (converseVar.eventKey is enter) /* if no pf key,*/
      OP0IW01.OP0IWEDT = "P"; /* and have more sizes, partial edit*/
    end
  end


      /* now do rest of edits, depending on edit flag*/

  if (OP0IW01.OP0IWEDT == "F") /* if no more sizes to show*/
                                 /* ;   edit full map, btm->top*/
    OP0IS70(); /* control edits of map prod info*/
    OP0IS40(); /* control edits of map size info*/
  else
    OP0IS78(); /* edit need date*/
    OP0IS40(); /* else control edits of map size info*/
  end

      /* ***************************************/
      /* * if found errors, re-show the map*/
      /* ***************************************/

  if (OPAREC.OPAERR == "Y"
   || converseVar.validationMsgNum != 0)
    exit stack;
  end


      /* ************************************************/
      /* * all is good, flow to correct place:*/
      /* * may be-screen 2*/
      /* * or write (add/update) record, then*/
      /* * flo to-start next product (op0i020)*/
      /* *   or  -prod summary (review mode)*/
      /* *   or  -prod header (add mode/enter)*/
      /* *   or  -prod header (accept order #8, add/enter)*/
      /* *   or  -prod summary(phone flow/pf13)*/
      /* *   or  -accept order(form flow/pf13)*/
      /* ************************************************/

  if (converseVar.eventKey is enter /* normal flow*/
   || converseVar.eventKey is pf13) /* or user chose to end prod loop*/
    OP0IS64(); /* scrn 2 or verify/write, flow*/
  end


      /* ****************************************/
      /* * check pf keys for further action*/
      /* ****************************************/

  if (converseVar.eventKey is pf12) /* pf 12 edit only*/
    converseLib.validationFailed(009); /* press enter message*/
    exit stack; /* re-show the screen*/
  end

      /* note - pf 13 checked above, the processing is the same*/
             /* as 'enter', but the flow is different*/


  if (converseVar.eventKey is pf21) /* pf 21 add sizes*/
    OP0IW01.OP0IWP21 = "Y";
    OP0IS65(); /* re-build screen-first to last sz*/
    set OP0IM001.OP3ONOQT[1] cursor; /* set cursor to qty of 1st size req.*/
    exit stack; /* re-show the screen*/
  end

  if (converseVar.eventKey is pf6) /* pf 6 allow size price change*/
    OP0IW01.OP0IWPF6 = "Y";
    OP0IS66(); /* put prices on map*/
    set OP0IM001.OP0IMPAL cursor, normal; /* unprotect data fields*/
    set OP0IM001.OP0IMPAD normal;
    exit stack; /* re-show the screen*/
  end



   /* ***********************************************************/
end // end OP0I060

// enter lost demand
Function OP0I070()





      /* **********************************************/
      /* * init working storage, constants, flags*/
      /* **********************************************/

  OP0IS01(); /* initialize working storage*/

      /* **********************************************/
      /* * init map*/
      /* **********************************************/

  set OP0IM002 initial; /* initialize map*/

  OP0IM002.OPMDT = VGVar.currentShortGregorianDate;

  OP0IM002.OPMRVN = 01; /* revision number*/



   /* build map*/

  OP0ISBM();

      /* ******************************************************/
      /* * converse lost demand entry map*/
      /* ******************************************************/

  while (OP0IW01.OP0IWLDF == "N" /* lost demand not entered*/
   && OP0IW01.OP0IWLDE == "N") /* lost demand fatal error*/
    OP0I080(); /* converse loop*/
  end

   /* **********************************************************/
end // end OP0I070

// converse lost demand map, edit
Function OP0I080()
  converse OP0IM002 ;
   /* reset all map fields to normal*/

  OP0ISRA();

   /* set error flag to 'n'*/
  OP0IW01.OP0IWLDE = "N";



  if (converseVar.eventKey is enter) /* edit/write processing*/
    OP0ISEW();
  else
    if (converseVar.eventKey is pf12) /* edit only*/
      OP0ISEO();
    else
      converseLib.validationFailed(2); /* invalid pfkey*/
    end
  end
end // end OP0I080

// add 1 dollar to price per unit
Function OP0IS-ADD-1-DOLLAR()

  if (OP3REC.SY5PRCUN[OP0IWSBR] != 0) /* price per unit not 0*/
    OP3REC.SY5PRCUN[OP0IWSBR] = OP3REC.SY5PRCUN[OP0IWSBR] +                             OP0IW-PRICING-FACTOR; /* 1 or 0*/
  end

end // end OP0IS-ADD-1-DOLLAR

// check if ord needs def frm blk
Function OP0IS-ADD-BLK-DFLT()
   /* **************************************************************/
   /* * This statement group is added as part of BSSA project. We **/
   /* * have defaulted handling codes, charges, override flags &  **/
   /* * and label codes from customer file. in this sgrp we will  **/
   /* * add handling codes which are on bulk and not on customer  **/
   /* * file to the draw order item.                              **/
   /* **************************************************************/

  sysVar.arrayIndex = 1; /* initialize subscript*/
  while (sysVar.arrayIndex <= 5) /* loop 5 time*/
    if (OP0IW03.XHDCD[sysVar.arrayIndex] != " ") /* valid handling code on blk*/
      OP0IS-ADD-BLK-HND(); /* add bulk handling codes*/
    end
    sysVar.arrayIndex = sysVar.arrayIndex + 1; /* increment subscript*/
  end
end // end OP0IS-ADD-BLK-DFLT

// add bulk handling codes
Function OP0IS-ADD-BLK-HND()
   /* **************************************************************/
   /* * This statement group is added as part of BSSA project. We **/
   /* * have valid handling code on bulk. check if it already     **/
   /* * exists on item. if not on item add it to item.            **/
   /* **************************************************************/

  OP0IW01.OP0IW-HNDL-ON-CST = "N"; /* initialize flag*/
  OP0IW01.OP0IW-BSSA-SUB = 1; /* initialize subscript*/

  while (OP0IW01.OP0IW-BSSA-SUB <= 5) /* loop 5 times*/
    if (OP0IW03.XHDCD[sysVar.arrayIndex] == OP3REC.XHDCD[OP0IW-BSSA-SUB]) /* exists*/
      OP0IW01.OP0IW-HNDL-ON-CST = "Y"; /* set flag*/
      OP0IW01.OP0IW-BSSA-SUB = 5; /* come out of loop*/
    end
    OP0IW01.OP0IW-BSSA-SUB = OP0IW01.OP0IW-BSSA-SUB + 1; /* increment sub*/
  end

  if (OP0IW01.OP0IW-HNDL-ON-CST == "N") /* handling code not on cust*/
    OP0IW01.OP0IW-BSSA-SUB = 1; /* initialize subscript*/
    while (OP0IW01.OP0IW-BSSA-SUB <= 5) /* loop 5 times*/
      if (OP3REC.XHDCD[OP0IW-BSSA-SUB] == " ") /* if empty*/
        OP3REC.XHDCD[OP0IW-BSSA-SUB] = OP0IW03.XHDCD[sysVar.arrayIndex];
        OP3REC.XHDCHG[OP0IW-BSSA-SUB] = OP0IW03.XHDCHG[sysVar.arrayIndex];
        OP3REC.OP2HCHGO[OP0IW-BSSA-SUB] = OP0IW03.OP2HCHGO[sysVar.arrayIndex];
        OP0IW01.OP0IW-SYST-HNDCHG-OVRD = "Y"; /* set hndovrd fl*/
        OP0IW01.OP0IW-BSSA-SUB = 5; /* come out of loop*/
      end /* check for empty*/
      OP0IW01.OP0IW-BSSA-SUB = OP0IW01.OP0IW-BSSA-SUB + 1; /* increment sub*/
    end /* end while*/
  end /* final end*/
end // end OP0IS-ADD-BLK-HND

// edit for trnsmted airborne ord
Function OP0IS-AIRBORNE()
    /* this edit is to determine if an airborne order is being added,*/
     /* and whether or not the airborne transmission for the need date*/
     /* has already been done.*/

     /* first we have to get the last airborne transmission date*/

  if (OP0IW01.OP0IW-VOPPGM-READ != "Y")
    VOPPGM01.XXX-PGM-NBR = "OP1920";
    call "IO6600" ("S ", SQLCA, VOPPGM01) {isNoRefresh = yes, isExternal = yes};

    if (SQLCA.VAGen_SQLCODE == 0)
      OP0IW01.OP0IW-VOPPGM-READ = "Y";
    else
      TA1REC.TA1DBASE = "DORDER";
      TA1REC.TA1TBLVU = "VOPPGM01";
      TA1REC.TA1LOC = "OP0IS-AIRBORNE";
      TA1REC.TA1LOCAT[4] = "IO6600";
      TA1REC.TA1TBLKE = "OP1920";
      XSOPS02();
    end
  end

   /* now perform the airbore checkint stmtgrp.  if need date is on or*/
    /* before the last transmission date, then we have to put out an error*/
    /* to force a need date change*/

  XS0MW01.XS0MWDIV = OP1REC.XDVCD;
  XS0MW01.XS0MWORT = OP1REC.XOTCD;
  XS0MW01.XS0MWDIR = OP1REC.XDSCD;
  XS0MW01.XS0MWCUS = OP1REC.KUCCOID;
  XS0MW01.XS0MWGPC = OP1REC.XGPCD;
  XS0MW01.XS0MWNDT = OP0IW01.OP1CUNDT;

  XS0MS-CHK-AIRBORNE();

  if (XS0MW01.XS0MWABF == "Y") /* changes make a transmitted*/
    OPAREC.OPAERR = "Y"; /* airborne order*/
    XS0MW01.XS0MWABF = "N"; /* reset airborne flag*/
    converseLib.validationFailed(792); /* updates not allowed*/
    set OP0IM001.OP0IMNDT cursor, modified, bold;
  end
end // end OP0IS-AIRBORNE

// CALL AV1750 TO CALC OWNER GRP
Function OP0IS-AV1750-XOW()
   /* THIS STMT GROUP CALLS AV1750 TO CALCULATE THE OWNER GROUP*/

  set AVOREC empty;
  set TAEREC empty;

   /* BUILD THE KEY USING AVOREC*/
  AVOREC.SY1STNBR = OPWREC.SY1STNBR[OP0IWSBP];
  AVOREC.SY2CLRID = OPWREC.SY2CLRID[OP0IWSBP];
  AVOREC.XDMCD = OPWREC.XDMCD[OP0IWSBP];
  AVOREC.AVO-DATE = OP0IW01.OP1CUNDT;
  AVOREC.AVO-OPTION = "O";

  call "AV1750" (AVOREC); /* AVAILABILITY SUB TO CALCULATE XOWCD*/

  if (AVO-RETURN-STATUS == 0)
    OP3REC.XOWCD = AVOREC.XOWCD;
    OP0IM001.XOWCD = AVOREC.XOWCD;
    if (AVOREC.XOWCD == "SM"
     || AVOREC.XOWCD == "MR")
      OP0IW01.OP0IW-BLANK-BULK-ONLY-FL = "Y";
      OP0IW01.OP0IW-XOWCD-FOUND-FL = "Y";
    else
      if (AVOREC.XOWCD != "00")
        OP0IW01.OP0IW-XOWCD-FOUND-FL = "Y";
      else
        converseLib.validationFailed(785);
        OPAREC.OPAERR = "Y";
        set OP0IM001.OP0IMNDT cursor, modified, bold;
      end
    end
  else
    TA1REC.TA1TYPE = "APPL";
    TA1REC.TA1FUNC = "RETN";
    TA1REC.TA1PGMNM = "OP0I ";
    TA1REC.TA1LOC = "OP0IS-AV1750-XOW";
    TA1REC.TA1MAP = "OP0IM001";
    OP0IW01.OP0IW-AVOREC-RTN-STAT = AVOREC.AVO-RETURN-STATUS;
    OP0IW01.OP0IW-AVOREC-XOWCD = AVOREC.XOWCD;
    OP0IW01.OP0IW-AVOREC-SY1STYNBR = AVOREC.SY1STNBR;
    OP0IW01.OP0IW-AVOREC-SY2CLRID = AVOREC.SY2CLRID;
    OP0IW01.OP0IW-AVOREC-XDMCD = AVOREC.XDMCD;
    OP0IW01.OP0IW-AVOREC-OPTION = AVOREC.AVO-OPTION;
    OP0IW01.OP0IWDT1 = OP0IW01.OP1CUNDT;
    OP0IW01.OP0IW-AVOREC-DATE = OP0IW01.OP0IWDT1;
    TA1REC.TA1TBLKE = OP0IW01.OP0IW-AVOREC-ERRDIAG;
    TAEREC.TAEDESC1 = OP0IW01.OP0IW-AVOREC-ERRDIAG;
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.rollback();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
    
    call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes};
    XSPF4();
  end

end // end OP0IS-AV1750-XOW

// CALCULATE THE OWNER GROUP
Function OP0IS-CALC-XOWCD()
   /* THIS STMT GROUP CALCULATES THE OWNER GROUP FOR SCREENED FLYER STYLES*/
   /* IF NONE WAS ENTERED.*/

  OP0IST0(); /* GET THE PROGRAM INDICATOR*/
  OP0IS7I(); /* GET XOWCD BY NEED DATE*/

  if (SQLCA.VAGen_SQLCODE == 0)
    OP0IS7K(); /* VALIDATE OWNER GROUP/STYLE*/
    if (SQLCA.VAGen_SQLCODE == 0) /* VALID XOW/STYLE*/
      OP0IW01.OP0IW-BLANK-BULK-ONLY-FL = AVHREC.AVHBLKFL;
      OP0IW01.OP0IW-XOWCD-FOUND-FL = "Y";
      OP3REC.XOWCD = AVHREC.XOWCD;
      OP0IM001.XOWCD = AVHREC.XOWCD;
    else
      OP0IS-AV1750-XOW();
    end
  else
    if (SQLCA.VAGen_SQLCODE == +100) /* NO VALID XOW/STYLE FOUND*/
      OP0IS-AV1750-XOW();
    end
  end
end // end OP0IS-CALC-XOWCD

// call ob1470 for bk-sesn and mo
Function OP0IS-CALL-OB1470()
      /* ********************************************************/
      /* * 08/12/92 JLoyer #774: booking seasons               **/
      /* ********************************************************/
      /* * call ob1470 to calculate a product's available      **/
      /* * booking season(s) and booking month(s).             **/
      /* ********************************************************/

      /* set up OBSREC (pass record to and from ob1470)*/

  set OBSREC empty;

  OBSREC.OP1PARTN = OP3REC.OP1PARTN; /* op-ord-part-char*/
  OBSREC.OP1CUOID = OP3REC.OP1CUOID; /* op-cust-ord-id*/
  OBSREC.OP1NORID = OP0IW01.OP0IWSBS; /* op-nike-ord-id*/
  OBSREC.OP2LNINB = OPWREC.OP2LNINB; /* op-line-item-nbr*/
  OBSREC.XGPCD = OP1REC.XGPCD; /* xgp-gpc-cd*/
  OBSREC.SY1STNBR = OP3REC.SY1STNBR; /* sy-sty-nbr*/
  OBSREC.SY2CLRID = OP3REC.SY2CLRID; /* sy-colr-cd-id*/
  OBSREC.XDMCD = OP3REC.XDMCD; /* xdm-dim-cd*/
  OBSREC.OP1CUNDT = OP0IW01.OP0IW-OB1470-OP1CUNDT; /* op-cust-need-dt*/
  OBSREC.XOTCD = OP1REC.XOTCD; /* xot-ord-typ-cd*/
  OBSREC.XDVCD = OP1REC.XDVCD; /* xdv-div-cd*/
  OBSREC.XBCCD = OP1REC.XBCCD; /* xbc-brand-cd*/
  OBSREC.XQACD = OP3REC.XQACD; /* xqa-qual-cd*/
  OBSREC.KUCCOID = OP1REC.KUCCOID; /* cu-co-id*/
  OBSREC.KUMSTRID = OP1REC.KUMSTRID; /* cu-stor-id*/
  OBSREC.XNXCD = OP1REC.XNXCD; /* xnx-dept-id-xref*/
  OBSREC.XOTFUTRF = XOTTBL.XOTFUTRF[OP0IWSBO]; /* xottbl futr-fl*/
  OBSREC.XOTSMPLF = XOTTBL.XOTSMPLF[OP0IWSBO]; /* xottbl smpl-fl*/
  OBSREC.OBS-XDZCD = OP1REC.XDZ-DATA-DIST-CD; /* added for Canada 6/95*/
  OBSREC.OBS-SYS-ID = "OP"; /* system id*/


  call "OB1470" (OBSREC) {isNoRefresh = yes, isExternal = yes};

  if (OBSREC.OBS-RETN-CD == "00" /* if single bk-sesn and bk-mo*/
   || OBSREC.OBS-RETN-CD == "01") /* or multiple bk-sesns/bk-mos*/

  else
    OPAREC.OPAERR = "Y"; /* set error flag on*/
    if (OBSREC.OBS-RETN-CD == "02") /* order not eligable for*/
      converseLib.validationFailed(770); /* booking seasons*/
    else
      OP0IW01.OP0IWREJ = "Y"; /* set reject product flag*/
      if (OBSREC.OBS-RETN-CD == "03") /* invalid style*/
        converseLib.validationFailed(131); /**/
      else
        if (OBSREC.OBS-RETN-CD == "04") /* unable to calc bk-sesn*/
          converseLib.validationFailed(771); /* need-date not in XSNTBL*/
        else
          if (OBSREC.OBS-RETN-CD == "05") /* unable to calc bk-sesn*/
            converseLib.validationFailed(772); /* no bk-sesn on XSNTBL*/
          else
            if (OBSREC.OBS-RETN-CD == "06") /* ob1470 table overflow*/
              converseLib.validationFailed(773); /**/
            else
              if (OBSREC.OBS-RETN-CD == "08") /* misc db2 error*/
                converseLib.validationFailed(774); /* (sqlcd ^= 00, +100, -911)*/
              else
                if (OBSREC.OBS-RETN-CD == "09") /* -911 database busy*/
                  converseLib.validationFailed(010); /* database busy msg*/
                else
                  converseLib.validationFailed(775); /* unknown obsrec.retn-cd*/
                end
              end
            end
          end
        end
      end
    end
  end

  if (OBSREC.OBS-RETN-CD == "08") /* misc db2 error*/
    TA1REC.TA1TYPE = "APPL"; /* error type*/
    TA1REC.TA1FUNC = "RETN"; /* termination*/
    TA1REC.TA1PGMNM = "OP0I    "; /* calling pgm name*/
    TA1REC.TA1LOCAT[1] = "OP0IS-CA"; /* statement group*/
    TA1REC.TA1LOCAT[2] = "LL-OB147"; /* statement group*/
    TA1REC.TA1LOCAT[3] = "0 OB1470"; /* statement group/subpgm id*/
    TA1REC.TA1LOCAT[4] = OBSREC.OBS-RETN-CD; /* return-code*/
    TA1REC.TA1MAP = "OP0IM001"; /* map name*/
    TA1REC.TA1DBASE = "        "; /* database name*/
    TA1REC.TA1TBLVU = "        "; /* table view*/
    TA1REC.TA1TBLKE = "        "; /* table key*/
    TA1REC.TA1FYICD = "   "; /* fyi code*/
    TAEREC.TAEDESC1 = "ERROR CALLING OB1470 - OBSREC KEY IS: ";
    OP0IW01.OP0IW-OB1470-ERR-DESC = " "; /* init err-key*/
    OP0IW01.OP0IW-OB1470-OP1PARTN = OBSREC.OP1PARTN; /* part char*/
    OP0IW01.OP0IW-OB1470-DASH-1 = "-"; /* separator*/
    OP0IW01.OP0IW-OB1470-OP1CUOID = OBSREC.OP1CUOID; /* cust ord id*/
    OP0IW01.OP0IW-OB1470-DASH-2 = "-"; /* separator*/
    OP0IW01.OP0IW-OB1470-OP1NORID = OBSREC.OP1NORID; /* nike ord id*/
    OP0IW01.OP0IW-OB1470-DASH-3 = "-"; /* separator*/
    OP0IW01.OP0IW-OB1470-OP2LNINB = OBSREC.OP2LNINB; /* line item nbr*/
    OP0IW01.OP0IW-OB1470-DASH-4 = "-"; /* separator*/
    OP0IW01.OP0IW-OB1470-XGPCD = OBSREC.XGPCD; /* gpc cd*/
    OP0IW01.OP0IW-OB1470-DASH-5 = "-"; /* separator*/
    OP0IW01.OP0IW-OB1470-SY1STNBR = OBSREC.SY1STNBR; /* style*/
    OP0IW01.OP0IW-OB1470-DASH-6 = "-"; /* separator*/
    OP0IW01.OP0IW-OB1470-SY2CLRID = OBSREC.SY2CLRID; /* color*/
    OP0IW01.OP0IW-OB1470-DASH-7 = "-"; /* separator*/
    OP0IW01.OP0IW-OB1470-XDMCD = OBSREC.XDMCD; /* dim cd*/
    OP0IW01.OP0IW-OB1470-DASH-8 = "-"; /* separator*/
    OP0IW01.OP0IW-OB1470-NEED-DT = OBSREC.OP1CUNDT; /* cust need dt*/
    OP0IW01.OP0IW-OB1470-DASH-9 = "-"; /* separator*/
    OP0IW01.OP0IW-OB1470-XOTCD = OBSREC.XOTCD; /* sys order typ*/
    OP0IW01.OP0IW-OB1470-DASH-10 = "-"; /* separator*/
    OP0IW01.OP0IW-OB1470-XDVCD = OBSREC.XDVCD; /* division*/
    TAEREC.TAEDESC2 = OP0IW01.OP0IW-OB1470-ERR-DESC; /* display keys*/
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.rollback();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
     /* back out any chgs*/
    call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* appl retn*/
    COMMAREA.CA-USER-WORKAREA-4K = " "; /* clear user commarea*/
    XSPF4(); /* master menu*/
    exit program; /* master menu failure*/
  end

end // end OP0IS-CALL-OB1470

// CHECK FOR FLYER PROGRAM
Function OP0IS-CHK-FLYER()
   /* THIS STMT GROUP DETERMINES IF THE*/
   /* STYLE IS ON A FLYER PROGRAM. IF ONE*/
   /* ROW IS FOUND ON DAVAIL.VBLNKS01 THEN THE STYLE QUALIFIES AND WE*/
   /* CONTINUE WITH SCREENED STYLE EDITING. IF NO ROWS ARE FOUND THE STYLE*/
   /* IS PROCESSED AS A NON-FLYER STYLE.*/

   /* BUILD KEY FOR READ OF VBLNKS01*/

  set AVHREC empty;
  AVHREC.SY1STNBR = OPWREC.SY1STNBR[OP0IWSBP];
  AVHREC.SY2CLRID = OPWREC.SY2CLRID[OP0IWSBP];
  AVHREC.XDMCD = OPWREC.XDMCD[OP0IWSBP];

  call "IO5470" ("SF", SQLCA, AVHREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0 /* FLYER STYLE FOUND*/
   || SQLCA.VAGen_SQLCODE == -811)
   /* NEXT SENTENCE*/
  else
    if (SQLCA.VAGen_SQLCODE == +100)
      if (OPWREC.XOWCD == " ")
        OPWREC.XOWCD = "00";
      end
    else
      TA1REC.TA1PGMNM = "OP0I ";
      TA1REC.TA1LOC = "OP0IS-CHK-FLYR";
      TA1REC.TA1LOCAT[4] = "IO5470";
      TA1REC.TA1MAP = "OP0IM001";
      TA1REC.TA1DBASE = "DAVAIL";
      TA1REC.TA1TBLVU = "VBLNKS01";
      TA1REC.TA1TBLKE = AVHREC.AVHKEY;
      XSOPS02();
    end
  end

end // end OP0IS-CHK-FLYER

// Check for BSSA products
Function OP0IS-CHK-IF-BSSA()
   /* TT#4752-BSSA Project*/
   /* This statement group is added to read the sum code table and to*/
   /* identify BSSA Products*/

  OP0IW01.OP0IW-BSSA-PRODUCT = "N";
  YSMREC.YSMTBLPF = "XPC"; /* table prefix XPC*/
  YSMREC.YSMSYSPF = "BS"; /* BS system prefix for BSSA Prodcts*/
  YSMREC.YSMSUMID = 1;
  YSMREC.YSMSUMCD = "1";
  YSMREC.YSMSRCVL = SYCREC.XPCCD; /* 1&2 positions of srce code*/
                                  /* is XPC code*/
  call "IO2640" ("S ", SQLCA, YSMREC) {isNoRefresh = yes, isExternal = yes}; /* unique select*/

  if (SQLCA.VAGen_SQLCODE == 0) /* bssa product found*/
    OP0IW01.OP0IW-BSSA-PRODUCT = "Y";
  else
    if (SQLCA.VAGen_SQLCODE == 100) /* bssa product not found*/
        /* next sentence;*/
    else
      TA1REC.TA1LOCAT[1] = "OP0IS-CH";
      TA1REC.TA1LOCAT[2] = "K-IF-BSS";
      TA1REC.TA1LOCAT[3] = "IO2640  ";
      TA1REC.TA1DBASE = "DCORP   ";
      TA1REC.TA1TBLVU = "VSUMCD01";
      TA1REC.TA1TBLKE = YSMREC.YSMGRP;
      XSOPS02(); /* abend*/
    end
  end

end // end OP0IS-CHK-IF-BSSA

// CHECK FOR PROMO OWNER GROUP
Function OP0IS-CHK-PROMO()
   /* THIS STMT GROUP DETERMINES IF THE OWNER GROUP ENTERED IS A NON-FLYER*/
   /* (PROMO) OWNER GROUP.*/
                                  /* THIS IS A NON-FLYER OWNER GROUP IF NO*/
                                   /* ROW IS FOUND ON DAVAIL.VBLAKP01*/

  AVGREC.XOWCD = OP0IM001.XOWCD; /* LOAD THE KEY*/

  call "IO5480" ("S ", SQLCA, AVGREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == +0)
    /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == +100)
      OP0IW01.OP0IW-PROMO-XOWCD-FL = "Y";
    else
      TA1REC.TA1PGMNM = "OP0I ";
      TA1REC.TA1LOC = "OP0IS-CHK-PROMO";
      TA1REC.TA1LOCAT[4] = "IO5480";
      TA1REC.TA1MAP = "OP0IM001";
      TA1REC.TA1DBASE = "DAVAIL";
      TA1REC.TA1TBLVU = "VBLNKP01";
      TA1REC.TA1TBLKE = AVGREC.AVGKEY;
      XSOPS02();
    end
  end

   /* ************************************************************/
end // end OP0IS-CHK-PROMO

// Remove Hang Code
Function OP0IS-DONT-HANG()
  if (OP3REC.XHDCD[1] == "HNG")
    OP3REC.XHDCD[1] = "   ";
  end
  if (OP3REC.XHDCD[2] == "HNG")
    OP3REC.XHDCD[2] = "   ";
  end
  if (OP3REC.XHDCD[3] == "HNG")
    OP3REC.XHDCD[3] = "   ";
  end
  if (OP3REC.XHDCD[4] == "HNG")
    OP3REC.XHDCD[4] = "   ";
  end
  if (OP3REC.XHDCD[5] == "HNG")
    OP3REC.XHDCD[5] = "   ";
  end
end // end OP0IS-DONT-HANG

// edit booking seasons and month
Function OP0IS-EDIT-BK-SESN()

      /* ********************************************************/
      /* * 08/12/92 JLoyer #774 booking seasons                **/
      /* *                                                     **/
      /* * OBSREC contains the valid booking seasons available **/
      /* * for the current product.  if obsrec.retn-cd = '00', **/
      /* * only 1 booking season is available.  If the retn-cd **/
      /* * is '01', there are 2 booking seasons available and  **/
      /* * the user must enter 1 of the 2, or the existing one **/
      /* * must match 1 of the 2 obsrec-bk-sesns available.    **/
      /* ********************************************************/

  set OP0IM001.XBK-BK-SESN-CD initialAttributes; /* askip*/
  set OP0IM001.OP0IM-OP-BK-YR-YY initialAttributes; /* askip*/
  set OP0IM001.OP0IM-OP-BK-MO-MM initialAttributes; /* askip*/

  OP0IW01.OP0IW-BK-SESN-ERR = "N"; /* init bk-sesn-err flag*/


      /* ********************************************************/
      /* * op-bk-mo does not default from the bulk, even when  **/
      /* * we default xbk-bk-sesn-cd and op-bk-yr.  Int'l does **/
      /* * not use op-bk-mo.                                   **/
      /* ********************************************************/

  if (OP0IW01.OP0IW-DEFAULT-BK-SESN == "Y") /* if default bk-sesn*/
    if (OP1REC.XDVCD == "02") /* if NIL order*/
      return; /* no need to edit*/
    else /* else*/
      if (OBSREC.OBS-RETN-CD == "00" /* if single or multi*/
       || OBSREC.OBS-RETN-CD == "01") /* bk-sesns found*/
        OP3REC.OP-BK-MO = OBSREC.OP-BK-MO[1]; /* move 1st bk-mo*/
        OP0IS-MAP-BK-SESN(); /* move to map*/
        return; /* no need to edit*/
      end
    end
  end


      /* ********************************************************/
      /* * Retn-cd '00' means only 1 bk-sesn and bk-mo are     **/
      /* * available, move bk-sesn and bk-mo to op3rec and map.**/
      /* ********************************************************/

  if (OBSREC.OBS-RETN-CD == "00") /* single bk-sesn and mo*/
    OP3REC.XBK-BK-SESN-CD = OBSREC.XBK-BK-SESN-CD[1];
    OP3REC.OP-BK-YR = OBSREC.OP-BK-YR[1];
    OP3REC.OP-BK-MO = OBSREC.OP-BK-MO[1];
    OP0IS-MAP-BK-SESN(); /* move op3rec bk-sesn to map*/
  end


      /* ********************************************************/
      /* * Retn-cd '01' means 2 bk-sesns and bk-mos are        **/
      /* * available, the map must match 1 of the 2 available. **/
      /* * Numeric op-bk-yr must be moved to a character field **/
      /* * for comparison to the map, which is character.      **/
      /* ********************************************************/

  if (OBSREC.OBS-RETN-CD == "01") /* multi bk-sesn available*/
    set OP0IM001.XBK-BK-SESN-CD normal; /* allow entry*/
    set OP0IM001.OP0IM-OP-BK-YR-YY normal; /* allow entry*/
    if (OP0IM001.XBK-BK-SESN-CD == OBSREC.XBK-BK-SESN-CD[1]) /* map=bk-cd(1)*/
      OP0IW01.OP0IW-NUM-1-4 = OBSREC.OP-BK-YR[1];
      OP0IW01.OP0IW-CHA-BK-YY = OP0IW01.OP0IW-NUM-3-4; /* char yy*/
      if (OP0IM001.OP0IM-OP-BK-YR-YY == OP0IW01.OP0IW-CHA-BK-YY) /* yr(1)*/
        OP3REC.XBK-BK-SESN-CD = OBSREC.XBK-BK-SESN-CD[1];
        OP3REC.OP-BK-YR = OBSREC.OP-BK-YR[1];
        OP3REC.OP-BK-MO = OBSREC.OP-BK-MO[1];
        OP0IS-MAP-BK-SESN(); /* display bk-sesns on map*/
      else
        OP0IW01.OP0IW-BK-SESN-ERR = "Y"; /* map yr didn't match yr*/
      end /* for bk-sesn-cd(1)*/
    else
      if (OP0IM001.XBK-BK-SESN-CD == OBSREC.XBK-BK-SESN-CD[2]) /* map=bk-cd(2)*/
        OP0IW01.OP0IW-NUM-1-4 = OBSREC.OP-BK-YR[2]; /* extract last 2*/
        OP0IW01.OP0IW-CHA-BK-YY = OP0IW01.OP0IW-NUM-3-4; /* hold yy*/
        if (OP0IM001.OP0IM-OP-BK-YR-YY == OP0IW01.OP0IW-CHA-BK-YY) /* yr(2)*/
          OP3REC.XBK-BK-SESN-CD = OBSREC.XBK-BK-SESN-CD[2];
          OP3REC.OP-BK-YR = OBSREC.OP-BK-YR[2];
          OP3REC.OP-BK-MO = OBSREC.OP-BK-MO[2];
          OP0IS-MAP-BK-SESN(); /* display bk-sesn on map*/
        else
          OP0IW01.OP0IW-BK-SESN-ERR = "Y"; /* yr didn't match yr*/
        end /* for bk-sesn-cd(2)*/
      else
        OP0IW01.OP0IW-BK-SESN-ERR = "Y"; /* map bk-cd didn't match*/
      end /* either bk-cds in OBSREC*/
    end
  end

  if (OP0IW01.OP0IW-BK-SESN-ERR == "Y") /* bk-sesn error occurred*/
    if (OPAREC.OPAERR == "Y") /* if previous errors exist*/
                                          /* don't overlay msg*/
    else /* else*/
      if (converseVar.validationMsgNum == 0) /* if no prev error msgs*/
        OPAREC.OPAERR = "Y"; /* set error flag*/
        converseLib.validationFailed(777); /* bk-sesn/yr error msg*/
        set OP0IM001.XBK-BK-SESN-CD cursor, modified, bold;
        set OP0IM001.OP0IM-OP-BK-YR-YY modified, bold;
        return;
      end
    end
  else
    OP0IW01.OP0IW-CHECK-BK-SESN = "N"; /* bk-sesn ok, reset flag*/
  end


      /* ********************************************************/
      /* * bk-sesns on International suborders must be the     **/
      /* * on all the items, if changed if review mode update  **/
      /* * the other items under the same suborder.            **/
      /* ********************************************************/

  if (OP0IW01.OP0IW-BK-SESN-ERR == "N") /* if no bk-sesn errors*/
    if (OBSREC.OBS-RETN-CD == "01") /* if multi bk-sesn avail*/
      if (OP1REC.XDVCD == "02") /* if Int'l apparel*/
        if (OPWREC.OPWREVM == 7) /* if review mode*/
          OP0IS-UPDT-NIL-SUB(); /* update bk-sesns*/
        end /* on items under*/
      end /* this suborder.*/
    end
  end


      /* ********************************************************/
      /* * multi-bk-sesn-msg = 'y' means display a map message **/
      /* * to inform users that 2 bk-sesns are available.      **/
      /* * Show this message for new multi bk-sesns and bk-mos.**/
      /* ********************************************************/

  if (OP0IW01.OP0IW-MULTI-BK-SESN-MSG == "Y") /* if we need to disp msg*/
    if (OPAREC.OPAERR == "Y") /* if other errors exist*/
                                           /* don't overlay*/
    else /* else*/
      if (converseVar.validationMsgNum == 0) /* if no prev error msgs*/
        converseLib.validationFailed(776); /* bk-sesn can be 'SP' or 'FA'*/
        OP0IW01.OP0IW-MULTI-BK-SESN-MSG = "N"; /* turn off msg fl*/
      end
    end
  end

end // end OP0IS-EDIT-BK-SESN

// edit label codes
Function OP0IS-EDIT-LABL-CD()


  TA1REC.TA1LOCAT[1] = "OP0IS-ED"; /* location*/
  TA1REC.TA1LOCAT[2] = "IT-LABL-"; /* location*/
  TA1REC.TA1LOCAT[3] = "CD      "; /* location*/

  if (OP0IM001.PWRLBCD[OP0IW-LABL-CD-SUB] == " ") /* labl cd is blank*/
    set OP0IM001.PWRLBCD[OP0IW-LABL-CD-SUB] initialAttributes;
    OP0IM001.PWRLBABR[OP0IW-LABL-CD-SUB] = " "; /* blank out abrv*/
    OP3REC.PWRLBCD[OP0IW-LABL-CD-SUB] = OP0IM001.PWRLBCD[OP0IW-LABL-CD-SUB]; /* valid labl cd*/
  else
    set PWRREC empty; /* initialize pwrrec*/
    PWRREC.PWRLBCD = OP0IM001.PWRLBCD[OP0IW-LABL-CD-SUB]; /* dbase key*/

    call "IO5750" ("S ", SQLCA, PWRREC) {isNoRefresh = yes, isExternal = yes}; /* select unique labl cd*/

    if (SQLCA.VAGen_SQLCODE == +0) /* labl cd found*/
      if (PWRREC.XXXSTAT == "A") /* active labl cd*/
        OP0IM001.PWRLBABR[OP0IW-LABL-CD-SUB] = PWRREC.PWRLBABR; /* fill in labl cd abrv*/
        set OP0IM001.PWRLBABR[OP0IW-LABL-CD-SUB] initialAttributes;
        OP3REC.PWRLBCD[OP0IW-LABL-CD-SUB] = OP0IM001.PWRLBCD[OP0IW-LABL-CD-SUB]; /* valid labl cd*/
      else
        converseLib.validationFailed(716); /* labl cd is inactive*/
        OPAREC.OPAERR = "Y"; /* set error to true*/
        set OP0IM001.PWRLBCD[OP0IW-LABL-CD-SUB] modified, cursor, bold;
        OP0IM001.PWRLBABR[OP0IW-LABL-CD-SUB] = " ";
      end
    else
      if (SQLCA.VAGen_SQLCODE == +100) /* labl cd not found*/
        converseLib.validationFailed(717); /* labl cd not found*/
        OPAREC.OPAERR = "Y"; /* set error to true*/
        set OP0IM001.PWRLBCD[OP0IW-LABL-CD-SUB] modified, cursor, bold;
        OP0IM001.PWRLBABR[OP0IW-LABL-CD-SUB] = " ";
      else
        if (SQLCA.VAGen_SQLCODE == -911)
          converseLib.validationFailed(010); /* database busy, please try again*/
          OPAREC.OPAERR = "Y"; /* set error to true*/
          OP0IM001.PWRLBABR[OP0IW-LABL-CD-SUB] = " ";
          set OP0IM001.PWRLBCD[OP0IW-LABL-CD-SUB] modified; /* force edit*/
        else
          TA1REC.TA1DBASE = "DPICK   "; /* data base name*/
          TA1REC.TA1TBLVU = "VZLABL01"; /* table view*/
          OP0IW01.OP0IW-PWRLBCD[1] = OP0IM001.PWRLBCD[1]; /* labl cd#1*/
          OP0IW01.OP0IW-PWRLBCD[2] = OP0IM001.PWRLBCD[2]; /* labl cd#2*/
          TA1REC.TA1TBLKE = OP0IW01.OP0IW-PWRLBCD-GRP; /* key value*/
          TA1REC.TA1LOCAT[4] = "IO5750"; /* i/o mod*/
          XSOPS02(); /* common abend*/
        end
      end
    end
  end


end // end OP0IS-EDIT-LABL-CD

// move bk-sesn and bk-mo to map
Function OP0IS-MAP-BK-SESN()

      /* ********************************************************/
      /* * Move booking seasons and month to the map.  Only    **/
      /* * display the last two digits of year and month.  If  **/
      /* * the year or month are zeroes, display spaces.       **/
      /* ********************************************************/

  OP0IM001.XBK-BK-SESN-CD = OP3REC.XBK-BK-SESN-CD; /* display*/
                                  /* bk-sesn-cd*/
   /* -----------------------  Y2K OUT BEGIN  ------------------------*/
   /*  */
   /* IF OP3REC.OP-BK-YR = 0;*/
   /* MOVE '  ' TO OP0IM001.OP0IM-OP-BK-YR-YY;*/
   /* ELSE;*/
   /* MOVE OP3REC.OP-BK-YR TO OP0IW01.OP0IW-NUM-1-4;/* display last*/
   /* MOVE OP0IW01.OP0IW-NUM-3-4 TO OP0IM001.OP0IM-OP-BK-YR-YY;/* 2 digits*/
   /* END;*/
   /*  */
   /* ------------------------  Y2K OUT END  -------------------------*/
   /* -----------------------  Y2K IN BEGIN  -------------------------*/
   /*  */
  OP0IW01.OP0IW-NUM-1-4 = OP3REC.OP-BK-YR; /* display last*/
  OP0IM001.OP0IM-OP-BK-YR-YY = OP0IW01.OP0IW-NUM-3-4; /* 2 digits*/

   /*  */
   /* ------------------------  Y2K IN END  --------------------------*/
  if (OP3REC.OP-BK-MO == 0)
    OP0IM001.OP0IM-OP-BK-MO-MM = "  ";
  else
    OP0IW01.OP0IW-NUM-1-4 = OP3REC.OP-BK-MO; /* display last*/
    OP0IM001.OP0IM-OP-BK-MO-MM = OP0IW01.OP0IW-NUM-3-4; /* 2 digits*/
  end
end // end OP0IS-MAP-BK-SESN

// PROCESS FLYER STYLE
Function OP0IS-PROCES-FLYR()
   /* THIS STMT GRP CONTINUES THE EDITING OF A SCREENED PRODUCT*/
   /* THAT IS ON A FLYER PROGRAM*/

  OP0IW01.OP0IW-XOWCD-FOUND-FL = "N"; /* INIT FLAG*/
  OP0IW01.OP0IW-BLANK-BULK-ONLY-FL = "N"; /* INIT FLAG*/

  if (OP0IM001.XOWCD == " " /* NO OWNER GROUP ENTERED*/
   || OP0IM001.XOWCD == "00")
    if (XOTTBL.XOTFUTRF[OP0IWSBO] == "Y") /* FUTURES ORDER*/
      converseLib.validationFailed(784); /* CAN'T ORDER ON FUTURES OT*/
      OPAREC.OPAERR = "Y";
      set OP0IM001.XWHCD cursor, modified, bold;
      return;
    else
      OP0IS-CALC-XOWCD(); /* CALCULATE THE OWNER GROUP*/
    end
  else
    OP0IW01.OP0IW-PROMO-XOWCD-FL = "N"; /* INIT FLAG*/
    OP0IS-CHK-PROMO(); /* CHECK IF PROMO OWNER GROUP*/
    if (OP0IW01.OP0IW-PROMO-XOWCD-FL == "Y") /* THIS IS A PROMO OWNER GROUP*/
      return;
    else /* NOT A PROMO OWNER GROUP*/
      if (XOTTBL.XOTFUTRF[OP0IWSBO] == "Y") /* FUTURES ORDER TYPE*/
        converseLib.validationFailed(784); /* CAN'T ORDER ON FUTURES OT*/
        OPAREC.OPAERR = "Y";
        set OP0IM001.XOWCD cursor, modified, bold;
        return;
      else /* not promo not futures*/
        AVGREC.XOWCD = OP0IM001.XOWCD;
        OP0IS7K(); /* VALIDATE XOWCD/STYLE*/
        if (SQLCA.VAGen_SQLCODE == 0)
          OP0IW01.OP0IW-BLANK-BULK-ONLY-FL = AVHREC.AVHBLKFL;
          OP0IW01.OP0IW-XOWCD-FOUND-FL = "Y";
        else
          converseLib.validationFailed(785); /* SC STYLE NOT AVAIL FOR NEEDDT*/
          OPAREC.OPAERR = "Y";
          set OP0IM001.XOWCD cursor, modified, bold;
          return;
        end
      end
    end
  end


  if (OP0IW01.OP0IW-XOWCD-FOUND-FL == "Y") /* GOOD OWNER GROUP FOUND*/
    if (OP0IW01.OP0IW-BLANK-BULK-ONLY-FL == "Y") /* BLANK BULK ONLY*/
      converseLib.validationFailed(682); /* BLANK BULK ONLY MSG*/
      OPAREC.OPAERR = "Y";
      set OP0IM001.XOWCD cursor, modified, bold;
      return;
    else
      OP0IS7J(); /* CHECK THE CUTOFF TABLE*/
      if (SQLCA.VAGen_SQLCODE == 0)
        if (OECREC.OPJCUTDT < OPAREC.OPACDT) /* if cut-off-date < curr-date*/
          if (COMMAREA.CAUSERID in YOSTBL.XXXUSRID
           && YOSTBL.XXXSTAT[sysVar.arrayIndex] == "A"
           && YOSTBL.YOSNDTFL[sysVar.arrayIndex] == "Y") /* authorized for lateness*/
            if (converseVar.validationMsgNum == 0)
              converseLib.validationFailed(638); /* past cut-off date warning msg*/
            end
          else
            converseLib.validationFailed(679); /* CUTOFF DATE HAS PASSED*/
            OPAREC.OPAERR = "Y";
            set OP0IM001.OP0IMNDT cursor, modified, bold;
            return;
          end
        end
      else
        if (SQLCA.VAGen_SQLCODE == +100)
          converseLib.validationFailed(785);
          OPAREC.OPAERR = "Y";
          set OP0IM001.OP0IMNDT cursor, modified, bold;
          return;
        end
      end
    end
  end



end // end OP0IS-PROCES-FLYR

// round b-grade price to nickel
Function OP0IS-ROUND-BG-PRC()

       /* you are here if the order is international and*/
       /* a b-grade product.  round the product price up*/
       /* to the nickel*/


  OP0IW-SAVE-PRICE-1 = 0;
  OP0IW-SAVE-PRICE-2 = 0;

  OP0IW-SAVE-PRICE-1 = OP3REC.SY5PRCUN[OP0IWSBR] / 5;

  OP0IW-SAVE-PRICE-2 = OP0IW-SAVE-PRICE-1 * 5;

  if (OP3REC.SY5PRCUN[OP0IWSBR] != OP0IW-SAVE-PRICE-2)
    OP0IW-SAVE-PRICE-2 = OP0IW-SAVE-PRICE-2 + .05;
    OP3REC.SY5PRCUN[OP0IWSBR] = OP0IW-SAVE-PRICE-2;
  end


end // end OP0IS-ROUND-BG-PRC

// select dprod.vsyreg01
Function OP0IS-SEL-SY2000()


   /* This statement group added for Canada -- June 2, 1995 --*/

     /* get the product/region record*/

  set SQLCA empty;
  WSY2000.XGP-GPC-CD = SYCREC.XGPCD;
  WSY2000.SY-STY-NBR = SYCREC.SY1STNBR;
  WSY2000.SY-COLR-CD-ID = SYCREC.SY2CLRID;
  WSY2000.XDM-DIM-CD = SYCREC.XDMCD;
  WSY2000.WSY2000-OPTION-CODE = "S ";
  WSY2000.WSY2000-SUB-OPTION-CODE = "O";


  call "SY2000" (WSY2000) {isNoRefresh = yes, isExternal = yes};

  if (WSY2000.WSY2000-RETURN-CODE == "00")
    OP0IW01.OP0IW-WSY2000-FND-FLAG = "Y";

      /* move from wsy2000 to vcolor02*/

    SYCREC.PG1SC4CD = WSY2000.PG-SCHED-SPCLT-CD;
    SYCREC.PG1FCTCD = WSY2000.PG-FCST-CD;
    SYCREC.XSECD = WSY2000.XSE-SESN-CD;
    SYCREC.XSNYR = WSY2000.XSN-SESN-YR-RNG;

    SYCREC.SY2POFBD = WSY2000.SY-PROP-OFFER-BDT;
    SYCREC.SY2POFXD = WSY2000.SY-PROP-OFFER-XDT;
    SYCREC.SY2FOFBD = WSY2000.SY-FUTR-OFFER-BDT;
    SYCREC.SY2FOFXD = WSY2000.SY-FUTR-OFFER-XDT;

    SYCREC.XLCCD1 = WSY2000.XLC-LIFE-CYC-CD[1];
    SYCREC.XLCCD2 = WSY2000.XLC-LIFE-CYC-CD[2];
    SYCREC.XLCCD3 = WSY2000.XLC-LIFE-CYC-CD[3];
    SYCREC.XLCCD4 = WSY2000.XLC-LIFE-CYC-CD[4];

    SYCREC.SY2CEDT1 = WSY2000.SY-LIFE-CYC-EDT[1];
    SYCREC.SY2CEDT2 = WSY2000.SY-LIFE-CYC-EDT[2];
    SYCREC.SY2CEDT3 = WSY2000.SY-LIFE-CYC-EDT[3];
    SYCREC.SY2CEDT4 = WSY2000.SY-LIFE-CYC-EDT[4];

    SYCREC.XPRCD = WSY2000.XPR-PROD-TYP-CD;
    SYCREC.XPLCD = WSY2000.XPL-PROD-LN-CD;
    SYCREC.XPCCD = WSY2000.XPC-PROD-CAT-CD;

    SYCREC.SY2FDSMO = WSY2000.SY-FRST-DOM-SLS-MO;
    SYCREC.SY2PDCMO = WSY2000.SY-PROJ-DOM-CLS-MO;
    SYCREC.SY2SSCIN = WSY2000.SY-SFTY-STKCLS-IND;

    SYCREC.OPZHMIND = WSY2000.OP-HMDL-HOT-FL;
    SYCREC.SY2ALNOR = WSY2000.SY-ALW-NEW-ORD-FL;

    sysVar.arrayIndex = 1;
    while (sysVar.arrayIndex <= 6)
      SYCREC.XWHCD[sysVar.arrayIndex] = WSY2000.XWH-WHSE-CD[sysVar.arrayIndex];
      sysVar.arrayIndex = sysVar.arrayIndex + 1;
    end

    SYCREC.SY2RPRDI = WSY2000.SY-RSTR-XSO-IND;
    SYCREC.SY2BOSWI = WSY2000.SY-BO-SW;
    SYCREC.SY2BOEDT = WSY2000.SY-BO-SW-EDT;

  else
    if (WSY2000.WSY2000-RETURN-CODE == "02")
      OP0IW01.OP0IW-WSY2000-FND-FLAG = "N";
    else
      if (WSY2000.WSY2000-RETURN-CODE == 98) /* data base is busy*/
  /* next sentence*/
      else
        TA1REC.TA1TYPE = "APPL";
        TA1REC.TA1FUNC = "POST";
        TA1REC.TA1PGMNM = "OP0I";
        OP0IW01.OP0IW-WSY2000-GPC-CD = SYCREC.XGPCD;
        OP0IW01.OP0IW-WSY2000-STY-NBR = SYCREC.SY1STNBR;
        OP0IW01.OP0IW-WSY2000-COLR-CD = SYCREC.SY2CLRID;
        OP0IW01.OP0IW-WSY2000-DIM-CD = SYCREC.XDMCD;
        OP0IW01.OP0IW-WSY2000-PROD-REG-CD = WSY2000.XDR-PROD-REG-CD;
        OP0IW01.OP0IW-WSY2000-RETURN-CD = WSY2000.WSY2000-RETURN-CODE;
        TAEREC.TAEDESC1 = OP0IW-WSY2000-POST-1;
        TAEREC.TAEDESC2 = "BAD RETURN CODE FROM SY2000";
        TA1REC.TA1DBASE = "DPROD";
        TA1REC.TA1TBLVU = "SYREG02";
        TA1REC.TA1MAP = "OP0IM001";
        try
          call "TA0020" (TA1REC, TAEREC) {isExternal = yes};
        end
        COMMAREA.CA-USER-WORKAREA-4K = " "; /* on error - clear ws*/
      end
    end
  end
end // end OP0IS-SEL-SY2000

// select the next NIL item
Function OP0IS-SN-NIL-ITM()

       /* *******************************************************/
       /* * select the next item under the NIL suborder.       **/
       /* *******************************************************/


  call "IO0450" ("SN", SQLCA, OP6REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0
   || SQLCA.VAGen_SQLCODE == +100
  )
  else
    TA1REC.TA1TYPE = "DB2 ";
    TA1REC.TA1FUNC = "RETN";
    TA1REC.TA1PGMNM = "OP0I    ";
    TA1REC.TA1LOCAT[1] = "SN      ";
    TA1REC.TA1LOCAT[2] = "SN-NIL- ";
    TA1REC.TA1LOCAT[3] = "IO0450  ";
    OP0IW01.OP0IWNBR = SQLCA.VAGen_SQLCODE;
    TA1REC.TA1LOCAT[4] = OP0IW01.OP0IWNBR;
    TA1REC.TA1MAP = "OP0IM001";
    TA1REC.TA1DBASE = "DORDER  ";
    TA1REC.TA1TBLVU = "VITEM002";
    OP0IW01.OP0IW-OB1470-ERR-DESC = "  ";
    OP0IW01.OP0IW-OB1470-OP1PARTN = OP6REC.OP1PARTN;
    OP0IW01.OP0IW-OB1470-DASH-1 = "-";
    OP0IW01.OP0IW-OB1470-OP1CUOID = OP6REC.OP1CUOID;
    OP0IW01.OP0IW-OB1470-DASH-2 = "-";
    OP0IW01.OP0IW-OB1470-OP1NORID = OP6REC.OP1NORID;
    OP0IW01.OP0IW-OB1470-DASH-3 = "-";
    OP0IW01.OP0IW-OB1470-OP2LNINB = OP6REC.OP2LNINB;
    TA1REC.TA1TBLKE = OP0IW01.OP0IW-OB1470-ERR-DESC;
    TA1REC.TA1FYICD = "   ";
    XSOPS02();
  end

end // end OP0IS-SN-NIL-ITM

// update bk-sesn on NIL item
Function OP0IS-UPDT-NIL-ITM()

       /* *******************************************************/
       /* * update all the items with the bk-sesn from the     **/
       /* * current op3rec.                                    **/
       /* *******************************************************/


  if (OP3REC.OP2LNINB == OP6REC.OP2LNINB) /* don't update the same item*/
                                        /* we're working on*/
  else
    OP6REC.XBK-BK-SESN-CD = OP3REC.XBK-BK-SESN-CD;
    OP6REC.OP-BK-YR = OP3REC.OP-BK-YR;
    call "IO0450" ("U ", SQLCA, OP6REC) {isNoRefresh = yes, isExternal = yes};
    if (SQLCA.VAGen_SQLCODE == 0)
       /* next sentence*/
    else
      TA1REC.TA1TYPE = "DB2 ";
      TA1REC.TA1FUNC = "RETN";
      TA1REC.TA1PGMNM = "OP0I    ";
      TA1REC.TA1LOCAT[1] = "U       ";
      TA1REC.TA1LOCAT[2] = "UPDT-NIL";
      TA1REC.TA1LOCAT[3] = "IO0450  ";
      OP0IW01.OP0IWNBR = SQLCA.VAGen_SQLCODE;
      TA1REC.TA1LOCAT[4] = OP0IW01.OP0IWNBR;
      TA1REC.TA1MAP = "OP0IM001";
      TA1REC.TA1DBASE = "DORDER  ";
      TA1REC.TA1TBLVU = "VITEM002";
      OP0IW01.OP0IW-OB1470-ERR-DESC = "  ";
      OP0IW01.OP0IW-OB1470-OP1PARTN = OP6REC.OP1PARTN;
      OP0IW01.OP0IW-OB1470-DASH-1 = "-";
      OP0IW01.OP0IW-OB1470-OP1CUOID = OP6REC.OP1CUOID;
      OP0IW01.OP0IW-OB1470-DASH-2 = "-";
      OP0IW01.OP0IW-OB1470-OP1NORID = OP6REC.OP1NORID;
      OP0IW01.OP0IW-OB1470-DASH-3 = "-";
      OP0IW01.OP0IW-OB1470-OP2LNINB = OP6REC.OP2LNINB;
      TA1REC.TA1TBLKE = OP0IW01.OP0IW-OB1470-ERR-DESC;
      TA1REC.TA1FYICD = "   ";
      XSOPS02();
    end
  end

end // end OP0IS-UPDT-NIL-ITM

// update bk-sesn on NIL suborder
Function OP0IS-UPDT-NIL-SUB()

       /* *******************************************************/
       /* * update all the items under the current NIL subord  **/
       /* * so that all booking seasons match the first item.  **/
       /* *******************************************************/
       /* * first select the entire suborder                   **/
       /* *******************************************************/


  OP6REC.OP1PARTN = OP3REC.OP1PARTN;
  OP6REC.OP1CUOID = OP3REC.OP1CUOID;
  OP6REC.OP1NORID = OP3REC.OP1NORID;

  call "IO0450" ("SS", SQLCA, OP6REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0
   || SQLCA.VAGen_SQLCODE == +100)
     /* next sentence*/
  else
    TA1REC.TA1TYPE = "DB2 ";
    TA1REC.TA1FUNC = "RETN";
    TA1REC.TA1PGMNM = "OP0I    ";
    TA1REC.TA1LOCAT[1] = "SS      ";
    TA1REC.TA1LOCAT[2] = "UPDT-NIL";
    TA1REC.TA1LOCAT[3] = "IO0450  ";
    OP0IW01.OP0IWNBR = SQLCA.VAGen_SQLCODE;
    TA1REC.TA1LOCAT[4] = OP0IW01.OP0IWNBR;
    TA1REC.TA1MAP = "OP0IM001";
    TA1REC.TA1DBASE = "DORDER  ";
    TA1REC.TA1TBLVU = "VITEM002";
    OP0IW01.OP0IW-OB1470-ERR-DESC = "  ";
    OP0IW01.OP0IW-OB1470-OP1PARTN = OP6REC.OP1PARTN;
    OP0IW01.OP0IW-OB1470-DASH-1 = "-";
    OP0IW01.OP0IW-OB1470-OP1CUOID = OP6REC.OP1CUOID;
    OP0IW01.OP0IW-OB1470-DASH-2 = "-";
    OP0IW01.OP0IW-OB1470-OP1NORID = OP6REC.OP1NORID;
    TA1REC.TA1TBLKE = OP0IW01.OP0IW-OB1470-ERR-DESC;
    TA1REC.TA1FYICD = "   ";
    XSOPS02();
  end


       /* *******************************************************/
       /* * select the first item and begin updating the sub   **/
       /* * until all the items are done.                      **/
       /* *******************************************************/

  OP0IS-SN-NIL-ITM(); /* select the next item*/

  while (SQLCA.VAGen_SQLCODE == 0)
    OP0IS-UPDT-NIL-ITM(); /* update bk-sesns on the item*/
    OP0IS-SN-NIL-ITM(); /* select the next item*/
  end


  call "IO0450" ("CS", SQLCA, OP6REC) {isNoRefresh = yes, isExternal = yes};


  if (OPAREC.OPAERR == "N") /* If no other errors*/
    if (converseVar.validationMsgNum == 0) /* or messages*/
      converseLib.validationFailed(778); /* display all items updated msg*/
    end
  end
end // end OP0IS-UPDT-NIL-SUB

// validate musical size runs
Function OP0IS-VALIDATE-MSR()


    /* this statement group validates the distributed musical size run*/
    /* quantities when the order is a direct ship order and musical size*/
    /* run was requested (op1rec.xpacd = 'MS')*/


   /* Call subprogram to validate the quantities*/

  set OPMZREC empty;

  OPMZREC.XGPCD = OP1REC.XGPCD;
  /* TT#12895-Changes begin -kshiva*/
  OPMZREC.XDSCD = OP1REC.XDSCD;
  /* TT#12895-Changes end -kshiva*/
  OPMZREC.SY1STNBR = OP3REC.SY1STNBR;
  OPMZREC.SY2CLRID = OP3REC.SY2CLRID;
  OPMZREC.XDMCD = OP3REC.XDMCD;
  OPMZREC.OP2TONOQ = OP3REC.OP2TONOQ;

   /* Move qtys to pass record  - qty's were moved from the map to*/
   /* OP3REC in OP0IS47*/

  OPAREC.OPASUB = 1;

  while (OPAREC.OPASUB <= 40)
    OPMZREC.OP3ONOQT[OPASUB] = OP3REC.OP3ONOQT[OPASUB];
    OPAREC.OPASUB = OPAREC.OPASUB + 1;
  end


  call "OP3850" (OPMZREC) {isNoRefresh = yes, isExternal = yes};

  if (OPMZREC.OPMZ-RETURN-CD == 0)
     /* next sentence*/
  else
    if (OPMZREC.OPMZ-RETURN-CD == 1
     || OPMZREC.OPMZ-RETURN-CD == 2
     || OPMZREC.OPMZ-RETURN-CD == 3
     || OPMZREC.OPMZ-RETURN-CD == 4)
      OPAREC.OPAERR = "Y";
      OP0IM001.VAGen_EZEMSG = OPMZREC.OPMZ-RETURN-MSG;
    else
      if (OPMZREC.OPMZ-RETURN-CD == 8)
        OPAREC.OPAERR = "Y";
        converseLib.validationFailed(10);
      else
        if (OPMZREC.OPMZ-RETURN-CD == 7
         || OPMZREC.OPMZ-RETURN-CD == 9)
          OPAREC.OPAERR = "Y";
          TA1REC.TA1TYPE = "APPL";
          TA1REC.TA1FUNC = "RETN";
          TA1REC.TA1PGMNM = "OP0I    ";
          TA1REC.TA1LOCAT[1] = "OP0IS-VA";
          TA1REC.TA1LOCAT[2] = "R-QTYS  ";
          TA1REC.TA1LOCAT[3] = "OP3850  ";
          TA1REC.TA1LOCAT[4] = OPMZREC.OPMZ-RETURN-CD;
          set TAEREC empty;
          OPMZREC.OPMZ-DIAG-KEY = " ";
          OPMZREC.OPMZ-DIAG-CUST-ORD-ID = OP1REC.OP1CUOID;
          OPMZREC.OPMZ-DIAG-NIKE-ORD-ID = OP1REC.OP1NORID;
          OPMZREC.OPMZ-DIAG-GPC-CD = OPMZREC.XGPCD;
          OPMZREC.OPMZ-DIAG-STY-NBR = OPMZREC.SY1STNBR;
          OPMZREC.OPMZ-DIAG-COLR-CD-ID = OPMZREC.SY2CLRID;
          OPMZREC.OPMZ-DIAG-DIM-CD = OPMZREC.XDMCD;
          OPMZREC.OPMZ-DIAG-RETURN-CD = OPMZREC.OPMZ-RETURN-CD;
          OPMZREC.OPMZ-DIAG-LIT1 = "ORD";
          OPMZREC.OPMZ-DIAG-LIT2 = "PRD";
          OPMZREC.OPMZ-DIAG-LIT5 = "RTN";
          TAEREC.TAEDESC1 = OPMZREC.OPMZ-DIAG-KEY;
          TAEREC.TAEDESC2 = OPMZREC.OPMZ-RETURN-MSG;
          VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
          VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
          sysLib.rollback();
          VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
          
          call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes};
          XSPF4();
          exit program;
        end
      end
    end
  end





end // end OP0IS-VALIDATE-MSR

// initialize working stroage
Function OP0IS01()
   /* initialize working storage*/



   /* set application level recs empty where possible*/


  set OPTREC empty; /* dorder.vlost001*/
  set OSEREC empty; /* pass record to edit module*/
  set XX0XW01 empty; /* ws for formatting dates*/



   /* initialize flags*/

  OP0IW01.OP0IWLDF = "N"; /* lost demand entered flag*/
  OP0IW01.OP0IWLDE = "N"; /* lost demand error flag*/



  XX0XS01(); /* get system date and time*/


end // end OP0IS01

// init w-s fields, ord-tp, spgm
Function OP0IS10()



      /* *************************************/
      /* * initialize all working-storages*/
      /* *************************************/

  TA1REC.TA1LOCAT[2] = "OP0IS10"; /* error diag group name*/

      /* **************************/
      /* init opwrec, global w-s*/
      /* **************************/

  if (OPWREC.XWHCD[1] == " ") /* if w-s nike sub-order array empty*/
    OPWREC.XWHCD[1] = OP1REC.XWHCD;
                                   /* set first entry = order header*/
    OPWREC.OP1CUNDT[1] = OP1REC.OP1CUNDT; /* warehouse & needdate*/
    OPAREC.OPASUB = 1;
    while (OPAREC.OPASUB <= 10)
      OPWREC.OPWOPQTF[OPASUB] = "N"; /* init qty flags*/
      OPWREC.OPWRSQTF[OPASUB] = "N";
      OPAREC.OPASUB = OPAREC.OPASUB + 1;
    end
  end


      /* *********************************/
      /* init oparec, temporary w-s*/
      /* *********************************/

  OPAREC.OPASEP1 = "."; /* set customer number separators*/
  OPAREC.OPASEP2 = ".";

  OPAREC.OP1NORID = 0; /* nike sub-ord split to hex*/

  OPAREC.OPACYMD = VGVar.currentShortGregorianDate; /* keep current date*/
  if (OPAREC.OPACYY > 56) /* add correct century*/
    OPAREC.OPACCC = 19;
  else
    OPAREC.OPACCC = 20;
  end

  OPAREC.OPAWCC = OPAREC.OPACCC; /* init century in work date*/


    /* set up time for record updates*/

  OP0IW01.OP0IWTM1 = VGVar.currentFormattedTime; /* change hh:mm:ss to hhmm*/
  OP0IW01.OP0IWTHL = OP0IW01.OP0IWTHF;
  OP0IW01.OP0IWTML = OP0IW01.OP0IWTMF;
  OP0IW01.OP0IWTSL = OP0IW01.OP0IWTSF;



      /* *********************************/
      /* init op0iws, application w-s*/
      /* *********************************/

  OP0IW01.OP0IWSBP = 1; /* start product array at 1*/
  OP0IW01.OP0IWS01 = "-"; /* set product number separators*/
  OP0IW01.OP0IWS02 = "-";
  OP0IW01.OP0IWREJ = "N"; /* no bad db2 access, yet . . .*/
  OP0IW01.OP0IWMSA = "INCORRECT TOTAL QUANTITY "; /* message*/
  OP0IW01.OP0IWMSD = " FOUND - PLEASE CORRECT";

  OP0IS11(); /* build empty size data*/


      /* ************************************************/
      /* get order type table to use to validate sizes*/
      /* ************************************************/

  if (OP1REC.XOTCD in XOTTBL.XOTCD) /* find order type code in table*/
    OP0IW01.OP0IWSBO = sysVar.arrayIndex; /* hold index*/
  else /* else reject product*/
    converseLib.validationFailed(17); /* msg-order type not valid*/
    OP0IW01.OP0IWREJ = "Y";
    OPAREC.OPAERR = "Y";
    exit stack;
  end

  OP0IW01.OP0IWPCT = XOTTBL.XOTPRCVP[OP0IWSBO] / 100;
                                   /* chg price vary to %*/


      /* set-up price effective date, either bookings or ship*/

  if (XOTTBL.XOTPRCDT[OP0IWSBO] == "B")
    OP0IW01.OP0IWPED = OPAREC.OPACDT; /* bookings = today*/
  else
    OP0IW01.OP0IWPED = OP1REC.OP1CUNDT; /* ship = needdate*/
  end


      /* ************************************************/
      /* * if have sales program, get order type record*/
      /* * to use in editing need date*/
      /* ************************************************/

  if (OP1REC.SP1ID != " ") /* have sales pgm, so get rec*/
    SP2REC.SP1ID = OP1REC.SP1ID; /* set up key*/
    SP2REC.XOTCD = OP1REC.XOTCD;
    OP0IS98(); /* db2-get sp2rec spgm order type*/
  end





    /* set bulk/draw flag accordingly (op0iwwbdf)...*/

       /* dc = customer draw*/
       /* dn = nike draw*/
       /* dr = rebook draw*/
       /* ds = smart draw*/
       /* dx = flexible draw*/
       /* bc = customer bulk*/
       /* bn = nike bulk*/
       /* bs = smart bulk*/
       /* bx = flexible bulk*/


  OP0IW01.OP0IWBDF = " ";
  OP0IW01.OP0IWBBD = " "; /* blank bulk draw flag*/

  if (OP1REC.XBDCD in XBDTBL.XBDCD
   && XBDTBL.XXXSTAT[sysVar.arrayIndex] == "A") /* if active*/
    if (XBDTBL.XBDRWOFL[sysVar.arrayIndex] == "Y") /* if draw order*/
      if (XBDTBL.XBDSETFL[sysVar.arrayIndex] == "Y") /* if set-aside*/
        if (XBDTBL.XBDRVRFL[sysVar.arrayIndex] == "Y") /* if rsrvtion required*/
          OP0IW01.OP0IWBDF = "DS"; /* smart draw*/
        else
          OP0IW01.OP0IWBDF = "DX"; /* flexible draw*/
        end
      else
        if (XBDTBL.XBDXRFCD[sysVar.arrayIndex] == "R")
          OP0IW01.OP0IWBDF = "DR"; /* rebook draw*/
        else
          if (OP1REC.XBDCD == "K")
            OP0IW01.OP0IWBDF = "DN";
          else
            OP0IW01.OP0IWBDF = "DC"; /* customer draw*/
          end
          if (OP1REC.XBDCD == "8" /* blank bulk draw*/
           || OP1REC.XBDCD == "F") /* ' finished bulk*/
            OP0IW01.OP0IWBBD = "B"; /* draws from a blank bulk*/
          else
            if (OP1REC.XBDCD == "3") /* finished draw*/
              OP0IW01.OP0IWBBD = "F"; /* draws from a finished bulk*/
            end
          end
        end
      end
    else
      if (XBDTBL.XBDBKOFL[sysVar.arrayIndex] == "Y") /* if bulk order*/
        if (XBDTBL.XBDSETFL[sysVar.arrayIndex] == "Y") /* if set-aside*/
          if (XBDTBL.XBDRVRFL[sysVar.arrayIndex] == "Y") /* if rsrvtion required*/
            OP0IW01.OP0IWBDF = "BS"; /* smart bulk*/
          else
            OP0IW01.OP0IWBDF = "BX"; /* flexible bulk*/
          end
        else
          if (OP1REC.XBDCD == "B")
            OP0IW01.OP0IWBDF = "BB"; /* blank bulk*/
          else
            if (OP1REC.XBDCD == "N")
              OP0IW01.OP0IWBDF = "BN"; /* nike bulk*/
            else
              OP0IW01.OP0IWBDF = "BC"; /* customer bulk*/
            end
          end
        end
      end
    end
  end


      /* ***************************************************/
      /* * 08/12/92 JLoyer log #774: init bk-sesn flags   **/
      /* ***************************************************/

  OP0IW01.OP0IW-BK-SESN-REQUIRED = "N"; /* init to bk-sesn not req'd*/
  OP0IW01.OP0IW-DEFAULT-BK-SESN = "N"; /* init to bk-sesn not defltd*/

  if (OP1REC.XBCCD == "01") /* if nike brand*/
    if (OP1REC.XDVCD == "01") /* if domestic*/
      if (OP1REC.XGPCD == "02" /* if footwear*/
       || OP1REC.XGPCD == "03") /* or apparel*/
        OP0IW01.OP0IW-BK-SESN-REQUIRED = "Y"; /* bk-sesns required*/
      end
    else
      if (OP1REC.XDVCD == "02") /* if International*/
        if (OP1REC.XGPCD == "03") /* if apparel*/
          OP0IW01.OP0IW-BK-SESN-REQUIRED = "Y"; /* bk-sesns required*/
        end
      else
        if (OP1REC.XDVCD == "03") /* If promo*/
          if (OP1REC.XGPCD == "03") /* if apparel*/
            OP0IW01.OP0IW-BK-SESN-REQUIRED = "Y"; /* bk-sesns required*/
          end
        end
      end
    end
  end

  if (OP0IW01.OP0IW-BK-SESN-REQUIRED == "Y") /* if bk-sesn required*/
    if (OP1REC.XGPCD == "03") /* if apparel*/
      if (OP1REC.XDVCD == "01") /* if domestic*/
        if (OP1REC.XBDCD == "5" /* if cust draw*/
         || OP1REC.XBDCD == "8" /* or blank bulk draw*/
         || OP1REC.XBDCD == "3" /* or finished bulk draw*/
         || OP1REC.XBDCD == "K") /* or finished bulk draw*/
          OP0IW01.OP0IW-DEFAULT-BK-SESN = "Y"; /* default bk-sesn*/
        end
      else
        if (OP1REC.XDVCD == "02") /* if international (aprl)*/
          if (OP1REC.XBDCD in XBDTBL.XBDCD /* if xbdcd in xbdtbl*/
           && XBDTBL.XXXSTAT[sysVar.arrayIndex] == "A") /* if active*/
            if (XBDTBL.XBDRWOFL[sysVar.arrayIndex] == "Y") /* if a draw order*/
              OP0IW01.OP0IW-DEFAULT-BK-SESN = "Y"; /* deflt bk-sesn*/
            end
          end
        end
      end
    end
  end


   /* if this is a draw from bulk save the bulk header*/
   /* for use in a later edit*/


  if (OP0IW01.OP0IWBDF == "DC" /* customer draw*/
   || OP0IW01.OP0IWBDF == "DN" /* nike draw*/
   || OP0IW01.OP0IWBDF == "DR" /* rebook draw*/
   || OP0IW01.OP0IWBDF == "DS" /* smart draw*/
   || OP0IW01.OP0IWBDF == "DX") /* flexible draw*/
    OPWREC.OP1GROUP = OP1REC.OP1GROUP; /* save current orhdr*/

    OPAREC.OPAORDN = OP1REC.OP1BLKID; /* load key*/
    OP1REC.OP1PARTN = OPAREC.OP1PARTN; /* load key*/
    OP1REC.OP1CUOID = OP1REC.OP1BLKID; /* load key*/
    OP1REC.OP1NORID = OPWREC.OP1NORID[OP0IWSBP]; /* load key*/

    call "IO0430" ("S ", SQLCA, OP1REC) {isNoRefresh = yes, isExternal = yes};

    if (SQLCA.VAGen_SQLCODE == 0) /* good return*/
       /* next sentence*/
    else
      TA1REC.TA1TYPE = "DB2 ";
      TA1REC.TA1FUNC = "RETN";
      TA1REC.TA1PGMNM = "OP0I    ";
      TA1REC.TA1LOCAT[1] = "S       ";
      TA1REC.TA1LOCAT[2] = "OP0IS10 ";
      TA1REC.TA1LOCAT[3] = "IO0430  ";
      TA1REC.TA1LOCAT[4] = "        ";
      TA1REC.TA1MAP = "OP0IM001";
      TA1REC.TA1DBASE = "OP1REC  ";
      TA1REC.TA1TBLVU = "VORHDR01";
      TA1REC.TA1TBLKE = OP1REC.OP1KEY;
      call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
      COMMAREA.CA-USER-WORKAREA-4K = " "; /* on error clear we*/
      XSPF4();
      exit program;
    end
  end


  if (OP0IW01.OP0IWBDF == "DC" /* IF CUST DRAW*/
   || OP0IW01.OP0IWBDF == "DN" /* or nike draw*/
   || OP0IW01.OP0IWBDF == "DR" /* or rebook draw*/
   || OP0IW01.OP0IWBDF == "DS" /* or smart draw*/
   || OP0IW01.OP0IWBDF == "DX") /* or flexible draw*/
    OP0IW01.OP0IWSND = OP1REC.OP1CUNDT; /* save need date*/
    OP0IW01.OP1DSADT = OP1REC.OP1DSADT;
                                   /* save don't ship before date*/
    OP1REC.OP1GROUP = OPWREC.OP1GROUP; /* roll back in orhdr*/
  end



end // end OP0IS10

// init array group moves in w-s
Function OP0IS11()



      /* ********************************************/
      /* * initialize working-storage*/
      /* * with blanks & zeroes to be used*/
      /* * in group moves to initialize array(s)*/
      /* ********************************************/

  TA1REC.TA1LOCAT[2] = "OP0IS11"; /* error diag group name*/

      /* *********************************************/
      /* initialize 40 sizes and associated fields*/
      /* *********************************************/

  OP0IW01.OP3SZAFL = " "; /* size active flag*/
  OP0IW01.OP2PRCOF = "N"; /* price override flag*/
  OP0IW01.SY5PRCUN = 0; /* price per unit*/
  OP0IW01.OP3ORGQT = 0; /* original quantity*/
  OP0IW01.OP3ONOQT = 0; /* on-order    "*/
  OP0IW01.OP3ALQT = 0; /* allocated   "*/
  OP0IW01.OP3OHRQT = 0; /* on-hand reserved quantity*/
  OP0IW01.OP3WPRQT = 0; /* work-in-process reserved quantity*/
  OP0IW01.OP3SHPQT = 0; /* shipped quantity*/
  OP0IW01.OP3CNLQT = 0; /* cancelled   "*/



end // end OP0IS11

// re-set w-s for next product
Function OP0IS20()


      /* *********************************************************/
      /* * initialize flags for next product (add or review)*/
      /* * get sales pgm product prices, if any*/
      /* * re-set map to empty with original field attributes*/
      /* *********************************************************/



  OP0IW01.OP0IWNXT = "N"; /* no next product in 6 prod aray*/
  OP0IW01.OP0IWCHG = "N"; /* no changes made to reviewed prod*/
  OP0IW01.OP0IWPRC = 0; /* init hold price field*/
  OP0IW01.OP0IWPF6 = "N"; /* pf 6 change size price*/
  OP0IW01.OP0IWP21 = "N"; /* pf 21 add sizes*/
  OP0IW01.OP0IWP24 = "N"; /* pf 24 reject product*/
  OP0IW01.OP0IWP23 = "N"; /* pf 23 reject product*/

  OP0IW01.OP0IWREJ = "N"; /* rejected product*/
  OP0IW01.OP0IWDUP = "N"; /* duplicate product error*/

  OP0IW01.OP0IWVSF = "N"; /* re-set error on first size verify*/
  OP0IW01.OP0IWVSL = "N"; /* re-set error on last  size verify*/

  OP0IW01.OP0IWBAV = "N"; /* use blank availability flag(st3)*/
  OP0IW01.OP0IWESP = "N"; /* re-edit screened products flag*/

  OP0IW01.OP0IWAVX = "Y"; /* move order quantities to screen?*/

  if (OPWREC.XWHCD[1] == " ") /* if w-s nike sub-order array empty*/
    OPWREC.XWHCD[1] = OP1REC.XWHCD; /* set first entry=order header*/
    OPWREC.OP1CUNDT[1] = OP1REC.OP1CUNDT; /* warehouse & needdate*/
  end


   /* -----------------------------------------------------------*/
   /* Set the pointer for the sub-order and set substitution*/
   /* information passed from OP0H.*/
   /* -----------------------------------------------------------*/
  if (COMMAREA.CAFRMSYS == "AV") /* Sub-order and substitution*/
                                   /* info already set in 010 on*/
                                   /* return to OP0I from the*/
                                   /* substitution screens.*/
    COMMAREA.CAFROMAP = " ";

  else
    if (OPWREC.OP2SSTYN[OP0IWSBP] == " ") /* No substitution done in OP0H.*/
      OP0IW01.OP2PRDSF = "N"; /* Reset product substitution flag*/
      OP0IW01.OP0IWSBS = 1; /* Point to default whse & needdate*/
    else
      OP0IW01.OP2PRDSF = "Y"; /* Substitution was done in OP0H.*/
      OP0IW01.OP2SSTYN = OPWREC.OP2SSTYN[OP0IWSBP];
      OP0IW01.OP2SCLCD = OPWREC.OP2SCLCD[OP0IWSBP];
      OP0IW01.OP2SDMCD = OPWREC.OP2SDMCD[OP0IWSBP];


       /* Set up a sub-order if a warehouse for the substitute*/
       /* was selected.*/

      if (OPWREC.OPWSWHCD[OP0IWSBP] != " ")
        OP0IM001.XWHCD = OPWREC.OPWSWHCD[OP0IWSBP];
        OPAREC.OPAWDT = OPWREC.OPWSNDT[OP0IWSBP];
        OP0IS27(); /* Put whse/need date in suborder array*/
      else
        OP0IW01.OP0IWSBS = 1; /* Point to default whse & needdate*/
      end

    end
  end
                                 /* ; set to actual in revu mode*/
  OP0IW01.OP1CUNDT = OPWREC.OP1CUNDT[OP0IWSBS]; /* init w-s need date*/

  OP0IW01.OP0IWCWH = "N"; /* no change to whs*/
  OP0IW01.OP0IWCND = "N"; /* no change to needdate*/
  OP0IW01.OP0IWFTF = "Y"; /* first time through flag for warnings*/
  OP0IW01.OP0IW-MULTI-BK-SESN-MSG = "N"; /* init multi-bk-sesn-msg fl*/
  OP0IW01.OP0IW-CHECK-BK-SESN = "N"; /* init check-bk-sesn flag*/

  OP0IW01.OP0IWSPP = "N"; /* no sales pgm prod prices*/

  OP0IW01.OP0IWSCR = 1; /* start with screen #1*/

  OP0IW01.OP0IWPAD = "N"; /* no edit done, price adjust variance*/
  OP0IW01.OP0IWPAL = "N"; /* no edit done, price 4 all, variance*/
  OP0IW01.OP0IWPSZ = "N"; /* no edit done, size price variance*/
  OP0IW01.OP0IWZPR = "N"; /* flag to force zero price*/

  OP0IW01.OP0IWSZF = 0; /* INIT FIRST SIZE IN RANGE*/

      /* * if have sales program, get product pricing*/

  if (OP1REC.SP1ID != " ")
    OP0IS99(); /* db2-get spgm prod prices, if any*/
  end


      /* * if an international customer, get price type code*/

  if (OP1REC.XDVCD == "02") /* if a nil order*/
    OP0IS6A(); /* get nil price type code*/
  end


      /* init picking transaction*/

  PK1REC.ZZZSDT = OPAREC.OPACDT;
  PK1REC.ZZZSTM = OP0IW01.OP0IWTM3;

  OPIREC.ZZZSDT = OPAREC.OPACDT; /* 7-23-87*/

      /* ********************************************************/
      /* * re-set map to empty with original field attributes*/
      /* ********************************************************/

  set OPPREC empty; /* clear availability record.*/
  set OP0IM001 initial;
  set OP0IM001.OP3ONOQT[1] cursor;



end // end OP0IS20

// edit 1 model warehouse product
Function OP0IS21()



      /* *******************************************************/
      /* there are 6 warehouses on the product record*/
      /* if any is non-blank, there is a warehouse(s)*/
      /* restriction for the product.*/
      /* note-whs may not fill array consecutively, e.g.*/
        /* 1-blank  2-wh1  3-blank  4-wh2  5-blank  6-blank*/
      /* this explains all the fuss with op0iwwhs.*/
      /* note - also checked in warehouse edit*/
      /* *******************************************************/

   /* note: 2 exceptions 1) direct ship orders*/
                      /* 2) order types with either:*/
                          /* a) life cycle of 20 or,*/
                          /* b) quality code of 02 or 03.*/


  TA1REC.TA1LOCAT[2] = "OP0IS21"; /* error diag group name*/

  OP0IW01.OP0IWNWH = "N"; /* set new warehouse flag to no*/


    /* do direct ship first.use ws warehouse required flag.*/

  if (OP0IW01.XDSWHSEF == "Y") /* if whs required, not direct ship*/
     /* next sentence*/
  else
    return;
  end


   /* now check order type quality and life cycle.*/

  if (XOTTBL.XQACD1[OP0IWSBO] == "02"
   || XOTTBL.XQACD1[OP0IWSBO] == "03"
   || XOTTBL.XQACD2[OP0IWSBO] == "02"
   || XOTTBL.XQACD2[OP0IWSBO] == "03"
   || XOTTBL.XQACD3[OP0IWSBO] == "02"
   || XOTTBL.XQACD3[OP0IWSBO] == "03"
   || XOTTBL.XLCCD1[OP0IWSBO] == "20"
   || XOTTBL.XLCCD2[OP0IWSBO] == "20"
   || XOTTBL.XLCCD3[OP0IWSBO] == "20"
   || XOTTBL.XLCCD4[OP0IWSBO] == "20"
   || XOTTBL.XLCCD5[OP0IWSBO] == "20")
    return;
  end


  OPWREC.OP1OWHMF[OP0IWSBS] = "N"; /* init to no restric*/

  sysVar.arrayIndex = 6; /* loop 6 whse*/
  OP0IW01.OP0IWWHS = " "; /* hold first 1 model whs on prod*/

    /* if draw order, use the warehouse code of the bulk*/
    /* regardless of product-warehouse restrictions. 12/18/89*/

  if (OP0IW01.OP0IWBDF != "DC" /* cust draw*/
   && OP0IW01.OP0IWBDF != "DN" /* nike draw*/
   && OP0IW01.OP0IWBDF != "DR" /* rebook draw*/
   && OP0IW01.OP0IWBDF != "DS" /* smart draw*/
   && OP0IW01.OP0IWBDF != "DX") /* flex draw*/
    while (sysVar.arrayIndex > 0)
      if (SYCREC.XWHCD[sysVar.arrayIndex] != " ") /* match to restric whs is ok*/
        if (OPWREC.XWHCD[OP0IWSBS] == SYCREC.XWHCD[sysVar.arrayIndex])
          OPWREC.OP1OWHMF[OP0IWSBS] = "Y";
          return;
        else
          OP0IW01.OP0IWWHS = SYCREC.XWHCD[sysVar.arrayIndex]; /* hold first whs*/
        end
      end
      sysVar.arrayIndex = sysVar.arrayIndex - 1;
    end
  end


  if (OP0IW01.OP0IWWHS == " ") /* no whs restrictions*/
    return;
  end


  OP0IM001.XWHCD = OP0IW01.OP0IWWHS; /* change whse to 1st restric*/
  set OP0IM001.XWHCD bold;
  set OP0IM001.XWHSABRV bold;
  converseLib.validationFailed(164); /* whs changed -- style whs restriction*/
  OPAREC.OPAERR = "Y"; /* warning message*/

  OP0IW01.OP0IWNWH = "Y"; /* set new warehouse flag to yes*/



      /* take the first whs & curr needdate*/
      /* and put into sub-ord tbl(may match).*/
      /* re-set op0iwsbs value*/

  OP0IW01.OP0IWCWH = "Y"; /* set flag for change*/

  OPAREC.OPAWDT = OPWREC.OP1CUNDT[OP0IWSBS]; /* use curr prod needdate*/
   /* use warehouse in map op0im001.xwhcd*/

  OP0IS27(); /* build sub-order array*/

  OP0IW01.OP0IWCWH = "N"; /* re-set flag for change*/

  if (OP0IW01.OP0IWSBS <= 10)
    OPWREC.OP1OWHMF[OP0IWSBS] = "Y"; /* set one-whs model flag*/
  else
    /* move whs & needdate to map to avoid later subscript error*/
    OP0IM001.XWHSABRV = OP0IW01.OP0IWWHS; /* init abbrev to code*/
    if (OP0IW01.OP0IWWHS in XWHTBL.XWHCD)
      OP0IM001.XWHSABRV = XWHTBL.XWHSABRV[sysVar.arrayIndex];
    end
    OPAREC.OPAFYY = OPAREC.OPAWYY;
    OPAREC.OPAFMM = OPAREC.OPAWMM;
    OPAREC.OPAFDD = OPAREC.OPAWDD;
    OP0IM001.OP0IMNDT = OPAREC.OPAFDT;
  end





end // end OP0IS21

// get style/color & color prices
Function OP0IS22()



      /* ********************************************************/
      /* * get price or cost for product*/
      /* ********************************************************/


  TA1REC.TA1LOCAT[2] = "OP0IS22"; /* error diag group name*/


  OP0IW01.OP0IWSTP = 0; /* zero price defaults*/
  OP0IW01.OP0IWCLP = 0; /* default price by style & color*/


      /* ********************************************************/
      /* *  if it's an international apparel or footwear futures*/
      /* *  order whose product is in development, or an international*/
      /* *  apparel sample product in development, the price will*/
      /* *  be zero.  if zero price (from this or from finding*/
      /* *  no international price type code), won't need to get*/
      /* *  the product price.*/
      /* ********************************************************/

  OP0ISGL(); /* get the product's life cycle*/
  if (OP1REC.XDVCD == "02") /* if a nil order*/
    if (OP0IW01.XLCCD == "05") /* and prod is in development*/
      if (OP1REC.XOTCD == "31" /* and footwear futures*/
       || OP1REC.XOTCD == "36" /* or apparel futures*/
       || OP1REC.XOTCD == "49") /* or apparel samples*/
        OP0IW01.OP0IWZPR = "Y"; /* force zero prices*/
      end
    end
  end

  if (OP0IW01.OP0IWZPR == "Y") /* if zero price*/
    return; /* don't need product prices*/
  end

  if (OP1REC.XDVCD == "02") /* if a nil order*/
    if (IVEREC.IVEPCIND == "C") /* if from cost table*/
      OP0IS9H(); /* use product cost for nil price*/
    else /* else*/
      OP0IS9K(); /* use product price for nil price*/
    end
     /* apply price adjustment (default is 0)*/
    if (OP0IW01.OP0IWCLP > 0) /* adjust price by color if one*/
      if (OP0IW01.XAUCD == "33") /* nil independent distributor*/
        OP0IW01.OP0IWIPC = mathLib.round(OP0IW01.OP0IWCLP *                                      VNLXPY01.NL-PRC-COST-PCT / 100, -mathLib.decimals(OP0IW01.OP0IWIPC));
        OP0IW01.OP0IWCLP = OP0IW01.OP0IWCLP + OP0IW01.OP0IWIPC;
      else
        OP0IW01.OP0IWIPC = mathLib.round(OP0IW01.OP0IWCLP * IVEREC.IVEPCPCT / 100, -mathLib.decimals(OP0IW01.OP0IWIPC));
        OP0IW01.OP0IWCLP = OP0IW01.OP0IWCLP + OP0IW01.OP0IWIPC;
      end
    else /* otherwise adjust price by style*/
      if (OP0IW01.XAUCD == "33") /* nil independent distributor*/
        OP0IW01.OP0IWIPC = mathLib.round(OP0IW01.OP0IWSTP *                                      VNLXPY01.NL-PRC-COST-PCT / 100, -mathLib.decimals(OP0IW01.OP0IWIPC));
        OP0IW01.OP0IWSTP = OP0IW01.OP0IWSTP + OP0IW01.OP0IWIPC;
      else
        OP0IW01.OP0IWIPC = mathLib.round(OP0IW01.OP0IWSTP * IVEREC.IVEPCPCT / 100, -mathLib.decimals(OP0IW01.OP0IWIPC));
        OP0IW01.OP0IWSTP = OP0IW01.OP0IWSTP + OP0IW01.OP0IWIPC;
      end
    end
  else
    OP0IS9K(); /* get product price for all other divisions*/
  end


end // end OP0IS22

// edit for product size valid
Function OP0IS23()

  TA1REC.TA1LOCAT[2] = "OP0IS23"; /* error diag group name*/



   /* ----------------------------------------------------*/
   /* if flag = a (allowed) and the product division equals one*/
   /* of the order type's allowable divisions, it's ok*/
   /* else it's an error*/
   /* ----------------------------------------------------*/

  if (SYCREC.XDVCD[OP0IWSBR] != " "
   && XOTTBL.XOTALWDV[OP0IWSBO] == "A")
    if (SYCREC.XDVCD[OP0IWSBR] == XOTTBL.XDVCD1[OP0IWSBO]
     || SYCREC.XDVCD[OP0IWSBR] == XOTTBL.XDVCD2[OP0IWSBO]
     || SYCREC.XDVCD[OP0IWSBR] == XOTTBL.XDVCD3[OP0IWSBO]
     || SYCREC.XDVCD[OP0IWSBR] == XOTTBL.XDVCD4[OP0IWSBO]
     || SYCREC.XDVCD[OP0IWSBR] == XOTTBL.XDVCD5[OP0IWSBO])
       /* next sentence*/
    else
      return; /* division not allowed*/
    end
  end
       /* ----------------------------------------------------*/
       /* if flag = d (disallowed) this order type restricts*/
       /* the divisions listed from the product.  if no match,*/
       /* it's good; if there is a match, it's an error*/
       /* ----------------------------------------------------*/
  if (SYCREC.XDVCD[OP0IWSBR] != " "
   && XOTTBL.XOTALWDV[OP0IWSBO] == "D")
    if (SYCREC.XDVCD[OP0IWSBR] == XOTTBL.XDVCD1[OP0IWSBO]
     || SYCREC.XDVCD[OP0IWSBR] == XOTTBL.XDVCD2[OP0IWSBO]
     || SYCREC.XDVCD[OP0IWSBR] == XOTTBL.XDVCD3[OP0IWSBO]
     || SYCREC.XDVCD[OP0IWSBR] == XOTTBL.XDVCD4[OP0IWSBO]
     || SYCREC.XDVCD[OP0IWSBR] == XOTTBL.XDVCD5[OP0IWSBO])
      return; /* div not allowed*/
    end
  end




  if (XOTTBL.XOTXTRAS[OP0IWSBO] == "Y" /* if order type allows extras*/
   && SYCREC.SY3FRGUT[OP0IWSBR] == "X")
    OP0IW01.OP0IWVSZ = "Y"; /* match, set valid size flag*/
  else
    if (SYCREC.SY3FRGUT[OP0IWSBR] == "F" /* if size is fringe*/
     || SYCREC.SY3FRGUT[OP0IWSBR] == "G") /* or size is gut*/
      OP0IW01.OP0IWVSZ = "Y"; /* match, set valid size flag*/
    end
  end




end // end OP0IS23

// set size price (prod or spgm)
Function OP0IS24()


      /* *******************************************************/
      /* * if sales pgm has product pricing (op0iwspp = y)*/
      /* *   then use it*/
      /* * else*/
      /* * if international footwear or apparel futures order and*/
      /* *   the product is in development (life cycle = 05)*/
      /* *   or the int'l price type code could not be found*/
      /* *     the price is 0*/
      /* * else*/
      /* *   read db2 price by size,*/
      /* **/
      /* *    if price-size code = z:*/
      /* *      read price default for style,color,size*/
      /* *      use price directly into valid size on product*/
      /* *    else*/
      /* *      if color default price ne 0*/
      /* *        use it*/
      /* *      else*/
      /* *        use style default price.*/
      /* **/
      /* **/
      /* * for smart draw, do not recalculate price by instead,*/
      /* * get the price by size from the smart bulk order.*/
      /* *******************************************************/


  OP0IW-PRICING-FACTOR = 0;

  if (OP1REC.XDVCD == "02" /* if nil*/
   && OP3REC.XQACD == "02" /* b-grade product*/
   && OP1REC.XWHCD == "15") /* consol delivery*/
    OP0IW-PRICING-FACTOR = 1; /* for add 1$ to price per unit*/
  end

    /* set up unit of measure conver factor for the order.*/
      /* note - this is new u.o.m., which may eq old u.o.m.*/

  if (OP3REC.XUMCD in XUMTBL.XUMCD)
    OP0IW01.XUMCONVF = XUMTBL.XUMCONVF[sysVar.arrayIndex];
  end



   /* for customer, smart, and rebook draw orders,*/
      /* use the bulk order price unless the order uses*/
      /* international pricing.*/


  if (OP1REC.XDVCD == "02" /* if an int'l order*/
   || OP0IW01.OP0IWBBD == "B")
                                   /* or blank bulk draw (diff $ than bulk)*/
      /* next sentence                ;   don't use bulk price*/
  else /* otherwise*/
    if (OP0IW01.OP0IWBDF == "DC" /* if cust draw or*/
     || OP0IW01.OP0IWBDF == "DN" /* if nike draw or*/
     || OP0IW01.OP0IWBDF == "DS" /* if smart draw*/
     || OP0IW01.OP0IWBDF == "DR") /* if rebook draw*/
   /* ***************** CSP 4.0 Change ***********************************/
   /* *****  Added check for valid size prior to formatting the price*/
   /* *****  on OP3REC. Correct SOC7 Abend. 9/10/93*/
   /* ********************************************************************/
      if (OP0IW03.OP3SZAFL[OP0IWSBR] == "Y") /* check for active size*/
        OP3REC.SY5PRCUN[OP0IWSBR] = OP0IW03.SY5PRCUN[OP0IWSBR];
      else
        OP3REC.SY5PRCUN[OP0IWSBR] = 0; /* move zero to num field*/
      end
      return;
    end
  end



  if (OP0IW01.OP0IWSPP == "Y") /* if sales pgm prices*/
    if (SP5REC.SP5PRCOF[OP0IWSBR] == "S") /* use spgm prices*/
      OP3REC.SY5PRCUN[OP0IWSBR] = SP5REC.SP5SZPR[OP0IWSBR];
    else
      if (SP5REC.SP5PRCOF[OP0IWSBR] == "P") /* or use product prices*/
        if (SYCREC.SY1PRCZS == "Z" /* if might have size price*/
         && IVEREC.IVEPCIND != "C") /* & price not from cost tbl*/
          SY5REC.SY2CLRID = OP3REC.SY2CLRID; /* set up db key color*/
          SY5REC.XDMCD = OP3REC.XDMCD; /* & dimension*/
          SY5REC.SY5SZID = OP0IW01.OP0IWSBR; /* & size*/
          OP0IS97(); /* find size price, if any*/
          if (SQLCA.VAGen_SQLCODE == 0) /* pick out price effec.today*/
            OP0IS28(); /* from 6 possible prices*/
            if (sysVar.arrayIndex < 7) /* adjust price for some nil orders*/
               /* (for domestic the adjustment is 0)*/
              if (OP1REC.XDVCD == "02" /* if international*/
               && OP0IW01.XAUCD == "33") /* nil independent distrib.*/
                OP0IW01.OP0IWIPC = mathLib.round(SY5REC.SY5PRCUN[sysVar.arrayIndex] *                                        VNLXPY01.NL-PRC-COST-PCT / 100, -mathLib.decimals(OP0IW01.OP0IWIPC));
                OP3REC.SY5PRCUN[OP0IWSBR] = SY5REC.SY5PRCUN[sysVar.arrayIndex] + OP0IW01.OP0IWIPC;
              else
                OP0IW01.OP0IWIPC = mathLib.round(SY5REC.SY5PRCUN[sysVar.arrayIndex] * IVEREC.IVEPCPCT / 100, -mathLib.decimals(OP0IW01.OP0IWIPC));
                OP3REC.SY5PRCUN[OP0IWSBR] = SY5REC.SY5PRCUN[sysVar.arrayIndex] + OP0IW01.OP0IWIPC;
              end
            end
          end
        else
          if (OP0IW01.OP0IWCLP != 0) /* or use color default*/
            OP3REC.SY5PRCUN[OP0IWSBR] = OP0IW01.OP0IWCLP;
          else
            OP3REC.SY5PRCUN[OP0IWSBR] = OP0IW01.OP0IWSTP;
          end
        end
      else
        OP0IW01.OP0IWPR1 = SP5REC.SP5SZPR[OP0IWSBR];
        if (SYCREC.SY1PRCZS == "Z" /* if might have size price*/
         && IVEREC.IVEPCIND != "C")
          SY5REC.SY2CLRID = OP3REC.SY2CLRID; /* set up db key color*/
          SY5REC.XDMCD = OP3REC.XDMCD; /* & dimension*/
          SY5REC.SY5SZID = OP0IW01.OP0IWSBR; /* & size*/
          OP0IS97(); /* find size price, if any*/
          if (SQLCA.VAGen_SQLCODE == 0) /* pick out price effec.today*/
            OP0IS28(); /* from 6 possible prices*/
            if (sysVar.arrayIndex < 7) /* adjust price for some nil orders*/
               /* (for domestic the adjustment is 0)*/
              if (OP1REC.XDVCD == "02" /* if international*/
               && OP0IW01.XAUCD == "33") /* nil independent distrib.*/
                OP0IW01.OP0IWIPC = mathLib.round(SY5REC.SY5PRCUN[sysVar.arrayIndex] *                                       VNLXPY01.NL-PRC-COST-PCT / 100, -mathLib.decimals(OP0IW01.OP0IWIPC));
                OP0IW01.OP0IWPR2 = SY5REC.SY5PRCUN[sysVar.arrayIndex] + OP0IW01.OP0IWIPC;
              else
                OP0IW01.OP0IWIPC = mathLib.round(SY5REC.SY5PRCUN[sysVar.arrayIndex] * IVEREC.IVEPCPCT / 100, -mathLib.decimals(OP0IW01.OP0IWIPC));
                OP0IW01.OP0IWPR2 = SY5REC.SY5PRCUN[sysVar.arrayIndex] + OP0IW01.OP0IWIPC;
              end
            end
          end
        else
          if (OP0IW01.OP0IWCLP != 0) /* or use color default*/
            OP0IW01.OP0IWPR2 = OP0IW01.OP0IWCLP;
          else /* or use style default*/
            OP0IW01.OP0IWPR2 = OP0IW01.OP0IWSTP;
          end
        end
        if (OP0IW01.OP0IWPR1 > OP0IW01.OP0IWPR2)
          OP3REC.SY5PRCUN[OP0IWSBR] = OP0IW01.OP0IWPR2;
        else
          OP3REC.SY5PRCUN[OP0IWSBR] = OP0IW01.OP0IWPR1;
        end
      end
    end
  end


  if (OP0IW01.OP0IWSPP == "Y") /* may use sales pgm prices*/
    if (SYCREC.XUMCD != OP3REC.XUMCD) /* if change u.o.m., calc 'each'*/
      if (SYCREC.XUMCD in XUMTBL.XUMCD)
                                   /* set style unit of meas conv factor*/
        OP0IW01.SY5PRCUN = OP3REC.SY5PRCUN[OP0IWSBR];
        OP3REC.SY5PRCUN[OP0IWSBR] = OP0IW01.SY5PRCUN / XUMTBL.XUMCONVF[sysVar.arrayIndex];
      end
       /* convert 'each' to new uom (may be .5, 1, 6, etc)*/
      OP3REC.SY5PRCUN[OP0IWSBR] = OP3REC.SY5PRCUN[OP0IWSBR] * OP0IW01.XUMCONVF;
    end
    OP0IW01.SY5PRCUN = 0;
    OP0IS-ADD-1-DOLLAR(); /* add 1$ to price per unit*/
                                     /* on op3rec.sy5prcun*/

    if (OP1REC.XDVCD == "02" /* international*/
     && OP3REC.XQACD == "02") /* b-grade product*/
      OP0IS-ROUND-BG-PRC(); /* round b-grade price up*/
                                        /* to the nickel*/
    end

    return;
  end


      /* force a zero price for nil footwear or apparel futures*/
      /* orders with in development product*/
      /* or for nil pricing with no price type code found*/

  if (OP0IW01.OP0IWZPR == "Y") /* if flag is set to force 0 price*/
    OP3REC.SY5PRCUN[OP0IWSBR] = 0; /* set price to 0*/
    OP0IW01.SY5PRCUN = 0;
    return;
  end


      /* otherwise, see if there is a price by size*/

  if (SYCREC.SY1PRCZS == "Z" /* if might have size price*/
   && IVEREC.IVEPCIND != "C")
                                   /* and price comes from cost table (nil)*/
    SY5REC.SY2CLRID = OP3REC.SY2CLRID; /* set up db key color*/
    SY5REC.XDMCD = OP3REC.XDMCD; /* & dimension*/
    SY5REC.SY5SZID = OP0IW01.OP0IWSBR; /* & size*/
    OP0IS97(); /* find size price, if any*/
    if (SQLCA.VAGen_SQLCODE == 0) /* pick out price effec.today*/
      OP0IS28(); /* from 6 possible prices*/
      if (sysVar.arrayIndex < 7) /* adjust price for some nil orders*/
         /* (for domestic the adjustment is 0)*/
        if (OP1REC.XDVCD == "02" /* if international*/
         && OP0IW01.XAUCD == "33") /* nil independent distrib.*/
          OP0IW01.OP0IWIPC = mathLib.round(SY5REC.SY5PRCUN[sysVar.arrayIndex] *                                        VNLXPY01.NL-PRC-COST-PCT / 100, -mathLib.decimals(OP0IW01.OP0IWIPC));
          OP3REC.SY5PRCUN[OP0IWSBR] = SY5REC.SY5PRCUN[sysVar.arrayIndex] + OP0IW01.OP0IWIPC;
        else
          OP0IW01.OP0IWIPC = mathLib.round(SY5REC.SY5PRCUN[sysVar.arrayIndex] * IVEREC.IVEPCPCT / 100, -mathLib.decimals(OP0IW01.OP0IWIPC));
          OP3REC.SY5PRCUN[OP0IWSBR] = SY5REC.SY5PRCUN[sysVar.arrayIndex] + OP0IW01.OP0IWIPC;
        end
        if (SYCREC.XUMCD != OP3REC.XUMCD) /* if change u.o.m, calc 'each'*/
          if (SYCREC.XUMCD in XUMTBL.XUMCD) /* old uom*/
            OP0IW01.SY5PRCUN = OP3REC.SY5PRCUN[OP0IWSBR];
            OP3REC.SY5PRCUN[OP0IWSBR] = OP0IW01.SY5PRCUN / XUMTBL.XUMCONVF[sysVar.arrayIndex];
          end
           /* convert 'each' to new uom (may be .5, 1, 6, etc)*/
          OP3REC.SY5PRCUN[OP0IWSBR] = OP3REC.SY5PRCUN[OP0IWSBR] * OP0IW01.XUMCONVF;
        end
        OP0IW01.SY5PRCUN = 0;
        OP0IS-ADD-1-DOLLAR(); /* add 1$ to price per unit*/
                                     /* on op3rec.sy5prcun*/

        if (OP1REC.XDVCD == "02" /* international*/
         && OP3REC.XQACD == "02") /* b-grade product*/
          OP0IS-ROUND-BG-PRC(); /* round b-grade price up*/
                                            /* to the nickel*/
        end
        return;
      end
    end
  end


  if (OP0IW01.OP0IWCLP != 0) /* or use color default*/
    OP3REC.SY5PRCUN[OP0IWSBR] = OP0IW01.OP0IWCLP;
  else /* or use style default*/
    OP3REC.SY5PRCUN[OP0IWSBR] = OP0IW01.OP0IWSTP;
  end


  if (SYCREC.XUMCD != OP3REC.XUMCD) /* if change u.o.m., calc 'each'*/
    if (SYCREC.XUMCD in XUMTBL.XUMCD) /* set style unit of meas conv factor*/
      OP0IW01.SY5PRCUN = OP3REC.SY5PRCUN[OP0IWSBR];
      OP3REC.SY5PRCUN[OP0IWSBR] = OP0IW01.SY5PRCUN / XUMTBL.XUMCONVF[sysVar.arrayIndex];
    end
     /* convert 'each' to new uom (may be .5, 1, 6, etc)*/
    OP3REC.SY5PRCUN[OP0IWSBR] = OP3REC.SY5PRCUN[OP0IWSBR] * OP0IW01.XUMCONVF;
  end


  OP0IW01.SY5PRCUN = 0;


  OP0IS-ADD-1-DOLLAR(); /* add 1$ to price per unit*/
                                 /* on op3rec.sy5prcun*/


  if (OP1REC.XDVCD == "02" /* international*/
   && OP3REC.XQACD == "02") /* b-grade product*/
    OP0IS-ROUND-BG-PRC(); /* round b-grade price up*/
                                      /* to the nickel*/
  end


end // end OP0IS24

// check to set price vary flag
Function OP0IS25()



      /* compare each price against first price,*/
      /* if different, set on price vary flag*/

  TA1REC.TA1LOCAT[2] = "OP0IS25"; /* error diag group name*/


  if (OP0IW01.OP0IWPRC == 0) /* hold first price in record*/
    OP0IW01.OP0IWPRC = OP3REC.SY5PRCUN[OP0IWSBR];
    if (OPWREC.OPWREVM != 7 /* if new product,*/
     && OPWREC.OP2LNINB == 0) /* force avg price=first price*/
      OP3REC.OP2AUPRC = OP3REC.SY5PRCUN[OP0IWSBR];
    end
  else
    if (OP3REC.SY5PRCUN[OP0IWSBR] != OP0IW01.OP0IWPRC)
      OP3REC.OP2PRCVF = "Y";
    end
  end



end // end OP0IS25

// edit for min/max size range
Function OP0IS26()



      /* **************************************************/
      /* * hold min/max in w-s, compare all 40 valid sizes*/
      /* * to min/max to get a full range of sizes*/
      /* * for the product.*/
      /* **************************************************/

  TA1REC.TA1LOCAT[2] = "OP0IS26"; /* error diag group name*/


  if (OP0IW01.OP0IWSZF == 0) /* if first size still zero*/
    OP0IW01.OP0IWSZF = OP0IW01.OP0IWSBR; /* move in first valid size*/
  end

  OP0IW01.OP0IWSZL = OP0IW01.OP0IWSBR;
                                   /* move each valid size to range=last*/
                               /* ;then last one moved=last range*/



end // end OP0IS26

// put whs/needdt in sub-ord aray
Function OP0IS27()



      /* ********************************************************/
      /* * take new warehouse &/or new needdate and put*/
      /* * into nike sub-order array.  check for max. of 10.*/
      /* * new codes may match existing codes.*/
      /* * whs & needdate put in common areas before here*/
      /* ********************************************************/

  TA1REC.TA1LOCAT[2] = "OP0IS27"; /* error diag group name*/


  OPAREC.OPASUB = OP0IW01.OP0IWSBS; /* save orig sub-ord subscript*/
  OP0IW01.OP0IWSBS = 1; /* start array at 1*/

  while (OP0IW01.OP0IWSBS < 11) /* for up to 10 sub-orders,*/
    if (OPWREC.XWHCD[OP0IWSBS] == " " /* if array empty, insert*/
     && OPWREC.OP1CUNDT[OP0IWSBS] == 0)
      OPWREC.XWHCD[OP0IWSBS] = OP0IM001.XWHCD; /* new codes,exit*/

      OPWREC.OP1CUNDT[OP0IWSBS] = OPAREC.OPAWDT;
      return;
    else
      if (OP0IM001.XWHCD == OPWREC.XWHCD[OP0IWSBS] /* if match array,*/
       && OPAREC.OPAWDT == OPWREC.OP1CUNDT[OP0IWSBS]) /* exit*/
        return;
      end
    end
    OP0IW01.OP0IWSBS = OP0IW01.OP0IWSBS + 1;
  end

      /* reached limit of array, send error message*/

  converseLib.validationFailed(174); /* cant change whs/needt*/
  OPAREC.OPAERR = "Y";
  OP0IW01.OP0IWSBS = OPAREC.OPASUB; /* restore orig subscript*/

  if (OP0IW01.OP0IWCND == "Y") /* if need date changed*/
    set OP0IM001.OP0IMNDT cursor, modified, bold;
  end

  if (OP0IW01.OP0IWCWH == "Y") /* if warehouse changed*/
    set OP0IM001.XWHCD cursor, modified, bold;
  end



end // end OP0IS27

// check prod price effective dte
Function OP0IS28()



      /* find current price among 6 possible prices*/
      /* new/future date is first, oldest date is last*/
      /* price effective date is booking or need date,*/
      /* set by order type table in initial w-s.*/

   /* domestic: if no price if found for an effective date, a newer,*/
   /* valid price is used--To cover early shipments.  ssj(6/93)*/
   /* -----------------------------------------------------------------*/
  TA1REC.TA1LOCAT[2] = "OP0IS28"; /* error diag group name*/


  sysVar.arrayIndex = 1; /* check dates ascending seq*/
  OP0IW01.OP0IW-HOLD-EZETST-VAL = 0; /* init.subscript hold*/

  while (sysVar.arrayIndex < 7)

   /* -------(may need this sub.for domestic early offering products.--*/
    if (SY5REC.SY5PCEDT[sysVar.arrayIndex] > 0) /* hold subscript of oldest price*/
      OP0IW01.OP0IW-HOLD-EZETST-VAL = sysVar.arrayIndex;
    end

    if (SY5REC.SY5PCEDT[sysVar.arrayIndex] <= OP0IW01.OP0IWPED /* price effective date*/
     && SY5REC.SY5PCEDT[sysVar.arrayIndex] > 0)                /* found a valid eff.date*/
      return; /* then use ezetst for price*/
    end

    sysVar.arrayIndex = sysVar.arrayIndex + 1;
  end


   /* -- only get here if there is no price effective on date from order.*/
  if (sysVar.arrayIndex == 7) /* no price for effect.date*/
    if (OP1REC.XDVCD == "02") /* international-do not substitute*/
      /* next sentence*/
    else
      if (OP0IW01.OP0IW-HOLD-EZETST-VAL > 0)
        sysVar.arrayIndex = OP0IW01.OP0IW-HOLD-EZETST-VAL; /* use oldest price*/
      end
    end
  end



end // end OP0IS28

// get bulk order prd info
Function OP0IS29()


    /* this routine reads the bulk order item record*/
    /* being drawn from. uses a select unique.*/





  call "IO0440" ("S ", SQLCA, OP0IW02) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
     /* next sentence*/
  else
    TA1REC.TA1TYPE = "DB2 ";
    TA1REC.TA1FUNC = "RETN";
    TA1REC.TA1PGMNM = "OP0I    ";
    TA1REC.TA1LOCAT[1] = "S       ";
    TA1REC.TA1LOCAT[2] = "OP0IS29 ";
    TA1REC.TA1LOCAT[3] = "IO0440  ";
    TA1REC.TA1LOCAT[4] = "        ";
    TA1REC.TA1MAP = "OP0IM001";
    TA1REC.TA1DBASE = "OP2REC  ";
    TA1REC.TA1TBLVU = "VITEM001";
    TA1REC.TA1TBLKE = " "; /* init*/
    OP0IW01.OP0IWPRT = OP0IW02.OP1PARTN;
    OP0IW01.OP0IWCID = OP0IW02.OP1CUOID;
    OP0IW01.OP0IWNID = OP0IW02.OP1NORID;
    OP0IW01.OP0IWLIN = OP0IW02.OP2LNINB;
    TA1REC.TA1TBLKE = OP0IW01.OP0IWIKY;
    call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
    COMMAREA.CA-USER-WORKAREA-4K = " "; /* on error clear we*/
    XSPF4();
    exit program;
  end







   /* now get the size information*/




  OP0IW03.OP2KEY = OP0IW02.OP2KEY;
  OP8REC.OP8TASK = "S ";

  call "DB1000" (OP8REC, OP0IW03, OPBREC) {isNoRefresh = yes, isExternal = yes};

  if (OPBREC.OPBSZRC == 0)
    /* next sentence*/
  else
    TA1REC.TA1TYPE = "DB2 ";
    TA1REC.TA1FUNC = "RETN";
    TA1REC.TA1PGMNM = "OP0I    ";
    TA1REC.TA1LOCAT[1] = "S       ";
    TA1REC.TA1LOCAT[2] = "OP0IS29 ";
    TA1REC.TA1LOCAT[3] = "DB1000  ";
    TA1REC.TA1LOCAT[4] = OPBREC.OPBSZRC;
    TA1REC.TA1MAP = "OP0IM001";
    TA1REC.TA1DBASE = "DORDER  ";
    TA1REC.TA1TBLVU = "VOSIZE01";
    TA1REC.TA1TBLKE = " "; /* init*/
    OP0IW01.OP0IWPRT = OP0IW03.OP1PARTN;
    OP0IW01.OP0IWCID = OP0IW03.OP1CUOID;
    OP0IW01.OP0IWNID = OP0IW03.OP1NORID;
    OP0IW01.OP0IWLIN = OP0IW03.OP2LNINB;
    TA1REC.TA1TBLKE = OP0IW01.OP0IWIKY;
    call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
    COMMAREA.CA-USER-WORKAREA-4K = " "; /* clear ws on error*/
    XSPF4();
    exit program;
  end

   /* Initialize non-existant sizes on the bulk to prevent S0C7's*/
   /* in CSP 4.1 - 10/07/93 - schase*/

  OPAREC.OPASUB2 = 1;
  while (OPAREC.OPASUB2 < 41)
    if (OP0IW03.OP3SZAFL[OPASUB2] != "Y")
      OP0IW03.SY5PRCUN[OPASUB2] = 0;
      OP0IW03.OP3ORGQT[OPASUB2] = 0;
      OP0IW03.OP3ONOQT[OPASUB2] = 0;
      OP0IW03.OP3ALQT[OPASUB2] = 0;
      OP0IW03.OP3OHRQT[OPASUB2] = 0;
      OP0IW03.OP3WPRQT[OPASUB2] = 0;
      OP0IW03.OP3SHPQT[OPASUB2] = 0;
      OP0IW03.OP3CNLQT[OPASUB2] = 0;
    end
    OPAREC.OPASUB2 = OPAREC.OPASUB2 + 1;
  end

   /* now check if new product of different sub-order*/
   /* then previous product. only needs to be done when*/
   /* adding products, exclude review mode.*/

  if (OPWREC.OPWREVM == 7
   || OPWREC.OP2LNINB > 0)
    OP3REC.OP2TONOQ = 0; /* clear for tot quantity edit*/
    return;
  end


   /* EZETST = OP0IWSBP - 1  ;       set prev product index*/

   /* IF EZETST GT 0                  ; if there was a prev prd*/
    /* AND OP0IW02.OP1NORID EQ OPWREC.OP1NORID(EZETST); if equal*/
    /* MOVE 0 TO OP3REC.OP2TONOQ  ;clear for tot quantity edit*/
    /* EZERTN;*/
   /* END ;*/


   /* if got here sub-order changed!!!!!!!!!!!*/

        /* 1. get new bulk header*/
        /* 2. set up for new warehouse.*/
        /* 3. call s27 to position sub-order array.*/

  OPWREC.OP1GROUP = OP1REC.OP1GROUP; /* save current orhdr*/

  OP1REC.OP1CUOID = OP0IW02.OP1CUOID; /* load key*/
  OP1REC.OP1NORID = OP0IW02.OP1NORID; /* load key*/
  OP1REC.OP1PARTN = OP0IW02.OP1PARTN; /* load key*/

  call "IO0430" ("S ", SQLCA, OP1REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0) /* good return*/
     /* next sentence*/
  else
    TA1REC.TA1TYPE = "DB2 ";
    TA1REC.TA1FUNC = "RETN";
    TA1REC.TA1PGMNM = "OP0I    ";
    TA1REC.TA1LOCAT[1] = "S       ";
    TA1REC.TA1LOCAT[2] = "OP0IS29 ";
    TA1REC.TA1LOCAT[3] = "IO0430  ";
    TA1REC.TA1LOCAT[4] = "        ";
    TA1REC.TA1MAP = "OP0IM001";
    TA1REC.TA1DBASE = "OP1REC  ";
    TA1REC.TA1TBLVU = "VORHDR01";
    TA1REC.TA1TBLKE = " "; /* init*/
    OP0IW01.OP0IWPRT = OP0IW02.OP1PARTN;
    OP0IW01.OP0IWCID = OP0IW02.OP1CUOID;
    OP0IW01.OP0IWNID = OP0IW02.OP1NORID;
    TA1REC.TA1TBLKE = OP0IW01.OP0IWIKY;
    call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
    COMMAREA.CA-USER-WORKAREA-4K = " "; /* on error clear we*/
    XSPF4();
    exit program;
  end


   /* got here: use new warehouse. use old sub-ord need date,*/
   /* should be same or real close.*/

  OP0IM001.XWHCD = OP1REC.XWHCD;


  if (OP0IW01.OP0IWBDF == "DC" /* IF CUST DRAW*/
   || OP0IW01.OP0IWBDF == "DR") /* IF rebook DRAW*/
    OP0IW01.OP0IWSND = OP1REC.OP1CUNDT; /* save need date*/
    OP0IW01.OP1DSADT = OP1REC.OP1DSADT;
                                   /* save don't ship before date*/
    OPAREC.OPAWDT = OP1REC.OP1CUNDT; /* use bulk for s27 call*/
  end

  OP1REC.OP1GROUP = OPWREC.OP1GROUP; /* roll back in orhdr*/

  if (OP0IW01.OP0IWBDF == "DS" /* IF smart draw*/
   || OP0IW01.OP0IWBDF == "DN" /* or nike draw*/
   || OP0IW01.OP0IWBDF == "DX" /* or flex draw*/
   || OP0IW01.OP0IWBBD == "B") /* or draw against blank bulk*/
    OP0IW01.OP0IWSND = OP1REC.OP1CUNDT; /* save need date*/
    OP0IW01.OP1DSADT = OP1REC.OP1DSADT;
                                   /* save don't ship before date*/
    OPAREC.OPAWDT = OP1REC.OP1CUNDT; /* use draw for s27 call*/
                               /* ;  may have been change in OP0C*/
                               /* ;  or OP0D for t-shirts*/
  end



  OP0IS27(); /* reset sub-order subscript;*/

  OP0IS21(); /* now check for 1-whse model*/

  if (converseVar.validationMsgNum == 174) /* if sub-order-array full, reject*/
    converseLib.validationFailed(198); /* too many sub-ords, can't add product*/
    OP0IW01.OP0IWREJ = "Y";
    exit stack;
  end


    /* assume product header did edits so not found won't happen*/




  OP3REC.OP2TONOQ = 0; /* clear for tot quantity edit*/




end // end OP0IS29

// default bulk field values
Function OP0IS2B()




   /* this routine carries over certain values from the bulk*/
   /* order to the draw order.  some other fields are initialized*/




  OP3REC.OPRBNOID = OP0IW03.OP1NORID; /* bulk nike order id*/
  OP3REC.XUMCD = OP0IW03.XUMCD; /* unit of measure*/
  OP3REC.XOWCD = OP0IW03.XOWCD; /* owner group code*/
  OP0IM001.XOWCD = OP0IW03.XOWCD;
  OP3REC.OP2PRDSF = OP0IW03.OP2PRDSF; /* prd subst flag*/
  OP3REC.OP2SSTYN = OP0IW03.OP2SSTYN; /* subst style num*/
  OP3REC.OP2SCLCD = OP0IW03.OP2SCLCD; /* subst color code*/
  OP3REC.OP2SDMCD = OP0IW03.OP2SDMCD; /* subst dimen code*/
  OP3REC.OP2SUBQT = OP0IW03.OP2SUBQT; /* subst quantity*/
  OP3REC.OP2CGPCD = OP0IW03.OP2CGPCD; /* co-or gpc code*/
  OP3REC.OP2KSTYF = OP0IW03.OP2KSTYF; /* key style flag*/
  OP3REC.OP2GTSZF = OP0IW03.OP2GTSZF; /* gut size flag*/
  OP3REC.XEGCD = OP0IW03.XEGCD; /* shade code*/
  OP3REC.PC2INSEG = OP0IW03.PC2INSEG; /* spec diff code*/
  OP3REC.XPGCD = OP0IW03.XPGCD; /* package type code*/
  OP3REC.OP2MSCDP = OP0IW03.OP2MSCDP; /* max scale down %*/
  OP3REC.OP2PGRPF = OP0IW03.OP2PGRPF; /* prod grp flag*/
  OP3REC.OP2FSTFL = OP0IW03.OP2FSTFL; /* forescast flag*/
  OP3REC.XQACD = OP0IW03.XQACD; /* quality code*/
  OP3REC.XBRCD = OP0IW03.XBRCD; /* backorder reason code*/
  OP3REC.XDNCD = " "; /* alloc/dealloc rsn code*/
  OP3REC.XRSCD = " "; /* resv/deresv reasn code*/
  OP3REC.OP1ALFDT = 0; /* alloc force dt*/
  OP3REC.XAFCD = " "; /* alloc force code*/

   /* ********************************************************/
   /* 08/12/92 JLoyer Log #774; If we default the draw's   **/
   /* bk-sesns, copy from the bulk (don't default bk-mo).  **/
   /* ********************************************************/

  if (OP0IW01.OP0IW-DEFAULT-BK-SESN == "Y") /* if we default bk-sesns*/
    OP3REC.XBK-BK-SESN-CD = OP0IW03.XBK-BK-SESN-CD; /* bk-sesn-cd*/
    OP3REC.OP-BK-YR = OP0IW03.OP-BK-YR; /* op-bk-yr*/
  end


  if (OP0IW01.OP0IWBDF == "DR") /* rebook draw*/
    if (SYCREC.SY2BOSWI == "N" /* if style says no backorder*/
     && SYCREC.SY2BOEDT <= OPAREC.OPACDT)
      OP3REC.OP1BOFL = SYCREC.SY2BOSWI; /* use it*/
    else
      OP3REC.OP1BOFL = OP1REC.OP1BOFL; /* use draw header flag*/
    end
  else
    OP3REC.OP1BOFL = OP0IW03.OP1BOFL; /* use bulk header flag*/
  end

   /* bssa changes * begin * TT#4752 * following are the new rules **/
   /* handling codes, charges, override flags for non DC will first**/
   /* default from customer file. For draw orders handling codes on**/
   /* bulk and not on the customer will be added to item along will**/
   /* handling charges, override flag. Label codes and pack codes  **/
   /* will always default from customer for non Custmer draws.     **/
   /* After defaulting values BSSA hardcode logic will be applied. **/
   /* Changes will be made in Airspeed and maint to get all systems**/
   /* in sync.                                                     **/

   /* IF OP0IW01.OP0IWBDF NE 'DN';     /* if not a nike draw*/
  if (OP0IW01.OP0IWBDF == "DC") /* if cust draw*/
    /* bssa changes *  end  * TT#4752 *****************************/
    sysVar.arrayIndex = 1;
    while (sysVar.arrayIndex <= 5)
      OP3REC.XHDCD[sysVar.arrayIndex] = OP0IW03.XHDCD[sysVar.arrayIndex]; /* handling code*/
      OP3REC.XHDCHG[sysVar.arrayIndex] = OP0IW03.XHDCHG[sysVar.arrayIndex]; /* charge*/
      OP3REC.OP2HCHGO[sysVar.arrayIndex] = OP0IW03.OP2HCHGO[sysVar.arrayIndex];
      /* bssa changes *  begin * TT#4752 *****************************/
      /* * following is to avoid authorization override for draw ********/
      OP0IW01.OP0IW-SYST-HNDCHG-OVRD = "Y"; /* ovrdn by system*/
      OP0IW01.OP0IW-USER-HNDCHG-OVRD = "N"; /* and not ovrdn by user*/
      /* bssa changes *  end  * TT#4752 *****************************/
      sysVar.arrayIndex = sysVar.arrayIndex + 1;
    end
    OP3REC.PWRLBCD[1] = OP0IW03.PWRLBCD[1];
    OP3REC.PWRLBCD[2] = OP0IW03.PWRLBCD[2];
  else
    OP0IS2C(); /* get defaults from customer*/
    /* bssa changes * begin * TT#4752 * ****************************/
    OP0IS-ADD-BLK-DFLT(); /* add bulk defaults*/
    /* bssa changes *  end  * TT#4752 * ****************************/
  end


  OP3REC.OP2PRCOF = OP0IW03.OP2PRCOF; /* price ovride flag*/
  OP3REC.OP2PRCVF = OP0IW03.OP2PRCVF; /* price variance flag*/

  OP3REC.OP2GBLOF = "N"; /* global orvride flag*/

    /* clear maint flags*/

  sysVar.arrayIndex = 1;
  while (sysVar.arrayIndex < 5)
    OP3REC.XOMCD[sysVar.arrayIndex] = " "; /* maintenance reason code*/
    OP3REC.OP2OMQTY[sysVar.arrayIndex] = 0; /* maint quantity*/
    OP3REC.OP2OMDT[sysVar.arrayIndex] = 0; /* maint date*/
    OP3REC.XMTCD[sysVar.arrayIndex] = " "; /* maint type code*/
    OP3REC.OP1MTREP[sysVar.arrayIndex] = 0; /* maint rep*/
    sysVar.arrayIndex = sysVar.arrayIndex + 1;
  end

  OP3REC.ZZZCHGCT = 0; /* init change count*/

  OP3REC.OP2TDRWQ = 0; /* total draw quantity*/

  OP3REC.OP2TOBKQ = 0; /* orig booked quantity*/

  OPWREC.XUMCD[OP0IWSBP] = OP3REC.XUMCD; /* for later edits*/



end // end OP0IS2B

// get defaults from kufrec
Function OP0IS2C()



      /* *********************************************************/
      /* * this statement group gets the xhdcd, xhdchg, pwrlbcd **/
      /* * from the customer handling exception database        **/
      /* * (kufrec) and adds them to the order header           **/
      /* * As part of BSSA project added logic to move hard code**/
      /* * gpc '03' to fetch handling exception row for cust.   **/
      /* * Business will set up BSSA customers as GPC 03 in this**/
      /* * table. Business said it is OK if all the Apparel ords**/
      /* * gets these defaults. With these changes even though  **/
      /* * BSSA products are equipment they will be handled like**/
      /* * apparel.                                             **/
      /* *********************************************************/




  set KUFREC empty;
  KUFREC.KUCCOID = OP1REC.KUCCOID; /* cust num*/
  KUFREC.KUMSTRID = OP1REC.KUMSTRID; /* store*/
  KUFREC.XNXCD = OP1REC.XNXCD; /* dept*/
   /* bssa changes * begin * TT#4752 * ****************************/
  if (OP0IW01.OP0IW-BSSA-PRODUCT == "Y") /* If BSSA product*/
    KUFREC.XGPCD = "03"; /* gpc code*/
  else
    /* bssa changes * begin * TT#4752 * ****************************/
    KUFREC.XGPCD = OP1REC.XGPCD; /* gpc code*/
  end

  call "IO0200" ("SF", SQLCA, KUFREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0) /* check for good rc*/
    OP3REC.XHDCD[1] = KUFREC.XHDCD[1]; /* handling code*/
    OP3REC.XHDCHG[1] = KUFREC.XHDCHG[1]; /* handling charge*/
    OP3REC.XHDCD[2] = KUFREC.XHDCD[2];
    OP3REC.XHDCHG[2] = KUFREC.XHDCHG[2];
    OP3REC.XHDCD[3] = KUFREC.XHDCD[3];
    OP3REC.XHDCHG[3] = KUFREC.XHDCHG[3];
    OP3REC.XHDCD[4] = KUFREC.XHDCD[4];
    OP3REC.XHDCHG[4] = KUFREC.XHDCHG[4];
    OP3REC.XHDCD[5] = KUFREC.XHDCD[5];
    OP3REC.XHDCHG[5] = KUFREC.XHDCHG[5];
    OP3REC.PWRLBCD[1] = KUFREC.PWRLBCD[1]; /* label code*/
    OP3REC.PWRLBCD[2] = KUFREC.PWRLBCD[2];
    /* bssa changes * begin * TT#4752 * *****************************/
    sysVar.arrayIndex = 1; /* initialize sub*/
    while (sysVar.arrayIndex <= 5) /* loop 5 time*/
      OP3REC.OP2HCHGO[sysVar.arrayIndex] = "N"; /* set to n*/
      sysVar.arrayIndex = sysVar.arrayIndex + 1; /* increment to loop*/
    end /* end while loop*/
    OP1REC.KUFMIXBL = KUFREC.KUFMIXBL; /* allow mix box flag*/
    OP1REC.XPACD = KUFREC.XPACD; /* move pack code to common rec*/
    /* bssa changes *  end  * TT#4752 * *****************************/
  else
    if (SQLCA.VAGen_SQLCODE == 100)
       /* next sentence*/
    else
      TA1REC.TA1DBASE = "DCUST   "; /* data base name*/
      TA1REC.TA1TBLVU = "VHNDLX01"; /* table view*/
      TA1REC.TA1TBLKE = KUFREC.KUFGRP; /* key value*/
      TA1REC.TA1LOCAT[3] = "OP0IS2C "; /* statement group*/
      TA1REC.TA1LOCAT[4] = "IO0200  "; /* i/o mod name*/
      XSOPS02();
    end
  end


   /* *************************************************************/
end // end OP0IS2C

// Check for Hang Code Removal
Function OP0IS2D()


      /* *********************************************************/
      /* * this statement group gets the xhdcd, xhdchg, pwrlbcd **/
      /* * from the customer handling exception database        **/
      /* *********************************************************/


  set KUFREC empty;
  KUFREC.KUCCOID = OP1REC.KUCCOID; /* cust num*/
  KUFREC.KUMSTRID = OP1REC.KUMSTRID; /* store*/
  KUFREC.XNXCD = OP1REC.XNXCD; /* dept*/
  KUFREC.XGPCD = OP1REC.XGPCD; /* gpc code*/

  call "IO0200" ("SF", SQLCA, KUFREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0) /* check for good rc*/
      /* Is the Silhouette code (SYCREC.XSUCD) avail?*/
      /* Is it 14 or 19?*/
      /* Check the first character of the style number (5 or 6)*/
      /* IF X > 499999 and x < 700000*/
    if (SYCREC.XSUCD == "14" || 
    SYCREC.XSUCD == "19" || 
    (OP3REC.SY1STNBR > 499999 && 
    OP3REC.SY1STNBR < 700000))
      OP0IS-DONT-HANG();
    end
  else
    if (SQLCA.VAGen_SQLCODE == 100)
       /* next sentence*/
    else
      TA1REC.TA1DBASE = "DCUST   "; /* data base name*/
      TA1REC.TA1TBLVU = "VHNDLX01"; /* table view*/
      TA1REC.TA1TBLKE = KUFREC.KUFGRP; /* key value*/
      TA1REC.TA1LOCAT[3] = "OP0IS2C "; /* statement group*/
      TA1REC.TA1LOCAT[4] = "IO0200  "; /* i/o mod name*/
      XSOPS02();
    end
  end

end // end OP0IS2D

// get actual size range
Function OP0IS30()



      /* find first & last active sizes,*/
      /* move to requested size range for first prod in array*/

  TA1REC.TA1LOCAT[2] = "OP0IS30"; /* error diag group name*/


  sysVar.arrayIndex = 1;

  while (sysVar.arrayIndex < 41) /* find first active size*/
    if (OP3REC.OP3SZAFL[sysVar.arrayIndex] == "Y")
      OPWREC.OPWRQSZF[OP0IWSBP] = sysVar.arrayIndex;
      sysVar.arrayIndex = 49;
    end
    sysVar.arrayIndex = sysVar.arrayIndex + 1;
  end

  sysVar.arrayIndex = 40;

  while (sysVar.arrayIndex > 0) /* find last active size*/
    if (OP3REC.OP3SZAFL[sysVar.arrayIndex] == "Y")
      OPWREC.OPWRQSZL[OP0IWSBP] = sysVar.arrayIndex;
      sysVar.arrayIndex = 0;
    end
    sysVar.arrayIndex = sysVar.arrayIndex - 1;
  end



end // end OP0IS30

// check production deadline
Function OP0IS32()



   /* ******************************************************/
   /* *if the need date has been modidfied find the*/
   /* * production deadline. find out if today is 30 days*/
   /* * past the deadline. if it is and if this is a*/
   /* *futures type order only authorized persons may*/
   /* *change the need date. t. fox 8/87*/
   /* *****************************************************/



  set TA1REC empty;
  set TA2REC empty;
  set OPJREC empty;
  set SQLCA empty;

  OP0IW01.OP0IWPDO = "N"; /* init prod deadline past 30 days*/
  OP0IW01.OP0IWPDF = "N"; /* init prod deadline found flag*/
  OP0IW01.OP0IWFND = "N"; /* init prod deadline found flag*/
  OP0IW01.OP0IWP20 = "N"; /* init prod deadline past 20 days*/
  OP0IW01.OP0IW-DAYS-PAST-CUTOFF = 0; /* init days past cutoff*/
  OP0IW01.OP0IWPAO = "N"; /* init prod deadline add on flag*/
  if (OP1REC.XOTCD in XOTTBL.XOTCD              /* order type in table*/
   && XOTTBL.XOTFUTRF[sysVar.arrayIndex] == "Y" /* futures/*/
   && OP0IW01.OP0IWBDF != "DC"                  /* exclude draws from edit*/
   && OP0IW01.OP0IWBDF != "DN"                  
   && OP0IW01.OP0IWBDF != "DR"                  
   && OP0IW01.OP0IWBDF != "DS"                  
   && OP0IW01.OP0IWBDF != "DX")                

    OPJREC.XOTCD = OP1REC.XOTCD; /* order type code*/
    OPJREC.XPCCD = SYCREC.XPCCD; /* product cat code*/
    OPJREC.XGACD = SYCREC.XGACD; /* gender age code*/
    OPJREC.SY1STNBR = SYCREC.SY1STNBR; /* product style*/
    OPJREC.SY2CLRID = SYCREC.SY2CLRID; /* product color*/
    OPLREC.OPLSOP = "SF"; /* selection option*/
      /* note - need date is being moved to oplrec in*/
             /* calling satement group - s78 or 050*/

    call "IO2560" (OPLREC, SQLCA, OPJREC) {isNoRefresh = yes, isExternal = yes};

    if (SQLCA.VAGen_SQLCODE == 0) /* record found*/
      OP0IW01.OP0IWPDF = "Y"; /* deadline found*/
      OP0IW01.OP0IWFND = "Y"; /* deadline found*/
      if (OPAREC.OPACDT > OPJREC.OPJCUTDT) /* current date > prod d/l*/
        OP0IW01.OP0IWPDO = "Y";
        OP0IW01.OP0IWPAO = "Y";
        TA2REC.TA2DBDFN = OPJREC.OPJCUTDT; /* move d/l date*/
        TA2REC.TA2DBDTN = OPAREC.OPACDT; /* today's date*/
        TA2REC.TA2DTOPT = "DAYSDIFF";
        TA2REC.TA2GRTYP = "G";

        call "TA0040" (TA2REC) {isNoRefresh = yes, isExternal = yes};

        if (TA2REC.TA2RTNCD == 0)
          OP0IW01.OP0IW-DAYS-PAST-CUTOFF = TA2REC.TA2DBDDN;
          if (TA2REC.TA2DBDDN >= 20)
            OP0IW01.OP0IWP20 = "Y";
            if (TA2REC.TA2DBDDN >= 30)
              if (COMMAREA.CAUSERID in YOSTBL.XXXUSRID
               && YOSTBL.YOSNDTFL[sysVar.arrayIndex] == "Y") /* authorized to change*/
                 /* next sentence*/
              else
                converseLib.validationFailed(206); /* can't add; 30 days past d/l*/
                OPAREC.OPAERR = "Y";
                set OP0IM001.OP0IMNDT cursor, modified, bold;
                return;
              end
            end
          end
        else
          TA1REC.TA1TYPE = "DB2 ";
          TA1REC.TA1PGMNM = "OP0I    ";
          TA1REC.TA1LOCAT[1] = "OP0IS32 ";
          TA1REC.TA1DBASE = "OP3REC  ";
          TA1REC.TA1TBLVU = "VITEM001";
          TA1REC.TA1TBLKE = OP0IW02.OP2KEY;
          COMMAREA.CA-USER-WORKAREA-4K = " ";
          XSPF4();
          exit program;
        end
      end
    else
      TA1REC.TA1TYPE = "DB2";
      TA1REC.TA1FUNC = "POST";
      TA1REC.TA1PGMNM = "OP0I";
      TA1REC.TA1LOCAT[1] = "SF";
      TA1REC.TA1LOCAT[2] = "OP0IS32";
      TA1REC.TA1LOCAT[3] = "IO2560 ";
      TA1REC.TA1LOCAT[4] = " ";
      TA1REC.TA1LOCAT[4] = "OP0IM001";
      TA1REC.TA1DBASE = "DORDER.";
      TA1REC.TA1TBLVU = "VCUTOF01";
      OP0IW01.OP0IWDXT = " ";
      OP0IW01.OP0IWDND = 0;
      OP0IW01.OP0IWDXT = OPJREC.XOTCD; /* display ord type key*/
      OP0IW01.OP0IWDND = OPLREC.OPJCNDTB; /* display need date key*/
      TA1REC.TA1TBLKE = OP0IW01.OP0IWDKY; /* error display key*/
      VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
      VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
      sysLib.rollback();
      VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
      
      call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
      converseLib.validationFailed(404); /* deadline record not found*/
      OP0IW01.OP0IWREJ = "Y"; /* reject product*/
      OPAREC.OPAERR = "Y";
      set OP0IM001.OP0IMNDT cursor, modified, bold;
      exit stack;
    end
  end





   /* *************************************************************/
end // end OP0IS32

// control edits-size.info,top
Function OP0IS40()



      /* *********************************************************/
      /* * control all editing for top half fields on the map*/
      /* * the fields are not edited in reverse order because*/
      /* * the logic became too convoluted (nice word) . . .*/
      /* *********************************************************/

  TA1REC.TA1LOCAT[2] = "OP0IS40"; /* error diag group name*/



      /* edit the entered quantities*/

  OP0IW01.OP0IWSBM = 1; /* start at map column 1*/

  if (OP0IW01.OP0IWSCR == 1) /* start at record -*/
    OP0IW01.OP0IWSBR = OP0IW01.OP0IWSMF; /* first chosen size*/
  else
    OP0IW01.OP0IWSBR = OP0IW01.OP0IWSB2;
                                   /* or screen 2, starting point*/
  end


  if (OP0IW01.OP0IWPF6 == "Y") /* if allowed to change prices*/
    OP0IS42(); /* price edit/update, qty edit*/
  else
    OP0IS43(); /* no price change, qty edit only*/
  end

   /* validate musical size runs when order is direct ship*/

   /* F OP1REC.XPACD = 'MS';*/
    /* OP0IS-MSR-QTYS;*/
   /* ND;*/

   /* validate musical size runs when pack code is 'ms' 07/01/97*/
   /* include cu orders for msr validations             10/23/97*/
  if ((OP1REC.XPACD == "MS" || 
  OP1REC.XPACD == "CU") && 
  OP1REC.XGPCD == "02")
    OP0IS-VALIDATE-MSR();
  end

  if (OP0IM001.OP2TONOQ is modified) /* total requested quantity*/
    OP0IS44();
  end

   /* availability edits*/


  if (OP0IW01.OP0IWDAV == "S") /* if smart draw and not displaying*/
                                   /* avail*/
    if (OP3REC.OP2LNIST == "AL") /* still may be allocated*/
      set OP0IM001.XWHCD protect;
      set OP0IM001.OP0IMNDT protect;
    end
    if (OP3REC.OP2LNIST == "OP" /* if prev open*/
     && OP0IW01.OP0IWALO == "Y") /* but will get allocated*/
      if (OPWREC.OPWREVM == 7 /* or in review mode*/
       || OPWREC.OP2LNINB > 0)
        set OP0IM001.XWHCD protect;
        set OP0IM001.OP0IMNDT protect;
      end
    end
  end


  if (OP0IW01.OP0IWDAV == "N" /* if not displaying availablity*/
   || OP0IW01.OP0IWHAR == "N") /* or don't have avail record*/
    return;
  end


   /* review mode - nothing changed is also a valid exclusion.*/

  if (OPWREC.OPWREVM == 7
   || OPWREC.OP2LNINB > 0)
    if (OP0IW01.OP0IWCHG == "N")
      return;
    end
  end /* m*/




    /* 1.  when displaying availability,*/
        /* calculate allocation flag using sizes with qty*/
        /* calculate latest availability date*/
        /* (based on the quantities  entered, see if any*/
         /* of the sizes has a condition that prevents alloc.*/
         /* if so, set op0iwalo to 'n').*/

    /* 2.  the user may have entered a size that causes the*/
        /* op0iwalo flag to set to 'n', but they just zeroed*/
        /* the restricted size. since the flag (op0iwalo) was*/
        /* off for a while some sizes may have more ordered*/
        /* then is available. thus, if check 1 says no*/
        /* restrictions then recheck all quantities for*/
        /* availability, op0is47.*/


    /* set allocation allowed flag & furthest avail date*/

  OP0IW01.OP0IWAVD = 0;
  OPAREC.OPASUB = 1;
  OP0IW01.OP0IWALO = "Y";

  while (OPAREC.OPASUB <= 40)
    if (OPWREC.OPWREVM == 7 /* if review mode use the increment*/
     || OPWREC.OP2LNINB > 0)
      if (OP0IW01.OP0IWCQT[OPASUB] > 0) /* if qty ordered increased*/
        if (OP0IW01.OP0IWDTN[OPASUB] > OP0IW01.OP0IWAVD)
          OP0IW01.OP0IWAVD = OP0IW01.OP0IWDTN[OPASUB];
        end
      end
    else /* else, use the entire amount*/
      if (OP3REC.OP3ONOQT[OPASUB] > 0) /* if have qty ordered,*/
        if (OP0IW01.OP0IWDTN[OPASUB] > OP0IW01.OP0IWAVD)
          OP0IW01.OP0IWAVD = OP0IW01.OP0IWDTN[OPASUB];
        end
      end
    end
    OPAREC.OPASUB = OPAREC.OPASUB + 1;
  end





  if (OP0IW01.OP0IWALO == "Y"
   /* if no size restictions, re-edit avail*/
   || XOTTBL.XOTDSAVL[OP0IWSBO] == "A")
    OP0IW01.OP0IWSBM = 1; /* start at map column 1*/
    if (OP0IW01.OP0IWSCR == 1) /* start at record*/
      OP0IW01.OP0IWSBR = OP0IW01.OP0IWSMF; /* first chosen size*/
    else
      OP0IW01.OP0IWSBR = OP0IW01.OP0IWSB2; /* or screen 2, starting point*/
    end
    while (OP0IW01.OP0IWSBM < 21
     && OP0IW01.OP0IWSBR < 41
     && OP0IW01.OP0IWSBR <= OP0IW01.OP0IWSML)
      if (OP3REC.OP3SZAFL[OP0IWSBR] == "Y")
        if (OP3REC.OP3ONOQT[OP0IWSBR] > 0)
          if (OPWREC.OPWREVM == 7 /* then if review mode*/
           || OPWREC.OP2LNINB > 0)
             /* edit qty change*/
            if (OP0IW01.OP0IWCQT[OP0IWSBR] > OP0IM001.OP0IMAVL[OP0IWSBM])
              converseLib.validationFailed(385); /* not enough available*/
              OPAREC.OPAERR = "Y";
              set OP0IM001.OP3ONOQT[OP0IWSBM] cursor, modified, bold;
            end
          else /* not review mode*/
             /* edit total qty*/
            if (OP0IM001.OP3ONOQT[OP0IWSBM] > OP0IM001.OP0IMAVL[OP0IWSBM])
              converseLib.validationFailed(385); /* not enough available*/
              OPAREC.OPAERR = "Y";
              set OP0IM001.OP3ONOQT[OP0IWSBM] cursor, modified, bold;
            end
          end
        end
        OP0IW01.OP0IWSBM = OP0IW01.OP0IWSBM + 1;
        OP0IW01.OP0IWSBR = OP0IW01.OP0IWSBR + 1;
      else
        OP0IW01.OP0IWSBR = OP0IW01.OP0IWSBR + 1;
      end
    end
  end




   /* if we have an availability record*/
    /* if op0iwavd greater then 0, or need date changed*/
   /* *** do this test if chg needdate or chg qty ****/
           /* reset cursor position*/
           /* edit need date to furthest avail date*/
         /* end*/


  if (OP0IW01.OP0IWDAV == "Y" /* displaying availability*/
   && OP0IW01.OP0IWHAR == "Y")
    if (OP0IW01.OP0IWAVD > 0)
      if (OP0IM001.OP2TONOQ is modified) /* reset cursor position*/
        set OP0IM001.OP2TONOQ cursor;
      else
        set OP0IM001.OP3ONOQT[1] cursor;
      end
      OP0IS4B();
      if (OPAREC.OPAERR == "Y")
        return;
      end
    end
  end

           /* can't push need date past offer date*/

  if (OPWREC.OPWREVM == 7 /* already ok'd date in OP0I original*/
   || OPWREC.OP2LNINB > 0)
     /* next sentence*/
  else
    if (XOTTBL.XOTATONF[OP0IWSBO] == "Y")
      if (OP0IW01.OP0IWAVD == 0) /* no need to push for availability*/
        if (OP0IW01.OP1CUNDT > OP1REC.OP1CUNDT)
          if (OP0IW01.OP1CUNDT > SYCREC.SY2POFBD)
            OPAREC.OPAERR = "Y";
            converseLib.validationFailed(443); /* nd dt must meet avail dt or offer dt*/
            set OP0IM001.OP0IMNDT cursor, modified, bold;
            return;
          end
        end
      end
    end
  end

  if (OP0IW01.OP1CUNDT == OPAREC.OPACDT)
    OP0IW01.OP0IWPND = "N";
  else
    OP0IW01.OP0IWPND = "Y";
  end

  if (OP0IW01.OP0IWPND == "Y")
    OP0IW01.OP0IWALO = "N";
  end

     /* if all sizes allocatable, and order type is at-once*/
     /* make sure need date is today.*/


  if (OP0IW01.OP0IWALO == "Y"
   && XOTTBL.XOTATONF[OP0IWSBO] == "Y")
    if (OP0IW01.OP1CUNDT == OPAREC.OPACDT)
      OP0IW01.OP0IWPND = "N";
    else
      set OP0IM001.OP0IMNDT bold;
      converseLib.validationFailed(386); /* need date must be today, changed.*/
      OPAREC.OPAERR = "Y"; /* for re-converse*/
      if (OP3REC.OP2LNIST == "AL") /* cant chg date if prev. allocated*/
         /* next sentence*/
      else /* not review mode*/
        OP0IW01.OP1CUNDT = OPAREC.OPACDT; /* force to today*/
        OPAREC.OPAWDT = OPAREC.OPACDT; /* use in op0is27*/
        OPAREC.OPAFYY = OPAREC.OPAWYY;
        OPAREC.OPAFMM = OPAREC.OPAWMM;
        OPAREC.OPAFDD = OPAREC.OPAWDD;
        OP0IM001.OP0IMNDT = OPAREC.OPAFDT;
        OP0IS27(); /* set sub-order index*/
      end
    end
  end



     /* next may cause message and field conflicts -*/
     /* message wants change, yet field protected in review*/
     /* of previously allocated product*/
     /* to prevent sub-order changes.*/


  if (OP3REC.OP2LNIST == "AL")
    set OP0IM001.XWHCD protect;
    set OP0IM001.OP0IMNDT protect;
  end

  if (OP3REC.OP2LNIST == "OP" /* if item prev open*/
   && OP0IW01.OP0IWALO == "Y") /* but will get allocated*/
    if (OPWREC.OPWREVM == 7 /* or in review mode*/
     || OPWREC.OP2LNINB > 0)
      set OP0IM001.XWHCD protect;
      set OP0IM001.OP0IMNDT protect;
    end
  end


end // end OP0IS40

// highlight fields
Function OP0IS41()

   /* highlight sizes where cond dt gt need date*/

  OP0IW01.OP0IWSBM = 1; /* start at map column 1*/
  if (OP0IW01.OP0IWSCR == 1) /* start at record*/
    OP0IW01.OP0IWSBR = OP0IW01.OP0IWSMF; /* first chosen size*/
  else
    OP0IW01.OP0IWSBR = OP0IW01.OP0IWSB2;
  end


  while (OP0IW01.OP0IWSBM < 21 /* into screen*/
   && OP0IW01.OP0IWSBR < 41 /* into size array*/
   && OP0IW01.OP0IWSBR <= OP0IW01.OP0IWSML)
    if (OP0IM001.OP3ONOQT[OP0IWSBM] > 0)
      if (AV5REC.AV5CDDT[OP0IWSBR] > OP0IW01.OP1CUNDT)
        set OP0IM001.OP3ONOQT[OP0IWSBM] modified, bold;
      end
    end
    OP0IW01.OP0IWSBM = OP0IW01.OP0IWSBM + 1;
    OP0IW01.OP0IWSBR = OP0IW01.OP0IWSBR + 1;
  end /* end the while*/



end // end OP0IS41

// control edit-prc ed/upd,qty ed
Function OP0IS42()



      /* edit size price & quantity, update if o.k.*/

  TA1REC.TA1LOCAT[2] = "OP0IS42"; /* error diag group name*/


  while (OP0IW01.OP0IWSBM < 21 /* for each map size*/
   && OP0IW01.OP0IWSBR < 41 /* that is in size range*/
   && OP0IW01.OP0IWSBR <= OP0IW01.OP0IWSML)
    if (OP3REC.OP3SZAFL[OP0IWSBR] == "Y") /* with active flag*/
      if (OP0IM001.SY5PRCUN[OP0IWSBM] is modified)
        OP0IW01.OP0IWCHG = "Y";
        OP0IS45(); /* edit price variance*/
      else
        set OP0IM001.SY5PRCUN[OP0IWSBM] normal; /* unprotect*/
      end
      if (OP0IM001.OP3ONOQT[OP0IWSBM] is modified)
        OP0IW01.OP0IWCHG = "Y";
        OP0IS47(); /* quantity edit*/
      else
        set OP0IM001.OP3ONOQT[OP0IWSBM] initialAttributes;
      end
      OP0IW01.OP0IWSBM = OP0IW01.OP0IWSBM + 1; /* map subscript*/
    end
    OP0IW01.OP0IWSBR = OP0IW01.OP0IWSBR + 1; /* record subscript*/
  end


      /* note - check of msg 169 needed to avoid*/
           /* moving old op3rec price on top of price change*/
           /* edited with error 169 and not yet applied.*/

  if (OP0IW01.OP0IWPF6 == "Y") /* if show prices*/
    if (converseVar.validationMsgNum != 169) /* if size price edit is o.k.*/
      OP0IS66(); /* re-do price & **/
    end
  end



end // end OP0IS42

// control edit-qty edit/update
Function OP0IS43()



      /* edit only quantity, not price*/



  while (OP0IW01.OP0IWSBM < 21 /* for each map size*/
   && OP0IW01.OP0IWSBR < 41 /* that is in size range*/
   && OP0IW01.OP0IWSBR <= OP0IW01.OP0IWSML)
    if (OP3REC.OP3SZAFL[OP0IWSBR] == "Y") /* with active flag*/
      if (OP0IM001.OP3ONOQT[OP0IWSBM] is modified)
        OP0IW01.OP0IWCHG = "Y";
        OP0IS47(); /* quantity edit/updt*/
      else
        set OP0IM001.OP3ONOQT[OP0IWSBM] initialAttributes;
      end
      OP0IW01.OP0IWSBM = OP0IW01.OP0IWSBM + 1; /* map subscript*/
    end
    OP0IW01.OP0IWSBR = OP0IW01.OP0IWSBR + 1; /* record subscript*/
  end



end // end OP0IS43

// edit total requested quantity
Function OP0IS44()



      /* replace total quantity used to verify data entry*/
      /* (in w-s 6 product array)*/

  TA1REC.TA1LOCAT[2] = "OP0IS44"; /* error diag group name*/


  OPWREC.OP2TONOQ[OP0IWSBP] = OP0IM001.OP2TONOQ; /* replace tot qty*/



end // end OP0IS44

// edit size price
Function OP0IS45()


  TA1REC.TA1LOCAT[2] = "OP0IS45"; /* error diag group name*/

  OP0IW01.OP0IWPRO = OP3REC.SY5PRCUN[OP0IWSBR]; /* original price*/
  OP0IW01.OP0IWPRN = OP0IM001.SY5PRCUN[OP0IWSBM]; /* new price*/

  if (OP0IW01.OP0IWPRN <= 0) /* new price le 0 invalid*/
    if (OP0IW01.OP0IWPRN == 0 /* if new price is zero*/
     && SYCREC.SY1FNSHG == "2") /* and prod is raw materials*/
      if (OP0IW01.XAUCD == "64" /* class is salesman samples*/
       || OP0IW01.XAUCD == "82") /* or rep samples*/
          /* next sentence - price = 0 ok*/
      else
        OPAREC.OPAERR = "Y";
        converseLib.validationFailed(189); /* price can not be < or = zero*/
        set OP0IM001.SY5PRCUN[OP0IWSBM] cursor, modified, bold;
        return;
      end
    else
      OPAREC.OPAERR = "Y";
      converseLib.validationFailed(189); /* price can not be < or = zero*/
      set OP0IM001.SY5PRCUN[OP0IWSBM] cursor, modified, bold;
      return;
    end
  end

  OP0IW01.OP0IWFND = "N"; /* no error*/

      /* note - op0iwpsz = n, never changed*/
             /* op0iwpsz = y, warning given once, don't repeat,*/
                           /* apply any change*/
  if (OP0IW01.OP0IWPSZ == "N") /* edit only once*/
    OP0IS6H(); /* edit price variance*/
  end

  if (OP0IW01.OP0IWFND == "Y") /* edit once err found*/
    OP0IW01.OP0IWPSZ = "Y";
    converseLib.validationFailed(169); /* warning - outside ord type range*/
    set OP0IM001.SY5PRCUN[OP0IWSBM] cursor, modified, bold;
    return;
  end


      /* good price change for this size*/

  OP3REC.SY5PRCUN[OP0IWSBR] = OP0IM001.SY5PRCUN[OP0IWSBM];
  OP3REC.OP3PRCOF[OP0IWSBR] = "Y"; /* price override flag*/
  OP3REC.OP2PRCOF = "Y"; /* product price override*/
  OPWREC.OPWAUTFL = "Y"; /* authorization reqd*/
  OP3REC.OP2PRCVF = "Y"; /* product price varies*/
  set OP0IM001.SY5PRCUN[OP0IWSBM] normal; /* unprotected*/



end // end OP0IS45

// edit size quantity
Function OP0IS47()


      /* **********************************************/
      /* * keep running total of quantity for*/
      /* * verifying against requested total quantity.*/
      /* **********************************************/


      /* total qty = total qty - old size qty + new size qty*/

  OP3REC.OP2TONOQ = OP3REC.OP2TONOQ - OP3REC.OP3ONOQT[OP0IWSBR];


    /* check to see that for draw orders what was ordered*/
    /* is available.*/


  if (OP0IW01.OP0IWBDF == "DC" /* cust draw*/
   || OP0IW01.OP0IWBDF == "DN" /* nike draw*/
   || OP0IW01.OP0IWBDF == "DR" /* rebook draw*/
   || OP0IW01.OP0IWBDF == "DS" /* smart draw*/
   || OP0IW01.OP0IWBDF == "DX") /* flexible draw*/
    if (OPWREC.OPWREVM == 7 /* if in review mode*/
     || OPWREC.OP2LNINB > 0)
      OP0IW01.OP0IWQTY = OP3REC.OP3ONOQT[OP0IWSBR];
      OP0IW01.OP0IWQTY = OP0IM001.OP3ONOQT[OP0IWSBM] - OP0IW01.OP0IWQTY;
      OP0IW01.OP0IWQTY = OP0IW01.OP0IWQTY + OP0IW01.OP0IWCQT[OP0IWSBR];
      if (OP0IW01.OP0IWQTY > OP0IM001.OP0IMAVL[OP0IWSBM])
        converseLib.validationFailed(288); /* not enough available*/
        OPAREC.OPAERR = "Y";
        set OP0IM001.OP3ONOQT[OP0IWSBM] cursor, modified, bold;
        OP3REC.OP2TONOQ = OP3REC.OP2TONOQ + OP3REC.OP3ONOQT[OP0IWSBR];
        return;
      else
        set OP0IM001.OP3ONOQT[OP0IWSBM] initialAttributes;
      end
    else
      if (OP0IM001.OP3ONOQT[OP0IWSBM] > OP0IM001.OP0IMAVL[OP0IWSBM])
        converseLib.validationFailed(288); /* not enough available*/
        OPAREC.OPAERR = "Y";
        set OP0IM001.OP3ONOQT[OP0IWSBM] cursor, modified, bold;
        OP3REC.OP2TONOQ = OP3REC.OP2TONOQ + OP3REC.OP3ONOQT[OP0IWSBR];
        return;
      else
        set OP0IM001.OP3ONOQT[OP0IWSBM] initialAttributes;
      end
    end
  end




   /* check quantity ordered against availability.*/
   /* on regular orders, not bulk/draw*/

    /* note:  some condition codes allow the qty entered to be*/
           /* greater then the qty avail. (xcdentfl)*/
           /* For orders that can't be allocated, qty may be*/
           /* greater then avail if xcdentfl eq 'y'.*/


  if (OP0IW01.OP0IWDAV == "Y" /* if we are displaying availability*/
   && OP0IW01.OP0IWHAR == "Y") /* and have availability record*/
    if (OPWREC.OPWREVM == 7 /* or in review mode*/
     || OPWREC.OP2LNINB > 0)
      OP0IW01.OP0IWQTY = OP3REC.OP3ONOQT[OP0IWSBR];
      OP0IW01.OP0IWQTY = OP0IM001.OP3ONOQT[OP0IWSBM] - OP0IW01.OP0IWQTY;
      OP0IW01.OP0IWQTY = OP0IW01.OP0IWQTY + OP0IW01.OP0IWCQT[OP0IWSBR];
      OPPREC.OP3SZAFL[OP0IWSBR] = OP3REC.OP3SZAFL[OP0IWSBR];
      OPPREC.OPPQTY[OP0IWSBR] = OP0IW01.OP0IWQTY;
      set OP0IM001.OP3ONOQT[OP0IWSBM] initialAttributes;
    else
      OPPREC.OP3SZAFL[OP0IWSBR] = OP3REC.OP3SZAFL[OP0IWSBR];
      OPPREC.OPPQTY[OP0IWSBR] = OP0IM001.OP3ONOQT[OP0IWSBM];
    end
  end




      /* move map to record, either both on-order & orig qtys*/
      /* or just on-order - depending on produc deadline date*/

    /* for order reporting keep track of change qty in revw mod.*/

  if (OPWREC.OPWREVM == 7
   || OPWREC.OP2LNINB > 0)
    OP0IW01.OP0IWQTY = OP3REC.OP3ONOQT[OP0IWSBR];
    OP0IW01.OP0IWQTY = OP0IM001.OP3ONOQT[OP0IWSBM] - OP0IW01.OP0IWQTY;
    OP0IW01.OP0IWCQT[OP0IWSBR] = OP0IW01.OP0IWCQT[OP0IWSBR] + OP0IWQTY;
  end

  OP3REC.OP3ONOQT[OP0IWSBR] = OP0IM001.OP3ONOQT[OP0IWSBM];

  /* original quantity is recorded if order is added less than*/
  /* 60 days after the cutoff date*/

  if (OP0IW01.OP0IW-DAYS-PAST-CUTOFF < 60
   && OP0IW01.OP0IWBDF != "DC" /* cust draw*/
   && OP0IW01.OP0IWBDF != "DN" /* nike draw*/
   && OP0IW01.OP0IWBDF != "DR" /* rebook draw*/
   && OP0IW01.OP0IWBDF != "DS" /* smart draw*/
   && OP0IW01.OP0IWBDF != "DX") /* flexible draw*/
    OP3REC.OP3ORGQT[OP0IWSBR] = OP0IM001.OP3ONOQT[OP0IWSBM];
  end


      /* add in new size qty to total qty for product*/

  OP3REC.OP2TONOQ = OP3REC.OP2TONOQ + OP3REC.OP3ONOQT[OP0IWSBR];






end // end OP0IS47

// check avail dt with offer dt
Function OP0IS4B()



      /* *********************************************************/
      /* * check furthest avail date (op0iwavd) with product*/
      /* * offering date to ensure qty's available*/
      /* *********************************************************/

  TA1REC.TA1LOCAT[2] = "OP0IS4B"; /* error diag group name*/


  if (OPWREC.OPWREVM == 7
   /* if revw mode skip need date unprotect*/
   || OPWREC.OP2LNINB > 0)
    if (OP3REC.OP2LNIST == "AL")
      OPAREC.OPAERR = "Y";
      converseLib.validationFailed(197); /* cant chg needdt sub-ord on alloc*/
      OP0IS41();
      return;
    else
      if (OP0IW01.OP1CUNDT < OP0IW01.OP0IWAVD) /* if past date*/
        OPAREC.OPAERR = "Y";
        converseLib.validationFailed(397); /* cant chg needdt in rev mode remove*/
                                   /* size*/
        OP0IS41();
        return;
      end
    end
  end

   /* not previously allocated*/

  OP0IW01.OP0IWPND = "Y"; /* init pushed need date flag*/

  if (OP0IW01.OP1CUNDT < OP0IW01.OP0IWAVD)
    converseLib.validationFailed(383); /* need date can't be LT furthest avail*/
                                   /* date*/
    OPAREC.OPAERR = "Y";
    set OP0IM001.OP0IMNDT cursor, modified, bold;
    return;
  end

   /* need date gt available date and offering date*/

  if (OP0IW01.OP1CUNDT > OP0IW01.OP0IWAVD /* if past date*/
   && XOTTBL.XOTATONF[OP0IWSBO] == "Y")   /* and at-once*/
    if (OP0IW01.OP1CUNDT > SYCREC.SY2POFBD)
      OPAREC.OPAERR = "Y";
      converseLib.validationFailed(443);
                                   /* nd dt cant be gt offring date or wavd*/
      OP0IW01.OP0IWSBM = 1; /* start at map column 1*/
      if (OP0IW01.OP0IWSCR == 1) /* start at record*/
        OP0IW01.OP0IWSBR = OP0IW01.OP0IWSMF; /* first chosen size*/
      else
        OP0IW01.OP0IWSBR = OP0IW01.OP0IWSB2;
      end
      while (OP0IW01.OP0IWSBM < 21 /* into screen*/
       && OP0IW01.OP0IWSBR < 41 /* into size array*/
       && OP0IW01.OP0IWSBR <= OP0IW01.OP0IWSML)
        if (OP0IM001.OP3ONOQT[OP0IWSBM] > 0)
          if (OP0IW01.OP1CUNDT > OP0IW01.OP0IWAVD)
            set OP0IM001.OP3ONOQT[OP0IWSBM] modified, bold;
            set OP0IM001.OP0IMNDT cursor, modified, bold;
          end
        end
        OP0IW01.OP0IWSBM = OP0IW01.OP0IWSBM + 1;
        OP0IW01.OP0IWSBR = OP0IW01.OP0IWSBR + 1;
      end /* end the while*/
      return;
    end /* end offering date check*/
  end



end // end OP0IS4B

// map line 4-darken verify line
Function OP0IS50()



      /* BLANK WORDS, SIZE DESCRIP FOR VERIFY ERROR LINE*/



  OP0IM001.OP0IMWDF = " ";
  OP0IM001.OP0IMWDL = " ";
  OP0IM001.OP0IMWDQ = " ";
  OP0IM001.OP0IMRSF = " ";
  OP0IM001.OP0IMRSL = " ";
  set OP0IM001.OP2TONOQ skip, invisible;



end // end OP0IS50

// choose sizes/price for map
Function OP0IS51()



      /* *************************************/
      /* * map lines 5 - 14  all 20 sizes*/
      /* *************************************/

  TA1REC.TA1LOCAT[2] = "OP0IS51"; /* error diag data-group*/


      /* * the theory is - screen 1 has record sizes  1 to 20*/
      /* *                 screen 2 has record sizes 21 to 40*/
      /* * if screen 2 has only 2 sizes shown,*/
      /* *   then screen 1 sizes 3 to 20 still show on scrn 2.*/
      /* *   excess sizes will be cleared in the next section.*/


  OP0IW01.OP0IWSBM = 1; /* map index = 1 to start*/

      /* note - op0iwsmf/l were set before got here*/
             /* could be reqstd range, full range or actual range*/

  if (OP0IW01.OP0IWSCR == 1) /* if on screen 1*/
    OP0IWSBR = OP0IW01.OP0IWSMF; /* find first size to move*/
  else
    OP0IWSBR = OP0IW01.OP0IWSB2; /* screen 2 starting place*/
  end


      /* move size,qty,alloc (and price, flag) to map*/

  if (OP3REC.OP2PRCOF == "Y" /* if multiple prices in the product*/
   || OP3REC.OP2PRCVF == "Y" /* or pf6 requested prices*/
   || OP0IW01.OP0IWPF6 == "Y")
                                   /* move size,qty,alloc,price & fl to map*/
    OP0IW01.OP0IWPOF = " "; /* init ws price override work area*/
    while (OP0IWSBM < 21 /* for up to 20 sizes*/
     && OP0IWSBR < 41 
     && OP0IWSBR <= OP0IW01.OP0IWSML) /* until end of chosen range*/
      if (OP3REC.OP3SZAFL[OP0IWSBR] == "Y") /* active size -*/
        OP0IS52(); /* get size descrip, move all data*/
        OP0IS53(); /* move size price and * flag to map*/
        OP0IWSBM = OP0IWSBM + 1; /* next map column*/
      end
      OP0IWSBR = OP0IWSBR + 1; /* try next size in record*/
    end
  else
    while (OP0IWSBM < 21 /* if no multiple prices in the product*/
     && OP0IWSBR < 41 /* move size,qty,alloc to map*/
     && OP0IWSBR <= OP0IW01.OP0IWSML) /* until end of chosen range*/
      if (OP3REC.OP3SZAFL[OP0IWSBR] == "Y") /* for up to 20 sizes*/
        OP0IS52(); /* get size descrip, move all data*/
        OP0IWSBM = OP0IWSBM + 1; /* next map column*/
      end
      OP0IWSBR = OP0IWSBR + 1; /* try next size in record*/
    end
  end


  if (OP0IW01.OP0IWSCR == 1) /* if screen # 1*/
    OP0IW01.OP0IWSB2 = OP0IWSBR; /* hold scrn 2 starting point*/
  end


      /* ********************************************************/
      /* * check where valid sizes stopped -*/
      /* *   if have more than 20, set more flag = y*/
      /* *   if have less than 20, darken rest of 20 fields*/
      /* ********************************************************/

  OP0IW01.OP0IWMOR = "N"; /* init more sizes = n*/

  if (OP0IW01.OP0IWSCR == 1) /* if screen # 1 and*/
    if (OP0IW01.OP0IWSML >= OP0IWSBR) /* chosen last size > or =*/
      OP0IW01.OP0IWMOR = "Y"; /* last size shown + 1*/
    end /* then have more sizes for map*/
  end

  while (OP0IW01.OP0IWSBM < 21) /* for unused columns on screen*/
    OP0IS54(); /* clear size,qty,aloc,price,fl*/
    OP0IW01.OP0IWSBM = OP0IW01.OP0IWSBM + 1;
  end


      /* **********************************************/
      /* move correct value for 'more sizes' to map*/
      /* **********************************************/

  OP0IS55();



end // end OP0IS51

// move siz desc,qty,avail to map
Function OP0IS52()


      /* get size description and move to map*/
      /* size scale record with 40 descrip was read prev.*/



  OP0IM001.SY4IDDSC[OP0IWSBM] = SY4REC.SY4IDDSC[OP0IWSBR];
  set OP0IM001.SY4IDDSC[OP0IWSBM] initialAttributes;


      /* move order quantities from op3rec to map*/

    /* for dup sizes and review mode, op3rec contains quantities*/
    /* that we want to show on the screen before the initial*/
    /* converse.  However, this sgrp is part of the get*/
    /* availability routines, which can be executed after the*/
    /* converse as well.*/

    /* When some change has been made that requires rechecking*/
    /* of availability, (warehouse, need date, etc.) this*/
    /* rechecking must be done BEFORE the quantity edits, to*/
    /* allow verification of the quantities against the new*/
    /* availability.  OP3REC will not be valued with the map*/
    /* quantities until AFTER quantity edits are completed.*/

    /* OP0IWAVX is a trigger that is set off when availability*/
    /* is called as the result of some change to need date,*/
    /* warehouse, etc.  It prevents the quantity fields*/
    /* on the map from being overlaid with the old quantities*/
    /* still on OP3REC.*/

  if (OP0IW01.OP0IWAVX == "Y") /* okay to move op3rec to map*/
    OP0IM001.OP3ONOQT[OP0IWSBM] = OP3REC.OP3ONOQT[OP0IWSBR];
    set OP0IM001.OP3ONOQT[OP0IWSBM] initialAttributes;
  end


      /* move bulk availability to map*/

  if (OP0IW01.OP0IWBDF == "DC" /* cust draw*/
   || OP0IW01.OP0IWBDF == "DR" /* rebook draw*/
   || OP0IW01.OP0IWBDF == "DX") /* flexible draw*/
    if (OP0IW03.OP3ONOQT[OP0IWSBR] > 0)
      OP0IM001.OP0IMAVL[OP0IWSBM] = OP0IW03.OP3ONOQT[OP0IWSBR];
    else
      OP0IM001.OP0IMAVL[OP0IWSBM] = 0;
    end
    set OP0IM001.OP0IMAVL[OP0IWSBM] initialAttributes;
  else
    if (OP0IW01.OP0IWBDF == "DS") /* smart draw*/
      if (OP0IW03.OP3OHRQT[OP0IWSBR] > 0)
        OP0IM001.OP0IMAVL[OP0IWSBM] = OP0IW03.OP3OHRQT[OP0IWSBR];
      else
        OP0IM001.OP0IMAVL[OP0IWSBM] = 0;
      end
      set OP0IM001.OP0IMAVL[OP0IWSBM] initialAttributes;
    end
    if (OP0IW01.OP0IWBDF == "DN") /* nike draw*/
      if (XOTTBL.XOTATONF[OP0IWSBO] == "Y") /* if at-once OT*/
        if (OP0IW03.OP3OHRQT[OP0IWSBR] > 0) /* only display rsv'd qtys*/
          OP0IM001.OP0IMAVL[OP0IWSBM] = OP0IW03.OP3OHRQT[OP0IWSBR];
        else
          OP0IM001.OP0IMAVL[OP0IWSBM] = 0;
        end
        set OP0IM001.OP0IMAVL[OP0IWSBM] initialAttributes;
      else /* not at-once, display all bulk qtys*/
        if (OP0IW03.OP3ONOQT[OP0IWSBR] > 0)
          OP0IM001.OP0IMAVL[OP0IWSBM] = OP0IW03.OP3ONOQT[OP0IWSBR];
        else
          OP0IM001.OP0IMAVL[OP0IWSBM] = 0;
        end
        set OP0IM001.OP0IMAVL[OP0IWSBM] initialAttributes;
      end
    end
  end



   /* move availability to map. set fields dark if don't*/
   /* have an availability record.*/



  if (OP0IW01.OP0IWDAV == "Y") /* if we can display availability*/
    if (OP0IW01.OP0IWHAR == "Y") /* if have an availability record*/
      OP0IM001.OP0IMPOF[OP0IWSBM] = OP0IW01.OP0IWAVA[OP0IWSBR];
      OP0IM001.OP0IMAVL[OP0IWSBM] = OP0IW01.OP0IWAVQ[OP0IWSBR];
      set OP0IM001.OP0IMAVL[OP0IWSBM] initialAttributes;
      set OP0IM001.OP0IMPOF[OP0IWSBM] initialAttributes;
    else
      set OP0IM001.OP0IMAVL[OP0IWSBM] protect, invisible;
      set OP0IM001.OP0IMPOF[OP0IWSBM] protect, invisible;
    end
  end



   /* skip availability check if in review mode.*/

  if (OPWREC.OPWREVM == 7
   || OPWREC.OP2LNINB > 0)
    return;
  end




    /* now check to see if on order quantity > avail qty.*/

    /* note: only std sz dist will put qty's in op3rec prior*/
          /* to coming here the first time. only a pf21 will*/
          /* re-call this routine. thus if op3rec qty > 0*/
          /* and op0iwp21 eq 'n', set the size modified to*/
          /* trigger a qty edit later.*/
    /* also: under certain conditions we can enter a qty that*/
          /* is greater then what is available. (xcdentfl)*/



  if (OP0IW01.OP0IWBDF == "DC" /* if draw order*/
   || OP0IW01.OP0IWBDF == "DN" 
   || OP0IW01.OP0IWBDF == "DR" 
   || OP0IW01.OP0IWBDF == "DS" 
   || OP0IW01.OP0IWBDF == "DX" 
   || OP0IW01.OP0IWDAV == "Y") /* or displaying availability*/
    if (OP0IM001.OP0IMAVL[OP0IWSBM] < OP0IM001.OP3ONOQT[OP0IWSBM])
      if (OP0IW01.OP0IWDAV == "Y")
        if (OP0IW01.OP0IWHAR == "Y") /* and have a good avail record*/
                   /* next sentence*/
        else /* no avail record so no restriction.*/
          set OP0IM001.OP3ONOQT[OP0IWSBM] initialAttributes;
          return;
        end
      end
      set OP0IM001.OP3ONOQT[OP0IWSBM] modified, bold;
      if (OP0IW01.OP0IWRST == "Y") /* if in restart mode, don't chg msg*/
         /* next sentence*/
      else
        if (converseVar.validationMsgNum == 0)
          converseLib.validationFailed(385); /* more ordered then available msg*/
        end
      end
      OPAREC.OPAERR = "Y";
    else
      if (OP0IM001.OP3ONOQT[OP0IWSBM] > 0
       && OP0IW01.OP0IWP21 == "N")
        set OP0IM001.OP3ONOQT[OP0IWSBM] modified; /* to trigger qty edit*/
      else
        set OP0IM001.OP3ONOQT[OP0IWSBM] initialAttributes;
      end
    end
  end







end // end OP0IS52

// move price & flag to map/unpro
Function OP0IS53()


      /* move price to map*/

  OP0IM001.SY5PRCUN[OP0IWSBM] = OP3REC.SY5PRCUN[OP0IWSBR];

  if (OP0IW01.OP0IWPF6 == "Y") /* if allowed to change prices*/
    set OP0IM001.SY5PRCUN[OP0IWSBM] normal; /* unprotect prices*/
  else
    set OP0IM001.SY5PRCUN[OP0IWSBM] initialAttributes;
  end


   /* log 535 dflesh- if price for all sizes is gt $999.99,*/
   /* price per size field would show a truncated value.*/

  if (OP3REC.SY5PRCUN[OP0IWSBR] > 999.99) /* price per unit gt $999.99*/
    set OP0IM001.SY5PRCUN[OP0IWSBM] skip, invisible;
  end


      /* move price override flag to map*/

  set OP0IM001.OP0IMPOF[OP0IWSBM] initialAttributes;

  if (OP0IW01.OP0IWDAV == "Y" /* skip prc ovrd, cond codes priority.*/
   && OP0IW01.OP0IWHAR == "Y") /* only if Have Avail Record.*/
     /* next sentence*/
  else
    if (OP3REC.OP3PRCOF[OP0IWSBR] == "Y")
      OP0IM001.OP0IMPOF[OP0IWSBM] = "   * ";
    else
      OP0IW01.OP3PRCOF = " ";
      OP0IM001.OP0IMPOF[OP0IWSBM] = OP0IW01.OP0IWPOF;
    end
  end





end // end OP0IS53

// clear size cols(5 flds) on map
Function OP0IS54()



      /* *********************************************/
      /* * in size columns not used on the map*/
      /* * darken unused fields - size descrip*/
      /* *                      - ordered quantity*/
      /* *                      - available quantity*/
      /* *                      - price per size*/
      /* *                      - price override flag*/
      /* *********************************************/

  TA1REC.TA1LOCAT[2] = "OP0IS54"; /* error diag group name*/


  OP0IM001.SY4IDDSC[OP0IWSBM] = " "; /* wipe out old sizes*/
  set OP0IM001.SY4IDDSC[OP0IWSBM] skip, invisible;
  set OP0IM001.OP3ONOQT[OP0IWSBM] protect, invisible;
  set OP0IM001.OP0IMAVL[OP0IWSBM] protect, invisible;
  set OP0IM001.SY5PRCUN[OP0IWSBM] protect, invisible;
  set OP0IM001.OP0IMPOF[OP0IWSBM] protect, invisible;



end // end OP0IS54

// move 'more sizes' to map
Function OP0IS55()



      /* ******************************/
      /* * set up 'more sizes' flag*/
      /* ******************************/

  TA1REC.TA1LOCAT[2] = "OP0IS55"; /* error diag group name*/


  if (OP0IW01.OP0IWMOR == "Y") /* if screen 1 has more than 20 sizes*/
    set OP0IM001.OP0IMWDM initialAttributes; /* show 'y' on the screen*/
    set OP0IM001.OP0IWMOR initialAttributes;
    OP0IM001.OP0IWMOR = "Y";
  else
    set OP0IM001.OP0IMWDM protect, invisible; /* else darken this area*/
    set OP0IM001.OP0IWMOR protect, invisible; /* of the screen*/
  end



end // end OP0IS55

// validate pf 6(chg size prices)
Function OP0IS61()



      /* *************************************************/
      /* * pf 6 not valid if order is on sales program*/
      /* *   -- nor for set aside bulk orders -- jdv oproc-2*/
        /* unless the product is a sales tool like a component*/
        /* ring where the price needs to be changed to zero*/
        /* or division = '02'. (international)*/
      /* * pf 6 (change prize by size) is now allowed for*/
        /* smart reservation bulk orders as well as*/
        /* in-development products for nike international*/
      /* *************************************************/

  TA1REC.TA1LOCAT[2] = "OP0IS61"; /* error diag group name*/


  if (KUCREC.KUCCOID == 0) /* if cmpy rec not read yet*/
    KUCREC.KUCCOID = OP1REC.KUCCOID;
    OP0IS9C(); /* get company rec for acct class*/
    OP0IW01.XAUCD = KUCREC.XAUCD; /* save comp acct class*/
  end

  if (OP1REC.SP1ID == " "    /* if no sales program*/
   || SP1REC.XNDCD == "ALLM" /* allocation sales program*/
   || OP1REC.XDVCD == "02")  /* or international division*/
     /* next sentence                    price ovrd ok*/
  else
    if (SYCREC.SY1FNSHG == "2") /* if the prod is raw materials*/
      if (KUCREC.XAUCD == "64" /* if the cmpy account class is*/
       || KUCREC.XAUCD == "82") /* salesmen or rep samples*/
        /* next sentence                  it is ok to override the prce*/
      else /* otherwise*/
        OPAREC.OPAERR = "Y"; /* error*/
        converseLib.validationFailed(168);
                                   /* msg: sales pgm cant change prices*/
        OP0IS62(); /* reset mdts for changed fields*/
        exit stack; /* return*/
      end
    else /* else (prod not a raw material)*/
      OPAREC.OPAERR = "Y"; /* error*/
      converseLib.validationFailed(168);
                                   /* msg: sales pgm cant change prices*/
      OP0IS62(); /* reset mdts for changed fields*/
      exit stack; /* return*/
    end
  end


  if (OP0IW01.OP0IWBDF == "BX") /* flex bulk*/
    converseLib.validationFailed(294); /* set aside bulk cant change prices*/
    OPAREC.OPAERR = "Y";
    OP0IS62(); /* re-set mdt's for changed fields*/
    exit stack;
  end /* pf 6 o.k.*/


   /* added to stop discounts on salesman orders - bug 270*/
   /* dwalke 12/05/89*/

  if (KUCREC.XAUCD == "26" /* if order is a rep promo*/
   || KUCREC.XAUCD == "27") /* or agency/rep personal purhcase*/
    converseLib.validationFailed(687); /* cannot override prices on slsmn ord*/
    OPAREC.OPAERR = "Y"; /* so move yes to error flag*/
    set OP0IM001.OP3ONOQT[1] cursor; /* set cursor to 1st quantity field*/
    OP0IS62(); /* re-set mdt's for changed fields*/
    exit stack; /* and return to re-converse*/
  else
    if (KUCREC.XAUCD == "64" /* if the order is a salesman sample order*/
     && SYCREC.SY1FNSHG != "2") /* and the prod is not a raw material*/
      converseLib.validationFailed(687); /* cannot override prices on slsmn ord*/
      OPAREC.OPAERR = "Y"; /* so move yes to error flag*/
      set OP0IM001.OP3ONOQT[1] cursor; /* set cursor to 1st quantity field*/
      OP0IS62(); /* re-set mdt's for changed fields*/
      exit stack; /* and return to re-converse*/
    end
  end




end // end OP0IS61

// map fld attrib-if modfd,set md
Function OP0IS62()



      /* *************************************************/
      /* * set mdt's for fields previously changed*/
      /* * this allow user to press the correct pf key*/
      /* * without having to re-enter the data.*/
      /* * also, allows data entry on bottom of screen 1*/
      /* * to show on screen 2.*/
      /* * if field not modified, reset attributes*/
      /* *************************************************/



  if (OP0IM001.OP2TONOQ is modified) /* verify total quantity*/
    set OP0IM001.OP2TONOQ modified;
  end


      /* *************************************************/
      /* * check all 20 sizes for data entered*/
      /* *************************************************/


  sysVar.arrayIndex = 1; /* start at 1*/
  OP0IW01.OP0IWQTC = "N";
  OP0IW01.OP0IWNDC = "N";

  while (sysVar.arrayIndex < 21)
    if (OP0IM001.OP3ONOQT[sysVar.arrayIndex] is modified)
      set OP0IM001.OP3ONOQT[sysVar.arrayIndex] modified;
      OP0IW01.OP0IWQTC = "Y";
    end
    if (OP0IM001.SY5PRCUN[sysVar.arrayIndex] is modified)
      set OP0IM001.SY5PRCUN[sysVar.arrayIndex] modified;
    end
    sysVar.arrayIndex = sysVar.arrayIndex + 1;
  end


      /* *************************************************/
      /* * continue with bottom half of screen*/
      /* *************************************************/

  if (OP0IM001.OP0IMPAL is modified) /* price for all sizes*/
    set OP0IM001.OP0IMPAL modified;
  end

  if (OP0IM001.OP0IMPAD is modified) /* price adjustment*/
    set OP0IM001.OP0IMPAD modified;
  end

  if (OP0IM001.OP0IWMOR is modified) /* more sizes*/
    set OP0IM001.OP0IWMOR modified;
  end

  if (OP0IM001.XWHCD is modified) /* warehouse*/
    set OP0IM001.XWHCD modified;
  end

  if (OP0IM001.OP0IMNDT is modified) /* need date*/
    OP0IWNDC = "Y";
    set OP0IM001.OP0IMNDT modified;
    OP0IW01.OP0IWESP = "Y";
                                   /* set flag to re-edit screened products*/
  end

  if (OP0IM001.XOWCD is modified) /* owner group*/
    set OP0IM001.XOWCD modified;
    OP0IW01.OP0IWESP = "Y";
                                   /* set flag to re-edit screened products*/
  end

  if (OP0IM001.OP1BOFL is modified) /* backorder flag*/
    set OP0IM001.OP1BOFL modified;
  end

  if (OP0IM001.PWRLBCD[1] is modified /* labl cd #1*/
   || OP0IM001.PWRLBCD[2] is modified) /* labl cd #2*/
    set OP0IM001.PWRLBCD[1] modified;
    set OP0IM001.PWRLBCD[2] modified;
  end

  if (OP0IM001.OP0IMFIL is modified) /* fill lost demand*/
    set OP0IM001.OP0IMFIL modified;
  end

  if (OP0IM001.OP2CGPCD is modified) /* coordinate group*/
    set OP0IM001.OP2CGPCD modified;
  end

  if (OP0IM001.PC2INSEG is modified) /* spec code*/
    set OP0IM001.PC2INSEG modified;
  end

  if (OP0IM001.OP2KSTYF is modified) /* key style*/
    set OP0IM001.OP2KSTYF modified;
  end


  if (OP0IM001.OP2GTSZF is modified) /* gut size*/
    set OP0IM001.OP2GTSZF modified;
  end


      /* *************************************************/
      /* * check all 5 pack handling codes for change entered*/
      /* *************************************************/

  sysVar.arrayIndex = 1;

  while (sysVar.arrayIndex < 6)
    if (OP0IM001.XHDCD[sysVar.arrayIndex] is modified) /* handling code*/
      set OP0IM001.XHDCD[sysVar.arrayIndex] modified;
    end
    if (OP0IM001.XHDCHG[sysVar.arrayIndex] is modified) /* handling charge*/
      set OP0IM001.XHDCHG[sysVar.arrayIndex] modified;
    end
    sysVar.arrayIndex = sysVar.arrayIndex + 1;
  end

      /* *************************************************/
      /* * 08/12/92 JLoyer; check bk-sesns              **/
      /* *************************************************/

  if (OP0IM001.XBK-BK-SESN-CD is modified /* booking season code*/
   || OP0IM001.OP0IM-OP-BK-YR-YY is modified) /* booking year (yy)*/
    set OP0IM001.XBK-BK-SESN-CD modified;
    set OP0IM001.OP0IM-OP-BK-YR-YY modified;
  end

      /* *************************************************/
      /* * continue with bottom of screen*/
      /* *************************************************/

  if (OP0IM001.OP2SSTYN is modified) /* substitute style*/
    set OP0IM001.OP2SSTYN modified;
  end

  if (OP0IM001.OP2SCLCD is modified) /* substiture color*/
    set OP0IM001.OP2SCLCD modified;
  end

  if (OP0IM001.OP2SDMCD is modified) /* substitute dimension*/
    set OP0IM001.OP2SDMCD modified;
  end

  if (OP0IM001.OP2SUBQT is modified) /* substitute quantity*/
    set OP0IM001.OP2SUBQT modified;
  end

  if (OP0IM001.OP2FSTFL is modified) /* forecast flag*/
    set OP0IM001.OP2FSTFL modified;
  end



end // end OP0IS62

// validate pf24(rjct-take actio)
Function OP0IS63()

      /* ********************************************************/
      /* * pf 23 and pf 24 processing*/
      /* ********************************************************/

  TA1REC.TA1LOCAT[2] = "OP0IS63"; /* error diag group name*/


  if (converseVar.eventKey is pf23) /* if reject skip report*/
    if (OP0IW01.OP0IWP23 == "Y") /* if first pf 24, ask for verify*/
       /* next sentence; ready to delete*/
    else
      OP0IW01.OP0IWP23 = "Y"; /* set flag for next converse*/
      OP0IW01.OP0IWP24 = "N"; /* reset other reject flag*/
      OPAREC.OPAERR = "Y";
      converseLib.validationFailed(190); /* verify reject with pf 23*/
      exit stack;
    end
  end





      /* if reviewing product, delete it*/
      /* else just skip add curr prod, and go to next flow*/

  if (OPWREC.OPWREVM == 7 /* in review mode*/
   || OPWREC.OP2LNINB > 0) /* or reviewing selected prod*/
    OP0IS68(); /* delete data base product*/
  end


  OP0IW01.OP0IWREJ = "Y"; /* set flag so won't try to dup this style*/


  OP3REC.SY1STNBR = "999999"; /* inactivate the style*/

  OP0IS89(); /* common flow to next applic*/



end // end OP0IS63

// control scr2,write action,flow
Function OP0IS64()



      /* ********************************************************/
      /* * flow -*/
      /* *     screen 2*/
      /* * or- verify sizes/qty -*/
      /* *       if bad verify - re-show screen*/
      /* *     write record*/
      /* *     if have another product, go start it (op0i020)*/
      /* *     else gl to common exit st.group*/
      /* *********************************************************/

  TA1REC.TA1LOCAT[2] = "OP0IS64"; /* error diag-group name*/

  /* TT#10546 gsunda 02/28/01 begin ****/
  if (OP0IM001.XWHCD is modified /* Whse is modified or*/
   || OP0IM001.XOWCD is modified) /* owner grp cd is modified*/
    OP0IW01.OP0IWMOR = "N"; /* set more size to No*/
    OP0IW01.OP0IWSCR = 1; /* Set to show screen 1*/
  end
  /* TT#10546 gsunda 02/28/01 end   ****/

  if (converseVar.eventKey is pf13) /* end prod loop, skip scr 2*/
    /* next sentence*/
  else
    if (OP0IW01.OP0IWMOR == "Y") /* if have more sizes,*/
      OP0IS69(); /* verify reqstd first size*/
       /* return here if edit o.k.*/
      OP0IS50(); /* re-set line 4(verify) dark*/
      OP0IW01.OP0IWSCR = 2; /* get set to show screen 2*/
      set OP0IM001.OP3ONOQT[1] cursor, normal;
         /* OP0IS62    ;   re-set mdt's for chnd flds*/
      OP0IS51(); /* re-build sizes on map*/
      exit stack; /* go back to show screen 2*/
    end
  end


      /* check that verify should be done*/

  if (OPWREC.OPWSFLOW == "1" /* data entry form flow*/
   && OPWREC.OPWREVM != 7    /* and not review mode*/
   && OPWREC.OP2LNINB == 0   
   && OPWREC.OP2TONOQ[OP0IWSBP] != 0) /* and not zero*/
    OP0IS6B(); /* verify first/last size, &qty*/
  end


  OP0IS6C(); /* edit 40 sizes for active*/
                                 /* ; reject if no active sizes*/

  OP0IS6D(); /* ok, set pack handle flag/auth reqd*/

  OP0IS6E(); /* ok, write record*/

   /* write hot model override rec if appropriate*/

   /* 08/07/89  bypass hot model logic if promo division*/
             /* or not first quality*/

  if (OP1REC.XDVCD == "03" /* if promo*/
   || OPWREC.XQACD != "01") /* or not first quality*/
      /* next sentence         bypass hot model logic*/
  else
    if (SYCREC.OPZHMIND == "Y")
      if (OP0IW01.OP0IWELI == "N"
       && OP0IW01.OP0IWAUT == "Y")
        OP0ISOV();
      end
    end
  end

  OP0IS89(); /* transfer flow to other applic*/



end // end OP0IS64

// pf21-activate sizes, full rnge
Function OP0IS65()



      /* ********************************************************/
      /* * re-set w-s map size range to be full size range     **/
      /* * convert valid size to active size for revu & duplict**/
      /* ********************************************************/



  OP0IW01.OP0IWSMF = OP0IW01.OP0IWSZF;
                                   /* set first map size=full rnge*/
  OP0IW01.OP0IWSML = OP0IW01.OP0IWSZL;
                                   /* set last map size=full range*/

  OP0IW01.OP0IWSCR = 1; /* re-set to screen 1*/

  if (OPWREC.OPWREVM == 7 /* if in review mode*/
   || OPWREC.OP2LNINB > 0 
   || OPWREC.OPWDUPSZ[OP0IWSBP] == "D") /* or duplicated product*/
    OP0IS6F(); /* convert valid sizes to active*/
  end

  OP0IS51(); /* move sizes to map*/



end // end OP0IS65

// put size prices on the map
Function OP0IS66()



      /* ********************************************************/
      /* * loop 20 sizes, move price to map*/
      /* **/
      /* * note - op0iwsmf/l were set before got here*/
      /* *        could be reqstd range, full rnge or actual rnge*/
      /* ********************************************************/


     /* cond code display takes precedent over prc ovrd.*/


  if (OP0IW01.OP0IWDAV == "Y" /* if displaying availability*/
   && OP0IW01.OP0IWHAR == "Y") /* and have avail record*/
     /* next sentence*/
  else
    OP0IM001.OP0IMLPO[1] = "PRC OVRD";
    OP0IM001.OP0IMLPO[2] = "PRC OVRD";
  end



  if (OP0IW01.OP0IWSCR == 1) /* if on screen 1*/
    OP0IWSBR = OP0IW01.OP0IWSMF; /* find first size to move*/
  else
    OP0IWSBR = OP0IW01.OP0IWSB2; /* screen 2 starting size*/
  end


  OP0IW01.OP0IWSBM = 1; /* map index = 1 to start*/
  OP0IW01.OP0IWPOF = " ";

  while (OP0IW01.OP0IWSBM < 21 /* for up to 20 sizes*/
   && OP0IW01.OP0IWSBR < 41 
   && OP0IW01.OP0IWSBR <= OP0IW01.OP0IWSML) /* until end of chosen range*/
    if (OP3REC.OP3SZAFL[OP0IWSBR] == "Y")
      OP0IS53(); /* move size price and * flag to map*/
      OP0IW01.OP0IWSBM = OP0IW01.OP0IWSBM + 1; /* next map column*/
    end
    OP0IW01.OP0IWSBR = OP0IW01.OP0IWSBR + 1; /* try next size in record*/
  end



end // end OP0IS66

// process pf5 -product subst
Function OP0IS67()
   /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * **/
    /* 1. fills in parameters to be passed to product*/
        /* substitution (av0l)*/
    /* 2. saves the commarea, etc... in xsrrec for later*/
        /* retrieval.*/

    /* Note: * For OP1REC database changes, XSRREC.XSRDATA length*/
            /* will be affected as well as OSKREC.*/
          /* * Currently, the value of XSRREC.XSRLNGTH is 3072.*/
            /* If op1rec, opwrec, or oskrec changes, this will*/
            /* also change.*/

   /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * **/


  set XSRREC empty;
  set OSKREC empty;

                                     /* SET-UP XSRREC TO BE SAVED*/

  XSRREC.XSRSYSID = "OP0I";
  XSRREC.XSRSUBID = COMMAREA.CAUSERID;

  OP0IS6P(); /* move/truncate op1cuoid to xsrsqnbr*/


  OSKREC.XWHCD = COMMAREA.XWHCD;
  OSKREC.XDVCD = COMMAREA.XDVCD;
  OSKREC.XSOCD = OP1REC.XSOCD;
  OSKREC.XNDCD = COMMAREA.XNDCD;
  OSKREC.XGPCD = COMMAREA.XGPCD;

  OPWREC.OP1GROUP = OP1REC.OP1GROUP;
  OSKREC.OS-USER-WORKAREA = OPWREC.OPWSGRP;


  XSRREC.XSRDATA = OSKREC.OSKGROUP;
  XX0XS01(); /* get date and time*/
  XSRREC.ZZZCHGDT = XX0XW01.XX0XWDAT;
  XSRREC.ZZZCHGTM = XX0XW01.XX0XWTIM;
  XSRREC.ZZZCHGCT = 0;
  XSRREC.XSRLNGTH = 3072; /* length of xsrdata/oskrec*/


  OP0IS6S(); /* WRITE XSRREC*/


                                    /* SET-UP OSGREC TO BE PASSED*/

  OSGREC.XSRSYSID = XSRREC.XSRSYSID; /* set-up the keys to xsrrec*/
  OSGREC.XSRSUBID = XSRREC.XSRSUBID; /* for later retrieval when*/
  OSGREC.XSRSQNBR = XSRREC.XSRSQNBR; /* comming back from subs.*/


   /* ***  The original source product and criteria codes will*/
   /* ***  only be initialized once in osgrec for every change*/
   /* ***  in products 1 thru 6. (Remember OP0I processes six*/
   /* ***  products at a time (max) from OP0H.)*/
   /* ***  Also, coming in fresh from OP0H, OSGREC will be*/
   /* ***  empty.*/

  if (OP0IW01.OP0IWSBP != OSGREC.OSGPRSUB /* product pointer changed*/
   || OSGREC.XGPCD == " ")                /* OSGREC is initially empty*/
    OSGREC.OSGPRSUB = OP0IW01.OP0IWSBP; /* save product pointer (1-6)*/
    OSGREC.KUCCOID = OP1REC.KUCCOID;
    OSGREC.KUMSTRID = OP1REC.KUMSTRID;
    OSGREC.XNXCD = OP1REC.XNXCD;
    OSGREC.OP1ORDBY = OP1REC.OP1ORDBY;
    OSGREC.XGPCD = OP1REC.XGPCD;

    /* ---------------------------------------------------------*/
     /* Product may have already been substituted in OP0H.*/
     /* Use the original product entered in OP0H if substitution*/
     /* was done.*/
    /* ---------------------------------------------------------*/
    if (OPWREC.OP2SSTYN[OP0IWSBP] != " ")
       /* Substitution in OP0H was done.*/
      OSGREC.SY1STNBR = OPWREC.OP2SSTYN[OP0IWSBP];
      OSGREC.SY2CLRID = OPWREC.OP2SCLCD[OP0IWSBP];
      OSGREC.XDMCD = OPWREC.OP2SDMCD[OP0IWSBP];
    else
       /* Substitution not done.*/
      OSGREC.SY1STNBR = OPWREC.SY1STNBR[OP0IWSBP];
      OSGREC.SY2CLRID = OPWREC.SY2CLRID[OP0IWSBP];
      OSGREC.XDMCD = OPWREC.XDMCD[OP0IWSBP];
    end

     /* ******MOVE OPWREC.XOWCD TO OSGREC.XOWCD*********/
      /* changed with screened product processing june/91 - bbake2*/
      /* when substituting products, owner group code for the*/
      /* product on the screen is used.  This may not*/
      /* be the same as the default owner group code for the*/
      /* order, which is in opwrec.xowcd*/

    OSGREC.XOWCD = OP0IM001.XOWCD;

    OSGREC.XSDCD = OPWREC.PC2INSEG[OP0IWSBP];
    OSGREC.XSACD = OP3REC.XEGCD;
    OSGREC.XPGCD = OPWREC.XPGCD[OP0IWSBP];
    OSGREC.XUMCD = OPWREC.XUMCD[OP0IWSBP];

    OSGREC.XLCCD = OP0IW01.XLCCD;
    OSGREC.XQACD = OPWREC.XQACD;
    OSGREC.XOTCD = OP1REC.XOTCD;

    OPAREC.OPAFDT = OP0IM001.OP0IMNDT; /* mmddyy format*/

    /* --- Y2k code added 03/31/99 ---*/
    if (OPAREC.OPAFYY > 56)
      OPAREC.OPAWCC = 19;
    else
      OPAREC.OPAWCC = 20;
    end
    /* --- end of Y2k code ---*/

    /* MOVE 19 TO OPAREC.OPAWCC;*/
    OPAREC.OPAWYY = OPAREC.OPAFYY;
    OPAREC.OPAWMM = OPAREC.OPAFMM;
    OPAREC.OPAWDD = OPAREC.OPAFDD;
    OSGREC.OP1CUNDT = OPAREC.OPAWDT; /* ccyymmdd format*/

    OSGREC.XWHCD = OP0IM001.XWHCD;
    OSGREC.OPWRQSZF = OPWREC.OPWRQSZF[OP0IWSBP];
    OSGREC.OPWRQSZL = OPWREC.OPWRQSZL[OP0IWSBP];
  end

  OSGREC.OP2SSTYN = " ";
  OSGREC.OP2SCLCD = " ";
  OSGREC.OP2SDMCD = " ";

  COMMAREA.CA-USER-WORKAREA-4K = OSGREC.OSGGROUP;


  COMMAREA.CATOAP = "AV0L";
  XSEXIT();





end // end OP0IS67

// reject prod-adjust totals
Function OP0IS68()



      /* ******************************************/
      /* * control processes to delete 1 product*/
      /* ******************************************/

  TA1REC.TA1LOCAT[2] = "OP0IS68"; /* error diag-group name*/


  OP0IS93(); /* delete data base record*/


      /* release data base resources*/

  VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
  VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
  sysLib.commit();
  VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
   /* commit deletion*/


      /* mark product as being rejected*/

  sysVar.arrayIndex = OPWREC.OP2LNINB; /* use line item # as index*/
  OPWREC.OPWSELCD[sysVar.arrayIndex] = "R";


      /* subtract 1 from number products on order*/

  OPWREC.OPWPITM = OPWREC.OPWPITM - 1;



end // end OP0IS68

// verify first size, multi scrns
Function OP0IS69()



      /* *************************************************/
      /* * data entry mode, but not in review, requires*/
      /* * verifying first/last sizes entered*/
      /* * and matching quantity.  these values were*/
      /* * entered on the product header screen.*/
      /* * note - this edits only the first size*/
      /* *   other edits done elsewhere (happy hunting)*/
      /* *************************************************/

  TA1REC.TA1LOCAT[2] = "OP0IS69"; /* error diag group name*/


      /* *************************************/
      /* * check that verify should be done*/
      /* *************************************/

  if (OPWREC.OPWSFLOW == "1" /* data entry form flow*/
   && OPWREC.OPWREVM != 7    /* and not review mode*/
   && OPWREC.OP2LNINB == 0) 
    /* next sentence*/
  else
    return; /* else exit*/
  end


  if (OP0IW01.OP0IWVSF == "N") /* if this test not yet done*/
    if (XOTTBL.XOTSZVER[OP0IWSBO] == "Y")
                                   /* &test should be done for ordtype*/
      OP0IW01.OP0IWVSF = "Y"; /* flag first size test being done*/
    else
      return; /* else exit*/
    end
  else
    return;
  end


      /* *****************************/
      /* * verify first size has qty*/
      /* *****************************/

  OP0IW01.OP0IWFND = "N";
  sysVar.arrayIndex = OPWREC.OPWRQSZF[OP0IWSBP];

  if (OP3REC.OP3SZAFL[sysVar.arrayIndex] == "Y") /* if requested size*/
    if (OP3REC.OP3ONOQT[sysVar.arrayIndex] > 0) /* active and qty > 0*/
      OP0IW01.OP0IWFND = "Y"; /* then first size has qty*/
    end
  end

  if (OP0IW01.OP0IWFND == "N")
    OPAREC.OPAERR = "Y"; /* if no match*/
    converseLib.validationFailed(167);
                                   /* warning-qty not entered for f/l sizes*/
    set OP0IM001.OP0IMRSF skip, bold;
    OP0IWSBR = OP0IW01.OP0IWSZF; /* set first size cursor*/
    OP0IWSBM = 1;
    while (OP0IWSBM < 21
     && OP0IWSBR < 41
     && OP0IWSBR <= OP0IWSZL)
      if (OP3REC.OP3SZAFL[OP0IWSBR] == "Y")
        if (OP0IWSBR == OPWREC.OPWRQSZF[OP0IWSBP])
          set OP0IM001.OP3ONOQT[OP0IWSBM] cursor;
        end
        OP0IWSBM = OP0IWSBM + 1;
      end
      OP0IWSBR = OP0IWSBR + 1;
    end
  end


      /* **********************************************/
      /* * if all o.k., exit - else set-up map line 4*/
      /* **********************************************/

  if (OPAREC.OPAERR == "N")
    OP0IS50(); /* re-set attributes dark*/
    return;
  end


      /* ********************************************************/
      /* * map line 4 - normally blank, unless error in verify **/
      /* ********************************************************/

      /* move words, size descrp(from product size scale record)*/
      /* for requested first/last sizes, and quantity.*/

  OP0IM001.OP0IMWDF = "FIRST SIZE:";
  OP0IM001.OP0IMWDL = "LAST SIZE:";
  OP0IM001.OP0IMWDQ = "TOTAL QTY:";
  sysVar.arrayIndex = OPWREC.OPWRQSZF[OP0IWSBP]; /* get subscript*/
  OP0IM001.OP0IMRSF = SY4REC.SY4IDDSC[sysVar.arrayIndex]; /* reqd 1st sz*/
  sysVar.arrayIndex = OPWREC.OPWRQSZL[OP0IWSBP]; /* get subscript*/
  OP0IM001.OP0IMRSL = SY4REC.SY4IDDSC[sysVar.arrayIndex]; /* reqd lst sz*/
  OP0IM001.OP2TONOQ = OPWREC.OP2TONOQ[OP0IWSBP]; /* total qty*/

  exit stack; /* go back to show screen*/



end // end OP0IS69

// get nil price type codes
Function OP0IS6A()




  KUCREC.KUCCOID = OP1REC.KUCCOID;
  OP0IS9C(); /* read the customer rec (kucrec)*/

     /* save the account class of the company in case kucrec*/
     /* later contains info on the comp nbr rather than the co.*/

  OP0IW01.XAUCD = KUCREC.XAUCD;


   /* *  for nike international orders, price type code can*/
   /* *  come from several sources:*/
   /* *  - if the customer is a nil distributor*/
   /* *        the price type code comes from nimrec*/
   /* *  - if the customer is nike owned or exports*/
   /* *    and the order type is sample*/
   /* *    and it is a direct ship or from the nil warehse*/
   /* *        the price type code comes from the invoicing*/
   /* *        specialty table using the account class of the*/
   /* *        company as part of the key*/
   /* *  - if the customer is nike owned or exports*/
   /* *    and the order type is sample*/
   /* *    and the item comes from a regular warehouse (not 12)*/
   /* *        the price type code comes from the invoicing*/
   /* *        specialty table using the account class of the*/
   /* *        comp number as part of the key*/
   /* *  - if the customer is nike owned or exports*/
   /* *    and the order type is not a sample*/
   /* *    and the comp number is entered*/
   /* *        the price type code comes from the invoicing*/
   /* *        specialty table using the account class of the*/
   /* *        comp number as part of the key*/
   /* *  - if the customer is nike owned or exports*/
   /* *    and the order type is not sample*/
   /* *    and the comp number is not entered*/
   /* *        the price type code comes from the invoicing*/
   /* *        specialty table using the account class of the*/
   /* *        company as part of the key*/


  if (OP0IW01.XAUCD == "33") /* if the customer is a nil distrib*/
    OP0IS9D(); /* get price type from nimrec*/
  else /* otherwise*/
    if (OP0IW01.XAUCD == "31" /* if cust acct class is nike owned*/
     || OP0IW01.XAUCD == "32") /* or exports get it from inv specl tb*/
      if (OP1REC.XOBCD == "S1") /* if order type is sample*/
        if (OP1REC.XWHCD == " ") /* if direct ship*/
          OP0IS6O(); /* use cust acct class in key*/
        else /* otherwise*/
          OP0IS6N(); /* use comp acct class in key*/
        end
      else /* if not a sample*/
        if (OP1REC.OP1CMPNB == 0) /* if comp nbr not entered*/
          OP0IS6O(); /* use cust acct class in key*/
        else /* otherwise*/
          OP0IS6N(); /* use comp acct class in key*/
        end
      end
    else /* all else (xaucd ne 31,32,or33)*/
      OP0IW01.OP0IWZPR = "Y"; /* give the item a zero price*/
    end
  end



end // end OP0IS6A

// verify first/last sizes, & qty
Function OP0IS6B()



      /* *************************************************/
      /* * data entry mode, but not in review, requires*/
      /* * verifying first/last sizes entered*/
      /* * and matching quantity.  these values were*/
      /* * entered on the product header screen.*/
      /* * note - the sizes edit is done only once,*/
      /* *   as a warning that qty not entered on specified*/
      /* *   first or last size.*/
      /* * note - the quantity edit must match - but the*/
      /* *   user may change the value to be matched.*/
      /* * note - edit reverse sequence, for scrn clarity*/
      /* *************************************************/

  TA1REC.TA1LOCAT[2] = "OP0IS6B"; /* error diag group name*/


      /* ********************************************************/
      /* * edit qty entered vs qty requested.*/
      /* * op3rec has total qty, from edit check of active sizes*/
      /* * opwrec 6 prod array has requested qty from prod hdr.*/
      /* ********************************************************/

  if (OP3REC.OP2TONOQ == OPWREC.OP2TONOQ[OP0IWSBP]) /* calc vs reqstd*/
    /* next sentence*/
  else
    OPAREC.OPAERR = "Y";
    OP0IS6J(); /* create error message*/
    set OP0IM001.OP2TONOQ cursor, bold;
  end


      /* ************************************/
      /* * verify last/first size has qty*/
      /* ************************************/

  if (XOTTBL.XOTSZVER[OP0IWSBO] == "Y")
                                   /* if test should be done for ordtype*/
    if (OP0IW01.OP0IWVSL == "N") /* if last size test not yet done*/
      OP0IW01.OP0IWVSL = "Y"; /* flag as being done*/
      OP0IW01.OP0IWFND = "N";
      sysVar.arrayIndex = OPWREC.OPWRQSZL[OP0IWSBP];
      if (OP3REC.OP3SZAFL[sysVar.arrayIndex] == "Y") /* if requested size*/
        if (OP3REC.OP3ONOQT[sysVar.arrayIndex] > 0) /* active and qty > 0*/
          OP0IW01.OP0IWFND = "Y"; /* then last size has qty*/
        end
      end
      if (OP0IW01.OP0IWFND == "N")
        OPAREC.OPAERR = "Y"; /* if no match*/
        converseLib.validationFailed(167);
                                   /* warning-qty not entered for last size*/
        set OP0IM001.OP0IMRSL skip, bold;
        if (OP0IW01.OP0IWP21 == "Y")
          OP0IW01.OP0IWSBR = OP0IW01.OP0IWSZF;
        else
          OP0IW01.OP0IWSBR = OPWREC.OPWRQSZF[OP0IWSBP];
        end
        OP0IW01.OP0IWSBM = 1;
        while (OP0IW01.OP0IWSBM < 21
         && OP0IW01.OP0IWSBR < 41
         && OP0IW01.OP0IWSBR <= OP0IW01.OP0IWSZL)
          if (OP3REC.OP3SZAFL[OP0IWSBR] == "Y")
            if (OP0IW01.OP0IWSBR == OPWREC.OPWRQSZL[OP0IWSBP])
              set OP0IM001.OP3ONOQT[OP0IWSBM] cursor;
            end
            OP0IW01.OP0IWSBM = OP0IW01.OP0IWSBM + 1;
          end
          OP0IW01.OP0IWSBR = OP0IW01.OP0IWSBR + 1;
        end
      end
    end
    if (OP0IW01.OP0IWVSF == "N") /* if have not tested first size,*/
      OP0IW01.OP0IWVSF = "Y"; /* flag first size test being done*/
      OP0IW01.OP0IWFND = "N";
      sysVar.arrayIndex = OPWREC.OPWRQSZF[OP0IWSBP];
      if (OP3REC.OP3SZAFL[sysVar.arrayIndex] == "Y") /* if requested size*/
        if (OP3REC.OP3ONOQT[sysVar.arrayIndex] > 0) /* active and qty > 0*/
          OP0IW01.OP0IWFND = "Y"; /* then first size has qty*/
        end
      end
      if (OP0IW01.OP0IWFND == "N")
        OPAREC.OPAERR = "Y"; /* if no match*/
        converseLib.validationFailed(167);
                                   /* warning-qty not entered for f/l sizes*/
        set OP0IM001.OP0IMRSF skip, bold;
        if (OP0IW01.OP0IWP21 == "Y")
          OP0IW01.OP0IWSBR = OP0IW01.OP0IWSZF;
        else
          OP0IW01.OP0IWSBR = OPWREC.OPWRQSZF[OP0IWSBP];
        end
        OP0IW01.OP0IWSBM = 1;
        while (OP0IW01.OP0IWSBM < 21
         && OP0IW01.OP0IWSBR < 41
         && OP0IW01.OP0IWSBR <= OP0IW01.OP0IWSZL)
          if (OP3REC.OP3SZAFL[OP0IWSBR] == "Y")
            if (OP0IW01.OP0IWSBR == OPWREC.OPWRQSZF[OP0IWSBP])
              set OP0IM001.OP3ONOQT[OP0IWSBM] cursor;
            end
            OP0IW01.OP0IWSBM = OP0IW01.OP0IWSBM + 1;
          end
          OP0IW01.OP0IWSBR = OP0IW01.OP0IWSBR + 1;
        end
      end
    end
  end


      /* *********************************************************/
      /* * if all o.k., exit - else show map line of verify data*/
      /* *********************************************************/

  if (OPAREC.OPAERR == "N")
    OP0IS50(); /* re-set attributes dark*/
    return;
  end


      /* ********************************************************/
      /* * map line 4 - normally blank, unless error in verify **/
      /* ********************************************************/

      /* move words, size descrp(from product size scale record)*/
      /* for requested first/last sizes, and quantity.*/

  OP0IM001.OP0IMWDF = "FIRST SIZE:";
  OP0IM001.OP0IMWDL = "LAST SIZE:";
  OP0IM001.OP0IMWDQ = "TOTAL QTY:";
  sysVar.arrayIndex = OPWREC.OPWRQSZF[OP0IWSBP]; /* get subscript*/
  OP0IM001.OP0IMRSF = SY4REC.SY4IDDSC[sysVar.arrayIndex]; /* reqd 1st sz*/
  sysVar.arrayIndex = OPWREC.OPWRQSZL[OP0IWSBP]; /* get subscript*/
  OP0IM001.OP0IMRSL = SY4REC.SY4IDDSC[sysVar.arrayIndex]; /* reqd lst sz*/
  OP0IM001.OP2TONOQ = OPWREC.OP2TONOQ[OP0IWSBP]; /* total qty*/

  exit stack; /* go back to show screen*/



end // end OP0IS6B

// clean-up sizes before write
Function OP0IS6C()


    /* don't accept this order if order type says disp*/
    /* avail and we don't have an availability record.*/


  if (OP0IW01.OP0IWDAV == "Y" /* if disp avail*/
   && OP0IW01.OP0IWHAR == "N") /* and don't have recor*/
    converseLib.validationFailed(150); /* chg something to get avail or reject*/
    set OP0IM001.OP0IMNDT modified, bold;
    set OP0IM001.XWHCD cursor, modified, bold;
    set OP0IM001.XOWCD modified, bold;
    exit stack;
  end



      /* check each size, zero quantity = inactive size*/


  if (OP3REC.OP2TONOQ == 0) /* no active sizes*/
    converseLib.validationFailed(153); /* product rejected -- zero quantity*/
    OPAREC.OPAERR = "Y"; /* exit*/
    exit stack;
  end




    /* don't accept this item if order type says at once*/
    /* and we can't allocate the item due to some restriction*/
    /* skip edit if in review mode.*/

  if (OPWREC.OPWREVM != 7
   || OPWREC.OP2LNINB == 0)
    if (XOTTBL.XOTATONF[OP0IWSBO] == "Y"
     && OP0IW01.OP0IWALO == "N"  
     && OP0IW01.OP0IWPND == "N"  
     && OP0IW01.OP0IWBDF != "DC" /* and not a draw order*/
     && OP0IW01.OP0IWBDF != "DR" 
     && OP0IW01.OP0IWBDF != "DX")
      set OP0IM001.OP3ONOQT[1] cursor;
      converseLib.validationFailed(328); /* chg something to allocate or reject*/
      exit stack;
    end
  end



  OP0IW01.OP0IWSBR = OP0IW01.OP0IWSZF; /* loop full size range*/

  while (OP0IWSBR < 41
   && OP0IWSBR <= OP0IWSZL)
    if (OP3REC.OP3SZAFL[OP0IWSBR] == "Y") /* check active sizes*/
      if (OP3REC.OP3ONOQT[OP0IWSBR] == 0) /* zero qty inactivates*/
        OP3REC.OP3SZAFL[OP0IWSBR] = "N"; /* the size*/
      end
    end
    OP0IWSBR = OP0IWSBR + 1;
  end



end // end OP0IS6C

// pack hndl cd=flag on;chk auth
Function OP0IS6D()



      /* if any pack handle code on the product*/
      /* turn on the order header flag*/
   /* * BSSA project * rharat * begin * 04/21/2000 ******************/
   /* * as part of BSSA project following changes are made:        **/
   /* * If the handling charge is overridden by system,autorization**/
   /* * is not needed for the order. User overrides will still need**/
   /* * an autorization for accepting the order into system.       **/
   /* * BSSA project * rharat *  end  * 04/21/2000 ******************/

  TA1REC.TA1LOCAT[2] = "OP0IS6D"; /* error diag group name*/


      /* ? ? ? ? ? ? ? ? ? ? ? ? ? ?   ?? ? ? ? ? ? ?*/
      /* * note - not valid in order maintenance,*/
      /* * since override may exist from previous change,*/
      /* * not this change*/
      /* ? ? ? ? ? ? ? ? ? ? ? ? ? ?   ?? ? ? ? ? ? ?*/



  sysVar.arrayIndex = 1;

  while (sysVar.arrayIndex < 6) /* loop 5 pack handle codes*/
    if (OP3REC.XHDCD[sysVar.arrayIndex] != " ")
      OP1REC.OP1SPHDF = "Y";
    end
    if (OP3REC.OP2HCHGO[sysVar.arrayIndex] == "Y")
      /* bssa chagnes * begin * 04/21/2000 ************************/
      if (OP0IW01.OP0IW-SYST-HNDCHG-OVRD == "Y") /* syst override*/
        if (OP0IW01.OP0IW-USER-HNDCHG-OVRD == "Y") /* & user override*/
          OPWREC.OPWAUTFL = "Y"; /* authorization required*/
        else /* ord has bssa ovrd & has no user ovrd*/
          /* autorization not required*/
        end
      else /* hndl ovrd set by user*/
        /* bssa chagnes *  end  * 04/21/2000 ************************/
        OPWREC.OPWAUTFL = "Y"; /* authorization required*/
      end
    end
    sysVar.arrayIndex = sysVar.arrayIndex + 1;
  end



end // end OP0IS6D

// add/updt szrun,do sub-ord tots
Function OP0IS6E()


      /* ********************************************************/
      /* * put (new) nike sub-order into key*/
      /* * if adding product, build key-product line item #,*/
      /* *    then add.*/
      /* * if reviewing product: update, or delete/add (if chged)*/
      /* ********************************************************/


  TA1REC.TA1LOCAT[2] = "OP0IS6E"; /* error diag group name*/


      /* ********************************************************/
      /* * put nike sub-order code into key*/
      /* * add prod = new code, review prod maybe = new code*/
      /* ********************************************************/

  OP3REC.OP1NORID = OP0IW01.OP0IWSBS;


      /* if need date changed after quantities entered,*/
      /* then the production deadline flag may have been changed*/
      /* and the quantities may be in the wrong buckets.*/
      /* if produc add-on flag = y, qty in on-order*/
                            /* = n, qty in on-order & original*/
      /* skip re-edit for draw orders, and orders entered*/
      /* with at-once order types. ( displaying avail )*/

  if (OP0IW01.OP0IWBDF != "DC" /* cust draw*/
   && OP0IW01.OP0IWBDF != "DN" /* nike draw*/
   && OP0IW01.OP0IWBDF != "DR" /* rebook draw*/
   && OP0IW01.OP0IWBDF != "DS" /* smart draw*/
   && OP0IW01.OP0IWBDF != "DX") /* flexible draw*/
    sysVar.arrayIndex = OP0IW01.OP0IWSMF; /* for active sizes*/
    while (sysVar.arrayIndex < 41
     && sysVar.arrayIndex <= OP0IW01.OP0IWSML)
      if (OP3REC.OP3SZAFL[sysVar.arrayIndex] == "Y")
        if (OP0IW01.OP0IW-DAYS-PAST-CUTOFF < 60)
          OP3REC.OP3ORGQT[sysVar.arrayIndex] = OP3REC.OP3ONOQT[sysVar.arrayIndex];
        else
          OP3REC.OP3ORGQT[sysVar.arrayIndex] = 0; /* after prod deadline*/
        end
      end
      sysVar.arrayIndex = sysVar.arrayIndex + 1;
    end
  end


      /* ************************************/
      /* * put in current date/time stamp*/
      /* ************************************/

  OP3REC.ZZZCHGDT = OPAREC.OPACDT;
  OP0IW03.ZZZCHGDT = OPAREC.OPACDT;
  PK1REC.ZZZSDT = OPAREC.OPACDT;
  PK1REC.ZZZCHGDT = OPAREC.OPACDT;
  OPIREC.ZZZSDT = OPAREC.OPACDT; /* 7-23-87*/
  OPIREC.ZZZCHGDT = OPAREC.OPACDT; /* 7-23-87*/

  OP3REC.ZZZCHGTM = OP0IW01.OP0IWTM3; /* hhmm binary*/
  OP0IW03.ZZZCHGTM = OP0IW01.OP0IWTM3; /* hhmm binary*/
  PK1REC.ZZZSTM = OP0IW01.OP0IWTM3;
  PK1REC.ZZZCHGTM = OP0IW01.OP0IWTM3;
  OPIREC.ZZZCHGTM = OP0IW01.OP0IWTM3; /* 7-23-87*/


  if (OP0IW01.OP0IWCHG == "Y" /* if change made to record*/
   || OPWREC.OPWDUPSZ[OP0IWSBP] == "D") /* or duped size run*/
    if (OPWREC.OPWREVM == 7
     || OPWREC.OP2LNINB > 0)
         /* NEXT SENTENCE;*/
    else
      OP0IS9A(); /* check for duplicate record*/
    end
  end



   /* for draw orders go update the bulk order.*/

  if (OP0IW01.OP0IWBDF == "DC" /* cust draw*/
   || OP0IW01.OP0IWBDF == "DN" /* nike draw*/
   || OP0IW01.OP0IWBDF == "DR" /* rebook draw*/
   || OP0IW01.OP0IWBDF == "DS" /* smart draw*/
   || OP0IW01.OP0IWBDF == "DX") /* flexible draw*/
    if (OPWREC.OPWREVM == 7 /* if in review mode*/
     || OPWREC.OP2LNINB > 0)
      if (OP0IW01.OP0IWCHG == "Y") /* if changes made*/
        OP0ISUC(); /* update bulk with changed qty*/
      end
    else
      OP0ISUB(); /* perform Update Bulk routine*/
    end
  end


   /* update inventory and availability for a/o if:*/
      /* 1. we are displaying avail ( at-once ord typ).*/
      /* 2. and all quantities are allocatable,*/
      /* 3. and order type alloc flag is on.*/
      /* 4. and order type is at once.*/
      /* 5. and need date is today.*/
   /* *Golf Cresting project * #TT4073 * begin * rharat ***************/
      /* 6. and sales office is not 59.*/
      /* All the orders for golf crested product should be put on alloc*/
      /* hold till the cresting is done. Don't allocate sales office 59*/
      /* orders. CSR's will release hold and resrv/alloc when product is*/
      /* ready to be shipped.  Look for Golf cresting in for changes **/
   /* *Golf Cresting project * #TT4073 * begin * rharat ***************/

   /* else call op1610*/

  OP0IW01.OP0IWEZ1 = VGVar.currentShortGregorianDate; /* current date*/
  OP0IW01.OP0IWDT1 = OP0IW01.OP1CUNDT; /* yymmdd*/

  OP0IS6K(); /* build opprec*/


  if (OP0IW01.OP0IWDAV == "Y"              /* if display avail or*/
   && OP0IW01.OP0IWALO == "Y"              /* if all sizes allocatable*/
   && XOTTBL.XOTOALOC[OP0IWSBO] == "Y"     
   && XOTTBL.XOTATONF[OP0IWSBO] == "Y"     
   && OP0IW01.OP0IWDT3 == OP0IW01.OP0IWEZ1 /* if need date = today*/
   && OP1REC.XSOCD != "59")                /* Golf cresting in * #TT4073 **/
    OPAREC.OPASUB1 = 0; /* count # deadlocks*/
    while (OPAREC.OPASUB1 < 6)
      OPAREC.OPASUB1 = OPAREC.OPASUB1 + 1;
      if (OPWREC.OPWREVM == 7 /* if review mode*/
       || OPWREC.OP2LNINB > 0)
        if (OP3REC.OP2LNIST == "AL" /* if previously allocated*/
         && OP0IW01.OP0IWNSO == OP0IW01.OP0IWSBS) /* new sub = old sub*/
          if (OP0IW01.OP0IWCHG == "Y")
            OP0ISCI(); /* change inventory*/
          else
            OPAREC.OPASUB1 = 9;
          end
        else
          OP0ISAI(); /* allocate inventory*/
        end
      else
        OP0ISAI(); /* allocate inventory*/
      end
    end
    if (OPAREC.OPASUB1 == 6) /* too many deadlocks*/
      converseLib.validationFailed(6); /* records busy -- try again*/
      exit stack;
    end
  end






  if (OP0IW01.OP0IWDAV == "S"              
   && OP0IW01.OP0IWALO == "Y"              
   && XOTTBL.XOTOALOC[OP0IWSBO] == "Y"     
   && XOTTBL.XOTATONF[OP0IWSBO] == "Y"     
   && OP0IW01.OP0IWDT3 == OP0IW01.OP0IWEZ1 /* if need date = today*/
   && OP1REC.XSOCD != "59")                /* Golf cresting in * #TT4073 **/
    OPAREC.OPASUB1 = 0; /* count # deadlocks*/
    while (OPAREC.OPASUB1 < 6)
      OPAREC.OPASUB1 = OPAREC.OPASUB1 + 1;
      if (OPWREC.OPWREVM == 7 /* if review mode*/
       || OPWREC.OP2LNINB > 0)
        if (OP3REC.OP2LNIST == "AL" /* if previously allocated*/
         && OP0IW01.OP0IWNSO == OP0IW01.OP0IWSBS) /* new sub = old sub*/
          if (OP0IW01.OP0IWCHG == "Y")
            OP0ISSC(); /* change inventory*/
          else
            OPAREC.OPASUB1 = 9;
          end
        else
          OP0ISSA(); /* allocate inventory*/
        end
      else
        OP0ISSA(); /* allocate inventory*/
      end
    end
    if (OPAREC.OPASUB1 == 6) /* too many deadlocks*/
      converseLib.validationFailed(6); /* records busy -- try again*/
      exit stack;
    end
  end


  if (OP0IW01.OP0IWDAV == "Y") /* display availability*/
    call "OP1610" (OPPREC, SQLCA) {isNoRefresh = yes, isExternal = yes}; /* decrement avail*/
    OP0IS6L(); /* process return code*/
  end

  set OPPREC empty; /* reinitialize for next product*/


      /* ****************************************/
      /* * separate writes, for add/review mode*/
      /* ****************************************/

  if (OPWREC.OPWREVM == 7 /* in review mode*/
   || OPWREC.OP2LNINB > 0)
    if (OP0IW01.OP0IWCHG == "Y") /* and any item changed*/
      if (OP0IW01.OP0IWNSO == OP3REC.OP1NORID)
        OP0IS92(); /* key not chgd, update*/
      else
        OP3REC.OP1NORID = OP0IW01.OP0IWNSO; /* key changed . .*/
        OP0IS93(); /* delete original key and*/
        OP3REC.OP1NORID = OP0IWSBS;
        OP0IS90(); /* add new key*/
      end
    end
    sysVar.arrayIndex = OPWREC.OP2LNINB; /* mark product as viewed*/
    OPWREC.OPWSELCD[sysVar.arrayIndex] = "V"; /* use line item # as index*/
    OPAREC.OP1NORID = OP0IWSBS; /* split to hex*/
    OPWREC.OPWHEXNO[sysVar.arrayIndex] = OPAREC.OPWHEXNO; /* replace sub-ord #*/
  else
    if (OP0IW01.OP0IWBDF == "BC"
     || OP0IW01.OP0IWBDF == "BS"
     || OP0IW01.OP0IWBDF == "BX")
      OP3REC.OP2TDRWQ = 0;
    end
    OP3REC.ZZZSDT = OP3REC.ZZZCHGDT; /* add times = chg times*/
    OP3REC.ZZZSTM = OP3REC.ZZZCHGTM;
    OPWREC.OPWLSTLI = OPWREC.OPWLSTLI + 1; /* up last line item # by 1*/
    if (OPWREC.OPWLSTLI > 900) /* limited to 900 prodts on order*/
      OPAREC.OPAERR = "Y";
      OP0IW01.OP0IWREJ = "Y";
      converseLib.validationFailed(188);
      return;
    end
    OP3REC.OP2LNINB = OPWREC.OPWLSTLI; /* set up new key*/
    OP3REC.OP2CPLNB = OPWREC.OPWLSTLI; /* cust po line nbr*/
    sysVar.arrayIndex = OPWREC.OPWLSTLI; /* enter prod into 900 array*/
    OPAREC.OP1NORID = OP0IWSBS;
    OPWREC.OPWHEXNO[sysVar.arrayIndex] = OPAREC.OPWHEXNO;
    OP0IS90(); /* go add op3rec*/
    OPWREC.OPWPITM = OPWREC.OPWPITM + 1; /* add 1 to # prods on order*/

    if (OP1REC.XDVCD == "02") /* if nil order &*/
      if (OP0IW01.XLCCD == "05") /* prod in development &*/
        if (OP1REC.XOTCD == "31" /* footwear or*/
         || OP1REC.XOTCD == "36") /* apparel futures*/
          OP0IS9F(); /* write a tag record*/
        end
      end
    end

  end



   /* do what ever damnd reporting is needed.*/

  OP0IS82();



      /* **********************************************/
      /* * add units and dollars to sub-order array*/
      /* * use current sub-order*/
      /* **********************************************/

  OPWREC.OP1OTUNT[OP0IWSBS] = OPWREC.OP1OTUNT[OP0IWSBS] + OP3REC.OP2TONOQ;
  OPWREC.OP1OVALU[OP0IWSBS] = OPWREC.OP1OVALU[OP0IWSBS] + OP3REC.OP2LNIVL;



end // end OP0IS6E

// init sizes on old szrun(revu)
Function OP0IS6F()



  TA1REC.TA1LOCAT[2] = "OP0IS6F"; /* error diag group name*/


  OP0IW01.OP0IWSBR = OP0IW01.OP0IWSZF;

  while (OP0IWSBR < 41 /* ; loop full size range*/
   && OP0IWSBR <= OP0IWSZL)
    if (OP3REC.OP3SZAFL[OP0IWSBR] == "V")
      OP3REC.OP3SZARY[OP0IWSBR] = OP0IW01.OP3SZARY;
                                   /* clear array line*/
      OP0IS24(); /* set-up size price*/
      OP3REC.OP3SZAFL[OP0IWSBR] = "Y";
    end
    if (OP3REC.OP3SZAFL[OP0IWSBR] == "Y")
      OP0IS25(); /* set price vary flag*/
    end
    OP0IWSBR = OP0IWSBR + 1;
  end



end // end OP0IS6F

// edit warehouse genl prod class
Function OP0IS6G()



      /* customer/order gpc must match 1 gpc on warehouse table*/

  TA1REC.TA1LOCAT[2] = "OP0IS6G"; /* error diag group name*/


  if (OP1REC.XGPCD == XWHTBL.XGPCD1[sysVar.arrayIndex]) /* match gpc*/
    OP0IW01.OP0IWFND = "Y";
    return;
  end

  if (OP1REC.XGPCD == XWHTBL.XGPCD2[sysVar.arrayIndex]) /* match gpc*/
    OP0IW01.OP0IWFND = "Y";
    return;
  end

  if (OP1REC.XGPCD == XWHTBL.XGPCD3[sysVar.arrayIndex]) /* match gpc*/
    OP0IW01.OP0IWFND = "Y";
    return;
  end

  if (OP1REC.XGPCD == XWHTBL.XGPCD4[sysVar.arrayIndex]) /* match gpc*/
    OP0IW01.OP0IWFND = "Y";
    return;
  end

  if (OP1REC.XGPCD == XWHTBL.XGPCD5[sysVar.arrayIndex]) /* match gpc*/
    OP0IW01.OP0IWFND = "Y";
    return;
  end

  if (OP1REC.XGPCD == XWHTBL.XGPCD6[sysVar.arrayIndex]) /* match gpc*/
    OP0IW01.OP0IWFND = "Y";
    return;
  end

  if (OP1REC.XGPCD == XWHTBL.XGPCD7[sysVar.arrayIndex]) /* match gpc*/
    OP0IW01.OP0IWFND = "Y";
    return;
  end



end // end OP0IS6G

// edit price variance
Function OP0IS6H()



  TA1REC.TA1LOCAT[2] = "OP0IS6H"; /* error diag group name*/


      /* note - op0iwpct is order type percent variance allowed*/

  if (OP0IW01.OP0IWPRO <= OP0IW01.OP0IWPRN) /* compare old to new*/
    OP0IW01.OP0IWPRO = OP0IW01.OP0IWPRO + OP0IW01.OP0IWPCT * OP0IW01.OP0IWPRO;
    if (OP0IW01.OP0IWPRO < OP0IW01.OP0IWPRN) /* if old + % < new*/
      OPAREC.OPAERR = "Y";
      OP0IW01.OP0IWFND = "Y";
    end
  else
    OP0IW01.OP0IWPRO = OP0IW01.OP0IWPRO - OP0IW01.OP0IWPCT * OP0IW01.OP0IWPRO;
    if (OP0IW01.OP0IWPRO > OP0IW01.OP0IWPRN) /* if old - % > new*/
      OPAREC.OPAERR = "Y";
      OP0IW01.OP0IWFND = "Y";
    end
  end



end // end OP0IS6H

// chg shipdate(needdt),redo pric
Function OP0IS6I()

      /* convert mdy date to cymd,*/
      /* re-calc size prices using new need date*/

    /* if re-do prices reset price override flags since*/
    /* any previous override was re-defaulted.*/
   /* ----------------------------------------------------------------*/

  if (XOTTBL.XOTPRCDT[OP0IWSBO] == "S" /* price eff date=ship date*/
   || XOTTBL.XOTPRCDT[OP0IWSBO] == "N") /* price eff date=need date*/
    OP0IW01.OP0IWPED = OPAREC.OPAWDT; /* re-set price effec.date*/
    OP0IW01.OP0IWSBR = 1;
    OP0IW01.OP0IWPRC = 0;
    while (OP0IW01.OP0IWSBR < 41
     && OP0IW01.OP0IWSBR <= OP0IW01.OP0IWSZL)
      OP0IS24(); /* re-do prices, use new eff date*/
      if (OP3REC.OP3SZAFL[OP0IWSBR] == "Y")
        OP0IS25(); /* set price vary flag*/
      end
      OP3REC.OP3PRCOF[OP0IWSBR] = "N";
      OP0IW01.OP0IWSBR = OP0IW01.OP0IWSBR + 1;
    end
    OP0IM001.OP0IMPAL = OP3REC.OP2AUPRC;
  end






end // end OP0IS6I

// create err msg-req qty ne real
Function OP0IS6J()



      /* create error message for qty not = requested qty*/

  TA1REC.TA1LOCAT[2] = "OP0IS6J"; /* error diag group name*/


  OP0IW01.OP0IWMSB = OP3REC.OP2TONOQ; /* put actual qty in msg*/

  sysVar.arrayIndex = 1; /* zero suppress quantity*/
  while (sysVar.arrayIndex < 10) /* qty is 9 digits*/
    if (OP0IW01.OP0IWMSC[sysVar.arrayIndex] == "0")
      OP0IW01.OP0IWMSC[sysVar.arrayIndex] = " ";
      sysVar.arrayIndex = sysVar.arrayIndex + 1;
    else
      sysVar.arrayIndex = 99; /* if not zero then get out*/
    end
  end

  OP0IM001.VAGen_EZEMSG = OP0IW01.OP0IWMSG; /* put msg on map*/



end // end OP0IS6J

// load op1610 pass record
Function OP0IS6K()

  OPPREC.OPPDECAV = "Y";

  OPPREC.XDSCD = OP1REC.XDSCD;
  OPPREC.XWHCD = OP0IM001.XWHCD;
  OPPREC.OP1CUNDT = OP0IW01.OP1CUNDT; /* use original need date*/

     /* for apparel direct ship use warehouse 51*/

  if (XOTTBL.XOTDSAVL[OP0IWSBO] == "Y" /* display availability*/
   && OP1REC.XDSCD == "1"              /* direct ship*/
   && OP1REC.XGPCD == "03")            /* apparel*/
    OPPREC.XWHCD = "51"; /* use whse 51 for product avail*/
    OPPREC.XDSCD = " "; /* default direct ship to ' '*/
  end

    /* for crested products use blank style for avail*/

  if (SYCREC.XPRCD == "22") /* if a crested product*/
    OPPREC.SY1STNBR = SYCREC.SY1BSTNB; /* use the blank style*/
    OPPREC.SY2CLRID = SYCREC.SY2BCLCD; /* and the blank color*/
    if (OP1REC.XDSCD == "1") /* if a crested direct ship*/
      OPPREC.XWHCD = "51"; /* default warehouse to '51'*/
      OPPREC.XDSCD = " "; /* default direct ship to ' '*/
    end
  else
    OPPREC.SY1STNBR = OP3REC.SY1STNBR; /* use the finished style*/
    OPPREC.SY2CLRID = OP3REC.SY2CLRID; /* and the finished color*/
  end

  if (OP0IM001.XOWCD == " ")
    OPPREC.XOWCD = "00";
  else
    OPPREC.XOWCD = OP0IM001.XOWCD;
  end

  OPPREC.XOTCD = OP1REC.XOTCD;
  OPPREC.XOCCD = OP1REC.XOCCD;
  OPPREC.XBCCD = OP1REC.XBCCD;
  OPPREC.XGPCD = OP3REC.XGPCD;
  OPPREC.XDMCD = OP3REC.XDMCD;
  OPPREC.XQACD = OP3REC.XQACD;
  OPPREC.XSDCD = OP3REC.PC2INSEG;
  OPPREC.XSACD = "000"; /* avail still using default eng diff*/
  OPPREC.XPGCD = OP3REC.XPGCD;
  OPPREC.XUMCD = OP3REC.XUMCD;
  OPPREC.XLCCD = OP0IW01.XLCCD;


end // end OP0IS6K

// process non 00 rtn from op1610
Function OP0IS6L()
  if (OPPREC.OPPRTNCD == 01) /* if not enuf quantity*/
    converseLib.validationFailed(166); /* qty requested exceeds qty avail*/
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.rollback();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
     /* rollback the database*/
    exit stack; /* return to map with msg*/
  else /* else*/
    if (OPPREC.OPPRTNCD == 02 /* if another error return code*/
     || OPPREC.OPPRTNCD == 03 
     || OPPREC.OPPRTNCD == 04 
     || OPPREC.OPPRTNCD == 05)
      TA1REC.TA1TYPE = "APPL"; /* format & write error diagnostic rec*/
      TA1REC.TA1FUNC = "POST";
      TA1REC.TA1PGMNM = "OP0I";
      TA1REC.TA1LOCAT[1] = OPPREC.OPPLOC1;
      TA1REC.TA1LOCAT[2] = OPPREC.OPPLOC2;
      TA1REC.TA1LOCAT[3] = OPPREC.OPPLOC3;
      TA1REC.TA1LOCAT[4] = "OP0IS6L ";
      OP0IS6M();
      TAEREC.TAEDESC1 = OP0IW01.OP0IWT1;
      TAEREC.TAEDESC2 = sysVar.errorCode;
      call "TA0020" (TA1REC, TAEREC) {isExternal = yes};
      if (OPPREC.OPPRTNCD == 02) /* if -911 deadlock*/
        converseLib.validationFailed(10); /* database busy, please try again*/
        exit stack; /* return*/
      else /* or*/
        if (OPPREC.OPPRTNCD == 03) /* if bad key passed or no avail rec*/
          converseLib.validationFailed(442); /* no avail recs for this prod*/
          VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
          VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
          sysLib.rollback();
          VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
           /* rollback the database*/
          exit stack; /* return*/
        else /* or*/
          if (OPPREC.OPPRTNCD == 04 /* if database error*/
           || OPPREC.OPPRTNCD == 05)
                                   /* or rec changed tween select & update*/
            converseLib.validationFailed(010); /* database busy, please try again*/
            VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
            VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
            sysLib.rollback();
            VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
             /* rollback the database*/
            exit stack; /* return*/
          end
        end
      end
    end
  end

end // end OP0IS6L

// load ta1rec translated key
Function OP0IS6M()



  OP0IW01.OP0IWTK1 = OP1REC.OP1CUOID;
  OP0IW01.OP0IWTK2 = OP1REC.OP1NORID;
  OP0IW01.OP0IWTK3 = OP0IW01.OP0IWDT1;
  OP0IW01.OP0IWTK4 = OPPREC.SY1STNBR;
  OP0IW01.OP0IWTK5 = OPPREC.SY2CLRID;
  OP0IW01.OP0IWTK6 = OPPREC.OPPRTNCD;



end // end OP0IS6M

// nil prc typ cd based on comp
Function OP0IS6N()


    /* **  get the price type code from the invoicing specialty*/
    /* **  table based on the comp number*/


   /* read the company record of the comp nbr to get its acct cls*/

  KUCREC.KUCCOID = OP1REC.OP1CMPNB; /* get kucrec using comp nbr*/
  OP0IS9C(); /* read company rec (kucrec)*/
  IVEREC.XAUCD = KUCREC.XAUCD; /* put acct class in key*/

    /* get the account type of the comp nbr & using it and the*/
    /* acct class as part of the key, get the price type from the*/
    /* invoicing specialty table*/


  sysVar.arrayIndex = 1;
  if (KUCREC.XAUCD in XAUTBL.XAUCD from sysVar.arrayIndex)
    IVEREC.XATCD = XAUTBL.XATCD[sysVar.arrayIndex]; /* put acct type in key*/
    OP0IS9G(); /* read inv specl tbl*/
  else /* if no account type*/
    OP0IW01.OP0IWZPR = "Y"; /* give the item a zero price*/
  end



end // end OP0IS6N

// nil price typ cd based on co.
Function OP0IS6O()


    /* **  get the price type code from the invoicing specialty*/
    /* **  table based on the company number*/


    /* put the account class of the company in the key*/

  IVEREC.XAUCD = OP0IW01.XAUCD;


    /* get the account type of the company & using it and the*/
    /* acct class as part of the key, get the price type from the*/
    /* invoicing specialty table*/


  sysVar.arrayIndex = 1;
  if (OP0IW01.XAUCD in XAUTBL.XAUCD from sysVar.arrayIndex)
    IVEREC.XATCD = XAUTBL.XATCD[sysVar.arrayIndex]; /* put acct type in key*/
    OP0IS9G(); /* read inv specl tbl*/
  else /* if no account type*/
    OP0IW01.OP0IWZPR = "Y"; /* give the item a zero price*/
  end



end // end OP0IS6O

// move/truncate op1cuoid to xsr
Function OP0IS6P()
   /* ***************************************************/
   /* **  this routine exists because xsrrec.xsrsqnbr is*/
   /* **  two bytes (binary) shorter than the customer*/
   /* **  order number.  this will ensure uniformity in*/
   /* **  truncating the most significant digits from the*/
   /* **  order number and used as part of the key in*/
   /* **  the saved xsrrec record during product subs-*/
   /* **  titution.*/
   /* ***************************************************/

  OP0IW01.OP0IWNBR = OP1REC.OP1CUOID;
  XSRREC.XSRSQNBR = OP0IW01.OP0IWNB2;



end // end OP0IS6P

// write xsrrec
Function OP0IS6S()


  TA1REC.TA1LOCAT[2] = "OP0IS6S";

  set SQLCA empty;

  call "IO3400" ("A ", SQLCA, XSRREC) {isNoRefresh = yes, isExternal = yes};


  if (SQLCA.VAGen_SQLCODE == 0) /* good return, clear*/
    return;
  else
    TA1REC.TA1DBASE = "DCORP"; /* data base name*/
    TA1REC.TA1TBLVU = "VCSPAD01"; /* table view*/
    TA1REC.TA1TBLKE = XSRREC.XSRGROUP; /* key value*/
    TA1REC.TA1LOCAT[1] = "A"; /* action*/
    TA1REC.TA1LOCAT[3] = "IO3400"; /* i/o mod*/
    XSOPS02(); /* common abend*/

  end

   /* **********************************************************/
end // end OP0IS6S

// control edits-prod info,bottom
Function OP0IS70()


      /* *********************************************************/
      /* * control all editing for bottom half fields on the map*/
      /* * the fields are edited in reverse order so that the*/
      /* * cursor and error message will appear for the first*/
      /* * field in error on the map.*/
      /* * all fields in error will be highlighted.*/
      /* *********************************************************/

  TA1REC.TA1LOCAT[2] = "OP0IS70"; /* error diag group name*/


  set OP0IM001.SY1SSTNM initialAttributes; /* reset fields used for mesg*/
  set OP0IM001.SY2CLRAB initialAttributes;


  if (OP0IM001.OP2FSTFL is modified) /* forecast flag*/
    OP0IW01.OP0IWCHG = "Y";
    OP0IS71();
  else
    set OP0IM001.OP2FSTFL initialAttributes;
  end

  if (OP0IM001.OP2SSTYN is modified /* substitute product*/
   || OP0IM001.OP2SCLCD is modified 
   || OP0IM001.OP2SDMCD is modified)
    OP0IW01.OP0IWCHG = "Y";
    OP0IS95();
  else
    set OP0IM001.OP2SSTYN initialAttributes;
    set OP0IM001.OP2SCLCD initialAttributes;
    set OP0IM001.OP2SDMCD initialAttributes;
  end

  if (OP0IM001.OP2SUBQT is modified) /* substitute quantity*/
    OP0IW01.OP0IWCHG = "Y";
    OP0IS72();
  else
    set OP0IM001.OP2SUBQT initialAttributes;
  end

      /* *********************************************************/
      /* * 08/12/92 JLoyer - Booking seasons                    **/
      /* *********************************************************/
      /* * Need date changes can impact domestic and Int'l      **/
      /* * bk-sesns.  Warehouse changes can also impact Int'l   **/
      /* * bk-sesn by causing a suborder split.  If the need    **/
      /* * date or warehouse changes, OP0IS7C will edit the     **/
      /* * bk-sesns and month.                                  **/
      /* *********************************************************/

  if (OP0IM001.XBK-BK-SESN-CD is modified    /* if xbk-bk-sesn-cd was chgd*/
   || OP0IM001.OP0IM-OP-BK-YR-YY is modified /* or op-bk-yr was chgd*/
   || OP0IW01.OP0IW-MULTI-BK-SESN-MSG == "Y") /* or multi-bk-sesn-msg is on*/
    OP0IW01.OP0IWCHG = "Y"; /**/
    if (OP1REC.XDVCD == "02") /* if International order*/
      if (OP0IM001.OP0IMNDT not modified /* if the need dt not chgd*/
       && OP0IM001.XWHCD not modified)   /* and warehouse not chgd*/
        OP0IS-EDIT-BK-SESN(); /* edit bk-sesn/bk-mo*/
      end
    else /* else*/
      if (OP0IM001.OP0IMNDT not modified) /* if the need dt not chgd*/
        OP0IS-EDIT-BK-SESN(); /* edit bk-sesn/bk-mo*/
      end
    end
  end


  OP0IW01.OP0IWSBH = 1; /* pack handling codes*/
  while (OP0IW01.OP0IWSBH < 6)
    if (OP0IM001.XHDCD[OP0IWSBH] is modified
     || OP0IM001.XHDCHG[OP0IWSBH] is modified)
      OP0IW01.OP0IWCHG = "Y";
      OP0IS73();
    else
      set OP0IM001.XHDCD[OP0IWSBH] initialAttributes;
      set OP0IM001.XHDCHG[OP0IWSBH] initialAttributes;
      set OP0IM001.OP0IMHTP[OP0IWSBH] initialAttributes;
    end
    OP0IW01.OP0IWSBH = OP0IW01.OP0IWSBH + 1;
  end

  if (OP0IM001.OP2GTSZF is modified) /* gut size*/
    OP0IW01.OP0IWCHG = "Y";
    OP0IS74();
  else
    set OP0IM001.OP2GTSZF initialAttributes;
  end


  if (OP0IM001.OP2KSTYF is modified) /* key style*/
    OP0IW01.OP0IWCHG = "Y";
    OP0IS75();
  else
    set OP0IM001.OP2KSTYF initialAttributes;
  end

  if (OP0IM001.OP2CGPCD is modified) /* coordinate group*/
    OP0IW01.OP0IWCHG = "Y";
    OP0IS76();
  else
    set OP0IM001.OP2CGPCD initialAttributes;
  end

  if (OP0IM001.PC2INSEG is modified) /* spec code can only be chgd*/
    OP0IW01.OP0IWCHG = "Y"; /* if in review mode and xdscd=' '*/
    OP0IS7E(); /* and line status is open*/
  else
    if (OP1REC.XDVCD == "02" /* international*/
     && OP1REC.XOBCD == "F1" /* futures*/
     && OP1REC.XGPCD == "03" /* apparel*/
     && OP1REC.XDSCD == " "  /* ship from  whse*/
     && OPWREC.OPWREVM == 7  
     && OP3REC.OP2LNIST == "OP")
      if (OP1REC.XWHCD == "51" /* Memphis aprl whse*/
       || OP1REC.XWHCD == "25" /* NSG aprl whse*/
       || OP1REC.XWHCD == "27") /* NSG aprl whse*/
        set OP0IM001.PC2INSEG initialAttributes;
      else
        set OP0IM001.PC2INSEG protect;
      end
    else
      set OP0IM001.PC2INSEG protect;
    end
  end

  if (OP0IM001.OP0IMFIL is modified) /* fill lost demand*/
    OP0IW01.OP0IWCHG = "Y";
    OP0IS7D();
  else
    set OP0IM001.OP0IMFIL initialAttributes;
  end

  if (OP0IM001.OP1BOFL is modified) /* backorder flag*/
    OP0IW01.OP0IWCHG = "Y";
    OP0IS77();
  else
    set OP0IM001.OP1BOFL initialAttributes;
  end

  if (OP0IM001.PWRLBCD[1] is modified /* labl cd #1*/
   || OP0IM001.PWRLBCD[2] is modified) /* labl cd #2*/
    OP0IW01.OP0IWCHG = "Y"; /* set change flag to true*/
    OP0IW01.OP0IW-LABL-CD-SUB = 2; /* initialize sub-script*/
    while (OP0IW01.OP0IW-LABL-CD-SUB > 0) /* loop thourgh labl cd*/
      OP0IS-EDIT-LABL-CD(); /* edit labl cd & fill in abrv*/
   /* decrement sub-script*/
      OP0IW01.OP0IW-LABL-CD-SUB = OP0IW01.OP0IW-LABL-CD-SUB - 1;
    end
  else
    set OP0IM001.PWRLBCD[1] initialAttributes;
    set OP0IM001.PWRLBCD[2] initialAttributes;
  end

  if (OP0IM001.OP0IMNDT is modified) /* need date*/
    OP0IW01.OP0IWCHG = "Y";
    OP0IW01.OP0IWNDC = "Y";
    if (OP0IW01.OP0IW-BK-SESN-REQUIRED == "Y") /* if bk-sesn required on ord*/
      OP0IW01.OP0IW-CHECK-BK-SESN = "Y"; /* ndt chg may impact bk-ses*/
    end
    OP0IS78();
  else
    if (OP3REC.OP2LNIST == "AL" /* if product allocated*/
     || OPWREC.OPWREVM == 7     /* and in review mode*/
     || OPWREC.OP2LNINB > 0)   
      set OP0IM001.OP0IMNDT protect; /* set ndt protect*/
    else
      set OP0IM001.OP0IMNDT initialAttributes;
    end
  end

  if (OPAREC.OPAERR == "Y")
    if (converseVar.validationMsgNum == 051)
      /* next sentence*/
    else
      return;
    end
  end

  if (OPAREC.OPAERR == "N")
      /* 9/5/89  -  For all NIL orders with first quality products*/
      /* and active or in development life cycles, verify if there*/
      /* is a restriction on the customer ordering the specific*/
      /* product for the need date requested.*/

    if (OP1REC.XDVCD == "02") /* nil order*/
      if (OP3REC.XQACD == "01") /* first quality*/
        if (OP0IW01.XLCCD == "10" /* active life cycle*/
         || OP0IW01.XLCCD == "05") /* or in development life cyc*/
          OP0IW05.OP0IWDTE = OP0IW01.OP1CUNDT; /* frmt need dte*/
          OP0ISOD(); /* verify customer/product elig.*/
          if (OPAREC.OPAERR == "Y") /* error exists*/
            return;
          end
        end
      end
    else
      OP0ISDZ(); /* check offering dates*/
    end
  end

  if (OP0IM001.XWHCD is modified) /* if warehouse changed*/
    if (OP0IW01.OP0IW-BK-SESN-REQUIRED == "Y" /* if bk-sesn required*/
     && OP1REC.XDVCD == "02")                 /* and order Int'l*/
      if (OP0IW01.OP0IW-DEFAULT-BK-SESN == "N") /* if not defaulting bs*/
        OP0IW01.OP0IW-CHECK-BK-SESN = "Y"; /* chk bk-sesn*/
      end
    end
  end

  if (OP0IM001.XWHCD is modified /* warehouse*/
   || OP0IM001.XWHCD == " ")     /* whs is required*/
    OP0IW01.OP0IWCHG = "Y";
    OP0IS79();
  else
    if (OP3REC.OP2LNIST == "AL" /* if product allocated*/
     || OPWREC.OPWREVM == 7     /* and in review mode*/
     || OPWREC.OP2LNINB > 0)   
      set OP0IM001.XWHCD protect; /* set whs protect*/
    else
      set OP0IM001.XWHCD initialAttributes;
      set OP0IM001.XWHSABRV initialAttributes;
    end
  end


  if (OP0IM001.OP0IMPAD is modified
   && OP0IM001.OP0IMPAL is modified)
    OPAREC.OPAERR = "Y";
    converseLib.validationFailed(185); /* cant have new price and adjust.*/
    set OP0IM001.OP0IMPAD bold;
    set OP0IM001.OP0IMPAL cursor, bold;
  else
    if (OP0IM001.OP0IMPAD is modified) /* price adjustment*/
      OP0IW01.OP0IWCHG = "Y";
      OP0IS7A();
    else
      if (OP0IW01.OP0IWPF6 == "Y") /* allow price change*/
        set OP0IM001.OP0IMPAD normal;
      else
        set OP0IM001.OP0IMPAD initialAttributes;
      end
    end
    if (OP0IM001.OP0IMPAL is modified) /* price for all sizes*/
      OP0IW01.OP0IWCHG = "Y";
      OP0IS7B();
    else
      if (OP0IW01.OP0IWPF6 == "Y") /* allow price change*/
        set OP0IM001.OP0IMPAL normal;
      else
        set OP0IM001.OP0IMPAL initialAttributes;
      end
    end
  end


   /* re-protect certain fields based on whether this*/
   /* order is a bulk order or a draw order.*/


  if (OP0IW01.OP0IWBDF > " ")
    set OP0IM001.XWHCD protect;
    if (OP0IW01.OP0IWBDF == "BS" /* smart res bulk*/
     || OP0IW01.OP0IWBDF == "BN" /* nike bulk*/
     || OP0IW01.OP0IWBDF == "BX" /* flex bulk*/
     || OP0IW01.OP0IWBDF == "BC" /* cust bulk*/
     || OP0IW01.OP0IWBDF == "BB") /* blank bulk*/
      set OP0IM001.OP0IMNDT protect;
    else
      if (OP0IW01.OP0IWBDF == "DR") /* rebook draw*/
        set OP0IM001.OP0IMNDT protect;
      end
    end
  end

  if (OP0IW01.OP0IWBDF == "BS" /* smart res bulk*/
   || OP0IW01.OP0IWBDF == "BX") /* flex bulk*/
    set OP0IM001.OP2CGPCD protect;
  end


  if (OPAREC.OPAERR == "Y")
    if (converseVar.validationMsgNum == 051)
      /* next sentence*/
    else
      return;
    end
  end

  OP0IS7C();

end // end OP0IS70

// edit forecast flag
Function OP0IS71()



  TA1REC.TA1LOCAT[2] = "OP0IS71"; /* error diag group name*/


  if (OP0IM001.OP2FSTFL == "Y" /* forecast flag*/
   || OP0IM001.OP2FSTFL == "N")
    OP3REC.OP2FSTFL = OP0IM001.OP2FSTFL; /* good, hold*/
    set OP0IM001.OP2FSTFL initialAttributes;
  else
    OPAREC.OPAERR = "Y";
    converseLib.validationFailed(181); /* correct response is y or n*/
    set OP0IM001.OP2FSTFL cursor, modified, bold;
  end



end // end OP0IS71

// edit substitute quantity
Function OP0IS72()



      /* *****************************************/
      /* * note - substitute style already edited*/
      /* *****************************************/

  TA1REC.TA1LOCAT[2] = "OP0IS72"; /* error diag group name*/


  if (OP0IM001.OP2SUBQT != 0)
    if (OP0IM001.OP2SSTYN == " ")
      OPAREC.OPAERR = "Y";
      converseLib.validationFailed(178); /* sub qty not valid without sub prod*/
      set OP0IM001.OP2SUBQT cursor, modified, bold;
      return;
    end
  end

  OP3REC.OP2SUBQT = OP0IM001.OP2SUBQT; /* hold good qty*/
  set OP0IM001.OP2SUBQT initialAttributes;



end // end OP0IS72

// edit pack handle code/charge
Function OP0IS73()



      /* ************************************************/
      /* * note - op0iwsbh set in control edit stmt group*/
      /* ************************************************/

  TA1REC.TA1LOCAT = "OP0IS73"; /* error diag group name*/


      /* edit pack handle code & charge*/

  sysVar.arrayIndex = 1;
  OP0IW01.OP0IWFND = "N"; /* match not found*/
  OP0IW01.OP0IWPHC = 0; /* hold pack handle charge*/

  if (OP0IM001.XHDCD[OP0IWSBH] == " ") /* blank out current code*/
    OP0IW01.OP0IWFND = "Y";
    OP0IM001.XHDCHG[OP0IWSBH] = 0; /* zero charge*/
    OP0IM001.OP0IMHTP[OP0IWSBH] = " ";
    OP0IW01.OP0IWHTP = " ";
  else
    if (OP1REC.ZFC-CRCY-CD == " ") /* Canada 6/95*/
      OP1REC.ZFC-CRCY-CD = "USD"; /* Canada 6/95*/
    end /* cana*/
    sysVar.arrayIndex = 1;
    OP0IW01.XHDCD = OP0IM001.XHDCD[OP0IWSBH];
    OP0IW01.XGPCD = OP3REC.XGPCD;
    if (OP0IW01.XHDKEY in XHDTBL.XHDKEY
     && XHDTBL.XXXSTAT[sysVar.arrayIndex] == "A")
      if (OP1REC.ZFC-CRCY-CD == XHDTBL.ZFC-CRCY-CD[sysVar.arrayIndex]) /* Canada 6/95*/
        OP0IW01.OP0IWFND = "Y"; /* force end of loop*/
        OP0IW01.OP0IWPHC = XHDTBL.XHDCHG[sysVar.arrayIndex]; /* hold charge*/
        OP0IW01.XHDUCHFL = XHDTBL.XHDUCHFL[sysVar.arrayIndex];
      else
        OPAREC.OPAERR = "Y"; /* Canada*/
        converseLib.validationFailed(901); /* Canada-unmatched crcy code*/
        set OP0IM001.XHDCD[OP0IWSBH] cursor, modified, bold; /* Canada*/
      end
    else
      OPAREC.OPAERR = "Y";
      converseLib.validationFailed(120); /* bad pack handle code*/
      set OP0IM001.XHDCD[OP0IWSBH] cursor, modified, bold;
    end
  end

  if (OP1REC.XDZ-DATA-DIST-CD != "CA") /* Canada 6/95*/
    OP1REC.ZFC-CRCY-CD = "   "; /* Canada 6/95*/
  end /* cana*/

  if (OPAREC.OPAERR == "Y")
    return;
  end


  OP3REC.OP2HCHGO[OP0IWSBH] = "N"; /* init override*/
  if (OP0IM001.XHDCHG[OP0IWSBH] != 0) /* check for override $*/
    if (OP0IM001.XHDCHG[OP0IWSBH] != OP0IW01.OP0IWPHC)
      /* bssa changes * start * 04/21/2000 * rharat *********/
      OP0IW01.OP0IW-USER-HNDCHG-OVRD = "Y"; /* set ovrfl*/
      /* bssa changes *  end  * 04/21/2000 * rharat *********/
      OP3REC.OP2HCHGO[OP0IWSBH] = "Y";
      OP0IW01.OP2HCHGO = "*"; /* override flag to map*/
    else
      OP0IW01.OP0IWHTP = " ";
    end
  else
    OP0IM001.XHDCHG[OP0IWSBH] = OP0IW01.OP0IWPHC; /* chrg to map*/
  end


    /* pack handle type (xhducfl)& override (op2hchgo)*/
  OP0IM001.OP0IMHTP[OP0IWSBH] = OP0IW01.OP0IWHTP;

  OP3REC.XHDCD[OP0IWSBH] = OP0IM001.XHDCD[OP0IWSBH];
                                   /* hold good stuff*/
  OP3REC.XHDCHG[OP0IWSBH] = OP0IM001.XHDCHG[OP0IWSBH];
   /* bssa changes * begin * TT#4752 * move vales back to comm rec **/
  OPWREC.XHDCD[OP0IWSBH] = OP0IM001.XHDCD[OP0IWSBH];
  OPWREC.XHDCHG[OP0IWSBH] = OP0IM001.XHDCHG[OP0IWSBH];
  OPWREC.OP2HCHGO[OP0IWSBH] = OP3REC.OP2HCHGO[OP0IWSBH];
   /* bssa changes *  end  * TT#4752 ******************************/
  set OP0IM001.XHDCD[OP0IWSBH] initialAttributes;
  set OP0IM001.XHDCHG[OP0IWSBH] initialAttributes;
  set OP0IM001.OP0IMHTP[OP0IWSBH] initialAttributes;



end // end OP0IS73

// edit gut size
Function OP0IS74()



  TA1REC.TA1LOCAT[2] = "OP0IS74"; /* error diag group name*/


  if (OP0IM001.OP2GTSZF == "Y" /* valid gut size is y/n*/
   || OP0IM001.OP2GTSZF == "N")
    OP3REC.OP2GTSZF = OP0IM001.OP2GTSZF;
    set OP0IM001.OP2GTSZF initialAttributes;
  else
    OPAREC.OPAERR = "Y";
    converseLib.validationFailed(161); /* bad gut size*/
    set OP0IM001.OP2GTSZF cursor, modified, bold;
  end



end // end OP0IS74

// edit key style
Function OP0IS75()



  TA1REC.TA1LOCAT[2] = "OP0IS75"; /* error diag group name*/


  if (OP0IM001.OP2KSTYF == "Y" /* valid key style is y/n*/
   || OP0IM001.OP2KSTYF == "N")
    OP3REC.OP2KSTYF = OP0IM001.OP2KSTYF;
    set OP0IM001.OP2KSTYF initialAttributes;
  else
    OPAREC.OPAERR = "Y";
    converseLib.validationFailed(160); /* bad key style*/
    set OP0IM001.OP2KSTYF cursor, modified, bold;
  end



end // end OP0IS75

// edit coordinate group
Function OP0IS76()



  TA1REC.TA1LOCAT[2] = "OP0IS76"; /* error diag group name*/


  OP3REC.OP2CGPCD = OP0IM001.OP2CGPCD; /* hold coordinate group*/
  set OP0IM001.OP2CGPCD initialAttributes;



end // end OP0IS76

// edit backorder flag
Function OP0IS77()



  TA1REC.TA1LOCAT[2] = "OP0IS77"; /* error diag group name*/


  if (OP0IM001.OP1BOFL == "Y" /* valid backorder is y/n*/
   || OP0IM001.OP1BOFL == "N")
    /* next sentence*/
  else
    OPAREC.OPAERR = "Y";
    converseLib.validationFailed(77); /* bad backorder*/
    set OP0IM001.OP1BOFL cursor, modified, bold;
    return;
  end

  if (OP0IM001.OP1BOFL == "Y") /* can not change product defined*/
    if (SYCREC.SY2BOSWI == "N" /* as 'no' backorder*/
     && SYCREC.SY2BOEDT <= OPAREC.OPACDT)
      OPAREC.OPAERR = "Y";
      converseLib.validationFailed(179); /* warning-prod requires bo=n*/
      OP0IM001.OP1BOFL = "N";
      set OP0IM001.OP1BOFL cursor, bold;
      return;
    end
  end

  OP3REC.OP1BOFL = OP0IM001.OP1BOFL; /* hold good stuff*/
  set OP0IM001.OP1BOFL initialAttributes;



end // end OP0IS77

// edit needdate
Function OP0IS78()

      /* convert mmddyy from map to ccyymmdd*/

  TA1REC.TA1LOCAT[2] = "OP0IS78"; /* error diag group name*/


  set TA2REC empty; /* clear before use*/
  TA2REC.TA2DTOPT = "GREGGREG"; /* convert mmddyy*/
  TA2REC.TA2GRTYP = "A"; /* to ccyymmdd*/
  TA2REC.TA2GRGA = OP0IM001.OP0IMNDT;

  call "TA0040" (TA2REC) {isNoRefresh = yes, isExternal = yes}; /* call date module*/


  if (TA2REC.TA2RTNCD != 0)
    OPAREC.OPAERR = "Y";
    converseLib.validationFailed(013); /* need date is not a valid date*/
    set OP0IM001.OP0IMNDT cursor, modified, bold;
    return;
  end


  OP0IW01.OP1CUNDT = TA2REC.TA2GRGGN; /* hold ccyymmdd*/

   /* ********************************************************************/
   /* divert order processing*/
   /* if the order is a divert order allow a need date less than today*/
   /* ********************************************************************/

  if (OP1REC.XDVCD == "02" /* international order*/
   && OP1REC.XOBCD == "F1" /* futures order*/
   && OP1REC.XDSCD == "1"  /* direct ship*/
   && OP1REC.OP1CUNDT < OPAREC.OPACDT) /* need dt less than order dt*/
      /* next sentence*/
  else
    if (TA2REC.TA2GRGGN < OPAREC.OPACDT)
      converseLib.validationFailed(015); /* need date must not be before*/
                                     /* todays's date*/
      OPAREC.OPAERR = "Y";
      set OP0IM001.OP0IMNDT cursor, modified, bold;
      return;
    end
  end


  OPAREC.OPAWDT = OPAREC.OPACDT + 20000; /* wk-dt = curr-dt + 2 years*/


  if (TA2REC.TA2GRGGN > OPAREC.OPAWDT)
    converseLib.validationFailed(016); /* need date is more than one year in*/
                                   /* the future*/
    OPAREC.OPAERR = "Y";
    set OP0IM001.OP0IMNDT cursor, modified, bold;
    return;
  end

  OPAREC.OPAWDT = TA2REC.TA2GRGGN; /* reset work date to need date.*/

      /* *********************************************************/
      /* * edit order type against sales program delivery date*/
      /* *********************************************************/

  if (OP1REC.SP1ID != " ") /* have sales pgm, so edit*/
    if (TA2REC.TA2GRGGN < SP2REC.SP2DLBDT /* if date outside deliv.range*/
     || TA2REC.TA2GRGGN > SP2REC.SP2DLXDT)
      converseLib.validationFailed(027); /* need date is not a valid delivery*/
                                   /* date for this*/
                             /* sales program*/
      OPAREC.OPAERR = "Y"; /* set error flag*/
      set OP0IM001.OP0IMNDT cursor, modified, bold;
      return;
    end
  end

  if (TA2REC.TA2GRGGN == OPWREC.OP1CUNDT[OP0IWSBS])
     /* next sentence*/
  else
    OP0IW01.OP0IWCND = "Y"; /* force edit of whs/needdate sub order*/
  end


  if (OPWREC.OPWREVM == 7
   /* if in review mode, dont unset need dt*/
   || OPWREC.OP2LNINB > 0)
    /* next sentence*/
  else
    set OP0IM001.OP0IMNDT initialAttributes;
  end


              /* check the production deadline*/

  set OPLREC empty; /* cutoff pass record*/
  OPLREC.OPJCNDTB = OP0IW01.OP1CUNDT; /* need date*/
  OP0IS32(); /* check prodcution deadline*/


    /* see if order adjustment number required*/

  OP0IW01.OP0IWOAF = "N"; /* initialize order adjustment flag*/
  OP0IW01.OP0IWOAC = "N"; /* initialize split order adjustment*/
                                   /* flag*/

  if (OP1REC.XOCCD == "IN") /* invoice only order*/
     /* next sentence*/
  else
    if (OP1REC.XDVCD == "02" /* if nil*/
     && OP1REC.XGPCD == "02" /* and footwear*/
     && OP0IW01.OP0IWP20 == "Y") /* and 20 days past cutoff date*/
      OP0IW01.OP0IWOAC = "Y"; /* indicate need date change*/
      OP0ISOB(); /* check for o/a validation override*/
      if (OP0IW01.OP0IWOAO == "N") /* o/a validation override?*/
        if (converseVar.validationMsgNum == 0)
          converseLib.validationFailed(614);
          OP0IW01.OP0IWOAF = "Y"; /* order adjustment required*/
        end
      end
    end
  end


   /* ********************************************************/
      /* * calc # days between curr date and need date*/
      /* * check for sufficient lead time, by order type;*/
      /* * check for sufficient lead time, for sales program.*/
      /* *********************************************************/

   /* ********************************************************************/
   /* divert order processing*/
   /* if the order is a divert order bypass the lead time check*/
   /* ********************************************************************/

  if (OP1REC.XDVCD == "02" /* international order*/
   && OP1REC.XOBCD == "F1" /* futures order*/
   && OP1REC.XDSCD == "1"  /* direct ship*/
   && OP1REC.OP1CUNDT < OPAREC.OPACDT) /* need dt less than order dt*/
      /* next sentence                        skip edit for divert orders*/
  else
    TA2REC.TA2GRGGN = OP0IW01.OP1CUNDT;
    if (OP0IW01.OP0IWBDF == "DC" /* skip edit for draw orders*/
     || OP0IW01.OP0IWBDF == "DN" 
     || OP0IW01.OP0IWBDF == "DR" 
     || OP0IW01.OP0IWBDF == "DS" 
     || OP0IW01.OP0IWBDF == "DX")
       /* next sentence*/
    else
      TA2REC.TA2DBDFN = OPAREC.OPACDT; /* curr date*/
      TA2REC.TA2DBDTN = TA2REC.TA2GRGGN; /* need date*/
      TA2REC.TA2GRTYP = "G";
      TA2REC.TA2DTOPT = "DAYSDIFF";
      TA2REC.TA2RTNCD = 0;
      call "TA0040" (TA2REC) {isNoRefresh = yes, isExternal = yes}; /* get # days*/
      if (TA2REC.TA2RTNCD == 0)
        if (TA2REC.TA2DBDDN < XOTTBL.XOTLDAYS[OP0IWSBO]) /* chk order type,*/
          if (OP0IW01.OP0IWLTM == "Y") /* if already gave lead time msg*/
            OP0IW01.OP0IWLTM = "N";
          else
            OPAREC.OPAERR = "Y";
            OP0IW01.OP0IWLTM = "Y";
            converseLib.validationFailed(051); /* warning-not enough lead time*/
            set OP0IM001.OP0IMNDT cursor, modified, bold;
            return;
          end
        end
        if (OP1REC.SP1ID != " ") /* have sales program*/
          if (TA2REC.TA2DBDDN >= SP2REC.SP2LEDTM)
            /* next sentence*/
          else
            OPAREC.OPAERR = "Y";
            converseLib.validationFailed(052); /* not within sales pgm lead time*/
             /* need to add flag that warning given once.*/
             /* if flag = y, then skip this edit and finish edits*/
            set OP0IM001.OP0IMNDT cursor, modified, bold;
            return;
          end
        end
      else
        OPAREC.OPAERR = "Y"; /* date not valid*/
        converseLib.validationFailed(13);
        set OP0IM001.OP0IMNDT cursor, modified, bold;
        return;
      end
    end
  end


   /* for draw orders, new need date can't be less then bulk*/
     /* need date. also new need date cannot be greater then*/
     /* the bulk order do-not-ship-after-date.*/


  if (OP0IW01.OP0IWBDF == "DR") /* rebook draw*/
    return; /* skip edit ndt same as bulk-can't chg*/
  end


  TA2REC.TA2GRGGN = OP0IW01.OP1CUNDT;
  if (OP0IW01.OP0IWBDF == "DS"
   || OP0IW01.OP0IWBDF == "DN"
   || OP0IW01.OP0IWBDF == "DC"
   || OP0IW01.OP0IWBDF == "DX")
    if (OP0IW01.OP0IWSND > TA2REC.TA2GRGGN
     
     /* *******************************************************/
     /* * as a temporary fix because reserved quantities are **/
     /* * not properly allocated to draws and bulk orders,   **/
     /* * flex-draws are allowed to have a need date earlier **/
     /* * than the bulk need date.  the following code will  **/
     /* * have to be removed when normal processing is to be **/
     /* * returned.                                          **/
     
     && OP0IW01.OP0IWBDF != "DX") /* if not flex draw*/

       /* * the code before this will have to be removed when  **/
       /* * normal processing is to be returned.               **/
       /* *******************************************************/

      converseLib.validationFailed(293); /* can't be gt bulk need date*/
      OPAREC.OPAERR = "Y";
      set OP0IM001.OP0IMNDT cursor, modified, bold;
      return;
    else
      if (OP0IW01.OP1DSADT > 0) /* if bulk order has a don't ship after*/
                                   /* dt*/
        if (TA2REC.TA2GRGGN > OP0IW01.OP1DSADT)
          converseLib.validationFailed(293); /* can't be gt don't ship after dt*/
          set OP0IM001.OP0IMNDT cursor, modified, bold;
          OPAREC.OPAERR = "Y";
          return;
        end
      end
    end
  end

  OP0IS-AIRBORNE(); /* edit for airborne*/
  if (OPAREC.OPAERR == "Y")
    return;
  end

   /* 08/07/89  bypass hot model logic if promo division*/
             /* or product is not first quality*/

  if (OP1REC.XDVCD == "03" /* if promo*/
   || OPWREC.XQACD != "01") /* or not first quality*/
      /* next sentence       bypass hot model logic*/
  else
    if (SYCREC.OPZHMIND == "Y"
     && OP0IW01.OP0IWBDF == " ")
      if (XOTTBL.XOTPROPF[OP0IWSBO] == "Y"
       && XOTTBL.XOTFUTRF[OP0IWSBO] == "N"
       && XOTTBL.XOTSMPLF[OP0IWSBO] == "N"
       && OP0IW01.OP0IWNDC == "Y")
        OP0ISHM();
      end
    end
  end


   /* *************************************************************/
end // end OP0IS78

// edit warehouse
Function OP0IS79()



  TA1REC.TA1LOCAT[2] = "OP0IS79"; /* error diag group name*/



   /* check if warehouse really changed.*/

  if (OP0IM001.XWHCD == OPWREC.XWHCD[OP0IWSBS])
    set OP0IM001.XWHCD initialAttributes;
    if (OP0IM001.XWHCD in XWHTBL.XWHCD)
      OP0IM001.XWHSABRV = XWHTBL.XWHSABRV[sysVar.arrayIndex];
    end
    if (OP0IW01.XDSWHSEF == "Y" /* check to make sure if wh is blank*/
     /* that*/
     && OP0IM001.XWHCD == " ")  /* direct ship is allowed*/
      /* next sentence*/
    else
      return;
    end
  end


    /* added for Canada --  June 13, 1995--*/
  if (OP1REC.XDZ-DATA-DIST-CD == "CA"
   && OP0IM001.XWHCD == "42")
     /* next sentence*/
  else
    if (OP1REC.XDZ-DATA-DIST-CD != "CA"
     && OP0IM001.XWHCD != "42"
    ) /* next sentence*/
    else
      OPAREC.OPAERR = "Y";
      converseLib.validationFailed(898); /* warehouse 42 only allowed for canada*/
      set OP0IM001.XWHCD cursor, modified, bold;
      return;
    end
  end



  if (OP0IM001.XWHCD == " ")
    OP0IM001.XWHSABRV = " ";
    set OP0IM001.XWHCD normal;
    set OP0IM001.XWHSABRV normal;
    if (OP0IW01.XDSWHSEF == "Y")
      OPAREC.OPAERR = "Y";
      converseLib.validationFailed(098); /* warehouse is required*/
      set OP0IM001.XWHCD cursor, modified, bold;
    else
      OP1REC.XWHCD = " ";
      OPWREC.XWHCD[OP0IWSBS] = " "; /* blank sub order array whs*/
      return;
    end
  else
    if (OP0IW01.XDSWHSEF == "N")
      OP0IM001.XWHCD = " ";
      OPWREC.XWHCD[OP0IWSBS] = " ";
      return;
    end
  end


  OP0IW01.OP0IWFND = "N"; /* not found fl on*/


  if (OP0IM001.XWHCD in XWHTBL.XWHCD)
    if (XWHTBL.XXXSTAT[sysVar.arrayIndex] == "A") /* validate whs*/
      OP0IS6G(); /* validate general prod class*/
      if (OP0IW01.OP0IWFND == "Y")
        OP0IM001.XWHSABRV = XWHTBL.XWHSABRV[sysVar.arrayIndex]; /* descr to map*/
      end
    end
  end

  if (OP0IW01.OP0IWFND == "N") /* whs not found is error*/
    OPAREC.OPAERR = "Y";
    converseLib.validationFailed(78);
    set OP0IM001.XWHCD cursor, modified, bold;
    return;
  end

    /* make sure that a international order cannot be changed*/
    /* to use warehouse code = '15'.*/

  if (OP1REC.XDVCD == "02") /* International Order*/
    if (OP1REC.XWHCD != "15" /* orig. order not for whse 15*/
     && OP0IM001.XWHCD == "15") /* but changed to use whse 15*/
      OPAREC.OPAERR = "Y";
      converseLib.validationFailed(783); /* can't change whse code to*/
                               /* 15 for this order*/
      set OP0IM001.XWHCD cursor, modified, bold;
      return;
    end
  end


    /* if warehouse division is promo, '03', let this*/
    /* item around the 1-whs edit.*/

  if (OP0IM001.XWHCD in XWHTBL.XWHCD)
    if (XWHTBL.XDVCD1[sysVar.arrayIndex] == "03") /* if promo*/
      OP0IW01.OP0IWCWH = "Y"; /* changed warehouse*/
      set OP0IM001.XWHCD initialAttributes;
      set OP0IM001.XWHSABRV initialAttributes;
      return; /* exit*/
    end
  end



   /* note: 2 exceptions 1) direct ship orders*/
                      /* 2) order types with either:*/
                          /* a) life cycle of 20 or,*/
                          /* b) quality code of 02 or 03.*/


    /* do direct ship first.use ws warehouse required flag.*/

  if (OP0IW01.XDSWHSEF == "Y") /* if whs required, not direct ship*/
     /* next sentence*/
  else
    OP0IW01.OP0IWCWH = "Y"; /* changed warehouse, do combo edit*/
    set OP0IM001.XWHCD initialAttributes;
    set OP0IM001.XWHSABRV initialAttributes;
    return;
  end


   /* now check order type quality and life cycle.*/

  if (XOTTBL.XQACD1[OP0IWSBO] == "02"
   || XOTTBL.XQACD1[OP0IWSBO] == "03"
   || XOTTBL.XQACD2[OP0IWSBO] == "02"
   || XOTTBL.XQACD2[OP0IWSBO] == "03"
   || XOTTBL.XQACD3[OP0IWSBO] == "02"
   || XOTTBL.XQACD3[OP0IWSBO] == "03"
   || XOTTBL.XLCCD1[OP0IWSBO] == "20"
   || XOTTBL.XLCCD2[OP0IWSBO] == "20"
   || XOTTBL.XLCCD3[OP0IWSBO] == "20"
   || XOTTBL.XLCCD4[OP0IWSBO] == "20"
   || XOTTBL.XLCCD5[OP0IWSBO] == "20")
    OP0IW01.OP0IWCWH = "Y"; /* changed warehouse, do combo edit*/
    set OP0IM001.XWHCD initialAttributes;
    set OP0IM001.XWHSABRV initialAttributes;
    return;
  end




      /* ****************************************************/
      /* * 1 warehouse model, also checked when add product*/
      /* ****************************************************/

  sysVar.arrayIndex = 6; /* check 1 whs model*/
  OP0IW01.OP0IWWHS = " "; /* init first 1 model whs on prod*/
  OP0IW01.OP0IWFND = "N"; /* init not found*/

  while (sysVar.arrayIndex > 0) /* check 6 whs on product*/
    if (SYCREC.XWHCD[sysVar.arrayIndex] != " ")
      if (OP0IM001.XWHCD == SYCREC.XWHCD[sysVar.arrayIndex])
        OP0IW01.OP0IWFND = "Y";
      else
        OP0IW01.OP0IWWHS = SYCREC.XWHCD[sysVar.arrayIndex]; /* hold first whs*/
      end
    end
    sysVar.arrayIndex = sysVar.arrayIndex - 1;
  end

  if (OP0IW01.OP0IWWHS != " ") /* warehouse restriction*/
    if (OP0IW01.OP0IWFND == "N") /* must match map whs else error*/
      OPAREC.OPAERR = "Y";
      converseLib.validationFailed(163); /* whs not allowed for style*/
      set OP0IM001.XWHCD cursor, modified, bold;
      return;
    else
      OP1REC.OP1OWHMF = "Y"; /* flag order-have product restric*/
    end
  end






      /* *********************************/
      /* * got here, so warehouse o.k.*/
      /* *********************************/

  OP0IW01.OP0IWCWH = "Y"; /* changed warehouse, do combo edit*/
  set OP0IM001.XWHCD initialAttributes;
  set OP0IM001.XWHSABRV initialAttributes;



end // end OP0IS79

// edit price adjustment
Function OP0IS7A()



  TA1REC.TA1LOCAT[2] = "OP0IS7A"; /* error diag group name*/


  if (OP0IM001.OP0IMPAD == 0) /* zero adjust o.k.*/
    set OP0IM001.OP0IMPAD normal;
    return;
  end

  OP0IW01.OP0IWPRO = OP3REC.OP2AUPRC; /* original price*/
  OP0IW01.OP0IWPRN = OP3REC.OP2AUPRC + OP0IM001.OP0IMPAD; /* adjust*/

  if (OP0IW01.OP0IWPRN <= 0) /* new price le 0 invalid*/
    if (OP0IW01.OP0IWPRN == 0 /* if new price is zero*/
     && SYCREC.SY1FNSHG == "2") /* and prod is raw materials*/
      if (OP0IW01.XAUCD == "64" /* class is salesman samples*/
       || OP0IW01.XAUCD == "82") /* or rep samples*/
          /* next sentence - price = 0 ok*/
      else
        OPAREC.OPAERR = "Y";
        converseLib.validationFailed(189); /* price can not be < or = zero*/
        set OP0IM001.OP0IMPAD cursor, modified, bold;
        return;
      end
    else
      OPAREC.OPAERR = "Y";
      converseLib.validationFailed(189); /* price can not be < or = zero*/
      set OP0IM001.OP0IMPAD cursor, modified, bold;
      return;
    end
  end

  OP0IW01.OP0IWFND = "N"; /* no error*/

      /* note - op0iwpad = n, never changed*/
             /* op0iwpad = y, warning given once, don't repeat,*/
                           /* apply change*/

      /* note - use average unit price on review,*/
             /* or first-size-price for add mode*/
  if (OP0IW01.OP0IWPAD == "N") /* edit vary % only once*/
    OP0IS6H(); /* edit price variance*/
  end

  if (OP0IW01.OP0IWFND == "Y") /* edit once err found*/
    OP0IW01.OP0IWPAD = "Y"; /* give warning*/
    converseLib.validationFailed(169); /* warning - price outside range*/
    set OP0IM001.OP0IMPAD cursor, modified, bold;
    return;
  end


      /* be sure price adjustment does not make price < 0*/

  if (OP0IM001.OP0IMPAD < 0) /* if adjust negative*/
    OP0IW01.OP0IWNSN = OP0IM001.OP0IMPAD; /* make adjust positive*/
    OP0IW01.OP0IWNSN = OP0IW01.OP0IWNSN * -1;
    sysVar.arrayIndex = OP0IW01.OP0IWSZF;
    while (sysVar.arrayIndex < 41 /* if positive adjust.*/
     && sysVar.arrayIndex <= OP0IW01.OP0IWSZL) /* gt price on file*/
      if (OP3REC.OP3SZAFL[sysVar.arrayIndex] == "Y")
        if (OP0IW01.OP0IWNSN >= OP3REC.SY5PRCUN[sysVar.arrayIndex])
          if (OP0IW01.OP0IWNSN == OP3REC.SY5PRCUN[sysVar.arrayIndex] /* price = 0*/
           && SYCREC.SY1FNSHG == "2")                                /* prod is raw materials*/
            if (OP0IW01.XAUCD == "64" /* class is salesman samples*/
             || OP0IW01.XAUCD == "82") /* or rep samples*/
                /* next sentence - price = 0 ok*/
            else
              OPAREC.OPAERR = "Y";
              converseLib.validationFailed(189); /* adjust makes price negative*/
              set OP0IM001.OP0IMPAD cursor, modified, bold;
              return;
            end
          else
            OPAREC.OPAERR = "Y";
            converseLib.validationFailed(189); /* adjust makes price negative*/
            set OP0IM001.OP0IMPAD cursor, modified, bold;
            return;
          end
        end
      end
      sysVar.arrayIndex = sysVar.arrayIndex + 1;
    end
  end


      /* good price adjustment for all sizes*/

  sysVar.arrayIndex = OP0IW01.OP0IWSZF; /* from first possible size*/

  while (sysVar.arrayIndex < 41 /* add price adjust to all sizes*/
   && sysVar.arrayIndex <= OP0IWSZL) /* that are in product*/
    if (OP3REC.OP3SZAFL[sysVar.arrayIndex] == "Y") /* and are active*/
      OP3REC.SY5PRCUN[sysVar.arrayIndex] = OP3REC.SY5PRCUN[sysVar.arrayIndex] + OP0IM001.OP0IMPAD;
      OP3REC.OP3PRCOF[sysVar.arrayIndex] = "Y";
    end
    sysVar.arrayIndex = sysVar.arrayIndex + 1;
  end


      /* also add adjustment to price for all sizes*/

  if (OP0IM001.OP0IMPAL != 0)
    OP0IM001.OP0IMPAL = OP0IM001.OP0IMPAL + OP0IM001.OP0IMPAD;
  end


      /* adjust price used in variance edit*/

  OP3REC.OP2AUPRC = OP3REC.OP2AUPRC + OP0IM001.OP0IMPAD;


  OPWREC.OPWAUTFL = "Y"; /* require authorization*/
  OP3REC.OP2PRCOF = "Y"; /* prod override flag*/
  set OP0IM001.OP0IMPAD normal;
  OP0IM001.OP0IMPAD = 0; /* clear field*/


  if (OP0IW01.OP0IWPF6 == "Y") /* put new prices on map*/
    OP0IS66();
  end



end // end OP0IS7A

// edit price for all sizes
Function OP0IS7B()



  TA1REC.TA1LOCAT[2] = "OP0IS7B"; /* error diag group name*/

  OP0IW01.OP0IWPRO = OP3REC.OP2AUPRC; /* original priceall sizes*/
  OP0IW01.OP0IWPRN = OP0IM001.OP0IMPAL; /* new price*/

  if (OP0IW01.OP0IWPRN <= 0) /* new price le 0 invalid*/
    if (OP0IW01.OP0IWPRN == 0 /* if new price is zero*/
     && SYCREC.SY1FNSHG == "2") /* and prod is raw materials*/
      if (OP0IW01.XAUCD == "64" /* class is salesman samples*/
       || OP0IW01.XAUCD == "82") /* or rep samples*/
          /* next sentence - price = 0 ok*/
      else
        OPAREC.OPAERR = "Y";
        converseLib.validationFailed(189); /* price can not be < or = zero*/
        set OP0IM001.OP0IMPAL cursor, modified, bold;
        return;
      end
    else
      OPAREC.OPAERR = "Y";
      converseLib.validationFailed(189); /* price can not be < or = zero*/
      set OP0IM001.OP0IMPAL cursor, modified, bold;
      return;
    end
  end

  OP0IW01.OP0IWFND = "N"; /* no error*/

      /* note - op0iwpal = n, never checked*/
             /* op0iwpal = y, warning given once, dont repeat,*/
                           /* apply any change*/
  if (OP0IW01.OP0IWPAL == "N") /* edit only once*/
    OP0IS6H(); /* edit price variance*/
  end

  if (OP0IW01.OP0IWFND == "Y") /* edit once err found*/
    OP0IW01.OP0IWPAL = "Y"; /* give warning*/
    converseLib.validationFailed(169); /* warning - price outside range*/
    set OP0IM001.OP0IMPAL cursor, modified, bold;
    return;
  end


      /* good price for all sizes*/

  sysVar.arrayIndex = OP0IW01.OP0IWSZF; /* from first possible size*/

  while (sysVar.arrayIndex < 41 /* move price to all sizes*/
   && sysVar.arrayIndex <= OP0IWSZL) /* until end of product sizes*/
    if (OP3REC.OP3SZAFL[sysVar.arrayIndex] == "Y") /* for all active sizes*/
      OP3REC.SY5PRCUN[sysVar.arrayIndex] = OP0IM001.OP0IMPAL;
      OP3REC.OP3PRCOF[sysVar.arrayIndex] = "Y";
    end
    sysVar.arrayIndex = sysVar.arrayIndex + 1;
  end


      /* hold new price for price variance edit*/

  OP3REC.OP2AUPRC = OP0IM001.OP0IMPAL;


  OPWREC.OPWAUTFL = "Y"; /* require authorization*/
  OP3REC.OP2PRCOF = "Y"; /* prod override flag*/
  OP3REC.OP2PRCVF = "N"; /* prod prc vary flag*/
  set OP0IM001.OP0IMPAL normal;


  if (OP0IW01.OP0IWPF6 == "Y") /* move changed prices to map*/
    OP0IS66();
  end



end // end OP0IS7B

// combo edits-prod info,bottom
Function OP0IS7C()





  OPAREC.OPAFDT = OP0IM001.OP0IMNDT; /* convert mmddyy to ccyymmdd*/
  OPAREC.OPAWMM = OPAREC.OPAFMM; /* in oparec.opwwdt*/
  OPAREC.OPAWDD = OPAREC.OPAFDD;
  OPAREC.OPAWYY = OPAREC.OPAFYY;
    /* TCS change begins*/
  if (OPAREC.OPAFYY > 56)
    OPAREC.OPAWCC = 19;
  else
    OPAREC.OPAWCC = 20;
  end
      /* TCS change ends*/

      /* changed need date may force re-do of size prices*/

  if (OP0IW01.OP0IWCND == "Y") /* if changed needdate,*/
    OP0IS6I(); /* re-calc size prices, maybe*/
  end




      /* warehouse or needdate change forces*/
      /* look at nike sub-order array*/

  if (OP0IW01.OP0IWCND == "Y" /* if need date change*/
   || OP0IW01.OP0IWCWH == "Y") /* or warehouse change*/
    OP0IS27(); /* match/put in sub-ord array*/
    OP0IS21(); /* check 1-whse model again*/
     /* since sub order probably changed*/
        /* warehouse & needdate put into nike sub-order array*/
        /* with op0iwsbs set correctly, or error msg set-up.*/
  end




      /* if warehouse change, may recalculate prices*/

  if (OP0IW01.OP0IWCWH == "Y" /* if warehouse changed*/
   && OP1REC.XDVCD == "02"    /* and a nil order*/
   && OP1REC.XOBCD == "S1")   /* and a sample order type*/
    if (OP0IW01.XAUCD == "31" /* and customer's account class*/
     || OP0IW01.XAUCD == "32") /* is nike owned or export co.*/
      if (OP0IM001.XWHCD == " " /* if warehouse is now blank*/
       || OP0IM001.XWHCD == "12") /* or 12 for nil warehouse*/
        OP0IS6O(); /* get prc type cd based on co.*/
      else
                                   /* else (xwhcd now entered but not 12)*/
        OP0IS6N();
                                   /* get price typ cd based on comp nbr*/
      end
      OP0IS7H(); /* redo the pricing*/
    end
  end


   /* see if warehouse code requires an owner group code.*/

  if (OPWREC.OPWREVM == 7 /* if in review mode skip edit*/
   || OPWREC.OP2LNINB > 0) /* user can't edit xow in revm*/
     /* next sentence*/
  else
    if (OPWREC.XWHCD[OP0IWSBS] in XWHTBL.XWHCD)
      if (XWHTBL.XWHOWNGF[sysVar.arrayIndex] == "Y") /* if owner grp required*/
        OP0IS81(); /* edit owner group code*/
        if (OPAREC.OPAERR == "Y")
          return;
        end
      else
        OP3REC.XOWCD = "00";
        OP0IM001.XOWCD = "  ";
      end
    end
  end

    /* screened products*/

  if (OP0IW01.OP0IWESP == "Y") /* need date or xowcd has changed*/
    if (OP0IW01.OP0IWBBD == "B") /* BLANK BULK DRAW*/
      OP0IST4(); /* EDIT DRAW FOR SCREENED PRODUCTS*/
    else
      if (OP0IM001.XWHCD == "51"
       || OP0IM001.XWHCD == "25"
       || OP0IM001.XWHCD == "27")
        if (SYCREC.SY1BSTNB > " " /* There is a blank style*/
         && SYCREC.XPRCD != "22"  /* and not a custom logo product*/
         && OP3REC.XQACD == "01"  /* first quality*/
         && OP0IW01.XLCCD < "11") /* active life cycle*/
          if (OP1REC.XBDCD == "0" /* REG ORD*/
           || OP1REC.XBDCD == "1" /* CUSTOMER BULK*/
           || OP1REC.XBDCD == "N") /* CUSTOMER BULK*/
            OP0IS-CHK-FLYER(); /* CHK FOR FLYER STYLE*/
            if (SQLCA.VAGen_SQLCODE == 0 /* ONE ROW FOUND*/
             || SQLCA.VAGen_SQLCODE == -811) /* MORE THAN ONE ROW FOUND*/
              OP0IS-PROCES-FLYR(); /* PROCESS FLYER*/
            end
          end
        end
      end
    end
  end

  if (OP0IM001.XOWCD == " " /* owner group not required*/
   && OP3REC.XOWCD == "00")
     /* next sentence*/
  else
    if (OP0IM001.XOWCD != OP3REC.XOWCD) /* owner group required and changed*/
      OP3REC.XOWCD = OP0IM001.XOWCD; /* reset for next if statement*/
    end
  end

    /* set flag to prevent move of ordered quantities*/
    /* from op3rec to map during get availability routine (s52)*/
    /* because quantities have not been edited yet, and op3rec*/
    /* contains preconverse quantities.*/

  OP0IW01.OP0IWAVX = "N";

  if (OP0IW01.OP0IWCWH == "Y"      
   || OP3REC.XOWCD != AV6REC.XOWCD /* if curr avail for diff xow*/
   || OP0IW01.OP0IWESP == "Y")     /* screened products must be refound*/
    if (OP0IW01.OP0IWDAV == "Y") /* if display avail*/
      if (OP0IW01.OP0IWCND == "Y") /* if need date changed*/
        if (OP1REC.XGPCD == "03"           /* and apparel*/
         && OPWREC.XQACD[OP0IWSBP] == "01" /* and first quality*/
         && OP0IW01.XLCCD == "10")         /* AND IN-LINE GOOD*/
          if (OPWREC.XWHCD[OP0IWSBS] == "51" /* if whse*/
           || OPWREC.XWHCD[OP0IWSBS] == "25" /* or whse*/
           || OPWREC.XWHCD[OP0IWSBS] == "27") /* or whse*/
             /* next sentence              ;  next test will re-do avail*/
          else
            OP0ISGA(); /* get availability*/
            OP0IS51(); /* move to map*/
          end
        else
          OP0ISGA(); /* get availability*/
          OP0IS51(); /* move to map*/
        end
      else
        OP0ISGA(); /* get availability*/
        OP0IS51(); /* move to map*/
      end
    end
  end


  if (OP0IW01.OP0IWCND == "Y"
   && XOTTBL.XOTDSAVL[OP0IWSBO] == "A"
   && OP0IW01.OP0IWPAO == "N"
   && OP0IW01.OP0IWDAV == "Y")
    OP0ISGA(); /* will reset op0iwdav to 'n'*/
    OP0IS51(); /* and set map avail fields to dark*/
  end


  if (OP0IW01.OP0IWCND == "Y"
   && XOTTBL.XOTDSAVL[OP0IWSBO] == "A"
   && OP0IW01.OP0IWPAO == "Y"
   && OP0IW01.OP0IWDAV == "N")
    OP0ISGA(); /* will reset op0iwdav to 'y'*/
    OP0IS51(); /* and show availability*/
  end


    /* if apparel will need to re read*/
    /* availability since based on need date season for*/
    /* apparel. ( re-do only if need date changed and*/
    /* in-line apparel).*/

  if (OP0IW01.OP0IWDAV == "Y")
    if (OP0IW01.OP0IWCND == "Y" /* if need date changed*/
     && XOTTBL.XOTATONF[OP0IWSBO] == "N") /* and not at-once*/
      OP0ISGA(); /* get availability again*/
      OP0IS51(); /* set up screen with new availability*/
    else
      if (OP0IW01.OP0IWCWH == "Y")
        OP0ISGA(); /* get availability again*/
        OP0IS51(); /* set up screen with new availability*/
      end
    end
  end


   /* *****************************************************************/
   /* * 08/12/92 JLoyer:  Booking seasons                            **/
   /* *****************************************************************/
   /* * Need date changes can impact the bk-sesn and mo.  Warehouse  **/
   /* * changes can impact the bk-sesn for Int'l by causing a subord **/
   /* * split.  All the products on an Int'l suborder have the same  **/
   /* * bk-sesn which is controlled by the 1st product on the subord.**/
   /* * A warehouse or need date change will put a product on a      **/
   /* * different suborder and may change its bk-sesn.               **/
   /* *****************************************************************/

  if (OP0IW01.OP0IW-BK-SESN-REQUIRED == "Y") /* bk-sesn required on order*/
    if (OP1REC.XDVCD == "02") /* if International*/
      if (OP0IW01.OP0IW-DEFAULT-BK-SESN == "Y") /* if default bk-sesn*/
                                  /* (doesn't use ob1470)*/
      else /* else*/
        if (OP0IW01.OP0IWCND == "Y" /* if need date change*/
         || OP0IW01.OP0IWCWH == "Y") /* or warehouse change*/
          OP0IW01.OP0IW-OB1470-OP1CUNDT = OP0IW01.OP1CUNDT;
          OP0IS-CALL-OB1470(); /* get new bk-sesn*/
          if (OBSREC.OBS-RETN-CD == "00") /* if single bk-sesn*/
            OP0IW01.OP0IW-MULTI-BK-SESN-MSG = "N";
            OP0IS-EDIT-BK-SESN(); /* recheck bk-sesn*/
          else /* else*/
            if (OBSREC.OBS-RETN-CD == "01") /* if multi bk-sesn*/
              OP0IW01.OP0IW-MULTI-BK-SESN-MSG = "Y"; /* set msg fl*/
              OP0IS-EDIT-BK-SESN(); /* rechk bk-sesn*/
            end /**/
          end /**/
        else /**/
          if (OP0IW01.OP0IW-CHECK-BK-SESN == "Y") /* set by map ndt/whs modify*/
            OP0IS-EDIT-BK-SESN(); /* edit bk-sesn*/
          end
        end
      end /**/
    else /* else (not International)*/
      if (OP0IW01.OP0IWCND == "Y") /* if need date change*/
        OP0IW01.OP0IW-OB1470-OP1CUNDT = OP0IW01.OP1CUNDT;
        OP0IS-CALL-OB1470(); /* get bk-sesn*/
        if (OBSREC.OBS-RETN-CD == "00") /* if single bk-sesn*/
          OP0IW01.OP0IW-MULTI-BK-SESN-MSG = "N";
          OP0IS-EDIT-BK-SESN(); /* recheck bk-sesn*/
        else /* else*/
          if (OBSREC.OBS-RETN-CD == "01") /* if multi bk-sesns*/
            OP0IW01.OP0IW-MULTI-BK-SESN-MSG = "Y"; /* set msg fl*/
            OP0IS-EDIT-BK-SESN(); /* recheck bk-sesn*/
          end /* end;*/
        end
      else
        if (OP0IW01.OP0IW-CHECK-BK-SESN == "Y") /* set by map ndt modified*/
          OP0IS-EDIT-BK-SESN(); /* edit bk-sesns and mo*/
        end
      end
    end
  end


      /* reset flags after use*/

  OP0IW01.OP0IWCND = "N";
  OP0IW01.OP0IWCWH = "N";
  OP0IW01.OP0IWESP = "N";
  OP0IW01.OP0IWAVX = "Y";




end // end OP0IS7C

// fill lost demand? edit
Function OP0IS7D()

  if (OP0IM001.OP0IMFIL == "Y"
   || OP0IM001.OP0IMFIL == "N")
     /* next sentence*/
  else
    converseLib.validationFailed(563); /* correct response is y or n*/
    OPAREC.OPAERR = "Y";
    set OP0IM001.OP0IMFIL cursor, bold;
  end

end // end OP0IS7D

// edit spec code
Function OP0IS7E()

   /* if spec code is greater than spaces, validate it*/
   /* from vprdcu01 table.*/


  if (OP0IM001.PC2INSEG > " ")
     /* next sentence*/
  else
    set OP0IM001.PC2INSEG initialAttributes;
    OP3REC.PC2INSEG = "000";
    return;
  end


  PC2REC.PC2INSEG = OP0IM001.PC2INSEG;
  PC2REC.XGPCD = OP1REC.XGPCD;

  call "IO3340" ("SG", SQLCA, PC2REC) {isNoRefresh = yes, isExternal = yes}; /* call spec cd*/

  if (SQLCA.VAGen_SQLCODE == 0)
    set OP0IM001.PC2INSEG initialAttributes;
    OP3REC.PC2INSEG = OP0IM001.PC2INSEG;
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      set OP0IM001.PC2INSEG cursor, modified, bold;
      OPAREC.OPAERR = "Y";
      converseLib.validationFailed(159); /* spec code is not valid*/
    else
      TA1REC.TA1TYPE = "DB2 ";
      TA1REC.TA1FUNC = "POST";
      TA1REC.TA1PGMNM = "OP0I    ";
      TA1REC.TA1LOCAT[1] = "SG      ";
      TA1REC.TA1LOCAT[2] = "OP0IS7E ";
      TA1REC.TA1LOCAT[3] = "IO3340  ";
      TA1REC.TA1LOCAT[4] = OP0IM001.PC2INSEG;
      TA1REC.TA1MAP = "OP0IM001";
      TA1REC.TA1DBASE = "PC2REC  ";
      TA1REC.TA1TBLVU = "VPRDCU01";
      TA1REC.TA1TBLKE = OP1REC.XGPCD;
      try
        call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
      end /* abend routine*/
      COMMAREA.CA-USER-WORKAREA-4K = " "; /* clear ws on error*/
    end
  end


end // end OP0IS7E

// redo nike int'l pricing
Function OP0IS7H()


      /* redo nike international pricing when warehouse changes*/


  OP0IS22(); /* get pricefor style/color*/



  OP0IW01.OP0IWSBR = 1; /* recalculate prices for each size*/
  OP0IW01.OP0IWPRC = 0;
  while (OP0IW01.OP0IWSBR < 41
   && OP0IW01.OP0IWSBR <= OP0IW01.OP0IWSZL)
    OP0IS24(); /* re-do prices*/
    if (OP3REC.OP3SZAFL[OP0IWSBR] == "Y")
      OP0IS25(); /* set price vary flag*/
    end
    OP3REC.OP3PRCOF[OP0IWSBR] = "N";
    OP0IW01.OP0IWSBR = OP0IW01.OP0IWSBR + 1;
  end
  OP0IM001.OP0IMPAL = OP3REC.OP2AUPRC;


end // end OP0IS7H

// find valid xow program
Function OP0IS7I()


   /* This statement group calls io5480 to access davail.vblnkp01*/
   /* Davail.vblnkp01 will determine if the need-date falls*/
   /* within a valid need-date range.  It will also return a new*/
   /* xowcd code for the order which is based on the need-date.*/


  set SQLCA empty;
  set AVGREC empty;
  set AVIREC empty;

   /* op0iw01.op0iwp01 was calculated in op0ist0*/
   /* based on order type:*/
   /* draws and reg ords - special makeup = s*/
                     /* - regular        = t*/


  AVIREC.AVIFUNCD = "SA";
  AVIREC.OP1CUNDT = OP0IW01.OP1CUNDT;
  AVGREC.AVGBPIND = OP0IW01.OP0IWP01;

  call "IO5480" (AVIREC, SQLCA, AVGREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == +0
   || SQLCA.VAGen_SQLCODE == +100)
    /* next sentence*/
  else
    TA1REC.TA1TYPE = "DB2 ";
    TA1REC.TA1PGMNM = "OP0I   "; /* application*/
    TA1REC.TA1LOCAT[1] = "OP0IS7I "; /* statement group*/
    TA1REC.TA1LOCAT[2] = "IO5480  "; /* io mod called*/
    TA1REC.TA1LOCAT[3] = AVIREC.AVIFUNCD; /* function code passed*/
    TA1REC.TA1LOCAT[4] = TA2REC.TA2GRGGN; /* need date passed*/
    TA1REC.TA1MAP = "OP0IM001"; /* map*/
    TA1REC.TA1DBASE = "DAVAIL"; /* database name*/
    TA1REC.TA1TBLVU = "VBLNKP01"; /* table view*/
    TA1REC.TA1TBLKE = AVGREC.AVGKEY; /* key*/
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.rollback();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
    
    call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
    XSPF4();
  end

   /* ************************************************************/
end // end OP0IS7I

// screend prod: get xow cutoffdt
Function OP0IS7J()

   /* IO5530 calls dorder.vogcut01 to verify that a finished*/
   /* style is valid for specific xowcd and provide us with*/
   /* the cut-off date*/
    /* the cutoff record we want to use varies,*/
    /* depending on the type of order.*/
    /* - blank bulks, regular prop, inline futures use the cutoff*/
        /* record appropiate to the finished style*/
        /* for which we got the owner group by*/
        /* reading davail.vblnkp01*/
    /* - draws from blank bulks must be validated against*/
        /* the owner group of the original blank bulk*/

  set SQLCA empty;
  set OPLREC empty;
  set OECREC empty;

  OPLREC.OPLSOP = "SF";
  OPLREC.OPJCNDTB = OP0IW01.OP1CUNDT;

  if (OP0IW01.OP0IWBBD == "B") /* for draw from blank bulk*/
    if (OP1REC.XOBCD == "M1") /* for special makeup bulks*/
      OECREC.XOWCD = "SM"; /* use special makeup owner code*/
    else
      OECREC.XOWCD = "MR"; /* regular owner code*/
    end
  else
    OECREC.XOWCD = OP0IM001.XOWCD; /* owner code from vblnkp01*/
  end

  call "IO5530" (OPLREC, SQLCA, OECREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == +0 /* handling of cutoff depends*/
   || SQLCA.VAGen_SQLCODE == +100) /* on type of order and where*/
     /* next sentence                    this logic was called from*/
  else
    TA1REC.TA1TYPE = "DB2 ";
    TA1REC.TA1PGMNM = "OP0I   "; /* application*/
    TA1REC.TA1LOCAT[1] = "OP0IS7J "; /* statement group*/
    TA1REC.TA1LOCAT[2] = "IO5530  "; /* io mod called*/
    TA1REC.TA1LOCAT[3] = "SF"; /* function code used*/
    TA1REC.TA1LOCAT[4] = OPLREC.OPLGRPL; /* avhrec key*/
    TA1REC.TA1MAP = "OP0IM001"; /* map*/
    TA1REC.TA1DBASE = "DORDER"; /* database name*/
    TA1REC.TA1TBLVU = "VOGCUT01"; /* table view*/
    TA1REC.TA1TBLKE = OPLREC.OPLGRPL; /* key*/
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.rollback();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
    
    call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
    XSPF4();
  end
end // end OP0IS7J

// screend prod validate fin styl
Function OP0IS7K()

   /* IO5470 calls davail.vblnks01 to find out whether a finished*/
   /* style is valid for specific xowcd.  The xowcd is determined*/
   /* by davail.vblnkp01 (op0is7i) based on need-date.*/

  set SQLCA empty;
  set AVHREC empty;

  AVHREC.XOWCD = AVGREC.XOWCD;
  AVHREC.SY1STNBR = OPWREC.SY1STNBR[OP0IWSBP];
  AVHREC.SY2CLRID = OPWREC.SY2CLRID[OP0IWSBP];
  AVHREC.XDMCD = OPWREC.XDMCD[OP0IWSBP];

  call "IO5470" ("S ", SQLCA, AVHREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == +0 /* further processing will*/
   || SQLCA.VAGen_SQLCODE == +100) /* be determined based on the*/
      /* next sentence                  type of order, and where we*/
  else
    TA1REC.TA1TYPE = "DB2 ";
    TA1REC.TA1PGMNM = "OP0I   "; /* application*/
    TA1REC.TA1LOCAT[1] = "OP0IS7K "; /* statement group*/
    TA1REC.TA1LOCAT[2] = "IO5470  "; /* io mod called*/
    TA1REC.TA1LOCAT[3] = "S "; /* function code used*/
    TA1REC.TA1LOCAT[4] = AVHREC.AVHKEY; /* avhrec key*/
    TA1REC.TA1MAP = "OP0IM001"; /* map*/
    TA1REC.TA1DBASE = "DAVAIL"; /* database name*/
    TA1REC.TA1TBLVU = "VBLNKS01"; /* table view*/
    TA1REC.TA1TBLKE = AVHREC.AVHKEY; /* key*/
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.rollback();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
    
    call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
    XSPF4();
  end /* were called from*/
   /* ************************************************************/
end // end OP0IS7K

// edit owner group code
Function OP0IS81()



   /* since owner code edit triggered when warehouse changes*/
   /* if xow code in error, also set xwhcd modified to trigger*/
   /* re-edit of owner code.*/


     /* edit owner group code.*/



  if (OP0IM001.XOWCD == " ")
    if (OP0IM001.XWHCD == "03"
     || OP0IM001.XWHCD == "51"
     || OP0IM001.XWHCD == "25"
     || OP0IM001.XWHCD == "27")
      OP0IM001.XOWCD = "00"; /* default for whse '03','51','25','27'*/
    else
      OPAREC.OPAERR = "Y";
      converseLib.validationFailed(103); /* owner group required*/
      set OP0IM001.XOWCD cursor, modified, bold;
      return;
    end
  end




    /* look owner code up in xowtbl.*/


  XOWREC.XWHCD = OP0IM001.XWHCD;
  XOWREC.XOWCD = OP0IM001.XOWCD;

  if (XOWREC.XOWKEY in XOWTBL.XOWKEY) /* if in table*/
    if (XOWTBL.XXXSTAT[sysVar.arrayIndex] == "A")
      set OP0IM001.XOWCD initialAttributes;
      OP0IM001.XOWABRV = XOWTBL.XOWABRV[sysVar.arrayIndex];
    else
      OPAREC.OPAERR = "Y";
      converseLib.validationFailed(101); /* owner group code not found on table*/
      set OP0IM001.XOWCD cursor, modified, bold;
      return;
    end
  else
    OPAREC.OPAERR = "Y";
    converseLib.validationFailed(101); /* owner group code not found on table*/
    set OP0IM001.XOWCD cursor, modified, bold;
    return;
  end


       /* check for the universal owner group code --*/
       /* any service rep is accepted if this owner group*/
       /* code was entered*/

  if (XOWTBL.XOWALUSR[sysVar.arrayIndex] == "Y") /* this is it*/
    OP3REC.XOWCD = OP0IM001.XOWCD;
    return; /* ok*/
  end /* continue editing*/


      /* for promo warehouse and team sales owner codes*/
      /* allow any service rep userid to order*/

  if (OP0IM001.XWHCD == "09")
    if (OP0IM001.XOWCD == "45"
     || OP0IM001.XOWCD == "55"
     || OP0IM001.XOWCD == "65"
     || OP0IM001.XOWCD == "75")
      set OP0IM001.XOWCD initialAttributes;
      OP3REC.XOWCD = OP0IM001.XOWCD;
      return;
    end
  end



    /* match owner code to userid and warehouse*/

  OPAREC.OPASUB = 1;
  OP0IW01.OP0IWFND = "N";

  while (XOLTBL.XSVCD[OPASUB] != 9999 /* while not end of table*/
   && XOLTBL.XWHCD[OPASUB] != "99" 
   && OP0IW01.OP0IWFND == "N")
    if (XOLTBL.XWHCD[OPASUB] == OP0IM001.XWHCD
     && XOLTBL.XSVCD[OPASUB] == OP1REC.OP1ENREP
     && XOLTBL.XXXSTAT[OPASUB] == "A")
      OP0IW01.OP0IWFND = "Y"; /* found entry*/
    else
      OPAREC.OPASUB = OPAREC.OPASUB + 1;
    end
  end


  if (OP0IW01.OP0IWFND == "N")
    converseLib.validationFailed(102);
                                   /* owner code no match to whs and userid*/
    OPAREC.OPAERR = "Y";
    set OP0IM001.XOWCD cursor, modified, bold;
    return;
  end



   /* now see that the xowcd is on the oltbl record.*/
   /* first check the all owners flag.*/


  if (XOLTBL.XOLALLOF[OPASUB] == "Y")
    set OP0IM001.XOWCD initialAttributes;
    OP3REC.XOWCD = OP0IM001.XOWCD;
    return;
  end


  if (XOLTBL.XOWCD1[OPASUB] == OP0IM001.XOWCD)
    set OP0IM001.XOWCD initialAttributes;
    OP3REC.XOWCD = OP0IM001.XOWCD;
    return;
  end

  if (XOLTBL.XOWCD2[OPASUB] == OP0IM001.XOWCD)
    set OP0IM001.XOWCD initialAttributes;
    OP3REC.XOWCD = OP0IM001.XOWCD;
    return;
  end

  if (XOLTBL.XOWCD3[OPASUB] == OP0IM001.XOWCD)
    set OP0IM001.XOWCD initialAttributes;
    OP3REC.XOWCD = OP0IM001.XOWCD;
    return;
  end

  if (XOLTBL.XOWCD4[OPASUB] == OP0IM001.XOWCD)
    set OP0IM001.XOWCD initialAttributes;
    OP3REC.XOWCD = OP0IM001.XOWCD;
    return;
  end

  if (XOLTBL.XOWCD5[OPASUB] == OP0IM001.XOWCD)
    set OP0IM001.XOWCD initialAttributes;
    OP3REC.XOWCD = OP0IM001.XOWCD;
    return;
  end

  if (XOLTBL.XOWCD6[OPASUB] == OP0IM001.XOWCD)
    set OP0IM001.XOWCD initialAttributes;
    OP3REC.XOWCD = OP0IM001.XOWCD;
    return;
  end

  if (XOLTBL.XOWCD7[OPASUB] == OP0IM001.XOWCD)
    set OP0IM001.XOWCD initialAttributes;
    OP3REC.XOWCD = OP0IM001.XOWCD;
    return;
  end

  if (XOLTBL.XOWCD8[OPASUB] == OP0IM001.XOWCD)
    set OP0IM001.XOWCD initialAttributes;
    OP3REC.XOWCD = OP0IM001.XOWCD;
    return;
  end

  if (XOLTBL.XOWCD9[OPASUB] == OP0IM001.XOWCD)
    set OP0IM001.XOWCD initialAttributes;
    OP3REC.XOWCD = OP0IM001.XOWCD;
    return;
  end

  if (XOLTBL.XOWCD10[OPASUB] == OP0IM001.XOWCD)
    set OP0IM001.XOWCD initialAttributes;
    OP3REC.XOWCD = OP0IM001.XOWCD;
    return;
  end

  if (XOLTBL.XOWCD11[OPASUB] == OP0IM001.XOWCD)
    set OP0IM001.XOWCD initialAttributes;
    OP3REC.XOWCD = OP0IM001.XOWCD;
    return;
  end

  if (XOLTBL.XOWCD12[OPASUB] == OP0IM001.XOWCD)
    set OP0IM001.XOWCD initialAttributes;
    OP3REC.XOWCD = OP0IM001.XOWCD;
    return;
  end

  if (XOLTBL.XOWCD13[OPASUB] == OP0IM001.XOWCD)
    set OP0IM001.XOWCD initialAttributes;
    OP3REC.XOWCD = OP0IM001.XOWCD;
    return;
  end

  if (XOLTBL.XOWCD14[OPASUB] == OP0IM001.XOWCD)
    set OP0IM001.XOWCD initialAttributes;
    OP3REC.XOWCD = OP0IM001.XOWCD;
    return;
  end

  if (XOLTBL.XOWCD15[OPASUB] == OP0IM001.XOWCD)
    set OP0IM001.XOWCD initialAttributes;
    OP3REC.XOWCD = OP0IM001.XOWCD;
    return;
  end

  if (XOLTBL.XOWCD16[OPASUB] == OP0IM001.XOWCD)
    set OP0IM001.XOWCD initialAttributes;
    OP3REC.XOWCD = OP0IM001.XOWCD;
    return;
  end

  if (XOLTBL.XOWCD17[OPASUB] == OP0IM001.XOWCD)
    set OP0IM001.XOWCD initialAttributes;
    OP3REC.XOWCD = OP0IM001.XOWCD;
    return;
  end

  if (XOLTBL.XOWCD18[OPASUB] == OP0IM001.XOWCD)
    set OP0IM001.XOWCD initialAttributes;
    OP3REC.XOWCD = OP0IM001.XOWCD;
    return;
  end

  if (XOLTBL.XOWCD19[OPASUB] == OP0IM001.XOWCD)
    set OP0IM001.XOWCD initialAttributes;
    OP3REC.XOWCD = OP0IM001.XOWCD;
    return;
  end

  if (XOLTBL.XOWCD20[OPASUB] == OP0IM001.XOWCD)
    set OP0IM001.XOWCD initialAttributes;
    OP3REC.XOWCD = OP0IM001.XOWCD;
    return;
  end




    /* if got here didn't find xowcd in the 20 xowcd's*/
    /* of the xoltbl.*/


  OPAREC.OPAERR = "Y";
  converseLib.validationFailed(102); /* owner group not allowable*/
  set OP0IM001.XOWCD cursor, modified, bold;





end // end OP0IS81

// do demand reporting
Function OP0IS82()



    /* this routine does the following demand reporting*/
    /* functions based on events throughout the entry*/
    /* of the last line item.*/

       /* 1.  "QA" - quantity added after production deadline.*/
       /* 2.  "PD" - postponed demand, need date pushed out.*/
       /* 3.  "SD" - substituted demand.*/
       /* 4.  "XD" - cancelled demand*/



    /* 1. qa*/


  if (OP0IW01.OP0IWBDF == "BS" /* smart reservations*/
   || OP0IW01.OP0IWBDF == "BX") /* flex bulks*/
     /* next sentence ;  write no audits for flex or smart bulks*/
  else
    if (OP0IW01.OP0IWPAO == "Y") /* if item was a production add on*/
      if (OP1REC.XOTCD in XOTTBL.XOTCD) /* if valid order type code*/
        if (XOTTBL.XOTFUTRF[sysVar.arrayIndex] == "Y") /* if futures order*/
          set OPUREC empty;
          if (OPWREC.OPWREVM == 7 /* if in review mode*/
           || OPWREC.OP2LNINB > 0)
            if (OP0IW01.OP0IWCHG == "Y") /* and something was changed*/
              OP0IW01.OP0IWQTY = 0; /* add up changed qty*/
              OPAREC.OPASUB = 1;
              while (OPAREC.OPASUB <= 40)
                OP0IW01.OP0IWQTY = OP0IW01.OP0IWQTY + OP0IW01.OP0IWCQT[OPASUB];
                OPAREC.OPASUB = OPAREC.OPASUB + 1;
              end
              if (OP0IW01.OP0IWQTY == 0) /* nothing chnaged*/
                 /* next sentence  - skip report*/
              else
                OPUREC.OPUAUDTP = "QA";
                OP0IS8E(); /* load qtys from cqt*/
                OP0IS8D(); /* load and write opurec*/
              end
            end
          else
            OPUREC.OPUAUDTP = "QA";
            OP0IS8C(); /* load qtys from op3rec*/
            OP0IS8D(); /* load and write opurec*/
          end
        end
      end
    end
  end





    /* 2. postponed demand.*/
        /* - reset need date in record to be the original*/
          /* need date requested or the need date in the*/
          /* first cell of the sub-order array. -- jdv 8/87*/

  OP0IW01.OP0IWNDT = OPWREC.OP1CUNDT[1];
  OP0IW01.OP0IWCMM = OP0IW01.OP0IWNMM;
  OP0IW01.OP0IWCDD = OP0IW01.OP0IWNDD;

    /* only do postponed demand if order type flag on.*/

  if (XOTTBL.XOTDMRPF[OP0IWSBO] == "Y")
     /* next sentence*/
  else
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.commit();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
     /* set data base*/
    return; /* exit*/
  end

  if (OP0IW01.OP0IWPND == "Y") /* if need date pushed*/
    if (OP0IW01.OP0IWNMM == OPAREC.OPAWMM) /* don't write if still same mo.*/
      /* next sentence*/
    else
      set OPTREC empty;
      OPTREC.OPTDMND = "PD";
      OPTREC.SY1STNBR = OP3REC.SY1STNBR;
      OPTREC.SY2CLRID = OP3REC.SY2CLRID;
      OPTREC.XDMCD = OP3REC.XDMCD;
      if (OPWREC.OPWREVM == 7 /* if review mode*/
       || OPWREC.OP2LNINB > 0)
        OP0IW01.OP0IWSBR = OP0IW01.OP0IWSMF; /* first active size*/
        while (OP0IW01.OP0IWSBR <= OP0IW01.OP0IWSML) /* last active size*/
          if (OP0IW01.OP0IWCQT[OP0IWSBR] != 0)
            OP0IS8B(); /* load demand qtys from op0iwcqt*/
            OP0IS86(); /* write demand record*/
            OP0IWSBR = 40; /* only process once, get out of loop*/
          end
          OP0IW01.OP0IWSBR = OP0IW01.OP0IWSBR + 1;
        end
      else
        OP0IS8A(); /* load dmnd qtys from op3rec*/
        OP0IS86(); /* write demand record*/
      end
    end
  end



    /* 3. substituted demand.*/



   /* *** note: the following were commented out because no*/
             /* substitution is done in review mode. 01/22/90*/

  if (OPWREC.OPWREVM == 7 /* if review mode*/
   || OPWREC.OP2LNINB > 0)
     /* next sentence for now*/
      /* IF OP3REC.OP2SSTYN NE ' '     ; if entered a subst style*/
        /* SET OPTREC EMPTY;*/
        /* MOVE 'SD' TO OPTREC.OPTDMND;*/
        /* MOVE OP3REC.OP2SSTYN TO OPTREC.SY1STNBR;*/
        /* MOVE OP3REC.OP2SCLCD TO OPTREC.SY2CLRID;*/
        /* MOVE OP3REC.OP2SDMCD TO OPTREC.XDMCD;*/
    /* MOVE OP0IW01.OP0IWSMF TO OP0IW01.OP0IWSBR; first active size*/
    /* WHILE OP0IW01.OP0IWSBR LE OP0IW01.OP0IWSML; last active size*/
          /* IF OP0IW01.OP0IWCQT(OP0IWSBR) NE 0;*/
        /* OP0IS8B                 ; load demand qtys from op0iwcqt*/
            /* OP0IS86                 ; write demand record*/
    /* MOVE 40 TO OP0IWSBR     ; only process once, get out of loop*/
          /* END ;*/
          /* OP0IW01.OP0IWSBR = OP0IW01.OP0IWSBR + 1;*/
        /* END ;*/
      /* END ;*/
  else
    if (OP3REC.OP2SSTYN > " ") /* if entered a subst style*/
      set OPTREC empty;
      OPTREC.OPTDMND = "SD";
      OPTREC.SY1STNBR = OP3REC.OP2SSTYN;
      OPTREC.SY2CLRID = OP3REC.OP2SCLCD;
      OPTREC.XDMCD = OP3REC.OP2SDMCD;
      OP0IS8A(); /* load demand qtys from op3rec*/
      OP0IS86(); /* write demand record*/
    end
  end



    /* 4. cancel lost demand.*/

  if (OP0IM001.OP0IMFIL == "Y") /* if fill lost demand flag on*/
    set OPTREC empty;
    OPTREC.OPTDMND = "XD";
    OPTREC.SY1STNBR = OP3REC.SY1STNBR;
    OPTREC.SY2CLRID = OP3REC.SY2CLRID;
    OPTREC.XDMCD = OP3REC.XDMCD;
    if (OPWREC.OPWREVM == 7 /* if review mode*/
     || OPWREC.OP2LNINB > 0)
      OP0IW01.OP0IWSBR = OP0IW01.OP0IWSMF; /* first active size*/
      while (OP0IW01.OP0IWSBR <= OP0IW01.OP0IWSML) /* last active size*/
        if (OP0IW01.OP0IWCQT[OP0IWSBR] != 0)
          OP0IS8B(); /* load demand qtys from op0iwcqt*/
          OP0IS8F(); /* make quantities negative*/
          OP0IS87(); /* write demand record w/neg qties*/
          OP0IWSBR = 40; /* only process once, get out of loop*/
        end
        OP0IW01.OP0IWSBR = OP0IW01.OP0IWSBR + 1;
      end
    else
      OP0IS8A(); /* load dmnd qtys from op3rec*/
      OP0IS8F(); /* make quantities negative*/
      OP0IS87(); /* write demand record*/
    end
  end



   /* **********************************************************/
end // end OP0IS82

// wait one second
Function OP0IS84()




    /* this routine waits one second. used for deadlock*/
    /* error trapping.*/


  OP0IW01.OP0IWTM1 = VGVar.currentFormattedTime;
  OP0IW01.OP0IWTHL = OP0IW01.OP0IWTHF;
  OP0IW01.OP0IWTML = OP0IW01.OP0IWTMF;
  OP0IW01.OP0IWTSL = OP0IW01.OP0IWTSF;

  OP0IW01.OP0IWSS1 = OP0IW01.OP0IWTSL;
  OP0IW01.OP0IWMM1 = OP0IW01.OP0IWTML;

  OP0IW01.OP0IWSS1 = OP0IW01.OP0IWSS1 + 1;
  OP0IW01.OP0IWTM1 = VGVar.currentFormattedTime;

  while (OP0IW01.OP0IWTSL < OP0IW01.OP0IWSS1
   && OP0IW01.OP0IWTML <= OP0IW01.OP0IWMM1)
    OP0IW01.OP0IWTHL = OP0IW01.OP0IWTHF;
    OP0IW01.OP0IWTML = OP0IW01.OP0IWTMF;
    OP0IW01.OP0IWTSL = OP0IW01.OP0IWTSF;
    OP0IW01.OP0IWTM1 = VGVar.currentFormattedTime;
  end






end // end OP0IS84

// write demand report record
Function OP0IS86()


    /* this routine writes vorder.vlost001 records.*/

      /* ********************************************************/
      /* * load optrec for lost demand reporting*/
      /* ********************************************************/


  TA1REC.TA1LOCAT[2] = "OP0IS86"; /* err diag group name*/


  OPTREC.XOTCD = OP1REC.XOTCD;
  OPTREC.OP1PARTN = OP1REC.OP1PARTN;
  OPTREC.OP1CUOID = OP1REC.OP1CUOID;
  OPTREC.OPTWAITF = "Y";
  OPTREC.XXXPHN = " ";
  OP0IW01.OP0IWFDT = OP0IM001.OP0IMNDT;
  if (OP0IW01.OP0IWFYY > 56)
    XX0XW19 = 19;
  else
    XX0XW19 = 20;
  end
  XX0XW01.XX0XWYY = OP0IW01.OP0IWFYY;
  XX0XW01.XX0XWMM = OP0IW01.OP0IWFMM;
  XX0XW01.XX0XWDD = OP0IW01.OP0IWFDD;
  OPTREC.OPTDRPDT = XX0XW01.XX0XWDAT;
  OPTREC.OP1ORDBY = " ";
  if (OPTREC.OPTDMND == "PD")
    OPTREC.OP1CUNDT = OPWREC.OP1CUNDT[1];
  else
    OPTREC.OP1CUNDT = OP0IW01.OP1CUNDT; /* map need date*/
  end
  OPTREC.XWHCD = OP1REC.XWHCD;
  OPTREC.XDVCD = OP1REC.XDVCD;
  OPTREC.XSOCD = OP1REC.XSOCD;
  OPTREC.OP1TBREP = OP1REC.OP1TBREP; /* taken by rep*/
  OPTREC.KUCCOID = OP1REC.KUCCOID;
  OPTREC.KUMSTRID = OP1REC.KUMSTRID;
  OPTREC.XNXCD = OP1REC.XNXCD;
  OPTREC.XGPCD = OP3REC.XGPCD;

  OPTREC.ZZZSDT = OPAREC.OPACDT;
  OPTREC.ZZZSTM = OP0IW01.OP0IWTM3;

  call "IO3070" ("A ", SQLCA, OPTREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DORDER";
    TA1REC.TA1LOCAT[1] = "OP0IS86";
    TA1REC.TA1TBLVU = "VLOST001";
    TA1REC.TA1TBLKE = OPTREC.SY1STNBR;
    TA1REC.TA1LOCAT[3] = "IO3070";
    XSOPS02(); /* common abend*/
  end




end // end OP0IS86

// write filled demand report rec
Function OP0IS87()


    /* this routine writes vorder.vlost001 records as cancelled*/
    /* demand for situtations where originally lost demand was*/
    /* now filled.  these record quantities are negative.*/
    /* this is done so lost demand isn't overstated.*/

      /* ********************************************************/
      /* * load optrec for filled lost demand reporting*/
      /* ********************************************************/


  TA1REC.TA1LOCAT[2] = "OP0IS87"; /* err diag group name*/


  OPTREC.XOTCD = OP1REC.XOTCD;
  OPTREC.OP1PARTN = OP1REC.OP1PARTN;
  OPTREC.OP1CUOID = OP1REC.OP1CUOID;
  OPTREC.OPTWAITF = "N";
  OPTREC.XXXPHN = " ";
  OP0IW01.OP0IWFDT = OP0IM001.OP0IMNDT;
  if (OP0IW01.OP0IWFYY > 56)
    XX0XW19 = 19;
  else
    XX0XW19 = 20;
  end
  XX0XW01.XX0XWYY = OP0IW01.OP0IWFYY;
  XX0XW01.XX0XWMM = OP0IW01.OP0IWFMM;
  XX0XW01.XX0XWDD = OP0IW01.OP0IWFDD;
  OPTREC.OP1CUNDT = XX0XW01.XX0XWDAT;
  OPTREC.OP1ORDBY = " ";
  OPTREC.OPTDRPDT = 0;
  OPTREC.XWHCD = OP1REC.XWHCD;
  OPTREC.XDVCD = OP1REC.XDVCD;
  OPTREC.XSOCD = OP1REC.XSOCD;
  OPTREC.OP1TBREP = OP1REC.OP1TBREP; /* taken by rep*/
  OPTREC.KUCCOID = OP1REC.KUCCOID;
  OPTREC.KUMSTRID = OP1REC.KUMSTRID;
  OPTREC.XNXCD = OP1REC.XNXCD;
  OPTREC.XGPCD = OP3REC.XGPCD;

  OPTREC.ZZZSDT = OPAREC.OPACDT;
  OPTREC.ZZZSTM = OP0IW01.OP0IWTM3;

  call "IO3070" ("A ", SQLCA, OPTREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DORDER";
    TA1REC.TA1LOCAT[1] = "OP0IS87";
    TA1REC.TA1TBLVU = "VLOST001";
    TA1REC.TA1TBLKE = OPTREC.SY1STNBR;
    TA1REC.TA1LOCAT[3] = "IO3070";
    XSOPS02(); /* common abend*/
  end




end // end OP0IS87

// db2-abend szrun add/update
Function OP0IS88()



      /* ***********************/
      /* check db2 return code*/
      /* ***********************/

  TA1REC.TA1LOCAT[2] = "OP0IS88"; /* error diag group name*/


  if (OPBREC.OPBSZRC < 0) /* if negative return code*/
    XSPF4(); /* return to master menu*/
    OP0IM001.VAGen_EZEMSG = COMMAREA.CAMSG; /* bad transfer*/
    exit stack;
  else
    TA1REC.TA1DBASE = "DORDER"; /* data base name*/
    TA1REC.TA1TBLVU = "SZRUN "; /* table view*/
    TA1REC.TA1TBLKE = OP3REC.OP2KEY; /* key value*/
    TA1REC.TA1LOCAT[3] = "DB1000"; /* i/o mod*/
    XSOPS02(); /* common abend routine*/
  end



end // end OP0IS88

// xfer to other application
Function OP0IS89()



      /* *************************************************/
      /* * common routine to exit op0i application*/
      /* * flow to prod hdr or summary or accept order*/
      /* *************************************************/

  TA1REC.TA1LOCAT[2] = "OP0IS89"; /* error diag-group name*/


  if (converseVar.eventKey is pf13) /* if pf13 (exit prod loop)*/
    /* next sentence                ;   skip next product check*/
  else /* assume 'enter',pf24,or reject prod*/
    if (OP0IW01.OP0IWREJ == "Y")
      OPWREC.OPWDUPSZ[OP0IWSBP] = "R"; /* flag prod as rejected*/
    end
    OP0IW01.OP0IWSBP = OP0IW01.OP0IWSBP + 1; /* look at next array entry*/
    if (OP0IW01.OP0IWSBP < 7 /* if still in array*/
     && OPWREC.SY1STNBR[OP0IWSBP] != " ") /* and have a product*/
      OP0IW01.OP0IWNXT = "Y";
      exit stack; /* go to start next product*/
    end
  end


      /* note - 6 prod array should have only 1 entry for review*/

  OPWREC.OP1GROUP = OP1REC.OP1GROUP; /* set up commarea for xfer*/
  COMMAREA.CA-USER-WORKAREA-4K = OPWREC.OPWSGRP;
  COMMAREA.CAFROMAP = COMMAREA.CACURRAP;


  if (OPWREC.OPWREVM == 7 /* in review mode*/
   || OPWREC.OP2LNINB > 0) /* or selected prod from summary*/
    sysVar.arrayIndex = OPWREC.OP2LNINB;
    if (OPWREC.OPWSELCD[sysVar.arrayIndex] == "R") /* if prd rejected*/
      OPWREC.OP2LNINB = 0; /* zero item nbr*/
      COMMAREA.CA-USER-WORKAREA-4K = OPWREC.OPWSGRP;
    end
    COMMAREA.CACURRAP = "OP0K";
    transfer to program "OP0K" passing COMMAREA; /* return to prod summry*/
  end


  if (converseVar.eventKey is pf13) /* if end of prod loop*/
    /* next sentence                ;   n.s.*/
  else
    if (OPWREC.OPWSFLOW == "1" /* in form flow with array not*/
     && OP0IW01.OP0IWSBP < 7)  /* full, so exit prod loop*/
      /* next sentence*/
    else /* in add mode or acpt ord#8 add*/
      COMMAREA.CACURRAP = "OP0H";
      transfer to program "OP0H" passing COMMAREA; /* go to product hdr, loop products*/
    end
  end


      /* got here with pf13, exit prod loop*/
      /* or end of products on mult prod header (form flow)*/

  if (OPWREC.OPWREVM == 8) /* if in add prod review mode*/
    COMMAREA.CACURRAP = "OP0J"; /* go to accept order*/
    transfer to program "OP0J" passing COMMAREA;
  else
    if (OPWREC.OPWPITM == 0) /* if 0 products were entered*/
      OPWREC.OPWMSGC1 = 130; /* set no prd warning msg*/
    end
    if (OPWREC.OPWSFLOW == "1") /* if form flow*/
      COMMAREA.CACURRAP = "OP0J"; /* accept order*/
      transfer to program "OP0J" passing COMMAREA;
    else
      COMMAREA.CACURRAP = "OP0K"; /* phone flow to prod summry*/
      transfer to program "OP0K" passing COMMAREA;
    end
  end



end // end OP0IS89

// load demand qtys from op3rec
Function OP0IS8A()


  TA1REC.TA1LOCAT[2] = "OP0IS8A"; /* group level diags*/


  OP0IW01.OP0IWTOT = 0; /* init counter*/

               /* load demand qtys from op3rec*/
  OP0IW01.OP0IWSBR = 1; /* first active size*/
  while (OP0IW01.OP0IWSBR <= 40) /* record le last active size*/
    if (OP3REC.OP3SZAFL[OP0IWSBR] == "Y") /* size active*/
      OPTREC.OPTDMDQT[OP0IWSBR] = OP3REC.OP3ONOQT[OP0IWSBR];
      OP0IW01.OP0IWTOT = OP0IW01.OP0IWTOT + OP3REC.OP3ONOQT[OP0IWSBR];
    else
      OPTREC.OPTDMDQT[OP0IWSBR] = 0;
    end
    OP0IW01.OP0IWSBR = OP0IW01.OP0IWSBR + 1;
  end

end // end OP0IS8A

// load demand qtys from op0icqt
Function OP0IS8B()

  TA1REC.TA1LOCAT[2] = "OP0IS8B"; /* group level diags*/


               /* load demand qtys from op0iw01.op0iwcqt*/
  OP0IW01.OP0IWSBR = OP0IW01.OP0IWSMF; /* first active size*/
  while (OP0IW01.OP0IWSBR <= OP0IW01.OP0IWSML) /* record le last active size*/
    OPTREC.OPTDMDQT[OP0IWSBR] = OP0IW01.OP0IWCQT[OP0IWSBR];
    OP0IW01.OP0IWSBR = OP0IW01.OP0IWSBR + 1;
  end

end // end OP0IS8B

// load opurec qtys from op3rec
Function OP0IS8C()


  TA1REC.TA1LOCAT[2] = "OP0IS8C"; /* group level diags*/


      /* ********************************************************/
      /* * load opurec qtys from op3rec for audit reporting*/
      /* ********************************************************/


               /* load demand qtys from op3rec*/
  OP0IW01.OP0IWSBR = 1; /* first active size*/
  while (OP0IW01.OP0IWSBR <= 40) /* record le last active size*/
    if (OP3REC.OP3SZAFL[OP0IWSBR] == "Y") /* size active*/
      OPUREC.OPUAUDQT[OP0IWSBR] = OP3REC.OP3ONOQT[OP0IWSBR];
    else
      OPUREC.OPUAUDQT[OP0IWSBR] = 0;
    end
    OP0IW01.OP0IWSBR = OP0IW01.OP0IWSBR + 1;
  end




end // end OP0IS8C

// load and write opurec audits
Function OP0IS8D()

  TA1REC.TA1LOCAT[2] = "OP0IS8D"; /* group level diags*/

     /* load data to opurec*/
    /* this routine writes dorder.voraud01 records.*/



      /* ********************************************************/
      /* * load opurec for audit reporting*/
      /* ********************************************************/


  OPUREC.XXXPGMNB = "OP0I"; /* program name*/
  OPUREC.OP1PARTN = OP3REC.OP1PARTN; /* part char*/
  OPUREC.OP1CUOID = OP3REC.OP1CUOID; /* cust ord id*/
  OPUREC.OP1NORID = OP3REC.OP1NORID; /* nike ord id*/
  OPUREC.OP2LNINB = OP3REC.OP2LNINB; /* line item number*/
  OPUREC.XGPCD = OP3REC.XGPCD; /* gen prod class*/
  OPUREC.SY1STNBR = OP3REC.SY1STNBR; /* style*/
  OPUREC.SY2CLRID = OP3REC.SY2CLRID; /* color*/
  OPUREC.XDMCD = OP3REC.XDMCD; /* dimension*/
  OPUREC.XQACD = OP3REC.XQACD; /* quality code*/
  OPUREC.XOWCD = OP3REC.XOWCD; /* owner group*/
  OPUREC.XOMCD = "  "; /* maint reason not req'd for entry*/
  OPUREC.XOTCD = OP1REC.XOTCD; /* order type*/
  OPUREC.OP1CUNDT = OP0IW01.OP1CUNDT; /* map need date*/
  OPUREC.XWHCD = OPWREC.XWHCD[OP0IWSBS]; /* map whse*/
  OPUREC.XDVCD = OP1REC.XDVCD; /* division*/

  OPUREC.ZZZSDT = OPAREC.OPACDT; /* date*/
  OPUREC.ZZZSTM = OP0IW01.OP0IWTM3; /* time*/



  call "IO3210" ("A ", SQLCA, OPUREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DORDER";
    TA1REC.TA1LOCAT[1] = "OP0IS8D";
    TA1REC.TA1TBLVU = "VORAUD01";
    OP0IW01.OP0IWTK1 = OPUREC.OP1CUOID; /* diagnostics*/
    OP0IW01.OP0IWTK2 = OPUREC.OP1NORID; /* diagnostics*/
    OP0IW01.OP0IWTK3 = OPUREC.OPUAUDTP; /* diagnostics*/
    OP0IW01.OP0IWTK4 = OPUREC.SY1STNBR; /* diagnostics*/
    OP0IW01.OP0IWTK5 = OPUREC.SY2CLRID; /* diagnostics*/
    TA1REC.TA1TBLKE = OP0IW01.OP0IWT1; /* diagnostics*/
    TA1REC.TA1LOCAT[3] = "IO3210";
    XSOPS02(); /* common abend*/
  end




end // end OP0IS8D

// load opurec qtys from op0iwcqt
Function OP0IS8E()


  TA1REC.TA1LOCAT[2] = "OP0IS8E"; /* group level diags*/


      /* ********************************************************/
      /* * load opurec qtys for audit reporting*/
      /* ********************************************************/


               /* load demand qtys from op0iw01.op0iwcqt*/

  OP0IW01.OP0IWSBR = 1; /* first active size*/
  while (OP0IW01.OP0IWSBR <= 40) /* record le last active size*/
    OPUREC.OPUAUDQT[OP0IWSBR] = OP0IW01.OP0IWCQT[OP0IWSBR];
    OP0IW01.OP0IWSBR = OP0IW01.OP0IWSBR + 1;
  end




end // end OP0IS8E

// load filled demand qtys optrec
Function OP0IS8F()

  TA1REC.TA1LOCAT[2] = "OP0IS8F"; /* group level diags*/

  OP0IW01.OP0IWSBR = 1;

  while (OP0IW01.OP0IWSBR <= 40)
    OPTREC.OPTDMDQT[OP0IWSBR] = OPTREC.OPTDMDQT[OP0IWSBR] * -1;
    OP0IW01.OP0IWSBR = OP0IW01.OP0IWSBR + 1;
  end

end // end OP0IS8F

// db2-add szrun record
Function OP0IS90()



      /* ****************************/
      /* * move data to pass record*/
      /* ****************************/

  TA1REC.TA1LOCAT[2] = "OP0IS90"; /* error diag group name*/


  OP8REC.OP8TASK = "A ";
  OP8REC.OP8LOCAT[1] = "OP0I060";
  OP8REC.OP8LOCAT[2] = "OP0IS90";
  OP8REC.OP8LOCAT[3] = " ";
  OP8REC.OP8LOCAT[4] = " ";
  OP8REC.OP8MAP = "OP0IM001";


      /* ***********************/
      /* * db2 write addition*/
      /* ***********************/

  call "DB1000" (OP8REC, OP3REC, OPBREC) {isNoRefresh = yes, isExternal = yes}; /* i/o mod - add*/


      /* ***********************/
      /* * check db2 return code*/
      /* ***********************/

  if (OPBREC.OPBSZRC == 0) /* check for good return*/
    /* next sentence*/
  else
    if (OPBREC.OPBSZRC == -911) /* deadlock*/
      sysVar.arrayIndex = OPWREC.OPWLSTLI;
      OPWREC.OPWSELCD[sysVar.arrayIndex] = "R";
                                   /* mark cell in array as rejected*/
      converseLib.validationFailed(6); /* busy record  -- try again*/
      converseLib.clearScreen();
       /* refresh map*/
      exit stack;
    else
      VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
      VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
      sysLib.rollback();
      VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
      
      OP0IS88(); /* common abend routine*/
    end
  end


      /* ***********************************/
      /* * release data base resources*/
      /* ***********************************/

  VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
  VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
  sysLib.commit();
  VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
   /* commit data base addition*/



end // end OP0IS90

// db2-szrun select
Function OP0IS91()



      /* ********************************************************/
      /* * set up key to read data base*/
      /* ********************************************************/

  TA1REC.TA1LOCAT[2] = "OP0IS91"; /* error diag - group name*/


  OP3REC.OP1PARTN = OP1REC.OP1PARTN; /* partition*/
  OP3REC.OP1CUOID = OP1REC.OP1CUOID; /* customer order*/

      /* set-up of op1norid & op2lninb*/
      /* done before come here*/


      /* **************************************/
      /* * set up parm record for formatter*/
      /* **************************************/

  OP8REC.OP8TASK = "S "; /* single select*/

  OP8REC.OP8LOCAT[1] = "OP0I030"; /* process name*/
  OP8REC.OP8LOCAT[2] = "OP0IS91"; /* group name*/
  OP8REC.OP8LOCAT[3] = " "; /* filler*/
  OP8REC.OP8MAP = "OP0IM001"; /* map name*/



      /* ***************/
      /* * read db2*/
      /* ***************/

  call "DB1000" (OP8REC, OP3REC, OPBREC) {isNoRefresh = yes, isExternal = yes}; /* i/o mod - single selct*/


      /* check db2 return code*/

  if (OPBREC.OPBSZRC == 0 /* check for good return*/
   || OPBREC.OPBSZRC == 1) /* or not found*/
    /* next sentence*/
  else
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.rollback();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
    
    OP0IS88(); /* common error routine*/
  end

   /* Initialize non-existant sizes on the bulk to prevent S0C7's*/
   /* in CSP 4.1 - 10/07/93 - schase*/

  OPAREC.OPASUB2 = 1;
  while (OPAREC.OPASUB2 < 41)
    if (OP3REC.OP3SZAFL[OPASUB2] != "Y")
      OP3REC.SY5PRCUN[OPASUB2] = 0;
      OP3REC.OP3ORGQT[OPASUB2] = 0;
      OP3REC.OP3ONOQT[OPASUB2] = 0;
      OP3REC.OP3ALQT[OPASUB2] = 0;
      OP3REC.OP3OHRQT[OPASUB2] = 0;
      OP3REC.OP3WPRQT[OPASUB2] = 0;
      OP3REC.OP3SHPQT[OPASUB2] = 0;
      OP3REC.OP3CNLQT[OPASUB2] = 0;
    end
    OPAREC.OPASUB2 = OPAREC.OPASUB2 + 1;
  end

  if (OPBREC.OPBSZRC == 0) /* good return*/
    /* next sentence*/
  else
    OPAREC.OPAERR = "Y"; /* reject product*/
    OP0IW01.OP0IWREJ = "Y";
    converseLib.validationFailed(173); /* prod not on data base, hit enter*/
    exit stack;
  end



end // end OP0IS91

// db2-update szrun record
Function OP0IS92()



      /* ********************************/
      /* * update product, in review mode*/
      /* ********************************/

  TA1REC.TA1LOCAT[2] = "OP0IS92"; /* error diag group name*/


      /* ****************************/
      /* * move data to pass record*/
      /* ****************************/

  OP8REC.OP8TASK = "U ";
  OP8REC.OP8LOCAT[1] = "OP0I060";
  OP8REC.OP8LOCAT[2] = "OP0IS92";
  OP8REC.OP8LOCAT[3] = " ";
  OP8REC.OP8LOCAT[4] = " ";
  OP8REC.OP8MAP = "OP0IM001";


      /* ***********************/
      /* db2 write update*/
      /* ***********************/

  call "DB1000" (OP8REC, OP3REC, OPBREC) {isNoRefresh = yes, isExternal = yes}; /* i/o mod - update*/


      /* ***********************/
      /* check db2 return code*/
      /* ***********************/

  if (OPBREC.OPBSZRC >= 0 /* check for good return*/
   && OPBREC.OPBSZRC < 10) /* or not found*/
    /* next sentence*/
  else
    OP0IS88(); /* commmon abend routine*/
  end


  if (OPBREC.OPBSZRC == 0) /* good return*/
    /* next sentence*/
  else
    OPAREC.OPAERR = "Y"; /* reject product*/
    OP0IW01.OP0IWREJ = "Y";
    if (OPBREC.OPBSZRC == 2
     || OPBREC.OPBSZRC == 3)
      converseLib.validationFailed(177); /* change cnt error, try again*/
      exit stack;
    else
      converseLib.validationFailed(175); /* rec not found, try again*/
      exit stack;
    end
  end


      /* *********************************/
      /* * release data base resources*/
      /* *********************************/

  VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
  VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
  sysLib.commit();
  VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
   /* keep updated record*/



end // end OP0IS92

// db2-delete szrun record
Function OP0IS93()


      /* *****************************************/
      /* * move data to pass record for formatter*/
      /* *****************************************/

  OP8REC.OP8LOCAT[1] = "OP0I060";
  OP8REC.OP8LOCAT[2] = "OP0IS93";
  OP8REC.OP8LOCAT[3] = " ";
  OP8REC.OP8LOCAT[4] = " ";
  OP8REC.OP8MAP = "OP0IM001";



   /* if item was allocated, and we are in review mode,*/
   /* de-allocate line item.*/

   /* need to be sure we are deleting product, not just changing*/
   /* sub-orders - that should be handled in op0isci*/

   /* note: user could have triggered an alloc out of an open item*/
        /* then when tried to write item encountered deadlock. if*/
        /* they then tried to reject the product, we don't want*/
        /* deallocate the item because the allocation was rolled*/
        /* back. only call sdi if sub-order didn't change.*/


  if (OP3REC.OP2LNIST == "AL")
    if (OPWREC.OPWREVM == 7 /* and review mode*/
     || OPWREC.OP2LNINB > 0)
      if (converseVar.eventKey is pf23
       || OP0IW01.OP0IWP24 == "Y")
        if (OP0IW01.OP0IWNSO == OP0IW01.OP0IWSBS) /* if sub didn't change*/
          if (OP0IW01.OP0IWBDF == "DS")
            OP0ISSD();
          else
            OP0ISDI(); /* de-allocate item*/
          end
          OPWREC.OPWNMALP[OP0IWSBS] = OPWREC.OPWNMALP[OP0IWSBS] - 1;
        end
      end
    end
  end



  if (OP0IW01.OP0IWBDF == "DC"
   || OP0IW01.OP0IWBDF == "DN"
   || OP0IW01.OP0IWBDF == "DR"
   || OP0IW01.OP0IWBDF == "DS"
   || OP0IW01.OP0IWBDF == "DX")
    OPAREC.OPAORDN = OP1REC.OP1BLKID;
    OP0IW02.OP1PARTN = OPAREC.OP1PARTN;
    OP0IW02.OP1CUOID = OP1REC.OP1BLKID;
    OP0IW02.OP2LNINB = OPWREC.OPWBKLIN[1];
    OP0IW02.OP1NORID = OPWREC.OP1NORID[1];
    OP0IS29(); /* re-read bulk order*/
  end


   /* if this is a draw order, roll quantities back into bulk.*/
    /* TOTAL QTY TO ROLL BACK INTO BULK FOR REVIEW MODE IS*/
     /* op3rec - op0iwcqt. may have changed before delete!!!*/

  OP0IW01.OP0IWDQT = 0;
  if (OP0IW01.OP0IWBDF == "DC"
   || OP0IW01.OP0IWBDF == "DN"
   || OP0IW01.OP0IWBDF == "DR"
   || OP0IW01.OP0IWBDF == "DS"
   || OP0IW01.OP0IWBDF == "DX")
    if (OPWREC.OPWREVM == 7 /* if in review mode*/
     || OPWREC.OP2LNINB > 0)
      OPAREC.OPASUB = 1;
      while (OPAREC.OPASUB <= 40)
        if (OP3REC.OP3SZAFL[OPASUB] == "Y")
          OP0IW01.OP0IWDQT = OP0IW01.OP0IWDQT + OP3REC.OP3ONOQT[OPASUB];
          OP0IW01.OP0IWDQT = OP0IW01.OP0IWDQT - OP0IW01.OP0IWCQT[OPASUB];
          OP0IW01.OP0IWQTY = OP3REC.OP3ORGQT[OPASUB];
          OP0IW03.OP3ORGQT[OPASUB] = OP0IW03.OP3ORGQT[OPASUB] + OP0IWQTY;
          OP0IW01.OP0IWQTY = OP3REC.OP3ONOQT[OPASUB];
          OP0IW01.OP0IWQTY = OP0IW01.OP0IWQTY - OP0IW01.OP0IWCQT[OPASUB];
          OP0IW03.OP3ONOQT[OPASUB] = OP0IW03.OP3ONOQT[OPASUB] + OP0IWQTY;
          if (OP3REC.OP3OHRQT[OPASUB] > 0)
            OP0IW01.OP0IWQTY = OP3REC.OP3OHRQT[OPASUB];
            OP0IW03.OP3OHRQT[OPASUB] = OP0IW03.OP3OHRQT[OPASUB] + OP0IWQTY;
          end
           /* if draw was allocated add back to reserved qty since*/
           /* it had to be reserved before it could be allocated*/
          if (OP3REC.OP3ALQT[OPASUB] > 0)
            OP0IW01.OP0IWQTY = OP3REC.OP3ALQT[OPASUB];
            OP0IW03.OP3OHRQT[OPASUB] = OP0IW03.OP3OHRQT[OPASUB] + OP0IWQTY;
          end
        end
        OPAREC.OPASUB = OPAREC.OPASUB + 1;
      end
    else
      OPAREC.OPASUB = 1;
      while (OPAREC.OPASUB <= 40)
        if (OP3REC.OP3SZAFL[OPASUB] == "Y")
          OP0IW01.OP0IWDQT = OP0IW01.OP0IWDQT + OP3REC.OP3ONOQT[OPASUB];
          OP0IW01.OP0IWQTY = OP3REC.OP3ORGQT[OPASUB];
          OP0IW03.OP3ORGQT[OPASUB] = OP0IW03.OP3ORGQT[OPASUB] + OP0IWQTY;
          OP0IW01.OP0IWQTY = OP3REC.OP3ONOQT[OPASUB];
          OP0IW03.OP3ONOQT[OPASUB] = OP0IW03.OP3ONOQT[OPASUB] + OP0IWQTY;
          OP0IW01.OP0IWQTY = OP3REC.OP3OHRQT[OPASUB];
          OP0IW03.OP3OHRQT[OPASUB] = OP0IW03.OP3OHRQT[OPASUB] + OP0IWQTY;
           /* if draw was allocated add back to reserved qty since*/
           /* it had to be reserved before it could be allocated*/
          OP0IW01.OP0IWQTY = OP3REC.OP3ALQT[OPASUB];
          OP0IW03.OP3OHRQT[OPASUB] = OP0IW03.OP3OHRQT[OPASUB] + OP0IWQTY;
        end
        OPAREC.OPASUB = OPAREC.OPASUB + 1;
      end
    end
    OP0IW03.OP2TDRWQ = OP0IW03.OP2TDRWQ - OP0IW01.OP0IWDQT;
    OP8REC.OP8TASK = "U ";
    call "DB1000" (OP8REC, OP0IW03, OPBREC) {isNoRefresh = yes, isExternal = yes};
    if (OPBREC.OPBSZRC != 0)
      OP0IS88(); /* abend*/
    end
  end





  OP8REC.OP8TASK = "D "; /* delete record*/


      /* ***************/
      /* db2 delete*/
      /* ***************/

  call "DB1000" (OP8REC, OP3REC, OPBREC) {isNoRefresh = yes, isExternal = yes}; /* delete record*/


      /* ***********************/
      /* check db2 return code*/
      /* ***********************/

  if (OPBREC.OPBSZRC == 0 /* check for good return*/
   || OPBREC.OPBSZRC == 1) /* or not-found error*/
    /* next sentence*/
  else
    OP0IS88(); /* common abend routine*/
  end


      /* ******************************************************/
      /* * note - call commit to release data base resources*/
      /* * done in calling stmts.*/
      /* * (allows update to actually be a delete & add*/
      /* *  with only 1 commit (in the add))*/
      /* ******************************************************/



end // end OP0IS93

// db2-prod style,color,size recs
Function OP0IS94()



      /* ********************************************************/
      /* * read db2 for the product's style,color & size recs  **/
      /* * this is a combined view of 3 records.               **/
      /* ********************************************************/

  TA1REC.TA1LOCAT[2] = "OP0IS94"; /* error diag group name*/

      /* set up read key*/

  SYCREC.XGPCD = OP3REC.XGPCD; /* general product class*/
  SYCREC.SY1STNBR = OP3REC.SY1STNBR; /* style*/
  SYCREC.SY2CLRID = OP3REC.SY2CLRID; /* color*/
  SYCREC.XDMCD = OP3REC.XDMCD; /* dimension*/


      /* read db2*/

  call "IO0560" ("S ", SQLCA, SYCREC) {isNoRefresh = yes, isExternal = yes}; /* i/o mod for single select*/


      /* check db2 return code*/

  if (SQLCA.VAGen_SQLCODE == 0 /* check for good return*/
   || SQLCA.VAGen_SQLCODE == 100) /* or rec not found*/
    /* next sentence*/
  else
    TA1REC.TA1DBASE = "DPROD"; /* data base name*/
    TA1REC.TA1TBLVU = "VCOLOR04"; /* table view*/
    TA1REC.TA1TBLKE = SYCREC.SYCKEY; /* key value*/
    TA1REC.TA1LOCAT[3] = "IO0560"; /* i/o mod*/
    XSOPS02(); /* common abend routine*/
  end


      /* if product record(s) not found*/

  if (SQLCA.VAGen_SQLCODE == 100) /* reject product*/
    set SYCREC empty;
    converseLib.validationFailed(131); /* not valid style, color*/
    OPAREC.OPAERR = "Y";
    OP0IW01.OP0IWREJ = "Y"; /* set reject product flag*/
    exit stack;
  end


    /* Added for Canada --  June 7, 1995--*/

  if (SQLCA.VAGen_SQLCODE == 0 /**/
   && OP1REC.XDZ-DATA-DIST-CD == "CA")
    set WSY2000 empty;
    WSY2000.XDR-PROD-REG-CD = "05";
    OP0IS-SEL-SY2000();
    if (OP0IW01.OP0IW-WSY2000-FND-FLAG == "Y")
      /* next sentence*/
    else
      if (WSY2000.WSY2000-RETURN-CODE == "98")
        converseLib.validationFailed(010); /* data base busy*/
        OPAREC.OPAERR = "Y";
        OP0IW01.OP0IWREJ = "Y"; /* set reject product flag*/
        exit stack;

      else
        if (OP0IW01.OP0IW-WSY2000-FND-FLAG == "N")
          set SYCREC empty;
          converseLib.validationFailed(911); /* not valid style, color for region*/
          OPAREC.OPAERR = "Y";
          OP0IW01.OP0IWREJ = "Y"; /* set reject product flag*/
          exit stack;
        else
          set SYCREC empty;
          converseLib.validationFailed(909); /* fatal error*/
          OPAREC.OPAERR = "Y";
          OP0IW01.OP0IWREJ = "Y"; /* set reject product flag*/
          exit stack;
        end
      end
    end

    /* Added for US apparel--June 13, 1996*/

  else
    if (SQLCA.VAGen_SQLCODE == 0 /**/
     && OP1REC.XGPCD == "03")   
      if (COMMAREA.XDVCD == "02" /* userid assigned to europe*/
       || COMMAREA.XDVCD == "03") /* userid assigned to asia*/
         /* continue processing*/
      else

        set WSY2000 empty;
        WSY2000.XDR-PROD-REG-CD = "01";
        OP0IS-SEL-SY2000();
        if (OP0IW01.OP0IW-WSY2000-FND-FLAG == "Y")
         /* next sentence*/
        else
          if (WSY2000.WSY2000-RETURN-CODE == "98")
            converseLib.validationFailed(010); /* data base busy*/
            OPAREC.OPAERR = "Y";
            OP0IW01.OP0IWREJ = "Y"; /* set reject product flag*/
            exit stack;

          else
            if (OP0IW01.OP0IW-WSY2000-FND-FLAG == "N")
              set SYCREC empty;
              converseLib.validationFailed(911); /* not valid style, color for region*/
              OPAREC.OPAERR = "Y";
              OP0IW01.OP0IWREJ = "Y"; /* set reject product flag*/
              exit stack;
            else
              set SYCREC empty;
              converseLib.validationFailed(909); /* fatal error*/
              OPAREC.OPAERR = "Y";
              OP0IW01.OP0IWREJ = "Y"; /* set reject product flag*/
              exit stack;
            end
          end
        end
      end
    end
  end


end // end OP0IS94

// db2 selct/edit substit.product
Function OP0IS95()



      /* *****************************************/
      /* * read db2 for the substitute product's*/
      /* * style,color & size recs*/
      /* * this is a combined view of 3 records.*/
      /* *****************************************/

  TA1REC.TA1LOCAT[2] = "OP0IS95"; /* error diag group name*/


  if (OP0IM001.OP2SSTYN == " ") /* change to blank is o.k.*/
    OP3REC.OP2SSTYN = OP0IM001.OP2SSTYN; /* hold good subs.prod*/
    OP3REC.OP2SCLCD = " ";
    if (OP0IM001.OP2SDMCD == "  ")
      OP0IM001.OP2SDMCD = "00";
    end
    OP3REC.OP2SDMCD = OP0IM001.OP2SDMCD;
    set OP0IM001.OP2SSTYN initialAttributes;
    set OP0IM001.OP2SCLCD initialAttributes;
    set OP0IM001.OP2SDMCD initialAttributes;
    return;
  end

      /* set up read key using substitute prod #*/

  SYCREC.XGPCD = OP3REC.XGPCD; /* general product class*/
  SYCREC.SY1STNBR = OP0IM001.OP2SSTYN; /* style*/
  SYCREC.SY2CLRID = OP0IM001.OP2SCLCD; /* color*/
  if (OP0IM001.OP2SDMCD == " ") /* phase 1 has blank input*/
    SYCREC.XDMCD = "00"; /* with zero on data base*/
  else
    SYCREC.XDMCD = OP0IM001.OP2SDMCD; /* dimension*/
  end


      /* read db2*/

  call "IO0560" ("S ", SQLCA, SYCREC) {isNoRefresh = yes, isExternal = yes}; /* i/o mod for single select*/


      /* check db2 return code*/

  if (SQLCA.VAGen_SQLCODE == 0 /* check for good return*/
   || SQLCA.VAGen_SQLCODE == 100) /* or rec not found*/
    /* next sentence*/
  else
    TA1REC.TA1DBASE = "DPROD"; /* data base name*/
    TA1REC.TA1TBLVU = "VCOLOR02"; /* table view*/
    TA1REC.TA1TBLKE = SYCREC.SYCKEY; /* key value*/
    TA1REC.TA1LOCAT[3] = "IO0560"; /* i/o mod*/
    XSOPS02(); /* common abend routine*/
  end


  if (SQLCA.VAGen_SQLCODE == 100) /* record not found*/
    OPAREC.OPAERR = "Y";
    converseLib.validationFailed(162); /* substitution style not found*/
    set OP0IM001.OP2SSTYN cursor, modified, bold;
    set OP0IM001.OP2SCLCD modified, bold;
    set OP0IM001.OP2SDMCD modified, bold; /* active in ph 2*/
    return;
  else
    OP3REC.OP2SSTYN = OP0IM001.OP2SSTYN; /* hold good subs.prod*/
    OP3REC.OP2SCLCD = OP0IM001.OP2SCLCD;
    OP3REC.OP2SDMCD = OP0IM001.OP2SDMCD;
    set OP0IM001.OP2SSTYN initialAttributes;
    set OP0IM001.OP2SCLCD initialAttributes;
    set OP0IM001.OP2SDMCD initialAttributes; /* active in ph 2*/
    if (OP1REC.XDZ-DATA-DIST-CD == "CA") /* Canadian customer-added 6/95*/
      set WSY2000 empty;
      WSY2000.XDR-PROD-REG-CD = "05";
      OP0IS-SEL-SY2000();
      if (OP0IW01.OP0IW-WSY2000-FND-FLAG == "N")
        OPAREC.OPAERR = "Y";
        converseLib.validationFailed(911); /* substitution style not found*/
        set OP0IM001.OP2SSTYN cursor, modified, bold;
        set OP0IM001.OP2SCLCD modified, bold;
        set OP0IM001.OP2SDMCD modified, bold; /* active in ph 2*/
        return;
      else
        if (OP0IW01.OP0IW-WSY2000-FND-FLAG == "Y")
          /* next sentence*/
        else
          if (WSY2000.WSY2000-RETURN-CODE == "98")
            OPAREC.OPAERR = "Y";
            converseLib.validationFailed(010);
            return;
          else
            OPAREC.OPAERR = "Y";
            converseLib.validationFailed(909);
            return;
          end
        end
      end
    else
      if (OP1REC.XGPCD == "03")
        if (COMMAREA.XDVCD == "02" /* userid assigned to europe*/
         || COMMAREA.XDVCD == "03") /* userid assigned to asia*/
          /* continue processing*/
        else
          set WSY2000 empty;
          WSY2000.XDR-PROD-REG-CD = "01";
          OP0IS-SEL-SY2000();
          if (OP0IW01.OP0IW-WSY2000-FND-FLAG == "N")
            OPAREC.OPAERR = "Y";
            converseLib.validationFailed(911); /* substitution style not found*/
            set OP0IM001.OP2SSTYN cursor, modified, bold;
            set OP0IM001.OP2SCLCD modified, bold;
            set OP0IM001.OP2SDMCD modified, bold; /* active in ph 2*/
            return;
          else
            if (OP0IW01.OP0IW-WSY2000-FND-FLAG == "Y")
              /* next sentence*/
            else
              if (WSY2000.WSY2000-RETURN-CODE == "98")
                OPAREC.OPAERR = "Y";
                converseLib.validationFailed(010);
                return;
              else
                OPAREC.OPAERR = "Y";
                converseLib.validationFailed(909);
                return;
              end
            end
          end
        end
      end
    end
  end


  OP3REC.OP2PRDSF = "N"; /* init to no subs.*/
  if (OP3REC.OP2SSTYN != " ")
    OP3REC.OP2PRDSF = "Y"; /* mark product is substitute*/
  end



end // end OP0IS95

// db2-get size scale descrips
Function OP0IS96()



      /* ********************************************************/
      /* * read db2 for the product's size scale code          **/
      /* * this give us a record with 40 size descriptions     **/
      /* ********************************************************/

  TA1REC.TA1LOCAT[2] = "OP0IS96"; /* error diag group name*/

      /* set up read key*/

  SY4REC.SY4SZSCL = SYCREC.SY4SZSCL; /* scale code*/


      /* read db2*/

  call "IO0040" ("S ", SQLCA, SY4REC) {isNoRefresh = yes, isExternal = yes}; /* i/o mod for single select*/


      /* check db2 return code*/

  if (SQLCA.VAGen_SQLCODE == 0 /* check for good return*/
   || SQLCA.VAGen_SQLCODE == 100) /* or not found*/
    /* next sentence*/
  else
    TA1REC.TA1DBASE = "DPROD"; /* data base name*/
    TA1REC.TA1TBLVU = "VSCALE01"; /* table view*/
    TA1REC.TA1TBLKE = SY4REC.SY4SZSCL; /* key value*/
    TA1REC.TA1LOCAT[3] = "IO0040"; /* i/o mod*/
    XSOPS02(); /* common abend routine*/
  end

  if (SQLCA.VAGen_SQLCODE == 100) /* if scale code not found*/
    sysVar.arrayIndex = 1;
    while (sysVar.arrayIndex < 41) /* move constant to all size descrips*/
      SY4REC.SY4IDDSC[sysVar.arrayIndex] = "UNKWN";
      sysVar.arrayIndex = sysVar.arrayIndex + 1;
    end
  end




end // end OP0IS96

// db2-product prices
Function OP0IS97()



      /* common read of product price data base*/


  TA1REC.TA1LOCAT[2] = "OP0IS97"; /* error diag group name*/

      /* *******************************************************/
      /* * set up data base key, color&size from calling place*/
      /* *******************************************************/

  SY5REC.XGPCD = OP3REC.XGPCD; /* general prod.class*/
  SY5REC.SY1STNBR = OP3REC.SY1STNBR; /* style*/
  if (OP1REC.XDVCD == "02") /* if nil order*/
    if (OP0IW01.XAUCD == "33") /* if nil independent distributor*/
      SY5REC.XPYCD = VNLXPY01.XPYCD; /* use nimrec's prc typ cd*/
    else /* otherwise (acct class 31, 32)*/
      SY5REC.XPYCD = IVEREC.IVEPCTYP; /* use invspec's price type cd*/
    end
  else /* domestic orders*/
    SY5REC.XPYCD = XOTTBL.XPYCD[OP0IWSBO]; /* price type cd from xot*/
  end

  if (OP1REC.XDVCD == "02" /* if nil*/
   && OP3REC.XQACD == "02") /* if b-grade product*/
    SY5REC.XQACD = "01"; /* quality code*/
  else
    SY5REC.XQACD = OP3REC.XQACD; /* quality code*/
  end


    /* --added for canada-- june 5, 1995--*/

  if (OP1REC.XDZ-DATA-DIST-CD == "CA") /* country code*/
    SY5REC.XCT-CTRY-CD = "CANA";
    SY5REC.ZFC-CRCY-CD = "CAD"; /* currency code*/
  else
    SY5REC.XCT-CTRY-CD = "USA";
    SY5REC.ZFC-CRCY-CD = "USD"; /* currency code*/
  end


      /* db2 read*/

  call "IO0380" ("S ", SQLCA, SY5REC) {isNoRefresh = yes, isExternal = yes}; /* i/o mod for single select*/


      /* check db2 return code*/

  if (SQLCA.VAGen_SQLCODE == 0 /* check for good return*/
   || SQLCA.VAGen_SQLCODE == 100) /* or not found*/
    return;
  else
    TA1REC.TA1DBASE = "DPROD"; /* data base name*/
    TA1REC.TA1TBLVU = "VPRICE01"; /* table view*/
    TA1REC.TA1TBLKE = SY5REC.SY5KEY; /* key value*/
    TA1REC.TA1LOCAT[4] = "IO0380"; /* i/o mod*/
    XSOPS02(); /* common abend routine*/
  end



end // end OP0IS97

// db2-sales pgm order type read
Function OP0IS98()



      /* *****************************************/
      /* * get sales program order type record*/
      /* *****************************************/

  TA1REC.TA1LOCAT[2] = "OP0IS98"; /* error diag group name*/


      /* note - key set up from order header op1rec*/
      /* in op0is10, general initialization*/


  call "IO0080" ("S ", SQLCA, SP2REC) {isNoRefresh = yes, isExternal = yes}; /* i/o mod for inquiry*/


      /* check db2 return code*/

  if (SQLCA.VAGen_SQLCODE == 0 /* check for good rc*/
   || SQLCA.VAGen_SQLCODE == 100) /* check for notfnd rc*/
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DSPGM   "; /* data base name*/
    TA1REC.TA1TBLVU = "VORTYP01"; /* table view*/
    TA1REC.TA1TBLKE = SP2REC.SP2KEY; /* key value*/
    TA1REC.TA1LOCAT[3] = "IO0080  "; /* i/o mod name*/
    XSOPS02(); /* common abend*/
  end


      /* if not found, then error*/

  if (SQLCA.VAGen_SQLCODE == 100) /* check for notfnd rc*/
    converseLib.validationFailed(025); /* sls pgm id is not valid for ord type*/
    OPAREC.OPAERR = "Y";
    OP0IW01.OP0IWREJ = "Y"; /* reject product*/
    exit stack;
  end



end // end OP0IS98

// db2-sales pgm product prices
Function OP0IS99()



      /* ************************************************/
      /* * get sales program product pricing record*/
      /* ************************************************/

  TA1REC.TA1LOCAT[2] = "OP0IS99"; /* error diag group name*/


  SP5REC.SP1ID = SP2REC.SP1ID; /* set-up key for prod price*/
  SP5REC.XGPCD = OP1REC.XGPCD;
  SP5REC.SY1STNBR = OPWREC.SY1STNBR[OP0IWSBP];
  SP5REC.SY2CLRID = OPWREC.SY2CLRID[OP0IWSBP];
  SP5REC.XDMCD = OPWREC.XDMCD[OP0IWSBP];


  call "IO0110" ("S ", SQLCA, SP5REC) {isNoRefresh = yes, isExternal = yes}; /* i/o mod for inquiry*/


      /* check db2 return code*/

  if (SQLCA.VAGen_SQLCODE == 0) /* check for good rc*/
     /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == 100) /* check for notfnd rc*/
       /* try reading generic color record*/
      SP5REC.SY2CLRID = "***";
      SP5REC.XDMCD = "**";
      call "IO0110" ("S ", SQLCA, SP5REC) {isNoRefresh = yes, isExternal = yes}; /* 2nd read try*/
      if (SQLCA.VAGen_SQLCODE == 0
       || SQLCA.VAGen_SQLCODE == 100)
        SP5REC.SY2CLRID = OPWREC.SY2CLRID[OP0IWSBP];
        SP5REC.XDMCD = OPWREC.XDMCD[OP0IWSBP];
         /* next sentence*/
      else
        TA1REC.TA1DBASE = "DSPGM   "; /* data base name*/
        TA1REC.TA1TBLVU = "VPROD001"; /* table view*/
        TA1REC.TA1TBLKE = SP5REC.SP5KEY; /* key value*/
        TA1REC.TA1LOCAT[3] = "IO0110  "; /* i/o mod name*/
        XSOPS02(); /* common abend*/
      end
    else
      TA1REC.TA1DBASE = "DSPGM   "; /* data base name*/
      TA1REC.TA1TBLVU = "VPROD001"; /* table view*/
      TA1REC.TA1TBLKE = SP5REC.SP5KEY; /* key value*/
      TA1REC.TA1LOCAT[3] = "IO0110  "; /* i/o mod name*/
      XSOPS02(); /* common abend*/
    end
  end


      /* if not found, leave flag = n (from init w-s)*/

  if (SQLCA.VAGen_SQLCODE == 0) /* found prod prices*/
    OP0IW01.OP0IWSPP = "Y";
  end



end // end OP0IS99

// db2-check if duplicate szrun
Function OP0IS9A()


      /* **********************************************/
      /* * check if duplicate record already on db2*/
      /* **********************************************/

  TA1REC.TA1LOCAT[2] = "OP0IS9A"; /* error diag - group name*/


      /* ****************************************************/
      /* * move data to opckey to read view vitem003.*/
      /* * this view contains only op-ord-part-char,*/
      /* * op-cust-ord-id, op-nike-ord-id, xgp-gpc-cd,*/
      /* * sy-sty-nbr, sy-colr-cd-id, xcm-dim-cd, op-coor-grp-cd,*/
      /* * xum code and xow code.*/
      /* ****************************************************/

  OPCREC.OP1PARTN = OP3REC.OP1PARTN;
  OPCREC.OP1CUOID = OP3REC.OP1CUOID;
  OPCREC.OP1NORID = OP3REC.OP1NORID;
  OPCREC.XGPCD = OP3REC.XGPCD;
  OPCREC.SY1STNBR = OP3REC.SY1STNBR;
  OPCREC.SY2CLRID = OP3REC.SY2CLRID;
  OPCREC.XDMCD = OP3REC.XDMCD;
  if (OP1REC.XDVCD == "03" /* duplicate product id allowed for*/
   && OP1REC.XBDCD == "0") /* division 03 regular orders only*/
    OPCREC.XUMCD = OP3REC.XUMCD;
    OPCREC.XOWCD = OP3REC.XOWCD;
  else
    OPCREC.XUMCD = "**";
    OPCREC.XOWCD = "**";
  end
  OPCREC.OP2CGPCD = OP3REC.OP2CGPCD;


      /* ***************/
      /* * read db2*/
      /* ***************/

  call "IO0570" ("S ", SQLCA, OPCREC) {isNoRefresh = yes, isExternal = yes};


      /* **************************/
      /* * check db2 return code*/
      /* **************************/

  if (SQLCA.VAGen_SQLCODE == 0   /* check for good return=duplicate*/
   || SQLCA.VAGen_SQLCODE == 100 /* or not found=not duplicate*/
   || SQLCA.VAGen_SQLCODE == -911) /* or deadlock*/
    /* next sentence*/
  else
    TA1REC.TA1DBASE = "DORDER"; /* data base name*/
    TA1REC.TA1TBLVU = "VITEM003"; /* table view*/
    TA1REC.TA1TBLKE = OP2REC.OP2KEY; /* key value*/
    TA1REC.TA1LOCAT[3] = "IO0570"; /* i/o mod*/
    XSOPS02(); /* common abend routine*/
  end


  if (SQLCA.VAGen_SQLCODE == 0) /* found key, may be duplicate*/
    if (OP0IW01.OP0IWDUP == "Y") /* if second dup error on this*/
      OPAREC.OPAERR = "Y"; /* product, reject product*/
      OP0IW01.OP0IWREJ = "Y";
      OP0IS89(); /* flow to next prod/application*/
    end
    OPAREC.OPAERR = "Y"; /* reject product*/
    OP0IW01.OP0IWDUP = "Y"; /* flag as duplicate error, first time*/
    converseLib.validationFailed(187); /* duplicate, can not add*/
    if (OP0IW01.OP0IWBDF == "BS" /* if smart or flex skip field*/
     || OP0IW01.OP0IWBDF == "BX" /* highlights*/
     || OP0IW01.OP0IWBDF == "DR") /* or if rebook draw*/
      exit stack;
    end
    set OP0IM001.OP2CGPCD cursor, modified, bold; /* coord group*/
    if (OP0IW01.OP0IWBDF == "DS"
     || OP0IW01.OP0IWBDF == "DX")
       /* next sentence*/
    else
      set OP0IM001.XWHCD cursor, modified, bold; /* warehouse*/
    end
    set OP0IM001.OP0IMNDT cursor, modified, bold; /* need date*/
    exit stack;
  end



    /* trap -911.*/


  if (SQLCA.VAGen_SQLCODE == -911) /* deadlock*/
    converseLib.validationFailed(6);
    exit stack;
  end






end // end OP0IS9A

// read company record for xaucd
Function OP0IS9C()


      /* this routine reads the company record to obtain the*/
      /* account class (xaucd).  account class is used to*/
      /* to determine whether a price override is valid*/


  call "IO0240" ("S ", SQLCA, KUCREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
     /* next sentence*/
  else
    TA1REC.TA1LOCAT[1] = "S       ";
    TA1REC.TA1LOCAT[3] = "IO0240  ";
    TA1REC.TA1DBASE = "KUCREC  ";
    TA1REC.TA1TBLVU = "VCMPNY01";
    OP0IW01.OP0IWTK1 = KUCREC.KUCCOID;
    OP0IW01.OP0IWTK1 = KUCREC.KUCCOID;
    TA1REC.TA1TBLKE = OP0IW01.OP0IWTK1;
    call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes};
    XSOPS02(); /* abend*/
  end





end // end OP0IS9C

// read nimrec for price code
Function OP0IS9D()



      /* ***************************************************/
      /* * get the price code from nimrec*/
      /* ***************************************************/



  OP0IS9E(); /* get the summary base order type*/

  if (OP0IW01.OP0IWZPR == "Y") /* if an error next sentence*/
    /* next sentence*/
  else /* else get nimrec*/
    OP0IS9L(); /* retrieve act reg code from vdstrb01*/
    VNLXPY01.ZARCD = VDSTRB01.ZARCD; /* act region code*/
    VNLXPY01.KUCCOID = OP1REC.KUCCOID; /* customer*/
    VNLXPY01.ZFCCD = " "; /* currency code*/
    VNLXPY01.YSMXOB = YSMREC.YSMSUMCD; /* sum base order type code*/
    VNLXPY01.XGPCD = OP1REC.XGPCD; /* gen prod class code*/

    call "IO4500" ("SF", SQLCA, VNLXPY01) {isNoRefresh = yes, isExternal = yes};

    if (SQLCA.VAGen_SQLCODE == 0) /* all ok if found*/
       /* next sentence*/
    else /* else*/
      if (SQLCA.VAGen_SQLCODE == 100) /* if price type code not found*/
        OP0IW01.OP0IWZPR = "Y"; /* force zero prices*/
      else /* else abend*/
        TA1REC.TA1LOCAT[2] = "OP0IS9D";
        TA1REC.TA1DBASE = "DNILO   "; /* data base name*/
        TA1REC.TA1TBLVU = "VNLXPY01"; /* table view*/
        OP0IW01.OP0IWNI1 = VNLXPY01.XGPCD; /* format key cuz*/
        OP0IW01.OP0IWNI2 = VNLXPY01.YSMXOB; /* kuccoid*/
        OP0IW01.OP0IWNI3 = VNLXPY01.ZARCD; /* is binary*/
        OP0IW01.OP0IWNI4 = VNLXPY01.KUCCOID;
        OP0IW01.OP0IWNI5 = VNLXPY01.ZFCCD;
        TA1REC.TA1TBLKE = OP0IW01.OP0IWNIM; /* move key to ta1rec*/
        TA1REC.TA1LOCAT[3] = "IO4500  "; /* i/o mod name*/
        XSOPS02(); /* common db abend*/
      end
    end

  end


end // end OP0IS9D

// read summary base order type
Function OP0IS9E()


      /* this routine reads the summary base order type table*/
      /* to convert the base order type to summary base order*/
      /* type.  this is part of the key to the international*/
      /* price type code table (nimrec).*/


  YSMREC.YSMTBLPF = "XOB"; /* table name of xob*/
  YSMREC.YSMSYSPF = "NL"; /* international system*/
  YSMREC.YSMSUMID = 2;
  YSMREC.YSMSUMCD = "**"; /* wild card for sum xob*/
  YSMREC.YSMSRCVL = OP1REC.XOBCD; /* order's base order type*/

  call "IO2640" ("S1", SQLCA, YSMREC) {isNoRefresh = yes, isExternal = yes}; /* declare & open cursor*/

  if (SQLCA.VAGen_SQLCODE == 0) /* all ok*/
     /* next sentence*/
  else
    TA1REC.TA1LOCAT[1] = "S1      ";
    TA1REC.TA1LOCAT[2] = "OP0IS9E ";
    TA1REC.TA1LOCAT[3] = "IO2640  ";
    TA1REC.TA1DBASE = "DCORP   ";
    TA1REC.TA1TBLVU = "VSUMCD01";
    TA1REC.TA1TBLKE = YSMREC.YSMGRP;
    XSOPS02(); /* abend*/
  end


  call "IO2640" ("N1", SQLCA, YSMREC) {isNoRefresh = yes, isExternal = yes}; /* fetch record*/

  if (SQLCA.VAGen_SQLCODE == 0) /* if found, ok*/
     /* next sentence*/
  else /* else*/
    if (SQLCA.VAGen_SQLCODE == 100) /* if none found*/
      OP0IW01.OP0IWZPR = "Y"; /* force zero price*/
    else /* else*/
      TA1REC.TA1LOCAT[1] = "N1      "; /* if other problems*/
      TA1REC.TA1LOCAT[2] = "OP0IS9E "; /* abend*/
      TA1REC.TA1LOCAT[3] = "IO2640  ";
      TA1REC.TA1DBASE = "DCORP   ";
      TA1REC.TA1TBLVU = "VSUMCD01";
      TA1REC.TA1TBLKE = YSMREC.YSMGRP;
      XSOPS02();
    end
  end


  while (SQLCA.VAGen_SQLCODE == 0 /* while record found*/
   && YSMREC.XXXSTAT != "A") /* but status not active*/
    call "IO2640" ("N1", SQLCA, YSMREC) {isNoRefresh = yes, isExternal = yes}; /* fetch next record*/

    if (SQLCA.VAGen_SQLCODE == 0 /* all ok*/
     || SQLCA.VAGen_SQLCODE == 100)
       /* next sentence*/
    else
      TA1REC.TA1LOCAT[1] = "N1      "; /* if other problems*/
      TA1REC.TA1LOCAT[2] = "OP0IS9E "; /* abend*/
      TA1REC.TA1LOCAT[3] = "IO2640  ";
      TA1REC.TA1DBASE = "DCORP   ";
      TA1REC.TA1TBLVU = "VSUMCD01";
      TA1REC.TA1TBLKE = YSMREC.YSMGRP;
      XSOPS02();
    end
  end


  if (YSMREC.XXXSTAT == "A") /* if active sum base ot found*/
      /* next sentence                ;    all ok*/
  else /* otherwise*/
    OP0IW01.OP0IWZPR = "Y"; /* force zero price*/
  end


  call "IO2640" ("C1", SQLCA, YSMREC) {isNoRefresh = yes, isExternal = yes}; /* close cursor*/

  if (SQLCA.VAGen_SQLCODE == 0)
     /* next sentence*/
  else
    TA1REC.TA1LOCAT[1] = "C1      "; /* if problems*/
    TA1REC.TA1LOCAT[2] = "OP0IS9E "; /* abend*/
    TA1REC.TA1LOCAT[3] = "IO2640  ";
    TA1REC.TA1DBASE = "DCORP   ";
    TA1REC.TA1TBLVU = "VSUMCD01";
    TA1REC.TA1TBLKE = YSMREC.YSMGRP;
    XSOPS02();
  end
end // end OP0IS9E

// db2-add nil 0 price tag rec
Function OP0IS9F()



      /* ******************************************************/
      /* * write a tag record when a nil footwear or apparel*/
      /* * futures order whose product is in development*/
      /* * so the price was forced to zero*/
      /* * these are read by batch pgm op3400 that will update*/
      /* * the price when the product becomes active*/
      /* ******************************************************/


  OEBREC.XGPCD = OP3REC.XGPCD;
  OEBREC.SY1STNBR = OP3REC.SY1STNBR;
  OEBREC.SY2CLRID = OP3REC.SY2CLRID;
  OEBREC.XDMCD = OP3REC.XDMCD;
  OEBREC.ZZZSDT = OP3REC.ZZZCHGDT;
  OEBREC.ZZZSTM = OP3REC.ZZZCHGTM;


  call "IO4590" ("A ", SQLCA, OEBREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    /* next sentence*/
  else
    TA1REC.TA1DBASE = "DORDER";
    TA1REC.TA1TBLVU = "VZPRIC01";
    TA1REC.TA1TBLKE = OEBREC.OEBGROUP;
    TA1REC.TA1LOCAT[3] = "OP0IS9F";
    TA1REC.TA1LOCAT[4] = "IO4590";
    XSOPS02(); /* abort program*/
  end



end // end OP0IS9F

// db2 - invc specialty tbl
Function OP0IS9G()



      /* *************************************************/
      /* * get the price or cost type code from invoicing*/
      /* *    specialty  table*/
      /* *************************************************/



  IVEREC.XOTCD = OP1REC.XOTCD; /* put order type in key*/


  call "IO1450" ("SF", SQLCA, IVEREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      OP0IW01.OP0IWZPR = "Y"; /* force zero prices*/
    else
      TA1REC.TA1LOCAT[1] = "S       ";
      TA1REC.TA1LOCAT[2] = "OP0IS9G ";
      TA1REC.TA1LOCAT[3] = "IO1450  ";
      TA1REC.TA1DBASE = "DINVC   ";
      TA1REC.TA1TBLVU = "VSPECL01";
      OP0IW01.OP0IWT1 = " ";
      OP0IW01.OP0IWTK3 = IVEREC.XATCD;
      OP0IW01.OP0IWTK4 = IVEREC.XAUCD;
      OP0IW01.OP0IWTK5 = IVEREC.XOTCD;
      TA1REC.TA1TBLKE = OP0IW01.OP0IWT1;
      XSOPS02();
    end
  end



end // end OP0IS9G

// get style/color & color cost
Function OP0IS9H()

      /* *******************************************************/
      /* * read db2 cost by style, color and dimension*/
      /* **/
      /* *******************************************************/


  OP0IS9I(); /* db2 read cost*/


    /* note: if the cost record is not found or the effective*/
          /* date is not found, color price automatically*/
          /* defaults to zero*/

  if (SQLCA.VAGen_SQLCODE == 0) /* if cost record found,*/
    OP0IS9J(); /* pick out cost effec date (from 6 possible)*/
    if (sysVar.arrayIndex < 7) /* if eff date found, save cost as color price*/
      OP0IW01.OP0IWCLP = SY6REC.SY6CSTUN[sysVar.arrayIndex];
    end
  end



end // end OP0IS9H

// db2 - read product cost
Function OP0IS9I()




      /* ***********************/
      /* * set up data base key*/
      /* ***********************/

  SY6REC.XGPCD = OP3REC.XGPCD; /* general prod.class*/
  SY6REC.SY1STNBR = OP3REC.SY1STNBR; /* style*/
  SY6REC.SY2CLRID = OP3REC.SY2CLRID; /* color*/
  SY6REC.XDMCD = OP3REC.XDMCD; /* dimension*/
  SY6REC.XCOCD = IVEREC.IVEPCTYP; /* cost type code*/

    /* --added for Canada--June 6, 1995---*/

  if (OP1REC.XDZ-DATA-DIST-CD == "CA") /* country code*/
    SY6REC.XCT-CTRY-CD = "CANA";
  else
    SY6REC.XCT-CTRY-CD = "USA"; /**/
  end

  if (OP1REC.ZFC-CRCY-CD != " ") /* currency code*/
    SY6REC.ZFC-CRCY-CD = OP1REC.ZFC-CRCY-CD;
  else
    SY6REC.ZFC-CRCY-CD = "USD";
  end

  if (OP1REC.XDVCD == "02" /* if nil*/
   && OP3REC.XQACD == "02") /* if b-grade product*/
    SY6REC.XQACD = "01"; /* quality code*/
  else
    SY6REC.XQACD = OP3REC.XQACD; /* quality code*/
  end


      /* db2 read*/

  call "IO0360" ("S ", SQLCA, SY6REC) {isNoRefresh = yes, isExternal = yes}; /* i/o mod for single select*/


      /* check db2 return code*/

  if (SQLCA.VAGen_SQLCODE == 0 /* ok if found*/
   || SQLCA.VAGen_SQLCODE == 100) /* or not found*/
     /* next sentence*/
  else /* otherwise, abend*/
    TA1REC.TA1LOCAT[1] = "S";
    TA1REC.TA1LOCAT[2] = "OP0IS9I";
    TA1REC.TA1LOCAT[3] = "IO0360"; /* i/o mod*/
    TA1REC.TA1DBASE = "DPROD"; /* data base name*/
    TA1REC.TA1TBLVU = "VDCOST01"; /* table view*/
    TA1REC.TA1TBLKE = SY6REC.SY6KEY; /* key value*/
    XSOPS02(); /* common abend routine*/
  end


end // end OP0IS9I

// check cost effective dte
Function OP0IS9J()



      /* find current cost among 6 possible costs*/
      /* new/future date is first, oldest date is last*/
      /* price effective date is booking or ship date,*/
      /* set by order type table (retrieved in 010)*/


  sysVar.arrayIndex = 1; /* check dates ascending seq*/

  while (sysVar.arrayIndex < 7)
    if (SY6REC.SY6CSEDT[sysVar.arrayIndex] <= OP0IW01.OP0IWPED) /* cost effective date*/
      return; /* then use ezetst for cost*/
    end
    sysVar.arrayIndex = sysVar.arrayIndex + 1;
  end



end // end OP0IS9J

// get style/color & color price
Function OP0IS9K()




      /* *******************************************************/
      /* * read db2 price by style or style & color for defaults*/
      /* **/
      /* * first - if price-size code = s or c or z (any):*/
      /* * _ read price default for style (all colors,dims,sizes)*/
      /* * - hold price in op0iwstp (style price)*/
      /* **/
      /* * second - if price-size code = c or z:*/
      /* *  - read price deflt for style & color & dim(all sizes)*/
      /* *  - hold price in op0iwclp (color price)*/
      /* *******************************************************/

      /* *****************************/
      /* * get style price record*/
      /* *****************************/

  SY5REC.SY2CLRID = "***"; /* default color code*/
  SY5REC.XDMCD = "**"; /* default dimension*/
  SY5REC.SY5SZID = 0; /* default size id*/

  OP0IS97(); /* db2 read price by style*/

  if (SQLCA.VAGen_SQLCODE == 100) /* if price record not found,*/
    OP0IW01.OP0IWSTP = 0; /* force zero prices*/
  else
    OP0IS28(); /* pick out price effec today (from 6 possible)*/
    if (sysVar.arrayIndex < 7)
      OP0IW01.OP0IWSTP = SY5REC.SY5PRCUN[sysVar.arrayIndex]; /* hold style price*/
    end
  end

      /* ******************************/
      /* * check if need second read*/
      /* ******************************/

  if (SYCREC.SY1PRCZS == "C" /* if have price by color or size*/
   || SYCREC.SY1PRCZS == "Z") /* get second default*/
    /* next sentence*/
  else /* else use only style default*/
    return;
  end


      /* *******************************************/
      /* * get style/color/dimension price record*/
      /* *******************************************/

  SY5REC.SY2CLRID = OP3REC.SY2CLRID; /* color*/
  SY5REC.XDMCD = OP3REC.XDMCD; /* dimension*/
  SY5REC.SY5SZID = 0; /* default size id*/

  OP0IS97(); /* db2 read price*/

  if (SQLCA.VAGen_SQLCODE == 100) /* price not found*/
    OP0IW01.OP0IWCLP = 0; /* forces price = 0*/
  else
    OP0IS28(); /* pick out price effec today (from 6 possible)*/
    if (sysVar.arrayIndex < 7)
      OP0IW01.OP0IWCLP = SY5REC.SY5PRCUN[sysVar.arrayIndex]; /* hold color price*/
    end
  end



end // end OP0IS9K

// read acct reg cd dnilo.vdstrb
Function OP0IS9L()


      /* this routine reads the dnilo.vdstrb01 to obtain the*/
      /* acct reg code*/

  set SQLCA empty;
  set VDSTRB01 empty;
  VDSTRB01.KUCCOID = KUCREC.KUCCOID;

  call "IO4600" ("S ", SQLCA, VDSTRB01) {isNoRefresh = yes, isExternal = yes}; /* select unique*/

  if (SQLCA.VAGen_SQLCODE == 0) /* row found*/
    /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == +100)
      set VDSTRB01 empty; /* no row found*/
    else
      TA1REC.TA1LOCAT[1] = "S       "; /* function code*/
      TA1REC.TA1LOCAT[2] = "OP0IS9L "; /* sgrp name*/
      TA1REC.TA1LOCAT[3] = "IO4600  "; /* i/o mod name*/
      TA1REC.TA1DBASE = "DNILO   "; /* table prefix*/
      TA1REC.TA1TBLVU = "VDSTRB01"; /* view name*/
      OP0IW01.OP0IW-KUCCOID = KUCREC.KUCCOID; /* unpack key*/
      TA1REC.TA1TBLKE = OP0IW01.OP0IW-KUCCOID; /* display key*/
      XSOPS02(); /* abend*/
    end
  end


end // end OP0IS9L

// set-up new uom and sizes
Function OP0ISA1()
   /* ******************************************************/
   /* **  set-up new unit of measure and/or first and last*/
   /* **  sizes if there were any changes.*/
   /* ******************************************************/

                                       /* unit of measure*/

  if (OSGREC.XUMCD > " "
   && OSGREC.XUMCD != OPWREC.XUMCD[OP0IWSBP])
    OPWREC.XUMCD[OP0IWSBP] = OSGREC.XUMCD;
  end

                                       /* first and last size*/

  if (OSGREC.OPWRQSZF > 0
   && OSGREC.OPWRQSZF != OPWREC.OPWRQSZF[OP0IWSBP])
    OPWREC.OPWRQSZF[OP0IWSBP] = OSGREC.OPWRQSZF;
  end
  if (OSGREC.OPWRQSZL > 0
   && OSGREC.OPWRQSZL != OPWREC.OPWRQSZL[OP0IWSBP])
    OPWREC.OPWRQSZL[OP0IWSBP] = OSGREC.OPWRQSZL;
  end



end // end OP0ISA1

// allocate inventory
Function OP0ISAI()




    /* this routine allocates the entered product.*/

    /* the sequence of events are as follows:*/
       /* 1.  read allocation priority record.*/
       /* 2.  read inventory.*/
       /* 3.  re-check available quantities.*/
       /* 4.  update inventory.*/
       /* 5.  write picking transaction record.*/
       /* 6.  roll allocated qtys into item record*/


  TA1REC.TA1LOCAT[2] = "OP0ISAI";



     /* 1. read the allocation priority record.*/



  set IN2REC empty; /* ; initialize inventory hdr rec*/

  IN2REC.XWHCD = OPWREC.XWHCD[OP0IWSBS]; /* build hdr rec key*/
  if (OP0IM001.XOWCD == " ")
    IN2REC.XOWCD = "00";
  else
    IN2REC.XOWCD = OP0IM001.XOWCD;
  end
  IN2REC.XGPCD = OP1REC.XGPCD;
  IN2REC.SY1STNBR = OPWREC.SY1STNBR[OP0IWSBP];
  IN2REC.SY2CLRID = OPWREC.SY2CLRID[OP0IWSBP];
  IN2REC.XDMCD = OPWREC.XDMCD[OP0IWSBP];
  IN2REC.XQACD = OPWREC.XQACD[OP0IWSBP];


  call "IO0580" ("SS", SQLCA, IN2REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    OP0IW01.OP0IWFND = "N";
    while (SQLCA.VAGen_SQLCODE != 100
     && OP0IW01.OP0IWFND == "N")
      call "IO0580" ("SN", SQLCA, IN2REC) {isNoRefresh = yes, isExternal = yes};
      if (SQLCA.VAGen_SQLCODE == 0)
        if (IN2REC.IN2ALCFL == "Y") /* if good record*/
          OP0IW01.OP0IWFND = "Y";
        end
      else
        if (SQLCA.VAGen_SQLCODE != 100) /* if error*/
          if (SQLCA.VAGen_SQLCODE == -911) /* if deadlock*/
            OP0IS84(); /* wait a second*/
            return; /* loop back*/
          else
            TA1REC.TA1DBASE = "DINVNT";
            TA1REC.TA1TBLVU = "VINHDR01";
            TA1REC.TA1TBLKE = IN2REC.IN2KEY;
            TA1REC.TA1LOCAT[1] = "SN";
            TA1REC.TA1LOCAT[3] = "IO0580";
            XSOPS02(); /* common abend*/
          end
        end
      end
    end
  else
    if (SQLCA.VAGen_SQLCODE == -911) /* if deadlock*/
      OP0IS84(); /* wait a second*/
      return;
    else
      TA1REC.TA1DBASE = "DINVNT";
      TA1REC.TA1TBLVU = "VINHDR01";
      TA1REC.TA1TBLKE = IN2REC.IN2KEY;
      TA1REC.TA1LOCAT[1] = "SS";
      TA1REC.TA1LOCAT[3] = "IO0580";
      XSOPS02(); /* common abend*/
    end
  end


  call "IO0580" ("CS", SQLCA, IN2REC) {isNoRefresh = yes, isExternal = yes};


  if (OP0IW01.OP0IWFND == "Y")
     /* next sentence*/
  else
    converseLib.validationFailed(104); /* no inventory available*/
    exit stack;
  end




     /* 2. access inventory*/


  set SQLCA empty;
  set IN9REC empty; /* ; initialize inventory item rec*/

  IN9REC.XWHCD = OPWREC.XWHCD[OP0IWSBS]; /* build hdr rec key*/
  if (OP0IM001.XOWCD == " ")
    IN9REC.XOWCD = "00";
  else
    IN9REC.XOWCD = OP0IM001.XOWCD;
  end
  IN9REC.XGPCD = OP1REC.XGPCD;
  IN9REC.SY1STNBR = OPWREC.SY1STNBR[OP0IWSBP];
  IN9REC.SY2CLRID = OPWREC.SY2CLRID[OP0IWSBP];
  IN9REC.XDMCD = OPWREC.XDMCD[OP0IWSBP];
  IN9REC.XQACD = OPWREC.XQACD[OP0IWSBP];
  IN9REC.XSDCD = OP3REC.PC2INSEG;
  IN9REC.XSACD = OP3REC.XEGCD;
  IN9REC.XPGCD = OPWREC.XPGCD[OP0IWSBP];
  IN9REC.XUMCD = OPWREC.XUMCD[OP0IWSBP];


  call "DB1030" ("S ", INQREC, IN9REC) {isNoRefresh = yes, isExternal = yes};

  SQLCA.SQLCAREC = INQREC.INQSQLCA;
  if (SQLCA.VAGen_SQLCODE == 0)
     /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == 100) /* lcr - if record not found*/
      converseLib.validationFailed(155); /* possible pkg type problem*/
      OP0IW01.OP0IWREJ = "Y"; /* reject product*/
      exit stack;
    else
      if (SQLCA.VAGen_SQLCODE == -911) /* if deadlock*/
        OP0IS84(); /* wait a second*/
        return; /* loop back*/
      else
        SQLCA.SQLERRP = INQREC.INQFAILR;
        TA1REC.TA1DBASE = "DINVNT";
        TA1REC.TA1TBLVU = "VINITM01";
        TA1REC.TA1TBLKE = IN9REC.IN9KEY;
        TA1REC.TA1LOCAT[1] = "S ";
        TA1REC.TA1LOCAT[3] = "DB1030";
        XSOPS02(); /* common abend*/
      end
    end
  end




    /* 3. re-check availability.*/


  OPAREC.OPASUB = 1;
  while (OPAREC.OPASUB <= 40)
    if (OP3REC.OP3SZAFL[OPASUB] == "Y")
       /* calc avail qty*/
      OP0IW01.OP0IWQTY = IN9REC.IN1ONHND[OPASUB];
             /* lcr - subtract positive qty only*/
      if (IN9REC.IN1RSRVD[OPASUB] < 0) /* negative reserved*/
        INZREC.INZRTNCD = 1050; /* do not process*/
        OP0ISEI();
      else
        OP0IW01.OP0IWQTY = OP0IW01.OP0IWQTY - IN9REC.IN1RSRVD[OPASUB];
      end
             /* lcr - subtract positive qty only*/
      if (IN9REC.IN1ALOCD[OPASUB] < 0) /* negative allocated*/
        INZREC.INZRTNCD = 1060; /* do not process*/
        OP0ISEI();
      else
        OP0IW01.OP0IWQTY = OP0IW01.OP0IWQTY - IN9REC.IN1ALOCD[OPASUB];
      end
      if (IN9REC.IN1STASD[OPASUB] > 0)
        OP0IW01.OP0IWQTY = OP0IW01.OP0IWQTY - IN9REC.IN1STASD[OPASUB];
      end
      if (IN9REC.IN1XFERO[OPASUB] < 0) /* negative transfer out*/
        INZREC.INZRTNCD = 1080; /* do not process*/
        OP0ISEI();
      else
        OP0IW01.OP0IWQTY = OP0IW01.OP0IWQTY - IN9REC.IN1XFERO[OPASUB];
      end
      if (OP3REC.OP3ONOQT[OPASUB] > OP0IW01.OP0IWQTY)
        VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
        VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
        sysLib.rollback();
        VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
        
        converseLib.validationFailed(105); /* insuff inv for 1 or more szs*/
        OPAREC.OPASUB = 1;
        while (OPAREC.OPASUB <= 40)
          OP0IW01.OP0IWQTY = IN9REC.IN1ONHND[OPASUB];
          OP0IW01.OP0IWQTY = OP0IW01.OP0IWQTY - IN9REC.IN1RSRVD[OPASUB];
          OP0IW01.OP0IWQTY = OP0IW01.OP0IWQTY - IN9REC.IN1ALOCD[OPASUB];
          OP0IW01.OP0IWQTY = OP0IW01.OP0IWQTY - IN9REC.IN1XFERO[OPASUB];
          if (IN9REC.IN1STASD < 0)
                       /* next sentence*/
          else
            OP0IW01.OP0IWQTY = OP0IW01.OP0IWQTY - IN9REC.IN1STASD[OPASUB];
          end
          OP0IW01.OP0IWAVQ[OPASUB] = OP0IW01.OP0IWQTY;
          OPAREC.OPASUB = OPAREC.OPASUB + 1;
        end
        OP0IS51(); /* re-show avail*/
        set OP0IM001.OP3ONOQT[1] cursor;
        exit stack; /* re-converse map*/
      end
    end
    OPAREC.OPASUB = OPAREC.OPASUB + 1;
  end





    /* 4. update inventory.*/


  set SQLCA empty;
  set INZREC empty; /* ; initialize in9020 record*/

  INZREC.XWHCD = OPWREC.XWHCD[OP0IWSBS]; /* build hdr rec key*/
  if (OP0IM001.XOWCD == " ")
    INZREC.XOWCD = "00";
  else
    INZREC.XOWCD = OP0IM001.XOWCD;
  end
  INZREC.XGPCD = OP1REC.XGPCD;
  INZREC.SY1STNBR = OPWREC.SY1STNBR[OP0IWSBP];
  INZREC.SY2CLRID = OPWREC.SY2CLRID[OP0IWSBP];
  INZREC.XDMCD = OPWREC.XDMCD[OP0IWSBP];
  INZREC.XQACD = OPWREC.XQACD[OP0IWSBP];
  INZREC.XSDCD = OP3REC.PC2INSEG;
  INZREC.XSACD = OP3REC.XEGCD;
  INZREC.XPGCD = OPWREC.XPGCD[OP0IWSBP];
  INZREC.XUMCD = OPWREC.XUMCD[OP0IWSBP];


  INZREC.IN5TRDTE = OPAREC.OPACDT;
  INZREC.IN5TRDDT = OPAREC.OPACDT;
  INZREC.IN5TRREF = " ";
  INZREC.IN5TRTIM = OP0IW01.OP0IWTM2;
  INZREC.IN5TRDCD = "O";
  INZREC.XITCD = "70";
  INZREC.XIRCD = "907";
  INZREC.XIFCD = "03";
  INZREC.IN5TRPRT = OP1REC.OP1PARTN;
  INZREC.IN5TRDOC = OP1REC.OP1CUOID;
  INZREC.IN5TRSUB = OP0IW01.OP0IWSBS;
  INZREC.IN5USRID = OPWREC.OPWENTLN;
  INZREC.INZALNGQ = "N";
  OPAREC.OPASUB = 1;
  while (OPAREC.OPASUB <= 40)
    INZREC.INZQTYCH[OPASUB] = OP3REC.OP3ONOQT[OPASUB];
    OPAREC.OPASUB = OPAREC.OPASUB + 1;
  end

  call "IN9020" (SQLCA, INZREC) {isNoRefresh = yes, isExternal = yes};

  if (INZREC.INZRTNCD < 1000 /* if good return codes*/
   && SQLCA.VAGen_SQLCODE == 0)
     /* next sentence*/
  else
    if (INZREC.INZRTNCD > 1000)
      OP0ISEI();
    else
      if (SQLCA.VAGen_SQLCODE == -911) /* if deadlock - reset already done*/
        OP0IS84(); /* wait a second*/
        return; /* loop back*/
      else
        VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
        VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
        sysLib.rollback();
        VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
        
        TA1REC.TA1DBASE = "INVENT";
        TA1REC.TA1TBLVU = "& AVAIL ";
        TA1REC.TA1TBLKE = INZREC.INZDATA;
        TA1REC.TA1LOCAT[1] = "OP0I060";
        TA1REC.TA1LOCAT[3] = "IN9020";
        TA1REC.TA1LOCAT[4] = INZREC.INZRTNCD;
        XSOPS02(); /* common abend*/
      end
    end
  end





      /* 5. write picking transaction record.*/
    /* note: 7-22-87.  one call updates io0910 (old picking*/
    /* record.  one call updates io1660 (new picking record).*/
    /* for a time we need to write both records.  not all*/
    /* warehouses are cutting over to the new picking system*/
    /* at the same time (which uses the new picking record),*/
    /* the reason two records must be kept.*/

  PK1REC.PK1PRTN = OP1REC.OP1PARTN;
  PK1REC.PK1CUOID = OP1REC.OP1CUOID;
  PK1REC.PK1NORID = OP0IW01.OP0IWSBS;
  PK1REC.XWHCD = OPWREC.XWHCD[OP0IWSBS];
  if (OPWREC.OPWREVM == 7 /* if addin in review mode*/
   || OPWREC.OP2LNINB > 0)
    PK1REC.PK1LNINB = OP3REC.OP2LNINB; /* use existing line #*/
  else
    PK1REC.PK1LNINB = OPWREC.OPWLSTLI + 1; /* else create new line #*/
  end

  PK1REC.PK1ALLNB = 1;
  PK1REC.PK1TRTYP = "O";
  PK1REC.PK1HLDCD = " ";
  OPAREC.OPASUB = 1;

  while (OPAREC.OPASUB <= 40)
    PK1REC.PK1QTY[OPASUB] = OP3REC.OP3ONOQT[OPASUB];
    OPIREC.OP3ALQT[OPASUB] = OP3REC.OP3ONOQT[OPASUB]; /* 7-22-87*/
    OPAREC.OPASUB = OPAREC.OPASUB + 1;
  end

  call "IO0910" ("A ", SQLCA, PK1REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    OP3REC.OP2LNIST = "AL";
  else
    if (SQLCA.VAGen_SQLCODE == -911) /* if deadlock - reset already done*/
      OP0IS84(); /* wait a second*/
      return; /* loop back*/
    else
      VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
      VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
      sysLib.rollback();
      VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
      
      TA1REC.TA1DBASE = "DPICK ";
      TA1REC.TA1TBLVU = "VPKTRN01";
      TA1REC.TA1TBLKE = PK1REC.PK1KEY;
      TA1REC.TA1LOCAT[1] = "A ";
      TA1REC.TA1LOCAT[3] = "IO0910";
      XSOPS02(); /* common abend*/
    end
  end


  OPIREC.XWHCD = OPWREC.XWHCD[OP0IWSBS]; /* 7-22-87*/
  OPIREC.OP1PARTN = OP1REC.OP1PARTN; /* 7-22-87*/
  OPIREC.OP1CUOID = OP1REC.OP1CUOID; /* 7-22-87*/
  OPIREC.OP1NORID = OP0IW01.OP0IWSBS; /* 7-22-87*/
  if (OPWREC.OPWREVM == 7 /* if addin in review mode*/
   || OPWREC.OP2LNINB > 0)
    OPIREC.OP2LNINB = OP3REC.OP2LNINB; /* use existing line #*/
  else
    OPIREC.OP2LNINB = OPWREC.OPWLSTLI + 1; /* else create new line #*/
    OPIREC.OP2CPLNB = OPIREC.OP2LNINB; /* cust po line itm #*/
  end

  OPIREC.OP1NTMAL = 1; /* 9-3-87 tf*/
  OPIREC.OP2AUPRC = OP0IM001.OP0IMPAL; /* 9-3-87tf*/
  OPIREC.XGPCD = OP3REC.XGPCD; /* 7-22-87*/
  OPIREC.SY1STNBR = OP3REC.SY1STNBR; /* 7-22-87*/
  OPIREC.SY2CLRID = OP3REC.SY2CLRID; /* 7-22-87*/
  OPIREC.XDMCD = OP3REC.XDMCD; /* 7-22-87*/
  OPIREC.XQACD = OP3REC.XQACD; /* 7-22-87*/
  OPIREC.OP2CGPCD = OP3REC.OP2CGPCD; /* 7-22-87*/
  OPIREC.PC2INSEG = OP3REC.PC2INSEG; /* 2-13-91 (db change)*/
  OPIREC.XEGCD = OP3REC.XEGCD; /* 2-13-91 (db change)*/
  OPIREC.XPGCD = OP3REC.XPGCD; /* 7-22-87*/
  OPIREC.XUMCD = OP3REC.XUMCD; /* 7-22-87*/
  if (OPWREC.XWHCD[OP0IWSBS] == "51" /* WHSE 51,*/
   || OPWREC.XWHCD[OP0IWSBS] == "25" /* WHSE 25 CANT USE OWNER GROUPS*/
   || OPWREC.XWHCD[OP0IWSBS] == "27") /* WHSE 27 CANT USE OWNER GROUPS*/
    OPIREC.XOWCD = "00"; /* FOR PICKING (T-SHIRTS CAUSING*/
                                   /* PROBLEMS)*/
  else
    OPIREC.XOWCD = OP3REC.XOWCD; /* 7-22-87*/
  end
  OPIREC.XHDCD[1] = OP0IM001.XHDCD[1]; /* 7-22-87*/
  OPIREC.XHDCD[2] = OP0IM001.XHDCD[2]; /* 7-22-87*/
  OPIREC.XHDCD[3] = OP0IM001.XHDCD[3]; /* 7-22-87*/
  OPIREC.XHDCD[4] = OP0IM001.XHDCD[4];
  OPIREC.XHDCD[5] = OP0IM001.XHDCD[5];
  OPIREC.PWRLBCD[1] = OP3REC.PWRLBCD[1];
  OPIREC.PWRLBCD[2] = OP3REC.PWRLBCD[2];
  OPIREC.KUIPRDID = OP3REC.KUIPRDID; /* 7-22-87*/
  OPIREC.SY1UNPCS = 0; /* 7-22-87*/
  OPIREC.PK5TIWT = 0; /* 7-22-87*/
  OPIREC.PK5TIQTY = OP3REC.OP2TONOQ; /* 7-22-87*/

  SQLCA.VAGen_SQLCODE = 0;
  call "IO1660" ("A ", SQLCA, OPIREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
     /* next sentence;                 uncomment below when io0910*/
     /* MOVE 'AL' TO OP3REC.OP2LNIST;  is no longer used*/
  else
    if (SQLCA.VAGen_SQLCODE == -911) /* if deadlock - reset already done*/
      OP0IS84(); /* wait a second*/
      return; /* loop back*/
    else
      VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
      VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
      sysLib.rollback();
      VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
      
      TA1REC.TA1DBASE = "DORDER";
      TA1REC.TA1TBLVU = "VOPPKI01";
      TA1REC.TA1LOCAT[1] = "A ";
      TA1REC.TA1LOCAT[3] = "IO1660";
      XSOPS02(); /* common abend*/
    end
  end
   /* END ;*/




     /* all is well, line item allocated!!!!!!!!!!!*/




  OPAREC.OPASUB = 1;
  OPAREC.OPASUB1 = 9;

  while (OPAREC.OPASUB <= 40)
    OP3REC.OP3ALQT[OPASUB] = OP3REC.OP3ONOQT[OPASUB];
    OPAREC.OPASUB = OPAREC.OPASUB + 1;
  end



  OPWREC.OPWNMALP[OP0IWSBS] = OPWREC.OPWNMALP[OP0IWSBS] + 1;
  OP3REC.OP2TALCQ = OP3REC.OP2TONOQ;




end // end OP0ISAI

// restore commarea from xsrrec
Function OP0ISAV()
   /* *************************************************************/
   /* * using the osgrec currently in the commarea.causera, get*/
   /* * the saved xsrrec record holding opwrec.  then move the*/
   /* * opwrec into the commarea to set it as if comming from op0h*/
   /* *************************************************************/

  OSGREC.OSGGROUP = COMMAREA.CA-USER-WORKAREA-4K;

      /* ********************************************/
      /* * set up the xsrrec key and get saved order*/
      /* ********************************************/

  set XSRREC empty;
  XSRREC.XSRSYSID = OSGREC.XSRSYSID;
  XSRREC.XSRSUBID = OSGREC.XSRSUBID;
  XSRREC.XSRSQNBR = OSGREC.XSRSQNBR;

  call "IO3400" ("S ", SQLCA, XSRREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0) /* check for good rc*/
    OSKREC.OSKGROUP = XSRREC.XSRDATA;
    COMMAREA.XWHCD = OSKREC.XWHCD;
    COMMAREA.XDVCD = OSKREC.XDVCD;
    COMMAREA.XSOCD = OSKREC.XSOCD;
    COMMAREA.XNDCD = OSKREC.XNDCD;
    COMMAREA.XGPCD = OSKREC.XGPCD;
    OPWREC.OPWSGRP = OSKREC.OS-USER-WORKAREA;
    COMMAREA.CA-USER-WORKAREA-4K = OSKREC.OS-USER-WORKAREA;
  else
    TA1REC.TA1DBASE = "DCORP   "; /* data base name*/
    TA1REC.TA1TBLVU = "VCSPAD01"; /* table view*/
    TA1REC.TA1TBLKE = XSRREC.XSRGROUP; /* key value*/
    TA1REC.TA1LOCAT[2] = "OP0ISAV"; /* error diag group name*/
    TA1REC.TA1LOCAT[3] = "IO3400  "; /* i/o mod name*/
    XSOPS02(); /* common abend*/
  end


      /* ********************************/
      /* * delete the record from xsrrec*/
      /* ********************************/


  call "IO3400" ("D ", SQLCA, XSRREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0) /* check for good rc*/
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DCORP   "; /* data base name*/
    TA1REC.TA1TBLVU = "VCSPAD01"; /* table view*/
    TA1REC.TA1TBLKE = XSRREC.XSRGROUP; /* key value*/
    TA1REC.TA1LOCAT[2] = "OP0ISAV"; /* error diag group name*/
    TA1REC.TA1LOCAT[3] = "IO3400  "; /* i/o mod name*/
    XSOPS02(); /* common abend*/
  end

  VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
  VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
  sysLib.commit();
  VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value

end // end OP0ISAV

// build lost demand map
Function OP0ISBM()

   /* build map*/



  TA1REC.TA1LOCAT[2] = "OP0ISBM";



   /* base order type*/

  OP0IM002.XOBCD = OP1REC.XOBCD;



   /* base order type description*/

  if (OP0IM002.XOBCD in XOBTBL.XOBCD
   && XOBTBL.XXXSTAT[sysVar.arrayIndex] == "A")
    OP0IM002.XOBDESC = XOBTBL.XOBDESC[sysVar.arrayIndex]; /* description*/
  else
    OP0IM002.XOBDESC = "UNKWN";
  end



   /* need date - from oparec not op0im001 11/27/89 rmd*/

  OP0IW01.OP0IWFYY = OPAREC.OPAWYY;
  OP0IW01.OP0IWFMM = OPAREC.OPAWMM;
  OP0IW01.OP0IWFDD = OPAREC.OPAWDD;
  OP0IM002.OP0IMNDT = OP0IW01.OP0IWFDT;



   /* gpc*/

  OP0IM002.XGPCD = OP1REC.XGPCD;



   /* gpc abreviation*/

  if (OP0IM002.XGPCD in XGPTBL.XGPCD
   && XGPTBL.XXXSTAT[sysVar.arrayIndex] == "A")
    OP0IM002.XGPABRV = XGPTBL.XGPABRV[sysVar.arrayIndex];
  else
    OP0IM002.XGPABRV = "UNKWN";
  end



   /* warehouse*/

  OP0IM002.XWHCD = OP1REC.XWHCD;



   /* whs abreviation*/

  if (OP1REC.XWHCD in XWHTBL.XWHCD
   && XWHTBL.XXXSTAT[sysVar.arrayIndex] == "A")
    OP0IM002.XWHSABRV = XWHTBL.XWHSABRV[sysVar.arrayIndex];
  else
    OP0IM002.XWHSABRV = "UNKWN";
  end



   /* waiting list flag*/
   /* if product is a hot model, and customer is not*/
   /* eligible to order hot models, default waiting list*/
   /* flag to 'n' and protect it.*/

  if (SYCREC.OPZHMIND == "Y") /* product is hot model*/
    if (OP0IWELI == "N") /* customer is not eligible*/
      OP0IM002.OPTWAITF = "N";
      set OP0IM002.OPTWAITF skip;
    else
      OP0IM002.OPTWAITF = "Y"; /* default to 'y'*/
    end
  else
    OP0IM002.OPTWAITF = "Y"; /* default to 'y'*/
  end



   /* drop date - default to need date +60 days*/

  set TA2REC empty;
  TA2REC.TA2DTOPT = "GREGGREG";
  TA2DYAOD = +60;
  TA2REC.TA2GRTYP = "G";
  TA2REC.TA2GRGGN = OP1REC.OP1CUNDT;

  call "TA0040" (TA2REC) {isNoRefresh = yes, isExternal = yes};

  if (TA2REC.TA2RTNCD == 0)
    OP0IM002.OP0IMDDT = TA2REC.TA2GRGAN;
  else
    OP0IW01.OP0IWLDE = "Y";
    converseLib.validationFailed(536); /* lost demand not recorded*/
    OP0IW01.OP0IWCWM = " "; /* move msg to commarea message*/
    OP0IW01.OP0IWCM1 = "LOST DEMAND NOT RECO";
    OP0IW01.OP0IWCM2 = "RDED";
    COMMAREA.CAMSG = OP0IW01.OP0IWCWM;
    OP0ISYT(); /* load ta1rec for ta0040 post*/
  end




   /* customer*/

  OP0IM002.OPACUNO = OP0IM001.OPACUNO;


   /* style, color, dimension*/

  OP0IM002.OP0IMPRD = OP0IM001.OP0IMPRD;


   /* product description*/

  OP0IM002.SY1SSTNM = OP0IM001.SY1SSTNM;
  OP0IM002.SY2CLRAB = OP0IM001.SY2CLRAB;


   /* store name*/
  OP0IM002.KUMSTRNM = OP0IM001.KUMSTRNM;

   /* Get the phone number for the store if it is available.*/
  OP0ISPH();

   /* ordered by*/

  OP0IM002.OP1ORDBY = OP1REC.OP1ORDBY;



   /* move sizes and quantities to the map*/

  OP0IW01.OP0IWSLD = 1; /* lost demand map subscript*/
  OP0IW01.OP0IWSBM = 1;
  while (OP0IW01.OP0IWSBM <= 20)
    if (OP0IM001.SY4IDDSC[OP0IWSLD] > " ")
      OP0IM002.OP0IMQT1[OP0IWSLD] = OP0IM001.OP3ONOQT[OP0IWSLD];
      OP0IM002.OP0IMSZ1[OP0IWSLD] = OP0IM001.SY4IDDSC[OP0IWSLD];
      OP0IW01.OP0IWSLD = OP0IW01.OP0IWSLD + 1;
    end
    OP0IW01.OP0IWSBM = OP0IW01.OP0IWSBM + 1;
  end




   /* darken unused map fields*/
   /* op0iwsld is set to the field after the field in which*/
   /* the last size is displayed*/

  if (OP0IW01.OP0IWSLD <= 12)
    set OP0IM002.OP0IMSL1[2] skip, invisible;
    set OP0IM002.OP0IMQL1[2] skip, invisible;
  end

  while (OP0IW01.OP0IWSLD <= 24) /* sub is last map field with size*/
    set OP0IM002.OP0IMQT1[OP0IWSLD] skip, invisible;
    OP0IW01.OP0IWSLD = OP0IW01.OP0IWSLD + 1;
  end




   /* *************************************************************/
end // end OP0ISBM

// allocate inventory,review mode
Function OP0ISCI()




    /* this routine allocates the entered product based on what*/
    /* has been changed in review mode as far as quantities.*/




    /* the sequence of events are as follows:*/
       /* 1.  read allocation priority record.*/
       /* 2.  read inventory.*/
       /* 3.  re-check available quantities.*/
       /* 4.  update inventory.*/
       /* 5.  write picking transaction record.*/


  TA1REC.TA1LOCAT[2] = "OP0ISCI";



     /* 1. read the allocation priority record.*/



  set IN2REC empty; /* ; initialize inventory hdr rec*/

  IN2REC.XWHCD = OPWREC.XWHCD[OP0IWSBS]; /* build hdr rec key*/
  if (OP0IM001.XOWCD == " ")
    IN2REC.XOWCD = "00";
  else
    IN2REC.XOWCD = OP0IM001.XOWCD;
  end
  IN2REC.XGPCD = OP1REC.XGPCD;
  IN2REC.SY1STNBR = OPWREC.SY1STNBR[OP0IWSBP];
  IN2REC.SY2CLRID = OPWREC.SY2CLRID[OP0IWSBP];
  IN2REC.XDMCD = OPWREC.XDMCD[OP0IWSBP];
  IN2REC.XQACD = OPWREC.XQACD[OP0IWSBP];


  call "IO0580" ("SS", SQLCA, IN2REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    OP0IW01.OP0IWFND = "N";
    while (SQLCA.VAGen_SQLCODE != 100
     && OP0IW01.OP0IWFND == "N")
      call "IO0580" ("SN", SQLCA, IN2REC) {isNoRefresh = yes, isExternal = yes};
      if (SQLCA.VAGen_SQLCODE == 0)
        if (IN2REC.IN2ALCFL == "Y") /* if good record*/
          OP0IW01.OP0IWFND = "Y";
        end
      else
        if (SQLCA.VAGen_SQLCODE != 100) /* if error*/
          if (SQLCA.VAGen_SQLCODE == -911) /* if deadlock*/
            OP0IS84(); /* wait 1 second*/
            return; /* loop back*/
          else
            TA1REC.TA1DBASE = "DINVNT";
            TA1REC.TA1TBLVU = "VINHDR01";
            TA1REC.TA1TBLKE = IN2REC.IN2KEY;
            TA1REC.TA1LOCAT[1] = "SN";
            TA1REC.TA1LOCAT[3] = "IO0580";
            XSOPS02(); /* common abend*/
          end
        end
      end
    end
  else
    if (SQLCA.VAGen_SQLCODE == -911) /* if deadlock*/
      OP0IS84(); /* wait a second*/
      return; /* loop back*/
    else
      TA1REC.TA1DBASE = "DINVNT";
      TA1REC.TA1TBLVU = "VINHDR01";
      TA1REC.TA1TBLKE = IN2REC.IN2KEY;
      TA1REC.TA1LOCAT[1] = "SS";
      TA1REC.TA1LOCAT[3] = "IO0580";
      XSOPS02(); /* common abend*/
    end
  end


  call "IO0580" ("CS", SQLCA, IN2REC) {isNoRefresh = yes, isExternal = yes};


  if (OP0IW01.OP0IWFND == "Y")
     /* next sentence*/
  else
    converseLib.validationFailed(104); /* no inventory available*/
    exit stack;
  end






     /* 2. access inventory*/


  set SQLCA empty;
  set IN9REC empty; /* ; initialize inventory item rec*/

  IN9REC.XWHCD = OPWREC.XWHCD[OP0IWSBS]; /* build hdr rec key*/
  if (OP0IM001.XOWCD == " ")
    IN9REC.XOWCD = "00";
  else
    IN9REC.XOWCD = OP0IM001.XOWCD;
  end
  IN9REC.XGPCD = OP1REC.XGPCD;
  IN9REC.SY1STNBR = OPWREC.SY1STNBR[OP0IWSBP];
  IN9REC.SY2CLRID = OPWREC.SY2CLRID[OP0IWSBP];
  IN9REC.XDMCD = OPWREC.XDMCD[OP0IWSBP];
  IN9REC.XQACD = OPWREC.XQACD[OP0IWSBP];
  IN9REC.XSDCD = OP3REC.PC2INSEG;
  IN9REC.XSACD = OP3REC.XEGCD;
  IN9REC.XPGCD = OPWREC.XPGCD[OP0IWSBP];
  IN9REC.XUMCD = OPWREC.XUMCD[OP0IWSBP];


  call "DB1030" ("S ", INQREC, IN9REC) {isNoRefresh = yes, isExternal = yes};

  SQLCA.SQLCAREC = INQREC.INQSQLCA;
  if (SQLCA.VAGen_SQLCODE == 0)
     /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == -911) /* if deadlock*/
      OP0IS84(); /* wait a second*/
      return; /* loop back*/
    else
      SQLCA.SQLERRP = INQREC.INQFAILR;
      TA1REC.TA1DBASE = "DINVNT";
      TA1REC.TA1TBLVU = "VINITM01";
      TA1REC.TA1TBLKE = IN9REC.IN9KEY;
      TA1REC.TA1LOCAT[1] = "S ";
      TA1REC.TA1LOCAT[3] = "DB1030";
      XSOPS02();
    end
  end




    /* 3. re-check availability.*/


  OPAREC.OPASUB = 1;
  while (OPAREC.OPASUB <= 40)
    if (OP0IW01.OP0IWCQT[OPASUB] != 0) /* if some qty was adjusted*/
      OP0IW01.OP0IWQTY = IN9REC.IN1ONHND[OPASUB];
      if (IN9REC.IN1RSRVD[OPASUB] < 0) /* lcr - subtract positive qty only*/
        INZREC.INZRTNCD = 1050;
        OP0ISEI();
      else
        OP0IW01.OP0IWQTY = OP0IW01.OP0IWQTY - IN9REC.IN1RSRVD[OPASUB];
      end
      if (IN9REC.IN1ALOCD[OPASUB] < 0) /* lcr - subtract positive qty only*/
        INZREC.INZRTNCD = 1060;
        OP0ISEI();
      else
        OP0IW01.OP0IWQTY = OP0IW01.OP0IWQTY - IN9REC.IN1ALOCD[OPASUB];
      end
      if (IN9REC.IN1STASD[OPASUB] > 0)
        OP0IW01.OP0IWQTY = OP0IW01.OP0IWQTY - IN9REC.IN1STASD[OPASUB];
      end
      if (IN9REC.IN1XFERO[OPASUB] < 0) /* negative qty*/
        INZREC.INZRTNCD = 1080;
        OP0ISEI();
      else
        OP0IW01.OP0IWQTY = OP0IW01.OP0IWQTY - IN9REC.IN1XFERO[OPASUB];
      end
      if (OP0IW01.OP0IWCQT[OPASUB] > OP0IW01.OP0IWQTY)
        VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
        VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
        sysLib.rollback();
        VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
        
        converseLib.validationFailed(105); /* insuff inv for 1 or more szs*/
        OPAREC.OPASUB = 1;
        while (OPAREC.OPASUB <= 40)
          OP0IW01.OP0IWQTY = IN9REC.IN1ONHND[OPASUB];
          OP0IW01.OP0IWQTY = OP0IW01.OP0IWQTY - IN9REC.IN1RSRVD[OPASUB];
          OP0IW01.OP0IWQTY = OP0IW01.OP0IWQTY - IN9REC.IN1ALOCD[OPASUB];
          OP0IW01.OP0IWQTY = OP0IW01.OP0IWQTY - IN9REC.IN1XFERO[OPASUB];
          if (IN9REC.IN1STASD[OPASUB] > 0)
            OP0IW01.OP0IWQTY = OP0IW01.OP0IWQTY - IN9REC.IN1STASD[OPASUB];
          end
          OP0IW01.OP0IWAVQ[OPASUB] = OP0IW01.OP0IWQTY;
          OPAREC.OPASUB = OPAREC.OPASUB + 1;
        end
        OP0IS51(); /* re-show avail*/
        set OP0IM001.OP3ONOQT[1] cursor;
        exit stack; /* re-converse map*/
      end
    end
    OPAREC.OPASUB = OPAREC.OPASUB + 1;
  end



    /* 4. update inventory.*/


  set SQLCA empty;
  set INZREC empty; /* ; initialize in9020 record*/

  INZREC.XWHCD = OPWREC.XWHCD[OP0IWSBS]; /* build hdr rec key*/
  if (OP0IM001.XOWCD == " ")
    INZREC.XOWCD = "00";
  else
    INZREC.XOWCD = OP0IM001.XOWCD;
  end
  INZREC.XGPCD = OP1REC.XGPCD;
  INZREC.SY1STNBR = OPWREC.SY1STNBR[OP0IWSBP];
  INZREC.SY2CLRID = OPWREC.SY2CLRID[OP0IWSBP];
  INZREC.XDMCD = OPWREC.XDMCD[OP0IWSBP];
  INZREC.XQACD = OPWREC.XQACD[OP0IWSBP];
  INZREC.XSDCD = OP3REC.PC2INSEG;
  INZREC.XSACD = OP3REC.XEGCD;
  INZREC.XPGCD = OPWREC.XPGCD[OP0IWSBP];
  INZREC.XUMCD = OPWREC.XUMCD[OP0IWSBP];


  INZREC.IN5TRDTE = OPAREC.OPACDT;
  INZREC.IN5TRDDT = OPAREC.OPACDT;
  INZREC.IN5TRREF = " ";
  INZREC.IN5TRTIM = OP0IW01.OP0IWTM2;
  INZREC.IN5TRDCD = "O";
  INZREC.XITCD = "70";
  INZREC.XIRCD = "907";
  INZREC.XIFCD = "03";
  INZREC.IN5TRPRT = OP1REC.OP1PARTN;
  INZREC.IN5TRDOC = OP1REC.OP1CUOID;
  INZREC.IN5TRSUB = OP0IW01.OP0IWSBS;
  INZREC.IN5USRID = OPWREC.OPWENTLN;
  INZREC.INZALNGQ = "N";
  OPAREC.OPASUB = 1;
  while (OPAREC.OPASUB <= 40)
    INZREC.INZQTYCH[OPASUB] = OP0IW01.OP0IWCQT[OPASUB];
    OPAREC.OPASUB = OPAREC.OPASUB + 1;
  end

  call "IN9020" (SQLCA, INZREC) {isNoRefresh = yes, isExternal = yes};

  if (INZREC.INZRTNCD < 1000 /* if good return codes*/
   && SQLCA.VAGen_SQLCODE == 0)
     /* next sentence*/
  else
    if (INZREC.INZRTNCD > 1000) /* if fatal return codes*/
      OP0ISEI();
    else
      if (SQLCA.VAGen_SQLCODE == -911) /* if deadlock, reset already done*/
        OP0IS84(); /* wait 1 second*/
        return;
      else
        VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
        VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
        sysLib.rollback();
        VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
        
        TA1REC.TA1DBASE = "INVENT";
        TA1REC.TA1TBLVU = "& AVAIL ";
        TA1REC.TA1TBLKE = INZREC.INZDATA;
        TA1REC.TA1LOCAT[1] = "OP0I060";
        TA1REC.TA1LOCAT[2] = "OP0ISCI";
        TA1REC.TA1LOCAT[3] = "IN9020";
        TA1REC.TA1LOCAT[4] = INZREC.INZRTNCD;
        XSOPS02(); /* common abend*/
      end
    end
  end




      /* 5. update picking transaction record.*/

    /* note: can only be one pick record per line item so i*/
          /* must first re-read the original record and then*/
          /* update it.*/

   /* but if there was no picking record*/
   /* or the suborder changed*/
   /* have 2 different situations*/
   /* 1. no picking found because product had future*/
      /* needt in order entry and was not allocated on-line,*/
      /* but future size was zeroed in review mode*/
      /* so product became eligible to allocate on-line.*/
      /* thus, if picking not found, add code to add picking rec.*/
      /* note - is this a problem with other files in this*/
        /* statement group?*/
   /* 2. need to select picking with old sub-order*/
      /* which is subscript op0iwsbo.*/
      /* when select is o.k., then move in new sub-order*/
      /* and other new fields as done below,*/
      /* and update the picking record.*/
   /* 3. must also move in old xwhcd before selct*/
      /* and new for update*/

   /* note:  for a time we will need to write both the old*/
   /* picking record (pk1rec) and new picking record (opirec).*/
   /* see further notes in op0isai.*/

  PK1REC.PK1PRTN = OP1REC.OP1PARTN;
  PK1REC.PK1CUOID = OP1REC.OP1CUOID;
  PK1REC.PK1NORID = OP0IW01.OP0IWSBS; /* old sub-order*/
  PK1REC.XWHCD = OPWREC.XWHCD[OP0IWSBS]; /* old whse*/
  PK1REC.PK1LNINB = OPWREC.OP2LNINB;
  PK1REC.PK1ALLNB = 1;
  PK1REC.PK1HLDCD = "O";

  call "IO0910" ("S ", SQLCA, PK1REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
     /* found old pick tran*/
     /* now load in changed quantities*/
    OPAREC.OPASUB = 1;
    while (OPAREC.OPASUB <= 40)
      OP0IW01.OP0IWQTY = OP0IW01.OP0IWCQT[OPASUB];
      PK1REC.PK1QTY[OPASUB] = PK1REC.PK1QTY[OPASUB] + OP0IW01.OP0IWQTY;
      OPAREC.OPASUB = OPAREC.OPASUB + 1;
    end

    call "IO0910" ("U ", SQLCA, PK1REC) {isNoRefresh = yes, isExternal = yes};

    if (SQLCA.VAGen_SQLCODE == 0)
      OP3REC.OP2LNIST = "AL";
    else
      if (SQLCA.VAGen_SQLCODE == -911) /* if deadlock - reset already done*/
        OP0IS84(); /* wait 1 second*/
        return; /* loop back*/
      else
        VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
        VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
        sysLib.rollback();
        VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
        
        TA1REC.TA1DBASE = "DPICK ";
        TA1REC.TA1TBLVU = "VPKTRN01";
        TA1REC.TA1TBLKE = PK1REC.PK1KEY;
        TA1REC.TA1LOCAT[1] = "U ";
        TA1REC.TA1LOCAT[3] = "IO0910";
        XSOPS02(); /* common abend*/
      end
    end
  else /* sqlcode ne 0*/
    if (SQLCA.VAGen_SQLCODE == -911) /* if deadlock - reset already done*/
      OP0IS84(); /* wait a second*/
      return; /* loop back*/
    else
      VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
      VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
      sysLib.rollback();
      VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
      
      TA1REC.TA1DBASE = "DPICK ";
      TA1REC.TA1TBLVU = "VPKTRN01";
      OP0IW01.OP0IWPRT = OP1REC.OP1PARTN;
      OP0IW01.OP0IWCID = OP1REC.OP1CUOID;
      OP0IW01.OP0IWNID = OP0IW01.OP0IWSBS;
      OP0IW01.OP0IWLIN = OPWREC.OP2LNINB;
      TA1REC.TA1TBLKE = OP0IW01.OP0IWIKY;
      TA1REC.TA1LOCAT[1] = "S ";
      TA1REC.TA1LOCAT[3] = "IO0910";
      XSOPS02(); /* common abend*/
    end
  end

           /* update new picking record opirec (added 7-22-87)*/

  OPIREC.OP1NTMAL = 1; /* 9-3-87tf*/
  OPIREC.OP2AUPRC = OP0IM001.OP0IMPAL; /* 9-3-87TF*/
  OPIREC.OP1PARTN = OP1REC.OP1PARTN;
  OPIREC.OP1CUOID = OP1REC.OP1CUOID;
  OPIREC.OP1NORID = OP0IW01.OP0IWSBS; /* old sub-order*/
  OPIREC.XWHCD = OPWREC.XWHCD[OP0IWSBS]; /* old whse*/
  OPIREC.OP2LNINB = OPWREC.OP2LNINB;

  call "IO1660" ("S ", SQLCA, OPIREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
     /* found old pick tran*/
     /* now load in changed quantities*/
    OPIREC.XQACD = OP3REC.XQACD; /* 7-22-87*/
    OPIREC.OP2CGPCD = OP3REC.OP2CGPCD; /* 7-22-87*/
    OPIREC.PC2INSEG = OP3REC.PC2INSEG; /* 2-13-91 (db change)*/
    OPIREC.XEGCD = OP3REC.XEGCD; /* 2-13-91(db change)*/
    OPIREC.XPGCD = OP3REC.XPGCD; /* 7-22-87*/
    OPIREC.XUMCD = OP3REC.XUMCD; /* 7-22-87*/
    if (OPIREC.XWHCD == "51" /* whse 51,*/
     || OPIREC.XWHCD == "25" /* whse 25 can't have*/
     || OPIREC.XWHCD == "27") /* whse 25 can't have*/
      OPIREC.XOWCD = "00"; /* owner grps--t shirt fix*/
    else
      OPIREC.XOWCD = OP3REC.XOWCD; /* 7-22-87*/
    end
    OPIREC.XHDCD[1] = OP0IM001.XHDCD[1]; /* 7-22-87*/
    OPIREC.XHDCD[2] = OP0IM001.XHDCD[2]; /* 7-22-87*/
    OPIREC.XHDCD[3] = OP0IM001.XHDCD[3]; /* 7-22-87*/
    OPIREC.XHDCD[4] = OP0IM001.XHDCD[4];
    OPIREC.XHDCD[5] = OP0IM001.XHDCD[5];
    OPIREC.PWRLBCD[1] = OP3REC.PWRLBCD[1];
    OPIREC.PWRLBCD[2] = OP3REC.PWRLBCD[2];
    OPIREC.KUIPRDID = OP3REC.KUIPRDID; /* 7-22-87*/
    OPIREC.SY1UNPCS = 0; /* 7-22-87*/
    OPIREC.PK5TIWT = 0; /* 7-22-87*/
    OPIREC.PK5TIQTY = OP3REC.OP2TONOQ; /* 7-22-87*/
    OPIREC.ZZZSDT = OPAREC.OPACDT;
    OPIREC.ZZZCHGDT = OPAREC.OPACDT;
    OPIREC.ZZZCHGTM = OP0IW01.OP0IWTM3;

    OPAREC.OPASUB = 1;
    while (OPAREC.OPASUB <= 40)
      OP0IW01.OP0IWQTY = OP0IW01.OP0IWCQT[OPASUB];
      OPIREC.OP3ALQT[OPASUB] = OPIREC.OP3ALQT[OPASUB] + OP0IW01.OP0IWQTY;
      OPAREC.OPASUB = OPAREC.OPASUB + 1;
    end

    SQLCA.VAGen_SQLCODE = 0;
    call "IO1660" ("U ", SQLCA, OPIREC) {isNoRefresh = yes, isExternal = yes};

    if (SQLCA.VAGen_SQLCODE == 0) /* comment out below until*/
       /* MOVE 'AL' TO OP3REC.OP2LNIST; old picking record not used*/
    else
      if (SQLCA.VAGen_SQLCODE == -911) /* if deadlock - reset already done*/
        OP0IS84(); /* wait 1 second*/
        return; /* loop back*/
      else
        VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
        VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
        sysLib.rollback();
        VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
        
        TA1REC.TA1DBASE = "DORDER";
        TA1REC.TA1TBLVU = "VOPPKI01";
        TA1REC.TA1LOCAT[1] = "U ";
        TA1REC.TA1LOCAT[3] = "IO1660";
        XSOPS02(); /* common abend*/
      end
    end
  else /* sqlcode ne 0*/
    if (SQLCA.VAGen_SQLCODE == -911) /* if deadlock - reset already done*/
      OP0IS84(); /* wait a second*/
      return; /* loop back*/
    else
      VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
      VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
      sysLib.rollback();
      VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
      
      TA1REC.TA1DBASE = "DORDER";
      TA1REC.TA1TBLVU = "VOPPKI01";
      OP0IW01.OP0IWPRT = OP1REC.OP1PARTN;
      OP0IW01.OP0IWCID = OP1REC.OP1CUOID;
      OP0IW01.OP0IWNID = OP0IW01.OP0IWSBS;
      OP0IW01.OP0IWLIN = OPWREC.OP2LNINB;
      TA1REC.TA1TBLKE = OP0IW01.OP0IWIKY;
      TA1REC.TA1LOCAT[1] = "S ";
      TA1REC.TA1LOCAT[3] = "IO1660";
      XSOPS02(); /* common abend*/
    end
  end
   /* END ;*/




     /* all is well, line item allocated!!!!!!!!!!!*/





  OPAREC.OPASUB = 1;
  OPAREC.OPASUB1 = 9;
  OP0IW01.OP0IWTOT = 0;

  while (OPAREC.OPASUB <= 40)
    OP0IW01.OP0IWQTY = OP0IW01.OP0IWCQT[OPASUB];
    OP0IW01.OP0IWTOT = OP0IW01.OP0IWTOT + OP0IW01.OP0IWQTY;
    OP3REC.OP3ALQT[OPASUB] = OP3REC.OP3ALQT[OPASUB] + OP0IWQTY;
    OPAREC.OPASUB = OPAREC.OPASUB + 1;
  end



  OP3REC.OP2TALCQ = OP3REC.OP2TALCQ + OP0IW01.OP0IWTOT;



end // end OP0ISCI

// de-allocate inventory
Function OP0ISDI()


    /* this routine de-allocates the rejected product.*/

    /* the sequence of events are as follows:*/
       /* 1.  read allocation record.*/
       /* 2.  de-allocate quantities.*/
       /* 3.  delete pick transaction record.*/
    /* use old sub-order values*/

  TA1REC.TA1LOCAT[2] = "OP0ISDI";



     /* 1. read the allocation record.*/


  set IN2REC empty; /* ; initialize inventory hdr rec*/

  IN2REC.XWHCD = OPWREC.XWHCD[OP0IWSBS]; /* build hdr rec key*/
  if (OP0IM001.XOWCD == " ")
    IN2REC.XOWCD = "00";
  else
    IN2REC.XOWCD = OP0IM001.XOWCD;
  end
  IN2REC.XGPCD = OP1REC.XGPCD;
  IN2REC.SY1STNBR = OPWREC.SY1STNBR[OP0IWSBP];
  IN2REC.SY2CLRID = OPWREC.SY2CLRID[OP0IWSBP];
  IN2REC.XDMCD = OPWREC.XDMCD[OP0IWSBP];
  IN2REC.XQACD = OPWREC.XQACD[OP0IWSBP];


  call "IO0580" ("SS", SQLCA, IN2REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    OP0IW01.OP0IWFND = "N";
    while (SQLCA.VAGen_SQLCODE != 100
     && OP0IW01.OP0IWFND == "N")
      call "IO0580" ("SN", SQLCA, IN2REC) {isNoRefresh = yes, isExternal = yes};
      if (SQLCA.VAGen_SQLCODE == 0)
        if (IN2REC.IN2ALCFL == "Y") /* if good record*/
          OP0IW01.OP0IWFND = "Y";
        end
      else
        if (SQLCA.VAGen_SQLCODE != 100) /* if error*/
          if (SQLCA.VAGen_SQLCODE == -911) /* if deadlock*/
            converseLib.validationFailed(6); /* record busy try again*/
            exit stack;
          else
            TA1REC.TA1DBASE = "DINVNT";
            TA1REC.TA1TBLVU = "VINHDR01";
            TA1REC.TA1TBLKE = IN2REC.IN2KEY;
            TA1REC.TA1LOCAT[1] = "SN";
            TA1REC.TA1LOCAT[3] = "IO0580";
            XSOPS02(); /* common abend*/
          end
        end
      end
    end
  else
    if (SQLCA.VAGen_SQLCODE == -911) /* if deadlock*/
      converseLib.validationFailed(6); /* record busy try again*/
      exit stack;
    else
      TA1REC.TA1DBASE = "DINVNT";
      TA1REC.TA1TBLVU = "VINHDR02";
      TA1REC.TA1TBLKE = IN2REC.IN2KEY;
      TA1REC.TA1LOCAT[1] = "SS";
      TA1REC.TA1LOCAT[3] = "IO0580";
      XSOPS02(); /* common abend*/
    end
  end


  call "IO0580" ("CS", SQLCA, IN2REC) {isNoRefresh = yes, isExternal = yes};


  if (OP0IW01.OP0IWFND == "Y")
     /* next sentence*/
  else
    converseLib.validationFailed(104); /* no inventory available*/
    exit stack;
  end



    /* 2. update inventory (deallocate)*/


  set SQLCA empty;
  set INZREC empty; /* ; initialize in9020 record*/

  INZREC.XWHCD = OPWREC.XWHCD[OP0IWSBS]; /* build hdr rec key*/
  if (OP0IM001.XOWCD == " ")
    INZREC.XOWCD = "00";
  else
    INZREC.XOWCD = OP0IM001.XOWCD;
  end
  INZREC.XGPCD = OP1REC.XGPCD;
  INZREC.SY1STNBR = OPWREC.SY1STNBR[OP0IWSBP];
  INZREC.SY2CLRID = OPWREC.SY2CLRID[OP0IWSBP];
  INZREC.XDMCD = OPWREC.XDMCD[OP0IWSBP];
  INZREC.XQACD = OPWREC.XQACD[OP0IWSBP];
  INZREC.XSDCD = OP3REC.PC2INSEG;
  INZREC.XSACD = OP3REC.XEGCD;
  INZREC.XPGCD = OP3REC.XPGCD;
  INZREC.XUMCD = OP3REC.XUMCD;


  INZREC.IN5TRDTE = OPAREC.OPACDT;
  INZREC.IN5TRDDT = OPAREC.OPACDT;
  INZREC.IN5TRREF = " ";
  INZREC.IN5TRTIM = OP0IW01.OP0IWTM2;
  INZREC.IN5TRDCD = "O";
  INZREC.XITCD = "70";
  INZREC.XIRCD = "907";
  INZREC.XIFCD = "03";
  INZREC.IN5TRPRT = OP1REC.OP1PARTN;
  INZREC.IN5TRDOC = OP1REC.OP1CUOID;
  INZREC.IN5TRSUB = OP0IW01.OP0IWSBS;
  INZREC.IN5USRID = OPWREC.OPWENTLN;
  INZREC.INZALNGQ = "N";

     /* roll quantities into inzrec.*/
     /* allocated qty = current op3rec - change qty.*/

  OPAREC.OPASUB = 1;
  while (OPAREC.OPASUB <= 40)
    if (OP3REC.OP3SZAFL[OPASUB] == "Y")
      OP0IW01.OP0IWQTY = OP3REC.OP3ONOQT[OPASUB];
      OP0IW01.OP0IWQTY = OP0IW01.OP0IWQTY - OP0IW01.OP0IWCQT[OPASUB];
      OP0IW01.OP0IWQTY = OP0IW01.OP0IWQTY * -1;
      INZREC.INZQTYCH[OPASUB] = OP0IW01.OP0IWQTY;
    else
      INZREC.INZQTYCH[OPASUB] = 0;
    end
    OPAREC.OPASUB = OPAREC.OPASUB + 1;
  end

  call "IN9020" (SQLCA, INZREC) {isNoRefresh = yes, isExternal = yes};

  if (INZREC.INZRTNCD < 1000 /* if good return codes*/
   && SQLCA.VAGen_SQLCODE == 0)
     /* next sentence*/
  else
    if (INZREC.INZRTNCD > 1000) /* if good return codes*/
      OP0ISEI();
    else
      if (SQLCA.VAGen_SQLCODE == -911) /* if deadlock - reset already done*/
        converseLib.validationFailed(6); /* record busy try again*/
        exit stack;
      else
        VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
        VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
        sysLib.rollback();
        VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
        
        TA1REC.TA1DBASE = "INVENT";
        TA1REC.TA1TBLVU = "+AVAIL  ";
        TA1REC.TA1TBLKE = INZREC.INZDATA;
        TA1REC.TA1LOCAT[1] = "U";
        TA1REC.TA1LOCAT[3] = "IN9020";
        XSOPS02(); /* common abend*/
      end
    end
  end





      /* 4. delete picking transaction record.*/

    /* for a time we will adjust both the old picking*/
    /* record (pk1rec) and the new picking record (opirec).*/
    /* this will be done until the the old picking record*/
    /* is no longer needed.  see op0isai for further details.*/


  PK1REC.PK1PRTN = OP1REC.OP1PARTN;
  PK1REC.PK1CUOID = OP1REC.OP1CUOID;
  PK1REC.PK1NORID = OP0IW01.OP0IWSBS;
  PK1REC.XWHCD = OPWREC.XWHCD[OP0IWSBS];
  PK1REC.PK1LNINB = OPWREC.OP2LNINB;
  PK1REC.PK1ALLNB = 1;
  PK1REC.PK1TRTYP = "O";
  PK1REC.PK1HLDCD = " ";

  call "IO0910" ("D ", SQLCA, PK1REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
     /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == -911) /* if deadlock - reset already done*/
      converseLib.validationFailed(6); /* record busy try again*/
      exit stack; /* re-converse*/
    else
      VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
      VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
      sysLib.rollback();
      VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
      
      TA1REC.TA1DBASE = "DPICK ";
      TA1REC.TA1TBLVU = "VPKTRN01";
      TA1REC.TA1TBLKE = PK1REC.PK1KEY;
      TA1REC.TA1LOCAT[1] = "A ";
      TA1REC.TA1LOCAT[3] = "IO0910";
      XSOPS02(); /* common abend*/
    end
  end


    /* adjust new picking record (added 7-23-87)*/

  OPIREC.OP1PARTN = OP1REC.OP1PARTN;
  OPIREC.OP1CUOID = OP1REC.OP1CUOID;
  OPIREC.OP1NORID = OP0IW01.OP0IWSBS;
  OPIREC.XWHCD = OPWREC.XWHCD[OP0IWSBS];
  OPIREC.OP2LNINB = OPWREC.OP2LNINB;

  SQLCA.VAGen_SQLCODE = 0;
  call "IO1660" ("D ", SQLCA, OPIREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
     /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == -911) /* if deadlock - reset already done*/
      converseLib.validationFailed(6); /* record busy try again*/
      exit stack; /* re-converse*/
    else
      VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
      VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
      sysLib.rollback();
      VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
      
      TA1REC.TA1DBASE = "DORDER";
      TA1REC.TA1TBLVU = "VOPPKI01";
      TA1REC.TA1LOCAT[1] = "D ";
      TA1REC.TA1LOCAT[3] = "IO1660";
      XSOPS02(); /* common abend*/
    end
  end
   /* END ;*/





end // end OP0ISDI

// edit direct ship
Function OP0ISDS()



    /* see if whs not required based on direct ship code.*/




  if (OP1REC.XDSCD == " ")
    OP0IW01.XDSWHSEF = "Y"; /* save whse flag*/
  else
    if (OP1REC.XDSCD in XDSTBL.XDSCD
     && XDSTBL.XXXSTAT[sysVar.arrayIndex] == "A")
      OP0IW01.XDSWHSEF = XDSTBL.XDSWHSEF[sysVar.arrayIndex]; /* save whse flag*/
    end
  end




    /* if whs not required, blank warehouse.*/

  if (OP0IW01.XDSWHSEF == "N") /* if not required*/
    OP1REC.XWHCD = " ";
    OPWREC.XWHCD[1] = " ";
  end



end // end OP0ISDS

// check prop date ranges for sty
Function OP0ISDW()



  if (SYCREC.SY2POFBD <= 0) /* if field is blank on database*/
    SYCREC.SY2POFBD = 0;
  end

  if (SYCREC.SY2POFXD <= 0) /* if field is blank on database*/
    SYCREC.SY2POFXD = 99999999;
  end

  if (OP0IW01.OP1CUNDT >= SYCREC.SY2POFBD) /* need dt>= prop begin dt*/
    if (OP0IW01.OP1CUNDT <= SYCREC.SY2POFXD) /* need dt <=prop expir dt*/
       /* next sentence--need date within range; ok to process*/
    else
      OP0IW01.OP0IWSFL = "Y";
    end
  else
    OP0IW01.OP0IWSFL = "Y";
  end



end // end OP0ISDW

// check futr dt ranges for style
Function OP0ISDX()



  if (SYCREC.SY2FOFBD <= 0) /* if field is blank on database*/
    SYCREC.SY2FOFBD = 0;
  end

  if (SYCREC.SY2FOFXD <= 0) /* if field is blank on database*/
    SYCREC.SY2FOFXD = 99999999;
  end

  if (OP0IW01.OP1CUNDT >= SYCREC.SY2FOFBD) /* need dt>= futr beg dt*/
    if (OP0IW01.OP1CUNDT <= SYCREC.SY2FOFXD) /* need dt <=futr xdt*/
       /* next sentence--need date within range; ok to process*/
    else
      OP0IW01.OP0IWSFL = "Y";
    end
  else
    OP0IW01.OP0IWSFL = "Y";
  end



end // end OP0ISDX

// check nil date ranges for styl
Function OP0ISDY()



  if (SYCREC.SY2NOFBD <= 0) /* if field is blank on database*/
    SYCREC.SY2NOFBD = 0;
  end

  if (SYCREC.SY2NOFXD <= 0) /* if field is blank on database*/
    SYCREC.SY2NOFXD = 99999999;
  end

  if (OP0IW01.OP1CUNDT >= SYCREC.SY2NOFBD) /* need dt >=nil begin dt*/
    if (OP0IW01.OP1CUNDT <= SYCREC.SY2NOFXD) /* need dt <=nil expir dt*/
       /* next sentence--need date within range; ok to process*/
    else
      OP0IW01.OP0IWSFL = "Y";
    end
  else
    OP0IW01.OP0IWSFL = "Y";
  end




end // end OP0ISDY

// style sold out or not avail?
Function OP0ISDZ()


  TA1REC.TA1LOCAT[2] = "OP0ISDZ"; /* diag*/

  OP0IW01.OP0IWSFL = "N";

   /* *******************************************************/
   /* if any of the quality codes = 02*/
   /* or any of the life cycle codes = 20*/
    /* and quality or life cycle cd = 02 or 20 at*/
   /* the product level; or division cd = 03;*/
   /* or bulk draw*/
   /* or warehouse = 03 (protek)  or  warehouse = 09 (promo)*/
   /* bypass the product offering date edits*/
   /* *******************************************************/

  if (OP0IW01.OP0IWBDF == "DS" /* if smart draw*/
   || OP0IW01.OP0IWBDF == "DX" /* if flexible draw*/
   || OP0IW01.OP0IWBDF == "DC" /* if customer draw*/
   || OP0IW01.OP0IWBDF == "DR" /* if rebook draw*/
   || OP0IW01.OP0IWBDF == "DN") /* if nike draw*/
    return; /* --return*/
  end

  /* BBAHUL Begin changes  11/02/99*/
  if (OP1REC.XDVCD == "03")
    if (COMMAREA.CAUSERID in YOSTBL.XXXUSRID)
      if (YOSTBL.YOSSCTYI[sysVar.arrayIndex] == "P") /* check if special promo*/
                                  /* continue*/
      else
        return;
      end
    else
      return;
    end
  end

  if (OP0IM001.XWHCD == "09")
    if (COMMAREA.CAUSERID in YOSTBL.XXXUSRID)
      if (YOSTBL.YOSSCTYI[sysVar.arrayIndex] == "P") /* If special promo and*/
                                  /* continue*/
      else
        return;
      end
    else
      return;
    end
  end

  if (OP0IM001.XWHCD == "03") /* if protek whse*/
    return; /* --return*/
  end

  /* BBAHUL end changes 11/03/99*/
  if (OP1REC.XOTCD in XOTTBL.XOTCD)
    if (XOTTBL.XQACD1[sysVar.arrayIndex] == "02"
     || XOTTBL.XQACD2[sysVar.arrayIndex] == "02"
     || XOTTBL.XQACD3[sysVar.arrayIndex] == "02"
     || XOTTBL.XLCCD1[sysVar.arrayIndex] == "20"
     || XOTTBL.XLCCD2[sysVar.arrayIndex] == "20"
     || XOTTBL.XLCCD3[sysVar.arrayIndex] == "20"
     || XOTTBL.XLCCD4[sysVar.arrayIndex] == "20"
     || XOTTBL.XLCCD5[sysVar.arrayIndex] == "20")
      if (OP3REC.XQACD == "02"
       || OP0IW01.XLCCD == "20")
        return; /* --return*/
      end
    end
  end



  if (XOTTBL.XOTSMPLF[sysVar.arrayIndex] == "Y" /* if footwear/apparel samples*/
   || OP1REC.XBDCD == "2"                       /* or smart of flex bulks, by-*/
   || OP1REC.XBDCD == "Z")                      /* ; pass product offering dates.*/
    return;
  end


  if (OP1REC.SP1ID == "EARL"       /* early futures allowed to*/
   && OP0IW01.OP1CUNDT == 19911201 /* order before the offering*/
   && XOTTBL.XOTFUTRF[sysVar.arrayIndex] == "Y") /* date*/
    return;
  end


  if (XOTTBL.XDVCD[sysVar.arrayIndex] == "02") /* if international order*/
    OP0ISDY(); /* check nil date ranges for the style*/
  else
    if (XOTTBL.XOTFUTRF[sysVar.arrayIndex] == "Y") /* if a futures order*/
      OP0ISDX(); /* check futures date ranges for the*/
                                   /* style*/
    else
      OP0ISDW(); /* check prop date ranges for the style*/
    end
  end


  if (OP0IW01.OP0IWSFL == "Y")
    OPAREC.OPAERR = "Y";
    converseLib.validationFailed(394); /* product will not be avail by need dt*/
    set OP0IM001.OP0IMNDT cursor, modified, bold;
  end

end // end OP0ISDZ

// build record to pass for edits
Function OP0ISEB()


  set OSEREC empty;
  OSEREC.OSEERRFL = "N"; /* map field error flag*/
  OSEREC.OSEQT1FL = "N"; /* quantity error, 1st style*/

   /* move all map fields that are editited to pass record*/

  OSEREC.OP1ORDBY = OP0IM002.OP1ORDBY;
  OSEREC.OPTWAITF = OP0IM002.OPTWAITF;

  OSEREC.OSEDRPDT = OP0IM002.OP0IMDDT;
  OSEREC.OSECUNDT = OP0IM002.OP0IMNDT;

   /* get fields from commarea*/

  OSEREC.XDVCD = COMMAREA.XDVCD;
  OSEREC.XSOCD = COMMAREA.XSOCD;



   /* style, color and dimension*/

  OSEREC.SY1STNBR[1] = OP3REC.SY1STNBR;
  OSEREC.SY2CLRID[1] = OP3REC.SY2CLRID;
  OSEREC.XDMCD[1] = OP3REC.XDMCD;

   /* quantities*/

  OP0IW01.OP0IWSLD = 1;
  while (OP0IWSLD <= 24)
    OSEREC.OP0LMQT1[OP0IWSLD] = OP0IM002.OP0IMQT1[OP0IWSLD];
    OP0IWSLD = OP0IWSLD + 1;
  end

end // end OP0ISEB

// error routine for in9010
Function OP0ISEI()


  if (INZREC.INZRTNCD == 8010
   || INZREC.INZRTNCD == 8020)
    converseLib.validationFailed(310);
  else
    if (INZREC.INZRTNCD >= 1020
     && INZREC.INZRTNCD <= 1029)
      converseLib.validationFailed(310);
    else
      if (INZREC.INZRTNCD == 1040
       || INZREC.INZRTNCD == 7020
       || INZREC.INZRTNCD == 8030
       || INZREC.INZRTNCD == 8040
       || INZREC.INZRTNCD == 8050
       || INZREC.INZRTNCD == 8060
       || INZREC.INZRTNCD == 8070
       || INZREC.INZRTNCD == 8090)
        converseLib.validationFailed(6);
      else
        if (INZREC.INZRTNCD == 1010
         || INZREC.INZRTNCD == 7040
         || INZREC.INZRTNCD == 8080)
          converseLib.validationFailed(312);
        else
          if (INZREC.INZRTNCD == 1050
           || INZREC.INZRTNCD == 1060
           || INZREC.INZRTNCD == 1070
           || INZREC.INZRTNCD == 1080
           || INZREC.INZRTNCD == 1090)
            converseLib.validationFailed(311);
          else
            VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
            VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
            sysLib.rollback();
            VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
            
            TA1REC.TA1DBASE = "INVENT";
            TA1REC.TA1TBLVU = "& AVAIL ";
            TA1REC.TA1TBLKE = INZREC.INZDATA;
            TA1REC.TA1LOCAT[1] = "OP0ISEI";
            TA1REC.TA1LOCAT[3] = "IN9020";
            TA1REC.TA1LOCAT[4] = INZREC.INZRTNCD;
            XSOPS02(); /* common abend*/
          end
        end
      end
    end
  end

  if (INZREC.INZRTNCD == 1021 /* added 1/30/89*/
   || INZREC.INZRTNCD == 1024 /* to bypass posting*/
   || INZREC.INZRTNCD == 1050 /* although are valid*/
   || INZREC.INZRTNCD == 1060) /* they are not worth posting  dwalke*/
     /* next sentence*/
  else
    /* MOVE INZREC.INZRTNCD TO OP0IW01.OP0IWRTN;*/
    /* MOVE IN9REC.SY1STNBR TO OP0IW01.OP0IWSTY;*/
    /* MOVE IN9REC.SY2CLRID TO OP0IW01.OP0IWCLR;*/
    /* MOVE OP0IW01.OP0IWERR TO TA1REC.TA1TBLKE;*/
    TA1REC.TA1TBLKE = INZREC.INZKEY;
    TA1REC.TA1TYPE = "DB2"; /* abend type*/
    TA1REC.TA1PGMNM = "OP0I"; /* program name*/
    TA1REC.TA1DBASE = "INVENT"; /* data base*/
    TA1REC.TA1TBLVU = "& AVAIL "; /* table view*/
    TA1REC.TA1LOCAT[1] = "OP0ISEI";
    TA1REC.TA1MAP = "OP0IM001";
    TA1REC.TA1LOCAT[3] = "IN9020";
    TA1REC.TA1LOCAT[4] = INZREC.INZRTNCD;
    TA1REC.TA1FUNC = "POST"; /* abend function*/
    set ERRSQLCA empty;
    move SQLCA to ERRSQLCA withV60Compat;
    call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes}; /* abend module*/
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.rollback();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
     /* synpoint rollback*/
    COMMAREA.CA-USER-WORKAREA-4K = " "; /* clear user commarea*/
    OPAREC.OPAERR = "Y";
  end
  exit stack;

end // end OP0ISEI

// edit only processing
Function OP0ISEO()


  TA1REC.TA1LOCAT[2] = "OP0ISEO";

  OP0ISEB(); /* build record to pass for edit*/



  OSEREC.OSERETN = "00";

  OSEREC.OSETASK = "03";

  call "OP04" (OSEREC); /* lost demand edit subprogram*/


  if (OSEREC.OSERETN == "00")
    if (OSEREC.OSEERRFL == "N")
      converseLib.validationFailed(518); /* edit perfromed with no errors*/
    else
      OP0ISYM();
    end
  else
    converseLib.validationFailed(536); /* lost demand not recorded*/
    OP0IW01.OP0IWCWM = " "; /* move msg to commarea message*/
    OP0IW01.OP0IWCM1 = "LOST DEMAND NOT RECO";
    OP0IW01.OP0IWCM2 = "RDED";
    COMMAREA.CAMSG = OP0IW01.OP0IWCWM;
    OP0IW01.OP0IWLDE = "Y"; /* lost demand fatal error*/
    TA1REC.TA1FUNC = "POST";
    TA1REC.TA1LOCAT[3] = "OP04";
    TA1REC.TA1LOCAT[4] = OSEREC.OSERETN;
    call "TA0020" (TA1REC, ERRSQLCA) {isNoRefresh = yes, isExternal = yes};

  end







   /* ***********************************************************/
end // end OP0ISEO

// lost demand edit/write
Function OP0ISEW()


  TA1REC.TA1LOCAT[2] = "OP0ISEW";

  OP0ISEB(); /* build record to pass for edit*/

  OSEREC.OSETASK = "03"; /* quantity edits*/

  OSEREC.OSERETN = "00";

  call "OP04" (OSEREC) {isNoRefresh = yes}; /* lost demand edit subprogram*/



  if (OSEREC.OSERETN == "00")
    if (OSEERRFL == "N") /* no errors*/
      OP0ISWR(); /* write lost demand*/
    else
      OP0ISYM(); /* set error message*/
    end
  else
    converseLib.validationFailed(536); /* lost demand not recorded*/
    OP0IW01.OP0IWCWM = " "; /* move msg to commarea message*/
    OP0IW01.OP0IWCM1 = "LOST DEMAND NOT RECO";
    OP0IW01.OP0IWCM2 = "RDED";
    COMMAREA.CAMSG = OP0IW01.OP0IWCWM;
    OP0IW01.OP0IWLDE = "Y"; /* lost demand fatal error*/
    TA1REC.TA1FUNC = "POST";
    TA1REC.TA1LOCAT[3] = "OP04";
    TA1REC.TA1LOCAT[4] = OSEREC.OSERETN;
    call "TA0020" (TA1REC, ERRSQLCA) {isNoRefresh = yes, isExternal = yes};

  end



   /* ***********************************************************/
end // end OP0ISEW

// get at-once availability
Function OP0ISG1()

   /* **************************************************/
   /* availability processing for at-once order types*/

   /* note: av5rec is avail header*/
        /* av6rec is avail qty's*/

   /* 1. build the header record key using the*/
      /* season begin date if it's apparel else*/
      /* use 0.*/

   /* 2. read the header.*/
      /* if no header rec is found move 'u/a' to all condition*/
      /* code buckets in the w/s array.*/

      /* if a header rec is found and the size is active*/
         /* or could be active*/
         /* if the condition code on the hdr = 01(avail at once)*/
            /* move 'a/o' to all cond code bkts in the w/s array*/
            /* if the cond code on the hdr = 02(booking date) or*/
              /* 04(open booking) move the hdr rec cond code date*/
              /* to cond code bkts in the w/s array*/
            /* otherwise use the hdr rec cond code to read the*/
            /* cond code table and move the tables cond code to*/
            /* cond code bkts in the w/s array.*/

   /* 3. build the key to the qty rec looking for f type rec's.*/

   /* 4. read the qty record.*/
      /* if a qty rec is found and the size is active or could be*/
         /* active, move the qty from the qty rec to the qty bkt*/
         /* in the w/s array*/
      /* otherwise move a msg 'no avail rec' to the map.*/

   /* 5. now add 1 to the need date and read the qty rec for*/
      /* p type recs.*/

      /* for each p rec found*/
          /* loop thru the w/s array looking for w/s qty bkts*/
          /* that still show 0 qty. if the qty rec for that size*/
          /* shows qty avail move it to the w/s array qty bkt.*/
          /* also move the period date from the qty rec to the*/
          /* cond code bkt in the w/s array.*/

      /* if no p rec types are found move 'u/a' to all w/s array*/
      /* bkts still showing 0 qtys.*/



   /* ***********************************************************/


  set SQLCA empty;
  set AV5REC empty; /* ; initialize hdr record*/

  AV5REC.XWHCD = OPWREC.XWHCD[OP0IWSBS]; /* build hdr rec key*/
  AV5REC.XGPCD = OP1REC.XGPCD;
  AV5REC.SY1STNBR = OPWREC.SY1STNBR[OP0IWSBP];
  AV5REC.SY2CLRID = OPWREC.SY2CLRID[OP0IWSBP];
  AV5REC.XDMCD = OPWREC.XDMCD[OP0IWSBP];
  AV5REC.XQACD = OPWREC.XQACD[OP0IWSBP];
  if (OP0IM001.XOWCD == " ")
    AV5REC.XOWCD = "00";
  else
    AV5REC.XOWCD = OP0IM001.XOWCD;
  end
  AV5REC.XSDCD = OPWREC.PC2INSEG[OP0IWSBP];
  AV5REC.XSACD = "000";
  AV5REC.XPGCD = OPWREC.XPGCD[OP0IWSBP];
  AV5REC.XUMCD = OPWREC.XUMCD[OP0IWSBP];
  AV5REC.AV5RECTY = " ";
  AV5REC.AV4PRDBD = 0;

  call "IO2310" ("S ", SQLCA, AV5REC) {isNoRefresh = yes, isExternal = yes}; /* select hdr record*/

  if (SQLCA.VAGen_SQLCODE == 0) /* ; good return*/
    OP0IW01.OP0IWHAR = "Y"; /* ; Have an Avail Record*/
    set OP0IM001.OP3ONOQT[1] cursor;
     /* MOVE AV5REC.AV2CMNT TO OP0IM001.AV2CMNT;*/
  else
    if (SQLCA.VAGen_SQLCODE == 100) /* ; record not found*/
      OP0IW01.OP0IWHAR = "N"; /* ; Have an Avail Record*/
      OPAREC.OPASUB = 1;
      while (OPAREC.OPASUB <= 40)
        if (OP0IW01.OP0IWAVA[OPASUB] == " ")
          OP0IW01.OP0IWAVA[OPASUB] = "U/A";
        end
        OPAREC.OPASUB = OPAREC.OPASUB + 1;
      end
    else
      TA1REC.TA1LOCAT[1] = "S       ";
      TA1REC.TA1LOCAT[2] = "OP0ISG1 ";
      TA1REC.TA1LOCAT[3] = "IO2310  ";
      TA1REC.TA1LOCAT[4] = "        ";
      TA1REC.TA1MAP = "OP0IM001";
      TA1REC.TA1DBASE = "DAVAIL  ";
      TA1REC.TA1TBLVU = "VAVHDR01";
      TA1REC.TA1TBLKE = AV5REC.AV5KEY;
      XSOPS02(); /* ; abort*/
    end
  end



  if (SQLCA.VAGen_SQLCODE == 0) /* good return code*/
    OPAREC.OPASUB = 0; /* ; re-set subscript*/
    while (OPAREC.OPASUB < 40) /* ; for all 40 sizes*/
      OPAREC.OPASUB = OPAREC.OPASUB + 1;
      if (OP3REC.OP3SZAFL[OPASUB] == "Y" /* if size is active*/
       || OP3REC.OP3SZAFL[OPASUB] == "V") /* or could be activated*/
        if (AV5REC.XCDCD[OPASUB] == "01") /* avail at once*/
          OP0IW01.OP0IWAVA[OPASUB] = "A/O";
        else
          if (OP3REC.OP3SZAFL[OPASUB] == "Y" /* size active*/
           || OP3REC.OP3SZAFL[OPASUB] == "V")
            if (AV5REC.XCDCD[OPASUB] == "02" /* if booking date*/
             || AV5REC.XCDCD[OPASUB] == "04") /* or open booking*/
              OPAREC.OPAWDT = AV5REC.AV5CDDT[OPASUB];
              OP0IW01.OP0IWPMM = OPAREC.OPAWMM;
              OP0IW01.OP0IWPDD = OPAREC.OPAWDD;
              OP0IW01.OP0IWS04 = "/";
              OP0IW01.OP0IWAVA[OPASUB] = OP0IW01.OP0IWPOF;
              OP0IW01.OP0IWDTN[OPASUB] = AV5REC.AV5CDDT[OPASUB];
            else
              if (AV5REC.XCDCD[OPASUB] in XCDTBL.XCDCD)
                OP0IW01.OP0IWAVA[OPASUB] = XCDTBL.XCDABRV[sysVar.arrayIndex];
              else
                OP0IW01.OP0IWAVA[OPASUB] = AV5REC.XCDCD[OPASUB];
              end
            end
          else
            OP0IW01.OP0IWAVA[OPASUB] = "U/A";
          end
        end
      end
    end
  end


  set AV6REC empty; /* ; initialize qty record*/
  AV6REC.AV6KEY = AV5REC.AV5KEY;
  set SQLCA empty;
  if (OP0IW01.OP0IWHAR == "Y")
    if (AV5REC.AV5FQTY == "Y")

      AV6REC.AV6RECTY = "F";

      call "IO2320" ("S ", SQLCA, AV6REC) {isNoRefresh = yes, isExternal = yes}; /* select qty record*/

      if (SQLCA.VAGen_SQLCODE == 0) /* ; good return*/
        OP0IW01.OP0IWHAR = "Y"; /* ; Have an Avail Record*/
        set OP0IM001.OP3ONOQT[1] cursor;
        OPAREC.OPASUB = 1;
        while (OPAREC.OPASUB <= 40)
          if (OP3REC.OP3SZAFL[OPASUB] == "Y" /* active*/
           || OP3REC.OP3SZAFL[OPASUB] == "V") /* could be active*/
            OP0IW01.OP0IWAVQ[OPASUB] = AV6REC.AV1AVQTY[OPASUB];
          end
          OPAREC.OPASUB = OPAREC.OPASUB + 1;
        end
      else
        if (SQLCA.VAGen_SQLCODE == 100) /* ; record not found*/
          converseLib.validationFailed(150);
          OP0IW01.OP0IWALO = "N"; /* can't allocate*/
          OP0IW01.OP0IWHAR = "N"; /* no avail record*/
          set OP0IM001.OP0IMNDT modified, bold;
          set OP0IM001.XWHCD cursor, modified, bold;
          set OP0IM001.XOWCD modified, bold;
          return;
        else
          TA1REC.TA1LOCAT[1] = "S       ";
          TA1REC.TA1LOCAT[2] = "OP0ISG1 ";
          TA1REC.TA1LOCAT[3] = "IO2320  ";
          TA1REC.TA1LOCAT[4] = "        ";
          TA1REC.TA1MAP = "OP0IM001";
          TA1REC.TA1DBASE = "DAVAIL  ";
          TA1REC.TA1TBLVU = "VAVHDR01";
          TA1REC.TA1TBLKE = AV6REC.AV6KEY;
          XSOPS02(); /* ; abort*/
        end
      end
    else
      converseLib.validationFailed(150);
      OP0IW01.OP0IWALO = "N"; /* can't allocate*/
      OP0IW01.OP0IWHAR = "N"; /* no avail record*/
      set OP0IM001.OP0IMNDT modified, bold;
      set OP0IM001.XWHCD cursor, modified, bold;
      set OP0IM001.XOWCD modified, bold;
      return;
    end
  end



   /* pharwo - use date routine - ta0040*/
   /* ADD 1 TO day to get avail from need date out*/
  OP0IW04.OP0IWLDT = OPWREC.OP1CUNDT[OP0IWSBS] + 1;
  AV6REC.AV6RECTY = "P";

  OP0IW04.OP0IWTSK = "SS";
  OP0IW04.OP0IWHDT = 99999999; /* ; set low-high date ranges*/

  call "IO2320" (OP0IW04, SQLCA, AV6REC) {isNoRefresh = yes, isExternal = yes}; /* select qty records*/

  if (SQLCA.VAGen_SQLCODE == 0) /* ; good return*/
    OP0IW01.OP0IWASZ = 0; /* init array size*/
    OP0IW01.OP0IWHAR = "Y"; /* ; Have an Avail Record*/
    if (OP1REC.XGPCD == "03"
     && XOTTBL.XOTFUTRF[OP0IWSBO] == "N")
      OP0ISGB();
    else
      OP0ISG6(); /* ; fill avail qty array*/
    end
    set OP0IM001.OP3ONOQT[1] cursor;
  else
    if (SQLCA.VAGen_SQLCODE == 100) /* ; record not found*/
      OPAREC.OPASUB = 1;
      while (OPASUB <= 40)
        if (OP0IW01.OP0IWAVA[OPASUB] == " ")
          OP0IW01.OP0IWAVA[OPASUB] = "U/A";
        end
        OPAREC.OPASUB = OPAREC.OPASUB + 1;
      end
    else
      TA1REC.TA1LOCAT[1] = "S       ";
      TA1REC.TA1LOCAT[2] = "OP0ISG1 ";
      TA1REC.TA1LOCAT[3] = "IO2320  ";
      TA1REC.TA1LOCAT[4] = "        ";
      TA1REC.TA1MAP = "OP0IM001";
      TA1REC.TA1DBASE = "DAVAIL  ";
      TA1REC.TA1TBLVU = "VAVQTY01";
      TA1REC.TA1TBLKE = AV6REC.AV6KEY;
      XSOPS02(); /* ; abort*/
    end
  end

  OP0IW04.OP0IWTSK = "CS";
  call "IO2320" (OP0IW04, SQLCA, AV6REC) {isNoRefresh = yes, isExternal = yes};
  if (SQLCA.VAGen_SQLCODE != 0)
    TA1REC.TA1LOCAT[1] = "CS      ";
    TA1REC.TA1LOCAT[2] = "OP0ISG1 ";
    TA1REC.TA1LOCAT[3] = "IO2320  ";
    TA1REC.TA1LOCAT[4] = "        ";
    TA1REC.TA1MAP = "OP0IM001";
    TA1REC.TA1DBASE = "DAVAIL  ";
    TA1REC.TA1TBLVU = "VAVQTY01";
    TA1REC.TA1TBLKE = AV6REC.AV6KEY;
    XSOPS02(); /* ; abort*/
  end

   /* *************************************************************/
                                  /* **/
      /* the following statments are used to get the comments   **/
      /* from the availability header record only.  for apparel,**/
      /* if there are no comments on the header record using    **/
      /* the working storage season begin date, get the header  **/
      /* again using the current season begin date.  if there   **/
      /* are no comments on this record, there are no comments  **/
      /* for this style.  continue processing.                  **/
                                  /* **/
   /* *************************************************************/

  AV5REC.AV5KEY = AV6REC.AV6KEY; /* qty key to hdr key*/
  AV5REC.AV5RECTY = " ";
  AV5REC.AV4PRDBD = 0;

  call "IO2310" ("S ", SQLCA, AV5REC) {isNoRefresh = yes, isExternal = yes}; /* select hdr rec*/

  if (SQLCA.VAGen_SQLCODE == 0)
    if (AV5REC.XGPCD == "03") /* apparel*/
      if (AV5REC.AV2CMNT > " ") /* hdr with comments found*/
        OP0IM001.AV2CMNT = AV5REC.AV2CMNT;
      else /* try again with current season bdt*/
        OPAREC.OPASUB1 = 1;
        OP0IW01.OP0IWFND = "N";
        while (XSNTBL.XSECD[OPASUB1] != "99" /* while not end of table*/
         && XSNTBL.XSNYR[OPASUB1] != 9999 
         && OP0IW01.OP0IWFND == "N") /* and record not found yet*/
          if (OPAREC.OPACDT >= XSNTBL.XSNBDT[OPASUB1]
           && OPAREC.OPACDT <= XSNTBL.XSNXDT[OPASUB1]
           && XSNTBL.XXXSTAT[OPASUB1] == "A")
            OP0IW01.OP0IWFND = "Y";
            OP0IW01.OP0IWSBD = XSNTBL.XSNBDT[OPASUB1];
          else
            OPAREC.OPASUB1 = OPAREC.OPASUB1 + 1;
          end
        end

        AV5REC.AV4PRDBD = 0; /* season begin date*/

        call "IO2310" ("S ", SQLCA, AV5REC) {isNoRefresh = yes, isExternal = yes}; /* select hdr rec*/

        if (SQLCA.VAGen_SQLCODE == 0)
          OP0IM001.AV2CMNT = AV5REC.AV2CMNT;
        end
      end
    else
      OP0IM001.AV2CMNT = AV5REC.AV2CMNT;
    end

  end




end // end OP0ISG1

// futures or apparel adv-prop
Function OP0ISG4()

   /* *************************************************/
   /* availability processing for futures and*/
   /* apparel advanced prop order types*/

   /* note: w/s array has 40 size buckets*/

   /* 1. build the key for the qty record looking*/
      /* for n and p type*/
      /* using a high and low date range.*/

   /* 2. if a qty record is found, add all the qty's by size*/
      /* for all the recs found and load then in the w/s array*/

   /* example::*/

                     /* sz5       sz5.5      sz6      sz6.5*/

   /* n rec type         2         3          0         0*/
   /* p rec type         1         2          6         0*/

   /* w/s avail qty      3         5          6         0*/

   /* 3. now move avail month and day*/
      /* if the array shows avail qty*/
      /* else*/
      /* move u/a (unavailable) if array shows 0 qty*/

   /* example::*/

                     /* sz5       sz5.5      sz6      sz6.5*/

   /* n rec type         2         3          0         0*/
   /* p rec type         1         2          6         0*/

   /* w/s avail qty      3         5          6         0*/
   /* w/s avail dt      date      date       date       u/a*/

   /* 4. if there are still array buckets with 0 avail qtys*/
      /* add 1 to the need date and the reset the low date*/
      /* range to the new need date. now reread the qty record*/
      /* with the new date ranges for p type recs only.*/

      /* for each qty rec found loop thru the sizes. if the array*/
      /* shows 0 qty for that size but the qty rec shows qty*/
      /* move the qty from the qty rec and the period date from*/
      /* the qty rec to the w/s array.*/

   /* 5. if the w/s array is still not full set up the key*/
      /* and read the header record for that product.*/
      /* using the condition code in the header record read*/
      /* the condition code table and move the abbreviation*/
      /* (a/o,s/o) to the condition code in the w/s array*/
      /* for that size.*/

   /* ********************************************************/

  set AV6REC empty; /* ; initialize qty record*/
  set OP0IW04 empty; /* ; initialize w.s. date range*/

   /* build the qty rec key*/

  AV6REC.XWHCD = OPWREC.XWHCD[OP0IWSBS];

     /* for apparel direct ship use warehouse 51*/

  if (XOTTBL.XOTDSAVL[OP0IWSBO] == "Y" /* display availability*/
   && OP1REC.XDSCD == "1"              /* direct ship*/
   && OP1REC.XGPCD == "03")            /* apparel*/
    AV6REC.XWHCD = "51"; /* use whse 51 for product avail*/
  end


  if (SYCREC.XPRCD == "22") /* if a crested product*/
    AV6REC.SY1STNBR = SYCREC.SY1BSTNB; /* use the blank style*/
    AV6REC.SY2CLRID = SYCREC.SY2BCLCD; /* and the blank color*/
    if (OP1REC.XDSCD == "1") /* if a crested direct ship*/
      AV6REC.XWHCD = "51"; /* default warehouse to '51'*/
    end
  else
    AV6REC.SY1STNBR = OPWREC.SY1STNBR[OP0IWSBP];
                                   /* use regular style*/
    AV6REC.SY2CLRID = OPWREC.SY2CLRID[OP0IWSBP];
  end

  AV6REC.XDMCD = OPWREC.XDMCD[OP0IWSBP];

  AV6REC.XGPCD = OP1REC.XGPCD;

  AV6REC.XQACD = OPWREC.XQACD[OP0IWSBP];
  if (OP0IM001.XOWCD == " ")
    AV6REC.XOWCD = "00";
  else
    AV6REC.XOWCD = OP0IM001.XOWCD;
  end
  AV6REC.XSDCD = OPWREC.PC2INSEG[OP0IWSBP];
  AV6REC.XSACD = "000";
  AV6REC.XPGCD = OPWREC.XPGCD[OP0IWSBP];
  AV6REC.XUMCD = OPWREC.XUMCD[OP0IWSBP];
  AV6REC.AV6RECTY = "$"; /* get's 'n' and 'p' rec types*/

  OP0IW04.OP0IWTSK = "SS";

   /* if this is apparel and the current date is > the*/
     /* season begin date set low search values to 0 and*/
     /* high search values to the need date*/
   /* else*/
     /* set low search values to season begin date*/
     /* and high search values to need date*/

  if (OP1REC.XGPCD == "03") /* if apparel*/
    OPAREC.OPAWDT = OP0IW01.OP0IWSBD; /* season begin date to w/s*/
    if (OPAREC.OPACDT > OPAREC.OPAWDT) /* current > season*/
      OP0IW04.OP0IWLDT = 0; /* ; set low-high date ranges*/
      OP0IW04.OP0IWHDT = OPWREC.OP1CUNDT[OP0IWSBS];
                                   /* needdate to high*/
    else
      OP0IW04.OP0IWLDT = 0; /* season begin date to low*/
      OP0IW04.OP0IWHDT = OPWREC.OP1CUNDT[OP0IWSBS];
    end
  else
    OP0IW04.OP0IWLDT = 0; /* ; set low-high date ranges*/
    OP0IW04.OP0IWHDT = OPWREC.OP1CUNDT[OP0IWSBS]; /* needdate to high*/
  end

  call "IO2320" (OP0IW04, SQLCA, AV6REC) {isNoRefresh = yes, isExternal = yes}; /* select qty records*/

  if (SQLCA.VAGen_SQLCODE == 0) /* ; good return*/
    OP0IW01.OP0IWASZ = 0; /* init array size*/
     /* sum all avail qty's by size that fall*/
     /* within the high and low parms*/
    OP0ISG5(); /* sum qty's*/
    OP0IW01.OP0IWHAR = "Y"; /* ; Have an Avail Record*/
    OPAREC.OPASUB = 1;
    while (OPASUB <= 40) /* all 40 sizes*/
      if (OP0IW01.OP0IWAVQ[OPASUB] > 0) /* avail qty > 0*/
             /* need date to last avai*/
        OP0IW01.OP0IWDTN[OPASUB] = OPWREC.OP1CUNDT[OP0IWSBS];
        OP0IW01.OP0IWETN = OPWREC.OP1CUNDT[OP0IWSBS]; /* need date to w/s*/
        OP0IW01.OP0IWAEC = "/";
        OP0IW01.OP0IWAEM = OP0IW01.OP0IWNMN; /* w/s month to edited*/
        OP0IW01.OP0IWAEY = OP0IW01.OP0IWNDY;
        OP0IW01.OP0IWAVA[OPASUB] = OP0IW01.OP0IWAED;
      else
        OP0IW01.OP0IWAVA[OPASUB] = "U/A";
      end
      OPAREC.OPASUB = OPAREC.OPASUB + 1;
    end
  else
    if (SQLCA.VAGen_SQLCODE != 100)
      TA1REC.TA1LOCAT[1] = "S       ";
      TA1REC.TA1LOCAT[2] = "OP0ISG4 ";
      TA1REC.TA1LOCAT[3] = "IO2320  ";
      TA1REC.TA1LOCAT[4] = "        ";
      TA1REC.TA1MAP = "OP0IM001";
      TA1REC.TA1DBASE = "DAVAIL  ";
      TA1REC.TA1TBLVU = "VAVQTY01";
      TA1REC.TA1TBLKE = AV6REC.AV6KEY;
      XSOPS02(); /* ; abort*/
    end
  end

  OP0IW04.OP0IWTSK = "CS";
  call "IO2320" (OP0IW04, SQLCA, AV6REC) {isNoRefresh = yes, isExternal = yes};
  if (SQLCA.VAGen_SQLCODE != 0)
    TA1REC.TA1LOCAT[1] = "CS      ";
    TA1REC.TA1LOCAT[2] = "OP0ISG4 ";
    TA1REC.TA1LOCAT[3] = "IO2320  ";
    TA1REC.TA1LOCAT[4] = "        ";
    TA1REC.TA1MAP = "OP0IM001";
    TA1REC.TA1DBASE = "DAVAIL  ";
    TA1REC.TA1TBLVU = "VAVQTY01";
    TA1REC.TA1TBLKE = AV6REC.AV6KEY;
    XSOPS02(); /* ; abort*/
  end

   /* ADD 1 TO day to get avail from need date out*/
   /* to fill in sizes that still have avail qty of 0 in array*/

   /* reset high/low values get p rec type*/

  AV6REC.AV6RECTY = "P";
  OP0IW04.OP0IWTSK = "SS";
  OP0IW04.OP0IWLDT = OPWREC.OP1CUNDT[OP0IWSBS] + 1;
  OP0IW04.OP0IWHDT = 99999999; /* ; set low-high date ranges*/

  call "IO2320" (OP0IW04, SQLCA, AV6REC) {isNoRefresh = yes, isExternal = yes}; /* select qty records*/

  if (SQLCA.VAGen_SQLCODE == 0) /* more rec's found*/
    OP0IW01.OP0IWASZ = 0; /* init array size*/
    OP0IW01.OP0IWHAR = "Y"; /* Have an Avail Record*/
    set AV5REC empty;
    AV5REC.AV5KEY = AV6REC.AV6KEY; /* qty key to hdr key*/
    if (OP1REC.XGPCD == "03" /* apparel*/
     || OP1REC.XOCCD == "GF") /* golf product*/
      OP0ISGB(); /* determine header*/
    else /* footwear and other*/
      OP0ISG6(); /* fill  availablility qty array*/
      OP0ISGE(); /* reads availablility hdr*/
      if (SQLCA.VAGen_SQLCODE == 0) /* hdr rec found*/
        OP0ISGF(); /* determine cond cd to be displayed*/
      end
    end
    set OP0IM001.OP3ONOQT[1] cursor;
  end

  OP0ISGG(); /* close set for hdrs*/


   /* *************************************************************/
                                  /* **/
      /* read the availability header record and get the        **/
      /* condition code. move the abbreviation to the the       **/
      /* ws array for the size. 8/03/89 rmd                     **/
                                  /* **/
   /* *************************************************************/

  AV5REC.AV5KEY = AV6REC.AV6KEY; /* qty key to hdr key*/
  AV5REC.AV5RECTY = " ";
  AV5REC.AV4PRDBD = 0;

  call "IO2310" ("S ", SQLCA, AV5REC) {isNoRefresh = yes, isExternal = yes}; /* select hdr rec*/

   /* get condition codes from availability header*/

  if (SQLCA.VAGen_SQLCODE == 0)
    OPAREC.OPASUB = 0;
    while (OPASUB < 40)
      OPAREC.OPASUB = OPAREC.OPASUB + 1;
      if (OP0IW01.OP0IWAVQ[OPASUB] == 0)
        if (OP3REC.OP3SZAFL[OPASUB] == "Y"
         || OP3REC.OP3SZAFL[OPASUB] == "V")
           /* if no av-hdr date, use the cd tbl, else use the hdr dt*/
          if (AV5REC.AV5CDDT[OPASUB] == 0)
            if (AV5REC.XCDCD[OPASUB] in XCDTBL.XCDCD) /* cond code in tbl*/
              OP0IW01.OP0IWAVA[OPASUB] = XCDTBL.XCDABRV[sysVar.arrayIndex];
            else
              OP0IW01.OP0IWAVA[OPASUB] = AV5REC.XCDCD[OPASUB];
            end
          else
            OPAREC.OPAWDT = AV5REC.AV5CDDT[OPASUB];
            OP0IW01.OP0IWAEM = OPAREC.OPAWMM;
            OP0IW01.OP0IWAEY = OPAREC.OPAWDD;
            OP0IW01.OP0IWAEC = "/";
          end
        end
      end
    end
    OP0ISGH(); /* now get the comments from the header*/
                                   /* 8/03/89 rmd*/
  else
    OP0IW01.OP0IWAVA = "U/A";
  end


end // end OP0ISG4

// move availibility
Function OP0ISG5()

  OP0IW04.OP0IWTSK = "SN";


  while (SQLCA.VAGen_SQLCODE == 0)
    call "IO2320" (OP0IW04, SQLCA, AV6REC) {isNoRefresh = yes, isExternal = yes};
    if (SQLCA.VAGen_SQLCODE == 0)
      OP0IW01.OP0IWFIL = 0;
      OPAREC.OPASUB = 1; /* init array sub*/
      while (OPAREC.OPASUB <= 40)
        if (OP3REC.OP3SZAFL[OPASUB] == "Y" /* active*/
         || OP3REC.OP3SZAFL[OPASUB] == "V") /* could be active*/
          if (AV6REC.AV1AVQTY[OPASUB] > 0)
            OP0IWAVQ[OPASUB] = OP0IW01.OP0IWAVQ[OPASUB] +             AV6REC.AV1AVQTY[OPASUB];
            OP0IW01.OP0IWFIL = OP0IW01.OP0IWFIL + 1;
          end
        end
        OPAREC.OPASUB = OPAREC.OPASUB + 1;
      end
    else
      if (OPAREC.OPASUB > 40)
        OPAREC.OPASUB = 40;
      end
    end
  end




end // end OP0ISG5

// fill avail qty array
Function OP0ISG6()

  OP0IW04.OP0IWTSK = "SN";

  while (SQLCA.VAGen_SQLCODE == 0
   && OP0IW01.OP0IWFIL <= 40)

    call "IO2320" (OP0IW04, SQLCA, AV6REC) {isNoRefresh = yes, isExternal = yes};

    if (SQLCA.VAGen_SQLCODE == 0)
      OPAREC.OPASUB = 1; /* init array sub*/
      while (OPAREC.OPASUB <= 40)
        if (OP3REC.OP3SZAFL[OPASUB] == "Y" /* active*/
         || OP3REC.OP3SZAFL[OPASUB] == "V") /* could be active*/
          if (OP0IW01.OP0IWAVQ[OPASUB] == 0)
            if (AV6REC.AV1AVQTY[OPASUB] > 0)
              OP0IW01.OP0IWAVQ[OPASUB] = AV6REC.AV1AVQTY[OPASUB];
              OP0IW01.OP0IWETN = AV6REC.AV6PRDDT;
              OP0IW01.OP0IWDTN[OPASUB] = AV6REC.AV6PRDDT;
              OP0IW01.OP0IWAEM = OP0IW01.OP0IWNMN; /* Use Rec Month*/
              OP0IW01.OP0IWAEY = OP0IW01.OP0IWNDY; /* Use Rec Day*/
              OP0IW01.OP0IWAEC = "/";
              OP0IW01.OP0IWAVA[OPASUB] = OP0IW01.OP0IWAED;
              OP0IW01.OP0IWFIL = OP0IW01.OP0IWFIL + 1;
            end
          end
        end
        OPAREC.OPASUB = OPAREC.OPASUB + 1;
      end
    else
      if (OPAREC.OPASUB > 40)
        OPAREC.OPASUB = 40;
      end
    end
  end



end // end OP0ISG6

// get availability for style
Function OP0ISGA()

  /* disable need date calc for crested prods as per Linda R. March '94*/

  /* IF SYCREC.XPRCD EQ '22';        /* if crested product*/
  /* OP0IS-CALC-NEED-DT;           /* edit need date - must be 30 days out*/
  /* END;*/

  if (OPWREC.OP1CUNDT[OP0IWSBS] == OPAREC.OPACDT)
    OP0IW01.OP0IWPND = "N"; /* n - need date is today*/
    OP0IW01.OP0IWALO = "Y"; /* y - can allocate*/
  else
    OP0IW01.OP0IWPND = "Y"; /* y - need date is pushed*/
    OP0IW01.OP0IWALO = "N"; /* n - cannot allocate*/
  end


    /* next see if order type says display availability*/
    /* or if the order class is golf*/

  if (XOTTBL.XOTDSAVL[OP0IWSBO] == "Y" /* display availability*/
   || OP1REC.XOCCD == "GF")            /* golf product*/
    if (OP0IW01.OP0IWBDF == "BC" /* if bulk order*/
     || OP0IW01.OP0IWBDF == "BS" 
     || OP0IW01.OP0IWBDF == "BX" 
     || OP0IW01.OP0IWBDF == "BN" 
     || OP0IW01.OP0IWBDF == "BB" /* if blank bulk*/
     || OP0IW01.OP0IWBDF == " ") /* or regular order*/
      OP0IW01.OP0IWDAV = "Y"; /* set ws disp avail flag*/
      OP0IM001.OP0IMLPO[1] = "COND CD:"; /* set up map line label*/
      OP0IM001.OP0IMLPO[2] = "COND CD:";
    else
      if (OP0IW01.OP0IWBDF == "DN" /* if nike draw*/
       || OP0IW01.OP0IWBDF == "DS") /* if smart draw*/
        OP0IW01.OP0IWDAV = "S"; /* set to allocate smart draw*/
      else
        OP0IW01.OP0IWALO = "N";
        OP0IW01.OP0IWDAV = "N";
        OP0IM001.OP0IMLPO[1] = "PRC OVRD"; /* set up map line label*/
        OP0IM001.OP0IMLPO[2] = "PRC OVRD";
        return;
      end
    end
  else
    if (XOTTBL.XOTDSAVL[OP0IWSBO] == "A"
     && OP0IW01.OP0IWPAO == "Y")
      if (OP0IW01.OP0IWBDF == "BC" /* if bulk order*/
       || OP0IW01.OP0IWBDF == "BS" 
       || OP0IW01.OP0IWBDF == "BX" 
       || OP0IW01.OP0IWBDF == "BN" 
       || OP0IW01.OP0IWBDF == "BB" /* if blank bulk*/
       || OP0IW01.OP0IWBDF == " ")
        OP0IW01.OP0IWDAV = "Y"; /* set ws disp avail flag*/
        OP0IM001.OP0IMLPO[1] = "COND CD:"; /* set up map line label*/
        OP0IM001.OP0IMLPO[2] = "COND CD:";
      else
        if (OP0IW01.OP0IWBDF == "DN" /* if nike  draw*/
         || OP0IW01.OP0IWBDF == "DS") /* if smart draw*/
          OP0IW01.OP0IWDAV = "S"; /* set to alocate if at-once*/
        else
          OP0IW01.OP0IWALO = "N";
          OP0IW01.OP0IWDAV = "N";
          OP0IM001.OP0IMLPO[1] = "PRC OVRD"; /* set up map line label*/
          OP0IM001.OP0IMLPO[2] = "PRC OVRD";
          return;
        end
      end
    else
      OP0IW01.OP0IWALO = "N";
      OP0IW01.OP0IWDAV = "N";
      OP0IM001.OP0IMLPO[1] = "PRC OVRD"; /* set up map line label*/
      OP0IM001.OP0IMLPO[2] = "PRC OVRD";
      return;
    end
  end


    /* next start setting up the availability key.*/

    /* get parent warehouse.*/

  AV5REC.XWHCD = OPWREC.XWHCD[OP0IWSBS];


     /* for apparel direct ship use warehouse 51*/

  if (XOTTBL.XOTDSAVL[OP0IWSBO] == "Y" /* display availability*/
   && OP1REC.XDSCD == "1"              /* direct ship*/
   && OP1REC.XGPCD == "03")            /* apparel*/
    AV5REC.XWHCD = "51"; /* use whse 51 for product avail*/
  end



    /* next get current life cycle for the product.*/

  OP0ISGL(); /* get life cycle*/




    /* for apparel, in-line, first quality - get season info.*/


  OP0IW01.OP0IWFND = "N";

  if (OP1REC.XGPCD == "03"  /* if apparel*/
   && OP0IW01.XLCCD == "10" /* and 'in-line'*/
   && OPWREC.XQACD[OP0IWSBP] == "01") /* and first quality*/
    OPAREC.OPASUB = 1;
    while (XSNTBL.XSECD[OPASUB] != "99" /* while not end of table*/
     && XSNTBL.XSNYR[OPASUB] != 9999 
     && OP0IW01.OP0IWFND == "N") /* and record not found yet*/
      if (OPWREC.OP1CUNDT[OP0IWSBS] >= XSNTBL.XSNBDT[OPASUB]
       && OPWREC.OP1CUNDT[OP0IWSBS] <= XSNTBL.XSNXDT[OPASUB]
       && XSNTBL.XXXSTAT[OPASUB] == "A")
        OP0IW01.OP0IWFND = "Y";
      else
        OPAREC.OPASUB = OPAREC.OPASUB + 1;
      end
    end
  end


  /*  */
  /*  */
  if (OP0IW01.OP0IWFND == "Y")
    OP0IW01.OP0IWSBD = XSNTBL.XSNBDT[OPASUB];
  end

  OPAREC.OPASUB = 1;
  while (OPASUB < 41)
    OP0IW01.OP0IWDTN[OPASUB] = 0;
    OP0IW01.OP0IWAVA[OPASUB] = " ";
    OP0IW01.OP0IWAVQ[OPASUB] = 0;
    OPAREC.OPASUB = OPAREC.OPASUB + 1;
  end

  if (XOTTBL.XOTATONF[OP0IWSBO] == "Y") /* at once order type*/
    OP0ISG1();
  else
    if (XOTTBL.XOTPROPF[OP0IWSBO] == "Y" /* advance prop*/
     && XOTTBL.XOTATONF[OP0IWSBO] == "N" 
     && OP1REC.XGPCD == "01")            /* instore promo 06/15/89 rmd*/
      OP0ISG1();
    else
      if (XOTTBL.XOTPROPF[OP0IWSBO] == "Y" /* footwear advance prop*/
       && XOTTBL.XOTATONF[OP0IWSBO] == "N" 
       && OP1REC.XGPCD == "02")           
        OP0ISG1();
      else
        if (XOTTBL.XOTPROPF[OP0IWSBO] == "Y"
         && OP1REC.XGPCD == "03") /* apparel advance prop*/
          OP0ISG4(); /* ;*/
        else
          if (XOTTBL.XOTFUTRF[OP0IWSBO] == "Y") /* futures order type*/
            OP0ISG4(); /* ;*/
          end
        end
      end
    end
  end

  if (OP1REC.XBDCD == "2" /* if smart bulk*/
   || OP1REC.XBDCD == "Z" /* or flex bulk*/
   || OP1REC.XBDCD == "B") /* or blank bulk*/
    OP0IW01.OP0IWDAV = "N"; /* no to display availability flag*/
  else
    if (XOTTBL.XOTDSAVL[OP0IWSBO] == "Y" /* display availability*/
     && OP1REC.XDSCD == "1"              /* direct ship*/
     && OP1REC.XGPCD == "03")            /* apparel*/
     /* next sentence*/
      if (OP1REC.XDVCD == "02") /* don't disp avail if nil order 10/06/97*/
        OP0IW01.OP0IWDAV = "N"; /* no to display availability flag*/
      end
    else
      if (OP1REC.XDSCD == "1" /* if direct ship*/
       || OP1REC.XDSCD == "2") /* or direct ship*/
        if (SYCREC.XPRCD != "22") /* if not a crested direct ship*/
          OP0IW01.OP0IWDAV = "N"; /* no to display availability flag*/
        end
      end
    end
  end


end // end OP0ISGA

// determine hdr key
Function OP0ISGB()
  OP0IW01.OP0IWCRS = "N"; /* init cross season flag*/

  OP0IW04.OP0IWTSK = "SN";

  while (SQLCA.VAGen_SQLCODE == 0
   && OP0IW01.OP0IWFIL <= 40)

    call "IO2320" (OP0IW04, SQLCA, AV6REC) {isNoRefresh = yes, isExternal = yes};

    if (SQLCA.VAGen_SQLCODE == 0)
      OPAREC.OPASUB = 1; /* init array sub*/
      while (OPAREC.OPASUB <= 40)
        if (OP3REC.OP3SZAFL[OPASUB] == "Y" /* active*/
         || OP3REC.OP3SZAFL[OPASUB] == "V") /* could be active*/
          if (OP0IW01.OP0IWAVQ[OPASUB] == 0
           && AV6REC.AV1AVQTY[OPASUB] > 0)
            if (OP1REC.XOCCD == "GF" /* golf product*/
             && OP1REC.XGPCD == "02") /* and footwear*/
              OP0ISGD(); /* read header with need date*/
            else
              if (AV6REC.AV6PRDDT < OP0IW01.OP0IWSED)
                OP0ISGD(); /* read header with need date*/
              else
                OP0IW01.OP0IWCRS = "Y"; /* CROSSED SEASONS*/
                OP0ISGC(); /* read header with period date*/
              end
            end
            OP0ISGE(); /* reads availability hdr*/
            OP0IW01.OP0IWAVQ[OPASUB] = AV6REC.AV1AVQTY[OPASUB];
            OP0IW01.OP0IWETN = AV6REC.AV6PRDDT;
            OP0IW01.OP0IWDTN[OPASUB] = AV6REC.AV6PRDDT;
            OP0IW01.OP0IWAEM = OP0IW01.OP0IWNMN; /* Use Rec Month*/
            OP0IW01.OP0IWAEY = OP0IW01.OP0IWNDY; /* Use Rec Day*/
            OP0IW01.OP0IWAEC = "/";
            OP0IW01.OP0IWAVA[OPASUB] = OP0IW01.OP0IWAED;
            OP0IW01.OP0IWFIL = OP0IW01.OP0IWFIL + 1;
            if (SQLCA.VAGen_SQLCODE == 0)
              OP0ISGF();
                                   /* determines cond code to be displaye*/
            end
          end
        end
        OPAREC.OPASUB = OPAREC.OPASUB + 1;
      end
    else
      if (OPAREC.OPASUB > 40)
        OPAREC.OPASUB = 40;
      end
    end
  end



end // end OP0ISGB

// read hdr with period date
Function OP0ISGC()
    /* FOR APPAREL, IN-LINE, FIRST QUALITY - GET SEASON INFO.*/


  OP0IW01.OP0IWFND = "N";


  if (OP1REC.XGPCD == "03"  /* if apparel*/
   && OP0IW01.XLCCD == "10" /* and 'in-line'*/
   && OPWREC.XQACD[OP0IWSBP] == "01") /* and first quality*/
    OPAREC.OPASUB1 = 1;
    while (XSNTBL.XSECD[OPASUB1] != "99" /* while not end of table*/
     && XSNTBL.XSNYR[OPASUB1] != 9999 
     && OP0IW01.OP0IWFND == "N") /* and record not found yet*/
      if (AV6REC.AV6PRDDT >= XSNTBL.XSNBDT[OPASUB1]
       && AV6REC.AV6PRDDT <= XSNTBL.XSNXDT[OPASUB1]
       && XSNTBL.XXXSTAT[OPASUB1] == "A")
        OP0IW01.OP0IWFND = "Y";
      else
        OPAREC.OPASUB1 = OPAREC.OPASUB1 + 1;
      end
    end
  end


  if (OP0IW01.OP0IWFND == "Y")
    AV5REC.AV4PRDBD = XSNTBL.XSNBDT[OPASUB1];
    OP0IW01.OP0IWSBD = XSNTBL.XSNBDT[OPASUB1];
  end


end // end OP0ISGC

// read hdr with need date
Function OP0ISGD()
    /* for apparel, in-line, first quality - get season info.*/


  OP0IW01.OP0IWFND = "N";


  if (OP1REC.XGPCD == "03"  /* if apparel*/
   && OP0IW01.XLCCD == "10" /* and 'in-line'*/
   && OPWREC.XQACD[OP0IWSBP] == "01") /* and first quality*/
    OPAREC.OPASUB1 = 1;
    while (XSNTBL.XSECD[OPASUB1] != "99" /* while not end of table*/
     && XSNTBL.XSNYR[OPASUB1] != 9999 
     && OP0IW01.OP0IWFND == "N") /* and record not found yet*/
      if (OP1REC.OP1CUNDT >= XSNTBL.XSNBDT[OPASUB1]
       && OP1REC.OP1CUNDT <= XSNTBL.XSNXDT[OPASUB1]
       && XSNTBL.XXXSTAT[OPASUB1] == "A")
        OP0IW01.OP0IWFND = "Y";
      else
        OPAREC.OPASUB1 = OPAREC.OPASUB1 + 1;
      end
    end
  end


  if (OP0IW01.OP0IWFND == "Y")
    AV5REC.AV4PRDBD = XSNTBL.XSNBDT[OPASUB1];
    OP0IW01.OP0IWSBD = XSNTBL.XSNBDT[OPASUB1];
  end


end // end OP0ISGD

// read hdr rec
Function OP0ISGE()
    /* read hdr record for availability*/

  TA1REC.TA1LOCAT[2] = "OP0ISGE"; /* diag group level*/

  AV5REC.AV5RECTY = " "; /* rec typ always spaces in av hdr*/
                                   /* 6/27/89*/

  AV5REC.AV4PRDBD = 0; /* period begin date always 0*/




  call "IO2310" ("S ", SQLCA, AV5REC) {isNoRefresh = yes, isExternal = yes}; /* select hdr record*/

  if (SQLCA.VAGen_SQLCODE == 0) /* ; good return*/
    OP0IW01.OP0IWHAR = "Y"; /* ; Have an Avail Record*/
  else
    TA1REC.TA1LOCAT[1] = "S       ";
    TA1REC.TA1LOCAT[3] = "IO2310  ";
    TA1REC.TA1LOCAT[4] = "        ";
    TA1REC.TA1DBASE = "DAVAIL  ";
    TA1REC.TA1TBLVU = "VAVHDR01";
    TA1REC.TA1TBLKE = AV5REC.AV5KEY;
    TA1REC.TA1TYPE = "DB2";
    TA1REC.TA1FUNC = "RETN";
    set ERRSQLCA empty;
    move SQLCA to ERRSQLCA withV60Compat;
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.rollback();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
    
    call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
    converseLib.validationFailed(442); /* no avail recs for this prod*/


    exit stack;
  end



end // end OP0ISGE

// determine cond cd for map
Function OP0ISGF()

    /* determines what to display for condition code on screen*/
    /* can be need date, hdr date, cond code from table*/

  TA1REC.TA1LOCAT[2] = "OP0ISGF"; /* diag group name*/


  if (OP0IW01.OP0IWFIL < 40) /* w/s array still not full*/
    if (OP0IW01.OP0IWAVQ[OPASUB] == 0)
       /* if no av-hdr date, use the cd tbl, else use the hdr dt*/
      if (AV5REC.AV5CDDT[OPASUB] == 0)
        if (AV5REC.XCDCD[OPASUB] in XCDTBL.XCDCD) /* cond code in tbl*/
          OP0IW01.OP0IWAVA[OPASUB] = XCDTBL.XCDABRV[sysVar.arrayIndex];
        else
          OP0IW01.OP0IWAVA[OPASUB] = AV5REC.XCDCD[OPASUB];
          OP0IW01.OP0IWFIL = OP0IW01.OP0IWFIL + 1;
        end
      else
        OPAREC.OPAWDT = AV5REC.AV5CDDT[OPASUB];
        OP0IW01.OP0IWPMM = OPAREC.OPAWMM;
        OP0IW01.OP0IWPDD = OPAREC.OPAWDD;
        OP0IW01.OP0IWS04 = "/";
        OP0IW01.OP0IWAVA[OPASUB] = OP0IW01.OP0IWPOF;
      end
    end
  end

end // end OP0ISGF

// close set for hdrs
Function OP0ISGG()

  TA1REC.TA1LOCAT[2] = "OP0ISGG"; /* diag group name*/



   /* close set, all hdr work complete*/

  OP0IW04.OP0IWTSK = "CS";
  call "IO2320" (OP0IW04, SQLCA, AV5REC) {isNoRefresh = yes, isExternal = yes};
  if (SQLCA.VAGen_SQLCODE != 0)
    TA1REC.TA1LOCAT[1] = "CS      ";
    TA1REC.TA1LOCAT[2] = "OP0ISG4 ";
    TA1REC.TA1LOCAT[3] = "IO2320  ";
    TA1REC.TA1LOCAT[4] = "        ";
    TA1REC.TA1MAP = "OP0IM001";
    TA1REC.TA1DBASE = "DAVAIL  ";
    TA1REC.TA1TBLVU = "VAVHDR01";
    TA1REC.TA1TBLKE = AV5REC.AV5KEY;
    XSOPS02(); /* ; abort*/
  end

  OP0IW04.OP0IWTSK = "CS";
  call "IO2320" (OP0IW04, SQLCA, AV6REC) {isNoRefresh = yes, isExternal = yes};
  if (SQLCA.VAGen_SQLCODE != 0
   && SQLCA.VAGen_SQLCODE != -501)
    TA1REC.TA1LOCAT[1] = "CS      ";
    TA1REC.TA1LOCAT[2] = "OP0ISG4 ";
    TA1REC.TA1LOCAT[3] = "IO2320  ";
    TA1REC.TA1LOCAT[4] = "        ";
    TA1REC.TA1MAP = "OP0IM001";
    TA1REC.TA1DBASE = "DAVAIL  ";
    TA1REC.TA1TBLVU = "VAVQTY01";
    TA1REC.TA1TBLKE = AV6REC.AV6KEY;
    XSOPS02(); /* ; abort*/
  end



end // end OP0ISGG

// get comments from avail. hdr
Function OP0ISGH()
   /* *************************************************************/
                                                             /* **/
      /* the following statments are used to get the comments   **/
      /* from the availability header record only.  for apparel,**/
      /* if there are no comments on the header record using    **/
      /* the working storage season begin date, get the header  **/
      /* again using the current season begin date.  if there   **/
      /* are no comments on this record, there are no comments  **/
      /* for this style.  continue processing.                  **/
                                                             /* **/
   /* *************************************************************/

  if (AV5REC.XGPCD == "03") /* apparel*/
    if (AV5REC.AV2CMNT > " ") /* hdr with comments found*/
      OP0IM001.AV2CMNT = AV5REC.AV2CMNT;
    else /* try again with current season bdt*/
      OPAREC.OPASUB1 = 1;
      OP0IW01.OP0IWFND = "N";
      while (XSNTBL.XSECD[OPASUB1] != "99" /* while not end of table*/
       && XSNTBL.XSNYR[OPASUB1] != 9999 
       && OP0IW01.OP0IWFND == "N") /* and record not found yet*/
        if (OPAREC.OPACDT >= XSNTBL.XSNBDT[OPASUB1]
         && OPAREC.OPACDT <= XSNTBL.XSNXDT[OPASUB1]
         && XSNTBL.XXXSTAT[OPASUB1] == "A")
          OP0IW01.OP0IWFND = "Y";
          OP0IW01.OP0IWSBD = XSNTBL.XSNBDT[OPASUB1];
        else
          OPAREC.OPASUB1 = OPAREC.OPASUB1 + 1;
        end
      end

      AV5REC.AV4PRDBD = 0; /* season begin date*/

      call "IO2310" ("S ", SQLCA, AV5REC) {isNoRefresh = yes, isExternal = yes}; /* select hdr rec*/

      if (SQLCA.VAGen_SQLCODE == 0)
        OP0IM001.AV2CMNT = AV5REC.AV2CMNT;
      end
    end
  else
    OP0IM001.AV2CMNT = AV5REC.AV2CMNT;
  end




end // end OP0ISGH

// get current style life cycle
Function OP0ISGL()




    /* this routine gets the most current life cycle for*/
    /* the style being entered.*/



  if (OPAREC.OPACDT >= SYCREC.SY2CEDT1)
    OP0IW01.XLCCD = SYCREC.XLCCD1;
  else
    if (OPAREC.OPACDT >= SYCREC.SY2CEDT2)
      OP0IW01.XLCCD = SYCREC.XLCCD2;
    else
      if (OPAREC.OPACDT >= SYCREC.SY2CEDT3)
        OP0IW01.XLCCD = SYCREC.XLCCD3;
      else
        if (OPAREC.OPACDT >= SYCREC.SY2CEDT4)
          OP0IW01.XLCCD = SYCREC.XLCCD4;
        else
          OP0IW01.XLCCD = " ";
        end
      end
    end
  end




end // end OP0ISGL

// check hot mod eligibility
Function OP0ISHM()
      /* *********************************************************/
      /* *  check to see if this customer is eligible to order*/
      /* *  hot models.*/
      /* *********************************************************/

  TA1REC.TA1LOCAT[1] = "OP0IHOT"; /* error diag data process name*/

  OP0IW01.OP0IWELI = "Y";

  OPZREC.SY1STNBR = OP3REC.SY1STNBR;
  OPZREC.SY2CLRID = OP3REC.SY2CLRID;
  OPZREC.XDMCD = OP3REC.XDMCD;
  OPZREC.XGPCD = OP3REC.XGPCD;

  call "IO3180" ("S ", SQLCA, OPZREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
      /* NEXT SENTENCE*/
  else
    TA1REC.TA1DBASE = "DORDER"; /* data base name*/
    TA1REC.TA1TBLVU = "VHOTSY01"; /* table view*/
    OP0IW01.OP0IWTK3 = OPZREC.SY1STNBR;
    OP0IW01.OP0IWTK4 = OPZREC.SY2CLRID;
    OP0IW01.OP0IWTK5 = OPZREC.XDMCD;
    TA1REC.TA1TBLKE = OP0IW01.OP0IWT1;
    TA1REC.TA1LOCAT[3] = "IO3180"; /* iomod*/
    XSOPS02(); /* standart abend routine*/
  end

  if (OPAREC.OPACDT >= OPZREC.OPZHMBDT
   && OPAREC.OPACDT <= OPZREC.OPZHMEDT)
      /* NEXT SENTENCE*/
  else
    return;
  end
   /* *************************************************/
   /* * call to eligible customer data base using*/
   /* * customer and hot model group code*/
   /* *************************************************/

  OPYREC.OPXHMGRP = OPZREC.OPXHMGRP;
  OPYREC.KUCCOID = OP1REC.KUCCOID;
  OPYREC.KUMSTRID = 0;
  OPYREC.XNXCD = 0;
  OPYREC.XGPCD = OP3REC.XGPCD;

  call "IO3170" ("SE", SQLCA, OPYREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0
   || SQLCA.VAGen_SQLCODE == 100)
      /* next sentence*/
  else
    TA1REC.TA1DBASE = "DORDER"; /* data base name*/
    TA1REC.TA1TBLVU = "VHOTCU01"; /* table view*/
    OP0IW01.OP0IWDI1 = OPYREC.KUCCOID;
    OP0IW01.OP0IWDI2 = OPYREC.KUMSTRID;
    OP0IW01.OP0IWDI3 = OPYREC.XNXCD;
    OP0IW01.OP0IWDI4 = OPYREC.OPXHMGRP;
    TA1REC.TA1TBLKE = OP0IW01.OP0IWDIG;
    TA1REC.TA1LOCAT[3] = "IO3170"; /* iomod*/
    XSOPS02(); /* standart abend routine*/
  end

  OP0IW01.OP0IWAUT = "N";
  if (SQLCA.VAGen_SQLCODE == 100)
    OP0IW01.OP0IWELI = "N";
    if (COMMAREA.CAUSERID in YOSTBL.XXXUSRID
     && YOSTBL.YOSHMDFL[sysVar.arrayIndex] == "Y") /* authorized to change*/
      OP0IW01.OP0IWAUT = "Y";
      converseLib.validationFailed(470);
    else
      converseLib.validationFailed(469);
    end
  end

end // end OP0ISHM

// load demand qtys from map
Function OP0ISMQ()

   /* move in quantities*/

  OP0IW01.OP0IWSLD = 1; /* map subscript*/
  if (OP0IW01.OP0IWSCR == 1) /* if on first screen*/
     /* start moving quantities beginning with the first*/
     /* size on the first screen up to the first size*/
     /* on the second screen*/
    OP0IW01.OP0IWSBR = OP0IW01.OP0IWSMF;
    while (OP0IWSBR < OP0IW01.OP0IWSB2)
      if (OP0IM001.SY4IDDSC[OP0IWSLD] == SY4REC.SY4IDDSC[OP0IWSBR])
        OPTREC.OPTDMDQT[OP0IWSBR] = OSEREC.OP0LMQT1[OP0IWSLD];
        OP0IW01.OP0IWSLD = OP0IW01.OP0IWSLD + 1;
      end
      OP0IW01.OP0IWSBR = OP0IW01.OP0IWSBR + 1;
    end
  else /* on the second screen of order entry*/
     /* start moving quantities beginning with the first*/
     /* size on the second screen to the last*/
     /* valid size*/
    OP0IW01.OP0IWSBR = OP0IW01.OP0IWSB2; /* first sz on 2nd screen*/
    while (OP0IWSBR <= OP0IW01.OP0IWSZL) /* last valid size*/
      if (OP0IM002.OP0IMSZ1[OP0IWSLD] == SY4REC.SY4IDDSC[OP0IWSBR])
        OPTREC.OPTDMDQT[OP0IWSBR] = OSEREC.OP0LMQT1[OP0IWSLD];
        OP0IW01.OP0IWSLD = OP0IW01.OP0IWSLD + 1;
      end
      OP0IW01.OP0IWSBR = OP0IW01.OP0IWSBR + 1;
    end
  end



   /* *************************************************************/
end // end OP0ISMQ

Function OP0ISOB()

   /* *************************************************************/
   /* Clear the row storage area*/
   /* Select row - Factory Control Table*/
   /* *************************************************************/

   /* *************************************************************/
  set FB9REC empty; /* initialize record*/
  OP0IW01.OP0IWOAO = "N"; /* and ord adj override flag*/

   /* *************************************************************/
   /* select requested row from table*/
   /* *************************************************************/

  try
    call "IO3650" ("S ", SQLCA, FB9REC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

   /* *************************************************************/
   /* If successful or not found, determine effect on order*/
    /* adjustment validation process*/
   /* *************************************************************/

  if (SQLCA.VAGen_SQLCODE != 0) /* post and exit if bad return*/
    TA1REC.TA1TYPE = "DB2";
    TA1REC.TA1FUNC = "POST";
    TA1REC.TA1PGMNM = "OP0I";
    TA1REC.TA1LOCAT[1] = "S ";
    TA1REC.TA1LOCAT[2] = "OP0ISOB";
    TA1REC.TA1LOCAT[3] = "IO3650 ";
    TA1REC.TA1LOCAT[4] = " ";
    TA1REC.TA1DBASE = "DFBUY.";
    TA1REC.TA1TBLVU = "VFMCTL01";
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.rollback();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
    
    call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
    return;
  end

    /* set up need date and buy date for compare*/

  if (OP0IW01.OP0IWOAC == "Y")
    OP0IW01.OP0IWOND = OP0IW01.OP1CUNDT; /* need date changed*/
  else
    OP0IW01.OP0IWOND = OPWREC.OP1CUNDT;
  end

  OP0IW01.OP0IWOBD = FB9REC.FB8BUYDT;

  if (OP0IW01.OP0IWNYM > OP0IW01.OP0IWBYM) /* if need date lt buy date*/
    OP0IW01.OP0IWOAO = "Y"; /* turn on override flag*/
    return; /* and exit*/
  else
    if (OP0IW01.OP0IWNYM < OP0IW01.OP0IWBYM) /* if need date gt buy date*/
      return; /* exit (o/a required)*/
    end
  end

    /* need date and buy date are equal -*/
     /* must now compare current date*/
      /* and time to cutoff date and time*/
       /* in same manner.*/



    /* set up current date and time for compares*/

  OP0IW01.OP0IWTM1 = VGVar.currentFormattedTime; /* change hh:mm:ss to hhmm*/
  OP0IW01.OP0IWTHL = OP0IW01.OP0IWTHF;
  OP0IW01.OP0IWTML = OP0IW01.OP0IWTMF;
  OP0IW01.OP0IWTSL = OP0IW01.OP0IWTSF;

  OPAREC.OPACDT = VGVar.currentShortGregorianDate; /* set curr date*/
  if (OPAREC.OPACYY > 56) /* set century based on year*/
    OPAREC.OPACCC = 19;
  else
    OPAREC.OPACCC = 20;
  end

  if (OPAREC.OPACDT < FB9REC.FB9COFDT)
                                   /* if current date lt cutoff date*/
    OP0IW01.OP0IWOAO = "Y"; /* turn on override flag*/
    return; /* and exit*/
  else
    if (OPAREC.OPACDT > FB9REC.FB9COFDT)
                                   /* if current date gt cutoff date*/
      return; /* exit (o/a required)*/
    end
  end

     /* still equal - try time compare*/

  if (OP0IW01.OP0IWTM3 < FB9REC.FB9COFTM)
                                   /* if current date lt cutoff date*/
    OP0IW01.OP0IWOAO = "Y"; /* turn on override flag*/
  end
   /* *************************************************************/
end // end OP0ISOB

// verify nil offering dates
Function OP0ISOD()


  TA1REC.TA1LOCAT[2] = "OP0ISOD"; /* diag*/

   /* *******************************************************/
   /* *  verify if there is a restriction on the customer*/
   /* *  ordering the specified product for the need date*/
   /* *  requested.*/
   /* *******************************************************/


     /* format nparec for calling io4430.*/

  VNILSY01.KUCCOID = OP1REC.KUCCOID; /* customer number*/
  VNILSY01.XGPCD = OP1REC.XGPCD; /* gpc code*/
  VNILSY01.SY1STNBR = OP3REC.SY1STNBR; /* style number*/
  VNILSY01.SY2CLRID = OP3REC.SY2CLRID; /* color number*/
  VNILSY01.XDMCD = OP3REC.XDMCD; /* dimension code*/

  OP0IW05.OP0IWTSK = "S1"; /* select set for io-mod*/


     /* call io4430 to access dnilo.vnilsy01 inorder to*/
     /* open and declare cursor for select set on records.*/

  call "IO4430" (OP0IW05, SQLCA, VNILSY01) {isNoRefresh = yes, isExternal = yes};


  if (SQLCA.VAGen_SQLCODE == 0) /* good return*/
     /* next sentence*/
  else
    TA1REC.TA1PGMNM = "OP0I    ";
    TA1REC.TA1LOCAT[1] = "S1      ";
    TA1REC.TA1LOCAT[3] = "IO4430  ";
    TA1REC.TA1LOCAT[4] = "        ";
    TA1REC.TA1MAP = "OP0IM001";
    TA1REC.TA1DBASE = "DNILO   ";
    TA1REC.TA1TBLVU = "VNILSY01";
    OP0IW01.OP0IWNP1 = VNILSY01.KUCCOID; /* customer number*/
    OP0IW01.OP0IWNP2 = VNILSY01.XGPCD; /* gpc code*/
    OP0IW01.OP0IWNP3 = VNILSY01.SY1STNBR; /* style number*/
    OP0IW01.OP0IWNP4 = VNILSY01.SY2CLRID; /* color number*/
    OP0IW01.OP0IWNP5 = VNILSY01.XDMCD; /* dimension code*/
    TA1REC.TA1TBLKE = OP0IW01.OP0IWNPA;
    XSOPS02(); /* call reset, ta0020, abend*/
  end


  OP0IW05.OP0IWTSK = "N1"; /* fetch next task for io-mod*/


     /* call io4430 to access dnilo.vnilsy01 inorder to*/
     /* select next on the first(only) valid row.*/

  call "IO4430" (OP0IW05, SQLCA, VNILSY01) {isNoRefresh = yes, isExternal = yes};


  if (SQLCA.VAGen_SQLCODE == 0) /* product was found*/
    if (VNILSY01.XXXSTAT == "A") /* and is active status*/
      converseLib.validationFailed(502); /* cust, prod, need date combo inelig.*/
      set OP0IM001.OP0IMNDT cursor, bold;
      OPAREC.OPAERR = "Y"; /* set error flag on*/
    else
      if (XOTTBL.XOTPROPF[OP0IWSBO] == "Y" /* prop order*/
       || XOTTBL.XOTFUTRF[OP0IWSBO] == "Y") /* future order*/
        OP0ISDZ(); /* check product offering dates*/
      end
    end
  else
    if (SQLCA.VAGen_SQLCODE == +100) /* product was not found*/
      if (XOTTBL.XOTPROPF[OP0IWSBO] == "Y" /* prop order*/
       || XOTTBL.XOTFUTRF[OP0IWSBO] == "Y") /* future order*/
        OP0ISDZ(); /* check product offering dates*/
      end
    else
      TA1REC.TA1PGMNM = "OP0I    ";
      TA1REC.TA1LOCAT[1] = "N1      ";
      TA1REC.TA1LOCAT[3] = "IO4430  ";
      TA1REC.TA1LOCAT[4] = "        ";
      TA1REC.TA1MAP = "OP0IM001";
      TA1REC.TA1DBASE = "DNILO   ";
      TA1REC.TA1TBLVU = "VNILSY01";
      OP0IW01.OP0IWNP1 = VNILSY01.KUCCOID; /* customer number*/
      OP0IW01.OP0IWNP2 = VNILSY01.XGPCD; /* gpc code*/
      OP0IW01.OP0IWNP3 = VNILSY01.SY1STNBR; /* style number*/
      OP0IW01.OP0IWNP4 = VNILSY01.SY2CLRID; /* color number*/
      OP0IW01.OP0IWNP5 = VNILSY01.XDMCD; /* dimension code*/
      TA1REC.TA1TBLKE = OP0IW01.OP0IWNPA;
      XSOPS02(); /* call reset, ta0020, abend*/
    end
  end


  OP0IW05.OP0IWTSK = "C1"; /* close cursor task for io-mod*/


     /* call io4430 to access dnilo.vnilsy01 inorder to*/
     /* close the cursor for the selected set.*/

  call "IO4430" (OP0IW05, SQLCA, VNILSY01) {isNoRefresh = yes, isExternal = yes};


  if (SQLCA.VAGen_SQLCODE == 0) /* good return*/
     /* next sentence*/
  else
    TA1REC.TA1PGMNM = "OP0I    ";
    TA1REC.TA1LOCAT[1] = "C1      ";
    TA1REC.TA1LOCAT[3] = "IO4430  ";
    TA1REC.TA1LOCAT[4] = "        ";
    TA1REC.TA1MAP = "OP0IM001";
    TA1REC.TA1DBASE = "DNILO   ";
    TA1REC.TA1TBLVU = "VNILSY01";
    OP0IW01.OP0IWNP1 = VNILSY01.KUCCOID; /* customer number*/
    OP0IW01.OP0IWNP2 = VNILSY01.XGPCD; /* gpc code*/
    OP0IW01.OP0IWNP3 = VNILSY01.SY1STNBR; /* style number*/
    OP0IW01.OP0IWNP4 = VNILSY01.SY2CLRID; /* color number*/
    OP0IW01.OP0IWNP5 = VNILSY01.XDMCD; /* dimension code*/
    TA1REC.TA1TBLKE = OP0IW01.OP0IWNPA;
    XSOPS02(); /* call reset, ta0020, abend*/
  end

end // end OP0ISOD

// report overide of hot model
Function OP0ISOV()

  TA1REC.TA1LOCAT[2] = "OP0ISOV";

  OSBREC.OSBOVTCD = "HM";
  OSBREC.OP1PARTN = OP3REC.OP1PARTN;
  OSBREC.OP1CUOID = OP3REC.OP1CUOID;
  OSBREC.OP1NORID = OP3REC.OP1NORID;
  OSBREC.OP2LNINB = OP3REC.OP2LNINB;
  OSBREC.XGPCD = OP3REC.XGPCD;
  OSBREC.SY1STNBR = OP3REC.SY1STNBR;
  OSBREC.SY2CLRID = OP3REC.SY2CLRID;
  OSBREC.XDMCD = OP3REC.XDMCD;
  OSBREC.OSBOVQTY = OP3REC.OP2TONOQ;
  OSBREC.ZZZSDT = OPAREC.OPACDT;
  OSBREC.ZZZSTM = OP0IW01.OP0IWTM3;
  if (COMMAREA.CAUSERID in YOSTBL.XXXUSRID)
    OSBREC.XXXUSRID = YOSTBL.XXXUSRID[sysVar.arrayIndex];
  end

  call "IO3410" ("A ", SQLCA, OSBREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
      /* NEXT SENTENCE*/
  else
    TA1REC.TA1DBASE = "DORDER";
    TA1REC.TA1TBLVU = "VORIDA01";
    TA1REC.TA1LOCAT[3] = "IO3410";
    XSOPS02();
  end


end // end OP0ISOV

// Get default phone number
Function OP0ISPH()
   /* Build the key to the store record.*/

  set KUMREC empty;
  KUMREC.KUCCOID = OP1REC.KUCCOID; /* Company id*/
  KUMREC.KUMSTRID = OP1REC.KUMSTRID; /* Store id*/
  KUMREC.XGPCD = OP0IM002.XGPCD; /* GPC*/

   /* Get the store record.*/

  call "IO0340" ("S ", SQLCA, KUMREC) {isNoRefresh = yes, isExternal = yes};

   /* Set up the telephone number if the store record was*/
   /* successfully retrieved and a number exists.*/

  if (SQLCA.VAGen_SQLCODE == 0
   && KUMREC.KUMPHN != " ")
     /* See if the phone number has numerics in the right places*/
     /* (i.e. 999-999-9999).*/

    OP0IW01.KUMPHN = KUMREC.KUMPHN;
    OP0IW01.OP0IWNUM = "Y"; /* Numeric flag.*/
    OP0IW01.OP0IWPSB = 1; /* Phone number subscript.*/
    while (OP0IW01.OP0IWPSB <= 12
     && OP0IW01.OP0IWNUM == "Y")
      if (OP0IW01.OP0IWPSB == 4
       || OP0IW01.OP0IWPSB == 8)
         /* Next sentence - these are the dash positions*/

      else
        if (OP0IW01.OP0IWPCH[OP0IWPSB] >= 0
         && OP0IW01.OP0IWPCH[OP0IWPSB] <= 9)
           /* Next sentence - number is numeric*/

        else
           /* Character was found where a numeric was expected.*/

          OP0IW01.OP0IWNUM = "N"; /* Numeric flag.*/
        end
      end

      OP0IW01.OP0IWPSB = OP0IW01.OP0IWPSB + 1; /* Increment subscript.*/
    end

     /* Move the number to the screen if it is numeric.*/

    if (OP0IW01.OP0IWNUM == "Y") /* Numeric flag*/
      OP0IW01.OP0IWFPH = OP0IW01.KUMPHN; /* Formatted phone number*/
      OP0IM002.XXXPHNA = OP0IW01.OP0IWPHA; /* Area code*/
      OP0IM002.XXXPHNP = OP0IW01.OP0IWPHP; /* Prefix*/
      OP0IM002.XXXPHNN = OP0IW01.OP0IWPHN; /* Number*/
    end
  end
end // end OP0ISPH

// reset map attributes
Function OP0ISRA()

   /* set all enterable map fileds to normal*/


   /* quantities*/

  set OP0IM002.OP0IMQT1[1] normal;



   /* drop date*/

  set OP0IM002.OP0IMDDT normal;


   /* add to waiting list flag*/

  set OP0IM002.OPTWAITF normal;


   /* phone number*/

  set OP0IM002.XXXPHNN normal;
  set OP0IM002.XXXPHNP normal;
  set OP0IM002.XXXPHNA normal;


   /* ordered by*/

  set OP0IM002.OP1ORDBY normal;


   /* ***************************************************/
end // end OP0ISRA

// de-rsrv and allocate item
Function OP0ISSA()



   /* ; set up time for record updates*/

  OP0IW01.OP0IWTM1 = VGVar.currentFormattedTime; /* change hh:mm:ss to hhmm*/
  OP0IW01.OP0IWTHL = OP0IW01.OP0IWTHF;
  OP0IW01.OP0IWTML = OP0IW01.OP0IWTMF;
  OP0IW01.OP0IWTSL = OP0IW01.OP0IWTSF;

  OPAREC.OPACDT = VGVar.currentShortGregorianDate; /* set curr date*/
  if (OPAREC.OPACYY > 56) /* set century based on year*/
    OPAREC.OPACCC = 19;
  else
    OPAREC.OPACCC = 20;
  end




    /* this routine allocates the entered product.*/

    /* the sequence of events are as follows:*/
       /* 1.  read inventory.*/
       /* 2.  update inventory.*/
       /* 3.  write picking transaction record.*/
       /* 4.  roll allocated qtys into item record*/


  TA1REC.TA1LOCAT[2] = "OP0ISSA";


     /* 1. access inventory*/


  set SQLCA empty;
  set IN9REC empty; /* ; initialize inventory item rec*/

  IN9REC.XWHCD = OPWREC.XWHCD[OP0IWSBS]; /* build hdr rec key*/
  if (OP0IM001.XOWCD == " ")
    IN9REC.XOWCD = "00";
  else
    IN9REC.XOWCD = OP0IM001.XOWCD;
  end
  IN9REC.XGPCD = OP1REC.XGPCD;
  IN9REC.SY1STNBR = OPWREC.SY1STNBR[OP0IWSBP];
  IN9REC.SY2CLRID = OPWREC.SY2CLRID[OP0IWSBP];
  IN9REC.XDMCD = OPWREC.XDMCD[OP0IWSBP];
  IN9REC.XQACD = OPWREC.XQACD[OP0IWSBP];
  IN9REC.XSDCD = OP3REC.PC2INSEG;
  IN9REC.XSACD = OP3REC.XEGCD;
  IN9REC.XPGCD = OPWREC.XPGCD[OP0IWSBP];
  IN9REC.XUMCD = OPWREC.XUMCD[OP0IWSBP];


  call "DB1030" ("S ", INQREC, IN9REC) {isNoRefresh = yes, isExternal = yes};

  SQLCA.SQLCAREC = INQREC.INQSQLCA;
  if (SQLCA.VAGen_SQLCODE == 0)
     /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == 100) /* lcr - if record not found*/
      OP0ISUD(); /* add draw back to bulk*/
      converseLib.validationFailed(155); /* possible pkg type problem*/
      OP0IW01.OP0IWREJ = "Y"; /* reject product*/
      exit stack;
    else
      if (SQLCA.VAGen_SQLCODE == -911) /* if deadlock*/
        OP0IS84(); /* wait a second*/
        return; /* loop back*/
      else
        SQLCA.SQLERRP = INQREC.INQFAILR;
        TA1REC.TA1DBASE = "DINVNT";
        TA1REC.TA1TBLVU = "VINITM01";
        TA1REC.TA1TBLKE = IN9REC.IN9KEY;
        TA1REC.TA1LOCAT[1] = "S ";
        TA1REC.TA1LOCAT[3] = "DB1030";
        XSOPS02(); /* common abend*/
      end
    end
  end




    /* 3. re-check availability.*/

   /* not needed because the qty's have been reserved*/


    /* 4. update inventory.*/
   /* will de-reserve the reserved amount and allocate*/


  set SQLCA empty;
  set OPSREC empty; /* ; initialize in9030 record*/

  OPSREC.XWHCD = OPWREC.XWHCD[OP0IWSBS]; /* build hdr rec key*/
  if (OP0IM001.XOWCD == " ")
    OPSREC.XOWCD = "00";
  else
    OPSREC.XOWCD = OP0IM001.XOWCD;
  end
  OPSREC.XGPCD = OP1REC.XGPCD;
  OPSREC.SY1STNBR = OPWREC.SY1STNBR[OP0IWSBP];
  OPSREC.SY2CLRID = OPWREC.SY2CLRID[OP0IWSBP];
  OPSREC.XDMCD = OPWREC.XDMCD[OP0IWSBP];
  OPSREC.XQACD = OPWREC.XQACD[OP0IWSBP];
  OPSREC.XSDCD = OP3REC.PC2INSEG;
  OPSREC.XSACD = OP3REC.XEGCD;
  OPSREC.XPGCD = OPWREC.XPGCD[OP0IWSBP];
  OPSREC.XUMCD = OPWREC.XUMCD[OP0IWSBP];


  OPSREC.IN5TRDTE = OPAREC.OPACDT;
  OPSREC.IN5TRDDT = OPAREC.OPACDT;
  OPSREC.IN5TRREF = " ";
  OPSREC.IN5TRTIM = OP0IW01.OP0IWTM2;
  OPSREC.IN5TRDCD = "O";
  OPSREC.XITCD = "70";
  OPSREC.XIRCD = "907";
  OPSREC.XIFCD = "03";
  OPSREC.IN5TRPRT = OP1REC.OP1PARTN;
  OPSREC.IN5TRDOC = OP1REC.OP1CUOID;
  OPSREC.IN5TRSUB = OP0IW01.OP0IWSBS;
  OPSREC.OP1PARTN = OP0IW03.OP1PARTN;
  OPSREC.OP1CUOID = OP0IW03.OP1CUOID;
  OPSREC.OP1NORID = OP0IW03.OP1NORID;
  OPSREC.IN5USRID = OPWREC.OPWENTLN;
  OPSREC.OPSALNGQ = "N";
  OPAREC.OPASUB = 1;
  while (OPAREC.OPASUB <= 40)
    if (OP3REC.OP3SZAFL[OPASUB] == "Y")
      OPSREC.OPSQTYCH[OPASUB] = OP3REC.OP3OHRQT[OPASUB];
    else
      OPSREC.OPSQTYCH[OPASUB] = 0;
    end
    OPAREC.OPASUB = OPAREC.OPASUB + 1;
  end

  call "IN9030" (SQLCA, OPSREC) {isNoRefresh = yes, isExternal = yes};

  if (OPSREC.OPSRTNCD < 1000 /* if good return codes*/
   && SQLCA.VAGen_SQLCODE == 0)
     /* next sentence*/
  else
    if (OPSREC.OPSRTNCD > 1000)
      OP0ISSI();
    else
      if (SQLCA.VAGen_SQLCODE == -911) /* if deadlock - reset already done*/
        OP0IS84(); /* wait a second*/
        return; /* loop back*/
      else
        VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
        VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
        sysLib.rollback();
        VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
        
        TA1REC.TA1DBASE = "INVENT";
        TA1REC.TA1TBLVU = "& AVAIL ";
        TA1REC.TA1TBLKE = OPSREC.OPSDATA;
        TA1REC.TA1LOCAT[1] = "OP0I060";
        TA1REC.TA1LOCAT[3] = "IN9030";
        TA1REC.TA1LOCAT[4] = OPSREC.OPSRTNCD;
        XSOPS02(); /* common abend*/
      end
    end
  end





      /* 5. write picking transaction record.*/
    /* note: 7-22-87.  one call updates io0910 (old picking*/
    /* record.  one call updates io1660 (new picking record).*/
    /* for a time we need to write both records.  not all*/
    /* warehouses are cutting over to the new picking system*/
    /* at the same time (which uses the new picking record),*/
    /* the reason two records must be kept.*/

  PK1REC.PK1PRTN = OP1REC.OP1PARTN;
  PK1REC.PK1CUOID = OP1REC.OP1CUOID;
  PK1REC.PK1NORID = OP0IW01.OP0IWSBS;
  PK1REC.XWHCD = OPWREC.XWHCD[OP0IWSBS];
  if (OPWREC.OPWREVM == 7 /* if addin in review mode*/
   || OPWREC.OP2LNINB > 0)
    PK1REC.PK1LNINB = OP3REC.OP2LNINB; /* use existing line #*/
  else
    PK1REC.PK1LNINB = OPWREC.OPWLSTLI + 1; /* else create new line #*/
  end

  PK1REC.PK1ALLNB = 1;
  PK1REC.PK1TRTYP = "O";
  PK1REC.PK1HLDCD = " ";
  OPAREC.OPASUB = 1;

  while (OPAREC.OPASUB <= 40)
    if (OP3REC.OP3SZAFL[OPASUB] == "Y")
      PK1REC.PK1QTY[OPASUB] = OP3REC.OP3OHRQT[OPASUB];
      OPIREC.OP3ALQT[OPASUB] = OP3REC.OP3OHRQT[OPASUB];
    else
      PK1REC.PK1QTY[OPASUB] = 0;
      OPIREC.OP3ALQT[OPASUB] = 0;
    end
    OPAREC.OPASUB = OPAREC.OPASUB + 1;
  end

  call "IO0910" ("A ", SQLCA, PK1REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    OP3REC.OP2LNIST = "AL";
  else
    if (SQLCA.VAGen_SQLCODE == -911) /* if deadlock - reset already done*/
      OP0IS84(); /* wait a second*/
      return; /* loop back*/
    else
      VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
      VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
      sysLib.rollback();
      VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
      
      TA1REC.TA1DBASE = "DPICK ";
      TA1REC.TA1TBLVU = "VPKTRN01";
      TA1REC.TA1TBLKE = PK1REC.PK1KEY;
      TA1REC.TA1LOCAT[1] = "A ";
      TA1REC.TA1LOCAT[3] = "IO0910";
      XSOPS02(); /* common abend*/
    end
  end



  OPIREC.XWHCD = OPWREC.XWHCD[OP0IWSBS]; /* 7-22-87*/
  OPIREC.OP1PARTN = OP1REC.OP1PARTN; /* 7-22-87*/
  OPIREC.OP1CUOID = OP1REC.OP1CUOID; /* 7-22-87*/
  OPIREC.OP1NORID = OP0IW01.OP0IWSBS; /* 7-22-87*/
  if (OPWREC.OPWREVM == 7 /* if addin in review mode*/
   || OPWREC.OP2LNINB > 0)
    OPIREC.OP2LNINB = OP3REC.OP2LNINB; /* use existing line #*/
  else
    OPIREC.OP2LNINB = OPWREC.OPWLSTLI + 1; /* else create new line #*/
    OPIREC.OP2CPLNB = OPIREC.OP2LNINB; /* cust po line itm #*/
  end

  OPIREC.OP1NTMAL = 1; /* 9-3-87 tf*/
  OPIREC.OP2AUPRC = OP0IM001.OP0IMPAL; /* 9-3-87tf*/
  OPIREC.XGPCD = OP3REC.XGPCD; /* 7-22-87*/
  OPIREC.SY1STNBR = OP3REC.SY1STNBR; /* 7-22-87*/
  OPIREC.SY2CLRID = OP3REC.SY2CLRID; /* 7-22-87*/
  OPIREC.XDMCD = OP3REC.XDMCD; /* 7-22-87*/
  OPIREC.XQACD = OP3REC.XQACD; /* 7-22-87*/
  OPIREC.OP2CGPCD = OP3REC.OP2CGPCD; /* 7-22-87*/
  OPIREC.PC2INSEG = OP3REC.PC2INSEG; /* 2-13-91 (db change)*/
  OPIREC.XEGCD = OP3REC.XEGCD; /* 2-13-91 (db change)*/
  OPIREC.XPGCD = OP3REC.XPGCD; /* 7-22-87*/
  OPIREC.XUMCD = OP3REC.XUMCD; /* 7-22-87*/
  if (OPWREC.XWHCD[OP0IWSBS] == "51") /* WHSE 51 CANT USE OWNER GRPS*/
    OPIREC.XOWCD = "00"; /* (T-SHIRTS CAUSING PROBLEMS)*/
  else
    OPIREC.XOWCD = OP3REC.XOWCD; /* 7-22-87*/
  end
  OPIREC.XHDCD[1] = OP0IM001.XHDCD[1]; /* 7-22-87*/
  OPIREC.XHDCD[2] = OP0IM001.XHDCD[2]; /* 7-22-87*/
  OPIREC.XHDCD[3] = OP0IM001.XHDCD[3]; /* 7-22-87*/
  OPIREC.XHDCD[4] = OP0IM001.XHDCD[4];
  OPIREC.XHDCD[5] = OP0IM001.XHDCD[5];
  OPIREC.PWRLBCD[1] = OP3REC.PWRLBCD[1];
  OPIREC.PWRLBCD[2] = OP3REC.PWRLBCD[2];
  OPIREC.KUIPRDID = OP3REC.KUIPRDID; /* 7-22-87*/
  OPIREC.SY1UNPCS = 0; /* 7-22-87*/
  OPIREC.PK5TIWT = 0; /* 7-22-87*/
  OPIREC.PK5TIQTY = OP3REC.OP2TONOQ; /* 7-22-87*/

  SQLCA.VAGen_SQLCODE = 0;
  call "IO1660" ("A ", SQLCA, OPIREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
     /* next sentence;                 uncomment below when io0910*/
     /* MOVE 'AL' TO OP3REC.OP2LNIST;  is no longer used*/
  else
    if (SQLCA.VAGen_SQLCODE == -911) /* if deadlock - reset already done*/
      OP0IS84(); /* wait a second*/
      return; /* loop back*/
    else
      VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
      VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
      sysLib.rollback();
      VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
      
      TA1REC.TA1DBASE = "DORDER";
      TA1REC.TA1TBLVU = "VOPPKI01";
      TA1REC.TA1LOCAT[1] = "A ";
      TA1REC.TA1LOCAT[3] = "IO1660";
      XSOPS02(); /* common abend*/
    end
  end
   /* END ;*/




     /* all is well, line item allocated!!!!!!!!!!!*/




  OPAREC.OPASUB = 1;
  OPAREC.OPASUB1 = 9;

  while (OPAREC.OPASUB <= 40)
    OP3REC.OP3ALQT[OPASUB] = OP3REC.OP3OHRQT[OPASUB];
    OP3REC.OP3OHRQT[OPASUB] = 0;
    OPAREC.OPASUB = OPAREC.OPASUB + 1;
  end



  OPWREC.OPWNMALP[OP0IWSBS] = OPWREC.OPWNMALP[OP0IWSBS] + 1;
  OP3REC.OP2TALCQ = OP3REC.OP2TONOQ;
  OP3REC.OP2TOHRQ = 0;



end // end OP0ISSA

// de-rsrv and aloc, review mode
Function OP0ISSC()



    /* set up time for record updates*/

  OP0IW01.OP0IWTM1 = VGVar.currentFormattedTime; /* change hh:mm:ss to hhmm*/
  OP0IW01.OP0IWTHL = OP0IW01.OP0IWTHF;
  OP0IW01.OP0IWTML = OP0IW01.OP0IWTMF;
  OP0IW01.OP0IWTSL = OP0IW01.OP0IWTSF;

  OPAREC.OPACDT = VGVar.currentShortGregorianDate; /* set curr date*/
  if (OPAREC.OPACYY > 56) /* set century based on year*/
    OPAREC.OPACCC = 19;
  else
    OPAREC.OPACCC = 20;
  end




    /* this routine allocates the entered product based on what*/
    /* has been changed in review mode as far as quantities.*/
    /* this routine is used only when the qtys have been reserved.*/



    /* the sequence of events are as follows:*/
       /* 1.  read inventory.*/
       /* 2.  update inventory.*/
       /* 3.  write picking transaction record.*/
       /* 4.  roll allocated qtys into item record.*/

  TA1REC.TA1LOCAT[2] = "OP0ISCI";



     /* 1. read inventory*/


  set SQLCA empty;
  set IN9REC empty; /* ; initialize inventory item rec*/

  IN9REC.XWHCD = OPWREC.XWHCD[OP0IWSBS]; /* build hdr rec key*/
  if (OP0IM001.XOWCD == " ")
    IN9REC.XOWCD = "00";
  else
    IN9REC.XOWCD = OP0IM001.XOWCD;
  end
  IN9REC.XGPCD = OP1REC.XGPCD;
  IN9REC.SY1STNBR = OPWREC.SY1STNBR[OP0IWSBP];
  IN9REC.SY2CLRID = OPWREC.SY2CLRID[OP0IWSBP];
  IN9REC.XDMCD = OPWREC.XDMCD[OP0IWSBP];
  IN9REC.XQACD = OPWREC.XQACD[OP0IWSBP];
  IN9REC.XSDCD = OP3REC.PC2INSEG;
  IN9REC.XSACD = OP3REC.XEGCD;
  IN9REC.XPGCD = OPWREC.XPGCD[OP0IWSBP];
  IN9REC.XUMCD = OPWREC.XUMCD[OP0IWSBP];


  call "DB1030" ("S ", INQREC, IN9REC) {isNoRefresh = yes, isExternal = yes};

  SQLCA.SQLCAREC = INQREC.INQSQLCA;
  if (SQLCA.VAGen_SQLCODE == 0)
     /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == -911) /* if deadlock*/
      OP0IS84(); /* wait a second*/
      return; /* loop back*/
    else
      SQLCA.SQLERRP = INQREC.INQFAILR;
      TA1REC.TA1DBASE = "DINVNT";
      TA1REC.TA1TBLVU = "VINITM01";
      TA1REC.TA1TBLKE = IN9REC.IN9KEY;
      TA1REC.TA1LOCAT[1] = "S ";
      TA1REC.TA1LOCAT[3] = "DB1030";
      XSOPS02();
    end
  end




    /* 2. update inventory.*/


  set SQLCA empty;
  set OPSREC empty; /* ; initialize in9030 record*/

  OPSREC.XWHCD = OPWREC.XWHCD[OP0IWSBS]; /* build hdr rec key*/
  if (OP0IM001.XOWCD == " ")
    OPSREC.XOWCD = "00";
  else
    OPSREC.XOWCD = OP0IM001.XOWCD;
  end
  OPSREC.XGPCD = OP1REC.XGPCD;
  OPSREC.SY1STNBR = OPWREC.SY1STNBR[OP0IWSBP];
  OPSREC.SY2CLRID = OPWREC.SY2CLRID[OP0IWSBP];
  OPSREC.XDMCD = OPWREC.XDMCD[OP0IWSBP];
  OPSREC.XQACD = OPWREC.XQACD[OP0IWSBP];
  OPSREC.XSDCD = OP3REC.PC2INSEG;
  OPSREC.XSACD = OP3REC.XEGCD;
  OPSREC.XPGCD = OPWREC.XPGCD[OP0IWSBP];
  OPSREC.XUMCD = OPWREC.XUMCD[OP0IWSBP];


  OPSREC.IN5TRDTE = OPAREC.OPACDT;
  OPSREC.IN5TRDDT = OPAREC.OPACDT;
  OPSREC.IN5TRREF = " ";
  OPSREC.IN5TRTIM = OP0IW01.OP0IWTM2;
  OPSREC.IN5TRDCD = "O";
  OPSREC.XITCD = "70";
  OPSREC.XIRCD = "907";
  OPSREC.XIFCD = "03";
  OPSREC.IN5TRPRT = OP1REC.OP1PARTN;
  OPSREC.IN5TRDOC = OP1REC.OP1CUOID;
  OPSREC.IN5TRSUB = OP0IW01.OP0IWSBS;
  OPSREC.OP1PARTN = OP0IW03.OP1PARTN;
  OPSREC.OP1CUOID = OP0IW03.OP1CUOID;
  OPSREC.OP1NORID = OP0IW03.OP1NORID;
  OPSREC.IN5USRID = OPWREC.OPWENTLN;
  OPSREC.OPSALNGQ = "N";

  OPAREC.OPASUB = 1;
  while (OPAREC.OPASUB <= 40)
    OPSREC.OPSQTYCH[OPASUB] = OP0IW01.OP0IWCQT[OPASUB];
    OPAREC.OPASUB = OPAREC.OPASUB + 1;
  end

  call "IN9030" (SQLCA, OPSREC) {isNoRefresh = yes, isExternal = yes};

  if (OPSREC.OPSRTNCD < 1000 /* if good return codes*/
   && SQLCA.VAGen_SQLCODE == 0)
     /* next sentence*/
  else
    if (OPSREC.OPSRTNCD > 1000) /* if fatal return codes*/
      OP0ISSI();
    else
      if (SQLCA.VAGen_SQLCODE == -911) /* if deadlock, reset already done*/
        OP0IS84(); /* wait 1 second*/
        return;
      else
        VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
        VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
        sysLib.rollback();
        VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
        
        TA1REC.TA1DBASE = "INVENT";
        TA1REC.TA1TBLVU = "& AVAIL ";
        TA1REC.TA1TBLKE = OPSREC.OPSDATA;
        TA1REC.TA1LOCAT[1] = "OP0I060";
        TA1REC.TA1LOCAT[2] = "OP0ISCI";
        TA1REC.TA1LOCAT[3] = "IN9030";
        TA1REC.TA1LOCAT[4] = OPSREC.OPSRTNCD;
        XSOPS02(); /* common abend*/
      end
    end
  end




      /* 3. update picking transaction record.*/

    /* note: can only be one pick record per line item so i*/
          /* must first re-read the original record and then*/
          /* update it.*/

   /* but if there was no picking record*/
   /* or the suborder changed*/
   /* have 2 different situations*/
   /* 1. no picking found because product had future*/
      /* needt in order entry and was not allocated on-line,*/
      /* but future size was zeroed in review mode*/
      /* so product became eligible to allocate on-line.*/
      /* thus, if picking not found, add code to add picking rec.*/
      /* note - is this a problem with other files in this*/
        /* statement group?*/
   /* 2. need to select picking with old sub-order*/
      /* which is subscript op0iwsbo.*/
      /* when select is o.k., then move in new sub-order*/
      /* and other new fields as done below,*/
      /* and update the picking record.*/
   /* 3. must also move in old xwhcd before selct*/
      /* and new for update*/

   /* note:  for a time we will need to write both the old*/
   /* picking record (pk1rec) and new picking record (opirec).*/
   /* see further notes in op0isai.*/

  PK1REC.PK1PRTN = OP1REC.OP1PARTN;
  PK1REC.PK1CUOID = OP1REC.OP1CUOID;
  PK1REC.PK1NORID = OP0IW01.OP0IWSBS; /* old sub-order*/
  PK1REC.XWHCD = OPWREC.XWHCD[OP0IWSBS]; /* old whse*/
  PK1REC.PK1LNINB = OPWREC.OP2LNINB;
  PK1REC.PK1ALLNB = 1;
  PK1REC.PK1HLDCD = "O";

  call "IO0910" ("S ", SQLCA, PK1REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
     /* found old pick tran*/
     /* now load in changed quantities*/
    OPAREC.OPASUB = 1;
    while (OPAREC.OPASUB <= 40)
      OP0IW01.OP0IWQTY = OP0IW01.OP0IWCQT[OPASUB];
      PK1REC.PK1QTY[OPASUB] = PK1REC.PK1QTY[OPASUB] + OP0IW01.OP0IWQTY;
      OPAREC.OPASUB = OPAREC.OPASUB + 1;
    end

    call "IO0910" ("U ", SQLCA, PK1REC) {isNoRefresh = yes, isExternal = yes};

    if (SQLCA.VAGen_SQLCODE == 0)
      OP3REC.OP2LNIST = "AL";
    else
      if (SQLCA.VAGen_SQLCODE == -911) /* if deadlock - reset already done*/
        OP0IS84(); /* wait 1 second*/
        return; /* loop back*/
      else
        VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
        VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
        sysLib.rollback();
        VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
        
        TA1REC.TA1DBASE = "DPICK ";
        TA1REC.TA1TBLVU = "VPKTRN01";
        TA1REC.TA1TBLKE = PK1REC.PK1KEY;
        TA1REC.TA1LOCAT[1] = "U ";
        TA1REC.TA1LOCAT[3] = "IO0910";
        XSOPS02(); /* common abend*/
      end
    end
  else /* sqlcode ne 0*/
    if (SQLCA.VAGen_SQLCODE == -911) /* if deadlock - reset already done*/
      OP0IS84(); /* wait a second*/
      return; /* loop back*/
    else
      VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
      VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
      sysLib.rollback();
      VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
      
      TA1REC.TA1DBASE = "DPICK ";
      TA1REC.TA1TBLVU = "VPKTRN01";
      OP0IW01.OP0IWPRT = OP1REC.OP1PARTN;
      OP0IW01.OP0IWCID = OP1REC.OP1CUOID;
      OP0IW01.OP0IWNID = OP0IW01.OP0IWSBS;
      OP0IW01.OP0IWLIN = OPWREC.OP2LNINB;
      TA1REC.TA1TBLKE = OP0IW01.OP0IWIKY;
      TA1REC.TA1LOCAT[1] = "S ";
      TA1REC.TA1LOCAT[3] = "IO0910";
      XSOPS02(); /* common abend*/
    end
  end

           /* update new picking record opirec (added 7-22-87)*/

  OPIREC.OP1NTMAL = 1; /* 9-3-87tf*/
  OPIREC.OP2AUPRC = OP0IM001.OP0IMPAL; /* 9-3-87TF*/
  OPIREC.OP1PARTN = OP1REC.OP1PARTN;
  OPIREC.OP1CUOID = OP1REC.OP1CUOID;
  OPIREC.OP1NORID = OP0IW01.OP0IWSBS; /* old sub-order*/
  OPIREC.XWHCD = OPWREC.XWHCD[OP0IWSBS]; /* old whse*/
  OPIREC.OP2LNINB = OPWREC.OP2LNINB;

  call "IO1660" ("S ", SQLCA, OPIREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
     /* found old pick tran*/
     /* now load in changed quantities*/
    OPIREC.XQACD = OP3REC.XQACD; /* 7-22-87*/
    OPIREC.OP2CGPCD = OP3REC.OP2CGPCD; /* 7-22-87*/
    OPIREC.PC2INSEG = OP3REC.PC2INSEG; /* 2-13-91 (db change)*/
    OPIREC.XEGCD = OP3REC.XEGCD; /* 2-13-91 (db change)*/
    OPIREC.XPGCD = OP3REC.XPGCD; /* 7-22-87*/
    OPIREC.XUMCD = OP3REC.XUMCD; /* 7-22-87*/
    if (OPWREC.XWHCD[OP0IWSBS] == "51")
      OPIREC.XOWCD = "00"; /* CAN'T USE OWNER GROUP FOR WHSE 51*/
    else
      OPIREC.XOWCD = OP3REC.XOWCD; /* 7-22-87*/
    end
    OPIREC.XHDCD[1] = OP0IM001.XHDCD[1]; /* 7-22-87*/
    OPIREC.XHDCD[2] = OP0IM001.XHDCD[2]; /* 7-22-87*/
    OPIREC.XHDCD[3] = OP0IM001.XHDCD[3]; /* 7-22-87*/
    OPIREC.XHDCD[4] = OP0IM001.XHDCD[4];
    OPIREC.XHDCD[5] = OP0IM001.XHDCD[5];
    OPIREC.PWRLBCD[1] = OP3REC.PWRLBCD[1];
    OPIREC.PWRLBCD[2] = OP3REC.PWRLBCD[2];
    OPIREC.KUIPRDID = OP3REC.KUIPRDID; /* 7-22-87*/
    OPIREC.SY1UNPCS = 0; /* 7-22-87*/
    OPIREC.PK5TIWT = 0; /* 7-22-87*/
    OPIREC.PK5TIQTY = OP3REC.OP2TONOQ; /* 7-22-87*/
    OPIREC.ZZZSDT = OPAREC.OPACDT;
    OPIREC.ZZZCHGDT = OPAREC.OPACDT;
    OPIREC.ZZZCHGTM = OP0IW01.OP0IWTM3;

    OPAREC.OPASUB = 1;
    while (OPAREC.OPASUB <= 40)
      OP0IW01.OP0IWQTY = OP0IW01.OP0IWCQT[OPASUB];
      OPIREC.OP3ALQT[OPASUB] = OPIREC.OP3ALQT[OPASUB] + OP0IW01.OP0IWQTY;
      OPAREC.OPASUB = OPAREC.OPASUB + 1;
    end

    SQLCA.VAGen_SQLCODE = 0;
    call "IO1660" ("U ", SQLCA, OPIREC) {isNoRefresh = yes, isExternal = yes};

    if (SQLCA.VAGen_SQLCODE == 0) /* comment out below until*/
       /* MOVE 'AL' TO OP3REC.OP2LNIST; old picking record not used*/
    else
      if (SQLCA.VAGen_SQLCODE == -911) /* if deadlock - reset already done*/
        OP0IS84(); /* wait 1 second*/
        return; /* loop back*/
      else
        VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
        VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
        sysLib.rollback();
        VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
        
        TA1REC.TA1DBASE = "DORDER";
        TA1REC.TA1TBLVU = "VOPPKI01";
        TA1REC.TA1LOCAT[1] = "U ";
        TA1REC.TA1LOCAT[3] = "IO1660";
        XSOPS02(); /* common abend*/
      end
    end
  else /* sqlcode ne 0*/
    if (SQLCA.VAGen_SQLCODE == -911) /* if deadlock - reset already done*/
      OP0IS84(); /* wait a second*/
      return; /* loop back*/
    else
      VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
      VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
      sysLib.rollback();
      VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
      
      TA1REC.TA1DBASE = "DORDER";
      TA1REC.TA1TBLVU = "VOPPKI01";
      OP0IW01.OP0IWPRT = OP1REC.OP1PARTN;
      OP0IW01.OP0IWCID = OP1REC.OP1CUOID;
      OP0IW01.OP0IWNID = OP0IW01.OP0IWSBS;
      OP0IW01.OP0IWLIN = OPWREC.OP2LNINB;
      TA1REC.TA1TBLKE = OP0IW01.OP0IWIKY;
      TA1REC.TA1LOCAT[1] = "S ";
      TA1REC.TA1LOCAT[3] = "IO1660";
      XSOPS02(); /* common abend*/
    end
  end
   /* END ;*/




     /* all is well, line item allocated!!!!!!!!!!!*/


       /* 4.  roll allocated qtys into item record.*/



  OPAREC.OPASUB = 1;
  OPAREC.OPASUB1 = 9;
  OP0IW01.OP0IWTOT = 0;

  while (OPAREC.OPASUB <= 40)
    OP0IW01.OP0IWQTY = OP0IW01.OP0IWCQT[OPASUB];
    OP0IW01.OP0IWTOT = OP0IW01.OP0IWTOT + OP0IW01.OP0IWQTY;
    OP3REC.OP3ALQT[OPASUB] = OP3REC.OP3ALQT[OPASUB] + OP0IWQTY;
    if (OP3REC.OP3OHRQT[OPASUB] > 0)
      OP3REC.OP3OHRQT[OPASUB] = OP3REC.OP3OHRQT[OPASUB] - OP0IWQTY;
    end
    OPAREC.OPASUB = OPAREC.OPASUB + 1;
  end



  OP3REC.OP2TALCQ = OP3REC.OP2TALCQ + OP0IW01.OP0IWTOT;
  OP3REC.OP2TOHRQ = OP3REC.OP2TOHRQ - OP0IW01.OP0IWTOT;



end // end OP0ISSC

// de-allocate inventory
Function OP0ISSD()



    /* set up time for record updates*/

  OP0IW01.OP0IWTM1 = VGVar.currentFormattedTime; /* change hh:mm:ss to hhmm*/
  OP0IW01.OP0IWTHL = OP0IW01.OP0IWTHF;
  OP0IW01.OP0IWTML = OP0IW01.OP0IWTMF;
  OP0IW01.OP0IWTSL = OP0IW01.OP0IWTSF;

  OPAREC.OPACDT = VGVar.currentShortGregorianDate; /* set curr date*/
  if (OPAREC.OPACYY > 56) /* set century based on year*/
    OPAREC.OPACCC = 19;
  else
    OPAREC.OPACCC = 20;
  end



    /* this routine de-allocates and rereserves the rejected prod*/

    /* the sequence of events are as follows:*/
       /* 1.  roll quantities into opsrec*/
       /* 2.  de-allocate quantities.*/
       /* 3.  delete pick transaction record.*/
    /* use old sub-order values*/

  TA1REC.TA1LOCAT[2] = "OP0ISSD";



     /* 1. roll quantities into opsrec.*/

     /* allocated qty = current op3rec - change qty.*/

  set SQLCA empty;
  set OPSREC empty; /* ; initialize in9030 record*/


  OPAREC.OPASUB = 1;
  while (OPAREC.OPASUB <= 40)
    if (OP3REC.OP3SZAFL[OPASUB] == "Y")
      OP0IW01.OP0IWQTY = OP3REC.OP3ONOQT[OPASUB];
      OP0IW01.OP0IWQTY = OP0IW01.OP0IWQTY - OP0IW01.OP0IWCQT[OPASUB];
      OPSREC.OPSQTYCH[OPASUB] = OP0IW01.OP0IWQTY;
    else
      OPSREC.OPSQTYCH[OPASUB] = 0;
    end
    OPAREC.OPASUB = OPAREC.OPASUB + 1;
  end



    /* 2. update inventory (deallocate qtys)*/



  OPSREC.XWHCD = OPWREC.XWHCD[OP0IWSBS]; /* build hdr rec key*/
  if (OP0IM001.XOWCD == " ")
    OPSREC.XOWCD = "00";
  else
    OPSREC.XOWCD = OP0IM001.XOWCD;
  end
  OPSREC.XGPCD = OP1REC.XGPCD;
  OPSREC.SY1STNBR = OPWREC.SY1STNBR[OP0IWSBP];
  OPSREC.SY2CLRID = OPWREC.SY2CLRID[OP0IWSBP];
  OPSREC.XDMCD = OPWREC.XDMCD[OP0IWSBP];
  OPSREC.XQACD = OPWREC.XQACD[OP0IWSBP];
  OPSREC.XSDCD = OP3REC.PC2INSEG;
  OPSREC.XSACD = OP3REC.XEGCD;
  OPSREC.XPGCD = OP3REC.XPGCD;
  OPSREC.XUMCD = OP3REC.XUMCD;


  OPSREC.IN5TRDTE = OPAREC.OPACDT;
  OPSREC.IN5TRDDT = OPAREC.OPACDT;
  OPSREC.IN5TRREF = " ";
  OPSREC.IN5TRTIM = OP0IW01.OP0IWTM2;
  OPSREC.IN5TRDCD = "O";
  OPSREC.XITCD = "60";
  OPSREC.XIRCD = "907";
  OPSREC.XIFCD = "02";
  OPSREC.IN5TRPRT = OP1REC.OP1PARTN;
  OPSREC.IN5TRDOC = OP1REC.OP1CUOID;
  OPSREC.IN5TRSUB = OP0IW01.OP0IWSBS;
  OPSREC.OP1PARTN = OP0IW03.OP1PARTN;
  OPSREC.OP1CUOID = OP0IW03.OP1CUOID;
  OPSREC.OP1NORID = OP0IW03.OP1NORID;
  OPSREC.IN5USRID = OPWREC.OPWENTLN;
  OPSREC.OPSALNGQ = "N";

  call "IN9030" (SQLCA, OPSREC) {isNoRefresh = yes, isExternal = yes};

  if (OPSREC.OPSRTNCD < 1000 /* if good return codes*/
   && SQLCA.VAGen_SQLCODE == 0)
     /* next sentence*/
  else
    if (OPSREC.OPSRTNCD > 1000) /* if good return codes*/
      OP0ISSI();
    else
      if (SQLCA.VAGen_SQLCODE == -911) /* if deadlock - reset already done*/
        converseLib.validationFailed(6); /* record busy try again*/
        exit stack;
      else
        VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
        VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
        sysLib.rollback();
        VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
        
        TA1REC.TA1DBASE = "INVENT";
        TA1REC.TA1TBLVU = "+AVAIL  ";
        TA1REC.TA1TBLKE = OPSREC.OPSDATA;
        TA1REC.TA1LOCAT[1] = "U";
        TA1REC.TA1LOCAT[3] = "IN9030";
        XSOPS02(); /* common abend*/
      end
    end
  end





      /* 3. delete picking transaction record.*/

    /* for a time we will adjust both the old picking*/
    /* record (pk1rec) and the new picking record (opirec).*/
    /* this will be done until the the old picking record*/
    /* is no longer needed.  see op0isai for further details.*/


  PK1REC.PK1PRTN = OP1REC.OP1PARTN;
  PK1REC.PK1CUOID = OP1REC.OP1CUOID;
  PK1REC.PK1NORID = OP0IW01.OP0IWSBS;
  PK1REC.XWHCD = OPWREC.XWHCD[OP0IWSBS];
  PK1REC.PK1LNINB = OPWREC.OP2LNINB;
  PK1REC.PK1ALLNB = 1;
  PK1REC.PK1TRTYP = "O";
  PK1REC.PK1HLDCD = " ";

  call "IO0910" ("D ", SQLCA, PK1REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
     /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == -911) /* if deadlock - reset already done*/
      converseLib.validationFailed(6); /* record busy try again*/
      exit stack; /* re-converse*/
    else
      VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
      VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
      sysLib.rollback();
      VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
      
      TA1REC.TA1DBASE = "DPICK ";
      TA1REC.TA1TBLVU = "VPKTRN01";
      TA1REC.TA1TBLKE = PK1REC.PK1KEY;
      TA1REC.TA1LOCAT[1] = "A ";
      TA1REC.TA1LOCAT[3] = "IO0910";
      XSOPS02(); /* common abend*/
    end
  end


    /* adjust new picking record (added 7-23-87)*/

  OPIREC.OP1PARTN = OP1REC.OP1PARTN;
  OPIREC.OP1CUOID = OP1REC.OP1CUOID;
  OPIREC.OP1NORID = OP0IW01.OP0IWSBS;
  OPIREC.XWHCD = OPWREC.XWHCD[OP0IWSBS];
  OPIREC.OP2LNINB = OPWREC.OP2LNINB;

  SQLCA.VAGen_SQLCODE = 0;
  call "IO1660" ("D ", SQLCA, OPIREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
     /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == -911) /* if deadlock - reset already done*/
      converseLib.validationFailed(6); /* record busy try again*/
      exit stack; /* re-converse*/
    else
      VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
      VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
      sysLib.rollback();
      VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
      
      TA1REC.TA1DBASE = "DORDER";
      TA1REC.TA1TBLVU = "VOPPKI01";
      TA1REC.TA1LOCAT[1] = "D ";
      TA1REC.TA1LOCAT[3] = "IO1660";
      XSOPS02(); /* common abend*/
    end
  end
   /* END ;*/





end // end OP0ISSD

// handle in1390 return code
Function OP0ISSI()


  if (OPSREC.OPSRTNCD == 8010
   || OPSREC.OPSRTNCD == 8020)
    converseLib.validationFailed(310);
  else
    if (OPSREC.OPSRTNCD >= 1020
     && OPSREC.OPSRTNCD <= 1029)
      converseLib.validationFailed(310);
    else
      if (OPSREC.OPSRTNCD == 1040
       || OPSREC.OPSRTNCD == 7020
       || OPSREC.OPSRTNCD == 8030
       || OPSREC.OPSRTNCD == 8040
       || OPSREC.OPSRTNCD == 8050
       || OPSREC.OPSRTNCD == 8060
       || OPSREC.OPSRTNCD == 8070
       || OPSREC.OPSRTNCD == 8090)
        converseLib.validationFailed(6);
      else
        if (OPSREC.OPSRTNCD == 1010
         || OPSREC.OPSRTNCD == 7040
         || OPSREC.OPSRTNCD == 8080)
          converseLib.validationFailed(312);
        else
          if (OPSREC.OPSRTNCD == 1050
           || OPSREC.OPSRTNCD == 1060
           || OPSREC.OPSRTNCD == 1070
           || OPSREC.OPSRTNCD == 1080
           || OPSREC.OPSRTNCD == 1090)
            converseLib.validationFailed(311);
          else
            VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
            VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
            sysLib.rollback();
            VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
            
            TA1REC.TA1DBASE = "INVENT";
            TA1REC.TA1TBLVU = "& AVAIL ";
            TA1REC.TA1TBLKE = OPSREC.OPSDATA;
            TA1REC.TA1LOCAT[1] = "OP0ISSI";
            TA1REC.TA1LOCAT[3] = "IN9030";
            TA1REC.TA1LOCAT[4] = OPSREC.OPSRTNCD;
            XSOPS02(); /* common abend*/
          end
        end
      end
    end
  end

  if (OPSREC.OPSRTNCD == 1021 /* added 1/30/89*/
   || OPSREC.OPSRTNCD == 1024 /* to bypass posting*/
   || OPSREC.OPSRTNCD == 1050 /* when these are valid*/
   || OPSREC.OPSRTNCD == 1060) /* but posting is not wanted or needed*/
                                   /* dlw*/
     /* next sentence*/
  else
    /* MOVE opsREC.opsRTNCD TO OP0IW01.OP0IWRTN;*/
    /* MOVE IN9REC.SY1STNBR TO OP0IW01.OP0IWSTY;*/
    /* MOVE IN9REC.SY2CLRID TO OP0IW01.OP0IWCLR;*/
    /* MOVE OP0IW01.OP0IWERR TO TA1REC.TA1TBLKE;*/
    TA1REC.TA1TBLKE = OPSREC.OPSKEY;
    TA1REC.TA1TYPE = "DB2"; /* abend type*/
    TA1REC.TA1PGMNM = "OP0I"; /* program name*/
    TA1REC.TA1DBASE = "INVENT"; /* data base*/
    TA1REC.TA1TBLVU = "& AVAIL "; /* table view*/
    TA1REC.TA1LOCAT[1] = "OP0ISSI";
    TA1REC.TA1MAP = "OP0IM001";
    TA1REC.TA1LOCAT[3] = "IN9030";
    TA1REC.TA1LOCAT[4] = OPSREC.OPSRTNCD;
    TA1REC.TA1FUNC = "POST"; /* abend function*/
    set ERRSQLCA empty;
    move SQLCA to ERRSQLCA withV60Compat;
    call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes}; /* abend module*/
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.rollback();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
     /* synpoint rollback*/
    COMMAREA.CA-USER-WORKAREA-4K = " "; /* clear user commarea*/
    OPAREC.OPAERR = "Y";
  end
  exit stack;

end // end OP0ISSI

// get sp1rec
Function OP0ISSP()



      /* ***************************/
      /* * get sales program record*/
      /* ***************************/

  TA1REC.TA1LOCAT[2] = "OP0ISSP"; /* error diag group name*/


      /* note - key set up from order header op1rec*/
      /* in op0i060*/


  call "IO0070" ("S ", SQLCA, SP1REC) {isNoRefresh = yes, isExternal = yes}; /* i/o mod for inquiry*/


      /* check db2 return code*/

  if (SQLCA.VAGen_SQLCODE == 0) /* check for good rc*/
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DSPGM   "; /* data base name*/
    TA1REC.TA1TBLVU = "VSPGM001"; /* table view*/
    TA1REC.TA1TBLKE = SP1REC.SP1ID; /* key value*/
    TA1REC.TA1LOCAT[3] = "IO0070  "; /* i/o mod name*/
    XSOPS02(); /* common abend*/
  end



end // end OP0ISSP

// screened prod: loas op0iwp01
Function OP0IST0()
    /* calculate program indicator for screened products*/

   /* **********************************************************/
              /* BLANK BULK DRAWS*/
   /* **********************************************************/

  if (OP0IW01.OP0IWBBD == "B") /* BLANK BULK DRAW*/
    if (OP1REC.XOBCD == "M1") /* SPECIAL MAKEUP*/
      OP0IW01.OP0IWP01 = "S"; /* hold for spcl makeup*/
    else
      OP0IW01.OP0IWP01 = "T"; /* HOLD AS REG PRODUCT*/
    end
    return;
  end

   /* **********************************************************/
              /* FLYERS AND SPCL MAKEUPS*/
    /* which is anything associated with a blank product*/
    /* that is not a draw and not a futures order type*/
   /* **********************************************************/

    /* find program indicator for prop orders*/

  if (OP1REC.XBDCD in XBDTBL.XBDCD              
   && XBDTBL.XBDRWOFL[sysVar.arrayIndex] != "Y" /* not a draw order*/
   && OP1REC.XOTCD in XOTTBL.XOTCD              
   && XOTTBL.XOTPROPF[sysVar.arrayIndex] == "Y") /* a prop order*/
    if (SYCREC.XPRCD in XPRTBL.XPRCD
     && XPRTBL.XPRSMKFL[sysVar.arrayIndex] == "Y") /* SPECIAL MAKEUP product*/
      OP0IW01.OP0IWP01 = "S"; /* HOLD FOR SPCL MAKEUP*/
    else
      OP0IW01.OP0IWP01 = "T"; /* HOLD AS REG PRODUCT*/
    end
  end
end // end OP0IST0

// process blank bulk draws
Function OP0IST4()
    /* this sgrp applies only to draws from a blank bulk*/
    /* it checks the style for valid need date by:*/
      /* - finding a record to cover the need date in*/
        /* davail.vblnkp01 using s or t program indicator as*/
              /* determined in st0*/
      /* - finding an associated style record in*/
        /* davail.vblnks01 using xowcd found in vblnkp01*/
      /* - verifying the cut-off date in dorder.vogcut01*/
        /* using xowcd appropriate to the blank bulk - mr or sm*/

  OP0IS7I(); /* GET OWNER GROUP PROGRAM P01 TABLE*/

  if (SQLCA.VAGen_SQLCODE == +100) /* NOTHING FOUND*/
    OPAREC.OPAERR = "Y"; /* no active finished program exists*/
    converseLib.validationFailed(628); /* for this need date*/
    set OP0IM001.OP0IMNDT cursor, bold;
    return;
  end

  OP0IS7J(); /* get cutoff row*/

  if (SQLCA.VAGen_SQLCODE == +100)
    OPAREC.OPAERR = "Y";
    converseLib.validationFailed(632); /* cutoff date for need date has not been set up*/
    set OP0IM001.OP0IMNDT cursor, modified, bold;
    return;
  end

  if (OECREC.OPJCUTDT < OPAREC.OPACDT) /* if cut-off-date < curr-date*/
    if (COMMAREA.CAUSERID in YOSTBL.XXXUSRID
     && YOSTBL.XXXSTAT[sysVar.arrayIndex] == "A"
     && YOSTBL.YOSNDTFL[sysVar.arrayIndex] == "Y") /* authorized for lateness*/
      OPAREC.OPAERR = "Y";
      converseLib.validationFailed(638); /* past cut-off date warning msg*/
      set OP0IM001.OP0IMNDT cursor, bold;
    else
      OPAREC.OPAERR = "Y";
      converseLib.validationFailed(631); /* past cut-off date error msg*/
      set OP0IM001.OP0IMNDT cursor, modified, bold;
      return;
    end
  end

  OP0IS7K(); /* validate finished style*/

  if (SQLCA.VAGen_SQLCODE == +100) /* no record for this style*/
    OPAREC.OPAERR = "Y";
    converseLib.validationFailed(629); /* this is not a valid finished style for this*/
    set OP0IM001.OP0IMNDT cursor, modified, bold; /* finished program*/
  end
   /* ************************************************************/
end // end OP0IST4

// update bulk order drawn from
Function OP0ISUB()




    /* this routine updates the bulk order just drawn from.*/

        /* this routine will recheck availablitity if a*/
        /* change count error occurs. it will keep doing*/
        /* this until we get a good write or until their*/
        /* is not enough available to enter this item.*/

           /* while write not complete*/
                /* roll item totals out of bulk*/
                /* try to update*/
                /* if good return, exit*/
                /* if change count error,*/
                    /* re-read bulk order*/
                    /* recheck availability*/
                    /* if ok, loop back*/
                    /* if not available, reconverse, ezeflo*/
                    /* if fatal, abend*/
                /* if fatal, abend.*/



  OP0IW01.OP0IWFND = "N";
  OPAREC.OPASUB = 0;
  OPAREC.OPASUB2 = 0;

  while (OPAREC.OPASUB < 6)
    OPAREC.OPASUB = OPAREC.OPASUB + 1;
    OPAREC.OPASUB1 = 1;
    while (OPAREC.OPASUB1 <= 40)
      if (OP3REC.OP3SZAFL[OPASUB1] == "Y") /* if active size*/
        OPAREC.OPASUB2 = OPAREC.OPASUB2 + 1;
        if (OP3REC.OP3ONOQT[OPASUB1] > OP0IW03.OP3ORGQT[OPASUB1])
          OP3REC.OP3ORGQT[OPASUB1] = OP0IW03.OP3ORGQT[OPASUB1];
          OP0IW03.OP3ORGQT[OPASUB1] = 0;
        else
          OP3REC.OP3ORGQT[OPASUB1] = OP3REC.OP3ONOQT[OPASUB1];
          OP0IW01.OP0IWQTY = OP3REC.OP3ONOQT[OPASUB1];
          if (OP0IW03.OP3ORGQT[OPASUB1] != 0)
            OP0IW03.OP3ORGQT[OPASUB1] = OP0IW03.OP3ORGQT[OPASUB1] - OP0IWQTY;
          end
        end
        if (OP0IW01.OP0IWBDF == "DR") /* if rebook draw*/
          OP3REC.OP3ORGQT[OPASUB1] = 0; /* draw orig qty*/
        end /* is always zero*/
        OP0IW01.OP0IWQTY = OP3REC.OP3ONOQT[OPASUB1];
        OP0IW03.OP3ONOQT[OPASUB1] = OP0IW03.OP3ONOQT[OPASUB1] - OP0IWQTY;
        if (OP0IW03.OP3OHRQT[OPASUB1] > 0)
          if (OP3REC.OP3ONOQT[OPASUB1] > OP0IW03.OP3OHRQT[OPASUB1])
            OP3REC.OP3OHRQT[OPASUB1] = OP0IW03.OP3OHRQT[OPASUB1];
            OP0IW03.OP3OHRQT[OPASUB1] = 0;
          else
            OP3REC.OP3OHRQT[OPASUB1] = OP3REC.OP3ONOQT[OPASUB1];
            OP0IW01.OP0IWQTY = OP3REC.OP3ONOQT[OPASUB1];
            OP0IW03.OP3OHRQT[OPASUB1] = OP0IW03.OP3OHRQT[OPASUB1] - OP0IWQTY;
          end
        end
      end
      OPAREC.OPASUB1 = OPAREC.OPASUB1 + 1;
    end
    OP0IW03.OP2TDRWQ = OP0IW03.OP2TDRWQ + OP3REC.OP2TONOQ;
    OP8REC.OP8TASK = "U ";
    OP8REC.OP8LOCAT[1] = "OP0I060";
    OP8REC.OP8LOCAT[2] = "OP0IS6E";
    call "DB1000" (OP8REC, OP0IW03, OPBREC) {isNoRefresh = yes, isExternal = yes};
    if (OPBREC.OPBSZRC == 0) /* good return*/
      OPAREC.OPASUB = 99;
    else
      if (OPBREC.OPBSZRC == 2 /* change count error codes*/
       || OPBREC.OPBSZRC == 3 /* re check availability*/
       || OPBREC.OPBSZRC == -911) /* deadlock*/
        VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
        VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
        sysLib.rollback();
        VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
        
        if (OPBREC.OPBSZRC == -911) /* -911 already does a reset*/
          OP0IS84(); /* wait a second*/
        else
          VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
          VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
          sysLib.rollback();
          VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
          
        end
        OP8REC.OP8TASK = "S ";
        call "DB1000" (OP8REC, OP0IW03, OPBREC) {isNoRefresh = yes, isExternal = yes};
        if (OPBREC.OPBSZRC == 0)
         /* Initialize non-existant sizes on the bulk to prevent S0C7's*/
         /* in CSP 4.1 - 10/07/93 - schase*/
          OPAREC.OPASUB2 = 1;
          while (OPAREC.OPASUB2 < 41)
            if (OP0IW03.OP3SZAFL[OPASUB2] != "Y")
              OP0IW03.SY5PRCUN[OPASUB2] = 0;
              OP0IW03.OP3ORGQT[OPASUB2] = 0;
              OP0IW03.OP3ONOQT[OPASUB2] = 0;
              OP0IW03.OP3ALQT[OPASUB2] = 0;
              OP0IW03.OP3OHRQT[OPASUB2] = 0;
              OP0IW03.OP3WPRQT[OPASUB2] = 0;
              OP0IW03.OP3SHPQT[OPASUB2] = 0;
              OP0IW03.OP3CNLQT[OPASUB2] = 0;
            end
            OPAREC.OPASUB2 = OPAREC.OPASUB2 + 1;
          end
          OPAREC.OPASUB1 = 1;
          while (OPAREC.OPASUB1 <= 40)
            if (OP3REC.OP3SZAFL[OPASUB1] == "Y")
              if (OP0IW01.OP0IWBDF == "DS")
                if (OP3REC.OP3ONOQT[OPASUB1] > OP0IW03.OP3OHRQT[OPASUB1])
                  OPAREC.OPASUB = 9;
                  OPAREC.OPASUB1 = 41;
                end
              else
                if (OP3REC.OP3ONOQT[OPASUB1] > OP0IW03.OP3ONOQT[OPASUB1])
                  OPAREC.OPASUB = 9;
                  OPAREC.OPASUB1 = 41;
                end
              end
            end
            OPAREC.OPASUB1 = OPAREC.OPASUB1 + 1;
          end
        else
          OP0IS88(); /* abend*/
        end
      else
        OP0IS88(); /* abend*/
      end
    end
  end







   /* now reset the status based on item values.*/

  OPWREC.OPWOPQTF[OP0IWSBS] = "N";
  OPWREC.OPWRSQTF[OP0IWSBS] = "N";
  OP0IW01.OP0IWFND = "N";
  sysVar.arrayIndex = 1;
  while (sysVar.arrayIndex <= 40)
    if (OP3REC.OP3SZAFL[sysVar.arrayIndex] == "Y" /* if size active*/
     && OP3REC.OP3ONOQT[sysVar.arrayIndex] > 0)  
      if (OP3REC.OP3ONOQT[sysVar.arrayIndex] > OP3REC.OP3OHRQT[sysVar.arrayIndex]
       && OP3REC.OP3OHRQT[sysVar.arrayIndex] > 0)
        OP0IW01.OP0IWFND = "P";
        OPWREC.OPWOPQTF[OP0IWSBS] = "Y";
        OPWREC.OPWRSQTF[OP0IWSBS] = "Y";
      else
        if (OP3REC.OP3ONOQT[sysVar.arrayIndex] == OP3REC.OP3OHRQT[sysVar.arrayIndex])
          if (OP0IW01.OP0IWFND == "P") /* don't reset 'pr' stat*/
             /* next sentence*/
          else
            OPWREC.OPWRSQTF[OP0IWSBS] = "Y";
            if (OPWREC.OPWOPQTF[OP0IWSBS] == "Y")
              OP0IW01.OP0IWFND = "P";
            else
              OP0IW01.OP0IWFND = "R";
            end
          end
        else
          if (OP0IW01.OP0IWFND == "R")
            OP0IW01.OP0IWFND = "P";
          end
          OPWREC.OPWOPQTF[OP0IWSBS] = "Y";
        end
      end
    end
    sysVar.arrayIndex = sysVar.arrayIndex + 1;
  end



      /* for the quantity ordered, set line item status*/
      /* appropriately.*/

  if (OP0IW01.OP0IWFND == "P")
    OP3REC.OP2LNIST = "PR"; /* set status to partailly reserved*/
  else
    if (OP0IW01.OP0IWFND == "R")
      OP3REC.OP2LNIST = "RS"; /* set status to reserved*/
    else
      OP3REC.OP2LNIST = "OP"; /* set status to open*/
    end
  end








  if (OPAREC.OPASUB == 9) /* if not enough availability*/
    OP0IW01.OP0IWRST = "Y"; /* set restart flag*/
    converseLib.validationFailed(297);
    exit stack;
  end





  if (OPAREC.OPASUB == 6) /* chg cnt and deadlocks combo*/
    converseLib.validationFailed(6); /* records busy try again*/
    exit stack; /* re-converse*/
  end





end // end OP0ISUB

// update bulk order drawn from
Function OP0ISUC()




    /* this routine updates the bulk order just drawn from.*/
   /* review mode*/
        /* this routine will recheck availablitity if a*/
        /* change count error occurs. it will keep doing*/
        /* this until we get a good write or until their*/
        /* is not enough available to enter this item.*/

           /* while write not complete*/
                /* roll item totals out of bulk*/
                /* try to update*/
                /* if good return, exit*/
                /* if change count error,*/
                    /* re-read bulk order*/
                    /* recheck availability*/
                    /* if ok, loop back*/
                    /* if not available, reconverse, ezeflo*/
                    /* if fatal, abend*/
                /* if fatal, abend.*/



  OPAREC.OPASUB = 0;
  OP0IW01.OP0IWTOT = 0;
  OPAREC.OPASUB2 = 0;


      /* in case this confuses you like it did me, here's*/
      /* what's in the records.*/
       /* op0iw03 is the bulk db1000 (with the first decrease)*/
       /* op3rec is the draw before the qty's were changed*/
       /* op0iw01.op0iwcqt is the difference between the original*/
       /* draw (op3rec) and new draw (what's on the map).*/
          /* ****warning op0iwcqt may be negative*/
       /* this is really a mess if the negative qty was allocated*/
                      /* g o o d   l u c k*/
            /* and remember it's only a shoe company*/




  while (OPAREC.OPASUB < 6)
    OPAREC.OPASUB = OPAREC.OPASUB + 1;
    OPAREC.OPASUB1 = 1;
    while (OPAREC.OPASUB1 <= 40)
      if (OP0IW01.OP0IWCQT[OPASUB1] != 0) /* if quantity changed*/
        OPAREC.OPASUB2 = OPAREC.OPASUB2 + 1;
        if (OP0IW01.OP0IWCQT[OPASUB1] > OP0IW03.OP3ORGQT[OPASUB1])
                                   /* orig qty*/
          /* this doesn't make any sense*/
          OP0IW01.OP0IWQTY = OP0IW03.OP3ORGQT[OPASUB1];
          OP3REC.OP3ORGQT[OPASUB1] = OP3REC.OP3ORGQT[OPASUB1] + OP0IWQTY;
          OP0IW03.OP3ORGQT[OPASUB1] = 0;
        else
          OP0IW01.OP0IWQTY = OP0IW01.OP0IWCQT[OPASUB1];
          OP3REC.OP3ORGQT[OPASUB1] = OP3REC.OP3ORGQT[OPASUB1] + OP0IWQTY;
          OP0IW03.OP3ORGQT[OPASUB1] = OP0IW03.OP3ORGQT[OPASUB1] - OP0IWQTY;
          if (OP3REC.OP3ORGQT[OPASUB1] < 0)
            OP3REC.OP3ORGQT[OPASUB1] = 0;
          end
          if (OP0IW03.OP3ORGQT[OPASUB1] < 0)
            OP0IW03.OP3ORGQT[OPASUB1] = 0;
          end
        end
        if (OP0IW01.OP0IWBDF == "DR") /* if rebook draw*/
          OP3REC.OP3ORGQT[OPASUB1] = 0; /* draw orig qty*/
        end /* is always zero*/
        OP0IW01.OP0IWQTY = OP0IW01.OP0IWCQT[OPASUB1];
        OP0IW01.OP0IWTOT = OP0IW01.OP0IWTOT + OP0IW01.OP0IWQTY;
        OP0IW03.OP3ONOQT[OPASUB1] = OP0IW03.OP3ONOQT[OPASUB1] - OP0IWQTY;
        if (OP0IW03.OP3OHRQT[OPASUB1] > 0 /* there are rsrv qtys to adjust*/
         || OP3REC.OP3OHRQT[OPASUB1] > 0)
          if (OP3REC.OP3ALQT[OPASUB1] <= 0) /* they are not allocated*/
            if (OP0IW01.OP0IWCQT[OPASUB1] > 0) /* draw is being increased*/
              if (OP0IW01.OP0IWCQT[OPASUB1] > OP0IW03.OP3OHRQT[OPASUB1])
                OP0IW01.OP0IWQTY = OP0IW03.OP3OHRQT[OPASUB1];
                OP3REC.OP3OHRQT[OPASUB1] = OP3REC.OP3OHRQT[OPASUB1] + OP0IWQTY;
                OP0IW03.OP3OHRQT[OPASUB1] = 0;
              else
                OP0IW01.OP0IWQTY = OP0IW01.OP0IWCQT[OPASUB1];
                OP3REC.OP3OHRQT[OPASUB1] = OP3REC.OP3OHRQT[OPASUB1] + OP0IWQTY;
                OP0IW03.OP3OHRQT[OPASUB1] = OP0IW03.OP3OHRQT[OPASUB1] - OP0IWQTY;
              end
            else /* the draw is being decreased*/
              OP0IW01.OP0IWQTY = OP0IW01.OP0IWCQT[OPASUB1];
              OP0IW01.OP0IWQTY = OP0IW01.OP0IWQTY * -1; /* make change positive qty*/
              if (OP0IW01.OP0IWQTY > OP3REC.OP3OHRQT[OPASUB1])
                OP0IW01.OP0IWQTY = OP3REC.OP3OHRQT[OPASUB1];
                OP0IW03.OP3OHRQT[OPASUB1] = OP0IW03.OP3OHRQT[OPASUB1] + OP0IWQTY;
                OP3REC.OP3OHRQT[OPASUB1] = 0;
              else
                OP0IW01.OP0IWQTY = OP0IW01.OP0IWCQT[OPASUB1];
                OP3REC.OP3OHRQT[OPASUB1] = OP3REC.OP3OHRQT[OPASUB1] + OP0IWQTY;
                OP0IW03.OP3OHRQT[OPASUB1] = OP0IW03.OP3OHRQT[OPASUB1] - OP0IWQTY;
              end
            end
          else
            if (OP3REC.OP3ALQT[OPASUB1] > 0) /* draw was allocated... so*/
    /* the bulk was reserved (bulk qty may = 0) and the allocated*/
                /* draw qty needs to be added back (or subtracted) to the*/
                /* bulk reserved qty*/
              OP0IW01.OP0IWQTY = OP0IW01.OP0IWCQT[OPASUB1];
              OP0IW03.OP3OHRQT[OPASUB1] = OP0IW03.OP3OHRQT[OPASUB1] - OP0IWQTY;
            end
          end
        else
          if (OP3REC.OP3ALQT[OPASUB1] > 0) /* draw was allocated... so*/
                                  /* the bulk was reserved (bulk qty may =*/
                                   /* 0) and the allocated*/
              /* draw qty needs to be added back (or subtracted) to the*/
              /* bulk reserved qty*/
            OP0IW01.OP0IWQTY = OP0IW01.OP0IWCQT[OPASUB1];
            OP0IW03.OP3OHRQT[OPASUB1] = OP0IW03.OP3OHRQT[OPASUB1] - OP0IWQTY;
          end
        end
      end
      OPAREC.OPASUB1 = OPAREC.OPASUB1 + 1;
    end
    OP0IW03.OP2TDRWQ = OP0IW03.OP2TDRWQ + OP0IW01.OP0IWTOT;
    OP8REC.OP8TASK = "U ";
    OP8REC.OP8LOCAT[1] = "OP0I060";
    OP8REC.OP8LOCAT[2] = "OP0IS6E";
    call "DB1000" (OP8REC, OP0IW03, OPBREC) {isNoRefresh = yes, isExternal = yes};
    if (OPBREC.OPBSZRC == 0) /* good return*/
      OPAREC.OPASUB = 99;
    else
      if (OPBREC.OPBSZRC == 2 /* change count error codes*/
       || OPBREC.OPBSZRC == 3) /* re check availability*/
        VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
        VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
        sysLib.rollback();
        VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
        
        OP8REC.OP8TASK = "S ";
        call "DB1000" (OP8REC, OP0IW03, OPBREC) {isNoRefresh = yes, isExternal = yes};
        if (OPBREC.OPBSZRC == 0)
         /* Initialize non-existant sizes on the bulk to prevent S0C7's*/
         /* in CSP 4.1 - 10/07/93 - schase*/
          OPAREC.OPASUB2 = 1;
          while (OPAREC.OPASUB2 < 41)
            if (OP0IW03.OP3SZAFL[OPASUB2] != "Y")
              OP0IW03.SY5PRCUN[OPASUB2] = 0;
              OP0IW03.OP3ORGQT[OPASUB2] = 0;
              OP0IW03.OP3ONOQT[OPASUB2] = 0;
              OP0IW03.OP3ALQT[OPASUB2] = 0;
              OP0IW03.OP3OHRQT[OPASUB2] = 0;
              OP0IW03.OP3WPRQT[OPASUB2] = 0;
              OP0IW03.OP3SHPQT[OPASUB2] = 0;
              OP0IW03.OP3CNLQT[OPASUB2] = 0;
            end
            OPAREC.OPASUB2 = OPAREC.OPASUB2 + 1;
          end
          OPAREC.OPASUB1 = 1;
          while (OPAREC.OPASUB1 <= 40)
            if (OP3REC.OP3SZAFL[OPASUB1] == "Y")
              if (OP0IW01.OP0IWBDF == "DS")
                if (OP0IW01.OP0IWCQT[OPASUB1] > OP0IW03.OP3OHRQT[OPASUB1])
                  OPAREC.OPASUB = 6;
                  OPAREC.OPASUB1 = 41;
                end
              else
                if (OP0IW01.OP0IWCQT[OPASUB1] > OP0IW03.OP3ONOQT[OPASUB1])
                  OPAREC.OPASUB = 6;
                  OPAREC.OPASUB1 = 41;
                end
              end
            end
            OPAREC.OPASUB1 = OPAREC.OPASUB1 + 1;
          end
        else
          OP0IS88(); /* abend*/
        end
      else
        OP0IS88(); /* abend*/
      end
    end
  end



   /* now reset the status based on item values.*/

  OPWREC.OPWOPQTF[OP0IWSBS] = "N";
  OPWREC.OPWRSQTF[OP0IWSBS] = "N";
  OP0IW01.OP0IWFND = "N";
  sysVar.arrayIndex = 1;
  while (sysVar.arrayIndex <= 40)
    if (OP3REC.OP3SZAFL[sysVar.arrayIndex] == "Y" /* if size active*/
     && OP3REC.OP3ONOQT[sysVar.arrayIndex] > 0)  
      if (OP3REC.OP3ONOQT[sysVar.arrayIndex] > OP3REC.OP3OHRQT[sysVar.arrayIndex]
       && OP3REC.OP3OHRQT[sysVar.arrayIndex] > 0)
        OP0IW01.OP0IWFND = "P";
        OPWREC.OPWOPQTF[OP0IWSBS] = "Y";
        OPWREC.OPWRSQTF[OP0IWSBS] = "Y";
      else
        if (OP3REC.OP3ONOQT[sysVar.arrayIndex] == OP3REC.OP3OHRQT[sysVar.arrayIndex])
          if (OP0IW01.OP0IWFND == "P") /* don't reset 'pr' stat*/
             /* next sentence*/
          else
            if (OPWREC.OPWOPQTF[OP0IWSBS] == "Y")
              OP0IW01.OP0IWFND = "P";
            else
              OP0IW01.OP0IWFND = "R";
            end
            OPWREC.OPWRSQTF[OP0IWSBS] = "Y";
          end
        else
          if (OP0IW01.OP0IWFND == "R")
            OP0IW01.OP0IWFND = "P";
          end
          OPWREC.OPWOPQTF[OP0IWSBS] = "Y";
        end
      end
    end
    sysVar.arrayIndex = sysVar.arrayIndex + 1;
  end



   /* if previously allocated leave op0issc will*/
   /* set status*/

  if (OP3REC.OP2LNIST == "AL")
    return;
  end



      /* for the quantity ordered, set line item status*/
      /* appropriately.*/

  if (OP0IW01.OP0IWFND == "P")
    OP3REC.OP2LNIST = "PR"; /* set status to partailly reserved*/
  else
    if (OP0IW01.OP0IWFND == "R")
      OP3REC.OP2LNIST = "RS"; /* set status to reserved*/
    else
      OP3REC.OP2LNIST = "OP"; /* set status to open*/
    end
  end






  if (OPAREC.OPASUB == 6) /* if not enough availability*/
    OP0IW01.OP0IWRST = "Y"; /* set restart flag*/
    converseLib.validationFailed(297);
    exit stack;
  else
    OP0IW01.OP0IWRST = "N";
  end




end // end OP0ISUC

// add back to bulk - smart draw
Function OP0ISUD()


      /* *****************************************/
      /* * move data to pass record for formatter*/
      /* *****************************************/

  OP8REC.OP8LOCAT[1] = "OP0I060";
  OP8REC.OP8LOCAT[2] = "OP0ISUD";
  OP8REC.OP8LOCAT[3] = " ";
  OP8REC.OP8LOCAT[4] = " ";
  OP8REC.OP8MAP = "OP0IM001";




  OPAREC.OPAORDN = OP1REC.OP1BLKID;
  OP0IW02.OP1PARTN = OPAREC.OP1PARTN;
  OP0IW02.OP1CUOID = OP1REC.OP1BLKID;
  OP0IW02.OP2LNINB = OPWREC.OPWBKLIN[1];
  OP0IW02.OP1NORID = OPWREC.OP1NORID[1];
  OP0IS29(); /* re-read bulk order*/


   /* if this is a draw order, roll quantities back into bulk.*/
   /* total qty to roll back into bulk for review mode is*/
     /* op3rec - op0iwcqt. may have changed before delete!!!*/

  OP0IW01.OP0IWDQT = 0;
  if (OPWREC.OPWREVM == 7 /* if in review mode*/
   || OPWREC.OP2LNINB > 0)
    OPAREC.OPASUB = 1;
    while (OPAREC.OPASUB <= 40)
      if (OP3REC.OP3SZAFL[OPASUB] == "Y")
        OP0IW01.OP0IWDQT = OP0IW01.OP0IWDQT + OP3REC.OP3ONOQT[OPASUB];
        OP0IW01.OP0IWDQT = OP0IW01.OP0IWDQT - OP0IW01.OP0IWCQT[OPASUB];
        OP0IW01.OP0IWQTY = OP3REC.OP3ORGQT[OPASUB];
        OP0IW03.OP3ORGQT[OPASUB] = OP0IW03.OP3ORGQT[OPASUB] + OP0IWQTY;
        OP0IW01.OP0IWQTY = OP3REC.OP3ONOQT[OPASUB];
        OP0IW01.OP0IWQTY = OP0IW01.OP0IWQTY - OP0IW01.OP0IWCQT[OPASUB];
        OP0IW03.OP3ONOQT[OPASUB] = OP0IW03.OP3ONOQT[OPASUB] + OP0IWQTY;
        OP0IW01.OP0IWQTY = OP3REC.OP3OHRQT[OPASUB];
        OP0IW03.OP3OHRQT[OPASUB] = OP0IW03.OP3OHRQT[OPASUB] + OP0IWQTY;
        OP0IW01.OP0IWQTY = OP3REC.OP3ALQT[OPASUB];
        OP0IW03.OP3OHRQT[OPASUB] = OP0IW03.OP3OHRQT[OPASUB] + OP0IWQTY;
      end
      OPAREC.OPASUB = OPAREC.OPASUB + 1;
    end
  else
    OPAREC.OPASUB = 1;
    while (OPAREC.OPASUB <= 40)
      if (OP3REC.OP3SZAFL[OPASUB] == "Y")
        OP0IW01.OP0IWDQT = OP0IW01.OP0IWDQT + OP3REC.OP3ONOQT[OPASUB];
        OP0IW01.OP0IWQTY = OP3REC.OP3ORGQT[OPASUB];
        OP0IW03.OP3ORGQT[OPASUB] = OP0IW03.OP3ORGQT[OPASUB] + OP0IWQTY;
        OP0IW01.OP0IWQTY = OP3REC.OP3ONOQT[OPASUB];
        OP0IW03.OP3ONOQT[OPASUB] = OP0IW03.OP3ONOQT[OPASUB] + OP0IWQTY;
        OP0IW01.OP0IWQTY = OP3REC.OP3OHRQT[OPASUB];
        OP0IW03.OP3OHRQT[OPASUB] = OP0IW03.OP3OHRQT[OPASUB] + OP0IWQTY;
        OP0IW01.OP0IWQTY = OP3REC.OP3ALQT[OPASUB];
        OP0IW03.OP3OHRQT[OPASUB] = OP0IW03.OP3OHRQT[OPASUB] + OP0IWQTY;
      end
      OPAREC.OPASUB = OPAREC.OPASUB + 1;
    end
  end
  OP0IW03.OP2TDRWQ = OP0IW03.OP2TDRWQ - OP0IW01.OP0IWDQT;
  OP8REC.OP8TASK = "U ";
  call "DB1000" (OP8REC, OP0IW03, OPBREC) {isNoRefresh = yes, isExternal = yes};
  if (OPBREC.OPBSZRC != 0)
    OP0IS88(); /* abend*/
  end










end // end OP0ISUD

// write lost demand
Function OP0ISWR()



  TA1REC.TA1LOCAT[2] = "OP0ISWR";



  set OPTREC empty;



   /* get date and time*/

  XX0XS01();

  OPTREC.ZZZSDT = XX0XW01.XX0XWDAT;
  OPTREC.ZZZSTM = XX0XW01.XX0XWTIM;



  OPTREC.OPTDMND = "XD";
  OPTREC.XDVCD = COMMAREA.XDVCD;
  OPTREC.XSOCD = OP1REC.XSOCD;
  OPTREC.XOTCD = OP1REC.XOTCD;
  OPTREC.XWHCD = OP0IM002.XWHCD;
  OPTREC.OP1PARTN = OP1REC.OP1PARTN;
  OPTREC.OP1CUOID = OP1REC.OP1CUOID;



   /* format need date onto db2 form*/

  OP0IW01.OP0IWFDT = OP0IM002.OP0IMNDT;
  XX0XW01.XX0XWYY = OP0IW01.OP0IWFYY;
  XX0XW01.XX0XWMM = OP0IW01.OP0IWFMM;
  XX0XW01.XX0XWDD = OP0IW01.OP0IWFDD;
  OPTREC.OP1CUNDT = XX0XW01.XX0XWDAT;



  OPTREC.KUCCOID = OP1REC.KUCCOID;
  OPTREC.KUMSTRID = OP1REC.KUMSTRID;
  OPTREC.XNXCD = OP1REC.XNXCD;
  OPTREC.XGPCD = OP0IM002.XGPCD;
  OPTREC.OP1ORDBY = OP0IM002.OP1ORDBY;
  OPTREC.XXXPHNA = OP0IM002.XXXPHNA;
  OPTREC.XXXPHNP = OP0IM002.XXXPHNP;
  OPTREC.XXXPHNN = OP0IM002.XXXPHNN;
  if (OPTREC.XXXPHN == "0000000000") /* if no phn nbr, default to blanks*/
    OPTREC.XXXPHN = " ";
  end
  OPTREC.OPTWAITF = OP0IM002.OPTWAITF;
  OPTREC.OP1TBREP = OP1REC.OP1TBREP;


   /* format drop date onto db2 form*/

  OP0IW01.OP0IWFDT = OP0IM002.OP0IMDDT;
  XX0XW01.XX0XWYY = OP0IW01.OP0IWFYY;
  XX0XW01.XX0XWMM = OP0IW01.OP0IWFMM;
  XX0XW01.XX0XWDD = OP0IW01.OP0IWFDD;
  OPTREC.OPTDRPDT = XX0XW01.XX0XWDAT;



  OPTREC.SY1STNBR = OSEREC.SY1STNBR[1];
  OPTREC.SY2CLRID = OSEREC.SY2CLRID[1];
  OPTREC.XDMCD = OSEREC.XDMCD[1];



   /* get date and time*/

  XX0XS01();

  OPTREC.ZZZSDT = XX0XW01.XX0XWDAT;
  OPTREC.ZZZSTM = XX0XW01.XX0XWTIM;


   /* move in quantities*/
   /* if in review mode, move in the quantities from*/
   /* the op3rec, otherwise, move them in from the*/
   /* lost demand map, using size bucket subscripts*/
   /* from the order entry map- 1st or second screen*/

  if (OPWREC.OPWREVM == 7
   || OPWREC.OP2LNINB > 0) /* in review mode*/
    OP0IW01.OP0IWSBR = 1; /* size bucket subscript*/
    OP0IW01.OP0IWSLD = 1; /* lost demand subscript*/
    while (OP0IW01.OP0IWSBR <= 40
     && OP0IW01.OP0IWSLD <= 24)
      if (OP3REC.OP3SZAFL[OP0IWSBR] == "Y")
        OPTREC.OPTDMDQT[OP0IWSBR] = OP3REC.OP3ONOQT[OP0IWSBR];
        OP0IW01.OP0IWSLD = OP0IW01.OP0IWSLD + 1;
      end
      OP0IW01.OP0IWSBR = OP0IW01.OP0IWSBR + 1;
    end
  else
    OP0ISMQ(); /* move quantities from map*/
  end




   /* add lost demand - dorder.vlost001*/

  set SQLCA empty;



  call "IO3070" ("A ", SQLCA, OPTREC) {isNoRefresh = yes, isExternal = yes};



  if (SQLCA.VAGen_SQLCODE == 0) /* good return, clear*/
    OP0IW01.OP0IWLDF = "Y";
  else
    OP0IW01.OP0IWLDE = "Y";
    converseLib.validationFailed(536); /* lost demand not recorded*/
    TA1REC.TA1FUNC = "RETN";
    TA1REC.TA1DBASE = "DORDER"; /* data base name*/
    TA1REC.TA1TBLVU = "VLOST001"; /* table view*/
    OP0IW01.OP0IWKY1 = OPTREC.OPTDMND;
    OP0IW01.OP0IWKY2 = OPTREC.XDVCD;
    OP0IW01.OP0IWKY3 = OPTREC.XSOCD;
    OP0IW01.OP0IWKY4 = OPTREC.XOTCD;
    OP0IW01.OP0IWKY5 = OPTREC.XWHCD;
    OP0IW01.OP0IWKY6 = OPTREC.OP1PARTN;
    OP0IW01.OP0IWKY7 = OPTREC.OP1CUOID;
    TA1REC.TA1TBLKE = OP0IW01.OP0IWKEY; /* key value*/
    TA1REC.TA1LOCAT[3] = "IO3070"; /* i/o mod*/
    TA1REC.TA1LOCAT[4] = " ";
    move SQLCA to ERRSQLCA withV60Compat;
    call "TA0020" (TA1REC, ERRSQLCA) {isNoRefresh = yes, isExternal = yes};

  end


   /* **********************************************************/
end // end OP0ISWR

// set error messages
Function OP0ISYM()


   /* error messages have been passed from*/
   /* the edit program, and overlay one another as they are moved*/
   /* to ezemno. when finished, all fields in error will be*/
   /* bright and the cursor will be on the first field in error.*/
   /* the error message will be for the first field in error.*/


   /* errors in quantity fields*/



  if (OSEQT1FL == "Y") /* quantity  error*/
    if (OSEQTY1M == 9999)
      converseLib.validationFailed();
    else
      converseLib.validationFailed(OSEQTY1M);
    end
    set OP0IM002.OP0IMQT1[1] cursor, bold;
  end



   /* error in drop date*/

  if (OSEDRPDM != 0)
    if (OSEDRPDM == 9999)
      converseLib.validationFailed();
    else
      converseLib.validationFailed(OSEDRPDM);
    end
    set OP0IM002.OP0IMDDT cursor, bold;
  end



   /* error in add to waiting list flag*/

  if (OSEWAITM != 0)
    if (OSEWAITM == 9999)
      converseLib.validationFailed();
    else
      converseLib.validationFailed(OSEWAITM);
    end
    set OP0IM002.OPTWAITF cursor, bold;
  end





   /* error phone number*/

  if (OSEPHNNM != 0)
    if (OSEPHNNM == 9999)
      converseLib.validationFailed();
    else
      converseLib.validationFailed(OSEPHNNM);
    end
    set OP0IM002.XXXPHNN cursor, bold;
  end

  if (OSEPHNPM != 0)
    if (OSEPHNPM == 9999)
      converseLib.validationFailed();
    else
      converseLib.validationFailed(OSEPHNPM);
    end
    set OP0IM002.XXXPHNP cursor, bold;
  end

  if (OSEPHNAM != 0)
    if (OSEPHNAM == 9999)
      converseLib.validationFailed();
    else
      converseLib.validationFailed(OSEPHNAM);
    end
    set OP0IM002.XXXPHNA cursor, bold;
  end



   /* error in ordered by*/

  if (OSEORDBM != 0)
    if (OSEORDBM == 9999)
      converseLib.validationFailed();
    else
      converseLib.validationFailed(OSEORDBM);
    end
    set OP0IM002.OP1ORDBY cursor, bold;
  end




   /* ************************************************************/
end // end OP0ISYM

// load ta1rec with ta2rec
Function OP0ISYT()

   /* loads ta1rec for post ta0040 abends*/


  TA1REC.TA1FUNC = "POST";
  TA1REC.TA1LOCAT[3] = "TA0040 ";
  TA1REC.TA1LOCAT[4] = "CURR +60";
  call "TA0020" (TA1REC, ERRSQLCA) {isNoRefresh = yes, isExternal = yes};


   /* *************************************************/
end // end OP0ISYT

//*** RECORD=OP0IW01 ****
// * op0iw01 is the working-storage used only by appl op0i.
// *
// * it contains fields to:
// *   format product number for display
// *   subscripts for various arrays
// *   first & last sizes (both actual and those with qty ne 0.
// *
// ------------------------------------------------------------
//  date     signon  description
// --------  ------  ------------------------------------------
// 01/29/92  trober  added element for label code sub-script
// 02/29/92  jwils1  added op0iwpdt for crested product chgs
// 08/12/92  JLoyer  added op0iw-bk-sesn-required
//                         op0iw-default-bk-sesn
//                         op0iw-multi-bk-sesn-msg
//                         op0iw-ob1470-need-dt
//                         op0iw-num-1-4 (grp level)
// 10/23/92  dcaust  added op0iw-pricing-factor
// 12/15/92  dcaust  added op0iw-save-price-1 and
//                         op0iw-save-price-2
//                         for round b-grade price up
//                         to the nickel.
// 06/28/93  sjob    added op0iw-hold-ezetst-val
// 03/29/00  JJOSEP        TT#4752 - BSSA PROJECT
//         & RHARAT  added OP0IW-BSSA-PRODUCT,
//                         OP0IW-BSSA-OLD-HND,
//                         OP0IW-BSSA-HND-CD,
//                         OP0IW-BSSA-SUB-FLG,
//                         OP0IW-BSSA-SUB,
//                         OP0IW-HNDL-ON-CST,
//                         OP0IW-SYST-HNDCHG-OVRD,
//                         OP0IW-USER-HNDCHG-OVRD.
// *
// ***********************
Record OP0IW01 type basicRecord
  5 OP0IW01G OP0IW01G ; 
    10 OP0IWPUM OP0IWPUM ; 
    10 OP0IWLTM OP0IWLTM ; 
    10 OP2SUBQT OP2SUBQT ; 
    10 OP0IWP23 OP0IWP23 ; 
    10 OP0IWHAR OP0IWHAR ; 
    10 OP0IWAVA OP0IWAVA [40] ; 
    10 OP0IWAVQ OP0IWAVQ [40] ; 
    10 XUMCONVF XUMCONVF ; 
    10 XLCCD XLCCD ; 
    10 OP0IWOAF OP0IWOAF ; 
    10 OP0IWOAC OP0IWOAC ; 
    10 OP0IWOAO OP0IWOAO ; 
    10 OP0IWOND OP0IWOND ; 
      15 OP0IWNYM OP0IWNYM ; 
      15 * num(2) ; 
    10 OP0IWOBD OP0IWOBD ; 
      15 OP0IWBYM OP0IWBYM ; 
      15 * num(2) ; 
    10 OP0IWDAV OP0IWDAV ; 
    10 OP0IWPOF OP0IWPOF ; 
      15 OP0IWS03 OP0IWS03 ; 
        20 OP0IWPMM OP0IWPMM ; 
        20 OP0IWS04 OP0IWS04 ; 
      15 OP0IWPDD OP0IWPDD ; 
        20 OP3PRCOF OP3PRCOF ; 
        20 OP0IWS05 OP0IWS05 ; 
    10 OP0IWHTP OP0IWHTP ; 
      15 XHDUCHFL XHDUCHFL ; 
      15 OP2HCHGO OP2HCHGO ; 
    10 OP0IWALO OP0IWALO ; 
    10 OP0IWAVD OP0IWAVD ; 
    10 OP0IWPND OP0IWPND ; 
    10 OP0IWMOR OP0IWMOR ; 
    10 OP0IWSCR OP0IWSCR ; 
    10 OP0IWEDT OP0IWEDT ; 
    10 OP0IWFND OP0IWFND ; 
    10 OP0IWCHG OP0IWCHG ; 
    10 OP0IWPF5 OP0IWPF5 ; 
    10 OP0IWPF6 OP0IWPF6 ; 
    10 OP0IWP21 OP0IWP21 ; 
    10 OP0IWP24 OP0IWP24 ; 
    10 OP0IWREJ OP0IWREJ ; 
    10 OP0IWDUP OP0IWDUP ; 
    10 OP0IWPRD OP0IWPRD ; 
      15 SY1STNBR SY1STNBR ; 
      15 OP0IWS01 OP0IWS01 ; 
      15 SY2CLRID SY2CLRID ; 
      15 OP0IWS02 OP0IWS02 ; 
      15 XDMCD XDMCD ; 
    10 OP2CGPCD OP2CGPCD ; 
    10 OP0IWSBH OP0IWSBH ; 
    10 OP0IWSBM OP0IWSBM ; 
    10 OP0IWSBP OP0IWSBP ; 
    10 OP0IWSBR OP0IWSBR ; 
    10 OP0IWSB2 OP0IWSB2 ; 
    10 OP0IWSBS OP0IWSBS ; 
    10 OP0IWSBO OP0IWSBO ; 
    10 OP0IWNSO OP0IWNSO ; 
    10 OP0IWVSZ OP0IWVSZ ; 
    10 OP0IWNXT OP0IWNXT ; 
    10 OP0IWSZF OP0IWSZF ; 
    10 OP0IWSZL OP0IWSZL ; 
    10 OP0IWSMF OP0IWSMF ; 
    10 OP0IWSML OP0IWSML ; 
    10 OP0IWWHS OP0IWWHS ; 
    10 OP0IWCWH OP0IWCWH ; 
    10 OP0IWCND OP0IWCND ; 
    10 OP1CUNDT OP1CUNDT ; 
    10 OP0IWPAO OP0IWPAO ; 
    10 OP0IWPHC OP0IWPHC ; 
    10 OP0IWSPP OP0IWSPP ; 
    10 OP0IWPSC OP0IWPSC ; 
    10 OP0IWPED OP0IWPED ; 
    10 OP0IWSTP OP0IWSTP ; 
    10 OP0IWCLP OP0IWCLP ; 
    10 OP0IWNSN OP0IWNSN ; 
    10 OP0IWPRC OP0IWPRC ; 
    10 OP0IWPCT OP0IWPCT ; 
    10 OP0IWPRO OP0IWPRO ; 
    10 OP0IWPRN OP0IWPRN ; 
    10 OP0IWPAL OP0IWPAL ; 
    10 OP0IWPAD OP0IWPAD ; 
    10 OP0IWPSZ OP0IWPSZ ; 
    10 OP0IWMSG OP0IWMSG ; 
      15 OP0IWMSA OP0IWMSA ; 
      15 OP0IWMSB OP0IWMSB ; 
        20 OP0IWMSC OP0IWMSC [9] ; 
      15 OP0IWMSD OP0IWMSD ; 
    10 OP0IWVSF OP0IWVSF ; 
    10 OP0IWVSL OP0IWVSL ; 
    10 OP3SZARY OP3SZARY ; 
      15 OP3SZAFL OP3SZAFL ; 
      15 OP2PRCOF OP2PRCOF ; 
      15 SY5PRCUN SY5PRCUN ; 
      15 OP3ORGQT OP3ORGQT ; 
      15 OP3ONOQT OP3ONOQT ; 
      15 OP3ALQT OP3ALQT ; 
      15 OP3OHRQT OP3OHRQT ; 
      15 OP3WPRQT OP3WPRQT ; 
      15 OP3SHPQT OP3SHPQT ; 
      15 OP3CNLQT OP3CNLQT ; 
    10 XDSWHSEF XDSWHSEF ; 
    10 OP0IWRST OP0IWRST ; 
    10 OP0IWCQT OP0IWCQT [40] ; 
    10 OP0IWDQT OP0IWDQT ; 
    10 OP0IWBDF OP0IWBDF ; 
    10 OP0IWQTY OP0IWQTY ; 
    10 OP0IWSSP OP0IWSSP [40] ; 
    10 XSZNBRSZ XSZNBRSZ ; 
    10 OP0IWVAR OP0IWVAR ; 
    10 OP0IWSZC OP0IWSZC ; 
    10 OP0IWTOT OP0IWTOT ; 
    10 OP0IWTM1 OP0IWTM1 ; 
      15 OP0IWTHF OP0IWTHF ; 
      15 * char(1) ; 
      15 OP0IWTMF OP0IWTMF ; 
      15 * char(1) ; 
      15 OP0IWTSF OP0IWTSF ; 
    10 OP0IWTM2 OP0IWTM2 ; 
      15 OP0IWTM3 OP0IWTM3 ; 
        20 OP0IWTHL OP0IWTHL ; 
        20 OP0IWTML OP0IWTML ; 
      15 OP0IWTSL OP0IWTSL ; 
    10 OP0IWMM1 OP0IWMM1 ; 
    10 OP0IWSS1 OP0IWSS1 ; 
    10 OP0IWIKY OP0IWIKY ; 
      15 OP0IWPRT OP0IWPRT ; 
      15 OP0IWCID OP0IWCID ; 
      15 OP0IWNID OP0IWNID ; 
      15 OP0IWLIN OP0IWLIN ; 
    10 OP0IWNDT OP0IWNDT ; 
      15 OP0IWNYY OP0IWNYY ; 
      15 OP0IWNMM OP0IWNMM ; 
      15 OP0IWNDD OP0IWNDD ; 
    10 OP0IWFDA OP0IWFDA ; 
      15 XOTCD XOTCD ; 
      15 OP0IWCDT OP0IWCDT ; 
        20 OP0IWCMM OP0IWCMM ; 
        20 OP0IWCDD OP0IWCDD ; 
      15 OP0IWHS OP0IWHS ; 
    10 CAITEM CAITEM ; 
      15 OP0IWXOT OP0IWXOT ; 
      15 XWHCD XWHCD ; 
      15 OP0IWPSS OP0IWPSS ; 
      15 OP0IWPSK OP0IWPSK ; 
      15 OP0IWPSD OP0IWPSD ; 
      15 XOWCD XOWCD ; 
      15 OP0IWPS1 OP0IWPS1 ; 
      15 OP0IWPS2 OP0IWPS2 ; 
    10 OP2PRDSF OP2PRDSF ; 
    10 OP2SSTYN OP2SSTYN ; 
    10 OP2SCLCD OP2SCLCD ; 
    10 OP2SDMCD OP2SDMCD ; 
    10 OP0IWPDF OP0IWPDF ; 
    10 OP0IWPDO OP0IWPDO ; 
    10 OP0IWERR OP0IWERR ; 
      15 OP0IWRTN OP0IWRTN ; 
      15 OP0IWSTY OP0IWSTY ; 
      15 OP0IWCLR OP0IWCLR ; 
    10 OP0IWP20 OP0IWP20 ; 
    10 OP0IW-DAYS-PAST-CUTOFF OP0IW-DAYS-PAST-CUTOFF ; 
    10 OP0IWSND OP0IWSND ; 
    10 OP1DSADT OP1DSADT ; 
    10 OP0IWASZ OP0IWASZ ; 
    10 OP0IWDTN OP0IWDTN [40] ; 
    10 OP0IWETN OP0IWETN ; 
      15 OP0IWNCC OP0IWNCC ; 
      15 OP0IWNYR OP0IWNYR ; 
      15 OP0IWNMN OP0IWNMN ; 
      15 OP0IWNDY OP0IWNDY ; 
    10 OP0IWAED OP0IWAED ; 
      15 OP0IWAEM OP0IWAEM ; 
      15 OP0IWAEC OP0IWAEC ; 
      15 OP0IWAEY OP0IWAEY ; 
    10 OP0IWSBD OP0IWSBD ; 
    10 OP0IWSED OP0IWSED ; 
    10 OP0IWFIL OP0IWFIL ; 
    10 OP0IWNDC OP0IWNDC ; 
    10 OP0IWQTC OP0IWQTC ; 
    10 OP0IWDKY OP0IWDKY ; 
      15 OP0IWDXT OP0IWDXT ; 
      15 OP0IWDND OP0IWDND ; 
    10 OP0IWPR1 OP0IWPR1 ; 
    10 OP0IWPR2 OP0IWPR2 ; 
    10 OP0IWCRS OP0IWCRS ; 
    10 OP0IWSFL OP0IWSFL ; 
    10 OP0IWEZ1 OP0IWEZ1 ; 
    10 OP0IWDT1 OP0IWDT1 ; 
      15 OP0IWDT2 OP0IWDT2 ; 
      15 OP0IWDT3 OP0IWDT3 ; 
    10 OP0IWT1 OP0IWT1 ; 
      15 OP0IWTK1 OP0IWTK1 ; 
      15 OP0IWTK2 OP0IWTK2 ; 
      15 OP0IWTK3 OP0IWTK3 ; 
      15 OP0IWTK4 OP0IWTK4 ; 
      15 OP0IWTK5 OP0IWTK5 ; 
      15 OP0IWTK6 OP0IWTK6 ; 
    10 OP0IWELI OP0IWELI ; 
    10 OP0IWAUT OP0IWAUT ; 
    10 OP0IWDIG OP0IWDIG ; 
      15 OP0IWDI1 OP0IWDI1 ; 
      15 OP0IWDI2 OP0IWDI2 ; 
      15 OP0IWDI3 OP0IWDI3 ; 
      15 OP0IWDI4 OP0IWDI4 ; 
    10 OP0IWNPA OP0IWNPA ; 
      15 OP0IWNP1 OP0IWNP1 ; 
      15 OP0IWNP2 OP0IWNP2 ; 
      15 OP0IWNP3 OP0IWNP3 ; 
      15 OP0IWNP4 OP0IWNP4 ; 
      15 OP0IWNP5 OP0IWNP5 ; 
    10 OP0IWNIM OP0IWNIM ; 
      15 OP0IWNI1 OP0IWNI1 ; 
      15 OP0IWNI2 OP0IWNI2 ; 
      15 OP0IWNI3 OP0IWNI3 ; 
      15 OP0IWNI4 OP0IWNI4 ; 
      15 OP0IWNI5 OP0IWNI5 ; 
    10 OP0IWZPR OP0IWZPR ; 
    10 OP0IWIPC OP0IWIPC ; 
    10 OP0IWLDF OP0IWLDF ; 
    10 OP0IWLDE OP0IWLDE ; 
    10 OP0IWSLD OP0IWSLD ; 
    10 OP0IWFDT OP0IWFDT ; 
      15 OP0IWFMM OP0IWFMM ; 
      15 OP0IWFDD OP0IWFDD ; 
      15 OP0IWFYY OP0IWFYY ; 
    10 OP0IWCWM OP0IWCWM ; 
      15 OP0IWCM1 OP0IWCM1 ; 
      15 OP0IWCM2 OP0IWCM2 ; 
      15 OP0IWCM3 OP0IWCM3 ; 
      15 OP0IWCM4 OP0IWCM4 ; 
    10 OP0IWKEY OP0IWKEY ; 
      15 OP0IWKY1 OP0IWKY1 ; 
      15 OP0IWKY2 OP0IWKY2 ; 
      15 OP0IWKY3 OP0IWKY3 ; 
      15 OP0IWKY4 OP0IWKY4 ; 
      15 OP0IWKY5 OP0IWKY5 ; 
      15 OP0IWKY6 OP0IWKY6 ; 
      15 OP0IWKY7 OP0IWKY7 ; 
    10 XAUCD XAUCD ; 
    10 OP0IWNWH OP0IWNWH ; 
    10 OP0IWNBR OP0IWNBR ; 
      15 OP0IWNB1 OP0IWNB1 ; 
      15 OP0IWNB2 OP0IWNB2 ; 
    10 OP0IWPSB OP0IWPSB ; 
    10 OP0IWNUM OP0IWNUM ; 
    10 KUMPHN KUMPHN ; 
      15 OP0IWPCH OP0IWPCH [15] ; 
    10 OP0IWFPH OP0IWFPH ; 
      15 OP0IWPHA OP0IWPHA ; 
      15 OP0IWD1 OP0IWD1 ; 
      15 OP0IWPHP OP0IWPHP ; 
      15 OP0IWD2 OP0IWD2 ; 
      15 OP0IWPHN OP0IWPHN ; 
    10 OP0IWBBD OP0IWBBD ; 
    10 OP0IWFTF OP0IWFTF ; 
    10 OP0IWBAV OP0IWBAV ; 
    10 OP0IWP01 OP0IWP01 ; 
    10 OP0IWSTN OP0IWSTN ; 
    10 OP0IWESP OP0IWESP ; 
    10 OP0IWAVX OP0IWAVX ; 
    10 XHDKEY XHDKEY ; 
      15 XHDCD XHDCD ; 
      15 XGPCD XGPCD ; 
    10 OP0IW-LABL-CD-SUB OP0IW-LABL-CD-SUB ; 
    10 OP0IW-PWRLBCD-GRP OP0IW-PWRLBCD-GRP ; 
      15 OP0IW-PWRLBCD OP0IW-PWRLBCD [2] ; 
    10 OP0IWPDT OP0IWPDT ; 
    10 OP0IW-KUCCOID OP0IW-KUCCOID ; 
    10 OP0IW-BK-SESN-REQUIRED OP0IW-BK-SESN-REQUIRED ; 
    10 OP0IW-DEFAULT-BK-SESN OP0IW-DEFAULT-BK-SESN ; 
    10 OP0IW-MULTI-BK-SESN-MSG OP0IW-MULTI-BK-SESN-MSG ; 
    10 OP0IW-BK-SESN-ERR OP0IW-BK-SESN-ERR ; 
    10 OP0IW-CHECK-BK-SESN OP0IW-CHECK-BK-SESN ; 
    10 OP0IW-OB1470-OP1CUNDT OP0IW-OB1470-OP1CUNDT ; 
    10 OP0IW-NUM-1-4 OP0IW-NUM-1-4 ; 
      15 OP0IW-NUM-1-2 OP0IW-NUM-1-2 ; 
      15 OP0IW-NUM-3-4 OP0IW-NUM-3-4 ; 
    10 OP0IW-CHA-BK-YY OP0IW-CHA-BK-YY ; 
    10 OP0IW-OB1470-ERR-DESC OP0IW-OB1470-ERR-DESC ; 
      15 OP0IW-OB1470-OP1PARTN OP0IW-OB1470-OP1PARTN ; 
      15 OP0IW-OB1470-DASH-1 OP0IW-OB1470-DASH-1 ; 
      15 OP0IW-OB1470-OP1CUOID OP0IW-OB1470-OP1CUOID ; 
      15 OP0IW-OB1470-DASH-2 OP0IW-OB1470-DASH-2 ; 
      15 OP0IW-OB1470-OP1NORID OP0IW-OB1470-OP1NORID ; 
      15 OP0IW-OB1470-DASH-3 OP0IW-OB1470-DASH-3 ; 
      15 OP0IW-OB1470-OP2LNINB OP0IW-OB1470-OP2LNINB ; 
      15 OP0IW-OB1470-DASH-4 OP0IW-OB1470-DASH-4 ; 
      15 OP0IW-OB1470-XGPCD OP0IW-OB1470-XGPCD ; 
      15 OP0IW-OB1470-DASH-5 OP0IW-OB1470-DASH-5 ; 
      15 OP0IW-OB1470-SY1STNBR OP0IW-OB1470-SY1STNBR ; 
      15 OP0IW-OB1470-DASH-6 OP0IW-OB1470-DASH-6 ; 
      15 OP0IW-OB1470-SY2CLRID OP0IW-OB1470-SY2CLRID ; 
      15 OP0IW-OB1470-DASH-7 OP0IW-OB1470-DASH-7 ; 
      15 OP0IW-OB1470-XDMCD OP0IW-OB1470-XDMCD ; 
      15 OP0IW-OB1470-DASH-8 OP0IW-OB1470-DASH-8 ; 
      15 OP0IW-OB1470-NEED-DT OP0IW-OB1470-NEED-DT ; 
      15 OP0IW-OB1470-DASH-9 OP0IW-OB1470-DASH-9 ; 
      15 OP0IW-OB1470-XOTCD OP0IW-OB1470-XOTCD ; 
      15 OP0IW-OB1470-DASH-10 OP0IW-OB1470-DASH-10 ; 
      15 OP0IW-OB1470-XDVCD OP0IW-OB1470-XDVCD ; 
    10 OP0IW-PRICING-FACTOR OP0IW-PRICING-FACTOR ; 
    10 OP0IW-XOWCD-FOUND-FL OP0IW-XOWCD-FOUND-FL ; 
    10 OP0IW-PROMO-XOWCD-FL OP0IW-PROMO-XOWCD-FL ; 
    10 OP0IW-BLANK-BULK-ONLY-FL OP0IW-BLANK-BULK-ONLY-FL ; 
    10 OP0IW-AVOREC-ERRDIAG OP0IW-AVOREC-ERRDIAG ; 
      15 OP0IW-AVOREC-XOWCD OP0IW-AVOREC-XOWCD ; 
      15 OP0IW-AVOREC-RTN-STAT OP0IW-AVOREC-RTN-STAT ; 
      15 OP0IW-AVOREC-SY1STYNBR OP0IW-AVOREC-SY1STYNBR ; 
      15 OP0IW-AVOREC-SY2CLRID OP0IW-AVOREC-SY2CLRID ; 
      15 OP0IW-AVOREC-XDMCD OP0IW-AVOREC-XDMCD ; 
      15 OP0IW-AVOREC-DATE OP0IW-AVOREC-DATE ; 
      15 OP0IW-AVOREC-OPTION OP0IW-AVOREC-OPTION ; 
    10 OP0IW-SAVE-PRICE-1 OP0IW-SAVE-PRICE-1 ; 
    10 OP0IW-SAVE-PRICE-2 OP0IW-SAVE-PRICE-2 ; 
    10 OP0IW-VOPPGM-READ OP0IW-VOPPGM-READ ; 
    10 OP0IW-HOLD-EZETST-VAL OP0IW-HOLD-EZETST-VAL ; 
    10 OP0IW-WSY2000-FND-FLAG OP0IW-WSY2000-FND-FLAG ; 
    10 OP0IW-WSY2000-POST-1 OP0IW-WSY2000-POST-1 ; 
      15 OP0IW-WSY2000-GPC-CD OP0IW-WSY2000-GPC-CD ; 
      15 OP0IW-WSY2000-STY-NBR OP0IW-WSY2000-STY-NBR ; 
      15 OP0IW-WSY2000-COLR-CD OP0IW-WSY2000-COLR-CD ; 
      15 OP0IW-WSY2000-DIM-CD OP0IW-WSY2000-DIM-CD ; 
      15 OP0IW-WSY2000-PROD-REG-CD OP0IW-WSY2000-PROD-REG-CD ; 
      15 OP0IW-WSY2000-RETURN-CD OP0IW-WSY2000-RETURN-CD ; 
    10 OP0IW-BSSA-PRODUCT char(1) ; // Flag for BSSA products
    10 OP0IW-BSSA-OLD-HND char(3) ; // Handling code to be replaced
    10 OP0IW-BSSA-HND-CD char(3) ; // Set the new Handling code
    10 OP0IW-BSSA-SUB-FLG char(1) ; // Flag set if hndl substituted
    10 OP0IW-BSSA-SUB num(1) ; // subscript for bssa logic
    10 OP0IW-HNDL-ON-CST char(1) ; // flag to chk if hndl is on cust
    10 OP0IW-SYST-HNDCHG-OVRD char(1) ; // hand charge overrdn for bssa
    10 OP0IW-USER-HNDCHG-OVRD char(1) ; // hand change overrdn by user
end // end OP0IW01

//*** RECORD=OP0IW02 ****
// ***********************  ITEM TABLE  ***********************
// 
// this is the ws version of the db2 item record op2rec.
// 
// 
// 
// ***********************
Record OP0IW02 type basicRecord
  5 OP2GROUP OP2GROUP ; 
    10 OP2KEY OP2KEY ; 
      15 OP1PARTN OP1PARTN ; 
      15 OP1CUOID OP1CUOID ; 
      15 OP1NORID OP1NORID ; 
      15 OP2LNINB OP2LNINB ; 
    10 OP2CPLNB OP2CPLNB ; 
    10 XGPCD XGPCD ; 
    10 SY1STNBR SY1STNBR ; 
    10 SY2CLRID SY2CLRID ; 
    10 XDMCD XDMCD ; 
    10 KUIPRDID KUIPRDID ; 
    10 XUMCD XUMCD ; 
    10 XOWCD XOWCD ; 
    10 OP2PRDSF OP2PRDSF ; 
    10 OP2SSTYN OP2SSTYN ; 
    10 OP2SCLCD OP2SCLCD ; 
    10 OP2SDMCD OP2SDMCD ; 
    10 OP2SUBQT OP2SUBQT ; 
    10 OPRBNOID OPRBNOID ; 
    10 OP2TDRWQ OP2TDRWQ ; 
    10 OP2CGPCD OP2CGPCD ; 
    10 OP2KSTYF OP2KSTYF ; 
    10 OP2GTSZF OP2GTSZF ; 
    10 XEGCD XEGCD ; 
    10 PC2INSEG PC2INSEG ; 
    10 XPGCD XPGCD ; 
    10 XBK-BK-SESN-CD XBK-BK-SESN-CD ; 
    10 OP-BK-YR OP-BK-YR ; 
    10 OP-BK-MO OP-BK-MO ; 
    10 OP2MSCDP OP2MSCDP ; 
    10 OP2PGRPF OP2PGRPF ; 
    10 OP2FSTFL OP2FSTFL ; 
    10 XQACD XQACD ; 
    10 OP2LNIST OP2LNIST ; 
    10 OP2LNSDT OP2LNSDT ; 
    10 XBRCD XBRCD ; 
    10 XDNCD XDNCD ; 
    10 XRSCD XRSCD ; 
    10 XAFCD XAFCD ; 
    10 OP1ALFDT OP1ALFDT ; 
    10 OP1BOFL OP1BOFL ; 
    10 XHDCD XHDCD [5] ; 
    10 XHDCHG XHDCHG [5] ; 
    10 OP2HCHGO OP2HCHGO [5] ; 
    10 PWRLBCD PWRLBCD [2] ; 
    10 OP-CUST-LABL-PRTFL OP-CUST-LABL-PRTFL ; 
    10 XOMCD XOMCD [4] ; 
    10 XMTCD XMTCD [4] ; 
    10 OP2OMQTY OP2OMQTY [4] ; 
    10 OP2OMDT OP2OMDT [4] ; 
    10 OP1MTREP OP1MTREP [4] ; 
    10 OP2GBLOF OP2GBLOF ; 
    10 OP2PRCOF OP2PRCOF ; 
    10 OP2PRCVF OP2PRCVF ; 
    10 OP2TOBKQ OP2TOBKQ ; 
    10 OP2TORGQ OP2TORGQ ; 
    10 OP2TONOQ OP2TONOQ ; 
    10 OP2TALCQ OP2TALCQ ; 
    10 OP2TOHRQ OP2TOHRQ ; 
    10 OP2TWIPQ OP2TWIPQ ; 
    10 OP2TSHPQ OP2TSHPQ ; 
    10 OP2TCNLQ OP2TCNLQ ; 
    10 OP2AUPRC OP2AUPRC ; 
    10 OP2LNIVL OP2LNIVL ; 
    10 OP2NSIZE OP2NSIZE ; 
    10 XDZ-DATA-DIST-CD XDZ-DATA-DIST-CD ; 
    10 ZZ-CS400-CHNG-DT ZZ-CS400-CHNG-DT ; 
    10 ZZ-CS400-CHNG-HHMM ZZ-CS400-CHNG-HHMM ; 
    10 ZZ-DS400-CHNG-DT ZZ-DS400-CHNG-DT ; 
    10 ZZ-DS400-CHNG-HHMM ZZ-DS400-CHNG-HHMM ; 
    10 ZZZSZCHG ZZZSZCHG ; 
    10 ZZZSDT ZZZSDT ; 
    10 ZZZSTM ZZZSTM ; 
    10 ZZZCHGDT ZZZCHGDT ; 
    10 ZZZCHGTM ZZZCHGTM ; 
    10 ZZZCHGCT ZZZCHGCT ; 
end // end OP0IW02

//*** RECORD=OP0IW03 ****
// ***********************  ITEM TABLE  ***********************
// 
// this is the ws version of the db1000 item/size view op3rec.
// 
// 
// 
// ***********************
Record OP0IW03 type basicRecord
  5 OP3GROUP OP3GROUP ; 
    10 OP2KEY OP2KEY ; 
      15 OP1PARTN OP1PARTN ; 
      15 OP1CUOID OP1CUOID ; 
      15 OP1NORID OP1NORID ; 
      15 OP2LNINB OP2LNINB ; 
    10 OP2CPLNB OP2CPLNB ; 
    10 XGPCD XGPCD ; 
    10 SY1STNBR SY1STNBR ; 
    10 SY2CLRID SY2CLRID ; 
    10 XDMCD XDMCD ; 
    10 KUIPRDID KUIPRDID ; 
    10 XUMCD XUMCD ; 
    10 XOWCD XOWCD ; 
    10 OP2PRDSF OP2PRDSF ; 
    10 OP2SSTYN OP2SSTYN ; 
    10 OP2SCLCD OP2SCLCD ; 
    10 OP2SDMCD OP2SDMCD ; 
    10 OP2SUBQT OP2SUBQT ; 
    10 OPRBNOID OPRBNOID ; 
    10 OP2TDRWQ OP2TDRWQ ; 
    10 OP2CGPCD OP2CGPCD ; 
    10 OP2KSTYF OP2KSTYF ; 
    10 OP2GTSZF OP2GTSZF ; 
    10 XEGCD XEGCD ; 
    10 PC2INSEG PC2INSEG ; 
    10 XPGCD XPGCD ; 
    10 XBK-BK-SESN-CD XBK-BK-SESN-CD ; 
    10 OP-BK-YR OP-BK-YR ; 
    10 OP-BK-MO OP-BK-MO ; 
    10 OP2MSCDP OP2MSCDP ; 
    10 OP2PGRPF OP2PGRPF ; 
    10 OP2FSTFL OP2FSTFL ; 
    10 XQACD XQACD ; 
    10 OP2LNIST OP2LNIST ; 
    10 OP2LNSDT OP2LNSDT ; 
    10 XBRCD XBRCD ; 
    10 XDNCD XDNCD ; 
    10 XRSCD XRSCD ; 
    10 XAFCD XAFCD ; 
    10 OP1ALFDT OP1ALFDT ; 
    10 OP1BOFL OP1BOFL ; 
    10 XHDCD XHDCD [5] ; 
    10 XHDCHG XHDCHG [5] ; 
    10 OP2HCHGO OP2HCHGO [5] ; 
    10 PWRLBCD PWRLBCD [2] ; 
    10 OP-CUST-LABL-PRTFL OP-CUST-LABL-PRTFL ; 
    10 XOMCD XOMCD [4] ; 
    10 XMTCD XMTCD [4] ; 
    10 OP2OMQTY OP2OMQTY [4] ; 
    10 OP2OMDT OP2OMDT [4] ; 
    10 OP1MTREP OP1MTREP [4] ; 
    10 OP2GBLOF OP2GBLOF ; 
    10 OP2PRCOF OP2PRCOF ; 
    10 OP2PRCVF OP2PRCVF ; 
    10 OP2TOBKQ OP2TOBKQ ; 
    10 OP2TORGQ OP2TORGQ ; 
    10 OP2TONOQ OP2TONOQ ; 
    10 OP2TALCQ OP2TALCQ ; 
    10 OP2TOHRQ OP2TOHRQ ; 
    10 OP2TWIPQ OP2TWIPQ ; 
    10 OP2TSHPQ OP2TSHPQ ; 
    10 OP2TCNLQ OP2TCNLQ ; 
    10 OP2AUPRC OP2AUPRC ; 
    10 OP2LNIVL OP2LNIVL ; 
    10 OP2NSIZE OP2NSIZE ; 
    10 XDZ-DATA-DIST-CD XDZ-DATA-DIST-CD ; 
    10 ZZ-CS400-CHNG-DT ZZ-CS400-CHNG-DT ; 
    10 ZZ-CS400-CHNG-HHMM ZZ-CS400-CHNG-HHMM ; 
    10 ZZ-DS400-CHNG-DT ZZ-DS400-CHNG-DT ; 
    10 ZZ-DS400-CHNG-HHMM ZZ-DS400-CHNG-HHMM ; 
    10 ZZZSZCHG ZZZSZCHG ; 
    10 ZZZSDT ZZZSDT ; 
    10 ZZZSTM ZZZSTM ; 
    10 ZZZCHGDT ZZZCHGDT ; 
    10 ZZZCHGTM ZZZCHGTM ; 
    10 ZZZCHGCT ZZZCHGCT ; 
    10 OP3SZARY OP3SZARY [40] ; 
      15 OP3SZAFL OP3SZAFL ; 
      15 OP3PRCOF OP3PRCOF ; 
      15 SY5PRCUN SY5PRCUN ; 
      15 OP3ORGQT OP3ORGQT ; 
      15 OP3ONOQT OP3ONOQT ; 
      15 OP3ALQT OP3ALQT ; 
      15 OP3OHRQT OP3OHRQT ; 
      15 OP3WPRQT OP3WPRQT ; 
      15 OP3SHPQT OP3SHPQT ; 
      15 OP3CNLQT OP3CNLQT ; 
end // end OP0IW03

Record OP0IW04 type basicRecord
  10 OP0IWPAS OP0IWPAS ; 
    15 OP0IWTSK OP0IWTSK ; 
    15 OP0IWLDT OP0IWLDT ; 
    15 OP0IWHDT OP0IWHDT ; 
end // end OP0IW04

Record OP0IW05 type basicRecord
  5 OP0IWPA2 OP0IWPA2 ; 
    10 OP0IWTSK OP0IWTSK ; 
    10 OP0IWDTE OP0IWDTE ; 
end // end OP0IW05

//*** RECORD=OPNREC ****
// opnrec is ther working-storage and the parameter record
// it contains the key information used to read the avail
// records. it also contains the avail matrix used to fill
// in the map of the calling program
// 05/18/89 XSNCD CHANGED TO XSECD FOR C. RAINEY...
// **********************
Record OPNREC type basicRecord
  10 OPNTRAN OPNTRAN ; 
  10 OPNMSG OPNMSG ; 
  10 XSECD XSECD ; 
  10 XSNYR XSNYR ; 
  10 XWHCD XWHCD ; 
  10 OP1CUNDT OP1CUNDT ; 
  10 SY1STNBR SY1STNBR ; 
  10 SY2CLRID SY2CLRID ; 
  10 XDMCD XDMCD ; 
  10 XUMCD XUMCD ; 
  10 XPGCD XPGCD ; 
  10 XQACD XQACD ; 
  10 XOTCD XOTCD ; 
  10 XGPCD XGPCD ; 
  10 XLCCD XLCCD ; 
  10 XOWCD XOWCD ; 
  10 XCDCD XCDCD ; 
  10 AV1CUEDT AV1CUEDT ; 
  10 AV1PRPRC AV1PRPRC ; 
  10 AV1CUCST AV1CUCST ; 
  10 AV1AVQTY AV1AVQTY ; 
  10 OPNHAR OPNHAR ; 
  10 OPNPOF OPNPOF ; 
    15 OPNS03 OPNS03 ; 
      20 OPNPMM OPNPMM ; 
      20 OPNS04 OPNS04 ; 
    15 OPNPDD OPNPDD ; 
      20 OPNCOF OPNCOF ; 
      20 OPNS05 OPNS05 ; 
  10 OPNSBP OPNSBP ; 
  10 OPNSBS OPNSBS ; 
  10 OPNASZ OPNASZ ; 
  10 OPNETN OPNETN ; 
    15 OPNNCC OPNNCC ; 
    15 OPNNYR OPNNYR ; 
    15 OPNNMN OPNNMN ; 
    15 OPNNDY OPNNDY ; 
  10 OPNAED OPNAED ; 
    15 OPNAEM OPNAEM ; 
    15 OPNAEC OPNAEC ; 
    15 OPNAEY OPNAEY ; 
  10 OPNSBD OPNSBD ; 
  10 OPNSED OPNSED ; 
  10 OPNFIL OPNFIL ; 
  10 OPNALO OPNALO ; 
  10 OPNDTN OPNDTN [40] ; 
  10 OPNAVA OPNAVA [40] ; 
  10 OPNAVQ OPNAVQ [40] ; 
end // end OPNREC

// AVOREC DATE
DataItem OP0IW-AVOREC-DATE num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// AVOREC ERR DIAG AREA
DataItem OP0IW-AVOREC-ERRDIAG char(24)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// AVOREC OPTION
DataItem OP0IW-AVOREC-OPTION char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// AVOREC RETURN STATUS
DataItem OP0IW-AVOREC-RTN-STAT num(1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// AVOREC STYLE
DataItem OP0IW-AVOREC-SY1STYNBR char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// AVOREC COLOR
DataItem OP0IW-AVOREC-SY2CLRID char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// AVOREC DIM CODE
DataItem OP0IW-AVOREC-XDMCD char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// AVOREC OWNER GROUP CODE
DataItem OP0IW-AVOREC-XOWCD char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// booking season error flag
DataItem OP0IW-BK-SESN-ERR char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// booking season required flag
DataItem OP0IW-BK-SESN-REQUIRED char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// BLANK BULK ONLY FLAG
DataItem OP0IW-BLANK-BULK-ONLY-FL char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// 2 byte cha yy for map compare
DataItem OP0IW-CHA-BK-YY char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// check bk-sesn flag
DataItem OP0IW-CHECK-BK-SESN char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// number of days past cutoff dt
DataItem OP0IW-DAYS-PAST-CUTOFF decimal(5)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// default booking seasons flag
DataItem OP0IW-DEFAULT-BK-SESN char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem OP0IW-HOLD-EZETST-VAL num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// CU_CO_ID
DataItem OP0IW-KUCCOID num(12)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = "0", inputRequired = no
}
end

// labl cd sub-script
DataItem OP0IW-LABL-CD-SUB smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// display multi-bkg-sesn-msg flg
DataItem OP0IW-MULTI-BK-SESN-MSG char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// first 2 bytes of numeric field
DataItem OP0IW-NUM-1-2 num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// 4 byte numeric field
DataItem OP0IW-NUM-1-4 num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// last 2 bytes of numeric field
DataItem OP0IW-NUM-3-4 num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dash separator
DataItem OP0IW-OB1470-DASH-1 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dash separator
DataItem OP0IW-OB1470-DASH-10 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dash separator
DataItem OP0IW-OB1470-DASH-2 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dash separator
DataItem OP0IW-OB1470-DASH-3 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dash separtor
DataItem OP0IW-OB1470-DASH-4 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dash separator
DataItem OP0IW-OB1470-DASH-5 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dash separator
DataItem OP0IW-OB1470-DASH-6 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dash separator
DataItem OP0IW-OB1470-DASH-7 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dash separator
DataItem OP0IW-OB1470-DASH-8 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dash separator
DataItem OP0IW-OB1470-DASH-9 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// display ob1470 key
DataItem OP0IW-OB1470-ERR-DESC char(54)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// op1cundt
DataItem OP0IW-OB1470-NEED-DT num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// need date used to call ob1470
DataItem OP0IW-OB1470-OP1CUNDT int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// op-cust-ord-id
DataItem OP0IW-OB1470-OP1CUOID num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// op-nike-ord-id
DataItem OP0IW-OB1470-OP1NORID num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// op-ord-part-char
DataItem OP0IW-OB1470-OP1PARTN char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// op-line-item-nbr
DataItem OP0IW-OB1470-OP2LNINB num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// sy-sty-nbr
DataItem OP0IW-OB1470-SY1STNBR char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// sy-colr-cd-id
DataItem OP0IW-OB1470-SY2CLRID char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// xdm-dim-cd
DataItem OP0IW-OB1470-XDMCD char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// xdvcd
DataItem OP0IW-OB1470-XDVCD char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// xgp-gpc-cd
DataItem OP0IW-OB1470-XGPCD char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// xotcd
DataItem OP0IW-OB1470-XOTCD char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// add 1 dollar to price per unit
DataItem OP0IW-PRICING-FACTOR num(1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// PROMO OWNER GROUP FLAG
DataItem OP0IW-PROMO-XOWCD-FL char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pk_LABL_CD
DataItem OP0IW-PWRLBCD char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pk_LABL_CD
DataItem OP0IW-PWRLBCD-GRP char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// for round b-grade price
DataItem OP0IW-SAVE-PRICE-1 decimal(11,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// for round b-grade price
DataItem OP0IW-SAVE-PRICE-2 decimal(11,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// read flag for prog ctl table
DataItem OP0IW-VOPPGM-READ char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem OP0IW-WSY2000-COLR-CD char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem OP0IW-WSY2000-DIM-CD char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// found flag call to sy2000
DataItem OP0IW-WSY2000-FND-FLAG char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem OP0IW-WSY2000-GPC-CD char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// sy2000 posting area
DataItem OP0IW-WSY2000-POST-1 char(17)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem OP0IW-WSY2000-PROD-REG-CD char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem OP0IW-WSY2000-RETURN-CD char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem OP0IW-WSY2000-STY-NBR char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// GOOD OWNER GROUP FOUND FLAG
DataItem OP0IW-XOWCD-FOUND-FL char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// op0i w/s
DataItem OP0IW01G char(1905)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// '/'
DataItem OP0IWAEC char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// avail edited date
DataItem OP0IWAED char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// edited month
DataItem OP0IWAEM char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// edited year
DataItem OP0IWAEY char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// all szs aloocatable (y/n)
DataItem OP0IWALO char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// array size
DataItem OP0IWASZ num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// hot model override authority
DataItem OP0IWAUT char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// condition code array
DataItem OP0IWAVA char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// furthest out avail date
DataItem OP0IWAVD int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// available quantity by sz
DataItem OP0IWAVQ decimal(7)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// move quantities to screen?
DataItem OP0IWAVX char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// use blank availability flag
DataItem OP0IWBAV char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// blank bulk draw flag
DataItem OP0IWBBD char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// bulk/draw type flag
DataItem OP0IWBDF char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// o/a buy yymm
DataItem OP0IWBYM num(6)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// dd
DataItem OP0IWCDD num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// mmdd
DataItem OP0IWCDT num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// changed data on review (y/n)
DataItem OP0IWCHG char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// op-cust-ord-id
DataItem OP0IWCID num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// default price by style,color
DataItem OP0IWCLP decimal(11,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// color
DataItem OP0IWCLR char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// commarea message - 1
DataItem OP0IWCM1 char(20)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// commarea message - 2
DataItem OP0IWCM2 char(20)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// commarea message - 3
DataItem OP0IWCM3 char(20)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// commarea message - 4
DataItem OP0IWCM4 char(18)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// mm
DataItem OP0IWCMM num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// changed needdate  (y/n)
DataItem OP0IWCND char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// review, changed qty
DataItem OP0IWCQT decimal(7)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// cross seasons switch
DataItem OP0IWCRS char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// changed warehouse (y/n)
DataItem OP0IWCWH char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// commarea message wk field
DataItem OP0IWCWM char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// -
DataItem OP0IWD1 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// -
DataItem OP0IWD2 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// disp availability flag(y/n)
DataItem OP0IWDAV char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// diag1
DataItem OP0IWDI1 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// diag2
DataItem OP0IWDI2 smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// diag3
DataItem OP0IWDI3 smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// diag4
DataItem OP0IWDI4 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// diag reformatter
DataItem OP0IWDIG char(12)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// error display key
DataItem OP0IWDKY char(11)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// error display need date
DataItem OP0IWDND num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// delete quantity total
DataItem OP0IWDQT decimal(7)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// temporary hold ccyymmdd
DataItem OP0IWDT1 num(8)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// century
DataItem OP0IWDT2 num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// yymmdd
DataItem OP0IWDT3 num(6)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

DataItem OP0IWDTE int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// num date hold
DataItem OP0IWDTN num(8)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// db2 dup.sub-ord,coord gp.erro
DataItem OP0IWDUP char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// error display order type
DataItem OP0IWDXT char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// edit map (full/partial)
DataItem OP0IWEDT char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// eligible customer flag
DataItem OP0IWELI char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// vsam err record
DataItem OP0IWERR char(13)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// re-edit screened product flag
DataItem OP0IWESP char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// num date hold
DataItem OP0IWETN num(8)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// temporary hold yymmdd
DataItem OP0IWEZ1 num(6)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// opfrec data
DataItem OP0IWFDA char(8)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// lost demand format day
DataItem OP0IWFDD num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// lost demand format date
DataItem OP0IWFDT num(6)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// array filled counter
DataItem OP0IWFIL num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// lost demand format month
DataItem OP0IWFMM num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// found error or entry
DataItem OP0IWFND char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Formatted phone number
DataItem OP0IWFPH char(12)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// first time through flag
DataItem OP0IWFTF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// lost demand format year
DataItem OP0IWFYY num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// have avail record (y/n)
DataItem OP0IWHAR char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem OP0IWHDT int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// warehouse
DataItem OP0IWHS char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pack hndling type and ovrd
DataItem OP0IWHTP char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// op2rec key
DataItem OP0IWIKY char(14)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// value * iverec price percent
DataItem OP0IWIPC decimal(11,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// lost demand error key
DataItem OP0IWKEY char(21)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// ld type code
DataItem OP0IWKY1 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// ld division code
DataItem OP0IWKY2 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// ld sales ofc code
DataItem OP0IWKY3 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// ld order type code
DataItem OP0IWKY4 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// ld warehouse code
DataItem OP0IWKY5 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// ld order part char
DataItem OP0IWKY6 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// ld cust order id
DataItem OP0IWKY7 num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// lost demand error flag
DataItem OP0IWLDE char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// lost demand entered flag
DataItem OP0IWLDF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem OP0IWLDT int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// op-line-item-nbr
DataItem OP0IWLIN num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// need dt lead time message
DataItem OP0IWLTM char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// mm
DataItem OP0IWMM1 num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// more sizes? (y/n)
DataItem OP0IWMOR char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

//        -start of message
DataItem OP0IWMSA char(25)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

//        -quantity calculated
DataItem OP0IWMSB num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

//    (each digit-zero suppress)
DataItem OP0IWMSC char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

//        -end of message
DataItem OP0IWMSD char(23)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// message-verify qty error
DataItem OP0IWMSG char(57)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// numeric 5 digit redefine area
DataItem OP0IWNB1 num(5)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// numeric 4 digit redefine area
DataItem OP0IWNB2 num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// numeric 9 digit workarea
DataItem OP0IWNBR num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// num century
DataItem OP0IWNCC num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// need date changed
DataItem OP0IWNDC char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// opfrec yy
DataItem OP0IWNDD num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// opfrec date
DataItem OP0IWNDT num(8)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// num day
DataItem OP0IWNDY num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// xgpcd
DataItem OP0IWNI1 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// xobcd
DataItem OP0IWNI2 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// zarcd
DataItem OP0IWNI3 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// kuccoid
DataItem OP0IWNI4 num(12)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// zfccd
DataItem OP0IWNI5 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// op-nike-ord-id
DataItem OP0IWNID num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// nimrec error diag key
DataItem OP0IWNIM char(21)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// opfrec dd
DataItem OP0IWNMM num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// num month
DataItem OP0IWNMN num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// kuccoid
DataItem OP0IWNP1 num(12)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// xgpcd
DataItem OP0IWNP2 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// sy1stnbr
DataItem OP0IWNP3 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// sy2clrid
DataItem OP0IWNP4 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// xdmcd
DataItem OP0IWNP5 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// nparec error diag key
DataItem OP0IWNPA char(25)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// size price, no sign
DataItem OP0IWNSN decimal(11,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// orig nike sub-ord for review
DataItem OP0IWNSO smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Numeric flag
DataItem OP0IWNUM char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// new xwhcd flag for nil pricing
DataItem OP0IWNWH char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// use next prod in 6 array(y/n)
DataItem OP0IWNXT char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// o/a need yymm
DataItem OP0IWNYM num(6)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// num year
DataItem OP0IWNYR num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// opfrec mm
DataItem OP0IWNYY num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// split order adjustment flag
DataItem OP0IWOAC char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// order adjustment flag(y/n)
DataItem OP0IWOAF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// order adj override flag
DataItem OP0IWOAO char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// ord adj buy date
DataItem OP0IWOBD num(8)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// ord adj need date
DataItem OP0IWOND num(8)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// key to davail.vblnkp01
DataItem OP0IWP01 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// 20 days past deadline
DataItem OP0IWP20 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pf21 full size range (y/n)
DataItem OP0IWP21 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pf23 reject product (y/n)
DataItem OP0IWP23 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pf24 reject prodct   (y/n)
DataItem OP0IWP24 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem OP0IWPA2 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// edt prc adj>ord/tp vary%(y/n)
DataItem OP0IWPAD char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// edt prc4all>ord/tp vary%(y/n)
DataItem OP0IWPAL char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// produc. add-on (y/n)
DataItem OP0IWPAO char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem OP0IWPAS char(10)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Phone number character
DataItem OP0IWPCH char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// price variance percent
DataItem OP0IWPCT decimal(5,4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// avail condotion code day
DataItem OP0IWPDD char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// prod dedlne found
DataItem OP0IWPDF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// prod dedlne past 30 days
DataItem OP0IWPDO char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// need date + 60 days
DataItem OP0IWPDT int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// prod price effective date
DataItem OP0IWPED int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// pf5 key (subst) allowed (y/n)
DataItem OP0IWPF5 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pf6 chg size price   (y/n)
DataItem OP0IWPF6 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Area code
DataItem OP0IWPHA num(3)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// hold pack handle charge
DataItem OP0IWPHC decimal(9,3)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Number
DataItem OP0IWPHN num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Prefix
DataItem OP0IWPHP num(3)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// avail condition code month
DataItem OP0IWPMM char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pushed out need date (y/n)
DataItem OP0IWPND char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// price overirde flag
DataItem OP0IWPOF char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// hold price 1
DataItem OP0IWPR1 decimal(11,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// hold price 2
DataItem OP0IWPR2 decimal(11,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// hold 1st prd pric,chk vary fl
DataItem OP0IWPRC decimal(11,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// product number display area**
DataItem OP0IWPRD char(13)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// new price to chk prc variance
DataItem OP0IWPRN decimal(11,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// old price to chk prc variance
DataItem OP0IWPRO decimal(11,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// op-ord-part-char
DataItem OP0IWPRT char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem OP0IWPS1 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// saved product subscript
DataItem OP0IWPS2 smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Phone number subscript
DataItem OP0IWPSB smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// previous prod size scale code
DataItem OP0IWPSC char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dimension
DataItem OP0IWPSD char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// color
DataItem OP0IWPSK char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// style
DataItem OP0IWPSS char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// edt siz prc>ord/tp vary%(y/n)
DataItem OP0IWPSZ char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// previous unit of measure
DataItem OP0IWPUM char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// qty on order changed
DataItem OP0IWQTC char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// ws quantity field
DataItem OP0IWQTY decimal(11,3)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// db2 bad-reject product (y/n)
DataItem OP0IWREJ char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// restart product entry flag
DataItem OP0IWRST char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// in9010 rtn cd
DataItem OP0IWRTN num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// separator 01
DataItem OP0IWS01 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// separator 02
DataItem OP0IWS02 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// space preceding ovrd flag
DataItem OP0IWS03 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// separator '-'
DataItem OP0IWS04 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// space after price ovrd flag
DataItem OP0IWS05 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

//   screen 2 start record(1-40)
DataItem OP0IWSB2 smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// save season beg date
DataItem OP0IWSBD num(8)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// subscript for pack hndl(1-3)
DataItem OP0IWSBH smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// subscript for map      (1-20)
DataItem OP0IWSBM smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// subscript for order typ(1-x)
DataItem OP0IWSBO smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// subscript for mult prod(1-6)
DataItem OP0IWSBP smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// subscript for record   (1-40)
DataItem OP0IWSBR smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// subscript for sub-order(1-10)
DataItem OP0IWSBS smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// on screen 1 or 2 (1/2)
DataItem OP0IWSCR num(1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// save season end date
DataItem OP0IWSED num(8)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// style error flag
DataItem OP0IWSFL char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// lost demand map subscript
DataItem OP0IWSLD smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// first size for map display
DataItem OP0IWSMF smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// last  size for map display
DataItem OP0IWSML smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// save bulk need date
DataItem OP0IWSND int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// have sales pgm pricing (y/n)
DataItem OP0IWSPP char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// ss
DataItem OP0IWSS1 num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// ws percent array
DataItem OP0IWSSP decimal(7,3)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// temp store of need date
DataItem OP0IWSTN int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// default price by style
DataItem OP0IWSTP decimal(11,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// style number
DataItem OP0IWSTY char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// count of sizes processed
DataItem OP0IWSZC num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// product first size
DataItem OP0IWSZF smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// product last size
DataItem OP0IWSZL smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// group item diagnostics
DataItem OP0IWT1 char(36)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// hh
DataItem OP0IWTHF char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// hh
DataItem OP0IWTHL num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// diag field 1
DataItem OP0IWTK1 num(10)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// diag field 2
DataItem OP0IWTK2 num(3)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// diag field 3
DataItem OP0IWTK3 char(9)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// diag field 4
DataItem OP0IWTK4 char(7)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// diag field 5
DataItem OP0IWTK5 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// diag field 6
DataItem OP0IWTK6 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// hh:mm:ss
DataItem OP0IWTM1 char(8)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// hhmmss
DataItem OP0IWTM2 num(6)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// hhmm
DataItem OP0IWTM3 num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// mm
DataItem OP0IWTMF char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// mm
DataItem OP0IWTML num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// ws variable for qty totals
DataItem OP0IWTOT decimal(7)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// ss
DataItem OP0IWTSF char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem OP0IWTSK char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// ss
DataItem OP0IWTSL num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// variance variable
DataItem OP0IWVAR decimal(11,3)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// verify err on first size(y/n)
DataItem OP0IWVSF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// verify err on last size (y/n)
DataItem OP0IWVSL char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// valid size for product (y/n)
DataItem OP0IWVSZ char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// hold first 1 model whse
DataItem OP0IWWHS char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// order type code
DataItem OP0IWXOT char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// force zero price flag
DataItem OP0IWZPR char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// '/'
DataItem OPNAEC char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// avail edited date
DataItem OPNAED char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// edited month
DataItem OPNAEM char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// edited year
DataItem OPNAEY char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// all szs aloocatable (y/n)
DataItem OPNALO char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// array size
DataItem OPNASZ num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// condition code array
DataItem OPNAVA char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// available quantity by sz
DataItem OPNAVQ decimal(7)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// space preceding ovrd flag
DataItem OPNCOF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// num date hold
DataItem OPNDTN num(8)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// num date hold
DataItem OPNETN num(8)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// array filled counter
DataItem OPNFIL num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// have avail record (y/n)
DataItem OPNHAR char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// err msg holding area
DataItem OPNMSG num(6)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// num century
DataItem OPNNCC num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// num day
DataItem OPNNDY num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// num month
DataItem OPNNMN num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// num year
DataItem OPNNYR num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// space preceding ovrd flag
DataItem OPNPDD char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// space preceding ovrd flag
DataItem OPNPMM char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// price overirde flag
DataItem OPNPOF char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// space preceding ovrd flag
DataItem OPNS03 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// space preceding ovrd flag
DataItem OPNS04 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// space preceding ovrd flag
DataItem OPNS05 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// subscript for mult prod(1-6)
DataItem OPNSBP smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// subscript for sub-order(1-10)
DataItem OPNSBS smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// tran type
DataItem OPNTRAN char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

