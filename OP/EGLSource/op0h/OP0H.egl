package op0h;
import av.common.*;
import corpcom1.*;
import corpcom2.*;
import corpcom4.*;
import corpcom5.*;
import corpcom6.*;
import corpcom7.*;
import corpx1.*;
import corpx2.*;
import corpy2.*;
import corpz3.*;
import dg.common.*;
import fk.common.*;
import fy.common.*;
import ku.common.*;
import ob.common.*;
import op.common.*;
import os.common.*;
import pc.common.*;
import pg.common.*;
import pk.common.*;
import pw.common.*;
import sm.common.*;
import sp.common.*;
import sy.common.*;
import ta.common.*;
import tf.common.*;
import ts.common.*;
import vv.common.*;
import ww.common.*;
//*** PROGRAM=OP0H ****
//              order entry ---  product header entry
// 
// 
//     this application has two main flows. one for single
//     product header entry and the other for multiple product
//     header entry.
// 
// 
//     multiple: this screen is used for form flow order entry
//               to identify up to six styles at once before
//               going into the size/quantity loop. this flow
//               can be reached in two ways. either through
//               option 1 -- enter new order, or to add a new
//               product.
// 
//     single:   this screen is used for phone order flow. The
//               user can enter one product at a time. if the
//               flow in is from product summary then there is
//               a product number coming in which i will show
//               on the map. they can then go on to detail or
//               they may choose to reject the product. if they
//               reject the product the flow goes back to prd
//               summary. if they don't it goes on to product
//               detail. when done in detail the user is sent
//               back to product summary.
// 
// 
// 
// maintenance history:
// 
//      date    by whom     overview of changes
//    -------- ---------   ----------------------------------
//     june 86   jdv       program creation
//    08-28-86   jdv       added logic to op0hsla to maintain
//                         dup anchors. see SLA for more detail
//    02/06/87   jvande    changed sgi, sdi xpg edit so won't
//                         overlay previous entered value
//    04/29/87   craine    added diagnostics to op0hse3 to
//                         display a readable op2key on abend
//    05/14/87   jvande    chngd sge, on "no valid sizes" set
//                         style modified to retrigger edit,
//                         otherwise goes on to op0i and blows.
//    05/14/87   jvande    chngd sdc and sgc so if cust style
//                         in err, clear map nike style.
//    09/14/87   jvande    support xsdcd - m005,m010,sbb,sbc,
//                         sb2,sda,sgl,sdl.
//    10/14/87   jvande    chng to chk for pa keys. on pa set
//                         all styles to mod to re-trigger edit
//    11/13/87   jvande    fixed to not go to op0i if no prds
//                         were entered. (015 flow)
//    11/20/87   tfox      chged abend diag information in sd8
//                         to include rtncd from db100.
//    01/15/88   jhh       added flexible bulk/draw to sba/sbb/
//                         sbc/sdb/sdc/sde/sdf/se3/sgb/sgc/sge/
//                         sgf/sg9/sh2/sh3/sh4
//    02/23/88   craine    fixed op0hse2 to use 2nd product
//                         (when same product exists in more
//                         than 1 sub order on a bulk) this
//                         allow draws form the 2nd product.
//    03/29/88   craine    force edit of spec code and package
//                         type for draws - sdb, sgb. chg sh1
//                         to use second product.
//    06/28/88   obecke    check flag and dates on color rec to
//                         see if style sold out or not avail
//                         by need date.  sdb,sdz,sgb,sgz
//    07/11/88   obecke    if order type allows qual cd of 02
//                         or a life cyc cd of 20, don't do
//                         the 'sold out' logic of the above
//                         paragraph (6-28-88). sdz,sgz.
//    07/25/88   obecke    log #9: sge--load readable key to
//                         ta1rec.ta1tblke.
//    10/20/88   gwells    rebooking - added code to accomodate
//                           the new 'rebook draw' type - sba,
//                           sbc, sdb, sdd, sde, sdf, se3, sdc,
//                           sbb,sgb, sh1, sgd, sgf, sh2, sge,
//                           sh3, sh4, sg9, sgc.
//    11/04/88   JWOOD     NONCSP OPT ADDED TO CALLS
//    01/06/89   skott     check no more orders flag only,
//                         check offering date in op0i.  sdz,
//                         sd1,sgz,sg1
//    01/09/89   dwalke    add segmented transaction id to appl
//    02/23/89   skott     bug #154, products ordered before
//                         life cycle effective date.  sg2, sd2
//    04/20/89   dwalke    added quality check in se2, se4, and
//                         sh1 for correct draws against bulks
//    04/24/89   skott     added code to edit, display, and
//                         use xdmcd for Cole-Haan.  sbb,sbc,
//                         sb1,sda,sdb,sdc,sdz,sd1,se2,se4,
//                         sga,sgb,sgc,sg1,sh1
//    05/10/89   jbecke    changes to the database necessitated
//                         changes to sde, sd3, sd4, se5, sge,
//                         sg3, sg4, sh5, w02, w03.
//    05/17/89   obecke    divisions added to xottbl. sde, sd3,
//                         sd4,se5,sge,sg3,sg4,sh5.
//    06/19/89   jbecke    accessories project:
//                         added OP0HSMA (check for accessory
//                         on correct sales program) and added
//                         logic to set OP0HWAOF in OP0HSDA and
//                         OP0HSGA.
//    07/06/89   ssteph    draws from bulks with multiple sub-
//                         orders. se2, se4, sh1.
//    07/06/89   jbecke    changed SDA and SGA to exclude
//                         sales office 10 from accessories
//                         processing.
//    07/10/89   jbecke    changed SDA and SGA to exclude
//                         sales office 12 from accessories
//                         processing.
//    09/26/89   rcoron    #244  added the facility to read
//                         all colors from the sales program
//                         product file. (op0hsdd & op0hsgd)
//    10/16/89   skott     #259  added check against xautbl
//                         for in-house accts.  sma
//    10/24/89   oricha    #266. make spgm/life cycle product
//                         edit messages more specific.  sdd,
//                         sd2,sgd,sg2.
//    10/24/89   craine    replicate product number on screen
//                         loop.  sbb.
//    10/27/89   mbarna    restrict certain sports activities
//                         from sales office 01, 02, and 03.
//                         sdb, sgb, slb.
//    10/31/89   skott     correct style propagation for
//                         for draws.  sga
//    11/01/89   rcoron    excempt in-house customers from
//                         sales office restrictions. op0hslb.
//    11/13/89   craine    db2 chg's - chg'd op0hw02, op0hw03
//                         to add oprbnoid - bulk-nike-ord-id
//    11/21/89   rcoron    excempt military accounts from
//                         sales office restrictions and sales
//                         program-accessory requirement. slb,
//                         slc, sma, sba, & 001.  added kunrec
//                         and errsqlca to the record list.
//    12/14/89   rcoron    put in a TEMPORARY HARDCODED fix to
//                         allow customers 1006140 and 1006141
//                         to draw accessories from the bulks
//                         without requiring a sales program.
//                         THIS SHOULD BE REMOVED AS SOON AS
//                         ALL THEIR BULK ORDERS ARE USED UP.
//                         sma.
//    12/21/89   cgrice    bug#225 - added product/sales office
//                         restiction using xsotbl.  slb
//    02/07/90   rcoron    added routines to allow user to ac-
//                         cess product substitution from this
//                         application.  The statement groups
//                         are present but the feature is cur-
//                         rently turned off until av0l is ins-
//                         talled.
//    03/06/90   tfox      bug#282 - chg kuirec to ku2rec when
//                         looking for cust prod number sdb,sgb
//    03/07/90  BWATSO     Bug 306 - Correct use of the size
//                         distribution code was flagged as an
//                         error.  This program was incorrectly
//                         counting the number of valid sizes
//                         between the first and last size.
//                         Using the size distribution code
//                         requires that the total number of
//                         sizes indicated by the range match
//                         the number that the size distribut-
//                         ion was designed for.  The logic
//                         changes were made in SD5, SD6, and
//                         SE5 for the multiple product screen;
//                         and SG5, SG6, and SH5 for the single
//                         product screen.  OM0A was also
//                         corrected for the same problem.
//    03/08/90   rcoron    Removed the statements that dis-
//                         allowed access to product substitu-
//                         tion.  (see changes dated 02/07/90).
//                         Added changes so that, instead of
//                         checking CAFROMAP for either 'AV0K'
//                         or 'AV0L',  CAFRMSYS is tested for
//                         just 'AV'.  This was done because
//                         the product substitution system can
//                         now come back to order processing
//                         from AV0K, AV0L, AV0R, or AV0Q.
//                         sbd, 001, 003, and 007.
//    03/15/90   rcoron    Added routine to disallow access to
//                         product substitution if the customer
//                         status in kucrec.kuccnssx indicates
//                         so. op0hsbd, op0h.
//    03/26/90   rcoron    Modified sqb to always use the orig-
//                         inal product as the 'source' product
//                         whenever product substitution is
//                         accessed.
//    03/28/90   scantr    Hardcoded a temporary fix to access-
//                         ories sales pgm logic for XPCCD 'RM'
//                         Changed OP0HSMA.  Bug #318
//    04/03/90   skott     database chgs - sgl, sdl, sb2 - call
//                         pc2rec.  001-init pc2rec. sba -
//                         replace op1blkcd with xbdcd. sbd -
//                         check kucpsfl instead of kuccnssx.
//    04/09/90   scantr    Bug 321
//                         Added 2 more products to temporary
//                         fix #318. SMA
//    04/09/90   BWATSO    Bug 320
//                         Fixed abend when an invalid first
//                         size was entered.  Changed SD5, SD6,
//                         SG5, and SG6.
//    04/30/90   BWATSO    Bug 340
//                         Pass substituted product and ware-
//                         house to OP0I.  Changed SBF, SBG,
//                         SDA, SGA, SLA, SQA, SQB.  New state-
//                         ment groups SB3, SB4, SDS, and SGS.
//                         Also required changes to OPWREC and
//                         OSKREC.
//    05/30/90   BWATSO    Brand code changes.
//                         Added edit to make sure that brand
//                         of products matched brand of order.
//                         Changed SDB, SDC, SGB, and SGC.
//    06/08/90   oricha    add style '1el4' to accessories
//                         edit. sma.
//    07/23/90   ischmi    change indirect ship orders to
//                         default to dprodc.vprdcu01 for
//                         iseg number.
//    10/10/90   dviert    rename:  xfmcd to xpccd
//    10/16/90   craine    added life cycle '10' to error msg
//                         if in OP0HSD2. Was highlighting
//                         sty/col/dim and not displaying an
//                         error message.
//    11/06/90   skott     database changes - xsdcd to pc2inseg
//                         xsacd to xegcd. sqb, sbf, sqd, sdb,
//                          sdl, sb2, sql, sbg, sha, sfa, sgb,
//                         sbc, sqb, m010, m005.
//    12/29/90   jloyer    modified to process blank bulks...
//                         op0hsda, sdb, sdc, 001, om0hw01
//                         new: op0hsdm; calls io5480 which
//                                     accesses davail.vblnkp01
//                              op0hsdo; calls io5470 which
//                                     accesses davail.vblnks01
//                              op0hsdn; setup for op0hsdo
//                         new rec: avirec; pass keys to io5470
//                                  avgrec; rtn data frm io5470
//                                  avhrec; rtn data frm io5480
//    01/17/91   schase    added hard coded cust acct numbers
//                         to accessory sales program editting.
//                         sdp, sdq, sgp, sgq.
//    01/21/91   craine    added edit to OP0HSLB - check if ACG
//                         product restricted to specialty xso
//                         for the customer. Added KUPREC to
//                         table list and new sgrp OP0HSCU.
//    01/24/91   tfox      added new logic to call op1660 for
//                         each product to see if sls pgm is
//                         required. sdk,sdp,sdq,sdt,sgp,sgq
//                         op0hw01
//    01/31/91   craine    fix sdp, sgp to get sizes for draws
//    02/04/91   craine    fix sdq, sgq to get sizes for draws
//    02/15/91   dmeier    regen for database changes
//    02/28/91   tfox      t-shirt changes. sba,sda,sdb,sdc,
//                         sdd,se2,sga,agb,sgc,sgd,sh1.
//    03/14/91   dmeier    correct op0hslb to allow military
//                         accounts to order specialty products
//    03/17/91   oricha    translate style/color/dim to short
//                         version for cust who can't handle
//                         our reg nbr. dcust.vcusku01.
//                         sbb,sbc,sdb,sdc,sgb,sgc.
//    04/01/91   dflesh    log #589.  created new return codes
//                         within sdk for life cycle (07) and
//                         quality code (08)  'product _______
//                         not valid for sales program'.
//    04/05/91 craine      db2 chgs - rename life cycle codes
//                         in xoctbl - code chg'd in sd2, sg2
//    05/13/91   dharri    log # 632 - product category code
//                         chgs - 'me' replaced with 'ja' in
//                         stmt group op0hslb
// 
//    05/23/91   schen     log #554 - data base changes
//                         changed sdb, sdc, sgb, sgc to use
//                         io5790 instead of io0270 or io0400
//                         because vcusku02 is deleted and dept
//                         code is now part of key in vcusku01.
//    06/10/91   oricha    db2 changes - op0hw02, op0hw03 and
//                         changed slb to allow nordstrom to
//                         order restricted products.
//    06/19/91  oricha     sbb - added read to sycrec for
//                               apparel
//                         se4 - added read to sycrec for
//                               blank bulk draws
//    07/10/91  jloyer     bypass cust/prod restriction edits
//                         for ACG close-out products.
//                         chgd: slb, sd2, sg2.  new: op0hsld
//    08/13/91  dharri     log #673 - add new product XREF ind
//                         value of 'R'. sba, sbb, sbc,sdb, sdc
//                         sgb, sgc, w01.
//    12/17/91  gwells     #715 - set cursor on color when
//                                style field is full
//    01/14/92  gwells     #731 - iseg defaults for nil - sbc
//    02/03/92  jwils1     added custom logo prdct processing
//                         sgz,sdz,and sba.
//    03/04/92  jwils1     added check for direct ship codes
//                         2 and 3 for custom logo.  sdz,sgz.
//    03/11/92  JLoyer     DB2 chgs: chgd op0hw02 and op0hw03
//                         due to chgs in op2rec and op3rec.
//    04.14.92  bbake2     database changes: avhbxdm removed
//                         from avhrec.  op0hwxdm removed from
//                         op0hw01 - sdo, sdn
//    06/08/92  jhecke     database changes,pick up new version
//                         of kucrec.
//    08/31/92  dlegg      #885 - Cust Prod Xref changes. SBC,
//                         SBB, SDB, SDC, SGB, SGC.
//    05/01/93  dlegg      #937 - NSG whse changes. Remove some
//                         custom logo restrictions. Add edit
//                         for custom/non-custom product con-
//                         sistency within order. Changes to
//                         sbc, sdz, sgz, 005, sba. New:
//                         s-read-dorder, s-chk-prod-typ.
//    07/09/93  gcalki     #848 - internaitonal divert orders.
//                         sd2, sg2.
//    10/11/93  gcalki     csp 4.1 changes.  check to see if
//                         size passed numeric check. sd5, sg5
//    11/18/93  gcalki     #998 - repeat prior product for
//                         footwear orders.  sbb
//    11/24/93  gcalki     backout #998 changes due to error.
//    12/01/93  gcalki     #998 - repeat prior product for
//                         footwear orders.  sbb, sga.
//    12/13/93  craine     #971 - change to allow for musical
//                         size runs for footwear products -
//                         SDP, SDV, SGP, SGV AND OP0HW01.
//    03/01/94  schase     DB2 CHANGES (MARCH): Increased size
//                         of op0hw02 and op0hw03 per changes
//                         to op2group and op3group.
//    04/01/94  gcalki     Log #1003 - renamed causera to
//                         ca-user-workarea-4k so it can hold
//                         opwrec which is now 3072 bytes.(ALL)
//                         Changed oskrec.causera to oskrec.
//                         os-user-workarea-3k so it can pass
//                         the causera to xsrrec. (saa,sqb)
//                         made change to the length passed to
//                         xsrrec data length to 4024.
//    06/02/95  mmcgol     op0hs-ck-prod-type, op0hsd1, and
//                         op0hsg1 changed for Canadian
//                         conversion.  op0hs-sel-vsyreg01
//                         added-these allow for calls to
//                         product thru sy2000 for CAnadian
//                         orders.
//    06/13/96  mvalbu     Changed to use regional data for
//                         US apparel by calling SY2000.
//                         Changed OP0HS-CK-PROD-TYPE, OP0HSD1,
//                         OP0HSD1, OP0HSG1, and OP0HS-SEL-
//                         VSYREG01.
//    12/07/96  csawki     Added Product Category for Equipment
//    12/10/96  wleong     removed musical size run logic
//    06/24/97  csawki     Added Equipment/Product Category
//                         changes: modified OP0HSDB to include
//                         2 new SGRPS: 1)OP0HS-CHECK-EQUIP
//                         2)OP0HS-EU0100-SU.
//     7/29/97  Kramse     chgd OP0HSDB, OP0HSGB if stmt to =
//                         if cust has own style ind on. To
//                         match European MSL code.
//     8/11/97  CBRINE     REMOVED KUIREC
//     1/15/98  klee       bypass regions edits for intl users.
//     2/01/98  klee       Modified op0hsh1 so op0hwfnd sw was
//                         set on when only a draw was found.
//                         not when a draw and quantity was
//                         found. The quantity is checked in
//                         the calling proc to determine if an
//                         error occured.
//     3/06/98  klee       bypass regions edits for intl users
//                         in op0hsg1.
//     03/24/98 sparth     removed use of xvotbl and added code
//                         to access dcorp.vxvo0001 using the
//                         iomod vxvo0001.
//                         The statement group changed are:
//                         SDB and SGB
//     04/01/98 sgopal     Removed code that accesses XVOTBL in
//                         OP0HSDB and OP0HSGB.
//     05/07/98 eshanm     SQLCODE -811 from IO5470 is treated
//                         as ZERO. Statement groups changed
//                         are OP0HSDO and OP0HSDN.Look for tcs
//     05/27/98 jflor1     changed op0hs-ck-prod-type to bypass
//                         SY2000 if div-code is '02' or '03'.
//     06/03/98 jflor1     changed op0hs-ck-prod-type message
//                         number 780 to 970 to better reflect
//                         description after call to SY2000.
//     09/16/98 jkenne     op0hsh1 changed to check for
//                         non-zero on-ord-qty in vitem001 call
//     10/12/98 sgopal     Modified code in OP0HSDE and OP0HSBA
//                         to chek the first and last sizes for
//                         the bulks.
//                         Modified code in OP0HSDB and OP0HSGB
//                         for changing the message number from
//                         327 to 972.
//     03/15/00 RSHAIK     SPAIN TRADE MARK PROJECT
//     TT#4654             Added SGRP OP0HS-SPAIN-CHECK to
//                         determine whether a product is
//                         SPAIN/CANARY complaint or not.
//                         following SGRPs are added to handle
//                         deadlock and abend situation.
//                         XOPS-OP6410-PSRTN &
//                         XOPS-OP6410-ERRTN.
//                         following SGRPs are modified
//                         OP0HSDB, OP0HSDB1, OP0HSGB & OP0HSG1
//                         OP0HW01 working storage record
//                         modified.
//                         OP0H001  Proc modified.
//     05/23/01 KMANNE     Changed op0hsba, to abend if xot
//     TT#11708            is not valid
// *********************
Program OP0H type textUIProgram //VAGen Info - main text program
  {
  includeReferencedFunctions = yes, allowUnqualifiedItemReferences = yes, 
  throwNrfEofExceptions = yes, handleHardIOErrors = no, V60ExceptionCompatibility = yes, 
  I4GLItemsNullable = no, textLiteralDefaultIsString = no, localSQLScope = yes, 
  msgTablePrefix = "OP00", inputRecord = COMMAREA, segmented = yes
  }

  // Data Declarations
  AVGREC AVGREC; // record
  AVHREC AVHREC; // record
  AVIREC AVIREC; // record
  COMMAREA COMMAREA ; // record
  ERRSQLCA ERRSQLCA; // record
  KUCREC KUCREC; // record
  KUNREC KUNREC; // record
  KUPREC KUPREC; // record
  OP0HW01 OP0HW01; // record
  OP0HW02 OP0HW02; // record
  OP0HW03 OP0HW03; // record
  OP10REC OP10REC; // record
  OP1REC OP1REC; // record
  OP2REC OP2REC; // record
  OP3REC OP3REC; // record
  OP8REC OP8REC; // record
  OP9REC OP9REC; // record
  OPAREC OPAREC; // record
  OPBREC OPBREC; // record
  OPWREC OPWREC; // record
  OPWREC01 OPWREC01; // record
  OSGREC OSGREC; // record
  OSKREC OSKREC; // record
  PC2REC PC2REC; // record
  SP1REC SP1REC; // record
  SP5REC SP5REC; // record
  SQLCA SQLCA; // record
  SY2REC SY2REC; // record
  SY4REC SY4REC; // record
  SYCREC SYCREC; // record
  TA1REC TA1REC; // record
  TAEREC TAEREC; // record
  VXVO0001 VXVO0001; // record
  WCU1710 WCU1710; // record
  WEU0100 WEU0100; // record
  WSY2000 WSY2000; // record
  XSRREC XSRREC; // record
  XX0XW01 XX0XW01; // record

  // VAGen Info - items needed for migration
  VAGen_EZESYS char(8);
  VAGen_EZEREPLY num(1);
  VAGen_EZE_WAIT_TIME bin(9,2);
  VAGen_EZE_ITEMLEN int;

  // Use Declarations
  use XQATBL; // table
  use XSOTBL; // table
  use XOCTBL; // table
  use XOTTBL; // table
  use XUMTBL; // table
  use XPGTBL; // table
  use XBDTBL; // table
  use XSZTBL; // table
  use XDMTBL; // table
  use XAUTBL; // table
  use OP0HM.OP0HM005,  // forms
      OP0HM.OP0HM010
   {
    pfKeyEquate = no
  };

  function main()
    // VAGen Info - initialization needed for migration
    VAGen_EZESYS = VGLib.getVAGSysType();
    OP0H001: OP0H001();





               /* if in review mode, or option 7 from order accept,*/
                        /* go to single product header*/

    if (OPWREC.OPWREVM == 7)
      goto OP0H007;
    end



               /* if in form flow go to multiple header screen*/
                /* else must be phone flow go to single header*/

    if (OPWREC.OPWSFLOW == "1")
      goto OP0H003; /* go to multiple header screen*/
    else
      goto OP0H007; /* go to single header screen*/
    end








    OP0H003: OP0H003();







    goto OP0H005; /* converse multiple product header map*/







    OP0H005: OP0H005();
     /* *************************************************************/



    if (OPAREC.OPAERR == "Y") /* errors found?*/
      goto OP0H005; /* branch to converse*/
    end





    if (converseVar.eventKey is pf12) /* if edit only*/
      set OP0HM005.SY1STNBR[1] cursor;
      goto OP0H005; /* reconverse map*/
    end



    goto OP0H015; /* exit process*/







    OP0H007: OP0H007();







    goto OP0H010; /* converse single product header entry map*/







    OP0H010: OP0H010();
     /* *************************************************************/



    if (OPAREC.OPAERR == "Y") /* errors found?*/
      goto OP0H010; /* branch to converse*/
    end





    if (converseVar.eventKey is pf12) /* if edit only*/
      set OP0HM010.SY1STNBR cursor;
      goto OP0H010; /* reconverse map*/
    end



    goto OP0H015; /* exit paragraph*/








    OP0H015: OP0H015();







           /* this flow goes as follows:*/

             /* if no products were entered*/
                /* if in review mode*/
                   /* if just deleted a product (pf24)*/
                      /* go to product summary*/
                   /* else*/
                      /* go to accept order*/
                /* else*/
                   /* set up 'no products entered' msg*/
                   /* if form flow*/
                      /* go to accept order*/
                   /* else; (phone)*/
                      /* go to product summary*/
             /* else*/
                /* go to product detail.*/


    OPWREC.OP1GROUP = OP1REC.OP1GROUP;
    COMMAREA.CA-USER-WORKAREA-4K = OPWREC.OPWSGRP; /* save ws*/
    COMMAREA.CAFROMAP = COMMAREA.CACURRAP;



            /* exit application*/

    if (OPWREC.SY1STNBR[1] == " " /* if nothing in ws prd array*/
     && OPWREC.SY1STNBR[2] == " " /* if nothing in ws prd array*/
     && OPWREC.SY1STNBR[3] == " " /* if nothing in ws prd array*/
     && OPWREC.SY1STNBR[4] == " " /* if nothing in ws prd array*/
     && OPWREC.SY1STNBR[5] == " " /* if nothing in ws prd array*/
     && OPWREC.SY1STNBR[6] == " ") /* if nothing in ws prd array*/
      if (OPWREC.OPWREVM == 7 /* if in review mode*/
       || OPWREC.OPWREVM == 8)
        if (OPWREC.OPWREVM == 8)
          COMMAREA.CACURRAP = "OP0K";
          transfer to program "OP0K" passing COMMAREA;
        else
          COMMAREA.CACURRAP = "OP0J";
          transfer to program "OP0J" passing COMMAREA;
        end
      else
        if (OPWREC.OPWSFLOW == "1") /* if form flow*/
          COMMAREA.CACURRAP = "OP0J";
          transfer to program "OP0J" passing COMMAREA;
        else
          COMMAREA.CACURRAP = "OP0K";
          transfer to program "OP0K" passing COMMAREA;
        end
      end
    end





     /* if got here something was entered so call op0i prd dtl*/


    COMMAREA.CACURRAP = "OP0I";
    transfer to program "OP0I" passing COMMAREA;









  end // end main
end // end OP0H

// application init
Function OP0H001()




     /* **********************************************************/
     /* * this process initializes program work area and clears **/
     /* * the map areas.                                        **/
     /* **********************************************************/

  VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
  VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
  sysLib.commit();
  VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value


         /* initialize records*/

  set OPAREC empty;
  set OPBREC empty;
  set OPWREC empty;
  set KUCREC empty;
  set KUNREC empty;
  set WCU1710 empty;
  set SQLCA empty;
  set SYCREC empty;
  set SY4REC empty;
  set OP1REC empty;
  set OP2REC empty;
  set OP3REC empty;
  set OP8REC empty;
  set OP0HW01 empty;
  set PC2REC empty;
  set SP1REC empty;
  set SP5REC empty;
  set OSGREC empty;
  set OSKREC empty;
  set XSRREC empty;
  set AVIREC empty;
  set AVGREC empty;
  set AVHREC empty;
   /* TT#4654 SPAIN CHANGES Begin  **********/
  set OP10REC empty; /* passing record for op6410*/
   /* TT#4654 SPAIN CHANGES End    **********/






  XSENTRY(); /* check csp security*/



   /* ****************************************************/
   /* *** set segmented trans id                      ****/
   /* ****************************************************/

  COMMAREA.CAEZSAP = sysVar.transactionID;
  COMMAREA.CAEZSG12 = "OP";
  COMMAREA.CAEZSG4 = "H";
  sysVar.transactionID = COMMAREA.CAEZSAP;



   /* *************************************************************/

      /* retrieve user common area*/


       /* *** if coming from substitution, commarea contents is*/
       /* ***  in osgrec/oskrec format.  using this, restore*/
       /* ***  opwrec from xsrrec.*/

  if (COMMAREA.CAFRMSYS == "AV") /* product substitution*/

    OP0HSAA(); /* restore commarea from xsrrec*/

  end




  XSOPS01(); /* check order entry security*/
  OP1REC.OP1GROUP = OPWREC.OP1GROUP;






  OP0HSBA(); /* set some fields dark and init appl*/






  OP0HSBD(); /* determine if pf5 is allowed (prd*/
                                   /* subs)*/






   /* *************************************************************/
end // end OP0H001

// mult hdr init
Function OP0H003()



     /* **********************************************************/
     /* * this process initializes program work area and clears **/
     /* * the map for the multiple product header entry screen. **/
     /* **********************************************************/








  OP0HSBC(); /* set some fields dark and init mult*/
                                   /* map*/






  if (COMMAREA.CAFRMSYS == "AV") /* if from substitution*/
    OP0HSBF(); /* move saved map values into op0hm005*/
  end









   /* *************************************************************/
end // end OP0H003

// converse multiple hdr screen
Function OP0H005()



      /* *********************************************************/
      /* * this process converses the map, edits the entered    **/
      /* * fields and if possible, xfer's to the requested      **/
      /* * application                                          **/
      /* *********************************************************/





      /* force segmented converse execution mode*/

  converseVar.segmentedMode = 1; /* force segmented execution mode*/



   /* *************************************************************/
  converse OP0HM005 ;
   /* *************************************************************/



      /* clear (reset fields)*/

  OP0HM005.VAGen_EZEMSG = " "; /* clear err msg*/
  OPAREC.OPAERR = "N"; /* clear error flag*/
  OP0HW01.OP0HW-CUST-LOGO-FL = " "; /* init flag for this converse*/


      /* check and process valid aid key requests*/

      /* enter  - continue processing*/
        /* pf12 - edit only*/
        /* pf5  - product substitution*/



  if (converseVar.eventKey is enter)
     /* next sentence*/
  else
    if (converseVar.eventKey is pf12)
       /* next sentence*/
    else
      if (converseVar.eventKey is pf5 /* product substitution request*/
       && OP0HW01.OP0HWPF5 == "Y")    /* and pf5 is allowed*/

        OP0HSQA(); /* edit product substitution request*/

        OP0HSCA(); /* set mdt for modified fields*/
        exit stack;

      else
        OP0HSCA(); /* set mdt for modified fields*/
        converseLib.validationFailed(2);
        OPAREC.OPAERR = "Y"; /* set error flag*/
        if (converseVar.eventKey is pa1
         || converseVar.eventKey is pa2
         || converseVar.eventKey is pa3)
          set OP0HM005.SY1STNBR[1] modified;
          set OP0HM005.SY1STNBR[2] modified;
          set OP0HM005.SY1STNBR[3] modified;
          set OP0HM005.SY1STNBR[4] modified;
          set OP0HM005.SY1STNBR[5] modified;
          set OP0HM005.SY1STNBR[6] modified;
        end
        exit stack;
      end
    end
  end





  OP0HSDA(); /* perform field edits*/






   /* *************************************************************/
end // end OP0H005

// single hdr init
Function OP0H007()



     /* **********************************************************/
     /* * this process initializes program work area and clears **/
     /* * the map areas for the single product header entry map.**/
     /* **********************************************************/










  OP0HSBB(); /* set some fields dark and init appl*/






  if (COMMAREA.CAFRMSYS == "AV") /* from substitution*/
    OP0HSBG(); /* move saved map values to op0hm010*/
  end









   /* *************************************************************/
end // end OP0H007

// converse single hdr screen
Function OP0H010()



      /* *********************************************************/
      /* * this process converses the map, edits the entered    **/
      /* * fields and if possible, xfer's to the requested      **/
      /* * application                                          **/
      /* *********************************************************/





      /* force segmented converse execution mode*/

  converseVar.segmentedMode = 1; /* force segmented execution mode*/



   /* *************************************************************/
  converse OP0HM010 ;
   /* *************************************************************/



      /* clear (reset fields)*/

  OPAREC.OPAERR = "N"; /* clear error flag*/


      /* check and process valid aid key requests*/

      /* enter  - continue processing*/
        /* pf12 - edit only*/
        /* pf5  - product substitution*/


  if (converseVar.eventKey is enter)
    OP0HW01.OP0HWDLF = "N"; /* reset del confirm flag*/
  else
    if (converseVar.eventKey is pf12)
      OP0HW01.OP0HWDLF = "N"; /* reset del confirm flag*/
    else
      if (converseVar.eventKey is pf5 /* product substitution request*/
       && OP0HW01.OP0HWPF5 == "Y")    /* and pf5 is allowed*/
        OP0HSQA(); /* edit product substitution request*/
        OP0HW01.OP0HWDLF = "N"; /* reset del confirm flag*/
        OP0HSHA(); /* reset mdt's*/
        exit stack;
      else
        OP0HW01.OP0HWDLF = "N"; /* reset del flag*/
        OP0HSHA(); /* reset mdt's*/
        converseLib.validationFailed(2);
        OPAREC.OPAERR = "Y"; /* set error flag*/
        if (converseVar.eventKey is pa1
         || converseVar.eventKey is pa2
         || converseVar.eventKey is pa3)
          set OP0HM010.SY1STNBR modified;
        end
        exit stack;
      end
    end
  end





  if (OPWREC.OPWREVM == 7 /* IF IN REVIEW MODE*/
   || OP0HW01.OP0HWSPV == "Y") /* or if selected product to view*/
    exit stack; /* skip edits*/
  else
    OP0HSGA(); /* perform field edits*/
  end






   /* *************************************************************/
end // end OP0H010

// program exit
Function OP0H015()



            /* this process does some clean up before exiting*/
            /* the application.*/







  OP0HSLA(); /* pack the product array passed to prd dtl appl*/












   /* *************************************************************/
end // end OP0H015

// check for equipment product
Function OP0HS-CHECK-EQMT()
   /* --------------------- op0hs-check-eqmt ---------------------------*/

   /* determine whether or not this is an equipment product*/

  set WEU0100 empty; /* initialize the passing record*/
  set SQLCA empty; /* initialize sqlca record*/

  WEU0100.WEU0100-EQUIP-PROD-FL = "N";
  WEU0100.WEU0100-CALLING-APPL = "OP0H";
  WEU0100.SQLCAREC = SQLCA.SQLCAREC;

  WEU0100.XGPCD = SYCREC.XGPCD;
  WEU0100.SY1STNBR = SYCREC.SY1STNBR;
  WEU0100.SY2CLRID = SYCREC.SY2CLRID;
  WEU0100.XDMCD = SYCREC.XDMCD;

  OP0HS-EU0100-SU(); /* select unique*/

end // end OP0HS-CHECK-EQMT

// check prod type code
Function OP0HS-CK-PROD-TYPE()

    /* GET THE PRODUCT TYPE CODE FROM ITEM JUST READ*/


  OP0HW01.SYCDATA = SYCREC.SYCDATA; /* save data for item being added*/

  set SQLCA empty;
  set SYCREC empty;
  SYCREC.XGPCD = OP2REC.XGPCD;
  SYCREC.SY1STNBR = OP2REC.SY1STNBR;
  SYCREC.SY2CLRID = OP2REC.SY2CLRID;
  SYCREC.XDMCD = OP2REC.XDMCD;


  call "IO0560" ("S ", SQLCA, SYCREC) {isNoRefresh = yes, isExternal = yes}; /* call i/o mod for inquiry*/

  if (SQLCA.VAGen_SQLCODE == 0)
    /* continue processing*/
  else
    if (SQLCA.VAGen_SQLCODE == +100)
      OPAREC.OPAERR = "Y"; /* set error flag*/
      converseLib.validationFailed(780); /* can't determine prod type - no adds*/
    else
      TA1REC.TA1TYPE = "DB2 ";
      TA1REC.TA1FUNC = "RETN";
      TA1REC.TA1PGMNM = "OP0H";
      TA1REC.TA1LOCAT[1] = "S     ";
      TA1REC.TA1LOCAT[2] = "IO0560";
      TA1REC.TA1LOCAT[3] = "OPOHS-CK";
      TA1REC.TA1LOCAT[4] = SYCREC.SYCKEY;
      TA1REC.TA1DBASE = "DPROD";
      TA1REC.TA1TBLVU = "VCOLOR02";
      try
        call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
      end
      COMMAREA.CA-USER-WORKAREA-4K = " "; /* on error clear ws*/
      XSPF4();
      exit program;
    end
  end

    /* --added for Canada--June 2, 1995---*/

  if (SQLCA.VAGen_SQLCODE == 0)
    if (OP1REC.XDZ-DATA-DIST-CD == "CA")
      set WSY2000 empty;
      WSY2000.XDR-PROD-REG-CD = "05";
      OP0HS-SEL-VSYREG01();
      if (WSY2000.WSY2000-RETURN-CODE == "98") /* DATA BASE BUSY*/
        OPAREC.OPAERR = "Y"; /* set error flag*/
        converseLib.validationFailed(010);
      else
        if (OP0HW01.OP0HW-WSY2000-FND-FLAG == "Y")
          SYCREC.XPRCD = WSY2000.XPR-PROD-TYP-CD; /* Added for Canada*/
        else
          if (OP0HW01.OP0HW-WSY2000-FND-FLAG == "N")
            OPAREC.OPAERR = "Y"; /* set error flag*/
            converseLib.validationFailed(970);
          else
            OPAREC.OPAERR = "Y"; /* set error flag*/
            converseLib.validationFailed(909);
          end
        end
      end

      /* --added for US apparel--June 13, 1996--*/

    else
      if (OP1REC.XGPCD == "03")
        if (COMMAREA.XDVCD == "02" /* userid assigned to europe*/
         || COMMAREA.XDVCD == "03") /* userid assigned to asia*/
         /* continue processing*/
        else
          set WSY2000 empty;
          WSY2000.XDR-PROD-REG-CD = "01";
          OP0HS-SEL-VSYREG01();
          if (WSY2000.WSY2000-RETURN-CODE == "98") /* DATA BASE BUSY*/
            OPAREC.OPAERR = "Y"; /* set error flag*/
            converseLib.validationFailed(010);
          else
            if (OP0HW01.OP0HW-WSY2000-FND-FLAG == "Y")
              SYCREC.XPRCD = WSY2000.XPR-PROD-TYP-CD;
            else
              if (OP0HW01.OP0HW-WSY2000-FND-FLAG == "N")
                OPAREC.OPAERR = "Y"; /* set error flag*/
                converseLib.validationFailed(970);
              else
                OPAREC.OPAERR = "Y"; /* set error flag*/
                converseLib.validationFailed(909);
              end
            end
          end
        end
      end
    end
  end


  if (OPAREC.OPAERR == "N") /* no previous errors*/
    if (OP0HW01.OP0HW-CUST-LOGO-FL == "Y") /* trying to add cust logo prod*/
      if (SYCREC.XPRCD == "22") /* to a cust logo order*/
        /* Continue Processing*/
      else
        OPAREC.OPAERR = "Y"; /* set error flag*/
        converseLib.validationFailed(782); /* can't add cust logo to non-cust logo*/
      end
    else
      if (SYCREC.XPRCD == "22") /* cust logo order*/
        OPAREC.OPAERR = "Y"; /* set error flag*/
        converseLib.validationFailed(781); /* can't add cust logo to non-cust logo*/
      end
    end
  end


  SYCREC.SYCDATA = OP0HW01.SYCDATA; /* return orig data to record*/


end // end OP0HS-CK-PROD-TYPE

// call select unique for equip
Function OP0HS-EU0100-SU()
   /* ------------------- op0hs-eu0100-su -------------------------*/

  WEU0100.WEU0100-TASK = "S ";
  WEU0100.WEU0100-CALLER-LOCATION = "OP0HS-EU0100-SU";

  try
    call "EU0100" (WEU0100) {isNoRefresh = yes, isExternal = yes};
  end /* select unique*/

  SQLCA.SQLCAREC = WEU0100.SQLCAREC;

  if (WEU0100.WEU0100-RETURN-CODE == 0) /* call successful*/
    return; /* return to op0hs-check-eqmt*/
  end

  TA1REC.TA1MAP = WEU0100.WEU0100-RETURN-CODE; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  if (WEU0100.WEU0100-RETURN-CODE == 8) /* resource not available*/
    TA1REC.TA1FUNC = "POST"; /* termination function*/
  else
    TA1REC.TA1FUNC = "RETN"; /* termination function*/
  end

  TA1REC.TA1TYPE = "DB2"; /* type of error*/
  TA1REC.TA1LOC = "OP0HS-EU0100-SU"; /* program location*/
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* program application*/
  TA1REC.TA1PGMNO = "EU0100"; /* called program*/
  TA1REC.TA1DBASE = "DEQUIP"; /* database name*/
  TA1REC.TA1TBLVU = "VEQPRD01"; /* table view name*/
  TA1REC.TA1TBLKE = SYCREC.SYCKEY; /* table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* error diagnosis routine*/


end // end OP0HS-EU0100-SU

// edit musical size run - ftwr
Function OP0HS-GET-MSR()




    /* edit musical size run code  (see ymstbl for possible values)*/


   /* F OP0HM005.XSZCD(OPASUB) EQ ' ';*/
   /* MOVE ' ' TO OPWREC.XSZCD(OPASUB);*/
   /* EZERTN;*/
   /* ND;*/

   /* Code was entered, so call subprogram to edit the the code against*/
   /* the product.*/

   /* ET OPMSREC EMPTY;*/

   /* OVE 1 TO OPMSREC.OPMS-OPTION-CD;*/
   /* OVE OP1REC.XGPCD TO OPMSREC.XGPCD;*/
   /* OVE OP0HM005.SY1STNBR(OPASUB) TO OPMSREC.SY1STNBR;*/
   /* OVE OP0HM005.SY2CLRID(OPASUB) TO OPMSREC.SY2CLRID;*/
   /* OVE OP0HM005.XDMCD(OPASUB) TO OPMSREC.XDMCD;*/
   /* OVE OP0HM005.OP2TORGQ(OPASUB) TO OPMSREC.OP2TONOQ;*/
   /* OVE OP0HM005.XSZCD(OPASUB) TO OPMSREC.OP-MSC-SZ-RUN-CD;*/

   /* ALL OP2830 OPMSREC (NOMAPS,NONCSP;*/

   /* F OPMSREC.OPMS-RETURN-CD = 0;*/
   /* MOVE OP0HM005.XSZCD(OPASUB) TO OPWREC.XSZCD(OPASUB);*/
   /* SET OP0HM005.XSZCD(OPASUB) DEFINED;*/
   /* LSE;*/
   /* IF OPMSREC.OPMS-RETURN-CD = 1*/
     /* OR OPMSREC.OPMS-RETURN-CD = 2*/
     /* OR OPMSREC.OPMS-RETURN-CD = 3*/
     /* OR OPMSREC.OPMS-RETURN-CD = 4;*/
     /* MOVE 'Y' TO OPAREC.OPAERR;*/
     /* SET OP0HM005.XSZCD(OPASUB) CURSOR,MODIFIED,BRIGHT;*/
     /* MOVE OPMSREC.OPMS-RETURN-MSG TO OP0HM005.EZEMSG;*/
   /* ELSE;*/
     /* IF OPMSREC.OPMS-RETURN-CD = 8;*/
       /* MOVE 'Y' TO OPAREC.OPAERR;*/
       /* SET OP0HM005.XSZCD(OPASUB) CURSOR,MODIFIED,BRIGHT;*/
       /* MOVE 10 TO EZEMNO;*/
     /* ELSE;*/
       /* IF OPMS-RETURN-CD = 7*/
         /* OR OPMS-RETURN-CD = 9;*/
         /* MOVE 'Y' TO OPAREC.OPAERR;*/
         /* MOVE 'APPL' TO TA1REC.TA1TYPE;*/
         /* MOVE 'RETN' TO TA1REC.TA1FUNC;*/
         /* MOVE 'OP0H    ' TO TA1REC.TA1PGMNM;*/
         /* MOVE 'OP0HS-GE' TO TA1REC.TA1LOCAT(1);*/
         /* MOVE 'T-MSR   ' TO TA1REC.TA1LOCAT(2);*/
         /* MOVE 'OP2830  ' TO TA1REC.TA1LOCAT(3);*/
         /* MOVE OPMSREC.OPMS-RETURN-CD TO TA1REC.TA1LOCAT(4);*/
         /* SET TAEREC EMPTY;*/
         /* MOVE ' ' TO OPMSREC.OPMS-DIAG-KEY;*/
         /* MOVE OP1REC.OP1CUOID TO OPMSREC.OPMS-DIAG-CUST-ORD-ID;*/
         /* MOVE OP1REC.OP1NORID TO OPMSREC.OPMS-DIAG-NIKE-ORD-ID;*/
         /* MOVE OPMSREC.XGPCD TO OPMSREC.OPMS-DIAG-GPC-CD;*/
         /* MOVE OPMSREC.SY1STNBR TO OPMSREC.OPMS-DIAG-STY-NBR;*/
         /* MOVE OPMSREC.SY2CLRID TO OPMSREC.OPMS-DIAG-COLR-CD-ID;*/
         /* MOVE OPMSREC.XDMCD TO OPMSREC.OPMS-DIAG-DIM-CD;*/
                                  /* MOVE OPMSREC.OP-MSC-SZ-RUN-CD TO*/
                                   /* OPMSREC.OPMS-DIAG-MSC-SZ-RUN-CD;*/
         /* MOVE OPMSREC.OPMS-OPTION-CD TO OPMSREC.OPMS-DIAG-OPTION-CD;*/
         /* MOVE OPMSREC.OPMS-RETURN-CD TO OPMSREC.OPMS-DIAG-RETURN-CD;*/
         /* MOVE 'ORD' TO OPMSREC.OPMS-DIAG-LIT1;*/
         /* MOVE 'PRD' TO OPMSREC.OPMS-DIAG-LIT2;*/
         /* MOVE 'YMS CD' TO OPMSREC.OPMS-DIAG-LIT3;*/
         /* MOVE 'OPT' TO OPMSREC.OPMS-DIAG-LIT4;*/
         /* MOVE 'RTN' TO OPMSREC.OPMS-DIAG-LIT5;*/
         /* MOVE OPMSREC.OPMS-DIAG-KEY TO TAEREC.TAEDESC1;*/
         /* MOVE OPMSREC.OPMS-RETURN-MSG TO TAEREC.TAEDESC2;*/
         /* CALL RESET;*/
         /* CALL TA0020 TA1REC,TAEREC (NOMAPS,NONCSP;*/
         /* XSPF4;*/
         /* EZECLOS;*/
       /* END;*/
     /* END;*/
   /* END;*/
   /* ND;*/



end // end OP0HS-GET-MSR

// read dorder items
Function OP0HS-READ-DORDER()


    /* NOTE:  DETERMINE IF THE PRODUCT YOU ARE ADDING TO THE ORDER IS*/
    /* CONSISTENT WITH THE OTHER PRODUCTS ON THE ORDER. (CUSTOM*/
    /* LOGO VS NON-CUSTOM LOGO PRODUCTS.)*/
    /* 1.  Read the first item found on the DORDER datbase*/
    /* 2.  When an item is found, read vcolor02 to get the product type.*/
    /* a.  if the product type of the item found is consistent with*/
    /* the proudct be added to the order, allow processing to*/
    /* continue, otherwise display a message indicating you can*/
    /* not mix product types on an order.*/
    /* 3.  If this is the 1st product on the order, accept either product*/
    /* type.*/
    /*  */


  TA1REC.TA1TYPE = "DB2";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "OP0H";
  TA1REC.TA1LOCAT[1] = "OPOHS-RE";
  TA1REC.TA1LOCAT[2] = "AD-DORDE";
  TA1REC.TA1LOCAT[3] = "R       ";
  TA1REC.TA1LOCAT[4] = "IO0440  ";
  TA1REC.TA1MAP = "OP0HM005";
  TA1REC.TA1DBASE = "OP2REC  ";
  TA1REC.TA1TBLVU = "VITEM001";

  OP2REC.OP1PARTN = OP1REC.OP1PARTN; /* Open item cursor for*/
  OP2REC.OP1CUOID = OP1REC.OP1CUOID; /* current order*/
  OP2REC.OP1NORID = 0;

  call "IO0440" ("SS", SQLCA, OP2REC) {isNoRefresh = yes, isExternal = yes}; /* Get the 1st item*/

  if (SQLCA.VAGen_SQLCODE == 0)
    call "IO0440" ("SN", SQLCA, OP2REC) {isNoRefresh = yes, isExternal = yes};
    if (SQLCA.VAGen_SQLCODE == 0) /* FOUND AN ITEM RECORD*/
      OP0HS-CK-PROD-TYPE(); /* See what product type it is*/
    else
      if (SQLCA.VAGen_SQLCODE == 100) /* No items on order yet*/
       /* accept item for any product type*/
      else
        TA1REC.TA1LOCAT[1] = "SN      ";
        try
          call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
        end
        COMMAREA.CA-USER-WORKAREA-4K = " "; /* on error clear ws*/
        XSPF4();
        exit program;
      end
    end
  else
    TA1REC.TA1LOCAT[1] = "SS     ";
    try
      call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
    end
    COMMAREA.CA-USER-WORKAREA-4K = " "; /* on error clear ws*/
    XSPF4();
    exit program;
  end

  call "IO0440" ("CS", SQLCA, OP2REC) {isNoRefresh = yes, isExternal = yes};

end // end OP0HS-READ-DORDER

// select dprod.vsyreg01
Function OP0HS-SEL-VSYREG01()

   /* CANADA 06/28/95*/

  TA1REC.TA1LOCAT[2] = "OP0H-SEL"; /* error diag group name*/

     /* get the product/region record*/

  set SQLCA empty;
  OP0HW01.OP0HW-WSY2000-FND-FLAG = " ";
  WSY2000.XGP-GPC-CD = SYCREC.XGPCD;
  WSY2000.SY-STY-NBR = SYCREC.SY1STNBR;
  WSY2000.SY-COLR-CD-ID = SYCREC.SY2CLRID;
  WSY2000.XDM-DIM-CD = SYCREC.XDMCD;
  WSY2000.WSY2000-OPTION-CODE = "S ";
  WSY2000.WSY2000-SUB-OPTION-CODE = "O";

  call "SY2000" (WSY2000) {isNoRefresh = yes, isExternal = yes};

  if (WSY2000.WSY2000-RETURN-CODE == 0)
    OP0HW01.OP0HW-WSY2000-FND-FLAG = "Y";

      /* move from wsy2000 to vcolor02*/

    SYCREC.PG1SC4CD = WSY2000.PG-SCHED-SPCLT-CD;
    SYCREC.PG1FCTCD = WSY2000.PG-FCST-CD;
    SYCREC.XSECD = WSY2000.XSE-SESN-CD;
    SYCREC.XSNYR = WSY2000.XSN-SESN-YR-RNG;

    SYCREC.SY2POFBD = WSY2000.SY-PROP-OFFER-BDT;
    SYCREC.SY2POFXD = WSY2000.SY-PROP-OFFER-XDT;
    SYCREC.SY2FOFBD = WSY2000.SY-FUTR-OFFER-BDT;
    SYCREC.SY2FOFXD = WSY2000.SY-FUTR-OFFER-XDT;

    SYCREC.XLCCD1 = WSY2000.XLC-LIFE-CYC-CD[1];
    SYCREC.XLCCD2 = WSY2000.XLC-LIFE-CYC-CD[2];
    SYCREC.XLCCD3 = WSY2000.XLC-LIFE-CYC-CD[3];
    SYCREC.XLCCD4 = WSY2000.XLC-LIFE-CYC-CD[4];

    SYCREC.SY2CEDT1 = WSY2000.SY-LIFE-CYC-EDT[1];
    SYCREC.SY2CEDT2 = WSY2000.SY-LIFE-CYC-EDT[2];
    SYCREC.SY2CEDT3 = WSY2000.SY-LIFE-CYC-EDT[3];
    SYCREC.SY2CEDT4 = WSY2000.SY-LIFE-CYC-EDT[4];

    SYCREC.XPRCD = WSY2000.XPR-PROD-TYP-CD;
    SYCREC.XPLCD = WSY2000.XPL-PROD-LN-CD;
    SYCREC.XPCCD = WSY2000.XPC-PROD-CAT-CD;

    SYCREC.SY2FDSMO = WSY2000.SY-FRST-DOM-SLS-MO;
    SYCREC.SY2PDCMO = WSY2000.SY-PROJ-DOM-CLS-MO;
    SYCREC.SY2SSCIN = WSY2000.SY-SFTY-STKCLS-IND;

    SYCREC.OPZHMIND = WSY2000.OP-HMDL-HOT-FL;
    SYCREC.SY2ALNOR = WSY2000.SY-ALW-NEW-ORD-FL;

    sysVar.arrayIndex = 1;
    while (sysVar.arrayIndex <= 6)
      SYCREC.XWHCD[sysVar.arrayIndex] = WSY2000.XWH-WHSE-CD[sysVar.arrayIndex];
      sysVar.arrayIndex = sysVar.arrayIndex + 1;
    end

    SYCREC.SY2RPRDI = WSY2000.SY-RSTR-XSO-IND;
    SYCREC.SY2BOSWI = WSY2000.SY-BO-SW;
    SYCREC.SY2BOEDT = WSY2000.SY-BO-SW-EDT;

  else
    if (WSY2000.WSY2000-RETURN-CODE == 02)
      OP0HW01.OP0HW-WSY2000-FND-FLAG = "N";
    else
      if (WSY2000.WSY2000-RETURN-CODE == 98) /* data base is busy*/
  /* next sentence*/
      else
        TA1REC.TA1TYPE = "APPL";
        TA1REC.TA1FUNC = "POST";
        TA1REC.TA1PGMNM = "OP0H";
        TA1REC.TA1LOC = "OMOPS-SEL-SY2000";
        OP0HW01.OP0HW-WSY2000-GPC-CD = SYCREC.XGPCD;
        OP0HW01.OP0HW-WSY2000-STY-NBR = SYCREC.SY1STNBR;
        OP0HW01.OP0HW-WSY2000-COLR-CD = SYCREC.SY2CLRID;
        OP0HW01.OP0HW-WSY2000-DIM-CD = SYCREC.XDMCD;
        OP0HW01.OP0HW-WSY2000-PROD-REG-CD = WSY2000.XDR-PROD-REG-CD;
        OP0HW01.OP0HW-WSY2000-RETURN-CD = WSY2000.WSY2000-RETURN-CODE;
        TAEREC.TAEDESC1 = OP0HW-WSY2000-POST-1;
        TAEREC.TAEDESC2 = "BAD RETURN CODE FROM SY2000";
        TA1REC.TA1DBASE = "DPROD";
        TA1REC.TA1TBLVU = "SYREG02";
        TA1REC.TA1MAP = "OP0HM001";
        try
          call "TA0020" (TA1REC, TAEREC) {isExternal = yes};
        end
        COMMAREA.CA-USER-WORKAREA-4K = " "; /* on error - clear ws*/
      end
    end
  end
end // end OP0HS-SEL-VSYREG01

// SPAIN/CANARY Validation
Function OP0HS-SPAIN-CHECK()
  /* TT#4654  RSHAIK  03/15/2000*/
  /* *******************************************************/
  /* This statement group calls OP6410 to determine if   **/
  /* the product is valid for SPAIN/CANARY ISLANDS.      **/
  /* Product is accepted depending on the return code    **/
  /* *******************************************************/
  set OP10REC empty;
  OP10REC.OP10-PASSING-APPL = "OP0H"; /* passing application*/
  OP10REC.OP1CUOID = OP1REC.OP1CUOID; /* cust order id*/
  OP10REC.KUCCOID = OP1REC.KUCCOID; /* customer company id*/
  OP10REC.KUMSTRID = OP1REC.KUMSTRID; /* customer store id*/
  OP10REC.OP11TMSF = OP1REC.OP11TMSF; /* one time ship flag*/
  OP10REC.OP1SGPAO = OP1REC.OP1SGPAO; /* ship grp ovrride ind*/
  OP10REC.OP1SHAID = OP1REC.OP1SHAID; /* ship grp addr id*/
  OP10REC.SY1STNBR = OP0HW01.SY1STNBR; /* style number*/
  OP10REC.XGPCD = OP1REC.XGPCD; /* gpc code*/
  OP0HW01.OP0HW-PRODUCT-INV-FLAG = " "; /* product inv flag*/
  OP0HW01.OP0HW-PROD-DLOCK-FLAG = " "; /* deadlock flag*/
  OP10REC.OP10-RETURN-CODE = "99"; /* init rtn code*/
  call "OP6410" (OP10REC) {isNoRefresh = yes, isExternal = yes};
  if (OP10REC.OP10-RETURN-CODE == "00" /* product is spain/canary compliant*/
   || OP10REC.OP10-RETURN-CODE == "01" /* country code is not spain/canary*/
   || OP10REC.OP10-RETURN-CODE == "02" /* product is spain/canary non comp*/
   || OP10REC.OP10-RETURN-CODE == "03") /* deadlock occured*/
  /* next sentence*/
  else
    set TA1REC empty;
    TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
    if (OP0HW01.OP0HW-MUL-PRODUCT-FLAG == "Y") /* check for mul prod screen*/
      TA1REC.TA1MAP = "OP0HM005";
    else
      TA1REC.TA1MAP = "OP0HM010";
    end
    TA1REC.TA1LOC = "OP0HS-SPAIN-CHECK";
    XSOPS-OP6410-ERRTN();
  end
end // end OP0HS-SPAIN-CHECK

// restore commarea from xsrrec
Function OP0HSAA()
   /* *************************************************************/
   /* * using the osgrec currently in the commarea.causera, get*/
   /* * the saved xsrrec record holding opwrec.  then move the*/
   /* * opwrec into the commarea to set it as if comming from op0h*/
   /* *************************************************************/

  OSGREC.OSGGROUP = COMMAREA.CA-USER-WORKAREA-4K;

      /* ********************************************/
      /* * set up the xsrrec key and get saved order*/
      /* ********************************************/

  set XSRREC empty;
  XSRREC.XSRSYSID = OSGREC.XSRSYSID;
  XSRREC.XSRSUBID = OSGREC.XSRSUBID;
  XSRREC.XSRSQNBR = OSGREC.XSRSQNBR;

  call "IO3400" ("S ", SQLCA, XSRREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0) /* check for good rc*/
    OSKREC.OSKGROUP = XSRREC.XSRDATA;
    COMMAREA.XWHCD = OSKREC.XWHCD;
    COMMAREA.XDVCD = OSKREC.XDVCD;
    COMMAREA.XSOCD = OSKREC.XSOCD;
    COMMAREA.XNDCD = OSKREC.XNDCD;
    COMMAREA.XGPCD = OSKREC.XGPCD;
    OPWREC.OPWSGRP = OSKREC.OS-USER-WORKAREA;
    COMMAREA.CA-USER-WORKAREA-4K = OSKREC.OS-USER-WORKAREA;
  else
    TA1REC.TA1DBASE = "DCORP   "; /* data base name*/
    TA1REC.TA1TBLVU = "VCSPAD01"; /* table view*/
    TA1REC.TA1TBLKE = XSRREC.XSRGROUP; /* key value*/
    TA1REC.TA1LOCAT[2] = "OP0HSAA"; /* error diag group name*/
    TA1REC.TA1LOCAT[3] = "IO3400  "; /* i/o mod name*/
    XSOPS02(); /* common abend*/
  end


      /* ********************************/
      /* * delete the record from xsrrec*/
      /* ********************************/


  call "IO3400" ("D ", SQLCA, XSRREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0) /* check for good rc*/
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DCORP   "; /* data base name*/
    TA1REC.TA1TBLVU = "VCSPAD01"; /* table view*/
    TA1REC.TA1TBLKE = XSRREC.XSRGROUP; /* key value*/
    TA1REC.TA1LOCAT[2] = "OP0HSAA"; /* error diag group name*/
    TA1REC.TA1LOCAT[3] = "IO3400  "; /* i/o mod name*/
    XSOPS02(); /* common abend*/
  end

  VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
  VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
  sysLib.commit();
  VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value

end // end OP0HSAA

// setup sizes to dup
Function OP0HSB1()





        /* this routine trys to get a set of first/last*/
        /* sizes from the previous op0i call. This is done*/
        /* so that the user can use the dup size flag.*/




   /* first init the dup size fields and flags*/


  OP0HW01.OP2TORGQ = 0; /* zero dup total quantity*/
  OP0HW01.OP0HWFDI = 0; /* zero first dup size integer*/
  OP0HW01.OP0HWLDI = 0; /* zero last dup size integer*/
  OP0HW01.OP0HWPST = " "; /* blank previous style to dup field*/
  OP0HW01.OP0HWFDD = " "; /* blank first dup size descriptive*/
  OP0HW01.OP0HWLDD = " "; /* blank last dup size descriptive*/
  OP0HW01.OP0HWPSD = "N"; /* init "prev sizes to dup" flag*/






    /* go backwards thru the product array from the last op0i*/
    /* call to find some sizes to save for duplication.*/



  OPAREC.OPASUB = 6;
  while (OPASUB >= 1
   && OP0HW01.OP0HWPSD != "Y") /* and size not found*/
    if (OPWREC.SY1STNBR[OPASUB] > " " /* if a styl exists*/
     && OPWREC.OPWDUPSZ[OPASUB] != "R") /* and prod not rejected*/
      OP0HW01.OP0HWPSD = "Y"; /* must be sizes to dup*/
    else
      OPAREC.OPASUB = OPAREC.OPASUB - 1;
    end
  end






    /* if found sizes to dup need to see if need descriptive*/
    /* or integer sizes for defaulting.also set up prev prd*/
    /* field and save the style number for defaulting aprl*/
    /* styles so that they can just enter color codes.*/


  if (OP0HW01.OP0HWPSD == "Y") /* if found*/
    OP0HW01.SY1STNBR = OPWREC.SY1STNBR[OPASUB];
    OP0HW01.SY2CLRID = OPWREC.SY2CLRID[OPASUB];
    OP0HW01.XDMCD = OPWREC.XDMCD[OPASUB];
    OP0HW01.OP0HWSP1 = "-";
    OP0HW01.OP0HWSP2 = "-";
    OP0HM005.OP0HMPPC = OP0HW01.OP0HWPRD;
    OP0HW01.OP0HWPST = OPWREC.SY1STNBR[OPASUB]; /* save prev style*/
    if (OP0HW01.XOTSZIND == "I") /* if sizes integer format*/
      OP0HW01.OP2TORGQ = OPWREC.OP2TONOQ[OPASUB];
      OP0HW01.OP0HWFDI = OPWREC.OPWRQSZF[OPASUB];
      OP0HW01.OP0HWLDI = OPWREC.OPWRQSZL[OPASUB];
      return;
    else /* save integer sizes for desc anyway*/
      OP0HW01.OP2TORGQ = OPWREC.OP2TONOQ[OPASUB];
      OP0HW01.OP0HWFDI = OPWREC.OPWRQSZF[OPASUB];
      OP0HW01.OP0HWLDI = OPWREC.OPWRQSZL[OPASUB];
    end
  else
    set OP0HM005.OP0HMPPL protect, invisible; /* no prev prd, darken label*/
    return; /* no sizes to dup, exit*/
  end






      /* if got here need dup sizes to be in desc format.*/
      /* convert from int format to desc and save dups.*/
          /* first read style record for sy4szscl field.*/
          /* then read sy4rec and get desc sizes.*/




  OP0HW01.SY1STNBR = OPWREC.SY1STNBR[OPASUB];
  OP0HW01.SY2CLRID = OPWREC.SY2CLRID[OPASUB];
  OP0HW01.XDMCD = OPWREC.XDMCD[OPASUB];

  OP0HSD1(); /* read style record*/

  if (SQLCA.VAGen_SQLCODE == 0)
     /* next sentence*/
  else /* rec not found, zero defs*/
    OP0HW01.OP0HWFDI = 0;
    OP0HW01.OP0HWLDI = 0;
    OP0HW01.OP0HWPSD = "N";
    return;
  end



     /* read scale record*/

     /* note: since int format is actual index into array, use it*/



  SY4REC.SY4SZSCL = SYCREC.SY4SZSCL;

  call "IO0040" ("S ", SQLCA, SY4REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    OP0HW01.OP2TORGQ = OPWREC.OP2TONOQ[OPASUB]; /* save quantity*/
    OP0HW01.OP0HWFDD = SY4REC.SY4IDDSC[OP0HWFDI]; /* save fir desc*/
    OP0HW01.OP0HWLDD = SY4REC.SY4IDDSC[OP0HWLDI]; /* save las desc*/
  else
    if (SQLCA.VAGen_SQLCODE == 100) /* shouldn't happen, zero def sizes*/
      OP0HW01.OP0HWFDI = 0;
      OP0HW01.OP0HWLDI = 0;
      OP0HW01.OP0HWPSD = "N";
    else
      TA1REC.TA1TYPE = "DB2 ";
      TA1REC.TA1FUNC = "RETN";
      TA1REC.TA1PGMNM = "OP0H    ";
      TA1REC.TA1LOCAT[1] = "S       ";
      TA1REC.TA1LOCAT[2] = "OP0HSB1 ";
      TA1REC.TA1LOCAT[3] = "IO0040  ";
      TA1REC.TA1LOCAT[4] = "        ";
      TA1REC.TA1MAP = "OP0HM005";
      TA1REC.TA1DBASE = "SY4REC  ";
      TA1REC.TA1TBLVU = "VSCALE01";
      TA1REC.TA1TBLKE = SY4REC.SY4SZSCL;
      call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes};
      COMMAREA.CA-USER-WORKAREA-4K = " "; /* on error, clear ws*/
      XSPF4();
      exit program;
    end
  end











end // end OP0HSB1

// load single map with prd data
Function OP0HSB2()







    /* this routine loads the op2rec information into*/
    /* the single product header map. this product was*/
    /* selected in order product summary.*/



  OP0HM010.SY1STNBR = OP2REC.SY1STNBR;
  OPWREC.SY1STNBR[1] = OP2REC.SY1STNBR;
  OP0HM010.SY2CLRID = OP2REC.SY2CLRID;
  OPWREC.SY2CLRID[1] = OP2REC.SY2CLRID;
  OP0HM010.XDMCD = OP2REC.XDMCD;
  OPWREC.XDMCD[1] = OP2REC.XDMCD;
  OP0HM010.KUIPRDID = OP2REC.KUIPRDID;
  OPWREC.KUIPRDID[1] = OP2REC.KUIPRDID;
  OP0HM010.XUMCD = OP2REC.XUMCD;
  OPWREC.XUMCD[1] = OP2REC.XUMCD;
  OP0HM010.PC2INSEG = OP2REC.PC2INSEG;
  OPWREC.PC2INSEG[1] = OP2REC.PC2INSEG;
  OP0HM010.XPGCD = OP2REC.XPGCD;
  OPWREC.XPGCD[1] = OP2REC.XPGCD;
  OP0HM010.XQACD = OP2REC.XQACD;
  OPWREC.XQACD[1] = OP2REC.XQACD;






   /* now load field descriptions*/

  if (OP0HM010.XQACD in XQATBL.XQACD)
    OP0HM010.XQAABRV = XQATBL.XQAABRV[sysVar.arrayIndex];
  else
    OP0HM010.XQAABRV = " ";
  end


  if (PC2REC.PC2SEGAB != " ") /* pc segment abrev already read*/
    OP0HM010.PC2SEGAB = PC2REC.PC2SEGAB;
  else
    OP0HSGL(); /* read pc2rec for spec code*/
  end


  if (OP0HM010.XPGCD in XPGTBL.XPGCD)
    OP0HM010.XPGABRV = XPGTBL.XPGABRV[sysVar.arrayIndex];
  else
    OP0HM010.XPGABRV = " ";
  end


  if (OP0HM010.XUMCD in XUMTBL.XUMCD)
    OP0HM010.XUMDESC = XUMTBL.XUMDESC[sysVar.arrayIndex];
  else
    OP0HM010.XUMDESC = " ";
  end



  if (OP2REC.XPGCD != "OP")
    set OP0HM010.XPGCD protect;
    set OP0HM010.XQACD protect;
    set OP0HM010.XUMCD protect;
    set OP0HM010.PC2INSEG protect;
  end




end // end OP0HSB2

// Replace prod with substitute
Function OP0HSB3()

   /* -----------------------------------------------------------*/
   /* The original product entered by the user is always kept*/
   /* as the substituted product.  Set up the current product as*/
   /* the substituted product if a substituted product does not*/
   /* already exist.*/
   /* -----------------------------------------------------------*/
  if (OSKREC.OP2SSTYN[OSGPRSUB] == " ")
    OSKREC.OP2SSTYN[OSGPRSUB] = OP0HM005.SY1STNBR[OSGPRSUB];
    OSKREC.OP2SCLCD[OSGPRSUB] = OP0HM005.SY2CLRID[OSGPRSUB];
    OSKREC.OP2SDMCD[OSGPRSUB] = OP0HM005.XDMCD[OSGPRSUB];
  end


   /* -----------------------------------------------------------*/
   /* Save the warehouse and need date for the substitute if*/
   /* a warehouse was selected in substution screens.*/
   /* -----------------------------------------------------------*/
  if (OSGREC.XWHCD != " ")
    OSKREC.OSKSWHCD[OSGPRSUB] = OSGREC.XWHCD;
    OSKREC.OSKSNDT[OSGPRSUB] = OSGREC.OP1CUNDT;
  else
    OSKREC.OSKSWHCD[OSGPRSUB] = " ";
    OSKREC.OSKSNDT[OSGPRSUB] = 0;
  end


   /* -----------------------------------------------------------*/
   /* Overlay the current product in the map with the*/
   /* substitute.*/
   /* -----------------------------------------------------------*/
  OP0HM005.SY1STNBR[OSGPRSUB] = OSGREC.OP2SSTYN;
  OP0HM005.SY2CLRID[OSGPRSUB] = OSGREC.OP2SCLCD;
  OP0HM005.XDMCD[OSGPRSUB] = OSGREC.OP2SDMCD;


   /* -----------------------------------------------------------*/
   /* Save the substitute in OSKREC as the current product.*/
   /* This will be used later to determine if the user entered*/
   /* a different product after it was substituted.*/
   /* -----------------------------------------------------------*/
  OSKREC.SY1STNBR[OSGPRSUB] = OSGREC.OP2SSTYN;
  OSKREC.SY2CLRID[OSGPRSUB] = OSGREC.OP2SCLCD;
  OSKREC.XDMCD[OSGPRSUB] = OSGREC.OP2SDMCD;
end // end OP0HSB3

// Replace prod with substitute
Function OP0HSB4()

   /* For single product screen*/


   /* -----------------------------------------------------------*/
   /* The original product entered by the user is always kept*/
   /* as the substituted product.  Set up the current product as*/
   /* the substituted product if a substituted product does not*/
   /* already exist.*/
   /* -----------------------------------------------------------*/
  if (OSKREC.OP2SSTYN[1] == " ")
    OSKREC.OP2SSTYN[1] = OP0HM010.SY1STNBR;
    OSKREC.OP2SCLCD[1] = OP0HM010.SY2CLRID;
    OSKREC.OP2SDMCD[1] = OP0HM010.XDMCD;
  end


   /* -----------------------------------------------------------*/
   /* Save the warehouse and need date for the substitute if*/
   /* a warehouse was selected in substution screens.*/
   /* -----------------------------------------------------------*/
  if (OSGREC.XWHCD != " ")
    OSKREC.OSKSWHCD[1] = OSGREC.XWHCD;
    OSKREC.OSKSNDT[1] = OSGREC.OP1CUNDT;
  else
    OSKREC.OSKSWHCD[1] = " ";
    OSKREC.OSKSNDT[1] = 0;
  end


   /* -----------------------------------------------------------*/
   /* Overlay the current product in the map with the*/
   /* substitute.*/
   /* -----------------------------------------------------------*/
  OP0HM010.SY1STNBR = OSGREC.OP2SSTYN;
  OP0HM010.SY2CLRID = OSGREC.OP2SCLCD;
  OP0HM010.XDMCD = OSGREC.OP2SDMCD;


   /* -----------------------------------------------------------*/
   /* Save the substitute in OSKREC as the current product.*/
   /* This will be used later to determine if the user entered*/
   /* a different product after it was substituted.*/
   /* -----------------------------------------------------------*/
  OSKREC.SY1STNBR[1] = OSGREC.OP2SSTYN;
  OSKREC.SY2CLRID[1] = OSGREC.OP2SCLCD;
  OSKREC.XDMCD[1] = OSGREC.OP2SDMCD;
end // end OP0HSB4

// application initialization
Function OP0HSBA()



      /* this routine sets up certain defaults for later use.*/




    /* build customer number for display*/

  OPAREC.OPASEP1 = ".";
  OPAREC.OPASEP2 = ".";
  OPAREC.OPACUCO = OP1REC.KUCCOID;
  OPAREC.OPACUSR = OP1REC.KUMSTRID;
  OPAREC.OPACUDP = OP1REC.XNXCD;


   /* set up size error message*/

  OP0HW01.OP0HWSZ1 = "VALID SIZE RANGE IS ";
  OP0HW01.OP0HWSZ3 = " THRU ";




     /* read the company record to get the parent number*/


  KUCREC.KUKPCOID = 0;
  KUCREC.KUCCOID = OP1REC.KUCCOID;

  call "IO0240" ("S ", SQLCA, KUCREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    OP0HW01.KUKPCOID = KUCREC.KUKPCOID;
    OP0HW01.KUCGRPID = KUCREC.KUCGRPID;
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      OP0HW01.KUKPCOID = 0;
      OP0HW01.KUCGRPID = 0;
    else
      TA1REC.TA1TYPE = "DB2 ";
      TA1REC.TA1FUNC = "RETN";
      TA1REC.TA1PGMNM = "OP0H    ";
      TA1REC.TA1LOCAT[1] = "S       ";
      TA1REC.TA1LOCAT[2] = "OP0HSBA ";
      TA1REC.TA1LOCAT[3] = "IO0240  ";
      TA1REC.TA1LOCAT[4] = "        ";
      TA1REC.TA1MAP = "OP0HM005";
      TA1REC.TA1DBASE = "KUCREC  ";
      TA1REC.TA1TBLVU = "VCMPNY01";
      TA1REC.TA1TBLKE = KUCREC.KUCGRP;
      call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes};
      COMMAREA.CA-USER-WORKAREA-4K = " "; /* clear ws on error*/
      XSPF4();
      exit program;
    end
  end




     /* read the customer record to get the xna code*/


  OP0HSLC(); /* get kunrec using company code*/






   /* set quality code default. also set flag as to whether*/
   /* there is more then one quality code for this order*/
   /* type for later use.*/


  OP0HW01.OP0HWOQC = "N"; /* init one qual code flag*/
  OP2REC.XPGCD = "00"; /* init package type*/

  if (OP1REC.XOTCD in XOTTBL.XOTCD)
    OPAREC.OPASUB = sysVar.arrayIndex;
  /* TT#11708 kmanne changes begin*/
  else
    OPAREC.OPAERR = "Y";
    TA1REC.TA1TYPE = "APPL";
    TA1REC.TA1FUNC = "RETN";
    TA1REC.TA1PGMNM = "OP0H    ";
    TA1REC.TA1LOCAT[1] = "OP0HSBA ";
    TA1REC.TA1LOCAT[2] = "XOTCD =";
    TA1REC.TA1LOCAT[3] = OP1REC.XOTCD;
    set TAEREC empty;
    TAEREC.TAEDESC1 = "XOTCD NOT FOUND IN XOTTBL";
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.rollback();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
    
    call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes};
    XSPF4();
    exit program;
  /* TT#11708 kmanne changes end*/
  end

   /* *************************************************************/
   /* store at once flag in oparec for custom logo  processing*/
   /* *************************************************************/
  OPAREC.XOTFUTRF = XOTTBL.XOTFUTRF[OPASUB];
  OPAREC.XOTATONF = XOTTBL.XOTATONF[OPASUB];


  if (XOTTBL.XQACD1[OPASUB] > " ")
    OP0HW01.XQACD = XOTTBL.XQACD1[OPASUB];
    OP0HW01.OP0HWOQC = "Y";
    if (XOTTBL.XQACD2[OPASUB] > " ")
      OP0HW01.OP0HWOQC = "N";
    else
      if (XOTTBL.XQACD3[OPASUB] > " ")
        OP0HW01.OP0HWOQC = "N";
      end
    end
  else
    if (XOTTBL.XQACD2[OPASUB] > " ")
      OP0HW01.XQACD = XOTTBL.XQACD2[OPASUB];
      OP0HW01.OP0HWOQC = "Y";
      if (XOTTBL.XQACD3[OPASUB] > " ")
        OP0HW01.OP0HWOQC = "N";
      end
    else
      if (XOTTBL.XQACD3[OPASUB] > " ")
        OP0HW01.XQACD = XOTTBL.XQACD2[OPASUB];
        OP0HW01.OP0HWOQC = "Y";
      else
        converseLib.validationFailed(143);
      end
    end
  end





   /* if this is a draw order, set a draw type ws field.*/
   /* set bulk/draw flag accordingly...*/

      /* ' ' = not a draw order*/
      /* 'c' = customer draw*/
      /* 'r' = rebook draw*/
      /* 's' = smart draw*/
      /* 'x' = semi-smart draw*/
      /* '1' = customer bulk*/

  OP0HW01.OP0HWBDF = " ";
  OP0HW01.OP0HWBBD = " ";
  OP0HW01.XBDRWOFL = "N"; /* initialize ws field for sdz and sgz*/
                                   /* checks*/

  if (OP1REC.XBDCD in XBDTBL.XBDCD
   && XBDTBL.XXXSTAT[sysVar.arrayIndex] == "A") /* if active*/
    if (XBDTBL.XBDRWOFL[sysVar.arrayIndex] == "Y") /* if draw order*/
      OP0HW01.XBDRWOFL = "Y"; /* set ws field for sdz and sgz cks*/
      if (XBDTBL.XBDSETFL[sysVar.arrayIndex] == "Y") /* if set-aside*/
        if (XBDTBL.XBDRVRFL[sysVar.arrayIndex] == "Y") /* if rsrvtion required*/
          OP0HW01.OP0HWBDF = "S"; /* smart draw*/
        else
          OP0HW01.OP0HWBDF = "X"; /* flexible draw*/
        end
      else
        if (XBDTBL.XBDXRFCD[sysVar.arrayIndex] == "R")
          OP0HW01.OP0HWBDF = "R"; /* rebook draw*/
        else
          OP0HW01.OP0HWBDF = "C"; /* customer draw*/
          if (XBDTBL.XBDCD[sysVar.arrayIndex] == "8"
           || XBDTBL.XBDCD[sysVar.arrayIndex] == "F")
            OP0HW01.OP0HWBBD = "B"; /* blank bulk draw*/
          else
            if (XBDTBL.XBDCD[sysVar.arrayIndex] == "3")
              OP0HW01.OP0HWBBD = "F"; /* finished bulk draw*/
            end
            /* check for customer bulk **tcs include***/
            if (XBDTBL.XBDCD[sysVar.arrayIndex] == "1")
              OP0HW01.OP0HWBDF = "1"; /* customer bulk*/
            end
            /* check for customer bulk*/
          end
        end
      end
    end
  end



     /* set up size indicator flag in ws*/

  if (OP1REC.XOTCD in XOTTBL.XOTCD)
    OP0HW01.XOTSZIND = XOTTBL.XOTSZIND[sysVar.arrayIndex];
  end



end // end OP0HSBA

// set up for single map
Function OP0HSBB()




      /* this statement group darkens certain fields based on:*/
      /* whether the customer has their own style numbers,*/
      /* certain fields won't be used until oproc-2,*/
      /* or certain fields values are not present so dark.*/
      /* this routine also sets up certain defaults.*/

    /* note: if in review mode i will protect all fields.*/




   /* if ordered by doesn't exist, darken field and label.*/
     /* otherwise load it to screen header*/

  if (OP1REC.OP1ORDBY > " ")
    OP0HM010.OP1ORDBY = OP1REC.OP1ORDBY;
  else
    set OP0HM010.OP1ORDBY protect, invisible;
    set OP0HM010.OP0HMOBL protect, invisible;
  end




    /* load map header fields*/

  OP0HM010.OP0HMDTE = VGVar.currentShortGregorianDate;
  OP0HM010.OP0HMRVN = "01";
  OP0HM010.OP0HMCNM = OPAREC.OPACUNO;
  OP0HM010.KUMSTRNM = OPWREC.KUMSTRNM;
  OP0HM010.OP0HMDPS = "N";
  OP0HW01.OP0HWDLF = "N";



   /* if gpc is apparel or footwear move previous style to style*/

   /* IF OPWREC.OPWREVM NE 7          ; if not in review mode*/
  if (OP1REC.XGPCD == "02"
   || OP1REC.XGPCD == "03")
    OP0HM010.SY1STNBR = OPWREC.SY1STNBR[1];
  end

   /* if gpc is not apparel or footwear move 00 to color code*/

  if (OP1REC.XGPCD != "02"
   && OP1REC.XGPCD != "03")
    OP0HM010.SY2CLRID = "00 ";
  end


    /* default dimension code to '00'*/

  OP0HM010.XDMCD = "00";





     /* if cust style indicator not c, g or p, or print xref flag*/
     /* not turned on, darken cust style*/


  if (KUCREC.CU-PRT-XREF-FL == "Y") /* print xref flag turned on*/
    if (OPWREC.KUCSKIND == "P"
     || OPWREC.KUCSKIND == "C"
     || OPWREC.KUCSKIND == "R"
     || OPWREC.KUCSKIND == "G")
      if (OPWREC.OPWREVM == 7 /* if in review mode*/
       || OPWREC.OP2LNINB > 0)
        set OP0HM010.KUIPRDID cursor, protect;
      else
        set OP0HM010.KUIPRDID cursor;
      end
    else
      set OP0HM010.KUIPRDID protect, invisible;
      set OP0HM010.OP0HMCSL protect, invisible;
    end
  else
    set OP0HM010.KUIPRDID protect, invisible;
    set OP0HM010.OP0HMCSL protect, invisible;
  end





    /* protect unit of measure if non std values aren't allowed*/



  if (OPWREC.OPWREVM == 7
   || OPWREC.OP2LNINB > 0)
    /* next sentence*/
  else
    if (OP1REC.XOTCD in XOTTBL.XOTCD
     && XOTTBL.XOTANSUM[sysVar.arrayIndex] == "Y") /* non standard um is allowed*/
       /* next sentence*/
    else
      set OP0HM010.XUMCD protect;
    end
  end

   /* if in review mode darken previous product field and label.*/
   /* also protect all other fields.*/

  if (OPWREC.OPWREVM == 7
   || OPWREC.OP2LNINB > 0)
    set OP0HM010.OP0HMPPL protect, invisible;
    set OP0HM010.OP0HMPPC protect, invisible;
    set OP0HM010.SY1STNBR protect;
    set OP0HM010.SY2CLRID protect;
    set OP0HM010.XDMCD protect;
    set OP0HM010.OP0HMDPS protect;
    set OP0HM010.XQACD protect;
   /* SET OP0HM010.XSZCD PROTECT;*/
   /* SET OP0HM010.OP0HMSSL PROTECT;*/
    set OP0HM010.OP2TORGQ protect;
    set OP0HM010.OP0HMFSZ protect;
    set OP0HM010.OP0HMLSZ protect;
    set OP0HM010.XUMCD protect;
    set OP0HM010.XUMDESC protect;
  end



   /* protect unit of measure field if draw order.*/

  if (OP0HW01.OP0HWBDF == "C"
   || OP0HW01.OP0HWBDF == "R"
   || OP0HW01.OP0HWBDF == "S"
   || OP0HW01.OP0HWBDF == "X")
    set OP0HM010.XUMCD protect;
  end





   /* set quality code. if no other defaults, protect field.*/


  if (OP0HW01.OP0HWOQC == "Y") /* if one qual code flag is y*/
    set OP0HM010.XQACD protect;
  end

  OP0HM010.XQACD = OP0HW01.XQACD;

  if (OP0HW01.XQACD in XQATBL.XQACD)
    OP0HM010.XQAABRV = XQATBL.XQAABRV[sysVar.arrayIndex];
  end






   /* next get sizes from previous op0i call for duplicating*/


  if (COMMAREA.CAFROMAP == "OP0I"
   && OPWREC.OPWDUPSZ[1] != "R") /* and prev prod not rejected*/
    OP0HW01.OP0HWPSD = "Y";
    OP0HW01.OP0HWFDI = OPWREC.OPWRQSZF[1];
    OP0HW01.OP0HWLDI = OPWREC.OPWRQSZL[1];
    if (OPWREC.OPWREVM != 7) /* if not in review mode, disp prev prd*/
      OP0HW01.SY1STNBR = OPWREC.SY1STNBR[1];
      OP0HW01.SY2CLRID = OPWREC.SY2CLRID[1];
      OP0HW01.XDMCD = OPWREC.XDMCD[1];
      OP0HW01.OP0HWSP1 = "-";
      OP0HW01.OP0HWSP2 = "-";
      OP0HM010.OP0HMPPC = OP0HW01.OP0HWPRD;
    end
  else
    OP0HW01.OP0HWPSD = "N";
  end





   /* clean out incoming product array*/

  OPAREC.OPASUB1 = 1;

  while (OPAREC.OPASUB1 <= 6)
    OPWREC.OPWMPRDA[OPASUB1] = " ";
    OPAREC.OPASUB1 = OPAREC.OPASUB1 + 1;
  end







   /* if we are in review mode then we are coming to this*/
   /* screen with a selected product. read the item record*/
   /* for display of the product summary data.also put*/
   /* selected product into prd array for op0i.*/



  if (OPWREC.OP2LNINB > 0)
    OP0HW01.OP0HWSPV = "Y";
  else
    OP0HW01.OP0HWSPV = "N";
  end




  if (OPWREC.OPWREVM == 7 /* if in review mode*/
   || OP0HW01.OP0HWSPV == "Y") /* or reviewing a selected line item*/
    OP2REC.OP2LNINB = OPWREC.OP2LNINB;
    sysVar.arrayIndex = OPWREC.OP2LNINB;
    OPAREC.OP1NORID = 0;
    OPAREC.OPWHEXNO = OPWREC.OPWHEXNO[sysVar.arrayIndex];
    OP2REC.OP1NORID = OPAREC.OP1NORID;
    OP2REC.OP1PARTN = OP1REC.OP1PARTN;
    OP2REC.OP1CUOID = OP1REC.OP1CUOID;
    call "IO0440" ("S ", SQLCA, OP2REC) {isNoRefresh = yes, isExternal = yes};
    if (SQLCA.VAGen_SQLCODE == 0)
      OP0HSB2(); /* load map information*/
    else
      if (SQLCA.VAGen_SQLCODE == 100) /* if not found, shouldn't happen*/
         /* next sentence*/
      else
        TA1REC.TA1TYPE = "DB2 ";
        TA1REC.TA1FUNC = "RETN";
        TA1REC.TA1PGMNM = "OP0H    ";
        TA1REC.TA1LOCAT[1] = "S       ";
        TA1REC.TA1LOCAT[2] = "OP0HSBB ";
        TA1REC.TA1LOCAT[3] = "IO0440  ";
        TA1REC.TA1LOCAT[4] = "        ";
        TA1REC.TA1MAP = "OP0HM010";
        TA1REC.TA1DBASE = "OP2REC  ";
        TA1REC.TA1TBLVU = "VITEM001";
        TA1REC.TA1TBLKE = OP2REC.OP2KEY;
        call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes};
        COMMAREA.CA-USER-WORKAREA-4K = " "; /* clear ws on error*/
        XSPF4();
        exit program;
      end
    end


     /* now read the size record for the record to review.*/

    OP8REC.OP8TASK = "S";
    OP3REC.OP2KEY = OP2REC.OP2KEY;

    call "DB1000" (OP8REC, OP3REC, OPBREC) {isNoRefresh = yes, isExternal = yes};

    if (OPBREC.OPBSZRC != 0)
      TA1REC.TA1TYPE = "DB2 ";
      TA1REC.TA1FUNC = "RETN";
      TA1REC.TA1PGMNM = "OP0H    ";
      TA1REC.TA1LOCAT[1] = "S       ";
      TA1REC.TA1LOCAT[2] = "OP0HSBB ";
      TA1REC.TA1LOCAT[3] = "DB1000  ";
      TA1REC.TA1LOCAT[4] = "        ";
      TA1REC.TA1MAP = "OP0HM010";
      TA1REC.TA1DBASE = "OP3REC  ";
      TA1REC.TA1TBLVU = "SZRUN   ";
      TA1REC.TA1TBLKE = OP3REC.OP2KEY;
      call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes};
      COMMAREA.CA-USER-WORKAREA-4K = " "; /* clear ws on error*/
      XSPF4();
      exit program;
    end
  end

   /* ******** SCREENED PRODUCT PROCESSING ***************/
   /* WE NEED TO READ SYCREC TO SEE IF THERE'S A BLANK*/
   /* STYLE ASSOCIATED W/THE PRODUCT SO WE KNOW WHAT AVAIL*/
   /* TO DISPLAY AND DECREMENT*/

  if (OP1REC.XGPCD == "03") /* IF APPAREL*/
    OP0HW01.SY1STNBR = OP0HM010.SY1STNBR;
    OP0HW01.SY2CLRID = OP0HM010.SY2CLRID;
    OP0HW01.XDMCD = OP0HM010.XDMCD;
    OP0HSD1(); /* GET SYCREC*/
  end

   /* ****************************************************/

   /* re-read the bulk order item record for op0i speed.*/
   /* read only if draw order and if in review mode.*/

  if (OP0HW01.OP0HWSPV == "Y"
   || OPWREC.OPWREVM == 7)
    if (OP0HW01.OP0HWBDF == "C"
     || OP0HW01.OP0HWBDF == "R"
     || OP0HW01.OP0HWBDF == "S"
     || OP0HW01.OP0HWBDF == "X")
      OP0HSE4();
      OPWREC.OPWBKLIN[1] = OP0HW02.OP2LNINB;
      OPWREC.OP1NORID[1] = OP0HW02.OP1NORID;
    end
  end


          /* Set pf5 substitution message*/

   /* if pf5 is allowed (product substitution),  display*/
     /* the pf5 option below the message line; otherwise,*/
     /* set that field dark.*/

  if (OP0HW01.OP0HWPF5 == "Y") /* substitution allowed*/
    OP0HM010.OP0HMPF5 = "5:SUBSTITUTION";
    set OP0HM010.OP0HMPF5 initialAttributes;
  else
    set OP0HM010.OP0HMPF5 skip, invisible;
  end



end // end OP0HSBB

// set up for mult map
Function OP0HSBC()

      /* this statement group darkens certain fields bases on:*/
      /* whether the customer has their own style numbers,*/
      /* certain fields won't be used until oproc-2,*/
      /* or certain fields values are not present so dark.*/
      /* this routine also sets up certain defaults.*/

   /* if no ordered by, darken field and label*/
     /* otherwise load it to map*/

  if (OP1REC.OP1ORDBY > " ")
    OP0HM005.OP1ORDBY = OP1REC.OP1ORDBY;
  else
    set OP0HM005.OP1ORDBY protect, invisible;
    set OP0HM005.OP0HMOBL protect, invisible;
  end




   /* set up some map header fields*/

  OP0HM005.OP0HMRVN = "01";
  OP0HM005.OP0HMDTE = VGVar.currentShortGregorianDate;
  OP0HM005.OP0HMCNM = OPAREC.OPACUNO;
  OP0HM005.KUMSTRNM = OPWREC.KUMSTRNM;




     /* if cust style indicator not c, g or p, or print xref flag*/
     /* not turned on, darken cust style*/


  if (KUCREC.CU-PRT-XREF-FL == "Y")
    if (OPWREC.KUCSKIND == "P"
     || OPWREC.KUCSKIND == "C"
     || OPWREC.KUCSKIND == "R"
     || OPWREC.KUCSKIND == "G")
       /* next sentence*/
    else
      OPASUB = 1; /* set index*/
      while (OPASUB <= 6)
        set OP0HM005.KUIPRDID[OPASUB] protect, invisible;
        set OP0HM005.OP0HMCSL[OPASUB] protect, invisible;
        OPASUB = OPASUB + 1;
      end
    end
  else
    OPASUB = 1; /* set index*/
    while (OPASUB <= 6)
      set OP0HM005.KUIPRDID[OPASUB] protect, invisible;
      set OP0HM005.OP0HMCSL[OPASUB] protect, invisible;
      OPASUB = OPASUB + 1;
    end
  end


    /* turn off some fields until later*/
    /* set the unit of measure to autoskip if non standard*/
    /* values are not allowed or if this is a draw order.*/



  OPASUB = 1; /* set index*/
  while (OPASUB <= 6)
    OP0HM005.OP0HMDSZ[OPASUB] = "N";
    if (OP0HW01.OP0HWBDF == "C"
     || OP0HW01.OP0HWBDF == "R"
     || OP0HW01.OP0HWBDF == "S"
     || OP0HW01.OP0HWBDF == "X")
      set OP0HM005.XUMCD[OPASUB] protect;
    else
      if (OP1REC.XOTCD in XOTTBL.XOTCD
       && XOTTBL.XOTANSUM[sysVar.arrayIndex] == "N")
        set OP0HM005.XUMCD[OPASUB] protect;
      end
    end
    OPASUB = OPASUB + 1;
  end





     /* set quality default.*/


   /* if got a default quality code, move it to the*/
     /* six quality code fields on the map. if only one*/
     /* default quality code, protect the field/*/



  if (OP0HW01.XQACD > " ")
    OPASUB = 1;
    while (OPASUB <= 6)
      OP0HM005.XQACD[OPASUB] = OP0HW01.XQACD;
      if (OP0HW01.OP0HWOQC == "Y") /* if only one qual default*/
        set OP0HM005.XQACD[OPASUB] protect;
      end
      OPASUB = OPASUB + 1;
    end
  else
    converseLib.validationFailed(143);
  end





     /* set substitution select fields*/


   /* if pf5 is allowed, show 'pf5' below the message line*/
     /* and set substitution select fields unprotected;*/
     /* otherwise, set them protected and dark.*/



  OPASUB = 1;
  if (OP0HW01.OP0HWPF5 == "Y") /* substitution allowed*/
    OP0HM005.OP0HMPF5 = "5:SUBSTITUTION";
    set OP0HM005.OP0HMPF5 initialAttributes;
    while (OPASUB <= 6)
      set OP0HM005.OP0HMSBD[OPASUB] initialAttributes;
      set OP0HM005.OP0HMSBF[OPASUB] initialAttributes;
      OP0HM005.OP0HMSBD[OPASUB] = "SUBS:";
      OP0HM005.OP0HMSBF[OPASUB] = "N";
      OPASUB = OPASUB + 1;
    end
  else /* substitution not allowed*/
    set OP0HM005.OP0HMPF5 skip, invisible;
    while (OPASUB <= 6)
      set OP0HM005.OP0HMSBD[OPASUB] skip, invisible;
      set OP0HM005.OP0HMSBF[OPASUB] skip, invisible;
      OP0HM005.OP0HMSBF[OPASUB] = "N";
      OPASUB = OPASUB + 1;
    end
  end



   /* if gpc is not apparel,  default the color codes to 00*/

  if (OP1REC.XGPCD != "03")
    OPAREC.OPASUB1 = 1;
    while (OPAREC.OPASUB1 <= 6)
      OP0HM005.SY2CLRID[OPASUB1] = "00 ";
      OPAREC.OPASUB1 = OPAREC.OPASUB1 + 1;
    end
  end

       /* default dimension to '00'*/


  OPAREC.OPASUB1 = 1;
  while (OPAREC.OPASUB1 <= 6)
    OP0HM005.XDMCD[OPASUB1] = "00";
    OPAREC.OPASUB1 = OPAREC.OPASUB1 + 1;
  end


       /* default to iseg number from dprodc.vprdcu01*/
       /* if international division, f1 base order type,*/
       /* warehouse 51, gpc 03, and direct ship ' '(ship from whse)*/

  if (OP1REC.XDVCD == "02" /* international*/
   && OP1REC.XOBCD == "F1" /* futures*/
   && OP1REC.XGPCD == "03" /* apparel*/
   /* AND OP1REC.XWHCD = '51'; /* apparel whse*/
   && OP1REC.XDSCD == " ") /* ship from whse*/
    PC2REC.KUCCOID = OP1REC.KUCCOID;
    PC2REC.KUMSTRID = OP1REC.KUMSTRID;
    PC2REC.XNXCD = OP1REC.XNXCD;
    PC2REC.XGPCD = OP1REC.XGPCD;

    call "IO3340" ("SA", SQLCA, PC2REC) {isNoRefresh = yes, isExternal = yes}; /* call spec cd*/

    OPAREC.OPASUB1 = 1;
    while (OPAREC.OPASUB1 <= 6)
      if (SQLCA.VAGen_SQLCODE == 0)
        OP0HM005.PC2INSEG[OPASUB1] = PC2REC.PC2INSEG;
      else
        if (SQLCA.VAGen_SQLCODE == 100)
           /* next sentence*/
        else
          TA1REC.TA1TYPE = "DB2 ";
          TA1REC.TA1FUNC = "POST";
          TA1REC.TA1PGMNM = "OP0H    ";
          TA1REC.TA1LOCAT[1] = "SA      ";
          TA1REC.TA1LOCAT[2] = "OP0HSBC ";
          TA1REC.TA1LOCAT[3] = "IO3340  ";
          TA1REC.TA1LOCAT[4] = "        ";
          TA1REC.TA1MAP = "OP0HM005";
          TA1REC.TA1DBASE = "DPRODC  ";
          TA1REC.TA1TBLVU = "VPRDCU01";
          OP0HW01.OP0HWEK1 = OP1REC.OP1PARTN; /* part-char*/
          OP0HW01.OP0HWEK2 = OP1REC.OP1CUOID; /* cust-ord-id*/
          OP0HW01.OP0HWEK3 = OP1REC.OP1NORID; /* nike id*/
          OP0HW01.OP0HWEK4 = OP1REC.KUCCOID; /* company id*/
          OP0HW01.OP0HWEK5 = OP1REC.KUMSTRID; /* store id*/
          OP0HW01.OP0HWEK6 = OP1REC.XNXCD; /* dept code*/
          OP0HW01.OP0HWEK7 = OP1REC.XGPCD; /* gpc*/
          TA1REC.TA1TBLKE = OP0HW01.OP0HWEKY;
          try
            call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
          end /* abend routine*/
          COMMAREA.CA-USER-WORKAREA-4K = " "; /* clear ws on error*/
          OPAREC.OPASUB1 = 7; /* get out of loop*/
        end
      end
      OPAREC.OPASUB1 = OPAREC.OPASUB1 + 1;
    end
  end


     /* if coming back from product detail, save last set of*/
     /* first/last sizes so can dup sizes on multiple map.*/



  if (COMMAREA.CAFROMAP == "OP0I")
    OP0HSB1(); /* get dup set of sizes*/
  else
    set OP0HM005.OP0HMPPL protect, invisible; /* set prev prd label dark*/
  end





  OPAREC.OPASUB1 = 1; /* clean up prd array*/
  while (OPAREC.OPASUB1 <= 6)
    OPWREC.OPWMPRDA[OPASUB1] = " ";
    OPAREC.OPASUB1 = OPAREC.OPASUB1 + 1;
  end



end // end OP0HSBC

// Determine if pf5 is allowed
Function OP0HSBD()

      /* *  pf 5 - product substitution*/

  if (OPWREC.OPWREVM == 7 /* product review mode*/
   || OPWREC.OP2LNINB > 0 /* line item number*/
   || OPWREC.OPWFUNC == "4") /* order is a draw*/
    OP0HW01.OP0HWPF5 = "N"; /* pf5 not allowed*/
  else
    if (OP1REC.SP1ID > " ") /* there is a sales program*/

          /* *** if a sales program is present, check if the sales*/
          /* *** program is applicable to all products -- a '**'*/
          /* *** is found in an sp1rec.xspcd bucket.  this is so*/
          /* *** as to insured that any product comming back is*/
          /* *** allowed for the sales program.*/

      set SP1REC empty;
      SP1REC.SP1ID = OP1REC.SP1ID;
      OP0HSBE(); /* get sp1rec*/

      if ("**" in SP1REC.XSPCD)
        OP0HW01.OP0HWPF5 = "Y"; /* pf5 allowed*/
      else
        OP0HW01.OP0HWPF5 = "N"; /* pf5 not allowed*/
      end
    else
      OP0HW01.OP0HWPF5 = "Y"; /* pf5 allowed*/
    end
  end


   /* *********************************************************/
   /* ** Note if after the above tests to determine if access*/
   /* ** to substitution is still allowed, KUCREC or the cus-*/
   /* ** tomer company record will indicate if the customer*/
   /* ** placing the order is eligible to do product substi-*/
   /* ** tution.*/
   /* *********************************************************/

  if (OP0HW01.OP0HWPF5 == "Y") /* pf5 was allowed*/
     /* ** kucrec was already read in op0hsba ***/
    if (KUCREC.KUCPSFL == "N") /* customer not allowed*/
      OP0HW01.OP0HWPF5 = "N";
    end
  end


   /* *********************************************************/
   /* ** Note that the following statement overrides*/
   /* ** what ever value is determined from the previous*/
   /* ** routine.  This statement will be deleted*/
   /* ** when AV0K and AV0L are installed in production to*/
   /* ** activate product substitution in order entry.*/
   /* *********************************************************/

   /* MOVE 'N' TO OP0HW01.OP0HWPF5    ; pf5 not allowed*/

   /* *********************************************************/



end // end OP0HSBD

// read sp1rec
Function OP0HSBE()
   /* ************************************************************/
   /* ***  READ SALES PROGRAM RECORD*/
   /* ************************************************************/

  call "IO0070" ("S ", SQLCA, SP1REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0
   || SQLCA.VAGen_SQLCODE == 100)
     /* next sentence*/
  else
    TA1REC.TA1TYPE = "DB2 ";
    TA1REC.TA1FUNC = "RETN";
    TA1REC.TA1PGMNM = "OP0H    ";
    TA1REC.TA1LOCAT[1] = "S       ";
    TA1REC.TA1LOCAT[2] = "OP0HSDE ";
    TA1REC.TA1LOCAT[3] = "IO0070  ";
    TA1REC.TA1LOCAT[4] = "        ";
    TA1REC.TA1MAP = "OP0HM005";
    TA1REC.TA1DBASE = "SP1REC  ";
    TA1REC.TA1TBLVU = "VSPGM001";
    TA1REC.TA1TBLKE = SP1REC.SP1ID;
    call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
    COMMAREA.CA-USER-WORKAREA-4K = " "; /* on error clear ws*/
    XSPF4();
    exit program;
  end



end // end OP0HSBE

// move saved map to op0hm005
Function OP0HSBF()
   /* ************************************************************/
   /* **  Move the saved values of the multiple header entry map*/
   /* **  back to op0hm005 from oskrec.  These values were saved*/
   /* **  in oskrec when a request for a product substitution*/
   /* **  was made.  if a substitute was made while in AV0L,*/
   /* **  it will take the place of the proper header line using*/
   /* **  the saved pointer/subscript in osgrec.*/
   /* ************************************************************/


  OPASUB = 1; /* set subscript*/
  while (OPASUB <= 6)
    set OP0HM005.SY1STNBR[OPASUB] modified; /* set style number modified*/
    OP0HM005.OP0HMSBF[OPASUB] = OSKREC.OSKSUBFL[OPASUB]; /* rqt fl*/
    OP0HM005.SY1STNBR[OPASUB] = OSKREC.SY1STNBR[OPASUB]; /* style*/
    OP0HM005.SY2CLRID[OPASUB] = OSKREC.SY2CLRID[OPASUB]; /* color*/
    OP0HM005.XDMCD[OPASUB] = OSKREC.XDMCD[OPASUB]; /* dim*/
    OP0HM005.KUIPRDID[OPASUB] = OSKREC.KUIPRDID[OPASUB]; /* cu sty*/
    OP0HM005.OP0HMDSZ[OPASUB] = OSKREC.OSKDUPSZ[OPASUB]; /* dup sz*/
                                  /* MOVE OSKREC.XSZCD(OPASUB) TO*/
                                   /* OP0HM005.XSZCD(OPASUB);    /* std sz*/
                                   /* dist*/
    OP0HM005.OP0HMFSZ[OPASUB] = OSKREC.OSKFSZ[OPASUB]; /* fst sz*/
    OP0HM005.OP0HMLSZ[OPASUB] = OSKREC.OSKLSZ[OPASUB]; /* lst sz*/
    OP0HM005.OP2TORGQ[OPASUB] = OSKREC.OP2TONOQ[OPASUB]; /* ord qty*/
    OP0HM005.XQACD[OPASUB] = OSKREC.XQACD[OPASUB]; /* qual cd*/
    OP0HM005.PC2INSEG[OPASUB] = OSKREC.XSDCD[OPASUB]; /* spec cd*/
    OP0HM005.XPGCD[OPASUB] = OSKREC.XPGCD[OPASUB]; /* pkg cd*/
    OP0HM005.XUMCD[OPASUB] = OSKREC.XUMCD[OPASUB]; /* uom*/
    OPASUB = OPASUB + 1;
  end

   /* -----------------------------------------------------------*/
    /* Replace substituted style if any.*/
    /* Note: OSGPRSUB is the saved product pointer for the map.*/
          /* This was saved in OSGREC before transfering to*/
          /* substitution.*/
   /* -----------------------------------------------------------*/
  set OP0HM005.SY1STNBR[OSGPRSUB] cursor;

  if (OSGREC.OP2SSTYN > " " /* Does a substitute exist?*/
   && OSGREC.OP2SCLCD > " " 
   && OSGREC.OP2SDMCD > " ")

    if (OSGREC.SY1STNBR == OSGREC.OP2SSTYN /* Make sure it's a substitute.*/
     && OSGREC.SY2CLRID == OSGREC.OP2SCLCD 
     && OSGREC.XDMCD == OSGREC.OP2SDMCD)  
      converseLib.validationFailed(566); /* No subs prod was selected.*/
    else
      OP0HSB3();
                                   /* Replace prod with substitute.*/
      converseLib.validationFailed(567); /* Product was substituted.*/
    end

  else
    converseLib.validationFailed(566); /* No subs prod was selected.*/
  end
end // end OP0HSBF

// move saved map to op0hm010
Function OP0HSBG()
   /* ************************************************************/
   /* **  Move the saved values of the multiple header entry map*/
   /* **  back to op0hm010 from oskrec.  These values were saved*/
   /* **  in oskrec when a request for a product substitution*/
   /* **  was made.  if a substitute was made while in AV0L,*/
   /* **  it will take the place of the product originally*/
   /* **  entered.*/
   /* ************************************************************/


  OP0HM010.SY1STNBR = OSKREC.SY1STNBR[1]; /* style*/
  OP0HM010.SY2CLRID = OSKREC.SY2CLRID[1]; /* color*/
  OP0HM010.XDMCD = OSKREC.XDMCD[1]; /* dim*/
  OP0HM010.KUIPRDID = OSKREC.KUIPRDID[1]; /* cu sty*/
  OP0HM010.OP0HMDPS = OSKREC.OSKDUPSZ[1]; /* dup sz*/
   /* OVE OSKREC.XSZCD(1) TO OP0HM010.XSZCD;     /* std sz dist*/
  OP0HM010.OP0HMFSZ = OSKREC.OSKFSZ[1]; /* fst sz*/
  OP0HM010.OP0HMLSZ = OSKREC.OSKLSZ[1]; /* lst sz*/
  OP0HM010.OP2TORGQ = OSKREC.OP2TONOQ[1]; /* ord qty*/
  OP0HM010.XQACD = OSKREC.XQACD[1]; /* qual cd*/
  OP0HM010.PC2INSEG = OSKREC.XSDCD[1]; /* spec cd*/
  OP0HM010.XPGCD = OSKREC.XPGCD[1]; /* pkg cd*/
  OP0HM010.XUMCD = OSKREC.XUMCD[1]; /* uom*/
  set OP0HM010.SY1STNBR modified;


   /* ----------------------------------------------------------*/
   /* Replace substituted style if any.*/
   /* ----------------------------------------------------------*/
  if (OSGREC.OP2SSTYN > " " /* Does a substitute exist?*/
   && OSGREC.OP2SCLCD > " " 
   && OSGREC.OP2SDMCD > " ")

    if (OSGREC.SY1STNBR == OSGREC.OP2SSTYN /* Make sure it's a substitute.*/
     && OSGREC.SY2CLRID == OSGREC.OP2SCLCD 
     && OSGREC.XDMCD == OSGREC.OP2SDMCD)  
      converseLib.validationFailed(566); /* No subs prod was selected.*/
    else
      OP0HSB4();
                                   /* Replace prod with substitute.*/
      converseLib.validationFailed(567); /* Product was substituted.*/
    end

  else
    converseLib.validationFailed(566); /* No subs prod was selected.*/
  end
end // end OP0HSBG

// reset mdt tags
Function OP0HSCA()



          /* set mdt's in fields for the case of invalid aid key*/
          /* this allows the user to press the correct aid key*/
          /* while the map doesn't lose its mdt's.*/




  OPASUB = 1;

  while (OPASUB <= 6)
    if (OP0HM005.SY1STNBR[OPASUB] is modified)
      set OP0HM005.SY1STNBR[OPASUB] modified;
    end
    if (OP0HM005.SY2CLRID[OPASUB] is modified)
      set OP0HM005.SY2CLRID[OPASUB] modified;
    end
    if (OP0HM005.XDMCD[OPASUB] is modified)
      set OP0HM005.XDMCD[OPASUB] modified;
    end
    if (OP0HM005.OP0HMFSZ[OPASUB] is modified)
      set OP0HM005.OP0HMFSZ[OPASUB] modified;
    end
    if (OP0HM005.OP0HMLSZ[OPASUB] is modified)
      set OP0HM005.OP0HMLSZ[OPASUB] modified;
    end
    if (OP0HM005.OP2TORGQ[OPASUB] is modified)
      set OP0HM005.OP2TORGQ[OPASUB] modified;
    end
    if (OP0HM005.XQACD[OPASUB] is modified)
      set OP0HM005.XQACD[OPASUB] modified;
    end
    if (OP0HM005.KUIPRDID[OPASUB] is modified)
      set OP0HM005.KUIPRDID[OPASUB] modified;
    end
    if (OP0HM005.OP0HMDSZ[OPASUB] is modified)
      set OP0HM005.OP0HMDSZ[OPASUB] modified;
    end
   /* IF OP0HM005.XSZCD(OPASUB) IS MODIFIED;*/
     /* SET OP0HM005.XSZCD(OPASUB) MODIFIED;*/
   /* END;*/
    if (OP0HM005.XPGCD[OPASUB] is modified)
      set OP0HM005.XPGCD[OPASUB] modified;
    end
    if (OP0HM005.XUMCD[OPASUB] is modified)
      set OP0HM005.XUMCD[OPASUB] modified;
    end
    OPASUB = OPASUB + 1;
  end







end // end OP0HSCA

// get special cust grp KUPREC
Function OP0HSCU()

  KUPREC.KUCCOID = OP1REC.KUCCOID; /* load cust comp key*/
  KUPREC.KUMSTRID = OP1REC.KUMSTRID; /* cust store key*/
  KUPREC.XNXCD = OP1REC.XNXCD; /* cust dept*/
  KUPREC.XGPCD = OP1REC.XGPCD; /* gpccode*/

  call "IO0260" ("S ", SQLCA, KUPREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0) /* this is a restricted customer*/
     /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == 100) /* this is not a restricted customer*/
        /* next sentence*/
    else
      TA1REC.TA1DBASE = "DCUST   ";
      TA1REC.TA1TBLVU = "VCUGRP01";
      OP0HW01.OP0HWNBR = OP1REC.OP1CUOID; /* format cust ord id*/
      TA1REC.TA1LOCAT[1] = OP0HW01.OP0HWNBR;
      OP0HW01.OP0HWNBR = OP1REC.OP1NORID; /* format nike ord id*/
      TA1REC.TA1LOCAT[2] = OP0HW01.OP0HWNBR;
      TA1REC.TA1LOCAT[3] = "OP0HSCU ";
      TA1REC.TA1LOCAT[4] = "IO0260  ";
      XSOPS02();
    end
  end


end // end OP0HSCU

// read nike style record
Function OP0HSD1()




        /* read nike style/color*/






  SYCREC.XGPCD = OP1REC.XGPCD;
  SYCREC.SY1STNBR = OP0HW01.SY1STNBR;
  SYCREC.SY2CLRID = OP0HW01.SY2CLRID;
  SYCREC.XDMCD = OP0HW01.XDMCD;

  call "IO0560" ("S ", SQLCA, SYCREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    /* TT#4654  SPAIN CHANGES  Begin **************/
    OP0HS-SPAIN-CHECK(); /* validate product for spain/canary*/
                                   /* compliance*/
    if (OP10REC.OP10-RETURN-CODE == "02")
      OP0HW01.OP0HW-PRODUCT-INV-FLAG = "Y"; /* product invalid*/
      OP0HW01.OP0HW-MUL-PRODUCT-FLAG = "Y"; /* multiple prod scr*/
      converseLib.validationFailed(1003); /* invalid style for SPAIN/CANARY*/
      return;
    end

    if (OP10REC.OP10-RETURN-CODE == "03") /* deadlock*/
      OP0HW01.OP0HW-PROD-DLOCK-FLAG = "Y"; /* set deadlock flag*/
      OP0HW01.OP0HW-MUL-PRODUCT-FLAG = "Y"; /* multiple prod fl*/
      converseLib.validationFailed(911); /* data base busy*/
      set TA1REC empty;
      TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* curr app*/
      TA1REC.TA1MAP = "OP0HM005"; /* curr map*/
      TA1REC.TA1LOC = "OP0HS-SPAIN-CHECK"; /* location*/
      XSOPS-OP6410-PSRTN();
      return;
    end
    /* TT#4654  SPAIN CHANGES  End ************/

    /* --added for Canada--June 2, 1995--*/

    if (OP1REC.XDZ-DATA-DIST-CD == "CA")
      set WSY2000 empty;
      WSY2000.XDR-PROD-REG-CD = "05";
      OP0HS-SEL-VSYREG01();


      if (OP0HW01.OP0HW-WSY2000-FND-FLAG == "Y")
        OP0HSDZ(); /* style not sold anymore?*/
      else
        if (OP0HW01.OP0HW-WSY2000-FND-FLAG == "N")
          OPAREC.OPAERR = "Y";
          converseLib.validationFailed(911);
          return;
        else
          if (WSY2000.WSY2000-RETURN-CODE == "98")
            OPAREC.OPAERR = "Y";
            converseLib.validationFailed(010);
            return;
          else
            OPAREC.OPAERR = "Y";
            converseLib.validationFailed(909);
            return;
          end
        end
      end
      /* --added for US Apparel--June 13, 1996--*/

    else
      if (OP1REC.XGPCD == "03")


        if (COMMAREA.XDVCD == "02" /* userid assigned to europe*/
         || COMMAREA.XDVCD == "03") /* userid assigned to asia*/
          /* continue processing*/
        else
          set WSY2000 empty;
          WSY2000.XDR-PROD-REG-CD = "01";
          OP0HS-SEL-VSYREG01();
          if (OP0HW01.OP0HW-WSY2000-FND-FLAG == "Y")
            OP0HSDZ(); /* style not sold anymore?*/
          else
            if (OP0HW01.OP0HW-WSY2000-FND-FLAG == "N")
              OPAREC.OPAERR = "Y";
              converseLib.validationFailed(911);
              return;
            else
              if (WSY2000.WSY2000-RETURN-CODE == "98")
                OPAREC.OPAERR = "Y";
                converseLib.validationFailed(010);
                return;
              else
                OPAREC.OPAERR = "Y";
                converseLib.validationFailed(909);
                return;
              end
            end
          end
        end
      end
    end

    OP0HSDZ(); /* style not sold anymore?*/
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      converseLib.validationFailed(131);
      return;
    else
      TA1REC.TA1TYPE = "DB2 ";
      TA1REC.TA1FUNC = "RETN";
      TA1REC.TA1PGMNM = "OP0H    ";
      TA1REC.TA1LOCAT[1] = "S       ";
      TA1REC.TA1LOCAT[2] = "OP0HSD1 ";
      TA1REC.TA1LOCAT[3] = "IO0560  ";
      TA1REC.TA1LOCAT[4] = "        ";
      TA1REC.TA1MAP = "OP0HM005";
      TA1REC.TA1DBASE = "SYCREC  ";
      TA1REC.TA1TBLVU = "VCOLOR02";
      TA1REC.TA1TBLKE = SYCREC.SYCKEY;
      call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
      COMMAREA.CA-USER-WORKAREA-4K = " "; /* clear ws on error*/
      XSPF4();
      exit program;
    end
  end




end // end OP0HSD1

// check prd life cycle
Function OP0HSD2()






          /* life cycle code check. get current life cycle from*/
          /* sycrec using system date then check to see that this*/
          /* life cycle is allowable for this order's order type.*/



  OP0HSLD(); /* find life cycle from sycrec*/

  if (OP0HW01.XLCCD == "  ") /* no active life cycle found*/
    converseLib.validationFailed(523); /* no life cycle currently in effect*/
    OPAREC.OPAERR = "Y";
    OP0HW01.OP0HWSFL = "Y";
    return;
  end




  if (OP1REC.XOTCD in XOTTBL.XOTCD)
    if (OP0HW01.XLCCD == XOTTBL.XLCCD1[sysVar.arrayIndex])
      return;
    else
      if (OP0HW01.XLCCD == XOTTBL.XLCCD2[sysVar.arrayIndex])
        return;
      else
        if (OP0HW01.XLCCD == XOTTBL.XLCCD3[sysVar.arrayIndex])
          return;
        else
          if (OP0HW01.XLCCD == XOTTBL.XLCCD4[sysVar.arrayIndex])
            return;
          else
            if (OP0HW01.XLCCD == XOTTBL.XLCCD5[sysVar.arrayIndex])
              return;
            end
          end
        end
      end
    end
  end



      /* if order type table didn't match life cylce try*/
      /* order class table. only way to get here is if*/
      /* didn't get match on order type table.*/


  if (OP1REC.XOCCD in XOCTBL.XOCCD)
    if (OP0HW01.XLCCD == XOCTBL.XLCCD1[sysVar.arrayIndex])
      return;
    else
      if (OP0HW01.XLCCD == XOCTBL.XLCCD2[sysVar.arrayIndex])
        return;
      end
    end
  end

   /* if we get here, still haven't found anything*/


   /* ********** divert order processing ********************/

  if (OP1REC.XDVCD == "02" /* international*/
   && OP1REC.XOBCD == "F1" /* futures*/
   && OP1REC.XDSCD == "1"  /* direct ship*/
   && OP1REC.OP1CUNDT < OPAREC.OPACDT) /* implies divert order*/
    return; /* skip error routine*/
  end

   /* ********** end divert order processing ****************/

  if (OP0HW01.XLCCD == "20")
    converseLib.validationFailed(524); /* this is a closeout product*/
  else /* not valid for the order type*/
    if (OP0HW01.XLCCD == "15")
      converseLib.validationFailed(525); /* this is a cancelled product*/
    else
      if (OP0HW01.XLCCD == "05")
        converseLib.validationFailed(526); /* this is an in development product*/
      else
        if (OP0HW01.XLCCD == "25")
          converseLib.validationFailed(527); /* this is a dormant product*/
        else
          if (OP0HW01.XLCCD == "10")
            converseLib.validationFailed(132); /* style life cycle not valid for xot*/
          end
        end
      end
    end
  end

  OPAREC.OPAERR = "Y";
  OP0HW01.OP0HWSFL = "Y";






end // end OP0HSD2

// default first size
Function OP0HSD3()
    /* multiple product header screen*/

   /* this routine will set a default first size if not entered*/
   /* it works forward through the products size array.*/

   /* ------------------------------------------------------------*/
    /* first make sure that the xottbl.allowed/disallowed*/
    /* division code = a or d.*/
   /* ------------------------------------------------------------*/

  if (OP1REC.XOTCD in XOTTBL.XOTCD)
    if (XOTTBL.XOTALWDV[sysVar.arrayIndex] == "A"
     || XOTTBL.XOTALWDV[sysVar.arrayIndex] == "D")
       /* next sentence--ok good values, keep going*/
    else
      OPAREC.OPAERR = "Y";
      OP0HW01.OP0HWSFL = "Y";
      set OP0HM005.OP0HMLSZ[OPASUB] cursor, modified, bold;
      set OP0HM005.OP0HMFSZ[OPASUB] cursor, modified, bold;
      converseLib.validationFailed(148);
      return;
    end
  end


   /* ------------------------------------------------------------*/
   /* look for a valid size based on division codes:*/
   /* if xottbl.xotalwdv = 'a' (allowed) and the product divison*/
   /* equals one of the order type's allowable divisions, and*/
   /* the xtras/fringe/gut ok, save it.*/
   /* ----------------------------------------------------*/

  OPAREC.OPASUB1 = 1;
  OP0HW01.OP0HWFSZ = 0;

  if (XOTTBL.XOTALWDV[sysVar.arrayIndex] == "A") /* allowed divisions*/

    while (OPAREC.OPASUB1 <= 40)
      if (SYCREC.XDVCD[OPASUB1] > " ")
        if (SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD1[sysVar.arrayIndex]
         || SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD2[sysVar.arrayIndex]
         || SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD3[sysVar.arrayIndex]
         || SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD4[sysVar.arrayIndex]
         || SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD5[sysVar.arrayIndex])

          if (XOTTBL.XOTXTRAS[sysVar.arrayIndex] == "Y") /* if ord type allows extras*/
            OP0HW01.OP0HWFSZ = OPAREC.OPASUB1;
            OPAREC.OPASUB1 = 41;
          else
            if (SYCREC.SY3FRGUT[OPASUB1] == "F" /* if size is fringe*/
             || SYCREC.SY3FRGUT[OPASUB1] == "G") /* if size is gut*/
              OP0HW01.OP0HWFSZ = OPAREC.OPASUB1;
              OPAREC.OPASUB1 = 41;
            end
          end

        end
      end
      OPAREC.OPASUB1 = OPAREC.OPASUB1 + 1;
    end

  end

       /* --------------------------------------------------*/
       /* if the order type table indicates 'd', use*/
       /* this 'disallowed' division logic instead*/
       /* --------------------------------------------------*/
  if (XOTTBL.XOTALWDV[sysVar.arrayIndex] == "D") /* disallowed divisions*/

    while (OPAREC.OPASUB1 <= 40)
      if (SYCREC.XDVCD[OPASUB1] > " ")
        if (SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD1[sysVar.arrayIndex]
         || SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD2[sysVar.arrayIndex]
         || SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD3[sysVar.arrayIndex]
         || SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD4[sysVar.arrayIndex]
         || SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD5[sysVar.arrayIndex])
          /* next sentence--disallowed division, keep looking*/
        else
          if (XOTTBL.XOTXTRAS[sysVar.arrayIndex] == "Y") /* if ord type allows extras*/
            OP0HW01.OP0HWFSZ = OPAREC.OPASUB1;
            OPAREC.OPASUB1 = 41;
          else
            if (SYCREC.SY3FRGUT[OPASUB1] == "F" /* if size is fringe*/
             || SYCREC.SY3FRGUT[OPASUB1] == "G") /* if size is gut*/
              OP0HW01.OP0HWFSZ = OPAREC.OPASUB1;
              OPAREC.OPASUB1 = 41;
            end
          end
        end
      end
      OPAREC.OPASUB1 = OPAREC.OPASUB1 + 1;
    end

  end




  if (OP0HW01.OP0HWFSZ > 0) /* if got a size*/
     /* next sentence*/
  else
    OPAREC.OPAERR = "Y"; /* error, no size to default to*/
    OP0HW01.OP0HWSFL = "Y";
    set OP0HM005.OP0HMFSZ[OPASUB] cursor, modified, bold;
    converseLib.validationFailed(148);
  end



end // end OP0HSD3

// default last size
Function OP0HSD4()
       /* multiple product header screen*/

   /* this routine will set a default first size if not entered*/
   /* it works backward through the product's size array.*/

   /* ------------------------------------------------------------*/
    /* first make sure that the xottbl.allowed/disallowed*/
    /* division code = a or d.*/
   /* ------------------------------------------------------------*/

  if (OP1REC.XOTCD in XOTTBL.XOTCD)
    if (XOTTBL.XOTALWDV[sysVar.arrayIndex] == "A"
     || XOTTBL.XOTALWDV[sysVar.arrayIndex] == "D")
       /* next sentence--ok good values, keep going*/
    else
      OPAREC.OPAERR = "Y";
      OP0HW01.OP0HWSFL = "Y";
      set OP0HM005.OP0HMLSZ[OPASUB] cursor, modified, bold;
      set OP0HM005.OP0HMFSZ[OPASUB] cursor, modified, bold;
      converseLib.validationFailed(148);
      return;
    end
  end


   /* ------------------------------------------------------------*/
   /* look for a valid size based on division codes:*/
   /* if xottbl.xotalwdv = 'a' (allowed) and the product divison*/
   /* equals one of the order type's allowable divisions, and*/
   /* the xtras/fringe/gut ok, save it.*/
   /* ----------------------------------------------------*/

  OPAREC.OPASUB1 = 40;
  OP0HW01.OP0HWLSZ = 0;

  if (XOTTBL.XOTALWDV[sysVar.arrayIndex] == "A") /* allowed divisions*/

    while (OPAREC.OPASUB1 >= 1)
      if (SYCREC.XDVCD[OPASUB1] > " ")
        if (SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD1[sysVar.arrayIndex]
         || SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD2[sysVar.arrayIndex]
         || SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD3[sysVar.arrayIndex]
         || SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD4[sysVar.arrayIndex]
         || SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD5[sysVar.arrayIndex])

          if (XOTTBL.XOTXTRAS[sysVar.arrayIndex] == "Y") /* if ord type allows extras*/
            OP0HW01.OP0HWLSZ = OPAREC.OPASUB1;
            OPAREC.OPASUB1 = 1;
          else
            if (SYCREC.SY3FRGUT[OPASUB1] == "F" /* if size is fringe*/
             || SYCREC.SY3FRGUT[OPASUB1] == "G") /* if size is gut*/
              OP0HW01.OP0HWLSZ = OPAREC.OPASUB1;
              OPAREC.OPASUB1 = 1;
            end
          end

        end
      end
      OPAREC.OPASUB1 = OPAREC.OPASUB1 - 1;
    end

  end

       /* --------------------------------------------------*/
       /* if the order type table indicates 'd', use*/
       /* this 'disallowed' division logic instead*/
       /* --------------------------------------------------*/
  if (XOTTBL.XOTALWDV[sysVar.arrayIndex] == "D") /* disallowed divisions*/

    while (OPAREC.OPASUB1 >= 1)
      if (SYCREC.XDVCD[OPASUB1] > " ")
        if (SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD1[sysVar.arrayIndex]
         || SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD2[sysVar.arrayIndex]
         || SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD3[sysVar.arrayIndex]
         || SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD4[sysVar.arrayIndex]
         || SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD5[sysVar.arrayIndex])
          /* next sentence--disallowed division, keep looking*/
        else
          if (XOTTBL.XOTXTRAS[sysVar.arrayIndex] == "Y") /* if ord type allows extras*/
            OP0HW01.OP0HWLSZ = OPAREC.OPASUB1;
            OPAREC.OPASUB1 = 1;
          else
            if (SYCREC.SY3FRGUT[OPASUB1] == "F" /* if size is fringe*/
             || SYCREC.SY3FRGUT[OPASUB1] == "G") /* if size is gut*/
              OP0HW01.OP0HWLSZ = OPAREC.OPASUB1;
              OPAREC.OPASUB1 = 1;
            end
          end
        end
      end
      OPAREC.OPASUB1 = OPAREC.OPASUB1 - 1;
    end

  end




  if (OP0HW01.OP0HWLSZ > 0) /* if got a size*/
     /* next sentence*/
  else
    OPAREC.OPAERR = "Y"; /* error, no size to default to*/
    OP0HW01.OP0HWSFL = "Y";
    set OP0HM005.OP0HMLSZ[OPASUB] cursor, modified, bold;
    converseLib.validationFailed(148);
  end




end // end OP0HSD4

// edit numeric size
Function OP0HSD5()







    /* this routines makes sure that the numeric size entered*/
    /* is between 1 and 40. this is hard due to the input field*/
    /* being character. The edit goes as follows:*/

      /* 1. move size field to array of 5 individual characters*/
      /* 2. go through each cell and test for 0 through 9.*/
         /* replace spaces with zeroes.*/
      /* 3. if map field ok, check range.*/
      /* 4. do all three steps for the first map size.*/










   /* check first size*/


  OP0HW01.OP0HWSRC = OP0HM005.OP0HMFSZ[OPASUB];
  OPAREC.OPASUB1 = 5;

  while (OPAREC.OPASUB1 >= 1)
    if (OP0HW01.OP0HWSRA[OPASUB1] >= "0"
     && OP0HW01.OP0HWSRA[OPASUB1] <= "9")
      OPAREC.OPASUB1 = OPAREC.OPASUB1 - 1;
    else
      if (OP0HW01.OP0HWSRA[OPASUB1] == " ")
        OP0HW01.OP0HWSRA[OPASUB1] = "0";
        OPAREC.OPASUB1 = OPAREC.OPASUB1 - 1;
      else
        OPAREC.OPAERR = "Y";
        OP0HW01.OP0HWSFL = "Y";
        set OP0HM005.OP0HMFSZ[OPASUB] cursor, modified, bold;
        OPAREC.OPASUB1 = 0;
      end
    end
  end


  if (OPAREC.OPAERR == "N") /* first size was numeric*/
    OP0HW01.OP0HWFSZ = OP0HW01.OP0HWSRN;
  else
    OP0HW01.OP0HWFSZ = 0;
  end



  if (OP0HW01.OP0HWFSZ >= 1
   && OP0HW01.OP0HWFSZ <= 40)
    set OP0HM005.OP0HMFSZ[OPASUB] initialAttributes;
  else
    OPAREC.OPAERR = "Y";
    OP0HW01.OP0HWSFL = "Y";
    set OP0HM005.OP0HMFSZ[OPASUB] cursor, modified, bold;
  end






    /* now find a match on last size*/



  OP0HW01.OP0HWSRC = OP0HM005.OP0HMLSZ[OPASUB];
  OPAREC.OPASUB1 = 5;

  while (OPAREC.OPASUB1 >= 1)
    if (OP0HW01.OP0HWSRA[OPASUB1] >= "0"
     && OP0HW01.OP0HWSRA[OPASUB1] <= "9")
      OPAREC.OPASUB1 = OPAREC.OPASUB1 - 1;
    else
      if (OP0HW01.OP0HWSRA[OPASUB1] == " ")
        OP0HW01.OP0HWSRA[OPASUB1] = "0";
        OPAREC.OPASUB1 = OPAREC.OPASUB1 - 1;
      else
        OPAREC.OPAERR = "Y";
        OP0HW01.OP0HWSFL = "Y";
        set OP0HM005.OP0HMLSZ[OPASUB] cursor, modified, bold;
        OPAREC.OPASUB1 = 0;
      end
    end
  end


  if (OPAREC.OPAERR == "N") /* last size was numeric*/
    OP0HW01.OP0HWLSZ = OP0HW01.OP0HWSRN;
  else
    OP0HW01.OP0HWLSZ = 0;
  end


  if (OP0HW01.OP0HWLSZ >= 1
   && OP0HW01.OP0HWLSZ <= 40)
    set OP0HM005.OP0HMLSZ[OPASUB] initialAttributes;
  else
    OPAREC.OPAERR = "Y";
    OP0HW01.OP0HWSFL = "Y";
    set OP0HM005.OP0HMLSZ[OPASUB] cursor, modified, bold;
  end





   /* Count the valid sizes between the first and last*/
   /* if no errors were found.*/

  if (OPAREC.OPAERR == "N")
    OP0HSE5();
  end
end // end OP0HSD5

// edit alpha sizes
Function OP0HSD6()







   /* this routine edits alpha sizes for existance*/



       /* find a match on first size*/


  OPASUB1 = 1;

  while (OPASUB1 <= 40)
    if (OP0HM005.OP0HMFSZ[OPASUB] == SY4REC.SY4IDDSC[OPASUB1])
      OP0HW01.OP0HWFSZ = OPASUB1;
      OPASUB1 = 99;
    else
      OPASUB1 = OPASUB1 + 1;
    end
  end


  if (OPASUB1 != 99) /* if not found*/
    set OP0HM005.OP0HMFSZ[OPASUB] cursor, modified, bold;
    OPAREC.OPAERR = "Y";
    OP0HW01.OP0HWSFL = "Y";
  end




   /* now find a match on last size*/



  OPASUB1 = 1;

  while (OPASUB1 <= 40)
    if (OP0HM005.OP0HMLSZ[OPASUB] == SY4REC.SY4IDDSC[OPASUB1])
      OP0HW01.OP0HWLSZ = OPASUB1;
      OPASUB1 = 99;
    else
      OPASUB1 = OPASUB1 + 1;
    end
  end


  if (OPASUB1 != 99) /* if not found*/
    set OP0HM005.OP0HMLSZ[OPASUB] cursor, modified, bold;
    OPAREC.OPAERR = "Y";
    OP0HW01.OP0HWSFL = "Y";
  end




   /* Count number of valid sizes between first and last*/
   /* if no errors were found.*/
  if (OPAREC.OPAERR == "N")
    OP0HSE5();
  end
end // end OP0HSD6

// propogate aprl style numbers
Function OP0HSD7()




    /* this routine will default aprl style numbers. it will*/
    /* do the following: (bottom up edit)*/

       /* if line item has no style but has an entered color code*/
          /* go up through the map looking for a style to copy.*/
       /* if found*/
          /* copy in the missing style number.*/
       /* else*/
          /* see if style from previous op0i call to default to*/
          /* if exists*/
             /* use it*/
          /* else*/
             /* ignore line item.*/




  OPAREC.OPASUB1 = 6;

  while (OPAREC.OPASUB1 >= 1)
    if (OP0HM005.SY1STNBR[OPASUB1] == " "      /* if no style*/
     && OP0HM005.SY2CLRID[OPASUB1] is modified /* but color just hit*/
     && OP0HM005.SY2CLRID[OPASUB1] > " ")      /* and color has a value*/
      OPAREC.OPASUB2 = OPAREC.OPASUB1;
      OPAREC.OPASUB2 = OPAREC.OPASUB2 - 1;
      while (OPAREC.OPASUB2 >= 1)
        if (OP0HM005.SY1STNBR[OPASUB2] > " ") /* if style exists to dup*/
          OP0HM005.SY1STNBR[OPASUB1] = OP0HM005.SY1STNBR[OPASUB2];
          OPAREC.OPASUB2 = -9; /* get out of loop*/
        else
          OPAREC.OPASUB2 = OPAREC.OPASUB2 - 1;
        end
      end
      if (OPAREC.OPASUB2 != -9) /* if def style not found on map, try op0i*/
        if (OP0HW01.OP0HWPST > " ") /* if previous style to use*/
          OP0HM005.SY1STNBR[OPASUB1] = OP0HW01.OP0HWPST; /* use it*/
        end
      end
    end
    OPAREC.OPASUB1 = OPAREC.OPASUB1 - 1;
  end







end // end OP0HSD7

// edit bulk order sizes, existan
Function OP0HSD8()




   /* this statement group checks to see that the first/last*/
   /* sizes entered for this product exist on the bulk order*/
   /* being drawn from.*/


  OP3REC.OP2KEY = OP2REC.OP2KEY;
  OP8REC.OP8TASK = "S ";

  call "DB1000" (OP8REC, OP3REC, OPBREC) {isNoRefresh = yes, isExternal = yes};

  if (OPBREC.OPBSZRC == 0)
    /* next sentence*/
  else
    TA1REC.TA1TYPE = "DB2 ";
    TA1REC.TA1FUNC = "RETN";
    TA1REC.TA1PGMNM = "OP0H    ";
    TA1REC.TA1LOCAT[1] = "S       ";
    TA1REC.TA1LOCAT[2] = "OP0HSD8 ";
    TA1REC.TA1LOCAT[3] = "DB1000  ";
    TA1REC.TA1LOCAT[4] = "        ";
    TA1REC.TA1MAP = "OP0HM005";
    TA1REC.TA1DBASE = "DORDER  ";
    TA1REC.TA1TBLVU = "VOSIZE01";
    OP0HW01.OP0HWDK1 = OP3REC.OP1PARTN;
    OP0HW01.OP0HWDK2 = OP3REC.OP1CUOID;
    OP0HW01.OP0HWDK3 = OP3REC.OP1NORID;
    OP0HW01.OP0HWDK4 = OP3REC.OP2LNINB;
    OP0HW01.OP0HWDK5 = " ";
    OP0HW01.OP0HWDK6 = " ";
    OP0HW01.OP0HWDK7 = OPBREC.OPBSZRC;
    TA1REC.TA1TBLKE = OP0HW01.OP0HWDKY;
    call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
    COMMAREA.CA-USER-WORKAREA-4K = " "; /* clear ws on error*/
    XSPF4();
    exit program;
  end




  OP0HW01.OP0HWNAS[OPASUB] = 0;
                                   /* init number of active sizes counter*/
  OP0HW01.OP0HWFSF = "N"; /* init size found flags*/
  OP0HW01.OP0HWLSF = "N";
  OPAREC.OPASUB1 = 1;

  while (OPAREC.OPASUB1 <= 40)
    if (OP3REC.OP3SZAFL[OPASUB1] == "Y") /* if size is active*/
      if (OPAREC.OPASUB1 >= OP0HW01.OP0HWFSZ
       && OPAREC.OPASUB1 <= OP0HW01.OP0HWLSZ)
        OP0HW01.OP0HWNAS[OPASUB] = OP0HW01.OP0HWNAS[OPASUB] + 1; /* inc counter*/
      end
      if (OPAREC.OPASUB1 == OP0HW01.OP0HWFSZ)
        OP0HW01.OP0HWFSF = "Y"; /* set first size found flag*/
      end
      if (OPAREC.OPASUB1 == OP0HW01.OP0HWLSZ)
        OP0HW01.OP0HWLSF = "Y"; /* set last size found flag*/
      end
    end
    OPAREC.OPASUB1 = OPAREC.OPASUB1 + 1;
  end




   /* now see if found sizes*/


  if (OP0HW01.OP0HWFSF == "N"
   || OP0HW01.OP0HWLSF == "N")
    OP0HW01.OP0HWSFL = "Y"; /* set error flags and msgs*/
    OPAREC.OPAERR = "Y";
    converseLib.validationFailed(286);
    if (OP0HW01.OP0HWLSF == "N") /* if last size not found*/
      set OP0HM005.OP0HMLSZ[OPASUB] cursor, modified, bold;
    end
    if (OP0HW01.OP0HWFSF == "N") /* if last first not found*/
      set OP0HM005.OP0HMFSZ[OPASUB] cursor, modified, bold;
    end
  end






end // end OP0HSD8

// setup size error message
Function OP0HSD9()






    /* when the user encounters some kind of size error we*/
    /* want to display a message showing the valid size*/
    /* range for the entered style. this sgrp builds this*/
    /* size range message.*/



   /* first get first and last available size*/

  OP0HSD3(); /* get first*/
  OP0HSD4(); /* get last*/



    /* test to see that there were some valid sizes*/

  if (OP0HW01.OP0HWFSZ < 1
   || OP0HW01.OP0HWLSZ > 40)
    converseLib.validationFailed(148);
    return;
  end



  if (OP0HW01.XOTSZIND == "D") /* if sizes need to be descriptive*/
    OP0HW01.OP0HWSZ4 = SY4REC.SY4IDDSC[OP0HWLSZ];
    OP0HW01.OP0HWSZ2 = SY4REC.SY4IDDSC[OP0HWFSZ];
  else
    OP0HW01.OP0HWSZ4 = OP0HW01.OP0HWLSZ;
    OP0HW01.OP0HWSZ2 = OP0HW01.OP0HWFSZ;
  end


  OP0HM005.VAGen_EZEMSG = OP0HW01.OP0HWSZM; /* move msg to map*/




end // end OP0HSD9

// edit map fields
Function OP0HSDA()
         /* this statement group edits the fields from op0hm005*/



         /* this routine drives the edits. it looks worse then*/
         /* it really is!!! The following if statements have two*/
         /* main sections. one to edit nike style numbers and the*/
         /* other to edit customer style numbers. the logic in*/
         /* these two sections is completely the same except for*/
         /* the individual style code edits. style, gpc code*/
         /* check, and sizes edits are related. all must be ok*/
         /* for a style to be accepted for entry. for this reason*/
         /* the logic won't go to the next edit unless the*/
         /* previous related edit passes.*/

         /* note: editing goes bottom up, line item by line item.*/


    /* the first thing to do before we go into the edit loop*/
    /* is to default style codes for apparel. apparel wants to*/
    /* be able to enter the style once and then just color codes*/
    /* and have the style code propogated down or defaulted.*/
    /* this routine will propogate the style numbers for apparel.*/



  if (OP1REC.XGPCD == "03") /* if apparel order*/
    OP0HSD7(); /* propogate style numbers*/
  end

  OP0HW01.OP0HWSFL = "N"; /* init style error flag*/
  OP0HW01.OP0HWMBF = "N"; /* init multi hdr blank pgm found flag*/
  OPASUB = 6;

  while (OPASUB >= 1)
    if (OP0HW01.OP0HWPF5 == "Y") /* reset any edit highlights from subs*/
      set OP0HM005.SY1STNBR[OPASUB] initialAttributes;
      set OP0HM005.SY2CLRID[OPASUB] initialAttributes;
      set OP0HM005.XDMCD[OPASUB] initialAttributes;
      set OP0HM005.OP0HMSBF[OPASUB] initialAttributes;
    end

    OP0HSDS(); /* Set up substitution fields.*/

    if (OP0HM005.SY1STNBR[OPASUB] > " ") /* if anything in field*/
      if (OP0HM005.KUIPRDID[OPASUB] is modified) /* if anything there*/
        set OP0HM005.KUIPRDID[OPASUB] initialAttributes; /* set field*/
        OP0HM005.KUIPRDID[OPASUB] = " "; /* clear field*/
      end
      if (OP0HM005.SY1STNBR[OPASUB] is modified /* if just entered*/
       || OP0HM005.SY2CLRID[OPASUB] is modified 
       || OP0HM005.XDMCD[OPASUB] is modified)  
        OP0HSDB(); /* edit nike style*/
        if (OP0HW01.OP0HWSFL == "Y") /* if error*/
          OP0HSKA(); /* reset mdt's*/
        else
          OP0HSDP(); /* misc nike style edit (mult)*/
        end
      else /* style ok, edit rest*/
        OP0HW01.SY1STNBR = OP0HM005.SY1STNBR[OPASUB];
        OP0HW01.SY2CLRID = OP0HM005.SY2CLRID[OPASUB];
        OP0HW01.XDMCD = OP0HM005.XDMCD[OPASUB];
        OP0HSDR(); /* edit sz, uom, pkg, etc.*/
      end
    else /* edit cust style*/
      if (OP0HM005.KUIPRDID[OPASUB] > " ") /* if cust stle entered*/
        if (OP0HM005.SY1STNBR[OPASUB] is modified
         || OP0HM005.SY2CLRID[OPASUB] is modified
         || OP0HM005.XDMCD[OPASUB] is modified)
          OP0HM005.SY1STNBR[OPASUB] = " ";
          OP0HM005.SY2CLRID[OPASUB] = " ";
          OP0HM005.XDMCD[OPASUB] = " ";
          set OP0HM005.SY1STNBR[OPASUB] initialAttributes;
          set OP0HM005.SY2CLRID[OPASUB] initialAttributes;
          set OP0HM005.XDMCD[OPASUB] initialAttributes;
        end
        if (OP0HM005.KUIPRDID[OPASUB] is modified) /* if just touched*/
          OP0HSDC(); /* edit cust style*/
          if (OP0HW01.OP0HWSFL == "Y") /* if error*/
            OP0HSKA(); /* reset mdt's*/
          else
            OP0HSDQ(); /* misc cust style edit (mult)*/
          end
        else /* style ok, edit rest*/
          OP0HW01.SY1STNBR = OPWREC.SY1STNBR[OPASUB];
          OP0HW01.SY2CLRID = OPWREC.SY2CLRID[OPASUB];
          OP0HW01.XDMCD = OPWREC.XDMCD[OPASUB];
          OP0HSDR(); /* edit size, uom, pkg, etc.*/
        end
      else
        OPWREC.SY1STNBR[OPASUB] = " ";
                                   /* clear style, user cleared it*/
      end
    end
    OPASUB = OPASUB - 1;
    OP0HW01.OP0HWSFL = "N"; /* reset style error flag*/
  end




  VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
  VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
  sysLib.commit();
  VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
   /* release data base resources*/






end // end OP0HSDA

// edit nike style/color
Function OP0HSDB()



        /* edit nike style/color*/





  OP0HW01.SY1STNBR = OP0HM005.SY1STNBR[OPASUB];
  OP0HW01.SY2CLRID = OP0HM005.SY2CLRID[OPASUB];
  OP0HW01.XDMCD = OP0HM005.XDMCD[OPASUB];


  OP0HSD1(); /* read nike style/color record*/

   /* TT#4654  SPAIN CHANGES  Begin **************/

  if (OP0HW01.OP0HW-PRODUCT-INV-FLAG == "Y") /* invalid product for spai*/
    OPAREC.OPAERR = "Y"; /* set error flag*/
    OP0HW01.OP0HWSFL = "Y"; /* style restricted*/
    set OP0HM005.SY1STNBR[OPASUB] cursor, modified, bold;
    set OP0HM005.SY2CLRID[OPASUB] modified, bold;
    set OP0HM005.XDMCD[OPASUB] modified, bold;
    return;
  end

  if (OP0HW01.OP0HW-PROD-DLOCK-FLAG == "Y")
    OPAREC.OPAERR = "Y";
    OP0HW01.OP0HWSFL = "Y";
    set OP0HM005.SY1STNBR[OPASUB] cursor, modified, bold;
    set OP0HM005.SY2CLRID[OPASUB] modified, bold;
    set OP0HM005.XDMCD[OPASUB] modified, bold;
    return;
  end


   /* TT#4654  SPAIN CHANGES  End   **************/
  if (SQLCA.VAGen_SQLCODE == 0)
    if (OP0HW01.OP0HWBBD != " ") /* blank/finished bulk draw*/
      OP0HSDD(); /* edit finished style*/
    end
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      OPAREC.OPAERR = "Y";
      OP0HW01.OP0HWSFL = "Y";
      set OP0HM005.SY1STNBR[OPASUB] cursor, modified, bold;
      set OP0HM005.SY2CLRID[OPASUB] modified, bold;
      set OP0HM005.XDMCD[OPASUB] modified, bold;
      return;
    end
  end


   /* -----------------------------------------------------------*/
    /* Make sure that product has the same brand as the order.*/
   /* -----------------------------------------------------------*/
  if (SYCREC.XBCCD != OP1REC.XBCCD)
    OPAREC.OPAERR = "Y";
    OP0HW01.OP0HWSFL = "Y";
    converseLib.validationFailed(586); /* Brand of product does not match*/
    set OP0HM005.SY1STNBR[OPASUB] cursor, modified, bold;
    set OP0HM005.SY2CLRID[OPASUB] modified, bold;
    set OP0HM005.XDMCD[OPASUB] modified, bold;
    return;
  end


   /* ----------------------------------------------------------*/
   /* equipment check*/
   /* ----------------------------------------------------------*/

  OP0HS-CHECK-EQMT(); /* call to eu0100*/
  if (WEU0100.WEU0100-EQUIP-PROD-FL == "Y")
    OPWREC01.XPCCK = WEU0100.XPCCD;
  else
    OPWREC01.XPCCK = "  ";
  end


  OPWREC01.XOTCK = "N";
  OP0HW01.OP0HWFND = "N";

   /* **********TCS INCLUDE BEGIN***********/

  set VXVO0001 empty;
  set SQLCA empty;
  VXVO0001.XOBCD = OP1REC.XOBCD; /* valid base order type*/
  VXVO0001.XGPCD = OP1REC.XGPCD; /* valid gpc code*/
  VXVO0001.XSOCD = OP1REC.XSOCD; /* valid salesoffice code*/
  VXVO0001.XDVCD = OP1REC.XDVCD; /* valid division code*/
  VXVO0001.XBCCD = OP1REC.XBCCD; /* valid brand code*/
  VXVO0001.XPC-PROD-CAT-CD = OPWREC01.XPCCK; /* category code*/
  VXVO0001.XXXSTAT = "A"; /* valid active status code*/

  call "VXVO0001" ("S4", SQLCA, VXVO0001) {isNoRefresh = yes, isExternal = yes}; /* open cursor*/

  if (SQLCA.VAGen_SQLCODE != 0) /* invalid cursor open*/
    TA1REC.TA1DBASE = "DCORP";
    TA1REC.TA1TBLVU = "VXVO0001";
    TA1REC.TA1TBLKE = VXVO0001-KEY;
    TA1REC.TA1LOCAT[3] = "OP0HSDB";
    TA1REC.TA1LOCAT[4] = "VXVO0001";
    XSOPS02();
  else
    call "VXVO0001" ("N4", SQLCA, VXVO0001) {isNoRefresh = yes, isExternal = yes};

    if (SQLCA.VAGen_SQLCODE == 0)
      if (VXVO0001.XOTCD != OP1REC.XOTCD)
        OPWREC01.XOTCK = "Y";
      end
      OP0HW01.OP0HWFND = "Y"; /* reset flag*/
    else
      if (SQLCA.VAGen_SQLCODE == +100)
          /* next sentence*/
      else
        TA1REC.TA1DBASE = "DCORP";
        TA1REC.TA1TBLVU = "VXVO0001";
        TA1REC.TA1TBLKE = VXVO0001-KEY;
        TA1REC.TA1LOCAT[3] = "OP0HSDB";
        TA1REC.TA1LOCAT[4] = "VXVO0001";
        XSOPS02();
      end
    end
  end
  call "VXVO0001" ("C4", SQLCA, VXVO0001) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE != 0)
    TA1REC.TA1DBASE = "DCORP";
    TA1REC.TA1TBLVU = "VXVO0001";
    TA1REC.TA1TBLKE = VXVO0001-KEY;
    TA1REC.TA1LOCAT[3] = "OP0HSDB";
    TA1REC.TA1LOCAT[4] = "VXVO0001";
    XSOPS02();
  end

   /* ********** TCS INCLUDE END ***********/

  if (OP0HW01.OP0HWFND == "N")
    if (OPWREC01.XPCCK > "  ")
      converseLib.validationFailed(923); /* prod cat/ot not valid so, etc*/
      OPAREC.OPAERR = "Y";
      OP0HW01.OP0HWSFL = "Y";
      return;
    else
      converseLib.validationFailed(482); /* Invalid system order type*/
      OPAREC.OPAERR = "Y";
      OP0HW01.OP0HWSFL = "Y";
      return;
    end
  end

  if (OPWREC01.XOTCK == "Y")
    converseLib.validationFailed(939); /* prod not valid for order type*/
    OPAREC.OPAERR = "Y";
    OP0HW01.OP0HWSFL = "Y";
    return;
  end
        /* check if cust has own style numbers. if so go*/
        /* get number.*/

  if (KUCREC.CU-PRT-XREF-FL == "Y") /* print xref flag is turned on*/
    if (OPWREC.KUCSKIND == "C" /* if indicator populated*/
     || OPWREC.KUCSKIND == "T" 
     || OPWREC.KUCSKIND == "P" 
     || OPWREC.KUCSKIND == "R" 
     || OPWREC.KUCSKIND == "G")

      /* *************/
      set WCU1710 empty;

      WCU1710.WCU1710-INQUIRY-OPTION = 2; /* xref info w/ovrds*/
      WCU1710-IN-CU-CO-ID = OP1REC.KUCCOID;
      WCU1710-XNX-DEPT-ID-XREF = OP1REC.XNXCD; /* move dept cd*/
      WCU1710-IN-XGP-GPC-CD = SYCREC.XGPCD;
      WCU1710-IN-SY-STY-NBR = OP0HM005.SY1STNBR[OPASUB];
      WCU1710-IN-SY-COLR-CD-ID = OP0HM005.SY2CLRID[OPASUB];
      WCU1710-IN-XDM-DIM-CD = OP0HM005.XDMCD[OPASUB];
      WCU1710-IN-XQA-QUAL-CD = OP0HM005.XQACD[OPASUB];

      WCU1710-RETURN-CODE = 99;

      call "CU1710" (WCU1710) {isNoRefresh = yes, isExternal = yes}; /* i/o mod-select scan*/

      /* check db2 return code*/

      if (WCU1710.WCU1710-RETURN-CODE == 0)
        OPWREC.KUIPRDID[OPASUB] = WCU1710.CU-CUST-PROD-ID[1];
        OP0HM005.KUIPRDID[OPASUB] = WCU1710.CU-CUST-PROD-ID[1];
      else
        if (WCU1710.WCU1710-RETURN-CODE == 1) /* check for not found*/
          OPWREC.KUIPRDID[OPASUB] = " ";
        else
          TA1REC.TA1LOCAT[1] = "CU1710  "; /* i/o mod name*/
          TA1REC.TA1LOCAT[2] = "OP0HSDB "; /* statement group*/
          TA1REC.TA1LOCAT[3] = "        ";
          TA1REC.TA1LOCAT[4] = "        ";
          TAEREC.TAEDESC1 = "BAD RETURN FROM CU1710 - RETURN CODE=";
          TAEREC.TAEDESC2 = WCU1710.WCU1710-RETURN-CODE;
          TA1REC.TA1TYPE = "APPL"; /* abend type*/
          TA1REC.TA1FUNC = "RETN"; /* abend func*/
          VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
          VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
          sysLib.rollback();
          VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
           /* synpoint rollback*/
          try
            call "TA0020" (TA1REC, TAEREC) {isExternal = yes};
          end /* abend module*/
          COMMAREA.CA-USER-WORKAREA-4K = " "; /* clear user commarea*/
          XSPF4(); /* master menu*/
          exit program;
        end
      end
    end
  end

  OP0HSLB(); /* check if style restricted from sales*/
                                   /* office*/

  if (OP0HW01.OP0HWSFL == "Y") /* style restricted*/
    set OP0HM005.SY1STNBR[OPASUB] cursor, modified, bold;
    set OP0HM005.SY2CLRID[OPASUB] modified, bold;
    set OP0HM005.XDMCD[OPASUB] modified, bold;
    return;
  end

          /* life cycle code check*/

  if (OP0HW01.OP0HWBDF == "C" /* if customer draw*/
   || OP0HW01.OP0HWBDF == "R") /* or rebook draw skip life cycle edit*/
     /* next sentence*/
  else
    OP0HSD2();
  end


  if (OP0HW01.OP0HWSFL == "Y") /* bad life cycle code*/
    set OP0HM005.SY1STNBR[OPASUB] cursor, modified, bold;
    set OP0HM005.SY2CLRID[OPASUB] modified, bold;
    set OP0HM005.XDMCD[OPASUB] modified, bold;
    return;
  end

   /* if this is a blank bulk order*/
    /* use io5480 to get the owner group from davail.vblnkp01*/
      /* lidate the blank style with io5470 (davail.vblnks01)*/

  if (OP1REC.XBDCD == "B")
    if (OP0HW01.OP0HWMBF == "Y")
      OP0HSDN(); /* validate blank style against*/
                                   /* davail.dblnks01 via io5470*/
    else
      OP0HSDM(); /* get xowcd from davail.vblnkp01 via*/
                                   /* io5480*/
      if (OP0HW01.OP0HWSFL == "Y") /* style error flag*/
        /* NEXT SENTENCE*/
      else
        OP0HSDN();
      end
    end
  end

  if (OP0HW01.OP0HWSFL == "Y")
    OPAREC.OPAERR = "Y";
    set OP0HM005.SY1STNBR[OPASUB] cursor, modified, bold;
    set OP0HM005.SY2CLRID[OPASUB] modified, bold;
    set OP0HM005.XDMCD[OPASUB] modified, bold;
    return;
  end

   /* if not a draw order, edits are complete, exit.*/

  if (OP0HW01.OP0HWBDF != "C"
   && OP0HW01.OP0HWBDF != "R"
   && OP0HW01.OP0HWBDF != "S"
   && OP0HW01.OP0HWBDF != "X")
    OPWREC.XDMCD[OPASUB] = OP0HM005.XDMCD[OPASUB];
    OPWREC.SY1STNBR[OPASUB] = OP0HM005.SY1STNBR[OPASUB];
    OPWREC.SY2CLRID[OPASUB] = OP0HM005.SY2CLRID[OPASUB];
    return;
  end

   /* need to see that product exists on bulk order.*/

  OP0HSE2(); /* read bulk order item record*/

  if (OP0HW01.OP0HWFND == "Y") /* if found the style*/
    OPWREC.OPWBKLIN[OPASUB] = OP2REC.OP2LNINB;
    OPWREC.OP1NORID[OPASUB] = OP2REC.OP1NORID;
    OP0HW01.OP2TONOQ[OPASUB] = OP2REC.OP2TONOQ; /* save qty for edit*/
    OP0HW01.OP2TOHRQ[OPASUB] = OP2REC.OP2TOHRQ;
    OPWREC.SY1STNBR[OPASUB] = OP0HM005.SY1STNBR[OPASUB];
    OPWREC.SY2CLRID[OPASUB] = OP0HM005.SY2CLRID[OPASUB];
    OPWREC.XDMCD[OPASUB] = OP0HM005.XDMCD[OPASUB];
    if (OP0HM005.XPGCD[OPASUB] == OP2REC.XPGCD)
      OPWREC.XPGCD[OPASUB] = OP0HM005.XPGCD[OPASUB];
    else
      OPWREC.XPGCD[OPASUB] = OP2REC.XPGCD;
      OP0HM005.XPGCD[OPASUB] = OP2REC.XPGCD;
      converseLib.validationFailed(326);
      set OP0HM005.SY1STNBR[OPASUB] cursor, modified, bold;
      set OP0HM005.SY2CLRID[OPASUB] modified, bold;
      set OP0HM005.XDMCD[OPASUB] modified, bold;
    end
    if (OP0HM005.PC2INSEG[OPASUB] == OP2REC.PC2INSEG)
      OPWREC.PC2INSEG[OPASUB] = OP0HM005.PC2INSEG[OPASUB];
    else
      OPWREC.PC2INSEG[OPASUB] = OP2REC.PC2INSEG;
      OP0HM005.PC2INSEG[OPASUB] = OP2REC.PC2INSEG;
      converseLib.validationFailed(972); /* size out of range*/
      set OP0HM005.SY1STNBR[OPASUB] cursor, modified, bold;
      set OP0HM005.SY2CLRID[OPASUB] modified, bold;
      set OP0HM005.XDMCD[OPASUB] modified, bold;
    end
  else
    OP0HW01.OP0HWSFL = "Y";
    OPAREC.OPAERR = "Y";
    converseLib.validationFailed(285);
    set OP0HM005.SY1STNBR[OPASUB] cursor, modified, bold;
    set OP0HM005.SY2CLRID[OPASUB] modified, bold;
    set OP0HM005.XDMCD[OPASUB] modified, bold;
    return;
  end


end // end OP0HSDB

// edit customer style
Function OP0HSDC()
           /* edit customer style number*/

    /* read customer style record*/

  set WCU1710 empty;

  WCU1710.WCU1710-INQUIRY-OPTION = 2; /* xref info w/ovrds*/
  WCU1710-IN-CU-CO-ID = OP1REC.KUCCOID; /**/
  WCU1710-XNX-DEPT-ID-XREF = OP1REC.XNXCD; /* move dept code*/
  WCU1710.WCU1710-IN-CU-CUST-PROD-ID = OP0HM005.KUIPRDID[OPASUB];
  WCU1710.WCU1710-IN-CU-PROD-SZ-ID = " ";

  WCU1710-RETURN-CODE = 99;

  call "CU1710" (WCU1710) {isNoRefresh = yes, isExternal = yes}; /* i/o mod-select scan*/

   /* check CU1710 return code*/

  if (WCU1710.WCU1710-RETURN-CODE == 0)
    /* continue*/
  else
    if (WCU1710.WCU1710-RETURN-CODE == 1 /* check for not found*/
     || WCU1710.WCU1710-RETURN-CODE == 9) /* or not xref customer*/
      converseLib.validationFailed(133);
      OPAREC.OPAERR = "Y";
      OP0HW01.OP0HWSFL = "Y";
      set OP0HM005.KUIPRDID[OPASUB] cursor, modified, bold;
      return;
    else
      TA1REC.TA1LOCAT[1] = "CU1710  "; /* i/o mod name*/
      TA1REC.TA1LOCAT[2] = "OP0HSDC "; /* statement group*/
      TA1REC.TA1LOCAT[3] = "        ";
      TA1REC.TA1LOCAT[4] = "        ";
      TAEREC.TAEDESC1 = "BAD RETURN FROM CU1710 - RETURN CODE=";
      TAEREC.TAEDESC2 = WCU1710.WCU1710-RETURN-CODE;
      TA1REC.TA1TYPE = "APPL"; /* abend type*/
      TA1REC.TA1FUNC = "RETN"; /* abend func*/
      VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
      VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
      sysLib.rollback();
      VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
       /* synpoint rollback*/
      try
        call "TA0020" (TA1REC, TAEREC) {isExternal = yes};
      end /* abend module*/
      COMMAREA.CA-USER-WORKAREA-4K = " "; /* clear user commarea*/
      XSPF4(); /* master menu*/
      exit program;
    end
  end

      /* read nike style record, check existance*/

  OP0HW01.SY1STNBR = WCU1710.SY-STY-NBR[1];
  OP0HM005.SY1STNBR[OPASUB] = WCU1710.SY-STY-NBR[1];
  OP0HW01.SY2CLRID = WCU1710.SY-COLR-CD-ID[1];
  OP0HM005.SY2CLRID[OPASUB] = WCU1710.SY-COLR-CD-ID[1];
  OP0HW01.XDMCD = WCU1710.XDM-DIM-CD[1];
  OP0HM005.XDMCD[OPASUB] = WCU1710.XDM-DIM-CD[1];

  OP0HSD1(); /* read nike style/color record*/

  if (SQLCA.VAGen_SQLCODE == 0)
    if (OP0HW01.OP0HWBBD != " ") /* blank/finished draw*/
      OP0HSDD(); /* edit finished style*/
    end
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      converseLib.validationFailed(133);
      OPAREC.OPAERR = "Y";
      OP0HW01.OP0HWSFL = "Y";
      OP0HM005.SY1STNBR[OPASUB] = " ";
      OP0HM005.SY2CLRID[OPASUB] = " ";
      OP0HM005.XDMCD[OPASUB] = " ";
      set OP0HM005.KUIPRDID[OPASUB] cursor, modified, bold;
      return;
    end
  end

   /* -----------------------------------------------------------*/
    /* Make sure that product has the same brand as the order.*/
   /* -----------------------------------------------------------*/
  if (SYCREC.XBCCD != OP1REC.XBCCD)
    OPAREC.OPAERR = "Y";
    OP0HW01.OP0HWSFL = "Y";
    converseLib.validationFailed(586); /* Brand of product does not match*/
    OP0HM005.SY1STNBR[OPASUB] = " ";
    OP0HM005.SY2CLRID[OPASUB] = " ";
    OP0HM005.XDMCD[OPASUB] = " ";
    set OP0HM005.KUIPRDID[OPASUB] cursor, modified, bold;
    return;
  end

    /* check customer style gpc to order gpc*/

  if (OP1REC.XGPCD != WCU1710.XGP-GPC-CD[1])
    converseLib.validationFailed(134);
    OPAREC.OPAERR = "Y";
    OP0HW01.OP0HWSFL = "Y";
    return;
  end

      /* check life cycle code for cust style*/
      /* don't check if order is a customer draw order*/

  if (OP0HW01.OP0HWBDF == "C" /* cust draw*/
   || OP0HW01.OP0HWBDF == "R") /* or rebook draw, skip lifecycle edit*/
     /* next sentence*/
  else
    OP0HSD2();
  end

  if (OP0HW01.OP0HWSFL == "Y") /* bad life cycle code*/
    OP0HM005.SY1STNBR[OPASUB] = " ";
    OP0HM005.SY2CLRID[OPASUB] = " ";
    OP0HM005.XDMCD[OPASUB] = " ";
    set OP0HM005.KUIPRDID[OPASUB] cursor, modified, bold;
    return;
  end

   /* if this is a blank bulk order*/
     /* use io5480 to get the owner group from davail.vblnkp01*/
     /* validate the blank styles with io5470 (davail.vblnks01)*/

  if (OP1REC.XBDCD == "B") /* if blank bulk order*/
    if (OP0HW01.OP0HWMBF == "Y") /* if vavail.vblnkp01 already found*/
      OP0HSDN(); /* validate blank style against*/
                                   /* davail.vblnks01 via io5470*/
    else
      OP0HSDM(); /* get xowcd from davail.vblnkp01 via*/
                                   /* io5480*/
      if (OP0HW01.OP0HWSFL == "Y") /* style error flag*/
         /* next sentence*/
      else
        OP0HSDN(); /* validate the blank styles*/
      end
    end
  end

  if (OP0HW01.OP0HWSFL == "Y")
    OPAREC.OPAERR = "Y";
    set OP0HM005.SY1STNBR[OPASUB] cursor, modified, bold;
    set OP0HM005.SY2CLRID[OPASUB] modified, bold;
    set OP0HM005.XDMCD[OPASUB] modified, bold;
    return;
  end

   /* if not a draw order, edits are complete, exit.*/

  if (OP0HW01.OP0HWBDF != "C"
   && OP0HW01.OP0HWBDF != "R"
   && OP0HW01.OP0HWBDF != "S"
   && OP0HW01.OP0HWBDF != "X")
    OPWREC.XDMCD[OPASUB] = SYCREC.XDMCD;
    OPWREC.SY1STNBR[OPASUB] = SYCREC.SY1STNBR;
    OPWREC.SY2CLRID[OPASUB] = SYCREC.SY2CLRID;
    OPWREC.KUIPRDID[OPASUB] = OP0HM005.KUIPRDID[OPASUB];
    return;
  end

   /* need to see that product exists on bulk order.*/

  OP0HSE2(); /* read bulk order item record.*/

  if (OP0HW01.OP0HWFND == "Y") /* if found the style*/
    OPWREC.OPWBKLIN[OPASUB] = OP2REC.OP2LNINB;
    OPWREC.OP1NORID[OPASUB] = OP2REC.OP1NORID;
    OP0HW01.OP2TONOQ[OPASUB] = OP2REC.OP2TONOQ; /* save for edits*/
    OP0HW01.OP2TOHRQ[OPASUB] = OP2REC.OP2TOHRQ;
    OPWREC.SY1STNBR[OPASUB] = SYCREC.SY1STNBR;
    OPWREC.SY2CLRID[OPASUB] = SYCREC.SY2CLRID;
    OPWREC.XDMCD[OPASUB] = SYCREC.XDMCD;
    OPWREC.KUIPRDID[OPASUB] = OP0HM005.KUIPRDID[OPASUB];
  else
    OP0HW01.OP0HWSFL = "Y";
    OPAREC.OPAERR = "Y";
    converseLib.validationFailed(285);
    OP0HM005.SY1STNBR[OPASUB] = " ";
    OP0HM005.SY2CLRID[OPASUB] = " ";
    OP0HM005.XDMCD[OPASUB] = " ";
    set OP0HM005.KUIPRDID[OPASUB] cursor, modified, bold;
    return;
  end


end // end OP0HSDC

// edit finished style
Function OP0HSDD()

  set SQLCA empty;
  set AVHREC empty;

  AVHREC.XOWCD = OPWREC.XOWCD;
  AVHREC.SY1STNBR = OP0HM005.SY1STNBR[OPASUB];
  AVHREC.SY2CLRID = OP0HM005.SY2CLRID[OPASUB];
  AVHREC.XDMCD = OP0HM005.XDMCD[OPASUB];

  call "IO5470" ("S ", SQLCA, AVHREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
     /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      converseLib.validationFailed(629);
      OP0HW01.OP0HWSFL = "Y";
      OPAREC.OPAERR = "Y";
      set OP0HM005.SY1STNBR[OPASUB] cursor, modified, bold;
    else
      TA1REC.TA1TYPE = "DB2 ";
      TA1REC.TA1PGMNM = "OP0H   "; /* application*/
      TA1REC.TA1LOCAT[1] = "OP0HSDD "; /* statement group*/
      TA1REC.TA1LOCAT[2] = "IO5470  "; /* io mod called*/
      TA1REC.TA1LOCAT[3] = "S "; /* function code used*/
      TA1REC.TA1LOCAT[4] = AVHREC.AVHKEY; /* avhrec key*/
      TA1REC.TA1MAP = "OP0HM005"; /* map*/
      TA1REC.TA1DBASE = "DAVAIL"; /* database name*/
      TA1REC.TA1TBLVU = "VBLNKS01"; /* table view*/
      TA1REC.TA1TBLKE = AVHREC.AVHKEY; /* key*/
      VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
      VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
      sysLib.rollback();
      VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
      
      call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
      XSPF4();
    end
  end

   /* ************************************************************/
end // end OP0HSDD

// edit first/last size
Function OP0HSDE()
         /* multiple product header screen*/

         /* this sgrp edits the first and last sizes from the*/
         /* multiple product header screen. the front end does*/
         /* some checking and defaulting before we get into*/
         /* the actual edits.*/

         /* front end:   1. if dup flag not 'y' or 'n'*/
                            /* error, exit.*/
                      /* 2. if sizes required and no sizes*/
                            /* ERROR, EXIT.*/
                      /* 3. if dup flag set to yes*/
                            /* set duplicates*/
                      /* 4. if any sizes missing*/
                            /* default sizes*/

         /* size edits:  1. edit entered map size for format*/
                      /* 2. check size division codes*/
                      /* 3. see if size division match allowable*/
                          /* division codes from ordr typ table.*/
                      /* 4. check size fringe/gut indicators*/
                      /* 5. first size cant be greater then last*/
                      /* 6. for draw orders, first/last sizes*/
                         /* must be on the bulk order drawn from.*/


       /* note: mdt use for the sizes is not complete. i don't*/
             /* reset them for converses. one reason is, when*/
             /* this sgrp is invoked, both sizes are edited no*/
             /* matter if only one was entered or touched.*/
             /* the other reason is, i always invoke this sgrp*/
             /* if sizes were touched or if no defaults have*/
             /* been placed into the ws product array yet.*/





    /* first check if dup flag is valid*/

  if (OP0HM005.OP0HMDSZ[OPASUB] == "N"
   || OP0HM005.OP0HMDSZ[OPASUB] == "Y")
     /* next sentence*/
  else
    set OP0HM005.OP0HMDSZ[OPASUB] cursor, modified, bold;
    OPAREC.OPAERR = "Y";
    OP0HW01.OP0HWSFL = "Y";
    converseLib.validationFailed(140);
    return;
  end







    /* next check if sizes are required.*/
          /* if so make sure either they were entered*/
           /* or that the duplicate sizes flag was set to 'y'*/
             /* if nothing entered but are required -- error*/
             /* else go on with edit*/
          /* else go on with edit.*/


  if (OP1REC.XOTCD in XOTTBL.XOTCD)
    if (XOTTBL.XOTSZVER[sysVar.arrayIndex] == "Y" /* if sizes required*/
     || OP0HW01.OP0HWBDF == "C"                   
     /* ; sizes also req for draw orders*/
     || OP0HW01.OP0HWBDF == "R"                   
     || OP0HW01.OP0HWBDF == "S"                   
     || OP0HW01.OP0HWBDF == "X")                 
      if (OP0HM005.OP0HMDSZ[OPASUB] == "Y") /* if dup sizes*/
         /* next sentence                  ; ok -- go on*/
      else
        if (OP0HM005.OP0HMFSZ[OPASUB] > " "
         && OP0HM005.OP0HMLSZ[OPASUB] > " ")
           /* next sentence*/
        else
          converseLib.validationFailed(146); /* required fields msg*/
          OPAREC.OPAERR = "Y"; /* set error flag*/
          OP0HW01.OP0HWSFL = "Y";
          set OP0HM005.OP0HMFSZ[OPASUB] cursor, modified, bold;
          set OP0HM005.OP0HMLSZ[OPASUB] modified, bold;
          set OP0HM005.OP0HMDSZ[OPASUB] modified, bold;
          return;
        end
      end
    end
  end







   /* see if dup flag on, if so try to dup f/l sizes*/
      /* the logic goes as follows:*/
        /* 1. we do edits bottom up so search back thru*/
           /* the previous styles on the map trying so find*/
           /* some entered sizes to duplicate. if so use them.*/
        /* 2. if don't find any, try to dup sizes from last*/
           /* set of products entered. if none to dup msg*/
           /* else use the sizes found.*/






  OPAREC.OPASUB1 = 0;

  if (OP0HM005.OP0HMDSZ[OPASUB] == "Y"
   && OP0HM005.OP0HMDSZ[OPASUB] is modified) /* and was just set to dup*/
    OPAREC.OPASUB1 = OPAREC.OPASUB;
    OPAREC.OPASUB1 = OPAREC.OPASUB1 - 1;
    while (OPAREC.OPASUB1 >= 1)
      if (OP0HM005.OP0HMFSZ[OPASUB1] > " "
       && OP0HM005.OP0HMLSZ[OPASUB1] > " ")
        OP0HM005.OP0HMFSZ[OPASUB] = OP0HM005.OP0HMFSZ[OPASUB1];
        OP0HM005.OP0HMLSZ[OPASUB] = OP0HM005.OP0HMLSZ[OPASUB1];
        OP0HM005.OP2TORGQ[OPASUB] = OP0HM005.OP2TORGQ[OPASUB1];
        OPAREC.OPASUB1 = -9;
      else
        OPAREC.OPASUB1 = OPAREC.OPASUB1 - 1;
      end
    end
  end





  if (OPAREC.OPASUB1 == -9 /* if match found*/
   || OP0HM005.OP0HMDSZ[OPASUB] == "N") /* or no need to dup*/
     /* next sentence*/
  else
    if (OP0HM005.OP0HMDSZ[OPASUB] is modified /* if dup just asked for*/
     && OP0HM005.OP0HMDSZ[OPASUB] == "Y")    
      if (OP0HW01.OP0HWPSD == "Y") /* if szs from prev map*/
        OP0HM005.OP2TORGQ[OPASUB] = OP0HW01.OP2TORGQ;
        if (OP0HW01.XOTSZIND == "I") /* if need integer sizes*/
          OP0HM005.OP0HMFSZ[OPASUB] = OP0HW01.OP0HWFDI; /* int size*/
          OP0HM005.OP0HMLSZ[OPASUB] = OP0HW01.OP0HWLDI;
        else
          OP0HM005.OP0HMFSZ[OPASUB] = OP0HW01.OP0HWFDD; /* desc size*/
          OP0HM005.OP0HMLSZ[OPASUB] = OP0HW01.OP0HWLDD;
        end
      else /* no sizes to dup error*/
        set OP0HM005.OP0HMDSZ[OPASUB] cursor, modified, bold;
        OPAREC.OPAERR = "Y";
        OP0HW01.OP0HWSFL = "Y";
        converseLib.validationFailed(147);
        return;
      end
    else
      OP0HM005.OP0HMDSZ[OPASUB] = "N";
                                   /* if change size, set dup flg off*/
    end
  end


  OPWREC.OPWDUPSZ[OPASUB] = OP0HM005.OP0HMDSZ[OPASUB]; /* save dup flag*/





   /* check if descriptive sizes, if so read the size scale*/
   /* record for later use.*/



  if (OP0HW01.XOTSZIND == "D") /* if descriptive sizes*/
    SY4REC.SY4SZSCL = SYCREC.SY4SZSCL;
    call "IO0040" ("S ", SQLCA, SY4REC) {isNoRefresh = yes, isExternal = yes};
    if (SQLCA.VAGen_SQLCODE == 0)
       /* next sentence*/
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence              *************************/
      else
        TA1REC.TA1TYPE = "DB2 ";
        TA1REC.TA1FUNC = "RETN";
        TA1REC.TA1PGMNM = "OP0H    ";
        TA1REC.TA1LOCAT[1] = "S       ";
        TA1REC.TA1LOCAT[2] = "OP0HSDE ";
        TA1REC.TA1LOCAT[3] = "IO0040  ";
        TA1REC.TA1LOCAT[4] = "        ";
        TA1REC.TA1MAP = "OP0HM005";
        TA1REC.TA1DBASE = "SY4REC  ";
        TA1REC.TA1TBLVU = "VSCALE01";
        TA1REC.TA1TBLKE = SY4REC.SY4SZSCL;
        call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes};
        COMMAREA.CAUSERA = " "; /* on error, clear ws*/
        XSPF4();
        exit program;
      end
    end
  end






   /* next check whether both sizes are entered.*/
       /* if not default the missing one.*/



  if (OP0HM005.OP0HMFSZ[OPASUB] > " ")
    if (OP0HM005.OP0HMLSZ[OPASUB] > " ")
       /* next sentence*/
    else
      OP0HSD4(); /* default last size*/
      if (OPAREC.OPAERR == "N") /* if no error*/
        if (OP0HW01.XOTSZIND == "D") /* if need desc sizes*/
          OP0HM005.OP0HMLSZ[OPASUB] = SY4REC.SY4IDDSC[OP0HWLSZ];
        else
          OP0HM005.OP0HMLSZ[OPASUB] = OP0HW01.OP0HWLSZ;
        end
      end
    end
  else
    if (OP0HM005.OP0HMLSZ[OPASUB] > " ")
      OP0HSD3(); /* default first size*/
      if (OPAREC.OPAERR == "N") /* if no error*/
        if (OP0HW01.XOTSZIND == "D") /* if need desc sizes*/
          OP0HM005.OP0HMFSZ[OPASUB] = SY4REC.SY4IDDSC[OP0HWFSZ];
        else
          OP0HM005.OP0HMFSZ[OPASUB] = OP0HW01.OP0HWFSZ;
        end
      end
    else
      OP0HSD3(); /* default both*/
      OP0HSD4();
      if (OP0HW01.OP0HWSFL == "N") /* if no error*/
        if (OP0HW01.XOTSZIND == "D") /* if need desc sizes*/
          OP0HM005.OP0HMFSZ[OPASUB] = SY4REC.SY4IDDSC[OP0HWFSZ];
          OP0HM005.OP0HMLSZ[OPASUB] = SY4REC.SY4IDDSC[OP0HWLSZ];
        else
          OP0HM005.OP0HMFSZ[OPASUB] = OP0HW01.OP0HWFSZ;
          OP0HM005.OP0HMLSZ[OPASUB] = OP0HW01.OP0HWLSZ;
        end
      end
    end
  end


  if (OP0HW01.OP0HWSFL == "Y") /* if error*/
    return;
  end






   /* now start edits on the sizes themselves*/
    /* as these edits progress, you can only*/
    /* go to the next edit if the previous one was good.*/





    /* size edit number 1*/
       /* based on the size input formats, verify sizes*/


  if (OP0HW01.XOTSZIND == "I")
    OP0HSD5(); /* edit numeric sizes*/
  else
    OP0HSD6(); /* edit alpha sizes*/
  end


  if (OP0HW01.OP0HWSFL == "Y") /* if error*/
    OP0HSD9(); /* setup size error message*/
    return;
  end




   /* size edit number 2*/
        /* check size division code for both first and last*/


  if (SYCREC.XDVCD[OP0HWLSZ] == " ")
    OPAREC.OPAERR = "Y";
    OP0HW01.OP0HWSFL = "Y";
    set OP0HM005.OP0HMLSZ[OPASUB] cursor, modified, bold;
  end


  if (SYCREC.XDVCD[OP0HWFSZ] == " ")
    OPAREC.OPAERR = "Y";
    OP0HW01.OP0HWSFL = "Y";
    set OP0HM005.OP0HMFSZ[OPASUB] cursor, modified, bold;
  end


  if (OP0HW01.OP0HWSFL == "Y") /* if error*/
    OP0HSD9(); /* setup size error message*/
    return;
  end





    /* edit check number 3*/
      /* match style div to allowed divs for order type*/
      /* for both first and last sizes.*/

    /* first make sure that the xottbl.allowed/disallowed*/
    /* division code = a or d.*/

  if (OP1REC.XOTCD in XOTTBL.XOTCD)
    if (XOTTBL.XOTALWDV[sysVar.arrayIndex] == "A"
     || XOTTBL.XOTALWDV[sysVar.arrayIndex] == "D")
       /* next sentence--ok good values, keep going*/
    else
      OPAREC.OPAERR = "Y";
      OP0HW01.OP0HWSFL = "Y";
      set OP0HM005.OP0HMLSZ[OPASUB] cursor, modified, bold;
      set OP0HM005.OP0HMFSZ[OPASUB] cursor, modified, bold;
      OP0HSD9(); /* setup size error message*/
      return;
    end
  end


   /* ----------------------------------------------------*/
         /* last-size check*/
   /* if flag = a (allowed) and the product division equals one*/
   /* of the order type's allowable divisions, it's ok*/
   /* else it's an error*/
   /* ----------------------------------------------------*/

  if (XOTTBL.XOTALWDV[sysVar.arrayIndex] == "A")
    if (SYCREC.XDVCD[OP0HWLSZ] == XOTTBL.XDVCD1[sysVar.arrayIndex]
     || SYCREC.XDVCD[OP0HWLSZ] == XOTTBL.XDVCD2[sysVar.arrayIndex]
     || SYCREC.XDVCD[OP0HWLSZ] == XOTTBL.XDVCD3[sysVar.arrayIndex]
     || SYCREC.XDVCD[OP0HWLSZ] == XOTTBL.XDVCD4[sysVar.arrayIndex]
     || SYCREC.XDVCD[OP0HWLSZ] == XOTTBL.XDVCD5[sysVar.arrayIndex])
       /* next sentence*/
    else
      OPAREC.OPAERR = "Y";
      OP0HW01.OP0HWSFL = "Y";
      set OP0HM005.OP0HMLSZ[OPASUB] cursor, modified, bold;
    end
  end
       /* ----------------------------------------------------*/
       /* if flag = d (disallowed) this order type restricts*/
       /* the divisions listed from the product.  if no match,*/
       /* it's good; if there is a match, it's an error*/
       /* ----------------------------------------------------*/
  if (XOTTBL.XOTALWDV[sysVar.arrayIndex] == "D")
    if (SYCREC.XDVCD[OP0HWLSZ] == XOTTBL.XDVCD1[sysVar.arrayIndex]
     || SYCREC.XDVCD[OP0HWLSZ] == XOTTBL.XDVCD2[sysVar.arrayIndex]
     || SYCREC.XDVCD[OP0HWLSZ] == XOTTBL.XDVCD3[sysVar.arrayIndex]
     || SYCREC.XDVCD[OP0HWLSZ] == XOTTBL.XDVCD4[sysVar.arrayIndex]
     || SYCREC.XDVCD[OP0HWLSZ] == XOTTBL.XDVCD5[sysVar.arrayIndex])
      OPAREC.OPAERR = "Y";
      OP0HW01.OP0HWSFL = "Y";
      set OP0HM005.OP0HMLSZ[OPASUB] cursor, modified, bold;
    end
  end



   /* ----------------------------------------------------*/
       /* first-size check*/
   /* if flag = a (allowed) and the product division equals one*/
   /* of the order type's allowable divisions, it's ok*/
   /* else it's an error*/
   /* ----------------------------------------------------*/
  if (XOTTBL.XOTALWDV[sysVar.arrayIndex] == "A")
    if (SYCREC.XDVCD[OP0HWFSZ] == XOTTBL.XDVCD1[sysVar.arrayIndex]
     || SYCREC.XDVCD[OP0HWFSZ] == XOTTBL.XDVCD2[sysVar.arrayIndex]
     || SYCREC.XDVCD[OP0HWFSZ] == XOTTBL.XDVCD3[sysVar.arrayIndex]
     || SYCREC.XDVCD[OP0HWFSZ] == XOTTBL.XDVCD4[sysVar.arrayIndex]
     || SYCREC.XDVCD[OP0HWFSZ] == XOTTBL.XDVCD5[sysVar.arrayIndex])
       /* next sentence*/
    else
      OPAREC.OPAERR = "Y";
      OP0HW01.OP0HWSFL = "Y";
      set OP0HM005.OP0HMFSZ[OPASUB] cursor, modified, bold;
    end
  end
       /* ----------------------------------------------------*/
       /* if flag = d (disallowed) this order type restricts*/
       /* the divisions listed from the product.  if no match,*/
       /* it's good; if there is a match, it's an error*/
       /* ----------------------------------------------------*/
  if (XOTTBL.XOTALWDV[sysVar.arrayIndex] == "D")
    if (SYCREC.XDVCD[OP0HWFSZ] == XOTTBL.XDVCD1[sysVar.arrayIndex]
     || SYCREC.XDVCD[OP0HWFSZ] == XOTTBL.XDVCD2[sysVar.arrayIndex]
     || SYCREC.XDVCD[OP0HWFSZ] == XOTTBL.XDVCD3[sysVar.arrayIndex]
     || SYCREC.XDVCD[OP0HWFSZ] == XOTTBL.XDVCD4[sysVar.arrayIndex]
     || SYCREC.XDVCD[OP0HWFSZ] == XOTTBL.XDVCD5[sysVar.arrayIndex])
      OPAREC.OPAERR = "Y";
      OP0HW01.OP0HWSFL = "Y";
      set OP0HM005.OP0HMFSZ[OPASUB] cursor, modified, bold;
    end
  end


  if (OP0HW01.OP0HWSFL == "Y") /* if error*/
    OP0HSD9(); /* setup size error message*/
    return;
  end






   /* edit check number 4*/
     /* check size fringe gut indicators*/


  if (XOTTBL.XOTXTRAS[sysVar.arrayIndex] == "Y") /* if order type allows extras*/
     /* next sentence*/
  else
    if (SYCREC.SY3FRGUT[OP0HWLSZ] == "X") /* if size is extra*/
      OPAREC.OPAERR = "Y";
      OP0HW01.OP0HWSFL = "Y";
      set OP0HM005.OP0HMLSZ[OPASUB] cursor, modified, bold;
    end
  end


  if (XOTTBL.XOTXTRAS[sysVar.arrayIndex] == "Y") /* if order type allows extras*/
     /* next sentence*/
  else
    if (SYCREC.SY3FRGUT[OP0HWFSZ] == "X") /* if size is an extra*/
      OPAREC.OPAERR = "Y";
      OP0HW01.OP0HWSFL = "Y";
      set OP0HM005.OP0HMFSZ[OPASUB] cursor, modified, bold;
    end
  end









   /* edit check number 5*/
     /* first size cannot be greater then last size*/


  if (OP0HW01.OP0HWFSZ > OP0HW01.OP0HWLSZ)
    converseLib.validationFailed(142);
    OPAREC.OPAERR = "Y";
    OP0HW01.OP0HWSFL = "Y";
    set OP0HM005.OP0HMFSZ[OPASUB] cursor, modified, bold;
    set OP0HM005.OP0HMLSZ[OPASUB] cursor, bold;
    return;
  end




                    /* size edit 6*/
     /* edit for bulk orders only. check to see that f/l sizes*/
     /* exist on the bulk order.*/


  if (OP0HW01.OP0HWBDF == "C"
   || OP0HW01.OP0HWBDF == "R"
   || OP0HW01.OP0HWBDF == "S"
   || OP0HW01.OP0HWBDF == "X"
   || OP0HW01.OP0HWBDF == "1") /* tcs include check for customer bulks*/
    OP0HSD8();
  end




  if (OP0HW01.OP0HWSFL == "Y") /* if error occured*/
    return; /* exit*/
  end







   /* IF GOT TO HERE ALL IS WELL SO LOAD F/L SIZE INTO WS TBL*/


  OPWREC.OPWRQSZF[OPASUB] = OP0HW01.OP0HWFSZ;
  OPWREC.OPWRQSZL[OPASUB] = OP0HW01.OP0HWLSZ;


end // end OP0HSDE

// edit total quantity
Function OP0HSDF()




          /* edit total quantity for this line item*/



  if (OP0HM005.OP2TORGQ[OPASUB] > 0)
    OPWREC.OP2TONOQ[OPASUB] = OP0HM005.OP2TORGQ[OPASUB];
    set OP0HM005.OP2TORGQ[OPASUB] initialAttributes;
  else
    converseLib.validationFailed(139);
    OPAREC.OPAERR = "Y";
    set OP0HM005.OP2TORGQ[OPASUB] cursor, modified, bold;
    return;
  end




    /* for draw orders, total quantity must be less then*/
    /* or equal to the quantity on the original bulk order.*/


  if (OP0HW01.OP0HWBDF == "C" /* if customer draw order*/
   || OP0HW01.OP0HWBDF == "R" /* or rebook draw order*/
   || OP0HW01.OP0HWBDF == "X") /* or flexible draw order*/
    if (OP0HM005.OP2TORGQ[OPASUB] <= OP0HW01.OP2TONOQ[OPASUB])
      set OP0HM005.OP2TORGQ[OPASUB] initialAttributes;
      OPWREC.OP2TONOQ[OPASUB] = OP0HM005.OP2TORGQ[OPASUB];
    else
      OPAREC.OPAERR = "Y";
      set OP0HM005.OP2TORGQ[OPASUB] cursor, modified, bold;
      if (OP2REC.OP2TORGQ == 0)
        converseLib.validationFailed(291); /* no qty left on bulk*/
      else
        converseLib.validationFailed(288); /* not enough qty for draw*/
      end
    end
  else
    if (OP0HW01.OP0HWBDF == "S") /* smart draw order*/
      if (OP0HM005.OP2TORGQ[OPASUB] <= OP0HW01.OP2TOHRQ[OPASUB])
        set OP0HM005.OP2TORGQ[OPASUB] initialAttributes;
        OPWREC.OP2TONOQ[OPASUB] = OP0HM005.OP2TORGQ[OPASUB];
      else
        OPAREC.OPAERR = "Y";
        set OP0HM005.OP2TORGQ[OPASUB] cursor, modified, bold;
        if (OP2REC.OP2TOHRQ == 0)
          converseLib.validationFailed(282); /* no qty left on bulk*/
        else
          converseLib.validationFailed(288); /* not enough qty for draw*/
        end
      end
    end
  end







end // end OP0HSDF

// edit quality code
Function OP0HSDG()




         /* edit quality code*/



    /* if there was only one default quality code then this*/
    /* field must have been protected thus no need to edit.*/


  if (OP0HW01.OP0HWOQC == "Y") /* if one quality code flag set*/
    OPWREC.XQACD[OPASUB] = OP0HM005.XQACD[OPASUB];
    return; /* exit edit*/
  end




  if (OP1REC.XOTCD in XOTTBL.XOTCD)
    if (XOTTBL.XQACD1[sysVar.arrayIndex] == OP0HM005.XQACD[OPASUB])
      OPWREC.XQACD[OPASUB] = XOTTBL.XQACD1[sysVar.arrayIndex];
      set OP0HM005.XQACD[OPASUB] initialAttributes;
    else
      if (XOTTBL.XQACD2[sysVar.arrayIndex] == OP0HM005.XQACD[OPASUB])
        OPWREC.XQACD[OPASUB] = XOTTBL.XQACD2[sysVar.arrayIndex];
        set OP0HM005.XQACD[OPASUB] initialAttributes;
      else
        if (XOTTBL.XQACD3[sysVar.arrayIndex] == OP0HM005.XQACD[OPASUB])
          OPWREC.XQACD[OPASUB] = XOTTBL.XQACD3[sysVar.arrayIndex];
          set OP0HM005.XQACD[OPASUB] initialAttributes;
        else
          converseLib.validationFailed(141);
          OPAREC.OPAERR = "Y";
          set OP0HM005.XQACD[OPASUB] cursor, modified, bold;
        end
      end
    end
  end








end // end OP0HSDG

// edit standard size
Function OP0HSDH()







    /* edit standard size distribution code*/


   /* F OP0HM005.XSZCD(OPASUB) IS MODIFIED;*/
   /* IF OP0HM005.XSZCD(OPASUB) GT ' ';*/
     /* ; /* next sentence*/
   /* ELSE;*/
     /* MOVE ' ' TO OPWREC.XSZCD(OPASUB);*/
     /* EZERTN;*/
   /* END;*/
   /* LSE;*/
   /* EZERTN;*/
   /* ND;*/




    /* if xszcd is valid and active*/
      /* if xsz number of sizes equals number of sizes between*/
               /* first and last sizes*/
         /* okay*/
      /* else;*/
         /* error*/
    /* else*/
      /* error*/



   /* F OP0HM005.XSZCD(OPASUB) IN XSZTBL.XSZCD*/
   /* AND XSZTBL.XXXSTAT(EZETST) EQ 'A';*/
   /* IF XSZTBL.XSZNBRSZ(EZETST) EQ OP0HW01.OP0HWNAS(OPASUB);*/
     /* MOVE OP0HM005.XSZCD(OPASUB) TO OPWREC.XSZCD(OPASUB);*/
     /* SET OP0HM005.XSZCD(OPASUB) DEFINED;*/
   /* ELSE;*/
     /* MOVE 'Y' TO OPAREC.OPAERR;*/
     /* MOVE 289 TO EZEMNO;           /* number of sizes don't match*/
     /* SET OP0HM005.XSZCD(OPASUB) CURSOR,MODIFIED,BRIGHT;*/
   /* END;*/
   /* LSE;*/
   /* MOVE 'Y' TO OPAREC.OPAERR;*/
   /* MOVE 290 TO EZEMNO;             /* invalid xszcd*/
   /* SET OP0HM005.XSZCD(OPASUB) CURSOR,MODIFIED,BRIGHT;*/
   /* ND;*/






end // end OP0HSDH

// edit package type code
Function OP0HSDI()



            /* edit package type*/



  if (OP0HM005.XPGCD[OPASUB] is modified)
    /* next sentence*/
  else
    if (OPWREC.XPGCD[OPASUB] > " ") /* if already has value*/
      return;
    else
      OPWREC.XPGCD[OPASUB] = "00";
      return;
    end
  end



  if (OP0HM005.XPGCD[OPASUB] == " ") /* spaces is valid as package code*/
    OPWREC.XPGCD[OPASUB] = "00";
    set OP0HM005.XPGCD[OPASUB] initialAttributes;
    return;
  end


  if (OP0HM005.XPGCD[OPASUB] in XPGTBL.XPGCD)
    OPWREC.XPGCD[OPASUB] = OP0HM005.XPGCD[OPASUB];
    set OP0HM005.XPGCD[OPASUB] initialAttributes;
  else
    converseLib.validationFailed(158);
    OPAREC.OPAERR = "Y";
    set OP0HM005.XPGCD[OPASUB] cursor, modified, bold;
  end



end // end OP0HSDI

// edit unit of measure
Function OP0HSDJ()




            /* edit unit of measure*/



  if (OP0HM005.XUMCD[OPASUB] is modified)
    /* next sentence*/
  else
    if (OPWREC.XUMCD[OPASUB] > " ") /* if already have some value*/
      return; /* don't overlay*/
    else
      OPWREC.XUMCD[OPASUB] = SYCREC.XUMCD; /* use style as default*/
      return;
    end
  end

  if (OP0HM005.XUMCD[OPASUB] in XUMTBL.XUMCD
   && XUMTBL.XXXSTAT[sysVar.arrayIndex] == "A")
    OPWREC.XUMCD[OPASUB] = OP0HM005.XUMCD[OPASUB];
    set OP0HM005.XUMCD[OPASUB] initialAttributes;
  else
    converseLib.validationFailed(156); /* "unit of measure invalid"*/
    OPAREC.OPAERR = "Y";
    set OP0HM005.XUMCD[OPASUB] cursor, modified, bold;
  end



end // end OP0HSDJ

// PROCESS OP1660 RETURN CODES
Function OP0HSDK()
   /* *********************************************************/
   /* * this routine moves the appropriate error message     **/
   /* * based on the return code form the sub-program op1660 **/
   /* *********************************************************/


  if (OP9REC.OP9RTNCD == "01") /* style doesn't qualify for sales pgm*/
    converseLib.validationFailed(135);
  else
    if (OP9REC.OP9RTNCD == "02") /* sls pgm required for this product*/
      converseLib.validationFailed(622);
    else
      if (OP9REC.OP9RTNCD == "03") /* product category not found*/
        converseLib.validationFailed(623);
      else
        if (OP9REC.OP9RTNCD == "05") /* -911 database busy*/
          converseLib.validationFailed(487);
        else
          if (OP9REC.OP9RTNCD == "06") /* sls pgm header not found*/
            converseLib.validationFailed(624);
          else
            if (OP9REC.OP9RTNCD == "07") /* product life cycle not valid*/
              converseLib.validationFailed(648); /* for sales program*/
            else
              if (OP9REC.OP9RTNCD == "08") /* product quality code not valid*/
                converseLib.validationFailed(649); /* for sales program*/
              end
            end
          end
        end
      end
    end
  end
end // end OP0HSDK

// edit specification code
Function OP0HSDL()



     /* edit specification code*/



  if (OP0HM005.PC2INSEG[OPASUB] > " ")
    /* next sentence*/
  else
    set OP0HM005.PC2INSEG[OPASUB] initialAttributes;
    OPWREC.PC2INSEG[OPASUB] = "000";
    return;
  end



  PC2REC.PC2INSEG = OP0HM005.PC2INSEG[OPASUB];
  PC2REC.XGPCD = OP1REC.XGPCD;

  call "IO3340" ("SG", SQLCA, PC2REC) {isNoRefresh = yes, isExternal = yes}; /* call spec cd*/

  if (SQLCA.VAGen_SQLCODE == 0)
    set OP0HM005.PC2INSEG[OPASUB] initialAttributes;
    OPWREC.PC2INSEG[OPASUB] = OP0HM005.PC2INSEG[OPASUB];
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      set OP0HM005.PC2INSEG[OPASUB] cursor, modified, bold;
      OPAREC.OPAERR = "Y";
      converseLib.validationFailed(159); /* spec code is not valid*/
    else
      TA1REC.TA1TYPE = "DB2 ";
      TA1REC.TA1FUNC = "RETN";
      TA1REC.TA1PGMNM = "OP0H    ";
      TA1REC.TA1LOCAT[1] = "SG      ";
      TA1REC.TA1LOCAT[2] = "OP0HSDL ";
      TA1REC.TA1LOCAT[3] = "IO3340  ";
      TA1REC.TA1LOCAT[4] = "        ";
      TA1REC.TA1MAP = "OP0HM005";
      TA1REC.TA1DBASE = "PC2REC  ";
      TA1REC.TA1TBLVU = "VPRDCU01";
      TA1REC.TA1TBLKE = OP0HM005.PC2INSEG;
      call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes};
      COMMAREA.CA-USER-WORKAREA-4K = " "; /* clear ws on error*/
      XSPF4();
      exit program;
    end
  end




end // end OP0HSDL

// get avgrec frm davail.vblnkp01
Function OP0HSDM()


   /* this statement group calls io5480 to access davail.vblnkp01*/
   /* for the blank bulk's owner group code which is part of the*/
   /* key to access davail.vblnks01 to validate the blank styles.*/


  set SQLCA empty;
  set AVGREC empty;

  if (OP1REC.XOBCD == "M1")
    AVGREC.AVGBPIND = "M";
  else
    AVGREC.AVGBPIND = "B";
  end

  AVIREC.AVIFUNCD = "SA";
  AVIREC.OP1CUNDT = OP1REC.OP1CUNDT;

  call "IO5480" (AVIREC, SQLCA, AVGREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == +0)
    OP0HW01.OP0HWMBF = "Y";
  else
    if (SQLCA.VAGen_SQLCODE == +100)
      converseLib.validationFailed(616); /* no active blank pgm exists for date range*/
      OP0HW01.OP0HWSFL = "Y";
      set OP0HM005.SY1STNBR[OPASUB] cursor, modified, bold;
      set OP0HM005.SY2CLRID[OPASUB] modified, bold;
      set OP0HM005.XDMCD[OPASUB] modified, bold;
    else
      TA1REC.TA1TYPE = "DB2 ";
      TA1REC.TA1PGMNM = "OP0H   "; /* application*/
      TA1REC.TA1LOCAT[1] = "OP0HSDM "; /* statement group*/
      TA1REC.TA1LOCAT[2] = "IO5480  "; /* io mod called*/
      TA1REC.TA1LOCAT[3] = AVIREC.AVIFUNCD; /* function code passed*/
      TA1REC.TA1LOCAT[4] = "        "; /* need date passed*/
      TA1REC.TA1MAP = "OP0HM005"; /* map*/
      TA1REC.TA1DBASE = "DAVAIL"; /* database name*/
      TA1REC.TA1TBLVU = "VBLNKP01"; /* table view*/
      TA1REC.TA1TBLKE = AVGREC.AVGKEY; /* key*/
      VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
      VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
      sysLib.rollback();
      VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
      
      call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
      XSPF4();
    end
  end

   /* ************************************************************/
end // end OP0HSDM

// setup call to davail.vblnks01
Function OP0HSDN()

   /* setup working storage fields to call io5470 for multi-hdrs*/

  OP0HW01.OP0HWSTY = OP0HM005.SY1STNBR[OPASUB];
  OP0HW01.OP0HWCLR = OP0HM005.SY2CLRID[OPASUB];

  OP0HSDO(); /* get avhrec from davail.vblnks01 via io5470*/

  if (SQLCA.VAGen_SQLCODE == 0
   || SQLCA.VAGen_SQLCODE == -811) /* tcs include eshanm(05/07/98) BL1119*/
    OPWREC.XOWCD = AVHREC.XOWCD;
  else
    converseLib.validationFailed(617);
    OP0HW01.OP0HWSFL = "Y";
  end
end // end OP0HSDN

// get avhrec frm davail.dblnks01
Function OP0HSDO()

   /* this statement group verifies that the blank style exists.*/
   /* IO5470 is called which accesses davail.vblnks01 using the*/
   /* owner group code from davail.vblnkp01 and sytle, color and*/
   /* dimension codes from the map as the key.*/

  set SQLCA empty;
  set AVHREC empty;

  AVHREC.XOWCD = AVGREC.XOWCD;
  AVHREC.SY1BSTNB = OP0HW01.OP0HWSTY;
  AVHREC.SY2BCLCD = OP0HW01.OP0HWCLR;
   /* MOVE OP0HW01.OP0HWXDM TO AVHREC.AVHBXDM removed from record 4/92;*/

  call "IO5470" ("SE", SQLCA, AVHREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == +0
   || SQLCA.VAGen_SQLCODE == +100
   || SQLCA.VAGen_SQLCODE == -811) /* tcs include eshanm(05/07/98) BL1119*/
     /* next sentence*/
  else
    TA1REC.TA1TYPE = "DB2 ";
    TA1REC.TA1PGMNM = "OP0H   "; /* application*/
    TA1REC.TA1LOCAT[1] = "OP0HSDO "; /* statement group*/
    TA1REC.TA1LOCAT[2] = "IO5470  "; /* io mod called*/
    TA1REC.TA1LOCAT[3] = "SE"; /* function code used*/
    TA1REC.TA1LOCAT[4] = AVHREC.AVHKEY; /* avhrec key*/
    TA1REC.TA1MAP = "OP0HM005"; /* map*/
    TA1REC.TA1DBASE = "DAVAIL"; /* database name*/
    TA1REC.TA1TBLVU = "VBLNKS01"; /* table view*/
    TA1REC.TA1TBLKE = AVHREC.AVHKEY; /* key*/
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.rollback();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
    
    call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
    XSPF4();
  end

   /* ************************************************************/
end // end OP0HSDO

// misc nike style edit (multiple
Function OP0HSDP()
   /* ******************************************************/
   /* **  misc nike style edits for multiple entry*/
   /* ******************************************************/
   /* check to see if a sales program is required for this*/
   /* product.*/

    /* build the op9rec key to subprogram op1660*/

  OP9REC.SP1ID = OP1REC.SP1ID; /* sales pgm id*/
  OP9REC.XLCCD = OP0HW01.XLCCD; /* life cycle code*/
  OP9REC.XQACD = OP0HM005.XQACD[OPASUB]; /* qual code*/
  OP9REC.XPCCD = SYCREC.XPCCD; /* product category*/
  OP9REC.SY1STNBR = OP0HM005.SY1STNBR[OPASUB];
  OP9REC.SY2CLRID = OP0HM005.SY2CLRID[OPASUB];
  OP9REC.XDMCD = OP0HM005.XDMCD[OPASUB];
  OP9REC.XGPCD = OP1REC.XGPCD;
  OP9REC.XDVCD = OP1REC.XDVCD;
  OP9REC.XSOCD = OP1REC.XSOCD;
  OP9REC.XSPCD = SYCREC.XSPCD;
  if (KUCREC.XAUCD in XAUTBL.XAUCD /* acct cls in table*/
   && XAUTBL.XXXSTAT[sysVar.arrayIndex] == "A")
    OP9REC.XAUCD = KUCREC.XAUCD;
  else
    OP9REC.XAUCD = " ";
  end
  OP9REC.KUCCOID = OP1REC.KUCCOID;
  OP9REC.KUMSTRID = OP1REC.KUMSTRID;
  OP9REC.XNXCD = OP1REC.XNXCD;
  OP9REC.OP9RTNCD = " ";


   /* skip sales program edit if customer draw*/
      /* or rebook draw*/

  if (OP0HW01.OP0HWBDF == "C" /* customer draw*/
   || OP0HW01.OP0HWBDF == "R") /* rebook draw*/
       /* continue*/
  else
    call "OP1660" (OP9REC) {isNoRefresh = yes, isExternal = yes};

    if (OP9REC.OP9RTNCD == "00") /* good rtn accept product*/
        /* next sentence*/
    else
      if (OP9REC.OP9RTNCD == "04") /* db2 error*/
        TAEREC.TAEDESC2 = "DB2 ERROR OP0HSDP ";
        OP0HSDT(); /* format error diags multi product*/
      else
        OP0HW01.OP0HWSFL = "Y";
        OPAREC.OPAERR = "Y";
        OP0HSDK(); /* process op1660 return code*/
      end
    end
  end

  if (OP0HW01.OP0HWSFL == "Y") /* error found*/
    set OP0HM005.SY1STNBR[OPASUB] cursor, modified, bold;
    set OP0HM005.SY2CLRID[OPASUB] modified, bold;
    set OP0HM005.XDMCD[OPASUB] modified, bold;
    OP0HSKA(); /* reset mdt's*/
  else
    set OP0HM005.SY1STNBR[OPASUB] initialAttributes;
    set OP0HM005.SY2CLRID[OPASUB] initialAttributes;
    set OP0HM005.XDMCD[OPASUB] initialAttributes;
    OP0HSDE(); /* edit sizes*/
    if (OP0HW01.OP0HWSFL == "Y") /* if error*/
      OP0HSKA(); /* reset mdt's*/
    else
      set OP0HM005.OP0HMFSZ[OPASUB] initialAttributes;
      set OP0HM005.OP0HMLSZ[OPASUB] initialAttributes;
      set OP0HM005.OP0HMDSZ[OPASUB] initialAttributes;
      OP0HSDJ(); /* edit unit of measure*/
      OP0HSDI(); /* edit package type*/
      if (OP1REC.XGPCD == "02")
        OP0HS-GET-MSR(); /* edit musical size run - footwear*/
      else
        OP0HSDH(); /* edit standard size- APPAREL*/
      end
      OP0HSDG(); /* edit quality code*/
      OP0HSDF(); /* edit tot quantity*/
      OP0HSDL(); /* edit spec code*/
    end
  end



end // end OP0HSDP

// misc cust style edit (multiple
Function OP0HSDQ()
   /* ****************************************************/
   /* **  misc cust style edit for multiple entry*/
   /* ****************************************************/
   /* check to see if a sales program is required for this*/
   /* product.*/

    /* build the op9rec key to subprogram op1660*/

  OP9REC.SP1ID = OP1REC.SP1ID; /* sales pgm id*/
  OP9REC.XLCCD = OP0HW01.XLCCD; /* life cycle code*/
  OP9REC.XQACD = OP0HM005.XQACD[OPASUB]; /* qual code*/
  OP9REC.XPCCD = SYCREC.XPCCD; /* product category*/
  OP9REC.SY1STNBR = OP0HM005.SY1STNBR[OPASUB];
  OP9REC.SY2CLRID = OP0HM005.SY2CLRID[OPASUB];
  OP9REC.XDMCD = OP0HM005.XDMCD[OPASUB];
  OP9REC.XGPCD = OP1REC.XGPCD;
  OP9REC.XDVCD = OP1REC.XDVCD;
  OP9REC.XSOCD = OP1REC.XSOCD;
  OP9REC.XSPCD = SYCREC.XSPCD;
  if (KUCREC.XAUCD in XAUTBL.XAUCD /* acct cls in table*/
   && XAUTBL.XXXSTAT[sysVar.arrayIndex] == "A")
    OP9REC.XAUCD = KUCREC.XAUCD;
  else
    OP9REC.XAUCD = " ";
  end
  OP9REC.KUCCOID = OP1REC.KUCCOID;
  OP9REC.KUMSTRID = OP1REC.KUMSTRID;
  OP9REC.XNXCD = OP1REC.XNXCD;
  OP9REC.OP9RTNCD = " ";

   /* skip sales program edit if customer draw*/
      /* or rebook draw*/

  if (OP0HW01.OP0HWBDF == "C" /* customer draw*/
   || OP0HW01.OP0HWBDF == "R") /* rebook draw*/
     /* NEXT SENTENCE*/
  else
    call "OP1660" (OP9REC) {isNoRefresh = yes, isExternal = yes};

    if (OP9REC.OP9RTNCD == "00") /* good rtn accept product*/
        /* next sentence*/
    else
      if (OP9REC.OP9RTNCD == "04") /* db2 error*/
        TAEREC.TAEDESC2 = "DB2 ERROR OP0HSDQ ";
        OP0HSDT(); /* format error diags multi product*/
      else
        OP0HW01.OP0HWSFL = "Y";
        OPAREC.OPAERR = "Y";
        OP0HSDK(); /* process op1660 return code*/
      end
    end
  end

  if (OP0HW01.OP0HWSFL == "Y") /* error found*/
    set OP0HM005.KUIPRDID[OPASUB] cursor, bold;
    set OP0HM005.SY1STNBR[OPASUB] modified, bold;
    set OP0HM005.SY2CLRID[OPASUB] modified, bold;
    set OP0HM005.XDMCD[OPASUB] modified, bold;
    OP0HSKA(); /* reset mdt's*/
  else
    set OP0HM005.KUIPRDID[OPASUB] initialAttributes;
    OP0HSDE(); /* edit sizes*/
    if (OP0HW01.OP0HWSFL == "Y") /* if error*/
      OP0HSKA(); /* reset mdt's*/
    else
      set OP0HM005.OP0HMFSZ[OPASUB] initialAttributes;
      set OP0HM005.OP0HMLSZ[OPASUB] initialAttributes;
      set OP0HM005.OP0HMDSZ[OPASUB] initialAttributes;
      OP0HSDJ(); /* edit unit of measure*/
      OP0HSDI(); /* edit package type*/

     /* IF OP1REC.XGPCD = '02';*/
       /* OP0HS-GET-MSR;              /* edit musical size run - ftwr*/
    /* ELSE;*/
     /* OP0HSDH;                      /* edit standard size - apprl*/
     /* END;*/

      OP0HSDG(); /* edit quality code*/
      OP0HSDF(); /* edit tot quantity*/
      OP0HSDL(); /* edit spec code*/
    end
  end


end // end OP0HSDQ

// edit sz, uom, pkg, etc...
Function OP0HSDR()
   /* *********************************************************/
   /* **  edit size, uom, pkg, etc...*/
   /* *********************************************************/
  OP0HSD1(); /* reread sycrec*/
  OP0HSE3(); /* reread bulk order item record*/
  if (OP0HM005.OP0HMFSZ[OPASUB] is modified /* if sizes touched*/
   || OP0HM005.OP0HMLSZ[OPASUB] is modified 
   || OP0HM005.OP0HMDSZ[OPASUB] is modified 
   || OPWREC.OPWRQSZF[OPASUB] == 0)         /* no prev size*/
    OP0HSDE(); /* edit sizes*/
    if (OP0HW01.OP0HWSFL == "Y") /* if error*/
      OP0HSKA(); /* reset mdt's*/
    else
      set OP0HM005.OP0HMFSZ[OPASUB] initialAttributes;
      set OP0HM005.OP0HMLSZ[OPASUB] initialAttributes;
      set OP0HM005.OP0HMDSZ[OPASUB] initialAttributes;
      OP0HSDJ(); /* edit unit of measure*/
      OP0HSDI(); /* edit package type*/

      if (OP1REC.XGPCD == "02")
        OP0HS-GET-MSR(); /* edit musical size run - ftwr*/
      else
        OP0HSDH(); /* edit standard size - apprl*/
      end

      OP0HSDG(); /* edit quality code*/
      OP0HSDF(); /* edit tot quantity*/
      OP0HSDL(); /* edit spec code*/
    end
  else
    OP0HSDJ(); /* edit unit of measure*/
    OP0HSDI(); /* edit package type*/

    if (OP1REC.XGPCD == "02")
      OP0HS-GET-MSR(); /* edit musical size run - ftwr*/
    else
      OP0HSDH(); /* edit standard size - apprl*/
    end

    OP0HSDG(); /* edit quality code*/
    OP0HSDF(); /* edit tot quantity*/
    OP0HSDL(); /* edit spec code*/
  end


end // end OP0HSDR

// Set up substitution fields
Function OP0HSDS()

   /* -----------------------------------------------------------*/
   /* Substitution information is set up if the user did not*/
   /* enter a different product and a substituted product*/
   /* exists.  Otherwise, the substitution fields in OPWREC*/
   /* are cleared.*/
   /* -----------------------------------------------------------*/
  if (OP0HM005.SY1STNBR[OPASUB] == OSKREC.SY1STNBR[OPASUB]
   && OP0HM005.SY2CLRID[OPASUB] == OSKREC.SY2CLRID[OPASUB]
   && OP0HM005.XDMCD[OPASUB] == OSKREC.XDMCD[OPASUB]
   && OSKREC.OP2SSTYN[OPASUB] != " ")
    OPWREC.OP2SSTYN[OPASUB] = OSKREC.OP2SSTYN[OPASUB];
    OPWREC.OP2SCLCD[OPASUB] = OSKREC.OP2SCLCD[OPASUB];
    OPWREC.OP2SDMCD[OPASUB] = OSKREC.OP2SDMCD[OPASUB];
    OPWREC.OPWSWHCD[OPASUB] = OSKREC.OSKSWHCD[OPASUB];
    OPWREC.OPWSNDT[OPASUB] = OSKREC.OSKSNDT[OPASUB];
  else
    OPWREC.OP2SSTYN[OPASUB] = " ";
    OPWREC.OP2SCLCD[OPASUB] = " ";
    OPWREC.OP2SDMCD[OPASUB] = " ";
    OPWREC.OPWSWHCD[OPASUB] = " ";
    OPWREC.OPWSNDT[OPASUB] = 0;
  end
end // end OP0HSDS

// OP1660 ERROR ROUTINE
Function OP0HSDT()
   /* **********************************************************/
   /* * this routine formats the error diags for a db2 error  **/
   /* * from the subroutine op1660 for the multiple product   **/
   /* * screen. op1660 posts the database information while   **/
   /* * this routine formats the key data which consists of   **/
   /* * of the entire pass record op9rec.                     **/
   /* **********************************************************/
  OPAREC.OPAERR = "Y";
  OP0HW01.OP0HWSFL = "Y";
  TA1REC.TA1TYPE = "APPL";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "OP0H    ";
  TA1REC.TA1LOCAT[1] = "OP0HSDT ";
  TA1REC.TA1LOCAT[2] = "OP1660  ";
  TA1REC.TA1LOCAT[3] = OP9REC.OP9RTNCD;
  TA1REC.TA1LOCAT[4] = "        ";
  set TAEREC empty;
  OP0HW01.OP0HWKEY = " ";
  OP0HW01.OP0HWK01 = OP1REC.OP1CUOID;
  OP0HW01.OP0HWK02 = OP1REC.OP1NORID;
  OP0HW01.OP0HWK03 = OP9REC.SP1ID;
  OP0HW01.OP0HWK04 = OP9REC.XLCCD;
  OP0HW01.OP0HWK05 = OP9REC.XQACD;
  OP0HW01.OP0HWK06 = OP9REC.XPCCD;
  OP0HW01.OP0HWK07 = OP9REC.SY1STNBR;
  OP0HW01.OP0HWK08 = OP9REC.SY2CLRID;
  OP0HW01.OP0HWK09 = OP9REC.XDMCD;
  OP0HW01.OP0HWK10 = OP9REC.XGPCD;
  OP0HW01.OP0HWK11 = OP9REC.XDVCD;
  OP0HW01.OP0HWK12 = OP9REC.XSOCD;
  OP0HW01.OP0HWK13 = OP9REC.XSPCD;
  OP0HW01.OP0HWK14 = OP9REC.XAUCD;
  OP0HW01.OP0HWK15 = OP9REC.KUCCOID;
  OP0HW01.OP0HWK16 = OP9REC.KUMSTRID;
  OP0HW01.OP0HWK17 = OP9REC.XNXCD;
  TAEREC.TAEDESC1 = OP0HW01.OP0HWKEY;
  VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
  VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
  sysLib.rollback();
  VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
  
  call "TA0020" (TA1REC, TAEREC) {isExternal = yes};
  XSPF4();
  exit program;
end // end OP0HSDT

// style sold out or not avail?
Function OP0HSDZ()

  OP0HW01.OP0HWSFL = "N"; /* initialize style error flag*/


   /* *******************************************************/
   /* This check is skipped for draw orders.*/
   /* *******************************************************/

  if (OP0HW01.XBDRWOFL == "Y") /* This is a draw order*/
    return;
  end


   /* *******************************************************/
   /* if no more orders accepted for product, get out*/
   /* *******************************************************/

  if (SYCREC.SY2ALNOR == "Y")
    /* next sentence--ok, orders still being accepted for prod*/
  else
    converseLib.validationFailed(393); /* new ords not being accept. for this*/
                                   /* prod*/
    OPAREC.OPAERR = "Y";
    OP0HW01.OP0HWSFL = "Y";
    set OP0HM005.SY1STNBR[OPASUB] cursor, modified, bold;
    set OP0HM005.SY2CLRID[OPASUB] modified, bold;
    set OP0HM005.XDMCD[OPASUB] modified, bold;
    return;
  end

   /* *************************************************************/
   /* Can't order custom logo on at-once order*/
   /* *************************************************************/
  if (SYCREC.XPRCD == "22")
    if (OPAREC.XOTATONF == "Y")
      converseLib.validationFailed(740);
      OPAREC.OPAERR = "Y";
      OP0HW01.OP0HWSFL = "Y";
      set OP0HM005.SY1STNBR[OPASUB] cursor, modified, bold;
      set OP0HM005.SY2CLRID[OPASUB] modified, bold;
      set OP0HM005.XDMCD[OPASUB] modified, bold;
      return;
    end
  end

   /* **************************************************************/
   /* Check for product consistency within the order. Must be all*/
   /* custom logo or all non-custom logo.*/
   /* Since this is the multiple sceen, keep track of*/
   /* items entered on the screen which haven't been added to*/
   /* the order yet. Make sure everything on screen is consistent.*/
   /* **************************************************************/

  if (SYCREC.XPRCD == "22") /* current product is custom logo*/
    if (OP0HW-CUST-LOGO-FL == "Y") /* custom prod entered before*/
       /* OK - products on screen are consistent*/
    else
      if (OP0HW-CUST-LOGO-FL == "N") /* non-custom prod entered before*/
        OPAREC.OPAERR = "Y";
        converseLib.validationFailed(795); /* can't mix custom/non-custom*/
        set OP0HM005.SY1STNBR[OPASUB] cursor, modified, bold;
        set OP0HM005.SY2CLRID[OPASUB] modified, bold;
        set OP0HM005.XDMCD[OPASUB] modified, bold;
      else
        OP0HW-CUST-LOGO-FL = "Y"; /* 1st prod on screen is cust*/
      end
    end
  else /* current product is not custom logo*/
    if (OP0HW-CUST-LOGO-FL == "N") /* non-custom prod entered before*/
       /* OK - products on screen are consistent*/
    else
      if (OP0HW-CUST-LOGO-FL == "Y") /* custom logo prod entered before*/
        OPAREC.OPAERR = "Y";
        converseLib.validationFailed(795); /* can't mix custom/non-custom*/
        set OP0HM005.SY1STNBR[OPASUB] cursor, modified, bold;
        set OP0HM005.SY2CLRID[OPASUB] modified, bold;
        set OP0HM005.XDMCD[OPASUB] modified, bold;
      else
        OP0HW-CUST-LOGO-FL = "N"; /* 1st prod on screen is non-custom*/
      end
    end
  end

  if (OPAREC.OPAERR == "N") /* no errors yet*/
    OP0HS-READ-DORDER(); /* Read 1st item to check for consistency*/
                      /* within product type in case items already*/
                      /* added which are not on this screen*/
  end

end // end OP0HSDZ

// read bulk item record
Function OP0HSE2()



    /* this routine reads the bulk order item record*/
    /* being drawn from for the multiple product screen.*/




  OPAREC.OPAORDN = OP1REC.OP1BLKID;
  OP2REC.OP1PARTN = OPAREC.OP1PARTN;
  OP2REC.OP1CUOID = OP1REC.OP1BLKID;
  OP2REC.OP1NORID = OPWREC.OPWBNOID;

  call "IO0440" ("SS", SQLCA, OP2REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    OP0HW01.OP0HWFND = "N"; /* init found flag*/
    while (SQLCA.VAGen_SQLCODE != 100 /* while not end of set*/
     && OP0HW01.OP0HWFND == "N") /* and while style not found*/
      call "IO0440" ("SN", SQLCA, OP2REC) {isNoRefresh = yes, isExternal = yes};
      if (SQLCA.VAGen_SQLCODE == 0)
        if (OP0HW01.OP0HWBBD == "B") /* blank bulk draw*/
          if (SYCREC.SY1BSTNB == OP2REC.SY1STNBR
           && SYCREC.SY2BCLCD == OP2REC.SY2CLRID
           && SYCREC.XDMCD == OP2REC.XDMCD
           && OP0HM005.XQACD[OPASUB] == OP2REC.XQACD
           && OP2REC.OP2TONOQ > 0)
            OP0HW01.OP0HWFND = "Y";
          end
        else
          if (OP0HM005.SY1STNBR[OPASUB] == OP2REC.SY1STNBR
           && OP0HM005.SY2CLRID[OPASUB] == OP2REC.SY2CLRID
           && OP0HM005.XDMCD[OPASUB] == OP2REC.XDMCD
           && OP0HM005.XQACD[OPASUB] == OP2REC.XQACD
           && OP2REC.OP2TONOQ > 0)
            OP0HW01.OP0HWFND = "Y";
          end
        end
      else
        if (SQLCA.VAGen_SQLCODE != 100)
          TA1REC.TA1TYPE = "DB2 ";
          TA1REC.TA1FUNC = "RETN";
          TA1REC.TA1PGMNM = "OP0H    ";
          TA1REC.TA1LOCAT[1] = "SN      ";
          TA1REC.TA1LOCAT[2] = "OP0HSE2 ";
          TA1REC.TA1LOCAT[3] = "IO0440  ";
          TA1REC.TA1LOCAT[4] = "        ";
          TA1REC.TA1MAP = "OP0HM005";
          TA1REC.TA1DBASE = "OP2REC  ";
          TA1REC.TA1TBLVU = "VITEM001";
          TA1REC.TA1TBLKE = OP2REC.OP2KEY;
          call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
          COMMAREA.CA-USER-WORKAREA-4K = " "; /* on error clear we*/
          XSPF4();
          exit program;
        end
      end
    end
  else /* no style records for the bulk order*/
    TA1REC.TA1TYPE = "DB2 ";
    TA1REC.TA1FUNC = "RETN";
    TA1REC.TA1PGMNM = "OP0H    ";
    TA1REC.TA1LOCAT[1] = "SS      ";
    TA1REC.TA1LOCAT[2] = "OP0HSE2 ";
    TA1REC.TA1LOCAT[3] = "IO0440  ";
    TA1REC.TA1LOCAT[4] = "        ";
    TA1REC.TA1MAP = "OP0HM005";
    TA1REC.TA1DBASE = "OP2REC  ";
    TA1REC.TA1TBLVU = "VITEM001";
    TA1REC.TA1TBLKE = OP2REC.OP2KEY;
    call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
    COMMAREA.CA-USER-WORKAREA-4K = " "; /* on error clear we*/
    XSPF4();
    exit program;
  end


  call "IO0440" ("CS", SQLCA, OP2REC) {isNoRefresh = yes, isExternal = yes}; /* close cursor*/









end // end OP0HSE2

// read bulk item record direct
Function OP0HSE3()


    /* this routine reads the bulk order item record*/
    /* being drawn from. uses a select unique.*/


   /* skip read if order is not a draw.*/

  if (OP0HW01.OP0HWBDF == "C"
   || OP0HW01.OP0HWBDF == "R"
   || OP0HW01.OP0HWBDF == "S"
   || OP0HW01.OP0HWBDF == "X")
     /* next sentence*/
  else
    return;
  end


  OPAREC.OPAORDN = OP1REC.OP1BLKID;
  OP2REC.OP1PARTN = OPAREC.OP1PARTN;
  OP2REC.OP1CUOID = OP1REC.OP1BLKID;
  OP2REC.OP2LNINB = OPWREC.OPWBKLIN[OPASUB];
  OP2REC.OP1NORID = OPWREC.OP1NORID[OPASUB];

   /* build key for abend display if needed*/
  OP0HW01.OP0HWDK1 = OP2REC.OP1PARTN;
  OP0HW01.OP0HWDK2 = OP2REC.OP1CUOID;
  OP0HW01.OP0HWDK3 = OP2REC.OP1NORID;
  OP0HW01.OP0HWDK4 = OP2REC.OP2LNINB;
  OP0HW01.OP0HWDK5 = OPWREC.SY1STNBR[OPASUB];
  OP0HW01.OP0HWDK6 = OPWREC.SY2CLRID[OPASUB];

  call "IO0440" ("S ", SQLCA, OP2REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
     /* next sentence*/
  else
    TA1REC.TA1TYPE = "DB2 ";
    TA1REC.TA1FUNC = "RETN";
    TA1REC.TA1PGMNM = "OP0H    ";
    TA1REC.TA1LOCAT[1] = "S       ";
    TA1REC.TA1LOCAT[2] = "OP0HSE3 ";
    TA1REC.TA1LOCAT[3] = "IO0440  ";
    TA1REC.TA1LOCAT[4] = "        ";
    TA1REC.TA1MAP = "OP0HM005";
    TA1REC.TA1DBASE = "OP2REC  ";
    TA1REC.TA1TBLVU = "VITEM001";
    TA1REC.TA1TBLKE = OP0HW01.OP0HWDKY;
    call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
    COMMAREA.CA-USER-WORKAREA-4K = " "; /* on error clear we*/
    XSPF4();
    exit program;
  end









end // end OP0HSE3

// read bulk item record
Function OP0HSE4()
   /* THIS IS REVIEW MODE OR SELECTED PRODUCT FROM OP0K*/


    /* this routine reads the bulk order item record*/
    /* being drawn from for the single product screen.*/


  if (OP0HW01.OP0HWBBD == "B") /* BLANK BULK DRAW*/
    OP0HW01.SY1STNBR = OP0HM010.SY1STNBR;
    OP0HW01.SY2CLRID = OP0HM010.SY2CLRID;
    OP0HW01.XDMCD = OP0HM010.XDMCD;
    OP0HSD1(); /* GET SYCREC*/
  end


  OPAREC.OPAORDN = OP1REC.OP1BLKID;
  OP0HW02.OP1PARTN = OPAREC.OP1PARTN;
  OP0HW02.OP1CUOID = OP1REC.OP1BLKID;
  OP0HW02.OP1NORID = OPWREC.OPWBNOID;

  call "IO0440" ("SS", SQLCA, OP0HW02) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    OP0HW01.OP0HWFND = "N"; /* init found flag*/
    while (SQLCA.VAGen_SQLCODE != 100 /* while not end of set*/
     && OP0HW01.OP0HWFND == "N") /* and while style not found*/
      call "IO0440" ("SN", SQLCA, OP0HW02) {isNoRefresh = yes, isExternal = yes};
      if (SQLCA.VAGen_SQLCODE == 0)
        if (OP0HW01.OP0HWBBD == "B") /* BLANK BULK DRAW*/
          if (SYCREC.SY1BSTNB == OP0HW02.SY1STNBR
           && SYCREC.SY2BCLCD == OP0HW02.SY2CLRID
           && SYCREC.XDMCD == OP0HW02.XDMCD
           && OP0HM010.XQACD == OP0HW02.XQACD)
            OP0HW01.OP0HWFND = "Y";
          end
        else
          if (OP0HM010.SY1STNBR == OP0HW02.SY1STNBR
           && OP0HM010.SY2CLRID == OP0HW02.SY2CLRID
           && OP0HM010.XDMCD == OP0HW02.XDMCD
           && OP0HM010.XQACD == OP0HW02.XQACD)
            OP0HW01.OP0HWFND = "Y";
          end
        end
      else
        if (SQLCA.VAGen_SQLCODE != 100)
          TA1REC.TA1TYPE = "DB2 ";
          TA1REC.TA1FUNC = "RETN";
          TA1REC.TA1PGMNM = "OP0H    ";
          TA1REC.TA1LOCAT[1] = "SN      ";
          TA1REC.TA1LOCAT[2] = "OP0HSE4 ";
          TA1REC.TA1LOCAT[3] = "IO0440  ";
          TA1REC.TA1LOCAT[4] = "        ";
          TA1REC.TA1MAP = "OP0HM010";
          TA1REC.TA1DBASE = "OP2REC  ";
          TA1REC.TA1TBLVU = "VITEM001";
          TA1REC.TA1TBLKE = OP0HW02.OP2KEY;
          call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
          COMMAREA.CA-USER-WORKAREA-4K = " "; /* on error clear we*/
          XSPF4();
          exit program;
        end
      end
    end
  else /* no style records for the bulk order*/
    TA1REC.TA1TYPE = "DB2 ";
    TA1REC.TA1FUNC = "RETN";
    TA1REC.TA1PGMNM = "OP0H    ";
    TA1REC.TA1LOCAT[1] = "SS      ";
    TA1REC.TA1LOCAT[2] = "OP0HSE4 ";
    TA1REC.TA1LOCAT[3] = "IO0440  ";
    TA1REC.TA1LOCAT[4] = "        ";
    TA1REC.TA1MAP = "OP0HM010";
    TA1REC.TA1DBASE = "OP2REC  ";
    TA1REC.TA1TBLVU = "VITEM001";
    TA1REC.TA1TBLKE = OP0HW02.OP2KEY;
    call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
    COMMAREA.CA-USER-WORKAREA-4K = " "; /* on error clear we*/
    XSPF4();
    exit program;
  end


  call "IO0440" ("CS", SQLCA, OP0HW02) {isNoRefresh = yes, isExternal = yes}; /* close cursor*/




  OP0HW03.OP2KEY = OP0HW02.OP2KEY;

  OP8REC.OP8TASK = "S";

  call "DB1000" (OP8REC, OP0HW03, OPBREC) {isExternal = yes};

  if (OPBREC.OPBSZRC != 0)
    TA1REC.TA1TYPE = "DB2 ";
    TA1REC.TA1FUNC = "RETN";
    TA1REC.TA1PGMNM = "OP0H    ";
    TA1REC.TA1LOCAT[1] = "S       ";
    TA1REC.TA1LOCAT[2] = "OP0HSE4 ";
    TA1REC.TA1LOCAT[3] = "DB1000  ";
    TA1REC.TA1LOCAT[4] = "        ";
    TA1REC.TA1MAP = "OP0HM010";
    TA1REC.TA1DBASE = "OP3REC  ";
    TA1REC.TA1TBLVU = "VOSIZE01";
    TA1REC.TA1TBLKE = OP0HW03.OP2KEY;
    call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
    COMMAREA.CA-USER-WORKAREA-4K = " "; /* on error clear we*/
    XSPF4();
    exit program;
  end







end // end OP0HSE4

// count active bulk sizes
Function OP0HSE5()


       /* if size's division code exists*/
          /* if size division is allowed*/
             /* if size fringe/gut/extras indicators ok*/
                /* then increment number of active size field.*/




  if (OP1REC.XOTCD in XOTTBL.XOTCD)
    if (XOTTBL.XOTALWDV[sysVar.arrayIndex] == "A"
     || XOTTBL.XOTALWDV[sysVar.arrayIndex] == "D")
       /* next sentence*/
    else
      return;
    end
  else
    return;
  end



  OPAREC.OPASUB1 = OP0HW01.OP0HWFSZ;
  OP0HW01.OP0HWNAS[OPASUB] = 0;

  if (XOTTBL.XOTALWDV[sysVar.arrayIndex] == "A")

    while (OPAREC.OPASUB1 <= 40
     && OPAREC.OPASUB1 <= OP0HW01.OP0HWLSZ)
      if (SYCREC.XDVCD[OPASUB1] != " ")
        if (SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD1[sysVar.arrayIndex]
         || SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD2[sysVar.arrayIndex]
         || SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD3[sysVar.arrayIndex]
         || SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD4[sysVar.arrayIndex]
         || SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD5[sysVar.arrayIndex])

          if (SYCREC.SY3FRGUT[OPASUB1] == "F"
           || SYCREC.SY3FRGUT[OPASUB1] == "G")
            OP0HW01.OP0HWNAS[OPASUB] = OP0HW01.OP0HWNAS[OPASUB] + 1;
          else
            if (SYCREC.SY3FRGUT[OPASUB1] == "X"
             /* if fringe/gut is extra*/
             && XOTTBL.XOTXTRAS[sysVar.arrayIndex] == "Y") /* if extras allowed*/
              OP0HW01.OP0HWNAS[OPASUB] = OP0HW01.OP0HWNAS[OPASUB] + 1;
            end
          end

        end
      end
      OPAREC.OPASUB1 = OPAREC.OPASUB1 + 1;
    end
  end


  if (XOTTBL.XOTALWDV[sysVar.arrayIndex] == "D")

    while (OPAREC.OPASUB1 <= 40
     && OPAREC.OPASUB1 <= OP0HW01.OP0HWLSZ)
      if (SYCREC.XDVCD[OPASUB1] != " ")
        if (SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD1[sysVar.arrayIndex]
         || SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD2[sysVar.arrayIndex]
         || SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD3[sysVar.arrayIndex]
         || SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD4[sysVar.arrayIndex]
         || SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD5[sysVar.arrayIndex])
           /* next sentence*/
        else

          if (SYCREC.SY3FRGUT[OPASUB1] == "F"
           || SYCREC.SY3FRGUT[OPASUB1] == "G")
            OP0HW01.OP0HWNAS[OPASUB] = OP0HW01.OP0HWNAS[OPASUB] + 1;
          else
            if (SYCREC.SY3FRGUT[OPASUB1] == "X"
             && XOTTBL.XOTXTRAS[sysVar.arrayIndex] == "Y")
              OP0HW01.OP0HWNAS[OPASUB] = OP0HW01.OP0HWNAS[OPASUB] + 1;
            end
          end

        end
      end
      OPAREC.OPASUB1 = OPAREC.OPASUB1 + 1;
    end
  end


end // end OP0HSE5

// reset single mdt tags
Function OP0HSFA()



          /* set mdt's in fields for the case of invalid aid key*/
          /* this allows the user to press the correct aid key*/
          /* without having to re-enter the data.*/



   /* note: only reset op0hmdsz mdt if style was in error*/

  if (OP0HM010.SY1STNBR is modified
   || OP0HM010.KUIPRDID is modified)
    if (OP0HM010.OP0HMDPS is modified)
      set OP0HM010.OP0HMDPS modified;
    end
  end


  if (OP0HM010.OP2TORGQ is modified)
    set OP0HM010.OP2TORGQ modified;
  end

  if (OP0HM010.XQACD is modified)
    set OP0HM010.XQACD modified;
  end

   /* F OP0HM010.XSZCD IS MODIFIED;*/
   /* SET OP0HM010.XSZCD MODIFIED;*/
   /* ND;*/

  if (OP0HM010.XPGCD is modified)
    set OP0HM010.XPGCD modified;
  end

  if (OP0HM010.XUMCD is modified)
    set OP0HM010.XUMCD modified;
  end

   /* IF OP0HM010.pc2inseg IS MODIFIED;*/
    /* SET OP0HM010.pc2inseg MODIFIED;*/
   /* END ;*/







end // end OP0HSFA

// read single nike style/clr
Function OP0HSG1()




        /* read nike style/color*/






  SYCREC.XGPCD = OP1REC.XGPCD;
  SYCREC.SY1STNBR = OP0HW01.SY1STNBR;
  SYCREC.SY2CLRID = OP0HW01.SY2CLRID;
  SYCREC.XDMCD = OP0HW01.XDMCD;

  call "IO0560" ("S ", SQLCA, SYCREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    /* TT#4654  SPAIN CHANGES  Begin **************/
    OP0HS-SPAIN-CHECK(); /* validate product for spain/canary*/
                                   /* compliance*/
    if (OP10REC.OP10-RETURN-CODE == "02") /* inv prod for spai/cnry*/
      OP0HW01.OP0HW-PRODUCT-INV-FLAG = "Y"; /* set invalid fl*/
      OP0HW01.OP0HW-MUL-PRODUCT-FLAG = "N"; /* reset mul prod fl*/
      converseLib.validationFailed(1002); /* invalid prod for spai/cnry*/
      return;
    end

    if (OP10REC.OP10-RETURN-CODE == "03") /* deadlock occured*/
      OP0HW01.OP0HW-PROD-DLOCK-FLAG = "Y"; /* set deadlock flag*/
      OP0HW01.OP0HW-MUL-PRODUCT-FLAG = "N"; /* reset mul prod fl*/
      converseLib.validationFailed(911); /* data base busy*/
      set TA1REC empty;
      TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* current appl*/
      TA1REC.TA1MAP = "OP0HM010"; /* curr map*/
      TA1REC.TA1LOC = "OP0HS-SPAIN-CHECK"; /* location*/
      XSOPS-OP6410-PSRTN();
      return;
    end
    /* TT#4654  SPAIN CHANGES  End   **************/

    /* --added for Canada --  June 2, 1995 --*/
    if (OP1REC.XDZ-DATA-DIST-CD == "CA")
      set WSY2000 empty;
      WSY2000.XDR-PROD-REG-CD = "05";
      OP0HS-SEL-VSYREG01();
      if (OP0HW01.OP0HW-WSY2000-FND-FLAG == "Y")
        OP0HSGZ(); /* style not sold anymore?*/
      else
        if (OP0HW01.OP0HW-WSY2000-FND-FLAG == "N")
          OPAREC.OPAERR = "Y";
          converseLib.validationFailed(911);
          return;
        else
          if (WSY2000.WSY2000-RETURN-CODE == "98")
            OPAREC.OPAERR = "Y";
            converseLib.validationFailed(010);
            return;
          else
            OPAREC.OPAERR = "Y";
            converseLib.validationFailed(909);
            return;
          end
        end
      end
      /* --added for US apparel--June 13, 1996--*/
    else
      if (OP1REC.XGPCD == "03")


        if (COMMAREA.XDVCD == "02" /* userid assigned to europe*/
         || COMMAREA.XDVCD == "03") /* userid assigned to asia*/
          /* continue processing*/
        else
          set WSY2000 empty;
          WSY2000.XDR-PROD-REG-CD = "01";
          OP0HS-SEL-VSYREG01();
          if (OP0HW01.OP0HW-WSY2000-FND-FLAG == "Y")
            OP0HSGZ(); /* style not sold anymore?*/
          else
            if (OP0HW01.OP0HW-WSY2000-FND-FLAG == "N")
              OPAREC.OPAERR = "Y";
              converseLib.validationFailed(911);
              return;
            else
              if (WSY2000.WSY2000-RETURN-CODE == "98")
                OPAREC.OPAERR = "Y";
                converseLib.validationFailed(010);
                return;
              else
                OPAREC.OPAERR = "Y";
                converseLib.validationFailed(909);
                return;
              end
            end
          end
        end
      end
    end
    OP0HSGZ(); /* style not sold anymore?*/
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      converseLib.validationFailed(131);
      return;
    else
      TA1REC.TA1TYPE = "DB2 ";
      TA1REC.TA1FUNC = "RETN";
      TA1REC.TA1PGMNM = "OP0H    ";
      TA1REC.TA1LOCAT[1] = "S       ";
      TA1REC.TA1LOCAT[2] = "OP0HSG1 ";
      TA1REC.TA1LOCAT[3] = "IO0560  ";
      TA1REC.TA1LOCAT[4] = "        ";
      TA1REC.TA1MAP = "OP0HM010";
      TA1REC.TA1DBASE = "SYCREC  ";
      TA1REC.TA1TBLVU = "VCOLOR02";
      TA1REC.TA1TBLKE = SYCREC.SYCKEY;
      call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
      COMMAREA.CA-USER-WORKAREA-4K = " "; /* on error clear ws*/
      XSPF4();
      exit program;
    end
  end






end // end OP0HSG1

// chk single prd life cycle
Function OP0HSG2()






          /* life cycle code check. get current life cycle from*/
          /* sycrec using system date then check to see that this*/
          /* life cycle is allowable for this order's order type.*/



  OP0HSLD(); /* find life cycle from sycrec*/

  if (OP0HW01.XLCCD == "  ") /* no current life cycle found*/
    converseLib.validationFailed(523); /* no life cycle currently in effect*/
    OPAREC.OPAERR = "Y";
    return;
  end





  if (OP1REC.XOTCD in XOTTBL.XOTCD)
    if (OP0HW01.XLCCD == XOTTBL.XLCCD1[sysVar.arrayIndex])
      return;
    else
      if (OP0HW01.XLCCD == XOTTBL.XLCCD2[sysVar.arrayIndex])
        return;
      else
        if (OP0HW01.XLCCD == XOTTBL.XLCCD3[sysVar.arrayIndex])
          return;
        else
          if (OP0HW01.XLCCD == XOTTBL.XLCCD4[sysVar.arrayIndex])
            return;
          else
            if (OP0HW01.XLCCD == XOTTBL.XLCCD5[sysVar.arrayIndex])
              return;
            end
          end
        end
      end
    end
  end



      /* if order type table didn't match life cycle try*/
      /* order class table. only way to get here is if*/
      /* didn't get match on order type table.*/


  if (OP1REC.XOCCD in XOCTBL.XOCCD)
    if (OP0HW01.XLCCD == XOCTBL.XLCCD1[sysVar.arrayIndex])
      return;
    else
      if (OP0HW01.XLCCD == XOCTBL.XLCCD2[sysVar.arrayIndex])
        return;
      end
    end
  end

   /* ********************* divert order processing **********************/

  if (OP1REC.XDVCD == "02" /* international order*/
   && OP1REC.XOBCD == "F1" /* futures order*/
   && OP1REC.XDSCD == "1"  /* direct ship*/
   && OP1REC.OP1CUNDT < OPAREC.OPACDT) /* need dt < order dt*/
    return; /* skip error routine*/
  end

   /* ********************* divert order processing **********************/

  if (OP0HW01.XLCCD == "20")
    converseLib.validationFailed(524); /* this is a closeout product*/
  else /* not valid for the order type*/
    if (OP0HW01.XLCCD == "15")
      converseLib.validationFailed(525); /* this is a cancelled product*/
    else
      if (OP0HW01.XLCCD == "05")
        converseLib.validationFailed(526); /* this is an in development product*/
      else
        if (OP0HW01.XLCCD == "25")
          converseLib.validationFailed(527); /* this is a dormant product*/
        end
      end
    end
  end

  OPAREC.OPAERR = "Y";
  OP0HW01.OP0HWSFL = "Y";

end // end OP0HSG2

// default first size single
Function OP0HSG3()
   /* single product header screen*/

   /* this routine will set a default first size if not entered*/
   /* it works forward through the products size array.*/

   /* ------------------------------------------------------------*/
    /* first make sure that the xottbl.allowed/disallowed*/
    /* division code = a or d.*/
   /* ------------------------------------------------------------*/

  if (OP1REC.XOTCD in XOTTBL.XOTCD)
    if (XOTTBL.XOTALWDV[sysVar.arrayIndex] == "A"
     || XOTTBL.XOTALWDV[sysVar.arrayIndex] == "D")
       /* next sentence--ok good values, keep going*/
    else
      OPAREC.OPAERR = "Y";
      converseLib.validationFailed(148);
      return;
    end
  end


   /* ------------------------------------------------------------*/
   /* look for a valid size based on division codes:*/
   /* if xottbl.xotalwdv = 'a' (allowed) and the product divison*/
   /* equals one of the order type's allowable divisions, and*/
   /* the xtras/fringe/gut ok, save it.*/
   /* ----------------------------------------------------*/

  OPAREC.OPASUB1 = 1;
  OPWREC.OPWRQSZF = 0;

  if (XOTTBL.XOTALWDV[sysVar.arrayIndex] == "A") /* allowed divisions*/

    while (OPAREC.OPASUB1 <= 40)
      if (SYCREC.XDVCD[OPASUB1] > " ")
        if (SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD1[sysVar.arrayIndex]
         || SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD2[sysVar.arrayIndex]
         || SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD3[sysVar.arrayIndex]
         || SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD4[sysVar.arrayIndex]
         || SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD5[sysVar.arrayIndex])

          if (XOTTBL.XOTXTRAS[sysVar.arrayIndex] == "Y") /* if ord type allows extras*/
            move OPASUB1 to OP0HWFSZ withV60Compat;
            OPWREC.OPWRQSZF[1] = OP0HWFSZ;
            OPASUB1 = 41;
          else
            if (SYCREC.SY3FRGUT[OPASUB1] == "F" /* if size is fringe*/
             || SYCREC.SY3FRGUT[OPASUB1] == "G") /* if size is gut*/
              OP0HW01.OP0HWFSZ = OPAREC.OPASUB1;
              OPWREC.OPWRQSZF[1] = OP0HWFSZ;
              OPAREC.OPASUB1 = 41;
            end
          end

        end
      end
      OPAREC.OPASUB1 = OPAREC.OPASUB1 + 1;
    end

  end

       /* --------------------------------------------------*/
       /* if the order type table indicates 'd', use*/
       /* the 'disallowed' division logic instead*/
       /* --------------------------------------------------*/
  if (XOTTBL.XOTALWDV[sysVar.arrayIndex] == "D") /* disallowed divisions*/

    while (OPAREC.OPASUB1 <= 40)
      if (SYCREC.XDVCD[OPASUB1] > " ")
        if (SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD1[sysVar.arrayIndex]
         || SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD2[sysVar.arrayIndex]
         || SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD3[sysVar.arrayIndex]
         || SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD4[sysVar.arrayIndex]
         || SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD5[sysVar.arrayIndex])
          /* next sentence--disallowed division, keep looking*/
        else
          if (XOTTBL.XOTXTRAS[sysVar.arrayIndex] == "Y") /* if ord type allows extras*/
            OP0HW01.OP0HWFSZ = OPAREC.OPASUB1;
            OPWREC.OPWRQSZF[1] = OP0HWFSZ;
            OPAREC.OPASUB1 = 41;
          else
            if (SYCREC.SY3FRGUT[OPASUB1] == "F" /* if size is fringe*/
             || SYCREC.SY3FRGUT[OPASUB1] == "G") /* if size is gut*/
              OP0HW01.OP0HWFSZ = OPAREC.OPASUB1;
              OPWREC.OPWRQSZF[1] = OP0HWFSZ;
              OPAREC.OPASUB1 = 41;
            end
          end
        end
      end
      OPAREC.OPASUB1 = OPAREC.OPASUB1 + 1;
    end

  end




  if (OP0HW01.OP0HWFSZ > 0) /* if got a size*/
     /* next sentence*/
  else
    OPAREC.OPAERR = "Y"; /* error, no size to default to*/
    converseLib.validationFailed(148);
  end



end // end OP0HSG3

// default last size single
Function OP0HSG4()
   /* single product header screen*/

   /* this routine will set a default first size if not entered*/
   /* it works backward through the product's size array.*/

   /* ------------------------------------------------------------*/
    /* first make sure that the xottbl.allowed/disallowed*/
    /* division code = a or d.*/
   /* ------------------------------------------------------------*/

  if (OP1REC.XOTCD in XOTTBL.XOTCD)
    if (XOTTBL.XOTALWDV[sysVar.arrayIndex] == "A"
     || XOTTBL.XOTALWDV[sysVar.arrayIndex] == "D")
       /* next sentence--ok good values, keep going*/
    else
      OPAREC.OPAERR = "Y";
      converseLib.validationFailed(148);
      return;
    end
  end


   /* ------------------------------------------------------------*/
   /* look for a valid size based on division codes:*/
   /* if xottbl.xotalwdv = 'a' (allowed) and the product divison*/
   /* equals one of the order type's allowable divisions, and*/
   /* the xtras/fringe/gut ok, save it.*/
   /* ----------------------------------------------------*/

  OPAREC.OPASUB1 = 40;
  OP0HW01.OP0HWLSZ = 0;

  if (XOTTBL.XOTALWDV[sysVar.arrayIndex] == "A") /* allowed divisions*/

    while (OPAREC.OPASUB1 >= 1)
      if (SYCREC.XDVCD[OPASUB1] > " ")
        if (SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD1[sysVar.arrayIndex]
         || SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD2[sysVar.arrayIndex]
         || SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD3[sysVar.arrayIndex]
         || SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD4[sysVar.arrayIndex]
         || SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD5[sysVar.arrayIndex])

          if (XOTTBL.XOTXTRAS[sysVar.arrayIndex] == "Y") /* if ord type allows extras*/
            OP0HW01.OP0HWLSZ = OPAREC.OPASUB1;
            OPWREC.OPWRQSZL[1] = OP0HW01.OP0HWLSZ;
            OPAREC.OPASUB1 = 1;
          else
            if (SYCREC.SY3FRGUT[OPASUB1] == "F" /* if size is fringe*/
             || SYCREC.SY3FRGUT[OPASUB1] == "G") /* if size is gut*/
              OP0HW01.OP0HWLSZ = OPAREC.OPASUB1;
              OPWREC.OPWRQSZL[1] = OP0HW01.OP0HWLSZ;
              OPAREC.OPASUB1 = 1;
            end
          end

        end
      end
      OPAREC.OPASUB1 = OPAREC.OPASUB1 - 1;
    end

  end

       /* --------------------------------------------------*/
       /* if the order type table indicates 'd', use*/
       /* the 'disallowed' division logic instead*/
       /* --------------------------------------------------*/
  if (XOTTBL.XOTALWDV[sysVar.arrayIndex] == "D") /* disallowed divisions*/

    while (OPAREC.OPASUB1 >= 1)
      if (SYCREC.XDVCD[OPASUB1] > " ")
        if (SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD1[sysVar.arrayIndex]
         || SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD2[sysVar.arrayIndex]
         || SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD3[sysVar.arrayIndex]
         || SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD4[sysVar.arrayIndex]
         || SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD5[sysVar.arrayIndex])
          /* next sentence--disallowed division, keep looking*/
        else
          if (XOTTBL.XOTXTRAS[sysVar.arrayIndex] == "Y") /* if ord type allows extras*/
            OP0HW01.OP0HWLSZ = OPAREC.OPASUB1;
            OPWREC.OPWRQSZL[1] = OP0HW01.OP0HWLSZ;
            OPAREC.OPASUB1 = 1;
          else
            if (SYCREC.SY3FRGUT[OPASUB1] == "F" /* if size is fringe*/
             || SYCREC.SY3FRGUT[OPASUB1] == "G") /* if size is gut*/
              OP0HW01.OP0HWLSZ = OPAREC.OPASUB1;
              OPWREC.OPWRQSZL[1] = OP0HW01.OP0HWLSZ;
              OPAREC.OPASUB1 = 1;
            end
          end
        end
      end
      OPAREC.OPASUB1 = OPAREC.OPASUB1 - 1;
    end

  end




  if (OP0HW01.OP0HWLSZ > 0) /* if got a size*/
     /* next sentence*/
  else
    OPAREC.OPAERR = "Y"; /* error, no size to default to*/
    converseLib.validationFailed(148);
  end


end // end OP0HSG4

// edit numeric sizes
Function OP0HSG5()







    /* this routines makes sure that the numeric size entered*/
    /* is between 1 and 40. this is hard due to the input field*/
    /* being character. The edit goes as follows:*/

      /* 1. move size field to array of 5 individual characters*/
      /* 2. go through each cell and test for 0 through 9.*/
         /* replace spaces with zeroes.*/
      /* 3. if map field ok, check range.*/
      /* 4. do all three steps for the first map size.*/





       /* check first size*/


  OP0HW01.OP0HWSRC = OP0HM010.OP0HMFSZ;
  OPAREC.OPASUB1 = 5;

  while (OPAREC.OPASUB1 >= 1)
    if (OP0HW01.OP0HWSRA[OPASUB1] >= "0"
     && OP0HW01.OP0HWSRA[OPASUB1] <= "9")
      OPAREC.OPASUB1 = OPAREC.OPASUB1 - 1;
    else
      if (OP0HW01.OP0HWSRA[OPASUB1] == " ")
        OP0HW01.OP0HWSRA[OPASUB1] = "0";
        OPAREC.OPASUB1 = OPAREC.OPASUB1 - 1;
      else
        OPAREC.OPAERR = "Y";
        OP0HW01.OP0HWSFL = "Y";
        set OP0HM010.OP0HMFSZ cursor, modified, bold;
        OPAREC.OPASUB1 = 0;
      end
    end
  end


  if (OPAREC.OPAERR == "N") /* first size was numeric*/
    OP0HW01.OP0HWFSZ = OP0HW01.OP0HWSRN;
  else
    OP0HW01.OP0HWFSZ = 0;
  end


  if (OP0HW01.OP0HWFSZ >= 1
   && OP0HW01.OP0HWFSZ <= 40)
    set OP0HM010.OP0HMFSZ initialAttributes;
  else
    OPAREC.OPAERR = "Y";
    OP0HW01.OP0HWSFL = "Y";
    set OP0HM010.OP0HMFSZ cursor, modified, bold;
  end




   /* now check last size*/



  OP0HW01.OP0HWSRC = OP0HM010.OP0HMLSZ;
  OPAREC.OPASUB1 = 5;

  while (OPAREC.OPASUB1 >= 1)
    if (OP0HW01.OP0HWSRA[OPASUB1] >= "0"
     && OP0HW01.OP0HWSRA[OPASUB1] <= "9")
      OPAREC.OPASUB1 = OPAREC.OPASUB1 - 1;
    else
      if (OP0HW01.OP0HWSRA[OPASUB1] == " ")
        OP0HW01.OP0HWSRA[OPASUB1] = "0";
        OPAREC.OPASUB1 = OPAREC.OPASUB1 - 1;
      else
        OPAREC.OPAERR = "Y";
        set OP0HM010.OP0HMLSZ cursor, modified, bold;
        OPAREC.OPASUB1 = 0;
      end
    end
  end


  if (OPAREC.OPAERR == "N") /* last size was numeric*/
    OP0HW01.OP0HWLSZ = OP0HW01.OP0HWSRN;
  else
    OP0HW01.OP0HWLSZ = 0;
  end


  if (OP0HW01.OP0HWLSZ >= 1
   && OP0HW01.OP0HWLSZ <= 40)
    set OP0HM010.OP0HMLSZ initialAttributes;
  else
    OPAREC.OPAERR = "Y";
    set OP0HM010.OP0HMLSZ cursor, modified, bold;
  end



   /* Count the number of valid sizes between first and last*/
   /* if no errors were found.*/

  if (OPAREC.OPAERR == "N")
    OP0HSH5();
  end
end // end OP0HSG5

// edit alpha sizes
Function OP0HSG6()







   /* this routine edits alpha sizes for existance*/





   /* find a match on first size*/



  OPASUB1 = 1;

  while (OPASUB1 <= 40)
    if (OP0HM010.OP0HMFSZ == SY4REC.SY4IDDSC[OPASUB1])
      OP0HW01.OP0HWFSZ = OPASUB1;
      OPASUB1 = 99;
    else
      OPASUB1 = OPASUB1 + 1;
    end
  end


  if (OPASUB1 != 99) /* if not found*/
    set OP0HM010.OP0HMFSZ cursor, modified, bold;
    OPAREC.OPAERR = "Y";
  end




   /* find a match on last size*/



  OPASUB1 = 1;

  while (OPASUB1 <= 40)
    if (OP0HM010.OP0HMLSZ == SY4REC.SY4IDDSC[OPASUB1])
      OP0HW01.OP0HWLSZ = OPASUB1;
      OPASUB1 = 99;
    else
      OPASUB1 = OPASUB1 + 1;
    end
  end



  if (OPASUB1 != 99) /* if not found*/
    set OP0HM010.OP0HMLSZ cursor, modified, bold;
    OPAREC.OPAERR = "Y";
  end



   /* Count the nbr of valid sizes between first and last size*/
   /* if no errors were found.*/

  if (OPAREC.OPAERR == "N")
    OP0HSH5();
  end
end // end OP0HSG6

// edit bulk order sizes, existan
Function OP0HSG8()




   /* this statement group checks to see that the first/last*/
   /* sizes entered for this product exist on the bulk order*/
   /* being drawn from.*/


  OP3REC.OP2KEY = OP2REC.OP2KEY;
  OP8REC.OP8TASK = "S ";

  call "DB1000" (OP8REC, OP3REC, OPBREC) {isNoRefresh = yes, isExternal = yes};

  if (OPBREC.OPBSZRC == 0)
    /* next sentence*/
  else
    TA1REC.TA1TYPE = "DB2 ";
    TA1REC.TA1FUNC = "RETN";
    TA1REC.TA1PGMNM = "OP0H    ";
    TA1REC.TA1LOCAT[1] = "S       ";
    TA1REC.TA1LOCAT[2] = "OP0HSD8 ";
    TA1REC.TA1LOCAT[3] = "DB1000  ";
    TA1REC.TA1LOCAT[4] = "        ";
    TA1REC.TA1MAP = "OP0HM010";
    TA1REC.TA1DBASE = "DORDER  ";
    TA1REC.TA1TBLVU = "VOSIZE01";
    TA1REC.TA1TBLKE = OP3REC.OP2KEY;
    call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
    COMMAREA.CA-USER-WORKAREA-4K = " "; /* clear ws on error*/
    XSPF4();
    exit program;
  end




  OP0HW01.OP0HWNAS[1] = 0; /* init number of active sizes counter*/
  OP0HW01.OP0HWFSF = "N"; /* init size found flags*/
  OP0HW01.OP0HWLSF = "N";
  OPAREC.OPASUB1 = 1;

  while (OPAREC.OPASUB1 <= 40)
    if (OP3REC.OP3SZAFL[OPASUB1] == "Y") /* if size is active*/
      if (OPAREC.OPASUB1 >= OP0HW01.OP0HWFSZ
       && OPAREC.OPASUB1 <= OP0HW01.OP0HWLSZ)
        OP0HW01.OP0HWNAS[1] = OP0HW01.OP0HWNAS[1] + 1; /* inc counter*/
      end
      if (OPAREC.OPASUB1 == OP0HW01.OP0HWFSZ)
        OP0HW01.OP0HWFSF = "Y"; /* set first size found flag*/
      end
      if (OPAREC.OPASUB1 == OP0HW01.OP0HWLSZ)
        OP0HW01.OP0HWLSF = "Y"; /* set last size found flag*/
      end
    end
    OPAREC.OPASUB1 = OPAREC.OPASUB1 + 1;
  end




   /* now see if found sizes*/


  if (OP0HW01.OP0HWFSF == "N"
   || OP0HW01.OP0HWLSF == "N")
    OP0HW01.OP0HWSFL = "Y"; /* set error flags and msgs*/
    OPAREC.OPAERR = "Y";
    converseLib.validationFailed(286);
    if (OP0HW01.OP0HWLSF == "N") /* if last size not found*/
      set OP0HM010.OP0HMLSZ cursor, modified, bold;
    end
    if (OP0HW01.OP0HWFSF == "N") /* if last first not found*/
      set OP0HM010.OP0HMFSZ cursor, modified, bold;
    end
  end






end // end OP0HSG8

// setup size error message
Function OP0HSG9()




    /* when the user encounters some kind of size error we*/
    /* want to display a message showing the valid size*/
    /* range for the entered style. this sgrp builds this*/
    /* size range message.*/



   /* first get first and last available size*/

  if (OP0HW01.OP0HWBDF == "C" /* cust draw*/
   || OP0HW01.OP0HWBDF == "R" /* rebook draw*/
   || OP0HW01.OP0HWBDF == "S" /* smart draw*/
   || OP0HW01.OP0HWBDF == "X") /* flexible draw*/
    OP0HSH3(); /* get first from bulk order*/
    OP0HSH4(); /* get last*/
  else
    OP0HSG3(); /* get first from style record*/
    OP0HSG4(); /* get last*/
  end




    /* test to see that there were some valid sizes*/

  if (OP0HW01.OP0HWFSZ < 1
   || OP0HW01.OP0HWLSZ > 40)
    converseLib.validationFailed(148);
    return;
  end



  if (OP0HW01.XOTSZIND == "D") /* if sizes need to be descriptive*/
    OP0HW01.OP0HWSZ4 = SY4REC.SY4IDDSC[OP0HWLSZ];
    OP0HW01.OP0HWSZ2 = SY4REC.SY4IDDSC[OP0HWFSZ];
  else
    OP0HW01.OP0HWSZ4 = OP0HW01.OP0HWLSZ;
    OP0HW01.OP0HWSZ2 = OP0HW01.OP0HWFSZ;
  end


  OP0HM010.VAGen_EZEMSG = OP0HW01.OP0HWSZM; /* move msg to map*/





end // end OP0HSG9

// edit single map fields
Function OP0HSGA()
         /* this statement group edits the fields from op0hm010*/



         /* this routine drives the edits. it looks worse then*/
         /* it really is!!! The following if statements have two*/
         /* main sections. one to edit nike style numbers and the*/
         /* other to edit customer style numbers. the logic in*/
         /* these two sections is completely the same except for*/
         /* the individual style code edits. style, gpc code*/
         /* check, and sizes edits are related. all must be ok*/
         /* for a style to be accepted for entry. for this reason*/
         /* the logic won't go to the next edit unless the*/
         /* previous related edit passes.*/

         /* *****************************************************/
         /* * these statements edit                             **/
         /* * the dimension code, if not valid, get out         **/
         /* *****************************************************/

  if (OP0HM010.XDMCD > " ")
    if (OP0HM010.XDMCD in XDMTBL.XDMCD
     && XDMTBL.XXXSTAT[sysVar.arrayIndex] == "A")
       /* next sentence*/
    else
      converseLib.validationFailed(234); /* dimension code is not valid*/
      set OP0HM010.XDMCD cursor, bold;
      OPAREC.OPAERR = "Y"; /* error*/
      OP0HSFA(); /* reset mdt's*/
      return; /* converse*/
    end
  else
    OP0HM010.XDMCD = "00"; /* standard default value*/
    set OP0HM010.XDMCD initialAttributes;
  end

   /* ************************************************************/

  OP0HSGS(); /* Set up substitution fields.*/

  if (OP0HM010.SY1STNBR > " " /* if anything in the field*/
   && OP0HM010.KUIPRDID == " ") /* if nothing in the field*/
    if (OP0HM010.KUIPRDID is modified)
      set OP0HM010.KUIPRDID initialAttributes;
      OP0HM010.KUIPRDID = " ";
    end
    if (OP0HM010.SY1STNBR is modified /* if just touched*/
     || OP0HM010.SY2CLRID is modified 
     || OP0HM010.XDMCD is modified)  
      OP0HSGB(); /* edit nike style*/
      if (OPAREC.OPAERR == "Y") /* if error*/
        OP0HSFA(); /* reset mdt's*/
      else
        OP0HSGP(); /* misc nike style edit (single entry)*/
      end
    else /* style ok, edit rest*/
      if ((OP1REC.XGPCD == "02" /* footwear*/
       || OP1REC.XGPCD == "03") /* apparel*/
       && OP0HM010.SY2CLRID == "   ") /* style was repeated, no chg made*/
        /* next sentence*/
      else
        OP0HW01.SY1STNBR = OP0HM010.SY1STNBR;
        OP0HW01.SY2CLRID = OP0HM010.SY2CLRID;
        OP0HW01.XDMCD = OP0HM010.XDMCD;
        OP0HSGR(); /* edit sz, uom, pkg, etc...*/
      end
    end
  else /* edit cust style*/
    if (OP0HM010.KUIPRDID > " ") /* if cust style entered*/
      if (OP0HM010.SY1STNBR is modified
       || OP0HM010.SY2CLRID is modified
       || OP0HM010.XDMCD is modified)
        OP0HM010.SY1STNBR = " ";
        OP0HM010.SY2CLRID = " ";
        OP0HM010.XDMCD = " ";
        set OP0HM010.SY1STNBR initialAttributes;
        set OP0HM010.SY2CLRID initialAttributes;
        set OP0HM010.XDMCD initialAttributes;
      end
      if (OP0HM010.KUIPRDID is modified) /* if just touched*/
        OP0HSGC(); /* edit cust style*/
        if (OPAREC.OPAERR == "Y") /* if error*/
          OP0HSFA(); /* reset mdt's*/
        else
          OP0HSGQ(); /* misc cust style edit (single entry)*/
        end
      else /* style ok, edit rest*/
        if ((OP1REC.XGPCD == "02" /* footwear*/
         || OP1REC.XGPCD == "03") /* apparel*/
         && OP0HM010.SY2CLRID == "   ") /* style was repeated, no chg*/
          /* next sentence*/
        else
          OP0HSGR(); /* edit sz, uom, pkg etc. single entry*/
        end
      end
    else /* if nothing entered, empty product array*/
      OPWREC.OPWMPRDA[1] = " ";
    end
  end

end // end OP0HSGA

// edit single nike style/color
Function OP0HSGB()

        /* edit nike style/color*/

  OP0HW01.SY1STNBR = OP0HM010.SY1STNBR;
  OP0HW01.SY2CLRID = OP0HM010.SY2CLRID;
  OP0HW01.XDMCD = OP0HM010.XDMCD;

  OP0HSG1(); /* read nike style/color record*/

   /* TT#4654  SPAIN CHANGES  Begin **************/

  if (OP0HW01.OP0HW-PRODUCT-INV-FLAG == "Y") /* prod invfor spai/cnry*/
    OPAREC.OPAERR = "Y"; /* set error flag*/
    set OP0HM010.SY1STNBR cursor, modified, bold;
    set OP0HM010.SY2CLRID modified, bold;
    set OP0HM010.XDMCD modified, bold;
    return;
  end

  if (OP0HW01.OP0HW-PROD-DLOCK-FLAG == "Y") /* if deadlock*/
    OPAREC.OPAERR = "Y";
    set OP0HM010.SY1STNBR cursor, modified, bold;
    set OP0HM010.SY2CLRID modified, bold;
    set OP0HM010.XDMCD modified, bold;
    return;
  end

   /* TT#4654  SPAIN CHANGES  End   **************/

  if (SQLCA.VAGen_SQLCODE == 0)
    if (OP0HW01.OP0HWBBD != " ") /* blank/finished draw*/
      OP0HSGD(); /* edit finished style*/
    end
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      OPAREC.OPAERR = "Y";
      set OP0HM010.SY1STNBR cursor, modified, bold;
      set OP0HM010.SY2CLRID modified, bold;
      set OP0HM010.XDMCD modified, bold;
      return;
    end
  end

   /* -----------------------------------------------------------*/
    /* Make sure that product has the same brand as the order.*/
   /* -----------------------------------------------------------*/
  if (SYCREC.XBCCD != OP1REC.XBCCD)
    OPAREC.OPAERR = "Y";
    converseLib.validationFailed(586); /* Brand of product does not match*/
    set OP0HM010.SY1STNBR cursor, modified, bold;
    set OP0HM010.SY2CLRID modified, bold;
    set OP0HM010.XDMCD modified, bold;
    return;
  end

   /* ---------------------------------------------------------*/
   /* equipment check*/
   /* ---------------------------------------------------------*/

  OP0HS-CHECK-EQMT(); /* call to eu0100*/
  if (WEU0100.WEU0100-EQUIP-PROD-FL == "Y")
    OPWREC01.XPCCK = WEU0100.XPCCD;
  else
    OPWREC01.XPCCK = "  ";
  end


  OPWREC01.XOTCK = "N";
  OP0HW01.OP0HWFND = "N";


   /* **********TCS INCLUDE BEGIN***********/

  set VXVO0001 empty;
  set SQLCA empty;
  VXVO0001.XOBCD = OP1REC.XOBCD; /**/
  VXVO0001.XGPCD = OP1REC.XGPCD;
  VXVO0001.XSOCD = OP1REC.XSOCD;
  VXVO0001.XDVCD = OP1REC.XDVCD;
  VXVO0001.XBCCD = OP1REC.XBCCD;
  VXVO0001.XPC-PROD-CAT-CD = OPWREC01.XPCCK;
  VXVO0001.XXXSTAT = "A";

  call "VXVO0001" ("S4", SQLCA, VXVO0001) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE != 0)
    TA1REC.TA1DBASE = "DCORP";
    TA1REC.TA1TBLVU = "VXVO0001";
    TA1REC.TA1TBLKE = VXVO0001-KEY;
    TA1REC.TA1LOCAT[3] = "OP0HSGB";
    TA1REC.TA1LOCAT[4] = "VXVO0001";
    XSOPS02();
  else
    call "VXVO0001" ("N4", SQLCA, VXVO0001) {isNoRefresh = yes, isExternal = yes};

    if (SQLCA.VAGen_SQLCODE == 0)
      if (VXVO0001.XOTCD != OP1REC.XOTCD)
        OPWREC01.XOTCK = "Y";
      end
      OP0HW01.OP0HWFND = "Y"; /* reset flag*/
    else
      if (SQLCA.VAGen_SQLCODE == +100)
        /* next sentence*/
      else
        TA1REC.TA1DBASE = "DCORP";
        TA1REC.TA1TBLVU = "VXVO0001";
        TA1REC.TA1TBLKE = VXVO0001-KEY;
        TA1REC.TA1LOCAT[3] = "OP0HSGB";
        TA1REC.TA1LOCAT[4] = "VXVO0001";
        XSOPS02();
      end
    end
  end

  call "VXVO0001" ("C4", SQLCA, VXVO0001) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE != 0)
    TA1REC.TA1DBASE = "DCORP";
    TA1REC.TA1TBLVU = "VXVO0001";
    TA1REC.TA1TBLKE = VXVO0001-KEY;
    TA1REC.TA1LOCAT[3] = "OP0HSGB";
    TA1REC.TA1LOCAT[4] = "VXVO0001";
    XSOPS02();
  end

   /* **********TCS INCLUDE END***********/

  if (OP0HW01.OP0HWFND == "N")
    if (OPWREC01.XPCCK > "  ")
      converseLib.validationFailed(923); /* prod cat/ot not valid so, etc*/
      OPAREC.OPAERR = "Y";
      OP0HW01.OP0HWSFL = "Y";
      return;
    else
      converseLib.validationFailed(482); /* Invalid system order type*/
      OPAREC.OPAERR = "Y";
      OP0HW01.OP0HWSFL = "Y";
      return;
    end
  end


  if (OPWREC01.XOTCK == "Y")
    converseLib.validationFailed(939); /* prod not valid for order type*/
    OPAREC.OPAERR = "Y";
    OP0HW01.OP0HWSFL = "Y";
    return;
  end

        /* check if cust has own style numbers. if so go*/
        /* get number.*/

  if (KUCREC.CU-PRT-XREF-FL == "Y") /* print cust xref flag turned on*/
    if (OPWREC.KUCSKIND == "C" /* if indicator set*/
     || OPWREC.KUCSKIND == "T" 
     || OPWREC.KUCSKIND == "P" 
     || OPWREC.KUCSKIND == "R" 
     || OPWREC.KUCSKIND == "G")
      set WCU1710 empty;

      WCU1710.WCU1710-INQUIRY-OPTION = 2; /* xref info*/
      WCU1710-IN-CU-CO-ID = OP1REC.KUCCOID;
      WCU1710-XNX-DEPT-ID-XREF = OP1REC.XNXCD;
      WCU1710-IN-XGP-GPC-CD = OP1REC.XGPCD;
      WCU1710-IN-SY-STY-NBR = OP0HM010.SY1STNBR;
      WCU1710-IN-SY-COLR-CD-ID = OP0HM010.SY2CLRID;
      WCU1710-IN-XDM-DIM-CD = OP0HM010.XDMCD;
      WCU1710-IN-XQA-QUAL-CD = OP0HM010.XQACD;

      WCU1710-RETURN-CODE = 99;

      call "CU1710" (WCU1710) {isNoRefresh = yes, isExternal = yes}; /* i/o mod-select scan*/

       /* check db2 return code*/

      if (WCU1710.WCU1710-RETURN-CODE == 0)
        OPWREC.KUIPRDID[1] = WCU1710.CU-CUST-PROD-ID[1];
        OP0HM010.KUIPRDID = WCU1710.CU-CUST-PROD-ID[1];
      else
        if (WCU1710.WCU1710-RETURN-CODE == 1) /* check for not found*/
          OPWREC.KUIPRDID[1] = " ";
        else
          TA1REC.TA1LOCAT[1] = "CU1710  "; /* i/o mod name*/
          TA1REC.TA1LOCAT[2] = "OP0HSGB "; /* statement group*/
          TA1REC.TA1LOCAT[3] = "        ";
          TA1REC.TA1LOCAT[4] = "        ";
          TAEREC.TAEDESC1 = "BAD RETURN FROM CU1710 - RETURN CODE=";
          TAEREC.TAEDESC2 = WCU1710.WCU1710-RETURN-CODE;
          TA1REC.TA1TYPE = "APPL"; /* abend type*/
          TA1REC.TA1FUNC = "RETN"; /* abend func*/
          VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
          VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
          sysLib.rollback();
          VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
           /* synpoint rollback*/
          try
            call "TA0020" (TA1REC, TAEREC) {isExternal = yes};
          end /* abend module*/
          COMMAREA.CA-USER-WORKAREA-4K = " "; /* clear user commarea*/
          XSPF4(); /* master menu*/
          exit program;
        end
      end
    end
  end

  OP0HSLB(); /* check if style is restricted from*/
                                   /* sales office*/

  if (OPAREC.OPAERR == "Y") /* style is restricted*/
    set OP0HM010.SY1STNBR cursor, modified, bold;
    set OP0HM010.SY2CLRID modified, bold;
    set OP0HM010.XDMCD modified, bold;
    return;
  end

          /* life cycle code check*/
    /* skip lifecycle edit if cust or rebook draw order.*/

  if (OP0HW01.OP0HWBDF == "C"
   || OP0HW01.OP0HWBDF == "R")
     /* next sentence*/
  else
    OP0HSG2();
  end

  if (OPAREC.OPAERR == "Y") /* bad life cycle code*/
    set OP0HM010.SY1STNBR cursor, modified, bold;
    set OP0HM010.SY2CLRID modified, bold;
    set OP0HM010.XDMCD modified, bold;
    return;
  end

   /* if not a draw order, edits are complete, exit.*/


  if (OP0HW01.OP0HWBDF != "C"
   && OP0HW01.OP0HWBDF != "R"
   && OP0HW01.OP0HWBDF != "S"
   && OP0HW01.OP0HWBDF != "X")
    OPWREC.XDMCD[1] = OP0HM010.XDMCD;
    OPWREC.SY1STNBR[1] = OP0HM010.SY1STNBR;
    OPWREC.SY2CLRID[1] = OP0HM010.SY2CLRID;
    return;
  end

   /* need to see that product exists on bulk order.*/

  OP0HSH1();

  if (OP0HW01.OP0HWFND == "Y") /* if found the style*/
    OPWREC.OPWBKLIN[1] = OP2REC.OP2LNINB;
    OPWREC.OP1NORID[1] = OP2REC.OP1NORID;
    if (OP0HWBDF == "C" /* if customer draw*/
     || OP0HWBDF == "R" /* or rebook draw*/
     || OP0HWBDF == "X") /* or flexible draw*/
      if (OP2REC.OP2TONOQ == 0) /* if no qty to order*/
        converseLib.validationFailed(291);
        OPAREC.OPAERR = "Y";
        set OP0HM010.SY1STNBR cursor, modified, bold;
        set OP0HM010.SY2CLRID modified, bold;
        set OP0HM010.XDMCD modified, bold;
      else
        OPWREC.SY1STNBR[1] = OP0HM010.SY1STNBR;
        OPWREC.SY2CLRID[1] = OP0HM010.SY2CLRID;
        OPWREC.XDMCD[1] = OP0HM010.XDMCD;
      end
    else
      if (OP0HWBDF == "S") /* if smart draw*/
        if (OP2REC.OP2TOHRQ == 0) /* if no qty to order*/
          converseLib.validationFailed(282);
          OPAREC.OPAERR = "Y";
          set OP0HM010.SY1STNBR cursor, modified, bold;
          set OP0HM010.SY2CLRID modified, bold;
          set OP0HM010.XDMCD modified, bold;
        else
          OPWREC.SY1STNBR[1] = OP0HM010.SY1STNBR;
          OPWREC.SY2CLRID[1] = OP0HM010.SY2CLRID;
          OPWREC.XDMCD[1] = OP0HM010.XDMCD;
        end
      end
    end
    if (OP0HM010.XPGCD == OP2REC.XPGCD)
      OPWREC.XPGCD[1] = OP0HM010.XPGCD;
    else
      converseLib.validationFailed(326);
      OPWREC.XPGCD[1] = OP2REC.XPGCD;
      OP0HM010.XPGCD = OP2REC.XPGCD;
    end
    if (OP0HM010.PC2INSEG == OP2REC.PC2INSEG)
      OPWREC.PC2INSEG[1] = OP0HM010.PC2INSEG;
    else
      converseLib.validationFailed(972); /* size out of range for order type*/
      OPWREC.PC2INSEG[1] = OP2REC.PC2INSEG;
      OP0HM010.PC2INSEG = OP2REC.PC2INSEG;
    end
  else
    OPAREC.OPAERR = "Y";
    converseLib.validationFailed(285);
    set OP0HM010.SY1STNBR cursor, modified, bold;
    set OP0HM010.SY2CLRID modified, bold;
    set OP0HM010.XDMCD modified, bold;
    return;
  end


end // end OP0HSGB

// edit single cust style
Function OP0HSGC()

           /* edit customer style number*/

    /* read customer style record*/

  set WCU1710 empty;

  WCU1710.WCU1710-INQUIRY-OPTION = 2; /* xref info w/ovrds*/
  WCU1710-IN-CU-CO-ID = OP1REC.KUCCOID;
  WCU1710-XNX-DEPT-ID-XREF = OP1REC.XNXCD; /* move dept code*/
  WCU1710-IN-CU-CUST-PROD-ID = OP0HM010.KUIPRDID;

  WCU1710-RETURN-CODE = 99;

  call "CU1710" (WCU1710) {isNoRefresh = yes, isExternal = yes}; /* i/o mod-select scan*/

   /* check db2 return code*/

  if (WCU1710.WCU1710-RETURN-CODE == 0)
     /* next sentence*/
  else
    if (WCU1710.WCU1710-RETURN-CODE == 1 /* check for not found*/
     || WCU1710.WCU1710-RETURN-CODE == 9) /* or not xref customer*/
      converseLib.validationFailed(133);
      OPAREC.OPAERR = "Y";
      set OP0HM010.KUIPRDID cursor, modified, bold;
      return;
    else
      TA1REC.TA1LOCAT[1] = "CU1710  "; /* i/o mod name*/
      TA1REC.TA1LOCAT[2] = "OP0HSGC "; /* statement group*/
      TA1REC.TA1LOCAT[3] = "        ";
      TA1REC.TA1LOCAT[4] = "        ";
      TAEREC.TAEDESC1 = "BAD RETURN FROM CU1710 - RETURN CODE=";
      TAEREC.TAEDESC2 = WCU1710.WCU1710-RETURN-CODE;
      TA1REC.TA1TYPE = "APPL"; /* abend type*/
      TA1REC.TA1FUNC = "RETN"; /* abend func*/
      VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
      VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
      sysLib.rollback();
      VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
       /* synpoint rollback*/
      try
        call "TA0020" (TA1REC, TAEREC) {isExternal = yes};
      end /* abend module*/
      COMMAREA.CA-USER-WORKAREA-4K = " "; /* clear user commarea*/
      XSPF4(); /* master menu*/
      exit program;
    end
  end

    /* move the first occurance with style information*/

  OP0HW01.SY1STNBR = WCU1710.SY-STY-NBR[1];
  OP0HM010.SY1STNBR = WCU1710.SY-STY-NBR[1];
  OP0HW01.SY2CLRID = WCU1710.SY-COLR-CD-ID[1];
  OP0HM010.SY2CLRID = WCU1710.SY-COLR-CD-ID[1];
  OP0HW01.XDMCD = WCU1710.XDM-DIM-CD[1];
  OP0HM010.XDMCD = WCU1710.XDM-DIM-CD[1];

  OP0HSG1(); /* read nike style/color record*/

  if (SQLCA.VAGen_SQLCODE == 0)
    if (OP0HW01.OP0HWBBD != " ") /* blank/finished draw*/
      OP0HSGD();
    end
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      converseLib.validationFailed(133);
      OPAREC.OPAERR = "Y";
      OP0HM010.SY1STNBR = " ";
      OP0HM010.SY2CLRID = " ";
      OP0HM010.XDMCD = " ";
      set OP0HM010.KUIPRDID cursor, modified, bold;
      return;
    end
  end
   /* -----------------------------------------------------------*/
    /* Make sure that product has the same brand as the order.*/
   /* -----------------------------------------------------------*/
  if (SYCREC.XBCCD != OP1REC.XBCCD)
    OPAREC.OPAERR = "Y";
    converseLib.validationFailed(586); /* Product brand does not match*/
    OP0HM010.SY1STNBR = " ";
    OP0HM010.SY2CLRID = " ";
    OP0HM010.XDMCD = " ";
    set OP0HM010.KUIPRDID cursor, modified, bold;
    return;
  end

    /* check customer style gpc to order gpc*/

  if (OP1REC.XGPCD != WCU1710.XGP-GPC-CD)
    converseLib.validationFailed(134);
    OPAREC.OPAERR = "Y";
    return;
  end

      /* check life cycle code for cust style*/

  if (OP0HW01.OP0HWBDF == "C" /* don't edit life cycle for cust draw*/
   || OP0HW01.OP0HWBDF == "R") /* or rebook draw*/
     /* next sentence*/
  else
    OP0HSG2();
  end

  if (converseVar.validationMsgNum == 132) /* bad life cycle code*/
    OP0HM010.SY1STNBR = " ";
    OP0HM010.SY2CLRID = " ";
    OP0HM010.XDMCD = " ";
    set OP0HM010.KUIPRDID cursor, modified, bold;
    return;
  end

   /* if not a draw order, edits are complete, exit.*/

  if (OP0HW01.OP0HWBDF != "C" /* cust draw*/
   && OP0HW01.OP0HWBDF != "R" /* rebook draw*/
   && OP0HW01.OP0HWBDF != "S" /* smart draw*/
   && OP0HW01.OP0HWBDF != "X") /* flexible draw*/
    OPWREC.SY1STNBR[1] = SYCREC.SY1STNBR;
    OPWREC.SY2CLRID[1] = SYCREC.SY2CLRID;
    OPWREC.XDMCD[1] = SYCREC.XDMCD;
    OPWREC.KUIPRDID[1] = OP0HM010.KUIPRDID;
    return;
  end

   /* need to see that product exists on bulk order.*/

  OP0HSH1();

  if (OP0HW01.OP0HWFND == "Y") /* if found the style*/
    OPWREC.OPWBKLIN[1] = OP2REC.OP2LNINB;
    OPWREC.OP1NORID[1] = OP2REC.OP1NORID;
    if (OP0HWBDF == "C" /* if customer draw*/
     || OP0HWBDF == "R" /* if rebook draw*/
     || OP0HWBDF == "X") /* if flexible draw*/
      if (OP2REC.OP2TONOQ == 0) /* if no qty to order*/
        converseLib.validationFailed(291);
        OPAREC.OPAERR = "Y";
        OP0HM010.SY1STNBR = " ";
        OP0HM010.SY2CLRID = " ";
        OP0HM010.XDMCD = " ";
        set OP0HM010.KUIPRDID cursor, modified, bold;
      else
        OPWREC.XDMCD[1] = SYCREC.XDMCD;
        OPWREC.SY1STNBR[1] = SYCREC.SY1STNBR;
        OPWREC.SY2CLRID[1] = SYCREC.SY2CLRID;
        OPWREC.KUIPRDID[1] = OP0HM010.KUIPRDID;
      end
    else
      if (OP0HWBDF == "S") /* if smart draw*/
        if (OP2REC.OP2TOHRQ == 0) /* if no qty to order*/
          converseLib.validationFailed(282);
          OPAREC.OPAERR = "Y";
          OP0HM010.SY1STNBR = " ";
          OP0HM010.SY2CLRID = " ";
          OP0HM010.XDMCD = " ";
          set OP0HM010.KUIPRDID cursor, modified, bold;
        else
          OPWREC.XDMCD[1] = SYCREC.XDMCD;
          OPWREC.SY1STNBR[1] = SYCREC.SY1STNBR;
          OPWREC.SY2CLRID[1] = SYCREC.SY2CLRID;
          OPWREC.KUIPRDID[1] = OP0HM010.KUIPRDID;
        end
      end
    end
  else
    OPAREC.OPAERR = "Y";
    converseLib.validationFailed(285);
    OP0HM010.SY1STNBR = " ";
    OP0HM010.SY2CLRID = " ";
    OP0HM010.XDMCD = " ";
    set OP0HM010.KUIPRDID cursor, modified, bold;
  end

end // end OP0HSGC

// edit finished style single pro
Function OP0HSGD()

  set SQLCA empty;
  set AVHREC empty;

  AVHREC.XOWCD = OPWREC.XOWCD;
  AVHREC.SY1STNBR = OP0HM010.SY1STNBR;
  AVHREC.SY2CLRID = OP0HM010.SY2CLRID;
  AVHREC.XDMCD = OP0HM010.XDMCD;

  call "IO5470" ("S ", SQLCA, AVHREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
     /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      converseLib.validationFailed(629);
      OP0HW01.OP0HWSFL = "Y";
      OPAREC.OPAERR = "Y";
      set OP0HM010.SY1STNBR cursor, modified, bold;
    else
      TA1REC.TA1TYPE = "DB2 ";
      TA1REC.TA1PGMNM = "OP0H   "; /* application*/
      TA1REC.TA1LOCAT[1] = "OP0HSGD "; /* statement group*/
      TA1REC.TA1LOCAT[2] = "IO5470  "; /* io mod called*/
      TA1REC.TA1LOCAT[3] = "S "; /* function code used*/
      TA1REC.TA1LOCAT[4] = AVHREC.AVHKEY; /* avhrec key*/
      TA1REC.TA1MAP = "OP0HM010"; /* map*/
      TA1REC.TA1DBASE = "DAVAIL"; /* database name*/
      TA1REC.TA1TBLVU = "VBLNKS01"; /* table view*/
      TA1REC.TA1TBLKE = AVHREC.AVHKEY; /* key*/
      VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
      VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
      sysLib.rollback();
      VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
      
      call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
      XSPF4();
    end
  end

   /* ************************************************************/
end // end OP0HSGD

// edit first/last size
Function OP0HSGE()
         /* single product header screen*/


         /* this sgrp edits the first and last sizes from the*/
         /* single product header screen. the front end does*/
         /* some checking and defaulting before we get into*/
         /* the actual edits.*/

         /* front end:   1. if dup flag not 'y' or 'n'*/
                            /* error, exit.*/
                      /* 2. if sizes required and no sizes*/
                            /* ERROR, EXIT.*/
                      /* 3. if dup flag set to yes*/
                            /* set duplicates*/
                      /* 4. if any sizes missing*/
                            /* default sizes*/

         /* size edits:  1. edit entered map size for format*/
                      /* 2. check size division codes*/
                      /* 3. see if size division match allowable*/
                          /* division codes from ordr typ table.*/
                      /* 4. check size fringe/gut indicators*/
                      /* 5. first size cant be greater then last*/
                      /* 6. for draw orders, first/last sizes*/
                         /* must be on the bulk order drawn from.*/


       /* note: mdt use for the sizes is not complete. i don't*/
             /* reset them for converses. one reason is, when*/
             /* this sgrp is invoked, both sizes are edited no*/
             /* matter if only one was entered or touched.*/
             /* the other reason is, i always invoke this sgrp*/
             /* if sizes were touched or if no defaults have*/
             /* been placed into the ws product array yet.*/


   /* get the op3rec for edits.*/

  if (OP0HW01.OP0HWBDF == "C" /* cust draw*/
   || OP0HW01.OP0HWBDF == "R" /* rebook draw*/
   || OP0HW01.OP0HWBDF == "S" /* smart draw*/
   || OP0HW01.OP0HWBDF == "X") /* flexible draw*/
    OP3REC.OP2KEY = OP2REC.OP2KEY;
    OP8REC.OP8TASK = "S ";
    call "DB1000" (OP8REC, OP3REC, OPBREC) {isNoRefresh = yes, isExternal = yes};
    if (OPBREC.OPBSZRC == 0)
      /* next sentence*/
    else
      TA1REC.TA1TYPE = "DB2 ";
      TA1REC.TA1FUNC = "RETN";
      TA1REC.TA1PGMNM = "OP0H    ";
      TA1REC.TA1LOCAT[1] = "S       ";
      TA1REC.TA1LOCAT[2] = "OP0HSGE ";
      TA1REC.TA1LOCAT[3] = "DB1000  ";
      TA1REC.TA1LOCAT[4] = "        ";
      TA1REC.TA1MAP = "OP0HM010";
      TA1REC.TA1DBASE = "DORDER  ";
      TA1REC.TA1TBLVU = "VOSIZE01";
      OP0HW01.OP0HWDK1 = OP3REC.OP1PARTN;
      OP0HW01.OP0HWDK2 = OP3REC.OP1CUOID;
      OP0HW01.OP0HWDK3 = OP3REC.OP1NORID;
      OP0HW01.OP0HWDK4 = OP3REC.OP2LNINB;
      OP0HW01.OP0HWDK5 = " ";
      OP0HW01.OP0HWDK6 = " ";
      OP0HW01.OP0HWDK7 = OPBREC.OPBSZRC;
      TA1REC.TA1TBLKE = OP0HW01.OP0HWDKY;
      call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
      COMMAREA.CA-USER-WORKAREA-4K = " "; /* clear ws on error*/
      XSPF4();
      exit program;
    end
  end








    /* first check if dup flag is valid*/

  if (OP0HM010.OP0HMDPS == "N"
   || OP0HM010.OP0HMDPS == "Y")
     /* next sentence*/
  else
    set OP0HM010.OP0HMDPS cursor, modified, bold;
    OPAREC.OPAERR = "Y";
    converseLib.validationFailed(140);
    return;
  end







    /* next check if sizes are required.(if xszcd entered,*/
                                      /* require sizes)*/
          /* if so make sure either they were entered*/
           /* or that the duplicate sizes flag was set to 'y'*/
             /* if nothing entered but are required -- error*/
             /* else go on with edit*/
          /* else go on with edit.*/


   /* F OP0HM010.XSZCD GT ' ';*/
   /* IF OP0HM010.OP0HMDPS EQ 'Y';    /* if dup sizes*/
     /* ; /* next sentence                   ; ok -- go on*/
   /* ELSE;*/
     /* IF OP0HM010.OP0HMFSZ GT ' '*/
       /* AND OP0HM010.OP0HMLSZ GT ' ';*/
       /* ; /* next sentence*/
     /* ELSE;*/
       /* MOVE 146 TO EZEMNO;         /* required fields msg*/
       /* MOVE 'Y' TO OPAREC.OPAERR;  /* set error flag*/
       /* SET OP0HM010.OP0HMFSZ CURSOR,MODIFIED,BRIGHT;*/
       /* SET OP0HM010.OP0HMLSZ MODIFIED,BRIGHT;*/
       /* SET OP0HM010.OP0HMDPS MODIFIED,BRIGHT;*/
       /* EZERTN;*/
     /* END;*/
   /* END;*/
   /* ND;*/







   /* see if dup flag on, if so try to dup f/l sizes*/
      /* the logic goes as follows:*/
        /* 1. Try to dup sizes from last set of products*/
           /* entered. if none to dup, msg, else use the*/
           /* sizes found.*/






  if (OP0HM010.OP0HMDPS == "Y")
    if (OP0HW01.OP0HWPSD == "Y") /* if szs from prev map*/
      OP0HM010.OP2TORGQ = OP0HW01.OP2TORGQ;
      if (OP0HW01.XOTSZIND == "I") /* if need integer sizes*/
        OP0HM010.OP0HMFSZ = OP0HW01.OP0HWFDI; /* int size*/
        OP0HM010.OP0HMLSZ = OP0HW01.OP0HWLDI;
      else
        OP0HM010.OP0HMFSZ = OP0HW01.OP0HWFDD; /* desc size*/
        OP0HM010.OP0HMLSZ = OP0HW01.OP0HWLDD;
      end
    else /* no sizes to dup error*/
      set OP0HM010.OP0HMDPS cursor, modified, bold;
      OPAREC.OPAERR = "Y";
      converseLib.validationFailed(147);
      return;
    end
  end


  OPWREC.OPWDUPSZ[1] = OP0HM010.OP0HMDPS; /* save dup flag*/





   /* check if descriptive sizes, if so read the size scale*/
   /* record for later use.*/



  if (OP0HW01.XOTSZIND == "D") /* if descriptive sizes*/
    SY4REC.SY4SZSCL = SYCREC.SY4SZSCL;
    call "IO0040" ("S ", SQLCA, SY4REC) {isNoRefresh = yes, isExternal = yes};
    if (SQLCA.VAGen_SQLCODE == 0)
       /* next sentence*/
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence              *************************/
      else
        TA1REC.TA1TYPE = "DB2 ";
        TA1REC.TA1FUNC = "RETN";
        TA1REC.TA1PGMNM = "OP0H    ";
        TA1REC.TA1LOCAT[1] = "S       ";
        TA1REC.TA1LOCAT[2] = "OP0HSDE ";
        TA1REC.TA1LOCAT[3] = "IO0040  ";
        TA1REC.TA1LOCAT[4] = "        ";
        TA1REC.TA1MAP = "OP0HM005";
        TA1REC.TA1DBASE = "SY4REC  ";
        TA1REC.TA1TBLVU = "VSCALE01";
        TA1REC.TA1TBLKE = SY4REC.SY4SZSCL;
        call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes};
        COMMAREA.CA-USER-WORKAREA-4K = " "; /* on error, clear ws*/
        XSPF4();
        exit program;
      end
    end
  end






   /* next check whether both sizes are entered.*/
       /* if not default the missing one. if order*/
       /* is a draw order, default from bulk order*/
       /* else default from style record.*/



  if (OP0HM010.OP0HMFSZ > " ")
    if (OP0HM010.OP0HMLSZ > " ")
       /* next sentence*/
    else
      if (OP0HW01.OP0HWBDF == "C" /* cust draw*/
       || OP0HW01.OP0HWBDF == "R" /* rebook draw*/
       || OP0HW01.OP0HWBDF == "S" /* smart draw*/
       || OP0HW01.OP0HWBDF == "X") /* flexible draw*/
        OP0HSH4(); /* default last from bulk*/
      else
        OP0HSG4(); /* default last size from style*/
      end
      if (OPAREC.OPAERR == "N") /* if no error*/
        if (OP0HW01.XOTSZIND == "D") /* if need desc sizes*/
          OP0HM010.OP0HMLSZ = SY4REC.SY4IDDSC[OP0HWLSZ];
        else
          OP0HM010.OP0HMLSZ = OP0HW01.OP0HWLSZ;
        end
      end
    end
  else
    if (OP0HM010.OP0HMLSZ > " ")
      if (OP0HW01.OP0HWBDF == "C" /* cust draw*/
       || OP0HW01.OP0HWBDF == "R" /* rebook draw*/
       || OP0HW01.OP0HWBDF == "S" /* smart draw*/
       || OP0HW01.OP0HWBDF == "X") /* flexible draw*/
        OP0HSH3(); /* default first from bulk*/
      else
        OP0HSG3(); /* default first size from style*/
      end
      if (OPAREC.OPAERR == "N") /* if no error*/
        if (OP0HW01.XOTSZIND == "D") /* if need desc sizes*/
          OP0HM010.OP0HMFSZ = SY4REC.SY4IDDSC[OP0HWFSZ];
        else
          OP0HM010.OP0HMFSZ = OP0HW01.OP0HWFSZ;
        end
      end
    else
      if (OP0HW01.OP0HWBDF == "C" /* cust draw*/
       || OP0HW01.OP0HWBDF == "R" /* rebook draw*/
       || OP0HW01.OP0HWBDF == "S" /* smart draw*/
       || OP0HW01.OP0HWBDF == "X") /* flexible draw*/
        OP0HSH3(); /* default both from bulk*/
        OP0HSH4();
      else
        OP0HSG3(); /* default both from style*/
        OP0HSG4();
        if (OPAREC.OPAERR == "N") /* if no error*/
          if (OP0HW01.XOTSZIND == "D") /* if need desc sizes*/
            OP0HM010.OP0HMFSZ = SY4REC.SY4IDDSC[OP0HWFSZ];
            OP0HM010.OP0HMLSZ = SY4REC.SY4IDDSC[OP0HWLSZ];
          else
            OP0HM010.OP0HMFSZ = OP0HW01.OP0HWFSZ;
            OP0HM010.OP0HMLSZ = OP0HW01.OP0HWLSZ;
          end
          return; /* exit if default from bulk, no edits needed*/
        end
      end
      if (OPAREC.OPAERR == "N") /* if no error*/
        if (OP0HW01.XOTSZIND == "D") /* if need desc sizes*/
          OP0HM010.OP0HMFSZ = SY4REC.SY4IDDSC[OP0HWFSZ];
          OP0HM010.OP0HMLSZ = SY4REC.SY4IDDSC[OP0HWLSZ];
        else
          OP0HM010.OP0HMFSZ = OP0HW01.OP0HWFSZ;
          OP0HM010.OP0HMLSZ = OP0HW01.OP0HWLSZ;
        end
      end
    end
  end



  if (OPAREC.OPAERR == "Y") /* if error*/
    set OP0HM010.SY1STNBR modified; /* to trigger re-edit*/
    OP0HSG9(); /* setup size error message*/
    return;
  end





   /* now start edits on the sizes themselves*/
    /* as these edits progress, you can only*/
    /* go to the next edit if the previous one was good.*/





    /* size edit number 1*/
       /* based on the size input formats, verify sizes*/


  if (OP0HW01.XOTSZIND == "I")
    OP0HSG5(); /* edit numeric sizes*/
  else
    OP0HSG6(); /* edit alpha sizes*/
  end


  if (OPAREC.OPAERR == "Y") /* if error*/
    OP0HSG9(); /* setup size error message*/
    return;
  end




   /* size edit number 2*/
        /* check size division code for both first and last*/


  if (SYCREC.XDVCD[OP0HWLSZ] == " ")
    OPAREC.OPAERR = "Y";
    set OP0HM010.OP0HMLSZ cursor, modified, bold;
  end


  if (SYCREC.XDVCD[OP0HWFSZ] == " ")
    OPAREC.OPAERR = "Y";
    set OP0HM010.OP0HMFSZ cursor, modified, bold;
  end


  if (OPAREC.OPAERR == "Y") /* if error*/
    OP0HSG9(); /* setup size error message*/
    return;
  end




    /* edit check number 3*/
      /* match style div to allowed divs for order type*/
      /* for both first and last sizes.*/

    /* first make sure that the xottbl.allowed/disallowed*/
    /* division code = a or d.*/

  if (OP1REC.XOTCD in XOTTBL.XOTCD)
    if (XOTTBL.XOTALWDV[sysVar.arrayIndex] == "A"
     || XOTTBL.XOTALWDV[sysVar.arrayIndex] == "D")
       /* next sentence--ok good values, keep going*/
    else
      OPAREC.OPAERR = "Y";
      set OP0HM010.OP0HMLSZ cursor, modified, bold;
      set OP0HM010.OP0HMFSZ cursor, modified, bold;
      OP0HSG9(); /* setup size error message*/
      return;
    end
  end


   /* ----------------------------------------------------*/
         /* last-size check*/
   /* if flag = a (allowed) and the product division equals one*/
   /* of the order type's allowable divisions, it's ok*/
   /* else it's an error*/
   /* ----------------------------------------------------*/

  if (XOTTBL.XOTALWDV[sysVar.arrayIndex] == "A")
    if (SYCREC.XDVCD[OP0HWLSZ] == XOTTBL.XDVCD1[sysVar.arrayIndex]
     || SYCREC.XDVCD[OP0HWLSZ] == XOTTBL.XDVCD2[sysVar.arrayIndex]
     || SYCREC.XDVCD[OP0HWLSZ] == XOTTBL.XDVCD3[sysVar.arrayIndex]
     || SYCREC.XDVCD[OP0HWLSZ] == XOTTBL.XDVCD4[sysVar.arrayIndex]
     || SYCREC.XDVCD[OP0HWLSZ] == XOTTBL.XDVCD5[sysVar.arrayIndex])
       /* next sentence*/
    else
      OPAREC.OPAERR = "Y";
      set OP0HM010.OP0HMLSZ cursor, modified, bold;
    end
  end
       /* ----------------------------------------------------*/
       /* if flag = d (disallowed) this order type restricts*/
       /* the divisions listed from the product.  if no match,*/
       /* it's good; if there is a match, it's an error*/
       /* ----------------------------------------------------*/
  if (XOTTBL.XOTALWDV[sysVar.arrayIndex] == "D")
    if (SYCREC.XDVCD[OP0HWLSZ] == XOTTBL.XDVCD1[sysVar.arrayIndex]
     || SYCREC.XDVCD[OP0HWLSZ] == XOTTBL.XDVCD2[sysVar.arrayIndex]
     || SYCREC.XDVCD[OP0HWLSZ] == XOTTBL.XDVCD3[sysVar.arrayIndex]
     || SYCREC.XDVCD[OP0HWLSZ] == XOTTBL.XDVCD4[sysVar.arrayIndex]
     || SYCREC.XDVCD[OP0HWLSZ] == XOTTBL.XDVCD5[sysVar.arrayIndex])
      OPAREC.OPAERR = "Y";
      set OP0HM010.OP0HMLSZ cursor, modified, bold;
    end
  end



   /* ----------------------------------------------------*/
       /* first-size check*/
   /* if flag = a (allowed) and the product division equals one*/
   /* of the order type's allowable divisions, it's ok*/
   /* else it's an error*/
   /* ----------------------------------------------------*/
  if (XOTTBL.XOTALWDV[sysVar.arrayIndex] == "A")
    if (SYCREC.XDVCD[OP0HWFSZ] == XOTTBL.XDVCD1[sysVar.arrayIndex]
     || SYCREC.XDVCD[OP0HWFSZ] == XOTTBL.XDVCD2[sysVar.arrayIndex]
     || SYCREC.XDVCD[OP0HWFSZ] == XOTTBL.XDVCD3[sysVar.arrayIndex]
     || SYCREC.XDVCD[OP0HWFSZ] == XOTTBL.XDVCD4[sysVar.arrayIndex]
     || SYCREC.XDVCD[OP0HWFSZ] == XOTTBL.XDVCD5[sysVar.arrayIndex])
       /* next sentence*/
    else
      OPAREC.OPAERR = "Y";
      set OP0HM010.OP0HMFSZ cursor, modified, bold;
    end
  end
       /* ----------------------------------------------------*/
       /* if flag = d (disallowed) this order type restricts*/
       /* the divisions listed from the product.  if no match,*/
       /* it's good; if there is a match, it's an error*/
       /* ----------------------------------------------------*/
  if (XOTTBL.XOTALWDV[sysVar.arrayIndex] == "D")
    if (SYCREC.XDVCD[OP0HWFSZ] == XOTTBL.XDVCD1[sysVar.arrayIndex]
     || SYCREC.XDVCD[OP0HWFSZ] == XOTTBL.XDVCD2[sysVar.arrayIndex]
     || SYCREC.XDVCD[OP0HWFSZ] == XOTTBL.XDVCD3[sysVar.arrayIndex]
     || SYCREC.XDVCD[OP0HWFSZ] == XOTTBL.XDVCD4[sysVar.arrayIndex]
     || SYCREC.XDVCD[OP0HWFSZ] == XOTTBL.XDVCD5[sysVar.arrayIndex])
      OPAREC.OPAERR = "Y";
      set OP0HM010.OP0HMFSZ cursor, modified, bold;
    end
  end


  if (OPAREC.OPAERR == "Y") /* if error*/
    OP0HSG9(); /* setup size error message*/
    return;
  end






   /* edit check number 4*/
     /* check size fringe gut indicators*/


  if (XOTTBL.XOTXTRAS[sysVar.arrayIndex] == "Y") /* if order type allows extras*/
     /* next sentence*/
  else
    if (SYCREC.SY3FRGUT[OP0HWLSZ] == "X") /* if size is extra*/
      OPAREC.OPAERR = "Y";
      set OP0HM010.OP0HMLSZ cursor, modified, bold;
    end
  end


  if (XOTTBL.XOTXTRAS[sysVar.arrayIndex] == "Y") /* if order type allows extras*/
     /* next sentence*/
  else
    if (SYCREC.SY3FRGUT[OP0HWFSZ] == "X") /* if size is an extra*/
      OPAREC.OPAERR = "Y";
      set OP0HM010.OP0HMFSZ cursor, modified, bold;
    end
  end





   /* edit check number 5*/
     /* first size cannot be greater then last size*/


  if (OP0HW01.OP0HWFSZ > OP0HW01.OP0HWLSZ)
    converseLib.validationFailed(142);
    OPAREC.OPAERR = "Y";
    set OP0HM010.OP0HMFSZ cursor, modified, bold;
    set OP0HM010.OP0HMLSZ cursor, bold;
    return;
  end




                    /* size edit 6*/
     /* edit for bulk orders only.*/


  if (OP0HW01.OP0HWBDF == "C" /* cust draw*/
   || OP0HW01.OP0HWBDF == "R" /* rebook draw*/
   || OP0HW01.OP0HWBDF == "S" /* smart draw*/
   || OP0HW01.OP0HWBDF == "X") /* flexible draw*/
    OP0HSG8();
  end




  if (OPAREC.OPAERR == "Y") /* if error occured*/
    return; /* exit*/
  end







   /* IF GOT TO HERE ALL IS WELL SO LOAD F/L SIZE INTO WS TBL*/


  OPWREC.OPWRQSZF = OP0HW01.OP0HWFSZ;
  OPWREC.OPWRQSZL = OP0HW01.OP0HWLSZ;








end // end OP0HSGE

// edit single tot quantity
Function OP0HSGF()




          /* edit total quantity for this line item*/



  if (OP0HM010.OP2TORGQ > 0)
    OPWREC.OP2TONOQ[1] = OP0HM010.OP2TORGQ;
    set OP0HM010.OP2TORGQ initialAttributes;
   /* LSE;*/
   /* IF OP0HM010.XSZCD GT ' ';       /* qty req if szcd entered*/
     /* MOVE 287 TO EZEMNO;*/
     /* MOVE 'Y' TO OPAREC.OPAERR;*/
     /* SET OP0HM010.OP2TORGQ CURSOR,MODIFIED,BRIGHT;*/
     /* SET OP0HM010.XSZCD MODIFIED,BRIGHT;*/
     /* EZERTN;*/
   /* ELSE;*/
     /* MOVE 0 TO OPWREC.OP2TONOQ(1);*/
     /* SET OP0HM010.OP2TORGQ DEFINED;*/
   /* END;*/
  end




    /* for draw orders, total quantity must be less then*/
    /* or equal to the quantity on the original bulk order.*/


  if (OP0HW01.OP0HWBDF == "C" /* if customer draw order*/
   || OP0HW01.OP0HWBDF == "R" /* or rebook draw order*/
   || OP0HW01.OP0HWBDF == "X") /* or flexible draw order*/
    if (OP0HM010.OP2TORGQ <= OP2REC.OP2TONOQ)
      set OP0HM010.OP2TORGQ initialAttributes;
      OPWREC.OP2TONOQ[1] = OP0HM010.OP2TORGQ;
    else
      OPAREC.OPAERR = "Y";
      set OP0HM010.OP2TORGQ cursor, modified, bold;
      converseLib.validationFailed(288); /* not enough qty for draw*/
    end
  else
    if (OP0HW01.OP0HWBDF == "S") /* smart draw order*/
      if (OP0HM010.OP2TORGQ <= OP2REC.OP2TOHRQ)
        set OP0HM010.OP2TORGQ initialAttributes;
        OPWREC.OP2TONOQ[1] = OP0HM010.OP2TORGQ;
      else
        OPAREC.OPAERR = "Y";
        set OP0HM010.OP2TORGQ cursor, modified, bold;
        converseLib.validationFailed(288); /* not enough qty for draw*/
      end
    end
  end









end // end OP0HSGF

// edit single quality code
Function OP0HSGG()




         /* edit quality code*/


   /* first check if need to validate*/

  if (OP0HM010.XQACD is modified)
     /* next sentence*/
  else
    OPWREC.XQACD[1] = OP0HM010.XQACD; /* save for op0i call*/
    return;
  end



  if (OP1REC.XOTCD in XOTTBL.XOTCD)
    if (XOTTBL.XQACD1[sysVar.arrayIndex] == OP0HM010.XQACD)
      OPWREC.XQACD[1] = XOTTBL.XQACD1[sysVar.arrayIndex];
      set OP0HM010.XQACD initialAttributes;
    else
      if (XOTTBL.XQACD2[sysVar.arrayIndex] == OP0HM010.XQACD)
        OPWREC.XQACD[1] = XOTTBL.XQACD2[sysVar.arrayIndex];
        set OP0HM010.XQACD initialAttributes;
      else
        if (XOTTBL.XQACD3[sysVar.arrayIndex] == OP0HM010.XQACD)
          OPWREC.XQACD[1] = XOTTBL.XQACD3[sysVar.arrayIndex];
          set OP0HM010.XQACD initialAttributes;
        else
          converseLib.validationFailed(141);
          OPAREC.OPAERR = "Y";
          set OP0HM010.XQACD cursor, modified, bold;
        end
      end
    end
  end



   /* put quality code desc into map field*/

  if (OP0HM010.XQACD in XQATBL.XQACD)
    OP0HM010.XQAABRV = XQATBL.XQAABRV[sysVar.arrayIndex];
  end





end // end OP0HSGG

// edit single standard size
Function OP0HSGH()







    /* edit standard size distribution code*/


   /* F OP0HM010.XSZCD IS MODIFIED;*/
   /* IF OP0HM010.XSZCD GT ' ';*/
     /* ; /* next sentence*/
   /* ELSE;*/
     /* SET OP0HM010.XSZCD DEFINED;*/
     /* MOVE ' ' TO OPWREC.XSZCD(1);*/
     /* EZERTN;*/
   /* END;*/
   /* LSE;*/
   /* EZERTN;*/
   /* ND;*/




    /* if xszcd is valid and active*/
      /* if xsz number of sizes equals number of sizes between*/
               /* first and last sizes*/
         /* okay*/
      /* else;*/
         /* error*/
    /* else*/
      /* error*/



   /* F OP0HM010.XSZCD IN XSZTBL.XSZCD*/
   /* AND XSZTBL.XXXSTAT(EZETST) EQ 'A';*/
   /* IF XSZTBL.XSZNBRSZ(EZETST) EQ OP0HW01.OP0HWNAS(1);*/
     /* MOVE OP0HM010.XSZCD TO OPWREC.XSZCD(1);*/
     /* SET OP0HM010.XSZCD DEFINED;*/
   /* ELSE;*/
     /* MOVE 'Y' TO OPAREC.OPAERR;*/
     /* MOVE 289 TO EZEMNO;           /* number of sizes don't match*/
     /* SET OP0HM010.XSZCD CURSOR,MODIFIED,BRIGHT;*/
     /* EZERTN;*/
   /* END;*/
   /* LSE;*/
   /* MOVE 'Y' TO OPAREC.OPAERR;*/
   /* MOVE 290 TO EZEMNO;             /* invalid xszcd*/
   /* SET OP0HM010.XSZCD CURSOR,MODIFIED,BRIGHT;*/
   /* EZERTN;*/
   /* ND;*/










end // end OP0HSGH

// edit single package type
Function OP0HSGI()



            /* edit package type*/



  if (OP0HM010.XPGCD is modified)
    /* next sentence*/
  else
    if (OPWREC.XPGCD[1] > " ") /* if already has value*/
      return;
    else
      OPWREC.XPGCD[1] = "00";
      return;
    end
  end



  if (OP0HM010.XPGCD == " ")
                                   /* spaces is valid as package code*/
    OPWREC.XPGCD[1] = "00";
    OP0HM010.XPGABRV = "      ";
    set OP0HM010.XPGCD initialAttributes;
    return;
  end



  if (OP0HM010.XPGCD in XPGTBL.XPGCD)
    OP0HM010.XPGABRV = XPGTBL.XPGABRV[sysVar.arrayIndex];
    OPWREC.XPGCD[1] = OP0HM010.XPGCD;
    set OP0HM010.XPGCD initialAttributes;
  else
    converseLib.validationFailed(158);
    OPAREC.OPAERR = "Y";
    set OP0HM010.XPGCD cursor, modified, bold;
  end






end // end OP0HSGI

// edit single unit of measure
Function OP0HSGJ()




            /* edit unit of measure*/



  if (OP0HM010.XUMCD is modified)
    /* next sentence*/
  else
    if (OPWREC.XUMCD[1] > "  ") /* if already have a value*/
      return; /* dont overlay it*/
    else
      OPWREC.XUMCD[1] = SYCREC.XUMCD; /* default from style record*/
      return;
    end
  end


  if (OP0HM010.XUMCD in XUMTBL.XUMCD
   && XUMTBL.XXXSTAT[sysVar.arrayIndex] == "A")
    OPWREC.XUMCD[1] = OP0HM010.XUMCD;
    set OP0HM010.XUMCD initialAttributes;
  else
    converseLib.validationFailed(156); /* "unit of measure is not valid"*/
    OPAREC.OPAERR = "Y";
    set OP0HM010.XUMCD cursor, modified, bold;
  end



end // end OP0HSGJ

// edit specification code
Function OP0HSGL()



     /* edit specification code*/





  if (OP0HM010.PC2INSEG > " ")
    /* next sentence*/
  else
    set OP0HM010.PC2INSEG initialAttributes;
    OPWREC.PC2INSEG[1] = "000";
    return;
  end



  PC2REC.PC2INSEG = OP0HM010.PC2INSEG;
  PC2REC.XGPCD = OP1REC.XGPCD;

  call "IO3340" ("SG", SQLCA, PC2REC) {isNoRefresh = yes, isExternal = yes}; /* call spec cd*/

  if (SQLCA.VAGen_SQLCODE == 0)
    set OP0HM010.PC2INSEG initialAttributes;
    OPWREC.PC2INSEG[1] = OP0HM010.PC2INSEG;
    OP0HM010.PC2SEGAB = PC2REC.PC2SEGAB;
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      set OP0HM010.PC2INSEG cursor, modified, bold;
      OP0HM010.PC2SEGAB = "  ";
      OPAREC.OPAERR = "Y";
      converseLib.validationFailed(159); /* spec code is not valid*/
    else
      TA1REC.TA1TYPE = "DB2 ";
      TA1REC.TA1FUNC = "RETN";
      TA1REC.TA1PGMNM = "OP0H    ";
      TA1REC.TA1LOCAT[1] = "SG      ";
      TA1REC.TA1LOCAT[2] = "OP0HSGL ";
      TA1REC.TA1LOCAT[3] = "IO3340  ";
      TA1REC.TA1LOCAT[4] = "        ";
      TA1REC.TA1MAP = "OP0HM010";
      TA1REC.TA1DBASE = "PC2REC  ";
      TA1REC.TA1TBLVU = "VPRDCU01";
      TA1REC.TA1TBLKE = OP0HM010.PC2INSEG;
      call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes};
      COMMAREA.CA-USER-WORKAREA-4K = " "; /* clear ws on error*/
      XSPF4();
      exit program;
    end
  end




end // end OP0HSGL

// misc nike style edit (single e
Function OP0HSGP()
   /* ******************************************************/
   /* **  misc nike style edit (single entry)*/
   /* ******************************************************/
   /* check to see if a sales program is required for this*/
   /* product.*/

    /* build the op9rec key to subprogram op1660*/

  OP9REC.SP1ID = OP1REC.SP1ID; /* sales pgm id*/
  OP9REC.XLCCD = OP0HW01.XLCCD; /* life cycle code*/
  OP9REC.XQACD = OP0HM010.XQACD; /* qual code*/
  OP9REC.XPCCD = SYCREC.XPCCD; /* product category*/
  OP9REC.SY1STNBR = OP0HM010.SY1STNBR;
  OP9REC.SY2CLRID = OP0HM010.SY2CLRID;
  OP9REC.XDMCD = OP0HM010.XDMCD;
  OP9REC.XGPCD = OP1REC.XGPCD;
  OP9REC.XDVCD = OP1REC.XDVCD;
  OP9REC.XSOCD = OP1REC.XSOCD;
  OP9REC.XSPCD = SYCREC.XSPCD;
  if (KUCREC.XAUCD in XAUTBL.XAUCD /* acct cls in table*/
   && XAUTBL.XXXSTAT[sysVar.arrayIndex] == "A")
    OP9REC.XAUCD = KUCREC.XAUCD;
  else
    OP9REC.XAUCD = " ";
  end
  OP9REC.KUCCOID = OP1REC.KUCCOID;
  OP9REC.KUMSTRID = OP1REC.KUMSTRID;
  OP9REC.XNXCD = OP1REC.XNXCD;
  OP9REC.OP9RTNCD = " ";


   /* skip sales program edit if customer draw*/
      /* or rebook draw*/

  if (OP0HW01.OP0HWBDF == "C" /* customer draw*/
   || OP0HW01.OP0HWBDF == "R") /* rebook draw*/
            /* continue*/
  else
    call "OP1660" (OP9REC) {isNoRefresh = yes, isExternal = yes};

    if (OP9REC.OP9RTNCD == "00") /* good rtn accept product*/
        /* next sentence*/
    else
      if (OP9REC.OP9RTNCD == "04") /* db2 error*/
        TAEREC.TAEDESC2 = " DB2 ERROR OP0HSGP ";
        OP0HSDT(); /* format error diags single prod*/
      else
        OP0HW01.OP0HWSFL = "Y";
        OPAREC.OPAERR = "Y";
        OP0HSDK(); /* process op1660 return code*/
      end
    end
  end

  if (OPAREC.OPAERR == "Y") /* error found*/
    set OP0HM010.SY1STNBR cursor, modified, bold;
    set OP0HM010.SY2CLRID modified, bold;
    set OP0HM010.XDMCD modified, bold;
    OP0HSFA(); /* reset mdt's*/
  else
    OP0HSGE(); /* set sizes*/
    if (OPAREC.OPAERR == "Y") /* if error*/
      OP0HSFA(); /* reset mdt's*/
    else
      set OP0HM010.SY1STNBR initialAttributes;
      set OP0HM010.SY2CLRID initialAttributes;
      set OP0HM010.XDMCD initialAttributes;
      OP0HSGJ(); /* edit unit of measure*/
      OP0HSGI(); /* edit package type*/
      OP0HSGL(); /* edit spec code*/
      OP0HSGG(); /* edit quality code*/
      OP0HSGF(); /* edit tot quantity*/
     /* OP0HSGH;                      /* edit standard size*/
    end
  end

end // end OP0HSGP

// misc cu style edit (single ent
Function OP0HSGQ()
   /* ****************************************************/
   /* **  misc cust style edit (single entry)*/
   /* ****************************************************/
   /* check to see if a sales program is required for this*/
   /* product.*/

    /* build the op9rec key to subprogram op1660*/

  OP9REC.SP1ID = OP1REC.SP1ID; /* sales pgm id*/
  OP9REC.XLCCD = OP0HW01.XLCCD; /* life cycle code*/
  OP9REC.XQACD = OP0HM010.XQACD; /* qual code*/
  OP9REC.XPCCD = SYCREC.XPCCD; /* product category*/
  OP9REC.SY1STNBR = OP0HM010.SY1STNBR;
  OP9REC.SY2CLRID = OP0HM010.SY2CLRID;
  OP9REC.XDMCD = OP0HM010.XDMCD;
  OP9REC.XGPCD = OP1REC.XGPCD;
  OP9REC.XDVCD = OP1REC.XDVCD;
  OP9REC.XSOCD = OP1REC.XSOCD;
  OP9REC.XSPCD = SYCREC.XSPCD;
  if (KUCREC.XAUCD in XAUTBL.XAUCD /* acct cls in table*/
   && XAUTBL.XXXSTAT[sysVar.arrayIndex] == "A")
    OP9REC.XAUCD = KUCREC.XAUCD;
  else
    OP9REC.XAUCD = " ";
  end
  OP9REC.KUCCOID = OP1REC.KUCCOID;
  OP9REC.KUMSTRID = OP1REC.KUMSTRID;
  OP9REC.XNXCD = OP1REC.XNXCD;
  OP9REC.OP9RTNCD = " ";


   /* skip sales program edit if customer draw*/
      /* or rebook draw*/

  if (OP0HW01.OP0HWBDF == "C" /* customer draw*/
   || OP0HW01.OP0HWBDF == "R") /* rebook draw*/
     /* NEXT SENTENCE*/
  else
    call "OP1660" (OP9REC) {isNoRefresh = yes, isExternal = yes};

    if (OP9REC.OP9RTNCD == "00") /* good rtn accept product*/
        /* next sentence*/
    else
      if (OP9REC.OP9RTNCD == "04") /* db2 error*/
        TAEREC.TAEDESC2 = "DB2 ERROR OP0HSGQ ";
        OP0HSDT(); /* format error diags single prod*/
      else
        OP0HW01.OP0HWSFL = "Y";
        OPAREC.OPAERR = "Y";
        OP0HSDK(); /* process op1660 return code*/
      end
    end
  end

  if (OPAREC.OPAERR == "Y") /* error found*/
    set OP0HM010.KUIPRDID cursor, bold;
    set OP0HM010.SY1STNBR modified, bold;
    set OP0HM010.SY2CLRID modified, bold;
    set OP0HM010.XDMCD modified, bold;
    OP0HSFA(); /* reset mdt's*/
  else
    OP0HSGE(); /* set sizes*/
    if (OPAREC.OPAERR == "Y") /* if error*/
      OP0HSFA(); /* reset mdt's*/
    else
      set OP0HM010.KUIPRDID initialAttributes;
      OP0HSGJ(); /* edit unit of measure*/
      OP0HSGI(); /* edit package type*/
      OP0HSGL(); /* edit spec code*/
      OP0HSGG(); /* edit quality code*/
      OP0HSGF(); /* edit tot quantity*/
      OP0HSGH(); /* edit standard size*/
    end
  end

end // end OP0HSGQ

// edit sz, uom, pkg, etc...
Function OP0HSGR()
   /* ***********************************************************/
   /* **  edit sz, uom, pkg, etc...*/
   /* ***********************************************************/
  OP0HSG1(); /* reread sycrec*/
  OP0HSH2(); /* reread bulk order itm record*/
  if (OP0HM010.OP0HMDPS is modified
   || OP0HM010.OP0HMFSZ is modified
   || OP0HM010.OP0HMLSZ is modified)
    OP0HSGE(); /* edit sizes*/
    if (OPAREC.OPAERR == "Y") /* if error*/
      OP0HSFA(); /* reset mdt's*/
    else
      OP0HSGJ(); /* edit unit of measure*/
      OP0HSGI(); /* edit package type*/
      OP0HSGL(); /* edit spec code*/
      OP0HSGG(); /* edit quality code*/
      OP0HSGF(); /* edit tot quantity*/
      OP0HSGH(); /* edit standard size*/
    end
  else
    OP0HSGJ(); /* edit unit of measure*/
    OP0HSGI(); /* edit package type*/
    OP0HSGL(); /* edit spec code*/
    OP0HSGG(); /* edit quality code*/
    OP0HSGF(); /* edit tot quantity*/
    OP0HSGH(); /* edit standard size*/
  end


end // end OP0HSGR

// Set up substitution fields
Function OP0HSGS()

   /* -----------------------------------------------------------*/
   /* Substitution information is set up if the user did not*/
   /* enter a different product and a substituted product*/
   /* exists.  Otherwise, the substitution fields in OPWREC*/
   /* are cleared.*/
   /* -----------------------------------------------------------*/
  if (OP0HM010.SY1STNBR == OSKREC.SY1STNBR[1]
   && OP0HM010.SY2CLRID == OSKREC.SY2CLRID[1]
   && OP0HM010.XDMCD == OSKREC.XDMCD[1]
   && OSKREC.OP2SSTYN[1] != " ")
    OPWREC.OP2SSTYN[1] = OSKREC.OP2SSTYN[1];
    OPWREC.OP2SCLCD[1] = OSKREC.OP2SCLCD[1];
    OPWREC.OP2SDMCD[1] = OSKREC.OP2SDMCD[1];
    OPWREC.OPWSWHCD[1] = OSKREC.OSKSWHCD[1];
    OPWREC.OPWSNDT[1] = OSKREC.OSKSNDT[1];
  else
    OPWREC.OP2SSTYN[1] = " ";
    OPWREC.OP2SCLCD[1] = " ";
    OPWREC.OP2SDMCD[1] = " ";
    OPWREC.OPWSWHCD[1] = " ";
    OPWREC.OPWSNDT[1] = 0;
  end
end // end OP0HSGS

// style sold out or not avail?
Function OP0HSGZ()

  OP0HW01.OP0HWSFL = "N"; /* initialize style error flag*/


   /* *******************************************************/
   /* This check not made for draw orders.*/
   /* *******************************************************/

  if (OP0HW01.XBDRWOFL == "Y") /* This is a draw order*/
    return;
  end


   /* *******************************************************/
   /* if no more orders accepted, get out*/
   /* *******************************************************/

  if (SYCREC.SY2ALNOR == "Y")
    /* next sentence--ok, orders still being accepted for prod*/
  else
    converseLib.validationFailed(393); /* new ords not being accept. for this*/
                                   /* prod*/
    OP0HW01.OP0HWSFL = "Y";
    OPAREC.OPAERR = "Y";
    set OP0HM010.SY1STNBR cursor, modified, bold;
    set OP0HM010.SY2CLRID modified, bold;
    return;
  end

   /* Can't order custom logo on at-once order*/

  if (SYCREC.XPRCD == "22")
    if (OPAREC.XOTATONF == "Y")
      converseLib.validationFailed(740);
      OPAREC.OPAERR = "Y";
      OP0HW01.OP0HWSFL = "Y";
      set OP0HM010.SY1STNBR cursor, modified, bold;
      set OP0HM010.SY2CLRID modified, bold;
      return;
    end
  end


   /* *******************************************************/
   /* Check for consistent product type within the order.*/
   /* Must be all custom logo or all non-custom logo.*/
   /* *******************************************************/

  if (SYCREC.XPRCD == "22") /* custom logo product*/
    OP0HW-CUST-LOGO-FL = "Y";
  else
    OP0HW-CUST-LOGO-FL = "N";
  end

  OP0HS-READ-DORDER(); /* Read 1st item on order to check for*/
                     /* product consistency*/

end // end OP0HSGZ

// read bulk item record
Function OP0HSH1()


    /* this routine reads the bulk order item record*/
    /* being drawn from.*/




  OPAREC.OPAORDN = OP1REC.OP1BLKID;
  OP2REC.OP1PARTN = OPAREC.OP1PARTN;
  OP2REC.OP1CUOID = OP1REC.OP1BLKID;
  OP2REC.OP1NORID = OPWREC.OPWBNOID;

  call "IO0440" ("SS", SQLCA, OP2REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    OP0HW01.OP0HWFND = "N"; /* init found flag*/
    OP0HW01.OP0HWFN2 = "N"; /* init found zero qty flag*/
    while (SQLCA.VAGen_SQLCODE != 100 /* while not end of set*/
     && OP0HW01.OP0HWFND == "N") /* and while style not found*/
      call "IO0440" ("SN", SQLCA, OP2REC) {isNoRefresh = yes, isExternal = yes};
      if (SQLCA.VAGen_SQLCODE == 0)
        if (OP0HW01.OP0HWBBD == "B") /* blank bulk draw*/
          if (SYCREC.SY1BSTNB == OP2REC.SY1STNBR
           && SYCREC.SY2BCLCD == OP2REC.SY2CLRID
           && SYCREC.XDMCD == OP2REC.XDMCD
           && OP0HM010.XQACD == OP2REC.XQACD)
            OP0HW01.OP0HWFND = "Y";
          end
        else
          if (OP0HM010.SY1STNBR == OP2REC.SY1STNBR
           && OP0HM010.SY2CLRID == OP2REC.SY2CLRID
           && OP0HM010.XDMCD == OP2REC.XDMCD
           && OP0HM010.XQACD == OP2REC.XQACD)
            if (OP0HWBDF == "C" /* cust draw*/
             || OP0HWBDF == "R" /* rebook draw*/
             || OP0HWBDF == "X" /* flexible draw*/
             || OP0HWBDF == "S") /* smart draw*/
              if (OP2REC.OP2TONOQ != 0)
                OP0HW01.OP0HWFND = "Y";
              else
                OP0HW01.OP0HWFN2 = "Y";
                OP0HW01.OP0HWDK1 = OP2REC.OP1PARTN;
                OP0HW01.OP0HWDK2 = OP2REC.OP1CUOID;
                OP0HW01.OP0HWDK3 = OP2REC.OP1NORID;
                OP0HW01.OP0HWDK4 = OP2REC.OP2LNINB;
              end
            end
          end
        end
      else
        if (SQLCA.VAGen_SQLCODE != 100)
          TA1REC.TA1TYPE = "DB2 ";
          TA1REC.TA1FUNC = "RETN";
          TA1REC.TA1PGMNM = "OP0H    ";
          TA1REC.TA1LOCAT[1] = "SN      ";
          TA1REC.TA1LOCAT[2] = "OP0HSH1 ";
          TA1REC.TA1LOCAT[3] = "IO0440  ";
          TA1REC.TA1LOCAT[4] = "        ";
          TA1REC.TA1MAP = "OP0HM010";
          TA1REC.TA1DBASE = "OP2REC  ";
          TA1REC.TA1TBLVU = "VITEM001";
          TA1REC.TA1TBLKE = OP2REC.OP2KEY;
          call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
          COMMAREA.CA-USER-WORKAREA-4K = " "; /* on error clear we*/
          XSPF4();
          exit program;
        end
      end
    end
  else /* no style records for the bulk order*/
    TA1REC.TA1TYPE = "DB2 ";
    TA1REC.TA1FUNC = "RETN";
    TA1REC.TA1PGMNM = "OP0H    ";
    TA1REC.TA1LOCAT[1] = "SS      ";
    TA1REC.TA1LOCAT[2] = "OP0HSH1 ";
    TA1REC.TA1LOCAT[3] = "IO0440  ";
    TA1REC.TA1LOCAT[4] = "        ";
    TA1REC.TA1MAP = "OP0HM010";
    TA1REC.TA1DBASE = "OP2REC  ";
    TA1REC.TA1TBLVU = "VITEM001";
    TA1REC.TA1TBLKE = OP2REC.OP2KEY;
    call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
    COMMAREA.CA-USER-WORKAREA-4K = " "; /* on error clear we*/
    XSPF4();
    exit program;
  end


  call "IO0440" ("CS", SQLCA, OP2REC) {isNoRefresh = yes, isExternal = yes}; /* close cursor*/


  if (OP0HWBDF != "C" /* cust draw*/
   && OP0HWBDF != "R" /* rebook draw*/
   && OP0HWBDF != "X" /* flexible draw*/
   && OP0HWBDF != "S") /* smart draw*/
      /* next sentence*/
  else
    if (OP0HW01.OP0HWFND == "N" /* if item with qty not found*/
     && OP0HW01.OP0HWFN2 == "Y") /* and item wite 0 qty found*/
      OP0HW01.OP0HWFND = "Y"; /* select item wo qty again*/
      OP2REC.OP1PARTN = OP0HW01.OP0HWDK1;
      OP2REC.OP1CUOID = OP0HW01.OP0HWDK2;
      OP2REC.OP1NORID = OP0HW01.OP0HWDK3;
      OP2REC.OP2LNINB = OP0HW01.OP0HWDK4;
      call "IO0440" ("S ", SQLCA, OP2REC) {isNoRefresh = yes, isExternal = yes};
      if (SQLCA.VAGen_SQLCODE == 0)
          /* next sentence*/
      else
        TA1REC.TA1TYPE = "DB2 ";
        TA1REC.TA1FUNC = "RETN";
        TA1REC.TA1PGMNM = "OP0H    ";
        TA1REC.TA1LOCAT[1] = "S       ";
        TA1REC.TA1LOCAT[2] = "OP0HSH1 ";
        TA1REC.TA1LOCAT[3] = "IO0440  ";
        TA1REC.TA1LOCAT[4] = "        ";
        TA1REC.TA1MAP = "OP0HM010";
        TA1REC.TA1DBASE = "OP2REC  ";
        TA1REC.TA1TBLVU = "VITEM001";
        TA1REC.TA1TBLKE = OP2REC.OP2KEY;
        call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
        COMMAREA.CA-USER-WORKAREA-4K = " "; /* on error clear we*/
        XSPF4();
        exit program;
      end
    end
  end

end // end OP0HSH1

// read bulk item record direct
Function OP0HSH2()


    /* this routine reads the bulk order item record*/
    /* being drawn from. uses a select unique.*/



   /* skip read if order is not a draw.*/

  if (OP0HW01.OP0HWBDF == "C"
   || OP0HW01.OP0HWBDF == "R"
   || OP0HW01.OP0HWBDF == "S"
   || OP0HW01.OP0HWBDF == "X")
     /* next sentence*/
  else
    return;
  end





  OPAREC.OPAORDN = OP1REC.OP1BLKID;
  OP2REC.OP1PARTN = OPAREC.OP1PARTN;
  OP2REC.OP1CUOID = OP1REC.OP1BLKID;
  OP2REC.OP2LNINB = OPWREC.OPWBKLIN[1];
  OP2REC.OP1NORID = OPWREC.OP1NORID;

  call "IO0440" ("S ", SQLCA, OP2REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
     /* next sentence*/
  else
    TA1REC.TA1TYPE = "DB2 ";
    TA1REC.TA1FUNC = "RETN";
    TA1REC.TA1PGMNM = "OP0H    ";
    TA1REC.TA1LOCAT[1] = "S       ";
    TA1REC.TA1LOCAT[2] = "OP0HSH2 ";
    TA1REC.TA1LOCAT[3] = "IO0440  ";
    TA1REC.TA1LOCAT[4] = "        ";
    TA1REC.TA1MAP = "OP0HM010";
    TA1REC.TA1DBASE = "OP2REC  ";
    TA1REC.TA1TBLVU = "VITEM001";
    TA1REC.TA1TBLKE = OP2REC.OP2KEY;
    call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
    COMMAREA.CA-USER-WORKAREA-4K = " "; /* on error clear we*/
    XSPF4();
    exit program;
  end









end // end OP0HSH2

// def first from bulk
Function OP0HSH3()






   /* this routine will set a default first size if not entered*/
   /* it works forward through the products size array.*/

       /* if size's division code exists*/
          /* if size division matched order type allowable divs*/
             /* if size fringe/gut/extras indicators ok*/
                /* good size, save size.*/







  OPAREC.OPASUB1 = 1;
  OP0HW01.OP0HWFSZ = 0;

  while (OPAREC.OPASUB1 <= 40)
    if (OP3REC.OP3SZAFL[OPASUB1] == "Y")
      if (OP0HW01.OP0HWBDF == "C" /* if customer draw*/
       || OP0HW01.OP0HWBDF == "R" /* if rebook draw*/
       || OP0HW01.OP0HWBDF == "X") /* if flexible draw*/
        if (OP3REC.OP3ONOQT[OPASUB1] > 0) /* if qty to order*/
          OP0HW01.OP0HWFSZ = OPAREC.OPASUB1;
          OPAREC.OPASUB1 = 41;
        else
          OPAREC.OPASUB1 = OPAREC.OPASUB1 + 1;
        end
      else
        if (OP0HW01.OP0HWBDF == "S") /* if smart draw*/
          if (OP3REC.OP3OHRQT[OPASUB1] > 0) /* if qty to order*/
            OP0HW01.OP0HWFSZ = OPAREC.OPASUB1;
            OPAREC.OPASUB1 = 41;
          else
            OPAREC.OPASUB1 = OPAREC.OPASUB1 + 1;
          end
        end
      end
    else
      OPAREC.OPASUB1 = OPAREC.OPASUB1 + 1;
    end
  end




  if (OP0HW01.OP0HWFSZ > 0) /* if got a size*/
     /* next sentence*/
  else
    OPAREC.OPAERR = "Y"; /* error, no size to default to*/
    set OP0HM010.OP0HMFSZ cursor, modified, bold;
    converseLib.validationFailed(148);
  end








end // end OP0HSH3

// def last from bulk
Function OP0HSH4()





   /* this routine will set a default first size if not entered*/
   /* it works forward through the products size array.*/

       /* if size's division code exists*/
          /* if size division matched order type allowable divs*/
             /* if size fringe/gut/extras indicators ok*/
                /* good size, save size.*/







  OPAREC.OPASUB1 = 40;
  OP0HW01.OP0HWLSZ = 0;

  while (OPAREC.OPASUB1 >= 1)
    if (OP3REC.OP3SZAFL[OPASUB1] == "Y")
      if (OP0HW01.OP0HWBDF == "C" /* if customer draw*/
       || OP0HW01.OP0HWBDF == "R" /* or rebook draw*/
       || OP0HW01.OP0HWBDF == "X") /* or flexible draw*/
        if (OP3REC.OP3ONOQT[OPASUB1] > 0) /* if qty to order*/
          OP0HW01.OP0HWLSZ = OPAREC.OPASUB1;
          OPAREC.OPASUB1 = 0;
        else
          OPAREC.OPASUB1 = OPAREC.OPASUB1 - 1;
        end
      else
        if (OP0HW01.OP0HWBDF == "S") /* if smart draw*/
          if (OP3REC.OP3OHRQT[OPASUB1] > 0) /* if qty to order*/
            OP0HW01.OP0HWLSZ = OPAREC.OPASUB1;
            OPAREC.OPASUB1 = 0;
          else
            OPAREC.OPASUB1 = OPAREC.OPASUB1 - 1;
          end
        end
      end
    else
      OPAREC.OPASUB1 = OPAREC.OPASUB1 - 1;
    end
  end




  if (OP0HW01.OP0HWLSZ > 0) /* if got a size*/
     /* next sentence*/
  else
    OPAREC.OPAERR = "Y"; /* error, no size to default to*/
    set OP0HM010.OP0HMLSZ cursor, modified, bold;
    converseLib.validationFailed(148);
  end
















end // end OP0HSH4

// count active bulk sizes
Function OP0HSH5()


       /* if size's division code exists*/
          /* if size division is allowed*/
             /* if size fringe/gut/extras indicators ok*/
                /* then increment number of active size field.*/


  if (OP1REC.XOTCD in XOTTBL.XOTCD)
    OPAREC.OPASUB2 = sysVar.arrayIndex;
    if (XOTTBL.XOTALWDV[sysVar.arrayIndex] == "A"
     || XOTTBL.XOTALWDV[sysVar.arrayIndex] == "D")
       /* next sentence*/
    else
      return;
    end
  else
    return;
  end



  OPAREC.OPASUB1 = OP0HW01.OP0HWFSZ;
  OP0HW01.OP0HWNAS[1] = 0;

  if (XOTTBL.XOTALWDV[OPASUB2] == "A")

    while (OPAREC.OPASUB1 <= 40
     && OPAREC.OPASUB1 <= OP0HW01.OP0HWLSZ)
      if (SYCREC.XDVCD[OPASUB1] != " ")
        if (SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD1[OPASUB2]
         || SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD2[OPASUB2]
         || SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD3[OPASUB2]
         || SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD4[OPASUB2]
         || SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD5[OPASUB2])

          if (SYCREC.SY3FRGUT[OPASUB1] == "F"
           || SYCREC.SY3FRGUT[OPASUB1] == "G")
            OP0HW01.OP0HWNAS[1] = OP0HW01.OP0HWNAS[1] + 1;
          else
            if (SYCREC.SY3FRGUT[OPASUB1] == "X"
             /* if fringe/gut is extra*/
             && XOTTBL.XOTXTRAS[OPASUB2] == "Y") /* if extras allowed*/
              OP0HW01.OP0HWNAS[1] = OP0HW01.OP0HWNAS[1] + 1;
            end
          end

        end
      end
      OPAREC.OPASUB1 = OPAREC.OPASUB1 + 1;
    end
  end


  if (XOTTBL.XOTALWDV[OPASUB2] == "D")

    while (OPAREC.OPASUB1 <= 40
     && OPAREC.OPASUB1 <= OP0HW01.OP0HWLSZ)
      if (SYCREC.XDVCD[OPASUB1] != " ")
        if (SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD1[OPASUB2]
         || SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD2[OPASUB2]
         || SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD3[OPASUB2]
         || SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD4[OPASUB2]
         || SYCREC.XDVCD[OPASUB1] == XOTTBL.XDVCD5[OPASUB2])
           /* next sentence*/
        else

          if (SYCREC.SY3FRGUT[OPASUB1] == "F"
           || SYCREC.SY3FRGUT[OPASUB1] == "G")
            OP0HW01.OP0HWNAS[1] = OP0HW01.OP0HWNAS[1] + 1;
          else
            if (SYCREC.SY3FRGUT[OPASUB1] == "X"
             && XOTTBL.XOTXTRAS[OPASUB2] == "Y")
              OP0HW01.OP0HWNAS[1] = OP0HW01.OP0HWNAS[1] + 1;
            end
          end

        end
      end
      OPAREC.OPASUB1 = OPAREC.OPASUB1 + 1;
    end
  end


end // end OP0HSH5

// reset mdt tags for single map
Function OP0HSHA()



          /* set mdt's in fields for the case of invalid aid key*/
          /* this allows the user to press the correct aid key*/
          /* without having to re-enter the data.*/




  if (OP0HM010.SY1STNBR is modified)
    set OP0HM010.SY1STNBR modified;
  end

  if (OP0HM010.SY2CLRID is modified)
    set OP0HM010.SY2CLRID modified;
  end

  if (OP0HM010.XDMCD is modified)
    set OP0HM010.XDMCD modified;
  end

  if (OP0HM010.OP2TORGQ is modified)
    set OP0HM010.OP2TORGQ modified;
  end

  if (OP0HM010.XQACD is modified)
    set OP0HM010.XQACD modified;
  end

  if (OP0HM010.KUIPRDID is modified)
    set OP0HM010.KUIPRDID modified;
  end

  if (OP0HM010.OP0HMDPS is modified)
    set OP0HM010.OP0HMDPS modified;
  end

   /* F OP0HM010.XSZCD IS MODIFIED;*/
   /* SET OP0HM010.XSZCD MODIFIED;*/
   /* ND;*/

  if (OP0HM010.XPGCD is modified)
    set OP0HM010.XPGCD modified;
  end

  if (OP0HM010.XUMCD is modified)
    set OP0HM010.XUMCD modified;
  end

   /* IF OP0HM010.pc2inseg IS MODIFIED;*/
    /* SET OP0HM010.pc2inseg MODIFIED;*/
   /* END ;*/








end // end OP0HSHA

// reset style mdt fields
Function OP0HSKA()



          /* set mdt's in fields for a line item due to some*/
          /* error condition.*/



     /* note: on an error, save the dup size flag for logic*/
           /* in op0hsla.*/


  OPWREC.OPWDUPSZ[OPASUB] = OP0HM005.OP0HMDSZ[OPASUB];




  if (OP0HM005.OP2TORGQ[OPASUB] is modified)
    set OP0HM005.OP2TORGQ[OPASUB] modified;
  end

  if (OP0HM005.XQACD[OPASUB] is modified)
    set OP0HM005.XQACD[OPASUB] modified;
  end

   /* F OP0HM005.XSZCD(OPASUB) IS MODIFIED;*/
   /* SET OP0HM005.XSZCD(OPASUB) MODIFIED;*/
   /* ND;*/

  if (OP0HM005.XPGCD[OPASUB] is modified)
    set OP0HM005.XPGCD[OPASUB] modified;
  end

  if (OP0HM005.XUMCD[OPASUB] is modified)
    set OP0HM005.XUMCD[OPASUB] modified;
  end









end // end OP0HSKA

// pack ws product array
Function OP0HSLA()






          /* this routine removes gaps in the ws product array*/
          /* which is used in product detail entry.*/


      /* note: i refer to an anchor below. this definition is:*/

            /* this is a line item from which lower styles are*/
            /* duplicating sizes from.(lower style have opwdupsz*/
            /* value of 'y')*/

            /* When anchor is deleted, op0i doesn't have a*/
            /* previous size record to read for duplicating.*/
            /* when this condition arises the logic goes as*/
            /* follows:*/

              /* first set a flag whenever we are deleting a*/
                 /* line item with a 'n' value in opwdupsz.*/

              /* later when packing the array, if we are replac-*/
              /* ing a line item and the old line item had an*/
              /* 'n' in the dup field, then if the line item we*/
              /* are replacing the old one with is a dup 'y'*/
              /* change it to an 'n'. (re-establish an anchor)*/



  OPAREC.OPASUB = 1;
  OPAREC.OPASUB1 = 1;
  OPAREC.OPASUB2 = 2;


  while (OPASUB2 <= 6)
    if (OPWREC.SY1STNBR[OPASUB1] > " ") /* if slot in use*/
      OPASUB1 = OPASUB1 + 1;
      OPASUB2 = OPASUB2 + 1;
    else
      if (OPWREC.OPWDUPSZ[OPASUB1] == "N") /* if style was an anchor*/
        OP0HW01.OP0HWSKA = "Y"; /* set skipped anchor product flag*/
      end
      OPASUB = 1;
      while (OPASUB == 1
       && OPASUB2 <= 6)
        if (OPWREC.SY1STNBR[OPASUB2] > " ")
          OPASUB = 0;
        else
          OPASUB2 = OPASUB2 + 1;
        end
      end
      if (OPASUB2 <= 6)
        if (OP0HW01.OP0HWSKA == "Y"
         && OPWREC.OPWDUPSZ[OPASUB2] == "Y")
          OPWREC.OPWDUPSZ[OPASUB2] = "N";
        end
        OP0HW01.OP0HWSKA = "N"; /* reset flag*/
        OPWREC.OPWMPRDA[OPASUB1] = OPWREC.OPWMPRDA[OPASUB2];
        OPWREC.OPWMPRDA[OPASUB2] = " ";
        OPWREC.OPWRQSZF[OPASUB2] = 0;
        OPWREC.OPWRQSZL[OPASUB2] = 0;
        OPWREC.OP2TONOQ[OPASUB2] = 0;
        OPWREC.OPWSNDT[OPASUB2] = 0;
        OPASUB1 = OPASUB1 + 1;
        OPASUB2 = OPASUB2 + 1;
      end
    end
  end







end // end OP0HSLA

// check for restricted product
Function OP0HSLB()


    /* The following codes will determine if the customer is*/
    /* an in house account and excempted from the sales office*/
    /* restrictions.*/

  if (KUCREC.XAUCD in XAUTBL.XAUCD             /* account class in table*/
   && XAUTBL.XXXSTAT[sysVar.arrayIndex] == "A" /* class is active*/
   && XAUTBL.XAUARIND[sysVar.arrayIndex] == "I") /* in-house account*/
    return;
  end


    /* The following codes will determine if the customer is*/
    /* a military national account (xna = F1, F2, F3, F4, F5, F6)*/
    /* and exempted from the sales office - product restrictions.*/


  if (KUNREC.XNACD == "F1" /* natl acct military*/
   || KUNREC.XNACD == "F2" /* natl acct military - nknw*/
   || KUNREC.XNACD == "F3" /* natl acct military - ngtr*/
   || KUNREC.XNACD == "F4" /* natl acct military - golf*/
   || KUNREC.XNACD == "F5" /* natl acct military - nkso*/
   || KUNREC.XNACD == "F6") /* natl acct military - nkgl*/
    return;
  end


    /* This edit will prevent restricted products from being*/
    /* ordered by any sales offices that are not authorized*/
    /* by a code on the xsotbl.*/

  OP0HSCU(); /* get cugrp record for customer*/

  if (SYCREC.SY2RPRDI == "R") /* ; product is restricted*/

    sysVar.arrayIndex = 0; /* ; reset ezetst*/
    if ("MI" in KUPREC.XSGCD /* ; military customer*/
     || "NO" in KUPREC.XSGCD) /* ; nordstrom's*/
       /* next sentence - ok        ;      ;*/
    else
      sysVar.arrayIndex = 0; /* ; reset ezetst*/
      if (OP1REC.XSOCD in XSOTBL.XSOCD /* sales office in table*/
       && XSOTBL.XXXSTAT[sysVar.arrayIndex] == "A") /* table status is active*/
        if (XSOTBL.XSORPRDI[sysVar.arrayIndex] == "N") /* no restriction on products*/
            /* next sentence - ok*/
        else
          OP0HW01.OP0HWSFL = "Y"; /* set style restricted flag*/
          OPAREC.OPAERR = "Y";
          converseLib.validationFailed(535); /* style is restricted...*/
        end
      else
        OP0HW01.OP0HWSFL = "Y"; /* set style restricted flag*/
        OPAREC.OPAERR = "Y";
        converseLib.validationFailed(109); /* sales office code is not valid*/
      end
    end
  end


   /* the following edit checks if AGG products must be ordered*/
   /* thru sales office '09' for the customer ('XT' customer*/
   /* orders must come through sales office '09' for ACG prods).*/

   /* 7/11/91 JLoyer: Bypass these edits for ACG close-outs*/

  if (SYCREC.XPCCD == "JA") /* product cat is for ACG product*/
      /* continue edit*/
  else
    return; /* not an ACG product*/
  end

  OP0HSLD(); /* determine prod's life cycle code*/

  if (OP0HW01.XLCCD == "20") /* if product is a close-out*/
    return; /* bypass ACG restriction edits*/
  end

  if (OP1REC.XSOCD == "09") /* '09' is what it should be*/
    return;
  end

  if (SQLCA.VAGen_SQLCODE == 0) /* ; if record found continue edit*/
    sysVar.arrayIndex = 0; /* ; reset ezetst*/

    if ("XT" in KUPREC.XSGCD) /* ; customer restricted for ACG*/
      converseLib.validationFailed(625); /* ; ACG must be ordered from specialty*/
                                 /* ; ; sales office for this cust*/
      OP0HW01.OP0HWSFL = "Y"; /* set style restricted flag*/
      OPAREC.OPAERR = "Y"; /* ; set error flag*/
    end
  end

end // end OP0HSLB

// get any kunrec for company
Function OP0HSLC()



      /* *********************************************************/
      /* * this statement group retrieves the xna code at the   **/
      /* * customer level.                                      **/
      /* *********************************************************/

  KUNREC.KUCCOID = OP1REC.KUCCOID; /* load key - company*/
  KUNREC.KUMSTRID = OP1REC.KUMSTRID; /* load key - store*/
  KUNREC.XNXCD = OP1REC.XNXCD; /* load key - dept*/
  KUNREC.XGPCD = "**"; /* load wildcard - gpc*/
  call "IO0280" ("SS", SQLCA, KUNREC) {isNoRefresh = yes, isExternal = yes}; /* call i/o mod for inquiry*/

      /* check db2 return code*/

  if (SQLCA.VAGen_SQLCODE != 0) /* check for good rc*/
    TA1REC.TA1DBASE = "DCUST   "; /* data base name*/
    TA1REC.TA1TBLVU = "VCUST001"; /* table view*/
    TA1REC.TA1TBLKE = KUNREC.KUNGRP; /* key value*/
    TA1REC.TA1LOCAT[3] = "OP0HSLC "; /* statement group*/
    TA1REC.TA1LOCAT[4] = "IO0280  "; /* i/o mod name*/
    XSOPS02();
  end

      /* fetch first customer record*/

  call "IO0280" ("SN", SQLCA, KUNREC) {isNoRefresh = yes, isExternal = yes}; /* fetch cust record*/

      /* check db2 return code.  should be able to find at least*/
      /* one because kunrec key has been validated by op0c.*/

  if (SQLCA.VAGen_SQLCODE == 0) /* good return code*/
    call "IO0280" ("CS", SQLCA, KUNREC) {isNoRefresh = yes, isExternal = yes}; /* close cursor*/
  else
    TA1REC.TA1DBASE = "DCUST   "; /* data base name*/
    TA1REC.TA1TBLVU = "VCUST001"; /* table view*/
    TA1REC.TA1TBLKE = KUNREC.KUNGRP; /* key value*/
    TA1REC.TA1LOCAT[3] = "OP0HSLC "; /* statement group*/
    TA1REC.TA1LOCAT[4] = "IO0280  "; /* i/o mod name*/
    XSOPS02();
  end
   /* *************************************************************/
end // end OP0HSLC

// determine current life cycle
Function OP0HSLD()

          /* Get the current life cycle code*/
          /* from sycrec using the system date*/


   /* first get from op1rec enter date*/

  OPAREC.OPACDT = OP1REC.ZZZSDT;


    /* get most current life cycle*/

  if (OPAREC.OPACDT >= SYCREC.SY2CEDT1)
    OP0HW01.XLCCD = SYCREC.XLCCD1;
  else
    if (OPAREC.OPACDT >= SYCREC.SY2CEDT2)
      OP0HW01.XLCCD = SYCREC.XLCCD2;
    else
      if (OPAREC.OPACDT >= SYCREC.SY2CEDT3)
        OP0HW01.XLCCD = SYCREC.XLCCD3;
      else
        if (OPAREC.OPACDT >= SYCREC.SY2CEDT4)
          OP0HW01.XLCCD = SYCREC.XLCCD4;
        else
          OP0HW01.XLCCD = "  ";
        end
      end
    end
  end
end // end OP0HSLD

// edit PF5 request
Function OP0HSQA()
   /* ********************************************************/
   /* ***   edit pf5 (product substitution) request*/
   /* ********************************************************/


  if (OPWREC.OPWSFLOW == "1") /* multiple product entry*/
    OPASUB = 6;
    while (OPASUB >= 1)
      if (OP0HM005.OP0HMSBF[OPASUB] != "Y"
       && OP0HM005.OP0HMSBF[OPASUB] != "N")
        OPAREC.OPAERR = "Y"; /* error flag*/
        set OP0HM005.OP0HMSBF[OPASUB] cursor, bold;
      end
      OPASUB = OPASUB - 1;
    end

    if (OPAREC.OPAERR == "Y") /* if error was found*/
      converseLib.validationFailed(563);
                                   /* invalid character. must be 'y' or 'n'*/
      return;
    end


    if ("Y" in OP0HM005.OP0HMSBF) /* at least one prod was selected*/
      OSGREC.OSGPRSUB = sysVar.arrayIndex; /* save map position*/
      SY2REC.SY1STNBR = OP0HM005.SY1STNBR[OSGPRSUB];
      SY2REC.SY2CLRID = OP0HM005.SY2CLRID[OSGPRSUB];
      SY2REC.XDMCD = OP0HM005.XDMCD[OSGPRSUB];
      TA1REC.TA1MAP = "OP0HM005";
    else
      set OP0HM005.OP0HMSBF[1] cursor;
      converseLib.validationFailed(565); /* at least 1 must be selected for pf5*/
      OPAREC.OPAERR = "Y"; /* error flag*/
      return;
    end


  else /* single product entry*/
    OSGREC.OSGPRSUB = 1; /* save map position*/
    SY2REC.SY1STNBR = OP0HM010.SY1STNBR;
    SY2REC.SY2CLRID = OP0HM010.SY2CLRID;
    SY2REC.XDMCD = OP0HM010.XDMCD;
    TA1REC.TA1MAP = "OP0HM010";


  end



  SY2REC.XGPCD = OP1REC.XGPCD; /* complete the prod key w/ gpc*/

  call "IO0130" ("S ", SQLCA, SY2REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      converseLib.validationFailed(131); /* style/color is not valid*/
      OPAREC.OPAERR = "Y"; /* error flag*/
      if (OPWREC.OPWSFLOW == "1") /* multiple product entry*/
        set OP0HM005.OP0HMSBF[OSGPRSUB] cursor, bold;
        set OP0HM005.SY1STNBR[OSGPRSUB] bold;
        set OP0HM005.SY2CLRID[OSGPRSUB] bold;
        set OP0HM005.XDMCD[OSGPRSUB] bold;
      else /* single product entry*/
        set OP0HM010.SY1STNBR cursor, bold;
        set OP0HM010.SY2CLRID bold;
        set OP0HM010.XDMCD bold;
      end
      return;
    else
      TA1REC.TA1TYPE = "DB2 ";
      TA1REC.TA1FUNC = "RETN";
      TA1REC.TA1PGMNM = "OP0H    ";
      TA1REC.TA1LOCAT[1] = "S       ";
      TA1REC.TA1LOCAT[2] = "OP0HSQA ";
      TA1REC.TA1LOCAT[3] = "IO0130  ";
      TA1REC.TA1LOCAT[4] = "SY2REC  ";
      TA1REC.TA1DBASE = "DPROD   ";
      TA1REC.TA1TBLVU = "VCOLOR01";
      TA1REC.TA1TBLKE = SY2REC.SY2KEY;
      call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
      COMMAREA.CA-USER-WORKAREA-4K = " "; /* on error clear ws*/
      XSPF4();
      exit program;
    end
  end


   /* -----------------------------------------------------------*/
   /* Set up the product number for the call to substitution.*/
   /* If the product has already been substituted, then the*/
   /* original product entered by the user is set up again for*/
   /* the call to substitution.*/
   /* -----------------------------------------------------------*/
  if (OPWREC.OPWSFLOW == "1") /* Multiple product entry*/
    if (OP0HM005.SY1STNBR[OSGPRSUB] == OSKREC.SY1STNBR[OSGPRSUB]
     && OSKREC.OP2SSTYN[OSGPRSUB] != " ")
      /* ------------------------------------------------------*/
       /* The user did not change the product on the screen*/
       /* and substitution was done before.  Use the original*/
       /* product entered by the user.*/
      /* ------------------------------------------------------*/
      OSGREC.SY1STNBR = OSKREC.OP2SSTYN[OSGPRSUB];
      OSGREC.SY2CLRID = OSKREC.OP2SCLCD[OSGPRSUB];
      OSGREC.XDMCD = OSKREC.OP2SDMCD[OSGPRSUB];
    else

      /* ------------------------------------------------------*/
       /* A new product was entered by user or substitute was*/
       /* not done.  Use the product from the screen.*/
      /* ------------------------------------------------------*/
      OSGREC.SY1STNBR = OP0HM005.SY1STNBR[OSGPRSUB];
      OSGREC.SY2CLRID = OP0HM005.SY2CLRID[OSGPRSUB];
      OSGREC.XDMCD = OP0HM005.XDMCD[OSGPRSUB];

      /* ------------------------------------------------------*/
       /* Clear out the substituted product and substitute*/
       /* warehouse and need date.*/
      /* ------------------------------------------------------*/
      OSKREC.OP2SSTYN[OSGPRSUB] = " ";
      OSKREC.OP2SCLCD[OSGPRSUB] = " ";
      OSKREC.OP2SDMCD[OSGPRSUB] = " ";
      OSKREC.OSKSWHCD[OSGPRSUB] = " ";
      OSKREC.OSKSNDT[OSGPRSUB] = 0;
    end

  else /* Single product entry*/
    if (OP0HM010.SY1STNBR == OSKREC.SY1STNBR[OSGPRSUB]
     && OSKREC.OP2SSTYN[OSGPRSUB] != " ")
      /* ------------------------------------------------------*/
       /* The user did not change the product on the screen*/
       /* and substitution was done before.  Use the original*/
       /* product entered by the user.*/
      /* ------------------------------------------------------*/
      OSGREC.SY1STNBR = OSKREC.OP2SSTYN[OSGPRSUB];
      OSGREC.SY2CLRID = OSKREC.OP2SCLCD[OSGPRSUB];
      OSGREC.XDMCD = OSKREC.OP2SDMCD[OSGPRSUB];
    else

      /* ------------------------------------------------------*/
       /* A new product was entered by user or substitute was*/
       /* not done.  Use the product from the screen.*/
      /* ------------------------------------------------------*/
      OSGREC.SY1STNBR = OP0HM010.SY1STNBR;
      OSGREC.SY2CLRID = OP0HM010.SY2CLRID;
      OSGREC.XDMCD = OP0HM010.XDMCD;

      /* -------------------------------------------------------*/
       /* Clear out the substituted product and substitute*/
       /* warehouse and need date.*/
      /* -------------------------------------------------------*/
      OSKREC.OP2SSTYN[OSGPRSUB] = " ";
      OSKREC.OP2SCLCD[OSGPRSUB] = " ";
      OSKREC.OP2SDMCD[OSGPRSUB] = " ";
      OSKREC.OSKSWHCD[OSGPRSUB] = " ";
      OSKREC.OSKSNDT[OSGPRSUB] = 0;
    end
  end




  OP0HSQB(); /* Process transfer to AV0L.*/
end // end OP0HSQA

// process transfer to subs.
Function OP0HSQB()
   /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * **/
    /* 1. fills in parameters to be passed to product*/
        /* substitution (av0l)*/
    /* 2. saves the commarea, etc... in xsrrec for later*/
        /* retrieval.*/

    /* Note: * For OP1REC database changes, XSRREC.XSRDATA length*/
            /* will be affected as well as OSKREC.*/
          /* * Currently, the value of XSRREC.XSRLNGTH is 3072.*/
            /* If op1rec, opwrec, or oskrec changes, this will*/
            /* also change.*/

   /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * **/



    /* OSGREC was initialized in OP0HSQA and now contains*/
    /* the product id to be replaced in the substitution*/
    /* system.  If OP0H is in multiple-product entry mode,*/
    /* OSGREC.OSGPRSUB also contains the subscript/pointer*/
    /* value of the product that will be substituted in*/
    /* AV0L.  If OP0H is in single entry mode or in Phone*/
    /* Flow, OSGPRSUB will have a value of one (1).*/

                                     /* SET-UP XSRREC TO BE SAVED*/

  XSRREC.XSRSYSID = "OP0H";
  XSRREC.XSRSUBID = COMMAREA.CAUSERID;

  OP0HSQC(); /* move/truncate op1cuoid to xsrsqnbr*/


  OSKREC.XWHCD = COMMAREA.XWHCD;
  OSKREC.XDVCD = COMMAREA.XDVCD;
  OSKREC.XSOCD = COMMAREA.XSOCD;
  OSKREC.XNDCD = COMMAREA.XNDCD;
  OSKREC.XGPCD = COMMAREA.XGPCD;

  OPWREC.OP1GROUP = OP1REC.OP1GROUP;
  COMMAREA.CA-USER-WORKAREA-4K = OPWREC.OPWSGRP;
  OSKREC.OS-USER-WORKAREA = COMMAREA.CA-USER-WORKAREA-4K;

  OP0HSQD(); /* save map to oskhmap (oskrec map area)*/


  XSRREC.XSRDATA = OSKREC.OSKGROUP;
  XX0XS01(); /* get date and time*/
  XSRREC.ZZZCHGDT = XX0XW01.XX0XWDAT;
  XSRREC.ZZZCHGTM = XX0XW01.XX0XWTIM;
  XSRREC.ZZZCHGCT = 0;
  XSRREC.XSRLNGTH = 4024; /* length of xsrdata/oskrec*/


  OP0HSQE(); /* WRITE XSRREC*/


                                    /* SET-UP OSGREC TO BE PASSED*/

  OSGREC.XSRSYSID = XSRREC.XSRSYSID;
  OSGREC.XSRSUBID = XSRREC.XSRSUBID;
  OSGREC.XSRSQNBR = XSRREC.XSRSQNBR;


   /* ***  The original source product and criteria codes will*/
   /* ***  only be initialized once in osgrec for every change*/
   /* ***  in products 1 thru 6.  This makes sure that the*/
   /* ***  source product passed to PRODUCT SUBSTITUTION will*/
   /* ***  always be the original one. (see op0hsqa)*/

   /* OSGREC.OSGPRSUB is the save product pointer (1-6)*/
  OSGREC.KUCCOID = OP1REC.KUCCOID;
  OSGREC.KUMSTRID = OP1REC.KUMSTRID;
  OSGREC.XNXCD = OP1REC.XNXCD;
  OSGREC.OP1ORDBY = OP1REC.OP1ORDBY;
  OSGREC.XGPCD = OP1REC.XGPCD;
   /* OSGREC.SY1STNBR was initialized in op0hsqa*/
   /* OSGREC.SY2CLRID was initialized in op0hsqa*/
   /* OSGREC.XDMCD    was initialized in op0hsqa*/
  OSGREC.XOWCD = OPWREC.XOWCD;
  OSGREC.XSDCD = " ";
  OSGREC.XSACD = OPWREC.XEGCD;
  OSGREC.XPGCD = " ";
  OSGREC.XUMCD = " ";

  OSGREC.XLCCD = " ";
  OSGREC.XQACD = OPWREC.XQACD;
  OSGREC.XOTCD = OP1REC.XOTCD;

  OSGREC.OP1CUNDT = OP1REC.OP1CUNDT; /* ccyymmdd format*/

  OSGREC.XWHCD = " ";
  OSGREC.OPWRQSZF = 0;
  OSGREC.OPWRQSZL = 0;
  OSGREC.OP2SSTYN = " ";
  OSGREC.OP2SCLCD = " ";
  OSGREC.OP2SDMCD = " ";

  COMMAREA.CA-USER-WORKAREA-4K = OSGREC.OSGGROUP;


  COMMAREA.CACURRAP = "OP0H";
  COMMAREA.CATOAP = "AV0L";
  XSEXIT();





end // end OP0HSQB

// truncate op1cuoid to xsrsqnbr
Function OP0HSQC()
   /* ***************************************************/
   /* **  this routine exists because xsrrec.xsrsqnbr is*/
   /* **  two bytes (binary) shorter than the customer*/
   /* **  order number.  this will ensure uniformity in*/
   /* **  truncating the most significant digits from the*/
   /* **  order number and used as part of the key in*/
   /* **  the saved xsrrec record during product subs-*/
   /* **  titution.*/
   /* ***************************************************/

  OP0HW01.OP0HWNBR = OP1REC.OP1CUOID;
  XSRREC.XSRSQNBR = OP0HW01.OP0HWNB2;



end // end OP0HSQC

// save op0hm005/010 to oskrec
Function OP0HSQD()
   /* ***************************************************/
   /* **  This routine saves the map of op0h either from*/
   /* **  the multiple entry screen (form flow) or from*/
   /* **  the single product entry screen (phone flow or*/
   /* **  add product) into the xsrrec map save area.*/
   /* **  These values will be restored to the map after*/
   /* **  coming back from substitution in another state-*/
   /* **  ment group.*/
   /* ***************************************************/



  if (OPWREC.OPWSFLOW == "1") /* multiple entry*/
    OPASUB = 1;
    while (OPASUB <= 6)
      OSKREC.OSKSUBFL[OPASUB] = OP0HM005.OP0HMSBF[OPASUB]; /* rqt fl*/
      OSKREC.SY1STNBR[OPASUB] = OP0HM005.SY1STNBR[OPASUB]; /* style*/
      OSKREC.SY2CLRID[OPASUB] = OP0HM005.SY2CLRID[OPASUB]; /* color*/
      OSKREC.XDMCD[OPASUB] = OP0HM005.XDMCD[OPASUB]; /* dim*/
      OSKREC.KUIPRDID[OPASUB] = OP0HM005.KUIPRDID[OPASUB]; /* cu sty*/
      OSKREC.OSKDUPSZ[OPASUB] = OP0HM005.OP0HMDSZ[OPASUB]; /* dup sz*/
     /* MOVE OP0HM005.XSZCD(OPASUB) TO OSKREC.XSZCD(OPASUB);*/
                                   /* std sz dist*/
      OSKREC.OSKFSZ[OPASUB] = OP0HM005.OP0HMFSZ[OPASUB]; /* fst sz*/
      OSKREC.OSKLSZ[OPASUB] = OP0HM005.OP0HMLSZ[OPASUB]; /* lst sz*/
      OSKREC.OP2TONOQ[OPASUB] = OP0HM005.OP2TORGQ[OPASUB]; /* ord qty*/
      OSKREC.XQACD[OPASUB] = OP0HM005.XQACD[OPASUB]; /* qual cd*/
      OSKREC.XSDCD[OPASUB] = OP0HM005.PC2INSEG[OPASUB]; /* spec cd*/
      OSKREC.XPGCD[OPASUB] = OP0HM005.XPGCD[OPASUB]; /* pkg cd*/
      OSKREC.XUMCD[OPASUB] = OP0HM005.XUMCD[OPASUB]; /* uom*/
      OPASUB = OPASUB + 1;
    end

      /* for the product requesting for a substitute, reset the*/
      /* request flag to 'n' so as not to process it again when*/
      /* coming back from substitution.*/

    OSKREC.OSKSUBFL[OSGPRSUB] = "N";

  else /* single entry*/
    OSKREC.SY1STNBR[1] = OP0HM010.SY1STNBR; /* style*/
    OSKREC.SY2CLRID[1] = OP0HM010.SY2CLRID; /* color*/
    OSKREC.XDMCD[1] = OP0HM010.XDMCD; /* dimension*/
    OSKREC.KUIPRDID[1] = OP0HM010.KUIPRDID; /* cust style*/
    OSKREC.OSKDUPSZ[1] = OP0HM010.OP0HMDPS; /* dup prev size*/
   /* MOVE OP0HM010.XSZCD TO OSKREC.XSZCD(1);         /* std sz dist*/
    OSKREC.OSKFSZ[1] = OP0HM010.OP0HMFSZ; /* first size*/
    OSKREC.OSKLSZ[1] = OP0HM010.OP0HMLSZ; /* last size*/
    OSKREC.OP2TONOQ[1] = OP0HM010.OP2TORGQ; /* ordered qty*/
    OSKREC.XQACD[1] = OP0HM010.XQACD; /* quality code*/
    OSKREC.XSDCD[1] = OP0HM010.PC2INSEG; /* spec code*/
    OSKREC.XPGCD[1] = OP0HM010.XPGCD; /* pkg code*/
    OSKREC.XUMCD[1] = OP0HM010.XUMCD; /* unit of measure*/
  end




end // end OP0HSQD

// write xsrrec
Function OP0HSQE()



  set SQLCA empty;

  call "IO3400" ("A ", SQLCA, XSRREC) {isNoRefresh = yes, isExternal = yes};


  if (SQLCA.VAGen_SQLCODE == 0) /* good return, clear*/
    return;
  else
    TA1REC.TA1DBASE = "DCORP"; /* data base name*/
    TA1REC.TA1TBLVU = "VCSPAD01"; /* table view*/
    TA1REC.TA1TBLKE = XSRREC.XSRGROUP; /* key value*/
    TA1REC.TA1LOCAT[1] = "A"; /* action*/
    TA1REC.TA1LOCAT[2] = "OP0HSQE"; /* statement group location*/
    TA1REC.TA1LOCAT[3] = "IO3400"; /* i/o mod*/
    XSOPS02(); /* common abend*/

  end

   /* **********************************************************/
end // end OP0HSQE

// OP6410 post sys routine
Function XSOPS-OP6410-PSRTN()
   /* TT#4654  RSHAIK  03/15/2000*/
   /* This SGRP handle the return code '03' from OP1640*/
             /* ********************************************************/
             /* * post routine for calls to op6410                   **/
             /* ********************************************************/

  set TAEREC empty;
   /* TA1REC  - Data is displayed and written to error log*/


  TA1REC.TA1TYPE = "APPL"; /* abend type*/
  TA1REC.TA1FUNC = "POST"; /* abend func*/
  TA1REC.TA1DBASE = OP10REC.OP10-RETURN-DBASE; /* data base*/
  TA1REC.TA1TBLVU = OP10REC.OP10-RETURN-TBLVU; /* table view*/
  TA1REC.TA1TBLKE = OP10REC.OP10-RETURN-KEY; /* key*/

   /* TAEREC - Data is only displayed on screen*/

  TAEREC.TAEDESC1 = "BAD RETURN FROM OP6410 - RETURN CODE";
  if (OP10REC.OP10-RETURN-CODE == "03")
    TAEREC.TAEDESC2 = "03 - DEAD LOCK OCCURED";
  end
  VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
  VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
  sysLib.rollback();
  VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
  
  try
    call "TA0020" (TA1REC, TAEREC) {isExternal = yes};
  end /* abend module*/

end // end XSOPS-OP6410-PSRTN

//*** RECORD=OP0HW01 ****
// 03/16/00     RSHAIK    Added the following variables as part
// TT#4654                of SPAIN TRADE MARK project.
//                        OP0HW-PRODUCT-INV-FLAG,
//                        OP0HW-MUL-PRODUCT-FLAG &
//                        OP0HW-PROD-DLOCK-FLAG
// ***********************
Record OP0HW01 type basicRecord
  10 XLCCD XLCCD ; 
  10 XQACD XQACD ; 
  10 OP0HWSKA OP0HWSKA ; 
  10 OP0HWSPV OP0HWSPV ; 
  10 OP0HWPSD OP0HWPSD ; 
  10 OP0HWFDI OP0HWFDI ; 
  10 OP0HWLDI OP0HWLDI ; 
  10 OP0HWFDD OP0HWFDD ; 
  10 OP0HWLDD OP0HWLDD ; 
  10 OP0HWFSZ OP0HWFSZ ; 
  10 OP0HWLSZ OP0HWLSZ ; 
  10 OP0HWPRD OP0HWPRD ; 
    15 SY1STNBR SY1STNBR ; 
    15 OP0HWSP1 OP0HWSP1 ; 
    15 SY2CLRID SY2CLRID ; 
    15 OP0HWSP2 OP0HWSP2 ; 
    15 XDMCD XDMCD ; 
  10 KUKPCOID KUKPCOID ; 
  10 KUCGRPID KUCGRPID ; 
  10 OP0HWSFL OP0HWSFL ; 
  10 XOTSZIND XOTSZIND ; 
  10 OP0HWSRQ OP0HWSRQ ; 
  10 OP0HWSRC OP0HWSRC ; 
    15 OP0HWSRN OP0HWSRN ; 
      20 OP0HWSRA OP0HWSRA [5] ; 
  10 OP2TORGQ OP2TORGQ ; 
  10 OP0HWDLF OP0HWDLF ; 
  10 OP0HWOQC OP0HWOQC ; 
  10 OP0HWSZM OP0HWSZM ; 
    15 OP0HWSZ1 OP0HWSZ1 ; 
    15 OP0HWSZ2 OP0HWSZ2 ; 
    15 OP0HWSZ3 OP0HWSZ3 ; 
    15 OP0HWSZ4 OP0HWSZ4 ; 
    15 * char(42) ; 
  10 OP0HWPST OP0HWPST ; 
  10 OP0HWBDF OP0HWBDF ; 
  10 OP0HWFND OP0HWFND ; 
  10 OP0HWFSF OP0HWFSF ; 
  10 OP0HWLSF OP0HWLSF ; 
  10 OP0HWNAS OP0HWNAS [6] ; 
  10 OP2TONOQ OP2TONOQ [6] ; 
  10 OP2TOHRQ OP2TOHRQ [6] ; 
  10 OP0HWDQT OP0HWDQT ; 
  10 OP0HWQTY OP0HWQTY ; 
  10 OP0HWDKY OP0HWDKY ; 
    15 OP0HWDK1 OP0HWDK1 ; 
    15 OP0HWDK2 OP0HWDK2 ; 
    15 OP0HWDK3 OP0HWDK3 ; 
    15 OP0HWDK4 OP0HWDK4 ; 
    15 OP0HWDK5 OP0HWDK5 ; 
    15 OP0HWDK6 OP0HWDK6 ; 
    15 OP0HWDK7 OP0HWDK7 ; 
  10 OP0HWAOF OP0HWAOF ; 
  10 OP0HWPF5 OP0HWPF5 ; 
  10 OP0HWNBR OP0HWNBR ; 
    15 OP0HWNB1 OP0HWNB1 ; 
    15 OP0HWNB2 OP0HWNB2 ; 
  10 OP0HWNPR OP0HWNPR ; 
  10 XBDRWOFL XBDRWOFL ; 
  10 OP0HWEKY OP0HWEKY ; 
    15 OP0HWEK1 OP0HWEK1 ; 
    15 OP0HWEK2 OP0HWEK2 ; 
    15 OP0HWEK3 OP0HWEK3 ; 
    15 OP0HWEK4 OP0HWEK4 ; 
    15 OP0HWEK5 OP0HWEK5 ; 
    15 OP0HWEK6 OP0HWEK6 ; 
    15 OP0HWEK7 OP0HWEK7 ; 
  10 OP0HWMBF OP0HWMBF ; 
  10 OP0HWSTY OP0HWSTY ; 
  10 OP0HWCLR OP0HWCLR ; 
  10 OP0HWKEY OP0HWKEY ; 
    15 OP0HWK01 OP0HWK01 ; 
    15 * char(1) ; 
    15 OP0HWK02 OP0HWK02 ; 
    15 * char(1) ; 
    15 OP0HWK03 OP0HWK03 ; 
    15 * char(1) ; 
    15 OP0HWK04 OP0HWK04 ; 
    15 * char(1) ; 
    15 OP0HWK05 OP0HWK05 ; 
    15 * char(1) ; 
    15 OP0HWK06 OP0HWK06 ; 
    15 * char(1) ; 
    15 OP0HWK07 OP0HWK07 ; 
    15 * char(1) ; 
    15 OP0HWK08 OP0HWK08 ; 
    15 * char(1) ; 
    15 OP0HWK09 OP0HWK09 ; 
    15 * char(1) ; 
    15 OP0HWK10 OP0HWK10 ; 
    15 * char(1) ; 
    15 OP0HWK11 OP0HWK11 ; 
    15 * char(1) ; 
    15 OP0HWK12 OP0HWK12 ; 
    15 * char(1) ; 
    15 OP0HWK13 OP0HWK13 ; 
    15 * char(1) ; 
    15 OP0HWK14 OP0HWK14 ; 
    15 * char(1) ; 
    15 OP0HWK15 OP0HWK15 ; 
    15 * char(1) ; 
    15 OP0HWK16 OP0HWK16 ; 
    15 * char(1) ; 
    15 OP0HWK17 OP0HWK17 ; 
  10 OP0HWBBD OP0HWBBD ; 
  10 SYCDATA SYCDATA ; 
  10 OP0HW-CUST-LOGO-FL OP0HW-CUST-LOGO-FL ; 
  10 OP0HW-WSY2000-FND-FLAG OP0HW-WSY2000-FND-FLAG ; 
  10 OP0HW-WSY2000-POST-1 OP0HW-WSY2000-POST-1 ; 
    15 OP0HW-WSY2000-GPC-CD OP0HW-WSY2000-GPC-CD ; 
    15 OP0HW-WSY2000-STY-NBR OP0HW-WSY2000-STY-NBR ; 
    15 OP0HW-WSY2000-COLR-CD OP0HW-WSY2000-COLR-CD ; 
    15 OP0HW-WSY2000-DIM-CD OP0HW-WSY2000-DIM-CD ; 
    15 OP0HW-WSY2000-PROD-REG-CD OP0HW-WSY2000-PROD-REG-CD ; 
    15 OP0HW-WSY2000-RETURN-CD OP0HW-WSY2000-RETURN-CD ; 
  10 OP0HWFN2 OP0HWFN2 ; 
  10 OP0HW-PRODUCT-INV-FLAG char(1) ; // SPAIN/CANARY compliant chk fl
  10 OP0HW-MUL-PRODUCT-FLAG char(1) ; // Multi product screen CHK flag
  10 OP0HW-PROD-DLOCK-FLAG char(1) ; // dead lock indicator flag
end // end OP0HW01

//*** RECORD=OP0HW02 ****
// ; ws version of op2rec
// ;
// ; 03/11/92  Jloyer   DB2 chgs:  chgd op0hw02 due to changes
//                      in op2rec.  Chgd length from 277 to 279
// ***********************
Record OP0HW02 type basicRecord
  5 OP2GROUP OP2GROUP ; 
    10 OP2KEY OP2KEY ; 
      15 OP1PARTN OP1PARTN ; 
      15 OP1CUOID OP1CUOID ; 
      15 OP1NORID OP1NORID ; 
      15 OP2LNINB OP2LNINB ; 
    10 OP2CPLNB OP2CPLNB ; 
    10 XGPCD XGPCD ; 
    10 SY1STNBR SY1STNBR ; 
    10 SY2CLRID SY2CLRID ; 
    10 XDMCD XDMCD ; 
    10 KUIPRDID KUIPRDID ; 
    10 XUMCD XUMCD ; 
    10 XOWCD XOWCD ; 
    10 OP2PRDSF OP2PRDSF ; 
    10 OP2SSTYN OP2SSTYN ; 
    10 OP2SCLCD OP2SCLCD ; 
    10 OP2SDMCD OP2SDMCD ; 
    10 OP2SUBQT OP2SUBQT ; 
    10 OPRBNOID OPRBNOID ; 
    10 OP2TDRWQ OP2TDRWQ ; 
    10 OP2CGPCD OP2CGPCD ; 
    10 OP2KSTYF OP2KSTYF ; 
    10 OP2GTSZF OP2GTSZF ; 
    10 XEGCD XEGCD ; 
    10 PC2INSEG PC2INSEG ; 
    10 XPGCD XPGCD ; 
    10 XBK-BK-SESN-CD XBK-BK-SESN-CD ; 
    10 OP-BK-YR OP-BK-YR ; 
    10 OP-BK-MO OP-BK-MO ; 
    10 OP2MSCDP OP2MSCDP ; 
    10 OP2PGRPF OP2PGRPF ; 
    10 OP2FSTFL OP2FSTFL ; 
    10 XQACD XQACD ; 
    10 OP2LNIST OP2LNIST ; 
    10 OP2LNSDT OP2LNSDT ; 
    10 XBRCD XBRCD ; 
    10 XDNCD XDNCD ; 
    10 XRSCD XRSCD ; 
    10 XAFCD XAFCD ; 
    10 OP1ALFDT OP1ALFDT ; 
    10 OP1BOFL OP1BOFL ; 
    10 XHDCD XHDCD [5] ; 
    10 XHDCHG XHDCHG [5] ; 
    10 OP2HCHGO OP2HCHGO [5] ; 
    10 PWRLBCD PWRLBCD [2] ; 
    10 OP-CUST-LABL-PRTFL OP-CUST-LABL-PRTFL ; 
    10 XOMCD XOMCD [4] ; 
    10 XMTCD XMTCD [4] ; 
    10 OP2OMQTY OP2OMQTY [4] ; 
    10 OP2OMDT OP2OMDT [4] ; 
    10 OP1MTREP OP1MTREP [4] ; 
    10 OP2GBLOF OP2GBLOF ; 
    10 OP2PRCOF OP2PRCOF ; 
    10 OP2PRCVF OP2PRCVF ; 
    10 OP2TOBKQ OP2TOBKQ ; 
    10 OP2TORGQ OP2TORGQ ; 
    10 OP2TONOQ OP2TONOQ ; 
    10 OP2TALCQ OP2TALCQ ; 
    10 OP2TOHRQ OP2TOHRQ ; 
    10 OP2TWIPQ OP2TWIPQ ; 
    10 OP2TSHPQ OP2TSHPQ ; 
    10 OP2TCNLQ OP2TCNLQ ; 
    10 OP2AUPRC OP2AUPRC ; 
    10 OP2LNIVL OP2LNIVL ; 
    10 OP2NSIZE OP2NSIZE ; 
    10 XDZ-DATA-DIST-CD XDZ-DATA-DIST-CD ; 
    10 ZZ-CS400-CHNG-DT ZZ-CS400-CHNG-DT ; 
    10 ZZ-CS400-CHNG-HHMM ZZ-CS400-CHNG-HHMM ; 
    10 ZZ-DS400-CHNG-DT ZZ-DS400-CHNG-DT ; 
    10 ZZ-DS400-CHNG-HHMM ZZ-DS400-CHNG-HHMM ; 
    10 ZZZSZCHG ZZZSZCHG ; 
    10 ZZZSDT ZZZSDT ; 
    10 ZZZSTM ZZZSTM ; 
    10 ZZZCHGDT ZZZCHGDT ; 
    10 ZZZCHGTM ZZZCHGTM ; 
    10 ZZZCHGCT ZZZCHGCT ; 
end // end OP0HW02

//*** RECORD=OP0HW03 ****
// ; ws version of op3rec
// ;
// ; 03/11/92  JLoyer   DB2 chgs: chgd op0hw03 due to changes
// ;                    in op3rec.  Changed the record length
// ;                    from 1137 to 1139.
// ***********************
Record OP0HW03 type basicRecord
  5 OP3GROUP OP3GROUP ; 
    10 OP2KEY OP2KEY ; 
      15 OP1PARTN OP1PARTN ; 
      15 OP1CUOID OP1CUOID ; 
      15 OP1NORID OP1NORID ; 
      15 OP2LNINB OP2LNINB ; 
    10 OP2CPLNB OP2CPLNB ; 
    10 XGPCD XGPCD ; 
    10 SY1STNBR SY1STNBR ; 
    10 SY2CLRID SY2CLRID ; 
    10 XDMCD XDMCD ; 
    10 KUIPRDID KUIPRDID ; 
    10 XUMCD XUMCD ; 
    10 XOWCD XOWCD ; 
    10 OP2PRDSF OP2PRDSF ; 
    10 OP2SSTYN OP2SSTYN ; 
    10 OP2SCLCD OP2SCLCD ; 
    10 OP2SDMCD OP2SDMCD ; 
    10 OP2SUBQT OP2SUBQT ; 
    10 OPRBNOID OPRBNOID ; 
    10 OP2TDRWQ OP2TDRWQ ; 
    10 OP2CGPCD OP2CGPCD ; 
    10 OP2KSTYF OP2KSTYF ; 
    10 OP2GTSZF OP2GTSZF ; 
    10 XEGCD XEGCD ; 
    10 PC2INSEG PC2INSEG ; 
    10 XPGCD XPGCD ; 
    10 XBK-BK-SESN-CD XBK-BK-SESN-CD ; 
    10 OP-BK-YR OP-BK-YR ; 
    10 OP-BK-MO OP-BK-MO ; 
    10 OP2MSCDP OP2MSCDP ; 
    10 OP2PGRPF OP2PGRPF ; 
    10 OP2FSTFL OP2FSTFL ; 
    10 XQACD XQACD ; 
    10 OP2LNIST OP2LNIST ; 
    10 OP2LNSDT OP2LNSDT ; 
    10 XBRCD XBRCD ; 
    10 XDNCD XDNCD ; 
    10 XRSCD XRSCD ; 
    10 XAFCD XAFCD ; 
    10 OP1ALFDT OP1ALFDT ; 
    10 OP1BOFL OP1BOFL ; 
    10 XHDCD XHDCD [5] ; 
    10 XHDCHG XHDCHG [5] ; 
    10 OP2HCHGO OP2HCHGO [5] ; 
    10 PWRLBCD PWRLBCD [2] ; 
    10 OP-CUST-LABL-PRTFL OP-CUST-LABL-PRTFL ; 
    10 XOMCD XOMCD [4] ; 
    10 XMTCD XMTCD [4] ; 
    10 OP2OMQTY OP2OMQTY [4] ; 
    10 OP2OMDT OP2OMDT [4] ; 
    10 OP1MTREP OP1MTREP [4] ; 
    10 OP2GBLOF OP2GBLOF ; 
    10 OP2PRCOF OP2PRCOF ; 
    10 OP2PRCVF OP2PRCVF ; 
    10 OP2TOBKQ OP2TOBKQ ; 
    10 OP2TORGQ OP2TORGQ ; 
    10 OP2TONOQ OP2TONOQ ; 
    10 OP2TALCQ OP2TALCQ ; 
    10 OP2TOHRQ OP2TOHRQ ; 
    10 OP2TWIPQ OP2TWIPQ ; 
    10 OP2TSHPQ OP2TSHPQ ; 
    10 OP2TCNLQ OP2TCNLQ ; 
    10 OP2AUPRC OP2AUPRC ; 
    10 OP2LNIVL OP2LNIVL ; 
    10 OP2NSIZE OP2NSIZE ; 
    10 XDZ-DATA-DIST-CD XDZ-DATA-DIST-CD ; 
    10 ZZ-CS400-CHNG-DT ZZ-CS400-CHNG-DT ; 
    10 ZZ-CS400-CHNG-HHMM ZZ-CS400-CHNG-HHMM ; 
    10 ZZ-DS400-CHNG-DT ZZ-DS400-CHNG-DT ; 
    10 ZZ-DS400-CHNG-HHMM ZZ-DS400-CHNG-HHMM ; 
    10 ZZZSZCHG ZZZSZCHG ; 
    10 ZZZSDT ZZZSDT ; 
    10 ZZZSTM ZZZSTM ; 
    10 ZZZCHGDT ZZZCHGDT ; 
    10 ZZZCHGTM ZZZCHGTM ; 
    10 ZZZCHGCT ZZZCHGCT ; 
    10 OP3SZARY OP3SZARY [40] ; 
      15 OP3SZAFL OP3SZAFL ; 
      15 OP3PRCOF OP3PRCOF ; 
      15 SY5PRCUN SY5PRCUN ; 
      15 OP3ORGQT OP3ORGQT ; 
      15 OP3ONOQT OP3ONOQT ; 
      15 OP3ALQT OP3ALQT ; 
      15 OP3OHRQT OP3OHRQT ; 
      15 OP3WPRQT OP3WPRQT ; 
      15 OP3SHPQT OP3SHPQT ; 
      15 OP3CNLQT OP3CNLQT ; 
end // end OP0HW03

// custom logo flag
DataItem OP0HW-CUST-LOGO-FL char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem OP0HW-WSY2000-COLR-CD char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem OP0HW-WSY2000-DIM-CD char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// sycrec found flag-call-sy2000
DataItem OP0HW-WSY2000-FND-FLAG char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem OP0HW-WSY2000-GPC-CD char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// sycrec posting area   -sy2000
DataItem OP0HW-WSY2000-POST-1 char(17)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem OP0HW-WSY2000-PROD-REG-CD char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem OP0HW-WSY2000-RETURN-CD char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem OP0HW-WSY2000-STY-NBR char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// accessories order flag
DataItem OP0HWAOF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// blank bulk draw flag
DataItem OP0HWBBD char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// bulk draw type flag
DataItem OP0HWBDF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// sy2clrid for io5470 call
DataItem OP0HWCLR char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// display part char
DataItem OP0HWDK1 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// display cust/bulk id
DataItem OP0HWDK2 num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// display nike ord id
DataItem OP0HWDK3 num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// display line item num
DataItem OP0HWDK4 num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// display style
DataItem OP0HWDK5 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// display color
DataItem OP0HWDK6 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// display rtncd from db1000
DataItem OP0HWDK7 num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// display key
DataItem OP0HWDKY char(31)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// del product verification flag
DataItem OP0HWDLF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// total deleted qty
DataItem OP0HWDQT decimal(7)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// error diag part char
DataItem OP0HWEK1 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// error diag cust id
DataItem OP0HWEK2 num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// error diag nike ord id
DataItem OP0HWEK3 num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// error diag company id
DataItem OP0HWEK4 num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// error diag store id
DataItem OP0HWEK5 num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// error diag dept id
DataItem OP0HWEK6 num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// error diag gpc
DataItem OP0HWEK7 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// error diag key
DataItem OP0HWEKY char(28)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// first desc size to dup
DataItem OP0HWFDD char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// first int size to dup
DataItem OP0HWFDI num(5)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

DataItem OP0HWFN2 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// found flag
DataItem OP0HWFND char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// first size found flag
DataItem OP0HWFSF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// first size
DataItem OP0HWFSZ num(5)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// error diag order num
DataItem OP0HWK01 num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// nike order id
DataItem OP0HWK02 num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// err diag sls pgm
DataItem OP0HWK03 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// err diag life cycle
DataItem OP0HWK04 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// err diag qual code
DataItem OP0HWK05 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// err diag prod code
DataItem OP0HWK06 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// err diag style
DataItem OP0HWK07 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// err diag color
DataItem OP0HWK08 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// err diag dim
DataItem OP0HWK09 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// err diag gpc
DataItem OP0HWK10 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// err diag division
DataItem OP0HWK11 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// err diag sales office
DataItem OP0HWK12 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// err diag sport activity
DataItem OP0HWK13 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// err diag acct class
DataItem OP0HWK14 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// err diag customer
DataItem OP0HWK15 num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// err diag store
DataItem OP0HWK16 num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// err diag department
DataItem OP0HWK17 num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// error diag key OP1660
DataItem OP0HWKEY char(68)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// last desc size to dup
DataItem OP0HWLDD char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// last int size to dup
DataItem OP0HWLDI num(5)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// last size found flag
DataItem OP0HWLSF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// last size
DataItem OP0HWLSZ num(5)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// blnk pgm found for mult hdrs
DataItem OP0HWMBF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// number of active sizes
DataItem OP0HWNAS num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// numeric 5 digit redefine area
DataItem OP0HWNB1 num(5)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// numeric 4 digit redefine area
DataItem OP0HWNB2 num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// numeric 9 digit workarea
DataItem OP0HWNBR num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// new line selected sw for subs
DataItem OP0HWNPR char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// one quality code default flag
DataItem OP0HWOQC char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// pf5 key (subst) allowed (y/n)
DataItem OP0HWPF5 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// product number formatted
DataItem OP0HWPRD char(13)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// prev sizes to dup flag
DataItem OP0HWPSD char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// prev style for defaulting
DataItem OP0HWPST char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// ws qty field
DataItem OP0HWQTY decimal(7)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// style error flag
DataItem OP0HWSFL char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dup anchor skipped flag(sla)
DataItem OP0HWSKA char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// product separator 1
DataItem OP0HWSP1 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// product separator 2
DataItem OP0HWSP2 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// selected product to view fl
DataItem OP0HWSPV char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// size redefine chr array
DataItem OP0HWSRA char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// size redefine char format
DataItem OP0HWSRC char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// size redefine numeric format
DataItem OP0HWSRN num(5)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// sizes required flag
DataItem OP0HWSRQ char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// sy1stnbr for io5470 call
DataItem OP0HWSTY char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// size message part 1
DataItem OP0HWSZ1 char(20)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// size message first size
DataItem OP0HWSZ2 char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// size message part 3
DataItem OP0HWSZ3 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// size message last size
DataItem OP0HWSZ4 char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// size error message
DataItem OP0HWSZM char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

