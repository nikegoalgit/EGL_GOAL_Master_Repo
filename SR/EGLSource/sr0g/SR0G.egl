package sr0g;
import az.common.*;
import corpcom1.*;
import corpcom4.*;
import corpcom5.*;
import corpcom6.*;
import corpcom7.*;
import corpx1.*;
import corpx2.*;
import corpz3.*;
import dg.common.*;
import fy.common.*;
import in1.common.*;
import ku.common.*;
import ni.common.*;
import op.common.*;
import pk.common.*;
import sm.common.*;
import sp.common.*;
import sr.common.*;
import ta.common.*;
import tf.common.*;
import ts.common.*;
import vv.common.*;
//*** PROGRAM=SR0G ****
// ;********************** sr0g: balance batch ****************
// description:
// -----------
//  the purpose of this screen is to inform the user whether
// the batchs entered are in balance or not.
//  two figures are checked: the actual number of orders in
// this batch and the actual number of units in this batch.
// these are checked against the user entered number of orders
// and the user entered number of units.
//  warehouse code is entered in one of two ways:
//   a. the user may enter it
//   b. if the user is coming into this application from an-
//      other application within the ship recon system the
//      warehouse the user was working with in that previous
//      application is displayed here. (its passed thru the
//      commarea). the user may of course change it if he/she
//      wishs.
//  the screen has ten lines of data with the following fields
// fields on each line: pick number, number of orders, actual
// number of orders, number of units and actual number of
// units. the user will enter warehouse code (or it will be al-
// ready entered as previously described) one time. it applies
// to all the batchs on the screen. they will also enter (up to
// ten times) pick number, number of orders and number of
// units.
//   actual number of orders and actual number of units are
// displayed back to the user at the appropriate time.
//   the user may enter the up to ten batchs one after the
// other on the screen or may have intervening blank lines.
//   the program checks for the usual pf keys and if necessary
// transfers to the appropriate applications depending on the
// pf key hit.
//   next the ten lines are reshuffled so that there are no
// intervening blank lines.
//   next warehouse code is edited against the table xwhtbl.
//   next it checks to make sure data has been entered.
//   next a check is made to make sure all required fields
// have been entered.
//   next a check is made to see if any duplicate pick numbers
// have been entered.
//   next each of the ten lines with data is edited.
// first the batch record is read verifying it exists. if so
// the actual number of orders and the actual number of units
// from this record is moved to the screen.
//   then the batch status is checked. batch status must be a
// 'p' (prepared) or a 'h' (hold) in order for a batch to be
// balanced.  The batch is then checked for an 'h'(hold)
// status.  If the status is an 'h' then the user must accept
// the batch in order for it to be balanced.
//   if the batch status is ok then the number of orders and
// the number of units is checked to see if they are equal
// to the actual number of orders and the actual number of
// units respectively. if either or both of these is not true
// then the batch may not be balanced.
//   if there are no errors the batch(s) are updated with the
// change date and time and the batch status is set to 'b'
// (balanced).
// ;
// ; MAINTENANCE HISTORY
// ;
// CONTROL    DATE    USERID  DESCRIPTION OF CHANGE
// -------  --------  ------  ---------------------------------
// ; 9/23/86    tlewis       creation
// ; 9/29/88    mwalke       log #sr 43-added additional check
// ;                         processing for batch status of h,
// ;                         hold.
// ;10/20/88    jwood        added call option NONCSP
// ;03/20/89    jwood        added XSSEGTR logic
// ;11/02/89    mwalto       add nil logic and date check
// ;11/30/89    jcampb       remove date check for nil orders
// SR#0     02/05/93  SPOPA   When checking direct ship orders
//                            against VNLPLO01 to ensure that
//                            the shipment id is not zero,
//                            ignore the row if pick schedule
//                            is not the same as the schedule
//                            being balanced.
// SR9001   02/28/94  HKEMPE  Generate/Compile to pick up
//                            revised COMMAREA and XWHTBL.
// SR##     12/05/97  dkesle  add pf22 xfer to az0a and add #
//                            of bols and bols sent to screen
// SR##     03/11/98  dkesle  make xfer to az0a be pf5 key
// Y2Kfix   03/26/98  dpage   Y2K modifcation in sr0gs12
// SR##     04/22/98  CBRINE  Use VAZCTN01 instead of VAZCIT01
// asnproj  04/23/98  DKESLE  do not count 'rl' status in
//                            bols sent
// asnproj  04/28/98  DKESLE  display error msg and don't
//                            balancing if no azhdr info found
// asnproj  05/05/98  GRAY    change S5 to S7 forBOL counts
// tblchgs  06/17/98  tdaugh  Regen'd for csprec changes
// dlvrusa  02/21/01  rnunna  Display number of SKUS and
//                            Highlite all the error schedules
//                            at once.
//                            Access OTP first to get the right
//                            key when retrieving the order
//                            either on Shiprec or NIL.
//                            Modified the follwoing to return
//                            correct error message after DB2
//                            access.
//                            SR0GS21, SROGS22, SR0GS23,
//                            SR0GS24, SROGS25, SR0GS26.
// *********************
Program SR0G type textUIProgram //VAGen Info - main text program
  {
  includeReferencedFunctions = yes, allowUnqualifiedItemReferences = yes, 
  throwNrfEofExceptions = yes, handleHardIOErrors = no, V60ExceptionCompatibility = yes, 
  I4GLItemsNullable = no, textLiteralDefaultIsString = no, localSQLScope = yes, 
  msgTablePrefix = "SR00", inputRecord = COMMAREA, segmented = yes
  }

  // Data Declarations
  COMMAREA COMMAREA ; // record
  SKUREC SKUREC; // record
  SQLCA SQLCA; // record
  SR0GW01 SR0GW01; // record
  SR0GW02 SR0GW02; // record
  SR0GW03 SR0GW03; // record
  SR0GW04 SR0GW04; // record
  SR1REC SR1REC; // record
  SR2REC SR2REC; // record
  SRWREC SRWREC; // record
  TA1REC TA1REC; // record
  TA2REC TA2REC; // record
  TAEREC TAEREC; // record
  TSVREC TSVREC; // record
  VAZCTN01 VAZCTN01; // record
  VAZHDR01 VAZHDR01; // record
  VOPPKH05 VOPPKH05; // record

  // VAGen Info - items needed for migration
  VAGen_EZESYS char(8);
  VAGen_EZEREPLY num(1);
  VAGen_EZE_WAIT_TIME bin(9,2);
  VAGen_EZE_ITEMLEN int;

  // Use Declarations
  use XWHTBL {deleteAfterUse = yes}; // table
  use SR0GM.SR0GM020 // form
   {
    pfKeyEquate = no
  };

  function main()
    // VAGen Info - initialization needed for migration
    VAGen_EZESYS = VGLib.getVAGSysType();
    SR0G010: SR0G010();
    goto SR0G020; /* go to balance batch scrn*/
    SR0G020: SR0G020();
     /* -----------  sr0g020 flow  -----------------*/

     /* test for pa2 and save warehouse code and name*/

    if (converseVar.eventKey is pa2)
      SR0GW02.XWHCD = SR0GM020.XWHCD;
      SR0GW02.XWHABRV = SR0GM020.XWHABRV;
      goto SR0G010; /* back to initialize screen*/
    else
      if (SR0GM020.SR0GMMSG != " "
       || SR0GM020.VAGen_EZEMSG != " "
       || converseVar.validationMsgNum != 0)
        set SR0GM020 alarm;
        goto SR0G020; /* errors/msg's - redisplay scrn*/
      else
        if (SRWREC.SRWMSG != " ")
          SR0GM020.SR0GMMSG = SRWREC.SRWMSG;
          set SR0GM020 alarm;
          goto SR0G020; /* errors/msg's - redisplay scrn*/
        else
          goto SR0G040; /* no errors so update the*/
        end /* batch headers*/
      end
    end
     /* ----------- end sr0g020 flow ------------------*/
    SR0G040: SR0G040();
    goto SR0G020; /* back to converse screen*/
  end // end main
end // end SR0G

// init balance batch scrn
Function SR0G010()

    /* -------------  execute process sr0g010  --------------*/

  XSENTRY(); /* appl entry security*/

  XSSEGTR(); /* set segmented transaction id*/



  VGVar.handleHardIOErrors = 1; /* return all file errors*/
  converseVar.commitOnConverse = 1; /* commit on every converse*/
  converseVar.segmentedMode = 1; /* force segmented run*/


  set SR1REC empty;
  set SQLCA empty;
  set TA1REC empty;
  set TA2REC empty;
  set SR0GW01 empty;
  set SR0GW03 empty;
  set SR0GW04 empty;
  set SRWREC empty;
  set SR0GM020 initial;
  set SR0GM020.PK1PKSCH[1] cursor;
  SR0GW01.SR0GWIDX = 1;
  while (SR0GW01.SR0GWIDX <= 10) /* initialize array*/
    SR0GM020.SR0GMAHD[SR0GWIDX] = "N";
    set SR0GMAHD[SR0GWIDX] skip, invisible;
    SR0GW01.SR0GWIDX = SR0GW01.SR0GWIDX + 1;
  end

   /* if youre coming from an application outside ship recon*/
   /* move whatever (if anything) is in the item field to*/
   /* the warehouse code on the map.*/

  if (COMMAREA.CAFROMAP != " ")
    SR0GW01.SR0GWFRA = COMMAREA.CAFROMAP;
    if (SR0GWFR1 != "SR")
      SR0GW01.SR0GWITM = COMMAREA.CAITEM;
      SR0GM020.XWHCD = SR0GW01.SR0GWWHS;
    else
      SRWREC.SRWGRP = COMMAREA.CAUSERA;
      SR0GM020.XWHCD = SRWREC.SRWXWHCD;
    end
  else
     /* next sentence.*/
  end



   /* if pa2 was requested then move the last warehouse code the*/
   /* user entered to the screen.*/

  if (converseVar.eventKey is pa2)
    SR0GM020.XWHCD = SR0GW02.XWHCD;
    SR0GM020.XWHABRV = SR0GW02.XWHABRV;
  end



  SR0GM020.SR0GMDT = VGVar.currentShortGregorianDate; /* system date*/


   /* -------------  end process sr0g010  --------------------*/

end // end SR0G010

// converse balance batch scrn
Function SR0G020()
   /* -----------  before stage - sr0g020 -----*/

   /* dlvrusa : modifed this group to perform sr0gs09 independently*/




  converse SR0GM020 ;

   /* -------------------map sr0gm020 conversed------------------*/

  SR0GM020.VAGen_EZEMSG = " ";
  SR0GM020.SR0GMMSG = " "; /* clear all message fields*/
  SRWREC.SRWMSG = " ";

  SRWREC.SRWXWHCD = SR0GM020.XWHCD; /* move warehouse and batch*/

  SR0GW01.SR0GWIDX = 1;
  while (SR0GW01.SR0GWIDX <= 10) /* clear fields if data is not present*/
    if (SR0GM020.PK1PKSCH[SR0GWIDX] == 0
     && SR0GM020.SR0GMNOU[SR0GWIDX] == 0
     && SR0GM020.SR0GMNOO[SR0GWIDX] == 0)
      set SR0GM020.PK1PKSCH[SR0GWIDX] initialAttributes;
      set SR0GM020.SR0GMNOU[SR0GWIDX] initialAttributes;
      set SR0GM020.SR0GMNOO[SR0GWIDX] initialAttributes;
      set SR0GM020.SR0GMAHD[SR0GWIDX] skip, invisible;
    end
    SR0GW01.SR0GWIDX = SR0GW01.SR0GWIDX + 1;
  end

  if (converseVar.eventKey is pf5)
    COMMAREA.CATOAP = "AZ0A";
  end

  XSSRS01(); /* check standard pf keys*/


  SR0GS07(); /* shuffle screen lines*/



  if (converseVar.validationMsgNum != 0 /* invalid pf*/
   || SR0GM020.SR0GMMSG != " ")         /* invalid security*/
    exit stack;
  end

   /* edit warehouse code*/

  SR0GS01(); /* edit warehouse code*/

  if (converseVar.validationMsgNum != 0)
    exit stack;
  end

   /* the following checks to see if data was entered*/


  SR0GW01.SR0GWFL3 = "N"; /* initialize data flag to no*/
  if (converseVar.eventKey is enter)
    SR0GW01.SR0GWIDX = 10;
    while (SR0GW01.SR0GWIDX > 0)
      if (SR0GM020.PK1PKSCH[SR0GWIDX] != 0
       || SR0GM020.SR0GMNOO[SR0GWIDX] != 0
       || SR0GM020.SR0GMNOU[SR0GWIDX] != 0)
        SR0GW01.SR0GWFL3 = "Y";
        SR0GW01.SR0GWIDX = 0;
      else
        SR0GW01.SR0GWIDX = SR0GW01.SR0GWIDX - 1;
      end
    end
  end

  if (SR0GW01.SR0GWFL3 == "Y") /* there is data to edit*/
     /* next sentence*/
  else
    set SR0GM020.PK1PKSCH[1] cursor;
    converseLib.validationFailed(18); /* please enter data*/
    exit stack;
  end





  SR0GS11(); /* check for duplicate pick numbers*/

  if (converseVar.validationMsgNum != 0)
    exit stack;
  else
     /* next sentence*/
  end


   /* dlvrusa start*/

  if (converseVar.eventKey is enter)
    SR0GW01.SR0GWIDX = 1;
    while (SR0GW01.SR0GWIDX <= 10)
      if (SR0GM020.PK1PKSCH[SR0GWIDX] != 0
       || SR0GM020.SR0GMNOO[SR0GWIDX] != 0)
        SR0GS05(); /* check for required fields*/
      end
      SR0GW01.SR0GWIDX = SR0GW01.SR0GWIDX + 1;
    end
  end

  if (converseVar.validationMsgNum != 0) /* there is a error*/
    exit stack;
  else
     /* next sentence*/
  end

   /* dlvrusa end*/

   /* in the next 'if' statement:*/
   /* edit pick schedule number*/
   /* to ten possible times (because ten lines on the screen).*/



  if (converseVar.eventKey is enter)
    SR0GW01.SR0GWIDX = 10;
    while (SR0GW01.SR0GWIDX > 0)
      if (SR0GM020.PK1PKSCH[SR0GWIDX] != 0
       || SR0GM020.SR0GMNOO[SR0GWIDX] != 0
       || SR0GM020.SR0GMNOU[SR0GWIDX] != 0)
        SR0GS02(); /* edit schedule nbr*/
        SR0GW04.SR0GWBTS[SR0GWIDX] = SR1REC.SR1BTST;
        SR0GW01.SR0GWIDX = SR0GW01.SR0GWIDX - 1;
      else
        SR0GM020.SR1QTYSH[SR0GWIDX] = 0;
        SR0GM020.SR1NBORD[SR0GWIDX] = 0;
        SR0GM020.SR0GNBBL[SR0GWIDX] = 0;
        SR0GM020.SR0GSTBL[SR0GWIDX] = 0;
        SR0GM020.SR0GSKUS[SR0GWIDX] = 0;
        SR0GW04.SR0GWBTS[SR0GWIDX] = " ";
        SR0GW01.SR0GWIDX = SR0GW01.SR0GWIDX - 1;
      end
    end
   /* dlvrusa start*/
    SR0GS08(); /* check batch status*/
    SR0GS09(); /* check batch balance*/
   /* dlvrusa end*/
    SR0GS10(); /* check for a batch status of H, hold*/
    exit stack;
  else
    exit stack;
  end

    /* -----------   end of process sr0g020  ------------*/

end // end SR0G020

// update batch headers
Function SR0G040()

   /* ---------------  execute process sr0g040  --------------*/
              /* prepare and update batch headers*/
   /* --------------------------------------------------------*/



  SR0GW01.SR0GWIDX = 1;
  while (SR0GW01.SR0GWIDX <= 10)
    SR0GS12(); /* update batch header*/
  end

   /* if no problems with updates then commit*/

  if (SR0GW01.SR0GWIDX == 11)
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.commit();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
     /* commit the changes*/
    converseLib.validationFailed(70); /* records updated*/
    set SR0GM020.PK1PKSCH[1] cursor;
    SR0GW01.SR0GWIDX = 1;
    while (SR0GW01.SR0GWIDX <= 10) /* reinitialize array*/
      SR0GM020.SR0GMAHD[SR0GWIDX] = "N";
      SR0GW01.SR0GWIDX = SR0GW01.SR0GWIDX + 1;
    end
  else
    exit stack;
  end

   /* -------------  end process sr0g040  --------------------*/

end // end SR0G040

// check std pf keys
Function SR0GS01()


   /* ------------ start stmt grp sr0gs01 -----------------*/

                 /* edit warehouse code*/
   /* Modified to populate SR0GMHD7 and SR0GMHD7*/
   /* -----------------------------------------------------*/

  set SR0GM020.XWHCD initialAttributes;
  set SR0GM020.XWHABRV initialAttributes;
  if (SR0GM020.XWHCD != " ")
    if (SR0GM020.XWHCD in XWHTBL.XWHCD)
      SR0GM020.XWHABRV = XWHTBL.XWHABRV[sysVar.arrayIndex];
    end
    if (sysVar.arrayIndex == 0)
      converseLib.validationFailed(1); /* non-existent warehouse*/
      set SR0GM020.XWHCD cursor, modified, bold;
      SR0GM020.XWHABRV = " ";
    else
      if (XWHTBL.XXXSTAT[sysVar.arrayIndex] != "A")
        converseLib.validationFailed(2); /* inactive warehouse*/
        set SR0GM020.XWHCD cursor, modified, bold;
        set SR0GM020.XWHABRV modified, bold;
      else
        if (XWHTBL.XWTCD[sysVar.arrayIndex] == "01" /* if movers warehouse*/
         && XWHTBL.XWHSTKLF[sysVar.arrayIndex] == "Y")
          SR0GW01.SR0GMVSW = "Y";
          SR0GM020.SR0GMHD3 = "NBR";
          SR0GM020.SR0GMHD4 = "BOLS";
          SR0GM020.SR0GMHD5 = "SENT";
          SR0GM020.SR0GMHD6 = "BOLS";
          SR0GM020.SR0GMHD7 = "NBR";
          SR0GM020.SR0GMHD8 = "SKUS";
        else
          SR0GW01.SR0GMVSW = "N";
          SR0GM020.SR0GMHD3 = " ";
          SR0GM020.SR0GMHD4 = " ";
          SR0GM020.SR0GMHD5 = " ";
          SR0GM020.SR0GMHD6 = " ";
          SR0GM020.SR0GMHD7 = " ";
          SR0GM020.SR0GMHD8 = " ";
        end
        return;
      end
    end
  else
    converseLib.validationFailed(17); /* warehouse code required*/
    set SR0GM020.XWHCD cursor, modified, bold;
  end


   /* -------------   end of stmt grp sr0gs01  ------------*/

end // end SR0GS01

// edit pick nbr,status,balance
Function SR0GS02()


   /* ------------ start stmt grp sr0gs02 -----------------*/

                   /* edit pick nbr*/

   /* -----------------------------------------------------*/

   /* DLVRUSA start*/

   /* SR0GS05;                         /* check for required fields*/
   /* ;*/
   /* IF EZEMNO NE 0;                  /* there is a error*/
   /* EZEFLO;*/
   /* END;*/

   /* DLVRUSA end*/

             /* edit pick schedule number*/

  SR0GW01.SR0GWFL2 = "N"; /* error on btch hdr read*/

  SR0GS03(); /* read batch record*/

  if (SR0GW01.SR0GWFL2 == "Y") /* error on btch hdr read*/
    converseLib.validationFailed(16); /* pick schedule nbr not on file*/
    set SR0GM020.PK1PKSCH[SR0GWIDX] cursor, bold;
    exit stack;
  end

  SR0GW01.SR0GWCNT[SR0GWIDX] = SR1REC.ZZZCHGCT;
  SR0GM020.SR1QTYSH[SR0GWIDX] = SR1REC.SR1QTYSH;
  SR0GM020.SR1NBORD[SR0GWIDX] = SR1REC.SR1NBORD;


  SR0GW01.SR0GWFL1 = "N"; /* initialize error flag*/

  if (SR0GW01.SR0GMVSW == "Y" /* if movers warehouse*/
   && SR0GM020.PK1PKSCH[SR0GWIDX] < 9900000) /* and not direct ship*/
    SR0GS04(); /* get number of bols and sent bols*/
    SR0GM020.SR0GNBBL[SR0GWIDX] = SR0GW01.SR0GNBBL;
    SR0GM020.SR0GSTBL[SR0GWIDX] = SR0GW01.SR0GSTBL;
  else
    SR0GM020.SR0GNBBL[SR0GWIDX] = 0; /* don't show number of bols*/
    SR0GM020.SR0GSTBL[SR0GWIDX] = 0; /* don't show sent bols*/
  end

  if (SR0GW01.SR0GWFL1 == "Y") /* error found in sr0gs04*/
    converseLib.validationFailed(252); /* no azhdr info found*/
    set SR0GM020.PK1PKSCH[SR0GWIDX] cursor, bold;
    exit stack;
  end

   /* DLVRUSA start*/

  SR0GW01.SR0GWFL1 = "N"; /* initialize error flag*/

  SR0GS17(); /* get number of SKUS*/
  SR0GM020.SR0GSKUS[SR0GWIDX] = SR0GW01.SR0GSKUS;

  if (SR0GW01.SR0GWFL1 == "Y") /* error found in sr0gs17*/
    converseLib.validationFailed(258); /* no skus  info found*/
    set SR0GM020.PK1PKSCH[SR0GWIDX] cursor, bold;
    exit stack;
  end

   /* MOVE 'N' TO SR0GW01.SR0GWFL4;    /* initialize batch status error flag*/

   /* SR0GS08;                         /* check batch status*/

   /* IF SR0GW01.SR0GWFL4 = 'Y';*/
   /* EZEFLO;*/
   /* END;*/

   /* MOVE 'N' TO SR0GW01.SR0GWFL1;   /* initialize error flag*/

   /* SR0GS09;                        /* check batch balance*/

   /* IF SR0GW01.SR0GWFL1 EQ 'Y';*/
   /* EZEFLO;*/
   /* END;*/

   /* DLVRUSA end*/

  SR0GW01.SR0GWFL6 = "N"; /* initialize error flag*/

  SR0GS20(); /* check orders assoc. to shipment*/

  if (SR0GW01.SR0GWFL6 == "Y")
    converseLib.validationFailed(160); /* pick sch has nil ords not assoc*/
    set SR0GM020.PK1PKSCH[SR0GWIDX] cursor, bold;
    exit stack;
  end


  if (SR0GM020.SR0GNBBL[SR0GWIDX] != SR0GM020.SR0GSTBL[SR0GWIDX])
    set SR0GM020.PK1PKSCH[SR0GWIDX] cursor, bold;
    converseLib.validationFailed(189);
    exit stack;
  end

   /* -------------   end of stmt grp sr0gs02  ------------*/

end // end SR0GS02

// read hdr batch record
Function SR0GS03()


   /* ------------ start stmt grp sr0gs03 -----------------*/

               /* read hdr batch record*/

   /* -----------------------------------------------------*/
  SR0GW01.SR0GWMSG = " ";

  set SR1REC empty; /* clear batch record*/
  set SQLCA empty;

  SR1REC.XWHCD = SR0GM020.XWHCD; /* set batch header key*/
  SR1REC.PK1PKSCH = SR0GM020.PK1PKSCH[SR0GWIDX];
  call "IO0790" ("S ", SQLCA, SR1REC) {isNoRefresh = yes, isExternal = yes}; /* read batch header*/
  if (SQLCA.VAGen_SQLCODE == 0)
    SR0GW04.SR0GWSHP[SR0GWIDX] = SR1REC.SR1SHPDT; /* keep ship date*/
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      SR0GW01.SR0GWFL2 = "Y"; /* error on btch hdr read*/
    else
      TA1REC.TA1TYPE = "DB2";
      TA1REC.TA1FUNC = "RETN";
      TA1REC.TA1DBASE = "DSHIP";
      TA1REC.TA1TBLVU = "VSRHDR01";
      TA1REC.TA1MAP = " ";
      TA1REC.TA1TBLKE = SR1REC.SR1KEYS;
      TA1REC.TA1PGMNM = "SR0BS03";
      TA1REC.TA1LOC = "READING DB2 VSRHDR01";
      call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
      COMMAREA.CAUSERA = " ";
      XSPF4();
    end
  end




    /* -----------   end of stmt grp sr0gs03  ------------*/

end // end SR0GS03

// edit pick nbr,status,balance
Function SR0GS04()

  SR0GW01.SR0GNBBL = 0;
  SR0GW01.SR0GSTBL = 0;
  SR0GW01.PK-BILL-OF-LADING = 0;
  SR0GW01.PK-BOL-SUB-NBR = 0;

  SR0GS13(); /* open cursor for vazctn01*/
  SR0GS14(); /* fetch first vazctn01 row*/

  while (SQLCA.VAGen_SQLCODE == 0
   && SR0GW01.SR0GWFL1 == "N")
    if (VAZCTN01.PK-BILL-OF-LADING != SR0GW01.PK-BILL-OF-LADING
     || VAZCTN01.PK-BOL-SUB-NBR != SR0GW01.PK-BOL-SUB-NBR)
      SR0GS15(); /* select vazhdr01 for new BOL/Sub*/
      if (SQLCA.VAGen_SQLCODE == 0)
        SR0GW01.SR0GNBBL = SR0GW01.SR0GNBBL + 1;
        if (VAZHDR01.AZ-ASN-STAT-CD == "ST"
         || VAZHDR01.AZ-ASN-STAT-CD == "XL")
          SR0GW01.SR0GSTBL = SR0GW01.SR0GSTBL + 1;
        end
      else
        SR0GW01.SR0GWFL1 = "Y";
      end
    end
    SR0GW01.PK-BILL-OF-LADING = VAZCTN01.PK-BILL-OF-LADING;
    SR0GW01.PK-BOL-SUB-NBR = VAZCTN01.PK-BOL-SUB-NBR;
    SR0GS14(); /* fetch next vazctn01 row*/
  end

  SR0GS16(); /* close vazctn01 cursor*/

end // end SR0GS04

// check for required field
Function SR0GS05()

   /* ---------------  statement group sr0gs05  --------------*/

                   /* check for required fields*/

   /* --------------------------------------------------------*/


  set SR0GM020.PK1PKSCH[SR0GWIDX] initialAttributes;
  set SR0GM020.SR0GMNOU[SR0GWIDX] initialAttributes;
  set SR0GM020.SR0GMNOO[SR0GWIDX] initialAttributes;

   /* check for missing pick sch nbr*/
  if (SR0GM020.PK1PKSCH[SR0GWIDX] <= 0
   && SR0GM020.SR0GMNOU[SR0GWIDX] >= 0
   && SR0GM020.SR0GMNOO[SR0GWIDX] > 0)
    SR0GM020.SR1QTYSH[SR0GWIDX] = 0;
    SR0GM020.SR1NBORD[SR0GWIDX] = 0;
    set SR0GM020.PK1PKSCH[SR0GWIDX] cursor, bold;
    converseLib.validationFailed(14); /* pick schedule nbr required*/
  end

   /* checks for missing pick sch nbr and nbr units*/
  if (SR0GM020.PK1PKSCH[SR0GWIDX] <= 0
   && SR0GM020.SR0GMNOU[SR0GWIDX] < 0
   && SR0GM020.SR0GMNOO[SR0GWIDX] > 0)
    SR0GM020.SR1QTYSH[SR0GWIDX] = 0;
    SR0GM020.SR1NBORD[SR0GWIDX] = 0;
    set SR0GM020.PK1PKSCH[SR0GWIDX] cursor, bold;
    set SR0GM020.SR0GMNOU[SR0GWIDX] bold;
    converseLib.validationFailed(24); /* required field*/
  end

   /* checks for missing sch nbr and nbr orders*/
  if (SR0GM020.PK1PKSCH[SR0GWIDX] <= 0
   && SR0GM020.SR0GMNOU[SR0GWIDX] >= 0
   && SR0GM020.SR0GMNOO[SR0GWIDX] <= 0)
    SR0GM020.SR1QTYSH[SR0GWIDX] = 0;
    SR0GM020.SR1NBORD[SR0GWIDX] = 0;
    set SR0GM020.PK1PKSCH[SR0GWIDX] cursor, bold;
    set SR0GM020.SR0GMNOO[SR0GWIDX] bold;
    converseLib.validationFailed(24); /* required field*/
  end

   /* checks for missing nbr units*/
  if (SR0GM020.PK1PKSCH[SR0GWIDX] > 0
   && SR0GM020.SR0GMNOU[SR0GWIDX] < 0
   && SR0GM020.SR0GMNOO[SR0GWIDX] > 0)
    SR0GW04.SR0GWPKI[SR0GWIDX] = SR0GM020.PK1PKSCH[SR0GWIDX];
    set SR0GM020.SR0GMNOU[SR0GWIDX] cursor, bold;
    converseLib.validationFailed(24); /* required field*/
  end

   /* checks for missing nbr orders*/
  if (SR0GM020.PK1PKSCH[SR0GWIDX] > 0
   && SR0GM020.SR0GMNOU[SR0GWIDX] >= 0
   && SR0GM020.SR0GMNOO[SR0GWIDX] <= 0)
    SR0GW04.SR0GWPKI[SR0GWIDX] = SR0GM020.PK1PKSCH[SR0GWIDX];
    set SR0GM020.SR0GMNOO[SR0GWIDX] cursor, bold;
    set SR0GM020.SR0GMNOU[SR0GWIDX] bold;
    converseLib.validationFailed(24); /* required field*/
  end

   /* checks for missing nbr units and nbr orders*/
  if (SR0GM020.PK1PKSCH[SR0GWIDX] > 0
   && SR0GM020.SR0GMNOU[SR0GWIDX] < 0
   && SR0GM020.SR0GMNOO[SR0GWIDX] <= 0)
    SR0GW04.SR0GWPKI[SR0GWIDX] = SR0GM020.PK1PKSCH[SR0GWIDX];
    set SR0GM020.SR0GMNOU[SR0GWIDX] cursor, bold;
    set SR0GM020.SR0GMNOO[SR0GWIDX] bold;
    converseLib.validationFailed(24); /* required field*/
  end

   /* sch nbr, nbr units, and nbr orders contains data*/
  if (SR0GM020.PK1PKSCH[SR0GWIDX] > 0
   && SR0GM020.SR0GMNOU[SR0GWIDX] >= 0
   && SR0GM020.SR0GMNOO[SR0GWIDX] > 0)
    SR0GW04.SR0GWPKI[SR0GWIDX] = SR0GM020.PK1PKSCH[SR0GWIDX];
  end

   /* checks if the sch number has been modified and if the*/
   /* the accept hold status is set to yes*/
  if (SR0GM020.PK1PKSCH[SR0GWIDX] != SR0GW04.SR0GWPKI[SR0GWIDX]
   && SR0GM020.SR0GMAHD[SR0GWIDX] == "Y")
    SR0GMAHD[SR0GWIDX] = "N";
    SR0GW04.SR0GWPKI[SR0GWIDX] = SR0GM020.PK1PKSCH[SR0GWIDX];
  end




   /* -------------  end statement group sr0gs05 -------------*/

end // end SR0GS05

// update batch headers
Function SR0GS06()

   /* ---------------  statement group sr0gs06  --------------*/
                    /* update batch headers*/
   /* --------------------------------------------------------*/




    /* update batch header*/

  set SQLCA empty;

  call "IO0790" ("U ", SQLCA, SR1REC) {isNoRefresh = yes, isExternal = yes};
  if (SQLCA.VAGen_SQLCODE == 0)
    converseLib.validationFailed(15); /* batch(s) updated*/
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
      VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
      sysLib.rollback();
      VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
       /* syncpoint rollback*/
      converseLib.validationFailed(20); /* record updated since last reference*/
      set SR0GM020.PK1PKSCH[SR0GWIDX] bold;
      return;
    else
      SR0GW01.SR0GWSQL = SQLCA.SQLCAREC; /* hold error sqlca*/
      VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
      VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
      sysLib.rollback();
      VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
       /* syncpoint rollback*/
      SQLCA.SQLCAREC = SR0GW01.SR0GWSQL;
      TA1REC.TA1TYPE = "DB2";
      TA1REC.TA1FUNC = "ABND";
      TA1REC.TA1DBASE = "DSHIP";
      TA1REC.TA1TBLVU = "VSRHDR01";
      TA1REC.TA1MAP = " ";
      TA1REC.TA1TBLKE = SR1REC.SR1KEYS;
      TA1REC.TA1PGMNM = "SR0GS06";
      TA1REC.TA1LOC = "UPDATE DB2 DCUST.VSRHDR01";
      call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
      XSPF4();
    end
  end


   /* -------------  end statement group sr0gs06 -------------*/

end // end SR0GS06

// shuffle lines on screen
Function SR0GS07()

   /* ---------------  statement group sr0gs07  --------------*/

                   /* shuffle lines on screen*/

   /* --------------------------------------------------------*/

  SR0GW01.SR0GWIDX = 1;
  while (SR0GW01.SR0GWIDX <= 10)

    if (SR0GM020.PK1PKSCH[SR0GWIDX] == 0
     && SR0GM020.SR0GMNOO[SR0GWIDX] == 0
     && SR0GM020.SR0GMNOU[SR0GWIDX] == 0)

         /* MOVE 0 TO SR0GM020.SR1NBORD(SR0GWIdx);*/
         /* MOVE 0 TO SR0GM020.SR1QTYSH(SR0GWIdx);*/
      SR0GW01.SR0GWIX2 = SR0GW01.SR0GWIDX + 1;
      while (SR0GW01.SR0GWIX2 <= 10) /* look for next non empty row*/

        if (SR0GM020.PK1PKSCH[SR0GWIX2] != 0 /* look for next non empty row*/
         || SR0GM020.SR0GMNOO[SR0GWIX2] != 0 
         || SR0GM020.SR0GMNOU[SR0GWIX2] != 0)
           /* swap sr0gwix2 row with sr0gwidx row (the empty row)*/
          SR0GM020.PK1PKSCH[SR0GWIDX] = SR0GM020.PK1PKSCH[SR0GWIX2];
          SR0GM020.SR0GMNOO[SR0GWIDX] = SR0GM020.SR0GMNOO[SR0GWIX2];
          SR0GM020.SR0GMNOU[SR0GWIDX] = SR0GM020.SR0GMNOU[SR0GWIX2];
          SR0GM020.SR0GMAHD[SR0GWIDX] = SR0GM020.SR0GMAHD[SR0GWIX2];
           /* set sr0gwix2 (the orginial next non empty row) empty*/
          SR0GM020.PK1PKSCH[SR0GWIX2] = 0;
          SR0GM020.SR0GMNOO[SR0GWIX2] = 0;
          SR0GM020.SR0GMNOU[SR0GWIX2] = 0;
          SR0GM020.SR1NBORD[SR0GWIX2] = 0;
          SR0GM020.SR1QTYSH[SR0GWIX2] = 0;
          SR0GM020.SR0GMAHD[SR0GWIX2] = "N";
          SR0GW01.SR0GWIX2 = 10;
        end
        SR0GW01.SR0GWIX2 = SR0GW01.SR0GWIX2 + 1;

      end /* end look for next non empty row*/

    end /* end if current row empty*/
    SR0GW01.SR0GWIDX = SR0GW01.SR0GWIDX + 1;

  end /* end cycle thru current rows*/



   /* -------------  end statement group sr0gs07 -------------*/

end // end SR0GS07

// check batch status
Function SR0GS08()


   /* ------------ start stmt grp sr0gs08 -----------------*/

                 /* check batch status*/

   /* -----------------------------------------------------*/


             /* only a batch which has a status of 'p' or 'h'*/
             /* (prepared or held) may be balanced.*/

   /* DLVRUSA  Modified this group to be performed in a loop*/

  SR0GW01.SR0GWIX2 = 1;
  while (SR0GW01.SR0GWIX2 <= 10)
    SR0GW01.SR0GWFL4 = "N"; /* initialize batch status error flag*/

    if (SR1REC.SR1BTST != "P"
     && SR1REC.SR1BTST != "H")
      converseLib.validationFailed(22); /* batch status is not 'p' or 'h'*/
      SR0GW01.SR0GWFL4 = "Y"; /* batch status error*/
      set SR0GM020.PK1PKSCH[SR0GWIX2] cursor, bold;
      return;
    end
    SR0GW01.SR0GWIX2 = SR0GW01.SR0GWIX2 + 1;
  end
  if (SR0GW01.SR0GWFL4 == "Y")
    exit stack;
  end



   /* -------------   end of stmt grp sr0gs08  ------------*/

end // end SR0GS08

// check batch balance
Function SR0GS09()


   /* ------------ start stmt grp sr0gs09 -----------------*/

                /* check batch balance*/

   /* -----------------------------------------------------*/

   /* here balance means to see if the number of orders and the*/
   /* number of units entered by the user matchs the number of*/
   /* orders and units carried on the batch header.*/

   /* Modified to perform this group in a loop*/

  SR0GW01.SR0GWIX2 = 1;
  while (SR0GW01.SR0GWIX2 <= 10)
    if (SR0GM020.SR1NBORD[SR0GWIX2] != SR0GM020.SR0GMNOO[SR0GWIX2]
     && SR0GW01.SR0GWFL2 == "Y") /* error on previous line*/
      set SR0GM020.PK1PKSCH[SR0GWIX2] bold;
      set SR0GM020.SR0GMNOO[SR0GWIX2] bold;
    end
    SR0GW01.SR0GWFL2 = "N"; /* initialize error flag*/
    if (SR0GM020.SR1QTYSH[SR0GWIX2] != SR0GM020.SR0GMNOU[SR0GWIX2])
      SR0GW01.SR0GWFL1 = "Y";
      SR0GW01.SR0GWFL2 = "Y";
      converseLib.validationFailed(60); /* number of units does not balance*/
      set SR0GM020.PK1PKSCH[SR0GWIX2] bold;
      set SR0GM020.SR0GMNOU[SR0GWIX2] cursor, bold;
      if (SR0GM020.SR1NBORD[SR0GWIX2] != SR0GM020.SR0GMNOO[SR0GWIX2]
       && SR0GW01.SR0GWFL2 == "N") /* error on previous line*/
        SR0GW01.SR0GWFL1 = "Y";
        SR0GW01.SR0GWFL2 = "Y";
        converseLib.validationFailed(259); /* number of orders & units not balance*/
        set SR0GM020.PK1PKSCH[SR0GWIX2] bold;
        set SR0GM020.SR0GMNOO[SR0GWIX2] cursor, bold;
        set SR0GM020.SR0GMNOU[SR0GWIX2] cursor, bold;
      else
          /* next sentence*/
      end
    else
      if (SR0GM020.SR1NBORD[SR0GWIX2] != SR0GM020.SR0GMNOO[SR0GWIX2]
       && SR0GW01.SR0GWFL2 == "N") /* error on previous line*/
        SR0GW01.SR0GWFL1 = "Y";
        SR0GW01.SR0GWFL2 = "Y";
        converseLib.validationFailed(59); /* number of orders does not balance*/
        set SR0GM020.PK1PKSCH[SR0GWIX2] bold;
        set SR0GM020.SR0GMNOO[SR0GWIX2] cursor, bold;
      end
    end

    SR0GW01.SR0GWIX2 = SR0GW01.SR0GWIX2 + 1;
  end
  if (SR0GW01.SR0GWFL1 == "Y")
    exit stack;
  end


   /* -------------   end of stmt grp sr0gs09  ------------*/

end // end SR0GS09

// check batch for H, hold status
Function SR0GS10()


   /* ------------ start stmt grp sr0gs10 ----------------*/

               /* check batch for H, hold status*/

   /* ----------------------------------------------------*/


            /* a batch with an H, hold, status*/
            /* is checked and highlighted*/



  SR0GW01.SR0GWIDX = 1;
  while (SR0GW01.SR0GWIDX <= 10) /* reset accept hold column field*/
    set SR0GMAHD[SR0GWIDX] skip, invisible; /* attributes*/
    SR0GW01.SR0GWIDX = SR0GW01.SR0GWIDX + 1;
  end

  set SR0GM020.SR0GMHD1 initialAttributes; /* reset header lines*/
  set SR0GM020.SR0GMHD2 initialAttributes;

  if (SR0GM020.SR0GMMSG == " " /* check for error message*/
   && SR0GM020.VAGen_EZEMSG == " "
   && converseVar.validationMsgNum == 0)
    SR0GW01.SR0GWIDX = 10;
    while (SR0GW01.SR0GWIDX > 0)
      if (SR0GW04.SR0GWBTS[SR0GWIDX] == "H") /* is batch status = 'h'*/
        if (SR0GM020.SR0GMAHD[SR0GWIDX] == "N") /* is accept hold col = 'n'*/
          if (SR0GW04.SR0GWSHP[SR0GWIDX] > 0) /* does a ship date exist*/
            converseLib.validationFailed(139); /* schedule on hold-enter 'y' to accept*/
            set SR0GM020.PK1PKSCH[SR0GWIDX] bold;
            set SR0GM020.SR0GMAHD[SR0GWIDX] normal;
            set SR0GM020.SR0GMAHD[SR0GWIDX] underline;
            set SR0GM020.SR0GMAHD[SR0GWIDX] cursor, bold;
            SR0GW01.SR0GWIDX = 1;
          else
            converseLib.validationFailed(148); /* schedule on hold-no ship date enter*/
            set SR0GM020.PK1PKSCH[SR0GWIDX] cursor, bold;
            SR0GW01.SR0GWIDX = 1;
          end
        end
      end
      SR0GW01.SR0GWIDX = SR0GW01.SR0GWIDX - 1;
    end
    if (converseVar.validationMsgNum == 139) /* a hold status exists*/
      SR0GM020.SR0GMHD1 = "ACPT"; /* display column headings*/
      set SR0GM020.SR0GMHD1 protect;
      SR0GM020.SR0GMHD2 = "HOLD?";
      set SR0GM020.SR0GMHD2 protect;
    end
  end


   /* -------------- end of stmt grp sr0gs10 ----------------*/

end // end SR0GS10

// check for duplicate pick nbr
Function SR0GS11()

   /* ---------------  statement group sr0gs11  --------------*/

             /* check for duplicate pick numbers*/

   /* --------------------------------------------------------*/


   /* set fields defined*/

  SR0GW01.SR0GWIDX = 1;
  while (SR0GW01.SR0GWIDX <= 10)

    set SR0GM020.PK1PKSCH[SR0GWIDX] initialAttributes;
    set SR0GM020.SR0GMNOO[SR0GWIDX] initialAttributes;
    set SR0GM020.SR0GMNOU[SR0GWIDX] initialAttributes;
    set SR0GM020.SR1NBORD[SR0GWIDX] initialAttributes;
    set SR0GM020.SR1QTYSH[SR0GWIDX] initialAttributes;

    SR0GW01.SR0GWIDX = SR0GW01.SR0GWIDX + 1;
  end

   /* check for duplicate pick schedule numbers*/

  SR0GW01.SR0GWIDX = 10;
  SR0GW01.SR0GWIX2 = 9;
  while (SR0GW01.SR0GWIDX >= 2)
    while (SR0GW01.SR0GWIX2 >= 1)

      if (SR0GM020.PK1PKSCH[SR0GWIDX] == SR0GM020.PK1PKSCH[SR0GWIX2]
       && SR0GM020.PK1PKSCH[SR0GWIDX] != 0)
        set SR0GM020.PK1PKSCH[SR0GWIDX] cursor, bold;
        set SR0GM020.PK1PKSCH[SR0GWIX2] cursor, bold;
        converseLib.validationFailed(21); /* duplicate pick schedule numbers*/
      end
      SR0GW01.SR0GWIX2 = SR0GW01.SR0GWIX2 - 1;
    end
    SR0GW01.SR0GWIDX = SR0GW01.SR0GWIDX - 1;
    SR0GW01.SR0GWIX2 = SR0GW01.SR0GWIDX - 1;
  end




   /* -------------  end statement group sr0gs11 -------------*/

end // end SR0GS11

// update hdrs
Function SR0GS12()
   /* ------------- start stmt grp sr0gs12 ---------------*/

                    /* update headers*/

   /* ----------------------------------------------------*/


  if (SR0GM020.PK1PKSCH[SR0GWIDX] != 0)
    SR0GS03(); /* read batch hdr*/
  else
    SR0GW01.SR0GWIDX = 11;
    return;
  end

  if (SR1REC.ZZZCHGCT != SR0GW01.SR0GWCNT[SR0GWIDX])
    converseLib.validationFailed(20); /* recd updated since last reference*/
    SR0GW01.SR0GWIDX = 12;
    set SR0GM020.PK1PKSCH[SR0GWIDX] cursor, bold;
    return;
  end
   /* --------------------Y2K out begin -----------------------*/
   /* MOVE 19 TO SR0GW01.SR0GWFCT;*/
   /* --------------------Y2K out end -------------------------*/
  SR0GW01.SR0GWTIM = VGVar.currentFormattedTime;
  SR0GW01.SR0GWTHH = SR0GW01.SR0GWHH;
  SR0GW01.SR0GWTMM = SR0GW01.SR0GWMI;
  SR1REC.SR1TMCHG = SR0GW01.SR0GWTI;
  SR1REC.ZZZCHGTM = SR0GW01.SR0GWTI;
  SR1REC.SR1BTST = "B";
   /* --------------------Y2K out begin -----------------------*/
   /* MOVE 19 TO SR0GW01.SR0GWFCT;*/
   /* MOVE EZEDTE TO SR0GW01.SR0GWFDA;*/
   /* -------------------Y2K out end -----------------------*/
   /* -------------------Y2K in begin-----------------------*/
  SR0GW01.SR0GWFDT = VGVar.currentGregorianDate; /* -------------------Y2K in end  -----------------------*/
  SR1REC.SR1DTCHG = SR0GW01.SR0GWFDT;
  SR1REC.ZZZCHGDT = SR0GW01.SR0GWFDT;
  SR1REC.XXXUSRID = COMMAREA.CAUSERID;

  if (SR1REC.SR1PKSFL != "Y") /* order not picked*/
    SR1REC.SR1PKAFL = "Y"; /* set sr-pick-act-fl*/
    SR1REC.SR1PKSFL = "Y"; /* set sr-pick-stat-fl*/
    SR1REC.SR1PKSDT = SR0GW01.SR0GWFDT; /* set sr-pick-stat-dt*/
  end

  SR0GS06(); /* update batch header*/

   /* check to see if there is a message using ezemno from*/
   /* sr0gs06. if so this means that the record has been*/
   /* updated since the user last saw it. they will have to*/
   /* update it again.*/
   /* if no problem then increment the index.*/

  if (converseVar.validationMsgNum != 15) /* batch(s) updated*/
    SR0GW01.SR0GWIDX = 12;
  else
    set SR0GM020.SR0GMNOO[SR0GWIDX] initialAttributes;
    set SR0GM020.SR0GMNOU[SR0GWIDX] initialAttributes;
    SR0GW01.SR0GWIDX = SR0GW01.SR0GWIDX + 1;
  end


   /* -------------   end stmt grp sr0gs12 ---------------*/
end // end SR0GS12

// open cursor for vazcit01 (S4)
Function SR0GS13()

  set VAZCTN01 empty; /* clear batch record*/
  set SQLCA empty;

  VAZCTN01.XWH-WHSE-CD = SR0GM020.XWHCD;
  VAZCTN01.PK-PICK-SCHED-NBR = SR0GM020.PK1PKSCH[SR0GWIDX];
  VAZCTN01.PK-BILL-OF-LADING = -1;
  VAZCTN01.PK-BOL-SUB-NBR = -1;
  VAZCTN01.OP-CUST-ORD-ID = -1;
  VAZCTN01.OP-NIKE-ORD-ID = -1;

  call "VAZCTN01" ("S7", SQLCA, VAZCTN01) {isNoRefresh = yes, isExternal = yes}; /* read carton table*/

  if (SQLCA.VAGen_SQLCODE != 0)
    TA1REC.TA1TYPE = "DB2";
    TA1REC.TA1FUNC = "RETN";
    TA1REC.TA1DBASE = "DSHIP";
    TA1REC.TA1TBLVU = "VAZCTN01";
    TA1REC.TA1MAP = "SR0GM020 ";
    TA1REC.TA1TBLKE = VAZCTN01.VAZCTN01-KEY;
    TA1REC.TA1PGMNM = "SR0BS13";
    TA1REC.TA1LOC = "OPENING VAZCTN01 S5 CURSOR";
    call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
    COMMAREA.CAUSERA = " ";
    XSPF4();
  end

end // end SR0GS13

// fetch vazcit01 row (N4)
Function SR0GS14()

  call "VAZCTN01" ("N7", SQLCA, VAZCTN01) {isNoRefresh = yes, isExternal = yes}; /* read carton item*/

  if (SQLCA.VAGen_SQLCODE == 0
   || SQLCA.VAGen_SQLCODE == +100)
    /* next sentence*/
  else
    TA1REC.TA1TYPE = "DB2";
    TA1REC.TA1FUNC = "RETN";
    TA1REC.TA1DBASE = "DSHIP";
    TA1REC.TA1TBLVU = "VAZCTN01";
    TA1REC.TA1MAP = "SR0GM020 ";
    TA1REC.TA1TBLKE = VAZCTN01.VAZCTN01-KEY;
    TA1REC.TA1PGMNM = "SR0BS14";
    TA1REC.TA1LOC = "FETCHING VAZCTN01 N5 ROW";
    call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
    COMMAREA.CAUSERA = " ";
    XSPF4();
  end

end // end SR0GS14

// select unique vazhdr01
Function SR0GS15()

  VAZHDR01.XWH-WHSE-CD = VAZCTN01.XWH-WHSE-CD;
  VAZHDR01.PK-BILL-OF-LADING = VAZCTN01.PK-BILL-OF-LADING;
  VAZHDR01.PK-BOL-SUB-NBR = VAZCTN01.PK-BOL-SUB-NBR;

  call "VAZHDR01" ("S ", SQLCA, VAZHDR01) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0
   || SQLCA.VAGen_SQLCODE == +100)
    /* next sentence*/
  else
    TA1REC.TA1TYPE = "DB2";
    TA1REC.TA1FUNC = "RETN";
    TA1REC.TA1DBASE = "DSHIP";
    TA1REC.TA1TBLVU = "VAZHDR01";
    TA1REC.TA1MAP = "SR0GM020 ";
    TA1REC.TA1TBLKE = VAZHDR01.VAZHDR01-KEY;
    TA1REC.TA1PGMNM = "SR0GS15";
    TA1REC.TA1LOC = "SELECTING VAZHDR01 ROW";
    call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
    COMMAREA.CAUSERA = " ";
    XSPF4();
  end

end // end SR0GS15

// close cursor for vazcit01 (C4)
Function SR0GS16()

  call "VAZCTN01" ("C7", SQLCA, VAZCTN01) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE != 0)
    TA1REC.TA1TYPE = "DB2";
    TA1REC.TA1FUNC = "RETN";
    TA1REC.TA1DBASE = "DSHIP";
    TA1REC.TA1TBLVU = "VAZCTN01";
    TA1REC.TA1MAP = "SR0GM020 ";
    TA1REC.TA1TBLKE = VAZCTN01.VAZCTN01-KEY;
    TA1REC.TA1PGMNM = "SR0GS16";
    TA1REC.TA1LOC = "CLOSING VAZCTN01 C5 CURSOR";
    call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
    COMMAREA.CAUSERA = " ";
    XSPF4();
  end

end // end SR0GS16

// extract number of skus
Function SR0GS17()


   /* ------------ start stmt grp sr0gs17 -----------------*/

                /* extract number of skus*/

   /* -----------------------------------------------------*/

  SR0GW01.SR0GWMSG = " ";

  set SKUREC empty; /* clear batch record*/
  set SQLCA empty;

  SKUREC.XWHCD = SR0GM020.XWHCD; /* set batch header key*/
  SKUREC.PK1PKSCH = SR0GM020.PK1PKSCH[SR0GWIDX];
  try
    call "GN6000" (SKUREC) {isNoRefresh = yes, isExternal = yes};
  end /* read SRORD/AZCIT/AZCSZ*/
  if (SKUREC.VAGen_SQLCODE == 0)
    SR0GW01.SR0GSKUS = SKUREC.SR0GSKUS;
  else
    if (SKUREC.VAGen_SQLCODE == 100)
      SR0GW01.SR0GWFL1 = "Y"; /* error on btch RECORD*/
    else
      TA1REC.TA1TYPE = "DB2";
      TA1REC.TA1FUNC = "RETN";
      TA1REC.TA1DBASE = "DSHIP";
      TA1REC.TA1TBLVU = "VSRORD01";
      TA1REC.TA1MAP = " ";
      TA1REC.TA1TBLKE = SR1REC.SR1KEYS;
      TA1REC.TA1PGMNM = "SR0BS17";
      TA1REC.TA1LOC = "READING DB2 SRORD/AZCIT/AZCSZ";
      call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
      COMMAREA.CAUSERA = " ";
      XSPF4();
    end
  end




    /* -----------   end of stmt grp sr0gs17  ------------*/


end // end SR0GS17

// chk nil order for shipment id
Function SR0GS20()

   /* ------------------------------------------------------------*/
   /* Select and open the cursor for the shiprec order table*/
   /* ------------------------------------------------------------*/

  SR0GS21(); /* Select set and open cursor*/

   /* ------------------------------------------------------------*/
   /* Fetch and format the data into pages until end of carton.*/
   /* ------------------------------------------------------------*/

  while (SR0GW01.SR0GWFLC == "N") /* Until end of cursor*/

    SR0GS22(); /* Fetch selected rows*/


    if (SR0GW01.SR0GWFLC == "N") /* if not end of shiprec orders*/

      /* DLVRUSA START*/

      /* ------------------------------------------------------------*/
      /* Select unqiue row from OTP table*/
      /* ------------------------------------------------------------*/

      if (SR2REC.XWHCD == "04" || SR2REC.XWHCD == "07" || 
      SR2REC.XWHCD == "09" || SR2REC.XWHCD == "42" || 
      SR2REC.XWHCD == "51")
        SR0GS27(); /* Select unique row from voppkh05*/
      end

      /* DLVRUSA END*/

      /* ------------------------------------------------------------*/
      /* Select and open the cursor for the nil packlist order table*/
      /* ------------------------------------------------------------*/


      SR0GS23(); /* Select set and open NLPLO01 cursor*/

          /* ------------------------------------------------------------*/
          /* Fetch the nil packlist order row and check if associated.*/
          /* ------------------------------------------------------------*/

      while (SR0GW01.SR0GWFLB == "N") /* Until end of cursor*/

        SR0GS24(); /* Fetch selected rows*/


            /* ------------------------------------------------------------*/
            /* If the order is associated to a shipment set the error flag*/

            /* ------------------------------------------------------------*/

        if (SR0GW01.SR0GWFLB == "N") /* if not end of nil p/l orders*/

          if (SR2REC.PK1PKSCH == TSVREC.PK2SCHNO /* Same schedule*/
           && TSVREC.TSFSHPID == 0)             
                                   /* and p/l not associated to shipment*/

            SR0GW01.SR0GWFL6 = "Y"; /* set flag for error*/

          end

        end

      end

          /* ------------------------------------------------------------*/
          /* Close the cursor for the nil packing list order table*/
          /* ------------------------------------------------------------*/

      SR0GS25(); /* Close the selected set cursor*/

    end

  end


   /* ------------------------------------------------------------*/
   /* Close the cursor for the shiprec order table*/
   /* ------------------------------------------------------------*/

  SR0GS26(); /* Close the selected set cursor*/


end // end SR0GS20

// declare cursor for shiprec ord
Function SR0GS21()
   /* ------------------------------------------------------------*/
   /* Select the requested set of rows from the table.*/
   /* ------------------------------------------------------------*/
   /* DLVRUSA:*/
   /* Modified to return the correct error message when non zero*/
   /* sqlcode.*/
   /* ------------------------------------------------------------*/

  set SR2REC empty; /* Clear row storage area*/

  SR2REC.XWHCD = SR1REC.XWHCD; /* whse cd*/
  SR2REC.PK1PKSCH = SR1REC.PK1PKSCH; /* pick schedule number*/
  SR2REC.OP1CUOID = -1; /* order number*/
  SR2REC.OP1NORID = -1; /* order id*/
  SR2REC.OP1NTMAL = -1; /* nbr times alloc*/

  try
    call "IO0800" ("S2", SQLCA, SR2REC) {isNoRefresh = yes, isExternal = yes};
  end /* Select table set*/

   /* ------------------------------------------------------------*/
   /* If successful, initialize the line index and cursor switch.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/

    SR0GW01.SR0GWFLC = "N"; /* End of cursor switch*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(134); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(124); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    converseLib.clearScreen();
     /* Clear screen before display*/

  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "SELECT SET OF TABLE ROWS";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = "S21"; /* Program number*/
  TA1REC.TA1DBASE = "DSHIP   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VSRORD01"; /* Table view name*/
  TA1REC.TA1TBLKE = SR2REC.SR2KEYS; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/

end // end SR0GS21

// fetch next shiprec order
Function SR0GS22()
   /* ------------------------------------------------------------*/
   /* Fetch the next row to display from the table.*/
   /* ------------------------------------------------------------*/
   /* DLVRUSA:*/
   /* Modified to return the correct error message when non zero*/
   /* sqlcode.*/
   /* ------------------------------------------------------------*/

  try
    call "IO0800" ("N2", SQLCA, SR2REC) {isNoRefresh = yes, isExternal = yes};
  end /* Fetch next row*/

   /* ------------------------------------------------------------*/
   /* If successful, save the data in display storage.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/

    if (SQLCA.VAGen_SQLCODE == 0) /* Normal return code*/

      if (SR2REC.XDVCD != "02") /* if not a nil order*/

        SR0GW01.SR0GWFLC = "Y"; /* Indicate end of cursor*/
        return; /* Return to previous process*/

      else

        return; /* Return to previous process*/

      end

    end

    /* ------------------------------------------------------------*/
     /* If end of selected set, indicate end of cursor.*/
    /* ------------------------------------------------------------*/

    if (SQLCA.VAGen_SQLCODE == 100) /* End of selected set*/

      SR0GW01.SR0GWFLC = "Y"; /* Indicate end of cursor*/

      return; /* Return to previous process*/

    end

  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(134); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(124); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    converseLib.clearScreen();
     /* Clear screen before display*/

  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "FETCH NEXT TABLE ROW";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = "S22"; /* Program number*/
  TA1REC.TA1DBASE = "DSHIP   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VSRORD01"; /* Table view name*/
  TA1REC.TA1TBLKE = SR2REC.SR2KEYS; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/

end // end SR0GS22

// declare cursor for nil p/l ord
Function SR0GS23()
   /* ------------------------------------------------------------*/
   /* Select the requested set of rows from the table.*/
   /* DLVRUSA: Modified to fetch the CUST-ORD and NIKE-ORD id*/
   /* from OTP table instead of Shiprec table.*/
   /* ------------------------------------------------------------*/

  set TSVREC empty; /* Clear row storage area*/

   /* DLVRUSA START*/

  if (SR2REC.XWHCD == "04" || SR2REC.XWHCD == "07" || 
  SR2REC.XWHCD == "09" || SR2REC.XWHCD == "42" || 
  SR2REC.XWHCD == "51")
    TSVREC.OP1CUOID = VOPPKH05.NI-CUST-ORD-ID; /* order number*/
    TSVREC.OP1NORID = VOPPKH05.NI-NIKE-ORD-ID; /* order id*/
  else
    TSVREC.OP1CUOID = SR2REC.OP1CUOID; /* order number*/
    TSVREC.OP1NORID = SR2REC.OP1NORID; /* order id*/
  end

   /* DLVRUSA END*/

  try
    call "IO4700" ("S2", SQLCA, TSVREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select table set*/

   /* ------------------------------------------------------------*/
   /* If successful, initialize the line index and cursor switch.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/

    SR0GW01.SR0GWFLB = "N"; /* End of cursor switch*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(134); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(124); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    converseLib.clearScreen();
     /* Clear screen before display*/

  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "SELECT SET OF TABLE ROWS";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = "S23"; /* Program number*/
  TA1REC.TA1DBASE = "DTRANS  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VNLPLO01"; /* Table view name*/
  TA1REC.TA1TBLKE = TSVREC.TSVKEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/

end // end SR0GS23

// fetch next nil p/l order
Function SR0GS24()
   /* ------------------------------------------------------------*/
   /* Fetch the next row to display from the table.*/
   /* ------------------------------------------------------------*/
   /* DLVRUSA:*/
   /* Modified to return the correct error message when non zero*/
   /* sqlcode.*/
   /* ------------------------------------------------------------*/

  try
    call "IO4700" ("N2", SQLCA, TSVREC) {isNoRefresh = yes, isExternal = yes};
  end /* Fetch next row*/

   /* ------------------------------------------------------------*/
   /* If successful, save the data in display storage.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/

    if (SQLCA.VAGen_SQLCODE == 0) /* Normal return code*/

      return; /* Return to previous process*/

    end

    /* ------------------------------------------------------------*/
     /* If end of selected set, indicate end of cursor.*/
    /* ------------------------------------------------------------*/

    if (SQLCA.VAGen_SQLCODE == 100) /* End of selected set*/

      SR0GW01.SR0GWFLB = "Y"; /* Indicate end of cursor*/

      return; /* Return to previous process*/

    end

  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(134); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(124); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    converseLib.clearScreen();
     /* Clear screen before display*/

  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "FETCH NEXT TABLE ROW";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = "S24"; /* Program number*/
  TA1REC.TA1DBASE = "DTRANS  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VNLPLO01"; /* Table view name*/
  TA1REC.TA1TBLKE = TSVREC.TSVKEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/

end // end SR0GS24

// close cursor for nil p/l order
Function SR0GS25()
   /* ------------------------------------------------------------*/
   /* Close the selected set of table rows.*/
   /* ------------------------------------------------------------*/
   /* DLVRUSA:*/
   /* Modified to return the correct error message when non zero*/
   /* sqlcode.*/
   /* ------------------------------------------------------------*/

  try
    call "IO4700" ("C2", SQLCA, TSVREC) {isNoRefresh = yes, isExternal = yes};
  end /* Close table set*/

   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  converseLib.validationFailed(134); /* Indicate system error*/

  TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "CLOSE SELECTED SET OF TABLE ROWS";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = "S25"; /* Program number*/
  TA1REC.TA1DBASE = "DTRANS  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VNLPLO01"; /* Table view name*/

  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/

end // end SR0GS25

// close cursor for shiprec order
Function SR0GS26()
   /* ------------------------------------------------------------*/
   /* Close the selected set of table rows.*/
   /* ------------------------------------------------------------*/
   /* DLVRUSA:*/
   /* Modified to return the correct error message when non zero*/
   /* sqlcode.*/
   /* ------------------------------------------------------------*/

  try
    call "IO0800" ("C2", SQLCA, SR2REC) {isNoRefresh = yes, isExternal = yes};
  end /* Close table set*/

   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  converseLib.validationFailed(134); /* Indicate system error*/

  TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "CLOSE SELECTED SET OF TABLE ROWS";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = "S26"; /* Program number*/
  TA1REC.TA1DBASE = "DSHIP   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VSRORD01"; /* Table view name*/

  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/

end // end SR0GS26

// select unique row from OTP
Function SR0GS27()
   /* ------------------------------------------------------------*/
   /* Select the requested row from the table.*/
   /* ------------------------------------------------------------*/

  set VOPPKH05 empty; /* Clear row storage area*/

  VOPPKH05.XWHCD = SR2REC.XWHCD; /* Warehouse Code*/
  VOPPKH05.OP1CUOID = SR2REC.OP1CUOID; /* order number*/
  VOPPKH05.OP1NORID = SR2REC.OP1NORID; /* order id*/

  try
    call "VOPPKH05" ("S ", SQLCA, VOPPKH05) {isNoRefresh = yes, isExternal = yes};
  end

   /* ------------------------------------------------------------*/
   /* If successful, initialize the line index and cursor switch.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(134); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(124); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

    converseLib.clearScreen();
     /* Clear screen before display*/

  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "SELECT UNIQUE ROW";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = "S27"; /* Program number*/
  TA1REC.TA1DBASE = "DORDER  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VOPPKH05"; /* Table view name*/
  TA1REC.TA1TBLKE = VOPPKH05.OP1KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/

end // end SR0GS27

//*** RECORD=SKUREC ****
// ************* ship recon batch header record ***************
// 
// db2 table:          dship.vsrhdr01
// 
// copylib member:     dcl00106
// 
// i/o mod:            io0790
// 
// key to db2 table:   xwhcd
//                     pk1pksch
// 
// date created:       9/10/86
// 
// maintenance log:
// 
//   date        init            comment
//   ----        ----       -----------------------------------
// 9/10/86       tl         initial creation
// 7/13/87       gda        added 2 new fields for phase 3
// 1/09/89       rhetri     added sr-pick-sched-dt
// 2/4/91        CHYDE      Correct data item desc (db2 names).
// **********************
Record SKUREC type basicRecord
  5 SKUGRP SKUGRP ; 
    10 SKUKEYS SKUKEYS ; 
      15 XWHCD XWHCD ; 
      15 PK1PKSCH PK1PKSCH ; 
    10 SKU-RETURN-DATA SKU-RETURN-DATA ; 
      15 SR0GSKUS SR0GSKUS ; 
      15 SKU-PROBLEM-INFO SKU-PROBLEM-INFO ; 
      15 SKU-ERROR-INFO SKU-ERROR-INFO ; 
      15 VAGen_SQLCODE VAGen_SQLCODE ; 
      15 SKU-FILLER SKU-FILLER ; 
end // end SKUREC

//*** RECORD=SR0GW01 ****
// ;********************** sr0gw01 ****************************
// ;
// ;         work record for sr0g: balance batch
// ;
// ;***********************************************************
// ***********************
Record SR0GW01 type basicRecord
  5 SR0GWGR1 SR0GWGR1 ; 
    10 XWHCD XWHCD ; 
    10 SR0GWMSG SR0GWMSG ; 
  5 SR0GWWRK char(243) ; // start of work area
    10 SR0GWIDX SR0GWIDX ; 
    10 SR0GWIX2 SR0GWIX2 ; 
    10 SR0GWDT SR0GWDT ; 
      15 SR0GWMM SR0GWMM ; 
      15 SR0GWDD SR0GWDD ; 
      15 SR0GWYY SR0GWYY ; 
    10 SR0GWFRA SR0GWFRA ; 
      15 SR0GWFR1 SR0GWFR1 ; 
      15 SR0GWFR2 SR0GWFR2 ; 
    10 SR0GWITM SR0GWITM ; 
      15 SR0GWWHS SR0GWWHS ; 
      15 * char(18) ; 
    10 SR0GWFDT SR0GWFDT ; 
      15 SR0GWFCT SR0GWFCT ; 
      15 SR0GWFDA SR0GWFDA ; 
        20 SR0GWFYY SR0GWFYY ; 
        20 SR0GWFMM SR0GWFMM ; 
        20 SR0GWFDD SR0GWFDD ; 
    10 SR0GWTIM SR0GWTIM ; 
      15 SR0GWHH SR0GWHH ; 
      15 * char(1) ; 
      15 SR0GWMI SR0GWMI ; 
      15 * char(1) ; 
      15 SR0GWSS SR0GWSS ; 
    10 SR0GWTI SR0GWTI ; 
      15 SR0GWTHH SR0GWTHH ; 
      15 SR0GWTMM SR0GWTMM ; 
    10 SR0GWPIC SR0GWPIC ; 
    10 SR0GWFL1 SR0GWFL1 ; 
    10 SR0GWFL2 SR0GWFL2 ; 
    10 SR0GWFL3 SR0GWFL3 ; 
    10 SR0GWFL4 SR0GWFL4 ; 
    10 SR0GWFL5 SR0GWFL5 ; 
    10 SR0GWFL6 SR0GWFL6 ; 
    10 SR0GWFLC SR0GWFLC ; 
    10 SR0GWFLB SR0GWFLB ; 
    10 SR0GWSQL SR0GWSQL ; 
    10 SR0GWCNT SR0GWCNT [10] ; 
    10 SR0GNBBL SR0GNBBL ; 
    10 SR0GSTBL SR0GSTBL ; 
    10 SR0GMVSW SR0GMVSW ; 
    10 PK-BILL-OF-LADING PK-BILL-OF-LADING ; 
    10 PK-BOL-SUB-NBR PK-BOL-SUB-NBR ; 
    10 SR0GSKUS SR0GSKUS ; 
end // end SR0GW01

//*** RECORD=SR0GW02 ****
// ;************************* sr0gw02 *************************
// ;
// ;       save area for warehouse and abreviation
// ;
// ;***********************************************************
// ***********************
Record SR0GW02 type basicRecord
  5 SR0GWSAV SR0GWSAV ; 
    10 XWHCD XWHCD ; 
    10 XWHABRV XWHABRV ; 
end // end SR0GW02

//*** RECORD=SR0GW03 ****
// ********************** sr0gw03 *****************************
// ;
// ;          work area for date tests
// ;
// ;***********************************************************
// ***********************
Record SR0GW03 type basicRecord
  3 SR0GWGR3 SR0GWGR3 ; 
    5 SR0GW2CH SR0GW2CH ; 
    5 SR0GW1N SR0GW1N ; 
    5 SR0GW2N SR0GW2N ; 
    5 SR0GW3N1 SR0GW3N1 ; 
    5 SR0GW3N2 SR0GW3N2 ; 
    5 SR0GWAGE SR0GWAGE ; 
    5 SR0GWDT1 SR0GWDT1 ; 
      10 SR0GWYY1 SR0GWYY1 ; 
      10 SR0GWMM1 SR0GWMM1 ; 
      10 SR0GWDD1 SR0GWDD1 ; 
    5 SR0GWDT2 SR0GWDT2 ; 
      10 SR0GWYY2 SR0GWYY2 ; 
      10 SR0GWMM2 SR0GWMM2 ; 
      10 SR0GWDD2 SR0GWDD2 ; 
end // end SR0GW03

//*** RECORD=SR0GW04 ****
// save area for work fields associated with sr0g:
//     sr-batch status and sr-ship date from dship.vsrhdr01
//     pick id entered from sr0gm020
// ***********************
Record SR0GW04 type basicRecord
  5 SR0GWGR4 SR0GWGR4 ; 
    10 SR0GWBTS SR0GWBTS [10] ; 
    10 SR0GWPKI SR0GWPKI [10] ; 
    10 SR0GWSHP SR0GWSHP [10] ; 
end // end SR0GW04

DataItem SKU-ERROR-INFO char(136)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler for sp1id & gpcd
DataItem SKU-FILLER char(722)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem SKU-PROBLEM-INFO char(152)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem SKU-RETURN-DATA char(1018)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// record group level
DataItem SKUGRP char(1024)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// key group
DataItem SKUKEYS char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem SR0GMVSW char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// number of BOLs
DataItem SR0GNBBL smallint {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

DataItem SR0GSKUS int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = nullFill, inputRequired = no
}
end

// number of BOLs sent
DataItem SR0GSTBL smallint {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// 1 digit work field
DataItem SR0GW1N num(1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// 2 char work field
DataItem SR0GW2CH char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// 2 digit work field
DataItem SR0GW2N num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// 3 digit work field
DataItem SR0GW3N1 num(3)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// 3 digit work field
DataItem SR0GW3N2 num(3)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// ship date age in days
DataItem SR0GWAGE num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// sr-batch status from map
DataItem SR0GWBTS char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// save chg cnt
DataItem SR0GWCNT smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// day
DataItem SR0GWDD num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

//   day
DataItem SR0GWDD1 num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

//   day
DataItem SR0GWDD2 num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// group date
DataItem SR0GWDT char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// work date 1
DataItem SR0GWDT1 num(6)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// work date 2
DataItem SR0GWDT2 num(6)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// century
DataItem SR0GWFCT num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// group yymmdd
DataItem SR0GWFDA num(6)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// day
DataItem SR0GWFDD num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// group yyyymmdd
DataItem SR0GWFDT num(8)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// error on previous line flag
DataItem SR0GWFL1 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// error on btch hdr read flag
DataItem SR0GWFL2 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// is there data flag
DataItem SR0GWFL3 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// batch status error
DataItem SR0GWFL4 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// error
DataItem SR0GWFL5 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// nil p/l order error flag
DataItem SR0GWFL6 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// end of p/l order flag
DataItem SR0GWFLB char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// end of shiprec order flag
DataItem SR0GWFLC char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// month
DataItem SR0GWFMM num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// first 2 chars of from appl
DataItem SR0GWFR1 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// last 2 chars of from appl
DataItem SR0GWFR2 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// from appl name
DataItem SR0GWFRA char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// year
DataItem SR0GWFYY num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// group level
DataItem SR0GWGR1 char(80)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// group field
DataItem SR0GWGR3 char(27)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// group level
DataItem SR0GWGR4 char(90)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// hours
DataItem SR0GWHH char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// work index
DataItem SR0GWIDX smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// caitem group level
DataItem SR0GWITM char(20)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// work index
DataItem SR0GWIX2 smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// minutes
DataItem SR0GWMI char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// month
DataItem SR0GWMM num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

//   month
DataItem SR0GWMM1 num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

//   month
DataItem SR0GWMM2 num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// save msg
DataItem SR0GWMSG char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// hold pick nbr
DataItem SR0GWPIC num(7)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// pick sch id map
DataItem SR0GWPKI int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// group level
DataItem SR0GWSAV char(14)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// shp dt assoc with map pkid
DataItem SR0GWSHP int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// sql hold area
DataItem SR0GWSQL char(136)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// seconds
DataItem SR0GWSS char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// hours
DataItem SR0GWTHH num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// time
DataItem SR0GWTI num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// group time
DataItem SR0GWTIM char(8)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// minutes
DataItem SR0GWTMM num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// whse cd from commarea.caitem
DataItem SR0GWWHS char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// year
DataItem SR0GWYY num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

//   year
DataItem SR0GWYY1 num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

//   year
DataItem SR0GWYY2 num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

