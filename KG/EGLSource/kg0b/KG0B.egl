package kg0b;

import corpcom2.XX0XW01;
import corpcom4.XSENTRY;
import corpcom4.XSEXIT;
import corpcom4.XSPF1;
import corpcom4.XSPF4;
import corpcom4.XSSEGTR;
import corpcom5.*;
import corpcom6.SQLCA;
import corpcom7.XXXSTAT;
import corpx1.*;
import corpx2.XOBABRV;
import corpx2.XOBCD;
import corpx2.XPCABRV;
import corpx2.XPCCD;
import corpx2.XPLABRV;
import corpx2.XPLCD;
import corpx2.XPLKEY;
import corpy2.YSBABRV;
import corpy2.YSBCD;
import corpy2.YSBTBL;
import corpz3.ZZZCHGCT;
import corpz3.ZZZCHGDT;
import corpz3.ZZZCHGTM;
import corpz3.ZZZSDT;
import ta.common.TA1REC;
import ta.common.TA2REC;
//*** PROGRAM=KG0B ****
// ------------  kg0b - maintenance sales resp table ----------
// 
// overview:  this application performs add & delete (inactive)
//            functions for dcust.vcuysb01/
// 
// date written: 10/90
// author:       Dianne Salzwedel
// 
// ************************************************************
// *              maintenance history log                     *
// ************************************************************
//  10/25/90  dsalzw  created application
//  12/12/91  chellm  fix bug in 431.  Row status checked xgpcd
//                    instead of xxxstat.
//   3/19/92  aivers  Modified screen to show product line.
//                    Also modified to allow the user to change
//                    the YSB or status on a record as well as
//                    deactivate or add records.  The inactives
//                    will be purged weekly out of the vcuysb01
//                    table, after Sales Analysis runs.
//  10/01/93  chellm  CSP 4.1 Conversion.
//  10/21/94  chellm  Added XOB code and XGB code.
//  12/05/95  kclar1  Added xgp code to key in search on the
//                    XPLTBL corporate table
//  05/17/96  kclar1  allow more than 200 rows in array
//  01/23/97  kclar1  allow 400 rows in array
//  04/03/98  kclar1  allow 562 rows in array
//  05/07/98  CTRAN   fix end of page bug
//  01/07/00  BMUSTI  mofdified kg0b210, kg0b230.
// *********************
Program KG0B type textUIProgram //VAGen Info - main text program
  {
  includeReferencedFunctions = yes, allowUnqualifiedItemReferences = yes, 
  throwNrfEofExceptions = yes, handleHardIOErrors = no, V60ExceptionCompatibility = yes, 
  I4GLItemsNullable = no, textLiteralDefaultIsString = no, localSQLScope = yes, 
  msgTablePrefix = "CU00", inputRecord = COMMAREA, segmented = yes
  }

  // Data Declarations
  COMMAREA COMMAREA ; // record
  KG0BW01 KG0BW01; // record
  KG0BW02 KG0BW02; // record
  KGBREC KGBREC; // record
  SQLCA SQLCA; // record
  TA1REC TA1REC; // record
  TA2REC TA2REC; // record
  XX0XW01 XX0XW01; // record

  // VAGen Info - items needed for migration
  VAGen_EZESYS char(8);
  VAGen_EZEREPLY num(1);
  VAGen_EZE_WAIT_TIME bin(9,2);
  VAGen_EZE_ITEMLEN int;

  // Use Declarations
  use XDVTBL {deleteAfterUse = yes}; // table
  use XPCTBL {deleteAfterUse = yes}; // table
  use XOBTBL {deleteAfterUse = yes}; // table
  use XGATBL {deleteAfterUse = yes}; // table
  use XGPTBL {deleteAfterUse = yes}; // table
  use YSBTBL {deleteAfterUse = yes}; // table
  use XPLTBL {deleteAfterUse = yes}; // table
  use KG0BM.KG0BM100 // form
   {
    pfKeyEquate = no
  };

  function main()
    // VAGen Info - initialization needed for migration
    VAGen_EZESYS = VGLib.getVAGSysType();
    KG0B000: KG0B000();
    goto KG0B100; /* converse maintenance screen*/

    KG0B100: KG0B100();

    goto KG0B100; /* maintenance screen*/

  end // end main
end // end KG0B

// scroll down
Function KG0B-PG()
   /* *********************************************************/
          /* scrolling down takes place*/
   /* *********************************************************/

  move KG0BM-PAGE-NUM to KG0BWCPG withV60Compat;

  if (KG0BW01.KG0BWREM > 0) /* spaces on the last page*/
    if (KG0BW02.KG0BWCDX == KG0BW02.KG0BWBOT /* at the bottom*/
     && KG0BM-PAGE-NUM == KG0BM-PAGE-TOT     
     && converseVar.validationMsgNum == 0)  
      converseLib.validationFailed(39); /* end of data*/
      KG0BW01.KG0BWERR = "Y";
      return;
    end
  else
    if (KG0BW01.KG0BWCPG > KG0BW01.KG0BWTPG /* allow one page past*/
     && converseVar.validationMsgNum == 0)  /* if no space on page*/
      converseLib.validationFailed(39); /* end of data*/
      KG0BW01.KG0BWERR = "Y";
      return;
    end
  end


  KG0BW01.KG0BWSTP = 0;
  move KG0BM-PAGE-NUM to KG0BWCPG withV60Compat;
  KG0BWCDX = (KG0BWCPG * 16) - 16;
  if (KG0BWCDX < 16)
    KG0BWCDX = 1;
  end
  KG0BW02.KG0BWPDX = KG0BW02.KG0BWCDX;

  while (KG0BW01.KG0BWSTP < 16 /* load the screen with the ws table*/
   && KG0BW02.KG0BWCDX < KG0BW02.KG0BWBOT)
    KG0BW01.KG0BWSTP = KG0BW01.KG0BWSTP + 1;
    KG0BW02.KG0BWCDX = KG0BW02.KG0BWCDX + 1;

    KG0BM100.KG0BMOPT[KG0BWSTP] = KG0BW02.KG0BWOPT[KG0BWCDX];
    KG0BM100.XDVCD[KG0BWSTP] = KG0BW02.XDVCD[KG0BWCDX];
    KG0BM100.XDVABRV[KG0BWSTP] = KG0BW02.XDVABRV[KG0BWCDX];
    KG0BM100.XOBCD[KG0BWSTP] = KG0BW02.XOBCD[KG0BWCDX];
    KG0BM100.XOBABRV[KG0BWSTP] = KG0BW02.XOBABRV[KG0BWCDX];
    KG0BM100.XGACD[KG0BWSTP] = KG0BW02.XGACD[KG0BWCDX];
    KG0BM100.XGAABRV[KG0BWSTP] = KG0BW02.XGAABRV[KG0BWCDX];
    KG0BM100.XPCCD[KG0BWSTP] = KG0BW02.XPCCD[KG0BWCDX];
    KG0BM100.XPCABRV[KG0BWSTP] = KG0BW02.XPCABRV[KG0BWCDX];
    KG0BM100.XPLCD[KG0BWSTP] = KG0BW02.XPLCD[KG0BWCDX];
    KG0BM100.XPLABRV[KG0BWSTP] = KG0BW02.XPLABRV[KG0BWCDX];
    KG0BM100.XGPCD[KG0BWSTP] = KG0BW02.XGPCD[KG0BWCDX];
    KG0BM100.XGPABRV[KG0BWSTP] = KG0BW02.XGPABRV[KG0BWCDX];
    KG0BM100.YSBCD[KG0BWSTP] = KG0BW02.YSBCD[KG0BWCDX];
    KG0BM100.YSBABRV[KG0BWSTP] = KG0BW02.YSBABRV[KG0BWCDX];
    KG0BM100.XXXSTAT[KG0BWSTP] = KG0BW02.XXXSTAT[KG0BWCDX];

    KG0B310(); /* set attributes to those of row*/
                                   /* requiring chg/del*/
  end

  KG0BW01.KG0BWSDX = KG0BW01.KG0BWSTP;
                                   /* reset current screen index*/
  if (KG0BW02.KG0BWCDX == KG0BW02.KG0BWBOT
   && KG0BW01.KG0BWERR == "N"
   && converseVar.validationMsgNum == 0)
    converseLib.validationFailed(39); /* last record displayed*/
  end

  KG0BW01.KG0BWRCD = KG0BW02.KG0BWCDX;
                                   /* record count set to last one*/

  while (KG0BW01.KG0BWSTP < 16)
    KG0BW01.KG0BWSTP = KG0BW01.KG0BWSTP + 1;
    KG0BM100.KG0BMOPT[KG0BWSTP] = " ";
    KG0BM100.XDVCD[KG0BWSTP] = " ";
    KG0BM100.XDVABRV[KG0BWSTP] = " ";
    KG0BM100.XOBCD[KG0BWSTP] = " ";
    KG0BM100.XOBABRV[KG0BWSTP] = " ";
    KG0BM100.XGACD[KG0BWSTP] = " ";
    KG0BM100.XGAABRV[KG0BWSTP] = " ";
    KG0BM100.XPLCD[KG0BWSTP] = " ";
    KG0BM100.XPLABRV[KG0BWSTP] = " ";
    KG0BM100.XPCCD[KG0BWSTP] = " ";
    KG0BM100.XPCABRV[KG0BWSTP] = " ";
    KG0BM100.XGPCD[KG0BWSTP] = " ";
    KG0BM100.XGPABRV[KG0BWSTP] = " ";
    KG0BM100.YSBCD[KG0BWSTP] = " ";
    KG0BM100.YSBABRV[KG0BWSTP] = " ";
    KG0BM100.XXXSTAT[KG0BWSTP] = " ";

    /* If last record defined on the screen is not the bottom of the*/
    /* array, define it so a row can be added.  If we have reached 200,*/
    /* the bottom of the array, then we do not want to define the rest of*/
                                  /* the rows on the screen as entry rows.*/
                                   /* Define them as autoskip, dark.*/

    if (KG0BW01.KG0BWRCD < KG0BW01.KG0BWACT)
                                   /* If not passed btm of array*/
      KG0BW01.KG0BWRCD = KG0BW01.KG0BWRCD + 1;
      KG0B320(); /* set attributes to those of addition*/
                                   /* row*/
    else
      KG0B330(); /* set attributes so row is autoskip,*/
                                   /* dark*/
    end
  end


  set KG0BM100.KG0BMOPT[1] cursor; /* set cursor at first row.*/
  KG0BW01.KG0BWERR = "Y"; /* reconverse the screen*/


end // end KG0B-PG

// init processing
Function KG0B000()
   /* *********************************************/
    /* initialization of variables              **/
   /* *********************************************/

  XSENTRY();

  XSSEGTR(); /* set segmented transaction id*/

  set KG0BM100 initial; /* sales resp screen*/
  set KG0BW01 empty; /* working storage*/
  set KG0BW02 empty;
  set KGBREC empty;
  set TA1REC empty;
  set TA2REC empty;
  set SQLCA empty;


  KG0BWOVM = "ONLY THE FIRST 200 ROWS ARE DISPLAYED, CALL HELP DESK";
  KG0BW01.KG0BWERR = "N"; /* set error flag*/

  KG0B200(); /* build map (read/format screen)*/

  KG0B150(); /* set up security for map*/
end // end KG0B000

// converse the screen
Function KG0B100()
   /* ************************************************/
   /* this process will allow the user to add, chg **/
   /* & inactive rows on cuysb via the kg0bm100    **/
                                  /* **/
   /* steps:                                       **/
   /* -- present the screen                        **/
   /* -- edit special keys                         **/
   /* -- edit the screen user entry                **/
                                  /* **/
   /* ************************************************/

  KG0BW01.KG0BWERR = "N"; /* set error flag*/
  KG0BM100.KG0BMMSG = KG0BW01.KG0BWMSG; /* message number*/

  move KG0BWCPG to KG0BM-PAGE-NUM withV60Compat; /* total pages*/
  move KG0BWTPG to KG0BM-PAGE-TOT withV60Compat; /* total pages*/

  converse KG0BM100 ;

  KG0BW01.KG0BWMSG = " ";
  KG0BM100.KG0BMMSG = " ";

  if (KG0BM100.CATOAP > " ")
    KG0B350(); /* edit fast pathing*/
  else
    set KG0BM100.CATOAP initialAttributes;
  end

  if (KG0BW01.KG0BWERR == "N") /* if no error*/
    KG0B400(); /* edit pf keys*/
  end

   /* ERFORM KG0B150;                 /* set up security*/
end // end KG0B100

// set security for update
Function KG0B150()
   /* ***************************************/
   /* * set security for screen            **/
   /* ***************************************/

  KG0BW01.KG0BWSTP = 0;

  while (KG0BW01.KG0BWSTP < 16)
    KG0BW01.KG0BWSTP = KG0BW01.KG0BWSTP + 1;
    if (COMMAREA.CACHGFL == "Y") /* security for change*/
         /* next sentence*/
    else
      set KG0BM100.KG0BMOPT[KG0BWSTP] skip, invisible;
      set KG0BM100.XDVCD[KG0BWSTP] skip;
      set KG0BM100.XOBCD[KG0BWSTP] skip;
      set KG0BM100.XGACD[KG0BWSTP] skip;
      set KG0BM100.XPLCD[KG0BWSTP] skip;
      set KG0BM100.XPCCD[KG0BWSTP] skip;
      set KG0BM100.XGPCD[KG0BWSTP] skip;
      set KG0BM100.YSBCD[KG0BWSTP] skip;
      set KG0BM100.XXXSTAT[KG0BWSTP] skip;
    end
  end


  if (KG0BW01.KG0BWERR == "Y") /* if errors*/
       /* next sentence*/
  else
    if (COMMAREA.CACHGFL == "Y") /* placement cursor*/
      set KG0BM100.KG0BMOPT[1] cursor;
    else
      set KG0BM100.CATOAP cursor;
    end
  end

end // end KG0B150

// build first screen
Function KG0B200()
   /* **********************************************/
   /* * this process will load all rows into      **/
   /* *   1. working storage                      **/
   /* *   2. build first screen                   **/
   /* **********************************************/

  KG0BW01.KG0BWACT = 562; /* changed to 562 - maximum*/
  KG0BW01.KG0BWEOF = "N"; /* set end-of-file flag to no*/
  KG0BW01.KG0BWEXC = "N"; /* set array exceeded flag to no*/
  KG0BW01.KG0BWMSG = " "; /* set error message to blank*/

  KG0B210(); /* get all rows - load ws-table*/

  KG0BW02.KG0BWTDX = 0; /* init temp table index*/
  KG0BW02.KG0BWCDX = 0; /* init current table index*/
  KG0BW02.KG0BWPDX = 0; /* init previous table index*/
  KG0BW01.KG0BWSDX = 0; /* init current screen index*/
  KG0BW01.KG0BWCPG = 1; /* current page*/

  KG0B260(); /* prepare first screen*/
  KG0BW02.KG0BWCDX = KG0BW02.KG0BWTDX; /* current table index*/

end // end KG0B200

// select rows
Function KG0B210()
   /* ***************************************/
   /* Select all rows*/
   /* ***************************************/
  KG0BW01.KG0BWCNT = 0; /* nbr of rows*/

  KG0B220(); /* declare cursor*/

  KG0B230(); /* get first row*/

  if (KG0BW01.KG0BWEOF == "Y")
    converseLib.validationFailed(39);
    KG0BW01.KG0BWERR = "Y";
    return;
  end

   /* ***************************************/
   /* * load row into ws-table             **/
   /* ***************************************/

  set KG0BW02 empty; /* empty ws-table*/

  while (KG0BW01.KG0BWEOF == "N" /* while there are rows to process*/
   && KG0BW01.KG0BWCNT <= KG0BW01.KG0BWACT) /* array is NOT full*/

    /* tcs chng - 01/07/00*/
    if (KGBREC.XXXSTAT == "A"
    )
      KG0B250(); /* load ws-table*/

      KG0BW01.KG0BWCNT = KG0BW01.KG0BWCNT + 1;
      /* tcs chng - 01/07/00*/
    end
    KG0B230(); /* get next row*/

  end

  KG0B240(); /* close cursor*/

  KG0BW02.KG0BWBOT = KG0BW02.KG0BWCDX; /* bottom of ws-table*/

  KG0BW01.KG0BWTPG = KG0BW02.KG0BWBOT / 16; /* figure how many full pages*/

  KG0BW01.KG0BWREM = KG0BW02.KG0BWBOT % 16; /* remaining spaces on last pg*/

  if (KG0BW01.KG0BWREM > 0) /* if partial page - add one to full*/
                                   /* pages*/
    KG0BW01.KG0BWTPG = KG0BW01.KG0BWTPG + 1;
  end


end // end KG0B210

// declare select cursor
Function KG0B220()
   /* *******************************************/
   /* declare select cursor*/
   /* *******************************************/


  set SQLCA empty;

  call "IO5420" ("S1", SQLCA, KGBREC) {isNoRefresh = yes, isExternal = yes}; /* all sub-ordsfor cus ord*/

  if (SQLCA.VAGen_SQLCODE == 0)
    /* next sentence*/
  else
    TA1REC.TA1TYPE = "DB2";
    TA1REC.TA1FUNC = "ABND";
    TA1REC.TA1DBASE = "DCUST";
    TA1REC.TA1TBLVU = "VCUYSB01";
    TA1REC.TA1MAP = " ";
    TA1REC.TA1PGMNM = "KG0B220";
    TA1REC.TA1LOC = "DECLARE CURSOR ON VCUYSB01";
    call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
  end


end // end KG0B220

// fetch next row
Function KG0B230()
   /* *******************************************/
   /* fetch next row*/
   /* *******************************************/

  call "IO5420" ("N1", SQLCA, KGBREC) {isNoRefresh = yes, isExternal = yes}; /* read*/

  if (SQLCA.VAGen_SQLCODE == 0)
    /* KG0BW01.KG0BWCNT = KG0BW01.KG0BWCNT + 1;*/
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      KG0BW01.KG0BWEOF = "Y"; /* set end-of-file flag to 'yes'*/
    else
      TA1REC.TA1TYPE = "DB2";
      TA1REC.TA1FUNC = "ABND";
      TA1REC.TA1DBASE = "DCUST";
      TA1REC.TA1TBLVU = "VCUYSB01";
      TA1REC.TA1MAP = " ";
      TA1REC.TA1PGMNM = "KG0B230";
      TA1REC.TA1LOC = "FETCH ROW ON VCUYSB01";
      call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
    end
  end

  if (KG0BW01.KG0BWCNT > KG0BW01.KG0BWACT) /* Array is full*/
    KG0BW01.KG0BWMSG = KG0BW01.KG0BWOVM; /* Set error message*/
  end

end // end KG0B230

// close cursor
Function KG0B240()
   /* *******************************************/
   /* close cursor*/
   /* *******************************************/


  call "IO5420" ("C1", SQLCA, KGBREC) {isNoRefresh = yes, isExternal = yes}; /* all sub-ordsfor cus ord*/

  if (SQLCA.VAGen_SQLCODE == 0)
    /* next sentence*/
  else
    TA1REC.TA1TYPE = "DB2";
    TA1REC.TA1FUNC = "ABND";
    TA1REC.TA1DBASE = "DCUST";
    TA1REC.TA1TBLVU = "VCUYSB01";
    TA1REC.TA1MAP = " ";
    TA1REC.TA1PGMNM = "KG0B240";
    TA1REC.TA1LOC = "CLOSE CURSOR ON VCUYSB01";
    call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
  end


end // end KG0B240

// load ws-table
Function KG0B250()
   /* ***************************************/
   /* * load all rows into ws-table        **/
   /* ***************************************/

  KG0BW02.KG0BWCDX = KG0BW02.KG0BWCDX + 1; /* add 1 to index table*/

  KG0BW02.KG0BWOPT[KG0BWCDX] = " ";

  KG0BW02.XDVCD[KG0BWCDX] = KGBREC.XDVCD; /* move division*/
  if (KGBREC.XDVCD == "**")
    KG0BW02.XDVABRV[KG0BWCDX] = "GLOBAL";
  else
    if (KGBREC.XDVCD in XDVTBL.XDVCD)
      KG0BW02.XDVABRV[KG0BWCDX] = XDVTBL.XDVABRV[sysVar.arrayIndex];
    else
      KG0BW02.XDVABRV[KG0BWCDX] = "UNKNWN";
    end
  end

  KG0BW02.XOBCD[KG0BWCDX] = KGBREC.XOBCD; /* Move product category*/
  if (KGBREC.XOBCD == "**")
    KG0BW02.XOBABRV[KG0BWCDX] = "GLOBAL";
  else
    if (KGBREC.XOBCD in XOBTBL.XOBCD)
      KG0BW02.XOBABRV[KG0BWCDX] = XOBTBL.XOBABRV[sysVar.arrayIndex];
    else
      KG0BW02.XOBABRV[KG0BWCDX] = "UNKNWN";
    end
  end

  KG0BW02.XGACD[KG0BWCDX] = KGBREC.XGBCD; /* Move product category*/
  if (KGBREC.XGBCD == "**")
    KG0BW02.XGAABRV[KG0BWCDX] = "GLOBAL";
  else
    KG0BW01.KG0BW-KEY-XGPCD = KGBREC.XGPCD;
    KG0BW01.KG0BW-KEY-XGACD = KGBREC.XGBCD;
    if (KG0BW01.KG0BW-XGATBL-KEY in XGATBL.XGAKEY)
      KG0BW02.XGAABRV[KG0BWCDX] = XGATBL.XGAABRV[sysVar.arrayIndex];
    else
      KG0BW02.XGAABRV[KG0BWCDX] = "UNKNWN";
    end
  end

  KG0BW02.XPCCD[KG0BWCDX] = KGBREC.XPCCD; /* Move product category*/
  if (KGBREC.XPCCD == "**")
    KG0BW02.XPCABRV[KG0BWCDX] = "GLOBAL";
  else
    if (KGBREC.XPCCD in XPCTBL.XPCCD)
      KG0BW02.XPCABRV[KG0BWCDX] = XPCTBL.XPCABRV[sysVar.arrayIndex];
    else
      KG0BW02.XPCABRV[KG0BWCDX] = "UNKNWN";
    end
  end

  KG0BW02.XPLCD[KG0BWCDX] = KGBREC.XPLCD; /* Move product line*/
  KG0BW01.XPLCD = KGBREC.XPLCD; /* Move product line*/
  KG0BW01.XGPCD = KGBREC.XGPCD; /* Move group product code*/
  if (KGBREC.XPLCD == "**")
    KG0BW02.XPLABRV[KG0BWCDX] = "GLOBAL";
  else
    if (KG0BW01.XPLKEY in XPLTBL.XPLKEY)
      KG0BW02.XPLABRV[KG0BWCDX] = XPLTBL.XPLABRV[sysVar.arrayIndex];
    else
      KG0BW02.XPLABRV[KG0BWCDX] = "UNKNWN";
    end
  end

  KG0BW02.XGPCD[KG0BWCDX] = KGBREC.XGPCD; /* Move GPC*/
  if (KGBREC.XGPCD == "**")
    KG0BW02.XGPABRV[KG0BWCDX] = "GLOBAL";
  else
    if (KGBREC.XGPCD in XGPTBL.XGPCD)
      KG0BW02.XGPABRV[KG0BWCDX] = XGPTBL.XGPABRV[sysVar.arrayIndex];
    else
      KG0BW02.XGPABRV[KG0BWCDX] = "UNKNWN";
    end
  end

  KG0BW02.YSBCD[KG0BWCDX] = KGBREC.YSBCD; /* Move Ysb*/
  if (KGBREC.YSBCD in YSBTBL.YSBCD)
    KG0BW02.YSBABRV[KG0BWCDX] = YSBTBL.YSBABRV[sysVar.arrayIndex];
  else
    KG0BW02.YSBABRV[KG0BWCDX] = "UNKNWN";
  end

  KG0BW02.XXXSTAT[KG0BWCDX] = KGBREC.XXXSTAT;

end // end KG0B250

// prepare first screen
Function KG0B260()
   /* *********************************************/
   /* *  prepare the first screen to be displayed**/
   /* *********************************************/

  set KG0BM100 initial; /* reset screen*/

   /* ******************************/
   /* move ws data to screen*/
   /* ******************************/

  KG0BM100.KG0BMDAT = VGVar.currentShortGregorianDate; /* prepare date*/


  KG0BW01.KG0BWSTP = 0; /* init screen top*/

  while (KG0BW01.KG0BWSTP < 16
   && KG0BW02.KG0BWTDX < KG0BW02.KG0BWBOT)
    KG0BW01.KG0BWSTP = KG0BW01.KG0BWSTP + 1;
    KG0BW02.KG0BWTDX = KG0BW02.KG0BWTDX + 1;

    KG0BM100.KG0BMOPT[KG0BWSTP] = KG0BW02.KG0BWOPT[KG0BWTDX];
    KG0BM100.XDVCD[KG0BWSTP] = KG0BW02.XDVCD[KG0BWTDX];
    KG0BM100.XDVABRV[KG0BWSTP] = KG0BW02.XDVABRV[KG0BWTDX];
    KG0BM100.XOBCD[KG0BWSTP] = KG0BW02.XOBCD[KG0BWTDX];
    KG0BM100.XOBABRV[KG0BWSTP] = KG0BW02.XOBABRV[KG0BWTDX];
    KG0BM100.XGACD[KG0BWSTP] = KG0BW02.XGACD[KG0BWTDX];
    KG0BM100.XGAABRV[KG0BWSTP] = KG0BW02.XGAABRV[KG0BWTDX];
    KG0BM100.XPCCD[KG0BWSTP] = KG0BW02.XPCCD[KG0BWTDX];
    KG0BM100.XPCABRV[KG0BWSTP] = KG0BW02.XPCABRV[KG0BWTDX];
    KG0BM100.XPLCD[KG0BWSTP] = KG0BW02.XPLCD[KG0BWTDX];
    KG0BM100.XPLABRV[KG0BWSTP] = KG0BW02.XPLABRV[KG0BWTDX];
    KG0BM100.XGPCD[KG0BWSTP] = KG0BW02.XGPCD[KG0BWTDX];
    KG0BM100.XGPABRV[KG0BWSTP] = KG0BW02.XGPABRV[KG0BWTDX];
    KG0BM100.YSBCD[KG0BWSTP] = KG0BW02.YSBCD[KG0BWTDX];
    KG0BM100.YSBABRV[KG0BWSTP] = KG0BW02.YSBABRV[KG0BWTDX];
    KG0BM100.XXXSTAT[KG0BWSTP] = KG0BW02.XXXSTAT[KG0BWTDX];

    KG0B310(); /* set field attributes to those of a chg/del row*/

  end

  KG0BW01.KG0BWSDX = KG0BW01.KG0BWSTP; /* current screen index*/

  if (KG0BW02.KG0BWTDX == KG0BW02.KG0BWBOT
   && KG0BW01.KG0BWERR == "N" /* no errors*/
   && converseVar.validationMsgNum == 0)
    converseLib.validationFailed(39); /* last record display*/
  end


  while (KG0BW01.KG0BWSTP < 16) /* sets blank lines defined*/
    KG0BW01.KG0BWSTP = KG0BW01.KG0BWSTP + 1;

    KG0B320(); /* set field attributes according to addition row*/
  end


end // end KG0B260

// check option selections
Function KG0B300()
   /* ***************************************/
   /* edit the map*/
   /* ***************************************/

  KG0BW01.KG0BWSTP = 0; /* set screen index*/
  KG0BW02.KG0BWTDX = KG0BW02.KG0BWPDX; /* temp ws-table index*/
  KG0BW01.KG0BWSOE = "N"; /* set screen option entered flag*/

  while (KG0BW01.KG0BWSTP < 16) /* go thru the screen*/
    KG0BW01.KG0BWSTP = KG0BW01.KG0BWSTP + 1; /* increment screen index*/
    KG0BW02.KG0BWTDX = KG0BW02.KG0BWTDX + 1; /* increment table index*/

    if (KG0BW02.XDVCD[KG0BWTDX] == " ") /* If the line is blank*/
      KG0B320(); /* Set the field attributes for a blank row*/
    else
      KG0B310(); /* set the field attributes for a row that can*/
                       /* be changed or deactivated.*/
    end

    /* ***************************************/
     /* check for valid options             **/
    /* ***************************************/

    if (KG0BM100.KG0BMOPT[KG0BWSTP] == " ")
       /* next sentence*/
    else
      KG0BW01.KG0BWSOE = "Y"; /* option entered on screen- set flag*/
      if (KG0BM100.KG0BMOPT[KG0BWSTP] == "A")
        KG0B550(); /* Add Routine*/
      else
        if (KG0BM100.KG0BMOPT[KG0BWSTP] == "C")
          KG0B560(); /* Change Routine*/
        else
          if (KG0BM100.KG0BMOPT[KG0BWSTP] == "D")
            KG0B570(); /* Deactivate routine*/
          else
            KG0BW01.KG0BWERR = "Y"; /* set error flag*/
            converseLib.validationFailed(40); /* invalid options*/
            set KG0BM100.KG0BMOPT[KG0BWSTP] cursor, bold;
          end
        end
      end
    end
  end

  if (KG0BW01.KG0BWERR == "N") /* no errors*/
    set KG0BM100.KG0BMOPT[1] cursor;

    if (KG0BW01.KG0BWSOE == "Y")
      converseLib.validationFailed(277); /* good edit message.  only appears if there is*/
                        /* something selected on the map.*/
    end
  end
end // end KG0B300

// set field attributes
Function KG0B310()
   /* ***************************************/
   /* set the field attributes of a row that can be modified or*/
   /* deactivated.*/
   /* ***************************************/

  set KG0BM100.KG0BMOPT[KG0BWSTP] initialAttributes;
  set KG0BM100.XDVCD[KG0BWSTP] skip;
  set KG0BM100.XDVABRV[KG0BWSTP] initialAttributes;
  set KG0BM100.XOBCD[KG0BWSTP] skip;
  set KG0BM100.XOBABRV[KG0BWSTP] initialAttributes;
  set KG0BM100.XGACD[KG0BWSTP] skip;
  set KG0BM100.XGAABRV[KG0BWSTP] initialAttributes;
  set KG0BM100.XPLCD[KG0BWSTP] skip;
  set KG0BM100.XPLABRV[KG0BWSTP] initialAttributes;
  set KG0BM100.XPCCD[KG0BWSTP] skip;
  set KG0BM100.XPCABRV[KG0BWSTP] initialAttributes;
  set KG0BM100.XGPCD[KG0BWSTP] skip;
  set KG0BM100.XGPABRV[KG0BWSTP] initialAttributes;
  set KG0BM100.YSBCD[KG0BWSTP] initialAttributes;
  set KG0BM100.YSBABRV[KG0BWSTP] initialAttributes;
  set KG0BM100.XXXSTAT[KG0BWSTP] initialAttributes;
end // end KG0B310

// set field attributes
Function KG0B320()
   /* *********************************************/
   /* *  Set the field attributes to those of a row that can be added.*/
   /* *********************************************/

  set KG0BM100.KG0BMOPT[KG0BWSTP] initialAttributes;
  set KG0BM100.XDVCD[KG0BWSTP] initialAttributes;
  set KG0BM100.XOBCD[KG0BWSTP] initialAttributes;
  set KG0BM100.XGACD[KG0BWSTP] initialAttributes;
  set KG0BM100.XPCCD[KG0BWSTP] initialAttributes;
  set KG0BM100.XPLCD[KG0BWSTP] initialAttributes;
  set KG0BM100.XGPCD[KG0BWSTP] initialAttributes;
  set KG0BM100.YSBCD[KG0BWSTP] initialAttributes;
  set KG0BM100.XXXSTAT[KG0BWSTP] skip;
end // end KG0B320

// set field attributes
Function KG0B330()
   /* ***************************************/
   /* set the field attributes of a row that can be modified or*/
   /* deactivated.*/
   /* ***************************************/

  set KG0BM100.KG0BMOPT[KG0BWSTP] skip, invisible;
  set KG0BM100.XDVCD[KG0BWSTP] skip, invisible;
  set KG0BM100.XDVABRV[KG0BWSTP] skip, invisible;
  set KG0BM100.XOBCD[KG0BWSTP] skip, invisible;
  set KG0BM100.XOBABRV[KG0BWSTP] skip, invisible;
  set KG0BM100.XGACD[KG0BWSTP] skip, invisible;
  set KG0BM100.XGAABRV[KG0BWSTP] skip, invisible;
  set KG0BM100.XPLCD[KG0BWSTP] skip, invisible;
  set KG0BM100.XPLABRV[KG0BWSTP] skip, invisible;
  set KG0BM100.XPCCD[KG0BWSTP] skip, invisible;
  set KG0BM100.XPCABRV[KG0BWSTP] skip, invisible;
  set KG0BM100.XGPCD[KG0BWSTP] skip, invisible;
  set KG0BM100.XGPABRV[KG0BWSTP] skip, invisible;
  set KG0BM100.YSBCD[KG0BWSTP] skip, invisible;
  set KG0BM100.YSBABRV[KG0BWSTP] skip, invisible;
  set KG0BM100.XXXSTAT[KG0BWSTP] skip, invisible;
end // end KG0B330

// Fast path editing
Function KG0B350()
   /* ***********************************/
   /* check for fast pathing*/
   /* ***********************************/

  if (converseVar.eventKey is enter)
    COMMAREA.CATOAP = KG0BM100.CATOAP;
    COMMAREA.CAITEM = KG0BM100.CAITEM;
    COMMAREA.CAFROMAP = "KG0B";
    XSEXIT();
    converseLib.validationFailed(422); /* invalid fast path*/
    KG0BW01.KG0BWERR = "Y";
    set KG0BM100.CATOAP cursor, bold;
  else
    KG0BW01.KG0BWERR = "Y";
    converseLib.validationFailed(48); /* can't fast path and use pf keys*/
    set KG0BM100.CATOAP cursor, bold;
  end
end // end KG0B350

// pfkey processing for kg0bm100
Function KG0B400()
   /* ************************************************/
   /* edit pfkeys and special keys                **/
   /* ************************************************/


   /* ***********************************/
   /* enter edit*/
   /* ***********************************/
  if (converseVar.eventKey is enter) /* just edit the map*/
    if (KG0BM-PAGE-NUM is modified)
      KG0B-PG();
    else
      KG0B300();
    end
    return;
  end
   /* ***********************************/
   /* pa2 edit*/
   /* ***********************************/
  if (converseVar.eventKey is pa2) /* refresh the screen*/
    KG0B200();
    return;
  end

   /* ***********************************/
     /* pfkeys edit*/
   /* ***********************************/

   /* ***********************************/
     /* pf1 edit*/
   /* ***********************************/

  if (converseVar.eventKey is pf1) /* help screens*/
    COMMAREA.CACURRAP = "KG0B";
    XSPF1();
    KG0BM100.VAGen_EZEMSG = COMMAREA.CAMSG;
    KG0BW01.KG0BWERR = "Y";
    return;
  end

   /* ***********************************/
     /* pf3 edit*/
   /* ***********************************/

  if (converseVar.eventKey is pf3) /* back to previous screen*/
    COMMAREA.CAITEM = " ";
    COMMAREA.CATOAP = COMMAREA.CAFROMAP;
    COMMAREA.CAFROMAP = "KG0B";
    XSEXIT();
    KG0BM100.VAGen_EZEMSG = COMMAREA.CAMSG;
    KG0BW01.KG0BWERR = "Y";
    return;
  end


   /* ***********************************/
     /* pf4 edit*/
   /* ***********************************/

  if (converseVar.eventKey is pf4) /* back to goal menu*/
    COMMAREA.CAFROMAP = "KG0B";
    XSPF4();
  end


   /* ***********************************/
     /* pf7 edit*/
   /* ***********************************/

  if (converseVar.eventKey is pf7)
    KG0B410(); /* scroll up*/
    return;
  end


   /* ***********************************/
     /* pf8 edit*/
   /* ***********************************/

  if (converseVar.eventKey is pf8)
    KG0B440(); /* scroll down*/
    return;
  end


   /* ***********************************/
     /* pf12 edit*/
   /* ***********************************/

  if (converseVar.eventKey is pf12)
    KG0B600(); /* update database*/
    return;
  end


  KG0BW01.KG0BWERR = "Y"; /* set error flag*/
  converseLib.validationFailed(3); /* invalid pf key*/


end // end KG0B400

// scroll up
Function KG0B410()
   /* *********************************************************/
          /* scrolling up takes place*/
   /* *********************************************************/


  if (KG0BW02.KG0BWPDX == 0 /* at the top of the screen*/
   && converseVar.validationMsgNum == 0)
    converseLib.validationFailed(38); /* cannot scroll up*/
    KG0BW01.KG0BWERR = "Y";
    return;
  end

  KG0BW02.KG0BWCDX = KG0BW02.KG0BWPDX; /* current eq  previous*/
  KG0BW01.KG0BWSTP = 16;

  while (KG0BW01.KG0BWSTP >= 1 /* load the screen with the ws table*/
   && KG0BW02.KG0BWPDX >= 1)
    KG0BM100.KG0BMOPT[KG0BWSTP] = KG0BW02.KG0BWOPT[KG0BWPDX];
    KG0BM100.XDVCD[KG0BWSTP] = KG0BW02.XDVCD[KG0BWPDX];
    KG0BM100.XDVABRV[KG0BWSTP] = KG0BW02.XDVABRV[KG0BWPDX];
    KG0BM100.XOBCD[KG0BWSTP] = KG0BW02.XOBCD[KG0BWPDX];
    KG0BM100.XOBABRV[KG0BWSTP] = KG0BW02.XOBABRV[KG0BWPDX];
    KG0BM100.XGACD[KG0BWSTP] = KG0BW02.XGACD[KG0BWPDX];
    KG0BM100.XGAABRV[KG0BWSTP] = KG0BW02.XGAABRV[KG0BWPDX];
    KG0BM100.XPLCD[KG0BWSTP] = KG0BW02.XPLCD[KG0BWPDX];
    KG0BM100.XPLABRV[KG0BWSTP] = KG0BW02.XPLABRV[KG0BWPDX];
    KG0BM100.XPCCD[KG0BWSTP] = KG0BW02.XPCCD[KG0BWPDX];
    KG0BM100.XPCABRV[KG0BWSTP] = KG0BW02.XPCABRV[KG0BWPDX];
    KG0BM100.XGPCD[KG0BWSTP] = KG0BW02.XGPCD[KG0BWPDX];
    KG0BM100.XGPABRV[KG0BWSTP] = KG0BW02.XGPABRV[KG0BWPDX];
    KG0BM100.YSBCD[KG0BWSTP] = KG0BW02.YSBCD[KG0BWPDX];
    KG0BM100.YSBABRV[KG0BWSTP] = KG0BW02.YSBABRV[KG0BWPDX];
    KG0BM100.XXXSTAT[KG0BWSTP] = KG0BW02.XXXSTAT[KG0BWPDX];

    KG0B310(); /* set field attributes for row*/
                                   /* requiring chg/del*/

    KG0BW01.KG0BWSTP = KG0BW01.KG0BWSTP - 1;
    KG0BW02.KG0BWPDX = KG0BW02.KG0BWPDX - 1;
  end

  set KG0BM100.KG0BMOPT[1] cursor; /* set cursor at first line*/
  KG0BW01.KG0BWERR = "Y"; /* reconverse the screen*/

  KG0BW01.KG0BWCPG = KG0BW01.KG0BWCPG - 1;

  if (KG0BWCPG < 1)
    KG0BWCPG = 1;
  end

  if (KG0BW02.KG0BWPDX < 1)
    KG0BW02.KG0BWPDX = 0;
  end



end // end KG0B410

// scroll down
Function KG0B440()
   /* *********************************************************/
          /* scrolling down takes place*/
   /* *********************************************************/


  if (KG0BW01.KG0BWREM > 0) /* spaces on the last page*/
    if (KG0BW02.KG0BWCDX == KG0BW02.KG0BWBOT /* at the bottom*/
     && converseVar.validationMsgNum == 0)  
      converseLib.validationFailed(39); /* end of data*/
      KG0BW01.KG0BWERR = "Y";
      return;
    end
  else
    if (KG0BW01.KG0BWCPG > KG0BW01.KG0BWTPG /* allow one page past*/
     && converseVar.validationMsgNum == 0)  /* if no space on page*/
      converseLib.validationFailed(39); /* end of data*/
      KG0BW01.KG0BWERR = "Y";
      return;
    end
  end

  KG0BW01.KG0BWSTP = 0;
  KG0BW02.KG0BWPDX = KG0BW02.KG0BWCDX;

  while (KG0BW01.KG0BWSTP < 16 /* load the screen with the ws table*/
   && KG0BW02.KG0BWCDX < KG0BW02.KG0BWBOT)
    KG0BW01.KG0BWSTP = KG0BW01.KG0BWSTP + 1;
    KG0BW02.KG0BWCDX = KG0BW02.KG0BWCDX + 1;

    KG0BM100.KG0BMOPT[KG0BWSTP] = KG0BW02.KG0BWOPT[KG0BWCDX];
    KG0BM100.XDVCD[KG0BWSTP] = KG0BW02.XDVCD[KG0BWCDX];
    KG0BM100.XDVABRV[KG0BWSTP] = KG0BW02.XDVABRV[KG0BWCDX];
    KG0BM100.XOBCD[KG0BWSTP] = KG0BW02.XOBCD[KG0BWCDX];
    KG0BM100.XOBABRV[KG0BWSTP] = KG0BW02.XOBABRV[KG0BWCDX];
    KG0BM100.XGACD[KG0BWSTP] = KG0BW02.XGACD[KG0BWCDX];
    KG0BM100.XGAABRV[KG0BWSTP] = KG0BW02.XGAABRV[KG0BWCDX];
    KG0BM100.XPCCD[KG0BWSTP] = KG0BW02.XPCCD[KG0BWCDX];
    KG0BM100.XPCABRV[KG0BWSTP] = KG0BW02.XPCABRV[KG0BWCDX];
    KG0BM100.XPLCD[KG0BWSTP] = KG0BW02.XPLCD[KG0BWCDX];
    KG0BM100.XPLABRV[KG0BWSTP] = KG0BW02.XPLABRV[KG0BWCDX];
    KG0BM100.XGPCD[KG0BWSTP] = KG0BW02.XGPCD[KG0BWCDX];
    KG0BM100.XGPABRV[KG0BWSTP] = KG0BW02.XGPABRV[KG0BWCDX];
    KG0BM100.YSBCD[KG0BWSTP] = KG0BW02.YSBCD[KG0BWCDX];
    KG0BM100.YSBABRV[KG0BWSTP] = KG0BW02.YSBABRV[KG0BWCDX];
    KG0BM100.XXXSTAT[KG0BWSTP] = KG0BW02.XXXSTAT[KG0BWCDX];

    KG0B310(); /* set attributes to those of row requiring chg/del*/
  end

  KG0BW01.KG0BWSDX = KG0BW01.KG0BWSTP;
                                   /* reset current screen index*/
  if (KG0BW02.KG0BWCDX == KG0BW02.KG0BWBOT
   && KG0BW01.KG0BWERR == "N"
   && converseVar.validationMsgNum == 0)
    converseLib.validationFailed(39); /* last record displayed*/
  end

  KG0BW01.KG0BWRCD = KG0BW02.KG0BWCDX;
                                            /* record count set to last one*/

  while (KG0BW01.KG0BWSTP < 16)
    KG0BW01.KG0BWSTP = KG0BW01.KG0BWSTP + 1;
    KG0BM100.KG0BMOPT[KG0BWSTP] = " ";
    KG0BM100.XDVCD[KG0BWSTP] = " ";
    KG0BM100.XDVABRV[KG0BWSTP] = " ";
    KG0BM100.XOBCD[KG0BWSTP] = " ";
    KG0BM100.XOBABRV[KG0BWSTP] = " ";
    KG0BM100.XGACD[KG0BWSTP] = " ";
    KG0BM100.XGAABRV[KG0BWSTP] = " ";
    KG0BM100.XPLCD[KG0BWSTP] = " ";
    KG0BM100.XPLABRV[KG0BWSTP] = " ";
    KG0BM100.XPCCD[KG0BWSTP] = " ";
    KG0BM100.XPCABRV[KG0BWSTP] = " ";
    KG0BM100.XGPCD[KG0BWSTP] = " ";
    KG0BM100.XGPABRV[KG0BWSTP] = " ";
    KG0BM100.YSBCD[KG0BWSTP] = " ";
    KG0BM100.YSBABRV[KG0BWSTP] = " ";
    KG0BM100.XXXSTAT[KG0BWSTP] = " ";

   /* If last record defined on the screen is not the bottom of the*/
   /* array, define it so a row can be added.  If we have reached 200,*/
   /* the bottom of the array, then we do not want to define the rest of*/
   /* the rows on the screen as entry rows.  Define them as autoskip, dark.*/

    if (KG0BW01.KG0BWRCD < KG0BW01.KG0BWACT)
                                              /* If not passed btm of array*/
      KG0BW01.KG0BWRCD = KG0BW01.KG0BWRCD + 1;
      KG0B320(); /* set attributes to those of addition row*/
    else
      KG0B330(); /* set attributes so row is autoskip, dark*/
    end
  end


  set KG0BM100.KG0BMOPT[1] cursor; /* set cursor at first row.*/
  KG0BW01.KG0BWERR = "Y"; /* reconverse the screen*/

  KG0BW01.KG0BWCPG = KG0BW01.KG0BWCPG + 1;


end // end KG0B440

// add routine edit
Function KG0B550()
   /* *********************************************/
   /* edit line tagged for addition*/
   /* *********************************************/

  if (KG0BW02.XDVCD[KG0BWTDX] != " ") /* the line is not blank*/
    set KG0BM100.KG0BMOPT[KG0BWSTP] cursor, bold;
    KG0BW01.KG0BWERR = "Y";
    converseLib.validationFailed(423); /* 'A' option can only be entered on blank row*/
  else
    KG0B555(); /* Edit fields*/
    KG0B556(); /* Check for duplicate row*/
  end

end // end KG0B550

// edit row addition
Function KG0B555()
   /* ***************************************/
   /* * edit row additions                 **/
   /* ***************************************/

  KG0B320();

  if (KG0BM100.XDVCD[KG0BWSTP] == "**") /* edit division*/
    KG0BM100.XDVABRV[KG0BWSTP] = "GLOBAL";
  else
    if (KG0BM100.XDVCD[KG0BWSTP] in XDVTBL.XDVCD)
      KG0BM100.XDVABRV[KG0BWSTP] = XDVTBL.XDVABRV[sysVar.arrayIndex];
    else
      KG0BM100.XDVABRV[KG0BWSTP] = "UNKNWN";
      set KG0BM100.XDVCD[KG0BWSTP] cursor, bold;
      KG0BW01.KG0BWERR = "Y"; /* set error*/
      converseLib.validationFailed(17); /* set message*/
    end
  end

  if (KG0BM100.XOBCD[KG0BWSTP] == "**") /* edit base ot*/
    KG0BM100.XOBABRV[KG0BWSTP] = "GLOBAL";
  else
    if (KG0BM100.XOBCD[KG0BWSTP] in XOBTBL.XOBCD)
      KG0BM100.XOBABRV[KG0BWSTP] = XOBTBL.XOBABRV[sysVar.arrayIndex];
    else
      KG0BM100.XOBABRV[KG0BWSTP] = "UNKNWN";
      set KG0BM100.XOBCD[KG0BWSTP] cursor, bold;
      KG0BW01.KG0BWERR = "Y"; /* set error*/
      converseLib.validationFailed(17); /* set message*/
    end
  end

  if (KG0BM100.XGACD[KG0BWSTP] == "**") /* edit gender age*/
    KG0BM100.XGAABRV[KG0BWSTP] = "GLOBAL";
  else
    KG0BW01.KG0BW-KEY-XGPCD = KG0BM100.XGPCD[KG0BWSTP];
    KG0BW01.KG0BW-KEY-XGACD = KG0BM100.XGACD[KG0BWSTP];
    if (KG0BW01.KG0BW-XGATBL-KEY in XGATBL.XGAKEY)
      KG0BM100.XGAABRV[KG0BWSTP] = XGATBL.XGAABRV[sysVar.arrayIndex];
    else
      KG0BM100.XGAABRV[KG0BWSTP] = "UNKNWN";
      set KG0BM100.XGACD[KG0BWSTP] cursor, bold;
      KG0BW01.KG0BWERR = "Y"; /* set error*/
      converseLib.validationFailed(17); /* set message*/
    end
  end

  if (KG0BM100.XPLCD[KG0BWSTP] == "**") /* edit product line*/
    KG0BM100.XPLABRV[KG0BWSTP] = "GLOBAL";
  else
    if (KG0BM100.XPLCD[KG0BWSTP] in XPLTBL.XPLCD)
      KG0BM100.XPLABRV[KG0BWSTP] = XPLTBL.XPLABRV[sysVar.arrayIndex];
    else
      KG0BM100.XPLABRV[KG0BWSTP] = "UNKNWN";
      set KG0BM100.XPLCD[KG0BWSTP] cursor, bold;
      KG0BW01.KG0BWERR = "Y"; /* set error*/
      converseLib.validationFailed(17); /* set message*/
    end
  end

  if (KG0BM100.XPCCD[KG0BWSTP] == "**") /* edit prod category*/
    KG0BM100.XPCABRV[KG0BWSTP] = "GLOBAL";
  else
    if (KG0BM100.XPCCD[KG0BWSTP] in XPCTBL.XPCCD)
      KG0BM100.XPCABRV[KG0BWSTP] = XPCTBL.XPCABRV[sysVar.arrayIndex];
    else
      KG0BM100.XPCABRV[KG0BWSTP] = "UNKNWN";
      set KG0BM100.XPCCD[KG0BWSTP] cursor, bold;
      KG0BW01.KG0BWERR = "Y"; /* set error*/
      converseLib.validationFailed(17); /* set message*/
    end
  end

  if (KG0BM100.XGPCD[KG0BWSTP] == "**") /* edit GPC*/
    KG0BM100.XGPABRV[KG0BWSTP] = "GLOBAL";
  else
    if (KG0BM100.XGPCD[KG0BWSTP] in XGPTBL.XGPCD)
      KG0BM100.XGPABRV[KG0BWSTP] = XGPTBL.XGPABRV[sysVar.arrayIndex];
    else
      KG0BM100.XGPABRV[KG0BWSTP] = "UNKNWN";
      set KG0BM100.XGPCD[KG0BWSTP] cursor, bold;
      KG0BW01.KG0BWERR = "Y"; /* set error*/
      converseLib.validationFailed(17); /* set message*/
    end
  end

  if (KG0BM100.YSBCD[KG0BWSTP] in YSBTBL.YSBCD) /* edit YSB*/
    KG0BM100.YSBABRV[KG0BWSTP] = YSBTBL.YSBABRV[sysVar.arrayIndex];
  else
    KG0BM100.YSBABRV[KG0BWSTP] = "UNKNWN";
    set KG0BM100.YSBCD[KG0BWSTP] cursor, bold;
    KG0BW01.KG0BWERR = "Y"; /* set error*/
    converseLib.validationFailed(17); /* set message*/
  end


end // end KG0B555

// check for dups
Function KG0B556()
   /* ******************************************************************/
   /* * check for duplicate row or product line/ product category combo*/
   /* ******************************************************************/

  KG0BW02.KG0BWEDX = 0; /* prepare the table index*/

  KG0BW01.KG0BWSTS = KG0BM100.XXXSTAT[KG0BWSTP]; /* move status to ws*/

  if (KG0BM100.KG0BMOPT[KG0BWSTP] == "A") /* set status to 'a' if line is*/
    KG0BW01.KG0BWSTS = "A"; /* being added*/
  end

  while (KG0BW02.KG0BWEDX < KG0BW02.KG0BWBOT) /* loop thru ws-table*/
    KG0BW02.KG0BWEDX = KG0BW02.KG0BWEDX + 1; /* add to the index*/

   /* check for duplicate record*/
    if (KG0BM100.XPLCD[KG0BWSTP] == KG0BW02.XPLCD[KG0BWEDX]
     && KG0BM100.XPCCD[KG0BWSTP] == KG0BW02.XPCCD[KG0BWEDX]
     && KG0BM100.XOBCD[KG0BWSTP] == KG0BW02.XOBCD[KG0BWEDX]
     && KG0BM100.XGACD[KG0BWSTP] == KG0BW02.XGACD[KG0BWEDX]
     && KG0BM100.XDVCD[KG0BWSTP] == KG0BW02.XDVCD[KG0BWEDX]
     && KG0BM100.XGPCD[KG0BWSTP] == KG0BW02.XGPCD[KG0BWEDX])

      if (KG0BM100.KG0BMOPT[KG0BWSTP] == "C") /* use status if status*/
        if (KG0BW02.XXXSTAT[KG0BWEDX] == "A")
          if (KG0BM100.YSBCD[KG0BWSTP] == KG0BW02.YSBCD[KG0BWEDX])
            set KG0BM100.KG0BMOPT[KG0BWSTP] cursor, bold;
            KG0BW01.KG0BWERR = "Y"; /* set error*/
            converseLib.validationFailed(108); /* set dup error message*/
          else
            set KG0BM100.KG0BMOPT[KG0BWSTP] cursor, bold;
            KG0BW01.KG0BWERR = "Y"; /* set error*/
            converseLib.validationFailed(430); /* set dup record w/diff YSB*/
          end
        end
      else /* record is being added, look to see if any actives exist*/

        if (KG0BW01.KG0BWSTS == KG0BW02.XXXSTAT[KG0BWEDX])
          set KG0BM100.KG0BMOPT[KG0BWSTP] cursor, bold;
          KG0BW01.KG0BWERR = "Y"; /* set error*/

          if (KG0BM100.YSBCD[KG0BWSTP] == KG0BW02.YSBCD[KG0BWEDX])
            converseLib.validationFailed(108); /* set dup error message*/
          else
            converseLib.validationFailed(430); /* set dup record w/diff YSB error*/
          end
        end
      end
    end
  end
end // end KG0B556

// change routine edit
Function KG0B560()
   /* *********************************************/
   /* edit line tagged for modification*/
   /* *********************************************/

  if (KG0BM100.XDVCD[KG0BWSTP] == " ") /* the line is blank*/
    set KG0BM100.KG0BMOPT[KG0BWSTP] cursor, bold;
    KG0BW01.KG0BWERR = "Y";
    converseLib.validationFailed(425); /* 'c' option cannot be entered on blank row*/
  else
    KG0B565(); /* Edit fields*/
    /* Only have to check for duplicates if the status was chgd to active*/
    if (KG0BM100.XXXSTAT[KG0BWSTP] != KG0BW02.XXXSTAT[KG0BWTDX]
     && KG0BM100.XXXSTAT[KG0BWSTP] == "A") /* status changed to active*/
      KG0B556(); /* Check for duplicate row*/
    end
  end

end // end KG0B560

// edit row modification
Function KG0B565()
   /* ***************************************/
   /* * change row edits                   **/
   /* ***************************************/

  if (KG0BM100.YSBCD[KG0BWSTP] in YSBTBL.YSBCD) /* edit YSB*/
    KG0BM100.YSBABRV[KG0BWSTP] = YSBTBL.YSBABRV[sysVar.arrayIndex];
  else
    KG0BM100.YSBABRV[KG0BWSTP] = "UNKNWN";
    set KG0BM100.YSBCD[KG0BWSTP] cursor, bold;
    KG0BW01.KG0BWERR = "Y"; /* set error*/
    converseLib.validationFailed(17); /* set message*/
  end

  if (KG0BM100.XXXSTAT[KG0BWSTP] == "A" /* status must be 'A' or 'I'*/
   || KG0BM100.XXXSTAT[KG0BWSTP] == "I")
    /* next sentence*/
  else
    set KG0BM100.XXXSTAT[KG0BWSTP] cursor, bold;
    KG0BW01.KG0BWERR = "Y"; /* set error*/
    converseLib.validationFailed(431); /* set message*/
  end
end // end KG0B565

// delete routine edit
Function KG0B570()
   /* *********************************************/
   /* edit line tagged for deletion*/
   /* *********************************************/

  if (KG0BM100.XDVCD[KG0BWSTP] == " ") /* the line is blank*/
    set KG0BM100.KG0BMOPT[KG0BWSTP] cursor, bold;
    KG0BW01.KG0BWERR = "Y";
    converseLib.validationFailed(424); /* 'D' option cannot be entered on blank row*/
  else
    KG0B575(); /* Edit fields*/
  end

end // end KG0B570

// edit row deletion
Function KG0B575()
   /* ***************************************/
   /* * edit row deletions                 **/
   /* ***************************************/
                                                   /* can't change YSB*/
  if (KG0BM100.YSBCD[KG0BWSTP] == KG0BW02.YSBCD[KG0BWTDX])
   /* next sentence*/
  else
    set KG0BM100.YSBCD[KG0BWSTP] cursor, bold;
    KG0BW01.KG0BWERR = "Y"; /* set error*/
    converseLib.validationFailed(432); /* set message*/
  end

  if (KG0BM100.XXXSTAT[KG0BWSTP] == KG0BW02.XXXSTAT[KG0BWTDX])
    if (KG0BM100.XXXSTAT[KG0BWSTP] == "I") /* status is already inactive*/
      set KG0BM100.KG0BMOPT[KG0BWSTP] cursor, bold;
      KG0BW01.KG0BWERR = "Y"; /* set error*/
      converseLib.validationFailed(437); /* set message*/
    end
  else /* can't change status*/
    set KG0BM100.XXXSTAT[KG0BWSTP] cursor, bold;
    KG0BW01.KG0BWERR = "Y"; /* set error*/
    converseLib.validationFailed(432); /* set message*/
  end
end // end KG0B575

// update database with changes
Function KG0B600()
   /* ****************************************/
   /* this process updates the records that**/
   /* have been selected                   **/
   /* ****************************************/

  KG0B300(); /* edit current screen*/

  if (KG0BW01.KG0BWERR == "Y")
    return;
  end

  if ("D" in KG0BM100.KG0BMOPT
   || "A" in KG0BM100.KG0BMOPT
   || "C" in KG0BM100.KG0BMOPT)
      /* next sentence                     /* If any row has update*/
  else
    KG0BW01.KG0BWERR = "Y"; /* set error message*/
    converseLib.validationFailed(280); /* no changes marked*/
    return;
  end


  KG0BW01.KG0BWSTP = 0; /* prepare screen index*/
  KG0BW02.KG0BWTDX = KG0BW02.KG0BWPDX; /* prepare table index*/

  while (KG0BW01.KG0BWSTP < 16)
    KG0BW01.KG0BWSTP = KG0BW01.KG0BWSTP + 1; /* add to the index*/
    KG0BW02.KG0BWTDX = KG0BW02.KG0BWTDX + 1; /* add to the index*/

   /* ****************************************************************/
   /* If the user changed a row, they could possibly have changed the*/
   /* ysb or the status.  If the ysb was changed and the record was*/
   /* active, then the 'old' record should be updated in the table as*/
   /* inactive and the 'new' record added to the table.  If the ysb was*/
   /* changed but the record was inactive, the table is just updated with*/
   /* the new ysb and the status remains as inactive.  If just the status*/
   /* of the record was changed and not the ysb, the record is updated on*/
   /* the table using the new YSB.  Since all inactives were purged after*/
   /* the Sales Analysis weekend run, all the inactives in the file are*/
   /* ones that happened during the week.  This is why it is not important*/
   /* to keep the 'old' inactives around if they are changed during the*/
   /* week.*/
   /* ****************************************************************/
   /* /*/
    if (KG0BM100.KG0BMOPT[KG0BWSTP] == "C")

     /* if status is inactive or the ysb has not changed the status*/
     /* for the record to be updated comes from the map.*/

      if (KG0BM100.XXXSTAT[KG0BWSTP] == "I"
       || KG0BW02.YSBCD[KG0BWTDX] == KG0BM100.YSBCD[KG0BWSTP])

        KGBREC.XXXSTAT = KG0BW02.XXXSTAT[KG0BWTDX];
        KGBREC.YSBCD = KG0BW02.YSBCD[KG0BWTDX];
        KG0B620(); /* delete the old row*/

        KGBREC.XXXSTAT = KG0BM100.XXXSTAT[KG0BWSTP];
        KGBREC.YSBCD = KG0BM100.YSBCD[KG0BWSTP];
        KG0B640(); /* add the new row*/
      else
        /* the ysb on the row was changed and the status is active, so the*/
        /* 'old' row must be made inactive in the file and the new row*/
        /* added with an 'A' status.*/

        KGBREC.XXXSTAT = "I";
        KGBREC.YSBCD = KG0BW02.YSBCD[KG0BWTDX];
        KG0B620(); /* delete old inactives out there*/
        KG0B640(); /* insert inactive*/

        KGBREC.XXXSTAT = "A";
        KGBREC.YSBCD = KG0BM100.YSBCD[KG0BWSTP];
        KG0B640(); /* add new row to the table*/
      end
    else
      if (KG0BM100.KG0BMOPT[KG0BWSTP] == "A")
        KGBREC.XXXSTAT = "A";
        KGBREC.YSBCD = KG0BM100.YSBCD[KG0BWSTP];
        KG0B640(); /* add new row to table*/
      else
        if (KG0BM100.KG0BMOPT[KG0BWSTP] == "D")
          KGBREC.XXXSTAT = "I";
          KGBREC.YSBCD = KG0BM100.YSBCD[KG0BWSTP];
          KG0B620(); /* inactivate this row on the table*/
          KG0B640();
        end
      end
    end
  end

  converseLib.validationFailed(029); /* updates ok message*/

  KG0B200(); /* refresh screen*/

end // end KG0B600

// delete row from table
Function KG0B620()
   /* ********************************************/
   /* * deletes row from table*/
   /* ********************************************/

  set SQLCA empty;

  KGBREC.XDVCD = KG0BW02.XDVCD[KG0BWTDX];
  KGBREC.XOBCD = KG0BW02.XOBCD[KG0BWTDX];
  KGBREC.XGBCD = KG0BW02.XGACD[KG0BWTDX];
  KGBREC.XPCCD = KG0BW02.XPCCD[KG0BWTDX];
  KGBREC.XPLCD = KG0BW02.XPLCD[KG0BWTDX];
  KGBREC.XGPCD = KG0BW02.XGPCD[KG0BWTDX];

  call "IO5420" ("D ", SQLCA, KGBREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    /* next sentence*/
  else
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.rollback();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
     /* roll back changes if abend*/
    TA1REC.TA1TYPE = "DB2";
    TA1REC.TA1FUNC = "ABND";
    TA1REC.TA1DBASE = "DCUST";
    TA1REC.TA1TBLVU = "VCUYSB01";
    TA1REC.TA1MAP = " ";
    TA1REC.TA1PGMNM = "KG0B620";
    TA1REC.TA1LOC = "SELECT ROW ON VCUYSB01";
    call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
  end

end // end KG0B620

// add row
Function KG0B640()
   /* ********************************************/
   /* * add row*/
   /* ********************************************/

  TA2REC.TA2DTOPT = "GETDATE"; /* get current date for*/
  call "TA0040" (TA2REC) {isNoRefresh = yes, isExternal = yes}; /* update all records*/


  set SQLCA empty;

  KGBREC.XDVCD = KG0BM100.XDVCD[KG0BWSTP];
  KGBREC.XOBCD = KG0BM100.XOBCD[KG0BWSTP];
  KGBREC.XGBCD = KG0BM100.XGACD[KG0BWSTP];
  KGBREC.XPLCD = KG0BM100.XPLCD[KG0BWSTP];
  KGBREC.XPCCD = KG0BM100.XPCCD[KG0BWSTP];
  KGBREC.XGPCD = KG0BM100.XGPCD[KG0BWSTP];

  KGBREC.ZZZSDT = TA2REC.TA2GRGGN;
  KGBREC.ZZZCHGDT = TA2REC.TA2GRGGN;
  KGBREC.ZZZCHGTM = TA2REC.TA2TIMHM;

  call "IO5420" ("A ", SQLCA, KGBREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    /* next sentence*/
  else
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.rollback();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
     /* roll back changes if abend*/
    TA1REC.TA1TYPE = "DB2";
    TA1REC.TA1FUNC = "ABND";
    TA1REC.TA1DBASE = "DCUST";
    TA1REC.TA1TBLVU = "VCUYSB01";
    TA1REC.TA1MAP = " ";
    TA1REC.TA1PGMNM = "KG0B640";
    TA1REC.TA1LOC = "ADD ROW ON VCUYSB01";
    call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
  end


end // end KG0B640

Record KG0BW01 type basicRecord
  10 KG0BWERR KG0BWERR ; 
  10 KG0BWEOF KG0BWEOF ; 
  10 KG0BWCPG KG0BWCPG ; 
  10 KG0BWTPG KG0BWTPG ; 
  10 KG0BWREM KG0BWREM ; 
  10 KG0BWCNT KG0BWCNT ; 
  10 KG0BWSTP KG0BWSTP ; 
  10 KG0BWSDX KG0BWSDX ; 
  10 KG0BWMSG KG0BWMSG ; 
  10 KG0BWOVM KG0BWOVM ; 
  10 KG0BWSOE KG0BWSOE ; 
  10 KG0BWSTS KG0BWSTS ; 
  10 KG0BWEXC KG0BWEXC ; 
  10 KG0BWRCD KG0BWRCD ; 
  10 KG0BWACT KG0BWACT ; 
  10 KG0BWIDX KG0BWIDX ; 
  10 KG0BWDUP KG0BWDUP ; 
  10 KG0BW-XGATBL-KEY KG0BW-XGATBL-KEY ; 
    15 KG0BW-KEY-XGACD KG0BW-KEY-XGACD ; 
    15 KG0BW-KEY-XGPCD KG0BW-KEY-XGPCD ; 
  10 XPLKEY XPLKEY ; 
    15 XPLCD XPLCD ; 
    15 XGPCD XGPCD ; 
  10 KG0BW-PAGE-NUM KG0BW-PAGE-NUM ; 
  10 KG0BW-PAGE-TOT KG0BW-PAGE-TOT ; 
end // end KG0BW01

//*** RECORD=KG0BW02 ****
// this is the csp working storage format company table.  the
// table contains data that is specific to the company level
// of the customer data base.
// 
// db2 table:        dcust.vcmpny01
// 
// dclgen:           dcl0021
// 
// i/o mod:          io0240
// 
// key to table:     kuccoid   -   cu-co-id
// 
// date created:     4/4/86
// 
// maintanence log:
//   who       when     why
// --------- --------  ---------------------------------------
// ctrouw    03/03/87  added to new fields - major group co-id
//                     and co-op analyst code.
// ctrouw    05/12/89  changed size of paydex score
//                     changed name from kucdhind to kuclbofl
//                     added various fields for A/R and NIL
// jfiat     11/09/89  database changes.
//                     added:kucxsond, kucpoqnd.
//                     deleted:edi fields.
// jfiat     01/15/90  database changes.
//                     added:yvicd(1-3), ylicd, kucxacap
//                           kucxacft, kucseqap, kucseqft
//                     deleted:kucltint, kuccsrt, kuccrvdt,
//                             kucuacr
// dsalzw    10/02/90  database changes.
//                     added:kucadrid, kucsrind, kuceom,
//                           kucpdind, kucecody, kucpdspd,
//                           xlbcd
//                     deleted:kuccaldt, kucdtlsa, kucdtlsf,
//                             kucnooh, kucorinp, kucxsond
//                     renamed:xcu_cd(3) to xce_cd
// CHELLM    10/21/94  Added XOB AND =XGB codes.
// ***********************
Record KG0BW02 type basicRecord
  5 KG0BWGR2 KG0BWGR2 ; 
    10 KG0BWTDX KG0BWTDX ; 
    10 KG0BWEDX KG0BWEDX ; 
    10 KG0BWCDX KG0BWCDX ; 
    10 KG0BWPDX KG0BWPDX ; 
    10 KG0BWBOT KG0BWBOT ; 
    10 KG0BWSCN KG0BWSCN [562] ; 
      15 KG0BWOPT KG0BWOPT ; 
      15 XDVCD XDVCD ; 
      15 XDVABRV XDVABRV ; 
      15 XOBCD XOBCD ; 
      15 XOBABRV XOBABRV ; 
      15 XGACD XGACD ; 
      15 XGAABRV XGAABRV ; 
      15 XPCCD XPCCD ; 
      15 XPCABRV XPCABRV ; 
      15 XPLCD XPLCD ; 
      15 XPLABRV XPLABRV ; 
      15 XGPCD XGPCD ; 
      15 XGPABRV XGPABRV ; 
      15 YSBCD YSBCD ; 
      15 YSBABRV YSBABRV ; 
      15 XXXSTAT XXXSTAT ; 
end // end KG0BW02

//*** RECORD=KGBREC ****
// this is the csp working storage format company table.  the
// table contains data that is specific to the company level
// of the customer data base.
// 
// db2 table:        dcust.vcmpny01
// 
// dclgen:           dcl0021
// 
// i/o mod:          io0240
// 
// key to table:     kuccoid   -   cu-co-id
// 
// date created:     4/4/86
// 
// maintanence log:
//   who       when     why
// --------- --------  ---------------------------------------
// ctrouw    03/03/87  added to new fields - major group co-id
//                     and co-op analyst code.
// ctrouw    05/12/89  changed size of paydex score
//                     changed name from kucdhind to kuclbofl
//                     added various fields for A/R and NIL
// jfiat     11/09/89  database changes.
//                     added:kucxsond, kucpoqnd.
//                     deleted:edi fields.
// jfiat     01/15/90  database changes.
//                     added:yvicd(1-3), ylicd, kucxacap
//                           kucxacft, kucseqap, kucseqft
//                     deleted:kucltint, kuccsrt, kuccrvdt,
//                             kucuacr
// dsalzw    10/02/90  database changes.
//                     added:kucadrid, kucsrind, kuceom,
//                           kucpdind, kucecody, kucpdspd,
//                           xlbcd
//                     deleted:kuccaldt, kucdtlsa, kucdtlsf,
//                             kucnooh, kucorinp, kucxsond
//                     renamed:xcu_cd(3) to xce_cd
// CHELLM    10/02/91  Database changes.
//                     Added:XPLCD
// CHELLM    10/21/94  Database changes.
//                     Added:XOBCD, XGACD, and Product
// **********************
Record KGBREC type basicRecord
  5 KGBGRP KGBGRP ; 
    10 XDVCD XDVCD ; 
    10 XOBCD XOBCD ; 
    10 XGBCD XGBCD ; 
    10 XPCCD XPCCD ; 
    10 XPLCD XPLCD ; 
    10 XGPCD XGPCD ; 
    10 YSBCD YSBCD ; 
    10 XXXSTAT XXXSTAT ; 
    10 ZZZSDT ZZZSDT ; 
    10 ZZZCHGDT ZZZCHGDT ; 
    10 ZZZCHGTM ZZZCHGTM ; 
    10 ZZZCHGCT ZZZCHGCT ; 
end // end KGBREC

// KG0BW-KEY-XGACD
DataItem KG0BW-KEY-XGACD char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// KG0BW-KEY-XGPCD
DataItem KG0BW-KEY-XGPCD char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem KG0BW-PAGE-NUM num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

DataItem KG0BW-PAGE-TOT num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// KG0BW-XGATBL-KEY
DataItem KG0BW-XGATBL-KEY char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// end of file
DataItem KG0BWACT num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// table index
DataItem KG0BWBOT num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// current index
DataItem KG0BWCDX num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// counter
DataItem KG0BWCNT num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// page counter
DataItem KG0BWCPG num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// end of file
DataItem KG0BWDUP char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// edit index
DataItem KG0BWEDX num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// end of file
DataItem KG0BWEOF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// error flag
DataItem KG0BWERR char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// end of file
DataItem KG0BWEXC char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem KG0BWGR2 char(32641)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// end of file
DataItem KG0BWIDX num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// application error message
DataItem KG0BWMSG char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// option, 'a' & 'd'
DataItem KG0BWOPT char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// MSG- too many rows
DataItem KG0BWOVM char(60)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// previous index
DataItem KG0BWPDX num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// end of file
DataItem KG0BWRCD num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// reminder
DataItem KG0BWREM num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// one row on screen
DataItem KG0BWSCN char(58)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// screen current index
DataItem KG0BWSDX num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// end of file
DataItem KG0BWSOE char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// screen top
DataItem KG0BWSTP num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// end of file
DataItem KG0BWSTS char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// temp index
DataItem KG0BWTDX num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// total number of pages
DataItem KG0BWTPG num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// cuysb record group field
DataItem KGBGRP char(27)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

