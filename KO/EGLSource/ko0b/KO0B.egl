package ko0b;

import corpcom4.XSENTRY;
import corpcom4.XSEXIT;
import corpcom4.XSKO001;
import corpcom4.XSPF1;
import corpcom4.XSPF4;
import corpcom4.XSSEGTR;
import corpcom5.*;
import corpcom6.SQLCA;
import corpx1.XOTTBL;
import corpx2.XOTABRV;
import corpx2.XOTCD;
import corpx2.XXXUSRID;
import corpz3.ZZZCHGCT;
import corpz3.ZZZCHGDT;
import corpz3.ZZZSDT;
import ko.common.KOAREC;
import ko.common.KOBCOPCT;
import ko.common.KOBPCTED;
import ko.common.KOBPCTXD;
import ko.common.KOBREC;
import sm.common.SM1AGYID;
import sm.common.SM1REC;
import sm.common.SM4REPID;
import ta.common.TA1REC;
import ta.common.TA2REC;
import ta.common.TA2TIMEN;
import ta.common.TA2TIMHM;
import ta.common.TA2TIMSS;
import vv.common.VRAGCY02;
//*** PROGRAM=KO0B ****
// ************************************************************
// *               commission order type overview
// 
// THIS PROGRAM MAINTAINS THE COMMISSION RATES FOR EACH NIKE
// ORDER TYPE. THERE IS A FLAG IN THE ORDER TYPE TABLE
// IDENTIFYING THOSE ORDER TYPES FOR WHICH COMMISSION IS PAID.
// 
// ONLY ONE ORDER TYPE CAN BE IN EFFECT AT A TIME.
// 
// THE APPLICATION WILL ALLOW THE USER TO ENTER A NEW RATE
// AND DATE FROM THE KO0BM001 SCREEN, THE RATE AND DATE WILL
// BE DUPLICATED FOR EACH ORDER TYPE ON KO0BM002. THE USER CAN
// THEN CHANGE ANY RATE OR DATE. THE USER WILL PRESS ENTER TO
// ADD THESE NEW RATES INTO KOBREC TABLE FROM KO0BM002.
// THE AGENCY MUST BE ACTIVE BEFORE AN ADD CAN OCCURE. IF THE
// THE ADD IS FOR AN AGENCY/REP THEN THE REP sm5rec.sm5comin
// FLAG CAN NOT BE "NP".
// THERE IS A PROCESS WHICH WILL TERMINATE AN AGENCY/REP
// FROM KO0BM001 SCREEN. THE USER WILL ENTER THE TERMINATION
// DATE AND PRESS ENTER TWICE TO ADD THE ENDING DATE TO ALL
// OF THE CURRENT ORDER TYPES ASSOCIATED WITH THAT AGENCY/REP.
// THE PROCESS TO ACTIVE A LIST OF ORDER TYPE HISTORY
// IS TO ENTER THE ORDER TYPE ON KO0BM001 SCREEN. SCREEN
// KO0BM002 WILL DISPLAY ALL OF THE HISTORY FOR THAT ORDER TYPE
// THE RATES,DATES AND REASON CODE CAN ALL BE CHANGED.
// IF THERE IS AN ENDING DATE THEN THE EFF. DATE CAN NOT BE
// CHANGED TO BE > THE ENDING DATE.
// ------------------------------------------------------------
// maintenance history
// 
// rev
// num.  when      who       why
// ----  --------  --------  ----------------------------------
// 00    10-30-86  jricha    created application.
// 01    12-16-88  jJWOOD    ADDED NONCSP OPTION TO CALLS
// 01    12-16-88  jJWOOD    ADDED XSSEGTR LOGIC
// 02    09-08-89  jbecke    added koarec.xrccd update in sdb.
// 03    11-13-89  jbecke    changed ypg to xpr sbe,bl,db,020.
// 04    08-26-91  jbecke    increase xot table to 154
// 05    04-09-92  aivers    rename sm5stat to xxxstat.
// 06    10-09-92  aivers    database changes.  Get rep's name
//                           from vragcy02 instead of sm5rec.
// 07    02-24-94  RPATTE    database changes.  DELETE MOVE OF
//                           XRCCD TO KOAREC.
// ------------------------------------------------------------
// *********************
Program KO0B type textUIProgram //VAGen Info - main text program
  {
  includeReferencedFunctions = yes, allowUnqualifiedItemReferences = yes, 
  throwNrfEofExceptions = yes, handleHardIOErrors = no, V60ExceptionCompatibility = yes, 
  I4GLItemsNullable = no, textLiteralDefaultIsString = no, localSQLScope = yes, 
  msgTablePrefix = "CO00", inputRecord = COMMAREA, segmented = yes
  }

  // Data Declarations
  COMMAREA COMMAREA ; // record
  ERRSQLCA ERRSQLCA; // record
  KO0BW02 KO0BW02; // record
  KO0BWMAP KO0BWMAP; // record
  KOAREC KOAREC; // record
  KOBREC KOBREC; // record
  SM1REC SM1REC; // record
  SQLCA SQLCA; // record
  TA1REC TA1REC; // record
  TA2REC TA2REC; // record
  VRAGCY02 VRAGCY02; // record

  // VAGen Info - items needed for migration
  VAGen_EZESYS char(8);
  VAGen_EZEREPLY num(1);
  VAGen_EZE_WAIT_TIME bin(9,2);
  VAGen_EZE_ITEMLEN int;

  // Use Declarations
  use XOTTBL {deleteAfterUse = yes}; // table
  use KO0BM.KO0BM001,  // forms
      KO0BM.KO0BM002
   {
    pfKeyEquate = no
  };

  function main()
    // VAGen Info - initialization needed for migration
    VAGen_EZESYS = VGLib.getVAGSysType();
    KO0B001: KO0B001();
     /* ******************************************/
      /* if caitem is not blank then proceed to*/
      /* to ko0b010 which will try to retrieve a valid*/
      /* comm. order type schedule for the agency entered.*/
     /* ******************************************/

    if (KO0BW02.SM1AGYID > " ")
      goto KO0B010;
    else
      goto KO0B005;
    end



    KO0B005: KO0B005();
     /* ********************************************/

    if (KO0BW02.KO0BWEFL == "Y"
     || converseVar.validationMsgNum > 0)
      goto KO0B005;
    else
      goto KO0B010;
    end


     /* ********************************************/
    KO0B010: KO0B010();
     /* ********************************************/

    if (KO0BW02.KO0BWFFL == "T")
      if (KO0BW02.KO0BWEFL == "Y") /* show where curr. date > term. date*/
        goto KO0B005;
      else
        if (KO0BW02.KO0BWCFL == "Y") /* user pressed enter twice can now process.*/
          goto KO0B020; /* add to db2 tables*/
        else
          KO0BW02.KO0BWCFL = "Y"; /* user has pressed enter once*/
          converseLib.validationFailed(108); /* press enter to terminate*/
          goto KO0B005;
        end
      end
    else
      if (converseVar.eventKey is pf12)
        if (KO0BW02.KO0BWEFL == "Y"
         || converseVar.validationMsgNum > 0)
          goto KO0B005;
        else
          converseLib.validationFailed(76); /* edit function complete, press enter to cont.*/
          goto KO0B005;
        end
      else
        if (KO0BW02.KO0BWEFL == "Y"
         || converseVar.validationMsgNum > 0
         || converseVar.eventKey is pf12)
          goto KO0B005;
        else
          goto KO0B015;
        end
      end
    end

     /* ********************************************/
    KO0B015: KO0B015();
     /* *****************************************/

    if (converseVar.eventKey is pf16)
      goto KO0B005;
    else
      /* next sentence*/
    end

    if (KO0BW02.SM1AGYID != KO0BM002.SM1AGYID
     || KO0BW02.SM4REPID != KO0BM002.SM4REPID)
      goto KO0B010;
    else
      /* next sentence*/
    end


    if (KO0BW02.KO0BWEFL == "Y")
      goto KO0B015;
    else
      /* next sentence*/
    end

    if (converseVar.eventKey is pf7
     || converseVar.eventKey is pf8)
      goto KO0B015;
    else
      /* next sentence*/
    end

    if (converseVar.eventKey is pf12)
      if (KO0BW02.KO0BWEFL == "Y"
       || converseVar.validationMsgNum > 0)
        goto KO0B015;
      else
        converseLib.validationFailed(76); /* edit function complete,press enter to cont.*/
        goto KO0B015;
      end
    else
      if (converseVar.eventKey is enter
       && KO0BW02.KO0BWEFL == "N")
        goto KO0B020;
      end
    end



    KO0B020: KO0B020();
     /* ******************************************/
    if (KO0BW02.KO0BWEFL == "Y")
      goto KO0B015;
    else
      goto KO0B005;
    end

  end // end main
end // end KO0B

// initialize application
Function KO0B001()

       /* ***************************************/
       /* * set all records and maps to zero   **/
       /* * or blanks. validate entry          **/
       /* *                                    **/
       /* * check for fast path.               **/
       /* ***************************************/

  XSENTRY();


  XSSEGTR(); /* SET SEGMENTED TRANSACTION ID*/

  set SQLCA empty;
  set KOAREC empty;
  set KOBREC empty;
  set KO0BW02 empty;
  set KO0BWMAP empty;
  set SM1REC empty;
  set VRAGCY02 empty;
  set TA1REC empty;
  set TA2REC empty;
  set ERRSQLCA empty;

  set KO0BM001 initial;
  set KO0BM002 initial;

       /* ***************************************/
       /* *  if user fast paths into this appl.**/
       /* *  then the caitem area is moved to  **/
       /* *  a redefined area and the record is**/
       /* *  retrieved from db2, and the screen**/
       /* *  displayed.                        **/
       /* ***************************************/

  if (COMMAREA.CAITEM > " ")
    KO0BW02.KO0BWKEY = COMMAREA.CAITEM;
    KO0BM001.SM1AGYID = KO0BW02.KO0BWAID;
    KO0BM001.SM4REPID = KO0BW02.KO0BWRID;
    KO0BW02.SM1AGYID = KO0BW02.KO0BWAID;
    KO0BW02.SM4REPID = KO0BW02.KO0BWRID;
    COMMAREA.CATOAP = " ";
    COMMAREA.CAITEM = " ";
  else
    /* next sentence*/
  end



end // end KO0B001

// display comm. rate screen
Function KO0B005()

       /* ***************************************/
       /* *  display ko0bm001 map. the agency  **/
       /* *  is a required field.              **/
       /* *                                    **/
       /* *  only one ko0bwffl (function) can  **/
       /* *  be active.                        **/
       /* *                                    **/
       /* *    'A' - will be for mass adds     **/
       /* *                                    **/
       /* *    'O' - retrieve current and      **/
       /* *          history order types       **/
       /* *                                    **/
       /* *    'T' - terminate all current o.t.**/
       /* *          for the agency,rep/agency **/
       /* *          (update the comm. ending  **/
       /* *           date.)                   **/
       /* *                                    **/
       /* *    ' ' - retrieve and update only  **/
       /* *          current order types (o.t.)**/
       /* *                                    **/
       /* *                                    **/
       /* ***************************************/



  KO0BM001.XXXCURDT = VGVar.currentShortGregorianDate;



   /* ********************************************/
  converse KO0BM001 ;
   /* ********************************************/

  KO0BSAA(); /* validate pf keys*/

  KO0BSAC(); /* set screen to normal*/

  KO0BW02.KO0BWFFL = " ";
  KO0BSAB(); /* validate relational screen field*/
                                   /* edits*/


end // end KO0B005

// retrieve comm. o.t. schedule
Function KO0B010()
   /* *************************************************/

  if (KO0BM001.SM1AGYID > " ")
    KO0BSBA(); /* validate and retrieve sales agency name.*/
  else
    converseLib.validationFailed(4); /* this agency does not exist*/
    exit stack;
  end

  if (KO0BM001.SM4REPID > 0)
    KO0BSBB(); /* validate and retrieve rep/agency*/
                                   /* name.*/
  else
    /* next sentence*/
  end



  if (KO0BW02.KO0BWFFL == "O")
    KO0BW02.KO0BWCDX = 0;
    KO0BW02.KO0BWTOT = 0;
    KO0BSBK(); /* RETRIEVE THE ORDER TYPE IN DATE DECENDING ORDER*/
  else
    if (KO0BW02.KO0BWFFL == "A")

      KO0BSBC(); /* retrieve commissionable order types.*/

      KO0BSBD(); /* retrieve all current order type comm. schedule*/

      KO0BSBG(); /* move add fields from ko0bm001 to ko0bwmap*/

      KO0BSBQ(); /* check if new eff. dates are > and existing term. date*/

    else
      if (KO0BW02.KO0BWFFL == "T")
        KO0BW02.KO0BWCDX = 0;
        KO0BW02.KO0BWTOT = 0;
        KO0BSBD(); /* retrieve all current order type comm. schedule*/

        KO0BSBP(); /* validate termination date with curr. eff. date*/

      else
        if (KO0BW02.KO0BWFFL == " ")

          KO0BSBC(); /* retrieve commissionable order types.*/

          KO0BSBD(); /* retrieve all current order type comm. schedule*/
        else
          /* next sentence*/
        end
         /* END ;*/
      end
    end
  end


  KO0BSBJ();
                                   /* move fields from ko0bwmap to ko0bm002*/


end // end KO0B010

// display retrieved o.t. data
Function KO0B015()



  KO0BM002.XXXCURDT = VGVar.currentShortGregorianDate;



   /* ******************************************/
  converse KO0BM002 ;
   /* ********************************************/

  KO0BW02.KO0BWEFL = "N";
  KO0BSCA(); /* validate pf keys*/


  if (KO0BM002.SM1AGYID != KO0BW02.SM1AGYID
   || KO0BM002.SM4REPID != KO0BW02.SM4REPID
   || converseVar.eventKey is pf16) /* return to first screen clear*/
                                   /* everything*/
    KO0BSCK(); /* the user is requesting a new agency*/
    exit stack;
  else
    /* next sentence*/
  end


  if (converseVar.eventKey is pf7)
    KO0BSCB(); /* scroll backwards.*/
  else
    /* next sentence*/
  end

  if (converseVar.eventKey is pf8)
    KO0BSCC(); /* scroll forward.*/
  else
    /* next sentence*/
  end

  if (converseVar.eventKey is enter
   || converseVar.eventKey is pf12)
    KO0BSCF(); /* validate all fields*/
  else
    /* next sentence*/
  end


end // end KO0B015

// update o.t. db2 tables.
Function KO0B020()
   /* ******************************************/

  KO0BW02.KO0BWCDX = 1;
  KO0BW02.KO0BWEFL = "N";

  KO0BSDD(); /* get change date and time*/

  converseLib.validationFailed(63); /* nothing has changed ,no updates*/


  while (KO0BW02.KO0BWCDX <= KO0BW02.KO0BWTOT
   && KO0BW02.KO0BWEFL == "N")

    set KOBREC empty;
    /* initialise kobrec.*/

    KOBREC.SM1AGYID = KO0BM002.SM1AGYID;
    KOBREC.SM4REPID = KO0BM002.SM4REPID;
    KOBREC.XPRCD = "**";
    KOBREC.YSCCD = "**";
    KOBREC.KUCCOID = -1;
    KOBREC.XDVCD = "99";
    KOBREC.XGPCD = "99";
    KOBREC.XOBCD = "99";
    KOBREC.XSOCD = "99";
    KOBREC.XOTCD = KO0BWMAP.XOTCD[KO0BWCDX];
    KOBREC.KOBPCTED = KO0BWMAP.KOBPCTED[KO0BWCDX];
    KOBREC.KOBPCTXD = KO0BWMAP.KOBPCTXD[KO0BWCDX];
    KOBREC.KOBCOPCT = KO0BWMAP.KOBCOPCT[KO0BWCDX];
    KOBREC.XXXUSRID = KO0BWMAP.XXXUSRID[KO0BWCDX];
    KOBREC.ZZZSDT = KO0BWMAP.ZZZSDT[KO0BWCDX];
    KOBREC.ZZZCHGDT = KO0BWMAP.ZZZCHGDT[KO0BWCDX];
    KOBREC.ZZZCHGCT = KO0BWMAP.ZZZCHGCT[KO0BWCDX];

    if (KO0BW02.KO0BWFFL == "T")
      KO0BSDA(); /* update ending date*/
    else
    /* IF KO0BWMAP.KO0BMRCD(KO0BWCDX) EQ 'CH'*/
    /* OR KO0BWMAP.KO0BMRCD(KO0BWCDX) EQ 'NR';*/
      if (KO0BWMAP.KO0BMPCT[KO0BWCDX] >= 0
       && KO0BWMAP.KO0BMEDT[KO0BWCDX] > " ")
        KO0BSDF(); /* ; add record*/
      else
   /* END;*/
   /* ELSE;*/
        if (KO0BWMAP.KO0BMEDT[KO0BWCDX] > " ")
   /* AND KO0BWMAP.KO0BMRCD(KO0BWCDX) NE ' ';*/
          KO0BSDE(); /* delete & new add*/
        else
          if (KO0BWMAP.KO0BMPCT[KO0BWCDX] >= 0)
   /* AND KO0BWMAP.KO0BMRCD(KO0BWCDX) NE ' ';*/
            KO0BSDH(); /* change order type row data*/
          end
        end
      end
    end

    KO0BW02.KO0BWCDX = KO0BW02.KO0BWCDX + 1;
  end

  if (KO0BW02.KO0BWEFL == "Y")
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.rollback();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
    
  else
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.commit();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
    
    KO0BSCK();
  end


end // end KO0B020

// validate and execute pf keys
Function KO0BSAA()


  if (converseVar.eventKey is pf1)
    XSPF1();
    KO0BM001.XXXMSG = COMMAREA.CAMSG;
    return;
  else
    if (converseVar.eventKey is pf4)
      XSPF4();
      KO0BM001.XXXMSG = COMMAREA.CAMSG;
      return;
    else
      if (converseVar.eventKey is pf3
       || converseVar.eventKey is pa2)
        COMMAREA.CATOAP = "KO0A";
        XSEXIT();
        KO0BM001.XXXMSG = COMMAREA.CAMSG;
        return;
      else
        if (KO0BM001.CATOAP != " ")
          if (converseVar.eventKey is enter)
            COMMAREA.CATOAP = KO0BM001.CATOAP;
            COMMAREA.CAITEM = KO0BM001.CAITEM;
            XSEXIT();
            KO0BM001.XXXMSG = COMMAREA.CAMSG;
            exit stack;
          else
            set KO0BM001.CATOAP cursor, bold;
            converseLib.validationFailed(1);
            exit stack;
          end
        else
          if (converseVar.eventKey is pf12
           || converseVar.eventKey is enter)
            return;
          else
            converseLib.validationFailed(2);
            exit stack;
          end
        end
      end
    end
  end


end // end KO0BSAA

// verify relational field edits
Function KO0BSAB()
   /* ******************************************/

       /* ***************************************/
       /* * the csp element name ko0bwffl is   **/
       /* * used to decide which db2 tables to **/
       /* * retrieve data from and which db2   **/
       /* * table to update. ko0bwffl can      **/
       /* * have four values:                  **/
       /* *                                    **/
       /* * ko0bwffl - function flag           **/
       /* *                                    **/
       /* *                                    **/
       /* *    'a' - will be for mass adds     **/
       /* *    'o' - retrieve current order    **/
       /* *          types if ko0bm001 order   **/
       /* *          type field is blank.      **/
       /* *          otherwise bring back all  **/
       /* *          of the history for the    **/
       /* *          order type that was       **/
       /* *          entered on ko0bm001 order **/
       /* *          type field.               **/
       /* *                                    **/
       /* *    't' - terminate all current o.t.**/
       /* *          for the agency,rep/agency **/
       /* *          (update the comm. ending  **/
       /* *           date.)                   **/
       /* *    ' ' - retrieve and update only  **/
       /* *          current order types (o.t.)**/
       /* *                                    **/
       /* *                                    **/
       /* *                                    **/
       /* ***************************************/


  if (KO0BM001.XOTCD > " ")
    KO0BSAD(); /* verify order type relational edits*/
    KO0BSAK(); /* validat order type code*/
    if (converseVar.validationMsgNum > 0)
      exit stack;
    else
      KO0BW02.KO0BWFFL = "O"; /* retrieve and update only one o.t.*/
    end
  else
    /* next sentence*/
  end

  if (KO0BM001.KO0BMPED > " "
   || KO0BM001.KOBCOPCT > 0)
   /* ***  OR KO0BM001.XRCCD GT ' '; /* 02-24-94*/
    KO0BSAE(); /* verify mass add relational edits*/
    if (KO0BM001.KOBCOPCT > 0)
      KO0BSAI(); /* verify commission percent is reasonable*/
    end
    if (KO0BM001.KO0BMPED > " ")
      KO0BSAJ(); /* validat new comm. eff. date*/
    end
   /* ***  IF KO0BM001.XRCCD GT ' ';/* 02-24-94 DB2 CHANGES.*/
   /* ***    KO0BSAH;                      /* verify reason code*/
   /* ***  END;*/
    if (converseVar.validationMsgNum > 0)
      exit stack;
    else
      KO0BW02.KO0BWFFL = "A";
                                   /* this will be a mass add of new rates.*/
    end
  else
    /* next sentence*/
  end

  if (KO0BM001.KO0BMPXD > " ")
    KO0BSAF(); /* verify termination date relational edits.*/
    KO0BSAG(); /* validat termination date*/
    if (converseVar.validationMsgNum > 0)
      exit stack;
    else
      KO0BW02.KO0BWFFL = "T"; /* set termination date.*/
    end
  else
    /* next sentence*/
  end



end // end KO0BSAB

// set screen fields to normal
Function KO0BSAC()


  set KO0BM001.SM1AGYID cursor, normal;
  set KO0BM001.SM4REPID normal;
  set KO0BM001.XOTCD normal;
  set KO0BM001.KO0BMPED normal;
  set KO0BM001.KOBCOPCT normal;
   /* ***SET KO0BM001.XRCCD NORMAL; /* 02-24-94*/
  set KO0BM001.KO0BMPXD normal;

  KO0BM001.XOTABRV = " ";
  KO0BW02.KO0BWEFL = "N"; /* set error flag to no*/

  set KO0BM002 initial;
  set KO0BWMAP empty;


end // end KO0BSAC

// o.t relational edit check
Function KO0BSAD()
   /* **********************************************/
   /* if ko0bm001.xotcd (order type field) ne blank*/
   /* then no other fields on ko0bm001 can have a value*/
   /* in them. if the other fields have any values it is*/
   /* in error.*/
   /* **********************************************/


  if (KO0BM001.KO0BMPXD > " ")
    set KO0BM001.KO0BMPXD cursor, bold;
    converseLib.validationFailed(64); /* this field must be blank when using*/
                                   /* o.t. history*/
  else
    /* next sentence*/
  end

   /* ***IF KO0BM001.XRCCD GT ' ';*/
   /* ***  SET KO0BM001.XRCCD CURSOR,BRIGHT;*/
   /* ***MOVE 64 EZEMNO;  /* this field must be blank when using*/
                      /* o.t. history*/
   /* ***ELSE;*/
    /* next sentence*/
   /* ***END;*/

  if (KO0BM001.KOBCOPCT > 0)
    set KO0BM001.KOBCOPCT cursor, bold;
    converseLib.validationFailed(64); /* this field must be blank when using*/
                                   /* o.t. history*/
  else
    /* next sentence*/
  end

  if (KO0BM001.KO0BMPED > " ")
    set KO0BM001.KO0BMPED cursor, bold;
    converseLib.validationFailed(64); /* this field must be blank when using*/
                                   /* o.t. history*/
  else
    /* next sentence*/
  end


end // end KO0BSAD

// new add relational edit check
Function KO0BSAE()
   /* ****************************************************/
         /* the o.t. field and termination fields must*/
         /* be blank for the add to work.*/
         /* if the fields are not blank flag them as errors*/
   /* ****************************************************/

  if (KO0BM001.KO0BMPXD > " ")
    set KO0BM001.KO0BMPXD cursor, bold;
    converseLib.validationFailed(66); /* this field must be blank when useing*/
                                   /* newo.t. add*/
  else
    /* next sentence*/
  end

  if (KO0BM001.XOTCD > " ")
    set KO0BM001.XOTCD cursor, bold;
    converseLib.validationFailed(66); /* this field must be blank when useing*/
                                   /* newo.t. add*/
  else
    /* next sentence*/
  end

   /* ***IF KO0BM001.XRCCD EQ ' ';   /* 02-24-94 DB CHANGES*/
   /* *** SET KO0BM001.XRCCD CURSOR,BRIGHT;*/
   /* *** MOVE 38 TO EZEMNO;              /* this is a required field.*/
   /* ***ELSE;*/
    /* ;/* next sentence*/
   /* ***END;*/
  if (KO0BM001.KO0BMPED == " ")
    set KO0BM001.KO0BMPED cursor, bold;
    converseLib.validationFailed(38); /* this is a required field.*/
  else
    /* next sentence*/
  end

end // end KO0BSAE

// term. relational edit check
Function KO0BSAF()
   /* ******************************************/
       /* the add fields and o.t. fields must*/
       /* be blank for the termination date*/
       /* to be valid.*/
   /* ******************************************/

   /* IF KO0BM001.XRCCD GT ' ';  /* 02-24-94 DB2 CHANGES Z*/
   /* SET KO0BM001.XRCCD CURSOR,BRIGHT;*/
   /* MOVE 67 EZEMNO; /* this field must be blank when using term date*/
   /* ELSE;*/
   /* ;/* next sentence*/
   /* END;*/

  if (KO0BM001.KOBCOPCT > 0)
    set KO0BM001.KOBCOPCT cursor, bold;
    converseLib.validationFailed(67);
  else
    /* next sentence*/
  end

  if (KO0BM001.KO0BMPED > " ")
    set KO0BM001.KO0BMPED cursor, bold;
    converseLib.validationFailed(67);
  else
    /* next sentence*/
  end

  if (KO0BM001.XOTCD > " ")
    set KO0BM001.XOTCD cursor, bold;
    converseLib.validationFailed(67); /* this field must be blank when using termination date*/
  else
    /* next sentence*/
  end


end // end KO0BSAF

// validate termination date
Function KO0BSAG()


  set TA2REC empty;
  KO0BW02.KO0BWHDT = " ";
  KO0BW02.KO0BWXDT = 0;
  TA2REC.TA2DTOPT = "GREGGREG";
  KO0BW02.KO0BWHDT = KO0BM001.KO0BMPXD;

  if (KO0BW02.KO0BWHYY != " ")
    TA2REC.TA2GRTYP = "B";
    TA2REC.TA2GRGB = KO0BM001.KO0BMPXD;
  else
    if (KO0BW02.KO0BWSL1 != "-")
      TA2REC.TA2GRTYP = "A";
      TA2REC.TA2GRGA = KO0BM001.KO0BMPXD;
    else
      TA2REC.TA2GRTYP = "B";
      TA2REC.TA2GRGB = KO0BM001.KO0BMPXD;
    end
  end

  call "TA0040" (TA2REC) {isNoRefresh = yes, isExternal = yes};

  if (TA2REC.TA2RTNCD == 0)
    KO0BM001.KO0BMPXD = TA2REC.TA2GRGB;
    KO0BW02.KO0BWXDT = TA2REC.TA2GRGGN; /* date format of ccyymmdd*/
  else
    set KO0BM001.KO0BMPXD cursor, bold;
    converseLib.validationFailed(46); /* date must be valid and in mmddyy or mm-dd-yy format*/
  end


end // end KO0BSAG

// verify reasonable comm. %
Function KO0BSAI()
   /* ************************************************/
   /* the commission rate should not exceed 25 percent.*/
   /* nike does not use rates greater than this.*/

   /* ************************************************/

  if (KO0BM001.KOBCOPCT > 25)
    converseLib.validationFailed(78); /* the commission rate must be less than 25%*/
    set KO0BM001.KOBCOPCT cursor, bold;
  else
    /* next sentence*/
  end



end // end KO0BSAI

// validate new eff. date
Function KO0BSAJ()


  set TA2REC empty;
  KO0BW02.KO0BWHDT = " ";
  TA2REC.TA2DTOPT = "GREGGREG";
  KO0BW02.KO0BWHDT = KO0BM001.KO0BMPED;

  if (KO0BW02.KO0BWHYY != " ")
    TA2REC.TA2GRTYP = "B";
    TA2REC.TA2GRGB = KO0BM001.KO0BMPED;
  else
    if (KO0BW02.KO0BWSL1 != "-")
      TA2REC.TA2GRTYP = "A";
      TA2REC.TA2GRGA = KO0BM001.KO0BMPED;
    else
      TA2REC.TA2GRTYP = "B";
      TA2REC.TA2GRGB = KO0BM001.KO0BMPED;
    end
  end

  call "TA0040" (TA2REC) {isNoRefresh = yes, isExternal = yes};

  if (TA2REC.TA2RTNCD == 0)
    KO0BM001.KO0BMPED = TA2REC.TA2GRGB;
    KO0BW02.KO0BWEDT = TA2REC.TA2GRGGN;
  else
    set KO0BM001.KO0BMPED cursor, bold;
    converseLib.validationFailed(46); /* date must be valid and in mmddyy or mm-dd-yy format*/
  end


end // end KO0BSAJ

// validate order type
Function KO0BSAK()


  if (KO0BM001.XOTCD in XOTTBL.XOTCD)
    KO0BM001.XOTABRV = XOTTBL.XOTABRV[sysVar.arrayIndex];
  else
    converseLib.validationFailed(65); /* invalid order type*/
    set KO0BM001.XOTCD cursor, bold;
  end


end // end KO0BSAK

// validate & retrieve agency nm
Function KO0BSBA()


  SM1REC.SM1AGYID = KO0BM001.SM1AGYID;
  KO0BW02.SM1AGYID = KO0BM001.SM1AGYID;
  KO0BW02.SM4REPID = KO0BM001.SM4REPID;

  call "IO0050" ("S ", SQLCA, SM1REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    KO0BM001.SM1AGYNM = SM1REC.SM1AGYNM;
    KO0BW02.SM1AGYID = SM1REC.SM1AGYID;
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      KO0BM001.SM1AGYNM = " ";
      converseLib.validationFailed(4);
      KO0BW02.KO0BWEFL = "Y";
      set KO0BM001.SM1AGYID cursor, bold;
      exit stack;
    else
      TA1REC.TA1DBASE = "DSLSMN";
      TA1REC.TA1TBLVU = "VSAGCY01";
      TA1REC.TA1TBLKE = SM1REC.SM1AGYID;
      TA1REC.TA1LOCAT[1] = "KO0BSBA";
      TA1REC.TA1LOCAT[2] = "IO0050";
      XSKO001();
    end
  end
end // end KO0BSBA

// retrieve rep/ name
Function KO0BSBB()

       /* ***************************************/
       /* *  retrieve active rep first and     **/
       /* *  then try to retrieve inactive rep **/
       /* *  if both fail the rep number is    **/
       /* *  not valid.                        **/
       /* *                                    **/
       /* ***************************************/

  set VRAGCY02 empty;
  set SQLCA empty;
  set ERRSQLCA empty;


  VRAGCY02.SM1AGYID = KO0BM001.SM1AGYID;
  KO0BW02.SM1AGYID = KO0BM001.SM1AGYID;
  VRAGCY02.SM4REPID = KO0BM001.SM4REPID;
  KO0BW02.SM4REPID = KO0BM001.SM4REPID;
  VRAGCY02.XXXSTAT = "A";

  call "IO0400" ("S ", SQLCA, VRAGCY02) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    KO0BM001.XXXFSTNM = VRAGCY02.XXXFSTNM;
    KO0BM001.XXXLSTNM = VRAGCY02.XXXLSTNM;
    KO0BM001.XXXMDINT = VRAGCY02.XXXMDINT;
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      KO0BM001.XXXFSTNM = " ";
      KO0BM001.XXXLSTNM = " ";
      KO0BM001.XXXMDINT = " ";
      /* next sentence*/
    else
      TA1REC.TA1DBASE = "DSLSMN";
      TA1REC.TA1TBLVU = "VRAGCY02";
      TA1REC.TA1TBLKE = KO0BW02.KO0BWKEY;
      TA1REC.TA1LOCAT[1] = "KO0BSBB";
      TA1REC.TA1LOCAT[2] = "IO0400";
      XSKO001(); /* abort*/
    end
  end


  if (SQLCA.VAGen_SQLCODE == 100)
    set VRAGCY02 empty;
    set SQLCA empty;
    set ERRSQLCA empty;

    VRAGCY02.SM1AGYID = KO0BM001.SM1AGYID;
    VRAGCY02.SM4REPID = KO0BM001.SM4REPID;
    VRAGCY02.XXXSTAT = "I";

    call "IO0400" ("S3", SQLCA, VRAGCY02) {isNoRefresh = yes, isExternal = yes};

    call "IO0400" ("N3", SQLCA, VRAGCY02) {isNoRefresh = yes, isExternal = yes};

    if (SQLCA.VAGen_SQLCODE == 0)
      KO0BM001.XXXFSTNM = VRAGCY02.XXXFSTNM;
      KO0BM001.XXXLSTNM = VRAGCY02.XXXLSTNM;
      KO0BM001.XXXMDINT = VRAGCY02.XXXMDINT;
      call "IO0400" ("C3", SQLCA, VRAGCY02) {isNoRefresh = yes, isExternal = yes};
    else
      if (SQLCA.VAGen_SQLCODE == 100)
        KO0BM001.XXXFSTNM = " ";
        KO0BM001.XXXLSTNM = " ";
        KO0BM001.XXXMDINT = " ";
        call "IO0400" ("C3", SQLCA, VRAGCY02) {isNoRefresh = yes, isExternal = yes};
        converseLib.validationFailed(6);
        KO0BW02.KO0BWEFL = "Y";
        set KO0BM001.SM4REPID cursor, bold;
        exit stack;
      else
        TA1REC.TA1DBASE = "DSLSMN";
        TA1REC.TA1TBLVU = "VRAGCY02";
        TA1REC.TA1TBLKE = KO0BW02.KO0BWKEY;
        TA1REC.TA1LOCAT[1] = "KO0BSBB";
        TA1REC.TA1LOCAT[2] = "IO0400";
        XSKO001(); /* abort*/
      end
    end
  end


end // end KO0BSBB

// retrieve commissionable o.t.
Function KO0BSBC()

       /* ***************************************/
       /* * retrieve from the order type table **/
       /* * only the order types that are      **/
       /* * flagged as commissionable.         **/
       /* *  (cocmfl = y)                      **/
       /* * move the commissionable order types**/
       /* * to working storage.                **/
       /* *                                    **/
       /* ***************************************/

  KO0BW02.KO0BWMDX = 1; /* counter for ko0bwmap map*/
  KO0BW02.KO0BWCDX = 1; /* counter for reading thru w.s. table*/
  KO0BW02.KO0BWTOT = 0; /* total number of entries in ko0bwmap*/

  while (XOTTBL.XOTCD[KO0BWCDX] <= "98")
    if (XOTTBL.XXXSTAT[KO0BWCDX] == "A")
      if (XOTTBL.COCMFL[KO0BWCDX] == "Y")
        KO0BWMAP.XOTCD[KO0BWMDX] = XOTTBL.XOTCD[KO0BWCDX];
        KO0BWMAP.XOTABRV[KO0BWMDX] = XOTTBL.XOTABRV[KO0BWCDX];
        KO0BWMAP.COCMFL[KO0BWMDX] = XOTTBL.COCMFL[KO0BWCDX];
        KO0BW02.KO0BWMDX = KO0BW02.KO0BWMDX + 1;
        KO0BW02.KO0BWTOT = KO0BW02.KO0BWTOT + 1;
      else
        /* next sentence*/
      end
    else
      /* next sentence*/
    end

    KO0BW02.KO0BWCDX = KO0BW02.KO0BWCDX + 1;

  end




end // end KO0BSBC

// retrieve all o.t. comm. sched
Function KO0BSBD()


       /* ***************************************/
       /* * all order types have been selected **/
       /* * when the order type changes the    **/
       /* * next new order type will be the    **/
       /* * most current. only the current     **/
       /* * order types are written into       **/
       /* * ko0bwmap record.                   **/
       /* *                                    **/
       /* ***************************************/


  if (SM1REC.SM1STAT == "I"
   && KO0BW02.KO0BWFFL == "A")
    converseLib.validationFailed(73); /* cannot add o.to. to an inactive*/
                                   /* agency*/
    KO0BW02.KO0BWEFL = "Y";
    set KO0BM001.SM1AGYID cursor, bold;
    return;
  else
    if (VRAGCY02.SM5COMIN == "NP" /* rep is not paid a commission*/
     && KO0BW02.KO0BWFFL == "A") 
      converseLib.validationFailed(73); /* cannot add o.t. to an inactive rep*/
      KO0BW02.KO0BWEFL = "Y";
      set KO0BM001.SM4REPID cursor, bold;
      return;
    else
      /* next sentence*/
    end
  end

  set KOBREC empty;
  set SQLCA empty;
  set ERRSQLCA empty;

  KOBREC.SM1AGYID = KO0BM001.SM1AGYID;
  KOBREC.SM4REPID = KO0BM001.SM4REPID;

  call "IO0690" ("S1", SQLCA, KOBREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    while (SQLCA.VAGen_SQLCODE == 0)
      KO0BSBE(); /* sequential read thru the selected*/
                                   /* set.*/
    end
    KO0BSBI(); /* close selected set*/
  else
    TA1REC.TA1DBASE = "DSLSMN";
    TA1REC.TA1TBLVU = "VOTSCH01";
    TA1REC.TA1TBLKE = KOBREC.KOBKEY;
    TA1REC.TA1LOCAT[1] = "KO0BSBD";
    TA1REC.TA1LOCAT[2] = "IO0690";
    XSKO001(); /* abort*/
  end


end // end KO0BSBD

// read selected set 'n1'
Function KO0BSBE()


  set SQLCA empty;
  set ERRSQLCA empty;
  call "IO0690" ("N1", SQLCA, KOBREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0
   && KOBREC.XPRCD == "**"
   && KOBREC.YSCCD == "**"
   && KOBREC.KUCCOID == -1
   && KOBREC.XDVCD == "99"
   && KOBREC.XGPCD == "99"
   && KOBREC.XOBCD == "99"
   && KOBREC.XSOCD == "99"
   && KOBREC.XOTCD != "**"
   && KOBREC.XOTCD != KO0BW02.XOTCD)
    KO0BSBF(); /* move kobrec to map working storage*/
    KO0BW02.XOTCD = KOBREC.XOTCD; /* save order type*/
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      if (KO0BW02.KO0BWFFL != "A")
        if (KO0BWMAP.KOBPCTED[1] == 0)
          converseLib.validationFailed(71); /* no records exists for this order type*/
          KO0BW02.KO0BWEFL = "Y";
        else
          /* next sentence*/
        end
      else
        /* next sentence*/
      end
    else
      if (SQLCA.VAGen_SQLCODE < 0)
        TA1REC.TA1DBASE = "DSLSMN";
        TA1REC.TA1TBLVU = "VOTSCH01";
        TA1REC.TA1TBLKE = KOBREC.KOBKEY;
        TA1REC.TA1LOCAT[1] = "KO0BSBE";
        TA1REC.TA1LOCAT[2] = "IO0160";
        XSKO001(); /* abort*/
      end
    end
  end


end // end KO0BSBE

// move kobrec to kobwmap
Function KO0BSBF()


       /* ***************************************/
       /* * match up the retrieve o.t. from    **/
       /* * db2 order type schedule with       **/
       /* * the commissionable o.t. if no match**/
       /* * then move the retrieve o.t. to the **/
       /* * bottom of the ko0bwmap record.     **/
       /* * this will mean that at some past   **/
       /* * point in time the order type had   **/
       /* * been commissionable. however the   **/
       /* * retrieved order type is still      **/
       /* * considered current in the db2 o.t. **/
       /* * table.                             **/
       /* *                                    **/
       /* ***************************************/

  if (KOBREC.XOTCD in KO0BWMAP.XOTCD)
    KO0BWMAP.KOBCOPCT[sysVar.arrayIndex] = KOBREC.KOBCOPCT;
    KO0BWMAP.KOBPCTED[sysVar.arrayIndex] = KOBREC.KOBPCTED;
    KO0BWMAP.KOBPCTXD[sysVar.arrayIndex] = KOBREC.KOBPCTXD;
    KO0BWMAP.ZZZSDT[sysVar.arrayIndex] = KOBREC.ZZZSDT;
    KO0BWMAP.ZZZCHGDT[sysVar.arrayIndex] = KOBREC.ZZZCHGDT;
    KO0BWMAP.ZZZCHGCT[sysVar.arrayIndex] = KOBREC.ZZZCHGCT;
    KO0BWMAP.XXXUSRID[sysVar.arrayIndex] = KOBREC.XXXUSRID;
    KO0BWMAP.KO0BMCED[sysVar.arrayIndex] = KOBREC.KOBPCTED;
  else
    KO0BW02.KO0BWTOT = KO0BW02.KO0BWTOT + 1; /* move inactive o.t. to bottom*/
    KO0BWMAP.KOBCOPCT[KO0BWTOT] = KOBREC.KOBCOPCT;
    KO0BWMAP.KOBPCTED[KO0BWTOT] = KOBREC.KOBPCTED;
    KO0BWMAP.KOBPCTXD[KO0BWTOT] = KOBREC.KOBPCTXD;
    KO0BWMAP.ZZZSDT[KO0BWTOT] = KOBREC.ZZZSDT;
    KO0BWMAP.ZZZCHGDT[KO0BWTOT] = KOBREC.ZZZCHGDT;
    KO0BWMAP.ZZZCHGCT[KO0BWTOT] = KOBREC.ZZZCHGCT;
    KO0BWMAP.XXXUSRID[KO0BWTOT] = KOBREC.XXXUSRID;
    KO0BWMAP.XOTCD[KO0BWTOT] = KOBREC.XOTCD;
    KO0BWMAP.KO0BMCED[KO0BWTOT] = KOBREC.KOBPCTED;
    if (KOBREC.XOTCD in XOTTBL.XOTCD)
      KO0BWMAP.XOTABRV[KO0BWTOT] = XOTTBL.XOTABRV[sysVar.arrayIndex];
    else
      KO0BWMAP.XOTABRV[KO0BWTOT] = "INVALI";
    end
  end


end // end KO0BSBF

// move 'add' fields to ko0bwmap
Function KO0BSBG()

   /* ***  move the 'add' fields from ko0bm001*/
   /* ***  to ko0bwmap record.*/


  KO0BW02.KO0BWCDX = 1;

  while (KO0BW02.KO0BWCDX <= KO0BW02.KO0BWTOT)
    if (KO0BM001.KOBCOPCT > 0)
      KO0BWMAP.KO0BMPCT[KO0BWCDX] = KO0BM001.KOBCOPCT;
    else
      /* next sentence*/
    end

    if (KO0BM001.KO0BMPED > " ")
      KO0BWMAP.KO0BMEDT[KO0BWCDX] = KO0BM001.KO0BMPED;
    else
      /* next sentence*/
    end

    /* IF KO0BM001.XRCCD GT ' '; /* 02-24-94*/
    /* MOVE KO0BM001.XRCCD TO KO0BWMAP.KO0BMRCD(KO0BWCDX);*/
    /* ELSE;*/
    /* ;/* next sentence*/
    /* END;*/

    KO0BW02.KO0BWCDX = KO0BW02.KO0BWCDX + 1;

  end



end // end KO0BSBG

// close selected set
Function KO0BSBI()

  call "IO0690" ("C1", SQLCA, KOBREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    /* next sentenece*/
  else
    TA1REC.TA1DBASE = "DSLSMN";
    TA1REC.TA1TBLVU = "VOTSCH01";
    TA1REC.TA1TBLKE = KOBREC.KOBKEY;
    TA1REC.TA1LOCAT[1] = "KO0BSBI";
    TA1REC.TA1LOCAT[2] = "IO0690";
    XSKO001(); /* abort*/
  end


end // end KO0BSBI

// move header info to ko0bm002
Function KO0BSBJ()


  KO0BW02.KO0BWCDX = 1;
  KO0BW02.KO0BWTOP = 1;
  KO0BW02.KO0BWMDX = 1;
  set KO0BM002 empty;
  KO0BM002.SM1AGYID = KO0BM001.SM1AGYID;
  KO0BM002.SM1AGYNM = KO0BM001.SM1AGYNM;
  KO0BM002.SM4REPID = KO0BM001.SM4REPID;
  KO0BM002.XXXLSTNM = KO0BM001.XXXLSTNM;
  KO0BM002.XXXFSTNM = KO0BM001.XXXFSTNM;
  KO0BM002.XXXMDINT = KO0BM001.XXXMDINT;


  KO0BSBO(); /* move ko0bwmap detail to ko0bm002*/



end // end KO0BSBJ

// retrieve one o.t. comm. sched.
Function KO0BSBK()


       /* *****************************************/
       /* * this select will retrieve all of the **/
       /* * same order types from the order type **/
       /* * table. (current+history)             **/
       /* *                                      **/
       /* *                                      **/
       /* *****************************************/


  set KOBREC empty;
  set SQLCA empty;
  set ERRSQLCA empty;

  KOBREC.SM1AGYID = KO0BM001.SM1AGYID;
  KOBREC.SM4REPID = KO0BM001.SM4REPID;

  call "IO0690" ("S1", SQLCA, KOBREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    while (SQLCA.VAGen_SQLCODE == 0)
      KO0BSBL(); /* read thru the selected set.*/
    end
    KO0BSBN(); /* close selected set*/
  else
    TA1REC.TA1DBASE = "DCOMM";
    TA1REC.TA1TBLVU = "VOTSCH01";
    TA1REC.TA1TBLKE = KOBREC.KOBKEY;
    TA1REC.TA1LOCAT[1] = "KO0BSBK";
    TA1REC.TA1LOCAT[2] = "IO0690";
    XSKO001(); /* abort*/
  end


end // end KO0BSBK

// read n2 selected set
Function KO0BSBL()


  set KOBREC empty;
  set SQLCA empty;
  set ERRSQLCA empty;

  call "IO0690" ("N1", SQLCA, KOBREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    if (KOBREC.XPRCD == "**"
     && KOBREC.YSCCD == "**"
     && KOBREC.KUCCOID == -1
     && KOBREC.XDVCD == "99"
     && KOBREC.XGPCD == "99"
     && KOBREC.XOBCD == "99"
     && KOBREC.XSOCD == "99"
     && KOBREC.XOTCD != "**")
      if (KOBREC.XOTCD == KO0BM001.XOTCD)
        KO0BW02.KO0BWCDX = KO0BW02.KO0BWCDX + 1;
        KO0BW02.KO0BWTOT = KO0BW02.KO0BWTOT + 1;
        KO0BSBM();
                                   /* move n2 kobrec to map working storage*/
      end
    end
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      if (KO0BW02.KO0BWFFL != "A")
        if (KO0BWMAP.KOBPCTED[1] == 0)
          set KO0BM001.SM1AGYID cursor, bold;
          converseLib.validationFailed(71);
                                   /* no records exists for this order type*/
          KO0BSBN(); /* close n2 selected set.*/
          exit stack;
        else
          /* next sentence normal end of file processing read.*/
        end
      else
        /* next sentence*/
      end
    else
      TA1REC.TA1DBASE = "DSLSMN";
      TA1REC.TA1TBLVU = "VOTSCH01";
      TA1REC.TA1TBLKE = KOBREC.KOBKEY;
      TA1REC.TA1LOCAT[1] = "KO0BSBL";
      TA1REC.TA1LOCAT[2] = "IO0160";
      XSKO001(); /* abort*/
    end
  end


end // end KO0BSBL

// move n2 kobrec to ko0bwmap
Function KO0BSBM()


  KO0BWMAP.XOTCD[KO0BWCDX] = KOBREC.XOTCD;
  KO0BWMAP.KOBCOPCT[KO0BWCDX] = KOBREC.KOBCOPCT;
  KO0BWMAP.KOBPCTED[KO0BWCDX] = KOBREC.KOBPCTED;
  KO0BWMAP.KOBPCTXD[KO0BWCDX] = KOBREC.KOBPCTXD;
  KO0BWMAP.ZZZSDT[KO0BWCDX] = KOBREC.ZZZSDT;
  KO0BWMAP.ZZZCHGDT[KO0BWCDX] = KOBREC.ZZZCHGDT;
  KO0BWMAP.ZZZCHGCT[KO0BWCDX] = KOBREC.ZZZCHGCT;
  KO0BWMAP.XXXUSRID[KO0BWCDX] = KOBREC.XXXUSRID;
  KO0BWMAP.KO0BMCED[KO0BWCDX] = KOBREC.KOBPCTED;
  KO0BWMAP.XOTABRV[KO0BWCDX] = KO0BM001.XOTABRV;


end // end KO0BSBM

// close c2 selected set
Function KO0BSBN()

  call "IO0690" ("C1", SQLCA, KOBREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    /* next sentenece*/
  else
    TA1REC.TA1DBASE = "DSLSMN";
    TA1REC.TA1TBLVU = "VOTSCH01";
    TA1REC.TA1TBLKE = KOBREC.KOBKEY;
    TA1REC.TA1LOCAT[1] = "KO0BSBN";
    TA1REC.TA1LOCAT[2] = "IO0690";
    XSKO001(); /* abort*/
  end


end // end KO0BSBN

// move det. ko0bwmap to ko0bm002
Function KO0BSBO()


  while (KO0BW02.KO0BWMDX <= 11)
    if (KO0BWMAP.XOTCD[KO0BWCDX] > " ")
      KO0BM002.KO0BMPCT[KO0BWMDX] = KO0BWMAP.KO0BMPCT[KO0BWCDX];
      KO0BM002.KO0BMEDT[KO0BWMDX] = KO0BWMAP.KO0BMEDT[KO0BWCDX];
  /* MOVE KO0BWMAP.KO0BMRCD(KO0BWCDX) TO KO0BM002.KO0BMRCD(KO0BWMDX);*/
      KO0BM002.XOTCD[KO0BWMDX] = KO0BWMAP.XOTCD[KO0BWCDX];
      KO0BM002.XOTABRV[KO0BWMDX] = KO0BWMAP.XOTABRV[KO0BWCDX];
      KO0BM002.KOBCOPCT[KO0BWMDX] = KO0BWMAP.KOBCOPCT[KO0BWCDX];
      KO0BM002.KOBPCTED[KO0BWMDX] = KO0BWMAP.KOBPCTED[KO0BWCDX];
      KO0BM002.KOBPCTXD[KO0BWMDX] = KO0BWMAP.KOBPCTXD[KO0BWCDX];
      KO0BM002.ZZZSDT[KO0BWMDX] = KO0BWMAP.ZZZSDT[KO0BWCDX];
      KO0BM002.ZZZCHGDT[KO0BWMDX] = KO0BWMAP.ZZZCHGDT[KO0BWCDX];
    else
      set KO0BM002.KO0BMPCT[KO0BWMDX] skip, invisible;
      set KO0BM002.KO0BMEDT[KO0BWMDX] skip, invisible;
  /* SET KO0BM002.KO0BMRCD(KO0BWMDX) AUTOSKIP,DARK;*/
      set KO0BM002.KOBCOPCT[KO0BWMDX] skip, invisible;
    end

    KO0BW02.KO0BWMDX = KO0BW02.KO0BWMDX + 1;
    KO0BW02.KO0BWCDX = KO0BW02.KO0BWCDX + 1;
    KO0BW02.KO0BWTOP = KO0BW02.KO0BWTOP + 1;

  end


end // end KO0BSBO

// validate term. vs eff. dates
Function KO0BSBP()
   /* ******************************************/
   /* the termination date must be gt any eff. date*/
   /* before the term. can be add.*/
   /* ******************************************/


  KO0BW02.KO0BWCDX = 1;

  while (KO0BW02.KO0BWCDX <= KO0BW02.KO0BWTOT)

    if (KO0BW02.KO0BWXDT > KO0BWMAP.KOBPCTED[KO0BWCDX])
      /* next sentence*/
    else
      converseLib.validationFailed(74); /* termination process aborted.*/
       /* termination date must be > curr. eff. date*/
      KO0BW02.KO0BWEFL = "Y";
      set KO0BM001.KO0BMPXD cursor, bold;
      exit stack;
    end

    /* *** if an order type does not exists then reason code*/
    /* *** must be 'nr' if adding a new order type row.*/
    /* *** COMMENTED OUT 02-24-94 FOR DB2 CHANGES. DELETE XRCCD .*/

    /* IF KO0BWMAP.KOBPCTED(KO0BWCDX) EQ 0;*/
    /* IF KO0BM001.XRCCD EQ 'CH';*/
    /* ;/* next sentence*/
    /* ELSE;*/
    /* SET KO0BM001.XRCCD CURSOR,BRIGHT;*/
    /* MOVE 72 TO EZEMNO;*/
    /* ;/* if no records exits,then ko0bmrcd must be nr for add*/
    /* MOVE 'Y' TO KO0BW02.KO0BWEFL;*/
    /* END;*/
    /* ELSE;*/
    /* ;/* next sentence*/
    /* END;*/


    KO0BW02.KO0BWCDX = KO0BW02.KO0BWCDX + 1;

  end
end // end KO0BSBP

// validate eff. dt > term dt.
Function KO0BSBQ()
   /* *********************************************/
   /* validate that the eff. date is gt the term. date*/
   /* if there is a term. date.*/
   /* *********************************************/


  KO0BW02.KO0BWCDX = 1;

  while (KO0BW02.KO0BWCDX <= KO0BW02.KO0BWTOT)

    if (KO0BWMAP.KOBPCTXD[KO0BWCDX] > 0) /* ending dt. gt 0*/
      if (KO0BW02.KO0BWEDT > KO0BWMAP.KOBPCTXD[KO0BWCDX])
        /* next sentence*/
      else
        converseLib.validationFailed(82); /* process aborted.*/
         /* curr. eff. date must be > term. date*/
        KO0BW02.KO0BWEFL = "Y";
        set KO0BM001.KO0BMPED cursor, bold;
        exit stack;
      end
    else
      /* next sentence*/
    end

    /* *** if first time add the reason code must be 'nr'*/

     /* IF KO0BWMAP.KOBPCTED(KO0BWCDX) EQ 0;*/
     /* IF KO0BM001.XRCCD EQ 'NR';*/
        /* ;/* next sentence*/
     /* ELSE;*/
     /* SET KO0BM001.XRCCD CURSOR,BRIGHT;*/
     /* MOVE 72 TO EZEMNO;*/
     /* ;/* if no records exits,then ko0bmrcd must be NR for add*/
     /* MOVE 'Y' TO KO0BW02.KO0BWEFL;*/
     /* END;*/
     /* ELSE;*/
     /* IF KO0BM001.XRCCD EQ 'NR';*/
     /* SET KO0BM001.XRCCD CURSOR,BRIGHT;*/
     /* MOVE 79 TO EZEMNO;*/
     /* ;/* if no records exits,then ko0bmrcd must be NR for add*/
     /* MOVE 'Y' TO KO0BW02.KO0BWEFL;*/
     /* ELSE;*/
     /* ;/* next sentence*/
     /* END;*/
     /* END;*/

    KO0BW02.KO0BWCDX = KO0BW02.KO0BWCDX + 1;

  end



end // end KO0BSBQ

// validate pf keys
Function KO0BSCA()


  if (converseVar.eventKey is pf1)
    XSPF1();
    KO0BM002.XXXMSG = COMMAREA.CAMSG;
    KO0BW02.KO0BWEFL = "Y";
    return;
  else
    if (converseVar.eventKey is pf4)
      XSPF4();
      KO0BM002.XXXMSG = COMMAREA.CAMSG;
      KO0BW02.KO0BWEFL = "Y";
      return;
    else
      if (converseVar.eventKey is pf3
       || converseVar.eventKey is pa2)
        COMMAREA.CATOAP = "KO0A";
        XSEXIT();
        KO0BM002.XXXMSG = COMMAREA.CAMSG;
        KO0BW02.KO0BWEFL = "Y";
        return;
      else
        if (KO0BM002.CATOAP != " ")
          if (converseVar.eventKey is enter)
            COMMAREA.CATOAP = KO0BM002.CATOAP;
            COMMAREA.CAITEM = KO0BM002.CAITEM;
            XSEXIT();
            KO0BM002.XXXMSG = COMMAREA.CAMSG;
            KO0BW02.KO0BWEFL = "Y";
            exit stack;
          else
            set KO0BM002.CATOAP cursor, bold;
            converseLib.validationFailed(1);
            KO0BW02.KO0BWEFL = "Y";
            exit stack;
          end
        else
          if (converseVar.eventKey is pf12
           || converseVar.eventKey is enter
           || converseVar.eventKey is pf7
           || converseVar.eventKey is pf8
           || converseVar.eventKey is pf16)
            return;
          else
            converseLib.validationFailed(2); /* invalid pfkey*/
            KO0BW02.KO0BWEFL = "Y";
            exit stack;
          end
        end
      end
    end
  end
end // end KO0BSCA

// handle scrolling backwards
Function KO0BSCB()


  if (KO0BW02.KO0BWCDX <= 12)
    converseLib.validationFailed(70); /* can not scroll backward any further*/
    exit stack;
  else
    /* next sentence*/
  end


  KO0BSCD(); /* move screen results to working*/
                                   /* storage*/
  KO0BSCE();
                                   /* clear screen fields for next display.*/



       /* ***************************************/
       /* *  pf7 scroll backwards starting from**/
       /* *  the top of screen.                **/
       /* *                                    **/
       /* ***************************************/

   /* *****  this will set-up the working storage pointer*/
   /* *****  to the appropriate starting point to read forward*/
   /* *****  from.*/


  if (KO0BW02.KO0BWTOP < 11)
    KO0BW02.KO0BWCDX = KO0BW02.KO0BWCDX - KO0BW02.KO0BWTOP;
    KO0BW02.KO0BWCDX = KO0BW02.KO0BWCDX - 10;
  else
    KO0BW02.KO0BWCDX = KO0BW02.KO0BWCDX - 22;
  end

  if (KO0BW02.KO0BWCDX <= 11)
    KO0BW02.KO0BWCDX = 1;
  else
    /* next sentence*/
  end

  KO0BW02.KO0BWMDX = 1;
  KO0BW02.KO0BWTOP = 1;

  KO0BSBO(); /* move ko0bwmap detail to ko0bm002*/



end // end KO0BSCB

// handle scrolling forward
Function KO0BSCC()


  if (KO0BW02.KO0BWCDX > KO0BW02.KO0BWTOT)
    converseLib.validationFailed(68); /* you are at the end cannot scroll forward*/
    return;
  else
    /* next sentence*/
  end


  KO0BSCD(); /* move screen results to working*/
                                   /* storage*/
  KO0BSCE();
                                   /* clear screen fields for next display.*/



       /* ***************************************/
       /* *  pf8 scroll forward starting from  **/
       /* *  the end of the previous screen.   **/
       /* *                                    **/
       /* *                                    **/
       /* ***************************************/

   /* *****  this will set-up the working storage pointer*/
   /* *****  to the appropriate starting point to read forward*/
   /* *****  from.*/


  KO0BW02.KO0BWMDX = 1;
  KO0BW02.KO0BWTOP = 1;


  KO0BSBO(); /* move ko0bwmap detail to ko0bm002*/


end // end KO0BSCC

// move ko0bm002 to ko0bwmap
Function KO0BSCD()

   /* *** this will set-up the working storage pointer to*/
   /* *** the beginning of the map(ko0bm002).*/

  KO0BW02.KO0BWCDX = KO0BW02.KO0BWCDX - KO0BW02.KO0BWTOP;
  KO0BW02.KO0BWCDX = KO0BW02.KO0BWCDX + 1;

  if (KO0BW02.KO0BWCDX <= 11)
    KO0BW02.KO0BWCDX = 1;
  else
    /* next sentence*/
  end


  KO0BW02.KO0BWMDX = 1;
  KO0BW02.KO0BWTOP = 1;

   /* *** the while loop will read forward and move the*/
   /* *** fields from the map to corresponding area in working*/
   /* *** storage.*/

   /* *** a zero percent is valid only if the user enters a zero*/
   /* *** if a zero is entered the field is modified and a flag*/
   /* *** for that line is set to 'y'. the screen will*/
   /* *** appear blank due to screen editing for csp.*/



  while (KO0BW02.KO0BWMDX <= 11
   && KO0BM002.XOTCD[KO0BWMDX] != " ")

    if (KO0BM002.KO0BMPCT[KO0BWMDX] is modified)
      KO0BWMAP.KO0BMMOD[KO0BWCDX] = "Y";
    else
      /* next sentence*/
    end

    KO0BWMAP.KO0BMPCT[KO0BWCDX] = KO0BM002.KO0BMPCT[KO0BWMDX];
    KO0BWMAP.KO0BMEDT[KO0BWCDX] = KO0BM002.KO0BMEDT[KO0BWMDX];
   /* MOVE KO0BM002.KO0BMRCD(KO0BWMDX) TO KO0BWMAP.KO0BMRCD(KO0BWCDX);*/

    KO0BW02.KO0BWMDX = KO0BW02.KO0BWMDX + 1;
    KO0BW02.KO0BWCDX = KO0BW02.KO0BWCDX + 1;
    KO0BW02.KO0BWTOP = KO0BW02.KO0BWTOP + 1;

  end


end // end KO0BSCD

// clear ko0bm002 map fields
Function KO0BSCE()

  KO0BW02.KO0BWMDX = 1;


  while (KO0BW02.KO0BWMDX <= 11)
    KO0BM002.KO0BMPCT[KO0BWMDX] = 0;
    KO0BM002.KO0BMEDT[KO0BWMDX] = " ";
   /* MOVE ' ' TO KO0BM002.KO0BMRCD(KO0BWMDX);*/
    KO0BM002.XOTCD[KO0BWMDX] = " ";
    KO0BM002.XOTABRV[KO0BWMDX] = " ";
    KO0BM002.KOBCOPCT[KO0BWMDX] = 0;
    KO0BM002.KOBPCTED[KO0BWMDX] = 0;
    KO0BM002.KOBPCTXD[KO0BWMDX] = 0;
    KO0BM002.ZZZSDT[KO0BWMDX] = 0;
    KO0BM002.ZZZCHGDT[KO0BWMDX] = 0;

    set KO0BM002.KO0BMPCT[KO0BWMDX] normal;
    set KO0BM002.KO0BMEDT[KO0BWMDX] normal;
   /* SET KO0BM002.KO0BMRCD(KO0BWMDX) NORMAL;*/
    set KO0BM002.KOBCOPCT[KO0BWMDX] protect;

    KO0BW02.KO0BWMDX = KO0BW02.KO0BWMDX + 1;

  end




end // end KO0BSCE

// validate all fields
Function KO0BSCF()



  KO0BSCD(); /* move screen results to working*/
                                   /* storage*/
  KO0BSCE();
                                   /* clear screen fields for next display.*/



   /* **  set-up all pointer to begin with and validate*/
   /* **  all fields a screen at a time. if there are any errors*/
   /* **  redisplay the screen so the user can correct and begin*/
   /* *****  validation from the beginning.*/

  KO0BW02.KO0BWMDX = 1;
  KO0BW02.KO0BWTOP = 1;
  KO0BW02.KO0BWCDX = 1;
  KO0BW02.KO0BWEFL = "N";


  while (KO0BW02.KO0BWCDX <= KO0BW02.KO0BWTOT
   && KO0BW02.KO0BWEFL == "N")
    KO0BSCG(); /* validate fields a screen at a time.*/
  end


  if (converseVar.eventKey is pf12
   && KO0BW02.KO0BWEFL == "N")
    KO0BW02.KO0BWMDX = 1;
    KO0BW02.KO0BWTOP = 1;
    KO0BW02.KO0BWCDX = 1;
    KO0BSBO();
  else
    /* next sentence*/
  end


end // end KO0BSCF

// validate fields for one screen
Function KO0BSCG()
       /* ***************************************/
       /* * this will validate all fields on a **/
       /* * screen, one screen at a time. if   **/
       /* * there are any errors then the      **/
       /* * screen will be redisplayed with    **/
       /* * the fields in error set to bright. **/
       /* *                                    **/
       /* * ko0bwmdx = an index for ko0bm002   **/
       /* * ko0bwcdx = an index for ko0bwmap   **/
       /* * ko0bwtop = # of screen lines       **/
       /* *            written.                **/
       /* *                                    **/
       /* ***************************************/

   /* *****  this will set-up the working storage pointer*/
   /* *****  to the appropriate starting point to read forward*/
   /* *****  from.*/

  KO0BSCE(); /* clear screen fields for next display*/

  KO0BW02.KO0BWMDX = 1;
  KO0BW02.KO0BWTOP = 1;


  while (KO0BW02.KO0BWMDX <= 11
   && KO0BW02.KO0BWCDX <= KO0BW02.KO0BWTOT)

    if (KO0BWMAP.KO0BMPCT[KO0BWCDX] > 0)
      KO0BM002.KO0BMPCT[KO0BWMDX] = KO0BWMAP.KO0BMPCT[KO0BWCDX];
      KO0BSCH(); /* validate percent*/
    else
    /* IF KO0BWMAP.KO0BMRCD(KO0BWCDX) EQ 'CH'*/
    /* OR KO0BWMAP.KO0BMRCD(KO0BWCDX) EQ 'NR';*/
      if (KO0BWMAP.KO0BMMOD[KO0BWCDX] == "Y"
       && KO0BWMAP.KO0BMPCT[KO0BWCDX] >= 0)
        KO0BSCH();
      else
        converseLib.validationFailed(103); /* you must enter a value of at least zero*/
        set KO0BM002.KO0BMPCT[KO0BWMDX] cursor, bold;
        KO0BW02.KO0BWEFL = "Y";
      end
    /* ELSE;*/
    /* ;/* next sentence*/
    /* END;*/
    end


    if (KO0BWMAP.KO0BMEDT[KO0BWCDX] > " ")
      KO0BM002.KO0BMEDT[KO0BWMDX] = KO0BWMAP.KO0BMEDT[KO0BWCDX];
      KO0BSCI(); /* validate eff. date*/
    else
      /* next sentence*/
    end


   /* iF KO0BWMAP.KO0BMRCD(KO0BWCDX) EQ 'CH'*/
   /* OR KO0BWMAP.KO0BMRCD(KO0BWCDX) EQ 'NR';*/
   /* IF KO0BWMAP.KO0BMPCT(KO0BWCDX) GE 0*/
   /* AND KO0BWMAP.KO0BMEDT(KO0BWCDX) GT ' ';*/
   /* ;/* next sentence*/
   /* ELSE;*/
   /* SET KO0BM002.KO0BMRCD(KO0BWMDX) CURSOR,BRIGHT;*/
   /* MOVE 79 TO EZEMNO;*/
   /* MOVE 'Y' TO KO0BW02.KO0BWEFL;*/
   /* END;*/
   /* ELSE;*/
    if (KO0BWMAP.KO0BMPCT[KO0BWCDX] > 0
     && KO0BWMAP.KO0BMEDT[KO0BWCDX] > " ")
      set KO0BM002.KO0BMPCT[KO0BWMDX] cursor, bold;
      converseLib.validationFailed(81); /* can not change both % and eff. date*/
      KO0BW02.KO0BWEFL = "Y";
    else
        /* next sentence*/
    end
   /* END;*/


   /* IF KO0BWMAP.KO0BMPCT(KO0BWCDX) GT 0*/
   /* OR KO0BWMAP.KO0BMEDT(KO0BWCDX) GT ' ';*/
   /* IF KO0BWMAP.KO0BMRCD(KO0BWCDX) GT ' ';*/
   /* MOVE KO0BWMAP.KO0BMRCD(KO0BWCDX) TO KO0BM002.KO0BMRCD(KO0BWMDX);*/
   /* KO0BSCJ;                    /* validate reason code*/
   /* ELSE;*/
   /* SET KO0BM002.KO0BMRCD(KO0BWMDX) CURSOR,BRIGHT;*/
   /* MOVE 'Y' TO KO0BW02.KO0BWEFL;*/
   /* MOVE 38 TO EZEMNO;          /* this is a required field*/
   /* END;*/
   /* ;/* next sentence*/
   /* END;*/

    if (KO0BW02.KO0BWEFL == "Y")
      /* next sentence*/
    else
   /* IF KO0BWMAP.KO0BMRCD(KO0BWCDX) EQ 'EA'*/
   /* OR KO0BWMAP.KO0BMRCD(KO0BWCDX) EQ 'EB'*/
  /* OR KO0BWMAP.KO0BMRCD(KO0BWCDX) EQ 'CH';*/
      KO0BSCL(); /* if eff. date changed, make sure it is unique*/
  /* ELSE;*/
  /* ;/* next sentence*/
  /* END;*/
    end


    if (KO0BWMAP.XOTCD[KO0BWCDX] > " ")
      /* next sentence*/
    else
      set KO0BM002.KO0BMPCT[KO0BWMDX] skip, invisible;
      set KO0BM002.KO0BMEDT[KO0BWMDX] skip, invisible;
   /* SET KO0BM002.KO0BMRCD(KO0BWMDX) AUTOSKIP,DARK;*/
    end

    KO0BM002.XOTCD[KO0BWMDX] = KO0BWMAP.XOTCD[KO0BWCDX];
    KO0BM002.XOTABRV[KO0BWMDX] = KO0BWMAP.XOTABRV[KO0BWCDX];
    KO0BM002.KOBCOPCT[KO0BWMDX] = KO0BWMAP.KOBCOPCT[KO0BWCDX];
    KO0BM002.KOBPCTED[KO0BWMDX] = KO0BWMAP.KOBPCTED[KO0BWCDX];
    KO0BM002.KOBPCTXD[KO0BWMDX] = KO0BWMAP.KOBPCTXD[KO0BWCDX];
    KO0BM002.ZZZSDT[KO0BWMDX] = KO0BWMAP.ZZZSDT[KO0BWCDX];
    KO0BM002.ZZZCHGDT[KO0BWMDX] = KO0BWMAP.ZZZCHGDT[KO0BWCDX];
    KO0BW02.KO0BWTOP = KO0BW02.KO0BWTOP + 1;
    KO0BW02.KO0BWMDX = KO0BW02.KO0BWMDX + 1;
    KO0BW02.KO0BWCDX = KO0BW02.KO0BWCDX + 1;
  end


end // end KO0BSCG

// validate percent field
Function KO0BSCH()


  if (KO0BWMAP.KO0BMPCT[KO0BWCDX] > 25)
    converseLib.validationFailed(78); /* the commission rate must be less than 25%*/
    set KO0BM002.KO0BMPCT[KO0BWMDX] cursor, bold;
    KO0BW02.KO0BWEFL = "Y";
  else
    /* next sentence*/
  end



end // end KO0BSCH

// validate new eff. date
Function KO0BSCI()



  set TA2REC empty;
  KO0BW02.KO0BWHDT = " ";
  TA2REC.TA2DTOPT = "GREGGREG";
  KO0BW02.KO0BWHDT = KO0BWMAP.KO0BMEDT[KO0BWCDX];

  if (KO0BW02.KO0BWHYY != " ")
    TA2REC.TA2GRTYP = "B";
    TA2REC.TA2GRGB = KO0BWMAP.KO0BMEDT[KO0BWCDX];
  else
    if (KO0BW02.KO0BWSL1 != "-")
      TA2REC.TA2GRTYP = "A";
      TA2REC.TA2GRGA = KO0BWMAP.KO0BMEDT[KO0BWCDX];
    else
      TA2REC.TA2GRTYP = "B";
      TA2REC.TA2GRGB = KO0BWMAP.KO0BMEDT[KO0BWCDX];
    end
  end

  call "TA0040" (TA2REC) {isNoRefresh = yes, isExternal = yes};



  if (TA2REC.TA2RTNCD == 0)
    KO0BWMAP.KO0BMEDT[KO0BWCDX] = TA2REC.TA2GRGB;
    KO0BWMAP.KO0BMCND[KO0BWCDX] = TA2REC.TA2GRGGN; /* format ccyymmdd*/
  else
    set KO0BM002.KO0BMEDT[KO0BWMDX] cursor, bold;
    converseLib.validationFailed(46); /* date must be valid and in mmddyy or mm-dd-yy format*/
    KO0BW02.KO0BWEFL = "Y";
    return;
  end

   /* *********************************************************/
   /* ko0bmcnd - is the new eff. date in the format of ccyymmdd*/
   /* ko0bmced - is the current eff. date in the format ccyymmdd*/
   /* when a new row is added the new eff. date must be >*/
   /* the current eff. date.*/
   /* ************************************************************/

   /* IF KO0BWMAP.KO0BMRCD(KO0BWCDX) EQ 'CH'*/
  if (KO0BWMAP.KO0BMEDT[KO0BWCDX] > " "
   && KO0BWMAP.KO0BMPCT[KO0BWCDX] >= 0)
    if (KO0BWMAP.KO0BMCND[KO0BWCDX] > KO0BWMAP.KO0BMCED[KO0BWCDX])
      /* next sentence*/
    else
      set KO0BM002.KO0BMEDT[KO0BWMDX] cursor, bold;
      converseLib.validationFailed(69); /* the new eff. date must be > the*/
                                   /* current eff. date*/
      KO0BW02.KO0BWEFL = "Y";
    end
  end

  if (KO0BWMAP.KOBPCTXD[KO0BWCDX] > 0)
   /* IF KO0BWMAP.KO0BMRCD(KO0BWCDX) EQ 'CH'*/
    if (KO0BWMAP.KO0BMEDT[KO0BWCDX] > " "
     && KO0BWMAP.KO0BMPCT[KO0BWCDX] >= 0)
      if (KO0BWMAP.KO0BMCND[KO0BWCDX] > KO0BWMAP.KOBPCTXD[KO0BWCDX])
        /* next sentence*/
      else
        set KO0BM002.KO0BMEDT[KO0BWMDX] cursor, bold;
        converseLib.validationFailed(82); /* the new eff. date must be > the term. date.*/
        KO0BW02.KO0BWEFL = "Y";
      end
    end
  end


   /* IF KO0BWMAP.KO0BMRCD(KO0BWCDX) EQ 'EA'*/
   /* OR KO0BWMAP.KO0BMRCD(KO0BWCDX) EQ 'EB';*/
  if (KO0BWMAP.KOBPCTXD[KO0BWCDX] > 0)
    if (KO0BWMAP.KO0BMCND[KO0BWCDX] < KO0BWMAP.KOBPCTXD[KO0BWCDX])
        /* next sentence*/
    else
      set KO0BM002.KO0BMEDT[KO0BWMDX] cursor, bold;
      converseLib.validationFailed(101); /* the new eff. date can not be > the*/
                                   /* term. date.*/
      KO0BW02.KO0BWEFL = "Y";
    end
  else
    KO0BW02.KO0BWNXT = KO0BW02.KO0BWCDX + 1;
    if (KO0BW02.KO0BWNXT >= KO0BW02.KO0BWTOT) /* at end of work. storage*/
        /* next sentence*/
    else
      if (KO0BWMAP.KOBPCTXD[KO0BWNXT] > 0)
        if (KO0BWMAP.KO0BMCND[KO0BWCDX] > KO0BWMAP.KOBPCTXD[KO0BWNXT])
            /* next sentence*/
        else
          set KO0BM002.KO0BMEDT[KO0BWMDX] cursor, bold;
          converseLib.validationFailed(106); /* the new eff. date can not be > the term. date.*/
          KO0BW02.KO0BWEFL = "Y";
        end
      else
        if (KO0BWMAP.KO0BMCND[KO0BWCDX] > KO0BWMAP.KOBPCTED[KO0BWNXT])
            /* next sentence*/
        else
          set KO0BM002.KO0BMEDT[KO0BWMDX] cursor, bold;
          converseLib.validationFailed(107); /* the new eff. date can not be > the term. date.*/
          KO0BW02.KO0BWEFL = "Y";
        end
      end
    end
  end
   /* ELSE;*/
   /* ;/* next sentence*/
   /* END;*/

end // end KO0BSCI

// set records & map empty
Function KO0BSCK()
   /* *****************************************/
   /* the ko0bm002 sm1agyid is different*/
   /* than the sm1agyid in kobrec. therefore*/
   /* all records and maps are set to empty*/
   /* and a new agency/rep will be retrieve.*/
   /* ******************************************/

  set KO0BM001 initial;
  KO0BM001.SM1AGYID = KO0BM002.SM1AGYID;
  KO0BM001.SM4REPID = KO0BM002.SM4REPID;
  set KO0BM002 initial;
  KO0BM002.SM1AGYID = KO0BM001.SM1AGYID;
  KO0BM002.SM4REPID = KO0BM001.SM4REPID;
  set KO0BW02 empty;
  set KO0BWMAP empty;


end // end KO0BSCK

// verify eff. date is unique
Function KO0BSCL()
   /* *****************************************/
    /* if user entered a new eff. date*/
    /* make sure that it is unique on*/
    /* kobrec table .*/
   /* *****************************************/


  if (KO0BWMAP.KO0BMCND[KO0BWCDX] > 0)

    set KOBREC empty;
    set SQLCA empty;
    set ERRSQLCA empty;

    KOBREC.SM1AGYID = KO0BM001.SM1AGYID;
    KOBREC.SM4REPID = KO0BM001.SM4REPID;
    KOBREC.XOTCD = KO0BWMAP.XOTCD[KO0BWCDX];
    KOBREC.KOBPCTED = KO0BWMAP.KO0BMCND[KO0BWCDX];

    call "IO0690" ("S ", SQLCA, KOBREC) {isNoRefresh = yes, isExternal = yes};

    if (SQLCA.VAGen_SQLCODE == 0)
      KO0BW02.KO0BWEFL = "Y";
      converseLib.validationFailed(110);
                                   /* duplicate record already exists error*/
      set KO0BM002.KO0BMEDT[KO0BWMDX] cursor, bold;
    else
      if (SQLCA.VAGen_SQLCODE == 100)
        /* next sentence*/
      else
        TA1REC.TA1DBASE = "DSLSMN";
        TA1REC.TA1TBLVU = "VOTSCH01";
        TA1REC.TA1TBLKE = KOBREC.KOBKEY;
        TA1REC.TA1LOCAT[1] = "KO0BSCL";
        TA1REC.TA1LOCAT[2] = "IO0690";
        XSKO001(); /* abort*/
      end
    end

  else
    /* next sentence*/
  end

end // end KO0BSCL

// write updated ending date
Function KO0BSDA()


       /* *****************************************/
       /* * 05 - is a code for kobrec            **/
       /* *  2 - is a code for 'before' a change **/
       /* *  3 - is a code for 'after' a change  **/
       /* *                                      **/
       /* *                                      **/
       /* *****************************************/


  set KOAREC empty;
  KOAREC.KOATBLCD = 05;
  KOAREC.KOAACTTY = "2";
  KOAREC.XXXTBLNM = "VOTSCH01";

  KO0BSDB(); /* set-up before picture of kobrec to audit*/
  KO0BSDC(); /* write audit record*/

  if (KO0BWMAP.KOBPCTXD[KO0BWCDX] > 0)
    return; /* don't update a row if ending date exists*/
  else
    KOBREC.KOBPCTXD = KO0BW02.KO0BWXDT;
    KOBREC.XXXUSRID = COMMAREA.CAUSERID;
    KOBREC.ZZZCHGDT = KO0BW02.ZZZCHGDT;
    KOBREC.ZZZCHGTM = KO0BW02.TA2TIMHM;
  end

  set SQLCA empty;
  set ERRSQLCA empty;

  call "IO0690" ("U ", SQLCA, KOBREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    converseLib.validationFailed(80); /* update was successful*/
    set KOAREC empty;
    KOAREC.KOATBLCD = 05;
    KOAREC.KOAACTTY = "3";
    KOAREC.XXXTBLNM = "VOTSCH01";
    KO0BSDB(); /* set-up before picture of kobrec to audit*/
    KO0BSDC(); /* write audit record*/
  else
    if (SQLCA.VAGen_SQLCODE == 100) /* this records was previously modified*/
       /* by someone else. the user must start over.*/
      KO0BW02.KO0BWEFL = "Y";
      converseLib.validationFailed(60);
      KO0BSCK(); /* set all records and maps to empty*/
    else
      TA1REC.TA1DBASE = "DSLSMN";
      TA1REC.TA1TBLVU = "VOTSCH01";
      TA1REC.TA1TBLKE = KOBREC.KOBKEY;
      TA1REC.TA1LOCAT[1] = "KO0BSBL";
      TA1REC.TA1LOCAT[2] = "IO0690";
      XSKO001(); /* abort*/
    end
  end


end // end KO0BSDA

// set up before audit rec.
Function KO0BSDB()


  KOAREC.ZZZSDT = KO0BW02.ZZZCHGDT;
  KOAREC.ZZHHMMSS = KO0BW02.TA2TIMEN;
  KOAREC.XXXUSRID = COMMAREA.CAUSERID;

   /* *****MOVE KO0BWMAP.KO0BMRCD(KO0BWCDX) TO KOAREC.XRCCD;   /* 02-24-94*/

  KOAREC.SM1AGYID = KOBREC.SM1AGYID;
  KOAREC.SM4REPID = KOBREC.SM4REPID;
  KOAREC.XPRCD = KOBREC.XPRCD;
  KOAREC.YSCCD = KOBREC.YSCCD;
  KOAREC.KUCCOID = KOBREC.KUCCOID;
  KOAREC.XDVCD = KOBREC.XDVCD;
  KOAREC.XGPCD = KOBREC.XGPCD;
  KOAREC.XOBCD = KOBREC.XOBCD;
  KOAREC.XOTCD = KOBREC.XOTCD;
  KOAREC.KOBCOPCT = KOBREC.KOBCOPCT;
  KOAREC.KOBPCTED = KOBREC.KOBPCTED;
  KOAREC.KOBPCTXD = KOBREC.KOBPCTXD;
  KOAREC.KOACRSDT = KOBREC.ZZZSDT;


  set TA1REC empty;

end // end KO0BSDB

// write audit rec.
Function KO0BSDC()

  set SQLCA empty;
  set ERRSQLCA empty;

  call "IO0630" ("A ", SQLCA, KOAREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    /* next sentence*/
  else
    TA1REC.TA1DBASE = "DCOMM";
    TA1REC.TA1TBLVU = "VCOAUD01";
    TA1REC.TA1TBLKE = KOBREC.KOBKEY;
    TA1REC.TA1LOCAT[1] = "KO0BSDC";
    TA1REC.TA1LOCAT[2] = "IO0630";
    XSKO001(); /* abort*/
  end


end // end KO0BSDC

// get chg. date & time
Function KO0BSDD()

       /* ***************************************/
       /* * this routine will retrieve todays  **/
       /* * date and time. these will be used  **/
       /* * to update zzzchgdt & zzzchgtm      **/
       /* * fields. there will be one date     **/
       /* * and time for all db2 rows that are **/
       /* * updated.                           **/
       /* *                                    **/
       /* *                                    **/
       /* ***************************************/

  set TA2REC empty;
  set TA1REC empty;
  KO0BW02.ZZZCHGDT = 0;
  KO0BW02.TA2TIMEN = 0;
  TA2REC.TA2DTOPT = "GETDATE";

  call "TA0040" (TA2REC) {isNoRefresh = yes, isExternal = yes};

  if (TA2REC.TA2RTNCD == 0)
    KO0BW02.ZZZCHGDT = TA2REC.TA2GRGGN;
    KO0BW02.TA2TIMEN = TA2REC.TA2TIMEN;
  else
    TA1REC.TA1DBASE = "DSLSMN";
    TA1REC.TA1TBLVU = "TA0040  ";
    TA1REC.TA1TBLKE = KOBREC.KOBKEY;
    TA1REC.TA1LOCAT[1] = "KO0BSDD";
    XSKO001(); /* abort*/
  end


end // end KO0BSDD

// delete and readd o.t. row
Function KO0BSDE()


       /* *****************************************/
       /* * 05 - is a code for kobrec            **/
       /* *  2 - is a code for 'before' a change **/
       /* *  3 - is a code for 'after' a change  **/
       /* *                                      **/
       /* *                                      **/
       /* *****************************************/



  set KOAREC empty;
  KOAREC.KOATBLCD = 05;
  KOAREC.KOAACTTY = "2";
  KOAREC.XXXTBLNM = "VOTSCH01";

  KO0BSDB(); /* set-up before picture of kobrec to audit*/
  KO0BSDC(); /* write audit record*/
  KO0BSDG(); /* delete existing record*/


  KOBREC.KOBPCTED = KO0BWMAP.KO0BMCND[KO0BWCDX];

  KOBREC.XXXUSRID = COMMAREA.CAUSERID;
  KOBREC.ZZZSDT = KO0BW02.ZZZCHGDT;
  KOBREC.ZZZCHGDT = KO0BW02.ZZZCHGDT;
  KOBREC.ZZZCHGTM = KO0BW02.TA2TIMHM;



  set SQLCA empty;
  set ERRSQLCA empty;

  call "IO0690" ("A ", SQLCA, KOBREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)

    converseLib.validationFailed(80); /* update successful*/
    set KOAREC empty;
    KOAREC.KOATBLCD = 05;
    KOAREC.KOAACTTY = "3";
    KOAREC.XXXTBLNM = "VOTSCH01";

    KO0BSDB(); /* set-up audit record*/
    KO0BSDC(); /* write audit record*/
  else
    TA1REC.TA1DBASE = "DCOMM";
    TA1REC.TA1TBLVU = "VOTSCH01";
    TA1REC.TA1TBLKE = KOBREC.KOBKEY;
    TA1REC.TA1LOCAT[1] = "KO0BSBE";
    TA1REC.TA1LOCAT[2] = "IO0690";
    XSKO001(); /* abort*/
  end



end // end KO0BSDE

// write new o.t. sch. row
Function KO0BSDF()


       /* *****************************************/
       /* * 05 - is a code for kobrec            **/
       /* *  1 - is a code for 'add'             **/
       /* *  2 - is a code for 'before' a change **/
       /* *  3 - is a code for 'after' a change  **/
       /* *                                      **/
       /* *                                      **/
       /* *****************************************/


  if (KO0BWMAP.KOBPCTED[KO0BWCDX] > 0)
    set KOAREC empty;
    KOAREC.KOATBLCD = 05;
    KOAREC.KOAACTTY = "2";
    KOAREC.XXXTBLNM = "VOTSCH01";

    KO0BSDB(); /* set-up before picture of kobrec to audit*/
    KO0BSDC(); /* write audit record*/

  else
    set KOAREC empty;
    KOAREC.KOATBLCD = 05;
    KOAREC.KOAACTTY = "1";
    KOAREC.XXXTBLNM = "VOTSCH01";
  end


  KOBREC.KOBCOPCT = KO0BWMAP.KO0BMPCT[KO0BWCDX];
  KOBREC.KOBPCTED = KO0BWMAP.KO0BMCND[KO0BWCDX];
  KOBREC.KOBPCTXD = 0;
  KOBREC.XXXUSRID = COMMAREA.CAUSERID;
  KOBREC.ZZZCHGDT = KO0BW02.ZZZCHGDT;
  KOBREC.ZZZSDT = KO0BW02.ZZZCHGDT;
  KOBREC.ZZZCHGTM = KO0BW02.TA2TIMHM;



  set SQLCA empty;
  set ERRSQLCA empty;

  call "IO0690" ("A ", SQLCA, KOBREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)

    converseLib.validationFailed(80); /* add was successful*/
    if (KO0BWMAP.KOBPCTED[KO0BWCDX] > 0)
      set KOAREC empty;
      KOAREC.KOATBLCD = 05;
      KOAREC.KOAACTTY = "3";
      KOAREC.XXXTBLNM = "VOTSCH01";
    else
      /* next sentence*/
    end

    KO0BSDB(); /* set-up audit record*/
    KO0BSDC(); /* write audit record*/
  else
    TA1REC.TA1DBASE = "DCOMM";
    TA1REC.TA1TBLVU = "VOTSCH01";
    TA1REC.TA1TBLKE = KOBREC.KOBKEY;
    TA1REC.TA1LOCAT[1] = "KO0BSBF";
    TA1REC.TA1LOCAT[2] = "IO0690";
    XSKO001(); /* abort*/
  end


end // end KO0BSDF

// delete order type row
Function KO0BSDG()

  set SQLCA empty;
  set ERRSQLCA empty;

  call "IO0690" ("D ", SQLCA, KOBREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    /* next sentence*/
  else
    TA1REC.TA1DBASE = "DCOMM";
    TA1REC.TA1TBLVU = "VOTSCH01";
    TA1REC.TA1TBLKE = KOBREC.KOBKEY;
    TA1REC.TA1LOCAT[1] = "KO0BSDC";
    TA1REC.TA1LOCAT[2] = "IO0690";
    XSKO001(); /* abort*/
  end




end // end KO0BSDG

// change order type row data
Function KO0BSDH()


       /* *****************************************/
       /* * 05 - is a code for kobrec            **/
       /* *  2 - is a code for 'before' a change **/
       /* *  3 - is a code for 'after' a change  **/
       /* *                                      **/
       /* *                                      **/
       /* *****************************************/


  set KOAREC empty;
  KOAREC.KOATBLCD = 05;
  KOAREC.KOAACTTY = "2";
  KOAREC.XXXTBLNM = "VOTSCH01";

  KO0BSDB(); /* set-up before picture of kobrec to audit*/
  KO0BSDC(); /* write audit record*/

  if (KO0BWMAP.KO0BMPCT[KO0BWCDX] >= 0)
    KOBREC.KOBCOPCT = KO0BWMAP.KO0BMPCT[KO0BWCDX];
  else
    /* next sentence*/
  end

  KOBREC.XXXUSRID = COMMAREA.CAUSERID;
  KOBREC.ZZZCHGDT = KO0BW02.ZZZCHGDT;
  KOBREC.ZZZCHGTM = KO0BW02.TA2TIMHM;


  set SQLCA empty;
  set ERRSQLCA empty;

  call "IO0690" ("U ", SQLCA, KOBREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    converseLib.validationFailed(80); /* update was successful*/
    set KOAREC empty;
    KOAREC.KOATBLCD = 05;
    KOAREC.KOAACTTY = "3";
    KOAREC.XXXTBLNM = "VOTSCH01";
    KO0BSDB(); /* set-up before picture of kobrec to audit*/
    KO0BSDC(); /* write audit record*/
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      KO0BW02.KO0BWEFL = "Y";
      converseLib.validationFailed(60); /* someone else modified record need to redo.*/
      KO0BSCK();
    else
      TA1REC.TA1DBASE = "DCOMM";
      TA1REC.TA1TBLVU = "VOTSCH01";
      TA1REC.TA1TBLKE = KOBREC.KOBKEY;
      TA1REC.TA1LOCAT[1] = "KO0BSDH";
      TA1REC.TA1LOCAT[2] = "IO0690";
      XSKO001(); /* abort*/
    end
  end


end // end KO0BSDH

//*** RECORD=KO0BW02 ****
// ************************************************************
// this is the general working storage area for ko0b.
// it contains indexs,flags, and key comparision fields
// 
// 
// ************************************************************
// maintenance history
// when       who        why
// --------   --------   --------------------------------------
// 10-30-86   jricha     created application
// 
// 
// ************************************************************
// ***********************
Record KO0BW02 type basicRecord
  5 KO0BWGRP KO0BWGRP ; 
    10 SM1AGYID SM1AGYID ; 
    10 SM4REPID SM4REPID ; 
    10 KO0BWKEY KO0BWKEY ; 
      15 KO0BWAID KO0BWAID ; 
      15 KO0BWRID KO0BWRID ; 
    10 KO0BWEFL KO0BWEFL ; 
    10 KO0BWCFL KO0BWCFL ; 
    10 XOTCD XOTCD ; 
    10 KO0BWCTT KO0BWCTT ; 
      15 KO0BWNXT KO0BWNXT ; 
      15 KO0BWCDX KO0BWCDX ; 
      15 KO0BWTOT KO0BWTOT ; 
      15 KO0BWTOP KO0BWTOP ; 
      15 KO0BWMDX KO0BWMDX ; 
    10 KO0BWFFL KO0BWFFL ; 
    10 KO0BWSOT KO0BWSOT ; 
    10 KO0BWHDT KO0BWHDT ; 
      15 KO0BWHMM KO0BWHMM ; 
      15 KO0BWSL1 KO0BWSL1 ; 
      15 KO0BWHDD KO0BWHDD ; 
      15 KO0BWSL2 KO0BWSL2 ; 
      15 KO0BWHYY KO0BWHYY ; 
    10 KO0BWXDT KO0BWXDT ; 
    10 KO0BWEDT KO0BWEDT ; 
    10 ZZZCHGDT ZZZCHGDT ; 
    10 TA2TIMEN TA2TIMEN ; 
      15 TA2TIMHM TA2TIMHM ; 
      15 TA2TIMSS TA2TIMSS ; 
end // end KO0BW02

//*** RECORD=KO0BWMAP ****
// ************************************************************
// this a working storage area for commission order type. there
// can be a max. of up to 99 records. this working storage area
// contains fields from ko0bm002 screen, and some fields for
// comparing dates in ccyymmdd order. the index for this area
// is ko0bwcdx.
// 
// ************************************************************
// maintenance history
// 
// when      who        why
// --------  --------   ---------------------------------------
// 10-30-86  jricha     created application
// 02-24-94  RPATTE     DB2 CHANGES. DELETE XRCCD.
// 
// 
// 
// ************************************************************
// ************************
Record KO0BWMAP type basicRecord
  10 KO0BW01 KO0BW01 ; 
    15 KO0BWDA KO0BWDA [154] ; 
      20 KO0BMPCT KO0BMPCT ; 
      20 KO0BMEDT KO0BMEDT ; 
      20 KO0BMRCD KO0BMRCD ; 
      20 XOTCD XOTCD ; 
      20 XOTABRV XOTABRV ; 
      20 KOBCOPCT KOBCOPCT ; 
      20 KOBPCTED KOBPCTED ; 
      20 KOBPCTXD KOBPCTXD ; 
      20 ZZZSDT ZZZSDT ; 
      20 ZZZCHGDT ZZZCHGDT ; 
      20 XXXUSRID XXXUSRID ; 
      20 COCMFL COCMFL ; 
      20 KO0BMCED KO0BMCED ; 
      20 KO0BMCND KO0BMCND ; 
      20 ZZZCHGCT ZZZCHGCT ; 
      20 KO0BMMOD KO0BMMOD ; 
end // end KO0BWMAP

// curr. eff. date in ccyymmdd
DataItem KO0BMCED int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// new eff. date in ccyymmdd
DataItem KO0BMCND int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// map. comm. eff. date
DataItem KO0BMEDT char(8)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// y = ko0bmpct had a 0 entered
DataItem KO0BMMOD char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// map. comm. % field
DataItem KO0BMPCT decimal(5,3)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = nullFill, inputRequired = no
}
end

// map. comm. reason code
DataItem KO0BMRCD char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// working stoarge like map
DataItem KO0BW01 char(9240)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// sales agency id
DataItem KO0BWAID char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// w.s. counter
DataItem KO0BWCDX smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// enter 2 times terminate check
DataItem KO0BWCFL char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// group level for all counters
DataItem KO0BWCTT char(10)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// group level for data
DataItem KO0BWDA char(60)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// 1st screen eff. date ccyymmdd
DataItem KO0BWEDT int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// error flag trigger
DataItem KO0BWEFL char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// function flag a,t,o
DataItem KO0BWFFL char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// working storage for ko0b appl
DataItem KO0BWGRP char(57)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// hold day
DataItem KO0BWHDD num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// hold date
DataItem KO0BWHDT char(8)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// hold month
DataItem KO0BWHMM num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// hold year
DataItem KO0BWHYY char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// key info into rep/agency
DataItem KO0BWKEY char(8)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// counter for ko0bwmap
DataItem KO0BWMDX smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// look ahead counter for ws.
DataItem KO0BWNXT smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// sales rep id
DataItem KO0BWRID num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = nullFill, inputRequired = no
}
end

// check for '-'
DataItem KO0BWSL1 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// check for '-'
DataItem KO0BWSL2 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// saved order type code
DataItem KO0BWSOT char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// # of lines used on ko0bm002
DataItem KO0BWTOP smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// tot. # of rows in ko0bwmap
DataItem KO0BWTOT smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// termination date ccyymmdd
DataItem KO0BWXDT int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

