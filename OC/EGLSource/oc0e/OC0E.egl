package oc0e;
import corpcom2.XX0XW01;
import corpcom3.XS0AS00;
import corpcom3.XS0AS03;
import corpcom3.XS0AS05;
import corpcom3.XS0AS13;
import corpcom3.XS0AS22;
import corpcom3.XS0ASDC;
import corpcom3.XS0ASDL;
import corpcom3.XS0ASDP;
import corpcom3.XS0ASDR;
import corpcom3.XS0ASNP;
import corpcom3.XS0ASNR;
import corpcom4.XSENTRY;
import corpcom4.XSEXIT;
import corpcom4.XSPF4;
import corpcom4.XX0XS01;
import corpcom5.COMMAREA;
import corpcom5.ERRSQLCA;
import corpcom6.SQLCA;
import ku.common.KUIPRDID;
import ku.common.KUMREC;
import ob.common.OB2REC;
import ob.common.OBKREC;
import oc.common.*;
import op.common.OP1CUNDT;
import op.common.OP2CPLNB;
import op.common.OP2REC;
import sy.common.SY2CLRID;
import ta.common.TA1REC;
import ta.common.TA5REC;
import ta.common.TAEREC;
import xx.common.*;
import xx02.*;
import xx02.XDMCD;
import xx02.XDTCD;
import xx02.XDTTBL;
import xx02.XGPTBL;
import xx08.*;
import xx08.SY1STNBR;
//*** PROGRAM=OC0E ****
// APPLICATION OVERVIEW:
// This application can be accessed from OC0B by selecting the
// discrepancy to change.
// 
// This application is used to manually change order discrep-
// ancies.  A sub-program is called to do the actual edits
// appropriate for each discrepancy type.  If the edit is
// successful you are returned to OC0B with the message
// 'discrepancy update complete'.
// 
// ------------------------------------------------------------
// 
// SUB-PROGRAM          FUNCTION
// -----------          ---------------------------
// TA0050               Read Temp Storage
// TA0020               Error Diag Post Routine
// IO5880               Get Discrepancy Record
// IO5850               Get Last Discrepancy Number
// IO0440               Select OP Items
// IO5170               Select OB Items
// ************************************************************
//               M A I N T E N A N C E  L O G
// ************************************************************
//   DATE      NAME    DESCRIPTION OF CHANGE
// --------   ------   ---------------------
// 06/01/91   DLEGG    CREATED
// 11/06/91   dflesh   adjusted pf key locations on map.
// 11/15/91   trober   corrected logic to delete letter header
//                     when all discrepancies and comments have
//                     been deleted.  also, changed so message
//                     "LETTER DELETED" instead of "DISCREPANCY
//                     UPDATE COMPLETE" when the letter header
//                     is deleted.
// 01/06/92   trober   added code to prevent a direct
//                     fast path to OC0D, (OC0ESPF).
// 01/25/94   gcalki   #1002 - only allow 'XL' discrepancy for
//                     orders with a 'XL' status. s64 ocwrec
// 08/07/95   CRAINE   DATABASE CHANGES
// *********************
Program OC0E type textUIProgram //VAGen Info - main text program
  {
  includeReferencedFunctions = yes, allowUnqualifiedItemReferences = yes, 
  throwNrfEofExceptions = yes, handleHardIOErrors = no, V60ExceptionCompatibility = yes, 
  I4GLItemsNullable = no, textLiteralDefaultIsString = no, localSQLScope = yes, 
  msgTablePrefix = "OC00", inputRecord = COMMAREA, segmented = yes
  }

  // Data Declarations
  COMMAREA COMMAREA ; // record
  ERRSQLCA ERRSQLCA; // record
  KUMREC KUMREC; // record
  OB2REC OB2REC; // record
  OBKREC OBKREC; // record
  OC0EW01 OC0EW01; // record
  OC0EW02 OC0EW02; // record
  OC0EW03 OC0EW03; // record
  OC1REC OC1REC; // record
  OC3REC OC3REC; // record
  OC4REC OC4REC; // record
  OCAREC OCAREC; // record
  OCDREC OCDREC; // record
  OCFREC OCFREC; // record
  OCWREC OCWREC; // record
  OP2REC OP2REC; // record
  SQLCA SQLCA; // record
  TA1REC TA1REC; // record
  TA5REC TA5REC; // record
  TAEREC TAEREC; // record
  XX0XW01 XX0XW01; // record

  // VAGen Info - items needed for migration
  VAGen_EZESYS char(8);
  VAGen_EZEREPLY num(1);
  VAGen_EZE_WAIT_TIME bin(9,2);
  VAGen_EZE_ITEMLEN int;

  // Use Declarations
  use XDTTBL {deleteAfterUse = yes}; // table
  use XGPTBL {deleteAfterUse = yes}; // table
  use OC0EM.OC0EM001 // form
   {
    pfKeyEquate = no
  };

  function main()
    // VAGen Info - initialization needed for migration
    VAGen_EZESYS = VGLib.getVAGSysType();
    OC0E000: OC0E000();
     /* Flow to converse*/

    goto OC0E010;

    OC0E010: OC0E010();
     /* Flow back to converse*/

    goto OC0E010;
  end // end main
end // end OC0E

// Discrepancy change init
Function OC0E000()
     /* Check csp and order information security*/

  XSENTRY();

   /* ****************************************************/
   /* *** set segmented trans id                      ****/
   /* ****************************************************/

  CAEZSAP = sysVar.transactionID;
  CAEZSG12 = "OC";
  CAEZSG4 = "E";
  sysVar.transactionID = CAEZSAP;

  OC0ES99(); /* Application security*/

     /* Initialize application - init records*/
                              /* save map name for XS sgrp's*/
  OC0ES01();


     /* 'Ready' message*/

  converseLib.validationFailed(088);

     /* Display commarea message,*/
     /* Move commarea passed data*/

  OC0EM001.CAMSG = COMMAREA.CAMSG;
  COMMAREA.CAMSG = " ";

     /* Build map for display*/

  OC0ES03();


end // end OC0E000

// CONVERSE OC0EM001
Function OC0E010()

  converseLib.clearScreen();
   /* set map page*/
  converseVar.segmentedMode = 1; /* force segmented converse mode*/

  converse OC0EM001 ;

  OC0ESDB(); /* Check for DB busy on initial build*/

     /* Init error stuff*/

  OC0EW01.OC0EWERR = "N"; /* Edit error flag*/
  converseLib.validationFailed(0); /* clear last error msg*/
  OC0EM001.VAGen_EZEMSG = " "; /* clear last error msg*/
  OC0EM001.CAMSG = " "; /* clear last commarea msg*/


     /* Process PF Keys*/

  OC0ESPF();

     /* Reset field attributes*/

  if (OC0EW01.OC0EWERR == "N") /* If no errors so far*/
    OC0ES40();
  end

     /* Edit map*/

  if (OC0EW01.OC0EWERR == "N") /* if no errors so far*/
    if (converseVar.eventKey is enter
     || converseVar.eventKey is pf12)
      OC0ES07();
    else
      if (converseVar.eventKey is pf19) /* Request to refresh screen*/
        OC0ES66(); /* Rebuild map from orig records*/
      end
    end
  end

     /* Update or Edit Only*/

  if (OC0EW01.OC0EWERR == "N") /* if no errors*/
    if (converseVar.eventKey is enter)
      if (OC0EW01.OC0EWDUP != "Y") /* there is no duplicate style warning*/
                                   /* msg*/
        OC0ES80(); /* Update/delete discrepancies*/
        if (OC0EW03.OC0EWDCT > 0) /* If any dscrp deleted*/
          OC0ES73(); /* should letter header be deleted*/
          if (OC0EW01.OC0EWERR == "N") /* if no errors*/
            if (OC0EW01.OC0EWLTR == "Y") /* letter header was deleted*/
              COMMAREA.CAMSG = "LETTER DELETED"; /* overlay message*/
            end
          end
        end
        if (OC0EW01.OC0EWERR == "N") /* If no update errors*/
          OC0ES72(); /* purge temp storage*/
          OC0ESP6(); /* xfer to Formatted Letter*/
        end
      else /* there is a duplicate style, reconverse warning*/
        OC0EW01.OC0EWDUP = "D"; /* warning has been displayed*/
      end
    else
      if (converseVar.eventKey is pf12)
        converseLib.validationFailed(089);
                                   /* no errors press enter to proc updates*/
      end
    end
  else
    OC0EW01.OC0EWDUP = "D"; /* warning has been displayed*/
  end


end // end OC0E010

// OC0E initialization
Function OC0ES01()
      /* Initialize application*/


  set OC0EM001 empty; /* map*/

  set OC1REC empty; /* letter header record*/
  set OC4REC empty; /* discrepancy record*/
  set OP2REC empty; /* OP item*/
  set OB2REC empty; /* OB item*/
  set OBKREC empty; /* OB IO mod pass rec*/
  set KUMREC empty; /* store record*/
  set OCAREC empty; /* OC5000 edit module pass rec*/
  set OCDREC empty; /* IO5850 dscrp IO mod pass rec*/
  set OCFREC empty; /* IO5870 comment IO mod pass rec*/
  set SQLCA empty; /* return code from DB2*/
  set ERRSQLCA empty; /* return code from non-db2*/
  set TAEREC empty; /* diags for non db2*/
  set TA1REC empty; /* diagnostic record*/
  set TA5REC empty; /* temp storage io- record*/
  set XX0XW01 empty; /* working storage for date rtn*/
  set OC0EW01 empty; /* working storage*/
  set OC0EW02 empty; /* temp storage hold*/

   /* Initialize working storage record for saving discrepancy*/
   /* lines. These working storage lines will be compared to the*/
   /* map lines later during editing*/

  set OC0EW03 empty; /* working storage to compare with the map*/

  XX0XS01(); /* get current date, time for updates*/

  TA1REC.TA1MAP = "OC0EM001"; /* map name*/
  COMMAREA.CACURRAP = "OC0E"; /* current appl*/

  OC0EW01.OC0EWDUP = "N";
end // end OC0ES01

// Build map
Function OC0ES03()

   /* Build map*/
   /* --------------------------------------------*/


   /* Build headings*/

  OC0ES25();

   /* Build bottom of map*/

  if (COMMAREA.CAFROMAP == "OC0D") /* transfer'd from Display Dscrp Cds*/
    OC0ES30();
                                   /* build bottom of map from temp storage*/
  else
    OC0ES31(); /* Build map from passed keys*/
  end

  if (converseVar.validationMsgNum == 006) /* If DB busy from build*/
    OC0EW01.OC0EWBSY = "Y"; /* Turn on DB busy flag*/
    OC0EW01.OC0EWLIX = 0; /* Set line subscript to zero*/
  end

  OC0EW01.OC0EWLIX = OC0EW01.OC0EWLIX + 1; /* Increment line*/
  if (OC0EW01.OC0EWLIX <= 13) /* If map not full*/
    OC0ES39(); /* darken, protect empty lines*/
  end

end // end OC0ES03

// Edit map
Function OC0ES07()

   /* Check to see if there is a '?' in any of the*/
   /* discrepancy type fields. This forces a transfer to OC0D*/
   /* (Discrepancy Type Display).*/

   /* Otherwise, edit each line on the map, bottom up.*/
   /* -----------------------------------------------------------*/

  set SQLCA empty;

  OC0ES61();
                                   /* Check for request to transfer to OC0D*/

  if (OC0EW01.OC0EWERR == "N") /* If no errors so far*/
    OC0EW01.OC0EWLIX = OC0EW03.OC0EWDCT;
                                   /* Set subs to last full line*/
    while (OC0EW01.OC0EWLIX > 0
     && SQLCA.VAGen_SQLCODE != -911)
      OC0ES62(); /* Edit line*/
      OC0EW01.OC0EWLIX = OC0EW01.OC0EWLIX - 1; /* Decrement line subscript*/
    end
  end

  if (SQLCA.VAGen_SQLCODE == -911)
    OC0EW01.OC0EWERR = "Y"; /* error flag on*/
    converseLib.validationFailed(006); /* db busy try again*/
    return;
  end


end // end OC0ES07

// Build map headings
Function OC0ES25()

   /* Move heading information to map*/


  OC0EM001.OCMPRC = "OC0E"; /* process name*/
  OC0EM001.OCMMAP = "M1"; /* map name*/
  OC0EM001.OCMDTE = VGVar.currentShortGregorianDate; /* current date*/

  OC0EM001.OCWCUOID = OCWREC.OCWCUOID; /* order number*/

  OC0EM001.OP1CUPO = OCWREC.OP1CUPO; /* customer PO*/
  OC0EM001.OCWCUST = OCWREC.OCWCUST; /* customer number*/
  OC0EM001.KUMSTRNM = OCWREC.KUMSTRNM; /* store name*/

   /* GPC Abbrev lookup*/

  sysVar.arrayIndex = 1;
  if (OCWREC.XGPCD in XGPTBL.XGPCD
   && XGPTBL.XXXSTAT[sysVar.arrayIndex] == "A")
    OC0EM001.XGPABRV = XGPTBL.XGPABRV[sysVar.arrayIndex];
  else
    OC0EM001.XGPABRV = "UNKNWN";
  end


end // end OC0ES25

// Build map from temp storage
Function OC0ES30()
   /* Build bottom of map from temp storage. Before the xfer*/
   /* to OC0D, the map discrepancy lines are written to temp*/
   /* storage. Now, returning from OC0D, rebuild the bottom of*/
   /* the map from temp storage.*/
   /* -----------------------------------------------------------*/

   /* Read temp storage record*/

  OC0ES34();



   /* move discrepancy line from temp storage record*/
   /* to the map. A discrepancy abbreviation may have been*/
   /* passed in OCWREC from OC0D. It will replace the first*/
   /* discrepancy abbreviation that had a '?' before the xfer.*/

  OC0EW01.OC0EWQSF = "N"; /* Init question mark found flag*/
  OC0EW01.OC0EWLIX = 1; /* Set map line subscript to 1*/

  while (OC0EW01.OC0EWLIX < 14
   && OC0EW01.OC0EWLIX <= OC0EW03.OC0EWDCT) /* and not all dscrp moved*/
    if (OC0EW01.OC0EWQSF == "N")
      OC0EW01.OC0EWABR = OC0EW02.XDTCD[OC0EWLIX];
      if (OC0EW01.OC0EWAB1 == "?" /* If there is a question*/
       || OC0EW01.OC0EWAB2 == "?") /* mark in either position of xdtcd*/
        OC0EW01.OC0EWQSF = "Y"; /* Turn on '?' found flag*/
        if (OCWREC.XDTCD > " ") /* the code was passed from oc0d*/
          OC0EM001.XDTCD[OC0EWLIX] = OCWREC.XDTCD;
          set OC0EM001.SY1STNBR[OC0EWLIX] cursor;
        else
          OC0EM001.XDTCD[OC0EWLIX] = OC0EW02.XDTCD[OC0EWLIX];
          set OC0EM001.XDTCD[OC0EWLIX] cursor;
        end
      else
        OC0EM001.XDTCD[OC0EWLIX] = OC0EW02.XDTCD[OC0EWLIX];
      end
    else
      OC0EM001.XDTCD[OC0EWLIX] = OC0EW02.XDTCD[OC0EWLIX];
    end
    OC0EM001.SY1STNBR[OC0EWLIX] = OC0EW02.SY1STNBR[OC0EWLIX];
    OC0EM001.SY2CLRID[OC0EWLIX] = OC0EW02.SY2CLRID[OC0EWLIX];
    OC0EM001.XDMCD[OC0EWLIX] = OC0EW02.XDMCD[OC0EWLIX];
    OC0EM001.OCASUBOR[OC0EWLIX] = OC0EW02.OCASUBOR[OC0EWLIX];
    OC0EM001.OC4EXPEC[OC0EWLIX] = OC0EW02.OC4EXPEC[OC0EWLIX];
    OC0EM001.OC4ACTUA[OC0EWLIX] = OC0EW02.OC4ACTUA[OC0EWLIX];
    OC0EW01.OC0EWLIX = OC0EW01.OC0EWLIX + 1; /* Increment subscript*/
  end

  OC0EW01.OC0EWLIX = OC0EW03.OC0EWDCT; /* Set subs to last full line*/

   /* Purge temp storage*/

  OC0ES72();

end // end OC0ES30

// Build map from passed keys
Function OC0ES31()
   /* Use keys passed from the formatted letter to*/
   /* build the discrepancy lines.*/
   /* ----------------------------------------------*/

   /* Set up generic portion of key for discrepancy*/
   /* record lookup.*/

  set OC4REC empty; /* Discrepancy record*/
  OC4REC.OP1CUOID = OCWREC.OCWCUOID; /* Order number*/
  OC4REC.OP1PARTN = OCWREC.OP1PARTN; /* Part char*/
  OC4REC.OC1LTRNB = OCWREC.OCWCULTR; /* Letter number*/

  OC0EW01.OC0EWDIX = 1;
                                   /* Set passed discrepancy subscript to 1*/
  OC0EW01.OC0EWLIX = 0; /* Set map line subscript to 0*/

  while (OC0EW01.OC0EWLIX < 13  /* While map is not full*/
   && OC0EW01.OC0EWDIX <= 15 /* and not at end of discrepancy array*/
   && SQLCA.VAGen_SQLCODE == 0) /* and no DB errors*/
    if (OCWREC.OC4DSCPN[OC0EWDIX] != 0) /* If dscrp code in array not blank*/
      OC4REC.OC4DSCPN = OCWREC.OC4DSCPN[OC0EWDIX]; /* Dscrp# key*/
      OC0ES33(); /* Get matching dscrp record*/
      if (SQLCA.VAGen_SQLCODE == 0) /* If good fetch*/
        OC0EW01.OC0EWLIX = OC0EW01.OC0EWLIX + 1; /* Increment line number*/
        OC0ES32(); /* Move dscrp data to line*/
      end
    end
    OC0EW01.OC0EWDIX = OC0EW01.OC0EWDIX + 1; /* Increment array subscript*/
  end

end // end OC0ES31

// Move discrepancy to map line
Function OC0ES32()
   /* Move data from discrepancy record to map line.*/
   /* Also save (in OC0CW03) the fields from the original*/
   /* record to compare against what's entered on the map*/
   /* -----------------------------------------------*/

   /* Discrepancy type - get matching abbrev from*/
   /* XDT table*/
  sysVar.arrayIndex = 1;
  if (OC4REC.XDTCD in XDTTBL.XDTCD)
    OC0EM001.XDTCD[OC0EWLIX] = XDTTBL.XDTCD[sysVar.arrayIndex];
    OC0EW03.XDTCD[OC0EWLIX] = XDTTBL.XDTCD[sysVar.arrayIndex];
  else
    OC0EM001.XDTCD[OC0EWLIX] = "UK"; /* Unknown dscrp type*/
    OC0EW03.XDTCD[OC0EWLIX] = "UK"; /* Also in save area*/
  end

  if (OC4REC.OC4STYFL == "Y") /* If all styles flag is yes*/
    OC0EM001.OCASUBOR[OC0EWLIX] = "ALL"; /* Move 'ALL' to subord ref*/
    OC0EW03.OCASUBOR[OC0EWLIX] = "ALL";
  else
    OC0EM001.OCASUBOR[OC0EWLIX] = " ";
    OC0EW03.OCASUBOR[OC0EWLIX] = " ";
  end

  OC0EM001.SY1STNBR[OC0EWLIX] = OC4REC.SY1STNBR; /* Style*/
  OC0EW03.SY1STNBR[OC0EWLIX] = OC4REC.SY1STNBR; /* Style (save)*/
  OC0EM001.SY2CLRID[OC0EWLIX] = OC4REC.SY2CLRID; /* Color*/
  OC0EW03.SY2CLRID[OC0EWLIX] = OC4REC.SY2CLRID; /* Color (save)*/
  OC0EM001.XDMCD[OC0EWLIX] = OC4REC.XDMCD; /* Dimension*/
  OC0EW03.XDMCD[OC0EWLIX] = OC4REC.XDMCD; /* Dimension (save)*/

  OC0EM001.OC4EXPEC[OC0EWLIX] = OC4REC.OC4EXPEC; /* Expected value*/
  OC0EW03.OC4EXPEC[OC0EWLIX] = OC4REC.OC4EXPEC; /* Expected value -save*/
  OC0EM001.OC4ACTUA[OC0EWLIX] = OC4REC.OC4ACTUA; /* Actual value*/
  OC0EW03.OC4ACTUA[OC0EWLIX] = OC4REC.OC4ACTUA;
                                   /* Actual value - save*/
  OC0EW03.OC0EWOGA[OC0EWLIX] = OC4REC.OC4ACTUA;
                                   /* Actual value - save*/
  OC0EW03.OC4DSCPN[OC0EWLIX] = OC4REC.OC4DSCPN;
                                   /* Dscrp number - save*/

  OC0EW03.OC0EWDCT = OC0EW03.OC0EWDCT + 1; /* Increment dscrp count*/

end // end OC0ES32

// IO5880 - Get discrepancy rec
Function OC0ES33()
   /* Get discrepancy record with unique key.*/
   /* Keys are set up in the calling statement group.*/
   /* -------------------------------------------------------*/

  set SQLCA empty;
  set OCDREC empty; /* Dscrp IO mod pass record*/

  OCDREC.OCDTASK = "S "; /* Select unique*/

  call "IO5880" (OCDREC, SQLCA, OC4REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
     /* next sentence*/
  else
    TA1REC.TA1LOCAT[1] = "OC0ES33"; /* stmt group*/
    TA1REC.TA1LOCAT[2] = "IO5880"; /* i/o mod*/
    TA1REC.TA1LOCAT[3] = "S "; /* function*/
    OC0EW01.OC0EWKY1 = " "; /* Init error key*/
    OC0EW01.OC0EWKPA = OCWREC.OP1PARTN; /* part char key*/
    OC0EW01.OC0EWKPB = OCWREC.OCWCUOID; /* order nbr key*/
    OC0EW01.OC0EWKPC = OC4REC.OC1LTRNB; /* letter number*/
    OC0EW01.OC0EWKPD = OC4REC.OC4DSCPN; /* dscrp number*/
    TA1REC.TA1TBLKE = OC0EW01.OC0EWKY1; /* error key*/
    TA1REC.TA1DBASE = "DORDC"; /* database name*/
    TA1REC.TA1TBLVU = "VDSCRP01"; /* database view name*/
    if (SQLCA.VAGen_SQLCODE == -911) /* timed out*/
      VGVar.handleSysLibraryErrors = 0;
      sysLib.rollback(); /* Rollback updates*/
      XS0ASDP(); /* Post and return*/
      converseLib.validationFailed(006); /* DB busy*/
      OC0EW01.OC0EWERR = "Y"; /* Turn on error flag*/
    else /* all other codes - abort*/
      COMMAREA.CAMSG = "DATA PROBLEM - TRY AGAIN LATER";
      XS0ASDC();
    end
  end

end // end OC0ES33

// TA0050 - Read TS
Function OC0ES34()

   /* Read temporary storage*/

  set OC0EW02 empty;

  TA5REC.TA5APPID = "OC0E"; /* appl identification*/
  TA5REC.TA5FNCCD = "R"; /* function code*/
  TA5REC.TA5TSQIX = 1; /* only one page*/
  OC0EW02.OC0EWTSL = 2232; /* length of record*/

  call "TA0050" (OC0EW02, TA5REC) {isNoRefresh = yes, isExternal = yes}; /* temp storage*/

  if (TA5REC.TA5RTNCD == 0)
    OC0EW03.OC0EWGP3 = OC0EW02.OC0EWGP3; /* Move saved area to rec*/
  else
    set TA1REC empty;
    set TAEREC empty;
    TA1REC.TA1LOCAT[1] = "OC0ES34";
    TA1REC.TA1LOCAT[2] = "TA0050"; /* io mod called*/
    TA1REC.TA1LOCAT[3] = TA5REC.TA5RTNCD; /* return code*/
    TA1REC.TA1TBLKE = OC0EW02.OC0EWTSR[1]; /* first row*/
    TAEREC.TAEDESC1 = TA5REC.TA5DATA; /* subroutine parms*/
    TAEREC.TAEDESC2 = "TSQ READ FAILED";
    XS0ASNR(); /* post, no rollback, non db2 diags*/
  end
end // end OC0ES34

// Darken, protect empty lines
Function OC0ES39()
   /* Lines which do not contain discrepancies*/
   /* are darkened and protected.*/
   /* -------------------------------------------*/

  while (OC0EW01.OC0EWLIX < 14)
    set OC0EM001.OC0EMCMD[OC0EWLIX] protect, invisible;
    set OC0EM001.XDTCD[OC0EWLIX] protect, invisible;
    set OC0EM001.SY1STNBR[OC0EWLIX] protect, invisible;
    set OC0EM001.SY2CLRID[OC0EWLIX] protect, invisible;
    set OC0EM001.XDMCD[OC0EWLIX] protect, invisible;
    set OC0EM001.OCASUBOR[OC0EWLIX] protect, invisible;
    set OC0EM001.OC4EXPEC[OC0EWLIX] protect, invisible;
    set OC0EM001.OC4ACTUA[OC0EWLIX] protect, invisible;
    OC0EW01.OC0EWLIX = OC0EW01.OC0EWLIX + 1; /* Increment subscript*/
  end

end // end OC0ES39

// Reset field attributes
Function OC0ES40()

   /* Reset line field attributes for all filled lines*/

  OC0EW01.OC0EWLIX = 1; /* Set line subscript to 1*/
  while (OC0EW01.OC0EWLIX <= OC0EW03.OC0EWDCT)
    set OC0EM001.OC0EMCMD[OC0EWLIX] initialAttributes; /* Line command*/
    set OC0EM001.XDTCD[OC0EWLIX] initialAttributes; /* Discrepancy type*/
    set OC0EM001.SY1STNBR[OC0EWLIX] initialAttributes; /* Style nbr*/
    set OC0EM001.SY2CLRID[OC0EWLIX] initialAttributes; /* Color id*/
    set OC0EM001.XDMCD[OC0EWLIX] initialAttributes; /* Dimension cd*/
    set OC0EM001.OCASUBOR[OC0EWLIX] initialAttributes; /* Sub order reference*/
    set OC0EM001.OC4EXPEC[OC0EWLIX] initialAttributes; /* Expected value*/
    set OC0EM001.OC4ACTUA[OC0EWLIX] initialAttributes; /* Actual value*/
    OC0EW01.OC0EWLIX = OC0EW01.OC0EWLIX + 1;
  end

  set OC0EM001.OC0EMCMD[1] cursor; /* Default cursor*/

end // end OC0ES40

// Transfer to OC0D
Function OC0ES50()
   /* Before transferring to OC0D (Discrepancy Code Display)*/
   /* save the discrepancy lines from the map to temp*/
   /* storage so the map can be rebuilt from temporary*/
   /* storage when returning from OC0D.*/



  OC0ES72(); /* Purge temp storage*/

  set OC0EW02 empty; /* Initialize map save area*/
  OC0EW01.OC0EWLIX = 1; /* Set line subscript to 1*/

   /* Save all the fields on the map line in a record to be*/
   /* written to temporary storage.*/

  while (OC0EW01.OC0EWLIX < 14)
    OC0EW02.XDTCD[OC0EWLIX] = OC0EM001.XDTCD[OC0EWLIX];
    OC0EW02.SY1STNBR[OC0EWLIX] = OC0EM001.SY1STNBR[OC0EWLIX];
    OC0EW02.SY2CLRID[OC0EWLIX] = OC0EM001.SY2CLRID[OC0EWLIX];
    OC0EW02.XDMCD[OC0EWLIX] = OC0EM001.XDMCD[OC0EWLIX];
    OC0EW02.OCASUBOR[OC0EWLIX] = OC0EM001.OCASUBOR[OC0EWLIX];
    OC0EW02.OC4EXPEC[OC0EWLIX] = OC0EM001.OC4EXPEC[OC0EWLIX];
    OC0EW02.OC4ACTUA[OC0EWLIX] = OC0EM001.OC4ACTUA[OC0EWLIX];

    OC0EW01.OC0EWLIX = OC0EW01.OC0EWLIX + 1; /* Increment subscript*/
  end

   /* In addition to a picture of the current map, move the*/
   /* copy of the original records that built the screen to*/
   /* therecord that will be written to temp storage.*/

  OC0EW02.OC0EWGP3 = OC0EW03.OC0EWGP3; /* Move copy of orig record*/

  OC0ES70(); /* Write saved map to temp storage*/

  XS0AS22(); /* Transfer to OC0D*/

end // end OC0ES50

// IO0440 - Fetch OP item
Function OC0ES51()
   /* Fetch OP item*/
   /* -----------------------------------------------------*/

  set SQLCA empty;

  call "IO0440" ("SN", SQLCA, OP2REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0
   || SQLCA.VAGen_SQLCODE == 100) /* End of selected items*/
    /* next sentence*/
  else
    TA1REC.TA1LOCAT[1] = "OC0ES51"; /* stmt group*/
    TA1REC.TA1LOCAT[2] = "IO0440"; /* i/o mod*/
    TA1REC.TA1LOCAT[3] = "SN"; /* function*/
    OC0EW01.OC0EWKY2 = " "; /* Init error key*/
    OC0EW01.OC0EWKPA = OCWREC.OP1PARTN; /* part char key*/
    OC0EW01.OC0EWKPB = OCWREC.OCWCUOID; /* order nbr key*/
    OC0EW01.OC0EWKPC = OC0EW01.OC0EWSID; /* suborder id key*/
    TA1REC.TA1TBLKE = OC0EW01.OC0EWKY2; /* error key*/
    TA1REC.TA1DBASE = "DORDER"; /* database name*/
    TA1REC.TA1TBLVU = "VITEM001"; /* database view name*/
    if (SQLCA.VAGen_SQLCODE == -911) /* timed out*/
      XS0ASDP();
      VGVar.handleSysLibraryErrors = 0;
      sysLib.rollback();
      converseLib.validationFailed(006); /* DB busy*/
      OC0EW01.OC0EWERR = "Y"; /* Turn on error flag*/
    else /* all other codes - abort*/
      COMMAREA.CAMSG = "DATA PROBLEM - TRY AGAIN LATER";
      XS0ASDC();
    end
  end

end // end OC0ES51

// IO0440 - Close OP cursor
Function OC0ES52()
   /* Close OP item cursor*/
   /* -----------------------------------------------------*/

  set SQLCA empty;

  call "IO0440" ("CS", SQLCA, OP2REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    /* next sentence*/
  else
    TA1REC.TA1LOCAT[1] = "OC0ES52"; /* stmt group*/
    TA1REC.TA1LOCAT[2] = "IO0440"; /* i/o mod*/
    TA1REC.TA1LOCAT[3] = "CS"; /* function*/
    OC0EW01.OC0EWKY2 = " "; /* Init error key*/
    OC0EW01.OC0EWKPA = OCWREC.OP1PARTN; /* part char key*/
    OC0EW01.OC0EWKPB = OCWREC.OCWCUOID; /* order nbr key*/
    OC0EW01.OC0EWKPC = OC0EW01.OC0EWSID; /* suborder id key*/
    TA1REC.TA1TBLKE = OC0EW01.OC0EWKY2; /* error key*/
    TA1REC.TA1DBASE = "DORDER"; /* database name*/
    TA1REC.TA1TBLVU = "VITEM001"; /* database view name*/
    if (SQLCA.VAGen_SQLCODE == -911) /* timed out*/
      XS0ASDP();
      VGVar.handleSysLibraryErrors = 0;
      sysLib.rollback();
      converseLib.validationFailed(006); /* DB busy*/
      OC0EW01.OC0EWERR = "Y"; /* Turn on error flag*/
    else /* all other codes - abort*/
      COMMAREA.CAMSG = "DATA PROBLEM - TRY AGAIN LATER";
      XS0ASDC();
    end
  end

end // end OC0ES52

// IO5170 - Select OB item
Function OC0ES53()
   /* Select OB items for Order#, Suborder ID*/
   /* -----------------------------------------------*/

  set OB2REC empty;
  set OBKREC empty;
  set SQLCA empty;

  OB2REC.OP1PARTN = OCWREC.OP1PARTN; /* part char*/
  OB2REC.OP1CUOID = OCWREC.OP1CUOID; /* cust order id*/
  OC0EW01.OC0EWSID = OC0EM001.OCASUBOR[OC0EWLIX]; /* num suborder id*/
  OB2REC.OP1NORID = OC0EW01.OC0EWSID; /* nike order id*/

  OBKREC.OBKTASK = "S1"; /* select items*/

  call "IO5170" (OBKREC, SQLCA, OB2REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    /* next sentence*/
  else
    TA1REC.TA1LOCAT[1] = "OC0ES53"; /* stmt group*/
    TA1REC.TA1LOCAT[2] = "IO5170"; /* i/o mod*/
    TA1REC.TA1LOCAT[3] = "S1"; /* function*/
    OC0EW01.OC0EWKY2 = " "; /* Init error key*/
    OC0EW01.OC0EWKPA = OCWREC.OP1PARTN; /* part char key*/
    OC0EW01.OC0EWKPB = OCWREC.OCWCUOID; /* order nbr key*/
    OC0EW01.OC0EWKPC = OC0EW01.OC0EWSID; /* suborder id key*/
    TA1REC.TA1TBLKE = OC0EW01.OC0EWKY2; /* error key*/
    TA1REC.TA1DBASE = "DORDB"; /* database name*/
    TA1REC.TA1TBLVU = "VBITEM01"; /* database view name*/
    if (SQLCA.VAGen_SQLCODE == -911) /* timed out*/
      XS0ASDP();
      VGVar.handleSysLibraryErrors = 0;
      sysLib.rollback();
      converseLib.validationFailed(006); /* DB busy*/
      OC0EW01.OC0EWERR = "Y"; /* Turn on error flag*/
    else /* all other codes - abort*/
      COMMAREA.CAMSG = "DATA PROBLEM - TRY AGAIN LATER";
      XS0ASDC();
    end
  end


end // end OC0ES53

// IO5170 - Fetch OB item
Function OC0ES54()
   /* Fetch OB item*/
   /* -----------------------------------------------*/

  set SQLCA empty;
  OBKREC.OBKTASK = "N1"; /* select items*/

  call "IO5170" (OBKREC, SQLCA, OB2REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0
   || SQLCA.VAGen_SQLCODE == 100) /* End selected OB items*/
    /* next sentence*/
  else
    TA1REC.TA1LOCAT[1] = "OC0ES54"; /* stmt group*/
    TA1REC.TA1LOCAT[2] = "IO5170"; /* i/o mod*/
    TA1REC.TA1LOCAT[3] = "N1"; /* function*/
    OC0EW01.OC0EWKY2 = " "; /* Init error key*/
    OC0EW01.OC0EWKPA = OCWREC.OP1PARTN; /* part char key*/
    OC0EW01.OC0EWKPB = OCWREC.OCWCUOID; /* order nbr key*/
    OC0EW01.OC0EWKPC = OC0EW01.OC0EWSID; /* suborder id key*/
    TA1REC.TA1TBLKE = OC0EW01.OC0EWKY2; /* error key*/
    TA1REC.TA1DBASE = "DORDB"; /* database name*/
    TA1REC.TA1TBLVU = "VBITEM01"; /* database view name*/
    if (SQLCA.VAGen_SQLCODE == -911) /* timed out*/
      XS0ASDP();
      VGVar.handleSysLibraryErrors = 0;
      sysLib.rollback();
      converseLib.validationFailed(006); /* DB busy*/
      OC0EW01.OC0EWERR = "Y"; /* Turn on error flag*/
    else /* all other codes - abort*/
      COMMAREA.CAMSG = "DATA PROBLEM - TRY AGAIN LATER";
      XS0ASDC();
    end
  end

end // end OC0ES54

// IO5170 - Close OB cursor
Function OC0ES55()
   /* Close OB item cursor*/
   /* -----------------------------------------------*/

  set SQLCA empty;
  OBKREC.OBKTASK = "C1"; /* select items*/

  call "IO5170" (OBKREC, SQLCA, OB2REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    /* next sentence*/
  else
    TA1REC.TA1LOCAT[1] = "OC0ES55"; /* stmt group*/
    TA1REC.TA1LOCAT[2] = "IO5170"; /* i/o mod*/
    TA1REC.TA1LOCAT[3] = "C1"; /* function*/
    OC0EW01.OC0EWKY2 = " "; /* Init error key*/
    OC0EW01.OC0EWKPA = OCWREC.OP1PARTN; /* part char key*/
    OC0EW01.OC0EWKPB = OCWREC.OCWCUOID; /* order nbr key*/
    OC0EW01.OC0EWKPC = OC0EW01.OC0EWSID; /* suborder id key*/
    TA1REC.TA1TBLKE = OC0EW01.OC0EWKY2; /* error key*/
    TA1REC.TA1DBASE = "DORDB"; /* database name*/
    TA1REC.TA1TBLVU = "VBITEM01"; /* database view name*/
    if (SQLCA.VAGen_SQLCODE == -911) /* timed out*/
      XS0ASDP();
      VGVar.handleSysLibraryErrors = 0;
      sysLib.rollback();
      converseLib.validationFailed(006); /* DB busy*/
      OC0EW01.OC0EWERR = "Y"; /* Turn on error flag*/
    else /* all other codes - abort*/
      COMMAREA.CAMSG = "DATA PROBLEM - TRY AGAIN LATER";
      XS0ASDC();
    end
  end

end // end OC0ES55

// IO0440 - Select OP items
Function OC0ES56()
   /* Select OP items for Order#, Suborder ID*/
   /* -----------------------------------------------------*/

  set OP2REC empty;
  set SQLCA empty;

  OP2REC.OP1CUOID = OCWREC.OCWCUOID; /* op-cust-ord-id*/
  OP2REC.OP1PARTN = OCWREC.OP1PARTN; /* op-ord-part-char*/
  OC0EW01.OC0EWSID = OC0EM001.OCASUBOR[OC0EWLIX]; /* suborder to num*/
  OP2REC.OP1NORID = OC0EW01.OC0EWSID; /* suborder id*/

  call "IO0440" ("SS", SQLCA, OP2REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    /* next sentence*/
  else
    TA1REC.TA1LOCAT[1] = "OC0ES56"; /* stmt group*/
    TA1REC.TA1LOCAT[2] = "IO0440"; /* i/o mod*/
    TA1REC.TA1LOCAT[3] = "SS"; /* function*/
    OC0EW01.OC0EWKY2 = " "; /* Init error key*/
    OC0EW01.OC0EWKPA = OCWREC.OP1PARTN; /* part char key*/
    OC0EW01.OC0EWKPB = OCWREC.OCWCUOID; /* order nbr key*/
    OC0EW01.OC0EWKPC = OC0EW01.OC0EWSID; /* suborder id key*/
    TA1REC.TA1TBLKE = OC0EW01.OC0EWKY2; /* error key*/
    TA1REC.TA1DBASE = "DORDER"; /* database name*/
    TA1REC.TA1TBLVU = "VITEM001"; /* database view name*/
    if (SQLCA.VAGen_SQLCODE == -911) /* timed out*/
      VGVar.handleSysLibraryErrors = 0;
      sysLib.rollback();
      XS0ASDP();
      converseLib.validationFailed(006); /* DB busy*/
      OC0EW01.OC0EWERR = "Y"; /* Turn on error flag*/
    else /* all other codes - abort*/
      COMMAREA.CAMSG = "DATA PROBLEM - TRY AGAIN LATER";
      XS0ASDC();
    end
  end

end // end OC0ES56

// Check for '?' in dscrp type
Function OC0ES61()
   /* Search all discrepancy type fields to see if a '?'*/
   /* has been entered. If so, save an image of the current*/
   /* screen in temporary storage, then transfer to OC0D*/
   /* (Discrepancy Type Display). The OC0E map will be*/
   /* rebuilt from this temporary storage record upon*/
   /* return to this application.*/
   /* -----------------------------------------------------*/

  OC0EW01.OC0EWQSF = "N"; /* Init question mark found flag*/
  OC0EW01.OC0EWLIX = 1; /* Set map line subscript to 1*/

  while (OC0EWLIX < 14
   && OC0EW01.OC0EWQSF == "N")
    OC0EW01.OC0EWABR = OC0EM001.XDTCD[OC0EWLIX];
    if (OC0EW01.OC0EWAB1 == "?" /* If there is a question*/
     || OC0EW01.OC0EWAB2 == "?") /* in either position of dscrp abrv*/
      OC0EW01.OC0EWQSF = "Y"; /* Turn on '?' found flag*/
    end
    OC0EW01.OC0EWLIX = OC0EW01.OC0EWLIX + 1; /* Increment subscript*/
  end

  if (OC0EW01.OC0EWQSF == "N") /* If no question mark was found*/
    return; /* go back to calling statement*/
  end

   /* If you get this far, there was a question mark found*/

  OC0ES50(); /* Write TS and transfer*/


end // end OC0ES61

// Edit line
Function OC0ES62()
    /* if all fields on this line are the same as are on file*/
    /* there is no edit to be done.  oc0ew03 is valued in*/
    /* oc0es32 and should not be changed by any post converse*/
    /* processing*/

  if (OC0EM001.OC0EMCMD[OC0EWLIX] == " " /* blank line command*/
   && OC0EM001.XDTCD[OC0EWLIX] == OC0EW03.XDTCD[OC0EWLIX]
   && OC0EM001.SY1STNBR[OC0EWLIX] == OC0EW03.SY1STNBR[OC0EWLIX]
   && OC0EM001.SY2CLRID[OC0EWLIX] == OC0EW03.SY2CLRID[OC0EWLIX]
   && OC0EM001.XDMCD[OC0EWLIX] == OC0EW03.XDMCD[OC0EWLIX]
   && OC0EM001.OCASUBOR[OC0EWLIX] == OC0EW03.OCASUBOR[OC0EWLIX]
   && OC0EM001.OC4EXPEC[OC0EWLIX] == OC0EW03.OC4EXPEC[OC0EWLIX])
    return; /* no change from what is on file now*/
  end

    /* check for style change, new style may be a duplicate*/
    /* for this suborder, and a warning will have to be shown*/

  if (OC0EM001.SY1STNBR[OC0EWLIX] != OC0EW03.SY1STNBR[OC0EWLIX]
   || OC0EM001.SY2CLRID[OC0EWLIX] != OC0EW03.SY2CLRID[OC0EWLIX]
   || OC0EM001.XDMCD[OC0EWLIX] != OC0EW03.XDMCD[OC0EWLIX])
    OC0EW01.OC0EWDUP = "N";
  end

  if (OC0EM001.OC0EMCMD[OC0EWLIX] != " ") /* If line command not blank*/
    if (OC0EM001.OC0EMCMD[OC0EWLIX] != "D") /* only valid value is 'D'*/
      set OC0EM001.OC0EMCMD[OC0EWLIX] cursor, bold;
      converseLib.validationFailed(086); /* 'Enter 'D' to delete...'*/
      OC0EW03.OCAMSGNO[OC0EWLIX] = 086; /* Save msg for line*/
      OC0EW01.OC0EWERR = "Y"; /* Turn on edit error flag*/
      OC0EW03.OC0EWCMD[OC0EWLIX] = "Y";
                                   /* Turn on line cmd error flag*/
      return; /* Don't do any more edits*/
    else
      if (OC0EM001.XDTCD[OC0EWLIX] == " ") /* If no discrepancy on line*/
        set OC0EM001.OC0EMCMD[OC0EWLIX] cursor, bold;
        converseLib.validationFailed(087); /* 'No dscrp to delete...'*/
        OC0EW03.OCAMSGNO[OC0EWLIX] = 087; /* Save msg for line*/
        OC0EW01.OC0EWERR = "Y"; /* Turn on edit error flag*/
        OC0EW03.OC0EWCMD[OC0EWLIX] = "Y";
                                   /* Turn on line cmd err flag*/
        return; /* Don't do any more edits*/
      else
        OC0EW03.OC0EWCMD[OC0EWLIX] = "N"; /* No line cmd error*/
        OC0EW03.OCAMSGNO[OC0EWLIX] = 0; /* No error this line*/
        return; /* Everything OK to delete this dscrp - no more editing*/
      end
    end
  end

  if (OC0EM001.SY1STNBR[OC0EWLIX] > " ") /* If style number is entered*/
    if (OC0EM001.SY2CLRID[OC0EWLIX] == " ") /* If color id is blank*/
      OC0EM001.SY2CLRID[OC0EWLIX] = "00 "; /* Init color id*/
    end
    if (OC0EM001.XDMCD[OC0EWLIX] == " ") /* If dimension is blank*/
      OC0EM001.XDMCD[OC0EWLIX] = "00"; /* Init dimension*/
    end
  end

   /* Initialize WS fields associated with the line*/

  OC0EW03.OC0EWXER[OC0EWLIX] = "N"; /* XDT error flag (line)*/
  OC0EW03.OCASTYFL[OC0EWLIX] = "N"; /* Style error flag (line)*/
  OC0EW03.OCASUBFL[OC0EWLIX] = "N"; /* Subord error flag (line)*/
  OC0EW03.OCAEXPFL[OC0EWLIX] = "N"; /* Expect val error flag (line)*/
  OC0EW03.OCADUPFL[OC0EWLIX] = " "; /* Dup style error flag (line)*/
  OC0EW03.KUIPRDID[OC0EWLIX] = " "; /* Line cust prod id*/
  OC0EW03.OC4ACTUA[OC0EWLIX] = " "; /* Line actual value*/
  OC0EW03.OP2CPLNB[OC0EWLIX] = 0; /* Line PO line nbr*/
  OC0EW03.OP1CUNDT[OC0EWLIX] = 0; /* Line need date*/
  OC0EW03.OCAMSGNO[OC0EWLIX] = 0; /* Line message nbr*/

  if (OC0EM001.XDTCD[OC0EWLIX] == " ") /* If dscrp type is blank*/
    if (OC0EM001.SY1STNBR[OC0EWLIX] > " " /* and any other field on*/
     || OC0EM001.SY2CLRID[OC0EWLIX] > " " /* the line is entered*/
     || OC0EM001.XDMCD[OC0EWLIX] > " "    
     || OC0EM001.OCASUBOR[OC0EWLIX] > " " 
     || OC0EM001.OC4EXPEC[OC0EWLIX] > " ")
      converseLib.validationFailed(040); /* 'Enter dscrp type to add...'*/
      set OC0EM001.XDTCD[OC0EWLIX] cursor, bold;
      OC0EW03.OCAMSGNO[OC0EWLIX] = 040; /* Save msg for line*/
      OC0EW01.OC0EWERR = "Y"; /* Turn on edit error flag*/
      OC0EW03.OC0EWXER[OC0EWLIX] = "Y";
                                   /* Turn on XDT line error flag*/
    else
      OC0EM001.OC4ACTUA[OC0EWLIX] = " "; /* Blank out actual value*/
    end
  else /* Dscrp type is entered*/
    OC0ES64(); /* Validate dscrp type*/
  end

  if (OC0EW03.OCAMSGNO[OC0EWLIX] == 0 /* If no line error so far*/
   && OC0EM001.XDTCD[OC0EWLIX] != " ") /* and there's a dscrp on line*/
    OC0ES65(); /* Call edit module for line*/
  end

end // end OC0ES62

// Validate discrepancy code
Function OC0ES64()
   /* Make sure discrepancy type is active entry*/
   /* in XDTTBL.*/
   /* -------------------------------------------------*/

  sysVar.arrayIndex = 1; /* Init EZETST*/

  if (OC0EM001.XDTCD[OC0EWLIX] in XDTTBL.XDTCD) /* If code in table*/
    if (XDTTBL.XXXSTAT[sysVar.arrayIndex] == "A") /* and active*/
      if (OCWREC.XOSCD == "XL" /* order is cancelled*/
       && OC0EM001.XDTCD[OC0EWLIX] != "XL") /* discrepancy type not xl*/
        converseLib.validationFailed(101); /* only XL valid for..*/
        OC0EW03.OCAMSGNO[OC0EWLIX] = 101; /* Save msg for line*/
        OC0EW01.OC0EWERR = "Y"; /* Turn on edit error flag*/
        OC0EW03.OC0EWXER[OC0EWLIX] = "Y";
        set OC0EM001.XDTCD[OC0EWLIX] cursor, bold; /* Highlight dscrp type*/
      end
    else
      converseLib.validationFailed(041); /* 'Dscrp type not active...'*/
      OC0EW03.OCAMSGNO[OC0EWLIX] = 041; /* Save msg for line*/
      OC0EW01.OC0EWERR = "Y"; /* Turn on edit error flag*/
      OC0EW03.OC0EWXER[OC0EWLIX] = "Y";
                                   /* Turn on line XDT error flag*/
      set OC0EM001.XDTCD[OC0EWLIX] cursor, bold; /* Highlight dscrp type*/
    end
  else
    converseLib.validationFailed(042); /* 'Invalid dscrp type..'*/
    OC0EW03.OCAMSGNO[OC0EWLIX] = 042; /* Save msg for line*/
    OC0EW01.OC0EWERR = "Y"; /* Turn on edit error flag*/
    OC0EW03.OC0EWXER[OC0EWLIX] = "Y"; /* Turn on line XDT error flag*/
    set OC0EM001.XDTCD[OC0EWLIX] cursor, bold; /* Highlight dscrp type*/
  end

end // end OC0ES64

// Call OC5000 edit for line
Function OC0ES65()
   /* Call OC5000 discrepancy type edit routine and*/
   /* process returned information.*/
   /* -----------------------------------------------*/

   /* Set up pass record parameters*/

  set OCAREC empty; /* Init pass record*/
  OCAREC.OP1PARTN = OCWREC.OP1PARTN; /* Part char*/
  OCAREC.OP1CUOID = OCWREC.OCWCUOID; /* Cust order id*/
  OCAREC.OCWSYSID = OCWREC.OCWSYSID; /* OP/OB system id*/
  OCAREC.XDTCD = OC0EM001.XDTCD[OC0EWLIX]; /* Dscrp type code*/
  OCAREC.SY1STNBR = OC0EM001.SY1STNBR[OC0EWLIX]; /* Style nbr*/
  OCAREC.SY2CLRID = OC0EM001.SY2CLRID[OC0EWLIX]; /* Color id*/
  OCAREC.XDMCD = OC0EM001.XDMCD[OC0EWLIX]; /* Dimension code*/
  OCAREC.OC4EXPEC = OC0EM001.OC4EXPEC[OC0EWLIX]; /* Expected value*/
  if (OC0EM001.OCASUBOR[OC0EWLIX] == " ") /* If sub-ord reference is blank*/
    OCAREC.OCASUBOR = "0000"; /* Init sub-ord ref to zero*/
  else
    OCAREC.OCASUBOR = OC0EM001.OCASUBOR[OC0EWLIX]; /* Sub order ref*/
  end

  try
    call "OC5000" (OCAREC) {isNoRefresh = yes, isExternal = yes};
  end /* Call edit module*/

   /* Check return code*/

  if (OCAREC.OCARTNCD != 0) /* If a non-zero return code*/
    SQLCA.VAGen_SQLCODE = OCAREC.OCARTNCD;
    if (OCAREC.OCARTNCD == -911) /* DB busy - posted by OC5000*/
      return; /* Handled above*/
    else
      set TA1REC empty;
      set TAEREC empty;
      TA1REC.TA1LOCAT[1] = "OC0ES65"; /* Stmt group*/
      TA1REC.TA1LOCAT[2] = "OC5000"; /* Subroutine called*/
      OC0EW01.OC0EWKPA = OC0EM001.XDTCD[OC0EWLIX]; /* Dscrp type*/
      OC0EW01.OC0EWKPB = OC0EM001.OCWCUOID; /* Order#*/
      OC0EW01.OC0EWKPC = OC0EM001.SY1STNBR[OC0EWLIX]; /* Style*/
      OC0EW01.OC0EWKPD = OC0EM001.SY2CLRID[OC0EWLIX]; /* Color*/
      TAEREC.TAEDESC1 = OC0EW01.OC0EWKY1; /* error key*/
      TAEREC.TAEDESC2 = "BAD RETURN FROM OC5000 - SEE OC5000 POST";
      XS0ASNR(); /* non DB2 post, no rollback, exit appl*/
    end
  end

   /* ------------------------------------------------------------*/
   /* If you get this far, you got a zero return code from OC5000*/
   /* ------------------------------------------------------------*/

   /* Multiple edit errors can appear on a line, so each flag is*/
   /* checked and the cursor is placed on the last field (right*/
   /* to left) found to be in error.*/

  if (OCAREC.OCAMSGNO > 0) /* If line contains an edit error*/
    if (OCAREC.OCAMSGNO == 9999)
      converseLib.validationFailed();
    else
      converseLib.validationFailed(OCAREC.OCAMSGNO);
    end /* Move msg returned to map msg*/
    OC0EW01.OC0EWERR = "Y"; /* Turn on edit error flag*/
    OC0EW03.OCAMSGNO[OC0EWLIX] = OCAREC.OCAMSGNO; /* Save line msg*/
    if (OCAREC.OCAEXPFL == "Y") /* If expected value error detected*/
      set OC0EM001.OC4EXPEC[OC0EWLIX] cursor, bold;
      OC0EW03.OCAEXPFL[OC0EWLIX] = "Y"; /* Expect val line error*/
    end
    if (OCAREC.OCASUBFL == "Y") /* If sub order ref error detected*/
      set OC0EM001.OCASUBOR[OC0EWLIX] cursor, bold;
      OC0EW03.OCASUBFL[OC0EWLIX] = "Y"; /* Subord line error*/
    end
    if (OCAREC.OCASTYFL == "Y") /* If style error detected*/
      OC0EW03.OCASTYFL[OC0EWLIX] = "Y"; /* Style line error*/
      set OC0EM001.SY1STNBR[OC0EWLIX] cursor, bold;
      set OC0EM001.SY2CLRID[OC0EWLIX] bold;
      set OC0EM001.XDMCD[OC0EWLIX] bold;
    end
  end
   /* ------------------------------------------------------*/
   /* Check for style appears more than once on a single*/
   /* sub-order*/
   /* ------------------------------------------------------*/
  if (OCAREC.OCADUPFL == "Y") /* Dup style on single suborder*/
    if (OC0EW01.OC0EWDUP == "N") /* warning has not been displayed*/
      OC0EW01.OC0EWDUP = "Y"; /* set flag to force warning display*/
    end
    OC0EWMP1 = "WARNING - PRODUCT ON SUBORD MO";
    OC0EWMP2 = "RE THAN ONCE. CHECK HIGHLIGHTE";
    OC0EWMP3 = "D ACTUAL VALUE.";
    OC0EM001.CAMSG = OC0EW01.OC0EWMS2; /* Dup style error*/
    set OC0EM001.OC4ACTUA[OC0EWLIX] bold;
    OC0EW03.OCADUPFL[OC0EWLIX] = "Y"; /* Save error*/
  end
   /* ------------------------------------------------------*/
   /* Move the fields returned from the edit module*/
   /* to the map and the WS save area (OC0eW03), whether*/
   /* there were errors found on the line or not.*/
   /* ------------------------------------------------------*/
  OC0EM001.OC4ACTUA[OC0EWLIX] = OCAREC.OC4ACTUA;
                                   /* Actual value - map*/
  OC0EW03.KUIPRDID[OC0EWLIX] = OCAREC.KUIPRDID; /* Cust prod id*/
  OC0EW03.OP2CPLNB[OC0EWLIX] = OCAREC.OP2CPLNB; /* PO line nbr*/
  OC0EW03.OP1CUNDT[OC0EWLIX] = OCAREC.OP1CUNDT; /* Need date*/
  OC0EW03.OCAWHFND[OC0EWLIX] = OCAREC.OCAWHFND; /* Where found ind*/

end // end OC0ES65

// Refresh map from orig recs
Function OC0ES66()
   /* Restore the map from the copy of the*/
   /* original records saved in OC0EW03*/
   /* -----------------------------------------*/

  OC0EW01.OC0EWLIX = 1; /* Set line subscript to 1*/

  while (OC0EW01.OC0EWLIX <= OC0EW03.OC0EWDCT)
    OC0EM001.OC0EMCMD[OC0EWLIX] = OC0EW03.OC0EMCMD[OC0EWLIX];
    OC0EM001.XDTCD[OC0EWLIX] = OC0EW03.XDTCD[OC0EWLIX];
    OC0EM001.SY1STNBR[OC0EWLIX] = OC0EW03.SY1STNBR[OC0EWLIX];
    OC0EM001.SY2CLRID[OC0EWLIX] = OC0EW03.SY2CLRID[OC0EWLIX];
    OC0EM001.XDMCD[OC0EWLIX] = OC0EW03.XDMCD[OC0EWLIX];
    OC0EM001.OCASUBOR[OC0EWLIX] = OC0EW03.OCASUBOR[OC0EWLIX];
    OC0EM001.OC4EXPEC[OC0EWLIX] = OC0EW03.OC4EXPEC[OC0EWLIX];
    OC0EM001.OC4ACTUA[OC0EWLIX] = OC0EW03.OC0EWOGA[OC0EWLIX];
    OC0EW01.OC0EWLIX = OC0EW01.OC0EWLIX + 1; /* Increment line*/
  end

  converseLib.validationFailed(090); /* Screen refreshed*/

end // end OC0ES66

// TA0050 - Write TS
Function OC0ES70()
   /* Write current map lines and copy of original*/
   /* records to temp storage.*/
   /* -----------------------------------------------------------*/

  set TA5REC empty;
  TA5REC.TA5APPID = "OC0E"; /* appl identification*/
  TA5REC.TA5FNCCD = "A"; /* function code*/
  OC0EW02.OC0EWTSL = 2232; /* length of record*/

  call "TA0050" (OC0EW02, TA5REC) {isNoRefresh = yes, isExternal = yes}; /* temp storage subroutine*/

  if (TA5REC.TA5RTNCD == 0)
    set OC0EW02 empty; /* reinitialize record*/
  else
    TA1REC.TA1LOCAT[1] = "OC0ES70";
    TA1REC.TA1LOCAT[2] = "TA0050"; /* io mod called*/
    TA1REC.TA1LOCAT[3] = TA5REC.TA5RTNCD; /* return code*/
    TA1REC.TA1TBLKE = OC0EW02.OC0EWTSR[1]; /* first row, first rec*/
    TAEREC.TAEDESC1 = TA5REC.TA5DATA; /* subroutine parms*/
    XS0ASNR(); /* post, no rollback, non db2, exit*/
  end

end // end OC0ES70

// TA0050 - Purge TS
Function OC0ES72()
   /* This statement group purges all temp storage*/
   /* for this application (OC0E).*/
   /* -------------------------------------------------------*/

  set TA5REC empty;
  TA5REC.TA5APPID = "OC0E"; /* appl identification*/
  TA5REC.TA5FNCCD = "P"; /* function code*/
  call "TA0050" (OC0EW02, TA5REC) {isNoRefresh = yes, isExternal = yes}; /* temp storage subroutine*/

  if (TA5REC.TA5RTNCD == 0)
     /* next sentence*/
  else
    TA1REC.TA1LOCAT[1] = "OC0ES72";
    TA1REC.TA1LOCAT[2] = "TA0050"; /* io mod called*/
    TA1REC.TA1LOCAT[3] = TA5REC.TA5RTNCD; /* return code*/
    TAEREC.TAEDESC1 = TA5REC.TA5DATA; /* subroutine parms*/
    TAEREC.TAEDESC1 = "TEMP STORAGE PURGE FAILED";
    XS0ASNP(); /* post,  no rollback, non db2*/
  end

end // end OC0ES72

// Check to delete letter header
Function OC0ES73()
   /* If all discrepancies on this map were deleted,*/
   /* check to see if there are any remaining discrepancies*/
   /* or comments for this letter. If not, go ahead and*/
   /* delete the letter header.*/
   /* -------------------------------------------------------*/

  OC0EW01.OC0EWLTR = "N"; /* letter header delete switch*/
  OC0ES74(); /* Find a count of remaining discrepancies*/

  if (OCDREC.OCDCOUNT > 0 /* If there are still discrepancies*/
   || SQLCA.VAGen_SQLCODE == -911) /* or DB busy*/
    return; /* Don't delete letter header - GOBACK*/
  end

   /* If we get this far, there are no remaining discrepancies*/
   /* for the current letter.*/

  OC0ES75(); /* Find a count of remaining comments*/

  if (OCFREC.OCFCOUNT > 0 /* If there are still comments*/
   || SQLCA.VAGen_SQLCODE == -911) /* or DB busy*/
    return; /* Don't delete letter header - GOBACK*/
  end

   /* If we get this far, there are not any discrepancies OR any*/
   /* comments remaining for the current letter. Go ahead and*/
   /* and delete the header.*/

  set SQLCA empty;
  set OC1REC empty;
  OC1REC.OP1CUOID = OCWREC.OCWCUOID; /* Order number*/
  OC1REC.OP1PARTN = OCWREC.OP1PARTN; /* Part char*/
  OC1REC.OC1LTRNB = OCWREC.OCWCULTR; /* Letter number*/

  call "IO5850" ("D ", SQLCA, OC1REC) {isNoRefresh = yes, isExternal = yes};

   /* Check return code*/

  if (SQLCA.VAGen_SQLCODE == 0)
    OC0EW01.OC0EWLTR = "Y"; /* letter header delete switch*/
  else
    TA1REC.TA1LOCAT[1] = "OC0ES73"; /* stmt group*/
    TA1REC.TA1LOCAT[2] = "IO5850"; /* i/o mod*/
    TA1REC.TA1LOCAT[3] = "D "; /* transaction*/
    OC0EW01.OC0EWKY1 = " "; /* Init error key*/
    OC0EW01.OC0EWKPA = OCWREC.OP1PARTN; /* part char*/
    OC0EW01.OC0EWKPB = OCWREC.OCWCUOID; /* order number*/
    OC0EW01.OC0EWKPC = OCWREC.OCWCULTR; /* letter number*/
    TA1REC.TA1TBLKE = OC0EW01.OC0EWKY1; /* error key*/
    TA1REC.TA1DBASE = "DORDC"; /* database name*/
    TA1REC.TA1TBLVU = "VLETTR01"; /* database view name*/
    if (SQLCA.VAGen_SQLCODE == -911) /* timed out*/
      XS0ASDL(); /* Post, rollback and come back*/
      converseLib.validationFailed(006); /* DB busy*/
      OC0EW01.OC0EWERR = "Y"; /* Turn on error flag*/
    else
      XS0ASDR(); /* Post, rollback, exit*/
    end
  end

end // end OC0ES73

// IO5880 - Find remaining dscrps
Function OC0ES74()
   /* Get a count of the remaining discrepancies*/
   /* the current order number/letter number.*/
   /* ------------------------------------------------*/

  set SQLCA empty;
  set OCDREC empty; /* Init pass record*/
  OCDREC.OCDTASK = "SC"; /* Select count function*/
  OC4REC.OP1CUOID = OCWREC.OP1CUOID; /* Order number*/
  OC4REC.OP1PARTN = OCWREC.OP1PARTN; /* Part char*/
  OC4REC.OC1LTRNB = OCWREC.OCWCULTR; /* Letter number*/

  call "IO5880" (OCDREC, SQLCA, OC4REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
     /* OK - next sentence - count in OCDREC.OCDCOUNT*/
  else
    TA1REC.TA1LOCAT[1] = "OC0ES74"; /* stmt group*/
    TA1REC.TA1LOCAT[2] = "IO5880"; /* i/o mod*/
    TA1REC.TA1LOCAT[3] = "SC"; /* function*/
    OC0EW01.OC0EWKY2 = " "; /* Init error key*/
    OC0EW01.OC0EWKPA = OCWREC.OP1PARTN; /* Error part char*/
    OC0EW01.OC0EWKPB = OCWREC.OCWCUOID; /* Error order nbr key*/
    OC0EW01.OC0EWKPC = OCWREC.OCWCULTR; /* Error letter nbr key*/
    TA1REC.TA1TBLKE = OC0EW01.OC0EWKY2; /* Formatted error key*/
    TA1REC.TA1DBASE = "DORDC"; /* database name*/
    TA1REC.TA1TBLVU = "VDSCRP01"; /* database view name*/
    if (SQLCA.VAGen_SQLCODE == -911) /* timed out*/
      XS0ASDP(); /* Post and return*/
      VGVar.handleSysLibraryErrors = 0;
      sysLib.rollback(); /* Rollback updates*/
      converseLib.validationFailed(006); /* DB busy*/
      OC0EW01.OC0EWERR = "Y"; /* Turn on error flag*/
    else
      COMMAREA.CAMSG = "DATA PROBLEM - TRY AGAIN LATER";
      XS0ASDC(); /* Post and exit*/
    end
  end

end // end OC0ES74

// IO5870 - Find remaining comnts
Function OC0ES75()
   /* GET OC0ES74*/
   /* Get a count of the remaining discrepancies*/
   /* the current order number/letter number.*/
   /* ------------------------------------------------*/

  set SQLCA empty;
  set OCFREC empty; /* Init pass record*/
  OCFREC.OCFTASK = "SC"; /* Select count function*/
  OC3REC.OP1CUOID = OCWREC.OP1CUOID; /* Order number*/
  OC3REC.OP1PARTN = OCWREC.OP1PARTN; /* Part char*/
  OC3REC.OC1LTRNB = OCWREC.OCWCULTR; /* Letter number*/

  call "IO5870" (OCFREC, SQLCA, OC3REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
     /* OK - next sentence - count will be in OCFREC.OCFCOUNT*/
  else
    TA1REC.TA1LOCAT[1] = "OC0ES75"; /* stmt group*/
    TA1REC.TA1LOCAT[2] = "IO5870"; /* i/o mod*/
    TA1REC.TA1LOCAT[3] = "SC"; /* function*/
    OC0EW01.OC0EWKY2 = " "; /* Init error key*/
    OC0EW01.OC0EWKPA = OCWREC.OP1PARTN; /* Error part char*/
    OC0EW01.OC0EWKPB = OCWREC.OCWCUOID; /* Error order nbr key*/
    OC0EW01.OC0EWKPC = OCWREC.OCWCULTR; /* Error letter nbr key*/
    TA1REC.TA1TBLKE = OC0EW01.OC0EWKY2; /* Formatted error key*/
    TA1REC.TA1DBASE = "DORDC"; /* database name*/
    TA1REC.TA1TBLVU = "VOCCMT01"; /* database view name*/
    if (SQLCA.VAGen_SQLCODE == -911) /* timed out*/
      XS0ASDP(); /* Post and return*/
      VGVar.handleSysLibraryErrors = 0;
      sysLib.rollback(); /* Rollback updates*/
      converseLib.validationFailed(006); /* DB busy*/
      OC0EW01.OC0EWERR = "Y"; /* Turn on error flag*/
    else
      COMMAREA.CAMSG = "DATA PROBLEM - TRY AGAIN LATER";
      XS0ASDC(); /* Post and exit*/
    end
  end

end // end OC0ES75

// Update/delete discrepancies
Function OC0ES80()

   /* Process updates/deletes. Only process lines*/
   /* which have been changed*/
   /* Updates are accomplished by doing a delete/add*/
   /* because a the discrepancy entered on a map line*/
   /* may generate more than one discrepancy insert.*/
   /* ---------------------------------------------------*/


  OC0ES84(); /* Get the last discrepancy number*/

  OC0EW01.OC0EWERR = "N"; /* Init error flag*/

   /* Check line to see if there is an update or delete*/
   /* to process.*/

  OC0EW01.OC0EWLIX = 1; /* Set subscript to 1*/

  while (OC0EW01.OC0EWLIX <= OC0EW03.OC0EWDCT /* For each filled line*/
   && OC0EW01.OC0EWERR == "N")
    if (OC0EM001.OC0EMCMD[OC0EWLIX] == " "                        /* Line command not entered*/
     && OC0EM001.XDTCD[OC0EWLIX] == OC0EW03.XDTCD[OC0EWLIX]       /* and no*/
     && OC0EM001.SY1STNBR[OC0EWLIX] == OC0EW03.SY1STNBR[OC0EWLIX] 
     /* fields*/
     && OC0EM001.SY2CLRID[OC0EWLIX] == OC0EW03.SY2CLRID[OC0EWLIX] /* chgd*/
     && OC0EM001.XDMCD[OC0EWLIX] == OC0EW03.XDMCD[OC0EWLIX]       
     && OC0EM001.OCASUBOR[OC0EWLIX] == OC0EW03.OCASUBOR[OC0EWLIX] 
     && OC0EM001.OC4EXPEC[OC0EWLIX] == OC0EW03.OC4EXPEC[OC0EWLIX])
      /* AND OC0EM001.OC4ACTUA(OC0EWLIX) = OC0EW03.OC4ACTUA(OC0EWLIX)*/
       /* Skip this line*/
    else
      OC0EW01.OC0EWCCT = OC0EW01.OC0EWCCT + 1; /* Increment change count*/
      OC0ES89(); /* Delete discrepancy on line*/
      if (OC0EM001.OC0EMCMD[OC0EWLIX] == " ") /* If not delete function*/
        if (SQLCA.VAGen_SQLCODE == 0 /* and a successful delete was executed*/
         || SQLCA.VAGen_SQLCODE == 100)
          OC0ES85();
                                   /* Do inserts for for update - this line*/
        end
      end
    end
    OC0EW01.OC0EWLIX = OC0EW01.OC0EWLIX + 1; /* Increment subscript*/
  end

  if (OC0EW01.OC0EWERR == "N") /* Inserts all okay*/
    if (OC0EW01.OC0EWCCT > 0) /* If dscrps were updated*/
      OC0EW01.OC0EWTXT = " DISCREPANCY UPDATE ";
      OC0EW01.OC0EWCNT = "COMPLETE            ";
      COMMAREA.CAMSG = OC0EW01.OC0EWMSG;
    end
    OC0EW01.OC0EWDIX = 1; /* Set dscrp array subs to 1*/
    while (OC0EW01.OC0EWDIX <= 15)
      OCWREC.OC4DSCPN[OC0EWDIX] = 0; /* Reinit dscrp array*/
      OC0EW01.OC0EWDIX = OC0EW01.OC0EWDIX + 1;
    end
  else
     /* next sentence*/
     /* a -911 was encounterd*/
     /* screen is reconversed as for errors*/
  end


end // end OC0ES80

// IO5850 - Get last dscpr number
Function OC0ES84()
   /* Get the last discrepancy number used for*/
   /* the current order number/letter number.*/
   /* ------------------------------------------------*/

  set SQLCA empty;
  set OCDREC empty; /* Init pass record*/
  OCDREC.OCDTASK = "SM"; /* Select max function*/
  OC4REC.OP1CUOID = OCWREC.OP1CUOID; /* Order number*/
  OC4REC.OP1PARTN = OCWREC.OP1PARTN; /* Part char*/
  OC4REC.OC1LTRNB = OCWREC.OCWCULTR; /* Letter number*/

  call "IO5880" (OCDREC, SQLCA, OC4REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    if (OCDREC.OCDIND < 0) /* No discrepancies for letter*/
      OC0EW01.OC4DSCPN = 0; /* Set discrepancy number to 0*/
    else
      OC0EW01.OC4DSCPN = OC4REC.OC4DSCPN; /* Set dscrp# to returned#*/
    end
  else
    TA1REC.TA1LOCAT[1] = "OC0ES84"; /* stmt group*/
    TA1REC.TA1LOCAT[2] = "IO5880"; /* i/o mod*/
    TA1REC.TA1LOCAT[3] = "SM"; /* function*/
    OC0EW01.OC0EWKY2 = " "; /* Init error key*/
    OC0EW01.OC0EWKPA = OCWREC.OP1PARTN; /* Error part char*/
    OC0EW01.OC0EWKPB = OCWREC.OCWCUOID; /* Error order nbr key*/
    OC0EW01.OC0EWKPC = OCWREC.OCWCULTR; /* Error letter nbr key*/
    TA1REC.TA1TBLKE = OC0EW01.OC0EWKY2; /* Formatted error key*/
    TA1REC.TA1DBASE = "DORDC"; /* database name*/
    TA1REC.TA1TBLVU = "VDSCRP01"; /* database view name*/
    if (SQLCA.VAGen_SQLCODE == -911) /* timed out*/
      XS0ASDP(); /* Post and return*/
      VGVar.handleSysLibraryErrors = 0;
      sysLib.rollback(); /* Rollback updates*/
      converseLib.validationFailed(006); /* DB busy*/
      OC0EW01.OC0EWERR = "Y"; /* Turn on error flag*/
    else
      COMMAREA.CAMSG = "DATA PROBLEM - TRY AGAIN LATER";
      XS0ASDC(); /* Post and exit*/
    end
  end

end // end OC0ES84

// Build dscprs for map line
Function OC0ES85()
   /* Insert discrepancies for one map line.*/
   /* The discrepancy entered on the line may*/
   /* apply to one style, all styles for a*/
   /* suborder, or the order as a whole.*/
   /* -------------------------------------------*/

  if (OC0EM001.XDTCD[OC0EWLIX] == " ") /* If no discrepancy on line*/
    return; /* skip*/
  end

   /* Style level discrepancy*/

  if (OC0EM001.SY1STNBR[OC0EWLIX] != " ") /* If style is entered*/
    set OC4REC empty; /* Init record*/
    OC4REC.OC4STYFL = "N"; /* All styles flag set to no*/
    OC4REC.SY1STNBR = OC0EM001.SY1STNBR[OC0EWLIX]; /* Style*/
    OC4REC.SY2CLRID = OC0EM001.SY2CLRID[OC0EWLIX]; /* Color*/
    OC4REC.XDMCD = OC0EM001.XDMCD[OC0EWLIX]; /* Dim*/
    OC4REC.KUIPRDID = OC0EW03.KUIPRDID[OC0EWLIX]; /* Cust prod id*/
    OC4REC.OP1CUNDT = OC0EW03.OP1CUNDT[OC0EWLIX]; /* Need date*/
    OC4REC.OP2CPLNB = OC0EW03.OP2CPLNB[OC0EWLIX]; /* PO line nbr*/
    OC0ES86(); /* Move other fields and insert dscrp*/
    return; /* All done with this line - GOBACK*/
  end

   /* Order level discrepancy*/

  if (OC0EM001.OCASUBOR[OC0EWLIX] == "ALL " /* If dscrp applies to all*/
   || OC0EM001.OCASUBOR[OC0EWLIX] == " ALL" /* styles on the order*/
   || OC0EM001.OCASUBOR[OC0EWLIX] == "A   " /* styles on the order*/
   || OC0EM001.OCASUBOR[OC0EWLIX] == " A  " 
   || OC0EM001.OCASUBOR[OC0EWLIX] == "  A " 
   || OC0EM001.OCASUBOR[OC0EWLIX] == "   A" 
   || OC0EM001.OCASUBOR[OC0EWLIX] == "AL  " 
   || OC0EM001.OCASUBOR[OC0EWLIX] == " AL " 
   || OC0EM001.OCASUBOR[OC0EWLIX] == "  AL")
    set OC4REC empty; /* Init record*/
    OC4REC.OC4STYFL = "Y"; /* All styles flag set to yes*/
    OC0ES86(); /* Move other fields and insert dscrp*/
    return; /* All done with this line - GOBACK*/
  end

   /* If you get this far, the discrepancy*/
   /* applies to all styles on a specific*/
   /* suborder. A discrepancy row is written*/
   /* for each product on the suborder*/
   /* specified, on either OP or OB depending*/
   /* on where the suborder was found.*/

  if (OC0EW03.OCAWHFND[OC0EWLIX] == "OP") /* If the suborder found on OP*/
    OC0ES56(); /* Select OP products for suborder*/
    OC0ES51(); /* Fetch first OP item*/
    while (SQLCA.VAGen_SQLCODE == 0)
      if (OP2REC.OP2LNIST != "XL") /* If product not cancelled*/
        OC0ES87(); /* Build product dscrp from OP*/
      end
      if (SQLCA.VAGen_SQLCODE == 0)
        OC0ES51(); /* Fetch next OP item*/
      end
    end
    if (SQLCA.VAGen_SQLCODE == 100) /* If normal end of items*/
      OC0ES52(); /* Close OP cursor*/
    end
  else /* Else suborder found on OB*/
    OC0ES53(); /* Select OB products for suborder*/
    OC0ES54(); /* Fetch first OB item*/
    while (SQLCA.VAGen_SQLCODE == 0)
      OC0ES88(); /* Build product dscrp from OB*/
      if (SQLCA.VAGen_SQLCODE == 0)
        OC0ES54(); /* Fetch next OB item*/
      end
    end
    if (SQLCA.VAGen_SQLCODE == 100) /* If normal end of items*/
      OC0ES55(); /* Close OB cursor*/
    end
  end
end // end OC0ES85

// IO5880 - Build/insert dscrp
Function OC0ES86()
   /* This statement group fills in the 'generic' fields*/
   /* in the discrepancy record and inserts one discrepancy*/
   /* row.*/
   /* -------------------------------------------------------*/

  OC4REC.OP1PARTN = OCWREC.OP1PARTN; /* Part char*/
  OC4REC.OP1CUOID = OCWREC.OP1CUOID; /* Cust order id*/
  OC4REC.XGPCD = OCWREC.XGPCD; /* GPC*/
  OC4REC.OC1LTRNB = OCWREC.OCWCULTR; /* Letter number*/
  OC4REC.OC4EXPEC = OC0EM001.OC4EXPEC[OC0EWLIX]; /* Expected value*/
  OC4REC.OC4ACTUA = OC0EM001.OC4ACTUA[OC0EWLIX]; /* Acutal value*/
  OC4REC.OC4DORCD = "M"; /* Dscrp origin - Manually added*/
  OC4REC.XXXUSRID = COMMAREA.CAUSERID; /* User ID*/
  OC4REC.ZZZSDT = XX0XWDAT; /* Set up date*/
  OC4REC.ZZZCHGDT = XX0XWDAT; /* Change date*/
  OC4REC.ZZZSTM = XX0XWTIM; /* Set up time*/
  OC4REC.ZZZCHGTM = XX0XWTIM; /* Change time*/

  OC0EW01.OC4DSCPN = OC0EW01.OC4DSCPN + 1; /* Increment dscrp nbr*/
  OC4REC.OC4DSCPN = OC0EW01.OC4DSCPN; /* Move dscrp nbr out*/

  sysVar.arrayIndex = 1;
  if (OC0EM001.XDTCD[OC0EWLIX] in XDTTBL.XDTCD) /* validate dscrp code*/
    OC4REC.XDTCD = XDTTBL.XDTCD[sysVar.arrayIndex];
  else
    set TAEREC empty;
    set TA1REC empty;
    TA1REC.TA1LOCAT[1] = "OC0ES86"; /* Stmt group*/
    TA1REC.TA1TBLKE = OC0EM001.XDTCD[OC0EWLIX]; /* key*/
    TAEREC.TAEDESC1 = "DSCRP TYPE NOT FOUND IN XDTTBL.XDTCD";
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback(); /* rollback updates*/
    XS0ASNR(); /* non-DB2, post, return to menu (OC0M)*/
  end
   /* ----------------------------------*/
     /* Insert discrepancy row*/
   /* ----------------------------------*/
  set SQLCA empty;
  set OCDREC empty; /* Dscrp IO mod pass record*/

  OCDREC.OCDTASK = "A "; /* Add dscrp*/

  call "IO5880" (OCDREC, SQLCA, OC4REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
     /* OK - next sentence*/
  else
    TA1REC.TA1LOCAT[1] = "OC0ES86"; /* stmt group*/
    TA1REC.TA1LOCAT[2] = "IO5880"; /* i/o mod*/
    TA1REC.TA1LOCAT[3] = "A "; /* function*/
    OC0EW01.OC0EWKY1 = " "; /* Init error key*/
    OC0EW01.OC0EWKPA = OCWREC.OP1PARTN; /* part char key*/
    OC0EW01.OC0EWKPB = OCWREC.OCWCUOID; /* order nbr key*/
    OC0EW01.OC0EWKPC = OC4REC.OC1LTRNB; /* letter number*/
    OC0EW01.OC0EWKPD = OC4REC.OC4DSCPN; /* dscrp number*/
    TA1REC.TA1TBLKE = OC0EW01.OC0EWKY1; /* error key*/
    TA1REC.TA1DBASE = "DORDC"; /* database name*/
    TA1REC.TA1TBLVU = "VDSCRP01"; /* database view name*/
    if (SQLCA.VAGen_SQLCODE == -911) /* timed out*/
      VGVar.handleSysLibraryErrors = 0;
      sysLib.rollback(); /* Rollback updates*/
      XS0ASDP(); /* Post and return*/
      converseLib.validationFailed(006); /* DB busy*/
      OC0EW01.OC0EWERR = "Y"; /* Turn on error flag*/
    else /* all other codes - abort*/
      COMMAREA.CAMSG = "DATA PROBLEM - TRY AGAIN LATER";
      XS0ASDC();
    end
  end

end // end OC0ES86

// Build dscrp from OP
Function OC0ES87()
   /* Use fields from the OP item to build a*/
   /* discrepancy row.*/
   /* -------------------------------------------*/

  set OC4REC empty; /* Init dscrp record*/

  OC4REC.OC4STYFL = "N"; /* Set all styles flag to no*/
  OC4REC.OP1CUNDT = OC0EW03.OP1CUNDT[OC0EWLIX]; /* Need date for subord*/
  OC4REC.SY1STNBR = OP2REC.SY1STNBR; /* Style*/
  OC4REC.SY2CLRID = OP2REC.SY2CLRID; /* Color*/
  OC4REC.XDMCD = OP2REC.XDMCD; /* Dimension*/
  OC4REC.KUIPRDID = OP2REC.KUIPRDID; /* Cust prod id*/
  OC4REC.OP2CPLNB = OP2REC.OP2CPLNB; /* PO line nbr*/
  OC0ES86(); /* Fill in rest of fields and insert record*/

end // end OC0ES87

// Build dscrp from OB item
Function OC0ES88()
   /* Use fields from the OB item to build a*/
   /* discrepancy row.*/
   /* -------------------------------------------*/

  set OC4REC empty; /* Init dscrp record*/

  OC4REC.OC4STYFL = "N"; /* Set all styles flag to no*/
  OC4REC.OP1CUNDT = OC0EW03.OP1CUNDT[OC0EWLIX]; /* Need date for subord*/
  OC4REC.SY1STNBR = OB2REC.SY1STNBR; /* Style*/
  OC4REC.SY2CLRID = OB2REC.SY2CLRID; /* Color*/
  OC4REC.XDMCD = OB2REC.XDMCD; /* Dimension*/
  OC4REC.KUIPRDID = OB2REC.CU-CUST-PROD-ID; /* Cust prod id*/
  OC4REC.OP2CPLNB = OB2REC.OP2CPLNB; /* PO line nbr*/
  OC0ES86(); /* Fill in rest of fields and insert record*/

end // end OC0ES88

// IO5880 - delete discrepancy
Function OC0ES89()
   /* Delete one discrpancy*/
   /* -------------------------------------------------------*/

  set SQLCA empty;
  set OCDREC empty; /* Dscrp IO mod pass record*/
   /* Set up delete key*/
  set OC4REC empty; /* Discrepancy record*/
  OC4REC.OP1CUOID = OCWREC.OCWCUOID; /* Order number*/
  OC4REC.OP1PARTN = OCWREC.OP1PARTN; /* Part char*/
  OC4REC.OC4DSCPN = OC0EW03.OC4DSCPN[OC0EWLIX]; /* Dscrp number*/
  OC4REC.OC1LTRNB = OCWREC.OCWCULTR; /* Letter number*/

  OCDREC.OCDTASK = "D "; /* delete discrepancy function*/

  call "IO5880" (OCDREC, SQLCA, OC4REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0
   || SQLCA.VAGen_SQLCODE == 100) /* Already deleted*/
     /* OK - next sentence*/
  else
    TA1REC.TA1LOCAT[1] = "OC0ES89"; /* stmt group*/
    TA1REC.TA1LOCAT[2] = "IO5880"; /* i/o mod*/
    TA1REC.TA1LOCAT[3] = "D "; /* function*/
    OC0EW01.OC0EWKY1 = " "; /* Init error key*/
    OC0EW01.OC0EWKPA = OCWREC.OP1PARTN; /* part char key*/
    OC0EW01.OC0EWKPB = OCWREC.OCWCUOID; /* order nbr key*/
    OC0EW01.OC0EWKPC = OC4REC.OC1LTRNB; /* letter number*/
    OC0EW01.OC0EWKPD = OC4REC.OC4DSCPN; /* dscrp number*/
    TA1REC.TA1TBLKE = OC0EW01.OC0EWKY1; /* error key*/
    TA1REC.TA1DBASE = "DORDC"; /* database name*/
    TA1REC.TA1TBLVU = "VDSCRP01"; /* database view name*/
    if (SQLCA.VAGen_SQLCODE == -911) /* timed out*/
      VGVar.handleSysLibraryErrors = 0;
      sysLib.rollback(); /* Rollback updates*/
      XS0ASDP(); /* Post and return*/
      converseLib.validationFailed(006); /* DB busy*/
      OC0EW01.OC0EWERR = "Y"; /* Turn on error flag*/
    else /* all other codes - abort*/
      COMMAREA.CAMSG = "DATA PROBLEM - TRY AGAIN LATER";
      XS0ASDC();
    end
  end

end // end OC0ES89

// OC0E security
Function OC0ES99()

   /* **** retrieve o/c commarea and check security *****/

    /* this prevents users from entering system using fastpath*/

  OCWREC.OCWGROUP = COMMAREA.CAUSERA; /* get commarea*/


   /* Disallow entry for inquiry-only id's*/

  if (COMMAREA.CACHGFL == "N") /* User is inquiry-only*/
    OC0EW01.OC0EWTXT = "DISCREPANCY CHANGE F";
    OC0EW01.OC0EWCNT = "UNCTION NOT AVAILABLE FOR INQUIRY-ONLY";
    COMMAREA.CAMSG = OC0EW01.OC0EWMSG;
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.commit();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
    
    COMMAREA.CATOAP = "OC0M"; /* Go to OC menu*/
    COMMAREA.CAFROMAP = COMMAREA.CACURRAP;
    COMMAREA.CACURRAP = COMMAREA.CATOAP;
    COMMAREA.CATOAP = " ";
    sysVar.transferName = COMMAREA.CACURRAP;
    transfer to program sysVar.transferName passing COMMAREA;
    XSPF4(); /* Transfer failure*/
    exit program;
  end

   /* The only entry to this application should be via*/
   /* the formatted letter or from the discrepancy code*/
   /* display*/

  if (COMMAREA.CAFROMAP == "OC0B" /* If coming from formatted letter*/
   || COMMAREA.CAFROMAP == "OC0D" /* or discrepancy code display*/
   || COMMAREA.CAFROMAP == "OC0E") /* or this application*/
     /* OK - next sentence*/
  else
    COMMAREA.CAMSG = "ENTER DSCRP CHANGE ONLY FROM FORMATTED LETTER";
    COMMAREA.CATOAP = COMMAREA.CAFROMAP; /* Go back to calling appl*/
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.commit();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
    
    COMMAREA.CATOAP = "OC0M"; /* Go to OC menu*/
    COMMAREA.CAFROMAP = COMMAREA.CACURRAP;
    COMMAREA.CACURRAP = COMMAREA.CATOAP;
    COMMAREA.CATOAP = " ";
    sysVar.transferName = COMMAREA.CACURRAP;
    transfer to program sysVar.transferName passing COMMAREA;
    XSPF4(); /* Transfer failure*/
    exit program;
  end


   /* *************************************************************/
end // end OC0ES99

// Check for DB busy on build
Function OC0ESDB()
   /* If there was a DB busy condition (-911) on*/
   /* the initial map build, restart application*/
   /* from the top.*/
   /* ----------------------------------------------*/

  if (OC0EW01.OC0EWBSY == "Y") /* If DB busy during initial build*/
    OC0ES72(); /* Purge temp storage*/
    XS0AS00(); /* Reinvoke this appl*/
  end

end // end OC0ESDB

// Return to formatted letter
Function OC0ESP6()

    /* Return to Discrepancy Letter Display*/
   /* **********************************************/

  OC0EW01.OC0EWDIX = 1; /* Set dscrp array subs to 1*/
  while (OC0EW01.OC0EWDIX <= 15)
    OCWREC.OC4DSCPN[OC0EWDIX] = 0; /* Reinit dscrp array*/
    OC0EW01.OC0EWDIX = OC0EW01.OC0EWDIX + 1;
  end

  COMMAREA.CAUSERA = OCWREC.OCWGROUP; /* Pass global work record*/

  COMMAREA.CATOAP = "OC0B";

  COMMAREA.CAFROMAP = COMMAREA.CACURRAP;
  COMMAREA.CACURRAP = COMMAREA.CATOAP;
  COMMAREA.CATOAP = " ";
  sysVar.transferName = COMMAREA.CACURRAP;
  transfer to program sysVar.transferName passing COMMAREA;


end // end OC0ESP6

// Process PF Keys
Function OC0ESPF()
   /* PF Key and Fast-path handling*/
   /* -------------------------------------*/

   /* Check for fast-path request*/

  if (OC0EM001.CATOAP != " ") /* Fast path application entered*/
    if (OC0EM001.CATOAP == "OC0D") /* can not fast path to oc0d*/
      OC0EM001.CATOAP = " "; /* intialize to app field*/
      converseLib.validationFailed(99); /* can not fast path to oc0d*/
      OC0EW01.OC0EWERR = "Y"; /* turn on error flag*/
      return; /* converse map*/
    else
      COMMAREA.CATOAP = OC0EM001.CATOAP;
      if (OC0EM001.OC0EMITM != " ") /* Fast path item*/
        COMMAREA.CAITEM = OC0EM001.OC0EMITM;
      end
    end
  end

  if (converseVar.eventKey is enter) /* Check for fast-path request*/
    if (COMMAREA.CATOAP != " ") /* If fast path application entered*/
      OC0ES72(); /* Purge temp storage*/
      COMMAREA.CAUSERA = " ";
      XSEXIT();

      sysVar.transferName = "OC0M";
      transfer to transaction sysVar.transferName passing COMMAREA;
    end
  end


  COMMAREA.CAUSERA = OCWREC.OCWGROUP;


  if (converseVar.eventKey is pf3)
    OC0ES72(); /* purge temp storage*/
    XS0AS03(); /* go to o/c menu*/
    OC0EM001.VAGen_EZEMSG = COMMAREA.CAMSG; /* transfer failed*/
    return; /* converse map*/
  end

  if (converseVar.eventKey is pf4)
    OC0ES72(); /* purge temp storage*/
    XSPF4(); /* go to main menu*/
    OC0EM001.VAGen_EZEMSG = COMMAREA.CAMSG; /* transfer failed*/
    return; /* converse map*/
  end

  if (converseVar.eventKey is pf5)
    OC0ES72(); /* purge temp storage*/
    XS0AS05(); /* go to discrepancy add screen*/
  end

  if (converseVar.eventKey is pf6)
    OC0ES72(); /* purge temp storage*/
    OC0ESP6(); /* go to discrepancy letter screen*/
  end

  if (converseVar.eventKey is pf13)
    OC0ES72(); /* purge temp storage*/
    XS0AS13(); /* go to letter summary*/
    OC0EM001.VAGen_EZEMSG = COMMAREA.CAMSG; /* transfer failed*/
    return; /* converse map*/
  end

  if (converseVar.eventKey is enter
   || converseVar.eventKey is pf12) /* if edit only*/
     /* OR EZEAID IS PF19             ; or refresh request*/
     /* next sentence*/
  else
    converseLib.validationFailed(1); /* invalid pf key*/
    OC0EW01.OC0EWERR = "Y"; /* set error flag*/
  end



end // end OC0ESPF

//*** RECORD=OC0EW01 ****
// *     Application work record for Discrepancy Add Screen
// *     (OC0A)
// *
// *     Csp record: OC0AW01
// *
// ************************************************************
// *                    MAINTENANCE                           *
// ************************************************************
// *
// *    DATE     SIGNON  DESCREPTION
// *  --------   ------  --------------------------------------
// *  11/07/91   TROBER  DELETED OC0EWDEL
// *
// ***********************
Record OC0EW01 type basicRecord
  5 OC0EWGP1 OC0EWGP1 ; 
    10 OC0EWLIX OC0EWLIX ; 
    10 OC0EWDIX OC0EWDIX ; 
    10 OC0EWERR OC0EWERR ; 
    10 OC0EWBSY OC0EWBSY ; 
    10 OC0EWQSF OC0EWQSF ; 
    10 OC0EWDSF OC0EWDSF ; 
    10 OC0EWDUP OC0EWDUP ; 
    10 OC0EWABR OC0EWABR ; 
      15 OC0EWAB1 OC0EWAB1 ; 
      15 OC0EWAB2 OC0EWAB2 ; 
    10 OC4DSCPN OC4DSCPN ; 
    10 OC0EWCCT OC0EWCCT ; 
    10 OC0EWMSG OC0EWMSG ; 
      15 OC0EWTXT OC0EWTXT ; 
      15 OC0EWCNT OC0EWCNT ; 
    10 OC0EWMS2 OC0EWMS2 ; 
      15 OC0EWMP1 OC0EWMP1 ; 
      15 OC0EWMP2 OC0EWMP2 ; 
      15 OC0EWMP3 OC0EWMP3 ; 
    10 OC0EWSID OC0EWSID ; 
    10 OC0EWKY1 OC0EWKY1 ; 
      15 OC0EWKY2 OC0EWKY2 ; 
        20 OC0EWKPA OC0EWKPA ; 
        20 OC0EWKF1 OC0EWKF1 ; 
        20 OC0EWKPB OC0EWKPB ; 
        20 OC0EWKF2 OC0EWKF2 ; 
        20 OC0EWKPC OC0EWKPC ; 
      15 OC0EWKF3 OC0EWKF3 ; 
      15 OC0EWKPD OC0EWKPD ; 
    10 OC0EWLTR OC0EWLTR ; 
end // end OC0EW01

//*** RECORD=OC0EW02 ****
// *     Temporary storage record used to save a copy of the
// *     discrepancy lines on the Discrepancy Add Screen (OC0A)
// *
// *     Csp record: OC0AW02
// *
// *      file name: OC0A
// *
// *      Loaded in: OC0A
// *
// *   Displayed in: OC0A
// *
// *
// *
// ***********************
Record OC0EW02 type basicRecord
  5 OC0EWGP2 OC0EWGP2 ; 
    10 OC0EWTSL OC0EWTSL ; 
    10 OC0EWTSR OC0EWTSR [14] ; 
      15 OC0EMCMD OC0EMCMD ; 
      15 XDTCD XDTCD ; 
      15 SY1STNBR SY1STNBR ; 
      15 SY2CLRID SY2CLRID ; 
      15 XDMCD XDMCD ; 
      15 OCASUBOR OCASUBOR ; 
      15 OC4EXPEC OC4EXPEC ; 
      15 OC4ACTUA OC4ACTUA ; 
    10 OC0EWGP3 OC0EWGP3 ; 
end // end OC0EW02

//*** RECORD=OC0EW03 ****
// *     This area is used to save map line fields and some
// *     additional fields passed back from OC5000 which are
// *     associated with the line, but not on the map.
// *
// *     Csp record: OC0AW03
// *
// *
// *
// ***********************
Record OC0EW03 type basicRecord
  5 OC0EWGP3 OC0EWGP3 ; 
    10 OC0EWDCT OC0EWDCT ; 
    10 OC0EWSAV OC0EWSAV [13] ; 
      15 OC4DSCPN OC4DSCPN ; 
      15 OC0EMCMD OC0EMCMD ; 
      15 XDTCD XDTCD ; 
      15 SY1STNBR SY1STNBR ; 
      15 SY2CLRID SY2CLRID ; 
      15 XDMCD XDMCD ; 
      15 OCASUBOR OCASUBOR ; 
      15 OC4EXPEC OC4EXPEC ; 
      15 OC4ACTUA OC4ACTUA ; 
      15 OC0EWOGA OC0EWOGA ; 
      15 OCAMSGNO OCAMSGNO ; 
      15 OC0EWCMD OC0EWCMD ; 
      15 OC0EWXER OC0EWXER ; 
      15 OCASTYFL OCASTYFL ; 
      15 OCASUBFL OCASUBFL ; 
      15 OCAEXPFL OCAEXPFL ; 
      15 OCADUPFL OCADUPFL ; 
      15 OP2CPLNB OP2CPLNB ; 
      15 KUIPRDID KUIPRDID ; 
      15 OP1CUNDT OP1CUNDT ; 
      15 OCAWHFND OCAWHFND ; 
end // end OC0EW03

// Map line command
DataItem OC0EMCMD char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// 1st char of abbrev
DataItem OC0EWAB1 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// 2nd char of abbrev
DataItem OC0EWAB2 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Used to check for '?' in cd
DataItem OC0EWABR char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// DB busy on build flag
DataItem OC0EWBSY char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Count of dscrp updates
DataItem OC0EWCCT smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Line command error flag
DataItem OC0EWCMD char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Continue msg
DataItem OC0EWCNT char(40)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Discrepancy count
DataItem OC0EWDCT smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Dscrp array subscript
DataItem OC0EWDIX num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// discrepancy entered flag
DataItem OC0EWDSF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Dup style error flag
DataItem OC0EWDUP char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// error flag
DataItem OC0EWERR char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// OC0EW01 GROUP LEVEL
DataItem OC0EWGP1 char(191)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// OC0EW02 GROUP LEVEL
DataItem OC0EWGP2 char(2622)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// OC0AW03 GROUP LEVEL
DataItem OC0EWGP3 char(1666)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Filler 1
DataItem OC0EWKF1 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Filler 2
DataItem OC0EWKF2 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Filler 3
DataItem OC0EWKF3 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Key part A - 2 alpha
DataItem OC0EWKPA char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Key part b - 9 numeric
DataItem OC0EWKPB num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Key part c - 9 numeric
DataItem OC0EWKPC num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Key part d - 4 numeric
DataItem OC0EWKPD num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Formatted error key
DataItem OC0EWKY1 char(27)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// 3-part key
DataItem OC0EWKY2 char(22)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Map line subscript
DataItem OC0EWLIX num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// letter header deleted switch
DataItem OC0EWLTR char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Msg part1
DataItem OC0EWMP1 char(30)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Msg part2
DataItem OC0EWMP2 char(30)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Msg part3
DataItem OC0EWMP3 char(20)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Message area 2
DataItem OC0EWMS2 char(80)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Message area 1
DataItem OC0EWMSG char(60)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Original rec actual value
DataItem OC0EWOGA char(25)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Question mark found flag
DataItem OC0EWQSF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Original rec saved for comp
DataItem OC0EWSAV char(128)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Numeric suborder id
DataItem OC0EWSID num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// temp storage lgth
DataItem OC0EWTSL num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// temp storage row
DataItem OC0EWTSR char(68)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Dscrp confirm text
DataItem OC0EWTXT char(20)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// XDT field error flag
DataItem OC0EWXER char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

