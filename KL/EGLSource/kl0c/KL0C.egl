package kl0c;

import as1.common.ARCCCREF;
import corpcom1.*;
import corpcom3.XPCL002;
import corpcom3.XPCL006;
import corpcom3.XPCL010;
import corpcom3.XPCL011;
import corpcom4.XSENTRY;
import corpcom4.XSPF1;
import corpcom4.XSPF4;
import corpcom4.XSSEGTR;
import corpcom5.COMMAREA;
import corpcom5.ERRSQLCA;
import corpcom6.SQLCA;
import corpx1.XDVTBL;
import corpx1.XGPCD;
import corpx1.XGPTBL;
import corpx1.XOBTBL;
import corpx2.XNXCD;
import corpy2.YATTBL;
import corpy2.YCRCD;
import corpy2.YCSCD1;
import corpy2.YCTCD;
import corpy2.YPSTBL;
import corpy2.YUATBL;
import iv.common.IV0IVCID;
import ku.common.KUCCOID;
import ku.common.KUCREC;
import ku.common.KUMSTRID;
import sm.common.SM1REC;
import sm.common.SM4REC;
import ta.common.TA1REC;
import ta.common.TA2REC;
//*** PROGRAM=KL0C ****
// ************************************************************
//   kl0c   application name
// 
// overview: put spec. overview here
// 
//           give notes or hints for other people to know
//           before reading or maintaining your application.
// 
// maintenance history:
// date      by      rev description of change
// --------  ---     --  --------------------------------------
// 04-10-87  lhughe   0  create model for claims appl using
//                       two screens.
// mm-dd-yy  xxxxxx  ##  ......................................
// 01-31-89  JWOOD    0  ADDED NONCSP OPTION ON CALLS
// 01-31-89  JWOOD    0  ADDED XSSEGTR LOGIC
// 04-24-89  bcourt   1  change XOT to base order type for
//                       sport/casual change.
// 04-24-89  bcourt   1  change XOT to base order type for
// 05-19-89  bcourt   1  DB2 structure changes: CLAREC, KUCREC,
//                       XGPTBL.
// 01-19-90  bcourt   1  DB2 structure changes: KUCrec.
// 06-10-91  twatso      DB2 structure changes: KUCrec regen
//                        only
// 08-08-91  wjohns      Renamed application and commarea
//                        refernces to renamed claims appls.
// 09-16-91  twatso      Renamed sgrps, and procs from cl to kl
//                       regened - to prod later
// 01-13-92  sgorga      set ta1rec, ta2rec empty.
//                       kl0cs33, s34, s35, s45, 001
// 10-11-93  GDECKE      TRANSFER TO KL0A IF INVALID FASTPATH
//                       FROM KL0E, SHOW ERROR MESSAGE.
// 09-09-99  ssank1      Changed map presentation KL0CM001 to
//                       accomodate 4 digit nike ord id.
// 07-23-01  dsinha      Renamed map field 'A/R Ref' as
//                       'SAP Rtn SO Nbr'.
// ************************************************************
// *********************
Program KL0C type textUIProgram //VAGen Info - main text program
  {
  includeReferencedFunctions = yes, allowUnqualifiedItemReferences = yes, 
  throwNrfEofExceptions = yes, handleHardIOErrors = no, V60ExceptionCompatibility = yes, 
  I4GLItemsNullable = no, textLiteralDefaultIsString = no, localSQLScope = yes, 
  msgTablePrefix = "CL00", inputRecord = COMMAREA, segmented = yes
  }

  // Data Declarations
  CL0CW01 CL0CW01; // record
  CL0CW05 CL0CW05; // record
  CL0CW10 CL0CW10; // record
  CLAREC CLAREC; // record
  CLBREC CLBREC; // record
  CLCREC CLCREC; // record
  CLEREC CLEREC; // record
  CLWREC CLWREC; // record
  CLXREC CLXREC; // record
  COMMAREA COMMAREA ; // record
  ERRSQLCA ERRSQLCA; // record
  KUCREC KUCREC; // record
  SM1REC SM1REC; // record
  SM4REC SM4REC; // record
  SQLCA SQLCA; // record
  TA1REC TA1REC; // record
  TA2REC TA2REC; // record

  // VAGen Info - items needed for migration
  VAGen_EZESYS char(8);
  VAGen_EZEREPLY num(1);
  VAGen_EZE_WAIT_TIME bin(9,2);
  VAGen_EZE_ITEMLEN int;

  // Use Declarations
  use XDVTBL {deleteAfterUse = yes}; // table
  use XGPTBL {deleteAfterUse = yes}; // table
  use XOBTBL {deleteAfterUse = yes}; // table
  use YUATBL {deleteAfterUse = yes}; // table
  use YATTBL {deleteAfterUse = yes}; // table
  use YPSTBL {deleteAfterUse = yes}; // table
  use KL0CM.KL0CM001,  // forms
      KL0CM.KL0CM002
   {
    pfKeyEquate = no
  };

  function main()
    // VAGen Info - initialization needed for migration
    VAGen_EZESYS = VGLib.getVAGSysType();
    KL0C000: KL0C000();
    ;
    ;
    exit program;
    ;
    ;
    ;
    KL0C001: KL0C001();
    KL0C050: KL0C050();
    KL0C100: KL0C100();
    KL0C101: KL0C101();
    KL0C110: KL0C110();
    KL0C120: KL0C120();
    KL0C200: KL0C200();
    KL0C201: KL0C201();
    KL0C210: KL0C210();
    KL0C220: KL0C220();
  end // end main
end // end KL0C

// application main logic
Function KL0C000()
   /* ************************************************************/
   /* *   this is the "main logic" for the application.         **/
   /* *                                                         **/
   /* *   xsentry checks to ensure that this application was    **/
   /* *         entered from another csp application.           **/
   /* *                                                         **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  ;
  KL0C001(); /* initilize the application*/
  ;
  KL0CM001.XXXRVNBR = "1"; /* appl maintainence revision number*/
  KL0CM002.XXXRVNBR = "1"; /* appl maintainence revision number*/
  KL0CM001.XXXCURDT = VGVar.currentShortGregorianDate;
  KL0CM002.XXXCURDT = VGVar.currentShortGregorianDate;
  ;
  ;
  CLXREC.CLXEOAF = "N"; /* set end-of-application flag to 'no'*/
  ;
  while (CLXREC.CLXEOAF == "N") /* while not end-of-aplication*/
    KL0C050(); /* process the application screen(s)*/
  end
  ;
  ;
  COMMAREA.CATOAP = "KL0A"; /* in case of trouble*/
  XPCL002(); /* exit application*/
  ;
  ;
  ;
end // end KL0C000

// initialize application
Function KL0C001()
   /* ************************************************************/
   /* *      initialize the application working storage         **/
   /* *                                                         **/
   /* *                                                         **/
   /* *  check if entry thru main menu                          **/
   /* *  initialize maps,records and working storage            **/
   /* *  set screen number,screen name and number of lines      **/
   /* *  possible on each.                                      **/
   /* *                                                         **/
   /* ************************************************************/
   /* MAINTENANCE HISTORY                               **/
   /* 01-13-92  sgorga  Set ta1rec, ta2rec empty.               **/
   /* 10-11-93  GDECKE  EXIT TO KL0A WHEN BAD TRANSFER FROM KL0E**/
   /* **/
   /* ************************************************************/
  ;
  ;
  converseVar.commitOnConverse = 1; /* force db2 to commit on each screen*/
                                   /* converse*/
  VGVar.handleHardIOErrors = 1; /* return control to program if hard db2*/
                                   /* error*/
  ;
  ;
  ;
   /* JAMIT     ;******** TEMP CODE FOR TESTING *************/
  ;
  XSENTRY(); /* check entered thru main menu*/
  XSSEGTR(); /* SET SEGMENTED TRANSACTION ID*/
  XPCL011(); /* claims entry module*/
  ;
     /* put statements here to initalize your working-storage(s),*/
     /* e.g. constants, messages, '-' for dates.*/
  ;
  ;
  set KL0CM001 initial; /* clear out map001*/
  set KL0CM002 initial; /* clear out map002*/
  set KUCREC empty; /* clear out kucrec*/
  set CLBREC empty; /* clear out clbrec*/
  set CLCREC empty; /* clear out clcrec*/
  set CLXREC empty; /* clear out the "common" working*/
                                   /* storage*/
  set SM1REC empty; /* clear out sm1rec*/
  set SM4REC empty; /* clear out sm4rec*/
  set CL0CW05 empty; /* clear out working storage*/
  set CL0CW10 empty; /* clear out working storage*/
  set SQLCA empty; /* clear out sqlca area*/
  set TA1REC empty;
  set TA2REC empty;
  ;
  ;
  CLXREC.CLXEOAF = "N"; /* set application-done-switch to 'no'*/
  ;
   /* MOVE '02' TO CLWREC.CLWSVSEL    ;##########################*/
  if (CLWREC.CLWSVSEL == "02")
    CLXREC.CLXCSCRN = "KL0CM002"; /* set screen name*/
  else
    CLXREC.CLXCSCRN = "KL0CM001"; /* set screen name*/
  end
   /* MOVE '  ' TO CLWREC.CLWSVSEL;*/
  ;
  ;
  CLXREC.CLXSNAME[1] = "KL0CM001"; /* initialize the names of the*/
  CLXREC.CLXSNAME[2] = "KL0CM002"; /* screens used in this appl*/
  ;
  CLXREC.CLXMAXLN[1] = 11; /* max lines on map 1*/
  if (COMMAREA.CAFROMAP == "KL0E")
    CLXREC.CLXARY1X[1] = CLWREC.CLWCLIDX;
    if (CLWREC.CLWCLIDX > 200
     || CLWREC.CLWCLIDX < 1)
      CLWREC.CLWEZMNO = 19;
      COMMAREA.CATOAP = "KL0A";
      XPCL002();
    end
  else
    CLXREC.CLXARY1X[1] = 1; /* start line on map 1*/
  end
  ;
  CLXREC.CLXMAXLN[2] = 13; /* max lines on map 2*/
  if (COMMAREA.CAFROMAP == "KL0E")
    CLXREC.CLXARY1X[2] = CLWREC.CLWCLIDX;
  else
    CLXREC.CLXARY1X[2] = 1; /* start line on map 2*/
  end
  ;
  if (CLWREC.CLWMAPFM == "KL0BM001")
    CLWREC.CLWCL0BX = "1";
  else
    if (CLWREC.CLWMAPFM == "KL0BM002")
      CLWREC.CLWCL0BX = "2";
    else
      if (CLWREC.CLWMAPFM == "KL0BM003")
        CLWREC.CLWCL0BX = "3";
      end
    end
  end
  ;
  CLXREC.CLXARAYX = 1; /* index to array*/
  CLXREC.CLXLINEX = 1; /* index to map line*/
  ;
  ;
  ;
end // end KL0C001

// main cl0% branch control
Function KL0C050()
   /* ************************************************************/
   /* *   control process the application screen(s)             **/
   /* *                                                         **/
   /* *  note that this process is being performed in a         **/
   /* *  "while loop" until the end-of-application flag is set  **/
   /* *  to 'y'.                                                **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0C050"; /* set current process name*/
  ;
  ;
  if (CLXREC.CLXCSCRN in CLXREC.CLXSNAME) /* if current-screen-name is*/
    CLXREC.CLXSCRNX = sysVar.arrayIndex; /* in the screen-array, then set*/
  end /* the screen-index*/
  ;
  ;
  CLXREC.CLXEOSF = "N"; /* set end-of-screen flag to 'no'*/
  CLXREC.CLXBLDSC = "Y"; /* set build screen flag to 'yes'*/
  ;
  ;
  if (CLXREC.CLXSCRNX == 1) /* if screen cl0%m001*/
    while (CLXREC.CLXEOSF == "N") /* while not end-of-screen*/
      KL0C100(); /* process screen cl0%m001*/
    end
  else
    if (CLXREC.CLXSCRNX == 2) /* if screen cl0%m005*/
      while (CLXREC.CLXEOSF == "N") /* while not end-of-screen*/
        KL0C200(); /* process screen cl0%m005*/
      end
    else
      TA1REC.TA1TBLKE = "CLAIMS UNKNOWN SCREEN NAME";
      XPCL010();
    end
  end
  ;
  ;
   /* at this point;*/
       /* if the end-of-application flag (clxeoaf ) = 'n'*/
         /* the perform will return to the top of cl0%050...*/
       /* else*/
         /* the perform will auto return to cl0%000.*/
  ;
  ;
  ;
end // end KL0C050

// converse screen m001
Function KL0C100()
   /* ************************************************************/
   /* *    process screen kl0cm001                              **/
   /* *                                                         **/
   /* *  note - this process is being performed in a            **/
   /* *     "while loop" from cl0c050 until the end-of-screen   **/
   /* *     flag (clxeosfl) is set to 'y'.                      **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0C100"; /* set current process name*/
  ;
  if (CLXREC.CLXERRF != "Y")
    set KL0CM001.SEL[1] cursor;
  end
  if (CLXREC.CLXBLDSC == "Y")
    KL0C101(); /* build screen because new record*/
  end /* to display or pf7/pf8 keyed*/
  ;
  CLXREC.CLXBLDSC = "N"; /* skip build screen next time thru*/
    /* skip build when have errors to show, or pf12 was keyed*/
  ;
  ;
  converse KL0CM001 ;
  ;
  ;
  CLXREC.CLXMSG = " "; /* set non-ezemno error message to*/
                                   /* spaces*/
  CLXREC.CLXERRF = "N"; /* re-set error flag*/
  ;
  ;
    /* may exit appl from this process*/
  ;
  ;
  ;
  CLXREC.CLXLINEX = 1;
  if (CLXREC.CLXARY1X <= 1)
    CLXREC.CLXCURLN = 1;
  else
    if (CLXREC.CLXCURLN == CLWREC.CLWMXIDX)
      /* IF EZEAID IS PF7;*/
      CLXREC.CLXCURLN = CLXREC.CLXARY1X;
      /* ELSE ;*/
      /* CLXREC.CLXCURLN = CLXREC.CLXARY1X + CLXREC.CLXMAXLN(1);*/
      /* END ;*/
    else
      CLXREC.CLXCURLN = CLXREC.CLXARY1X - CLXREC.CLXMAXLN[1];
    end
  end
  if (CLXREC.CLXCURLN < 1)
    CLXREC.CLXCURLN = 1;
  end
  CLWREC.CLWCLIDX = CLXREC.CLXCURLN;
  while (CLXREC.CLXLINEX <= CLXREC.CLXMAXLN[1])
    if (CLWREC.CLWCLIDX <= CLWREC.CLWMXIDX)
      KL0CS21(); /* save selections to array*/
      if (CLXREC.CLXERRF == "Y")
        CLXREC.CLXLINEX = 12;
      end
      CLXREC.CLXLINEX = CLXREC.CLXLINEX + 1;
    else
      CLXREC.CLXLINEX = 12;
    end
  end
  ;
  KL0C110(); /* handle any special entries*/
  ;
  if (KL0CM001 is modified) /* if there were entries*/
    CLXREC.CLXEDITF = "Y"; /* then set do-edits-flag*/
  else
    CLXREC.CLXEDITF = "N"; /* if no entries, then no edits*/
  end
  ;
  if (converseVar.eventKey is enter)
    if (CLXREC.CLXEDITF == "N")
      KL0CS05();
    end
  end
  ;
      /* determine next action*/
  ;
  if (CLXREC.CLXERRF == "Y" /* if screen has errors*/
   || converseVar.eventKey is pf12) /* or user wants to see same screen*/
    CLXREC.CLXBLDSC = "N"; /* do not rebuild screen, just reshow*/
  else
     /* if update sw on*/
       /* cl0cs..                     ; go update data base*/
     /* end*/
    if (converseVar.eventKey is enter)
      CLWREC.CLWCLIDX = 1;
      while (CLWREC.CLWCLIDX <= CLWREC.CLWMXIDX)
        if (CLWREC.CLWSELCD[CLWCLIDX] == "S")
          CLWREC.CLWMAPFM = "KL0CM001";
          set CLAREC empty;
          CLAREC.CLACLMNB = CLWREC.CLWCLMNB[CLWCLIDX];
          COMMAREA.CATOAP = "KL0E";
          XPCL002();
        else
          CLWREC.CLWCLIDX = CLWREC.CLWCLIDX + 1;
        end
      end
      KL0CS05();
      COMMAREA.CATOAP = "KL0B";
      CLXREC.CLXEOSF = "Y";
      XPCL002();
    else
      if (converseVar.eventKey is pf7 /* scroll commands*/
       || converseVar.eventKey is pf8)
      end
    end
  end
  ;
  ;
  ;
   /* at this point;*/
     /* if the end-of-screen flag (clxeosf) is 'n'*/
       /* the perform returns to top of process cl0c100.*/
     /* else*/
       /* the perform returns to cl0c050.*/
  ;
  ;
  ;
end // end KL0C100

// initialize screen CL0CM001
Function KL0C101()
   /* ************************************************************/
   /* *                                                         **/
   /* *                                                         **/
   /* *        this process initializes screen cl0cm001         **/
   /* *  it will read the necessary tables                      **/
   /* *  or will scroll forward or back                         **/
   /* *                                                         **/
   /* *                                                         **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0C101"; /* set current process name*/
  ;
  ;
  if (converseVar.eventKey not pf7 /* do not rebuild top of map*/
   && converseVar.eventKey not pf8) /* for pf7 or pf8*/
     /* build top of screen*/
     /* initialize indexes and pointers for multiple lines*/
    if (CLWREC.CLWEZMNO != 0)
      if (CLWREC.CLWEZMNO == 9999)
        converseLib.validationFailed();
      else
        converseLib.validationFailed(CLWREC.CLWEZMNO);
      end
      CLWREC.CLWEZMNO = 0;
    else
      /* next sentence*/
    end
    KL0CM001.CLWIVCID = CLWREC.IV0IVCID;
    KL0CM001.CLBARREF = CLWREC.ARCREFNB;
    KL0CM001.OP1CUOID = CLWREC.OP1CUOID;
    KL0CM001.OP1NORID = CLWREC.OP1NORID;
    ;
    if (CLWREC.KUCCOID != 0)
      KL0CM001.KUCCOID = CLWREC.KUCCOID;
      KUCREC.KUCCOID = CLWREC.KUCCOID;
    else
      KL0CM001.KUCCOID = CLAREC.KUCCOID;
      KUCREC.KUCCOID = CLAREC.KUCCOID;
    end
    ;
    KL0CS15(); /* read customer table for company name*/
    ;
    if (SQLCA.VAGen_SQLCODE == 0)
      KL0CM001.KUCCONM = KUCREC.KUCCONM;
    end
    ;
    KL0CM001.KUMSTRID = CLWREC.KUMSTRID;
    KL0CM001.XNXCD = CLWREC.XNXCD;
    KL0CM001.CL0CMGPC = CLWREC.XGPCD;
    ;
    if (CLWREC.XGPCD in XGPTBL.XGPCD) /* if in table*/
      KL0CM001.XGPABRV = XGPTBL.XGPABRV[sysVar.arrayIndex];
    end
    ;
    /* below added 4/89*/
    KL0CM001.XDVCD = CLWREC.XDVCD; /* division*/
    ;
    /* below added 4/89*/
    KL0CM001.XSOCD = CLWREC.XSOCD; /* sales office*/
    ;
    /* below added 6-27-88, change xot to xob 4/89*/
    KL0CM001.XOBCD = CLWREC.XOBCD; /* base order type*/
    if (CLWREC.XOBCD in XOBTBL.XOBCD)
      KL0CM001.XOBABRV = XOBTBL.XOBABRV[sysVar.arrayIndex];
    end
    ;
    KL0CM001.YPSCD = CLWREC.YPSCD; /* POD/POS status code*/
    if (CLWREC.YPSCD in YPSTBL.YPSCD)
      KL0CM001.YPSDESC = YPSTBL.YPSDESC[sysVar.arrayIndex];
    end
    /* above added 6-27-88*/
    ;
    KL0CM001.OP1CUPO = CLWREC.OP1CUPO;
    KL0CM001.CLWESTLO = CLWREC.CLWESTLO;
    KL0CM001.CLWESTHI = CLWREC.CLWESTHI;
    CLXREC.XXXWCYMD = CLWREC.CLWSETLO;
    CL0CW01.CL0CWMM = CLXREC.XXXWYY;
    CL0CW01.CL0CWDD = CLXREC.XXXWMM;
    CL0CW01.CL0CWYY = CLXREC.XXXWDD;
    KL0CM001.CLWSETLO = CL0CW01.CL0CWMDY;
    CLXREC.XXXWCYMD = CLWREC.CLWSETHI;
    CL0CW01.CL0CWMM = CLXREC.XXXWYY;
    CL0CW01.CL0CWDD = CLXREC.XXXWMM;
    CL0CW01.CL0CWYY = CLXREC.XXXWDD;
    KL0CM001.CLWSETHI = CL0CW01.CL0CWMDY;
    ;
    CLWREC.CLWCLIDX = 1;
    while (CLWREC.CLWCLIDX <= CLWREC.CLWMXIDX)
      CL0CW05.CLACLMNB[CLWCLIDX] = CLWREC.CLWCLMNB[CLWCLIDX];
      CLBREC.CLACLMNB = CLWREC.CLWCLMNB[CLWCLIDX];
      CLBREC.CLBPMIVC = "Y";
      KL0CS20(); /* select set invoice table*/
      ;
      KL0CS23(); /* select next on invoice table*/
      if (SQLCA.VAGen_SQLCODE == 0)
        CL0CW05.IV0IVCID[CLWCLIDX] = CLBREC.IV0IVCID;
      end
      ;
      KL0CS24(); /* close set invoice table*/
      ;
      ;
      CLCREC.CLACLMNB = CLWREC.CLWCLMNB[CLWCLIDX];
      CLCREC.CLCPMAR = "Y";
      KL0CS30(); /* read xref table for xref number*/
      ;
      KL0CS33(); /* select next on xref table*/
      if (SQLCA.VAGen_SQLCODE == 0)
        CL0CW05.ARCCCREF[CLWCLIDX] = CLCREC.ARCCCREF;
      end
      ;
      KL0CS34(); /* close set xref table*/
      ;
      CLAREC.CLACLMNB = CL0CW05.CLACLMNB[CLWCLIDX];
      KL0CS35(); /* read claim header table for misc info*/
      if (SQLCA.VAGen_SQLCODE == 0)
        CL0CW05.XGPCD[CLWCLIDX] = CLAREC.XGPCD;
        CL0CW05.CLAESTVL[CLWCLIDX] = CLAREC.CLAESTVL;
        CL0CW05.YCTCD[CLWCLIDX] = CLAREC.YCTCD;
        CL0CW05.YCRCD[CLWCLIDX] = CLAREC.YCRCD;
        CL0CW05.CLASETDT[CLWCLIDX] = CLAREC.CLASETDT;
        CL0CW05.YCSCD1[CLWCLIDX] = CLAREC.YCSCD1;
        CL0CW05.CLASTTDT[CLWCLIDX] = CLAREC.CLASTTDT;
      end
      CLWREC.CLWCLIDX = CLWREC.CLWCLIDX + 1;
    end
  end
  ;
  ;
    /* move multiple lines to map*/
  ;
  CLXREC.CLXLINEX = 1;
  CLWREC.CLWCLIDX = CLXREC.CLXARY1X;
  ;
  while (CLXREC.CLXLINEX <= CLXREC.CLXMAXLN[CLXSCRNX])
    if (CLXREC.CLXERRF != "Y")
      set KL0CM001.SEL[CLXLINEX] normal;
    end
    KL0CM001.SEL[CLXLINEX] = " ";
    KL0CS27(); /* build each screen line*/
    CLXREC.CLXLINEX = CLXREC.CLXLINEX + 1;
    CLWREC.CLWCLIDX = CLWREC.CLWCLIDX + 1;
  end
  ;
  if (CLWREC.CLWCLIDX >= CLWREC.CLWMXIDX)
    if (converseVar.eventKey is pf7)
      CLWREC.CLWCLIDX = CLWREC.CLWCLIDX - CLXREC.CLXMAXLN[CLXSCRNX];
    end
  end
  CLXREC.CLXARY1X = CLWREC.CLWCLIDX;
  ;
  if (converseVar.eventKey is enter)
    if (CLWREC.CLWMXIDX <= CLXREC.CLXMAXLN[CLXSCRNX])
      converseLib.validationFailed(3); /* at end of data*/
    end
  end
  ;
  ;
end // end KL0C101

// validate screen m001 pf keys
Function KL0C110()
   /* ************************************************************/
   /* *  validate pf keys                                       **/
   /* *                                                         **/
   /* *  the only keys acted upon at this time are pf 1, 3 & 4  **/
   /* *  and fastpath                                           **/
   /* *                                                         **/
   /* *  the other keys are just verified that they are used    **/
   /* *  by this application.  if the pf key is not recognized, **/
   /* *  the application resets all modified fields to remain   **/
   /* *  modified, then reshows the map with an error message.  **/
   /* *                                                         **/
   /* *  these other pf keys are acted upon after the editing   **/
   /* *  and updating have occured.                             **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0C110"; /* set current process name*/
  ;
  ;
  if (converseVar.eventKey is enter) /* normal 'enter'*/
    if (KL0CM001.CATOAP != " ")
      COMMAREA.CATOAP = KL0CM001.CATOAP;
      COMMAREA.CAITEM = KL0CM001.CAITEM;
      XPCL006(); /* check item for length and type*/
      if (CLXREC.CLXVITMF == "N") /* ITEM FIELD NOT VALID*/
        set KL0CM001.CATOAP cursor, modified, bold;
        set KL0CM001.CAITEM modified, bold;
        converseLib.validationFailed(285); /* ITEM FIELD or OPTION field invalid*/
        KL0CM001.XXXMSG = CLXREC.CLXMSG;
        CLXREC.CLXERRF = "Y";
        return;
      else
        if (COMMAREA.CAITEM != " ")
          set CLAREC empty;
          CLAREC.CLACLMNB = CLWREC.CLWITM1N;
          call "IO1160" ("S ", SQLCA, CLAREC) {isNoRefresh = yes, isExternal = yes}; /* get claim header*/
        end
      end
      XPCL002(); /* check security/xfer*/
      KL0CM001.XXXMSG = COMMAREA.CAMSG; /* security failed*/
      COMMAREA.CATOAP = " ";
      CLXREC.CLXERRF = "Y";
      CLXREC.CLXEDITF = "Y";
    else
      if (KL0CM001.CAITEM != " ") /* fastpath request*/
        set KL0CM001.CATOAP cursor, modified, bold;
        converseLib.validationFailed(1); /* ITEM FIELD NOT VALID UNLESS OPTION IS ENTERED*/
        CLXREC.CLXERRF = "Y";
        CLXREC.CLXEDITF = "Y";
      end
    end
    return;
  end
  ;
  ;
  ;
  if (converseVar.eventKey is pf1) /* 'help'*/
    XSPF1();
  end
  ;
  if (converseVar.eventKey is pf3)
    KL0CS03(); /* skip edit, update - exit*/
  end
  ;
  if (converseVar.eventKey is pf4)
    KL0CS04(); /* skip edit, update - exit*/
  end
  ;
  if (converseVar.eventKey is pf5)
    KL0CS05(); /* return to 'cl0b'*/
  end
  ;
  if (converseVar.eventKey is pf7) /* page back*/
    KL0CS07();
    return;
  end
  ;
  if (converseVar.eventKey is pf8) /* page forward*/
    KL0CS08();
    return;
  end
  ;
  ;
   /* other pf keys follow the same format*/
  ;
   /* if ezeaid is pf key ??*/
     /* ezertn*/
   /* end*/
  ;
  ;
  ;
      /* pf key not valid*/
  ;
  converseLib.validationFailed(2); /* pf key not valid*/
  KL0CS26(); /* set fields modfd so user no re-key*/
  CLXREC.CLXEDITF = "N"; /* do not edit map, just re-show it*/
  ;
  ;
  ;
end // end KL0C110

// process screen m001 entries
Function KL0C120()
   /* ************************************************************/
   /* *     this process handles all edits of screen fields,    **/
   /* *          and any subsequent updating, required by       **/
   /* *          entries into screen cl0%m001                   **/
   /* *                                                         **/
   /* *                                                         **/
   /* *                                                         **/
   /* *                                                         **/
   /* *                                                         **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0C120"; /* set current process name*/
  ;
  ;
     /* individual field edits use this form:*/
  ;
   /* if map.field is modified*/
     /* cl0%s..                            ; edit field 1*/
   /* end*/
  ;
   /* if map.field is modified*/
     /* cl0%s..                            ; edit field 2*/
   /* end*/
  ;
  ;
  ;
    /* cl0%s.. statement group uses this form:*/
  ;
    /* if field is in error*/
      /* move ## to ezemno             ; describe message here*/
      /* set map.field cursor,modified,bright*/
      /* move 'y' to clxrec.clxerrf*/
    /* else*/
      /* set map.field defined         ; reset color*/
    /* end*/
  ;
  ;
  ;
    /* do individual field edits first, then*/
      /* if clxrec.clxerrf = 'n'       ;if no errors on map input*/
        /* do field combination edits, if applicable*/
        /* if user entered data to select new record for display*/
          /* move 'y' to clxrec.clxbldsc ;flag to re-build screen*/
  ;
  ;
    /* note - turn on the update flag when the screen*/
    /* is error-free.*/
  ;
    /* note - when processing multiple lines, each line*/
    /* needs an update flag.  if the map has a 'select' column,*/
    /* use this by changing the 's' to a 'u' for update.*/
    /* the update routine will change the 'u' to a 'v' for*/
    /* viewed, so the user knows he has already seen the line.*/
  ;
  ;
  ;
end // end KL0C120

// converse screen m002
Function KL0C200()
   /* ************************************************************/
   /* *     process screen kl0cm002                             **/
   /* *                                                         **/
   /* *  note that this process is being performed in a         **/
   /* *      "while loop" from cl0c050 until the end-of-screen  **/
   /* *      flag (clxeosf) gets set to 'y'                     **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0C200"; /* set current process name*/
  ;
  if (CLXREC.CLXERRF != "Y")
    set KL0CM002.SEL[1] cursor;
  end
  ;
  if (CLXREC.CLXBLDSC == "Y")
    KL0C201(); /* build screen because new record*/
  end /* to display or pf7/pf8 keyed*/
  ;
  CLXREC.CLXBLDSC = "N"; /* skip build screen next time thru*/
    /* skip build when have errors to show, or pf12 was keyed*/
  ;
  ;
  ;
  converse KL0CM002 ;
  ;
  CLXREC.CLXMSG = " "; /* set non-ezemno error message to*/
                                   /* spaces*/
  CLXREC.CLXERRF = "N"; /* re-set error flag*/
  ;
  ;
  ;
  ;
    /* may exit appl from this process*/
  ;
  ;
  CLXREC.CLXLINEX = 1;
  if (CLXREC.CLXARY1X <= 1)
    CLXREC.CLXCURLN = 1;
  else
    if (CLXREC.CLXCURLN == CLWREC.CLWMXIDX)
      CLXREC.CLXCURLN = CLXREC.CLXARY1X;
    else
      CLXREC.CLXCURLN = CLXREC.CLXARY1X - CLXREC.CLXMAXLN[2];
    end
  end
  if (CLXREC.CLXCURLN < 1)
    CLXREC.CLXCURLN = 1;
  end
  CLWREC.CLWCLIDX = CLXREC.CLXCURLN;
  while (CLXREC.CLXLINEX <= CLXREC.CLXMAXLN[2])
    if (CLWREC.CLWCLIDX <= CLWREC.CLWMXIDX)
      KL0CS31(); /* save selections to array*/
      if (CLXREC.CLXERRF == "Y")
        CLXREC.CLXLINEX = 14;
      end
      CLXREC.CLXLINEX = CLXREC.CLXLINEX + 1;
    else
      CLXREC.CLXLINEX = 14;
    end
  end
  ;
  KL0C210(); /* handle any special entries*/
  ;
  if (KL0CM002 is modified) /* if there were entries*/
    CLXREC.CLXEDITF = "Y"; /* then set do-edits-flag*/
  else
    CLXREC.CLXEDITF = "N"; /* if no entries, then no edits*/
  end
  ;
  if (converseVar.eventKey is enter)
    if (CLXREC.CLXEDITF == "N")
      KL0CS05();
    end
  end
  ;
  if (CLXREC.CLXEDITF == "Y") /* if we still want to edit*/
    KL0C220(); /* go edit screen entries*/
  end
  ;
  ;
      /* determine next action*/
  ;
  if (CLXREC.CLXERRF == "Y" /* if screen has errors*/
   || converseVar.eventKey is pf12) /* or user wants to see same screen*/
    CLXREC.CLXBLDSC = "N"; /* do not rebuild screen, just reshow*/
  else
     /* if update sw on*/
       /* cl02s..                     ; go update data base*/
     /* end*/
    ;
    if (converseVar.eventKey is enter)
      CLWREC.CLWCLIDX = 1;
      while (CLWREC.CLWCLIDX <= CLWREC.CLWMXIDX)
        if (CLWREC.CLWSELCD[CLWCLIDX] == "S")
          CLWREC.CLWMAPFM = "KL0CM002";
          set CLAREC empty;
          CLAREC.CLACLMNB = CLWREC.CLWCLMNB[CLWCLIDX];
          COMMAREA.CATOAP = "KL0E";
          XPCL002();
        else
          CLWREC.CLWCLIDX = CLWREC.CLWCLIDX + 1;
        end
      end
      COMMAREA.CATOAP = "KL0B";
      CLXREC.CLXEOSF = "Y";
      XPCL002();
    else
      if (converseVar.eventKey is pf7 /* scroll commands*/
       || converseVar.eventKey is pf8)
      end
    end
  end
  ;
  ;
  ;
  ;
  ;
   /* at this point;*/
     /* if the end-of-screen flag (clxeosf) is 'n'*/
       /* the perform returns to top of process cl0c100.*/
     /* else*/
       /* the perform returns to cl0c050.*/
  ;
  ;
  ;
end // end KL0C200

// Initialize screen CL0CM002
Function KL0C201()
   /* ************************************************************/
   /* *        this process initializes screen cl0cm005         **/
   /* *        it will read the necessary tables or             **/
   /* *        scroll forward or back                           **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  ;
  CLXREC.CLXCPROC = "CL0C201"; /* set current process name*/
  ;
  ;
  if (converseVar.eventKey not pf7 /* do not rebuild top of map*/
   && converseVar.eventKey not pf8) /* for pf7 or pf8*/
     /* build top of screen*/
     /* initialize indexes and pointers for multiple lines*/
    if (CLWREC.CLWEZMNO != 0)
      if (CLWREC.CLWEZMNO == 9999)
        converseLib.validationFailed();
      else
        converseLib.validationFailed(CLWREC.CLWEZMNO);
      end
      CLWREC.CLWEZMNO = 0;
    else
      /* next sentence*/
    end
    if (CLWREC.SM1AGYID != " ")
      KL0CM002.SM1AGYID = CLWREC.SM1AGYID;
      SM1REC.SM1AGYID = CLWREC.SM1AGYID;
      KL0CS45();
      if (SQLCA.VAGen_SQLCODE == 0)
        KL0CM002.SM1AGYNM = SM1REC.SM1AGYNM;
      end
    end
    ;
    /* below added 6-27-88*/
    /* 4/89 change xot to xob*/
    KL0CM002.XOBCD = CLWREC.XOBCD; /* base order type*/
    if (CLWREC.XOBCD in XOBTBL.XOBCD) /* if in table*/
      KL0CM002.XOBABRV = XOBTBL.XOBABRV[sysVar.arrayIndex];
    end
    ;
    ;
    KL0CM002.YPSCD = CLWREC.YPSCD; /* POD/POS status code*/
    if (CLWREC.YPSCD in YPSTBL.YPSCD) /* if in table*/
      KL0CM002.YPSDESC = YPSTBL.YPSDESC[sysVar.arrayIndex];
    end
    /* above added 6-27-88*/
    ;
    KL0CM002.CL0CMGPC = CLWREC.XGPCD;
    if (CLWREC.XGPCD in XGPTBL.XGPCD) /* if in table*/
      KL0CM002.XGPABRV = XGPTBL.XGPABRV[sysVar.arrayIndex];
    end
    ;
     /* 4/89 add*/
    KL0CM002.XDVCD = CLWREC.XDVCD;
    if (CLWREC.XDVCD in XDVTBL.XDVCD) /* division*/
      KL0CM002.XDVABRV = XDVTBL.XDVABRV[sysVar.arrayIndex];
    end
    ;
    KL0CM002.SM4REPID = CLWREC.SM4REPID;
    KL0CM002.YPSCD = CLWREC.YPSCD;
    CLXREC.XXXWCYMD = CLWREC.CLWSETHI;
    CL0CW01.CL0CWMM = CLXREC.XXXWYY;
    CL0CW01.CL0CWDD = CLXREC.XXXWMM;
    CL0CW01.CL0CWYY = CLXREC.XXXWDD;
    KL0CM002.CLWSETHI = CL0CW01.CL0CWMDY;
    CLXREC.XXXWCYMD = CLWREC.CLWSETLO;
    CL0CW01.CL0CWMM = CLXREC.XXXWYY;
    CL0CW01.CL0CWDD = CLXREC.XXXWMM;
    CL0CW01.CL0CWYY = CLXREC.XXXWDD;
    KL0CM002.CLWSETLO = CL0CW01.CL0CWMDY;
    KL0CM002.CLWESTHI = CLWREC.CLWESTHI;
    KL0CM002.CLWESTLO = CLWREC.CLWESTLO;
    ;
    ;
    CLWREC.CLWCLIDX = 1;
    while (CLWREC.CLWCLIDX <= CLWREC.CLWMXIDX)
      CLBREC.CLACLMNB = CLWREC.CLWCLMNB[CLWCLIDX];
      CL0CW10.CLACLMNB[CLWCLIDX] = CLWREC.CLWCLMNB[CLWCLIDX];
      CLBREC.CLBPMIVC = "Y";
      KL0CS20();
                                   /* read invoice table for invoice number*/
      ;
      KL0CS23();
      if (SQLCA.VAGen_SQLCODE == 0)
        /* MOVE CLBREC.IV0IVCID TO CL0CW10.IV0IVCID(1);*/
        CL0CW10.IV0IVCID[CLWCLIDX] = CLBREC.IV0IVCID;
      end
      ;
      KL0CS24();
      ;
      CLAREC.CLACLMNB = CLWREC.CLWCLMNB[CLWCLIDX];
      KL0CS35(); /* read claim header table for misc info*/
      if (SQLCA.VAGen_SQLCODE == 0)
        CL0CW10.XGPCD[CLWCLIDX] = CLAREC.XGPCD;
        CL0CW10.CLAESTVL[CLWCLIDX] = CLAREC.CLAESTVL;
        CL0CW10.YCTCD[CLWCLIDX] = CLAREC.YCTCD;
        CL0CW10.YCRCD[CLWCLIDX] = CLAREC.YCRCD;
        CL0CW10.CLASETDT[CLWCLIDX] = CLAREC.CLASETDT;
        CL0CW10.YCSCD1[CLWCLIDX] = CLAREC.YCSCD1;
        CL0CW10.CLASTTDT[CLWCLIDX] = CLAREC.CLASTTDT;
        CL0CW10.KUCCOID[CLWCLIDX] = CLAREC.KUCCOID;
        CL0CW10.KUMSTRID[CLWCLIDX] = CLAREC.KUMSTRID;
        CL0CW10.XNXCD[CLWCLIDX] = CLAREC.XNXCD;
      end
      CLWREC.CLWCLIDX = CLWREC.CLWCLIDX + 1;
    end
  end
  ;
  ;
  ;
    /* move multiple lines to map*/
  ;
  CLXREC.CLXLINEX = 1;
  CLWREC.CLWCLIDX = CLXREC.CLXARY1X;
  ;
  while (CLXREC.CLXLINEX <= CLXREC.CLXMAXLN[CLXSCRNX])
    if (CLXREC.CLXERRF != "Y")
      set KL0CM002.SEL[CLXLINEX] normal;
    end
    KL0CM002.SEL[CLXLINEX] = " ";
    KL0CS37(); /* build each screen line*/
    CLXREC.CLXLINEX = CLXREC.CLXLINEX + 1;
    CLWREC.CLWCLIDX = CLWREC.CLWCLIDX + 1;
  end
  ;
  if (CLWREC.CLWCLIDX >= CLWREC.CLWMXIDX)
    if (converseVar.eventKey is pf7)
      CLWREC.CLWCLIDX = CLWREC.CLWCLIDX - CLXREC.CLXMAXLN[CLXSCRNX];
    end
  end
  CLXREC.CLXARY1X = CLWREC.CLWCLIDX;
  ;
  if (converseVar.eventKey is enter)
    if (CLWREC.CLWMXIDX <= CLXREC.CLXMAXLN[CLXSCRNX])
      converseLib.validationFailed(3); /* at end of data*/
    end
  end
  ;
  ;
end // end KL0C201

// handle screen m002 spec entrys
Function KL0C210()
   /* ************************************************************/
   /* *  validate pf keys                                       **/
   /* *                                                         **/
   /* *  the only keys acted upon at this time are pf 1, 3 & 4  **/
   /* *  and fastpath                                           **/
   /* *                                                         **/
   /* *  the other keys are just verified that they are used    **/
   /* *  by this application.  if the pf key is not recognized, **/
   /* *  the application resets all modified fields to remain   **/
   /* *  modified, then reshows the map with an error message.  **/
   /* *                                                         **/
   /* *  these other pf keys are acted upon after the editing   **/
   /* *  and updating have occured.                             **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0C210"; /* set current process name*/
  ;
  ;
  if (converseVar.eventKey is enter) /* normal 'enter'*/
    if (KL0CM002.CATOAP != " ")
      COMMAREA.CATOAP = KL0CM002.CATOAP;
      COMMAREA.CAITEM = KL0CM002.CAITEM;
      XPCL006(); /* check item for length and type*/
      if (CLXREC.CLXVITMF == "N") /* item is not valid*/
        set KL0CM002.CAITEM modified, bold;
        set KL0CM002.CATOAP cursor, modified, bold;
        converseLib.validationFailed(285); /* ITEM FIELD NOT VALID*/
        KL0CM002.XXXMSG = CLXREC.CLXMSG;
        CLXREC.CLXERRF = "Y";
        return;
      else
        if (COMMAREA.CAITEM != " ")
          set CLAREC empty;
          CLAREC.CLACLMNB = CLWREC.CLWITM1N;
          call "IO1160" ("S ", SQLCA, CLAREC) {isNoRefresh = yes, isExternal = yes}; /* get claim header*/
        end
      end
      XPCL002(); /* check security/xfer*/
      KL0CM002.XXXMSG = COMMAREA.CAMSG; /* security failed*/
      COMMAREA.CATOAP = " ";
      CLXREC.CLXERRF = "Y";
      CLXREC.CLXEDITF = "Y";
    else
      if (KL0CM002.CAITEM != " ") /* fastpath request*/
        set KL0CM002.CATOAP cursor, modified, bold;
        converseLib.validationFailed(1); /* ITEM FIELD NOT VALID UNLESS OPTION IS ENTERED*/
        CLXREC.CLXERRF = "Y";
        CLXREC.CLXEDITF = "Y";
      end
    end
    return;
  end
  ;
  ;
  ;
  if (converseVar.eventKey is pf1) /* 'help'*/
    XSPF1();
  end
  ;
  if (converseVar.eventKey is pf3)
    KL0CS03(); /* skip edit, update - exit*/
  end
  ;
  if (converseVar.eventKey is pf4)
    KL0CS04(); /* skip edit, update - exit*/
  end
  ;
  if (converseVar.eventKey is pf5)
    KL0CS05(); /* return to 'cl0b'*/
    return;
  end
  ;
  if (converseVar.eventKey is pf7) /* page back*/
    KL0CS07();
    return;
  end
  ;
  if (converseVar.eventKey is pf8) /* page forward*/
    KL0CS08();
    return;
  end
  ;
  ;
   /* other pf keys follow the same format*/
  ;
   /* if ezeaid is pf key ??*/
     /* ezertn*/
   /* end*/
  ;
  ;
  ;
      /* pf key not valid*/
  ;
  converseLib.validationFailed(2); /* pf key not valid*/
  KL0CS26(); /* set fields modfd so user no re-key*/
  CLXREC.CLXEDITF = "N"; /* do not edit map, just re-show it*/
  ;
  ;
  ;
end // end KL0C210

// process screen m002 entries
Function KL0C220()
   /* ************************************************************/
   /* *     this process handles all edits of screen fields,    **/
   /* *          and any subsequent updating, required by       **/
   /* *          entries into screen cl0%m005                   **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0C220"; /* set current process name*/
  ;
  ;
     /* individual field edits use this form:*/
  ;
   /* if map.field is modified*/
     /* cl0%s..                            ; edit field 1*/
   /* end*/
  ;
   /* if map.field is modified*/
     /* cl0%s..                            ; edit field 2*/
   /* end*/
  ;
  ;
    /* cl0%s.. statement group uses this form:*/
  ;
    /* if field is in error*/
      /* move ## to ezemno             ; describe message here*/
      /* set map.field cursor,modified,bright*/
      /* move 'y' to clxrec.clxerrf*/
    /* else*/
      /* set map.field defined         ; reset color*/
    /* end*/
  ;
  ;
  ;
    /* do individual field edits first, then*/
      /* if clxrec.clxerrf = 'n'       ;if no errors on map input*/
        /* do field combination edits, if applicable*/
        /* if user entered data to select new record for display*/
          /* move 'y' to clxrec.clxbldsc ;flag to re-build screen*/
  ;
  ;
    /* note - turn on the update flag when the screen*/
    /* is error-free.*/
  ;
    /* note - when processing multiple lines, each line*/
    /* needs an update flag.  if the map has a 'select' column,*/
    /* use this by changing the 's' to a 'u' for update.*/
    /* the update routine will change the 'u' to a 'v' for*/
    /* viewed, so the user knows he has already seen the line.*/
  ;
  ;
  ;
  ;
  ;
end // end KL0C220

// pf3 exit to claims
Function KL0CS03()
  ;
  ;
  ;
      /* skip edits/update, go to higher level in claims*/
  ;
    /* ** your application may need to go elsewhere ***/
  COMMAREA.CATOAP = "KL0A"; /* go to claims menu*/
  ;
  XPCL002(); /* common claims exit*/
  ;
  ;
  ;
end // end KL0CS03

// pf4 exit to master menu
Function KL0CS04()
  ;
  ;
  ;
      /* skip edits/update, go to goal master menu*/
  ;
  XSPF4();
  ;
end // end KL0CS04

// pf 5 action
Function KL0CS05()
   /* ************************************************************/
   /* *      handle the entry of pfkey 5                        **/
   /* *        claim header                                     **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  ;
  CLXREC.CLXEOSF = "Y"; /* we are done with this screen*/
  CLXREC.CLXEOAF = "Y"; /* we are done with this appl*/
   /* *******************/
  ;
     /* ***   this statement group has the chore of looping ****/
     /* *** thru the line item array and marking each entry ****/
     /* *** with an ' ', before returning to menu selection ****/
  ;
     /* set index*/
  ;
  CLWREC.CLWCLIDX = 1;
  ;
     /* loop thru and mark each entry*/
  ;
  while (CLWREC.CLWCLIDX <= CLWREC.CLWMXIDX)
    CL0CW05.CL0CWISF[CLWCLIDX] = " ";
    CL0CW10.CL0CWISF[CLWCLIDX] = " ";
    CLWREC.CLWSELCD[CLWCLIDX] = " ";
    CLWREC.CLWCLIDX = CLWREC.CLWCLIDX + 1;
  end
   /* *******************/
  ;
  COMMAREA.CATOAP = "KL0B"; /* claim header screen*/
  XPCL002();
  ;
  ;
  ;
end // end KL0CS05

// pf 7 action
Function KL0CS07()
   /* ************************************************************/
   /* *    this process handles the entry of pf key 7           **/
   /* *             (paging backward)                           **/
   /* *                                                         **/
   /* *                                                         **/
   /* *                                                         **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXMAPMX = CLXREC.CLXCURLN;
  if (CLXREC.CLXMAPMX <= 1)
    CLXREC.CLXCURLN = 1;
    converseLib.validationFailed(7); /* at top of data*/
  else
    CLXREC.CLXMAPMX = CLXREC.CLXMAPMX - CLXMAXLN[CLXSCRNX];
    if (CLXREC.CLXMAPMX <= 1)
      CLXREC.CLXCURLN = 1;
      converseLib.validationFailed(7); /* at top of data*/
    else
      CLXREC.CLXCURLN = CLXREC.CLXMAPMX;
    end
  end
  CLXREC.CLXARY1X = CLXREC.CLXCURLN;
  ;
  CLXREC.CLXBLDSC = "Y";
  ;
  ;
end // end KL0CS07

// pf 8 action
Function KL0CS08()
   /* ************************************************************/
   /* *   this process handles the entry of pf key 8            **/
   /* *           (paging forward)                              **/
   /* *                                                         **/
   /* *                                                         **/
   /* *                                                         **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  if (CLXREC.CLXCURLN <= 1)
    CLXREC.CLXCURLN = 1;
  end
  CLXREC.CLXMAPMX = CLXREC.CLXCURLN;
  CLXREC.CLXMAPMX = CLXREC.CLXMAPMX + CLXMAXLN[CLXSCRNX];
  if (CLXREC.CLXMAPMX > CLWREC.CLWMXIDX)
    converseLib.validationFailed(3); /* at end of data*/
  else
    CLXREC.CLXCURLN = CLXREC.CLXMAPMX;
    CLXREC.CLXMAPMX = CLXREC.CLXMAPMX + CLXMAXLN[CLXSCRNX];
    if (CLXREC.CLXMAPMX > CLWREC.CLWMXIDX)
      converseLib.validationFailed(3); /* at end of data*/
    end /* ;*/
  end /* ;*/
  ;
  CLXREC.CLXARY1X = CLXREC.CLXCURLN;
  ;
     /* force build new screen*/
  ;
  CLXREC.CLXBLDSC = "Y";
  ;
  ;
end // end KL0CS08

// read vcmpny01
Function KL0CS15()
  ;
   /* ----------  start stmt grp cl0cs15 ----------------*/
   /*  */
   /* 01-13-92  sgorga  Set ta1rec empty.*/
   /*  */
  ;
  call "IO0240" ("S ", SQLCA, KUCREC) {isNoRefresh = yes, isExternal = yes}; /* read cmpny01*/
  if (SQLCA.VAGen_SQLCODE == 0)
     /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      converseLib.validationFailed(25); /* company not found*/
      return;
    else
      set TA1REC empty;
      TA1REC.TA1TYPE = "DB2";
      TA1REC.TA1FUNC = "ABND";
      TA1REC.TA1DBASE = "DCUST";
      TA1REC.TA1TBLVU = "VCMPNY01";
      TA1REC.TA1MAP = " ";
      CL0CW01.CL0CWKEY = KUCREC.KUCCOID;
      TA1REC.TA1TBLKE = CL0CW01.CL0CWKEY;
      TA1REC.TA1PGMNM = "CL0CS15";
      TA1REC.TA1LOC = "READING DB2 CMPNY01";
      call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
    end
  end
  ;
   /* ----------  end  stmt grp cl0cs15 ----------------*/
end // end KL0CS15

// read vclivx01
Function KL0CS20()
  ;
   /* ----------  start stmt grp cl0cs20 ----------------*/
   /*  */
   /* 01-13-92  sgorga  Set ta1rec empty.*/
   /*  */
  ;
  call "IO1180" ("S3", SQLCA, CLBREC) {isNoRefresh = yes, isExternal = yes}; /* read clivx01*/
  if (SQLCA.VAGen_SQLCODE == 0)
     /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      converseLib.validationFailed(9); /* not found*/
      exit stack;
    else
      set TA1REC empty;
      TA1REC.TA1TYPE = "DB2";
      TA1REC.TA1FUNC = "ABND";
      TA1REC.TA1DBASE = "DCLAIM";
      TA1REC.TA1TBLVU = "VCLIVX01";
      TA1REC.TA1MAP = " ";
      CL0CW01.CL0CWKEY = CLBREC.IV0IVCID;
      TA1REC.TA1TBLKE = CL0CW01.CL0CWKEY;
      TA1REC.TA1PGMNM = "CL0CS20";
      TA1REC.TA1LOC = "READING DB2 CLIVX01";
      call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
    end
  end
  ;
   /* ----------  end  stmt grp cl0cs20 ----------------*/
end // end KL0CS20

// Save off Selections to array
Function KL0CS21()
  ;
     /* ***   This statement group checks for any selections ****/
     /* *** made by the user on the product summary screen,  ****/
     /* *** and records them in the line item array.         ****/
  ;
     /* set indexes*/
  ;
  ;
  ;
  if (KL0CM001.SEL[CLXLINEX] is modified)
    if (KL0CM001.SEL[CLXLINEX] == " " /* no entry,*/
     || KL0CM001.SEL[CLXLINEX] == "V" /* marked as viewed*/
     || KL0CM001.SEL[CLXLINEX] == "S") /* line selected*/
      CL0CW05.CL0CWISF[CLWCLIDX] = KL0CM001.SEL[CLXLINEX];
      CLWREC.CLWSELCD[CLWCLIDX] = KL0CM001.SEL[CLXLINEX];
      CLXREC.CLXEDITF = "Y";
      set KL0CM001.SEL[CLXLINEX] modified;
    else
      if (KL0CM001.SEL[CLXLINEX] == "A" /* all lines selected*/
       && CLXREC.CLXLINEX == 1)         /* entered on line 1*/
        if (CLWREC.CLWCLIDX == 1)
          set KL0CM001.SEL[CLXLINEX] modified;
          KL0CS22(); /* set all entries in array to s*/
          CLXREC.CLXLINEX = 11; /* get out of loop*/
        else
          set KL0CM001.SEL[CLXLINEX] modified;
          set KL0CM001.SEL[CLXLINEX] cursor, bold;
          converseLib.validationFailed(8); /* INVALID SELECTION*/
          CLXREC.CLXERRF = "Y";
          CLXREC.CLXLINEX = 11;
        end
        CLXREC.CLXEDITF = "Y";
      else
        set KL0CM001.SEL[CLXLINEX] modified;
        set KL0CM001.SEL[CLXLINEX] cursor, bold;
        CLXREC.CLXEDITF = "Y";
        CLXREC.CLXERRF = "Y";
        converseLib.validationFailed(8); /* INVALID SELECTION*/
      end
    end
  end
  CLWREC.CLWCLIDX = CLWREC.CLWCLIDX + 1; /* set indexes for next*/
  ;
  ;
end // end KL0CS21

// For All Selection, Set all 'S'
Function KL0CS22()
  ;
     /* ***   this statement group has the chore of looping ****/
     /* *** thru the line item array and marking each entry ****/
     /* *** with an 's', because some user has decided      ****/
     /* *** to display all detail screen for the invoice.   ****/
  ;
     /* set index*/
  ;
  CLWREC.CLWCLIDX = 1;
  ;
     /* loop thru and mark each entry*/
  ;
  while (CLWREC.CLWCLIDX <= CLWREC.CLWMXIDX)
    CL0CW05.CL0CWISF[CLWCLIDX] = "S";
    CLWREC.CLWSELCD[CLWCLIDX] = "S";
    CLWREC.CLWCLIDX = CLWREC.CLWCLIDX + 1;
  end
end // end KL0CS22

// select next on invoice table
Function KL0CS23()
   /* ---------- start stmt grp cl0cs23 ----------------*/
   /*  */
   /* 01-13-92  sgorga  Set ta1rec empty.*/
   /*  */
  ;
  call "IO1180" ("N3", SQLCA, CLBREC) {isNoRefresh = yes, isExternal = yes};
  if (SQLCA.VAGen_SQLCODE == 0
   || SQLCA.VAGen_SQLCODE == 100)
    return;
  else
    CL0CW01.CL0CWSQL = SQLCA.SQLCAREC; /* hold error sqlca*/
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.rollback();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
     /* syncpoint rollback*/
    SQLCA.SQLCAREC = CL0CW01.CL0CWSQL;
    set TA1REC empty;
    TA1REC.TA1TYPE = "DB2";
    TA1REC.TA1FUNC = "ABND";
    TA1REC.TA1DBASE = "DCLAIM";
    TA1REC.TA1TBLVU = "VCLIVX01";
    TA1REC.TA1MAP = " ";
    CL0CW01.CL0CWKEY = CLBREC.CLACLMNB;
    TA1REC.TA1TBLKE = CL0CW01.CL0CWKEY;
    TA1REC.TA1PGMNM = "CL0CS23";
    TA1REC.TA1LOC = "N3 ON VCLIVX01   ";
    call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
  end
  ;
   /* ---------- end stmt grp cl0cs23 ----------------*/
end // end KL0CS23

// close set on invoice table
Function KL0CS24()
   /* ---------- start stmt grp cl0cs24 ----------------*/
   /*  */
   /* 01-13-92  sgorga  Set ta1rec empty.*/
   /*  */
  ;
  call "IO1180" ("C3", SQLCA, CLBREC) {isNoRefresh = yes, isExternal = yes};
  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  else
    CL0CW01.CL0CWSQL = SQLCA.SQLCAREC; /* hold error sqlca*/
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.rollback();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
     /* syncpoint rollback*/
    set TA1REC empty;
    SQLCA.SQLCAREC = CL0CW01.CL0CWSQL;
    TA1REC.TA1TYPE = "DB2";
    TA1REC.TA1FUNC = "ABND";
    TA1REC.TA1DBASE = "DCUST";
    TA1REC.TA1TBLVU = "VCLIVX01";
    TA1REC.TA1MAP = " ";
    CL0CW01.CL0CWKEY = CLBREC.CLACLMNB;
    TA1REC.TA1TBLKE = CL0CW01.CL0CWKEY;
    TA1REC.TA1PGMNM = "CL0CS24";
    TA1REC.TA1LOC = "C3 ON VCLIVX01   ";
    call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
  end
  ;
   /* ---------- end stmt grp cl0cs24 ----------------*/
end // end KL0CS24

// modify entered fields
Function KL0CS26()
   /* ************************************************************/
   /* *  since the map must be re-shown to the user             **/
   /* *  before editing has been done, set fields modified to   **/
   /* *  keep track of all the fields entered by the user.      **/
   /* *  the user will only need to re-do the pf key or enter   **/
   /* *  key, not enter the data again.                         **/
   /* ************************************************************/
  ;
  ;
    /* for every entry field on the map,*/
    /* do this:*/
  ;
    /* if map.field modified*/
      /* set map.field modified*/
    /* end*/
  ;
  ;
  ;
end // end KL0CS26

// build each screen line
Function KL0CS27()
   /* ************************************************************/
   /* *         build line to show on map                       **/
   /* *                                                         **/
   /* *                                                         **/
   /* *                                                         **/
   /* *                                                         **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  ;
     /* if not at end of array or at end of map lines*/
       /* move line to map*/
  ;
  ;
  ;
  ;
  if (CLWREC.CLWCLIDX < 200)
    if (CLWREC.CLWSELCD[CLWCLIDX] == "V")
      KL0CM001.SEL[CLXLINEX] = CLWREC.CLWSELCD[CLWCLIDX];
    else
      if (CLWREC.CLWSELCD[CLWCLIDX] == "S")
        KL0CM001.SEL[CLXLINEX] = CLWREC.CLWSELCD[CLWCLIDX];
        set KL0CM001.SEL[CLXLINEX] modified;
        CLXREC.CLXEDITF = "Y";
      else
        if (CLWREC.CLWCLIDX <= CLWREC.CLWMXIDX)
          KL0CM001.SEL[CLXLINEX] = " ";
        else
          set KL0CM001.SEL[CLXLINEX] skip, invisible;
        end
      end
    end
    ;
    KL0CM001.CLACLMNB[CLXLINEX] = CL0CW05.CLACLMNB[CLWCLIDX];
    KL0CM001.IV0IVCID[CLXLINEX] = CL0CW05.IV0IVCID[CLWCLIDX];
    KL0CM001.ARCCCREF[CLXLINEX] = CL0CW05.ARCCCREF[CLWCLIDX];
    KL0CM001.XGPCD[CLXLINEX] = CL0CW05.XGPCD[CLWCLIDX];
    KL0CM001.CL0CMEVL[CLXLINEX] = CL0CW05.CLAESTVL[CLWCLIDX];
    KL0CM001.YCTCD[CLXLINEX] = CL0CW05.YCTCD[CLWCLIDX];
    KL0CM001.YCRCD[CLXLINEX] = CL0CW05.YCRCD[CLWCLIDX];
    KL0CM001.CLASETDT[CLXLINEX] = CL0CW05.CLASETDT[CLWCLIDX];
    KL0CM001.YCSCD1[CLXLINEX] = CL0CW05.YCSCD1[CLWCLIDX];
    KL0CM001.CLASTTDT[CLXLINEX] = CL0CW05.CLASTTDT[CLWCLIDX];
    ;
  else
    KL0CM001.CLACLMNB[CLXLINEX] = CL0CW05.CLACLMNB[CLWCLIDX];
    KL0CM001.IV0IVCID[CLXLINEX] = CL0CW05.IV0IVCID[CLWCLIDX];
    KL0CM001.ARCCCREF[CLXLINEX] = CL0CW05.ARCCCREF[CLWCLIDX];
    KL0CM001.XGPCD[CLXLINEX] = CL0CW05.XGPCD[CLWCLIDX];
    KL0CM001.CL0CMEVL[CLXLINEX] = CL0CW05.CLAESTVL[CLWCLIDX];
    KL0CM001.YCTCD[CLXLINEX] = CL0CW05.YCTCD[CLWCLIDX];
    KL0CM001.YCRCD[CLXLINEX] = CL0CW05.YCRCD[CLWCLIDX];
    KL0CM001.CLASETDT[CLXLINEX] = CL0CW05.CLASETDT[CLWCLIDX];
    KL0CM001.YCSCD1[CLXLINEX] = CL0CW05.YCSCD1[CLWCLIDX];
    KL0CM001.CLASTTDT[CLXLINEX] = CL0CW05.CLASTTDT[CLWCLIDX];
    set KL0CM001.SEL[CLXLINEX] skip, invisible;
    CLWREC.CLWCLIDX = 199;
  end
  ;
  ;
   /* ******************/
  ;
  ;
end // end KL0CS27

// read vclarx01
Function KL0CS30()
  ;
   /* ----------  start stmt grp cl0cs30 ----------------*/
   /*  */
   /* 01-13-92  sgorga  Set ta1rec empty.*/
   /*  */
  ;
  call "IO1170" ("S1 ", SQLCA, CLCREC) {isNoRefresh = yes, isExternal = yes}; /* read clarx01*/
  if (SQLCA.VAGen_SQLCODE == 0)
     /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
        converseLib.validationFailed(9); /* company not found*/
        CLXREC.CLXERRF = "Y";
        return;
      else
        set TA1REC empty;
        TA1REC.TA1TYPE = "DB2";
        TA1REC.TA1FUNC = "ABND";
        TA1REC.TA1DBASE = "DCLAIM";
        TA1REC.TA1TBLVU = "VCLARX01";
        TA1REC.TA1MAP = " ";
        CL0CW01.CL0CWKEY = CLCREC.ARCCCREF;
        TA1REC.TA1TBLKE = CL0CW01.CL0CWKEY;
        TA1REC.TA1PGMNM = "CL0CS30";
        TA1REC.TA1LOC = "READING DB2 CLARX01";
        call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
        ;
        XPCL010(); /* error diagnosis routine*/
        ;
        return;
      end
    end
  end
  ;
  ;
   /* ----------  end  stmt grp cl0cs30 ----------------*/
end // end KL0CS30

// Save off Selections to array
Function KL0CS31()
  ;
     /* ***   This statement group checks for any selections ****/
     /* *** made by the user on the product summary screen,  ****/
     /* *** and records them in the line item array.         ****/
  ;
     /* set indexes*/
  ;
  ;
  ;
  if (KL0CM002.SEL[CLXLINEX] is modified)
    if (KL0CM002.SEL[CLXLINEX] == " " /* no entry,*/
     || KL0CM002.SEL[CLXLINEX] == "V" /* marked as viewed*/
     || KL0CM002.SEL[CLXLINEX] == "S") /* line selected*/
      CL0CW10.CL0CWISF[CLWCLIDX] = KL0CM002.SEL[CLXLINEX];
      CLWREC.CLWSELCD[CLWCLIDX] = KL0CM002.SEL[CLXLINEX];
      CLXREC.CLXEDITF = "Y";
      set KL0CM002.SEL[CLXLINEX] modified;
    else
      if (KL0CM002.SEL[CLXLINEX] == "A" /* all lines selected*/
       && CLXREC.CLXLINEX == 1)         /* entered on line 1*/
        if (CLWREC.CLWCLIDX == 1)
          set KL0CM002.SEL[CLXLINEX] modified;
          KL0CS32(); /* set all entries in array to s*/
          CLXREC.CLXLINEX = 13; /* get out of loop*/
        else
          set KL0CM002.SEL[CLXLINEX] modified;
          set KL0CM002.SEL[CLXLINEX] cursor, bold;
          converseLib.validationFailed(8); /* INVALID SELECTION*/
          CLXREC.CLXERRF = "Y";
          CLXREC.CLXLINEX = 13;
        end
        CLXREC.CLXEDITF = "Y";
      else
        set KL0CM002.SEL[CLXLINEX] modified;
        set KL0CM002.SEL[CLXLINEX] cursor, bold;
        CLXREC.CLXEDITF = "Y";
        CLXREC.CLXERRF = "Y";
        converseLib.validationFailed(8); /* INVALID SELECTION*/
      end
    end
  end
  CLWREC.CLWCLIDX = CLWREC.CLWCLIDX + 1; /* set indexes for next*/
  ;
  ;
end // end KL0CS31

// For All Selection, Set all 'S'
Function KL0CS32()
  ;
     /* ***   this statement group has the chore of looping ****/
     /* *** thru the line item array and marking each entry ****/
     /* *** with an 's', because some user has decided      ****/
     /* *** to display all detail screen for the invoice.   ****/
  ;
     /* set index*/
  ;
  CLWREC.CLWCLIDX = 1;
  ;
     /* loop thru and mark each entry*/
  ;
  while (CLWREC.CLWCLIDX <= CLWREC.CLWMXIDX)
    CL0CW10.CL0CWISF[CLWCLIDX] = "S";
    CLWREC.CLWSELCD[CLWCLIDX] = "S";
    CLWREC.CLWCLIDX = CLWREC.CLWCLIDX + 1;
  end
end // end KL0CS32

// select next on xref table
Function KL0CS33()
   /* ---------- start stmt grp cl0cs33 ----------------*/
   /*  */
   /* 01-13-92  sgorga  Set ta1rec empty.*/
   /*  */
  ;
  call "IO1170" ("N1", SQLCA, CLCREC) {isNoRefresh = yes, isExternal = yes};
  if (SQLCA.VAGen_SQLCODE == 0
   || SQLCA.VAGen_SQLCODE == 100)
    return;
  else
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      CL0CW01.CL0CWSQL = SQLCA.SQLCAREC; /* hold error sqlca*/
      VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
      VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
      sysLib.rollback();
      VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
       /* syncpoint rollback*/
      SQLCA.SQLCAREC = CL0CW01.CL0CWSQL;
      set TA1REC empty;
      TA1REC.TA1TYPE = "DB2";
      TA1REC.TA1FUNC = "ABND";
      TA1REC.TA1DBASE = "DCLAIM";
      TA1REC.TA1TBLVU = "VCLARX01";
      TA1REC.TA1MAP = " ";
      CL0CW01.CL0CWKEY = CLCREC.CLACLMNB;
      TA1REC.TA1TBLKE = CL0CW01.CL0CWKEY;
      TA1REC.TA1PGMNM = "CL0CS33";
      TA1REC.TA1LOC = "N3 ON VCLARX01   ";
      call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
      ;
      XPCL010(); /* error diagnosis routine*/
      ;
      return;
    end
  end
  ;
  ;
   /* ---------- end stmt grp cl0cs33 ----------------*/
end // end KL0CS33

// close set on xref table
Function KL0CS34()
   /* ---------- start stmt grp cl0cs34 ----------------*/
   /*  */
   /* 01-13-92  sgorga  Set ta1rec empty.*/
   /*  */
  ;
  call "IO1170" ("C1", SQLCA, CLCREC) {isNoRefresh = yes, isExternal = yes};
  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  else
    CL0CW01.CL0CWSQL = SQLCA.SQLCAREC; /* hold error sqlca*/
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.rollback();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
     /* syncpoint rollback*/
    SQLCA.SQLCAREC = CL0CW01.CL0CWSQL;
    set TA1REC empty;
    TA1REC.TA1TYPE = "DB2";
    TA1REC.TA1FUNC = "ABND";
    TA1REC.TA1DBASE = "DCUST";
    TA1REC.TA1TBLVU = "VCLARX01";
    TA1REC.TA1MAP = " ";
    CL0CW01.CL0CWKEY = CLCREC.CLACLMNB;
    TA1REC.TA1TBLKE = CL0CW01.CL0CWKEY;
    TA1REC.TA1PGMNM = "CL0CS34";
    TA1REC.TA1LOC = "C3 ON VCLARX01   ";
    call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
  end
  ;
   /* ---------- end stmt grp cl0cs34 ----------------*/
end // end KL0CS34

// read vclhdr01
Function KL0CS35()
  ;
   /* ----------  start stmt grp cl0cs35 ----------------*/
   /*  */
   /* 01-13-92  sgorga  Set ta1rec empty.*/
   /*  */
  ;
  call "IO1160" ("S ", SQLCA, CLAREC) {isNoRefresh = yes, isExternal = yes}; /* read clhdr01*/
  if (SQLCA.VAGen_SQLCODE == 0)
     /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      converseLib.validationFailed(25); /* company not found*/
      return;
    else
      set TA1REC empty;
      TA1REC.TA1TYPE = "DB2";
      TA1REC.TA1FUNC = "ABND";
      TA1REC.TA1DBASE = "DCLAIM";
      TA1REC.TA1TBLVU = "VCLHDR01";
      TA1REC.TA1MAP = " ";
      CL0CW01.CL0CWKEY = CLAREC.CLACLMNB;
      TA1REC.TA1TBLKE = CL0CW01.CL0CWKEY;
      TA1REC.TA1PGMNM = "CL0CS35";
      TA1REC.TA1LOC = "READING DB2 CLHDR01";
      call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
    end
  end
  ;
   /* ----------  end  stmt grp cl0cs35 ----------------*/
end // end KL0CS35

// build each screen line
Function KL0CS37()
   /* ************************************************************/
   /* *         build line to show on map                       **/
   /* *                                                         **/
   /* *                                                         **/
   /* *                                                         **/
   /* *                                                         **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  ;
     /* if not at end of array or at end of map lines*/
       /* move line to map*/
  ;
  ;
  ;
  ;
  if (CLWREC.CLWCLIDX < 200)
    if (CLWREC.CLWSELCD[CLWCLIDX] == "V")
      KL0CM002.SEL[CLXLINEX] = CLWREC.CLWSELCD[CLWCLIDX];
    else
      if (CLWREC.CLWSELCD[CLWCLIDX] == "S")
        KL0CM002.SEL[CLXLINEX] = CLWREC.CLWSELCD[CLWCLIDX];
        set KL0CM002.SEL[CLXLINEX] modified;
        CLXREC.CLXEDITF = "Y";
      else
        if (CLWREC.CLWCLIDX <= CLWREC.CLWMXIDX)
          KL0CM002.SEL[CLXLINEX] = " ";
        else
          set KL0CM002.SEL[CLXLINEX] skip, invisible;
        end
      end
    end
    ;
    KL0CM002.CLACLMNB[CLXLINEX] = CL0CW10.CLACLMNB[CLWCLIDX];
    KL0CM002.IV0IVCID[CLXLINEX] = CL0CW10.IV0IVCID[CLWCLIDX];
    KL0CM002.KUCCOID[CLXLINEX] = CL0CW10.KUCCOID[CLWCLIDX];
    KL0CM002.KUMSTRID[CLXLINEX] = CL0CW10.KUMSTRID[CLWCLIDX];
    KL0CM002.XNXCD[CLXLINEX] = CL0CW10.XNXCD[CLWCLIDX];
    KL0CM002.CL0CMEVL[CLXLINEX] = CL0CW10.CLAESTVL[CLWCLIDX];
    KL0CM002.XGPCD[CLXLINEX] = CL0CW10.XGPCD[CLWCLIDX];
    KL0CM002.YCTCD[CLXLINEX] = CL0CW10.YCTCD[CLWCLIDX];
    KL0CM002.YCRCD[CLXLINEX] = CL0CW10.YCRCD[CLWCLIDX];
    KL0CM002.CLASETDT[CLXLINEX] = CL0CW10.CLASETDT[CLWCLIDX];
    KL0CM002.YCSCD1[CLXLINEX] = CL0CW10.YCSCD1[CLWCLIDX];
    KL0CM002.CLASTTDT[CLXLINEX] = CL0CW10.CLASTTDT[CLWCLIDX];
    ;
  else
    KL0CM002.CLACLMNB[CLXLINEX] = CL0CW10.CLACLMNB[CLWCLIDX];
    KL0CM002.IV0IVCID[CLXLINEX] = CL0CW10.IV0IVCID[CLWCLIDX];
    KL0CM002.KUCCOID[CLXLINEX] = CL0CW10.KUCCOID[CLWCLIDX];
    KL0CM002.KUMSTRID[CLXLINEX] = CL0CW10.KUMSTRID[CLWCLIDX];
    KL0CM002.XNXCD[CLXLINEX] = CL0CW10.XNXCD[CLWCLIDX];
    KL0CM002.CL0CMEVL[CLXLINEX] = CL0CW10.CLAESTVL[CLWCLIDX];
    KL0CM002.XGPCD[CLXLINEX] = CL0CW10.XGPCD[CLWCLIDX];
    KL0CM002.YCTCD[CLXLINEX] = CL0CW10.YCTCD[CLWCLIDX];
    KL0CM002.YCRCD[CLXLINEX] = CL0CW10.YCRCD[CLWCLIDX];
    KL0CM002.CLASETDT[CLXLINEX] = CL0CW10.CLASETDT[CLWCLIDX];
    KL0CM002.YCSCD1[CLXLINEX] = CL0CW10.YCSCD1[CLWCLIDX];
    KL0CM002.CLASTTDT[CLXLINEX] = CL0CW10.CLASTTDT[CLWCLIDX];
    set KL0CM002.SEL[CLXLINEX] skip, invisible;
    CLWREC.CLWCLIDX = 199;
  end
  ;
  ;
  ;
  ;
end // end KL0CS37

// read sm1rec
Function KL0CS45()
  ;
   /* ----------  start stmt grp cl0cs45 ----------------*/
   /*  */
   /* 01-13-92  sgorga  Set ta1rec empty.*/
   /*  */
  ;
  call "IO0050" ("S ", SQLCA, SM1REC) {isNoRefresh = yes, isExternal = yes}; /* read vsagcy01*/
  if (SQLCA.VAGen_SQLCODE == 0)
     /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      converseLib.validationFailed(25); /* sales rep not found*/
      exit stack;
    else
      set TA1REC empty;
      TA1REC.TA1TYPE = "DB2";
      TA1REC.TA1FUNC = "ABND";
      TA1REC.TA1DBASE = "DSLSMN";
      TA1REC.TA1TBLVU = "VSAGCY01";
      TA1REC.TA1MAP = " ";
      CL0CW01.CL0CWKY2 = SM1REC.SM1AGYID;
      TA1REC.TA1TBLKE = CL0CW01.CL0CWKY2;
      TA1REC.TA1PGMNM = "CL0CS45";
      TA1REC.TA1LOC = "READING DB2 SAGCY01";
      call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
    end
  end
  ;
   /* ----------  end  stmt grp cl0cs45 ----------------*/
end // end KL0CS45

//*** RECORD=CL0CW01 ****
// the "commarea" is is the communication area that will be
// used between csp applications.  this area will be used to
// transport system required information and application
// specific information between applications.  all online
// main transactions will be required to use the commarea as
// working storage.
// ***********************
Record CL0CW01 type basicRecord
  10 CL0CWUSR CL0CWUSR ; 
  10 CL0CWIX1 CL0CWIX1 ; 
  10 CL0CWIX2 CL0CWIX2 ; 
  10 CL0CWMDY CL0CWMDY ; 
    15 CL0CWMM CL0CWMM ; 
    15 CL0CWDD CL0CWDD ; 
    15 CL0CWYY CL0CWYY ; 
  10 CL0CWSQL CL0CWSQL ; 
  10 CL0CWKEY CL0CWKEY ; 
  10 CL0CWKY2 CL0CWKY2 ; 
end // end CL0CW01

//*** RECORD=CL0CW05 ****
// the "commarea" is is the communication area that will be
// used between csp applications.  this area will be used to
// transport system required information and application
// specific information between applications.  all online
// main transactions will be required to use the commarea as
// working storage.
// ***********************
Record CL0CW05 type basicRecord
  10 CLACLMNB CLACLMNB [200] ; 
  10 IV0IVCID IV0IVCID [200] ; 
  10 ARCCCREF ARCCCREF [200] ; 
  10 XGPCD XGPCD [200] ; 
  10 CLAESTVL CLAESTVL [200] ; 
  10 YCTCD YCTCD [200] ; 
  10 YCRCD YCRCD [200] ; 
  10 CLASETDT CLASETDT [200] ; 
  10 YCSCD1 YCSCD1 [200] ; 
  10 CLASTTDT CLASTTDT [200] ; 
  10 CL0CWISF CL0CWISF [200] ; 
end // end CL0CW05

//*** RECORD=CL0CW10 ****
// the "commarea" is is the communication area that will be
// used between csp applications.  this area will be used to
// transport system required information and application
// specific information between applications.  all online
// main transactions will be required to use the commarea as
// working storage.
// ***********************
Record CL0CW10 type basicRecord
  10 CLACLMNB CLACLMNB [200] ; 
  10 IV0IVCID IV0IVCID [200] ; 
  10 KUCCOID KUCCOID [200] ; 
  10 KUMSTRID KUMSTRID [200] ; 
  10 XNXCD XNXCD [200] ; 
  10 CLAESTVL CLAESTVL [200] ; 
  10 XGPCD XGPCD [200] ; 
  10 YCTCD YCTCD [200] ; 
  10 YCRCD YCRCD [200] ; 
  10 CLASETDT CLASETDT [200] ; 
  10 YCSCD1 YCSCD1 [200] ; 
  10 CLASTTDT CLASTTDT [200] ; 
  10 CL0CWISF CL0CWISF [200] ; 
end // end CL0CW10

// date--day
DataItem CL0CWDD num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// item select flag
DataItem CL0CWISF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// index 1
DataItem CL0CWIX1 num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// index 2
DataItem CL0CWIX2 num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// work key
DataItem CL0CWKEY num(7)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// work key
DataItem CL0CWKY2 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// date--month,day,year
DataItem CL0CWMDY num(6)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// date--month
DataItem CL0CWMM num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// save area for sqlca/reset
DataItem CL0CWSQL char(136)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// commarea user id
DataItem CL0CWUSR char(8)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// date--year
DataItem CL0CWYY num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

