package kl04;

import corpcom1.*;
import corpcom2.XZZBINGP;
import corpcom2.XZZDECIM;
import corpcom2.XZZINT1;
import corpcom2.XZZINT2;
import corpcom2.XZZINT3;
import corpcom2.XZZINT4;
import corpcom2.XZZINT5;
import corpcom2.XZZINT6;
import corpcom2.XZZINT7;
import corpcom2.XZZINT8;
import corpcom2.XZZKEYGP;
import corpcom2.XZZQRYID;
import corpcom2.XZZQRYLN;
import corpcom2.XZZQRYRN;
import corpcom2.XZZREC;
import corpcom3.XPCL002;
import corpcom3.XPCL006;
import corpcom3.XPCL010;
import corpcom3.XPCL011;
import corpcom4.XSENTRY;
import corpcom4.XSPF4;
import corpcom4.XSSEGTR;
import corpcom5.CLYATHPW;
import corpcom5.CLYREC;
import corpcom5.COMMAREA;
import corpcom5.ERRSQLCA;
import corpcom6.SQLCA;
import corpcom7.ZZZSTM;
import corpx1.XDMCD;
import corpx1.XGPCD;
import corpx1.XSNTBL;
import corpx2.XROCD;
import corpx2.XSNBDT;
import corpx2.XSNXDT;
import corpx2.XWHCD;
import corpx2.XXXUSRID;
import corpy2.YATTBL;
import corpy2.YUATBL;
import corpz3.ZZZSDT;
import ku.common.KUYREC;
import op.common.OP1CUPO;
import sy.common.SY1REC;
import sy.common.SY1STNBR;
import sy.common.SY2CLRID;
import sy.common.SY2REC;
import ta.common.TA1REC;
//*** PROGRAM=KL04 ****
// ;***********************************************************
// ;*  this application builds a parameter list that will be  *
// ;*  passed to a batch job for the purpose of setting up    *
// ;*  all the salesman sample return claims for a specified  *
// ;*  season. the batch program is cl2700. parms are passed  *
// ;*  in table dcorp.vparm101.                               *
// ;*                                                         *
// ;***********************************************************
// ;*       M A I N T E N A N C E    H I S T O R Y    L O G   *
// ;*---------------------------------------------------------*
// ;* PROJ#   date   pgmr    description                      *
// ;* -----  ------  -----   ---------------------------------*
// ;* cl909 10-25-90 gdecke  create application               *
// ;* cl909 06-03-91 gdecke  modify appl. for apparel prods.  *
// ;*       08-08-91 wjohns  Renamed application and commarea *
// ;*                          referrences to renamed claims  *
// ;*                          appls.                         *
// ;*       09-19-91 ahowar  changed proc&sgrp from "cl"to"kl"*
// ;* DB2   06-12-92 sgorga  Removed moves of clatbyid because
// ;*                        clascgby is being used instead.
// ;* Y2K   02-23-98 nfield  Y2K Compliance - changes to
// ;*                        KL04S40                       .
// ;***********************************************************
// *********************
Program KL04 type textUIProgram //VAGen Info - main text program
  {
  includeReferencedFunctions = yes, allowUnqualifiedItemReferences = yes, 
  throwNrfEofExceptions = yes, handleHardIOErrors = no, V60ExceptionCompatibility = yes, 
  I4GLItemsNullable = no, textLiteralDefaultIsString = no, localSQLScope = yes, 
  msgTablePrefix = "CL00", inputRecord = COMMAREA, segmented = yes
  }

  // Data Declarations
  CL04W01 CL04W01; // record
  CL04W02 CL04W02; // record
  CL04W03 CL04W03; // record
  CL04W04 CL04W04; // record
  CLAREC CLAREC; // record
  CLWREC CLWREC; // record
  CLXREC CLXREC; // record
  CLYREC CLYREC; // record
  COMMAREA COMMAREA ; // record
  ERRSQLCA ERRSQLCA; // record
  KUYREC KUYREC; // record
  SQLCA SQLCA; // record
  SY1REC SY1REC; // record
  SY2REC SY2REC; // record
  TA1REC TA1REC; // record
  XZZREC XZZREC; // record

  // VAGen Info - items needed for migration
  VAGen_EZESYS char(8);
  VAGen_EZEREPLY num(1);
  VAGen_EZE_WAIT_TIME bin(9,2);
  VAGen_EZE_ITEMLEN int;

  // Use Declarations
  use XSNTBL {deleteAfterUse = yes}; // table
  use YATTBL {deleteAfterUse = yes}; // table
  use YUATBL {deleteAfterUse = yes}; // table
  use KL04M.KL04M001,  // forms
      KL04M.KL04M005
   {
    pfKeyEquate = no
  };

  function main()
    // VAGen Info - initialization needed for migration
    VAGen_EZESYS = VGLib.getVAGSysType();
    KL04000: KL04000();
  end // end main
end // end KL04

// application main logic
Function KL04000()
   /* *************************************************************/
   /* *   this is the main logic for application kl04            **/
   /* *                                                          **/
   /* *   xsentry checks to ensure that this application was     **/
   /* *      entered from another csp application.               **/
   /* *                                                          **/
   /* *************************************************************/
  ;
  ;
  KL04001(); /* initialize the application*/
  ;
  KL04M001.XXXRVNBR = "1"; /* appl maint revision number*/
  KL04M005.XXXRVNBR = "1"; /* appl maint revision number*/
   /* also change map 5 revision nbr in cl04s67*/
  ;
  KL04M001.XXXCURDT = VGVar.currentShortGregorianDate; /* get current date for map m001*/
  KL04M005.XXXCURDT = VGVar.currentShortGregorianDate; /* get current date for map m005*/
  ;
  ;
  CLXREC.CLXEOAF = "N"; /* set end-of-appl flag to 'no'*/
  ;
  while (CLXREC.CLXEOAF == "N") /* while not end-of-appl*/
    KL04050(); /* process the application screen(s)*/
  end
  ;
  ;
  COMMAREA.CATOAP = "KL04"; /* in case of trouble*/
  XPCL002(); /* exit application*/
  ;
  ;
end // end KL04000

// initialize application
Function KL04001()
   /* *************************************************************/
   /* *     initialize the application working storage           **/
   /* *                                                          **/
   /* *  check if entry thru main menu.                          **/
   /* *  initialize maps, records and working storage.           **/
   /* *  set screen number, screen name and number of lines      **/
   /* *  possible on each.                                       **/
   /* *                                                          **/
   /* *************************************************************/
  ;
  converseVar.commitOnConverse = 1; /* force db2 to commit on each screen converse*/
  VGVar.handleHardIOErrors = 1; /* return control to program if hard db2 error*/
  ;
  ;
   /* ****TEMP001;*/
   /* ****  **** temp code for testing *****/
  ;
  XSENTRY(); /* check entered thru main menu*/
  XSSEGTR(); /* set segmented transaction id*/
  XPCL011(); /* claims entry module*/
  ;
     /* initialize working storage constants, records.*/
  ;
  ;
  set KL04M001 initial; /* clear out map kl0cm001*/
  set KL04M005 initial; /* clear out map kl0cm005*/
  set CLYREC empty; /* clear out clyrec*/
  set CL04W01 empty; /* clear out cl04w01*/
  set CL04W02 empty; /* clear out cl04w01*/
  set CL04W03 empty; /* clear out cl04w01*/
  set CL04W04 empty; /* clear out cl04w01*/
  set CLWREC empty; /* clear out clwrec*/
  set CLXREC empty; /* clear out clxrec*/
  set TA1REC empty; /* clear out ta2rec*/
  set SQLCA empty; /* clear out sqlca*/
  ;
  ;
  CLXREC.CLXEOAF = "N"; /* set application-done-switch to 'no'*/
  ;
  CLXREC.CLXCSCRN = "KL04M001"; /* set screen name*/
  ;
  CLXREC.CLXSNAME[1] = "KL04M001"; /* initialize the names of the*/
  CLXREC.CLXSNAME[2] = "KL04M005"; /* screens used in this appl*/
  ;
  CLXREC.CLXMAXLN[1] = 40; /* max lines on map 1*/
  CLXREC.CLXARY1X[1] = 1; /* start lines on map 1*/
  ;
  CLXREC.CLXMAXLN[2] = 12; /* max lines on map 2*/
  CLXREC.CLXARY1X[2] = 1; /* start lines on map 2*/
  ;
  CL04W01.CL04WMX1 = 600; /* max lines in cl04w03 table*/
  CLXREC.CLXCURLN = 1; /* ; set current cl04w03 line nbr to 1*/
  ;
  CL04W01.CL04WOVR[1] = "N"; /* reset override flags;*/
  CL04W01.CL04WOVR[2] = "N"; /* reset override flags;*/
  CL04W01.CL04WOVR[3] = "N"; /* reset override flags;*/
  CL04W01.CL04WOVR[4] = "N"; /* reset override flags;*/
  CL04W01.CL04WOVR[5] = "N"; /* reset override flags;*/
  CL04W01.CL04WOVR[6] = "N"; /* reset override flags;*/
  ;
end // end KL04001

// main cl04 branch control
Function KL04050()
   /* *************************************************************/
   /* *       main cl04 branch control                           **/
   /* *                                                          **/
   /* *  note that this process is being performed in a 'while'  **/
   /* *  loop until the end-of-application flag is set to 'y'.   **/
   /* *                                                          **/
   /* *************************************************************/
  ;
  CLXREC.CLXCPROC = "CL04050"; /* set current process name*/
  ;
  if (CLXREC.CLXCSCRN in CLXREC.CLXSNAME) /* if current screen name is*/
    CLXREC.CLXSCRNX = sysVar.arrayIndex; /* in the screen array, then set*/
  end /* the screen index*/
  ;
  ;
  CLXREC.CLXEOSF = "N"; /* set end of screen flag to 'no'*/
  CLXREC.CLXBLDSC = "Y"; /* set build screen flag to 'yes'*/
  ;
  ;
  if (CLXREC.CLXSCRNX == 1) /* if screen co0%m001*/
    while (CLXREC.CLXEOSF == "N") /* while not end of screen*/
      KL04100(); /* process screen cl0%m001*/
    end
  else
    if (CLXREC.CLXSCRNX == 2) /* if screen cl0%m005*/
      while (CLXREC.CLXEOSF == "N") /* while not end of screen*/
        KL04200(); /* process screen cl0%m005*/
      end
    else
      TA1REC.TA1TBLKE = "CLAIMS UNKNOWN SCREEN NAME";
      XPCL010();
    end
  end
  ;
  ;
    /* at this point:*/
       /* if the end of application flag (clxeoaf ) = 'n'*/
         /* the perform will return to the top of cl0%050*/
       /* else*/
         /* the perform will auto return to cl0%000.*/
  ;
  ;
end // end KL04050

// sales sample products
Function KL04100()
   /* *************************************************************/
   /* *   process screen kl04m001                                **/
   /* *                                                          **/
   /* *  note - this process is being performed in a 'while'     **/
   /* *         loop from cl04050 until the end of screen flag   **/
   /* *         (clxeosfl) is set to 'y'.                        **/
   /* *                                                          **/
   /* *************************************************************/
  ;
  CLXREC.CLXCPROC = "CL04100"; /* set current process name*/
  ;
  CLXREC.CLXMAXLN[CLXSCRNX] = 40; /* reset maximum line per page*/
  CLWREC.CLWMXIDX = CL04W01.CL04WMX1; /* init maximum select index*/
  ;
  if (CLXREC.CLXBLDSC == "Y")
    KL04101(); /* build screen because newrc*/
  end /* ; to display or pf7/pf8 keyed*/
  ;
  CLXREC.CLXBLDSC = "N"; /* skip build screen next time thru*/
     /* skip build when have errors to show, of pf 12 was keyed*/
  converse KL04M001 ;
  CLXREC.CLXMSG = " "; /* set non ezemno error message to*/
                                   /* spaces*/
  CLXREC.CLXERRF = "N"; /* re-set error flag.*/
  CLXREC.CLXUPDTF = "N"; /* init have-updates-flag*/
  ;
  ;
  CLXREC.CLXLINEX = 1;
  ;
  if (CLXREC.CLXCURLN < 1)
    CLXREC.CLXCURLN = 1;
  end
  ;
  CLWREC.CLWCLIDX = CLXREC.CLXCURLN; /* examine all the lines selected*/
  ;
    /* set the edit and update flags*/
  ;
  if (KL04M001.CLYATHPW is modified
   || KL04M001.XXXUSRID is modified
   || KL04M001.CLJNBLB is modified
   || KL04M001.OP1CUPO[1] is modified
   || KL04M001.OP1CUPO[2] is modified
   || KL04M001.XGPCD is modified
   || KL04M001.SY1STNBR[1] is modified
   || KL04M001.SY1STNBR[2] is modified
   || KL04M001.SY1STNBR[3] is modified
   || KL04M001.SY1STNBR[4] is modified
   || KL04M001.SY1STNBR[5] is modified
   || KL04M001.SY1STNBR[6] is modified
   || KL04M001.SY1STNBR[7] is modified
   || KL04M001.SY1STNBR[8] is modified
   || KL04M001.SY1STNBR[9] is modified
   || KL04M001.SY1STNBR[10] is modified
   || KL04M001.SY1STNBR[11] is modified
   || KL04M001.SY1STNBR[12] is modified
   || KL04M001.SY1STNBR[13] is modified
   || KL04M001.SY1STNBR[14] is modified
   || KL04M001.SY1STNBR[15] is modified
   || KL04M001.SY1STNBR[16] is modified
   || KL04M001.SY1STNBR[17] is modified
   || KL04M001.SY1STNBR[18] is modified
   || KL04M001.SY1STNBR[19] is modified
   || KL04M001.SY1STNBR[20] is modified
   || KL04M001.SY1STNBR[21] is modified
   || KL04M001.SY1STNBR[22] is modified
   || KL04M001.SY1STNBR[23] is modified
   || KL04M001.SY1STNBR[24] is modified
   || KL04M001.SY1STNBR[25] is modified
   || KL04M001.SY1STNBR[26] is modified
   || KL04M001.SY1STNBR[27] is modified
   || KL04M001.SY1STNBR[28] is modified
   || KL04M001.SY1STNBR[29] is modified
   || KL04M001.SY1STNBR[30] is modified
   || KL04M001.SY1STNBR[31] is modified
   || KL04M001.SY1STNBR[32] is modified
   || KL04M001.SY1STNBR[33] is modified
   || KL04M001.SY1STNBR[34] is modified
   || KL04M001.SY1STNBR[35] is modified
   || KL04M001.SY1STNBR[36] is modified
   || KL04M001.SY1STNBR[37] is modified
   || KL04M001.SY1STNBR[38] is modified
   || KL04M001.SY1STNBR[39] is modified
   || KL04M001.SY1STNBR[40] is modified)
    CLXREC.CLXEDITF = "Y"; /* set perform-edit flag to '*/
    CLXREC.CLXUPDTF = "Y"; /* set update table flag to '*/
  else
    CLXREC.CLXEDITF = "N"; /* if no entries, then no edits*/
  end
  ;
  ;
  KL04110(); /* handle any special entries*/
  ;
  ;
  if (CLXREC.CLXEDITF == "Y") /* if we still want to edit*/
    KL04120(); /* to process screen entries*/
  end
  ;
  if (CLXREC.CLXERRF == "Y")
    CLXREC.CLXCSCRN = "KL04M001"; /* show map kl04m001 next*/
    CLXREC.CLXEOSF = "N"; /* continue processing kl04m001*/
  else
    if (converseVar.eventKey is enter)
      if (CLXREC.CLXEDITF == "Y") /* if data was edited show data ok*/
        converseLib.validationFailed(669);
                                   /* msg and continue with kl04m001*/
        CLXREC.CLXCSCRN = "KL04M001";
        CLXREC.CLXEOSF = "N";
      else
        CLXREC.CLXCSCRN = "KL04M005"; /* no data was entered*/
        CLXREC.CLXEOSF = "Y"; /* go to kl04m005 next*/
      end
    else
      if (converseVar.eventKey is pf7
       || converseVar.eventKey is pf8)
        if (CLXREC.CLXEDITF == "Y") /* if data was edited show data ok*/
          converseLib.validationFailed(669);
                                   /* msg and continue with kl04m001*/
          CLXREC.CLXCSCRN = "KL04M001";
          CLXREC.CLXEOSF = "N";
        end
      end
    end
  end
  ;
  ;
   /* at this point:*/
     /* if the end of screen flag (clxeosfl) is 'n' the perform*/
       /* returns to top of process cl04100*/
     /* else*/
       /* the perform returns to cl04050*/
  ;
  ;
end // end KL04100

// initialize screen cl04m001
Function KL04101()
   /* *************************************************************/
   /* *                                                          **/
   /* *     this process will initialize screen cl04m001.        **/
   /* *       it will read the necessary tables or will scroll   **/
   /* *       forward or back                                    **/
   /* *                                                          **/
   /* *                                                          **/
   /* *************************************************************/
  ;
  CLXREC.CLXCPROC = "CL04101"; /* set current process name*/
  ;
  CLXREC.CLXARY1X[CLXSCRNX] = CLXREC.CLXCURLN;
  ;
  move CLXSCRNX to CLXSCRNX withV60Compat;
  if (CLXREC.CLXARY1X[CLXSCRNX] == 1 /* if user entered pf7 and position is*/
   && converseVar.eventKey is pf7)   /* at the beginning of the product table*/
    CLXREC.CLXLTRX1 = 1; /* compress blank prods from table*/
    CLXREC.CLXLTRX2 = 1; /* compress blank prods from table*/
    while (CLXREC.CLXLTRX1 <= CL04W01.CL04WMX1)
      if (CL04W03.SY1STNBR[CLXLTRX1] == "      ")
        CLXREC.CLXLTRX1 = CLXREC.CLXLTRX1 + 1;
      else
        CL04W03.SY1STNBR[CLXLTRX2] = CL04W03.SY1STNBR[CLXLTRX1];
        CL04W03.SY2CLRID[CLXLTRX2] = CL04W03.SY2CLRID[CLXLTRX1];
        CL04W03.XDMCD[CLXLTRX2] = CL04W03.XDMCD[CLXLTRX1];
        if (CLXREC.CLXLTRX1 > CLXREC.CLXLTRX2)
          CL04W03.SY1STNBR[CLXLTRX1] = "      ";
          CL04W03.SY2CLRID[CLXLTRX1] = "   ";
          CL04W03.XDMCD[CLXLTRX1] = "  ";
        end
        CLXREC.CLXLTRX1 = CLXREC.CLXLTRX1 + 1;
        CLXREC.CLXLTRX2 = CLXREC.CLXLTRX2 + 1;
      end
    end
  end
  ;
    /* the following computation replaces the case statement for*/
    /* getting the display page number*/
  ;
  CL04W01.CL04WPAG = CLXREC.CLXARY1X[CLXSCRNX] + CLXREC.CLXMAXLN[1];
  CL04W01.CL04WPAG = CL04W01.CL04WPAG - 1;
  CL04W01.CL04WPAG = CL04W01.CL04WPAG / 40;
  if (CL04W01.CL04WPAG < 1)
    CL04W01.CL04WPAG = 1;
  end
  KL04M001.CL04MPGE = CL04W01.CL04WPAG;
  ;
   /* IF CLXREC.CLXARY1X(CLXSCRNX) = 1;*/
    /* MOVE 1 TO CL04M001.CL04MPGE;*/
   /* ELSE ;*/
    /* IF CLXREC.CLXARY1X(CLXSCRNX) = 41;*/
      /* MOVE 2 TO CL04M001.CL04MPGE;*/
    /* ELSE ;*/
      /* IF CLXREC.CLXARY1X(CLXSCRNX) = 81;*/
        /* MOVE 3 TO CL04M001.CL04MPGE;*/
      /* ELSE ;*/
        /* IF CLXREC.CLXARY1X(CLXSCRNX) = 121;*/
          /* MOVE 4 TO CL04M001.CL04MPGE;*/
        /* ELSE ;*/
          /* IF CLXREC.CLXARY1X(CLXSCRNX) = 161;*/
            /* MOVE 5 TO CL04M001.CL04MPGE;*/
          /* END ;*/
        /* END ;*/
      /* END ;*/
    /* END ;*/
   /* END ;*/
  ;
  if (KL04M001.CL04MPGE == 1) /* if page 1 and no other errors then*/
    if (CLXREC.CLXERRF == "N") /* reset attributes per map definition*/
      set KL04M001.XXXUSRID initialAttributes;
      set KL04M001.CLYATHPW initialAttributes;
      set KL04M001.OP1CUPO[1] initialAttributes;
      set KL04M001.OP1CUPO[2] initialAttributes;
      set KL04M001.CLJNBLB initialAttributes;
      set KL04M001.XGPCD initialAttributes;
    end
  else
    set KL04M001.XXXUSRID protect; /* if not page 1 then protect*/
    set KL04M001.CLYATHPW protect, invisible;
                                   /* non-product data from re-entry*/
    set KL04M001.OP1CUPO[1] protect;
    set KL04M001.OP1CUPO[2] protect;
    set KL04M001.CLJNBLB protect;
    set KL04M001.XGPCD protect;
    set KL04M001.SY1STNBR[1] cursor;
  end
  ;
  CLXREC.CLXLINEX = 1; /* move tabled lines to map*/
  CLWREC.CLWCLIDX = CLXREC.CLXARY1X[CLXSCRNX];
  while (CLXREC.CLXLINEX <= CLXREC.CLXMAXLN[CLXSCRNX])
    if (CLXREC.CLXERRF != "Y")
      set KL04M001.SY1STNBR[CLXLINEX] normal;
      set KL04M001.SY2CLRID[CLXLINEX] normal;
    end
    KL04M001.SY1STNBR[CLXLINEX] = CL04W03.SY1STNBR[CLWCLIDX];
    KL04M001.SY2CLRID[CLXLINEX] = CL04W03.SY2CLRID[CLWCLIDX];
    KL04M001.XDMCD[CLXLINEX] = CL04W03.XDMCD[CLWCLIDX];
    CLXREC.CLXLINEX = CLXREC.CLXLINEX + 1; /* increment screen line number*/
    CLWREC.CLWCLIDX = CLWREC.CLWCLIDX + 1; /* increment table line number*/
  end
  ;
end // end KL04101

// validate screen m001 pf keys
Function KL04110()
   /* *************************************************************/
   /* *   validate screen cl04m001 pf keys                       **/
   /* *                                                          **/
   /* * the only keys acted upon at this time are pf3 and pf4    **/
   /* * and enter.                                               **/
   /* *                                                          **/
   /* * the other keys are just verified that they are used by   **/
   /* * this application. if the pf key is not recognized, the   **/
   /* * application resets all modified fields to remain modified**/
   /* * then reshows the map with an error message.              **/
   /* *                                                          **/
   /* * these other pf keys are acted upon after the editing and **/
   /* * updating have occured.                                   **/
   /* *************************************************************/
  ;
  CLXREC.CLXCPROC = "CL04110"; /* set current process name*/
  ;
  ;
  if (converseVar.eventKey is enter) /* normal 'enter;*/
    if (KL04M001.CATOAP != " ")
      COMMAREA.CATOAP = KL04M001.CATOAP;
      COMMAREA.CAITEM = KL04M001.CAITEM;
      XPCL006(); /* check item for length and type*/
      if (CLXREC.CLXVITMF == "N") /* item field not valid*/
        set KL04M001.CATOAP cursor, modified, bold;
        set KL04M001.CAITEM modified, bold;
        converseLib.validationFailed(285); /* item field or option field invalid*/
        KL04M001.XXXMSG = CLXREC.CLXMSG;
        CLXREC.CLXERRF = "Y";
        return;
      else
        if (COMMAREA.CAITEM != " ")
          set CLAREC empty;
          CLAREC.CLACLMNB = CLWREC.CLWITM1N;
          call "IO1160" ("S ", SQLCA, CLAREC) {isNoRefresh = yes, isExternal = yes}; /* get cl*/
        end
      end
      XPCL002(); /* check security/xfer*/
      KL04M001.XXXMSG = COMMAREA.CAMSG; /* security failed*/
      COMMAREA.CATOAP = " ";
      CLXREC.CLXERRF = "Y";
      CLXREC.CLXEDITF = "Y";
    else
      if (KL04M001.CAITEM != " ") /* fastpath request*/
        set KL04M001.CATOAP cursor, modified, bold;
        converseLib.validationFailed(1); /* item field not valid unless option is entered*/
        CLXREC.CLXERRF = "Y";
        CLXREC.CLXEDITF = "Y";
      end
    end
    ;
    return;
  end
  ;
  ;
  if (converseVar.eventKey is pf3) /* skip edit, update - exit*/
    KL04S03();
  end
  ;
  if (converseVar.eventKey is pf4) /* skip edit, update - exit*/
    KL04S04();
  end
  ;
  if (converseVar.eventKey is pf7) /* page back*/
    if (CLXREC.CLXEDITF == "N")
      KL04S07();
    end
    return;
  end
  ;
  if (converseVar.eventKey is pf8) /* page forward*/
    if (CLXREC.CLXEDITF == "N")
      KL04S08();
    end
    return;
  end
  ;
  ;
    /* all other pf keys are invalid*/
  ;
  converseLib.validationFailed(2); /* pf key not valid*/
  KL04S26(); /* set fields modfd so user n*/
  CLXREC.CLXEDITF = "N"; /* do not edit map, just re-show it*/
  CLXREC.CLXUPDTF = "N";
  ;
  ;
end // end KL04110

// process screen m001 entrys
Function KL04120()
   /* *************************************************************/
   /* *  this process handles all edits of screen fields, and any**/
   /* *  subsequent updating required by entries into screen     **/
   /* *  cl04m001.                                               **/
   /* **                                                         **/
   /* *************************************************************/
  ;
  CLXREC.CLXCPROC = "CL04120"; /* set current process name*/
  ;
  ;
     /* individual field edits:*/
  ;
  ;
  if (KL04M001.XGPCD is modified /* edit gpc code*/
   || KL04M001.XGPCD == "  ")   
    KL04S53();
  end
  ;
  ;
  if (KL04M001.XGPCD != "  ")
    CL04W01.CL04WIX2 = 1;
    CL04W01.CL04WIX1 = 0;
    CL04W01.CL04WCT1 = 0;
    ;
    while (CL04W01.CL04WIX2 <= CLXREC.CLXMAXLN[1]) /* edit product*/
      KL04S66(); /* id's on all map lines*/
    end
  end
  ;
  ;
  if (KL04M001.CLJNBLB is modified /* edit number of labels*/
   || KL04M001.CLJNBLB == 0)       /* edit number of labels*/
    KL04S52();
  end
  ;
  ;
  if (KL04M001.OP1CUPO[1] is modified /* edit cust po id*/
   || KL04M001.OP1CUPO[2] is modified 
   || KL04M001.OP1CUPO[1] == " "      
   || KL04M001.OP1CUPO[2] == " ")    
    KL04S51();
  end
  ;
  if (KL04M001.CLYATHPW is modified   /* edit auth-by-id/password*/
   || KL04M001.XXXUSRID is modified   
   || KL04M001.CLYATHPW == "        " /* edit auth-by-id/password*/
   || KL04M001.XXXUSRID == "        ")
    KL04150();
  end
  ;
  ;
  if (CL04W01.CL04WCT1 > 0) /* if at least one item changed*/
    CLXREC.CLXBLDSC = "Y"; /* flag to re-build screen*/
  end
  ;
  ;
end // end KL04120

// edit authorized by id
Function KL04150()
   /* *************************************************************/
   /* *   cl04s50 - edit authorized by id and password           **/
   /* *************************************************************/
  ;
  CLXREC.CLXCPROC = "CL04S50"; /* set current process name*/
  ;
  ;
  if (KL04M001.XXXUSRID == "        "
   /* both of these user id and password*/
   && KL04M001.CLYATHPW == "        ") /* must be entered*/
    converseLib.validationFailed(021); /* show auth by id/password invalid msg*/
    set KL04M001.XXXUSRID cursor, modified, bold;
    CLXREC.CLXERRF = "Y"; /* set attribute and error flag*/
    return;
  end
  ;
  ;
  if (KL04M001.XXXUSRID == "        "
   /* both of these user id and password*/
   || KL04M001.CLYATHPW == "        ") /* must be entered*/
    converseLib.validationFailed(036); /* show auth by id/password invalid msg*/
    set KL04M001.XXXUSRID cursor, modified, bold;
    CLXREC.CLXERRF = "Y"; /* set attribute and error flag*/
    return;
  end
  ;
  ;
  if (KL04M001.CLYATHPW is modified
   || KL04M001.XXXUSRID is modified)
    set CLYREC empty;
    CLYREC.XXXUSRID = KL04M001.XXXUSRID;
  else
    return;
  end
  ;
  KL04901(); /* get claims authorization table line*/
  ;
  if (SQLCA.VAGen_SQLCODE == +100) /* user id must be on the authorization table*/
    converseLib.validationFailed(078); /* show auth by id/password invalid msg*/
    set KL04M001.XXXUSRID cursor, modified, bold;
    CLXREC.CLXERRF = "Y"; /* set attribute and error flag*/
    return;
  end
  ;
  ;
  if (CLYREC.XXXSTAT == "I") /* user id must have active status in*/
                                   /* auth table*/
    converseLib.validationFailed(652); /* show auth by id/password invalid msg*/
    set KL04M001.XXXUSRID cursor, modified, bold;
    CLXREC.CLXERRF = "Y"; /* set attribute and error flag*/
    return;
  end
  ;
  ;
  if (KL04M001.CLYATHPW != CLYREC.CLYATHPW)
    converseLib.validationFailed(354); /* show auth by id/password invalid msg*/
    set KL04M001.XXXUSRID cursor, modified, bold;
    CLXREC.CLXERRF = "Y"; /* set attribute and error flag*/
    return;
  end
  ;
  CL04W01.CL04WIX2 = 1; /* index to control loop*/
  CL04W01.CL04WCT2 = 0; /* count of clm type codes = 'adj'*/
  CL04W01.CL04WCT3 = 0; /* count of clm type codes = 'rts'*/
  CL04W01.CL04WCT1 = 0; /* clm type codes = 'rts' & lim> 10k*/
  while (CL04W01.CL04WIX2 <= 20) /* get count of claim type occurances*/
    KL04902(); /* having 'rts' or 'adj' values*/
  end
  ;
  if (CL04W01.CL04WCT2 == 0 /* if user does not have sufficient authority*/
   || CL04W01.CL04WCT3 == 0) /* for both the rts and def claims, show msg.*/
    converseLib.validationFailed(653);
    set KL04M001.XXXUSRID cursor, modified, bold;
    CLXREC.CLXERRF = "Y"; /* set attribute and error flag.*/
    return;
  end
  ;
  ;
  if (CL04W01.CL04WCT1 == 0) /* if user does not have rts limit over 10k*/
    converseLib.validationFailed(077);
    set KL04M001.XXXUSRID cursor, modified, bold;
    CLXREC.CLXERRF = "Y"; /* set attribute and error flag.*/
    return;
  end
  ;
  CL04W03.XXXUSRID = KL04M001.XXXUSRID;
  CL04W03.CLYATHPW = KL04M001.CLYATHPW;
  CL04W03.CLYATHID = CLYREC.CLYATHID;
  ;
end // end KL04150

// sales sample comments
Function KL04200()
   /* *************************************************************/
   /* *   process screen kl04m005                                **/
   /* *                                                          **/
   /* *  note:  this process is being performed in a 'while'     **/
   /* *         loop from cl04050 until the end of screen flag   **/
   /* *         (clxeosfl) is set to 'n'.                        **/
   /* *                                                          **/
   /* *                                                          **/
   /* *************************************************************/
  ;
  CLXREC.CLXCPROC = "CL04200"; /* set current process name*/
  ;
  ;
  if (CLXREC.CLXBLDSC == "Y")
    KL04201(); /* build screen because of ne*/
  end /* to display authorization data*/
  ;
  CLXREC.CLXBLDSC = "N"; /* skip build screen next time thru*/
   /* skip build when there are errors to show, or pf 12 was keyed*/
  ;
  converse KL04M005 ;
  ;
  ;
  CLXREC.CLXMSG = " "; /* set non-ezemno error message to*/
                                   /* spaces*/
  CLXREC.CLXERRF = "N"; /* init errors-on-screen flag*/
  CLXREC.CLXUPDTF = "N"; /* init have-updates-flag*/
  ;
  ;
  if (KL04M005.CL04MCMP is modified
   || KL04M005.CLGCOMNT[1] is modified
   || KL04M005.CLGCOMNT[2] is modified
   || KL04M005.CLGCOMNT[3] is modified
   || KL04M005.CLGCOMNT[4] is modified
   || KL04M005.CLGCOMNT[5] is modified
   || KL04M005.CLGCOMNT[6] is modified
   || KL04M005.CLGCOMNT[7] is modified
   || KL04M005.CLGCOMNT[8] is modified
   || KL04M005.CLGCOMNT[9] is modified
   || KL04M005.CLGCOMNT[10] is modified
   || KL04M005.CLGCOMNT[11] is modified
   || KL04M005.CLGCOMNT[12] is modified)
    CLXREC.CLXEDITF = "Y"; /* set perform-edit-flag to '*/
    CLXREC.CLXUPDTF = "Y"; /* set update table flag to '*/
  else
    CLXREC.CLXEDITF = "N"; /* IF NO ENTRIES, THEN NO EDITS*/
  end
  ;
  ;
  KL04210(); /* handle any special entries*/
  ;
  ;
  if (CLXREC.CLXEDITF == "Y") /* if we still want to edit*/
    KL04220(); /* go process screen entries*/
  end
  ;
  ;
  CL04W03.XXXUSRID = CL04W03.XXXUSRID;
  CL04W03.CLYATHPW = CL04W03.CLYATHPW;
  CL04W03.XGPCD = CL04W03.XGPCD;
  CL04W03.CL04WNLB = CL04W03.CL04WNLB;
  CL04W03.OP1CUPO[1] = CL04W03.OP1CUPO[1];
  CL04W03.OP1CUPO[2] = CL04W03.OP1CUPO[2];
  CL04W01.CL04WOVR[1] = CL04W01.CL04WOVR[1];
  CL04W01.CL04WOVR[2] = CL04W01.CL04WOVR[2];
  CL04W01.CL04WOVR[3] = CL04W01.CL04WOVR[3];
  CL04W01.CL04WOVR[4] = CL04W01.CL04WOVR[4];
  KL04M005.CL04MCMP = KL04M005.CL04MCMP;
  ;
  ;
  if (CLXREC.CLXERRF == "N"      /* only update clm auth if no*/
   && CL04W03.XXXUSRID != " "    /* and all the required fields*/
   && CL04W03.CLYATHPW != " "    /* have some data*/
   && CL04W03.XGPCD != " "       
   /* **** CL04W03.CL04WNLB NE 0     ; NBR LABELS = 0 IS OK*/
   && CL04W03.OP1CUPO[1] != " "  
   && CL04W03.OP1CUPO[2] != " "  
   && CL04W01.CL04WOVR[1] == "Y" /* ra cmt entered or overridden*/
   && CL04W01.CL04WOVR[2] == "Y" /* cr memo cmt entered or overridden*/
   && CL04W01.CL04WOVR[3] == "Y" /* dr memo cmt entered or overridden*/
   && CL04W01.CL04WOVR[4] == "Y")
                                   /* carryover product entered of override*/
    if (KL04M005.CL04MCMP == "Y") /* if user says it's time to update*/
      KL04S40(); /* perform update routine*/
      if (CLXREC.CLXERRF == "Y") /* if we already have a message*/
         /* next sentence        do nothing*/
      else
        converseLib.validationFailed(349); /* show task completed message*/
        CLXREC.CLXERRF = "Y";
      end
    else
      if (CL04W01.CL04WOVR[5] == "Y") /* if this message already shown*/
         /* next sentence             do nothing*/
      else
        CL04W01.CL04WOVR[5] = "Y";
        converseLib.validationFailed(318);
        set KL04M005.CL04MCMP cursor, modified, bold;
        KL04M005.CL04MCMP = "?";
        CLXREC.CLXERRF = "Y";
      end
    end
  end
  ;
  ;
  if (CLXREC.CLXERRF == "Y") /* if errors found*/
    KL04S27(); /* set field attributes so operator*/
  end /* wont have to reenter all map data*/
  ;
  ;
  if (CLXREC.CLXERRF == "Y") /* if errors found*/
    CLXREC.CLXCSCRN = "KL04M005"; /* show kl04m005 map next*/
    CLXREC.CLXEOSF = "N"; /* continue processing kl04m005*/
  end
  ;
  ;
    /* at this point-*/
      /* if the end-of-screen flag (clxeosfl) is 'n'*/
        /* we go back to top of process cl04200.*/
      /* if the end-of-screen flag (clxeosfl) is 'y'*/
        /* we return to cl04050.*/
  ;
  ;
  ;
end // end KL04200

// initialize screen cl04m005
Function KL04201()
   /* ************************************************************/
   /* *                                                         **/
   /* *  this process will initialize screen cl04m005.          **/
   /* *    it will read the necessary tables and move the data  **/
   /* *    to the map area.                                     **/
   /* **                                                        **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL04201"; /* set current process name*/
  ;
  KL04M005.XXXUSRID = CL04W03.XXXUSRID;
  KL04M005.OP1CUPO[1] = CL04W03.OP1CUPO[1];
  KL04M005.OP1CUPO[2] = CL04W03.OP1CUPO[2];
  KL04M005.CLJNBLB = CL04W03.CL04WNLB;
  KL04M005.XGPCD = CL04W03.XGPCD;
  ;
  ;
end // end KL04201

// edit screen m005 entrys
Function KL04210()
   /* *************************************************************/
   /* *  validate screen kl04M005 pf keys                        **/
   /* *                                                          **/
   /* * the only keys acted upon at this time are pf3 and pf4,   **/
   /* * and enter.                                               **/
   /* *                                                          **/
   /* * the other keys are just verified that they are used by   **/
   /* * this application. if the pf key is not recognized, the   **/
   /* * application resets all modified fields to remain modified**/
   /* * then reshows the map with an error message.              **/
   /* *                                                          **/
   /* * the other pf keys are acted upon after the editing and   **/
   /* * updating have occured.                                   **/
   /* *                                                          **/
   /* *************************************************************/
  ;
  CLXREC.CLXCPROC = "CL04210"; /* set current process name*/
  ;
  ;
  if (converseVar.eventKey is enter) /* normal 'enter'*/
    if (KL04M005.CATOAP != " ")
      COMMAREA.CATOAP = KL04M005.CATOAP;
      COMMAREA.CAITEM = KL04M005.CAITEM;
      XPCL006(); /* check item for length and type*/
      if (CLXREC.CLXVITMF == "N") /* item field not valid*/
        set KL04M005.CATOAP cursor, modified, bold;
        set KL04M005.CAITEM modified, bold;
        converseLib.validationFailed(285); /* item field of option field invalid*/
        KL04M005.XXXMSG = CLXREC.CLXMSG;
        return;
      else
             /* IF COMMAREA.CAITEM NE ' ';*/
               /* SET CLYREC EMPTY;*/
               /* MOVE CLWREC.CLWITM1N TO CLYREC.CLYATHID;*/
               /* CALL IO2650 'S ',SQLCA,CLYREC (NOMAPS,NONCSP; get cla*/
             /* END ;*/
      end
      XPCL002(); /* check security/xfer*/
      KL04M005.XXXMSG = COMMAREA.CAMSG; /* security failed*/
      COMMAREA.CATOAP = " ";
      CLXREC.CLXERRF = "Y";
      CLXREC.CLXEDITF = "Y";
    else
      if (KL04M005.CAITEM != " ") /* fastpath request*/
        set KL04M005.CATOAP cursor, modified, bold;
        converseLib.validationFailed(1); /* item field not valid unless option is entered*/
        CLXREC.CLXERRF = "Y";
        CLXREC.CLXEDITF = "Y";
      end
    end
    ;
    CLXREC.CLXCSCRN = "KL04M001"; /* show m001 map next*/
    CLXREC.CLXEOSF = "Y"; /* ; stop processing m005 map*/
    ;
    return;
  end
  ;
  ;
  if (converseVar.eventKey is pf3) /* skip edit, update - exit*/
    KL04S03();
  end
  ;
  if (converseVar.eventKey is pf4) /* skip edit, update - exit*/
    KL04S04();
  end
  ;
  ;
    /* pf key not valid*/
  ;
  converseLib.validationFailed(2); /* pf key not valid*/
  KL04S27();
                                   /* set fields modfd so user won't re-key*/
  CLXREC.CLXEDITF = "N"; /* do not edit map, just re-show it*/
  CLXREC.CLXUPDTF = "N";
  ;
  ;
end // end KL04210

// process screen m005 entrys
Function KL04220()
   /* *************************************************************/
   /* *  this process handles all edit of screen fields, and any **/
   /* *  subsequent updating required by entries into screen     **/
   /* *  cl04m005.                                               **/
   /* *                                                          **/
   /* *************************************************************/
  ;
  CLXREC.CLXCPROC = "CL04220"; /* set current proc name*/
  ;
   /* ****/
   /* ***    edit label comments*/
   /* ****/
  if (KL04M005.CLGCOMNT[1] == "  ")
    if (CL04W01.CL04WOVR[1] != "Y")
      converseLib.validationFailed(656); /* show no label comments warning*/
      CL04W01.CL04WOVR[1] = "Y"; /* indicates label cmt msg was shown*/
      set KL04M005.CLGCOMNT[1] cursor, modified, bold; /* set field attr*/
      CLXREC.CLXERRF = "Y"; /* set error flag on*/
      return;
    else
      set KL04M005.CLGCOMNT[1] initialAttributes; /* reset comment attribute*/
    end
  else
    CL04W03.CLGCOMNT[1] = KL04M005.CLGCOMNT[1];
    CL04W03.CLGCOMNT[2] = KL04M005.CLGCOMNT[2];
    CL04W03.CLGCOMNT[3] = KL04M005.CLGCOMNT[3];
    CL04W03.CLGCOMNT[4] = KL04M005.CLGCOMNT[4];
    set KL04M005.CLGCOMNT[1] initialAttributes; /* reset comment attribute*/
    CL04W01.CL04WOVR[1] = "Y"; /* indicates cmt data accepted*/
  end
  ;
   /* ****/
   /* ***    edit credit memo comments*/
   /* ****/
  if (KL04M005.CLGCOMNT[5] == "  ")
    if (CL04W01.CL04WOVR[2] != "Y")
      converseLib.validationFailed(657); /* show no label comments warning*/
      CL04W01.CL04WOVR[2] = "Y"; /* indicates label cmt msg was shown*/
      set KL04M005.CLGCOMNT[5] cursor, modified, bold; /* set field attr*/
      CLXREC.CLXERRF = "Y"; /* set error flag on*/
      return;
    else
      set KL04M005.CLGCOMNT[5] initialAttributes; /* reset comment attribute*/
    end
  else
    CL04W03.CLGCOMNT[5] = KL04M005.CLGCOMNT[5];
    CL04W03.CLGCOMNT[6] = KL04M005.CLGCOMNT[6];
    CL04W03.CLGCOMNT[7] = KL04M005.CLGCOMNT[7];
    CL04W03.CLGCOMNT[8] = KL04M005.CLGCOMNT[8];
    set KL04M005.CLGCOMNT[5] initialAttributes; /* reset comment attribute*/
    CL04W01.CL04WOVR[2] = "Y"; /* indicates cmt data accepted*/
  end
  ;
   /* ****/
   /* ***    edit debit memo comments*/
   /* ****/
  if (KL04M005.CLGCOMNT[9] == "  ")
    if (CL04W01.CL04WOVR[3] != "Y")
      converseLib.validationFailed(658); /* show no label comments warning*/
      CL04W01.CL04WOVR[3] = "Y"; /* indicates label cmt msg was shown*/
      set KL04M005.CLGCOMNT[9] cursor, modified, bold; /* set field attr*/
      CLXREC.CLXERRF = "Y"; /* set error flag on*/
      return;
    else
      set KL04M005.CLGCOMNT[9] initialAttributes; /* reset comment attribute*/
    end
  else
    CL04W03.CLGCOMNT[9] = KL04M005.CLGCOMNT[9];
    CL04W03.CLGCOMNT[10] = KL04M005.CLGCOMNT[10];
    CL04W03.CLGCOMNT[11] = KL04M005.CLGCOMNT[11];
    CL04W03.CLGCOMNT[12] = KL04M005.CLGCOMNT[12];
    set KL04M005.CLGCOMNT[9] initialAttributes; /* reset comment attribute*/
    CL04W01.CL04WOVR[3] = "Y"; /* indicates cmt data accepted*/
  end
  ;
  ;
   /* ****/
   /* ***    edit complete flag*/
   /* ****/
  if (KL04M005.CL04MCMP is modified)
    if (KL04M005.CL04MCMP == "N ")
      KL04M005.CL04MCMP = " ";
    else
      if (KL04M005.CL04MCMP == "Y"
       || KL04M005.CL04MCMP == " ")
         /* next sentence*/
      else
        CL04W01.CL04WOVR[5] = "Y";
        converseLib.validationFailed(318); /* show complete flag invalid message*/
        set KL04M005.CL04MCMP cursor, modified, bold;
                                   /* set field attribute*/
        CLXREC.CLXERRF = "Y"; /* set error flag on*/
      end
    end
  else /* complete flag was not modified*/
    if (CLXREC.CLXERRF == "N") /* and no comment errors*/
      KL04M005.CL04MCMP = "?"; /* then prompt user for cmp flag*/
      CL04W01.CL04WOVR[5] = "Y";
      converseLib.validationFailed(318); /* show complete flag invalid message*/
      set KL04M005.CL04MCMP cursor, modified, bold; /* set field attribute*/
      CLXREC.CLXERRF = "Y"; /* set error flag on*/
    end
  end
  ;
end // end KL04220

// select unique auth table
Function KL04901()
   /* *************************************************************/
   /* *  select unique on clyrec (claim authorization table      **/
   /* *************************************************************/
  ;
  set SQLCA empty;
  call "IO2650" ("SB", SQLCA, CLYREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy, try later*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
        set CLYREC empty;
      else
        ;
        TA1REC.TA1LOCAT[2] = "CL04901"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO2650"; /* location*/
        TA1REC.TA1DBASE = "DCLAIM"; /* database name*/
        TA1REC.TA1TBLVU = "VCLATH01"; /* table view name*/
        CLXREC.XXXWDTE = KL04M001.CLYATHPW;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* table key*/
        ;
        XPCL010(); /* error diagnosis routine*/
      end
    end
  end
  ;
end // end KL04901

// edit auth table claim type
Function KL04902()
   /* *************************************************************/
   /* * cl04902 - edit auth table claim type                     **/
   /* *************************************************************/
  ;
  if (CLYREC.YCTCD[CL04WIX2] == "ADJ") /* count claim types = 'rts'*/
    CL04W01.CL04WCT2 = CL04W01.CL04WCT2 + 1;
  else
    if (CLYREC.YCTCD[CL04WIX2] == "RTS")
                                   /* count claim types = 'def' and*/
      CL04W01.CL04WCT3 = CL04W01.CL04WCT3 + 1;
      if (CLYREC.CLYATHLM > 10000) /* auth limit > $10,000.*/
        CL04W01.CL04WCT1 = CL04W01.CL04WCT1 + 1;
      end
    else
      if (CLYREC.YCTCD[CL04WIX2] == "   ") /* exit if no more claim types*/
        CL04W01.CL04WIX2 = 21;
        return;
      end
    end
  end
  ;
  CL04W01.CL04WIX2 = CL04W01.CL04WIX2 + 1; /* increment index*/
  ;
  ;
end // end KL04902

// pf3 exit to claims
Function KL04S03()
   /* *************************************************************/
   /* * skip edits / update, go to higher level in claims        **/
   /* *                                                          **/
   /* * ** your application may need to go elsewhere **          **/
   /* *                                                          **/
   /* *************************************************************/
  ;
  COMMAREA.CATOAP = "KL0A"; /* go to claims menu*/
  ;
  XPCL002(); /* common claims exit*/
  ;
  ;
end // end KL04S03

// pf4 exit to master menu
Function KL04S04()
   /* *************************************************************/
   /* *  skip edits / update, go to goal master menu             **/
   /* *************************************************************/
  ;
  XSPF4();
  ;
  ;
end // end KL04S04

// page back on cl04m001-pf7
Function KL04S07()
   /* *************************************************************/
   /* *                                                          **/
   /* * this process handles the entry of pf key 7               **/
   /* *      (paging backward)                                   **/
   /* *************************************************************/
  ;
  ;
  CLXREC.CLXCURLN = CLXREC.CLXCURLN - CLXMAXLN[CLXSCRNX];
  if (CLXREC.CLXCURLN <= 1)
    CLXREC.CLXCURLN = 1;
    converseLib.validationFailed(7);
  end
  ;
  CLXREC.CLXARY1X[CLXSCRNX] = CLXREC.CLXCURLN;
  ;
  CLXREC.CLXBLDSC = "Y";
  ;
  ;
end // end KL04S07

// page frwd on cl04m001-pf8
Function KL04S08()
   /* *************************************************************/
   /* * this process handles the entry of pf key 8               **/
   /* *    (paging forward)                                      **/
   /* *                                                          **/
   /* *************************************************************/
  ;
  if (CLXREC.CLXCURLN <= 1)
    CLXREC.CLXCURLN = 1;
  end
  ;
  CLXREC.CLXCURLN = CLXREC.CLXCURLN + CLXREC.CLXMAXLN[CLXSCRNX];
  if (CLXREC.CLXCURLN > CL04W01.CL04WMX1)
    converseLib.validationFailed(3); /* at end of data*/
    CLXREC.CLXCURLN = CLXREC.CLXCURLN - CLXREC.CLXMAXLN[CLXSCRNX];
  end
  ;
  CLXREC.CLXARY1X[CLXSCRNX] = CLXREC.CLXCURLN;
  ;
    /* force build new screen*/
  ;
  CLXREC.CLXBLDSC = "Y";
  ;
  ;
end // end KL04S08

// modify entered fields
Function KL04S26()
   /* *************************************************************/
   /* *  since the map must be re-shown to the user before       **/
   /* *  editing has been done, set fields modified to keep      **/
   /* *  track of  all the fields entered by the user.           **/
   /* *  the user will only need to re-do the pf key or enter    **/
   /* *  key, not enter the data again.                          **/
   /* *************************************************************/
  ;
  ;
  if (KL04M001.CLYATHPW is modified)
    set KL04M001.CLYATHPW modified;
  end
  ;
  ;
  if (KL04M001.CLJNBLB is modified)
    set KL04M001.CLJNBLB modified;
  end
  ;
  if (KL04M001.XGPCD is modified)
    set KL04M001.XGPCD modified;
  end
  ;
  if (KL04M001.OP1CUPO[1] is modified)
    set KL04M001.OP1CUPO[1] modified;
  end
  ;
  if (KL04M001.OP1CUPO[2] is modified)
    set KL04M001.OP1CUPO[2] modified;
  end
  ;
  CL04W01.CL04WIX2 = 1;
  while (CL04W01.CL04WIX2 <= 40)
    if (KL04M001.SY1STNBR[CL04WIX2] is modified)
      set KL04M001.SY1STNBR[CL04WIX2] modified;
    end
    if (KL04M001.SY2CLRID[CL04WIX2] is modified)
      set KL04M001.SY2CLRID[CL04WIX2] modified;
    end
    if (KL04M001.XDMCD[CL04WIX2] is modified)
      set KL04M001.XDMCD[CL04WIX2] modified;
    end
    CL04W01.CL04WIX2 = CL04W01.CL04WIX2 + 1;
  end
  ;
  ;
  ;
end // end KL04S26

// set cl04m005 fields modified
Function KL04S27()
   /* *************************************************************/
   /* * since the map must be re-shown to the user before editing**/
   /* * has been done, set fields moidfied to keep track of all  **/
   /* * the fields entered by the user. the user will only need  **/
   /* * to re-do the pf key or enter key, not enter the data     **/
   /* * again.                                                   **/
   /* *************************************************************/
  ;
  ;
  if (KL04M005.CL04MCMP is modified)
    set KL04M005.CL04MCMP modified;
  end
  ;
  ;
  CL04W01.CL04WIX2 = 1;
  while (CL04W01.CL04WIX2 <= 12)
    ;
    if (KL04M005.CLGCOMNT[CL04WIX2] is modified)
      set KL04M005.CLGCOMNT[CL04WIX2] modified;
    end
    ;
    CL04W01.CL04WIX2 = CL04W01.CL04WIX2 + 1;
    ;
  end
  ;
end // end KL04S27

// write sample claims parameters
Function KL04S40()
    /* **********************************************************/
    /* ** cl04s40 sgrp created 9-27-90 by gdecke              ***/
    /* **********************************************************/
  ;
   /* -------------- prepare data for  DCORP.VPARM101----------*/
     /* used in batch cl1371 for overnight 'batch only' rpts*/
   /* ------------------------------------------------------------*/
  ;
  CLXREC.CLXCPROC = "CL04S40";
  TA1REC.TA1LOCAT[1] = "CL04S40";
  ;
  set CL04W02 empty; /* CLEAR WORKING STORAGE AREA FOR OUTPUT*/
                                   /* RECORDS*/
  ;
  ;
     /* move input data to cl04w02 fields*/
  ;
  ;
     /* build record key fields*/
  ;
  CL04W02.XZZQRYID = "CL2730"; /* query id*/
  CL04W02.XZZQRYRN = 1; /* query request number*/
  CL04W02.XROCD = "  "; /* no remote printers will be involved*/
  CL04W02.XZZQRYLN = 1; /* query line number*/
  ;
   /* query line nbr created below*/
  ;
   /* -------Y2K OUT--------------*/
   /* MOVE EZEDTE TO CL04W02.CL04WSDT;  /* creation date*/
   /* CL04W02.CL04WSDT = CL04W02.CL04WSDT + 19000000;/* add century*/
   /* -------Y2K OUT--------------*/
   /* -------Y2K IN---------------*/
  CL04W02.CL04WSDT = VGVar.currentGregorianDate; /* creation date*/
   /* -------Y2K IN---------------*/
  CL04W02.ZZZSDT = CL04W02.CL04WSDT; /* convert to binary*/
  ;
  CL04W02.CL04WETM = VGVar.currentFormattedTime; /* creation time*/
  CL04W02.CL04WHH = CL04W02.CL04WEHH;
  CL04W02.CL04WMM = CL04W02.CL04WEMM;
  CL04W02.ZZZSTM = CL04W02.CL04WTM; /* convert to binary*/
  ;
     /* get last request nbr written to dcorp.vparm001,Xzzrec*/
  ;
  set XZZREC empty;
  ;
  XZZREC.XZZQRYID = CL04W02.XZZQRYID;
  CL04W04.CL04W4SQ = "SM"; /* select max = sql function*/
  CL04W04.CL04W4ID = 0; /* init io-indicator*/
  ;
  call "IO1000" (CL04W04, SQLCA, XZZREC) {isNoRefresh = yes, isExternal = yes};
                                   /* get max request # in use*/
  ;
  if (CL04W04.CL04W4ID < 0) /* 7-27-90 new code*/
    CL04W02.XZZQRYRN = 1; /* if empty table,start at # 1*/
  else
    if (SQLCA.VAGen_SQLCODE < 0)
      TA1REC.TA1DBASE = "DCORP";
      TA1REC.TA1TBLVU = "VPARM101";
      TA1REC.TA1LOCAT[3] = "CL04S40";
      TA1REC.TA1LOCAT[4] = "IO1000";
      TA1REC.TA1TBLKE = XZZREC.XZZQRYID;
      XPCL010(); /* abend*/
    else
      if (SQLCA.VAGen_SQLCODE == 100)
        CL04W02.XZZQRYRN = 1; /* if not found,start at 1*/
      else
        CL04W02.XZZQRYRN = XZZREC.XZZQRYRN + 1; /* incre last # by 1*/
        KL04S44(); /* check for duplicate request*/
        if (CLXREC.CLXERRF == "Y")
          return;
        end
      end
    end
  end
  ;
  CL04W03.CL04WPCT = 0;
  CL04W01.CL04WIX2 = 1;
  while (CL04W01.CL04WIX2 <= CL04W01.CL04WMX1)
    if (CL04W03.SY1STNBR[CL04WIX2] != "      ")
      CL04W03.CL04WPCT = CL04W03.CL04WPCT + 1;
    end
    CL04W01.CL04WIX2 = CL04W01.CL04WIX2 + 1;
  end
  ;
  if (CLXREC.CLXERRF == "N")
    if (CL04W03.CL04WPCT == 0)
      if (CL04W01.CL04WOVR[6] != "Y")
        converseLib.validationFailed(655);
        CL04W01.CL04WOVR[6] = "Y";
        set KL04M005.CL04MCMP cursor, modified, bold;
        KL04M005.CL04MCMP = " ";
        CLXREC.CLXERRF = "Y";
        return;
      end
    else
      CL04W01.CL04WOVR[6] = "Y";
    end
  end
  ;
  ;
     /* write parameter records for sales sample generate*/
  ;
  KL04S41(); /* write 4 parms to dcorp.vparm101*/
  ;
  ;
     /* report back to user*/
  ;
  KL04M005.CL04MCMP = " "; /* clear complete flag*/
  converseLib.validationFailed(272); /* job was submitted*/
  CLXREC.CLXERRF = "Y"; /* force message*/
  ;
  ;
end // end KL04S40

// write 4 parms to xzzrec
Function KL04S41()
   /* ******************************/
   /* **   sgrp created 3-8-88   ***/
   /* **************************************************************/
   /* MAINTENANCE HISTORY*/
   /*  */
   /* 06-10-92  sgorga  Removed 4 lines of code referencing*/
   /* clatbyid because we are using clascgby*/
   /* (which is userid 'ttansi') to pass to the*/
   /* batch program.  In both W02 and W03 working*/
   /* storage records, changed 'CLATBYID' field to*/
   /* '*', character, 2 bytes (from bin, pcked).*/
   /* **************************************************************/
  ;
   /* ---------------- WRITE 4 RECORDS TO DCORP.VPARM101----------*/
               /* RECORDS USED FOR NIGHTLY BATCH job cl1371*/
   /* ------------------------------------------------------------*/
  ;
  CLXREC.CLXCPROC = "CL04S41";
  TA1REC.TA1LOCAT[1] = "CL04S41";
  ;
  ;
     /* first parameter*/
  ;
  set XZZREC empty;
  CL04W02.XZZQRYLN = 1;
   /* MOVE COMMAREA.CAUSERID TO CL04W03.CLASCGBY;*/
  ;
   /* PERFORM CL04155       ;          select dcust.vsvrep01 to ge*/
  ;
  CL04W03.CLASCGBY = "TTANSI";
  ;
  CL04W03.XWHCD = COMMAREA.XWHCD;
  CL04W02.XXXUSRID = CL04W03.XXXUSRID;
  CL04W02.XZZINT1 = CL04W03.CLYATHID;
  CL04W02.CLYATHPW = CL04W03.CLYATHPW;
  CL04W02.XGPCD = CL04W03.XGPCD;
  CL04W02.CL04WNLB = CL04W03.CL04WNLB;
  CL04W02.CLASCGBY = CL04W03.CLASCGBY;
  CL04W02.XWHCD = CL04W03.XWHCD;
  ;
  ;
   /* MOVE 0 TO CL04W03.CL04WPCT      ; count the products*/
   /* MOVE 1 TO CL04W01.CL04WIX2;*/
   /* WHILE CL04W01.CL04WIX2 LE cl04w01.cl04wmx1;*/
    /* IF CL04W03.SY1STNBR(CL04WIX2) NE '      ';*/
      /* CL04W03.CL04WPCT = CL04W03.CL04WPCT + 1;*/
    /* END ;*/
    /* CL04W01.CL04WIX2 = CL04W01.CL04WIX2 + 1;*/
   /* END ;*/
  CL04W02.CL04WPCT = CL04W03.CL04WPCT; /* move prod count to parm*/
  ;
  ;
  CL04W03.CL04WCCT = 0;
  CL04W01.CL04WIX2 = 1;
  while (CL04W01.CL04WIX2 <= 12)
    if (CL04W03.CLGCOMNT[CL04WIX2] != " ") /* count number of comments*/
      CL04W03.CL04WCCT = CL04W03.CL04WCCT + 1;
    end
    CL04W01.CL04WIX2 = CL04W01.CL04WIX2 + 1;
  end
  CL04W02.CL04WCCT = CL04W03.CL04WCCT; /* move comment count to parm*/
  ;
  ;
  XZZREC.XZZRGRP = CL04W02.CL04WRT1;
  CL04W02.XZZDECIM = 0;
  XZZREC.XZZBINGP = CL04W02.XZZBINGP;
  XZZREC.XZZDECIM = 0;
  ;
  call "IO1000" ("A ", SQLCA, XZZREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE == -803)
      /* DO NOTHING*/
  else
    if (SQLCA.VAGen_SQLCODE < 0)
      TA1REC.TA1DBASE = "DCORP";
      TA1REC.TA1TBLVU = "VPARM101";
      TA1REC.TA1LOCAT[3] = "CL04S41";
      TA1REC.TA1LOCAT[4] = "IO1000-1";
      XPCL010();
    end
  end
  ;
  ;
     /* second parameter - closeout P.O. ID*/
  ;
  CL04W02.OP1CUPO = CL04W03.OP1CUPO[1];
  XZZREC.XZZRGRP = CL04W02.CL04WRT2;
  CL04W02.XZZQRYLN = 2;
  XZZREC.XZZKEYGP = CL04W02.XZZKEYGP;
  CL04W02.CL04WPCT = 0; /* reset product count*/
  CL04W02.CL04WCCT = 0; /* reset comment count*/
  CL04W02.XZZINT1 = 0; /* reset logon id's svc rep id*/
  CL04W02.XZZINT2 = 0; /* reset auth by id's svc rep id*/
  XZZREC.XZZBINGP = CL04W02.XZZBINGP;
  XZZREC.ZZZSDT = CL04W02.ZZZSDT;
  XZZREC.ZZZSTM = CL04W02.ZZZSTM;
  ;
  call "IO1000" ("A ", SQLCA, XZZREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE == -803)
      /* DO NOTHING*/
  else
    if (SQLCA.VAGen_SQLCODE < 0)
      TA1REC.TA1DBASE = "DCORP";
      TA1REC.TA1TBLVU = "VPARM101";
      TA1REC.TA1LOCAT[3] = "CL04S41";
      TA1REC.TA1LOCAT[4] = "IO1000-2";
      XPCL010();
    end
  end
  ;
  ;
     /* third parameter - next season P.O. ID*/
  ;
  CL04W02.OP1CUPO = CL04W03.OP1CUPO[2];
  XZZREC.XZZRGRP = CL04W02.CL04WRT2;
  CL04W02.XZZQRYLN = 3;
  XZZREC.XZZKEYGP = CL04W02.XZZKEYGP;
  XZZREC.XZZBINGP = CL04W02.XZZBINGP;
  XZZREC.ZZZSDT = CL04W02.ZZZSDT;
  XZZREC.ZZZSTM = CL04W02.ZZZSTM;
  ;
  call "IO1000" ("A ", SQLCA, XZZREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE == -803)
      /* DO NOTHING*/
  else
    if (SQLCA.VAGen_SQLCODE < 0)
      TA1REC.TA1DBASE = "DCORP";
      TA1REC.TA1TBLVU = "VPARM101";
      TA1REC.TA1LOCAT[3] = "CL04S41";
      TA1REC.TA1LOCAT[4] = "IO1000-2";
      XPCL010();
    end
  end
  ;
  ;
    /* fourth parameter type - products*/
  ;
  CL04W01.CL04WIX2 = 1;
  while (CL04W01.CL04WIX2 <= CL04W01.CL04WMX1)
    KL04S42();
  end
  ;
  ;
     /* fifth parameter - comments*/
  ;
  CL04W01.CL04WIX2 = 1; /* initialize index*/
  CL04W01.CL04WCT1 = 4; /* this value will be incremented each*/
  while (CL04W01.CL04WIX2 <= 12) /* time a comment is written*/
    KL04S43(); /* write comments*/
  end
  ;
end // end KL04S41

// write product lines to xzzrec
Function KL04S42()
    /* ******************************************/
    /* **   sgrp created 10-2-90 by gdecke    ***/
    /* ******************************************/
  ;
   /* -----------write product RECORDS TO DCORP.VPARM101----------*/
               /* RECORDS USED FOR semi-annual job cl2731*/
   /* ------------------------------------------------------------*/
  ;
  CLXREC.CLXCPROC = "CL04S42";
  TA1REC.TA1LOCAT[1] = "CL04S42";
  ;
     /* third parameter type - products*/
  ;
  if (CL04W03.SY1STNBR[CL04WIX2] == "      ")
    /* MOVE 201 TO CL04W01.CL04WIX2;*/
    /* EZERTN;*/
     /* next sentence*/
  else
    CL04W02.SY1STNBR = CL04W03.SY1STNBR[CL04WIX2];
    CL04W02.SY2CLRID = CL04W03.SY2CLRID[CL04WIX2];
    CL04W02.XDMCD = CL04W03.XDMCD[CL04WIX2];
    XZZREC.XZZRGRP = CL04W02.CL04WRT3;
    CL04W02.XZZQRYLN = 4;
    XZZREC.XZZKEYGP = CL04W02.XZZKEYGP;
    XZZREC.XZZBINGP = CL04W02.XZZBINGP;
    XZZREC.ZZZSDT = CL04W02.ZZZSDT;
    XZZREC.ZZZSTM = CL04W02.ZZZSTM;
    ;
    move XZZREC to XZZREC withV60Compat;
    call "IO1000" ("A ", SQLCA, XZZREC) {isNoRefresh = yes, isExternal = yes};
    ;
    if (SQLCA.VAGen_SQLCODE == -803)
        /* DO NOTHING*/
    else
      if (SQLCA.VAGen_SQLCODE < 0)
        TA1REC.TA1DBASE = "DCORP";
        TA1REC.TA1TBLVU = "VPARM101";
        TA1REC.TA1LOCAT[3] = "CL04S41";
        TA1REC.TA1LOCAT[4] = "IO1000-3";
        XPCL010();
      end
    end
  end
  ;
  ;
  CL04W01.CL04WIX2 = CL04W01.CL04WIX2 + 1; /* increment counter*/
  ;
end // end KL04S42

// write comment parms to xzzrec
Function KL04S43()
    /* ******************************/
    /* **   sgrp created 3-8-88   ***/
    /* ******************************/
  ;
   /* -----------write comment RECORDS TO DCORP.VPARM101----------*/
               /* RECORDS USED FOR BATCH job cl1371*/
   /* ------------------------------------------------------------*/
  ;
  CLXREC.CLXCPROC = "CL04S43";
  TA1REC.TA1LOCAT[1] = "CL04S43";
  ;
  ;
     /* fourth parameter*/
  ;
  CL04W01.CLGCOMNT = CL04W03.CLGCOMNT[CL04WIX2]; /* split cmt in two*/
  if (CL04W03.CLGCOMNT[CL04WIX2] != "  ") /* set comment id indicators*/
    if (CL04W01.CL04WIX2 == 1)
      CL04W02.CL04WCTY = "R"; /* comment type (RA)*/
      CL04W02.CL04WCSQ = "1"; /* comment sequence*/
    end
    if (CL04W01.CL04WIX2 == 2)
      CL04W02.CL04WCTY = "R"; /* comment type (RA)*/
      CL04W02.CL04WCSQ = "2"; /* comment sequence*/
    end
    if (CL04W01.CL04WIX2 == 3)
      CL04W02.CL04WCTY = "R"; /* comment type (RA)*/
      CL04W02.CL04WCSQ = "3"; /* comment sequence*/
    end
    if (CL04W01.CL04WIX2 == 4)
      CL04W02.CL04WCTY = "R"; /* comment type (RA)*/
      CL04W02.CL04WCSQ = "4"; /* comment sequence*/
    end
    if (CL04W01.CL04WIX2 == 5)
      CL04W02.CL04WCTY = "C"; /* comment type (credit memo)*/
      CL04W02.CL04WCSQ = "1"; /* comment sequence*/
    end
    if (CL04W01.CL04WIX2 == 6)
      CL04W02.CL04WCTY = "C"; /* comment type (credit memo)*/
      CL04W02.CL04WCSQ = "2"; /* comment sequence*/
    end
    if (CL04W01.CL04WIX2 == 7)
      CL04W02.CL04WCTY = "C"; /* comment type (credit memo)*/
      CL04W02.CL04WCSQ = "3"; /* comment sequence*/
    end
    if (CL04W01.CL04WIX2 == 8)
      CL04W02.CL04WCTY = "C"; /* comment type (credit memo)*/
      CL04W02.CL04WCSQ = "4"; /* comment sequence*/
    end
    if (CL04W01.CL04WIX2 == 9)
      CL04W02.CL04WCTY = "D"; /* comment type (debit memo)*/
      CL04W02.CL04WCSQ = "1"; /* comment sequence*/
    end
    if (CL04W01.CL04WIX2 == 10)
      CL04W02.CL04WCTY = "D"; /* comment type (debit memo)*/
      CL04W02.CL04WCSQ = "2"; /* comment sequence*/
    end
    if (CL04W01.CL04WIX2 == 11)
      CL04W02.CL04WCTY = "D"; /* comment type (debit memo)*/
      CL04W02.CL04WCSQ = "3"; /* comment sequence*/
    end
    if (CL04W01.CL04WIX2 == 12)
      CL04W02.CL04WCTY = "D"; /* comment type (debit memo)*/
      CL04W02.CL04WCSQ = "4"; /* comment sequence*/
    end
  end
  ;
    /* write the left half of the comment record*/
  ;
  if (CL04W03.CLGCOMNT[CL04WIX2] != "  ")
    CL04W01.CL04WCT1 = CL04W01.CL04WCT1 + 1;
    if (CL04W01.CL04WCML != " ")
      CL04W02.CL04WCMT = CL04W01.CL04WCML; /* write left half*/
      CL04W02.CL04WCPT = "L"; /* left half indicator*/
      ;
      XZZREC.XZZRGRP = CL04W02.CL04WRT4;
      CL04W02.XZZQRYLN = CL04W01.CL04WCT1;
      XZZREC.XZZKEYGP = CL04W02.XZZKEYGP;
      XZZREC.XZZBINGP = CL04W02.XZZBINGP;
      XZZREC.ZZZSDT = CL04W02.ZZZSDT;
      XZZREC.ZZZSTM = CL04W02.ZZZSTM;
      ;
      move XZZREC to XZZREC withV60Compat;
      call "IO1000" ("A ", SQLCA, XZZREC) {isNoRefresh = yes, isExternal = yes};
      ;
      if (SQLCA.VAGen_SQLCODE == -803)
          /* DO NOTHING*/
      else
        if (SQLCA.VAGen_SQLCODE < 0)
          TA1REC.TA1DBASE = "DCORP";
          TA1REC.TA1TBLVU = "VPARM101";
          TA1REC.TA1LOCAT[3] = "CL04S41";
          TA1REC.TA1LOCAT[4] = "IO1000-4";
          XPCL010();
        end
      end
    end
  end
  ;
  ;
    /* write the right half of the comment record*/
  ;
  if (CL04W03.CLGCOMNT[CL04WIX2] != "  ")
    ;
    if (CL04W01.CL04WCMR != " ")
      CL04W02.CL04WCMT = CL04W01.CL04WCMR; /* write left half*/
      CL04W02.CL04WCPT = "R"; /* left half indicator*/
      ;
      XZZREC.XZZRGRP = CL04W02.CL04WRT4;
      CL04W02.XZZQRYLN = CL04W01.CL04WCT1;
      XZZREC.XZZKEYGP = CL04W02.XZZKEYGP;
      XZZREC.XZZBINGP = CL04W02.XZZBINGP;
      XZZREC.ZZZSDT = CL04W02.ZZZSDT;
      XZZREC.ZZZSTM = CL04W02.ZZZSTM;
      ;
      move XZZREC to XZZREC withV60Compat;
      call "IO1000" ("A ", SQLCA, XZZREC) {isNoRefresh = yes, isExternal = yes};
      ;
      if (SQLCA.VAGen_SQLCODE == -803)
          /* DO NOTHING*/
      else
        if (SQLCA.VAGen_SQLCODE < 0)
          TA1REC.TA1DBASE = "DCORP";
          TA1REC.TA1TBLVU = "VPARM101";
          TA1REC.TA1LOCAT[3] = "CL04S41";
          TA1REC.TA1LOCAT[4] = "IO1000-4";
          XPCL010();
        end
      end
    end
  end
  ;
  CL04W01.CL04WIX2 = CL04W01.CL04WIX2 + 1;
  ;
end // end KL04S43

// edit parm file for duplicates
Function KL04S44()
    /* **********************************************************/
    /* ** cl04s44 sgrp created 10-09-90 by gdecke             ***/
    /* **********************************************************/
  ;
   /* -----------------------------------------------------------**/
     /* EDIT PARM FILE FOR DUPLICATE REQUEST                    **/
   /* -----------------------------------------------------------**/
  ;
  CLXREC.CLXCPROC = "CL04S44";
  TA1REC.TA1LOCAT[1] = "CL04S44";
  ;
  ;
  ;
     /* get create date from the last request written to*/
     /* dcorp.vparm001(Xzzrec). check for duplicate request.*/
  ;
  set XZZREC empty;
  ;
  XZZREC.XZZQRYID = "CL2730"; /* query id*/
  XZZREC.XZZQRYRN = CL04W02.XZZQRYRN - 1; /* decrement current # by 1*/
  XZZREC.XROCD = "  "; /* no remote printers will be involved*/
  XZZREC.XZZQRYLN = 1; /* query line number*/
  ;
  call "IO1000" ("S ", SQLCA, XZZREC) {isNoRefresh = yes, isExternal = yes}; /* get max request # in use*/
  ;
  if (SQLCA.VAGen_SQLCODE < 0)
    TA1REC.TA1DBASE = "DCORP";
    TA1REC.TA1TBLVU = "VPARM101";
    TA1REC.TA1LOCAT[3] = "CL04S44";
    TA1REC.TA1LOCAT[4] = "IO1000";
    TA1REC.TA1TBLKE = XZZREC.XZZQRYID;
    XPCL010(); /* abend*/
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      TA1REC.TA1DBASE = "DCORP";
      TA1REC.TA1TBLVU = "VPARM101";
      TA1REC.TA1LOCAT[3] = "CL04S44";
      TA1REC.TA1LOCAT[4] = "IO1000";
      TA1REC.TA1TBLKE = XZZREC.XZZQRYID;
      XPCL010(); /* abend*/
    else
      if (XZZREC.ZZZSDT == CL04W02.ZZZSDT
       || XZZREC.XZZQRYRN > 0)
                                   /* for now, allow only a single request*/
        converseLib.validationFailed(411);
                                   /* to exist on the parm file for cl2730*/
        set KL04M005.CL04MCMP cursor, modified, bold;
        CLXREC.CLXERRF = "Y";
        return;
      end
    end
  end
  ;
  ;
end // end KL04S44

// edit prev, next season PO ID,S
Function KL04S51()
   /* *************************************************************/
   /* *  cl04s51 - edit prev, next season po id's                **/
   /* *     by gdecke - 10-02-90                                 **/
   /* *************************************************************/
  CLXREC.CLXCPROC = "CL04S51"; /* set current process name*/
  ;
  CL04W01.XSNBDT = 0;
  CL04W01.XSNXDT = 0;
  ;
  ;
  if (KL04M001.OP1CUPO[1] == "   ")
    converseLib.validationFailed(21);
    set KL04M001.OP1CUPO[1] cursor, modified, bold;
    CLXREC.CLXERRF = "Y";
    return;
  end
  ;
  if (KL04M001.OP1CUPO[2] == "   ")
    converseLib.validationFailed(21);
    set KL04M001.OP1CUPO[2] cursor, modified, bold;
    CLXREC.CLXERRF = "Y";
    return;
  end
  ;
  if (KL04M001.OP1CUPO[1] != "   ")
    if (KL04M001.OP1CUPO[1] == "F91 SAMPLES ")
      CL04W01.OP1CUPO = "FA91 SAMPLES ";
    else
      CL04W01.OP1CUPO = KL04M001.OP1CUPO[1];
    end
    if (CL04W01.CL04WPO1 in XSNTBL.XSNABRV)
      CL04W01.XSNXDT = XSNTBL.XSNXDT[sysVar.arrayIndex];
      if (XSNTBL.XXXSTAT[sysVar.arrayIndex] != "A")
        converseLib.validationFailed(663);
        set KL04M001.OP1CUPO[1] cursor, modified, bold;
        CLXREC.CLXERRF = "Y";
        return;
      end
      if (CL04W01.CL04WPO2 != " SAMPLES ")
        converseLib.validationFailed(664);
        set KL04M001.OP1CUPO[1] cursor, modified, bold;
        CLXREC.CLXERRF = "Y";
        return;
      else
        if (CL04W01.CL04WPO3 != " ")
          converseLib.validationFailed(665);
          set KL04M001.OP1CUPO[1] cursor, modified, bold;
          CLXREC.CLXERRF = "Y";
          return;
        end
      end
    else
      converseLib.validationFailed(668);
      set KL04M001.OP1CUPO[1] cursor, modified, bold;
      CLXREC.CLXERRF = "Y";
      return;
    end
  end
  ;
  ;
  if (KL04M001.OP1CUPO[2] != "   ")
    if (KL04M001.OP1CUPO[2] == "F91 SAMPLES ")
      CL04W01.OP1CUPO = "FA91 SAMPLES ";
    else
      CL04W01.OP1CUPO = KL04M001.OP1CUPO[2];
    end
    if (CL04W01.CL04WPO1 in XSNTBL.XSNABRV)
      CL04W01.XSNBDT = XSNTBL.XSNBDT[sysVar.arrayIndex];
      if (XSNTBL.XXXSTAT[sysVar.arrayIndex] != "A")
        converseLib.validationFailed(663);
        set KL04M001.OP1CUPO[2] cursor, modified, bold;
        CLXREC.CLXERRF = "Y";
        return;
      end
      if (CL04W01.CL04WPO2 != " SAMPLES ")
        converseLib.validationFailed(664);
        set KL04M001.OP1CUPO[2] cursor, modified, bold;
        CLXREC.CLXERRF = "Y";
        return;
      else
        if (CL04W01.CL04WPO3 != " ")
          converseLib.validationFailed(665);
          set KL04M001.OP1CUPO[1] cursor, modified, bold;
          CLXREC.CLXERRF = "Y";
          return;
        end
      end
    else
      converseLib.validationFailed(668);
      set KL04M001.OP1CUPO[2] cursor, modified, bold;
      CLXREC.CLXERRF = "Y";
      return;
    end
  end
  ;
  ;
  if (CL04W01.XSNBDT == 0
   || CL04W01.XSNXDT == 0
   || CL04W01.XSNXDT > CL04W01.XSNBDT)
    converseLib.validationFailed(667);
    set KL04M001.OP1CUPO[1] cursor, modified, bold;
    set KL04M001.OP1CUPO[2] modified, bold;
    CLXREC.CLXERRF = "Y";
    return;
  end
  ;
  CL04W03.OP1CUPO[1] = KL04M001.OP1CUPO[1];
  CL04W03.OP1CUPO[2] = KL04M001.OP1CUPO[2];
  set KL04M001.OP1CUPO[1] initialAttributes;
  set KL04M001.OP1CUPO[2] initialAttributes;
  ;
end // end KL04S51

// edit number of ra mailers
Function KL04S52()
   /* *************************************************************/
   /* *  cl04s52 - edit number of ra mailers                     **/
   /* *     by gdecke - 10-02-90                                 **/
   /* *************************************************************/
  CLXREC.CLXCPROC = "CL04S52"; /* set current process name*/
  ;
   /* number of labels = 0 will be ok- gdecke- 06-03-91*/
   /* skip the following edit*/
    /* IF CL04M001.CLJNBLB = 0;*/
      /* MOVE 021 TO EZEMNO;*/
      /* SET CL04M001.CLJNBLB CURSOR,MODIFIED,BRIGHT;*/
      /* MOVE 'Y' TO CLXREC.CLXERRF;*/
      /* EZERTN;*/
    /* END ;*/
  ;
  CL04W03.CL04WNLB = KL04M001.CLJNBLB;
  ;
end // end KL04S52

// edit product class
Function KL04S53()
   /* *************************************************************/
   /* *  cl04s53 - edit general product class                    **/
   /* *     by gdecke - 10-02-90                                 **/
   /* *************************************************************/
  CLXREC.CLXCPROC = "CL04S53"; /* set current process name*/
  ;
  if (KL04M001.XGPCD == "02"
   || KL04M001.XGPCD == "03")
    CL04W03.XGPCD = KL04M001.XGPCD;
  else
    converseLib.validationFailed(86);
    set KL04M001.XGPCD cursor, modified, bold;
    CLXREC.CLXERRF = "Y";
  end
  ;
end // end KL04S53

// edit style/color/dimension
Function KL04S66()
   /* *************************************************************/
   /* *  cl04s66 - EDIT STYLE/COLOR/DIMENSION                    **/
   /* *     by gdecke - 10-02-90                                 **/
   /* *************************************************************/
  CLXREC.CLXCPROC = "CL04S66"; /* set current process name*/
  ;
  CL04W01.CL04WIX1 = CLXREC.CLXARY1X[CLXSCRNX]; /* index for w03*/
  CL04W01.CL04WIX2 = 1; /* index for cl04m001 map*/
  CL04W01.CL04WCT1 = 0; /* count number of products on map*/
  CL04W01.CL04WSTE = "N"; /* first style error flag*/
  ;
  while (CL04W01.CL04WIX2 <= CLXREC.CLXMAXLN[1] /* cl04m001 map*/
   && CL04W01.CL04WIX1 <= CL04W01.CL04WMX1) /* cl04w03 table*/
    KL04S67();
  end
  ;
  if (CLXREC.CLXERRF == "N")
    if (CL04W01.CL04WCT1 == 0)
      if (CL04W01.CL04WOVR[4] != "Y")
        converseLib.validationFailed(655);
        CL04W01.CL04WOVR[4] = "Y";
        set KL04M001.SY1STNBR[1] cursor, modified, bold;
        KL04M001.SY1STNBR[1] = "??????";
        CLXREC.CLXERRF = "Y";
      end
    else
      CL04W01.CL04WOVR[4] = "Y";
      CL04W03.CL04WPCT = CL04W01.CL04WCT1; /* save product count*/
    end
  end
  ;
end // end KL04S66

// edit one style/color/dimension
Function KL04S67()
   /* *************************************************************/
   /* *  cl04s67 - EDIT one STYLE/COLOR/DIMENSION                **/
   /* *     by gdecke - 10-02-90                                 **/
   /* *************************************************************/
  CLXREC.CLXCPROC = "CL04S67"; /* set current process name*/
  ;
  if (KL04M001.SY1STNBR[CL04WIX2] == "      "
   || KL04M001.SY1STNBR[CL04WIX2] == "0     ")
    CL04W03.SY1STNBR[CL04WIX1] = "      ";
    CL04W03.SY2CLRID[CL04WIX1] = "   ";
    CL04W03.XDMCD[CL04WIX1] = "  ";
  else
    if (KL04M001.SY2CLRID[CL04WIX2] == "   ")
      KL04M001.SY2CLRID[CL04WIX2] = "00 ";
    end
    if (KL04M001.XDMCD[CL04WIX2] == "  ")
      KL04M001.XDMCD[CL04WIX2] = "00";
    end
    CL04W01.CL04WCT1 = CL04W01.CL04WCT1 + 1;
    set SY1REC empty;
    SY1REC.SY1STNBR = KL04M001.SY1STNBR[CL04WIX2];
    SY1REC.XGPCD = KL04M001.XGPCD;
    ;
    CL04W01.CL04WDCT = 0; /* repeat select of product table until*/
    CL04W01.CL04WDFL = "Y"; /* line found or too many deadlocks.*/
    while (CL04W01.CL04WDFL == "Y")
      KL04S68(); /* get style table line*/
    end
    ;
    set SY2REC empty;
    SY2REC.SY1STNBR = KL04M001.SY1STNBR[CL04WIX2];
    SY2REC.SY2CLRID = KL04M001.SY2CLRID[CL04WIX2];
    SY2REC.XDMCD = KL04M001.XDMCD[CL04WIX2];
    SY2REC.XGPCD = KL04M001.XGPCD;
    ;
    if (SQLCA.VAGen_SQLCODE == 0) /* if stlye was found now look for color*/
      CL04W01.CL04WDCT = 0; /* repeat select of product table until*/
      CL04W01.CL04WDFL = "Y"; /* line found or too many deadlocks.*/
      while (CL04W01.CL04WDFL == "Y")
        KL04S69(); /* get color table line*/
      end
    end
    ;
    CL04W03.SY1STNBR[CL04WIX1] = KL04M001.SY1STNBR[CL04WIX2];
    CL04W03.SY2CLRID[CL04WIX1] = KL04M001.SY2CLRID[CL04WIX2];
    CL04W03.XDMCD[CL04WIX1] = KL04M001.XDMCD[CL04WIX2];
    ;
  end
  ;
  if (CLXREC.CLXERRF == "N")
    KL04S70(); /* check for duplicate style/colors*/
  end
  ;
  CL04W01.CL04WIX1 = CL04W01.CL04WIX1 + 1;
  CL04W01.CL04WIX2 = CL04W01.CL04WIX2 + 1;
  ;
end // end KL04S67

// select unique sy1rec-vstyle01
Function KL04S68()
  ;
  CLXREC.CLXCPROC = "CL04S68"; /* set current proc name*/
  ;
  call "IO0120" ("S ", SQLCA, SY1REC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    CL04W01.CL04WDFL = "N";
    CL04W01.CL04WDCT = 0; /* deadlock count*/
    set KL04M001.SY1STNBR[CL04WIX2] initialAttributes;
    set KL04M001.SY2CLRID[CL04WIX2] initialAttributes;
    return;
  end
  ;
  if (SQLCA.VAGen_SQLCODE == 100)
    CL04W01.CL04WDFL = "N";
    CL04W01.CL04WDCT = 0; /* deadlock count*/
    CLXREC.CLXERRF = "Y";
    converseLib.validationFailed(550);
    if (CL04W01.CL04WSTE == "N")
      set KL04M001.SY1STNBR[CL04WIX2] cursor, modified, bold;
      set KL04M001.SY2CLRID[CL04WIX2] modified, bold;
    else
      set KL04M001.SY1STNBR[CL04WIX2] modified, bold;
      set KL04M001.SY2CLRID[CL04WIX2] modified, bold;
      CL04W01.CL04WSTE = "Y";
    end
    return;
  end
  ;
  if (SQLCA.VAGen_SQLCODE == -911) /* deadlock*/
    CL04W01.CL04WDCT = CL04W01.CL04WDCT + 1;
    if (CL04W01.CL04WDCT > 2)
      converseLib.validationFailed(4); /* database busy*/
      CL04W01.CL04WDFL = "N"; /* deadlock flag*/
      CLXREC.CLXERRF = "Y"; /* error flag*/
    end
    return;
  end
  ;
  TA1REC.TA1LOCAT[2] = "CL04S68"; /* location*/
  TA1REC.TA1LOCAT[4] = "IO0120"; /* location*/
  TA1REC.TA1DBASE = "DPROD "; /* database*/
  TA1REC.TA1TBLVU = "VSTYLE01"; /* table view*/
  CLXREC.XXXWDTE = KL04M001.SY1STNBR[CL04WIX2]; /* style number*/
  TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* table key*/
  ;
  XPCL010(); /* error diagnosis routine*/
  ;
end // end KL04S68

// select unique sy2rec-vcolor01
Function KL04S69()
  ;
  CLXREC.CLXCPROC = "CL04S69"; /* set current proc name*/
  ;
  call "IO0130" ("S ", SQLCA, SY2REC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    CL04W01.CL04WDFL = "N";
    CL04W01.CL04WDCT = 0; /* deadlock count*/
    set KL04M001.SY1STNBR[CL04WIX2] initialAttributes;
    set KL04M001.SY2CLRID[CL04WIX2] initialAttributes;
    return;
  end
  ;
  if (SQLCA.VAGen_SQLCODE == 100)
    CL04W01.CL04WDFL = "N";
    CL04W01.CL04WDCT = 0; /* deadlock count*/
    CLXREC.CLXERRF = "Y";
    converseLib.validationFailed(550);
    if (CL04W01.CL04WSTE == "N")
      set KL04M001.SY1STNBR[CL04WIX2] cursor, modified, bold;
      set KL04M001.SY2CLRID[CL04WIX2] modified, bold;
    else
      set KL04M001.SY1STNBR[CL04WIX2] modified, bold;
      set KL04M001.SY2CLRID[CL04WIX2] modified, bold;
      CL04W01.CL04WSTE = "Y";
    end
    return;
  end
  ;
  if (SQLCA.VAGen_SQLCODE == -911) /* deadlock*/
    CL04W01.CL04WDCT = CL04W01.CL04WDCT + 1;
    if (CL04W01.CL04WDCT > 2)
      converseLib.validationFailed(4); /* database busy*/
      CL04W01.CL04WDFL = "N"; /* deadlock flag*/
      CLXREC.CLXERRF = "Y"; /* error flag*/
    end
    return;
  end
  ;
  TA1REC.TA1LOCAT[2] = "CL04S68"; /* location*/
  TA1REC.TA1LOCAT[4] = "IO0120"; /* location*/
  TA1REC.TA1DBASE = "DPROD "; /* database*/
  TA1REC.TA1TBLVU = "VSTYLE01"; /* table view*/
  CLXREC.XXXWDTE = KL04M001.SY1STNBR[CL04WIX2]; /* style number*/
  TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* table key*/
  ;
  XPCL010(); /* error diagnosis routine*/
  ;
end // end KL04S69

// edit sttle table for duplicate
Function KL04S70()
  ;
  CLXREC.CLXCPROC = "CL04S70"; /* set current proc name*/
  ;
   /* at this point cl04wix1 is the index in the cl04w03 style*/
   /* table, and cl04wix2 is the index in the cl04m001 carryover*/
   /* style table*/
  ;
  CL04W01.CL04WIX3 = 1; /* check for map style already in w/s*/
  while (CL04WIX3 <= CL04W01.CL04WMX1) /* style/color table*/
    if (CL04W01.CL04WIX3 != CL04W01.CL04WIX1 /* dont compare with self*/
     && KL04M001.SY1STNBR[CL04WIX2] != "      "
     && CL04W03.SY1STNBR[CL04WIX3] != "      ")
      if (KL04M001.SY1STNBR[CL04WIX2] == CL04W03.SY1STNBR[CL04WIX3]
       && KL04M001.SY2CLRID[CL04WIX2] == CL04W03.SY2CLRID[CL04WIX3])
        CLXREC.CLXERRF = "Y";
        converseLib.validationFailed(672);
        if (CL04W01.CL04WSTE == "N")
          set KL04M001.SY1STNBR[CL04WIX2] cursor, modified, bold;
          set KL04M001.SY2CLRID[CL04WIX2] modified, bold;
        else
          set KL04M001.SY1STNBR[CL04WIX2] modified, bold;
          set KL04M001.SY2CLRID[CL04WIX2] modified, bold;
          CL04W01.CL04WSTE = "Y";
        end
        return;
      end
    end
    CL04W01.CL04WIX3 = CL04W01.CL04WIX3 + 1;
  end
  ;
  ;
end // end KL04S70

//*** RECORD=CL04W01 ****
// ************************************************************
// *   CL04w01 is the working storage record used by the cl04 *
// *   application to pass switches and other data between    *
// *   statement groups and processes within cl04            **
// ************************************************************
// ***********************
Record CL04W01 type basicRecord
  5 CL04WGRP CL04WGRP ; 
    10 CL04WMX1 CL04WMX1 ; 
    10 CL04WMX2 CL04WMX2 ; 
    10 CL04WIX1 CL04WIX1 ; 
    10 CL04WIX2 CL04WIX2 ; 
    10 CL04WIX3 CL04WIX3 ; 
    10 CL04WCT1 CL04WCT1 ; 
    10 CL04WCT2 CL04WCT2 ; 
    10 CL04WCT3 CL04WCT3 ; 
    10 CL04WDCT CL04WDCT ; 
    10 CL04WDFL CL04WDFL ; 
    10 XSNBDT XSNBDT ; 
    10 XSNXDT XSNXDT ; 
    10 CL04WPAG CL04WPAG ; 
    10 OP1CUPO OP1CUPO ; 
      15 CL04WPO1 CL04WPO1 ; 
      15 CL04WPO2 CL04WPO2 ; 
      15 CL04WPO3 CL04WPO3 ; 
    10 CLGCOMNT CLGCOMNT ; 
      15 CL04WCML CL04WCML ; 
      15 CL04WCMR CL04WCMR ; 
    10 CL04WOVR CL04WOVR [6] ; 
    10 CL04WSTE CL04WSTE ; 
end // end CL04W01

//*** RECORD=CL04W02 ****
// build 4 different parameters in this record.
// parameters written to dcorp.vparm101 for use in cobol batch
// cl2731 to generate sales sample claims.
// 
// date      name    comment
// --------  ------  ---------------------------------------
// 10-01-90  gdecke  create record
// 06-12-92  sgorga  Set field 'clatbyid' to '*', char, 2 bytes
// 
// ***********************
Record CL04W02 type basicRecord
  5 CL04W02G CL04W02G ; 
    10 CL04WSDT CL04WSDT ; 
    10 CL04WETM CL04WETM ; 
      15 CL04WEHH CL04WEHH ; 
      15 * char(1) ; 
      15 CL04WEMM CL04WEMM ; 
      15 * char(1) ; 
      15 CL04WESS CL04WESS ; 
    10 CL04WTM CL04WTM ; 
      15 CL04WHH CL04WHH ; 
      15 CL04WMM CL04WMM ; 
    10 CL04WRT1 CL04WRT1 ; 
      15 XZZKEYGP XZZKEYGP ; 
        20 XZZQRYID XZZQRYID ; 
        20 XZZQRYRN XZZQRYRN ; 
        20 XZZQRYLN XZZQRYLN ; 
        20 XROCD XROCD ; 
      15 CLYATHPW CLYATHPW ; 
      15 XGPCD XGPCD ; 
      15 CL04WNLB CL04WNLB ; 
      15 CLASCGBY CLASCGBY ; 
      15 * char(2) ; // filler
      15 XWHCD XWHCD ; 
      15 XXXUSRID XXXUSRID ; 
      15 XZZBINGP XZZBINGP ; 
        20 CL04WPCT CL04WPCT ; 
        20 CL04WCCT CL04WCCT ; 
        20 XZZINT1 XZZINT1 ; 
        20 XZZINT2 XZZINT2 ; 
        20 XZZINT3 XZZINT3 ; 
        20 XZZINT4 XZZINT4 ; 
        20 XZZINT5 XZZINT5 ; 
        20 XZZINT6 XZZINT6 ; 
        20 XZZINT7 XZZINT7 ; 
        20 XZZINT8 XZZINT8 ; 
        20 XZZDECIM XZZDECIM ; 
      15 ZZZSDT ZZZSDT ; 
      15 ZZZSTM ZZZSTM ; 
    10 CL04WRT2 CL04WRT2 ; 
      15 CL04WKY2 CL04WKY2 ; 
      15 OP1CUPO OP1CUPO ; 
      15 * char(28) ; 
    10 CL04WRT3 CL04WRT3 ; 
      15 CL04WKY3 CL04WKY3 ; 
      15 * char(2) ; 
      15 XDMCD XDMCD ; 
      15 * char(2) ; 
      15 SY2CLRID SY2CLRID ; 
      15 * char(11) ; 
      15 SY1STNBR SY1STNBR ; 
      15 * char(27) ; 
    10 CL04WRT4 CL04WRT4 ; 
      15 CL04WKY4 CL04WKY4 ; 
      15 CL04WCTY CL04WCTY ; 
      15 CL04WCSQ CL04WCSQ ; 
      15 CL04WCPT CL04WCPT ; 
      15 CL04WCMT CL04WCMT ; 
      15 * char(20) ; 
end // end CL04W02

//*** RECORD=CL04W03 ****
// ************************************************************
// *   CL04w03 is the working storage record used by the cl04 *
// *   application to save the data entered in map cl04m001   *
// *   and cl04m005.                                         **
// 
//  06-12-92  sgorga  Set field 'clatbyid' to '*', char, 2 byte
// ************************************************************
// ***********************
Record CL04W03 type basicRecord
  5 CL04WGP3 CL04WGP3 ; 
    10 CLYATHPW CLYATHPW ; 
    10 XXXUSRID XXXUSRID ; 
    10 CLYATHID CLYATHID ; 
    10 XGPCD XGPCD ; 
    10 CL04WNLB CL04WNLB ; 
    10 CLASCGBY CLASCGBY ; 
    10 * char(2) ; // filler
    10 XWHCD XWHCD ; 
    10 CL04WPCT CL04WPCT ; 
    10 CL04WCCT CL04WCCT ; 
    10 OP1CUPO OP1CUPO [2] ; 
    10 SY1STNBR SY1STNBR [600] ; 
    10 SY2CLRID SY2CLRID [600] ; 
    10 XDMCD XDMCD [600] ; 
    10 CLGCOMNT CLGCOMNT [12] ; 
end // end CL04W03

//*** RECORD=CL04W04 ****
// %get cl0zw03
// *
// * select maximum sequence number from dcorp.vparm101
// *
// * 07-27-90 bcourt create record
// ***********************
Record CL04W04 type basicRecord
  10 CL04W4SQ CL04W4SQ ; 
  10 CL04W4ID CL04W4ID ; 
end // end CL04W04

// working storage group
DataItem CL04W02G char(326)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// io-ind
DataItem CL04W4ID smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// sql function
DataItem CL04W4SQ char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// count of sales sample comments
DataItem CL04WCCT smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// left half of a comment line
DataItem CL04WCML char(30)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// right half of a comment line
DataItem CL04WCMR char(30)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// half of a claim comment
DataItem CL04WCMT char(30)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// comment part code
DataItem CL04WCPT char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// comment sequence
DataItem CL04WCSQ char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// selected lines count
DataItem CL04WCT1 smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// selected lines count 2
DataItem CL04WCT2 smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// selected lines count 3
DataItem CL04WCT3 smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// comment type
DataItem CL04WCTY char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// deadlock count
DataItem CL04WDCT smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// deadlock flag
DataItem CL04WDFL char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// entry hour
DataItem CL04WEHH num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// entry minute
DataItem CL04WEMM num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// entry second
DataItem CL04WESS num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// entry time
DataItem CL04WETM char(8)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// cl04w03 group field
DataItem CL04WGP3 char(7410)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// cl04w01 group field
DataItem CL04WGRP char(123)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// hour
DataItem CL04WHH num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// index #1
DataItem CL04WIX1 smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// index #2
DataItem CL04WIX2 smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// index #3
DataItem CL04WIX3 smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// key id
DataItem CL04WKY2 char(16)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// key id
DataItem CL04WKY3 char(16)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// key id
DataItem CL04WKY4 char(16)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// minute
DataItem CL04WMM num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// maximum index value #1
DataItem CL04WMX1 smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// maximum index value #2
DataItem CL04WMX2 smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// cl-nbr-of-labl
DataItem CL04WNLB num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = nullFill, inputRequired = no
}
end

// error-message-was-shown flag
DataItem CL04WOVR char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// COMPUTED PAGE NUMBER
DataItem CL04WPAG int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// count of carryover products
DataItem CL04WPCT smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// season abbreviation
DataItem CL04WPO1 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// value is ' samples '
DataItem CL04WPO2 char(9)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// last part of p.o. is blank
DataItem CL04WPO3 char(12)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// parm rec type 1 group ********
DataItem CL04WRT1 char(99)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// parm rec type 2 group ********
DataItem CL04WRT2 char(69)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// parm rec type 3 group ********
DataItem CL04WRT3 char(69)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// parm rec type 4 group ********
DataItem CL04WRT4 char(69)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// yymmdd ezedte + 19000000
DataItem CL04WSDT num(8)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// first style error flag
DataItem CL04WSTE char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// time
DataItem CL04WTM num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

