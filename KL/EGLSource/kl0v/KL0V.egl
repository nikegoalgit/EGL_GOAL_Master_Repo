package kl0v;

import corpcom1.CL-CLCOM-FL;
import corpcom1.CL2ISBDT;
import corpcom1.CL2ISXDT;
import corpcom1.CL2REC;
import corpcom1.CLACLMNB;
import corpcom1.CLAESTVL;
import corpcom1.CLAREC;
import corpcom1.CLFREC;
import corpcom1.CLGCMSEQ;
import corpcom1.CLGREC;
import corpcom1.CLHREC;
import corpcom1.CLHSEQNB;
import corpcom1.CLIREC;
import corpcom1.CLJNCRFL;
import corpcom1.CLJREC;
import corpcom1.CLJTATHQ;
import corpcom1.CLKCLPRC;
import corpcom1.CLKPRCFF;
import corpcom1.CLLREC;
import corpcom1.CLMTNCRQ;
import corpcom1.CLNNCRQ;
import corpcom1.CLODMAMT;
import corpcom1.CLOFGAAM;
import corpcom1.CLOFGAQ;
import corpcom1.CLORCTFL;
import corpcom1.CLOREC;
import corpcom1.CLOTDFQY;
import corpcom1.CLOTLRID;
import corpcom1.CLOTRCQY;
import corpcom1.CLPCRTNB;
import corpcom1.CLPDEFQ;
import corpcom1.CLPREC;
import corpcom1.CLPRTCTQ;
import corpcom1.CLPVLDFL;
import corpcom1.CLSREC;
import corpcom1.CLWREC;
import corpcom1.CLXREC;
import corpcom3.XPCL002;
import corpcom3.XPCL004;
import corpcom3.XPCL010;
import corpcom3.XPCL011;
import corpcom4.XSENTRY;
import corpcom4.XSPF1;
import corpcom4.XSPF4;
import corpcom4.XSSEGTR;
import corpcom5.COMMAREA;
import corpcom5.ERRSQLCA;
import corpcom6.SQLCA;
import corpx1.XATCD;
import corpx1.XATTBL;
import corpx1.XAUTBL;
import corpx1.XDMCD;
import corpx1.XGATBL;
import corpx1.XGPCD;
import corpx1.XOTTBL;
import corpx1.XPGTBL;
import corpx1.XQATBL;
import corpx1.XSATBL;
import corpx1.XSTTBL;
import corpx1.XUMTBL;
import corpx1.XWHTBL;
import corpx2.XNXCD;
import corpx2.XQACD;
import corpx2.XUMCD;
import corpx2.XWHABRV;
import corpx2.XWHCD;
import corpx2.XXXUSRID;
import corpy2.YATTBL;
import corpy2.YCCTBL;
import corpy2.YCSTBL;
import corpy2.YCTCD;
import corpy2.YCTTBL;
import corpy2.YDDCD;
import corpy2.YDDTBL;
import corpy2.YDFCD;
import corpy2.YDFKEY;
import corpy2.YDFTBL;
import corpy2.YDRCD;
import corpy2.YDRTBL;
import corpy2.YDSTBL;
import corpy2.YRMTBL;
import corpy2.YUATBL;
import corpz3.ZZZCHGCT;
import corpz3.ZZZCHGDT;
import corpz3.ZZZCHGTM;
import fy.common.FY1FCTYC;
import fy.common.FY1REC;
import iv.common.IV5REC;
import iv.common.IVEREC;
import ku.common.KUCCOID;
import ku.common.KUCCONM;
import ku.common.KUCREC;
import ku.common.KUMSTRID;
import ku.common.KUYREC;
import ku.common.KUYREPNM;
import pc.common.PC2REC;
import pc.common.PC3POIDT;
import pc.common.PC6REC;
import sy.common.SY1REC;
import sy.common.SY1STNBR;
import sy.common.SY2CLRID;
import sy.common.SY2REC;
import sy.common.SY5REC;
import sy.common.SY6REC;
import sy.common.SYCREC;
import ta.common.TA1REC;
import ta.common.TA2REC;
//*** PROGRAM=KL0V ****
// ************************************************************
// claim defective  entry/update/inquiry screens.
// 
//     the two main parts of the defective application are:
//   1) adding defective header and detail data
//   2) updating and inquiring against the defective detail
//      data.
// 
//    the claim header data is given to cl0v application thru
//   the clargroup level inside clwrec.
// 
//    for phase 1 of the application we have to add 2 db2
//   records that would normally be in existence already. they
//   are cljrec (return authorization), and cllrec (actural
//   return). (note: the add logic for these two records will
//   go away when phase b&c are installed)
//   therefore, if the records do not exist then there is a
//   flag set for each record. once all three header records
//   exist the user can then begin to add detail data.
// 
//   the add detail will continue to add as long as there is
//   a style number entered.
// 
// ************************************************************
// *maintenance history:                                      *
// *date      by     rev description of change                *
// *--------  ---    --  -------------------------------------*
// *04-20-87  jricha  0  create application.                  *
// *02-27-89  jwood   0  added noncsp option to calls         *
// *02-27-89  jwood   0  added xssegtr logic                  *
// *05-19-89  bcourt     DB2 structure changes: CLAREC, CLIREC*
// *                     KUCREC, SYCREC, SY2REC, XWHTBL       *
// *08-01-89  gdecke     DB2 structure changes: CLAREC, CLPREC*
// *                     CL2REC.                              *
// *09-22-89  bcourt     DB2 structure changes: PD1REC.       *
// *11-27-89  gdecke     add quality code to clprec add,select*
// *01-19-90  chellm     DB2 structure changes regen only     *
// *02-22-90  chellm     Replaced DWPROD.VFCTY001 with DFCTY. *
// *                     VFCTY001. Replaced IO0870 with       *
// *                     IO2810 and renamed all PD1.. items   *
// *                     as FY1..                             *
// *                                                          *
// *04-03-90  sgorga     DB2 structure changes.               *
// *                     Replaced XSDTBL in table list with   *
// *                     PC2REC. No other changes necessary.  *
// *05-31-90  chellm     Added edit for Product Brand - Claim *
// *                     Brand mis-match.                     *
// *06-06-90  chellm     added xottbl for product division -
// *                     claim order type division edit.
// *06-14-90  chellm     db2 structure changes. replaced pd2rec
// *                     with pc6rec to validate fcty po nbr.
// *06-21-90  chellm     changed the FCTY PO edit back to
// *                     a warning only edit to allow for old
// *                     PO numbers since purged from VPOITM01
// *08-03-90  gdecke     expand number of product lines in
// *                     table cl0vw02 to 500.
// * 11-09-90 bcourt  db2 structure changes, no code change.
// *01-09-91  gdecke #cl974 activate dimension code processing
// *02-18-91  gdecke INITIALIZE CL2TOSLF IN CL0VSBM,CL0VSBD.
// *08-08-91  wjohns Renamed application and commarea
// *                   referrences to renamed claims appls.
// *09-19-91  ahowar changed proc and sgrp from "cl" to "kl".
// *01-13-92  sgorga  Set ta1rec,ta2rec empty - kl0v001.
// *04-13-92  twatso  db2 change - clacmind     = cl-clcom-fl
// *11-12-93  GDECKE  REMOVE OVERLAPPING MOVE:KL0VSJB,KL0VSKD.
// 03-11-94  BCourt  Rename sy6cstfl to xqacd.
//              Add defaults for country & currency in KL0VSCT.
// 02-27-98   rgilli  Y2K MODIFICATIONS MADE TO:
//                    Re-generate to include new version of
//                    xpcl004.
//                    KL0VSBC: Change date compare from yymmdd
//                             to ccyymmdd.
//                    KL0VM001:Remove zero suppression PO nbr.
//                    KL0VM005:Remove zero suppression PO nbr.
// *12-30-99  SSANK1  Replaced CLXREC.XXXCYMD by CLXREC.XXXCDTE
// *                  in KL0VSAD due to Y2K impact.
// *11-28-01  SVIJAY  RECOMPILED DUE TO CHANGES IN CLPREC.
// ************************************************************
// *********************
Program KL0V type textUIProgram //VAGen Info - main text program
  {
  includeReferencedFunctions = yes, allowUnqualifiedItemReferences = yes, 
  throwNrfEofExceptions = yes, handleHardIOErrors = no, V60ExceptionCompatibility = yes, 
  I4GLItemsNullable = no, textLiteralDefaultIsString = no, localSQLScope = yes, 
  msgTablePrefix = "CL00", inputRecord = COMMAREA, segmented = yes
  }

  // Data Declarations
  CL0VW01 CL0VW01; // record
  CL0VW02 CL0VW02; // record
  CL0VW03 CL0VW03; // record
  CL0VW04 CL0VW04; // record
  CL0VW05 CL0VW05; // record
  CL0VW06 CL0VW06; // record
  CL0VW07 CL0VW07; // record
  CL2REC CL2REC; // record
  CLAREC CLAREC; // record
  CLFREC CLFREC; // record
  CLGREC CLGREC; // record
  CLHREC CLHREC; // record
  CLIREC CLIREC; // record
  CLJREC CLJREC; // record
  CLLREC CLLREC; // record
  CLOREC CLOREC; // record
  CLPREC CLPREC; // record
  CLSREC CLSREC; // record
  CLWREC CLWREC; // record
  CLXREC CLXREC; // record
  COMMAREA COMMAREA ; // record
  ERRSQLCA ERRSQLCA; // record
  FY1REC FY1REC; // record
  IV5REC IV5REC; // record
  IVEREC IVEREC; // record
  KUCREC KUCREC; // record
  KUYREC KUYREC; // record
  PC2REC PC2REC; // record
  PC6REC PC6REC; // record
  SQLCA SQLCA; // record
  SY1REC SY1REC; // record
  SY2REC SY2REC; // record
  SY5REC SY5REC; // record
  SY6REC SY6REC; // record
  SYCREC SYCREC; // record
  TA1REC TA1REC; // record
  TA2REC TA2REC; // record

  // VAGen Info - items needed for migration
  VAGen_EZESYS char(8);
  VAGen_EZEREPLY num(1);
  VAGen_EZE_WAIT_TIME bin(9,2);
  VAGen_EZE_ITEMLEN int;

  // Use Declarations
  use XATTBL {deleteAfterUse = yes}; // table
  use XAUTBL {deleteAfterUse = yes}; // table
  use XGATBL {deleteAfterUse = yes}; // table
  use XPGTBL {deleteAfterUse = yes}; // table
  use XOTTBL {deleteAfterUse = yes}; // table
  use XQATBL {deleteAfterUse = yes}; // table
  use XSATBL {deleteAfterUse = yes}; // table
  use XSTTBL {deleteAfterUse = yes}; // table
  use XUMTBL {deleteAfterUse = yes}; // table
  use XWHTBL {deleteAfterUse = yes}; // table
  use YATTBL {deleteAfterUse = yes}; // table
  use YCCTBL {deleteAfterUse = yes}; // table
  use YCSTBL {deleteAfterUse = yes}; // table
  use YCTTBL {deleteAfterUse = yes}; // table
  use YDDTBL {deleteAfterUse = yes}; // table
  use YDFTBL {deleteAfterUse = yes}; // table
  use YDRTBL {deleteAfterUse = yes}; // table
  use YDSTBL {deleteAfterUse = yes}; // table
  use YRMTBL {deleteAfterUse = yes}; // table
  use YUATBL {deleteAfterUse = yes}; // table
  use KL0VM.KL0VM001,  // forms
      KL0VM.KL0VM005
   {
    pfKeyEquate = no
  };

  function main()
    // VAGen Info - initialization needed for migration
    VAGen_EZESYS = VGLib.getVAGSysType();
    KL0V000: KL0V000();
    ;
    ;
    exit program;
    ;
    ;
    ;
    KL0V050: KL0V050();
    KL0V060: KL0V060();
    KL0V100: KL0V100();
    KL0V130: KL0V130();
    KL0V110: KL0V110();
    KL0V150: KL0V150();
    KL0V160: KL0V160();
    KL0V200: KL0V200();
    KL0V230: KL0V230();
    KL0V210: KL0V210();
    KL0V250: KL0V250();
    KL0V280: KL0V280();
    KL0V290: KL0V290();
  end // end main
end // end KL0V

// application main logic
Function KL0V000()
   /* ************************************************************/
   /* *   this is the "main logic" for the application.         **/
   /* *                                                         **/
   /* *   xsentry checks to ensure that this application was    **/
   /* *         entered from another csp application.           **/
   /* *   xclentry checks to ensure that the claim header has   **/
   /* *         been flagged as "in use" if this application    **/
   /* *         does updates.                                   **/
   /* *                                                         **/
   /* *                                                         **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  ;
  KL0V001(); /* initilize the application*/
  ;
  ;
  CLXREC.CLXEOAF = "N"; /* set end-of-application flag to 'no'*/
  ;
  while (CLXREC.CLXEOAF == "N") /* while not end-of-aplication*/
    KL0V050(); /* process the application screen(s)*/
  end
  ;
  COMMAREA.CATOAP = "KL0A";
  XPCL002(); /* exit application*/
end // end KL0V000

// initialize application
Function KL0V001()
   /* ************************************************************/
   /* *      initialize the application working storage         **/
   /* *                                                         **/
   /* *  describe what happens in this process                  **/
   /* ************************************************************/
   /* MAINTENANCE HISTORY                       **/
   /* 01-13-92  sgorga  Set ta1rec, ta2rec empty.               **/
   /* ************************************************************/
  ;
  converseVar.commitOnConverse = 1; /* force db2 to commit on each screen converse*/
  VGVar.handleHardIOErrors = 1; /* return control to program if hard db2 error*/
  ;
  set TA1REC empty;
  set TA2REC empty;
  ;
  KL0VSAK(); /* set all recs and maps empty*/
  ;
  set CLXREC empty; /* clear out the "common" working*/
                                   /* storage*/
   /* TEMP001;*/
  XSENTRY(); /* check entered thru main menu*/
  XSSEGTR(); /* set segmented transaction id*/
  XPCL011(); /* claims entry module*/
  ;
  ;
  ;
     /* put statements here to initalize your working-storage(s),*/
     /* e.g. constants, messages, '-' for dates.*/
  ;
  KL0VSAA(); /* retrieve all header info*/
  ;
  CLXREC.CLXEOAF = "N"; /* set application-done-switch to 'no'*/
  ;
  ;
  CLXREC.CLXSNAME[1] = "KL0VM001"; /* initialize the names of the*/
  CLXREC.CLXSNAME[2] = "KL0VM005"; /* screens used in this appl*/
  ;
  CL0VWMX = 500; /* maximum number of lines in cl0vw02*/
  CL0VWMXL = 499; /* maximum number of lines in cl0vw02 less 1*/
  ;
  CLXREC.CLXMAXLN[2] = 10; /* max lines on map 2*/
  CLXREC.CLXARY1X[2] = 1; /* start line on map 2*/
  ;
  CLXREC.CLXARAYX = 1; /* index to array*/
  CLXREC.CLXLINEX = 1; /* index to map line*/
  ;
  ;
  KL0V002(); /* load the factory xref table*/
  ;
  ;
  ;
end // end KL0V001

// load factory xref table
Function KL0V002()
  set CL0VW03 empty;
  CL0VW03.CL0VWFTY[1] = "AP  51  ";
  CL0VW03.CL0VWFTY[2] = "BC  17  ";
  CL0VW03.CL0VWFTY[3] = "BO  39  ";
  CL0VW03.CL0VWFTY[4] = "BR  20  ";
  CL0VW03.CL0VWFTY[5] = "BS  14  ";
  CL0VW03.CL0VWFTY[6] = "BY  34  ";
  CL0VW03.CL0VWFTY[7] = "CH  3   ";
  CL0VW03.CL0VWFTY[8] = "CJ  44  ";
  CL0VW03.CL0VWFTY[9] = "CU  52  ";
  CL0VW03.CL0VWFTY[10] = "DG  53  ";
  CL0VW03.CL0VWFTY[11] = "DS  57  ";
  CL0VW03.CL0VWFTY[12] = "EA  9   ";
  CL0VW03.CL0VWFTY[13] = "EI  28  ";
  CL0VW03.CL0VWFTY[14] = "EX  8   ";
  CL0VW03.CL0VWFTY[15] = "FT  4   ";
  CL0VW03.CL0VWFTY[16] = "FZ  2   ";
  CL0VW03.CL0VWFTY[17] = "GH  41  ";
  CL0VW03.CL0VWFTY[18] = "GN  13  ";
  CL0VW03.CL0VWFTY[19] = "HS  27  ";
  CL0VW03.CL0VWFTY[20] = "IN  40  ";
  CL0VW03.CL0VWFTY[21] = "JD  12  ";
  CL0VW03.CL0VWFTY[22] = "JN  59  ";
  CL0VW03.CL0VWFTY[23] = "JO  49  ";
  CL0VW03.CL0VWFTY[24] = "KC  26  ";
  CL0VW03.CL0VWFTY[25] = "KO  42  ";
  CL0VW03.CL0VWFTY[26] = "LM  5   ";
  CL0VW03.CL0VWFTY[27] = "LT  24  ";
  CL0VW03.CL0VWFTY[28] = "MA  33  ";
  CL0VW03.CL0VWFTY[29] = "MC  16  ";
  CL0VW03.CL0VWFTY[30] = "NF  32  ";
  CL0VW03.CL0VWFTY[31] = "NH  56  ";
  CL0VW03.CL0VWFTY[32] = "NO  50  ";
  CL0VW03.CL0VWFTY[33] = "OS  35  ";
  CL0VW03.CL0VWFTY[34] = "PA  21  ";
  CL0VW03.CL0VWFTY[35] = "PD  23  ";
  CL0VW03.CL0VWFTY[36] = "PV  46  ";
  CL0VW03.CL0VWFTY[37] = "PY  10  ";
  CL0VW03.CL0VWFTY[38] = "QZ  25  ";
  CL0VW03.CL0VWFTY[39] = "S1  54  ";
  CL0VW03.CL0VWFTY[40] = "SA  11  ";
  CL0VW03.CL0VWFTY[41] = "SC  58  ";
  CL0VW03.CL0VWFTY[42] = "SD  37  ";
  CL0VW03.CL0VWFTY[43] = "SH  6   ";
  CL0VW03.CL0VWFTY[44] = "SI  30  ";
  CL0VW03.CL0VWFTY[45] = "SN  15  ";
  CL0VW03.CL0VWFTY[46] = "SP  43  ";
  CL0VW03.CL0VWFTY[47] = "ST  7   ";
  CL0VW03.CL0VWFTY[48] = "SR  1   ";
  CL0VW03.CL0VWFTY[49] = "T2  55  ";
  CL0VW03.CL0VWFTY[50] = "T3  60  ";
  CL0VW03.CL0VWFTY[51] = "TE  36  ";
  CL0VW03.CL0VWFTY[52] = "TH  19  ";
  CL0VW03.CL0VWFTY[53] = "TL  47  ";
  CL0VW03.CL0VWFTY[54] = "TJ  31  ";
  CL0VW03.CL0VWFTY[55] = "TY  18  ";
  CL0VW03.CL0VWFTY[56] = "UF  38  ";
  CL0VW03.CL0VWFTY[57] = "UI  48  ";
  CL0VW03.CL0VWFTY[58] = "WC  22  ";
  CL0VW03.CL0VWFTY[59] = "XZ  45  ";
  CL0VW03.CL0VWFTY[60] = "99  99  ";
end // end KL0V002

// main cl0v branch control
Function KL0V050()
   /* ************************************************************/
   /* *   control process the application screen(s)             **/
   /* *                                                         **/
   /* *  note that this process is being performed in a         **/
   /* *  "while loop" until the end-of-application flag is set  **/
   /* *  to 'y'.                                                **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0V050"; /* set current process name*/
  ;
  if (CLXREC.CLXCSCRN in CLXREC.CLXSNAME) /* if current-screen-name is*/
    CLXREC.CLXSCRNX = sysVar.arrayIndex; /* in the screen-array, then set*/
  end /* the screen-index*/
  ;
  ;
  CLXREC.CLXEOSF = "N"; /* set end-of-screen flag to 'no'*/
  CL0VW01.CL0VWDEF = "N"; /* set end-of-detail map flag to 'no'*/
  ;
  KL0VSAH(); /* move cl0vw01 header info to cl0vm001,005,010 maps*/
  ;
  if (CLXREC.CLXSCRNX == 1) /* if screen cl0vm001*/
    while (CLXREC.CLXEOSF == "N") /* while not end-of-screen*/
      KL0V100(); /* process screen cl0vm001*/
    end
  else
    if (CLXREC.CLXSCRNX == 2) /* if screen cl0vm005*/
      while (CLXREC.CLXEOSF == "N") /* while not end-of-screen*/
        KL0V200(); /* process screen cl0vm005*/
      end
    else
      TA1REC.TA1TBLKE = "CLAIMS UNKNOWN SCREEN NAME";
      XPCL010();
    end
  end
  ;
  ;
   /* at this point;*/
       /* if the end-of-application flag (clxeoaf ) = 'n'*/
         /* the perform will return to the top of cl0v050...*/
       /* else*/
         /* the perform will auto return to cl0v000.*/
  ;
  ;
  ;
end // end KL0V050

// update est. clm value clarec
Function KL0V060()
  ;
   /* ************************************************************/
   /* *                                                         **/
   /* *                                                         **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0V060"; /* set current process name*/
  ;
  ;
  if (CL0VW01.CL0VWAMT != CLOREC.CLODMAMT /* changed est value*/
   || CL0VW01.CL-CLCOM-FL != CLAREC.CLACMIND) /* changed comments*/
    if (CLWREC.CLWACTIV != "I") /* and not in inquiry mode*/
      KL0VSJA();
    else
      /* next sentence*/
    end
  end
  ;
end // end KL0V060

// control module for adds
Function KL0V100()
   /* ************************************************************/
   /* *    execute process                                      **/
   /* *                                                         **/
   /* *  note - this process is being performed in a            **/
   /* *     "while loop" from cl0v050 until the end-of-screen   **/
   /* *     flag (clxeosfl) is set to 'y'.                      **/
   /* *                                                         **/
   /* *   the execute process will perform either the defective **/
   /* *   header or detail process depending on:                **/
   /* *                                                         **/
   /* *      header- if the claim number and seq number have a  **/
   /* *              memo written against them. then they       **/
   /* *              are consider closed and the user will      **/
   /* *              return to kl0vm005 screen.                 **/
   /* *                                                         **/
   /* *              if the defective header does not exist,    **/
   /* *              one must be added before detail info. can  **/
   /* *              be added. the user will add the required   **/
   /* *              fields and the application will exit the   **/
   /* *              header loop and go into the detail loop.   **/
   /* *                                                         **/
   /* *      detail- the detail screen will display all the     **/
   /* *              header info. and the user will enter all   **/
   /* *              the required data. the while loop is       **/
   /* *              stopped when the user does not enter a     **/
   /* *              nike prod. id and presses enter.           **/
   /* *                                                         **/
   /* *     pf keys- the pf keys will terminate the entire add  **/
   /* *              loop and go back to cl0v050 process.       **/
   /* *                                                         **/
   /* *                                                         **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0V100"; /* set current process name*/
  ;
  CLXREC.CLXMSG = " "; /* set non-ezemno error message to*/
                                   /* spaces*/
  CLXREC.CLXERRF = "N"; /* re-set error flag*/
  CL0VW01.CL0VWWRF = "N"; /* re-set warning flag*/
  ;
  if (CL0VW01.CL0VWUDF == "N")
    CLXREC.CLXEOSF = "Y";
    CLXREC.CLXCSCRN = "KL0VM005";
    return;
  else
    /* next sentence*/
  end
  ;
  ;
   /* update the defective header*/
  if (CL0VW01.CL0VWHDF == "N" /* header not complete flag*/
   && CL0VW01.CL0VWUDF == "Y") /* update flag*/
    while (CL0VW01.CL0VWEHF == "N" /* end of header flag.*/
     && CLXREC.CLXEOSF == "N"   
     && CLXREC.CLXEOAF == "N")
      KL0V130(); /* display/add defective header*/
    end
  end
   /* update the defective detail*/
  if (CL0VW01.CL0VWHDF == "Y" /* header complete flag*/
   && CL0VW01.CL0VWUDF == "Y") /* update flag*/
    while (CL0VW01.CL0VWDEF == "N" /* end of detail flag.*/
     && CLXREC.CLXEOSF == "N"   
     && CLXREC.CLXEOAF == "N")
      KL0V150(); /* update def. detail data.*/
    end
    KL0VSCA(); /* update def header;*/
  end
  ;
  KL0VSAN();
                                   /* move kl0vm001 header infor to cl0vw01*/
  ;
  ;
end // end KL0V100

// validate screen m001 pf keys
Function KL0V110()
   /* ************************************************************/
   /* *  validate pf keys                                       **/
   /* *                                                         **/
   /* *  the only keys acted upon at this time are pf 1, 3 & 4  **/
   /* *  and fastpath                                           **/
   /* *                                                         **/
   /* *  the other keys are just verified that they are used    **/
   /* *  by this application.  if the pf key is not recognized, **/
   /* *  the application resets all modified fields to remain   **/
   /* *  modified, then reshows the map with an error message.  **/
   /* *                                                         **/
   /* *  these other pf keys are acted upon after the editing   **/
   /* *  and updating have occured.                             **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0V110"; /* set current process name*/
  ;
     /* if you want to use pa2 to ezeclos, for testing only,*/
     /* then use stmnt group 'tests01' or some non-std name*/
  ;
  KL0VS26(); /* set fields modfd so user no re-key*/
  ;
  ;
  ;
  if (converseVar.eventKey is enter)
        /* check for fastpath option/item*/
    if (KL0VM001.CATOAP != " ") /* if fastpath option entered,*/
      COMMAREA.CATOAP = KL0VM001.CATOAP;
      COMMAREA.CAITEM = KL0VM001.CAITEM;
      XPCL002(); /* exit application*/
      return;
    else
      return;
    end
  else
    if (converseVar.eventKey is pf1)
      XSPF1();
      return;
    else
      if (converseVar.eventKey is pf3)
        COMMAREA.CATOAP = "KL0A";
        CLXREC.CLXEOSF = "Y"; /* done with screen kl0vm001*/
        CLXREC.CLXEOAF = "Y"; /* done with application*/
        XPCL002(); /* exit application*/
        return;
      else
        if (converseVar.eventKey is pf4)
          XSPF4();
          XPCL002(); /* exit application*/
          return;
               /* ELSE ;*/
                 /* IF EZEAID IS PF13;*/
                   /* MOVE 'KL0VM010' TO CLXREC.CLXCSCRN;*/
                   /* MOVE 'Y' TO CLXREC.CLXEOSF   ; done with screen 005*/
                   /* EZERTN;*/
          /* next sentence*/
        else
          if (converseVar.eventKey is pf15)
            CLXREC.CLXCSCRN = "KL0VM005";
            CLXREC.CLXEOSF = "Y"; /* done with screen 005*/
            return;
          else
            if (converseVar.eventKey is pf17)
              COMMAREA.CATOAP = "KL0F";
              CLXREC.CLXEOSF = "Y"; /* done with screen kl0vm001*/
              CLXREC.CLXEOAF = "Y"; /* done with application*/
              XPCL002(); /* exit application*/
              return;
            end
          end
        end
      end
    end
  end
  ;
      /* pf key not valid*/
  ;
  converseLib.validationFailed(2); /* pf key not valid*/
  CLXREC.CLXERRF = "Y";
  ;
  ;
  ;
end // end KL0V110

// add/display defective header.
Function KL0V130()
   /* ************************************************************/
   /* *    process screen cl0vm001 (top half)                   **/
   /* *                                                         **/
   /* *  note - this process is being performed in a            **/
   /* *     "while loop" from cl0v100 until:                    **/
   /* *         cl0vw01.clovwehf = 'y' (end of header flag)     **/
   /* *         clxrec.clxeosf   = 'y' (end of screen flag)     **/
   /* *         clxrec.clxeoaf   = 'y' (end of appl.  flag)     **/
   /* *                                                         **/
   /* *     this is the defective header add screen.            **/
   /* *   the update step will add data to 4 db2 table          **/
   /* *       1) cljrec - return authorization (tempory)*/
   /* *       2) cllrec - actual return         (tempory)       **/
   /* *       3) clorec - defective header                      **/
   /* *       4) cl2rec - return inspection                     **/
   /* *                                                         **/
   /* *                                                         **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0V130"; /* set current process name*/
  KL0VM001.XXXPRCNM = "KL0V130"; /* set current process name*/
  KL0VM001.XXXMAPNM = "KL0VM001"; /* set current map name*/
  KL0VM001.XXXTITLE = " ADD - DEFECTIVE HEADER DATA  ";
  KL0VM001.XXXCURDT = VGVar.currentShortGregorianDate;
  KL0VM001.XXXRVNBR = "0";
  set KL0VM001.CL0VMFDA skip, invisible;
  ;
  if (CLXREC.CLXERRF == "Y")
    /* next sentence*/
  else
    if (CL0VW01.CL0VWUDF == "N")
      KL0VSAL(); /* set cl0vm001 map fields to autoskip*/
    else
      KL0VSAM(); /* set detail fields to autoskip*/
    end
  end
  ;
  ;
   /* ************************************************************/
  converse KL0VM001 ;
   /* ************************************************************/
  ;
  CLXREC.CLXMSG = " "; /* set non-ezemno error message to*/
                                   /* spaces*/
  CLXREC.CLXERRF = "N"; /* re-set error flag*/
  ;
  ;
  KL0V110(); /* handle any special entries*/
    /* may exit appl from this process*/
  ;
  ;
  if (CLXREC.CLXERRF == "Y" /* if screen has errors*/
   || CLXREC.CLXEOSF == "N")
    KL0VSBA(); /* go edit screen entries*/
  else
    /* next sentence                ;   re-show screen*/
  end
  ;
      /* determine next action*/
  ;
  if (CLXREC.CLXERRF == "Y") /* if screen has errors*/
    CLXREC.CLXEOSF = "N";
    /* next sentence                ;   re-show screen*/
  else
    if (CLXREC.CLXEOSF == "Y")
      /* next sentence                ;   re-show screen*/
    else
      if (CL0VW01.CL0VWUDF == "N" /* defective update = no*/
       && converseVar.eventKey is enter)
        CL0VW01.CL0VWEHF = "Y"; /* finished with header screen*/
         /* go back to cl0v100 module.*/
      else
        KL0VSBE(); /* add actual returns,def. header,return auth. recs.*/
        if (CLXREC.CLXERRF == "Y") /* if error while doing updates.*/
          CLXREC.CLXEOSF = "N";
        else
          /* next sentence*/
        end
      end
    end
  end
  ;
  ;
end // end KL0V130

// add defective detail.
Function KL0V150()
   /* ************************************************************/
   /* *    process screen cl0vm001 (bottom half)                **/
   /* *                                                         **/
   /* *  note - this process is being performed in a            **/
   /* *     "while loop" from cl0v100 until the end-of-screen   **/
   /* *     flag (clxeosfl) is set to 'y'.                      **/
   /* *                                                         **/
   /* *     this is the defective detail add screen.            **/
   /* *                                                         **/
   /* *                                                         **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0V150"; /* set current process name*/
  KL0VM001.XXXPRCNM = "KL0V150"; /* set current process name*/
  KL0VM001.XXXMAPNM = "KL0VM001"; /* set current map name*/
  KL0VM001.XXXTITLE = " ADD - DEFECTIVE DETAIL DATA  ";
  KL0VM001.XXXCURDT = VGVar.currentShortGregorianDate;
  KL0VM001.XXXRVNBR = "0";
  ;
  set KL0VM001.CL0VMFDA skip, invisible;
  ;
  if (CLXREC.CLXERRF == "Y" /* error flag*/
   || CL0VW01.CL0VWWRF == "Y") /* warning flag*/
    /* next sentence*/
  else
    if (CL0VW01.CL0VWUDF == "N")
      KL0VSAP(); /* set all fields to protect*/
    else
      ;
       /* position cursor on screen*/
      ;
      if (KL0VM001.CLJNCRFL == " "
       || KL0VM001.XXXUSRID == " "
       || KL0VM001.CL0VMIDT == " "
       || KL0VM001.XWHCD == " ")
        set KL0VM001.XXXUSRID cursor;
        KL0VM001.SY2CLRID = "00";
        KL0VM001.XDMCD = "00";
      else
        set KL0VM001.SY1STNBR cursor;
        KL0VM001.SY2CLRID = "00";
        KL0VM001.XDMCD = "00";
      end
    end
  end
  ;
   /* repaint screen with values from cl0vw01*/
  ;
  KL0VM001.CLJNCRFL = CL0VW01.CLJNCRFL;
  KL0VM001.XXXUSRID = CL0VW01.XXXUSRID;
   /* MOVE CL0VW01.CL0VMIDT TO CL0VM001.CL0VMIDT;*/
  KL0VM001.XWHCD = CL0VW01.XWHCD;
  ;
   /* ************************************************************/
  converse KL0VM001 ;
   /* ************************************************************/
  ;
  ;
  CLXREC.CLXMSG = " "; /* set non-ezemno error message to*/
                                   /* spaces*/
  CLXREC.CLXERRF = "N"; /* re-set error flag*/
  ;
  KL0V160(); /* handle any special entries*/
    /* may exit appl from this process*/
  ;
  if (CLXREC.CLXERRF == "Y")
    /* next sentence*/
  else
    KL0VSCB(); /* edit defective detail screen*/
  end
  ;
      /* determine next action*/
  ;
  if (CLXREC.CLXERRF == "Y") /* if screen has errors*/
    /* next sentence                ;   re-show screen*/
  else
    if (converseVar.eventKey is enter /* or user wants to see same screen*/
     && CL0VW01.CL0VWEDF == "Y")      /* end of detail screen processing*/
      /* next sentence*/
    else
      if (converseVar.eventKey is enter /* or user wants to see same screen*/
       && CL0VW01.CL0VWUDF == "Y"       
       && CL0VW01.CL0VWWRF == "N")     
        KL0VSCC(); /* add/update defective detail row*/
      else
        /* next sentence*/
      end
    end
  end
  ;
  ;
end // end KL0V150

// handle special pf keys & enter
Function KL0V160()
  ;
   /* ************************************************************/
   /* *  validate pf keys                                       **/
   /* *                                                         **/
   /* *  the only keys acted upon at this time are pf 1, 3 & 4  **/
   /* *  and fastpath                                           **/
   /* *                                                         **/
   /* *  the other keys are just verified that they are used    **/
   /* *  by this application.  if the pf key is not recognized, **/
   /* *  the application resets all modified fields to remain   **/
   /* *  modified, then reshows the map with an error message.  **/
   /* *                                                         **/
   /* *  these other pf keys are acted upon after the editing   **/
   /* *  and updating have occured.                             **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0V160"; /* set current process name*/
  ;
  KL0VS26(); /* set fields modfd so user no re-key*/
  ;
     /* if you want to use pa2 to ezeclos, for testing only,*/
     /* then use stmnt group 'tests01' or some non-std name*/
  ;
  if (converseVar.eventKey is pfkey)
    if (KL0VM001.SY1STNBR != " "
     || KL0VM001.YDFCD != " "
     || KL0VM001.CL0VWDFQ != 0
     || KL0VM001.CLPDEFQ != 0)
      converseLib.validationFailed(369);
      CLXREC.CLXERRF = "Y";
      return;
    else
      /* next sentence*/
    end
  else
    if (converseVar.eventKey is enter)
      if (KL0VM001.SY1STNBR == " "
       && CLXREC.CLXERRF != "Y"
       && KL0VM001.YDFCD == " "
       && KL0VM001.CATOAP == " ") /* if fastpath option entered,*/
        CL0VW01.CL0VWDEF = "Y";
        CLXREC.CLXEOSF = "Y";
        CLXREC.CLXCSCRN = "KL0VM005";
        return;
      else
        /* next sentence*/
      end
      /* next sentence*/
    end
  end
  ;
  ;
  ;
  ;
  if (converseVar.eventKey is enter)
        /* check for fastpath option/item*/
    if (KL0VM001.CATOAP != " ") /* if fastpath option entered,*/
      COMMAREA.CATOAP = KL0VM001.CATOAP;
      COMMAREA.CAITEM = KL0VM001.CAITEM;
      KL0VSGG();
      KL0V060();
      XPCL002(); /* exit application*/
      return;
    else
      return;
    end
  else
    if (converseVar.eventKey is pf1)
      KL0VSGG();
      KL0V060();
      XSPF1();
      return;
    else
      if (converseVar.eventKey is pf3)
        COMMAREA.CATOAP = "KL0A";
        CLXREC.CLXEOSF = "Y"; /* done with screen kl0vm001*/
        CLXREC.CLXEOAF = "Y"; /* done with application*/
        KL0VSGG();
        KL0V060();
        return;
      else
        if (converseVar.eventKey is pf4)
          KL0VSGG();
          KL0V060();
          XSPF4();
          return;
        else
          if (converseVar.eventKey is pf15)
            CLXREC.CLXCSCRN = "KL0VM005";
            CLXREC.CLXEOSF = "Y"; /* done with screen 005*/
            return;
          else
            if (converseVar.eventKey is pf17)
              COMMAREA.CATOAP = "KL0F";
              CLXREC.CLXEOSF = "Y"; /* done with screen kl0vm001*/
              CLXREC.CLXEOAF = "Y"; /* done with application*/
              KL0VSGG();
              KL0V060();
              XPCL002();
              return;
            else
              /* next sentence*/
            end
          end
                 /* END ;*/
        end
      end
    end
  end
  ;
      /* pf key not valid*/
  ;
  converseLib.validationFailed(2); /* pf key not valid*/
  CLXREC.CLXERRF = "Y"; /* set error flag to yes*/
  ;
  ;
end // end KL0V160

// retrieve all def. detail recs.
Function KL0V200()
  ;
   /* ************************************************************/
   /* *    execute process                                      **/
   /* *                                                         **/
   /* *  note - this process is being performed in a            **/
   /* *     "while loop" from cl0v050 until the end-of-screen   **/
   /* *     flag (clxeosfl) is set to 'y'.                      **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0V200"; /* set current process name*/
  ;
  CLXREC.CLXMSG = " "; /* set non-ezemno error message to*/
                                   /* spaces*/
  CLXREC.CLXERRF = "N"; /* re-set error flag*/
  CL0VW01.CL0VWELF = "N"; /* set end of header flag*/
  ;
  KL0VSFA(); /* select 500 defective detail lines.*/
   /* and move them to the 1st map*/
  ;
   /* display 500 defective detail lines*/
  while (CL0VW01.CL0VWELF == "N" /* end of list screen flag.*/
   && CLXREC.CLXEOSF == "N"   
   && CLXREC.CLXEOAF == "N")
    KL0V230(); /* display list screen*/
  end
  ;
  ;
end // end KL0V200

// handle screen m005 spec entrys
Function KL0V210()
   /* ************************************************************/
   /* *                                                         **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0V210"; /* set current process name*/
  ;
  ;
  if (converseVar.eventKey is enter)
    if (KL0VM005.CATOAP != " ") /* if fastpath option entered,*/
      COMMAREA.CATOAP = KL0VM005.CATOAP;
      COMMAREA.CAITEM = KL0VM005.CAITEM;
      XPCL002(); /* exit application*/
      return;
    else
      return;
    end
  else
    if (converseVar.eventKey is pf1)
      XSPF1();
      return;
    else
      if (converseVar.eventKey is pf3)
        COMMAREA.CATOAP = "KL0A";
        CLXREC.CLXEOSF = "Y"; /* done with screen 005*/
        CLXREC.CLXEOAF = "Y"; /* done with screen 005*/
        KL0VSGG(); /* update defective header*/
        KL0V060(); /* update claim header*/
        XPCL002();
      else
        if (converseVar.eventKey is pf4)
          XSPF4();
          return;
        else
          if (converseVar.eventKey is pf7
           || converseVar.eventKey is pf8
           || converseVar.eventKey is enter)
            return;
          else
            if (converseVar.eventKey is pf10)
              COMMAREA.CATOAP = "KL0W";
              CLXREC.CATOAP = COMMAREA.CATOAP;
              CLXREC.YCTCD = CLAREC.YCTCD;
              if (CLXREC.YATKEY in YATTBL.YATKEY)
                CLXREC.CLXEOSF = "Y"; /* done with screen 005*/
                CLXREC.CLXEOAF = "Y"; /* done with screen 005*/
                KL0VSGG(); /* update defective header*/
                KL0V060(); /* update claim header*/
                XPCL002();
                return;
              else
                COMMAREA.CATOAP = " ";
                converseLib.validationFailed(25); /* cant xfer due to invalid claim type*/
                CLXREC.CLXERRF = "Y";
                return;
              end
            else
              if (converseVar.eventKey is pf14)
                COMMAREA.CATOAP = "KL0J";
                CLXREC.CATOAP = COMMAREA.CATOAP;
                CLXREC.YCTCD = CLAREC.YCTCD;
                if (CLXREC.YATKEY in YATTBL.YATKEY)
                  CLXREC.CLXEOSF = "Y"; /* done with screen 005*/
                  CLXREC.CLXEOAF = "Y"; /* done with screen 005*/
                  KL0VSGG(); /* update defective header*/
                  KL0V060(); /* update claim header*/
                  XPCL002();
                  return;
                else
                  COMMAREA.CATOAP = " ";
                  converseLib.validationFailed(25); /* cant xfer due to invalid claim type*/
                  CLXREC.CLXERRF = "Y";
                  return;
                end
              else
                if (converseVar.eventKey is pf15)
                  if (CL0VW01.CL0VWUDF == "Y")
                    CLXREC.CLXCSCRN = "KL0VM001";
                    CLXREC.CLXEOSF = "Y"; /* done with screen 005*/
                    return;
                  else
                    converseLib.validationFailed(370); /* add action is invalid during inquire mode*/
                    CLXREC.CLXERRF = "Y";
                    return;
                  end
                else
                  if (converseVar.eventKey is pf17)
                    COMMAREA.CATOAP = "KL0F";
                    CLXREC.CLXEOSF = "Y"; /* done with screen 005*/
                    CLXREC.CLXEOAF = "Y"; /* done with screen 005*/
                    KL0VSGG(); /* update defective header*/
                    KL0V060(); /* update claim header*/
                    XPCL002();
                    return;
                  else
                    /* next sentence*/
                  end
                end
              end
            end
          end
        end
      end
    end
  end
  ;
  ;
      /* pf key not valid*/
  ;
  converseLib.validationFailed(2); /* pf key not valid*/
  CLXREC.CLXERRF = "Y";
  ;
  ;
  ;
end // end KL0V210

// display def. detail list
Function KL0V230()
  ;
   /* ************************************************************/
   /* *                                                         **/
   /* *     process screen cl0vm005                             **/
   /* *                                                         **/
   /* *  note that this process is being performed in a         **/
   /* *      "while loop" from cl0v200 until:                   **/
   /* *        cl0vw01.cl0vwelf = 'y'  end of list screen flag  **/
   /* *        clxrec.clxeosf   = 'y'  end of screen flag       **/
   /* *        clxrec.clxeoaf   = 'y'  end of application flag  **/
   /* *                                                         **/
   /* *   this is a summary list of defective products entered  **/
   /* * against a claim. the user can enter 3 values in         **/
   /* * cl0vm005.cl0vmsel field:                                **/
   /* *       's' - select this field and display the detail    **/
   /* *             for either inquire or update.               **/
   /* *       'x' - delete this defective item and detail from  **/
   /* *             the data base.                              **/
   /* *       'a' - default to select all the product items for **/
   /* *             this claim number.                          **/
   /* *  after a successful selection a 'v' will be entered into**/
   /* *  the cl0vw02.cl0vmsel(clxarayx) field.                  **/
   /* *                                                         **/
   /* *  the user will enter a 'y' in the inspection complete   **/
   /* * field to inform the program that the inspection is      **/
   /* * complete. the user must also enter an approved qty.     **/
   /* * the progam will update the approved qty in clkrec       **/
   /* * (return auth.). the process-complete date will be       **/
   /* * updated in cllrec(actual return) and the claim status   **/
   /* * will be changed to 'rpm' and some flags will be set     **/
   /* * in the claim header (clarec).                           **/
   /* *                                                         **/
   /* * the flows from this screen are:                         **/
   /* *     pf1 - go to back help menu.                         **/
   /* *     pf3 - go to back to previous application.           **/
   /* *     pf4 - go to master menu.                            **/
   /* *     pf10- go to 'kl0w' shipping charges map. and then   **/
   /* *           back to 'kl0v' def. inquire map.              **/
   /* *     pf14- go to 'kl0j' general ledger map. and then     **/
   /* *           back to 'cl0v' def. inquire map.              **/
   /* *     pf15- go to cl0vm001                                **/
   /* *     enter - with no selections or all 'v' to 'kl0e'     **/
   /* *             claim header.                               **/
   /* *     enter - with selections go to cl0vm001 (chg/inq map)**/
   /* *                                                         **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0V230"; /* set current process name*/
  KL0VM005.XXXPRCNM = "KL0V230"; /* set current process name*/
  KL0VM005.XXXMAPNM = "KL0VM005"; /* set current process name*/
  KL0VM005.XXXCURDT = VGVar.currentShortGregorianDate;
  KL0VM005.XXXRVNBR = "0";
  ;
  if (CL0VW01.CL2ISXDT > 0)
    KL0VM005.CL0VMICF = "Y";
  else
    /* next sentence*/
  end
  ;
  if (CLXREC.CLXERRF == "Y")
    /* next sentence*/
  else
    set KL0VM005.CL0VMSEL[1] cursor;
  end
  ;
  if (CL0VW01.CL0VWUDF == "N")
    KL0VM005.XXXTITLE = " INQUIRE - DEFECTIVE SUMMARY DATA ";
    set KL0VM005.CL0VMJAQ skip;
    set KL0VM005.CL0VMICF skip;
  else
    if (CL0VW01.CL2ISXDT > 0)
      if (CL0VW01.CL2ISXDT == CLXREC.XXXCDTE)
        KL0VM005.XXXTITLE = " UPDATE  - DEFECTIVE SUMMARY DATA ";
      else
        KL0VM005.XXXTITLE = " INQUIRE - DEFECTIVE SUMMARY DATA ";
        set KL0VM005.CL0VMJAQ skip;
        set KL0VM005.CL0VMICF skip;
      end
    else
      KL0VM005.XXXTITLE = " UPDATE  - DEFECTIVE SUMMARY DATA ";
    end
  end
  ;
  ;
   /* ************************************************************/
  converse KL0VM005 ;
   /* ************************************************************/
  ;
  CL0VW01.CL0VWLDF = "N"; /* set list flag to no*/
  CLXREC.CLXERRF = "N"; /* set error flag to no*/
  ;
  CLXREC.CLXMSG = " "; /* set non-ezemno error msg to spaces*/
  ;
  if (converseVar.eventKey is enter
   && KL0VM005.CAITEM != " "
   && KL0VM005.CATOAP == " ")
    KL0VSFH(); /* handle pf7 & pf8 reading next 500 prod.*/
    return;
  else
    if (converseVar.eventKey is pf8
     && CLXREC.CLXARAYX >= CL0VW01.CL0VWMXL)
      KL0VM005.CAITEM = CL0VW02.SY1STNBR[498];
      KL0VSFH();
      return;
    else
      /* next sentence*/
    end
  end
  ;
  KL0V210(); /* handle special entries*/
  ;
  if ("A" in KL0VM005.CL0VMSEL)
    if (KL0VM005.CL0VMSEL[1] == "A")
      KL0VSFG(); /* move an 's' to all cl0vw02.cl0vmsel lines*/
    else
      CLXREC.CLXERRF = "Y";
      VAGen_EZEMSG = "A - IS VALID ONLY ON LINE 1 ";
      set KL0VM005.CL0VMSEL[sysVar.arrayIndex] cursor, bold;
      /* next sentence*/
    end
  else
    /* next sentence*/
  end
  ;
  if (CLXREC.CLXERRF == "Y")
    /* next sentence*/
  else
    if ("X" in KL0VM005.CL0VMSEL)
      if ("S" in KL0VM005.CL0VMSEL)
        CLXREC.CLXERRF = "Y";
        converseLib.validationFailed(371); /* chose either 'x' or 's' to execute*/
        set KL0VM005.CL0VMSEL[sysVar.arrayIndex] cursor, bold;
      else
        KL0VSFE(); /* move screen data to cl0vw02*/
      end
    else
      if ("S" in KL0VM005.CL0VMSEL)
        if ("X" in KL0VM005.CL0VMSEL)
          CLXREC.CLXERRF = "Y";
          converseLib.validationFailed(371); /* chose either 'x' or 's' to execute*/
          set KL0VM005.CL0VMSEL[sysVar.arrayIndex] cursor, bold;
        else
          KL0VSFE(); /* move screen data to cl0vw02*/
        end
      else
        CLXREC.CLXCURLN = 1;
        while (CLXREC.CLXCURLN <= 10)
          if (KL0VM005.CL0VMSEL[CLXCURLN] == "S"
           || KL0VM005.CL0VMSEL[CLXCURLN] == "X"
           || KL0VM005.CL0VMSEL[CLXCURLN] == "V"
           || KL0VM005.CL0VMSEL[CLXCURLN] == " ")
            /* next sentence*/
          else
            CLXREC.CLXERRF = "Y";
            converseLib.validationFailed(371); /* chose either 'x' or 's' to execute*/
            set KL0VM005.CL0VMSEL[CLXCURLN] cursor, bold;
          end
          CLXREC.CLXCURLN = CLXREC.CLXCURLN + 1;
        end
      end
      /* next sentence*/
    end
  end
  ;
  if (CLXREC.CLXERRF == "Y")
    /* next sentence*/
  else
    if (converseVar.eventKey is pf7)
      KL0VS07();
    else
      if (converseVar.eventKey is pf8)
        KL0VS08();
      end
    end
  end
  ;
  ;
   /* if ezeaid is enter and there is something*/
   /* in the sel field then do cl0v250*/
   /* else return to next module.*/
  if (CLXREC.CLXERRF == "Y"
   || converseVar.eventKey is pf7
   || converseVar.eventKey is pf8)
    /* next sentence*/
  else
    if (converseVar.eventKey is enter)
      if ("X" in CL0VW02.CL0VMSEL)
        while (CL0VW01.CL0VWLDF == "N") /* until list detail flag is complete*/
          KL0V250(); /* process update/inquire detail*/
        end
      else
        if ("S" in CL0VW02.CL0VMSEL)
          while (CL0VW01.CL0VWLDF == "N")
                                   /* until list detail flag is complete*/
            KL0V250(); /* process update/inquire detail*/
          end
        else
          KL0VSHG(); /* check to add the inspection compete flag*/
          if (CLXREC.CLXERRF == "Y")
            /* next sentence*/
          else
            CLXREC.CLXEOSF = "Y";
            CLXREC.CLXEOAF = "Y";
            CL0VW01.CL0VWELF = "Y";
            COMMAREA.CATOAP = "KL0E";
            KL0VSGG(); /* update defective header*/
            KL0V060(); /* update claim header*/
            XPCL002();
          end
        end
      end
    end
  end
  ;
   /* at this point;*/
      /* if the end-of-screen flag (clxeosfl) = 'n'*/
          /* we go back to the top of cl0v200.*/
      /* if the end-of-screen flag (clxeosfl) = 'y'*/
          /* we return to cl0v050.*/
  ;
  ;
end // end KL0V230

// process 's' and 'x'
Function KL0V250()
  ;
  ;
  CLXREC.CLXCPROC = "CL0V250";
  ;
  CL0VW01.CL0VWDEF = "N";
  ;
   /* the x are all processed first and then a new cl0vm005 screen*/
   /* is redisplayed with new rows.*/
  ;
  if ("X" in CL0VW02.CL0VMSEL)
    while ("X" in CL0VW02.CL0VMSEL)
      CLXREC.CLXARAYX = sysVar.arrayIndex;
      KL0VSGA(); /* begin the delete process*/
    end
    KL0VSGG(); /* update header info with new totals*/
    KL0V060(); /* update the clarec correctly*/
    KL0VSFA();
    CL0VW01.CL0VWLDF = "Y"; /* end of detail list*/
    CL0VW01.CL0VWELF = "Y"; /* end of list screen*/
    return;
  end
  ;
  ;
  ;
  if ("S" in CL0VW02.CL0VMSEL)
    while ("S" in CL0VW02.CL0VMSEL
     && CL0VW01.CL0VWDEF == "N")
      CLXREC.CLXARAYX = sysVar.arrayIndex;
      if (CLXREC.CLXERRF == "Y")
        /* next sentence*/
      else
        KL0VSGB(); /* move cl0vw02 to cl0vm001 change/inquire record*/
      end
      KL0V280(); /* update/inquire defective detail*/
    end
    ;
     /* repaint screen with any new values*/
    ;
    KL0VSFF(); /* reshow header values - 8-3-88*/
    CLXREC.CLXCURLN = 1;
    CLXREC.CLXMAPMX = 1;
    while (CLXREC.CLXCURLN <= 10)
         /* AND CLXREC.CLXARAYX LE 500;*/
      KL0VSFD();
    end
  end
  ;
  CL0VW01.CL0VWLDF = "Y"; /* end of list flag*/
  ;
  ;
  ;
end // end KL0V250

// chg/display def. detail map
Function KL0V280()
   /* ************************************************************/
   /* *    process screen cl0vm001 (bottom half)                **/
   /* *                                                         **/
   /* *  note - this process is being performed in a            **/
   /* *     "while loop" from cl0v250 until:                    **/
   /* *       clxrec.clxeosfl   = 'y'                           **/
   /* *       cl0vw01.cl0vwdef  = 'y'.                          **/
   /* *                                                         **/
   /* *     this is the defective detail change screen.         **/
   /* *                                                         **/
   /* *                                                         **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0V280"; /* set current process name*/
  KL0VM001.XXXPRCNM = "KL0V280"; /* set current process name*/
  KL0VM001.XXXMAPNM = "KL0VM001"; /* set current map name*/
  KL0VM001.XXXRVNBR = "0";
  KL0VM001.XXXCURDT = VGVar.currentShortGregorianDate;
  ;
  if (CL0VW01.CL2ISXDT > 0)
    KL0VM001.CL0VMICF = "Y";
  else
    /* next sentence*/
  end
  ;
  ;
  if (CLWREC.CLWACTIV == "I"
   || CL0VW01.CL0VWUDF == "N")
    KL0VM001.XXXTITLE = " INQUIRE - DEFECTIVE DETAIL DATA  ";
    KL0VSHA(); /* set all field items to autoskip*/
  else
    KL0VSHB(); /* set key field to autoskip*/
    KL0VM001.XXXTITLE = " CHANGE - DEFECTIVE DETAIL DATA  ";
  end
  ;
  if (CLXREC.CLXERRF == "Y")
    /* next sentence*/
  else
    set KL0VM001.XXXUSRID cursor;
  end
  ;
   /* ************************************************************/
  converse KL0VM001 ;
   /* ************************************************************/
  ;
  ;
  CLXREC.CLXMSG = " "; /* set non-ezemno error message to*/
                                   /* spaces*/
  CLXREC.CLXERRF = "N"; /* re-set error flag*/
  ;
  KL0V290(); /* handle special pf keys*/
  ;
  if (converseVar.eventKey is enter
   && CL0VW01.CL0VWUDF == "N")
    CL0VW02.CL0VMSEL[CLXARAYX] = "V";
    return;
  else
    /* next sentence*/
  end
  ;
  if (CLXREC.CLXERRF == "Y")
    /* next sentence*/
  else
    KL0VSHQ(); /* edit defective detail chg screen*/
  end
  ;
      /* determine next action*/
  ;
  if (CLXREC.CLXERRF == "Y") /* if screen has errors*/
    CLXREC.CLXEOSF = "N"; /* re-show screen*/
    CL0VW01.CL0VWDEF = "N"; /* re-show screen*/
  else
    if (CLWREC.CLWACTIV != "I")
      KL0VSHC(); /* update defective detail row*/
      if (CLXREC.CLXERRF == "Y") /* if screen has errors*/
        CLXREC.CLXEOSF = "N"; /* re-show screen*/
        CL0VW01.CL0VWDEF = "N"; /* re-show screen*/
      else
        CL0VW02.CL0VMSEL[CLXARAYX] = "V";
      end
    else
      CL0VW02.CL0VMSEL[CLXARAYX] = "V";
    end
  end
end // end KL0V280

// check for pf keys
Function KL0V290()
  ;
   /* ************************************************************/
   /* *  validate pf keys                                       **/
   /* *                                                         **/
   /* *  the only keys acted upon at this time are pf 1, 3 & 4  **/
   /* *  and fastpath                                           **/
   /* *                                                         **/
   /* *  the other keys are just verified that they are used    **/
   /* *  by this application.  if the pf key is not recognized, **/
   /* *  the application resets all modified fields to remain   **/
   /* *  modified, then reshows the map with an error message.  **/
   /* *                                                         **/
   /* *  these other pf keys are acted upon after the editing   **/
   /* *  and updating have occured.                             **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0V290"; /* set current process name*/
  ;
     /* if you want to use pa2 to ezeclos, for testing only,*/
     /* then use stmnt group 'tests01' or some non-std name*/
  ;
  KL0VS26(); /* set fields modfd so user no re-key*/
  ;
  if (converseVar.eventKey is enter)
        /* check for fastpath option/item*/
    if (KL0VM001.CATOAP != " ") /* if fastpath option entered,*/
      COMMAREA.CATOAP = KL0VM001.CATOAP;
      COMMAREA.CAITEM = KL0VM001.CAITEM;
      KL0VSGG();
      KL0V060();
      XPCL002(); /* exit application*/
      return;
    else
      return;
    end
  else
    if (converseVar.eventKey is pf3)
      COMMAREA.CATOAP = "KL0A";
      CLXREC.CLXEOSF = "Y"; /* done with screen 005*/
      CLXREC.CLXEOAF = "Y"; /* done with application*/
      CL0VW01.CL0VWDEF = "Y";
      KL0VSGG();
      KL0V060();
      XPCL002();
      return;
    else
      if (converseVar.eventKey is pf4)
        KL0VSGG();
        KL0V060();
        XSPF4();
        return;
      else
        if (converseVar.eventKey is pf15) /* transfer to summary screen*/
          CLXREC.CLXCSCRN = "KL0VM005";
          /* MOVE 'Y' TO CLXREC.CLXEOSF     ; done with screen 005*/
          CL0VW01.CL0VWDEF = "Y";
                 /* PERFORM CL0V060;*/
          return;
        else
          if (converseVar.eventKey is pf17)
            COMMAREA.CATOAP = "KL0F";
            CLXREC.CLXEOSF = "Y"; /* done with screen 005*/
            CLXREC.CLXEOAF = "Y"; /* done with application*/
            CL0VW01.CL0VWDEF = "Y";
            KL0VSGG();
            KL0V060();
            XPCL002();
            return;
          else
            if (converseVar.eventKey is pf24) /* transfer to add detail screen*/
              if (CL0VW01.CL0VWUDF == "Y")
                CLXREC.CLXCSCRN = "KL0VM001";
                CLXREC.CLXEOSF = "Y"; /* done with screen 005*/
                CL0VW01.CL0VWDEF = "Y";
                           /* PERFORM CL0V060;*/
                return;
              else
                converseLib.validationFailed(370); /* add action is invalid during inquire mode*/
                CLXREC.CLXERRF = "Y";
                return;
              end
            else
              /* next sentence*/
            end
          end
        end
      end
    end
  end
  ;
      /* pf key not valid*/
  ;
  converseLib.validationFailed(2); /* pf key not valid*/
  CLXREC.CLXERRF = "Y";
  ;
  ;
  ;
end // end KL0V290

// select set from clprec
Function KL0V791()
   /* **************************************/
   /* select set from clprec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO1350" ("S2", SQLCA, CLPREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        TA1REC.TA1LOCAT[2] = "CL0V791"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO1350";
        TA1REC.TA1DBASE = "DCLAIM  ";
        TA1REC.TA1TBLVU = "VDEFIT01";
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE;
        ;
        XPCL010(); /* error diagnosis routine*/
        ;
        return;
      end
    end
  end
end // end KL0V791

// fetch next from clprec
Function KL0V792()
   /* **************************************/
   /* fetch next from clprec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO1350" (CL0VW06, SQLCA, CLPREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        TA1REC.TA1LOCAT[2] = "CL0V792"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO1350";
        TA1REC.TA1DBASE = "DCLAIM  ";
        TA1REC.TA1TBLVU = "VDEFIT01";
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE;
        ;
        XPCL010(); /* error diagnosis routine*/
        ;
        return;
      end
    end
  end
end // end KL0V792

// close cursor for clprec
Function KL0V793()
   /* **************************************/
   /* fetch next from clprec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO1350" ("C2", SQLCA, CLPREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        TA1REC.TA1LOCAT[2] = "CL0V793"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO1350";
        TA1REC.TA1DBASE = "DCLAIM  ";
        TA1REC.TA1TBLVU = "VDEFIT01";
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE;
        ;
        XPCL010(); /* error diagnosis routine*/
        ;
        return;
      end
    end
  end
end // end KL0V793

// fetch unique from clarec
Function KL0V814()
   /* **************************************/
   /* select unique on clarec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO1160" ("S ", SQLCA, CLAREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        ;
        TA1REC.TA1LOCAT[2] = "CL0V814"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO1160"; /* location*/
        TA1REC.TA1DBASE = "DCLAIM"; /* database name*/
        TA1REC.TA1TBLVU = "VCLHDR01"; /* table view name*/
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* table key*/
        ;
        XPCL010(); /* error diagnosis routine*/
      end
    end
  end
end // end KL0V814

// update unique from clarec
Function KL0V817()
   /* **************************************/
   /* update unique on clarec*/
   /* **************************************/
  ;
  set SQLCA empty;
  CLAREC.CLAWSENF = "Y"; /* worksheet entry flag*/
  call "IO1160" ("U ", SQLCA, CLAREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        ;
        TA1REC.TA1LOCAT[2] = "CL0V817"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO1160"; /* location*/
        TA1REC.TA1DBASE = "DCLAIM"; /* database name*/
        TA1REC.TA1TBLVU = "VCLHDR01"; /* table view name*/
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* table key*/
        ;
        XPCL010(); /* error diagnosis routine*/
      end
    end
  end
end // end KL0V817

// fetch unique from cljrec
Function KL0V824()
   /* **************************************/
   /* select unique on cljrec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO1270" ("S ", SQLCA, CLJREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        ;
        TA1REC.TA1LOCAT[2] = "CL0V824"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO1270"; /* location*/
        TA1REC.TA1DBASE = "DCLAIM"; /* database name*/
        TA1REC.TA1TBLVU = "VRAHDR01"; /* table view name*/
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* table key*/
        ;
        XPCL010(); /* error diagnosis routine*/
      end
    end
  end
end // end KL0V824

// add record to cljrec
Function KL0V826()
   /* **************************************/
   /* add record to cljrec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO1270" ("A ", SQLCA, CLJREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      ;
      TA1REC.TA1LOCAT[2] = "CL0V826"; /* location*/
      TA1REC.TA1LOCAT[4] = "IO1270"; /* location*/
      TA1REC.TA1DBASE = "DCLAIM"; /* database name*/
      TA1REC.TA1TBLVU = "VRAHDR01"; /* table view name*/
      CLXREC.XXXWDTE = CLAREC.CLACLMNB;
      TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* table key*/
      ;
      XPCL010(); /* error diagnosis routine*/
    end
  end
end // end KL0V826

// update unique from cljrec
Function KL0V827()
   /* **************************************/
   /* update unique on cljrec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO1270" ("U ", SQLCA, CLJREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        ;
        TA1REC.TA1LOCAT[2] = "CL0V827"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO1270"; /* location*/
        TA1REC.TA1DBASE = "DCLAIM"; /* database name*/
        TA1REC.TA1TBLVU = "VRAHDR01"; /* table view name*/
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* table key*/
        ;
        XPCL010(); /* error diagnosis routine*/
      end
    end
  end
end // end KL0V827

// fetch unique from clorec
Function KL0V834()
   /* **************************************/
   /* select unique on clorec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO1340" ("S ", SQLCA, CLOREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        ;
        TA1REC.TA1LOCAT[2] = "CL0V834"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO1340"; /* location*/
        TA1REC.TA1DBASE = "DCLAIM"; /* database name*/
        TA1REC.TA1TBLVU = "VDEFHD01"; /* table view name*/
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* table key*/
        ;
        XPCL010(); /* error diagnosis routine*/
      end
    end
  end
end // end KL0V834

// add record to clorec
Function KL0V836()
   /* **************************************/
   /* add record to clorec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO1340" ("A ", SQLCA, CLOREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      ;
      TA1REC.TA1LOCAT[2] = "CL0V836"; /* location*/
      TA1REC.TA1LOCAT[4] = "IO1340"; /* location*/
      TA1REC.TA1DBASE = "DCLAIM"; /* database name*/
      TA1REC.TA1TBLVU = "VDEFHD01"; /* table view name*/
      CLXREC.XXXWDTE = CLAREC.CLACLMNB;
      TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* table key*/
      ;
      XPCL010(); /* error diagnosis routine*/
    end
  end
end // end KL0V836

// update unique from clorec
Function KL0V837()
   /* **************************************/
   /* update unique on clorec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO1340" ("U ", SQLCA, CLOREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        ;
        TA1REC.TA1LOCAT[2] = "CL0V837"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO1340"; /* location*/
        TA1REC.TA1DBASE = "DCLAIM"; /* database name*/
        TA1REC.TA1TBLVU = "VDEFHD01"; /* table view name*/
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* table key*/
        ;
        XPCL010(); /* error diagnosis routine*/
      end
    end
  end
end // end KL0V837

// fetch unique from cllrec
Function KL0V844()
   /* **************************************/
   /* select unique on cllrec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO1310" ("S ", SQLCA, CLLREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        ;
        TA1REC.TA1LOCAT[2] = "CL0V844"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO1310"; /* location*/
        TA1REC.TA1DBASE = "DCLAIM"; /* database name*/
        TA1REC.TA1TBLVU = "VCLRTN01"; /* table view name*/
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* table key*/
        ;
        XPCL010(); /* error diagnosis routine*/
      end
    end
  end
end // end KL0V844

// add record to cllrec
Function KL0V846()
   /* **************************************/
   /* add record to cllrec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO1310" ("A ", SQLCA, CLLREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      ;
      TA1REC.TA1LOCAT[2] = "CL0V846"; /* location*/
      TA1REC.TA1LOCAT[4] = "IO1310"; /* location*/
      TA1REC.TA1DBASE = "DCLAIM"; /* database name*/
      TA1REC.TA1TBLVU = "VCLRTN01"; /* table view name*/
      CLXREC.XXXWDTE = CLAREC.CLACLMNB;
      TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* table key*/
      ;
      XPCL010(); /* error diagnosis routine*/
    end
  end
end // end KL0V846

// update unique from cllrec
Function KL0V847()
   /* **************************************/
   /* update unique on cllrec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO1310" ("U ", SQLCA, CLLREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        ;
        TA1REC.TA1LOCAT[2] = "CL0V847"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO1310"; /* location*/
        TA1REC.TA1DBASE = "DCLAIM"; /* database name*/
        TA1REC.TA1TBLVU = "VCLRTN01"; /* table view name*/
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* table key*/
        ;
        XPCL010(); /* error diagnosis routine*/
      end
    end
  end
end // end KL0V847

// fetch unique from kucrec
Function KL0V864()
   /* **************************************/
   /* select unique on kucrec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO0240" ("S ", SQLCA, KUCREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        ;
        TA1REC.TA1LOCAT[2] = "CL0V864"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO0240"; /* location*/
        TA1REC.TA1DBASE = "DCUST "; /* database name*/
        TA1REC.TA1TBLVU = "VCMPNY01"; /* table view name*/
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* table key*/
        ;
        XPCL010(); /* error diagnosis routine*/
      end
    end
  end
end // end KL0V864

// fetch unique from iverec
Function KL0V874()
   /* **************************************/
   /* select unique on iverec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO1450" ("S ", SQLCA, IVEREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        ;
        TA1REC.TA1LOCAT[2] = "CL0V874"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO1450"; /* location*/
        TA1REC.TA1DBASE = "DINVC "; /* database name*/
        TA1REC.TA1TBLVU = "VSPECL01"; /* table view name*/
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* table key*/
        ;
        XPCL010(); /* error diagnosis routine*/
      end
    end
  end
end // end KL0V874

// select set from clprec
Function KL0V891()
   /* **************************************/
   /* select set from clprec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO1350" ("S1", SQLCA, CLPREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        TA1REC.TA1LOCAT[2] = "CL0V891"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO1350";
        TA1REC.TA1DBASE = "DCLAIM  ";
        TA1REC.TA1TBLVU = "VDEFIT01";
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE;
        ;
        XPCL010(); /* error diagnosis routine*/
        ;
        return;
      end
    end
  end
end // end KL0V891

// close cursor for clprec
Function KL0V893()
   /* **************************************/
   /* fetch next from clprec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO1350" ("C1", SQLCA, CLPREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        TA1REC.TA1LOCAT[2] = "CL0V893"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO1350";
        TA1REC.TA1DBASE = "DCLAIM  ";
        TA1REC.TA1TBLVU = "VDEFIT01";
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE;
        ;
        XPCL010(); /* error diagnosis routine*/
        ;
        return;
      end
    end
  end
end // end KL0V893

// fetch unique from clprec
Function KL0V894()
   /* **************************************/
   /* select unique on clprec*/
   /* **************************************/
  ;
  set SQLCA empty;
  CLPREC.IV0IVCID = 0;
  CLPREC.IV0PARTN = "0";
  call "IO1350" ("S ", SQLCA, CLPREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        ;
        TA1REC.TA1LOCAT[2] = "CL0V894"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO1350"; /* location*/
        TA1REC.TA1DBASE = "DCLAIM"; /* database name*/
        TA1REC.TA1TBLVU = "VDEFIT01"; /* table view name*/
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* table key*/
        ;
        XPCL010(); /* error diagnosis routine*/
      end
    end
  end
end // end KL0V894

// fetch unique from clprec
Function KL0V895()
   /* **************************************/
   /* select unique on clprec*/
   /* **************************************/
  ;
  set SQLCA empty;
  CLPREC.IV0IVCID = 0;
  CLPREC.IV0PARTN = "0";
  call "IO1350" ("D ", SQLCA, CLPREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        ;
        TA1REC.TA1LOCAT[2] = "CL0V895"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO1350"; /* location*/
        TA1REC.TA1DBASE = "DCLAIM"; /* database name*/
        TA1REC.TA1TBLVU = "VDEFIT01"; /* table view name*/
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* table key*/
        ;
        XPCL010(); /* error diagnosis routine*/
      end
    end
  end
end // end KL0V895

// add record to clprec
Function KL0V896()
   /* **************************************/
   /* add record to clprec*/
   /* **************************************/
  ;
  set SQLCA empty;
  CLPREC.IV0IVCID = 0;
  CLPREC.IV0PARTN = "0";
  call "IO1350" ("A ", SQLCA, CLPREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      ;
      TA1REC.TA1LOCAT[2] = "CL0V896"; /* location*/
      TA1REC.TA1LOCAT[4] = "IO1350"; /* location*/
      TA1REC.TA1DBASE = "DCLAIM"; /* database name*/
      TA1REC.TA1TBLVU = "VDEFIT01"; /* table view name*/
      CLXREC.XXXWDTE = CLAREC.CLACLMNB;
      TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* table key*/
      ;
      XPCL010(); /* error diagnosis routine*/
    end
  end
end // end KL0V896

// sum records from clprec
Function KL0V897()
   /* **************************************/
   /* update unique on clprec*/
   /* **************************************/
  ;
  set SQLCA empty;
  CLPREC.IV0IVCID = 0;
  CLPREC.IV0PARTN = "0";
  call "IO1350" ("U ", SQLCA, CLPREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        ;
        TA1REC.TA1LOCAT[2] = "CL0V897"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO1350"; /* location*/
        TA1REC.TA1DBASE = "DCLAIM"; /* database name*/
        TA1REC.TA1TBLVU = "VDEFIT01"; /* table view name*/
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* table key*/
        ;
        XPCL010(); /* error diagnosis routine*/
      end
    end
  end
end // end KL0V897

// sum records from clprec
Function KL0V898()
   /* **************************************/
   /* select unique on clprec*/
   /* **************************************/
  ;
  set SQLCA empty;
  CL0VW04.CL0VWSQL = "SM"; /* select sumed values*/
  call "IO1350" (CL0VW04, SQLCA, CLPREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    ;
     /* if no rows exist then the value returned is null and*/
     /* not useable. it has to be replaced with zero.*/
    ;
    if (CL0VW04.CL0VWIN1 < 0)
      CL0VW04.CLOTDFQY = 0;
    end
    if (CL0VW04.CL0VWIN2 < 0)
      CL0VW04.CLMTNCRQ = 0;
    end
    if (CL0VW04.CL0VWIN3 < 0)
      CL0VW04.CLOTRCQY = 0;
    end
    if (CL0VW04.CL0VWIN4 < 0)
      CL0VW04.CL0VWAMT = 0;
    end
    ;
     /* calculate values for total defective quantity and noncredit*/
     /* nonreturn quantity*/
    ;
    CL0VW04.CL0VWTDQ = CL0VW04.CLOTDFQY + CL0VW04.CLMTNCRQ;
                                   /* total def qty*/
    CL0VW04.CL0VWTNQ = CL0VW04.CLMTNCRQ - CL0VW04.CLOTRCQY;
                                   /* noncrd-nonrtn*/
    ;
  else
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
        CL0VW04.CLOTDFQY = 0;
        CL0VW04.CLMTNCRQ = 0;
        CL0VW04.CLOTRCQY = 0;
        CL0VW04.CL0VWAMT = 0;
        CL0VW04.CL0VWTDQ = 0;
        CL0VW04.CL0VWTNQ = 0;
      else
        ;
        TA1REC.TA1LOCAT[2] = "CL0V898"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO1350"; /* location*/
        TA1REC.TA1DBASE = "DCLAIM"; /* database name*/
        TA1REC.TA1TBLVU = "VDEFIT01"; /* table view name*/
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* table key*/
        ;
        XPCL010(); /* error diagnosis routine*/
      end
    end
  end
end // end KL0V898

// fetch unique from pd1rec
Function KL0V904()
   /* **************************************/
   /* select unique on fy1rec*/
   /* **************************************/
  ;
    /* Maintenance History:*/
    /* 02-22-90 CHELLM Renamed PD1.. items as FY1.. items.*/
             /* Replaced DWPROD.VFCTY001 with DFCTY.VFCTY001.*/
             /* Replaced IO0870 with IO2810.*/
  ;
  ;
  ;
  set SQLCA empty;
  call "IO2810" ("S ", SQLCA, FY1REC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        ;
        TA1REC.TA1LOCAT[2] = "CL0V904"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO2810"; /* location*/
        TA1REC.TA1DBASE = "DFCTY"; /* database name*/
        TA1REC.TA1TBLVU = "VFCTY001"; /* table view name*/
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* table key*/
        ;
        XPCL010(); /* error diagnosis routine*/
      end
    end
  end
end // end KL0V904

// select set from pc6rec
Function KL0V914()
   /* **************************************/
   /* select set on pc6rec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO3310" (CL0VW07, SQLCA, PC6REC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
        CL0VW01.CLPVLDFL = "N";
      else
        ;
        TA1REC.TA1LOCAT[2] = "CL0V914"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO3310"; /* location*/
        TA1REC.TA1DBASE = "DPRODC"; /* database name*/
        TA1REC.TA1TBLVU = "VPOITM01"; /* table view name*/
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* table key*/
        ;
        XPCL010(); /* error diagnosis routine*/
      end
    end
  end
   /* **************************************/
   /* select next on pd2rec*/
   /* **************************************/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    set SQLCA empty;
    call "IO3310" ("N3", SQLCA, PC6REC) {isNoRefresh = yes, isExternal = yes};
    ;
    if (SQLCA.VAGen_SQLCODE != 0)
      ;
      if (SQLCA.VAGen_SQLCODE == -911)
        converseLib.validationFailed(4); /* database is busy*/
        CLXREC.CLXERRF = "Y";
      else
        if (SQLCA.VAGen_SQLCODE == 100)
          CL0VW01.CLPVLDFL = "N";
        else
          ;
          TA1REC.TA1LOCAT[2] = "CL0V914"; /* location*/
          TA1REC.TA1LOCAT[4] = "IO3310"; /* location*/
          TA1REC.TA1DBASE = "DPRODC"; /* database name*/
          TA1REC.TA1TBLVU = "VPOITM01"; /* table view name*/
          CLXREC.XXXWDTE = CLAREC.CLACLMNB;
          TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* table key*/
          ;
          XPCL010(); /* error diagnosis routine*/
        end
      end
    else
      CL0VW01.CLPVLDFL = "Y";
    end
  end
  ;
  set SQLCA empty;
  call "IO3310" ("C3", SQLCA, PC6REC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        ;
        TA1REC.TA1LOCAT[2] = "CL0V914"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO3310"; /* location*/
        TA1REC.TA1DBASE = "DPRODC"; /* database name*/
        TA1REC.TA1TBLVU = "VPOITM01"; /* table view name*/
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* table key*/
        ;
        XPCL010(); /* error diagnosis routine*/
      end
    end
  end
end // end KL0V914

// fetch unique from sy1rec
Function KL0V924()
   /* **************************************/
   /* select unique on sy1rec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO0120" ("S ", SQLCA, SY1REC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        ;
        TA1REC.TA1LOCAT[2] = "CL0V924"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO0120"; /* location*/
        TA1REC.TA1DBASE = "DPROD "; /* database name*/
        TA1REC.TA1TBLVU = "VSTYLE01"; /* table view name*/
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* table key*/
        ;
        XPCL010(); /* error diagnosis routine*/
      end
    end
  end
end // end KL0V924

// fetch unique from sy2rec
Function KL0V934()
   /* **************************************/
   /* select unique on sy2rec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO0130" ("S ", SQLCA, SY2REC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        ;
        TA1REC.TA1LOCAT[2] = "CL0V934"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO0130"; /* location*/
        TA1REC.TA1DBASE = "DPROD "; /* database name*/
        TA1REC.TA1TBLVU = "VCOLOR01"; /* table view name*/
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* table key*/
        ;
        XPCL010(); /* error diagnosis routine*/
      end
    end
  end
end // end KL0V934

// fetch unique from sy5rec
Function KL0V944()
   /* **************************************/
   /* select unique on sy5rec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO0380" ("S ", SQLCA, SY5REC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        ;
        TA1REC.TA1LOCAT[2] = "CL0V944"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO0380"; /* location*/
        TA1REC.TA1DBASE = "DPROD "; /* database name*/
        TA1REC.TA1TBLVU = "VPRICE01"; /* table view name*/
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* table key*/
        ;
        XPCL010(); /* error diagnosis routine*/
      end
    end
  end
end // end KL0V944

// fetch unique from sy6rec
Function KL0V954()
   /* **************************************/
   /* select unique on sy6rec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO0360" ("S ", SQLCA, SY6REC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        ;
        TA1REC.TA1LOCAT[2] = "CL0V954"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO0360"; /* location*/
        TA1REC.TA1DBASE = "DPROD "; /* database name*/
        TA1REC.TA1TBLVU = "VDCOST01"; /* table view name*/
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* table key*/
        ;
        XPCL010(); /* error diagnosis routine*/
      end
    end
  end
end // end KL0V954

// select set from clgrec
Function KL0V961()
   /* **************************************/
   /* select set from clgrec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO1260" ("SS", SQLCA, CLGREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        TA1REC.TA1LOCAT[2] = "CL0V961"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO1260";
        TA1REC.TA1DBASE = "DCLAIM  ";
        TA1REC.TA1TBLVU = "VCLCOM01";
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE;
        ;
        XPCL010(); /* error diagnosis routine*/
        ;
        return;
      end
    end
  end
end // end KL0V961

// fetch next from clgrec
Function KL0V962()
   /* **************************************/
   /* fetch next from clgrec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO1260" ("SN", SQLCA, CLGREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        TA1REC.TA1LOCAT[2] = "CL0V962"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO1260";
        TA1REC.TA1DBASE = "DCLAIM  ";
        TA1REC.TA1TBLVU = "VCLCOM01";
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE;
        ;
        XPCL010(); /* error diagnosis routine*/
        ;
        return;
      end
    end
  end
end // end KL0V962

// close cursor for clgrec
Function KL0V963()
   /* **************************************/
   /* fetch next from clgrec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO1260" ("CS", SQLCA, CLGREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        TA1REC.TA1LOCAT[2] = "CL0V963"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO1260";
        TA1REC.TA1DBASE = "DCLAIM  ";
        TA1REC.TA1TBLVU = "VCLCOM01";
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE;
        ;
        XPCL010(); /* error diagnosis routine*/
        ;
        return;
      end
    end
  end
end // end KL0V963

// fetch unique from clgrec
Function KL0V964()
   /* **************************************/
   /* select unique on clgrec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO1260" ("S ", SQLCA, CLGREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        ;
        TA1REC.TA1LOCAT[2] = "CL0V964"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO1260"; /* location*/
        TA1REC.TA1DBASE = "DCLAIM"; /* database name*/
        TA1REC.TA1TBLVU = "VCLCOM01"; /* table view name*/
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* table key*/
        ;
        XPCL010(); /* error diagnosis routine*/
      end
    end
  end
end // end KL0V964

// fetch unique from clgrec
Function KL0V965()
   /* **************************************/
   /* select unique on clgrec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO1260" ("D ", SQLCA, CLGREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        ;
        TA1REC.TA1LOCAT[2] = "CL0V965"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO1260"; /* location*/
        TA1REC.TA1DBASE = "DCLAIM"; /* database name*/
        TA1REC.TA1TBLVU = "VCLCOM01"; /* table view name*/
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* table key*/
        ;
        XPCL010(); /* error diagnosis routine*/
      end
    end
  end
end // end KL0V965

// add record to clgrec
Function KL0V966()
   /* **************************************/
   /* add record to clgrec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO1260" ("A ", SQLCA, CLGREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      ;
      TA1REC.TA1LOCAT[2] = "CL0V966"; /* location*/
      TA1REC.TA1LOCAT[4] = "IO1260"; /* location*/
      TA1REC.TA1DBASE = "DCLAIM"; /* database name*/
      TA1REC.TA1TBLVU = "VDEFIT01"; /* table view name*/
      CLXREC.XXXWDTE = CLAREC.CLACLMNB;
      TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* table key*/
      ;
      XPCL010(); /* error diagnosis routine*/
    end
  end
end // end KL0V966

// update unique from clgrec
Function KL0V967()
   /* **************************************/
   /* update unique on clgrec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO1260" ("U ", SQLCA, CLGREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        ;
        TA1REC.TA1LOCAT[2] = "CL0V967"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO1260"; /* location*/
        TA1REC.TA1DBASE = "DCLAIM"; /* database name*/
        TA1REC.TA1TBLVU = "VCLCOM01"; /* table view name*/
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* table key*/
        ;
        XPCL010(); /* error diagnosis routine*/
      end
    end
  end
end // end KL0V967

// sum records from clirec
Function KL0V978()
   /* **************************************/
   /* sum records on clirec*/
   /* **************************************/
  ;
  set SQLCA empty;
  CL0VW05.CL0VWSQL = "SM";
  call "IO1300" (CL0VW05, SQLCA, CLIREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    if (CL0VW05.CL0VWIN1 <= 0)
      CL0VW05.CL0VWGLA = 0;
    end
    ;
  else
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
        CL0VW05.CL0VWGLA = 0;
      else
        ;
        TA1REC.TA1LOCAT[2] = "CL0V978"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO1300"; /* location*/
        TA1REC.TA1DBASE = "DCLAIM"; /* database name*/
        TA1REC.TA1TBLVU = "VCLGLX01"; /* table view name*/
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* table key*/
        ;
        XPCL010(); /* error diagnosis routine*/
      end
    end
  end
end // end KL0V978

// select unique from clhrec
Function KL0V984()
   /* **************************************/
   /* select unique on clhrec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO1290" ("SA", SQLCA, CLHREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        ;
        TA1REC.TA1LOCAT[2] = "CL0V984"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO1290"; /* location*/
        TA1REC.TA1DBASE = "DCLAIM"; /* database name*/
        TA1REC.TA1TBLVU = "VCLMEM01"; /* table view name*/
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* table key*/
        ;
        XPCL010(); /* error diagnosis routine*/
      end
    end
  end
end // end KL0V984

// fetch unique from cl2rec
Function KL0V994()
   /* **************************************/
   /* select unique on cl2rec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO2870" ("S ", SQLCA, CL2REC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        ;
        TA1REC.TA1LOCAT[2] = "CL0V994"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO2870"; /* location*/
        TA1REC.TA1DBASE = "DCLAIM"; /* database name*/
        TA1REC.TA1TBLVU = "VRINSP01"; /* table view name*/
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* table key*/
        ;
        XPCL010(); /* error diagnosis routine*/
      end
    end
  end
end // end KL0V994

// add record to cl2rec
Function KL0V996()
   /* **************************************/
   /* add record to cl2rec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO2870" ("A ", SQLCA, CL2REC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      ;
      TA1REC.TA1LOCAT[2] = "CL0V996"; /* location*/
      TA1REC.TA1LOCAT[4] = "IO2870"; /* location*/
      TA1REC.TA1DBASE = "DCLAIM"; /* database name*/
      TA1REC.TA1TBLVU = "VRINSP01"; /* table view name*/
      CLXREC.XXXWDTE = CLAREC.CLACLMNB;
      TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* table key*/
      ;
      XPCL010(); /* error diagnosis routine*/
    end
  end
end // end KL0V996

// update unique from cl2rec
Function KL0V997()
   /* **************************************/
   /* update unique on cl2rec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO2870" ("U ", SQLCA, CL2REC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        ;
        TA1REC.TA1LOCAT[2] = "CL0V997"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO2870"; /* location*/
        TA1REC.TA1DBASE = "DCLAIM"; /* database name*/
        TA1REC.TA1TBLVU = "VRINSP01"; /* table view name*/
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* table key*/
        ;
        XPCL010(); /* error diagnosis routine*/
      end
    end
  end
end // end KL0V997

// pf 7 action
Function KL0VS07()
   /* ************************************************************/
   /* *    this process handles the entry of pf key 7           **/
   /* *             (paging backward)                           **/
   /* *                                                         **/
   /* *    clxarayx is used to read through the cl0vw02 record. **/
   /* *    clxmapmx indicated the number of lines painted on    **/
   /* *    the map.                                             **/
   /* *    the idea is to always paint the map and then         **/
   /* *    subtract the number of lines painted on the map from **/
   /* *    the clxarayx. (this is so the array always starts    **/
   /* *    from the beginning.)                                 **/
   /* *                                                         **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  ;
  CLXREC.CLXCPROC = "CL0VS07";
  ;
  ;
  CLXREC.CLXARAYX = CLXREC.CLXARAYX - CLXREC.CLXMAPMX;
  CLXREC.CLXARAYX = CLXREC.CLXARAYX - 9; /* the first line on the map - 9*/
  ;
  if (CLXREC.CLXARAYX <= 0)
    ;
     /* if we have reached the first record on database*/
    ;
    if (CL0VW01.CL0VWHST == CL0VW02.SY1STNBR[1]
     && CL0VW01.CL0VWHCL == CL0VW02.SY2CLRID[1]
     && CL0VW01.CL0VWHDM == CL0VW02.XDMCD[1])
      converseLib.validationFailed(7); /* top of data*/
      CLXREC.CLXARAYX = 1;
    else
      converseLib.validationFailed(10); /* can not scroll backwards.*/
      CLXREC.CLXARAYX = 1;
    end
  else
    /* next sentence*/
  end
  ;
  KL0VSFF(); /* set cl0vm005 empty and move cl0vw01*/
                                   /* to cl0vm005*/
  CLXREC.CLXMAPMX = 1;
  CLXREC.CLXCURLN = 1;
  ;
  while (CLXREC.CLXCURLN <= 10)
     /* AND CL0VW02.CLPDEFQ(CLXARAYX) GT 0;*/
    KL0VSFD(); /* move cl0vw02 to cl0vm005*/
  end
  ;
  ;
  ;
  ;
end // end KL0VS07

// pf 8 action
Function KL0VS08()
  ;
   /* ************************************************************/
   /* *   this process handles the entry of pf key 8            **/
   /* *           (paging forward)                              **/
   /* *                                                         **/
   /* *    clxarayx is used to read through the cl0vw02 record. **/
   /* *    clxmapmx indicated the number of lines painted on    **/
   /* *    the map.                                             **/
   /* *    the idea is to always paint the map and then         **/
   /* *    subtract the number of lines painted on the map from **/
   /* *    the clxarayx. (this is so the array always starts    **/
   /* *    from the beginning.)                                 **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  ;
  CLXREC.CLXCPROC = "CL0VS08";
  ;
  ;
  if (CLXREC.CLXARAYX > CLXREC.CLXLSTAX)
    converseLib.validationFailed(20);
    return;
  else
    /* next sentence*/
  end
  ;
  ;
  KL0VSFF(); /* set screen empty and move cl0vw01 to cl0vm005*/
  ;
  CLXREC.CLXMAPMX = 1;
  CLXREC.CLXCURLN = 1;
  ;
  while (CLXREC.CLXCURLN <= 10
   && CLXREC.CLXARAYX <= CL0VW01.CL0VWMX) /* less than or = 500*/
     /* AND CL0VW02.CLPDEFQ(CLXARAYX) GT 0;*/
    KL0VSFD(); /* move cl0vw02 to cl0vm005*/
  end
  ;
  ;
   /* must subtract the indexes by 1 because i*/
   /* read one further than nessary.*/
  ;
   /* CLXREC.CLXARAYX = CLXREC.CLXARAYX - 1;*/
   /* CLXREC.CLXMAPMX = CLXREC.CLXMAPMX - 1;*/
   /* CLXREC.CLXCURLN = CLXREC.CLXCURLN - 1;*/
  ;
  ;
  ;
  ;
  ;
end // end KL0VS08

// modify entered fields
Function KL0VS26()
   /* ************************************************************/
   /* *  since the map must be re-shown to the user             **/
   /* *  before editing has been done, set fields modified to   **/
   /* *  keep track of all the fields entered by the user.      **/
   /* *  the user will only need to re-do the pf key or enter   **/
   /* *  key, not enter the data again.                         **/
   /* ************************************************************/
  ;
  ;
    /* for every entry field on the map,*/
    /* do this:*/
  ;
    /* if map.field modified*/
      /* set map.field modified*/
    /* end*/
  ;
  ;
  if (KL0VM001.XWHCD is modified)
    set KL0VM001.XWHCD modified;
  end
  ;
  if (KL0VM001.XXXUSRID is modified)
    set KL0VM001.XXXUSRID modified;
  end
  ;
  if (KL0VM001.CL0VMIDT is modified)
    set KL0VM001.CL0VMIDT modified;
  end
  ;
  if (KL0VM001.SY1STNBR is modified)
    set KL0VM001.SY1STNBR modified;
  end
  ;
  if (KL0VM001.SY2CLRID is modified)
    set KL0VM001.SY2CLRID modified;
  end
  ;
  if (KL0VM001.XUMCD is modified)
    set KL0VM001.XUMCD modified;
  end
  ;
  if (KL0VM001.CLKCLPRC is modified)
    set KL0VM001.CLKCLPRC modified;
  end
  ;
  if (KL0VM001.FY1FCTYC is modified)
    set KL0VM001.FY1FCTYC modified;
  end
  ;
  if (KL0VM001.CL0VMFPO is modified)
    set KL0VM001.CL0VMFPO modified;
  end
  ;
  if (KL0VM001.YDDCD is modified)
    set KL0VM001.YDDCD modified;
  end
  ;
  if (KL0VM001.CLPCRTNB is modified)
    set KL0VM001.CLPCRTNB modified;
  end
  ;
  if (KL0VM001.YDFCD is modified)
    set KL0VM001.YDFCD modified;
  end
  ;
  if (KL0VM001.CL0VWDFQ is modified)
    set KL0VM001.CL0VWDFQ modified;
  end
  ;
  if (KL0VM001.CLPDEFQ is modified)
    set KL0VM001.CLPDEFQ modified;
  end
  ;
  if (KL0VM001.YDRCD is modified)
    set KL0VM001.YDRCD modified;
  end
  ;
  if (KL0VM001.CLPRTCTQ is modified)
    set KL0VM001.CLPRTCTQ modified;
  end
  ;
  if (KL0VM001.CL0VWNRQ is modified)
    set KL0VM001.CL0VWNRQ modified;
  end
  ;
  if (KL0VM001.CLGCOMNT is modified)
    set KL0VM001.CLGCOMNT modified;
  end
  ;
  ;
end // end KL0VS26

// get header info
Function KL0VSAA()
   /* ************************************************************/
   /* *  this is the execute process that will check to see if  **/
   /* *  the 3 header pieces of data exist.                     **/
   /* *         cljrec - return authorization                   **/
   /* *         cllrec - actural return                         **/
   /* *         clorec - defective header data.                 **/
   /* *                                                         **/
   /* *  the cl0vw01.cl0vwudf(update flag) is set to 'y' or 'n' **/
   /* *  for the entire program here.                           **/
   /* *   if all 3 pieces exists then the flag is set to 'y'    **/
   /* *   otherwise the flag is set to 'n'                      **/
   /* *                                                         **/
   /* *  the controller for which screen is presented to the    **/
   /* *  user is setup here.                                    **/
   /* *                                                         **/
   /* *  if add mode:            kl0vm001           kl0vm005    **/
   /* * (header does not exist)   x - header                    **/
   /* * (header does exist)       x - detail                    **/
   /* *                                                         **/
   /* *  if change mode:                                        **/
   /* * (header does not exist)   x - header                    **/
   /* * (header does exist)                          x - summary**/
   /* *                                                         **/
   /* *  if inquire mode:                            x -summary **/
   /* *                                                         **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0VSAA"; /* set current process name*/
  ;
  CL0VW01.CLACLMNB = CLAREC.CLACLMNB;
  CL0VW01.CLHSEQNB = CLWREC.CLHSEQNB;
  CL0VW01.XGPCD = CLAREC.XGPCD;
  CL0VW01.YCTCD = CLAREC.YCTCD;
  CL0VW01.KUCCONM = CLWREC.KUCCONM;
  CL0VW01.KUCCOID = CLAREC.KUCCOID;
  CL0VW01.KUMSTRID = CLAREC.KUMSTRID;
  CL0VW01.XNXCD = CLAREC.XNXCD;
  ;
  ;
  KL0VSAQ(); /* retrieve customer company record*/
  ;
  CL0VW01.CL0VWUDF = "N"; /* set update flag to no*/
  CL0VW01.CL0VWEHF = "N"; /* set end of header flag*/
  CL0VW01.CL0VWDEF = "N"; /* set end of detail flag*/
  ;
  ;
  ;
  set CLJREC empty;
  CLJREC.CLACLMNB = CL0VW01.CLACLMNB;
  KL0VSAB(); /* check return authorization*/
  ;
  set CLOREC empty;
  CLOREC.CLACLMNB = CL0VW01.CLACLMNB;
  CLOREC.CLHSEQNB = CL0VW01.CLHSEQNB;
  CLOREC.CL2ISNBR = CLAREC.CLACISNB;
  KL0VSAC(); /* check defective header exists*/
  ;
  set CLLREC empty;
  CLLREC.CLACLMNB = CL0VW01.CLACLMNB;
  CLLREC.CLLRTNNB = CLAREC.CLACRTNB;
  set CL2REC empty;
  CL2REC.CLACLMNB = CL0VW01.CLACLMNB;
  CL2REC.CL2ISNBR = CLAREC.CLACISNB;
  CL2REC.CLHSEQNB = CLAREC.CLACSQNB;
  ;
  KL0VSAG(); /* retrieve todays date*/
  ;
   /* IF CL0VM001.CL0VMIDT IS MODIFIED;*/
   /* IF CL0VM001.CL0VMIDT EQ ' ';*/
  CLXREC.XXXCDTE = TA2REC.TA2GRGGN;
   /* MOVE CLXREC.XXXCDTE TO CL0VW01.CL0VMIDT;*/
  CLXREC.XXXFLYY = CLXREC.XXXCYY;
  CLXREC.XXXFLMM = CLXREC.XXXCMM;
  CLXREC.XXXFLDD = CLXREC.XXXCDD;
  CLXREC.XXXSEP5 = "-";
  CLXREC.XXXSEP6 = "-";
   /* MOVE CLXREC.XXXCYMD TO CL0VW01.CL0VWYMD;*/
   /* MOVE CLXREC.XXXFLDT TO CL0VW01.CL0VMIDT;*/
   /* ELSE ;*/
  KL0VSAD(); /* check actual return and rtn insp*/
                                   /* exists*/
   /* END ;*/
   /* END ;*/
  ;
  ;
  if (CL0VW01.CL0VWLFL == "Y" /* actual return add flag*/
   || CL0VW01.CL0VWOFL == "Y" /* defective header add flag*/
   || CL0VW01.CL0VWJFL == "Y" /* return authorization add flag*/
   || CL0VW01.CL0VW2FL == "Y") /* return authorization add flag*/
    CL0VW01.CL0VWHDF = "N"; /* header is not complete flag*/
  else
    CL0VW01.CL0VWHDF = "Y";
  end
  ;
  ;
   /* check values to see if the detail can be updated.*/
  ;
  if (CLWREC.CLWACTIV == "I")
    CL0VW01.CL0VWUDF = "N"; /* set update flag to no*/
    CLXREC.CLXCSCRN = "KL0VM005";
  else
    if (CLWREC.CLHSEQNB == CLAREC.CLACSQNB)
      if (CL2REC.CL2ISXDT == CLXREC.XXXCDTE
       || CL2REC.CL2ISXDT == 0)
        if (CL0VW01.CL0VWHDF == "N")
          CLXREC.CLXCSCRN = "KL0VM001";
          CL0VW01.CL0VWUDF = "Y";
        else
          if (CLWREC.CLWACTIV == "C")
            CLXREC.CLXCSCRN = "KL0VM005"; /* update on summ screen*/
            CL0VW01.CL0VWUDF = "Y";
          else
            CLXREC.CLXCSCRN = "KL0VM001"; /* update on add screen*/
            CL0VW01.CL0VWUDF = "Y";
          end
        end
      else
        if (CLXREC.CLXERRF == "Y")
          /* next sentence*/
        else
          CL0VW01.CL0VWUDF = "N"; /* force user into inquire mode*/
          CLXREC.CLXCSCRN = "KL0VM005";
        end
      end
    else
      CLXREC.CLXCSCRN = "KL0VM005";
      CL0VW01.CL0VWUDF = "N";
    end
  end
  ;
  ;
  if (COMMAREA.CAFROMAP == "KL0W"
   || COMMAREA.CAFROMAP == "KL0J")
    CLXREC.CLXCSCRN = "KL0VM005";
  else
    /* next sentence*/
  end
  ;
  ;
   /* IF COMMAREA.CAALVL(7) ='Y'*/
   /* AND COMMAREA.CACLVL(7) ='Y'*/
   /* AND COMMAREA.CADLVL(7) ='Y'*/
   /* ;next sentence*/
   /* ELSE*/
      /* MOVE 'KL0VM005' TO CLXREC.CLXCSCRN;*/
      /* MOVE 'N' TO CL0VW01.CL0VWUDF;*/
    /* END ;*/
end // end KL0VSAA

// check return auth. exists.
Function KL0VSAB()
  ;
  CLXREC.CLXCPROC = "CL0VSAB";
  ;
  KL0V824(); /* select unique from cljrec*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    CL0VW01.CL0VWJFL = "N"; /* set actual return add flag to 'n'*/
    CL0VW01.CLJTATHQ = CLJREC.CLJTATHQ;
    CL0VW01.CLJNCRFL = CLJREC.CLJNCRFL;
    ;
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      CL0VW01.CL0VWJFL = "Y"; /* set actual return add flag to 'y'*/
      CL0VW01.CLJTATHQ = 0;
      CL0VW01.CLJNCRFL = " ";
    end
  end
  ;
  ;
  ;
end // end KL0VSAB

// check if defect. header exists
Function KL0VSAC()
  ;
  CLXREC.CLXCPROC = "CL0VSAC";
  ;
  KL0V834(); /* select unique from clorec*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    CL0VW01.CL0VWOFL = "N"; /* set actual return add flag to 'n'*/
    CL0VW01.CLOTLRID = CLOREC.CLOTLRID; /* trailer id*/
    CL0VW01.CLOFGAQ = CLOREC.CLOFGAQ; /* freight allowance quantity*/
    CL0VW01.CLOTDFQY = CLOREC.CLOTDFQY; /* total credit qty.*/
    CL0VW01.CLOFGAAM = CLOREC.CLOFGAAM; /* freight all. amount*/
    CL0VW01.CLODMAMT = CLOREC.CLODMAMT; /* merchandize amount.*/
    CL0VW01.CL0VWAAM = CLOREC.CLOFGAAM; /* freight all. amount*/
    CL0VW01.CL0VWAMT = CLOREC.CLODMAMT; /* merchandize amount.*/
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      CL0VW01.CL0VWOFL = "Y"; /* set defective header add flag to 'y'*/
      CL0VW01.CLOTLRID = " "; /* trailer id*/
      CL0VW01.CLOFGAQ = 0; /* freight allowance quantity*/
      CL0VW01.CLOFGAAM = 0; /* freight all. amount*/
    end
  end
  ;
  ;
  ;
end // end KL0VSAC

// check actual return
Function KL0VSAD()
  ;
  ;
  ;
  KL0V844(); /* select unique from cllrec*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    CL0VW01.CL0VWLFL = "N"; /* set actual return add flag to 'n'*/
    CL0VW01.XWHCD = CLLREC.XWHCD;
    if (CL0VW01.XWHCD in XWHTBL.XWHCD)
      CL0VW01.XWHABRV = XWHTBL.XWHABRV[sysVar.arrayIndex];
    end
    ;
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      CL0VW01.CL0VWLFL = "Y"; /* set return auth. add flag to 'y'*/
      CL0VW01.CL0VMICF = "N";
    end
  end
  ;
  ;
  KL0V994(); /* select unique from cl2rec*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    CL0VW01.CL0VW2FL = "N"; /* set return insp add flag to 'n'*/
    CL0VW01.XXXUSRID = CL2REC.XXXUSRID;
    CLXREC.XXXWDTE = CL2REC.CL2ISBDT;
    CL0VW01.CL2ISBDT = CL2REC.CL2ISBDT;
    CLXREC.XXXFLMM = CLXREC.XXXWMM; /* format long month*/
    CLXREC.XXXFLDD = CLXREC.XXXWDD; /* format long month*/
    CLXREC.XXXFLYY = CLXREC.XXXWYY; /* format long month*/
    CLXREC.XXXSEP5 = "-";
    CLXREC.XXXSEP6 = "-";
   /* TCS CHANGES BEGIN 12/30/99*/
   /* MOVE CLXREC.XXXCYMD TO CL0VW01.CL0VWYMD;*/
    CL0VW01.CL0VWYMD = CLXREC.XXXCDTE;
   /* TCS CHANGES END   12/30/99*/
    KL0VM001.CL0VMIDT = CLXREC.XXXFLDT;
    KL0VM005.CL0VMIDT = CLXREC.XXXFLDT;
    CL0VW01.CL0VMIDT = CLXREC.XXXFLDT;
    /* MOVE CL2REC.CL2ISXDT TO CL0VW01.CL2ISXDT;*/
    ;
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      CL0VW01.CL0VW2FL = "Y"; /* set return insp. add flag to 'y'*/
      CL0VW01.CL0VMICF = "N";
      CL0VW01.CL2ISBDT = CLXREC.XXXCDTE;
      CLXREC.XXXFLMM = CLXREC.XXXCMM; /* format long month*/
      CLXREC.XXXSEP5 = "-";
      CLXREC.XXXFLDD = CLXREC.XXXCDD; /* format long day*/
      CLXREC.XXXSEP6 = "-";
      CLXREC.XXXFLYY = CLXREC.XXXCYY; /* format long year*/
   /* TCS CHANGES BEGIN 12/30/99*/
     /* MOVE CLXREC.XXXCYMD TO CL0VW01.CL0VWYMD;*/
      CL0VW01.CL0VWYMD = CLXREC.XXXCDTE;
   /* TCS CHANGES END   12/30/99*/
      /* MOVE CLXREC.XXXFLDT TO CL0VM001.CL0VMIDT;*/
      /* MOVE CLXREC.XXXFLDT TO CL0VM005.CL0VMIDT;*/
    end
  end
  ;
  ;
end // end KL0VSAD

// get todays date
Function KL0VSAG()
  ;
  CLXREC.CLXCPROC = "CL0VSAG";
  ;
  set TA2REC empty;
  TA2REC.TA2DTOPT = "GETDATE";
  call "TA0040" (TA2REC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (TA2REC.TA2RTNCD != 0)
    CLXREC.CLXVALDT = "N"; /* set valid date flag to no*/
    XPCL010();
  else
    CLXREC.CLXVALDT = "Y"; /* set valid date flag to yes*/
  end
  ;
  ;
  ;
end // end KL0VSAG

// move cl0vm001 to cl0vm005,m010
Function KL0VSAH()
  ;
  ;
  set KL0VM001 initial;
  ;
  KL0VM001.CLACLMNB = CL0VW01.CLACLMNB;
  KL0VM001.CLHSEQNB = CL0VW01.CLHSEQNB;
  KL0VM001.KUCCONM = CL0VW01.KUCCONM;
  KL0VM001.KUCCOID = CL0VW01.KUCCOID;
  KL0VM001.KUMSTRID = CL0VW01.KUMSTRID;
  KL0VM001.CLJTATHQ = CL0VW01.CLJTATHQ;
  KL0VM001.CLODMAMT = CL0VW01.CLODMAMT;
  KL0VM001.CLJNCRFL = CL0VW01.CLJNCRFL;
  KL0VM001.CLOFGAQ = CL0VW01.CLOFGAQ;
  KL0VM001.CLOFGAAM = CL0VW01.CLOFGAAM;
  KL0VM001.XXXUSRID = CL0VW01.XXXUSRID;
  KL0VM001.CL0VMIDT = CL0VW01.CL0VMIDT;
  KL0VM001.XNXCD = CL0VW01.XNXCD;
  KL0VM001.XGPCD = CL0VW01.XGPCD;
  KL0VM001.YCTCD = CL0VW01.YCTCD;
  KL0VM001.XWHCD = CL0VW01.XWHCD;
  KL0VM001.XWHABRV = CL0VW01.XWHABRV;
  KL0VM001.CLOTLRID = CL0VW01.CLOTLRID;
  KL0VM001.CL2ISXDT = CL0VW01.CL2ISXDT;
  ;
  set KL0VM005 initial;
  ;
  KL0VM005.CLACLMNB = CL0VW01.CLACLMNB;
  KL0VM005.CLHSEQNB = CL0VW01.CLHSEQNB;
  KL0VM005.KUCCONM = CL0VW01.KUCCONM;
  KL0VM005.KUCCOID = CL0VW01.KUCCOID;
  KL0VM005.KUMSTRID = CL0VW01.KUMSTRID;
  KL0VM005.CLODMAMT = CL0VW01.CLODMAMT;
  KL0VM005.CLJTATHQ = CL0VW01.CLJTATHQ;
  KL0VM005.CLJNCRFL = CL0VW01.CLJNCRFL;
  KL0VM005.CLOFGAQ = CL0VW01.CLOFGAQ;
  KL0VM005.CLOFGAAM = CL0VW01.CLOFGAAM;
  KL0VM005.XXXUSRID = CL0VW01.XXXUSRID;
  KL0VM005.CL0VMIDT = CL0VW01.CL0VMIDT;
  KL0VM005.XNXCD = CL0VW01.XNXCD;
  KL0VM005.XGPCD = CL0VW01.XGPCD;
  KL0VM005.YCTCD = CL0VW01.YCTCD;
  KL0VM005.XWHCD = CL0VW01.XWHCD;
  KL0VM005.XWHABRV = CL0VW01.XWHABRV;
  KL0VM005.CLOTLRID = CL0VW01.CLOTLRID;
  KL0VM005.CL2ISXDT = CL0VW01.CL2ISXDT;
end // end KL0VSAH

// set all rec. and maps empty
Function KL0VSAK()
   /* **************************** CL0VSAK ************************/
  ;
    /* Maintenance History:*/
    /* 02-22-90 CHELLM Renamed PD1.. items as FY1.. items.*/
    /* 06-14-90 CHELLM replaced pd2rec with pc3rec.*/
  ;
  ;
  CLXREC.CLXCPROC = "CL0VSAK";
  ;
  set KL0VM001 initial;
  set KL0VM005 initial;
  set CLAREC empty;
  set CLXREC empty;
  set CLWREC empty;
  set CL0VW01 empty;
  set CLLREC empty;
  set CLOREC empty;
  set CLPREC empty;
  CLPREC.IV0PARTN = "0";
  set CLJREC empty;
  set CLGREC empty;
  set CLSREC empty;
  set CL2REC empty;
  set KUYREC empty;
  set KUCREC empty;
  set CLFREC empty;
  set IV5REC empty;
  set IVEREC empty;
  set FY1REC empty;
  set PC6REC empty;
  set SY1REC empty;
  set SY2REC empty;
  set SY5REC empty;
  set SY6REC empty;
  set SYCREC empty;
  set SQLCA empty;
  set ERRSQLCA empty;
  set TA1REC empty;
  set TA2REC empty;
end // end KL0VSAK

// set all fields to autoskip
Function KL0VSAL()
   /* ************************************************************/
   /* *  protect all the screen fields if update not allowed.   **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0VSAL"; /* set current process name*/
  ;
  set KL0VM001.CLJNCRFL skip;
  set KL0VM001.XXXUSRID skip;
  set KL0VM001.CL0VMIDT skip;
  set KL0VM001.XWHCD skip;
  set KL0VM001.SY1STNBR skip, invisible;
  set KL0VM001.SY2CLRID skip, invisible;
  set KL0VM001.XDMCD skip, invisible;
  set KL0VM001.XUMCD skip, invisible;
  set KL0VM001.CL0VMFPO skip, invisible;
  set KL0VM001.FY1FCTYC skip, invisible;
  set KL0VM001.YDDCD skip, invisible;
  set KL0VM001.CLPCRTNB skip, invisible;
  set KL0VM001.YDFCD skip, invisible;
  set KL0VM001.CL0VWDFQ skip, invisible;
  set KL0VM001.CLPDEFQ skip, invisible;
  set KL0VM001.YDRCD skip, invisible;
  set KL0VM001.CLPRTCTQ skip, invisible;
  set KL0VM001.CL0VWNRQ skip, invisible;
  set KL0VM001.CLKCLPRC skip, invisible;
  set KL0VM001.CLGCOMNT skip, invisible;
  set KL0VM001.CL0VMICF skip, invisible;
  ;
  ;
  ;
end // end KL0VSAL

// set all detail fields autoskip
Function KL0VSAM()
   /* ************************************************************/
   /* *   set the detail fields to dark and autoskip. only      **/
   /* *   header information will be worked on.                 **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0VSAM"; /* set current process name*/
  ;
  set KL0VM001.XXXUSRID cursor;
  set KL0VM001.SY1STNBR skip, invisible;
  set KL0VM001.SY2CLRID skip, invisible;
  set KL0VM001.XDMCD skip, invisible;
  set KL0VM001.XUMCD skip, invisible;
  set KL0VM001.CL0VMFPO skip, invisible;
  set KL0VM001.FY1FCTYC skip, invisible;
  set KL0VM001.YDDCD skip, invisible;
  set KL0VM001.CLPCRTNB skip, invisible;
  set KL0VM001.YDFCD skip, invisible;
  set KL0VM001.CL0VWDFQ skip, invisible;
  set KL0VM001.CLPDEFQ skip, invisible;
  set KL0VM001.YDRCD skip, invisible;
  set KL0VM001.CLPRTCTQ skip, invisible;
  set KL0VM001.CL0VWNRQ skip, invisible;
  set KL0VM001.CLKCLPRC skip, invisible;
  set KL0VM001.CLGCOMNT skip, invisible;
  set KL0VM001.CL0VMICF skip, invisible;
  ;
  ;
end // end KL0VSAM

// move cl0vm001 to cl0vw01
Function KL0VSAN()
  ;
  ;
  CLXREC.CLXCPROC = "CL0VSAN";
  ;
  ;
  CL0VW01.CLACLMNB = KL0VM001.CLACLMNB;
  CL0VW01.CLHSEQNB = KL0VM001.CLHSEQNB;
  CL0VW01.KUCCONM = KL0VM001.KUCCONM;
  CL0VW01.KUCCOID = KL0VM001.KUCCOID;
  CL0VW01.KUMSTRID = KL0VM001.KUMSTRID;
  CL0VW01.XNXCD = KL0VM001.XNXCD;
  CL0VW01.XGPCD = KL0VM001.XGPCD;
  CL0VW01.CLJTATHQ = KL0VM001.CLJTATHQ;
  CL0VW01.CLODMAMT = KL0VM001.CLODMAMT;
  CL0VW01.CLJNCRFL = KL0VM001.CLJNCRFL;
  CL0VW01.CLOFGAQ = KL0VM001.CLOFGAQ;
  CL0VW01.CLOFGAAM = KL0VM001.CLOFGAAM;
  CL0VW01.CLOTLRID = KL0VM001.CLOTLRID;
  CL0VW01.XXXUSRID = KL0VM001.XXXUSRID;
  CL0VW01.CL0VMIDT = KL0VM001.CL0VMIDT;
  CL0VW01.XWHCD = KL0VM001.XWHCD;
  CL0VW01.XWHABRV = KL0VM001.XWHABRV;
  ;
  if (CLXREC.CLXERRF != "Y")
    set KL0VM001 initial;
  end
  ;
  KL0VM001.CLACLMNB = CL0VW01.CLACLMNB;
  KL0VM001.CLHSEQNB = CL0VW01.CLHSEQNB;
  KL0VM001.KUCCONM = CL0VW01.KUCCONM;
  KL0VM001.KUCCOID = CL0VW01.KUCCOID;
  KL0VM001.KUMSTRID = CL0VW01.KUMSTRID;
  KL0VM001.XNXCD = CL0VW01.XNXCD;
  KL0VM001.XGPCD = CL0VW01.XGPCD;
  KL0VM001.CLJTATHQ = CL0VW01.CLJTATHQ;
  KL0VM001.CLJNCRFL = CL0VW01.CLJNCRFL;
  KL0VM001.CLODMAMT = CL0VW01.CLODMAMT;
  KL0VM001.CLOFGAQ = CL0VW01.CLOFGAQ;
  KL0VM001.CLOFGAAM = CL0VW01.CLOFGAAM;
  KL0VM001.CLOTLRID = CL0VW01.CLOTLRID;
  KL0VM001.XXXUSRID = CL0VW01.XXXUSRID;
  KL0VM001.CL0VMIDT = CL0VW01.CL0VMIDT;
  KL0VM001.XWHCD = CL0VW01.XWHCD;
  KL0VM001.XWHABRV = CL0VW01.XWHABRV;
  ;
end // end KL0VSAN

// set all field autoskip
Function KL0VSAP()
  ;
   /* ************************************************************/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0VSAP"; /* set current process name*/
  ;
  set KL0VM001.CLJNCRFL skip;
  set KL0VM001.XXXUSRID skip;
  set KL0VM001.CL0VMIDT skip;
  set KL0VM001.XWHCD skip;
  set KL0VM001.SY1STNBR skip;
  set KL0VM001.SY2CLRID skip;
  set KL0VM001.XDMCD skip;
  set KL0VM001.XUMCD skip;
  set KL0VM001.CL0VMFPO skip;
  set KL0VM001.FY1FCTYC skip;
  set KL0VM001.YDDCD skip;
  set KL0VM001.CLPCRTNB skip;
  set KL0VM001.YDFCD skip;
  set KL0VM001.CL0VWDFQ skip;
  set KL0VM001.CLPDEFQ skip;
  set KL0VM001.YDRCD skip;
  set KL0VM001.CLPRTCTQ skip;
  set KL0VM001.CL0VWNRQ skip;
  set KL0VM001.CLKCLPRC skip;
  set KL0VM001.CLGCOMNT skip;
  set KL0VM001.CL0VMICF skip;
  ;
  ;
  ;
end // end KL0VSAP

// retrieve customer company rec.
Function KL0VSAQ()
  ;
  ;
     /* **************************************************/
     /* read customer company vcmpny01,*/
     /* to get cu-cusku-ind.  this tells us there*/
     /* may be customer product id's for the nike prod id*/
     /* **************************************************/
  ;
  KUCREC.KUCCOID = CLAREC.KUCCOID;
  ;
  KL0V864(); /* read company record*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
     /* next sentence               ; have company*/
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      KUCREC.KUCSKIND = " "; /* no company = no sku*/
      KUCREC.XAUCD = " "; /* no company = no acct class*/
    end
  end
  ;
  ;
     /* ****************************************************/
     /* find company account type code, for product pricing*/
     /* ****************************************************/
  ;
  CL0VW01.XATCD = " ";
  if (KUCREC.XAUCD in XAUTBL.XAUCD)
    CL0VW01.XATCD = XAUTBL.XATCD[sysVar.arrayIndex];
  end
  ;
     /* ********************************************************/
     /* read invoice speciality table to get:*/
       /* price/cost indicator - use product price or cost?*/
       /* price/cost type - either xpycd or xcocd*/
       /* price/cost pct - signed percent field to add to 100%*/
                        /* to make a multiplier for the std*/
                        /* price/cost value.*/
     /* table record may have blanks in order type or acct class,*/
     /* so the order of reading is:*/
     /* 1. read for acct type, acct class & order type*/
        /* if not found,*/
     /* 2. read for acct type, acct class & blank o/t*/
        /* if not found,*/
     /* 3. read for acct type, blank acct class & blank o/t*/
        /* if not found,*/
          /* zero price/cost indicator, so clngrprc is 0.*/
     /* ********************************************************/
  ;
     /* data from the company*/
  ;
  IVEREC.XATCD = CL0VW01.XATCD; /* account type*/
  IVEREC.XAUCD = KUCREC.XAUCD; /* account class*/
  IVEREC.XOTCD = CLAREC.XOTCD; /* order type*/
  ;
  KL0V874(); /* select unique from iverec*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
     /* next sentence, matched all 3 codes*/
  else
    IVEREC.XOTCD = " ";
    KL0V874();
    if (SQLCA.VAGen_SQLCODE == 0)
       /* next sentence, matched 2 codes*/
    else
      IVEREC.XAUCD = " ";
      KL0V874();
      if (SQLCA.VAGen_SQLCODE == 0)
         /* next sentence, matched 1 code*/
      else
        IVEREC.IVEPCIND = " "; /* no match at all*/
        IVEREC.IVEPCTYP = " ";
        IVEREC.IVEPCPCT = 0;
      end
    end
  end
  ;
  ;
  ;
  ;
end // end KL0VSAQ

// validate screen fields
Function KL0VSBA()
   /* ************************************************************/
   /* *     this process handles all edits for the header screen**/
   /* *     fields.                                             **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0VSBA"; /* set current process name*/
  ;
  ;
  if (KL0VM001.XWHCD is modified) /* new warehouse code entered*/
    KL0VSBB(); /* validate warehouse code*/
  else
    if (CLAREC.YCTCD == "DFO" 
     && KL0VM001.XWHCD == " " /* no warehouse code*/
     && KL0VM001.XWHABRV == " ") /* no warehouse abrev*/
       /* next sentence...not required for dfo clm type*/
    else
      if (KL0VM001.XWHCD == " " /* no warehouse code*/
       && KL0VM001.XWHABRV == " ") /* no warehouse abrev*/
        set KL0VM001.XWHCD cursor, modified, bold;
        CLXREC.CLXERRF = "Y";
        converseLib.validationFailed(21); /* error this is a required field.*/
      end
    end
  end
  ;
  if (KL0VM001.CL0VMIDT is modified)
    if (KL0VM001.CL0VMIDT == " ")
      CL0VW01.CL2ISBDT = CLXREC.XXXCDTE; /* format todays date*/
      CLXREC.XXXFLMM = CLXREC.XXXCMM;
      CLXREC.XXXSEP5 = "-";
      CLXREC.XXXFLDD = CLXREC.XXXCDD;
      CLXREC.XXXSEP6 = "-";
      CLXREC.XXXFLYY = CLXREC.XXXCYY;
      set KL0VM001.CL0VMIDT normal;
      CLXREC.CLXERRF = "Y";
      /* MOVE CLXREC.XXXFLDT TO CL0VW01.CL0VMIDT;*/
      /* MOVE CLXREC.XXXFLDT TO CL0VM001.CL0VMIDT;*/
      /* MOVE CLXREC.XXXFLDT TO CL0VM005.CL0VMIDT;*/
      /* MOVE CLXREC.XXXFLDT TO CL0VW02.CL0VMIDT;*/
    else
      /* IF CLXREC.XXXWYMD LE TA2REC.TA2GRGEN;*/
      KL0VSBC(); /* determine if valid date*/
      /* ELSE ;*/
      /* SET CL0VM001.CL0VMIDT CURSOR,BRIGHT;*/
      /* MOVE 17 TO EZEMNO           ;invaild date*/
      /* MOVE 'Y' TO CLXREC.CLXERRF;*/
    end
  else
    if (KL0VM001.CL0VMIDT == " ")
      CLXREC.CLXERRF = "Y";
      CL0VW01.CL2ISBDT = CLXREC.XXXCDTE; /* format todays date*/
      CLXREC.XXXFLMM = CLXREC.XXXCMM;
      CLXREC.XXXSEP5 = "-";
      CLXREC.XXXFLDD = CLXREC.XXXCDD;
      CLXREC.XXXSEP6 = "-";
      CLXREC.XXXFLYY = CLXREC.XXXCYY;
      set KL0VM001.CL0VMIDT normal;
      CL0VW01.CL0VMIDT = CLXREC.XXXCYMD;
      KL0VM001.CL0VMIDT = CLXREC.XXXCYMD;
    end
  end
  ;
  if (KL0VM001.XXXUSRID != " ")
    CL0VW01.XXXUSRID = KL0VM001.XXXUSRID;
  else
    set KL0VM001.XXXUSRID cursor, modified, bold;
    CLXREC.CLXERRF = "Y";
    converseLib.validationFailed(21); /* this field is required*/
  end
  ;
  ;
  if (CLAREC.YCTCD == "DFO"
   && KL0VM001.CLJNCRFL == " ")
    KL0VM001.CLJNCRFL = "N"; /* default to 'no' to dfo clm typ*/
  else
    if (KL0VM001.CLJNCRFL == "Y" /* only 'y' and 'n' are valid values.*/
     || KL0VM001.CLJNCRFL == "N")
      /* next sentence*/
    else
      set KL0VM001.CLJNCRFL cursor, bold;
      CLXREC.CLXERRF = "Y";
      converseLib.validationFailed(367); /* valid values are 'y' or 'n'*/
    end
  end
  ;
  ;
   /* ***********************/
  ;
  ;
   /* ***********************/
end // end KL0VSBA

// validate warehouse id
Function KL0VSBB()
  ;
  ;
  CLXREC.CLXCPROC = "CL0VSBB";
  ;
  if (KL0VM001.XWHCD in XWHTBL.XWHCD
   && XWHTBL.XXXSTAT[sysVar.arrayIndex] == "A")
    set KL0VM001.XWHCD initialAttributes;
    KL0VM001.XWHABRV = XWHTBL.XWHABRV[sysVar.arrayIndex];
    CL0VW01.XWHABRV = XWHTBL.XWHABRV[sysVar.arrayIndex];
    CL0VW01.XWHCD = KL0VM001.XWHCD;
    KL0VSBI(); /* get valid trailer nbr for warehouse*/
  else
    converseLib.validationFailed(400); /* warehouse is not valid*/
    CLXREC.CLXERRF = "Y";
    KL0VM001.XWHABRV = " ";
    CL0VW01.XWHABRV = " ";
    CL0VW01.XWHCD = KL0VM001.XWHCD;
    set KL0VM001.XWHCD cursor, modified, bold;
  end
  ;
  ;
end // end KL0VSBB

// validate entered date
Function KL0VSBC()
  ;
  CLXREC.CLXCPROC = "CL0VSBC"; /* set current process name*/
  ;
  CLXREC.XXXEDFLD = KL0VM001.CL0VMIDT;
  ;
  XPCL004(); /* date routine*/
  ;
   /* IF CLXREC.CLXVALDT EQ 'N'       ;bad date*/
   /* SET CL0VM001.CL0VMIDT CURSOR,BRIGHT;*/
   /* MOVE 17 TO EZEMNO             ;invaild date*/
   /* MOVE 'Y' TO CLXREC.CLXERRF;*/
   /* ELSE ;*/
   /* SET CL0VM001.CL0VMIDT NORMAL;*/
   /* MOVE TA2REC.TA2GRGGN TO CL0VW01.CL2ISBDT;*/
   /* MOVE TA2REC.TA2GRGGN TO CLXREC.XXXWDTE;*/
   /* MOVE CLXREC.XXXWYY TO CLXREC.XXXFLYY;*/
   /* MOVE CLXREC.XXXWMM TO CLXREC.XXXFLMM;*/
   /* MOVE CLXREC.XXXWDD TO CLXREC.XXXFLDD;*/
   /* MOVE '-' TO CLXREC.XXXSEP5;*/
   /* MOVE '-' TO CLXREC.XXXSEP6;*/
   /* IF CLXREC.XXXCYMD LE CL0VW01.CL0VWYMD;*/
   /* MOVE CLXREC.XXXFLDT TO CL0VM001.CL0VMIDT;*/
   /* MOVE CLXREC.XXXFLDT TO CL0VM005.CL0VMIDT;*/
   /* ELSE ;*/
   /* MOVE CL0VW01.CL0VMIDT TO CL0VM001.CL0VMIDT;*/
   /* SET CL0VM001.CL0VMIDT CURSOR,MODIFIED,BRIGHT;*/
   /* MOVE 'Y' TO CLXREC.CLXERRF  ; set map error flag*/
   /* MOVE 293 TO EZEMNO;*/
   /* END ;*/
   /* END ;*/
  ;
  ;
   /* %%%%%%%%%%%%%%%%%%%%%*/
   /* ***********************/
  ;
  ;
  if (CLXREC.CLXVALDT == "Y")
    set KL0VM001.CL0VMIDT normal;
    CL0VW01.CL2ISBDT = TA2REC.TA2GRGGN;
    CLXREC.XXXWDTE = TA2REC.TA2GRGGN;
    CLXREC.XXXFLYY = CLXREC.XXXWYY;
    CLXREC.XXXFLMM = CLXREC.XXXWMM;
    CLXREC.XXXFLDD = CLXREC.XXXWDD;
    CLXREC.XXXSEP5 = "-";
    CLXREC.XXXSEP6 = "-";
    /* -------------------- y2k out begin ---------------------*/
    /* IF CLXREC.XXXWYMD LE CL0VW01.CL0VWYMD;*/
    /* -------------------- y2k out end   ---------------------*/
    /* -------------------- y2k in begin  ---------------------*/
    if (CLXREC.XXXWCYMD <= CL0VW01.CL0VWYMD)
    /* -------------------- y2k in end    ---------------------*/
      /* IF CL0mEC.XXXWYMD NE ' ';*/
      if (KL0VM001.CL0VMIDT != " ")
        CL0VW01.CL0VMIDT = CLXREC.XXXWYMD;
        KL0VM001.CL0VMIDT = CLXREC.XXXFLDT;
        KL0VM005.CL0VMIDT = CLXREC.XXXFLDT;
      else
        CLXREC.CLXERRF = "Y";
        CL0VW01.CL0VMIDT = CLXREC.XXXCYMD;
        KL0VM001.CL0VMIDT = CLXREC.XXXCYMD;
        KL0VM005.CL0VMIDT = CLXREC.XXXCYMD;
      end
    else
      CL0VW01.CL0VMIDT = CLXREC.XXXWYMD;
      KL0VM001.CL0VMIDT = CLXREC.XXXFLDT;
      CLXREC.CLXERRF = "Y";
      /* MOVE 'Y' TO CL0VW01.CL0VWDEF;*/
      /* MOVE 'Y' TO CL0VW01.CL0VWUDF;*/
      /* MOVE 'CL0VM001' TO CLXREC.CLXCSCRN;*/
      set KL0VM001.CL0VMIDT cursor, modified, bold;
      converseLib.validationFailed(293);
    end
  else
    set KL0VM001.CL0VMIDT cursor, modified, bold;
    CLXREC.CLXERRF = "Y";
    /* MOVE 'Y' TO CL0VW01.CL0VWDEF;*/
    /* MOVE 'Y' TO CL0VW01.CL0VWUDF;*/
    /* MOVE 'CL0VM001' TO CLXREC.CLXCSCRN;*/
    set KL0VM001.CL0VMIDT cursor, modified, bold;
    converseLib.validationFailed(17);
  end
  ;
  ;
  ;
   /* ***********************/
   /* %%%%%%%%%%%%%%%%%%%%%*/
end // end KL0VSBC

// setup add return insp. row
Function KL0VSBD()
  ;
  CLXREC.CLXCPROC = "CL0VSBD";
  ;
  ;
  CL2REC.CLACLMNB = KL0VM001.CLACLMNB;
  CL2REC.CL2ISNBR = CLAREC.CLACISNB;
  CL2REC.CLHSEQNB = CLAREC.CLACSQNB;
  ;
  KL0V994(); /* inquire to see if defective header exists.*/
  ;
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    CL0VW01.CL0VW2FL = "N"; /* set defective header flag to 'n'*/
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      ;
      set CL2REC empty;
      CL2REC.CLACLMNB = KL0VM001.CLACLMNB;
      CL2REC.CL2ISNBR = CLAREC.CLACISNB;
      CL2REC.CLHSEQNB = CLAREC.CLACSQNB;
      CL2REC.YCICD = "WSE";
      CL2REC.CLJRDIND = "D";
      CL2REC.XXXUSRID = KL0VM001.XXXUSRID;
      CL2REC.CL2ISBDT = TA2REC.TA2GRGGN;
      CL2REC.CL2TOSLF = "N"; /* GDECKE 02-18-91 CLM TO STOCK LOCATE*/
                                   /* FL*/
      CL2REC.ZZZCHGDT = TA2REC.TA2GRGGN;
      CL2REC.ZZZCHGTM = TA2REC.TA2TIMHM;
      ;
      KL0V996(); /* add cl2rec*/
      ;
      if (SQLCA.VAGen_SQLCODE == 0)
        CL0VW01.CL0VW2FL = "N"; /* set return insp add flag to 'n'*/
      else
        if (SQLCA.VAGen_SQLCODE == -911)
          CLXREC.CLXERRF = "Y";
          converseLib.validationFailed(4);
        end
      end
      ;
      ;
    else
      if (SQLCA.VAGen_SQLCODE == -911)
        CLXREC.CLXERRF = "Y";
        converseLib.validationFailed(4);
      end
    end
  end
  ;
  ;
  ;
end // end KL0VSBD

// add required header table info
Function KL0VSBE()
  ;
  KL0VSAG(); /* get todays date*/
  ;
  if (CL0VW01.CL0VWLFL == "Y") /* :GO ADD ACTUAL RETURN ROW*/
    KL0VSBF(); /* cllrec*/
  end
  ;
  if (CL0VW01.CL0VWOFL == "Y") /* :GO ADD defective header row*/
    KL0VSBG(); /* clorec*/
  end
  ;
  if (CL0VW01.CL0VWJFL == "Y") /* :GO ADD return authorization row*/
    KL0VSBH(); /* cljrec*/
  end
  ;
  if (CL0VW01.CL0VW2FL == "Y") /* :GO ADD return inspection row*/
    KL0VSBD(); /* cl2rec*/
  end
  ;
  if (CLXREC.CLXERRF == "Y")
    /* next sentence*/
  else
    if (CL0VW01.CL0VWLFL == "N" /* ADD ACTUAL RETURN ROW successful*/
     && CL0VW01.CL0VWOFL == "N" /* ADD defective header row successful*/
     && CL0VW01.CL0VWJFL == "N" /* ADD return authorization successful*/
     && CL0VW01.CL0VW2FL == "N") /* ADD return inspection successful*/
      CL0VW01.CL0VWEHF = "Y"; /* end of header update flag*/
      CL0VW01.CL0VWHDF = "Y"; /* end of header flag*/
    else
      /* next sentence*/
    end
  end
  ;
  KL0VSAN(); /* move cl0vm001 to cl0vw01 and clear screen*/
  ;
end // end KL0VSBE

// setup add actual return row
Function KL0VSBF()
  ;
  ;
  CLXREC.CLXCPROC = "CL0VSBF";
  ;
  ;
  CLLREC.CLACLMNB = KL0VM001.CLACLMNB;
  CLLREC.CLLRTNNB = CLAREC.CLACRTNB;
  ;
  KL0V844(); /* select unique from cllrec*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    CL0VW01.CL0VWJFL = "N"; /* set return auth. add flag to 'n'*/
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      KL0VSBJ(); /* add actual return row*/
    else
      if (SQLCA.VAGen_SQLCODE == -911)
        converseLib.validationFailed(4);
        CLXREC.CLXERRF = "Y";
      end
    end
  end
  ;
  CL2REC.CLACLMNB = KL0VM001.CLACLMNB;
  CL2REC.CL2ISNBR = CLAREC.CLACISNB;
  CL2REC.CLHSEQNB = CLAREC.CLACSQNB;
  ;
  KL0V994(); /* select unique from cllrec*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    CL0VW01.CL0VWJFL = "N"; /* set return auth. add flag to 'n'*/
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      KL0VSBM(); /* add return insp row*/
    else
      if (SQLCA.VAGen_SQLCODE == -911)
        converseLib.validationFailed(4);
        CLXREC.CLXERRF = "Y";
      end
    end
  end
  ;
  ;
  ;
  ;
end // end KL0VSBF

// setup add defective header row
Function KL0VSBG()
  CLOREC.CLACLMNB = KL0VM001.CLACLMNB;
  CLOREC.CLHSEQNB = KL0VM001.CLHSEQNB;
  CLOREC.CL2ISNBR = CLAREC.CLACISNB;
  ;
  KL0V834(); /* inquire to see if defective header exists.*/
  ;
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    CL0VW01.CL0VWOFL = "N"; /* set defective header flag to 'n'*/
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      KL0VSBK(); /* add defective header*/
    else
      if (SQLCA.VAGen_SQLCODE == -911)
        CLXREC.CLXERRF = "Y";
        converseLib.validationFailed(4);
      end
    end
  end
  ;
  ;
end // end KL0VSBG

// setup add return auth. row
Function KL0VSBH()
  ;
  CLXREC.CLXCPROC = "CL0VSBH";
  ;
  ;
  CLOREC.CLACLMNB = KL0VM001.CLACLMNB;
  ;
  KL0V824(); /* inquire to see if defective header exists.*/
  ;
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    CL0VW01.CL0VWJFL = "N"; /* set defective header flag to 'n'*/
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      KL0VSBL(); /* add return authorization row*/
    else
      if (SQLCA.VAGen_SQLCODE == -911)
        CLXREC.CLXERRF = "Y";
        converseLib.validationFailed(4);
      end
    end
  end
  ;
  ;
  ;
end // end KL0VSBH

// retrieve valid trailer number
Function KL0VSBI()
  ;
  CLXREC.CLXCPROC = "CL0VSBI";
  ;
   /* SET CLSREC EMPTY;*/
   /* MOVE CL0VM001.XWHCD TO CLSREC.XWHCD;*/
   /* MOVE 'O' TO CLSREC.CLSTLRST;*/
   /* ;*/
   /* PERFORM CL0V884                 ; select unique from clsrec*/
   /* ;*/
   /* IF SQLCA.SQLCODE EQ 0;*/
    /* MOVE CLSREC.CLOTLRID TO CL0VM001.CLOTLRID;*/
    /* MOVE CLSREC.CLOTLRID TO CL0VW01.CLOTLRID;*/
    /* SET CL0VM001.XWHCD DEFINED;*/
   /* ELSE ;*/
    /* IF SQLCA.SQLCODE EQ 100;*/
      /* MOVE 'Y' TO CLXREC.CLXERRF;*/
      /* SET CL0VM001.XWHCD CURSOR,MODIFIED,BRIGHT;*/
      /* MOVE 361 TO EZEMNO; no trailer number assigned to whse*/
    /* END ;*/
   /* END ;*/
  ;
  ;
  KL0VM001.CLOTLRID = "TR99";
  CL0VW01.CLOTLRID = "TR99";
  ;
end // end KL0VSBI

// add actual return row
Function KL0VSBJ()
  ;
  ;
  set CLLREC empty;
  CLLREC.CLACLMNB = KL0VM001.CLACLMNB;
  CLLREC.CLLRTNNB = CLAREC.CLACRTNB;
  CLLREC.XWHCD = KL0VM001.XWHCD;
  CLLREC.ZZZCHGDT = TA2REC.TA2GRGGN;
  CLLREC.ZZZCHGTM = TA2REC.TA2TIMHM;
  ;
  KL0V846(); /* add actual return row*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    CL0VW01.CL0VWLFL = "N"; /* set return auth. add flag to 'n'*/
  else
    if (SQLCA.VAGen_SQLCODE == -911)
      CLXREC.CLXERRF = "Y";
      converseLib.validationFailed(4);
    end
  end
  ;
  ;
end // end KL0VSBJ

// add defective header row
Function KL0VSBK()
  ;
  ;
  CLXREC.CLXCPROC = "CL0VSBK";
  ;
  ;
  set CLOREC empty;
  CLOREC.CLACLMNB = KL0VM001.CLACLMNB;
  CLOREC.CLHSEQNB = KL0VM001.CLHSEQNB;
  CLOREC.CL2ISNBR = CLAREC.CLACISNB;
  CLOREC.CLOTLRID = KL0VM001.CLOTLRID;
  CLOREC.ZZZCHGDT = TA2REC.TA2GRGGN;
  CLOREC.ZZZCHGTM = TA2REC.TA2TIMHM;
  ;
  KL0V836(); /* add clorec*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    CL0VW01.CL0VWOFL = "N"; /* set defective header flag to 'n'*/
  else
    if (SQLCA.VAGen_SQLCODE == -911)
      CLXREC.CLXERRF = "Y";
      converseLib.validationFailed(4);
    end
  end
  ;
  ;
end // end KL0VSBK

// add return authorization row
Function KL0VSBL()
  ;
  ;
  CLXREC.CLXCPROC = "CL0VSBL";
  ;
  ;
  set CLJREC empty;
  CLJREC.CLACLMNB = KL0VM001.CLACLMNB;
  CLJREC.XWHCD = KL0VM001.XWHCD;
  CLJREC.CLJNCRFL = KL0VM001.CLJNCRFL;
  CLJREC.ZZZCHGDT = TA2REC.TA2GRGGN;
  CLJREC.ZZZCHGTM = TA2REC.TA2TIMHM;
  ;
  KL0V826(); /* add cljrec*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    CL0VW01.CL0VWJFL = "N"; /* set actual return add flag to 'n'*/
  else
    if (SQLCA.VAGen_SQLCODE == -911)
      CLXREC.CLXERRF = "Y";
      converseLib.validationFailed(4);
    end
  end
  ;
  ;
  ;
end // end KL0VSBL

// add actual return row
Function KL0VSBM()
  ;
  ;
  set CL2REC empty;
  CL2REC.CLACLMNB = KL0VM001.CLACLMNB;
  CL2REC.CL2ISNBR = CLAREC.CLACISNB;
  CL2REC.CLHSEQNB = CLAREC.CLACSQNB;
  CL2REC.YCICD = "WSE";
  CL2REC.CLJRDIND = "D";
  CL2REC.XXXUSRID = KL0VM001.XXXUSRID;
  CL2REC.CL2ISBDT = CL0VW01.CL2ISBDT;
  CL2REC.CL2TOSLF = "N"; /* GDECKE 02-18-91 CLM TO STOCK LOCATE FLAG*/
  CL2REC.ZZZCHGDT = TA2REC.TA2GRGGN;
  CL2REC.ZZZCHGTM = TA2REC.TA2TIMHM;
  ;
  KL0V996(); /* add return insp row*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    CL0VW01.CL0VW2FL = "N"; /* set return insp. add flag to 'n'*/
  else
    if (SQLCA.VAGen_SQLCODE == -911)
      CLXREC.CLXERRF = "Y";
      converseLib.validationFailed(4);
    end
  end
  ;
  ;
end // end KL0VSBM

// edit product brand code
Function KL0VSBR()
   /* *************************************************************/
  ;
    /* Edit the product brand code for customer-product legal*/
    /* entity mis-match.*/
  ;
    /* Maintenance History:*/
    /* 05-31-90 CHELLM created*/
  ;
  ;
   /* *************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0VSBR";
  ;
  if (CLXREC.CLXERRF == "Y") /* if errors in product already exist*/
    return; /* don't need to edit*/
  end
  ;
   /* If either the claim or the invoice was set up prior*/
   /* to 06-01-90 it doesnt have a brand code, so make sure*/
   /* the legal entity of customer match the legal entity of*/
   /* the product.*/
  if (CLAREC.XBCCD == " ")
    ;
    if (CLWREC.XLECD == "01") /* If Nike Customer*/
      if (SY1REC.XBCCD == "01") /* and Nike Product*/
                                 /* ;   Product is OK*/
      else
        converseLib.validationFailed(634); /* Product's XLE must match Cust XLE*/
        CLXREC.CLXERRF = "Y";
        set KL0VM001.SY1STNBR cursor, modified, bold;
        return;
      end
    end
    ;
    if (CLWREC.XLECD == "05") /* If Side 1 Customer*/
      if (SY1REC.XBCCD == "05" /* and Side 1 Product*/
       || SY1REC.XBCCD == "06" /* or Relay  product*/
       || SY1REC.XBCCD == "07") /* or i.e    product*/
                                 /* ;  then Product is OK*/
      else
        converseLib.validationFailed(634); /* Product's XLE must match Cust XLE*/
        CLXREC.CLXERRF = "Y";
        set KL0VM001.SY1STNBR cursor, modified, bold;
        return;
      end
    end
    ;
     /* check the division code value against allowable*/
     /* division codes for the claims order type.*/
    ;
    if (CLAREC.XOTCD in XOTTBL.XOTCD)
      ;
      if (SY2REC.XDVCD == XOTTBL.XDVCD1[sysVar.arrayIndex]
       || SY2REC.XDVCD == XOTTBL.XDVCD2[sysVar.arrayIndex]
       || SY2REC.XDVCD == XOTTBL.XDVCD3[sysVar.arrayIndex]
       || SY2REC.XDVCD == XOTTBL.XDVCD4[sysVar.arrayIndex]
       || SY2REC.XDVCD == XOTTBL.XDVCD5[sysVar.arrayIndex])
         /* next sentence*/
      else
        converseLib.validationFailed(637); /* the product brand must match the*/
        CLXREC.CLXERRF = "Y"; /* claims division or new division*/
        set KL0VM001.SY1STNBR cursor, modified, bold;
        return;
      end
    else
      converseLib.validationFailed(096); /* order type not on system table*/
      CLXREC.CLXERRF = "Y";
      return;
    end
    ;
  else
    ;
    ;
    if (SY1REC.XBCCD != CLAREC.XBCCD) /* if brand codes don't match*/
      converseLib.validationFailed(611); /* Product brand must match claim brand*/
      CLXREC.CLXERRF = "Y";
      set KL0VM001.SY1STNBR cursor, modified, bold;
    end
    ;
  end
  ;
end // end KL0VSBR

// update frgt qty&amt def. field
Function KL0VSCA()
   /* ********************************************************/
   /* *   the total of the cr qty field for a claim is      **/
   /* *   equal to the freight quantity. the freight qty    **/
   /* *   is then multiplyied by a dollar amount from yrmtbl**/
   /* *   based on gpc to give the freight amount.          **/
   /* *                                                     **/
   /* *   the freight amount and qty are updated for the    **/
   /* *   defective header.                                 **/
   /* *                                                     **/
   /* *                                                     **/
   /* ********************************************************/
  ;
  CLXREC.CLXCPROC = "CL0VSCA";
  ;
  KL0VSAG(); /* retrieve todays date and time*/
  ;
   /* update the defective header for frgt qty& amt.*/
  ;
  KL0VSGG(); /* update defective header and clarec est. claim value*/
  ;
  CLXREC.CLXEOSF = "Y";
  ;
  ;
end // end KL0VSCA

// validate defective detail data
Function KL0VSCB()
  ;
  ;
  CLXREC.CLXCPROC = "CL0VSCB";
  ;
  ;
  ;
   /* ************************************************************/
   /* *     this process handles all edits for the header       **/
   /* *     fields.                                             **/
   /* ************************************************************/
  ;
  if (KL0VM001.XWHCD not modified) /* new warehouse code entered*/
    /* next sentence*/
  else
    if (KL0VM001.XWHCD == " ")
      set KL0VM001.XWHCD cursor, modified, bold;
      KL0VM001.XWHABRV = " ";
      CL0VW01.XWHABRV = " ";
      CLXREC.CLXERRF = "Y";
      converseLib.validationFailed(21);
    else
      KL0VSBB(); /* validate warehouse code*/
    end
  end
  ;
  if (KL0VM001.CL0VMIDT == CL0VW02.CL0VMIDT
   && KL0VM001.CL0VMIDT != " ")
    /* next sentence*/
  else
    KL0VSBC(); /* determine if valid date*/
  end
  ;
  if (KL0VM001.XXXUSRID == CL0VW02.XXXUSRID)
    /* next sentence*/
  else
    if (KL0VM001.XXXUSRID != " ")
      CL0VW01.XXXUSRID = KL0VM001.XXXUSRID;
    else
      set KL0VM001.XXXUSRID cursor, modified, bold;
      CLXREC.CLXERRF = "Y";
      converseLib.validationFailed(21); /* this field is required*/
    end
  end
  ;
  ;
  if (KL0VM001.CLJNCRFL == "Y" /* only 'y' and 'n' are valid values.*/
   || KL0VM001.CLJNCRFL == "N")
    /* next sentence*/
  else
    set KL0VM001.CLJNCRFL cursor, bold;
    CLXREC.CLXERRF = "Y";
    converseLib.validationFailed(367); /* valid values are 'y' or 'n'*/
  end
  ;
   /* not data in detail fields*/
  ;
  if (CLXREC.CLXEOSF == "Y")
    return;
  end
  ;
   /* ****************************************/
   /* for phase c you may want to enter*/
   /* rts info statement groups here.*/
   /* ****************************************/
  ;
  if (KL0VM001.CLGCOMNT is modified)
    set KL0VM001.CLGCOMNT modified;
  else
    set KL0VM001.CLGCOMNT initialAttributes;
  end
  ;
  ;
  KL0VSCD(); /* validate the no credit return code*/
   /* a qty must be entered to offset the def. qty entered*/
  ;
  ;
  ;
  CL0VW01.CL0VWDFQ = 0;
  CL0VW01.CL0VWDFQ = KL0VM001.CLPRTCTQ + KL0VM001.CL0VWNRQ;
  CL0VW01.CL0VWDFQ = CL0VW01.CL0VWDFQ + KL0VM001.CLPDEFQ;
  if (CL0VW01.CL0VWDFQ != 0)
    if (KL0VM001.CL0VWDFQ == CL0VW01.CL0VWDFQ)
      set KL0VM001.CL0VWDFQ initialAttributes;
      set KL0VM001.CLPDEFQ initialAttributes;
      set KL0VM001.CLPRTCTQ initialAttributes;
      set KL0VM001.CL0VWNRQ initialAttributes;
    else
      set KL0VM001.CL0VWDFQ cursor, bold;
      set KL0VM001.CLPDEFQ bold;
      set KL0VM001.CLPRTCTQ bold;
      set KL0VM001.CL0VWNRQ bold;
      CLXREC.CLXERRF = "Y";
      converseLib.validationFailed(365);
    end
  else
    set KL0VM001.CL0VWDFQ cursor, bold;
    set KL0VM001.CLPDEFQ bold;
    set KL0VM001.CLPRTCTQ bold;
    set KL0VM001.CL0VWNRQ cursor, bold;
    CLXREC.CLXERRF = "Y";
    converseLib.validationFailed(365);
  end
  ;
  if (KL0VM001.CLPDEFQ != 0)
    KL0VSCE(); /* validate the defective code*/
    KL0VSCF(); /* validate the carton number*/
  else
    if (KL0VM001.CLPDEFQ > 0
     || KL0VM001.CL0VWNRQ > 0)
      KL0VM001.CLPCRTNB = "000";
      KL0VSCF(); /* validate the carton number*/
    end
  end
  ;
  ;
   /* CL0VSCG   ; validate the duty drawback code*/
   /* see below*/
  ;
  ;
  KL0VSCI(); /* validate the style,color,dimension,uom data*/
  ;
  ;
  KL0VSCH(); /* validate p.o. and factory codes*/
  ;
  ;
   /* *************************************************/
   /* validate the duty drawback codeto be used in a later*/
   /* phase*/
   /* IF CL0VM001.YDDCD NE ' ';*/
    /* IF CL0VM001.YDDCD IN YDDTBL.YDDCD;*/
      /* IF YDDTBL.XXXSTAT(EZETST) = 'A';*/
        /* SET CL0VM001.YDDCD DEFINED;*/
      /* ELSE ;*/
        /* MOVE 'Y' TO CLXREC.CLXERRF;*/
        /* SET CL0VM001.YDDCD CURSOR,BRIGHT;*/
        /* ;error message this record does not exist*/
      /* END ;*/
    /* ELSE ;*/
      /* MOVE 'Y' TO CLXREC.CLXERRF;*/
      /* SET CL0VM001.YDDCD CURSOR,BRIGHT;*/
      /* ;error message this record does not exist*/
   /* END ;*/
   /* eLSE ;*/
   /* MOVE 'Y' TO CLXREC.CLXERRF;*/
   /* SET CL0VM001.YDDCD CURSOR,BRIGHT;*/
   /* ;error message, this is a required field*/
   /* END ;*/
  ;
end // end KL0VSCB

// all updates
Function KL0VSCC()
  ;
  ;
  CLXREC.CLXCPROC = "CL0VSCC";
  ;
  KL0VSAG(); /* get todays date*/
  ;
  ;
          /* update header information*/
  ;
  if (CL0VW02.XWHCD == KL0VM001.XWHCD)
    /* next sentence*/
  else
    KL0VSKB();
                                   /* update clorec defective hdeade record*/
  end
  ;
  if (CLXREC.CLXERRF == "Y")
    return;
  end
  ;
  if (CL0VW02.CLJNCRFL == KL0VM001.CLJNCRFL
   && CL0VW02.XWHCD == KL0VM001.XWHCD)
    /* next sentence*/
  else
    KL0VSKC(); /* UPDATE CLJREC RETURN AUTHORIZATION*/
  end
  ;
  if (CLXREC.CLXERRF == "Y")
    return;
  end
  ;
  if (CL0VW02.XXXUSRID == KL0VM001.XXXUSRID
   && CL0VW02.CL0VMIDT == KL0VM001.CL0VMIDT
   && CL0VW02.XWHCD == KL0VM001.XWHCD)
    /* next sentence*/
  else
    KL0VSKD(); /* update cllrec return auth and cl2rec*/
  end
  ;
  if (CLXREC.CLXERRF == "Y")
    return;
  end
  ;
   /* only have changed header data*/
  ;
  if (CLXREC.CLXEOSF == "Y")
    return;
  end
  ;
         /* update detail area*/
  ;
  set CLPREC empty;
  ;
  CL0VW01.CLGCMSEQ = 0;
   /* the fields below will check for a unique row.*/
  ;
  CLPREC.CLACLMNB = KL0VM001.CLACLMNB;
  CLPREC.CLHSEQNB = KL0VM001.CLHSEQNB;
  CLPREC.CL2ISNBR = CLAREC.CLACISNB;
  CLPREC.XGPCD = KL0VM001.XGPCD;
  CLPREC.SY1STNBR = KL0VM001.SY1STNBR;
  CLPREC.SY2CLRID = KL0VM001.SY2CLRID;
  CLPREC.XDMCD = KL0VM001.XDMCD;
  CLPREC.YDDCD = KL0VM001.YDDCD;
  CLPREC.XUMCD = KL0VM001.XUMCD;
  CLPREC.XQACD = KL0VM001.XQACD;
  CLPREC.CLKCLPRC = KL0VM001.CLKCLPRC;
  CLPREC.FY1FCTYC = CL0VW01.FY1FCTYC;
  ;
   /* PO Date conversion added 06-14-90*/
  if (KL0VM001.CL0VMFPO != 0)
    CLXREC.XXXWYMD = KL0VM001.CL0VMFPO;
    if (CLXREC.XXXWYY < 50)
      CLXREC.XXXWCC = 20;
    else
      CLXREC.XXXWCC = 19;
    end
    CLPREC.PC3POIDT = CLXREC.XXXWCYMD;
  else
    CLPREC.PC3POIDT = 0;
  end
  ;
  CLPREC.CLPCRTNB = KL0VM001.CLPCRTNB;
  CLPREC.YDFCD = KL0VM001.YDFCD;
  CLPREC.YDRCD = KL0VM001.YDRCD;
  CLPREC.XQACD = "01";
  ;
  KL0V894(); /* inquire to check if defective detail exists*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    KL0VSDB(); /* update defective detail*/
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      KL0VSDA(); /* add defective detail*/
    else
      if (SQLCA.VAGen_SQLCODE == -911)
        converseLib.validationFailed(4);
        CLXREC.CLXERRF = "Y";
        return;
      end
    end
  end
  ;
  ;
    /* set comment indicator to be updated on clarec*/
  ;
  CLGREC.CLACLMNB = CLAREC.CLACLMNB;
  CLGREC.CLHSEQNB = -1;
  CLGREC.CL2ISNBR = -1;
  CLGREC.CLGCMTYP = "**";
  ;
  call "IO1260" ("SS", SQLCA, CLGREC) {isNoRefresh = yes, isExternal = yes}; /* dclaim.vclcom01*/
  call "IO1260" ("SN", SQLCA, CLGREC) {isNoRefresh = yes, isExternal = yes};
  ;
  CL0VW01.CL-CLCOM-FL = CLAREC.CLACMIND;
  if (SQLCA.VAGen_SQLCODE == 0)
    if (CLAREC.CLACMIND == "N"
     || CLAREC.CLACMIND == " ")
      CL0VW01.CL-CLCOM-FL = "Y";
    end
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      if (CLAREC.CLACMIND == "Y")
        CL0VW01.CL-CLCOM-FL = "N";
      end
    end
  end
  call "IO1260" ("CS", SQLCA, CLGREC) {isNoRefresh = yes, isExternal = yes};
  ;
  ;
   /* add together all credit qtys. this will be used to calculate*/
   /* the freight amount.*/
  ;
  if (KUCREC.XCUCD[1] == "PY97") /* customers with this credit rep*/
    KL0VM001.CLOFGAQ = 0; /* dont get freight allowance*/
  else
    KL0VM001.CLOFGAQ = KL0VM001.CLOFGAQ + KL0VM001.CLPDEFQ;
  end
  ;
  ;
   /* this routine will calculate the total merchandise amount*/
   /* for the claim/seq. number*/
  ;
  CL0VW01.CL0VWMAM = 0;
  CL0VW01.CL0VWMAM = KL0VM001.CLKCLPRC * KL0VM001.CLPDEFQ;
  CL0VW01.CLODMAMT = CL0VW01.CLODMAMT + CL0VW01.CL0VWMAM;
  KL0VM001.CLODMAMT = CL0VW01.CLODMAMT;
  ;
  ;
  if (CL0VW01.XGPCD in YRMTBL.XGPCD)
    CL0VW01.CLOFGAAM = KL0VM001.CLOFGAQ * YRMTBL.YRMDFRGT[sysVar.arrayIndex];
    KL0VM001.CLOFGAAM = CL0VW01.CLOFGAAM;
  else
    /* next sentence*/
  end
  ;
  ;
  if (CLXREC.CLXERRF == "Y")
    /* next sentence*/
  else
    KL0VSAN(); /* move cl0vm001 to cl0vw01 and clear screen*/
  end
  ;
end // end KL0VSCC

// check no credit return data
Function KL0VSCD()
  ;
  ;
  CLXREC.CLXCPROC = "CL0VSCD";
  ;
  ;
  if (KL0VM001.CL0VWNRQ > 0
   || KL0VM001.CLPRTCTQ > 0)
    if (KL0VM001.YDRCD != " ")
      KL0VSCQ(); /* validate reason code.*/
    else
      CLXREC.CLXERRF = "Y";
      set KL0VM001.YDRCD cursor, bold;
      converseLib.validationFailed(21); /* this is a required field*/
    end
  else
    if (KL0VM001.CL0VWNRQ == 0
     || KL0VM001.CLPRTCTQ == 0)
      if (KL0VM001.YDRCD != " ")
        CLXREC.CLXERRF = "Y";
        set KL0VM001.CL0VWNRQ cursor, bold;
        set KL0VM001.CLPRTCTQ bold;
        converseLib.validationFailed(366); /* one of these two qtys is required.*/
      else
        /* next sentence*/
      end
    else
      /* next sentence*/
    end
  end
  ;
  ;
end // end KL0VSCD

// validate defective code
Function KL0VSCE()
  ;
  CLXREC.CLXCPROC = "CL0VSCE";
  ;
  ;
  ;
   /* ***************************************/
  if (KL0VM001.YDFCD != " ")
    CL0VW01.XGPCD = KL0VM001.XGPCD;
    CL0VW01.YDFCD = KL0VM001.YDFCD;
    if (CL0VW01.YDFKEY in YDFTBL.YDFKEY)
      if (YDFTBL.XXXSTAT[sysVar.arrayIndex] == "A")
        set KL0VM001.YDFCD initialAttributes;
      else
        set KL0VM001.YDFCD cursor, bold;
        CLXREC.CLXERRF = "Y";
        converseLib.validationFailed(9); /* no records exist*/
      end
    else
      CLXREC.CLXERRF = "Y";
      set KL0VM001.YDFCD cursor, bold;
      converseLib.validationFailed(9); /* no records exist*/
    end
  else
    CLXREC.CLXERRF = "Y";
    set KL0VM001.YDFCD cursor, bold;
    converseLib.validationFailed(21); /* this is a required field*/
  end
  ;
   /* ***************************************/
  ;
end // end KL0VSCE

// validate carton number
Function KL0VSCF()
  ;
  ;
  if (KL0VM001.CLPCRTNB != " ")
    set KL0VM001.CLPCRTNB initialAttributes;
  else
    if (CLAREC.YCTCD == "DFO")
      /* next sentence*/
    else
      CLXREC.CLXERRF = "Y";
      set KL0VM001.CLPCRTNB cursor, bold;
      if (KL0VM001.YDFCD == " ")
        converseLib.validationFailed(418); /* these fields are required*/
      else
        converseLib.validationFailed(21); /* this is a required field*/
      end
    end
  end
  ;
end // end KL0VSCF

// validate p.o. and factory code
Function KL0VSCH()
  ;
  ;
  CLXREC.CLXCPROC = "CL0VSCH";
  ;
   /* The code below has been commented out because Phase IV now*/
   /* requires Factory code to be entered and only valid*/
   /* Style-FctyCd-PO Nbr combinations.*/
   /* 06-21-90 CHELLM Removed comments below to revert back to*/
                   /* warning only edit*/
  ;
  if (CLXREC.CLXERRF == "Y")
    CL0VW01.CL0VWWRF = "N";
    return;
  else
    /* next sentence*/
  end
  ;
  if (CL0VW01.CL0VWWRF == "Y")
    if (KL0VM001.FY1FCTYC is modified
     || KL0VM001.CL0VMFPO is modified)
      CL0VW01.CL0VWWRF = "N";
    else
      CL0VW01.CL0VWWRF = "N";
      return;
    end
  else
    /* next sentence*/
  end
  ;
  if (KL0VM001.FY1FCTYC == " "
   && KL0VM001.CL0VMFPO == 0)
    KL0VSCO(); /* retrieve default values from ycc*/
                                   /* table*/
  else
    /* next sentence*/
  end
  ;
  KL0VSCJ(); /* validate factory code*/
  ;
  if (CLXREC.CLXERRF == "N") /* if no errors so far*/
    KL0VSCK(); /* validate po number*/
  end
  ;
  ;
  ;
end // end KL0VSCH

// validate style,color,dim.,uom
Function KL0VSCI()
  ;
    /* Maintenance History:*/
    /* 05-31-90 CHELLM Added CL0VSBR Edit product brand code.*/
  ;
   /* *************************************************************/
  ;
  ;
  CLXREC.CLXCPROC = "CL0VSCI";
  ;
  ;
  if (KL0VM001.SY1STNBR != " ")
    KL0VSCM(); /* validate style number*/
    KL0VSCN(); /* validate style/color number*/
    KL0VSBR(); /* validate product brand code*/
    if (KL0VM001.CLKCLPRC is modified)
      if (KL0VM001.CLKCLPRC > 0)
        if (KL0VM001.CLKCLPRC <= CL0VW01.CL0VWMX)
          CL0VW01.CLKPRCFF = "E";
          set KL0VM001.CLKCLPRC initialAttributes;
        else
          CLXREC.CLXERRF = "Y";
          set KL0VM001.CLKCLPRC cursor, modified, bold;
          converseLib.validationFailed(375); /* price can't exceed 200.00*/
        end
      else
        if (KL0VM001.CLKCLPRC == 0
         && CL0VW01.CL0VWPEF == "Y") /* there was a price error*/
          CL0VW01.CL0VWPEF = "N";
          CL0VW01.CLKPRCFF = "E";
          set KL0VM001.CLKCLPRC initialAttributes;
        else
          set KL0VM001.CLKCLPRC initialAttributes;
          CL0VW01.CLKPRCFF = "P";
          KL0VSCR(); /* retrieve price from product*/
        end
      end
    else
      if (KL0VM001.CLKCLPRC > 0)
        /* next sentence*/
      else
        set KL0VM001.CLKCLPRC initialAttributes;
        CL0VW01.CLKPRCFF = "P";
        KL0VSCR(); /* retrieve price from product*/
      end
    end
  else
    CLXREC.CLXERRF = "Y";
    set KL0VM001.SY1STNBR cursor, bold;
    converseLib.validationFailed(21); /* this is a required field*/
  end
  ;
  ;
end // end KL0VSCI

// validate factory code
Function KL0VSCJ()
    /* Edit Factory Code*/
  ;
    /* Maintenance History:*/
    /* 02-22-90 CHELLM Renamed PD1.. items as FY1.. items.*/
    /* 05-31-90 CHELLM Transformed this edit from a warning*/
                    /* to a hard edit.*/
    /* 06-21-90 CHELLM added edit to require fcty code entry*/
  ;
  ;
  CLXREC.CLXCPROC = "CL0VSCJ";
  ;
  ;
  set FY1REC empty;
  ;
   /* IF CL0VM001.FY1FCTYC IN CL0VW03.PD1FTYNO;       (02-22-90)*/
    /* MOVE CL0VW03.FY1FCTYC(EZETST) TO CL0VW01.FY1FCTYC;*/
    /* SET CL0VM001.FY1FCTYC DEFINED;*/
    /* MOVE 'N' TO CL0VW01.CLPVLDFL  ;set warning flag to no*/
    /* EZERTN;*/
   /* ELSE ;*/
  ;
  if (CLAREC.XGPCD != "02"
   && KL0VM001.FY1FCTYC != " ")
    CLXREC.CLXERRF = "Y";
    CL0VW01.CLPVLDFL = "N"; /* set warning flag on invalid po*/
    converseLib.validationFailed(624); /* fcty cd only allowed for footware claims*/
    set KL0VM001.FY1FCTYC cursor, modified, bold;
    return;
  end
  ;
  if (KL0VM001.FY1FCTYC == " ")
    CLXREC.CLXERRF = "Y";
    CL0VW01.CLPVLDFL = "N"; /* set warning flag on invalid po*/
    converseLib.validationFailed(620); /* fcty cd only allowed for footware claims*/
    set KL0VM001.FY1FCTYC cursor, modified, bold;
    return;
  end
  ;
  if (KL0VM001.FY1FCTYC in CL0VW03.FY1FCTYC)
    CL0VW01.FY1FCTYC = KL0VM001.FY1FCTYC;
    set KL0VM001.FY1FCTYC initialAttributes;
    CL0VW01.CLPVLDFL = "Y"; /* yes is valid*/
    return;
  end
  ;
  FY1REC.FY1FCTYC = KL0VM001.FY1FCTYC;
  FY1REC.XGPCD = KL0VM001.XGPCD; /* (02-22-90)*/
  KL0V904(); /* select unique from FY1REC*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    set KL0VM001.FY1FCTYC initialAttributes;
    CL0VW01.CLPVLDFL = "Y"; /* yes is valid*/
    CL0VW01.FY1FCTYC = KL0VM001.FY1FCTYC; /* 5-13-88*/
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      set KL0VM001.FY1FCTYC cursor, bold;
      CL0VW01.FY1FCTYC = KL0VM001.FY1FCTYC; /* 5-13-88*/
      converseLib.validationFailed(363);
      CLXREC.CLXERRF = "Y"; /* set error flag on*/
      CL0VW01.CLPVLDFL = "N"; /* set warning flag on invalid po*/
    end
  end
  ;
  ;
  ;
end // end KL0VSCJ

// validate p.o. code
Function KL0VSCK()
  ;
  ;
    /* Maintenance History:*/
    /* 02-22-90 CHELLM Renamed PD1.. items as FY1.. items.*/
    /* 05-31-90 CHELLM Transformed the PO Nbr edit from a warning*/
                    /* to a hard edit.*/
    /* 06-21-90 CHELLM Changed the fcty - PO edit back to just*/
                    /* a warning edit.*/
  ;
  CLXREC.CLXCPROC = "CL0VSCK";
  ;
   /* currently (5/88) the only valid po's are for gpc '02'.*/
   /* everything else is invalid.*/
  ;
  if (KL0VM001.XGPCD != "02")
    CLXREC.CLXERRF = "Y"; /* set warning flag on.*/
    CL0VW01.CLPVLDFL = "N"; /* set warning flag on invalid po*/
    converseLib.validationFailed(364); /* warning invalid po*/
    set KL0VM001.CL0VMFPO cursor, bold;
    return; /* table checking not set up*/
  end
  ;
    /* If factory code is 99, then you can't have a PO Nbr.*/
  if (KL0VM001.FY1FCTYC == "99")
    if (KL0VM001.CL0VMFPO != 0)
      CLXREC.CLXERRF = "Y";
      set KL0VM001.CL0VMFPO cursor, modified, bold;
      converseLib.validationFailed(614);
      return;
    else
      CL0VW01.CLPVLDFL = "N"; /* set warning flag to no*/
      return; /* Fcty 99 and 0 PO Nbr is valid combo*/
    end
  end
  ;
  ;
    /* If factory code is entered then PO Nbr is required.*/
  if (KL0VM001.FY1FCTYC != "99"
   && KL0VM001.FY1FCTYC != " "
   && KL0VM001.CL0VMFPO == 0)
    CLXREC.CLXERRF = "Y";
    set KL0VM001.CL0VMFPO cursor, modified, bold;
    converseLib.validationFailed(623); /* must have PO nbr for factory*/
    return;
  end
  ;
  set PC6REC empty;
  set CL0VW07 empty;
  ;
  PC6REC.FY1FCTYC = CL0VW01.FY1FCTYC;
  ;
   /* PO Date conversion added 06-14-90*/
  CLXREC.XXXWYMD = KL0VM001.CL0VMFPO;
  if (CLXREC.XXXWYY < 50)
    CLXREC.XXXWCC = 20;
  else
    CLXREC.XXXWCC = 19;
  end
  PC6REC.PC3POIDT = CLXREC.XXXWCYMD;
  CL0VW07.CL0VWDT1 = CLXREC.XXXWCYMD;
  CL0VW07.CL0VWDT2 = CLXREC.XXXWCYMD;
  CL0VW07.CL0VWSQL = "S3";
  PC6REC.XGPCD = KL0VM001.XGPCD;
  PC6REC.SY1STNBR = KL0VM001.SY1STNBR;
  PC6REC.SY2CLRID = KL0VM001.SY2CLRID;
  PC6REC.XDMCD = KL0VM001.XDMCD;
  PC6REC.XDMCD = "*";
  PC6REC.PCFSECD = "*";
  PC6REC.PC4ORTYP = "*";
  PC6REC.XQACD = "*";
  PC6REC.XOWCD = "*";
  PC6REC.XPGCD = "*";
  PC6REC.XUMCD = "*";
  PC6REC.XWHCD = "*";
  PC6REC.PC2INSEG = "*";
  PC6REC.PC2CUXID = "*";
  PC6REC.PC6ETSDT = -1;
  PC6REC.YMTCD = "*";
  PC6REC.PC6PLAN = -1;
  PC6REC.XDSCD = "*";
  PC6REC.YSMXDV = "*";
  PC6REC.PC6STAT = "*";
  ;
  KL0V914(); /* select unique from pc6rec*/
  ;
  if (CL0VW01.CLPVLDFL == "N")
    /* MOVE 'Y' TO CLXREC.CLXERRF    ; set error flag on.*/
    CL0VW01.CL0VWWRF = "Y"; /* set warning flag on.*/
    converseLib.validationFailed(364); /* invalid po combo*/
    set KL0VM001.CL0VMFPO cursor, bold;
    set KL0VM001.SY1STNBR bold;
    set KL0VM001.FY1FCTYC bold;
  else
    set KL0VM001.CL0VMFPO initialAttributes;
  end
  ;
  ;
  ;
end // end KL0VSCK

// validate style
Function KL0VSCM()
  ;
  CLXREC.CLXCPROC = "CL0VSCM"; /* set current process name*/
  ;
  set SY1REC empty;
  SY1REC.SY1STNBR = KL0VM001.SY1STNBR;
  SY1REC.XGPCD = KL0VM001.XGPCD;
  ;
  KL0V924(); /* inquire on the style table*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    set KL0VM001.SY1STNBR initialAttributes;
    /* check for life cycle code of 25*/
    if (KL0VM001.XUMCD == " ")
      KL0VM001.XUMCD = SY1REC.XUMCD;
    else
      KL0VSCP(); /* validate uom against uom table*/
    end
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      CLXREC.CLXERRF = "Y";
      set KL0VM001.SY1STNBR cursor, bold;
      converseLib.validationFailed(550); /* product id not valid*/
    end
  end
  ;
  ;
  ;
end // end KL0VSCM

// validate color
Function KL0VSCN()
  ;
  CLXREC.CLXCPROC = "CL0VSCN"; /* set current process name*/
  ;
  if (CLXREC.CLXERRF == "Y")
    return;
  else
    /* next sentence*/
  end
  ;
  if (KL0VM001.SY2CLRID == " ")
    KL0VM001.SY2CLRID = "00";
  else
    /* next sentence*/
  end
  ;
  set SY2REC empty;
  SY2REC.XGPCD = KL0VM001.XGPCD;
  SY2REC.SY1STNBR = KL0VM001.SY1STNBR;
  SY2REC.SY2CLRID = KL0VM001.SY2CLRID;
  SY2REC.XDMCD = KL0VM001.XDMCD;
  ;
  KL0V934(); /* inquire on style/color row*/
  ;
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    set KL0VM001.SY2CLRID initialAttributes;
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      CLXREC.CLXERRF = "Y";
      converseLib.validationFailed(550);
      set KL0VM001.SY2CLRID cursor, modified, bold;
      /* SET CL0VM001.XDMCD CURSOR,MODIFIED,BRIGHT;future use.*/
    end
  end
  ;
  ;
  ;
end // end KL0VSCN

// retrieve factory/po defaults
Function KL0VSCO()
  ;
  CLXREC.CLXCPROC = "CL0VSCO";
  ;
  if (KL0VM001.XGPCD in YCCTBL.XGPCD)
    if (YCCTBL.XXXSTAT[sysVar.arrayIndex] == "A")
      if (KL0VM001.CL0VMFPO == 0)
        KL0VM001.CL0VMFPO = YCCTBL.YCCFTYPO[sysVar.arrayIndex];
        set KL0VM001.CL0VMFPO initialAttributes;
      end
      ;
      if (KL0VM001.FY1FCTYC == " ")
        KL0VM001.FY1FCTYC = YCCTBL.YCCFCTYC[sysVar.arrayIndex];
        set KL0VM001.FY1FCTYC initialAttributes;
      end
    else
      CLXREC.CLXERRF = "Y";
      converseLib.validationFailed(9); /* no default records exist*/
      set KL0VM001.CL0VMFPO cursor, modified, bold;
      set KL0VM001.FY1FCTYC cursor, modified, bold;
    end
  else
    CLXREC.CLXERRF = "Y";
    converseLib.validationFailed(9); /* no default records exist*/
    set KL0VM001.CL0VMFPO cursor, modified, bold;
    set KL0VM001.FY1FCTYC cursor, modified, bold;
  end
end // end KL0VSCO

// validate uom
Function KL0VSCP()
  ;
  ;
  CLXREC.CLXCPROC = "CL0VSCP";
  ;
  ;
  ;
   /* ***************************************/
  if (KL0VM001.XUMCD in XUMTBL.XUMCD)
    if (XUMTBL.XXXSTAT[sysVar.arrayIndex] == "A")
      set KL0VM001.XUMCD initialAttributes;
    else
      set KL0VM001.XUMCD cursor, bold;
      CLXREC.CLXERRF = "Y";
      converseLib.validationFailed(9); /* no records exist*/
    end
  else
    set KL0VM001.XUMCD cursor, bold;
    CLXREC.CLXERRF = "Y";
    converseLib.validationFailed(9); /* no records exist*/
  end
  ;
   /* ***************************************/
  ;
end // end KL0VSCP

// validate no return reason code
Function KL0VSCQ()
  ;
  ;
  CLXREC.CLXCPROC = "CL0VSCQ";
  ;
  ;
  if (KL0VM001.YDRCD in YDRTBL.YDRCD)
    if (YDRTBL.XXXSTAT == "A")
      set KL0VM001.YDRCD initialAttributes;
    else
      CLXREC.CLXERRF = "Y";
      set KL0VM001.YDRCD cursor, bold;
      converseLib.validationFailed(9); /* no records exists*/
    end
  else
    CLXREC.CLXERRF = "Y";
    set KL0VM001.YDRCD cursor, bold;
    converseLib.validationFailed(9); /* no records exists*/
    /* error message, this is a required field*/
  end
  ;
  ;
  ;
end // end KL0VSCQ

// set-up prod. price retrievel.
Function KL0VSCR()
  ;
         /* * * ********************************* * **/
       /* *                                           **/
     /* *           keep similar to cl0lsps             **/
       /* *                                           **/
         /* * * ********************************* * **/
  ;
  ;
     /* *****************************************************/
     /* get product price using same method as orders, op0i.*/
     /* also consider the invoice special pricing table,iverec.*/
     /* if price is done by size, then use the first valid size*/
     /* as the product price.  a price varies flag will be*/
     /* set when size prices differ within a product*/
     /* *****************************************************/
  ;
  CLXREC.CLXCPROC = "CL0VSCR";
  ;
  if (CLXREC.CLXERRF == "Y") /* if have style/color record*/
    return;
  else
    /* next sentence*/
  end
  ;
  ;
      /* *******************************************************/
      /* * if sales pgm has product pricing (clarec.sp1id = y)*/
      /* *   then use it*/
      /* * else*/
      /* *   use invoice speciality table, iverec,*/
      /* *     price/cost indicator to access either:*/
      /* *     product price table sy5rec*/
      /* *     or*/
      /* *     product cost table sy6rec*/
      /* **/
      /* *    if product price-size code = z:*/
      /* *      read price/cost default for style,color,size*/
      /* *      use price/cost directly into valid size on prodct*/
      /* *    else*/
      /* *      if color default price/cost ne 0*/
      /* *        use it*/
      /* *      else*/
      /* *        use style default price/cost.*/
      /* *******************************************************/
  ;
      /* get sales pgm prices - or -*/
      /* get style and style/color price/cost defaults to use*/
      /* when there is no price by size for the product*/
  ;
  CL0VW01.CLKCLPRC = 0; /* init result field*/
  ;
  if (IVEREC.IVEPCIND == "P") /* invc specl codes from cl0l001*/
    KL0VSCS(); /* product price defaults*/
  else
    if (IVEREC.IVEPCIND == "C")
      KL0VSCT(); /* product cost defaults*/
    end
     /* note ivepcind may be blank, if not found in cl0l001*/
  end
  ;
   /* use product price, if any*/
   /* don't bother with trying to get price by size,*/
   /* this becomes too confusing, since need to first*/
   /* decide what sizes are valid.  then which size price*/
   /* would we choose to use?*/
  ;
   /* SET TOTAL ADJUST TO PRICE/COST, USING INVC SPECIAL TABLE*/
  CL0VW01.CL0VWPCP = IVEREC.IVEPCPCT + 100;
  ;
   /* style/color defaults were set above*/
  if (CL0VW01.CL0VWCLP != 0)
     /* use color default price/cost*/
    CL0VW01.CLKCLPRC = CL0VWCLP * CL0VWPCP / 100;
  else
     /* use style default price/cost*/
    CL0VW01.CLKCLPRC = CL0VWSTP * CL0VWPCP / 100;
  end
  ;
  KL0VM001.CLKCLPRC = CL0VW01.CLKCLPRC;
  ;
  ;
end // end KL0VSCR

// prod price style/color dflts
Function KL0VSCS()
      /* *******************************************************/
      /* * read db2 price by style or style & color for defaults*/
      /* **/
      /* * first - if price-size code = s or c or z (any):*/
      /* * _ read price default for style (all colors,dims,sizes)*/
      /* * - hold price in cl0lwstp (style price)*/
      /* **/
      /* * second - if price-size code = c or z:*/
      /* *  - read price deflt for style & color & dim(all sizes)*/
      /* *  - hold price in cl0lwclp (color price)*/
      /* **/
      /* * sgrp done from cl0lspp, with cl0lw02(cl0lwinx)*/
      /* *            and cl0lsps, with cl0lw02(cl0lwcax)*/
   /* * Maintenance Log: ****************************************/
   /* *  2-15-91 bcourt rename SY5PRCFL to XQACD.*/
   /* **/
   /* ***********************************************************/
  ;
  CLXREC.CLXCPROC = "CL0VSCS";
  ;
  CL0VW01.CL0VWSTP = 0; /* zero price defaults*/
  CL0VW01.CL0VWCLP = 0;
  CL0VW01.CL0VWPEF = "N";
  ;
  ;
      /* *****************************/
      /* * get style price record*/
      /* *****************************/
  ;
  ;
  SY5REC.XGPCD = CLAREC.XGPCD; /* general prod.class*/
  ;
  SY5REC.SY1STNBR = KL0VM001.SY1STNBR; /* style*/
  SY5REC.SY2CLRID = KL0VM001.SY2CLRID; /* color*/
  if (KL0VM001.XDMCD == " ")
    SY5REC.XDMCD = "00"; /* dimension*/
  else
    SY5REC.XDMCD = KL0VM001.XDMCD; /* dimension*/
  end
  ;
  SY5REC.SY5SZID = 0; /* default size id*/
  ;
  SY5REC.XPYCD = IVEREC.IVEPCTYP; /* price type code*/
  SY5REC.XQACD = "01"; /* this is hard coded because; 2/91*/
             /* ; only first quality are allowed to be returned*/
  ;
  KL0V944(); /* select unique from sy5rec*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0) /* check for good return*/
     /* find current price among 6 possible prices*/
     /* new/future date is first, oldest date is last*/
     /* price effective date is today*/
    sysVar.arrayIndex = 1; /* check dates ascending seq*/
    while (sysVar.arrayIndex < 7)
      if (SY5REC.SY5PCEDT[sysVar.arrayIndex] <= CLXREC.XXXCDTE) /* price effective date*/
        CL0VW01.CL0VWSTP = SY5REC.SY5PRCUN[sysVar.arrayIndex]; /* hold style price*/
        sysVar.arrayIndex = 9; /* force loop end*/
      end
      sysVar.arrayIndex = sysVar.arrayIndex + 1;
    end
    return;
  else
    if (SQLCA.VAGen_SQLCODE == 100) /* if price record not found,*/
       /* next sentence*/
    end
  end
  ;
  ;
      /* ******************************/
      /* * check if need second read*/
      /* ******************************/
  ;
   /* IF SYCREC.SY1PRCZS EQ 'C' ; if have price by color or size*/
    /* OR SYCREC.SY1PRCZS EQ 'Z';   get second default*/
    /* ;next sentence*/
   /* ELSE                      ; else use only style default*/
    /* EZERTN;*/
   /* END ;*/
  ;
  ;
      /* *******************************************/
      /* * get style/color/dimension price record*/
      /* *******************************************/
  ;
     /* other sy5rec key data moved above*/
  ;
   /* style default price has these defaults in the key*/
  SY5REC.SY2CLRID = "***"; /* color code*/
  SY5REC.XDMCD = "**"; /* default dimension*/
  SY5REC.SY5SZID = 0; /* default size id*/
  ;
  ;
  KL0V944(); /* select unique from sy5rec*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0) /* check for good return*/
    /* GET OP0IS28*/
     /* find current price among 6 possible prices*/
     /* new/future date is first, oldest date is last*/
     /* price effective date is today*/
    sysVar.arrayIndex = 1; /* check dates ascending seq*/
    while (sysVar.arrayIndex < 7)
      if (SY5REC.SY5PCEDT[sysVar.arrayIndex] <= CLXREC.XXXCDTE) /* price effective date*/
        CL0VW01.CL0VWCLP = SY5REC.SY5PRCUN[sysVar.arrayIndex]; /* hold color price*/
        sysVar.arrayIndex = 9; /* force loop end*/
      end
      sysVar.arrayIndex = sysVar.arrayIndex + 1;
    end
    return;
  else
    if (SQLCA.VAGen_SQLCODE == 100) /* price not found*/
      CLXREC.CLXERRF = "Y";
      CL0VW01.CL0VWPEF = "Y"; /* price error*/
      converseLib.validationFailed(374); /* price record not found...must enter*/
      set KL0VM001.CLKCLPRC cursor, modified, bold;
      CL0VW01.CL0VWCLP = 0; /* forces price = 0*/
    end
  end
  ;
  ;
  ;
end // end KL0VSCS

// prod cost style/color dflts
Function KL0VSCT()
      /* *******************************************************/
      /* * read db2 cost by style or style & color for defaults*/
      /* **/
      /* * first - if price-size code = s or c or z (any):*/
      /* * _ read cost default for style (all colors,dims,sizes)*/
      /* * - hold cost in cl0lwstp (style price)*/
      /* **/
      /* * second - if price-size code = c or z:*/
      /* *  - read cost deflt for style & color & dim(all sizes)*/
      /* *  - hold cost in cl0lwclp (color price)*/
      /* **/
      /* * executed from cl0lspp, with cl0lw02(cl0lwinx)*/
      /* *           and cl0lsps, with cl0lw02(cl0lwcax)*/
      /* **/
   /* ** Maintenance Log *************************************/
   /* 03-11-94  BCourt  Rename sy6cstfl to xqacd.          **/
   /* Add defaults for country & currency.     **/
   /* ********************************************************/
  ;
  CLXREC.CLXCPROC = "CL0VSCT";
  ;
  CL0VW01.CL0VWSTP = 0; /* zero price defaults*/
  CL0VW01.CL0VWCLP = 0;
  ;
  ;
      /* *****************************/
      /* * get style price record*/
      /* *****************************/
  ;
  SY6REC.XGPCD = CLAREC.XGPCD; /* general prod.class*/
  SY6REC.SY1STNBR = KL0VM001.SY1STNBR; /* style*/
  SY6REC.SY2CLRID = KL0VM001.SY2CLRID; /* color*/
  SY6REC.XDMCD = KL0VM001.XDMCD; /* dimension*/
  ;
  ;
  SY6REC.XCOCD = IVEREC.IVEPCTYP; /* cost type code*/
  ;
  SY6REC.XQACD = "01"; /* default to 01 because only first*/
                              /* quality are returned /*3-11-94 rename*/
  SY6REC.XCT-CTRY-CD = "USA"; /* 3-11-94 add country*/
  SY6REC.ZFC-CRCY-CD = "USD"; /* 3-11-94 add currency*/
  ;
  KL0V954(); /* select unique from sy6rec*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0) /* check for good return*/
     /* find current cost among 6 possible costs*/
     /* new/future date is first, oldest date is last*/
     /* price effective date is today*/
    sysVar.arrayIndex = 1; /* check dates ascending seq*/
    while (sysVar.arrayIndex < 7)
      if (SY6REC.SY6CSEDT[sysVar.arrayIndex] <= CLXREC.XXXCDTE) /* price effective date*/
        CL0VW01.CL0VWSTP = SY6REC.SY6CSTUN[sysVar.arrayIndex]; /* hold style price*/
        sysVar.arrayIndex = 9; /* force loop end*/
      end
      sysVar.arrayIndex = sysVar.arrayIndex + 1;
    end
    return;
  else
    if (SQLCA.VAGen_SQLCODE == 100) /* if price record not found,*/
      /* next sentence*/
    end
  end
  ;
  ;
      /* ******************************/
      /* * check if need second read*/
      /* ******************************/
  ;
   /* IF SYCREC.SY1PRCZS EQ 'C'  ; if have price by color or size*/
    /* OR SYCREC.SY1PRCZS EQ 'Z' ;   get second default*/
    /* ;next sentence*/
   /* ELSE                       ; else use only style default*/
    /* EZERTN;*/
   /* END ;*/
  ;
  ;
      /* *******************************************/
      /* * get style/color/dimension cost record*/
      /* *******************************************/
  ;
     /* other sy6rec key data moved above*/
  ;
   /* style default price has these defaults in the key*/
  SY6REC.SY2CLRID = "***"; /* default color code*/
  SY6REC.XDMCD = "**"; /* default dimension*/
  ;
  KL0V954(); /* select unique from sy6rec*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0) /* check for good return*/
     /* find current cost among 6 possible costs*/
     /* new/future date is first, oldest date is last*/
     /* price effective date is today*/
    sysVar.arrayIndex = 1; /* check dates ascending seq*/
    while (sysVar.arrayIndex < 7)
      if (SY6REC.SY6CSEDT[sysVar.arrayIndex] <= CLXREC.XXXCDTE) /* price effective date*/
        CL0VW01.CL0VWCLP = SY6REC.SY6CSTUN[sysVar.arrayIndex]; /* hold color price*/
        sysVar.arrayIndex = 9; /* force loop end*/
      end
      sysVar.arrayIndex = sysVar.arrayIndex + 1;
    end
    ;
  else
    if (SQLCA.VAGen_SQLCODE == 100) /* price not found*/
      CLXREC.CLXERRF = "Y";
      CL0VW01.CL0VWPEF = "Y"; /* price error*/
      converseLib.validationFailed(358); /* cost record not found...must enter*/
      set KL0VM001.CLKCLPRC cursor, modified, bold;
      CL0VW01.CL0VWCLP = 0; /* forces price = 0*/
    end
  end
  ;
  ;
  ;
  ;
end // end KL0VSCT

// add defective detail
Function KL0VSDA()
  ;
  ;
  CLXREC.CLXCPROC = "CL0VSDA";
  ;
  ;
  set CLPREC empty;
  ;
  if (KL0VM001.CLGCOMNT is modified)
    if (KL0VM001.CLGCOMNT != " ")
      CLPREC.CL-CLCOM-FL = "Y";
      KL0VSDC(); /* add comment table*/
    else
      /* delete record from comment table*/
    end
  else
    /* next sentence*/
  end
  ;
  ;
  CLPREC.CLACLMNB = KL0VM001.CLACLMNB;
  CLPREC.CLHSEQNB = KL0VM001.CLHSEQNB;
  CLPREC.CL2ISNBR = CLAREC.CLACISNB;
  CLPREC.XGPCD = KL0VM001.XGPCD;
  CLPREC.SY1STNBR = KL0VM001.SY1STNBR;
  CLPREC.SY2CLRID = KL0VM001.SY2CLRID;
  CLPREC.XDMCD = KL0VM001.XDMCD;
  CLPREC.YDDCD = KL0VM001.YDDCD;
  CLPREC.XUMCD = KL0VM001.XUMCD;
  CLPREC.FY1FCTYC = CL0VW01.FY1FCTYC;
  ;
   /* PO Date conversion added 06-14-90*/
  if (KL0VM001.CL0VMFPO != 0)
    CLXREC.XXXWYMD = KL0VM001.CL0VMFPO;
    if (CLXREC.XXXWYY < 50)
      CLXREC.XXXWCC = 20;
    else
      CLXREC.XXXWCC = 19;
    end
    CLPREC.PC3POIDT = CLXREC.XXXWCYMD;
  else
    CLPREC.PC3POIDT = 0;
  end
  ;
  CLPREC.CLPCRTNB = KL0VM001.CLPCRTNB;
  CLPREC.YDFCD = KL0VM001.YDFCD;
  CLPREC.CLKCLPRC = KL0VM001.CLKCLPRC;
  CLPREC.CLPDEFQ = KL0VM001.CLPDEFQ;
  CLPREC.CLNNCRQ = KL0VM001.CLPRTCTQ + KL0VM001.CL0VWNRQ;
  CLPREC.YDRCD = KL0VM001.YDRCD;
  CLPREC.CLPRTCTQ = KL0VM001.CLPRTCTQ;
  ;
  CLPREC.CLKPRCFF = CL0VW01.CLKPRCFF;
  CLPREC.CLPVLDFL = CL0VW01.CLPVLDFL;
  CLPREC.CLGCMSEQ = CL0VW01.CLGCMSEQ;
  CLPREC.XQACD = "01";
  ;
  CLPREC.ZZZCHGDT = TA2REC.TA2GRGGN;
  CLPREC.ZZZCHGTM = TA2REC.TA2TIMHM;
  ;
  ;
  KL0V896(); /* add defective detail*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    /* next setence*/
  else
    if (SQLCA.VAGen_SQLCODE == -911)
      CLXREC.CLXERRF = "Y";
      converseLib.validationFailed(4); /* database is busy*/
    end
  end
  ;
  ;
end // end KL0VSDA

// update defective detail
Function KL0VSDB()
  ;
  CLXREC.CLXCPROC = "CL0VSDB";
  ;
  CLPREC.CLACLMNB = KL0VM001.CLACLMNB;
  CLPREC.CLHSEQNB = KL0VM001.CLHSEQNB;
  CLPREC.CL2ISNBR = CLAREC.CLACISNB;
  CLPREC.XGPCD = KL0VM001.XGPCD;
  CLPREC.SY1STNBR = KL0VM001.SY1STNBR;
  CLPREC.SY2CLRID = KL0VM001.SY2CLRID;
  CLPREC.XDMCD = KL0VM001.XDMCD;
  CLPREC.YDDCD = KL0VM001.YDDCD;
  CLPREC.XUMCD = KL0VM001.XUMCD;
  CLPREC.XQACD = KL0VM001.XQACD;
  CLPREC.FY1FCTYC = CL0VW01.FY1FCTYC;
  ;
   /* added 06-14-90*/
  if (KL0VM001.CL0VMFPO != 0)
    CLXREC.XXXWYMD = KL0VM001.CL0VMFPO;
    if (CLXREC.XXXWYY < 50)
      CLXREC.XXXWCC = 20;
    else
      CLXREC.XXXWCC = 19;
    end
    CLPREC.PC3POIDT = CLXREC.XXXWCYMD;
  else
    CLPREC.PC3POIDT = 0;
  end
  ;
  CLPREC.CLPCRTNB = KL0VM001.CLPCRTNB;
  CLPREC.YDFCD = KL0VM001.YDFCD;
  CLPREC.CLKCLPRC = KL0VM001.CLKCLPRC;
  CLPREC.YDRCD = KL0VM001.YDRCD;
  ;
  CLPREC.CLKPRCFF = CL0VW01.CLKPRCFF;
  CLPREC.CLPVLDFL = CL0VW01.CLPVLDFL;
  ;
  CLPREC.ZZZCHGDT = TA2REC.TA2GRGGN;
  CLPREC.ZZZCHGTM = TA2REC.TA2TIMHM;
  CLPREC.XQACD = "01";
  ;
  if (KL0VM001.CLGCOMNT is modified)
    if (KL0VM001.CLGCOMNT != " ")
      CLPREC.CL-CLCOM-FL = "Y";
      KL0VSDC(); /* add/update comment table*/
      CLPREC.CLGCMSEQ = CL0VW01.CLGCMSEQ;
    else
      /* next sentence*/
    end
  else
    /* next sentence*/
  end
  ;
  KL0V894(); /* select uniqe form clprec*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == -100)
      CLXREC.CLXERRF = "Y";
      converseLib.validationFailed(18);
      return;
    else
      if (SQLCA.VAGen_SQLCODE == -911)
        CLXREC.CLXERRF = "Y";
        converseLib.validationFailed(4);
        return;
      end
    end
  end
  ;
  ;
  CLPREC.CLPDEFQ = CLPREC.CLPDEFQ + KL0VM001.CLPDEFQ; /* defective cr qty*/
  CLPREC.CLNNCRQ = CLPREC.CLNNCRQ + KL0VM001.CLPRTCTQ + KL0VM001.CL0VWNRQ;
  CLPREC.CLPRTCTQ = CLPREC.CLPRTCTQ + KL0VM001.CLPRTCTQ; /* noncredit rtn*/
  ;
  KL0V897(); /* replace defective detail*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    if (CLXREC.CLXARAYX > 0)
      ;
       /* move changed fields into array to be shown on summary scrn*/
      ;
      CL0VW02.CL0VWDFQ[CLXARAYX] = KL0VM001.CLPRTCTQ + KL0VM001.CL0VWNRQ;
      CL0VW02.CL0VWDFQ[CLXARAYX] = CL0VW02.CL0VWDFQ + KL0VM001.CLPDEFQ;
      CL0VW02.CLPDEFQ[CLXARAYX] = KL0VM001.CLPDEFQ;
      CL0VW02.YDRCD[CLXARAYX] = KL0VM001.YDRCD;
      CL0VW02.CLNNCRQ[CLXARAYX] = CLPREC.CLNNCRQ;
      CL0VW02.CLPRTCTQ[CLXARAYX] = KL0VM001.CLPRTCTQ;
      CL0VW02.CLNNCRQ[CLXARAYX] = CLPREC.CLNNCRQ - KL0VM001.CLPRTCTQ;
    end
  end
  ;
  ;
end // end KL0VSDB

// set-up add def. detail comment
Function KL0VSDC()
  ;
  ;
  CLXREC.CLXCPROC = "CL0VSDC";
  ;
   /* update the comment table*/
  CLGREC.CLACLMNB = KL0VM001.CLACLMNB;
  CLGREC.CLHSEQNB = KL0VM001.CLHSEQNB;
  CLGREC.CLGCMTYP = "D";
   /* MOVE CL0VM001.XGPCD TO CLGREC.XGPCD;*/
   /* MOVE CL0VM001.SY1STNBR TO CLGREC.SY1STNBR;*/
   /* MOVE CL0VM001.SY2CLRID TO CLGREC.SY2CLRID;*/
   /* MOVE CL0VM001.XDMCD TO CLGREC.XDMCD;*/
   /* MOVE ' ' TO CLGREC.GLCD;*/
   /* MOVE ' ' TO CLGREC.CLICRDFL;*/
  ;
  KL0V961(); /* select set on clgrec*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    CL0VW01.CL0VWCFL = "N";
    CL0VW01.CLGCMSEQ = 0;
    while (SQLCA.VAGen_SQLCODE == 0
     && CL0VW01.CL0VWCFL == "N")
      KL0VSDI(); /* add  comment line.*/
    end
  end
  ;
  KL0V963(); /* close cursor for clgrec*/
end // end KL0VSDC

// fetch    comment line
Function KL0VSDI()
  ;
  ;
  CLXREC.CLXCPROC = "CL0VSDI";
  ;
  KL0V962(); /* fetch defective header.*/
  ;
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      CL0VW01.CLGCMSEQ = CLGREC.CLGCMSEQ + 1;
      KL0VSDJ(); /* add comment line.*/
    end
  end
  ;
  ;
  ;
end // end KL0VSDI

// add def detail comment line
Function KL0VSDJ()
  ;
  ;
  CLXREC.CLXCPROC = "CL0VSDJ";
  ;
  ;
  set CLGREC empty;
  ;
   /* add to the comment table*/
  CLGREC.CLACLMNB = KL0VM001.CLACLMNB;
  CLGREC.CLHSEQNB = KL0VM001.CLHSEQNB;
  CLGREC.CL2ISNBR = 0;
  CLGREC.CLGCMTYP = "D";
  CLGREC.ZZZCHGDT = TA2REC.TA2GRGGN;
  CLGREC.ZZZCHGTM = TA2REC.TA2TIMHM;
  ;
  CLGREC.CLGCMSEQ = CL0VW01.CLGCMSEQ;
  ;
  CLGREC.CLGCOMNT = KL0VM001.CLGCOMNT;
  ;
  KL0V966(); /* add clgrec*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    CL0VW01.CL0VWCFL = "Y"; /* added comment flag successfully*/
    CL0VW02.CLGCMSEQ[CLXARAYX] = CLGREC.CLGCMSEQ;
  else
    if (SQLCA.VAGen_SQLCODE == -911)
      CLXREC.CLXERRF = "Y";
      converseLib.validationFailed(4);
    end
  end
  ;
  ;
end // end KL0VSDJ

// select 200 defective recs.
Function KL0VSFA()
  ;
  CLXREC.CLXCPROC = "CL0VSFA";
  ;
  set CL0VW02 empty;
  set CLPREC empty;
  CLPREC.CLACLMNB = KL0VM005.CLACLMNB;
  CLPREC.CLHSEQNB = KL0VM005.CLHSEQNB;
  CLPREC.CL2ISNBR = CLAREC.CLACISNB;
  CLPREC.XGPCD = "**";
  CLPREC.SY1STNBR = "******";
  CLPREC.SY2CLRID = "***";
  CLPREC.XDMCD = "**";
  CLPREC.XUMCD = "**"; /* 10-04-90*/
  CLPREC.XQACD = "**"; /* 10-04-90*/
  CLXREC.CLXARAYX = 0;
  ;
  KL0V891(); /* select set from clprec*/
  CL0VW06.CL0VWSQL = "N1"; /* sql selection for fetch stmt*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    while (SQLCA.VAGen_SQLCODE == 0
     && CLXREC.CLXARAYX < CL0VW01.CL0VWMXL) /* index less than 499*/
      KL0VSFB(); /* process all fetched records.*/
    end
    CL0VW01.CL0VWMNB = CLXREC.CLXARAYX; /* total items selected*/
    CLXREC.CLXARAYX = CLXREC.CLXARAYX + 1;
    CL0VW02.CL0VWDFQ[CLXARAYX] = CLOREC.CLOTDFQY + CLOREC.CLMTNCRQ;
    CL0VW02.CLPDEFQ[CLXARAYX] = CLOREC.CLOTDFQY;
    CL0VW02.CLNNCRQ[CLXARAYX] = CLOREC.CLMTNCRQ;
    CL0VW02.CLPRTCTQ[CLXARAYX] = CLOREC.CLOTRCQY;
    CL0VW02.CL0VWNRQ[CLXARAYX] = CLOREC.CLMTNCRQ - CLOREC.CLOTRCQY;
    CL0VW02.SY1STNBR[CLXARAYX] = "TOTALS";
    CLXREC.CLXLSTAX = CLXREC.CLXARAYX; /* last filled array row*/
  else
    if (SQLCA.VAGen_SQLCODE == -911)
      KL0V893(); /* close cursor for clprec*/
      CLXREC.CLXERRF = "Y";
      converseLib.validationFailed(4);
      return;
    end
  end
  ;
  KL0V893(); /* close cursor for clprec*/
  ;
  ;
  if (CLXREC.CLXERRF == "N")
    CLXREC.CLXARAYX = 1; /* array counter*/
    CLXREC.CLXCURLN = 1; /* current map line*/
    CLXREC.CLXMAPMX = 1; /* total number of lines on map*/
    ;
    KL0VSFF(); /* move header data from cl0vw01 to cl0vm005*/
    ;
    CL0VW01.CL0VWMSG = " LINES AVAILABLE FOR SELECTION ";
    KL0VM005.VAGen_EZEMSG = CL0VW01.CL0VWMGT;
    ;
    while (CLXREC.CLXCURLN <= 10)
         /* AND CL0VW02.CLPDEFQ(CLXARAYX) GT 0;*/
      KL0VSFD(); /* move cl0vw02 rec to 1st map*/
    end
  end
  ;
end // end KL0VSFA

// retrieve selected def. detail
Function KL0VSFB()
  ;
  ;
  CLXREC.CLXCPROC = "CL0VSFB";
  ;
  ;
  ;
  KL0V792(); /* fetch defective detail rec.*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    CLXREC.CLXARAYX = CLXREC.CLXARAYX + 1;
    KL0VSFC(); /* move fetched record to cl0vw01 rec.*/
    ;
     /* need to save very first record read from database*/
     /* to give different error messages when beginning of*/
     /* of array is reached with pf7s.*/
    ;
    if (CL0VW01.CL0VWHST == " "
     && CL0VW01.CL0VWHCL == " "
     && CL0VW01.CL0VWHDM == " ")
      CL0VW01.CL0VWHST = CLPREC.SY1STNBR;
      CL0VW01.CL0VWHCL = CLPREC.SY2CLRID;
      CL0VW01.CL0VWHDM = CLPREC.XDMCD;
    end
    ;
    if (CLXREC.CLXARAYX == 200)
       /* ve up message to say max. rec. limit*/
      /* move clprec key data to aray*/
    end
  end
  ;
  ;
  ;
end // end KL0VSFB

// move def. detail to cl0vw02rec
Function KL0VSFC()
   /* *************************************************************/
    /* Move DEF detail to CL0VW02 rec.*/
  ;
   /* 10-04-90 CHELLM Added XQACD.*/
   /* 04-13-92 twatso changed  clacmind to cl-clcom-fl*/
  ;
   /* *************************************************************/
  CLXREC.CLXCPROC = "CL0VSFC";
  ;
  ;
  CL0VW02.SY1STNBR[CLXARAYX] = CLPREC.SY1STNBR;
  CL0VW02.SY2CLRID[CLXARAYX] = CLPREC.SY2CLRID;
  CL0VW02.XDMCD[CLXARAYX] = CLPREC.XDMCD;
  CL0VW02.YDDCD[CLXARAYX] = CLPREC.YDDCD;
  CL0VW02.XUMCD[CLXARAYX] = CLPREC.XUMCD;
  CL0VW02.XQACD[CLXARAYX] = CLPREC.XQACD; /* 09-13-90*/
  CL0VW02.CLKCLPRC[CLXARAYX] = CLPREC.CLKCLPRC;
  CL0VW02.CLKPRCFF[CLXARAYX] = CLPREC.CLKPRCFF;
  CL0VW02.FY1FCTYC[CLXARAYX] = CLPREC.FY1FCTYC;
  CL0VW02.PC3POIDT[CLXARAYX] = CLPREC.PC3POIDT;
  CL0VW02.CLPVLDFL[CLXARAYX] = CLPREC.CLPVLDFL;
  CL0VW02.CLPCRTNB[CLXARAYX] = CLPREC.CLPCRTNB;
  CL0VW02.YDFCD[CLXARAYX] = CLPREC.YDFCD;
  CL0VW02.CL0VWDFQ[CLXARAYX] = CLPREC.CLPDEFQ + CLPREC.CLNNCRQ;
  CL0VW02.CLPDEFQ[CLXARAYX] = CLPREC.CLPDEFQ;
  CL0VW02.YDRCD[CLXARAYX] = CLPREC.YDRCD;
  CL0VW02.CLNNCRQ[CLXARAYX] = CLPREC.CLNNCRQ;
  CL0VW02.CLPRTCTQ[CLXARAYX] = CLPREC.CLPRTCTQ;
  CL0VW02.CL0VWNRQ[CLXARAYX] = CLPREC.CLNNCRQ - CLPREC.CLPRTCTQ;
  CL0VW02.CL-CLCOM-FL[CLXARAYX] = CLPREC.CL-CLCOM-FL;
  CL0VW02.CLGCMSEQ[CLXARAYX] = CLPREC.CLGCMSEQ;
  CL0VW02.ZZZCHGDT[CLXARAYX] = CLPREC.ZZZCHGDT;
  CL0VW02.ZZZCHGTM[CLXARAYX] = CLPREC.ZZZCHGTM;
  CL0VW02.ZZZCHGCT[CLXARAYX] = CLPREC.ZZZCHGCT;
  ;
end // end KL0VSFC

// move cl0vw02 to cl0vm005
Function KL0VSFD()
  ;
   /* GET MHIST*/
   /* *********************************************************************/
    /* Maintenance History:*/
   /* 02-22-90 CHELLM Renamed PD1.. items as FY1.. items.*/
   /* 04-13-92 twatso db2 changes - clacmind = cl-clcom-fl*/
  ;
   /* *********************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0VSFD";
  ;
  ;
  if (CLXREC.CLXARAYX <= CL0VW01.CL0VWMX) /* less than or = 500*/
    if (CL0VW02.SY1STNBR[CLXARAYX] > " ")
      if (CL0VW02.SY1STNBR[CLXARAYX] == "TOTALS")
        set KL0VM005.CL0VMSEL[CLXMAPMX] skip, invisible;
        set KL0VM005.CL0VMFPO[CLXMAPMX] skip, invisible;
      else
        set KL0VM005.CL0VMSEL[CLXMAPMX] normal;
        set KL0VM005.CL0VMFPO[CLXMAPMX] initialAttributes;
      end
    else
      set KL0VM005.CL0VMSEL[CLXMAPMX] skip, invisible;
      set KL0VM005.CL0VMFPO[CLXMAPMX] skip, invisible;
    end
    ;
    KL0VM005.CL0VMSEL[CLXMAPMX] = CL0VW02.CL0VMSEL[CLXARAYX];
    KL0VM005.SY1STNBR[CLXMAPMX] = CL0VW02.SY1STNBR[CLXARAYX];
    KL0VM005.SY2CLRID[CLXMAPMX] = CL0VW02.SY2CLRID[CLXARAYX];
    KL0VM005.XDMCD[CLXMAPMX] = CL0VW02.XDMCD[CLXARAYX];
    KL0VM005.YDDCD[CLXMAPMX] = CL0VW02.YDDCD[CLXARAYX];
    KL0VM005.XUMCD[CLXMAPMX] = CL0VW02.XUMCD[CLXARAYX];
    /* IF CL0VW02.FY1FCTYC(CLXARAYX) IN CL0VW03.FY1FCTYC;*/
    /* MOVE CL0VW03.FY1FTYNO(EZETST) TO CL0VM005.FY1FCTYC(CLXMAPMX)*/
    /* ELSE ;*/
    KL0VM005.FY1FCTYC[CLXMAPMX] = CL0VW02.FY1FCTYC[CLXARAYX];
    /* END ;*/
    ;
    CLXREC.XXXWCYMD = CL0VW02.PC3POIDT[CLXARAYX];
    KL0VM005.CL0VMFPO[CLXMAPMX] = CLXREC.XXXWYMD;
    ;
    KL0VM005.CLPCRTNB[CLXMAPMX] = CL0VW02.CLPCRTNB[CLXARAYX];
    KL0VM005.YDFCD[CLXMAPMX] = CL0VW02.YDFCD[CLXARAYX];
    KL0VM005.CL0VWDFQ[CLXMAPMX] = CL0VW02.CL0VWDFQ[CLXARAYX];
    KL0VM005.CLPDEFQ[CLXMAPMX] = CL0VW02.CLPDEFQ[CLXARAYX];
    KL0VM005.CLPRTCTQ[CLXMAPMX] = CL0VW02.CLPRTCTQ[CLXARAYX];
    KL0VM005.CL0VWNRQ[CLXMAPMX] = CL0VW02.CL0VWNRQ[CLXARAYX];
    KL0VM005.YDRCD[CLXMAPMX] = CL0VW02.YDRCD[CLXARAYX];
    KL0VM005.CL-CLCOM-FL[CLXMAPMX] = CL0VW02.CL-CLCOM-FL[CLXARAYX];
  else
    KL0VM005.CL0VMSEL[CLXMAPMX] = " ";
    KL0VM005.SY1STNBR[CLXMAPMX] = " ";
    KL0VM005.SY2CLRID[CLXMAPMX] = " ";
    KL0VM005.XDMCD[CLXMAPMX] = " ";
    KL0VM005.YDDCD[CLXMAPMX] = " ";
    KL0VM005.XUMCD[CLXMAPMX] = " ";
    KL0VM005.FY1FCTYC[CLXMAPMX] = " ";
    KL0VM005.CL0VMFPO[CLXMAPMX] = " ";
    set KL0VM005.CL0VMSEL[CLXMAPMX] skip, invisible;
    set KL0VM005.SY1STNBR[CLXMAPMX] skip, invisible;
    set KL0VM005.SY2CLRID[CLXMAPMX] skip, invisible;
    set KL0VM005.XDMCD[CLXMAPMX] skip, invisible;
    set KL0VM005.YDDCD[CLXMAPMX] skip, invisible;
    set KL0VM005.XUMCD[CLXMAPMX] skip, invisible;
    set KL0VM005.FY1FCTYC[CLXMAPMX] skip, invisible;
    set KL0VM005.CL0VMFPO[CLXMAPMX] skip, invisible;
    set KL0VM005.CLPCRTNB[CLXMAPMX] skip, invisible;
    set KL0VM005.YDFCD[CLXMAPMX] skip, invisible;
    set KL0VM005.CL0VWDFQ[CLXMAPMX] skip, invisible;
    set KL0VM005.CLPDEFQ[CLXMAPMX] skip, invisible;
    set KL0VM005.CLPRTCTQ[CLXMAPMX] skip, invisible;
    set KL0VM005.CL0VWNRQ[CLXMAPMX] skip, invisible;
    set KL0VM005.YDRCD[CLXMAPMX] skip, invisible;
    set KL0VM005.CL-CLCOM-FL[CLXMAPMX] skip, invisible;
  end
  ;
  CLXREC.CLXARAYX = CLXREC.CLXARAYX + 1;
  CLXREC.CLXMAPMX = CLXREC.CLXMAPMX + 1;
  CLXREC.CLXCURLN = CLXREC.CLXCURLN + 1;
  ;
  ;
end // end KL0VSFD

// move cur. map data to cl0vw02
Function KL0VSFE()
  ;
  ;
  CLXREC.CLXCPROC = "CL0VSFE";
  ;
  ;
  CLXREC.CLXARAYX = CLXREC.CLXARAYX - CLXREC.CLXMAPMX + 1;
  if (CLXREC.CLXARAYX < 1)
    CLXREC.CLXARAYX = 1;
  else
    /* next sentence*/
  end
  ;
  CLXREC.CLXMAPMX = 1;
  CLXREC.CLXCURLN = 1;
  ;
  while (CLXREC.CLXCURLN <= 10)
    set KL0VM005.CL0VMSEL[CLXCURLN] initialAttributes;
    if (KL0VM005.CL0VMSEL[CLXCURLN] == " "
     || KL0VM005.CL0VMSEL[CLXCURLN] == "V")
      /* next sentence*/
    else
      if (KL0VM005.CL0VMSEL[CLXCURLN] == "S")
        if (KL0VM005.SY1STNBR[CLXCURLN] > " ")
          CL0VW02.CL0VMSEL[CLXARAYX] = KL0VM005.CL0VMSEL[CLXCURLN];
        else
          converseLib.validationFailed(372);
          CLXREC.CLXERRF = "Y";
          set KL0VM005.CL0VMSEL[CLXCURLN] cursor, bold;
        end
      else
        if (KL0VM005.CL0VMSEL[CLXCURLN] == "X")
          if (KL0VM005.SY1STNBR[CLXCURLN] > " ")
            if (CL0VW01.CL0VWUDF == "Y")
              CL0VW02.CL0VMSEL[CLXARAYX] = KL0VM005.CL0VMSEL[CLXCURLN];
            else
              set KL0VM005.CL0VMSEL[CLXCURLN] cursor, modified, bold;
              CLXREC.CLXERRF = "Y";
              converseLib.validationFailed(368); /* x is not valid in inquire mode*/
            end
          else
            converseLib.validationFailed(372);
            CLXREC.CLXERRF = "Y";
            set KL0VM005.CL0VMSEL[CLXCURLN] cursor, bold;
          end
        else
          set KL0VM005.CL0VMSEL[CLXCURLN] cursor, modified, bold;
          CLXREC.CLXERRF = "Y";
          converseLib.validationFailed(17); /* data is not valid*/
        end
      end
    end
    CLXREC.CLXARAYX = CLXREC.CLXARAYX + 1; /* array counter*/
    CLXREC.CLXMAPMX = CLXREC.CLXMAPMX + 1; /* number of lines on map*/
    CLXREC.CLXCURLN = CLXREC.CLXCURLN + 1; /* current map line*/
  end
  ;
  ;
end // end KL0VSFE

// move cl0vw01 to cl0vm005
Function KL0VSFF()
  ;
  ;
  CLXREC.CLXCPROC = "CL0VSFF";
  ;
  set KL0VM005 empty;
  ;
  KL0VM005.CLACLMNB = CL0VW01.CLACLMNB;
  KL0VM005.CLHSEQNB = CL0VW01.CLHSEQNB;
  KL0VM005.KUCCONM = CL0VW01.KUCCONM;
  KL0VM005.KUCCOID = CL0VW01.KUCCOID;
  KL0VM005.KUMSTRID = CL0VW01.KUMSTRID;
  KL0VM005.CLJTATHQ = CL0VW01.CLJTATHQ;
  KL0VM005.CLJNCRFL = CL0VW01.CLJNCRFL;
  KL0VM005.CLOFGAQ = CL0VW01.CLOFGAQ;
  KL0VM005.CLOFGAAM = CL0VW01.CLOFGAAM;
  KL0VM005.XXXUSRID = CL0VW01.XXXUSRID;
  KL0VM005.CL0VMIDT = CL0VW01.CL0VMIDT;
  KL0VM005.XNXCD = CL0VW01.XNXCD;
  KL0VM005.XGPCD = CL0VW01.XGPCD;
  KL0VM005.YCTCD = CL0VW01.YCTCD;
  KL0VM005.XWHCD = CL0VW01.XWHCD;
  KL0VM005.XWHABRV = CL0VW01.XWHABRV;
  KL0VM005.CLODMAMT = CL0VW01.CLODMAMT;
  KL0VM005.CLOTLRID = CL0VW01.CLOTLRID;
  KL0VM005.CL2ISXDT = CL0VW01.CL2ISXDT;
  ;
  ;
  ;
end // end KL0VSFF

// move 's' to all cl0vmsel field
Function KL0VSFG()
   /* ***************************************************/
   /* if the user selects 'a' for all records to be viewed*/
   /* we will put an 's' into all cl0vw02.cl0vmsel(clxarayx) line*/
   /* fields and then begin to display the line items one at a*/
   /* time.*/
   /* ***************************************************/
  ;
  CLXREC.CLXCPROC = "CL0VSFG";
  ;
  CLXREC.CLXARAYX = 1;
  ;
  while (CLXREC.CLXARAYX <= CLXREC.CLXLSTAX
   && CL0VW02.SY1STNBR[CLXARAYX] != " "
   && CL0VW02.SY1STNBR[CLXARAYX] != "TOTALS")
    CL0VW02.CL0VMSEL[CLXARAYX] = "S";
    if (CLXREC.CLXARAYX > 10)
      /* next sentence*/
    else
      KL0VM005.CL0VMSEL[CLXARAYX] = "S";
    end
    CLXREC.CLXARAYX = CLXREC.CLXARAYX + 1;
  end
  ;
  ;
  ;
end // end KL0VSFG

// setup for next 200 products
Function KL0VSFH()
   /* ****************************************************/
    /* the user may enter the style,color,dimension in the*/
    /* item screen field. there must be a space between each*/
    /* style,color,dimension. we then search through until*/
    /* the first space is found. after we identify the style*/
    /* color and dimension we will begin to read from the data*/
    /* base starting with style,color,dimension row the user*/
    /* entered.*/
   /* ****************************************************/
  ;
  ;
  CL0VW01.CL0VWGIT = KL0VM005.CAITEM;
  ;
  CLXREC.CLXITMX = 1;
  CLXREC.CLXLTRX1 = 1;
   /* revrive style number until 1st blank character.*/
  ;
  while (CL0VW01.CL0VWITM[CLXITMX] != " "
   && CLXREC.CLXLTRX1 < 7)
    CL0VW01.CL0VWSTY[CLXLTRX1] = CL0VW01.CL0VWITM[CLXITMX];
    CLXREC.CLXITMX = CLXREC.CLXITMX + 1;
    CLXREC.CLXLTRX1 = CLXREC.CLXLTRX1 + 1;
  end
  ;
  ;
  ;
  CLXREC.CLXLTRX1 = 1;
  CLXREC.CLXITMX = CLXREC.CLXITMX + 1;
  if (CL0VW01.CL0VWITM[CLXITMX] == " ")
    CL0VW01.CL0VWCLR[1] = "0";
    CL0VW01.CL0VWCLR[2] = "0";
    CL0VW01.CL0VWCLR[3] = "0";
  else
    while (CL0VW01.CL0VWITM[CLXITMX] != " "
     && CLXREC.CLXLTRX1 < 4)
      CL0VW01.CL0VWCLR[CLXLTRX1] = CL0VW01.CL0VWITM[CLXITMX];
      CLXREC.CLXITMX = CLXREC.CLXITMX + 1;
      CLXREC.CLXLTRX1 = CLXREC.CLXLTRX1 + 1;
    end
  end
  ;
  ;
  CLXREC.CLXLTRX1 = 1;
  CLXREC.CLXITMX = CLXREC.CLXITMX + 1;
  if (CL0VW01.CL0VWITM[CLXITMX] == " ")
    CL0VW01.CL0VWXDM[1] = "0";
    CL0VW01.CL0VWXDM[2] = "0";
  else
    while (CL0VW01.CL0VWITM[CLXITMX] != " "
     && CLXREC.CLXLTRX1 < 3)
      CL0VW01.CL0VWCLR[CLXLTRX1] = CL0VW01.CL0VWITM[CLXITMX];
      CLXREC.CLXITMX = CLXREC.CLXITMX + 1;
      CLXREC.CLXLTRX1 = CLXREC.CLXLTRX1 + 1;
    end
  end
  ;
  KL0VSFI(); /* retrieve next 200 products*/
   /* starting from the style,color,dimension entered into the*/
   /* item field.*/
  ;
  ;
end // end KL0VSFH

// retrieve next 200 products
Function KL0VSFI()
   /* ***************************************************/
   /* retrieve the defective detail rows starting from*/
   /* the style,color,dimension the user entered.*/
  ;
   /* ***************************************************/
  ;
  CLXREC.CLXCPROC = "CL0VSFI";
  ;
  set CLPREC empty;
  CLPREC.CLACLMNB = KL0VM005.CLACLMNB;
  CLPREC.CLHSEQNB = KL0VM005.CLHSEQNB;
  CLPREC.CL2ISNBR = CLAREC.CLACISNB;
  CLPREC.XGPCD = KL0VM005.XGPCD;
  CLPREC.SY1STNBR = CL0VW01.SY1STNBR;
  CLPREC.SY2CLRID = CL0VW01.SY2CLRID;
  CLPREC.XDMCD = CL0VW01.XDMCD;
  CLXREC.CLXARAYX = 0;
  set CL0VW02 empty;
  ;
  KL0V791(); /* select from a specific gpc and style*/
  CL0VW06.CL0VWSQL = "N2"; /* sql code for fetch stmt*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    while (SQLCA.VAGen_SQLCODE == 0
     && CLXREC.CLXARAYX < CL0VW01.CL0VWMXL) /* less than 499*/
      KL0VSFB(); /* process all fetched records.*/
    end
    CL0VW01.CL0VWMNB = CLXREC.CLXARAYX; /* total items selected*/
    CLXREC.CLXARAYX = CLXREC.CLXARAYX + 1;
    CL0VW02.CL0VWDFQ[CLXARAYX] = CLOREC.CLOTDFQY + CLOREC.CLMTNCRQ;
    CL0VW02.CLPDEFQ[CLXARAYX] = CLOREC.CLOTDFQY; /* this sets up*/
    CL0VW02.CLNNCRQ[CLXARAYX] = CLOREC.CLMTNCRQ; /* the total line.*/
    CL0VW02.CLPRTCTQ[CLXARAYX] = CLOREC.CLOTRCQY;
    CL0VW02.CL0VWNRQ[CLXARAYX] = CLOREC.CLMTNCRQ - CLOREC.CLOTRCQY;
    CL0VW02.SY1STNBR[CLXARAYX] = "TOTALS";
    CLXREC.CLXLSTAX = CLXREC.CLXARAYX; /* last filled array row*/
  end
  ;
  KL0V793(); /* close cursor for clprec*/
  ;
  if (CLXREC.CLXERRF == "N")
    CLXREC.CLXARAYX = 1; /* array counter*/
    CLXREC.CLXCURLN = 1; /* current map line*/
    CLXREC.CLXMAPMX = 1; /* total number of lines on map*/
    ;
    KL0VSFF(); /* move header data from cl0vw01 to cl0vm005*/
    ;
    CL0VW01.CL0VWMSG = " PRODUCTS SELECTED. ";
    KL0VM005.VAGen_EZEMSG = CL0VW01.CL0VWMGT;
    ;
    while (CLXREC.CLXCURLN <= 10)
         /* AND CL0VW02.CLPDEFQ(CLXARAYX) GT 0;*/
      KL0VSFD(); /* move cl0vw02 rec to 1st map*/
    end
  else
    /* next sentence*/
  end
  ;
  ;
end // end KL0VSFI

// setup this delete process
Function KL0VSGA()
  ;
  ;
  CLXREC.CLXCPROC = "CL0VSGA";
  ;
  KL0VSAG(); /* retrieve todays date and time*/
  ;
  ;
  set CLPREC empty;
  ;
  ;
   /* the fields below will check for a unique row.*/
  ;
  CLPREC.CLACLMNB = CL0VW01.CLACLMNB;
  CLPREC.CLHSEQNB = CL0VW01.CLHSEQNB;
  CLPREC.CL2ISNBR = CLAREC.CLACISNB;
  CLPREC.XGPCD = CL0VW01.XGPCD;
  CLPREC.SY1STNBR = CL0VW02.SY1STNBR[CLXARAYX];
  CLPREC.SY2CLRID = CL0VW02.SY2CLRID[CLXARAYX];
  CLPREC.XDMCD = CL0VW02.XDMCD[CLXARAYX];
  CLPREC.YDDCD = CL0VW02.YDDCD[CLXARAYX];
  CLPREC.XUMCD = CL0VW02.XUMCD[CLXARAYX];
  CLPREC.XQACD = CL0VW02.XQACD[CLXARAYX];
  CLPREC.CLKCLPRC = CL0VW02.CLKCLPRC[CLXARAYX];
  CLPREC.FY1FCTYC = CL0VW02.FY1FCTYC[CLXARAYX];
  CLPREC.PC3POIDT = CL0VW02.PC3POIDT[CLXARAYX];
  CLPREC.CLPCRTNB = CL0VW02.CLPCRTNB[CLXARAYX];
  CLPREC.YDFCD = CL0VW02.YDFCD[CLXARAYX];
  CLPREC.YDRCD = CL0VW02.YDRCD[CLXARAYX];
  CLPREC.ZZZCHGCT = CL0VW02.ZZZCHGCT[CLXARAYX];
  ;
  KL0V897(); /* update to check if defective detail exists*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    KL0VSGE(); /* delete defective detail*/
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      converseLib.validationFailed(18);
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == -911)
        converseLib.validationFailed(4);
        CLXREC.CLXERRF = "Y"; /* redisplay the screen*/
      end
    end
  end
  ;
  CL0VW02.CL0VMSEL[CLXARAYX] = "V";
  ;
end // end KL0VSGA

// move cl0vw02 to cl0vm001 chg
Function KL0VSGB()
  ;
   /* ************************ CL0VSGB ****************************/
  ;
    /* Maintenance History:*/
    /* 02-22-90 CHELLM Renamed PD1.. items as FY1.. items.*/
    /* 04-13-92 twatso Renamed clacmind to cl-clcom-fl except for clarec*/
   /* *************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0VSGB";
  ;
  ;
  set KL0VM001 initial;
   /* move header info*/
  KL0VM001.CLACLMNB = CL0VW01.CLACLMNB;
  KL0VM001.CLHSEQNB = CL0VW01.CLHSEQNB;
  KL0VM001.KUCCONM = CL0VW01.KUCCONM;
  KL0VM001.KUCCOID = CL0VW01.KUCCOID;
  KL0VM001.KUMSTRID = CL0VW01.KUMSTRID;
  KL0VM001.CLJTATHQ = CL0VW01.CLJTATHQ;
  KL0VM001.CLJNCRFL = CL0VW01.CLJNCRFL;
  KL0VM001.CLOFGAQ = CL0VW01.CLOFGAQ;
  KL0VM001.CLOFGAAM = CL0VW01.CLOFGAAM;
  KL0VM001.XXXUSRID = CL0VW01.XXXUSRID;
  KL0VM001.CLODMAMT = CL0VW01.CLODMAMT;
  KL0VM001.CL0VMIDT = CL0VW01.CL0VMIDT;
  KL0VM001.XNXCD = CL0VW01.XNXCD;
  KL0VM001.XGPCD = CL0VW01.XGPCD;
  KL0VM001.YCTCD = CL0VW01.YCTCD;
  KL0VM001.XWHCD = CL0VW01.XWHCD;
  KL0VM001.XWHABRV = CL0VW01.XWHABRV;
  KL0VM001.CLOTLRID = CL0VW01.CLOTLRID;
  KL0VM001.CL2ISXDT = CL0VW01.CL2ISXDT;
  ;
   /* header info for chg. of*/
  CL0VW02.XWHCD = CL0VW01.XWHCD;
  CL0VW02.CLOTLRID = CL0VW01.CLOTLRID;
  CL0VW02.CL0VMIDT = CL0VW01.CL0VMIDT;
  CL0VW02.XXXUSRID = CL0VW01.XXXUSRID;
  CL0VW02.KUYREPNM = CL0VW01.KUYREPNM;
  ;
  ;
   /* move detail info.*/
  ;
  KL0VM001.SY1STNBR = CL0VW02.SY1STNBR[CLXARAYX];
  KL0VM001.SY2CLRID = CL0VW02.SY2CLRID[CLXARAYX];
  KL0VM001.XDMCD = CL0VW02.XDMCD[CLXARAYX];
  KL0VM001.YDDCD = CL0VW02.YDDCD[CLXARAYX];
  KL0VM001.XUMCD = CL0VW02.XUMCD[CLXARAYX];
  KL0VM001.CLKCLPRC = CL0VW02.CLKCLPRC[CLXARAYX];
   /* IF CL0VW02.FY1FCTYC(CLXARAYX) IN CL0VW03.FY1FCTYC;*/
    /* MOVE CL0VW03.PD1FTYNO(EZETST) TO CL0VM001.FY1FCTYC;*/
   /* ELSE ;*/
  KL0VM001.FY1FCTYC = CL0VW02.FY1FCTYC[CLXARAYX];
   /* END ;*/
  ;
  CLXREC.XXXWCYMD = CL0VW02.PC3POIDT[CLXARAYX];
  KL0VM001.CL0VMFPO = CLXREC.XXXWYMD;
  ;
  KL0VM001.CLPCRTNB = CL0VW02.CLPCRTNB[CLXARAYX];
  KL0VM001.YDFCD = CL0VW02.YDFCD[CLXARAYX];
  KL0VM001.CL0VWDFQ = CL0VW02.CL0VWDFQ[CLXARAYX];
  KL0VM001.CLPDEFQ = CL0VW02.CLPDEFQ[CLXARAYX];
  KL0VM001.CLPRTCTQ = CL0VW02.CLPRTCTQ[CLXARAYX];
  KL0VM001.CL0VWNRQ = CL0VW02.CL0VWNRQ[CLXARAYX];
  KL0VM001.YDRCD = CL0VW02.YDRCD[CLXARAYX];
  ;
  CL0VW01.CLPVLDFL = CL0VW02.CLPVLDFL[CLXARAYX];
  CL0VW01.CLKPRCFF = CL0VW02.CLKPRCFF[CLXARAYX];
  CL0VW01.CLGCMSEQ = CL0VW02.CLGCMSEQ[CLXARAYX];
  ;
  if (CL0VW02.CL-CLCOM-FL[CLXARAYX] == "Y")
    KL0VSGC(); /* retrieve claim comments*/
  else
    /* next sentence*/
  end
  ;
  ;
  ;
end // end KL0VSGB

// retrieve claim comments
Function KL0VSGC()
  ;
  ;
  CLXREC.CLXCPROC = "CL0VSGC";
  ;
  set CLGREC empty;
  ;
  CLGREC.CLACLMNB = CL0VW01.CLACLMNB;
  CLGREC.CLHSEQNB = CL0VW01.CLHSEQNB;
  CLGREC.CL2ISNBR = 0;
  CLGREC.CLGCMTYP = "D";
  CLGREC.CLGCMSEQ = CL0VW02.CLGCMSEQ[CLXARAYX];
  ;
  KL0V964(); /* select unique from clgrec*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    KL0VM001.CLGCOMNT = CLGREC.CLGCOMNT;
    set KL0VM001.CLGCOMNT initialAttributes;
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      CLXREC.CLXERRF = "Y"; /* set up error flag*/
      converseLib.validationFailed(9);
      set KL0VM001.CLGCOMNT cursor, bold;
    end
  end
  ;
  ;
  ;
end // end KL0VSGC

// delete the defective detail
Function KL0VSGE()
  ;
  CLXREC.CLXCPROC = "CL0VSGE";
  ;
  ;
  if (CL0VW02.CLGCMSEQ[CLXARAYX] > 0)
    KL0VSGF(); /* delete the claim comments*/
  else
    /* next sentence*/
  end
  ;
  KL0V895(); /* delete defective detail*/
  ;
  ;
    /* set comment indicator to be updated on clarec*/
  ;
  CLGREC.CLACLMNB = CLAREC.CLACLMNB;
  CLGREC.CLHSEQNB = -1;
  CLGREC.CL2ISNBR = -1;
  CLGREC.CLGCMTYP = "**";
  ;
  call "IO1260" ("SS", SQLCA, CLGREC) {isNoRefresh = yes, isExternal = yes}; /* dclaim.vclcom01*/
  call "IO1260" ("SN", SQLCA, CLGREC) {isNoRefresh = yes, isExternal = yes};
  ;
  CL0VW01.CL-CLCOM-FL = CLAREC.CLACMIND;
  if (SQLCA.VAGen_SQLCODE == 0)
    if (CLAREC.CLACMIND == "N"
     || CLAREC.CLACMIND == " ")
      CL0VW01.CL-CLCOM-FL = "Y";
    end
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      if (CLAREC.CLACMIND == "Y")
        CL0VW01.CL-CLCOM-FL = "N";
      end
    end
  end
  call "IO1260" ("CS", SQLCA, CLGREC) {isNoRefresh = yes, isExternal = yes};
  ;
  ;
end // end KL0VSGE

// delete defective det. comment
Function KL0VSGF()
  ;
  CLXREC.CLXCPROC = "CL0VSGF";
  ;
  ;
  set CLGREC empty; /* comment db2 table*/
  ;
  CLGREC.CLACLMNB = CL0VW01.CLACLMNB;
  CLGREC.CLHSEQNB = CL0VW01.CLHSEQNB;
  CLGREC.CL2ISNBR = 0;
  CLGREC.CLGCMTYP = "D";
  CLGREC.CLGCMSEQ = CL0VW02.CLGCMSEQ[CLXARAYX];
  ;
  KL0V964(); /* select unique from clgrec*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    KL0VSGH(); /* delete comment*/
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      CLXREC.CLXERRF = "Y"; /* set up error flag*/
      converseLib.validationFailed(9);
    end
  end
  ;
end // end KL0VSGF

// update def. header w/del. qtys
Function KL0VSGG()
  ;
  ;
  if (CLWREC.CLWACTIV == "I") /* in inquiry mode*/
    return; /* so don't try update*/
  end
  ;
  CLXREC.CLXCPROC = "CL0VSGG";
  ;
  CLOREC.CLACLMNB = KL0VM001.CLACLMNB;
  CLOREC.CLHSEQNB = KL0VM001.CLHSEQNB;
  CLOREC.CL2ISNBR = CLAREC.CLACISNB;
  ;
   /* move key values to defective item to sum fields*/
  ;
  CLPREC.CLACLMNB = KL0VM001.CLACLMNB;
  CLPREC.CLHSEQNB = KL0VM001.CLHSEQNB;
  CLPREC.CL2ISNBR = CLAREC.CLACISNB;
  ;
  ;
  KL0V834(); /* select unique from clorec*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    KL0VSHP(); /* update the defective header*/
  else
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4);
      CLXREC.CLXERRF = "Y";
      return;
    end
  end
  ;
  ;
  ;
end // end KL0VSGG

// delete defective comment line
Function KL0VSGH()
  ;
  ;
  CLXREC.CLXCPROC = "CL0VSGH";
  ;
  ;
  ;
  KL0V965(); /* delete the claim comment*/
  ;
  ;
end // end KL0VSGH

// set all fields to autoskip
Function KL0VSHA()
  ;
  CLXREC.CLXCPROC = "CL0VSHA"; /* set current process name*/
  ;
  ;
  set KL0VM001.CL0VMFDA skip, invisible;
  set KL0VM001.CLJNCRFL skip;
  set KL0VM001.XXXUSRID skip;
  set KL0VM001.CL0VMIDT skip;
  set KL0VM001.XWHCD skip;
  set KL0VM001.SY1STNBR skip;
  set KL0VM001.SY2CLRID skip;
  set KL0VM001.XDMCD skip;
  set KL0VM001.XUMCD skip;
  set KL0VM001.CL0VMFPO skip;
  set KL0VM001.FY1FCTYC skip;
  set KL0VM001.YDDCD skip;
  set KL0VM001.CLPCRTNB skip;
  set KL0VM001.YDFCD skip;
  set KL0VM001.CL0VWDFQ skip;
  set KL0VM001.CLPDEFQ skip;
  set KL0VM001.YDRCD skip;
  set KL0VM001.CLPRTCTQ skip;
  set KL0VM001.CL0VWNRQ skip;
  set KL0VM001.CLKCLPRC skip;
  set KL0VM001.CLGCOMNT skip;
  set KL0VM001.CL0VMICF skip;
  ;
  ;
  set KL0VM001.CATOAP cursor;
  ;
  ;
end // end KL0VSHA

// set key fields to autoskip
Function KL0VSHB()
   /* *  2-15-91 bcourt change CLLIBYID to XXXUSRID.*/
  ;
  CLXREC.CLXCPROC = "CL0VSHB"; /* set current process name*/
  ;
  ;
   /* SET CL0VM001.xxxusrID AUTOSKIP; 2-15-91*/
   /* SET CL0VM001.CL0VMIDT AUTOSKIP;*/
   /* SET CL0VM001.XWHCD AUTOSKIP;*/
   /* SET CL0VM001.CLJNCRFL AUTOSKIP;*/
  set KL0VM001.SY1STNBR skip;
  set KL0VM001.SY2CLRID skip;
  set KL0VM001.XDMCD skip;
  set KL0VM001.XUMCD skip;
  set KL0VM001.CL0VMFPO skip;
  set KL0VM001.FY1FCTYC skip;
  set KL0VM001.YDDCD skip;
  set KL0VM001.CLPCRTNB skip;
  set KL0VM001.YDFCD skip;
  set KL0VM001.CL0VMICF skip;
  ;
end // end KL0VSHB

// update defective detail
Function KL0VSHC()
  ;
  CLXREC.CLXCPROC = "CL0VSHC";
  ;
  KL0VSAG(); /* retrieve todays date and time*/
  ;
  KL0VSKA(); /* check to see if header fields were changed.*/
  if (CLXREC.CLXERRF == "Y")
    return;
  else
     /* next sentence*/
  end
  ;
  if (CL0VW02.CLPDEFQ[CLXARAYX] == KL0VM001.CLPDEFQ
   && CL0VW02.CL0VWNRQ[CLXARAYX] == KL0VM001.CL0VWNRQ
   && CL0VW02.YDRCD[CLXARAYX] == KL0VM001.YDRCD
   && CL0VW02.CLPRTCTQ[CLXARAYX] == KL0VM001.CLPRTCTQ
   && CL0VW02.CLKCLPRC[CLXARAYX] == KL0VM001.CLKCLPRC)
    if (KL0VM001.CLGCOMNT is modified)
      if (CL0VW02.CLGCMSEQ[CLXARAYX] > 0)
        KL0VSHE(); /* update the defective comment line*/
      else
        KL0VSDC(); /* add a new comment line*/
      end
    else
      return;
    end
  else
    if (KL0VM001.CLGCOMNT is modified)
      if (CL0VW02.CLGCMSEQ[CLXARAYX] > 0)
        KL0VSHE(); /* update the defective comment line*/
      else
        KL0VSDC(); /* add a new comment line*/
        CL0VW02.CL-CLCOM-FL[CLXARAYX] = "Y";
        CL0VW02.CLGCMSEQ[CLXARAYX] = CLGREC.CLGCMSEQ;
      end
    else
         /* next sentence*/
    end
  end
  ;
  ;
    /* set comment indicator to be updated on clarec*/
  ;
  CLGREC.CLACLMNB = CLAREC.CLACLMNB;
  CLGREC.CLHSEQNB = -1;
  CLGREC.CL2ISNBR = -1;
  CLGREC.CLGCMTYP = "**";
  ;
  call "IO1260" ("SS", SQLCA, CLGREC) {isNoRefresh = yes, isExternal = yes}; /* dclaim.vclcom01*/
  call "IO1260" ("SN", SQLCA, CLGREC) {isNoRefresh = yes, isExternal = yes};
  ;
  CL0VW01.CL-CLCOM-FL = CLAREC.CLACMIND;
  if (SQLCA.VAGen_SQLCODE == 0)
    if (CLAREC.CLACMIND == "N"
     || CLAREC.CLACMIND == " ")
      CL0VW01.CL-CLCOM-FL = "Y";
    end
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      if (CLAREC.CLACMIND == "Y")
        CL0VW01.CL-CLCOM-FL = "N";
      end
    end
  end
  call "IO1260" ("CS", SQLCA, CLGREC) {isNoRefresh = yes, isExternal = yes};
  ;
  ;
  ;
  if (CL0VW02.CLKCLPRC[CLXARAYX] != KL0VM001.CLKCLPRC)
    KL0VSHS(); /* perform a delete and readd*/
  else
    KL0VSHR(); /* normal change for clprec*/
  end
  ;
  if (CLXREC.CLXERRF == "Y")
    /* next sentence*/
  else
    KL0VSGG(); /* update the defective header*/
    ;
    CL0VW02.CLKCLPRC[CLXARAYX] = CLPREC.CLKCLPRC; /* move updated info*/
    CL0VW02.CL0VWDFQ[CLXARAYX] = CLPREC.CLPDEFQ + CLPREC.CLNNCRQ; /* into*/
    CL0VW02.CLPDEFQ[CLXARAYX] = CLPREC.CLPDEFQ; /* storage aray*/
    CL0VW02.YDRCD[CLXARAYX] = CLPREC.YDRCD;
    CL0VW02.CLNNCRQ[CLXARAYX] = CLPREC.CLNNCRQ;
    CL0VW02.CLPRTCTQ[CLXARAYX] = CLPREC.CLPRTCTQ;
    CL0VW02.CL0VWNRQ[CLXARAYX] = CLPREC.CLNNCRQ - CLPREC.CLPRTCTQ;
    CL0VW02.ZZZCHGCT[CLXARAYX] = CLPREC.ZZZCHGCT;
    ;
    CL0VW02.CL0VWDFQ[CLXLSTAX] = CLOREC.CLOTDFQY + CLOREC.CLMTNCRQ;
    CL0VW02.CLPDEFQ[CLXLSTAX] = CLOREC.CLOTDFQY;
    CL0VW02.CLNNCRQ[CLXLSTAX] = CLOREC.CLMTNCRQ;
    CL0VW02.CLPRTCTQ[CLXLSTAX] = CLOREC.CLOTRCQY;
    CL0VW02.CL0VWNRQ[CLXLSTAX] = CLOREC.CLMTNCRQ - CLOREC.CLOTRCQY;
  end
  ;
end // end KL0VSHC

// update defective detail
Function KL0VSHD()
  ;
  CLXREC.CLXCPROC = "CL0VSHD";
  ;
  ;
  CLPREC.CLKCLPRC = KL0VM001.CLKCLPRC;
  CLPREC.CLPDEFQ = KL0VM001.CLPDEFQ;
  CLPREC.YDRCD = KL0VM001.YDRCD;
  CLPREC.CLNNCRQ = KL0VM001.CLPRTCTQ + KL0VM001.CL0VWNRQ;
  CLPREC.CLPRTCTQ = KL0VM001.CLPRTCTQ;
  CLPREC.ZZZCHGDT = TA2REC.TA2GRGGN;
  CLPREC.ZZZCHGTM = TA2REC.TA2TIMHM;
  ;
  if (CL0VW02.CLGCMSEQ[CLXARAYX] > 0)
    CLPREC.CLGCMSEQ = CL0VW02.CLGCMSEQ[CLXARAYX];
    CLPREC.CL-CLCOM-FL = "Y";
    CL0VW02.CL-CLCOM-FL[CLXARAYX] = "Y";
  else
    CLPREC.CLGCMSEQ = 0; /* added 11/88*/
    CLPREC.CL-CLCOM-FL = " ";
    CL0VW02.CL-CLCOM-FL[CLXARAYX] = " ";
  end
  ;
  ;
  KL0V897(); /* replace defective detail*/
  ;
  ;
  if (KL0VM001.CLPDEFQ != CL0VW02.CLPDEFQ[CLXARAYX])
    KL0VSHO(); /* update the defective header*/
  else
    /* next sentence*/
  end
  ;
  CL0VW02.CLKPRCFF[CLXARAYX] = CLPREC.CLKPRCFF;
  CL0VW02.CLKCLPRC[CLXARAYX] = CLPREC.CLKCLPRC; /* move updated info*/
  CL0VW02.CL0VWDFQ[CLXARAYX] = CLPREC.CLPDEFQ + CLPREC.CLNNCRQ;
  CL0VW02.CLPDEFQ[CLXARAYX] = CLPREC.CLPDEFQ; /* back into the working*/
  CL0VW02.YDRCD[CLXARAYX] = CLPREC.YDRCD;
  CL0VW02.CLNNCRQ[CLXARAYX] = CLPREC.CLNNCRQ; /* storage aray*/
  CL0VW02.CLPRTCTQ[CLXARAYX] = CLPREC.CLPRTCTQ;
  CL0VW02.CL0VWNRQ[CLXARAYX] = CLPREC.CLNNCRQ - CLPREC.CLPRTCTQ;
  CL0VW02.ZZZCHGCT[CLXARAYX] = CLPREC.ZZZCHGCT;
  ;
end // end KL0VSHD

// update the defective comment
Function KL0VSHE()
   /* update the comment table*/
   /* the clgrec should have all the old*/
   /* data in the working storage area so*/
   /* update and replace is all that is needed.*/
  ;
  KL0V964(); /* select unique from clgrec*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    if (KL0VM001.CLGCOMNT == " ")
      ;
      KL0V965(); /* delete comment*/
      if (SQLCA.VAGen_SQLCODE == 0)
        CL0VW02.CL-CLCOM-FL[CLXARAYX] = " ";
        CL0VW02.CLGCMSEQ[CLXARAYX] = 0;
      end
      ;
    else
      KL0VSHF(); /* change comment line.*/
    end
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      CLXREC.CLXERRF = "Y"; /* set up error flag*/
      converseLib.validationFailed(18); /* data base changed*/
      return;
    else
      if (SQLCA.VAGen_SQLCODE == -911)
        CLXREC.CLXERRF = "Y"; /* set up error flag*/
        converseLib.validationFailed(4); /* data base changed*/
      end
    end
  end
  ;
  ;
end // end KL0VSHE

// replace the comment line
Function KL0VSHF()
  ;
  ;
  CLXREC.CLXCPROC = "CL0VSHF";
  ;
  CLGREC.CLGCOMNT = KL0VM001.CLGCOMNT;
  CLGREC.ZZZCHGDT = TA2REC.TA2GRGGN;
  CLGREC.ZZZCHGTM = TA2REC.TA2TIMHM;
  ;
  KL0V967(); /* update defective header.*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    CL0VW02.CL-CLCOM-FL[CLXARAYX] = "Y";
    CL0VW02.CLGCMSEQ[CLXARAYX] = CLGREC.CLGCMSEQ;
    /* next sentence*/
  end
  ;
  ;
  ;
end // end KL0VSHF

// check if inspection complete
Function KL0VSHG()
  ;
  ;
  ;
  CLXREC.CLXCPROC = "CL0VSHG"; /* set current process name*/
  ;
  if (KL0VM005.CL0VMICF is modified)
    set KL0VM005.CL0VMICF modified;
    if (KL0VM005.CL0VMICF == " ")
        /* next sentence*/
    else
      if (KL0VM005.CL0VMICF == "Y")
        if (CLAREC.YCTCD == "DFO") /* dfo claims get a dfo*/
          CLWREC.YCSCD = "DFO"; /* status when complete*/
        else
          CLWREC.YCSCD = "RPM";
        end
        if (KL0VM005.CLOFGAQ > 0)
          if (KL0VM005.CL0VMJAQ > 0)
            set KL0VM005.CL0VMJAQ initialAttributes;
          else
            set KL0VM005.CL0VMJAQ cursor, bold;
            CLWREC.YCSCD = CLAREC.YCSCD1;
            CLXREC.CLXERRF = "Y";
            converseLib.validationFailed(21);
            return;
          end
        else
          if (KL0VM005.CLPDEFQ[1] > 0
           || KL0VM005.CLPRTCTQ[1] > 0
           || KL0VM005.CL0VWNRQ[1] > 0)
            /* next sentence*/
          else
            set KL0VM005.CL0VMICF initialAttributes;
            CLWREC.YCSCD = CLAREC.YCSCD1;
            KL0VM005.CL0VMICF = " ";
            KL0VM005.CL0VMJAQ = 0;
            CLXREC.CLXERRF = "Y";
            converseLib.validationFailed(373); /* can not close detail does not exist*/
            return;
          end
        end
      else
        set KL0VM005.CL0VMICF cursor, bold;
        converseLib.validationFailed(283); /* insp field must be 'y' or blank*/
        CLXREC.CLXERRF = "Y";
        CLWREC.YCSCD = CLAREC.YCSCD1;
        return;
      end
    end
  else
    return;
  end
  ;
   /* if gotten this far no errors with inspection cmp*/
   /* flag and need to update status-changed-by userid*/
  ;
  CLAREC.CLASCGBY = COMMAREA.CAUSERID;
  ;
  ;
  ;
  KL0VSAG(); /* retrieve todays date*/
  ;
  ;
  set CLJREC empty;
  CLJREC.CLACLMNB = CL0VW01.CLACLMNB;
  CLJREC.ZZZCHGDT = TA2REC.TA2GRGGN;
  CLJREC.ZZZCHGTM = TA2REC.TA2TIMHM;
  ;
  KL0VSHH(); /* update the returned qty authorized.*/
  ;
  ;
  set CL2REC empty;
  CL2REC.CLACLMNB = CL0VW01.CLACLMNB;
  CL2REC.CL2ISNBR = CLAREC.CLACISNB;
  CL2REC.CLHSEQNB = CLAREC.CLACSQNB;
  ;
  KL0VSHL(); /* update insp comp dt in  return insp*/
  ;
  set CLAREC empty;
  CLAREC.CLACLMNB = CL0VW01.CLACLMNB;
  CLAREC.ZZZCHGDT = TA2REC.TA2GRGGN;
  CLAREC.ZZZCHGTM = TA2REC.TA2TIMHM;
  KL0VSHJ(); /* update the claim header status code*/
  ;
  ;
  ;
  ;
end // end KL0VSHG

// ret.&update return authorizat.
Function KL0VSHH()
  ;
  ;
  KL0V824(); /* select unique from cljrec*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    CLJREC.CLJTATHQ = KL0VM005.CL0VMJAQ;
    CLJREC.ZZZCHGDT = TA2REC.TA2GRGGN;
    CLJREC.ZZZCHGTM = TA2REC.TA2TIMHM;
    ;
    KL0VSHK(); /* update cljrec.*/
    ;
  else
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4);
      CLXREC.CLXERRF = "Y";
    end
  end
  ;
end // end KL0VSHH

// ret&update claim header
Function KL0VSHJ()
  ;
  ;
  CLXREC.CLXCPROC = "CL0VSHJ";
  ;
  ;
  KL0V814(); /* select unique from clarec*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    KL0VSHN(); /* update clarec.*/
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      CLXREC.CLXERRF = "Y";
      converseLib.validationFailed(18);
      return;
    else
      if (SQLCA.VAGen_SQLCODE == -911)
        CLXREC.CLXERRF = "Y";
        converseLib.validationFailed(4);
        return;
      end
    end
  end
  ;
end // end KL0VSHJ

// replace cljrec
Function KL0VSHK()
  ;
  ;
  CLXREC.CLXCPROC = "CL0VSHK";
  ;
  KL0V827(); /* update record from cljrec*/
  ;
  ;
  ;
end // end KL0VSHK

// replace cl2rec
Function KL0VSHL()
  CLXREC.CLXCPROC = "CL0VSHL";
  ;
  ;
  KL0V994(); /* select unique from cl2rec*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    ;
     /* move currdte to completion date*/
    CL2REC.CL2ISXDT = TA2REC.TA2GRGGN;
    CL2REC.XXXUSRID = COMMAREA.CAUSERID;
    CL2REC.ZZZCHGDT = TA2REC.TA2GRGGN;
    CL2REC.ZZZCHGTM = TA2REC.TA2TIMHM;
    ;
    KL0V997(); /* update record from cl2rec*/
    ;
  end
  ;
end // end KL0VSHL

// replace cllrec
Function KL0VSHM()
  ;
  ;
  CLXREC.CLXCPROC = "CL0VSHM";
  ;
  ;
  KL0V847(); /* update record from cllrec*/
  ;
  ;
end // end KL0VSHM

// replace clarec
Function KL0VSHN()
  ;
  ;
  CLXREC.CLXCPROC = "CL0VSHN";
  ;
  if (CLWREC.YCSCD == "DFO")
    CLAREC.YCSCD1 = "DFO";
    if ("DFO" in YCSTBL.YCSCD)
      CLAREC.YCSACTCD = YCSTBL.YCSACTCD[sysVar.arrayIndex];
      CLAREC.YCSRPTEX = YCSTBL.YCSRPTEX[sysVar.arrayIndex];
    else
      /* next sentence*/
    end
  end
  ;
  if (CLWREC.YCSCD == "DEF")
    CLAREC.YCSCD1 = "DEF";
    if ("DEF" in YCSTBL.YCSCD)
      CLAREC.YCSACTCD = YCSTBL.YCSACTCD[sysVar.arrayIndex];
      CLAREC.YCSRPTEX = YCSTBL.YCSRPTEX[sysVar.arrayIndex];
    else
      /* next sentence*/
    end
  end
  ;
  if (CLWREC.YCSCD == "RPM")
    CLAREC.YCSCD1 = "RPM";
    if ("RPM" in YCSTBL.YCSCD)
      CLAREC.YCSACTCD = YCSTBL.YCSACTCD[sysVar.arrayIndex];
      CLAREC.YCSRPTEX = YCSTBL.YCSRPTEX[sysVar.arrayIndex];
    else
      /* next sentence*/
    end
  end
  ;
  CLAREC.CLASTTDT = TA2REC.TA2GRGGN;
  CLAREC.ZZZCHGDT = TA2REC.TA2GRGGN;
  CLAREC.ZZZCHGTM = TA2REC.TA2TIMHM;
  ;
  KL0V817(); /* update clarec*/
  ;
end // end KL0VSHN

// update the def. header
Function KL0VSHO()
  ;
  ;
  CLXREC.CLXCPROC = "CL0VSHO";
  ;
  if (KL0VM001.CLPDEFQ != CL0VW02.CLPDEFQ[CLXARAYX])
    ;
    CL0VW01.CLOFGAQ = KL0VM001.CLOFGAQ - CL0VW02.CLPDEFQ[CLXARAYX];
    CL0VW01.CLOFGAQ = KL0VM001.CLOFGAQ + KL0VM001.CLPDEFQ;
    CL0VW01.CLOFGAQ = KL0VM001.CLOFGAQ;
    if (CL0VW01.XGPCD in YRMTBL.XGPCD)
      CL0VW01.CLOFGAAM = CL0VW01.CLOFGAQ * YRMTBL.YRMDFRGT[sysVar.arrayIndex];
      KL0VM001.CLOFGAAM = CL0VW01.CLOFGAAM;
    else
      /* next sentence*/
    end
  else
    /* next sentence*/
  end
  ;
  ;
  if (KL0VM001.CLPRTCTQ != CL0VW02.CLPRTCTQ[CLXARAYX])
    CL0VW01.CLORCTFL = "Y"; /* return to customer flag*/
  else
    CL0VW01.CLORCTFL = " ";
  end
  ;
  CLOREC.CLACLMNB = KL0VM001.CLACLMNB;
  CLOREC.CLHSEQNB = KL0VM001.CLHSEQNB;
  CLOREC.CL2ISNBR = CLAREC.CLACISNB;
  ;
   /* move key fields to defective item to get sums*/
  ;
  CLPREC.CLACLMNB = KL0VM001.CLACLMNB;
  CLPREC.CLHSEQNB = KL0VM001.CLHSEQNB;
  CLPREC.CL2ISNBR = CLAREC.CLACISNB;
  ;
  KL0V834(); /* select unique from clorec*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    KL0VSHP(); /* update the defective header*/
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      converseLib.validationFailed(18); /* data base changed by another user*/
      CLXREC.CLXERRF = "Y";
    else
      if (sysVar.sqlData.sqlcode == -911)
        converseLib.validationFailed(4); /* data base busy*/
        CLXREC.CLXERRF = "Y";
        /* set up error*/
      end
    end
  end
  ;
  ;
end // end KL0VSHO

// replace the def. header
Function KL0VSHP()
  ;
  CLXREC.CLXCPROC = "CL0VSHP";
  ;
  set CL0VW04 empty;
  ;
  KL0V898(); /* inquire on summary of qty's.*/
  if (SQLCA.VAGen_SQLCODE == -911)
    return;
  end
  ;
  CLOREC.CLOTDFQY = CL0VW04.CLOTDFQY; /* move values into header*/
  CLOREC.CLMTNCRQ = CL0VW04.CLMTNCRQ;
  CLOREC.CLOTRCQY = CL0VW04.CLOTRCQY;
  CLOREC.CLODMAMT = CL0VW04.CL0VWAMT;
  ;
  CL0VW01.CLODMAMT = CLOREC.CLODMAMT; /* merchandise amount*/
  CLOREC.CLOFGAQ = CLOREC.CLOTDFQY; /* freight qty = credit qty*/
  CL0VW01.CLOFGAQ = CLOREC.CLOTDFQY; /* freight qty = credit qty*/
  ;
  ;
   /* use the yrmtbl to obtain the freight rate. which is used*/
   /* to calculate the freight amount.*/
  ;
  if (CL0VW01.XGPCD in YRMTBL.XGPCD)
    if (KUCREC.XCUCD[1] == "PY97") /* if credit mgr is comp*/
      CLOREC.CLOFGAAM = 0; /* there are no freight charges*/
    else
      CLOREC.CLOFGAAM = CLOREC.CLOFGAQ * YRMTBL.YRMDFRGT[sysVar.arrayIndex];
    end
    CL0VW01.CLOFGAAM = CLOREC.CLOFGAAM;
  end
  ;
  ;
  if (CLOREC.CLORCTFL == "Y")
    /* next sentence*/
  else
    if (CLOREC.CLOTRCQY > 0)
      CLOREC.CLORCTFL = "Y";
    else
      CLOREC.CLORCTFL = "N";
    end
  end
  ;
  CLOREC.ZZZCHGDT = TA2REC.TA2GRGGN;
  CLOREC.ZZZCHGTM = TA2REC.TA2TIMHM;
  ;
  KL0VSKE(); /* replace defective header*/
  ;
  ;
end // end KL0VSHP

// validate change screen
Function KL0VSHQ()
  ;
  ;
  CLXREC.CLXCPROC = "CL0VSHQ";
  ;
  ;
  if (KL0VM001.CL0VWNRQ > 0
   || KL0VM001.CLPRTCTQ > 0)
    if (KL0VM001.YDRCD != " ")
      if (KL0VM001.YDRCD in YDRTBL.YDRCD)
        if (YDRTBL.XXXSTAT == "A")
          set KL0VM001.YDRCD initialAttributes;
        else
          CLXREC.CLXERRF = "Y";
          set KL0VM001.YDRCD cursor, bold;
          converseLib.validationFailed(9); /* no records exists*/
        end
      else
        CLXREC.CLXERRF = "Y";
        set KL0VM001.YDRCD cursor, bold;
        converseLib.validationFailed(9); /* no records exists*/
      end
    else
      CLXREC.CLXERRF = "Y";
      set KL0VM001.YDRCD cursor, bold;
      converseLib.validationFailed(21); /* this is a required field*/
    end
  else
    /* next sentence*/
  end
  ;
  if (KL0VM001.CLPDEFQ == 0
   && KL0VM001.CLPRTCTQ == 0
   && KL0VM001.CL0VWNRQ == 0)
    set KL0VM001.CLPDEFQ bold;
    set KL0VM001.CLPRTCTQ bold;
    set KL0VM001.CL0VWNRQ bold;
    converseLib.validationFailed(21); /* this is a required field*/
  else
    /* next sentence*/
  end
  ;
  CL0VW01.CL0VWDFQ = 0;
  ;
  CL0VW01.CL0VWDFQ = KL0VM001.CLPRTCTQ + KL0VM001.CL0VWNRQ;
  CL0VW01.CL0VWDFQ = CL0VW01.CL0VWDFQ + KL0VM001.CLPDEFQ;
  ;
  if (KL0VM001.CL0VWDFQ != 0)
    if (KL0VM001.CL0VWDFQ == CL0VW01.CL0VWDFQ)
      set KL0VM001.CL0VWDFQ initialAttributes;
      set KL0VM001.CLPDEFQ initialAttributes;
      set KL0VM001.CLPRTCTQ initialAttributes;
      set KL0VM001.CL0VWNRQ initialAttributes;
    else
      set KL0VM001.CL0VWDFQ cursor, bold;
      set KL0VM001.CLPDEFQ bold;
      set KL0VM001.CLPRTCTQ bold;
      set KL0VM001.CL0VWNRQ bold;
      CLXREC.CLXERRF = "Y";
      converseLib.validationFailed(365); /* either clncrq,clnrctq,clpncrdq must = def. qty.*/
    end
  else
    set KL0VM001.CL0VWDFQ cursor, bold;
    CLXREC.CLXERRF = "Y";
    converseLib.validationFailed(21); /* this is a required field*/
  end
  ;
  ;
  CL0VW01.CLKPRCFF = CL0VW02.CLKPRCFF[CLXARAYX];
  if (KL0VM001.CLKCLPRC != CL0VW02.CLKCLPRC[CLXARAYX])
    if (KL0VM001.CLKCLPRC > 0)
      if (KL0VM001.CLKCLPRC < 201) /* this is a dollar value limit*/
        CL0VW01.CLKPRCFF = "E";
        set KL0VM001.CLKCLPRC initialAttributes;
      else
        CLXREC.CLXERRF = "Y";
        set KL0VM001.CLKCLPRC cursor, modified, bold;
        converseLib.validationFailed(375); /* price to not exceed $200*/
      end
    else
      CL0VW01.CLKPRCFF = "P";
      KL0VSCR(); /* retrieve price from product*/
    end
  else
    /* next sentence*/
  end
  ;
  ;
   /* ************************************************************/
   /* *     this process handles all edits for the header       **/
   /* *     fields.                                             **/
   /* ************************************************************/
  ;
  if (KL0VM001.XWHCD == CL0VW02.XWHCD) /* new warehouse code entered*/
    /* next sentence*/
  else
    if (KL0VM001.XWHCD == " ")
      set KL0VM001.XWHCD cursor, modified, bold;
      KL0VM001.XWHABRV = " ";
      CL0VW01.XWHABRV = " ";
      CLXREC.CLXERRF = "Y";
      converseLib.validationFailed(21);
    else
      KL0VSBB(); /* validate warehouse code*/
    end
  end
  ;
  if (KL0VM001.CL0VMIDT == CL0VW02.CL0VMIDT)
    /* next sentence*/
  else
    KL0VSBC(); /* determine if valid date*/
  end
  ;
  if (KL0VM001.XXXUSRID == CL0VW02.XXXUSRID)
    /* next sentence*/
  else
    if (KL0VM001.XXXUSRID != " ")
      CL0VW01.XXXUSRID = KL0VM001.XXXUSRID;
    else
      set KL0VM001.XXXUSRID cursor, modified, bold;
      CLXREC.CLXERRF = "Y";
      converseLib.validationFailed(21); /* this field is required*/
    end
  end
  ;
  ;
  if (KL0VM001.CLJNCRFL == "Y" /* only 'y' and 'n' are valid values.*/
   || KL0VM001.CLJNCRFL == "N")
    /* next sentence*/
  else
    set KL0VM001.CLJNCRFL cursor, bold;
    CLXREC.CLXERRF = "Y";
    converseLib.validationFailed(367); /* valid values are 'y' or 'n'*/
  end
  ;
  ;
  ;
end // end KL0VSHQ

// change defective detail
Function KL0VSHR()
  ;
  ;
  CLXREC.CLXCPROC = "CL0VSHR";
  ;
  set CLPREC empty;
  ;
   /* the fields below will check for a unique row.*/
  ;
  CLPREC.CLACLMNB = KL0VM001.CLACLMNB;
  CLPREC.CLHSEQNB = KL0VM001.CLHSEQNB;
  CLPREC.CL2ISNBR = CLAREC.CLACISNB;
  CLPREC.XGPCD = KL0VM001.XGPCD;
  CLPREC.SY1STNBR = KL0VM001.SY1STNBR;
  CLPREC.SY2CLRID = KL0VM001.SY2CLRID;
  CLPREC.XDMCD = KL0VM001.XDMCD;
  CLPREC.YDDCD = KL0VM001.YDDCD;
  CLPREC.XUMCD = KL0VM001.XUMCD;
  CLPREC.XQACD = KL0VM001.XQACD; /* 10-04-90*/
  CLPREC.CLKCLPRC = KL0VM001.CLKCLPRC;
  CLPREC.FY1FCTYC = CL0VW02.FY1FCTYC[CLXARAYX];
  ;
   /* added 06-14-90*/
  if (KL0VM001.CL0VMFPO != 0)
    CLXREC.XXXWYMD = KL0VM001.CL0VMFPO;
    if (CLXREC.XXXWYY < 50)
      CLXREC.XXXWCC = 20;
    else
      CLXREC.XXXWCC = 19;
    end
    CLPREC.PC3POIDT = CLXREC.XXXWCYMD;
  else
    CLPREC.PC3POIDT = 0;
  end
  ;
  CLPREC.CLPCRTNB = KL0VM001.CLPCRTNB;
  CLPREC.YDFCD = KL0VM001.YDFCD;
  CLPREC.YDRCD = KL0VM001.YDRCD;
  CLPREC.ZZZCHGCT = CL0VW02.ZZZCHGCT[CLXARAYX];
  CLPREC.XQACD = "01";
  ;
  KL0V894(); /* inquire to check if defective detail exists*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    KL0VSHD(); /* update defective detail*/
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      converseLib.validationFailed(18);
      CLXREC.CLXERRF = "Y";
    end
  end
  ;
  ;
end // end KL0VSHR

// delete & readd defective det.
Function KL0VSHS()
  ;
  CLXREC.CLXCPROC = "CL0VSHS";
  ;
  set CLPREC empty;
  ;
   /* the fields below will check for a unique row.*/
  ;
  CLPREC.CLACLMNB = KL0VM001.CLACLMNB;
  CLPREC.CLHSEQNB = KL0VM001.CLHSEQNB;
  CLPREC.CL2ISNBR = CLAREC.CLACISNB;
  CLPREC.XGPCD = KL0VM001.XGPCD;
  CLPREC.SY1STNBR = KL0VM001.SY1STNBR;
  CLPREC.SY2CLRID = KL0VM001.SY2CLRID;
  CLPREC.XDMCD = KL0VM001.XDMCD;
  CLPREC.YDDCD = KL0VM001.YDDCD;
  CLPREC.XUMCD = KL0VM001.XUMCD;
  CLPREC.XQACD = KL0VM001.XQACD; /* 10-04-90*/
  CLPREC.CLKCLPRC = CL0VW02.CLKCLPRC[CLXARAYX]; /* use old unit price*/
  CLPREC.FY1FCTYC = CL0VW02.FY1FCTYC[CLXARAYX];
  ;
   /* added 06-14-90*/
  if (KL0VM001.CL0VMFPO != 0)
    CLXREC.XXXWYMD = KL0VM001.CL0VMFPO;
    if (CLXREC.XXXWYY < 50)
      CLXREC.XXXWCC = 20;
    else
      CLXREC.XXXWCC = 19;
    end
    CLPREC.PC3POIDT = CLXREC.XXXWCYMD;
  else
    CLPREC.PC3POIDT = 0;
  end
  ;
  CLPREC.CLPCRTNB = KL0VM001.CLPCRTNB;
  CLPREC.YDFCD = KL0VM001.YDFCD;
  CLPREC.YDRCD = KL0VM001.YDRCD;
  CLPREC.ZZZCHGCT = CL0VW02.ZZZCHGCT[CLXARAYX];
  CLPREC.XQACD = "01";
  ;
  KL0V894(); /* inquire to check if defective detail exists*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    KL0VSHT(); /* delete defective detail for readd*/
    KL0VSHU(); /* re-add the defective detail*/
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      converseLib.validationFailed(18);
      CLXREC.CLXERRF = "Y";
    end
  end
  ;
  ;
end // end KL0VSHS

// delete def. detail for readd
Function KL0VSHT()
  ;
   /* this will be used just to delete the row so that*/
   /* it can be re-added, because the price has changed which*/
   /* is part of the key that makes a unique row.*/
  ;
  CLXREC.CLXCPROC = "CL0VSHT";
  ;
  ;
  KL0V895(); /* delete defective detail*/
  ;
  ;
end // end KL0VSHT

// readd the defective detail
Function KL0VSHU()
  ;
  ;
  CLXREC.CLXCPROC = "CL0VSHU";
  ;
  set CLPREC empty;
  ;
   /* MOVE 0 TO CL0VW01.CLGCMSEQ;*/
   /* the fields below will check for a unique row.*/
  ;
  CLPREC.CLACLMNB = KL0VM001.CLACLMNB;
  CLPREC.CLHSEQNB = KL0VM001.CLHSEQNB;
  CLPREC.CL2ISNBR = CLAREC.CLACISNB;
  CLPREC.XGPCD = KL0VM001.XGPCD;
  CLPREC.SY1STNBR = KL0VM001.SY1STNBR;
  CLPREC.SY2CLRID = KL0VM001.SY2CLRID;
  CLPREC.XDMCD = KL0VM001.XDMCD;
  CLPREC.YDDCD = KL0VM001.YDDCD;
  CLPREC.XUMCD = KL0VM001.XUMCD;
  CLPREC.XQACD = KL0VM001.XQACD; /* 10-04-90*/
  CLPREC.CLKCLPRC = KL0VM001.CLKCLPRC;
  CLPREC.FY1FCTYC = CL0VW02.FY1FCTYC;
  ;
   /* added 06-14-90*/
  if (KL0VM001.CL0VMFPO != 0)
    CLXREC.XXXWYMD = KL0VM001.CL0VMFPO;
    if (CLXREC.XXXWYY < 50)
      CLXREC.XXXWCC = 20;
    else
      CLXREC.XXXWCC = 19;
    end
    CLPREC.PC3POIDT = CLXREC.XXXWCYMD;
  else
    CLPREC.PC3POIDT = 0;
  end
  ;
  CLPREC.CLPCRTNB = KL0VM001.CLPCRTNB;
  CLPREC.YDFCD = KL0VM001.YDFCD;
  CLPREC.YDRCD = KL0VM001.YDRCD;
  if (CLPREC.XQACD == " ")
    CLPREC.XQACD = "01";
  end
  ;
  KL0V894(); /* inquire to check if defective detail exists*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    KL0VSHX(); /* change defective detail*/
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      KL0VSHW(); /* re-add defective detail*/
    end
  end
  ;
  ;
  ;
  ;
end // end KL0VSHU

// readd defective detail
Function KL0VSHW()
  ;
  CLXREC.CLXCPROC = "CL0VSHW";
  ;
  set CLPREC empty;
  ;
  CLPREC.CLACLMNB = KL0VM001.CLACLMNB;
  CLPREC.CLHSEQNB = KL0VM001.CLHSEQNB;
  CLPREC.CL2ISNBR = CLAREC.CLACISNB;
  CLPREC.XGPCD = KL0VM001.XGPCD;
  CLPREC.SY1STNBR = KL0VM001.SY1STNBR;
  CLPREC.SY2CLRID = KL0VM001.SY2CLRID;
  CLPREC.XDMCD = KL0VM001.XDMCD;
  CLPREC.YDDCD = KL0VM001.YDDCD;
  CLPREC.XUMCD = KL0VM001.XUMCD;
  CLPREC.FY1FCTYC = CL0VW02.FY1FCTYC;
  ;
   /* added 06-14-90*/
  if (KL0VM001.CL0VMFPO != 0)
    CLXREC.XXXWYMD = KL0VM001.CL0VMFPO;
    if (CLXREC.XXXWYY < 50)
      CLXREC.XXXWCC = 20;
    else
      CLXREC.XXXWCC = 19;
    end
    CLPREC.PC3POIDT = CLXREC.XXXWCYMD;
  else
    CLPREC.PC3POIDT = KL0VM001.CL0VMFPO;
  end
  ;
  CLPREC.CLPCRTNB = KL0VM001.CLPCRTNB;
  CLPREC.YDFCD = KL0VM001.YDFCD;
  CLPREC.CLKCLPRC = KL0VM001.CLKCLPRC;
  CLPREC.CLKPRCFF = CL0VW01.CLKPRCFF;
  CLPREC.CLPDEFQ = KL0VM001.CLPDEFQ;
  CLPREC.YDRCD = KL0VM001.YDRCD;
  CLPREC.CLNNCRQ = KL0VM001.CLPRTCTQ + KL0VM001.CL0VWNRQ;
  CLPREC.CLPRTCTQ = KL0VM001.CLPRTCTQ;
  ;
  CLPREC.CLPVLDFL = CL0VW01.CLPVLDFL;
  CLPREC.CLGCMSEQ = CL0VW01.CLGCMSEQ;
  if (CL0VW01.CLGCMSEQ > 0)
    CLPREC.CL-CLCOM-FL = "Y";
  else
    CLPREC.CLGCMSEQ = 0; /* added 11/88*/
    CLPREC.CL-CLCOM-FL = " ";
  end
  ;
  CLPREC.XQACD = "01";
  CLPREC.ZZZCHGDT = TA2REC.TA2GRGGN;
  CLPREC.ZZZCHGTM = TA2REC.TA2TIMHM;
  ;
  ;
  KL0V896(); /* add defective detail*/
  ;
  ;
  ;
end // end KL0VSHW

// change defective detail
Function KL0VSHX()
  ;
  CLXREC.CLXCPROC = "CL0VSHX";
  ;
  CLPREC.CLACLMNB = KL0VM001.CLACLMNB;
  CLPREC.CLHSEQNB = KL0VM001.CLHSEQNB;
  CLPREC.CL2ISNBR = CLAREC.CLACISNB;
  CLPREC.XGPCD = KL0VM001.XGPCD;
  CLPREC.SY1STNBR = KL0VM001.SY1STNBR;
  CLPREC.SY2CLRID = KL0VM001.SY2CLRID;
  CLPREC.XDMCD = KL0VM001.XDMCD;
  CLPREC.YDDCD = KL0VM001.YDDCD;
  CLPREC.XUMCD = KL0VM001.XUMCD;
  CLPREC.XQACD = KL0VM001.XQACD;
  CLPREC.FY1FCTYC = CL0VW02.FY1FCTYC;
  ;
   /* added 06-14-90*/
  if (KL0VM001.CL0VMFPO != 0)
    CLXREC.XXXWYMD = KL0VM001.CL0VMFPO;
    if (CLXREC.XXXWYY < 50)
      CLXREC.XXXWCC = 20;
    else
      CLXREC.XXXWCC = 19;
    end
    CLPREC.PC3POIDT = CLXREC.XXXWCYMD;
  else
    CLPREC.PC3POIDT = KL0VM001.CL0VMFPO;
  end
  ;
  CLPREC.CLPCRTNB = KL0VM001.CLPCRTNB;
  CLPREC.YDFCD = KL0VM001.YDFCD;
  CLPREC.CLKCLPRC = KL0VM001.CLKCLPRC;
  CLPREC.YDRCD = KL0VM001.YDRCD;
  ;
  CLPREC.CLPVLDFL = CL0VW01.CLPVLDFL;
  CLPREC.CLKPRCFF = CL0VW01.CLKPRCFF;
  ;
   /* if a comment exists for line2 thats ok.*/
   /* if line1 is being added to an line2,*/
   /* and  if comments exist for line1 but comments do not*/
   /* exist for line2 we will then add clgcmseq to line2  from*/
   /* line1. (this way the comments are not lost)*/
  ;
  if (CLPREC.CLGCMSEQ > 0) /* a comment already exists*/
    /* next sentence*/
  else
    if (CL0VW02.CLGCMSEQ[CLXARAYX] > 0)
      CLPREC.CL-CLCOM-FL = CL0VW02.CL-CLCOM-FL[CLXARAYX];
      CLPREC.CLGCMSEQ = CL0VW02.CLGCMSEQ[CLXARAYX];
    else
      CLPREC.CLGCMSEQ = 0; /* added 11/88*/
      /* next sentence*/
    end
  end
  ;
  CLPREC.ZZZCHGDT = TA2REC.TA2GRGGN;
  CLPREC.ZZZCHGTM = TA2REC.TA2TIMHM;
  CLPREC.XQACD = "01";
  ;
  KL0V894(); /* update defective detail*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == -100)
      CLXREC.CLXERRF = "Y";
      converseLib.validationFailed(18);
      return;
    end
  end
  ;
  ;
  CLPREC.CLPDEFQ = CLPREC.CLPDEFQ + KL0VM001.CLPDEFQ; /* defective qty*/
  CLPREC.CLNNCRQ = KL0VM001.CLPRTCTQ + KL0VM001.CL0VWNRQ; /* no credit qty*/
  CLPREC.CLPRTCTQ = CLPREC.CLPRTCTQ + KL0VM001.CLPRTCTQ;
                                   /* noncredit rtn qty*/
  ;
  KL0V897(); /* replace defective detail*/
  ;
  ;
end // end KL0VSHX

// inquire on claim header
Function KL0VSJA()
  ;
  ;
   /* ************************************************************/
   /* *                                                         **/
   /* *                                                         **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0VSJA"; /* set current process name*/
  ;
  ;
  ;
  CLAREC.CLACLMNB = CL0VW01.CLACLMNB;
  KL0V814(); /* select unique from clarec*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    KL0VSJB(); /* update clarec.*/
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      CLXREC.CLXERRF = "Y";
      converseLib.validationFailed(18);
      return;
    end
  end
  ;
  CLOREC.CLACLMNB = CL0VW01.CLACLMNB;
  CLOREC.CLHSEQNB = CL0VW01.CLHSEQNB;
  CLOREC.CL2ISNBR = CLAREC.CLACISNB;
  KL0VSAC(); /* inquire on defective header*/
  ;
end // end KL0VSJA

// update claim header
Function KL0VSJB()
      /* KL0VSJB  --  UPDATE CLAIM HEADER*/
  ;
   /* ************************************************************/
   /* *    M A I N T E N A N C E    H I S T O R Y    L O G      **/
   /* *---------------------------------------------------------**/
   /* *   DATE    PGMR    DESCRIPTION                           **/
   /* *---------------------------------------------------------**/
   /* * 11-12-93  GDECKE  REMOVE OVERLAPPING MOVE               **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0VSJB"; /* set current process name*/
  ;
  ;
  set CLIREC empty;
  CLIREC.CLACLMNB = CLAREC.CLACLMNB;
  CLIREC.CLHSEQNB = CLAREC.CLACSQNB;
  CLIREC.CLICRDFL = "D";
  ;
  CLAREC.CLATQTY = CLOREC.CLOTDFQY;
  ;
  KL0V978(); /* get total gl debits*/
  CLIREC.CLIGLAM = CL0VW05.CL0VWGLA; /* calculated sum*/
  ;
  CLAREC.CLAESTVL = CLIREC.CLIGLAM;
  ;
  set CLIREC empty;
  CLIREC.CLACLMNB = CLAREC.CLACLMNB;
  CLIREC.CLHSEQNB = CLAREC.CLACSQNB;
  CLIREC.CLICRDFL = "C";
  ;
  KL0V978(); /* get total gl credits*/
  CLIREC.CLIGLAM = CL0VW05.CL0VWGLA; /* calculated sum*/
  ;
  CLAREC.CLAESTVL = CLAREC.CLAESTVL + CLIREC.CLIGLAM;
  ;
  set CLHREC empty;
  CLHREC.CLACLMNB = CLAREC.CLACLMNB;
  CLHREC.CLHSEQNB = CLAREC.CLACSQNB;
  ;
  KL0V984(); /* select unique from clhrec*/
  ;
  CLAREC.CLAESTVL = CLAREC.CLAESTVL + CLHREC.CLHSHPCG;
  ;
  CL0VW01.CLAESTVL = 0;
  CL0VW01.CLAESTVL = CLOREC.CLODMAMT + CLOREC.CLOFGAAM;
  CL0VW01.CLAESTVL = CL0VW01.CLAESTVL * -1;
  CLAREC.CLAESTVL = CLAREC.CLAESTVL + CL0VW01.CLAESTVL;
  ;
  CLAREC.CLACMIND = CL0VW01.CL-CLCOM-FL;
  CLAREC.ZZZCHGDT = TA2REC.TA2GRGGN;
  CLAREC.ZZZCHGTM = TA2REC.TA2TIMHM;
  ;
  KL0V817(); /* update clarec*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      CLXREC.CLXERRF = "Y";
      converseLib.validationFailed(18);
      return;
    else
      if (SQLCA.VAGen_SQLCODE == -911)
        return;
      end
    end
  end
  ;
  CL0VW01.CLODMAMT = CLOREC.CLODMAMT;
  ;
  if (KUCREC.XCUCD[1] == "PY97")
    CL0VW01.CLOFGAQ = 0;
  else
    CL0VW01.CLOFGAQ = CLOREC.CLOTDFQY;
  end
  ;
end // end KL0VSJB

// check if header fields changed
Function KL0VSKA()
  ;
  CLXREC.CLXCPROC = "CL0VSKA";
  ;
  if (CL0VW02.XWHCD == KL0VM001.XWHCD)
    /* next sentence*/
  else
    KL0VSKB(); /* UPDATE CLOREC DEFECTIVE HEADER*/
                                   /* RECORD.*/
  end
  ;
  ;
  if (CL0VW02.CLJNCRFL == KL0VM001.CLJNCRFL
   && CL0VW02.XWHCD == KL0VM001.XWHCD)
    /* next sentence*/
  else
    KL0VSKC(); /* UPDATE CLJREC RETURN AUTHORIZATION*/
  end
  ;
  ;
  if (CL0VW02.XXXUSRID == KL0VM001.XXXUSRID
   && CL0VW02.CL0VMIDT == KL0VM001.CL0VMIDT
   && CL0VW02.XWHCD == KL0VM001.XWHCD)
    /* next sentence*/
  else
    KL0VSKD(); /* UPDATE CLlREC RETURN AUTHORIZATION*/
  end
end // end KL0VSKA

// setup  clorec header chgs.
Function KL0VSKB()
  ;
  CLXREC.CLXCPROC = "CL0VSKB";
  ;
  CLOREC.CLACLMNB = KL0VM001.CLACLMNB;
  CLOREC.CLHSEQNB = KL0VM001.CLHSEQNB;
  CLOREC.CL2ISNBR = CLAREC.CLACISNB;
  ;
  KL0V834(); /* select unique from clorec*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    CLOREC.CLOTLRID = KL0VM001.CLOTLRID;
    CLOREC.ZZZCHGDT = TA2REC.TA2GRGGN;
    CLOREC.ZZZCHGTM = TA2REC.TA2TIMHM;
    ;
    KL0VSKE(); /* update the defective header*/
    CL0VW01.XWHCD = KL0VM001.XWHCD;
    CL0VW01.CLOTLRID = KL0VM001.CLOTLRID;
    ;
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      converseLib.validationFailed(18); /* data base changed by another user*/
      CLXREC.CLXERRF = "Y";
    end
  end
  ;
end // end KL0VSKB

// setup  cljrec header chgs.
Function KL0VSKC()
  ;
  CLXREC.CLXCPROC = "CL0VSKC";
  ;
  KL0V824(); /* select unique from cljrec*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    CLJREC.CLJNCRFL = KL0VM001.CLJNCRFL;
    CLJREC.XWHCD = KL0VM001.XWHCD;
    CLJREC.ZZZCHGDT = TA2REC.TA2GRGGN;
    CLJREC.ZZZCHGTM = TA2REC.TA2TIMHM;
    ;
    KL0VSHK(); /* update cljrec.*/
    CL0VW01.CLJNCRFL = KL0VM001.CLJNCRFL;
    CL0VW01.XWHCD = KL0VM001.XWHCD;
    ;
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      converseLib.validationFailed(9);
      CLXREC.CLXERRF = "Y";
      return;
    end
  end
  ;
end // end KL0VSKC

// setup  cllrec header chgs.
Function KL0VSKD()
     /* KL0VSKD  --  SETUP CLLREC.HEADER CHGS*/
  ;
   /* *******************************************************************/
   /* *     M A I N T E N A N C E     H I S T O R Y     L O G          **/
   /* *----------------------------------------------------------------**/
   /* *   DATE    PGMR    DESCRIPTION                                  **/
   /* *----------------------------------------------------------------**/
   /* * 11-12-93  GDECKE  REMOVE OVERLAPPING MOVE                      **/
   /* *******************************************************************/
  CLXREC.CLXCPROC = "CL0VSKD";
  ;
  ;
  KL0V844(); /* select unique from cllrec*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    ;
    CLLREC.XWHCD = KL0VM001.XWHCD;
    CLLREC.ZZZCHGDT = TA2REC.TA2GRGGN;
    CLLREC.ZZZCHGTM = TA2REC.TA2TIMHM;
    ;
    KL0VSHM(); /* update cllrec.*/
    CL0VW01.XWHCD = KL0VM001.XWHCD;
    ;
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      converseLib.validationFailed(9);
      CLXREC.CLXERRF = "Y";
    end
  end
  ;
  KL0V994(); /* select unique from cl2rec*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    ;
    CL2REC.XXXUSRID = KL0VM001.XXXUSRID;
    CL2REC.CL2ISBDT = CL0VW01.CL2ISBDT;
    CL2REC.ZZZCHGDT = TA2REC.TA2GRGGN;
    CL2REC.ZZZCHGTM = TA2REC.TA2TIMHM;
    ;
    KL0V997(); /* update cl2rec.*/
    CL0VW01.XXXUSRID = KL0VM001.XXXUSRID;
    CL0VW01.CL0VMIDT = KL0VM001.CL0VMIDT;
    ;
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      converseLib.validationFailed(9);
      CLXREC.CLXERRF = "Y";
    end
  end
  ;
end // end KL0VSKD

// update clorec header chgs
Function KL0VSKE()
  ;
  CLXREC.CLXCPROC = "CL0VSKE";
  ;
  KL0V837(); /* replace defective header*/
  ;
  ;
  ;
  ;
end // end KL0VSKE

//*** RECORD=CL0VW01 ****
// this is the main working storage record for cl0v.
// ;
// all the fields are temporary holding areas, for maps
// cl0vm001 and the header portation of cl0vm005.
// ;
// some of the fields are reset each time a funtion is
// successfully performed. while other fields from the header
// maps do not change.
// ;
// ;***********************************************************
// ;
// ;
// ; maintenance log:
// ;
// ;   date       who      why
// ; --------   -------    ------------------------------------
// ; 06-29-87   jricha     created application
// ;
// ;
// ;
// ;***********************************************************
// ***********************
Record CL0VW01 type basicRecord
  10 CL0VWGP CL0VWGP ; 
    15 CL0VWDFQ CL0VWDFQ ; 
    15 FY1FCTYC FY1FCTYC ; 
    15 CL0VWFL CL0VWFL ; 
      20 CL0VWLFL CL0VWLFL ; 
      20 CL0VWOFL CL0VWOFL ; 
      20 CL0VWJFL CL0VWJFL ; 
      20 CL0VW2FL CL0VW2FL ; 
      20 CL0VWHDF CL0VWHDF ; 
      20 CL0VWDEF CL0VWDEF ; 
      20 CL0VWELF CL0VWELF ; 
      20 CL0VWLDF CL0VWLDF ; 
      20 CL0VWEHF CL0VWEHF ; 
      20 CL0VWEDF CL0VWEDF ; 
      20 CL0VWCFL CL0VWCFL ; 
      20 CL0VWUDF CL0VWUDF ; 
      20 CL0VWWRF CL0VWWRF ; 
      20 CL0VWPEF CL0VWPEF ; 
    15 CLACLMNB CLACLMNB ; 
    15 CLHSEQNB CLHSEQNB ; 
    15 KUCCOID KUCCOID ; 
    15 KUMSTRID KUMSTRID ; 
    15 XNXCD XNXCD ; 
    15 KUCCONM KUCCONM ; 
    15 CLODMAMT CLODMAMT ; 
    15 CLJTATHQ CLJTATHQ ; 
    15 CLJNCRFL CLJNCRFL ; 
    15 YCTCD YCTCD ; 
    15 XWHCD XWHCD ; 
    15 XWHABRV XWHABRV ; 
    15 CLOFGAQ CLOFGAQ ; 
    15 CLOFGAAM CLOFGAAM ; 
    15 CLOTLRID CLOTLRID ; 
    15 XXXUSRID XXXUSRID ; 
    15 KUYREPNM KUYREPNM ; 
    15 CL0VMIDT CL0VMIDT ; 
    15 CL0VMICF CL0VMICF ; 
    15 CL2ISXDT CL2ISXDT ; 
    15 CLPVLDFL CLPVLDFL ; 
    15 CLORCTFL CLORCTFL ; 
    15 CLKPRCFF CLKPRCFF ; 
  10 CL2ISBDT CL2ISBDT ; 
  10 CLGCMSEQ CLGCMSEQ ; 
  10 CL0VWMGT CL0VWMGT ; 
    15 CL0VWMNB CL0VWMNB ; 
    15 CL0VWMSG CL0VWMSG ; 
  10 CL0VWGIT CL0VWGIT ; 
    15 CL0VWITM CL0VWITM [20] ; 
  10 SY1STNBR SY1STNBR ; 
    15 CL0VWSTY CL0VWSTY [6] ; 
  10 SY2CLRID SY2CLRID ; 
    15 CL0VWCLR CL0VWCLR [3] ; 
  10 XDMCD XDMCD ; 
    15 CL0VWXDM CL0VWXDM [2] ; 
  10 XATCD XATCD ; 
  10 CLKCLPRC CLKCLPRC ; 
  10 CL0VWPCP CL0VWPCP ; 
  10 CL0VWSTP CL0VWSTP ; 
  10 CL0VWCLP CL0VWCLP ; 
  10 CL0VWAAM CL0VWAAM ; 
  10 CL0VWAMT CL0VWAMT ; 
  10 CL0VWMAM CL0VWMAM ; 
  10 CL-CLCOM-FL CL-CLCOM-FL ; 
  10 CLAESTVL CLAESTVL ; 
  10 CLOTDFQY CLOTDFQY ; 
  10 YDFKEY YDFKEY ; 
    15 YDFCD YDFCD ; 
    15 XGPCD XGPCD ; 
  10 CL0VWHST CL0VWHST ; 
  10 CL0VWHCL CL0VWHCL ; 
  10 CL0VWHDM CL0VWHDM ; 
  10 CL0VWYMD CL0VWYMD ; 
  10 CL0VWMX CL0VWMX ; 
  10 CL0VWMXL CL0VWMXL ; 
end // end CL0VW01

//*** RECORD=CL0VW02 ****
// **************  Claim Defective working storage table ******
// 
//                 cl0vw02
// this is a working storage array for the defective detail
// table. the array is setup to hold a maximum of 200 rows.
// 
// 
// Date Created:        03/01/87
// 
// Maintenance Log:
// 
//   Date    Init.      Comment
// --------  -----      ---------------------------------------
// 05-05-87  jricha     Initial record creation
// 10-04-90  CHELLM     Added XQACD.
// 
// ***********************
Record CL0VW02 type basicRecord
  5 XWHCD XWHCD ; 
  5 CLOTLRID CLOTLRID ; 
  5 CLJNCRFL CLJNCRFL ; 
  5 CL0VMIDT CL0VMIDT ; 
  5 XXXUSRID XXXUSRID ; 
  5 KUYREPNM KUYREPNM ; 
  5 CL0VW2GP CL0VW2GP [500] ; 
    10 CL0VMSEL CL0VMSEL ; 
    10 SY1STNBR SY1STNBR ; 
    10 SY2CLRID SY2CLRID ; 
    10 XDMCD XDMCD ; 
    10 YDDCD YDDCD ; 
    10 XUMCD XUMCD ; 
    10 XQACD XQACD ; 
    10 CLKCLPRC CLKCLPRC ; 
    10 CLKPRCFF CLKPRCFF ; 
    10 FY1FCTYC FY1FCTYC ; 
    10 PC3POIDT PC3POIDT ; 
    10 CLPVLDFL CLPVLDFL ; 
    10 CLPCRTNB CLPCRTNB ; 
    10 YDFCD YDFCD ; 
    10 CL0VWDFQ CL0VWDFQ ; 
  5 CL0VW2GB CL0VW2GB [500] ; 
    10 CLPDEFQ CLPDEFQ ; 
    10 YDRCD YDRCD ; 
    10 CLNNCRQ CLNNCRQ ; 
    10 CLPRTCTQ CLPRTCTQ ; 
    10 CL0VWNRQ CL0VWNRQ ; 
    10 CL-CLCOM-FL CL-CLCOM-FL ; 
    10 CLGCMSEQ CLGCMSEQ ; 
    10 ZZZCHGDT ZZZCHGDT ; 
    10 ZZZCHGTM ZZZCHGTM ; 
    10 ZZZCHGCT ZZZCHGCT ; 
end // end CL0VW02

//*** RECORD=CL0VW03 ****
// * 02-22-90 CHELLM Deleted pd1ftyno. No longer used.
// *          DWPROD.VFCTY001 was replaced by DFCTY.VFCTY001.
// ***********************
Record CL0VW03 type basicRecord
  5 CL0VW3GP CL0VW3GP ; 
    10 CL0VWFTY CL0VWFTY [100] ; 
      15 FY1FCTYC FY1FCTYC ; 
end // end CL0VW03

//*** RECORD=CL0VW04 ****
// pass calculated sums from dclaim.vdefit01.  if no rows exist
// that fit the where clause then null values are passed in
// the sum fields. for this reason the indicator fields need to
// be checked.  if the indicator is negative or zero move zero
// to the sum field.
// ***********************
Record CL0VW04 type basicRecord
  5 CL0VW4GR CL0VW4GR ; 
    10 CL0VWSQL CL0VWSQL ; 
    10 CL0VWCNT CL0VWCNT ; 
    10 CLOTDFQY CLOTDFQY ; 
    10 CL0VWIN1 CL0VWIN1 ; 
    10 CLMTNCRQ CLMTNCRQ ; 
    10 CL0VWIN2 CL0VWIN2 ; 
    10 CLOTRCQY CLOTRCQY ; 
    10 CL0VWIN3 CL0VWIN3 ; 
    10 CL0VWAMT CL0VWAMT ; 
    10 CL0VWIN4 CL0VWIN4 ; 
    10 CL0VWTDQ CL0VWTDQ ; 
    10 CL0VWTNQ CL0VWTNQ ; 
end // end CL0VW04

//*** RECORD=CL0VW05 ****
// pass calculated sums from dclaim.vclglx01.  if no rows exist
// that fit the where clause then null values are passed in
// the sum fields. for this reason the indicator fields need to
// be checked.  if the indicator is negative or zero move zero
// to the sum field.
// ***********************
Record CL0VW05 type basicRecord
  5 CL0VW5GR CL0VW5GR ; 
    10 CL0VWSQL CL0VWSQL ; 
    10 CL0VWMAX CL0VWMAX ; 
    10 CL0VWCNT CL0VWCNT ; 
    10 CL0VWGLA CL0VWGLA ; 
    10 CL0VWIN1 CL0VWIN1 ; 
end // end CL0VW05

//*** RECORD=CL0VW06 ****
// pass calculated sums from dclaim.vclglx01.  if no rows exist
// that fit the where clause then null values are passed in
// the sum fields. for this reason the indicator fields need to
// be checked.  if the indicator is negative or zero move zero
// to the sum field.
// ***********************
Record CL0VW06 type basicRecord
  5 CL0VW6GR CL0VW6GR ; 
    10 CL0VWSQL CL0VWSQL ; 
end // end CL0VW06

//*** RECORD=CL0VW07 ****
// IO3310:
// pass PO Number Date to iomod.
// 06-14-90 CHELLM Created record.
// ***********************
Record CL0VW07 type basicRecord
  10 CL0VWSQL CL0VWSQL ; 
  10 CL0VWCN1 CL0VWCN1 ; 
  10 CL0VWDT1 CL0VWDT1 ; 
  10 CL0VWDT2 CL0VWDT2 ; 
end // end CL0VW07

// map insp-flag
DataItem CL0VMICF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// map insp-date
DataItem CL0VMIDT char(8)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// cl0vm005 map select
DataItem CL0VMSEL char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// (2) return insp. add flag
DataItem CL0VW2FL char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// record group level
DataItem CL0VW2GB char(27)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// record group level
DataItem CL0VW2GP char(43)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// cl0vw03 record group level
DataItem CL0VW3GP char(400)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// record group level
DataItem CL0VW4GR char(42)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// record group level
DataItem CL0VW5GR char(20)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// record group level
DataItem CL0VW6GR char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// freight amount hold field
DataItem CL0VWAAM decimal(9,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// merchandise amt. hold field
DataItem CL0VWAMT decimal(15,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// end of adding comment flag
DataItem CL0VWCFL char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// default price by style,color
DataItem CL0VWCLP decimal(7,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// color number char. 1-3
DataItem CL0VWCLR char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// counter for db item
DataItem CL0VWCN1 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// counter
DataItem CL0VWCNT int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// detail complete flag
DataItem CL0VWDEF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// total qty
DataItem CL0VWDFQ int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = nullFill, inputRequired = no
}
end

// PO Number Date
DataItem CL0VWDT1 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// PO Number Date
DataItem CL0VWDT2 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = nullFill, inputRequired = no
}
end

// end of detail flag
DataItem CL0VWEDF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// end of header flag
DataItem CL0VWEHF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// end of list  flag
DataItem CL0VWELF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// all the internal flags
DataItem CL0VWFL char(14)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// factory group
DataItem CL0VWFTY char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// group level fir cl0vwitm
DataItem CL0VWGIT char(20)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// cl-gl-amt
DataItem CL0VWGLA decimal(15,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// cl0vw01 group level
DataItem CL0VWGP char(161)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// hold first color code
DataItem CL0VWHCL char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// header complete  flag
DataItem CL0VWHDF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// hold first dimension code
DataItem CL0VWHDM char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// hold first style number
DataItem CL0VWHST char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// indicator
DataItem CL0VWIN1 smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// indicator
DataItem CL0VWIN2 smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// indicator
DataItem CL0VWIN3 smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// indicator
DataItem CL0VWIN4 smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// cl0vm005 item line for pf7&8
DataItem CL0VWITM char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// (J) return auth. add flag
DataItem CL0VWJFL char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// end of detail list flag
DataItem CL0VWLDF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// (L) actual return add. flag
DataItem CL0VWLFL char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// tempory merchandize amt. field
DataItem CL0VWMAM decimal(11,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// counter
DataItem CL0VWMAX int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// message for tot. rec. selected
DataItem CL0VWMGT char(54)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// number of items selected.
DataItem CL0VWMNB num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// message line
DataItem CL0VWMSG char(50)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// max number lines in cl0vw05
DataItem CL0VWMX smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// max cl0vw05 lines, less 1
DataItem CL0VWMXL smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// cl-noncr-def-qty
DataItem CL0VWNRQ int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = nullFill, inputRequired = no
}
end

// (O) defective header add flag
DataItem CL0VWOFL char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// product price/cost pct
DataItem CL0VWPCP decimal(5,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// price error flag
DataItem CL0VWPEF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// sql selection
DataItem CL0VWSQL char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// default price by style
DataItem CL0VWSTP decimal(7,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// style nuber char. 1-6
DataItem CL0VWSTY char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// total qty
DataItem CL0VWTDQ int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// total noncredit-nonreturn qty
DataItem CL0VWTNQ int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// updates allowed flag
DataItem CL0VWUDF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// warning flag
DataItem CL0VWWRF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// xdmcd char. 1-2
DataItem CL0VWXDM char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// work date yymmdd
DataItem CL0VWYMD num(8)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

