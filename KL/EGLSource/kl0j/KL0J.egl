package kl0j;

import corpcom1.*;
import corpcom2.XQWREC;
import corpcom3.XPCL002;
import corpcom3.XPCL010;
import corpcom3.XPCL011;
import corpcom4.XSENTRY;
import corpcom4.XSSEGTR;
import corpcom5.COMMAREA;
import corpcom5.ERRSQLCA;
import corpcom5.GLACD;
import corpcom6.SQLCA;
import corpx1.XAUTBL;
import corpx1.XDMCD;
import corpx1.XGPCD;
import corpx1.XHDCD;
import corpx1.XHDKEY;
import corpx1.XHDTBL;
import corpx2.XSECD;
import corpx2.XSTCD;
import corpy2.YAPCD;
import corpy2.YATTBL;
import corpy2.YCGTBL;
import corpy2.YCRTBL;
import corpy2.YCSTBL;
import corpy2.YCTTBL;
import corpy2.YMDCD;
import corpy2.YSRSLSRG;
import corpz3.ZZZCHGCT;
import corpz3.ZZZCHGDT;
import corpz3.ZZZCHGTM;
import iv.common.IV0IVCID;
import iv.common.IV0PARTN;
import iv.common.IV3REC;
import iv.common.IV6FBTYP;
import iv.common.IV6GLSEQ;
import iv.common.IV6REC;
import ku.common.KUCREC;
import op.common.OP2LNINB;
import pf.common.PFJREC;
import pf.common.PFJXREF;
import sy.common.SY1STNBR;
import sy.common.SY2CLRID;
import ta.common.TA1REC;
import ta.common.TA2REC;
//*** PROGRAM=KL0J ****
// ************************************************************
// kl0j   claims general ledger
// 
// overview: on the first time through, this application will
//           show all the g/l records associated with all the
//           invoices on the claim.  the user may select g/l
//           lines by entering a 'c'redit or a 'd'ebit code
//           in the left map column.  the selected g/l records
//           are then copied from the invoice to the claim
//           g/l record.
// 
//           overrides created by batch can also be 'd'ebited
//           or 'c'redited (also know as reversing). the
//           selected g/l record is copied with the following
//           modifications:
//             1.  the claim number in the comments field
//                 of the override is moved to the comments
//                 field of the reversed override.
//             2.  the apply flag is set to 'n'o.
//             3.  the cliglfiv flag is set to 'f' only because
//                 it needs to come after the 'i'nvoice g/l's
//                 and before the 'e'ntered g/l's.
// 
//           on subsequent entries to this application, all
//           processing is done using only the claim g/l
//           records.  the invoice g/l records are not used
//           again.
// 
//           when a g/l is encountered as a reversed
//           override ('f'), the original override will not
//           be shown on the screen. this is taken care of
//           in the match/merge of invoice and claim g/l's
// 
// 
//           general ledger entries may be made for any claim
//           type.  there is no limit to the number of entries.
//           a g/l entry is related to one memo by the nike
//           claim number and the sequence number.
// 
//           note that this application is similar to cl0k, the
//           nike bank claim g/l.
// 
// 
// maintenance history:
// date      by     rev description of change
// --------  ---    --  --------------------------------------
// 01-31-89  JBWOOD --  ADDED NONCSP OPTION TO CALLS
// 01-31-89  JBWOOD --  XSSEGTR LOGIC
// 03-23-89  bcourt --  drop IV0REC from table list
// 05-16-89  gdecke    DB2 structure changes: clarec, clirec.
// 08-24-89  gdecke    skip any vclivx01 lines with ivc-id=0.
// 09-22-89  bcourt    remove 5-16 ref to unused tables: X CT,
//                     X WH; & recs: KU C, SY C, SY 2.
// 01-19-90 chellm     DB2/CSP structure changes.
//                     renamed GLCD to GLACD in except for
//                     CLIREC references. Renamed XGEXREF to
//                     PFJXREF.  Removed XGETBL and replaced it
//                     with PFJREC & IO4360. Renamed XGEDESC to
//                     GLADESC. Renamed XGEFBTYP as IV6FBTYP.
// 10-22-90  bcourt    allow reversal of invoice g/ls that paid
//          &chellm    all or part of invoice with nike bank $
//                     These are really 'B'ank g/ls but treated
//                     as 'F'ace g/ls. Ident by xref = 'NBQ'
//                     Also add comments to existing code.
// 03-29-91  twatso    Change g/l code 596  to 599
//                     for non sco  acct class 93
//                     change g/l code  596  to  597
//                     for non sco  acct class not = 93
// 04-15-91  twatso    need to not show cancelled claims in
//                     the comments field on the map.
//                     Also only change the g/l on the invoice
// 06-03-91  twatso    specs have changed to be all non-sco
//                     freight charges.  now need to edit user
//                     entered g/ls to make sure they are
//                     correct.
// 06-07-91  twatso    revised a message in s52 to include 595,
//                     596, 597, 599 in msg 169
// 08-08-91  wjohns    Renamed application and commarea
//                       referrences to renamed claims appls.
// 09-18-91  ahowar    Renamed proc and sgrp from "cl" to "kl".
// 10-11-91  sgorga    DB2 changes.  Added gpc code to key to
//                     get handle code from table.  kl0j103.
//                     Also added xhdkey,xhdcd,xgpcd to cl0jw01
// 10-24-91  gdecke    process 'yit' ='o','d' claims the same
//                     way as 'i','y' claims so that gl lines
//                     will have invoice id.
// 11-11-91  twatso    added code for osd to be treated like
//                     def for installation by dec 91.
// 01-13-92  sgorga    Set ta1, ta2rec emtpy.  kl0j002,001.
// 06-23-92  GDECKE    SET RECORDS EMPTY IN KL0J001,KL0J109.
// 06-24-92  GDECKE    SET RECORDS EMPTY IN KL0J009, RESTORE
//                     KL0J109 TO 6-23-92 VERSION.
// 10-16-92  sgorga    rename cllseqnb to clhdeqnb in key field
// 11-12-93  GDECKE    REMOVE OVERLAPPING MOVE IN KL0J121.
// ************************************************************
// *********************
Program KL0J type textUIProgram //VAGen Info - main text program
  {
  includeReferencedFunctions = yes, allowUnqualifiedItemReferences = yes, 
  throwNrfEofExceptions = yes, handleHardIOErrors = no, V60ExceptionCompatibility = yes, 
  I4GLItemsNullable = no, textLiteralDefaultIsString = no, localSQLScope = yes, 
  msgTablePrefix = "CL00", inputRecord = COMMAREA, segmented = yes
  }

  // Data Declarations
  CL0JW01 CL0JW01; // record
  CL0JW02 CL0JW02; // record
  CL0JW03 CL0JW03; // record
  CL0JW04 CL0JW04; // record
  CL0JW05 CL0JW05; // record
  CL0JW06 CL0JW06; // record
  CL0JW07 CL0JW07; // record
  CL0JW08 CL0JW08; // record
  CLAREC CLAREC; // record
  CLBREC CLBREC; // record
  CLGREC CLGREC; // record
  CLHREC CLHREC; // record
  CLIREC CLIREC; // record
  CLKREC CLKREC; // record
  CLRREC CLRREC; // record
  CLWREC CLWREC; // record
  CLXREC CLXREC; // record
  COMMAREA COMMAREA ; // record
  ERRSQLCA ERRSQLCA; // record
  IV3REC IV3REC; // record
  IV6REC IV6REC; // record
  KUCREC KUCREC; // record
  PFJREC PFJREC; // record
  SQLCA SQLCA; // record
  TA1REC TA1REC; // record
  TA2REC TA2REC; // record
  XQWREC XQWREC; // record

  // VAGen Info - items needed for migration
  VAGen_EZESYS char(8);
  VAGen_EZEREPLY num(1);
  VAGen_EZE_WAIT_TIME bin(9,2);
  VAGen_EZE_ITEMLEN int;

  // Use Declarations
  use XHDTBL {deleteAfterUse = yes}; // table
  use XAUTBL {deleteAfterUse = yes}; // table
  use YATTBL {deleteAfterUse = yes}; // table
  use YCGTBL {deleteAfterUse = yes}; // table
  use YCRTBL {deleteAfterUse = yes}; // table
  use YCSTBL {deleteAfterUse = yes}; // table
  use YCTTBL {deleteAfterUse = yes}; // table
  use KL0JM.KL0JM001 // form
   {
    pfKeyEquate = no
  };

  function main()
    // VAGen Info - initialization needed for migration
    VAGen_EZESYS = VGLib.getVAGSysType();
    KL0J000: KL0J000();
    ;
    ;
    exit program;
    ;
    ;
    ;
    KL0J001: KL0J001();
    KL0J050: KL0J050();
    KL0J100: KL0J100();
    KL0J101: KL0J101();
    KL0J110: KL0J110();
    KL0J120: KL0J120();
    KL0J130: KL0J130();
    KL0J140: KL0J140();
  end // end main
end // end KL0J

// application main logic
Function KL0J000()
   /* ************************************************************/
   /* *   this is the "main logic" for the application.         **/
   /* *                                                         **/
   /* *   xsentry checks to ensure that this application was    **/
   /* *         entered from another csp application.           **/
   /* *   xclentry checks to ensure that the claim header has   **/
   /* *         been flagged as "in use" if this application    **/
   /* *         does updates.                                   **/
   /* *                                                         **/
   /* *                                                         **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0J000"; /* set current process name*/
  ;
  ;
  KL0J001(); /* initilize the application*/
  ;
  KL0JM001.XXXRVNBR = "0"; /* appl maintainence revision number*/
  CL0JW01.CL0JWLAR = 0; /* last line in array counter*/
  ;
  CLXREC.CLXEOAF = "N"; /* set end-of-application flag to 'no'*/
  CL0JW01.CL0JWMIF = "N"; /* set more-invoice-flag to 'no'*/
  CL0JW01.CL0JWAR1 = "Y"; /* set first-11-of-screen-flag to yes*/
  CL0JW01.CL0JWRFI = "N"; /* set records-from-invoice flag to no*/
  CL0JW01.CL0JWCLF = "N"; /* set complete-loop-flag to no*/
  CL0JW01.CL0JWFTT = "N"; /* set first-time-thru flag to 'n'*/
  CL0JW01.CL0JWNIF = "N"; /* set no-invoice-flag to no*/
  ;
  while (CLXREC.CLXEOAF == "N") /* while not end-of-aplication*/
    KL0J050(); /* process the application screen(s)*/
  end
  ;
  COMMAREA.CATOAP = "KL0A";
  XPCL002(); /* exit application*/
  ;
  ;
  ;
end // end KL0J000

// initialize application
Function KL0J001()
   /* ************************************************************/
   /* initialize the application working storage         **/
   /* **/
   /* describe what happens in this process                  **/
   /* **/
   /* **/
   /* 05-09-91  twatso  added the call to the kucrec          **/
   /* to get acct cls cd for the map        **/
   /* 10-23-91  gdecke  kl0j001 - count invoices even when    **/
   /* yit code is 'o' or 'd'.               **/
   /* 11-11-91  twatso  added code for osd to be treated like **/
   /* 'def' for installation in dec 91.     **/
   /* 01-13-92  sgorga  Set ta1rec, ta2rec empty.             **/
   /* 06-23-92  gdecke  clear records before using any of them**/
   /* ************************************************************/
   /* TEMP001;*/
  CLXREC.CLXCPROC = "CL0J001";
  ;
  converseVar.commitOnConverse = 1; /* force db2 to commit on each screen*/
                                   /* converse*/
  VGVar.handleHardIOErrors = 1; /* return control to program if hard db2*/
                                   /* error*/
  ;
  set TA1REC empty;
  set TA2REC empty;
  set CLAREC empty;
  XSENTRY(); /* check entered thru main*/
  XSSEGTR(); /* SET SEGMENTED TRANSACTION ID*/
  XPCL011(); /* claims entry module*/
  ;
  KL0J009(); /* set working storage records empty*/
  ;
     /* put staements here to initalize your working-storage(s),*/
     /* e.g. constants, messages, '-' for dates.*/
  ;
  CLXREC.CLXEOAF = "N"; /* set application-done-switch to 'no'*/
  CLXREC.CLXCSCRN = "KL0JM001"; /* set first screen name*/
  CLXREC.CLXSNAME[1] = "KL0JM001"; /* initialize the names of the*/
  CLXREC.CLXMAXLN[1] = 11; /* max lines on map 1*/
  CLXREC.CLXARY1X[1] = 1; /* start line on map 1*/
  CLXREC.CLXARAYX = 1; /* index to array*/
  CLXREC.CLXLINEX = 1; /* index to map line*/
  CLWREC.IV0IVCID = 0;
  CL0JW01.CL0JWICT = 0; /* set invoice-counter to 0*/
  CL0JW01.CL0JWNBF = "N"; /* set Nike Bank warning flag*/
  CL0JW01.CL0JWNBW = "N"; /* set warning flag*/
  ;
  if (CLAREC.YITCD == "Y" /* have ibm invoice*/
   || CLAREC.YITCD == "I" 
   || CLAREC.YITCD == "O" /* or invoice is 'old', 'dec',*/
   || CLAREC.YITCD == "D" /* 'more' or, 'additional.*/
   || CLAREC.YITCD == "A" /* this makes it so the gl's will*/
   || CLAREC.YITCD == "M") /* have an appropriate invoice*/
    if (CLAREC.YCTCD == "ADJ") /* associated with them.*/
      KL0J002(); /* get all invoices for this claim*/
    else
      if (CLAREC.YCTCD == "RTS"
       || CLAREC.YCTCD == "RFL"
       || CLAREC.YCTCD == "DEF"
       || CLAREC.YCTCD == "OSD"
       || CLAREC.YCTCD == "CDR")
        if (CLAREC.CLAWSENF == "N")
          /* IF CLAREC.YCTCD IN YCTTBL.YCTCD;*/
            /* AND YCTTBL.YCTRQIVC(EZETST) = 'Y';*/
          KL0J002(); /* get all invoices for this claim*/
        end
      end
    end
  end
  ;
   /* this was added 5-9-91 to get the account class code*/
   /* to the map, so later it can be used as data when trying*/
   /* to determine g/l codes*/
  ;
  set KUCREC empty;
  KUCREC.KUCCOID = CLAREC.KUCCOID;
  call "IO0240" ("S ", SQLCA, KUCREC) {isNoRefresh = yes, isExternal = yes};
  if (SQLCA.VAGen_SQLCODE == 0)
     /* MOVE KUCREC.XAUCD TO KL0JM001.XAUCD;the move happens in 101*/
  else /* because the map is cleared between*/
                                   /* here and there*/
    XPCL010(); /* abort if no company*/
  end
   /* end of 5-9-91 call*/
end // end KL0J001

// get invoices assoc with claim
Function KL0J002()
   /* *************************************************************/
   /* get all invoices associated with this claim*/
   /*  */
   /* 05-10-91 twatso  only those that have not been cancelled*/
   /* 05-13-91 twatso  get the header record to tell if it is*/
   /* cancelled - if so, don't display*/
   /* 01-13-92 sgorga  Set ta1rec empty.*/
   /* *************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0J002"; /* set current process name*/
  ;
  CLBREC.CLACLMNB = CLAREC.CLACLMNB;
  CLBREC.CLBPMIVC = "*"; /* want all invoices from clbrec.*/
  ;
  CL0JW01.CL0JW05X = 1;
  CL0JW01.CLIADVSQ = 0;
  ;
  call "IO1180" ("S3", SQLCA, CLBREC) {isNoRefresh = yes, isExternal = yes}; /* get all records*/
  if (SQLCA.VAGen_SQLCODE == 0)
     /* next sentence*/
  else
    XPCL010();
  end
  ;
  call "IO1180" ("N3", SQLCA, CLBREC) {isNoRefresh = yes, isExternal = yes}; /* fetch first from clbrec*/
  if (SQLCA.VAGen_SQLCODE == 0) /* move in key to iv6rec*/
     /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      CL0JW01.CL0JWNIF = "Y"; /* there are no invoice records*/
      return;
    else
      XPCL010();
    end
  end
  ;
  CL0JW01.CL0JWICT = 0;
  CL0JW01.CL0JWEOB = "N"; /* init end-of-clb-file-flag*/
  CL0JW01.CL0JWINX = 0;
      /* NOTE THAT THE ARRAY INDEX IS INCREMENTED IN*/
           /* process cl0j005*/
  ;
  while (CL0JW01.CL0JWEOB == "N") /* fetch up to 200 records from iv6rec*/
    if (CLBREC.IV0IVCID == 0) /* zero not valid ivc-id on clbrec*/
      set TA1REC empty;
      TA1REC.TA1DBASE = "DCLAIM";
      TA1REC.TA1TBLVU = "VCLIVX";
      CLXREC.CLXORDIV = CLAREC.CLACLMNB;
      TA1REC.TA1MAP = CLXREC.CLXORDIV;
      CL0JW01.CL0JWMOD = "IVC-ID";
      CL0JW01.CL0JWNCL = "ZERO";
      CL0JW01.CL0JWMS1 = "HD IVC=";
      CL0JW01.CL0JWCIV = CLAREC.IV0IVCID;
      CL0JW01.CL0JWMS2 = "PMY=";
      CL0JW01.CL0JWIIV = CLBREC.IV0IVCID;
      TA1REC.TA1TBLKE = CL0JW01.CL0JWMSG;
      TA1REC.TA1TYPE = "DB2"; /* abend type;*/
      TA1REC.TA1FUNC = "POST"; /* abend func post to log:no msg shown*/
      TA1REC.TA1PGMNM = COMMAREA.CACURRAP; /* appl name*/
      TA1REC.TA1LOCAT[1] = "CL0J002"; /* aborting process*/
      try
        call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes};
      end /* messg then return*/
       /* fetch record from clbrec*/
      call "IO1180" ("N3", SQLCA, CLBREC) {isNoRefresh = yes, isExternal = yes};
      if (SQLCA.VAGen_SQLCODE == 0) /* move in key to iv6rec*/
         /* next sentence*/
      else
        if (SQLCA.VAGen_SQLCODE == 100)
          CL0JW01.CL0JWICT = CL0JW01.CL0JWINX;
          CL0JW01.CL0JWEOB = "Y";
        else
          XPCL010();
        end
      end
    else
      ;
      CL0JW01.CL0JWINX = CL0JW01.CL0JWINX + 1;
      CL0JW06.IV0PARTN[CL0JWINX] = CLBREC.IV0PARTN;
      CL0JW06.IV0IVCID[CL0JWINX] = CLBREC.IV0IVCID;
       /* fetch record from clbrec*/
      call "IO1180" ("N3", SQLCA, CLBREC) {isNoRefresh = yes, isExternal = yes};
      if (SQLCA.VAGen_SQLCODE == 0) /* move in key to iv6rec*/
         /* next sentence*/
      else
        if (SQLCA.VAGen_SQLCODE == 100)
          CL0JW01.CL0JWICT = CL0JW01.CL0JWINX;
          CL0JW01.CL0JWEOB = "Y";
        else
          XPCL010();
        end
      end
    end
  end
  ;
  if (CL0JW01.CL0JWINX == 0) /* if no valid invoice xref lines found*/
    CL0JW01.CL0JWNIF = "Y"; /* there are no invoice records*/
  end
  ;
end // end KL0J002

// get all invoice g/l's for clm
Function KL0J003()
   /* *************************************************************/
   /* *     get all of the g/l's for this invoice*/
   /* **/
   /* **/
   /* **/
   /* **/
   /* **/
   /* **/
   /* *************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0J003"; /* set current process name*/
  ;
  IV6REC.IV0PARTN = CL0JW06.IV0PARTN[CL0JWINX];
  IV6REC.IV0IVCID = CL0JW06.IV0IVCID[CL0JWINX];
  ;
  IV6REC.OP2LNINB = -1; /* want all g/l's for this invoice*/
  ;
  ;
  call "IO1080" ("SS", SQLCA, IV6REC) {isNoRefresh = yes, isExternal = yes}; /* get all records*/
  if (SQLCA.VAGen_SQLCODE == 0)
     /* next sentence*/
  else
    XPCL010(); /* abort*/
  end
  ;
  ;
  KL0J007(); /* fetch first iv6rec*/
  ;
  ;
  ;
end // end KL0J003

// get g/ls from clms, using invc
Function KL0J004()
   /* *************************************************************/
   /* *     get all of the g/l's on all claims, for this invoice*/
   /* **/
   /* * 10-22-90 bcourt improve comments*/
   /* **/
   /* *************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0J004"; /* set current process name*/
  ;
  ;
  CLIREC.CLHSEQNB = CLWREC.CLHSEQNB;
  ;
  if (CL0JW01.CL0JWICT > 0)
    CLIREC.IV0IVCID = CL0JW06.IV0IVCID[CL0JWINX];
    call "IO1300" ("S4", SQLCA, CLIREC) {isNoRefresh = yes, isExternal = yes};
                                   /* get all records for ivc*/
  else
    CLIREC.IV0IVCID = -1;
    CLIREC.CLACLMNB = CLAREC.CLACLMNB;
    call "IO1300" ("S3", SQLCA, CLIREC) {isNoRefresh = yes, isExternal = yes};
                                   /* get all records for clm*/
  end
  ;
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DCLAIM";
    TA1REC.TA1TBLVU = "VCLGLX01";
    TA1REC.TA1LOCAT[2] = "CL0J004";
    if (CL0JW01.CL0JWICT > 0)
      TA1REC.TA1LOCAT[3] = "SEL 4";
    else
      TA1REC.TA1LOCAT[3] = "SEL 3";
    end
    CLXREC.XXXWDTE = CLAREC.CLACLMNB;
    TA1REC.TA1TBLKE = CLXREC.XXXWDTE;
    XPCL010(); /* abort*/
  end
  ;
  ;
  ;
  KL0J008(); /* fetch first clirec*/
  ;
end // end KL0J004

// build G/L array from clm / ivc
Function KL0J005()
   /* ************************************************************/
   /* *      build an array of all invoice and item g/l         **/
   /* *      records currently associated with this claim       **/
   /* *                                                         **/
   /* *  Maintenance History:                                   **/
   /* *                                                         **/
   /* *  01-19-90 CHELLM renamed CL0JW01.GLCD as CLACD          **/
   /* *                                                         **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0J005"; /* set up current process name*/
  ;
  ;
  CL0JW01.CL0JWDON = "N"; /* no, we're not done*/
  CL0JW01.GLACD = " "; /* store gl code for override reversals*/
  ;
  ;
  if (IV6REC.IV0IVCID == 999999999
   && CLIREC.IV0IVCID == 999999999)
    CL0JW01.CL0JWDON = "Y";
  end
  ;
  ;
  ;
  while (CL0JW01.CL0JWDON == "N" /* while not done*/
   && CL0JW01.CL0JW05X < 200)
    if (CLIREC.CLIGLFIV == "E"
     && CLIREC.CLIGLOIN != "Y") /* not an override*/
      KL0JS62(); /* write cli to table, read next cli*/
    else
      if (IV6REC.OP2LNINB == CLIREC.OP2LNINB)
        if (IV6REC.GLACD == CLIREC.GLACD)
          if (IV6REC.IV6GLSEQ == CLIREC.IV6GLSEQ)
            KL0JS60(); /* write cli to table, read both cli & iv6*/
          else
            if (IV6REC.IV6GLSEQ < CLIREC.IV6GLSEQ)
              KL0JS61(); /* write iv6 to table, read next iv6*/
            else
              KL0JS62(); /* write cli to table, read next cli*/
            end
          end
        else
          if (IV6REC.GLACD < CLIREC.GLACD)
            KL0JS61(); /* write iv6 to table, read next iv6*/
          else
            KL0JS62(); /* write cli to table, read next cli*/
          end
        end
      else
        if (IV6REC.OP2LNINB < CLIREC.OP2LNINB)
          KL0JS61(); /* write iv6 to table, read next iv6*/
        else
          KL0JS62(); /* write cli to table, read next cli*/
        end
      end
    end
    if (IV6REC.IV0IVCID == 999999999
     && CLIREC.IV0IVCID == 999999999)
      CL0JW01.CL0JWDON = "Y";
    end
  end
  ;
   /* need to close*/
  call "IO1080" ("CS", SQLCA, IV6REC) {isNoRefresh = yes, isExternal = yes};
  call "IO1300" ("S3", SQLCA, CLIREC) {isNoRefresh = yes, isExternal = yes};
   /* CALL IO1300 'S4',SQLCA,CLIREC (NOMAPS,NONCSP;*/
end // end KL0J005

// bld g/l rec in array W03 & W05
Function KL0J006()
   /* *************************************************************/
   /* *      build an image of the claims g/l record             **/
   /* *      and move that image to the working storage array    **/
   /* *      (cl0jw05)                                           **/
   /* *                                                          **/
   /* *  Maintenance History:                                    **/
   /* *                                                          **/
   /* * 01-19-90 CHELLM renamed CL0JW03.GLCD to GLACD and        **/
   /* *                 renamed CL0JW03.XGEXREF to PFJXREF       **/
   /* * 10-22-90 BCOURT force 'G/L apply flag' = 'y' for "NBQ" G/L*/
   /* *                 since invoice paid with Nike bank co-op$$**/
   /* * 02-15-91 CHELLM Increased occurrences of XHDCD on the    **/
   /* *                 IV6REC from 3 to 5.                      **/
   /* *************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0J006"; /* set current process name*/
  ;
  ;
  ;
  CL0JW03.CLACLMNB = CLAREC.CLACLMNB; /* claim #*/
  CL0JW03.CLHSEQNB = CLAREC.CLACSQNB; /* memo seq #*/
  CL0JW03.IV0PARTN = IV6REC.IV0PARTN;
  CL0JW03.IV0IVCID = IV6REC.IV0IVCID; /* invc #*/
  CL0JW03.OP2LNINB = IV6REC.OP2LNINB;
  CL0JW03.PFJXREF = IV6REC.PFJXREF; /* (01-19-90) cross-ref 3 chars.*/
  CL0JW03.IV6FBTYP = IV6REC.IV6FBTYP; /* face/bank type*/
  CL0JW03.GLACD = IV6REC.GLACD; /* (01-19-90) G/L code*/
  CL0JW03.IV6GLSEQ = IV6REC.IV6GLSEQ;
  CL0JW03.CLIGLNFL = IV6REC.IV6GLNFL; /* net flag*/
  CL0JW03.CLIGLPC = IV6REC.IV6GLPCT; /* percent*/
  CL0JW03.CLIGLAM = IV6REC.IV6GLAMT; /* amount*/
  CL0JW03.CLIADVSQ = 0;
  CL0JW03.CLIGLOIN = "N"; /* override flag*/
  CL0JW03.CLICRDFL = " ";
  CL0JW03.CLIGLFIV = "I";
  CL0JW03.CLGCMSEQ = 0;
  ;
  ;
   /* FYI - when percent = 0, net flag = ' '.*/
  ;
  if (IV6REC.IV6GLPCT > 0)
    if (IV6REC.IV6GLNFL == "Y") /* net g/l's don't apply*/
      CL0JW03.CLIIGOFL = "N";
    else
      CL0JW03.CLIIGOFL = "Y"; /* apply g/l to claim*/
    end
  else
     /* IF IV6REC.PFJXREF = 'NBQ';10-22-90 force 'apply flag' = 'y'*/
    /* OVE 'Y' CL0JW03.CLIIGOFLwhen have ivc pd with nike bank $$.*/
     /* ELSE ;*/
    CL0JW03.CLIIGOFL = "N";
                                   /* have amount (orig code, before 10-22)*/
     /* END ;*/
  end
  ;
  ;
  if (IV6REC.OP2LNINB == 0)
    CL0JW03.SY1STNBR = " ";
    CL0JW03.SY2CLRID = " ";
    CL0JW03.XDMCD = " ";
    CL0JW03.XHDCD = " ";
  else
    IV3REC.IV0PARTN = IV6REC.IV0PARTN;
    IV3REC.IV0IVCID = IV6REC.IV0IVCID;
    IV3REC.OP2LNINB = IV6REC.OP2LNINB;
     /* get item record for this line item*/
    call "IO1100" ("S ", SQLCA, IV3REC) {isNoRefresh = yes, isExternal = yes};
    if (SQLCA.VAGen_SQLCODE == 0)
      CL0JW03.SY1STNBR = IV3REC.SY1STNBR;
      CL0JW03.SY2CLRID = IV3REC.SY2CLRID;
      CL0JW03.XDMCD = IV3REC.XDMCD;
      if (IV6REC.IV6GLSEQ == "1")
        CL0JW03.XHDCD = IV3REC.XHDCD[1];
      else
        if (IV6REC.IV6GLSEQ == "2")
          CL0JW03.XHDCD = IV3REC.XHDCD[2];
        else
          if (IV6REC.IV6GLSEQ == "3")
            CL0JW03.XHDCD = IV3REC.XHDCD[3];
          else
            if (IV6REC.IV6GLSEQ == "4") /* 2-15-91*/
              CL0JW03.XHDCD = IV3REC.XHDCD[4];
            else
              if (IV6REC.IV6GLSEQ == "5")
                CL0JW03.XHDCD = IV3REC.XHDCD[5];
              else
                TA1REC.TA1TBLKE = "G/L SEQ NBR GREATER THAN 5";
                XPCL010();
              end
            end
          end
        end
      end
    else
      TA1REC.TA1TBLKE = "NO IV3 RECORD FOR GL LINE ITEM";
      XPCL010();
    end
  end
  ;
  ;
end // end KL0J006

// read next iv6 record
Function KL0J007()
   /* *************************************************************/
   /* *     fetch the next iv6 record*/
   /* **/
   /* * Maintenance History:*/
   /* * 01-19-90 chellm  renamed iv6rec.glcd as glacd*/
   /* * 10-22-90 bcourt '595' is shipping charge with no XREF*/
   /* *                 '596' is   "        "    with XREF = 'SHP'*/
   /* * 06-04-91 twatso '596' will be changed to '597' or '599'*/
   /* *                  depending on xaucd and yctcd*/
   /* *************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0J007"; /* set current process name*/
  ;
  call "IO1080" ("SN", SQLCA, IV6REC) {isNoRefresh = yes, isExternal = yes}; /* fetch record from clbrec*/
  if (SQLCA.VAGen_SQLCODE == 0) /* move in key to iv6rec*/
    if (IV6REC.GLACD == "595")
      IV6REC.GLACD = "596";
    end
     /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      set IV6REC empty;
      IV6REC.IV0IVCID = 999999999;
      IV6REC.OP2LNINB = 9999;
      return;
    else
      XPCL010();
    end
  end
  ;
  if (IV6REC.GLACD == "596" /* begin 06-04-91 change*/
   && CLAREC.YCTCD != "SCO") /* shipping chg only*/
    if (KL0JM001.XAUCD != "93") /* accounting class*/
      IV6REC.GLACD = "599";
    else
      IV6REC.GLACD = "597";
    end
  end
  ;
end // end KL0J007

// fetch next cli record
Function KL0J008()
   /* *************************************************************/
   /* *     fetch the next cli record*/
   /* **/
   /* *10-22-90 bcourt  improve comments. Split huge if-else.*/
   /* *05-15-91 twatso  where reading the clirec for all claims*/
   /* *                 changed so any claims which are cancelled*/
   /* *                 are not included in the array to be shown*/
   /* *                 on the screen - to cut out the*/
   /* *                 garbage showing on all lines*/
   /* *************************************************************/
  ;
  ;
  CLXREC.CLXCPROC = "CL0J008"; /* set current process name*/
  ;
   /* if reading database with the invoice number as the key,*/
   /* some g/l's might show up that don't relate to this claim*/
   /* (because they are not overrides). have to read past those*/
   /* g/l's. also read past g/l's with non-qualifying date.*/
  ;
    /* 05-15-91 change is in this paragraph - do not allow*/
    /* cancelled claims to show on the screen*/
  ;
  if (CL0JW01.CL0JWICT > 0)
    CLXREC.CLXTESTF = "N";
    while (CLXREC.CLXTESTF == "N")
      ;
      set SQLCA empty;
      call "IO1300" ("N4", SQLCA, CLIREC) {isNoRefresh = yes, isExternal = yes}; /* fetch from clirec*/
      if (SQLCA.VAGen_SQLCODE == 0) /* if good return*/
        KL0JS30(); /* read clarec for status 5-15-91*/
        if (CLXREC.CLXTESTF == "C") /* has been cancelled*/
          CLXREC.CLXTESTF = "N"; /* do not use it*/
        else
          if (CLIREC.CLACLMNB == KL0JM001.CLACLMNB)
                                   /* have same claim number*/
            CLXREC.CLXTESTF = "Y"; /* use it*/
          else
            if (CLIREC.CLIGLOIN == "Y") /* have override*/
              if (KL0JM001.CLHMEMNB > 0) /* working w/ completed claim*/
                if (CLIREC.ZZZCHGDT < CL0JW01.ZZZCHGDT)
                  CLXREC.CLXTESTF = "Y"; /* use g/l if date < clm dt*/
                else
                  if (CLIREC.ZZZCHGDT == CL0JW01.ZZZCHGDT
                   && CLIREC.ZZZCHGTM < CL0JW01.ZZZCHGTM)
                     /* use ovrd before curr dt/tm*/
                    CLXREC.CLXTESTF = "Y";
                  else
                     /* look at memo sequence number*/
                    if (CLIREC.ZZZCHGTM == CL0JW01.ZZZCHGTM)
                      CLHREC.CLACLMNB = CLIREC.CLACLMNB;
                      CLHREC.CLHSEQNB = CLIREC.CLHSEQNB;
                      call "IO1290" ("SA", SQLCA, CLHREC) {isNoRefresh = yes, isExternal = yes};
                      if (SQLCA.VAGen_SQLCODE == 0)
                        if (CLHREC.CLHMEMNB <= KL0JM001.CLHMEMNB)
                          CLXREC.CLXTESTF = "Y";
                        else
                           /* next sentence - found subsequent claim*/
                        end
                      end
                    end
                  end
                end
              else
                CLXREC.CLXTESTF = "Y"; /* use g/l if clm not memoed*/
              end
            end
          end
        end
      else
        if (SQLCA.VAGen_SQLCODE == 100) /* no g/ls exist on clms for this ivc*/
          set CLIREC empty;
          CLIREC.IV0IVCID = 999999999;
          CLIREC.OP2LNINB = 9999;
          return;
        else
          XPCL010();
        end
      end
    end
    return; /* 10-22-90 break huge if-else into 2 parts by adding ezertn*/
  end
  ;
  ;
   /* 10-22-90 cl0jw01.cl0jwict = or LT 0, thus have no invc.*/
  ;
   /* will use all g/l's that we read because they all are*/
   /* associated with the same claim number ( if they have*/
   /* the correct date and have lower memo numbers).*/
  ;
  CLXREC.CLXTESTF = "N";
  while (CLXREC.CLXTESTF == "N")
    call "IO1300" ("N3", SQLCA, CLIREC) {isNoRefresh = yes, isExternal = yes}; /* fetch from clirec*/
    if (SQLCA.VAGen_SQLCODE == 0) /* if good return*/
      if (KL0JM001.CLHMEMNB > 0) /* working w/ completed claim*/
        if (CLIREC.ZZZCHGDT < CL0JW01.ZZZCHGDT) /* look at g/ls created*/
          CLXREC.CLXTESTF = "Y";
        else
          if (CLIREC.ZZZCHGDT == CL0JW01.ZZZCHGDT
           && CLIREC.ZZZCHGTM < CL0JW01.ZZZCHGTM)
            CLXREC.CLXTESTF = "Y";
          else
             /* look at memo sequence number*/
            if (CLIREC.ZZZCHGTM == CL0JW01.ZZZCHGTM)
              CLHREC.CLACLMNB = CLIREC.CLACLMNB;
              CLHREC.CLHSEQNB = CLIREC.CLHSEQNB;
              call "IO1290" ("SA", SQLCA, CLHREC) {isNoRefresh = yes, isExternal = yes};
              if (SQLCA.VAGen_SQLCODE == 0)
                if (CLHREC.CLHMEMNB <= KL0JM001.CLHMEMNB)
                  CLXREC.CLXTESTF = "Y";
                else
                   /* next sentence - found subsequent claim*/
                end
              end
            end
          end
        end
      else
        CLXREC.CLXTESTF = "Y";
      end
    else
      if (SQLCA.VAGen_SQLCODE == 100) /* no g/ls exist on clm*/
        set CLIREC empty;
        CLIREC.IV0IVCID = 999999999;
        CLIREC.OP2LNINB = 9999;
        return;
      else
        XPCL010();
      end
    end
  end
  ;
end // end KL0J008

// set working storage recs empty
Function KL0J009()
   /* *************************************************************/
   /* *           set working storage records empty              **/
   /* *************************************************************/
   /* *     M A I N T E N A N C E    H I S T O R Y    L O G      **/
   /* *----------------------------------------------------------**/
   /* *  DATE     PGMR    DESCRIPTION                            **/
   /* * 06-24-92  GDECKE  SET TABLES EMPTY                       **/
   /* *************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0J009"; /* set current process name*/
  ;
  ;
  set CLXREC empty;
  set CL0JW01 empty;
  set CL0JW02 empty; /* GDECKE - 06-24-92*/
  set CL0JW03 empty;
  set CL0JW04 empty;
  set CL0JW05 empty;
  set CL0JW06 empty;
  set CL0JW07 empty;
  set CL0JW08 empty; /* GDECKE  06-24-92*/
  set CLBREC empty;
  set CLGREC empty;
  set CLHREC empty; /* GDECKE  06-24-92*/
  set CLIREC empty;
  set CLKREC empty; /* GDECKE  06-24-92*/
  set CLRREC empty; /* GDECKE  06-24-92*/
  set XQWREC empty; /* GDECKE  06-24-92*/
  set IV3REC empty;
  set IV6REC empty;
  set KUCREC empty; /* GDECKE  06-24-92*/
  set PFJREC empty; /* GDECKE  06-24-92*/
  set SQLCA empty; /* GDECKE  06-24-92*/
  set ERRSQLCA empty; /* GDECKE  06-24-92*/
  ;
  ;
  ;
  ;
  ;
  ;
end // end KL0J009

// main cl0j branch control
Function KL0J050()
   /* ************************************************************/
   /* *   control process the application screen                **/
   /* *                                                         **/
   /* *  note that this process is being performed in a         **/
   /* *  "while loop" until the end-of-application flag is set  **/
   /* *  to 'y'.                                                **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0J050"; /* set current process name*/
  ;
  ;
  if (CLXREC.CLXCSCRN in CLXREC.CLXSNAME) /* if current-screen-name is*/
    CLXREC.CLXSCRNX = sysVar.arrayIndex; /* in the screen-array, then set*/
  end /* the screen-index*/
  ;
  ;
  CLXREC.CLXEOSF = "N"; /* set end-of-screen flag to 'no'*/
  CLXREC.CLXBLDSC = "Y"; /* set build screen flag to 'yes'*/
  ;
  ;
  while (CLXREC.CLXEOSF == "N") /* while not end-of-screen*/
    KL0J100(); /* process screen cl0jm001*/
  end
  ;
  ;
   /* at this point;*/
       /* if the end-of-application flag (clxeoaf ) = 'n'*/
         /* the perform will return to the top of cl0j050...*/
       /* else*/
         /* the perform will auto return to cl0j000.*/
  ;
  ;
  ;
end // end KL0J050

// converse screen m001
Function KL0J100()
   /* ************************************************************/
   /* *    process screen cl0jm001                              **/
   /* *                                                         **/
   /* *  note - this process is being performed in a            **/
   /* *     "while loop" from cl0j050 until the end-of-screen   **/
   /* *     flag (clxeosfl) is set to 'y'.                      **/
   /* *                                                         **/
   /* * 5-05-93 BCOURT Add menu option 19, like 09.             **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0J100"; /* set current process name*/
  ;
  if (CLXREC.CLXBLDSC == "Y")
    KL0J101(); /* build screen because new record*/
  end /* ;*/
  ;
  CLXREC.CLXBLDSC = "N"; /* skip build screen next time thru*/
    /* skip build when have errors to show, or pf12 was keyed*/
  ;
   /* place cursor in correct position*/
  if (CLWREC.CLWACTIV == "I" /* inquiry mode*/
   || KL0JM001.CLHMEMNB != 0 /* memo has been printed*/
   || CLWREC.CLWMNOPT == 7   
   || CLWREC.CLWMNOPT == 8   
   || CLWREC.CLWMNOPT == 9   
   || CLWREC.CLWMNOPT == 17  /* 5-5-93*/
   || CLWREC.CLWMNOPT == 19) /* 5-5-93*/
    set KL0JM001.CLHSEQNB cursor;
  end
  ;
   /* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
  converse KL0JM001 ;
   /* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
  ;
  CLXREC.CLXMSG = " "; /* set non-ezemno error message to*/
                                   /* spaces*/
  CLXREC.CLXERRF = "N"; /* re-set error flag*/
  ;
  KL0J110(); /* handle any special entries*/
    /* may exit appl from this process*/
  ;
  if (KL0JM001 is modified) /* if there were entries*/
    CLXREC.CLXEDITF = "Y"; /* then set do-edits-flag to 'yes'*/
  end
  ;
   /* set fields on map back to normal*/
  ;
  set KL0JM001.CLHSEQNB initialAttributes;
  set KL0JM001.CL0JWINB initialAttributes;
  ;
  if (CLXREC.CLXEDITF == "Y") /* if we still want to edit*/
    KL0J120(); /* go edit screen entries*/
  end
  ;
  if (CLXREC.CLXERRF == "Y") /* if screen has errors*/
    CL0JW01.CL0JWNBW = "N"; /* reset warnings shown flag*/
    CL0JW01.CL0JWNBF = "N"; /* reset warnings shown flag*/
  else
    if (CL0JW01.CL0JWNBF == "Y" /* if there are warnings to show*/
     && CL0JW01.CL0JWNBW == "N") /* and not already shown*/
      CL0JW01.CL0JWNBW = "Y"; /* set show warnings flag*/
    else
      CL0JW01.CL0JWNBW = "N"; /* warnings already shown*/
      CL0JW01.CL0JWNBF = "N"; /* warnings already shown*/
      converseLib.validationFailed(0);
    end
  end
  ;
      /* determine next action*/
  if (CLXREC.CLXERRF == "Y"        /* if screen has errors*/
   || converseVar.eventKey is pf12 /* or user wants to see same screen*/
   || CL0JW01.CL0JWNBW == "Y")     /* or need to show warnings*/
    CLXREC.CLXBLDSC = "N"; /* do not rebuild screen, just reshow*/
  else
    if (CLWREC.CLWACTIV == "I") /* if inquiry skip database updates*/
      /* next sentence*/
    else
       /* 1-4-88 change cl0js40 to cl0j130*/
       /* 1-4-88 change cl0j130 to cl0j140*/
      KL0J130(); /* go update data base 1-4-88*/
    end
    if (converseVar.eventKey is pf7) /* scroll commands*/
      KL0JS07();
    else
      if (converseVar.eventKey is pf8) /* process other pf keys ***/
        KL0JS08();
      else
        KL0J140(); /* act upon enter/pf key*/
      end
    end
  end /* ;*/
  ;
   /* at this point;*/
     /* if the end-of-screen flag (clxeosf) is 'n'*/
       /* the perform returns to top of process cl0j100.*/
     /* else*/
       /* the perform returns to cl0j050.*/
  ;
  ;
end // end KL0J100

// initialize screen cl0jm001
Function KL0J101()
   /* ************************************************************/
   /* *        this process initializes screen cl0jm001         **/
   /* *  it will read the necessary tables                      **/
   /* *  or will scroll forward or back                         **/
   /* *  added account class code (xaucd ) 5-9-91 tw            **/
   /* *                                                         **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0J101"; /* set current process name*/
  KL0JM001.XXXCURDT = VGVar.currentShortGregorianDate; /* set current date*/
  ;
  set KL0JM001 initial;
  set KL0JM001.CLICRDFL[1] cursor;
  KL0J109(); /* set records empty*/
  ;
  KL0JM001.CLACLMNB = CLAREC.CLACLMNB;
  KL0JM001.KUCCOID = CLAREC.KUCCOID;
  KL0JM001.KUMSTRID = CLAREC.KUMSTRID;
  KL0JM001.XNXCD = CLAREC.XNXCD;
  KL0JM001.KUCCONM = CLWREC.KUCCONM;
  KL0JM001.CLACTCNM = CLAREC.CLACTCNM;
  KL0JM001.YCTCD = CLAREC.YCTCD;
  KL0JM001.YCSCD = CLAREC.YCSCD1;
  KL0JM001.CLHSEQNB = CLWREC.CLHSEQNB;
  CLXREC.XXXCDTE = CLAREC.CLASTTDT;
  KL0JM001.CLASTTDT = CLXREC.XXXCYMD;
  ;
  KL0JM001.XAUCD = KUCREC.XAUCD; /* account class cd 05-09-91*/
  if (KL0JM001.XAUCD in XAUTBL.XAUCD)
    KL0JM001.XAUABRV = XAUTBL.XAUABRV[sysVar.arrayIndex];
  end
  ;
  KL0JS29(); /* get claim typ abrv & short status*/
                                   /* desc*/
  ;
   /* if memo exist, can't change data*/
   /* get memo date, for selection of g/l's to show on screen*/
  KL0JS28(); /* figure sequence number and get memo*/
  ;
   /* set cl0jw06 index for 1 to 200 invoices on the claim*/
   /* used in CL0J003*/
  ;
  if (CLWREC.IV0IVCID == 0)
    CL0JW01.CL0JWINX = 1;
  else
    if (CLWREC.IV0IVCID in CL0JW06.IV0IVCID)
      CL0JW01.CL0JWINX = sysVar.arrayIndex;
    else
      CLXREC.CLXWFLDN = CLWREC.IV0IVCID;
      TA1REC.TA1DBTBL = CLXREC.CLXWFLDC;
      TA1REC.TA1TBLKE = "UNKNOWN INVOICE NBR IN CLWREC";
      XPCL010();
    end
  end
  ;
  set CLGREC empty;
  set CL0JW08 empty;
  set SQLCA empty;
  ;
  CLGREC.CLACLMNB = CLAREC.CLACLMNB;
  CLGREC.CLHSEQNB = CLWREC.CLHSEQNB;
  CLGREC.CL2ISNBR = 0;
  CLGREC.CLGCMTYP = "G";
  CL0JW08.CL0JWSQL = "MX";
  ;
  call "IO1260" (CL0JW08, SQLCA, CLGREC) {isNoRefresh = yes, isExternal = yes};
                                   /* get max sequence number*/
  if (CL0JW08.CL0JWIN1 >= 0)
    CLGREC.CLGCMSEQ = CL0JW08.CL0JWCN1;
  else
    CLGREC.CLGCMSEQ = 0;
  end
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    CL0JW01.CLGCMSEQ = CLGREC.CLGCMSEQ;
  else
    TA1REC.TA1TBLKE = "GETTING MAX CLGREC SEQ NBR IN CL0J101";
    XPCL010();
  end
  ;
  set CLIREC empty;
  set CL0JW07 empty;
  set SQLCA empty;
  ;
  CLIREC.CLACLMNB = CLAREC.CLACLMNB;
  CLIREC.CLHSEQNB = CLWREC.CLHSEQNB;
  CL0JW07.CL0JWSQL = "MX"; /* get max sequence number*/
  call "IO1300" (CL0JW07, SQLCA, CLIREC) {isNoRefresh = yes, isExternal = yes};
  if (CL0JW07.CL0JWIN1 >= 0)
    CLIREC.CLIADVSQ = CL0JW07.CL0JWCN1;
  else
    CLIREC.CLIADVSQ = 0;
  end
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    CL0JW01.CLIADVSQ = CLIREC.CLIADVSQ;
  else
    TA1REC.TA1TBLKE = "GETTING MAX CLIREC SEQ NBR IN CL0J101";
    XPCL010();
  end
  ;
  CL0JW01.CL0JWNOG = 0;
  CL0JW01.CL0JW05X = 1;
  ;
  if (CL0JW01.CL0JWICT > 0   /* if there are invoices*/
   && KL0JM001.CLHMEMNB == 0 /* only get ivc g/l's if no memo*/
   && CLAREC.YCSCD1 != "CMP") /* and clm status not complete*/
    KL0J003(); /* select invoice g/l's*/
  else
    IV6REC.IV0IVCID = 999999999;
    IV6REC.OP2LNINB = 9999;
  end
  ;
  if (CL0JW01.CL0JWICT == 0) /* if there are no invoices*/
    set KL0JM001.CL0JWINB skip;
  end
  ;
  KL0J004(); /* select claims g/l's*/
  KL0J005(); /* match/merge invoice & claims g/l's*/
  ;
  CL0JW01.CL0JW05X = 1;
  CL0JW01.CL0JW05X = CL0JW01.CL0JW05X + CL0JW01.CL0JWOST;
  ;
  KL0JM001.CL0JWICT = CL0JW01.CL0JWICT; /* nbr of invoices*/
  if (CL0JW01.CL0JWICT == 0)
    KL0JM001.CL0JWINB = 0;
  else
    KL0JM001.CL0JWINB = CL0JW01.CL0JWINX;
    KL0JM001.IV0IVCID = CL0JW06.IV0IVCID[CL0JWINX];
  end
  ;
  KL0JM001.CL0JWNOG = CL0JW01.CL0JWNOG;
  ;
  CLXREC.CLXLINEX = 1;
  while (CLXREC.CLXLINEX <= 11)
    KL0J103(); /* build screen line from CL0JW05*/
    KL0J105(); /* protect screen line*/
    CL0JW01.CL0JW05X = CL0JW01.CL0JW05X + 1;
    CLXREC.CLXLINEX = CLXREC.CLXLINEX + 1;
  end
  ;
end // end KL0J101

// build screen line
Function KL0J103()
   /* *************************************************************/
   /* *     build screen line*/
   /* **/
   /* *  Maintenance History:*/
   /* * 01-19-90 CHELLM replaced the xgetbl with pfjrec&iio4360*/
   /* *          to get gldesc.*/
   /* * 10-22-90 BCOURT improve comments & spacing.*/
   /* * 05-10-91 TWATSO somewhere in here need to add the code*/
   /* *          to determine if gl code is displayed differently*/
   /* 10-11-91 DB2 changes.  Added gpc code to key to get hndl cd*/
   /* *************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0J103"; /* set current process name*/
  ;
  CL0JW04.CL0JWGUP[CLXLINEX] = "N";
  CL0JW04.CL0JWCUP[CLXLINEX] = "N";
  ;
    /* if number of g/l's equal 0*/
    /* or have shown all g/l's, then move blank lines to screen*/
  if (CL0JW01.CL0JWNOG == 0
   || CLXREC.CLXLINEX > CL0JW01.CL0JWNOG
   || CL0JW01.CL0JW05X > CL0JW01.CL0JWNOG)
    set CLIREC empty;
    CL0JW04.CL0JWAPT[CLXLINEX] = 0;
    CL0JW04.CLGCMSEQ[CLXLINEX] = 0;
    CL0JW04.CLIADVSQ[CLXLINEX] = 0;
    CL0JW04.CL0JWSFL[CLXLINEX] = "E";
    CL0JW04.CLIGLFIV[CLXLINEX] = "E";
    CL0JW04.CLIIGOFL[CLXLINEX] = "N";
    return;
  end
  ;
   /* move CL0JW05 group to CLIREC to remove subscript*/
   /* so the following moves each fit on a single line*/
   /* (multiple lines are not allowed)*/
  CL0JW04.CL0JWAPT[CLXLINEX] = CL0JW01.CL0JW05X;
  CLIREC.CLIGROUP = CL0JW05.CLIGROUP[CL0JW05X];
  CL0JW04.CL0JWSFL[CLXLINEX] = CL0JW05.CL0JWSFL[CL0JW05X];
  CL0JW04.CLGCMSEQ[CLXLINEX] = CLIREC.CLGCMSEQ;
  CL0JW04.CLIADVSQ[CLXLINEX] = CLIREC.CLIADVSQ;
  CL0JW04.CLIGLFIV[CLXLINEX] = CLIREC.CLIGLFIV;
  CL0JW04.CLIIGOFL[CLXLINEX] = CLIREC.CLIIGOFL;
  KL0JM001.IV6FBTYP[CLXLINEX] = CLIREC.IV6FBTYP;
  KL0JM001.CLIIGOFL[CLXLINEX] = CLIREC.CLIIGOFL;
  KL0JM001.CLIGLNFL[CLXLINEX] = CLIREC.CLIGLNFL;
  ;
   /* IF CL0JM001.CLICRDFL(CLXLINEX) = 'R';*/
    /* MOVE 'D' TO CL0JM001.CLICRDFL(CLXLINEX);*/
   /* ELSE ;*/
    /* IF CL0JM001.CLICRDFL(CLXLINEX) = 'S';*/
      /* MOVE 'C' TO CL0JM001.CLICRDFL(CLXLINEX);*/
   /* END ;*/
   /* END ;*/
  ;
  KL0JM001.CLICRDFL[CLXLINEX] = CLIREC.CLICRDFL;
  KL0JM001.GLACD[CLXLINEX] = CLIREC.GLACD;
  ;
   /* if the g/l was a reversal of an invoice g/l or an*/
   /* override g/l, or the g/l was created by batch but*/
   /* batch used the invoice percent to calculate the g/l*/
   /* show the*/
   /* percent in 'inv gl pct' field, else show the percent*/
   /* in the 'clm ovrd pct' field*/
  ;
  if (CLIREC.CLIGLFIV == "I") /* from invoice*/
    KL0JM001.IV6GLPCT[CLXLINEX] = CLIREC.CLIGLPC;
    set KL0JM001.CLIGLPC[CLXLINEX] protect;
  else
    if (CLIREC.CLIGLFIV == "B"
     && CLIREC.CLIGLOIN == "N"
     && CLIREC.CLIGLPPT == 0)
       /* if batch created the g/l for the products and the g/l*/
       /* wasn't on the invoice originally, batch moves 99999*/
       /* to cliglppt*/
      KL0JM001.IV6GLPCT[CLXLINEX] = CLIREC.CLIGLPC;
      set KL0JM001.CLIGLPC[CLXLINEX] protect;
    else
      if (CLIREC.CLIGLPC > 0)
        KL0JM001.CLIGLPC[CLXLINEX] = CLIREC.CLIGLPC;
      end
      if (CLIREC.PFJXREF == "NBQ") /* if coop use pct but dont allow chg*/
        KL0JM001.IV6GLPCT[CLXLINEX] = CLIREC.CLIGLPC;
        set KL0JM001.CLIGLPC[CLXLINEX] protect;
      end
    end
  end
  ;
   /* show signed amt instead of d/c in selection field*/
  CL0JW01.CL0JWNBR = 1;
  if (CLIREC.CLIGLOIN == "Y")
    if (CLIREC.CLACLMNB == KL0JM001.CLACLMNB)
       /* next sentence*/
    else
       /* show signed amt instead of d/c if g/l is an  override*/
       /* and from this claim*/
      KL0JM001.CLICRDFL[CLXLINEX] = " ";
    end
    if (CLIREC.CLICRDFL == "C"
     && CLIREC.CLIGLAM > 0
     && CLIREC.PFJXREF != "NBQ")
      CL0JW01.CL0JWNBR = -1;
    end
    KL0JM001.CLIGLAM[CLXLINEX] = CLIREC.CLIGLAM * CL0JW01.CL0JWNBR;
  else
    ;
     /* show signed amt instead of d/c on screen if g/l from invce*/
    if (CLIREC.CLIGLNFL == "Y") /* if net*/
       /* next sentence...dont show amount*/
    else
      if (CL0JW04.CL0JWSFL[CLXLINEX] == "I") /* 10-22-90 g/l is from invoice*/
        if (CLIREC.PFJXREF in YCGTBL.PFJXREF /* and is invc discount*/
         && CLIREC.CLIGLAM > 0)             
          CL0JW01.CL0JWNBR = -1;
        end
      end
      KL0JM001.CLIGLAM[CLXLINEX] = CLIREC.CLIGLAM * CL0JW01.CL0JWNBR;
    end
  end
  ;
  if (CLIREC.OP2LNINB == 0)
                               /* (begin 01-19-90 addition)*/
    PFJREC.GLACD = CLIREC.GLACD;
    ;
    call "IO4360" ("S ", SQLCA, PFJREC) {isNoRefresh = yes, isExternal = yes}; /* get gl code info*/
    ;
    if (SQLCA.VAGen_SQLCODE == 0)
      KL0JM001.GLADESC[CLXLINEX] = PFJREC.GLADESC;
    else
      if (SQLCA.VAGen_SQLCODE == 100)
        /* next sentence*/
      else
        TA1REC.TA1DBASE = "DPROFT";
        TA1REC.TA1TBLVU = "VGLCDS01";
        CLXREC.XXXWDTE = KL0JM001.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE;
        XPCL010();
      end
    end
                               /* (end 01-19-90 addition)*/
  else
   /* 10-11-91  DB2 chgs.  Add gpc code to key to get handle code*/
    CL0JW01.XHDCD = CLIREC.XHDCD; /* Move hndl cd from vclglx01*/
    CL0JW01.XGPCD = CLAREC.XGPCD; /* Move gpc code from clm hdr*/
    if (CL0JW01.XHDKEY in XHDTBL.XHDKEY) /* Use gpc/hdl cd to read xhdtbl*/
      KL0JM001.GLADESC[CLXLINEX] = XHDTBL.XHDDESC[sysVar.arrayIndex];
    end
  end
  ;
  if (CLIREC.OP2LNINB != 0)
    CL0JW04.SY1STNBR[CLXLINEX] = CLIREC.SY1STNBR;
    CL0JW04.SY2CLRID[CLXLINEX] = CLIREC.SY2CLRID;
    CL0JW04.XDMCD[CLXLINEX] = CLIREC.XDMCD;
    KL0JM001.CLGCOMNT[CLXLINEX] = CL0JW04.CL0JWCOM[CLXLINEX];
    CL0JW04.CL0JWCOM[CLXLINEX] = "NO COMMENT";
  else
    ;
     /* if have override and override wasn't generated by this*/
     /* claim, show claim number that did generate override*/
    if (CLIREC.CLIGLOIN == "Y"
     && CLIREC.CLACLMNB != KL0JM001.CLACLMNB)
      CLXREC.XXXWDTE = CLIREC.CLACLMNB; /* move binary to numeric*/
      KL0JM001.CLGCOMNT[CLXLINEX] = CLXREC.XXXWDTE; /* move num to char*/
      CL0JW04.CL0JWCOM[CLXLINEX] = "NO COMMENT";
    else
      if (CLIREC.CLGCMSEQ == 0) /* if no comments*/
        KL0JM001.CLGCOMNT[CLXLINEX] = " ";
        CL0JW04.CL0JWCOM[CLXLINEX] = " ";
      else
        KL0J104(); /* get g/l comment*/
      end
    end
  end
  ;
   /* hold map image in CL0JW02 to decide if map values changed*/
  if (CLIREC.CLIGLOIN == "Y") /* if override*/
    if (CLIREC.CLACLMNB == KL0JM001.CLACLMNB)
      CL0JW02.CLICRDFL[CLXLINEX] = CLIREC.CLICRDFL;
      CL0JW02.PFJXREF[CLXLINEX] = CLIREC.PFJXREF;
    else
      ;
       /* c/d wasn't moved to screen, the amt took on the sign*/
      CL0JW02.CLICRDFL[CLXLINEX] = KL0JM001.CLICRDFL[CLXLINEX];
    end
  else
    CL0JW02.CLICRDFL[CLXLINEX] = KL0JM001.CLICRDFL[CLXLINEX];
  end
  CL0JW02.GLACD[CLXLINEX] = KL0JM001.GLACD[CLXLINEX];
  CL0JW02.CLIGLAM[CLXLINEX] = KL0JM001.CLIGLAM[CLXLINEX];
  CL0JW02.CLIGLPC[CLXLINEX] = KL0JM001.CLIGLPC[CLXLINEX];
  CL0JW02.CLIIGOFL[CLXLINEX] = KL0JM001.CLIIGOFL[CLXLINEX];
  CL0JW02.CLGCOMNT[CLXLINEX] = KL0JM001.CLGCOMNT[CLXLINEX];
  CL0JW02.PFJXREF[CLXLINEX] = PFJREC.PFJXREF; /* 2-27-91*/
  CL0JW04.CLIGLOIN[CLXLINEX] = CLIREC.CLIGLOIN;
  ;
end // end KL0J103

// get g/l comment record
Function KL0J104()
   /* ************************************************************/
   /* **/
   /* **/
   /* **/
   /* **/
   /* **/
   /* **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0J104"; /* set current process name*/
  ;
  ;
  set CLGREC empty;
  set SQLCA empty;
  ;
  ;
  CLGREC.CLACLMNB = CLAREC.CLACLMNB; /* move comment to map.*/
  CLGREC.CLHSEQNB = CLIREC.CLHSEQNB; /* memo sequence number*/
  CLGREC.CL2ISNBR = 0; /* inspection number*/
  CLGREC.CLGCMTYP = "G"; /* comment type*/
  CLGREC.CLGCMSEQ = CLIREC.CLGCMSEQ; /* comment sequence*/
  ;
  call "IO1260" ("S ", SQLCA, CLGREC) {isNoRefresh = yes, isExternal = yes}; /* read records from clgrec*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0) /* move comment to map*/
    KL0JM001.CLGCOMNT[CLXLINEX] = CLGREC.CLGCOMNT;
    CL0JW04.CL0JWCOM[CLXLINEX] = CLGREC.CLGCOMNT;
  else
    XPCL010();
  end
end // end KL0J104

// protect the screen line
Function KL0J105()
   /* ************************************************************/
   /* *      protect the screen fields                          **/
   /* *                                                         **/
   /* * 10-22-90 bcourt drop last paragraph.                    **/
   /* *  5-05-93 BCOURT Add menu option 19, like 09.            **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0J105"; /* set current process name*/
  ;
  if (CLWREC.CLWMNOPT == 3
   || CLWREC.CLWMNOPT == 10
   || CLWREC.CLWMNOPT == 11
   || CLWREC.CLWMNOPT == 12
   || CLWREC.CLWMNOPT == 13)
    set KL0JM001.CL0JML1 skip, invisible;
    set KL0JM001.CL0JML2 skip, invisible;
    set KL0JM001.CL0JWINB skip, invisible;
    set KL0JM001.CL0JWICT skip, invisible;
  end
  ;
  if (CLWREC.CLWACTIV == "I"             
   || KL0JM001.CLHMEMNB != 0             /* or the memo has been written*/
   || KL0JM001.CLIGLNFL[CLXLINEX] == "Y" /* or the gl is netted*/
   /* the inquiry mode is not dependent on who is doing the*/
   /* accessing, but strictly on the method of access.  Even*/
   /* demo should be blocked for update/add if using menu*/
   /* option 7/8/9.*/
   || CLWREC.CLWMNOPT == 7               
   || CLWREC.CLWMNOPT == 8               
   || CLWREC.CLWMNOPT == 9               
   || CLWREC.CLWMNOPT == 17              /* 5-5-93*/
   || CLWREC.CLWMNOPT == 19)             /* 5-5-93*/
    set KL0JM001.CLICRDFL[CLXLINEX] skip;
    set KL0JM001.IV6GLPCT[CLXLINEX] skip;
    set KL0JM001.CLIGLPC[CLXLINEX] skip;
    set KL0JM001.CLIGLAM[CLXLINEX] skip;
    set KL0JM001.CLIIGOFL[CLXLINEX] skip;
    set KL0JM001.CLGCOMNT[CLXLINEX] skip;
    if (CL0JW04.CL0JWSFL[CLXLINEX] == "I") /* if record source is inv*/
      if (KL0JM001.GLACD[CLXLINEX] == "597" /* and gl code was chngd*/
       || KL0JM001.GLACD[CLXLINEX] == "599")
         /* next sentence -- leave alone - it is set*/
      end
    else
      set KL0JM001.GLACD[CLXLINEX] skip;
    end
    return;
  end
  ;
   /* any row from the invoice or an override or a reversal of*/
   /* an override is a protected row.*/
   /* selection field can change except if it's from the invoice*/
   /* and doesn't apply or an override of an override*/
   /* (cliglfiv eq 'f') and the flag says it is still an override*/
  ;
  if (CL0JW04.CLIGLFIV[CLXLINEX] == "I" /* g/l is from invoice*/
   || CL0JW04.CLIGLOIN[CLXLINEX] == "Y" /* g/l is from override*/
   || CL0JW04.CLIGLFIV[CLXLINEX] == "F")
                                   /* g/l is reversal of an override*/
    ;
    set KL0JM001.CLIGLPC[CLXLINEX] skip;
    set KL0JM001.CLIIGOFL[CLXLINEX] skip;
    set KL0JM001.CLGCOMNT[CLXLINEX] skip;
    if (PFJREC.PFJXREF != "NBQ")
      set KL0JM001.CLIGLAM[CLXLINEX] skip;
    end
    if (CL0JW04.CLIGLOIN[CLXLINEX] == "Y" 
     && CL0JW04.CLIIGOFL[CLXLINEX] == "N" /* apply flag eq 'n'*/
     && CL0JW04.CLIGLFIV[CLXLINEX] == "I")
      set KL0JM001.CLICRDFL[CLXLINEX] skip;
    end
    if (CL0JW04.CLIGLOIN[CLXLINEX] == "Y"
     && CL0JW04.CLIGLFIV[CLXLINEX] == "F")
      set KL0JM001.CLICRDFL[CLXLINEX] skip;
    end
    if (CL0JW04.CL0JWSFL[CLXLINEX] == "I") /* if record source is inv*/
      if (KL0JM001.GLACD[CLXLINEX] == "597" /* and gl code was chngd*/
       || KL0JM001.GLACD[CLXLINEX] == "599")
         /* next sentence -- leave alone - it is set*/
      end
    else
      set KL0JM001.GLACD[CLXLINEX] skip;
    end
  end
  ;
  if (CLIREC.CLIGLOIN == "Y") /* have claim number in comment field*/
    set KL0JM001.CLGCOMNT[CLXLINEX] skip;
  else
    if (CLIREC.OP2LNINB == 0) /* if not assoc with a line item*/
      /* next sentence*/
    else
      set KL0JM001.CLGCOMNT[CLXLINEX] skip;
    end
  end
  ;
   /* IF CLAREC.YCRCD IN YCRTBL.YCRCD;*/
   /* AND YCRTBL.YCRSPARN(EZETST) = 'Y'; this is a special arrang*/
    /* SET CL0JM001.CLIGLPC(CLXLINEX) AUTOSKIP;*/
   /* END ;*/
  ;
   /* 10-22-90 comment code since 'E' never moved to CL0JWSFL*/
         /* and EZERTN is redundant*/
   /* IF CL0JW04.CL0JWSFL(CLXLINEX) = 'E';*/
    /* OR CL0JW01.CL0JWNOG = 0;*/
    /* OR CLXREC.CLXLINEX GT CL0JW01.CL0JWNOG;*/
    /* EZERTN;*/
   /* END ;*/
  ;
end // end KL0J105

// clear out scrn-dependent recs
Function KL0J109()
   /* *************************************************************/
   /* *           set working storage records empty*/
   /* *************************************************************/
   /* *    M A I N T E N A N C E    H I S T O R Y    L O G       **/
   /* *----------------------------------------------------------**/
   /* *   DATE     PGMR     DESCRIPTION                          **/
   /* *----------------------------------------------------------**/
   /* *06-24-92   GDECKE   RESTORE TO 06-22-92 VERSION           **/
   /* *************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0J109"; /* set current process name*/
  ;
  ;
  set CL0JW02 empty;
  set CL0JW03 empty;
  set CL0JW04 empty;
  set CL0JW05 empty;
  set CLBREC empty;
  set CLGREC empty;
  set CLIREC empty;
  set IV3REC empty;
  set IV6REC empty;
  ;
  ;
  ;
  ;
  ;
  ;
end // end KL0J109

// validate screen m001 pf keys
Function KL0J110()
   /* ************************************************************/
   /* *  validate pf keys                                       **/
   /* *                                                         **/
   /* *  the only keys acted upon at this time are pf 1, 3 & 4  **/
   /* *  and fastpath                                           **/
   /* *  the other keys are just verified that they are used    **/
   /* *  by this application.  if the pf key is not recognized, **/
   /* *  the application resets all modified fields to remain   **/
   /* *  modified, then reshows the map with an error message.  **/
   /* *                                                         **/
   /* *  these other pf keys are acted upon after the editing   **/
   /* *  and updating have occured.                             **/
   /* * 11-04-91 twatso  added code for 'osd' for installation  **/
   /* *                  in dec. 1991.                          **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0J110"; /* set current process name*/
  ;
  if (converseVar.eventKey is enter) /* normal 'enter'*/
        /* check for fastpath option/item*/
    if (KL0JM001.CATOAP != " ") /* if fastpath option entered,*/
      COMMAREA.CATOAP = KL0JM001.CATOAP;
      COMMAREA.CAITEM = KL0JM001.CAITEM;
      XPCL002(); /* exit application*/
      CLXREC.CLXEDITF = "N"; /* re-show map (transfer failed)*/
      return;
    else
      if (KL0JM001.CAITEM != " ")
        converseLib.validationFailed(1);
        CLXREC.CLXEDITF = "N"; /* set do-edits-flag to no*/
        CLXREC.CLXERRF = "Y"; /* yes, there is an error*/
      end
      return;
    end
  end
  ;
  if (converseVar.eventKey is pf1) /* 'help'*/
    KL0JS01(); /* skip edit, update - exit*/
  end
  ;
  if (converseVar.eventKey is pf3)
    KL0JS03(); /* skip edit, update - exit*/
  end
  ;
  if (converseVar.eventKey is pf4)
    KL0JS04(); /* skip edit, update - exit*/
  end
  ;
  if (converseVar.eventKey is pf7  /* page back*/
   || converseVar.eventKey is pf8  /* page forward*/
   || converseVar.eventKey is pf2  /* skip edit, update - exit*/
   || converseVar.eventKey is pf5  /* skip edit, update - exit*/
   || converseVar.eventKey is pf12 /* edit only*/
   || converseVar.eventKey is pf13 /* edit, update*/
   || converseVar.eventKey is pf18 /* edit, update  1-4-88*/
   || converseVar.eventKey is pf20) /* edit, update  1-4-88*/
    return;
  end
  ;
  if (converseVar.eventKey is pf15) /* ; skip edit, update - exit*/
    if (CLAREC.YCTCD == "ADJ"
     || CLAREC.YCTCD == "RTS"
     || CLAREC.YCTCD == "DEF"
     || CLAREC.YCTCD == "OSD"
     || CLAREC.YCTCD == "CDR"
     || CLAREC.YCTCD == "NIL")
      return;
    else
      converseLib.validationFailed(24);
      CLXREC.CLXEDITF = "N";
      CLXREC.CLXERRF = "Y"; /* pf key error , just re-show map*/
      return;
    end
  end
  ;
  if (converseVar.eventKey is pa1
   || converseVar.eventKey is pa2)
    converseLib.clearScreen();
    
    converseLib.validationFailed(62); /* pa keys cause loss of data*/
    CLXREC.CLXEDITF = "N"; /* do not edit map, just re-show it*/
    CLXREC.CLXERRF = "Y"; /* pf key error , just re-show map*/
    return;
  end
      /* pf key not valid*/
  converseLib.validationFailed(2); /* pf key not valid*/
  KL0JS26(); /* set fields modfd so user no re-key*/
  CLXREC.CLXEDITF = "N"; /* do not edit map, just re-show it*/
  CLXREC.CLXERRF = "Y"; /* pf key error , just re-show map*/
  ;
end // end KL0J110

// process screen m001 entries
Function KL0J120()
   /* ************************************************************/
   /* *     this process handles all edits of screen fields,    **/
   /* *          and any subsequent updating, required by       **/
   /* *          entries into screen cl0jm001                   **/
   /* *                                                         **/
   /* *  Maintenance History:                                   **/
   /* *  01-19-90 CHELLM renamed CL0JM001.GLCD to GLACD.        **/
   /* *  01-18-91 CHELLM Added CL0JS64 to perform warning edit  **/
   /* *                  on the NBQ GL amount.                  **/
   /* *  01-21-91 CHELLM Added edit to not allow total NBQ GL $ **/
   /* *                  to be greater then the total merch. $  **/
   /* *                  CL0J122 - DEF's and RTS's              **/
   /* *                  CL0J123 - ADJ's                        **/
   /* *  11-04-91 twatso added code for 'osd' for installation  **/
   /* *                  in Dec. 1991. Treat like 'def'         **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0J120"; /* set current process name*/
  ;
  CL0JW01.CL0JWNIR = "N";
  CL0JW01.CL0JWNSR = "N";
  CL0JW01.CLADBOCL = "N";
  CL0JW01.CL0JWTGL = 0; /* 1-21-91*/
  CL0JW01.CL0JWMCH = 0; /* 1-21-91*/
  ;
  if (KL0JM001.CLHSEQNB != CLWREC.CLHSEQNB) /* check if seq# changed*/
    if (CL0JW01.CL0JWCLF == "Y") /* if user was in complete loop*/
      CL0JW01.CL0JWCLF = "N"; /* but changes the seq# need*/
    end /* to break out of the loop to*/
                                  /* get the seq# they entered*/
                                  /* rather than the next one in*/
                                  /* incremented sequence.*/
    if (KL0JM001.CLHSEQNB <= CLAREC.CLACSQNB)
      CL0JW01.CL0JWNSR = "Y";
    else
      converseLib.validationFailed(187); /* sequence number too high*/
      set KL0JM001.CLHSEQNB cursor, modified, bold;
      CLXERRF = "Y"; /* move y to error flag*/
    end
    ;
    if (KL0JM001.CLHSEQNB == 1)
      CL0JW01.CL0JWCLF = "Y"; /* move yes to complete-loop-flag*/
      CL0JW01.CL0JWFTT = "Y"; /* move yes to first time thru loop*/
    else
      /* next sentence;*/
    end
  end
  ;
  if (KL0JM001.CL0JWINB is modified) /* if requested ivc has changed*/
    KL0J124(); /* check validity of invoice number*/
  end
  ;
  if (CLWREC.CLWACTIV == "I") /* only do editing when not in inquiry*/
    return;
  end
  ;
  CLXREC.CLXLINEX = 11; /* last line number on screen*/
  while (CLXLINEX >= 1) /* start editing from last row up*/
    CL0JW04.CL0JWCUP[CLXLINEX] = "N"; /* update this comment*/
    CL0JW04.CL0JWGUP[CLXLINEX] = "N"; /* update this g/l row*/
    if (KL0JM001.CLICRDFL[CLXLINEX] == CL0JW02.CLICRDFL[CLXLINEX]
     && KL0JM001.GLACD[CLXLINEX] == CL0JW02.GLACD[CLXLINEX]
     && KL0JM001.CLIGLAM[CLXLINEX] == CL0JW02.CLIGLAM[CLXLINEX]
     && KL0JM001.CLIGLPC[CLXLINEX] == CL0JW02.CLIGLPC[CLXLINEX]
     && KL0JM001.CLIIGOFL[CLXLINEX] == CL0JW02.CLIIGOFL[CLXLINEX]
     && KL0JM001.CLGCOMNT[CLXLINEX] == CL0JW02.CLGCOMNT[CLXLINEX])
       /* next sentence*/
    else
      KL0J121(); /* edit each line*/
      if (KL0JM001.CLICRDFL[CLXLINEX] != "X") /* if deleting dont do*/
        KL0JS64(); /* warning edits*/
      end
    end
    ;
    CLXREC.CLXLINEX = CLXREC.CLXLINEX - 1;
  end
  ;
   /* below added 1-21-91*/
  ;
  if (CLXREC.CLXERRF != "Y")
    ;
    if (CLAREC.YCTCD == "DEF" /* if defective*/
     || CLAREC.YCTCD == "RTS" /* or return to stock*/
     || CLAREC.YCTCD == "OSD") /* or offshore defectives. 11-4-91*/
      KL0J122();
    end
    ;
    if (CLAREC.YCTCD == "ADJ" /* if adjustment or adjustment exists*/
     || CLAREC.CLADJIND == "Y")
      KL0J123();
    end
    ;
    if (CL0JW01.CL0JWMCH < 0)
      CL0JW01.CL0JWMCH = CL0JW01.CL0JWMCH * -1;
    end
    ;
    if (CL0JW01.CL0JWTGL < 0)
      CL0JW01.CL0JWTGL = CL0JW01.CL0JWTGL * -1;
    end
    ;
    if (CL0JW01.CL0JWTGL > CL0JW01.CL0JWMCH
     && CLXREC.CLXERRF != "Y")
      converseLib.validationFailed(684);
      CLXREC.CLXERRF = "Y"; /* move y to error flag*/
    end
    ;
  end
  ;
end // end KL0J120

// edit each screen line
Function KL0J121()
   /* ************************************************************/
   /* *     this process edits each field of every screen line  **/
   /* *                                                         **/
   /* *  Maintenance History:                                   **/
   /* *  01-19-90 CHELLM renamed CL0JM001.GLCD to GLACD.        **/
   /* *  11-12-93 gdecke  remove overlapping move stmt.         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0J121"; /* set current process name*/
  ;
  CL0JW04.CL0JWCUP[CLXLINEX] = "N"; /* update this comment*/
  CL0JW04.CL0JWGUP[CLXLINEX] = "N"; /* update this g/l*/
  ;
  if (KL0JM001.CLICRDFL[CLXLINEX] is modified)
    set KL0JM001.CLICRDFL[CLXLINEX] modified;
  end
  ;
  if (KL0JM001.GLACD[CLXLINEX] is modified)
    set KL0JM001.GLACD[CLXLINEX] modified;
  end
  ;
  if (KL0JM001.CLIGLPC[CLXLINEX] is modified)
    set KL0JM001.CLIGLPC[CLXLINEX] modified;
  end
  ;
  if (KL0JM001.CLIIGOFL[CLXLINEX] is modified)
    set KL0JM001.CLIIGOFL[CLXLINEX] modified;
  end
  ;
  if (KL0JM001.CLIGLAM[CLXLINEX] is modified
   && CL0JW01.CL0JWNBF != "Y") /* and not just showing warnings*/
    set KL0JM001.CLIGLAM[CLXLINEX] modified;
  end
  ;
  if (KL0JM001.CLGCOMNT[CLXLINEX] is modified)
    set KL0JM001.CLGCOMNT[CLXLINEX] modified;
  end
  ;
     /* if the user wants to delete this line, then*/
     /* the line cannot be from the invoice file*/
  if (KL0JM001.CLICRDFL[CLXLINEX] == "X")
    if (CL0JW04.CL0JWSFL[CLXLINEX] == "I")
      converseLib.validationFailed(194); /* cannot delete...this is invoice g/l*/
      set KL0JM001.CLICRDFL[CLXLINEX] cursor, modified, bold;
      CLXREC.CLXERRF = "Y";
      return;
    end
    if (CL0JW04.CLIGLOIN[CLXLINEX] == "Y")
      converseLib.validationFailed(424); /* cannot delete...this is override g/l*/
      set KL0JM001.CLICRDFL[CLXLINEX] cursor, modified, bold;
      CLXREC.CLXERRF = "Y";
      return;
    end
    ;
     /* cannot delete reversed invoice row where there is a*/
     /* matching entered g/l row with apply flag eq 'y'.*/
     /* otherwise we would end up with the same g/l with*/
     /* with 2 different percentages, both with apply flag eq 'y'*/
    ;
    if (CL0JW04.CLIGLFIV[CLXLINEX] == "I"
     || CL0JW04.CLIGLFIV[CLXLINEX] == "F")
      KL0JS56();
      if (CLXREC.CLXERRF == "N")
        CL0JW04.CL0JWCUP[CLXLINEX] = "Y";
        CL0JW04.CL0JWGUP[CLXLINEX] = "Y";
      end
      return;
    else
      CL0JW04.CL0JWCUP[CLXLINEX] = "Y";
      CL0JW04.CL0JWGUP[CLXLINEX] = "Y";
      return;
       /* END ;*/
    end
  end
  ;
  KL0JS51(); /* validate comment*/
  ;
         /* get gl description*/
  if (KL0JM001.GLACD[CLXLINEX] != CL0JW02.GLACD[CLXLINEX]
   || KL0JM001.GLACD[CLXLINEX] == " ")
    KL0JS53(); /* validate g/l code*/
  end
  ;
  KL0JS52(); /* validate percent and amount*/
  ;
      /* if credit/debit code is entered it must be c,d or x*/
  KL0JS54(); /* validate credit/debit code*/
  ;
  KL0JS55(); /* validate apply flag*/
  ;
  KL0JS58(); /* validate extra credit/debit lines*/
  ;
  if (CLXREC.CLXERRF == "N")
    CL0JW04.CL0JWGUP[CLXLINEX] = "Y";
  end
  ;
end // end KL0J121

// process screen m001 entries
Function KL0J122()
   /* ************************************************************/
   /* *     this process handles edits the nike bank coop gl's  **/
   /* *     to make sure the amount credited does not exceed    **/
   /* *     the total merchandise amount.                       **/
   /* *                                                         **/
   /* *  Maintenance History:                                   **/
   /* *                                                         **/
   /* *  01-21-91 CHELLM Created.                               **/
   /* *  03-07-91 CHELLM Dont include NBQ GL 980 (Coop freight  **/
   /* *           replenishment) int the total NBQ GL amount.   **/
   /* *           Use only the regular quarterly GL's.          **/
   /* *                                                         **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0J122"; /* set current process name*/
  ;
  CL0JW01.CL0JWTGL = 0;
  ;
  CLXREC.CLXLINEX = 11; /* last line number on screen*/
  while (CLXLINEX >= 1) /* start editing from last row up*/
    ;
     /* check the Profitability GL table to see if NBQ GL's exist.*/
                          /* below added 1-8-91*/
    set SQLCA empty;
    set PFJREC empty;
    ;
    PFJREC.GLACD = KL0JM001.GLACD[CLXLINEX];
    ;
    call "IO4360" ("S ", SQLCA, PFJREC) {isNoRefresh = yes, isExternal = yes}; /* select PFJREC*/
    if (SQLCA.VAGen_SQLCODE == 0) /* if good return check for NBQ GL*/
      if (PFJREC.PFJXREF == "NBQ"           
       && KL0JM001.GLACD[CLXLINEX] != "980" /* dont include shp chrgs*/
       && KL0JM001.CLICRDFL[CLXLINEX] == "C")
        CL0JW01.CL0JWTGL = CL0JW01.CL0JWTGL + KL0JM001.CLIGLAM[CLXLINEX];
      end
    else
      if (SQLCA.VAGen_SQLCODE == 100)
        /* next sentence*/
      else
        TA1REC.TA1TBLKE = "FETCHING PFJREC  (CL0J122)";
        XPCL010();
      end
    end
    ;
    ;
    CLXREC.CLXLINEX = CLXREC.CLXLINEX - 1;
    ;
  end
  ;
  CLKREC.CLACLMNB = CLAREC.CLACLMNB;
  CLKREC.IV0IVCID = -1;
  CLKREC.XGPCD = "**";
  CLKREC.SY1STNBR = "******";
  CLKREC.SY2CLRID = "***";
  CLKREC.XDMCD = "**";
  CLKREC.XUMCD = "**";
  CLKREC.XQACD = "**";
  CLKREC.CLKCRFL = "Y";
  ;
  CL0JW01.CL0JWDON = "N"; /* init done-flag*/
  ;
  set SQLCA empty;
  call "IO1280" ("S1", SQLCA, CLKREC) {isNoRefresh = yes, isExternal = yes};
              /* ; select the set of all invoice GL records*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0) /* if the select-set return code is ok*/
    /* next sentence*/
  else
    TA1REC.TA1TBLKE = "SELCT RAITM SET (CL0J122)";
    XPCL010();
  end
  ;
  ;
  set SQLCA empty;
  call "IO1280" ("N1", SQLCA, CLKREC) {isNoRefresh = yes, isExternal = yes}; /* first record of the set*/
  if (SQLCA.VAGen_SQLCODE == 0) /* if we found a first record*/
    /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == 100) /* no first record found*/
      CL0JW01.CL0JWDON = "Y";
    else
      TA1REC.TA1TBLKE = "FETCH 1ST CLKREC  CL0J122";
      XPCL010();
    end
  end
  ;
  ;
  while (CL0JW01.CL0JWDON == "N") /* while not done*/
    ;
      /* accumulate the total merchandise value authorized*/
      /* for return.*/
    ;
    if (CLKREC.CLKCRFL == "Y")
      CL0JW01.CL0JWVCH = 0;
      CL0JW01.CL0JWVCH = CLKREC.CLKCLPRC * CLKREC.CLKAUTHQ;
      CL0JW01.CL0JWMCH = CL0JW01.CL0JWMCH + CL0JW01.CL0JWVCH;
    end
    ;
    ;
    set SQLCA empty;
    call "IO1280" ("N1", SQLCA, CLKREC) {isNoRefresh = yes, isExternal = yes}; /* get the next clkrec*/
    if (SQLCA.VAGen_SQLCODE == 0) /* good return,*/
      /* next sentence*/
    else
      if (SQLCA.VAGen_SQLCODE == 100)
        CL0JW01.CL0JWDON = "Y"; /* we're done*/
      else
        TA1REC.TA1TBLKE = "FETCH NEXT RAITM   CL0J122";
        XPCL010();
      end
    end
  end
  ;
  set SQLCA empty;
  call "IO1280" ("C1", SQLCA, CLKREC) {isNoRefresh = yes, isExternal = yes}; /* close cursor*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0) /* if the select-set return code is ok*/
    /* next sentence*/
  else
    TA1REC.TA1TBLKE = "CLOSE RAITM SET (CL0J122)";
    XPCL010();
  end
  ;
  ;
  ;
  ;
end // end KL0J122

// process screen m001 entries
Function KL0J123()
   /* ************************************************************/
   /* *     this process handles edits the nike bank coop gl's  **/
   /* *     to make sure the amount credited does not exceed    **/
   /* *     the total merchandise amount for adjustments.       **/
   /* *                                                         **/
   /* *  Maintenance History:                                   **/
   /* *                                                         **/
   /* *  01-21-91 CHELLM Created.                               **/
   /* *  03-07-91 CHELLM Dont include NBQ GL 980 (freight chrgs **/
   /* *           Co-op replenishment) in calculating total NBQ **/
   /* *           GL amount, only use the quarterly NBQ GL's    **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0J123"; /* set current process name*/
  ;
  CL0JW01.CL0JWTGL = 0;
  ;
  CLXREC.CLXLINEX = 11; /* last line number on screen*/
  while (CLXLINEX >= 1) /* start editing from last row up*/
    ;
     /* check the Profitability GL table to see if NBQ GL's exist.*/
    set SQLCA empty;
    set PFJREC empty;
    ;
    PFJREC.GLACD = KL0JM001.GLACD[CLXLINEX];
    ;
    call "IO4360" ("S ", SQLCA, PFJREC) {isNoRefresh = yes, isExternal = yes}; /* select PFJREC*/
    if (SQLCA.VAGen_SQLCODE == 0) /* if good return check for NBQ GL*/
      if (PFJREC.PFJXREF == "NBQ"           
       && KL0JM001.GLACD[CLXLINEX] != "980" /* dont include shp chrgs*/
       && KL0JM001.CLICRDFL[CLXLINEX] == "C")
        if (KL0JM001.CLIGLAM[CLXLINEX] < 0)
          CL0JW01.CL0JWTGL = CL0JW01.CL0JWTGL + KL0JM001.CLIGLAM[CLXLINEX] * -1;
        else
          CL0JW01.CL0JWTGL = CL0JW01.CL0JWTGL + KL0JM001.CLIGLAM[CLXLINEX];
        end
      end
    else
      if (SQLCA.VAGen_SQLCODE == 100)
        /* next sentence*/
      else
        TA1REC.TA1TBLKE = "FETCHING PFJREC  (CL0J123)";
        XPCL010();
      end
    end
    ;
    ;
    CLXREC.CLXLINEX = CLXREC.CLXLINEX - 1;
    ;
  end
  ;
  CLRREC.CLACLMNB = CLAREC.CLACLMNB;
  CLRREC.CLHSEQNB = CLAREC.CLACSQNB;
  CLRREC.XGPCD = "**";
  CLRREC.SY1STNBR = "******";
  CLRREC.SY2CLRID = "***";
  CLRREC.XDMCD = "**";
  CLRREC.CLICRDFL = "*";
  ;
  CL0JW01.CL0JWDON = "N"; /* init done-flag*/
  ;
  set SQLCA empty;
  call "IO1370" ("S1", SQLCA, CLRREC) {isNoRefresh = yes, isExternal = yes};
              /* ; select the set of all invoice GL records*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0) /* if the select-set return code is ok*/
    /* next sentence*/
  else
    TA1REC.TA1TBLKE = "SELCT CLADJ SET (CL0J123)";
    XPCL010();
  end
  ;
  ;
  set SQLCA empty;
  call "IO1370" ("N1", SQLCA, CLRREC) {isNoRefresh = yes, isExternal = yes}; /* first record of the set*/
  if (SQLCA.VAGen_SQLCODE == 0) /* if we found a first record*/
    /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == 100) /* no first record found*/
      CL0JW01.CL0JWDON = "N";
    else
      TA1REC.TA1TBLKE = "FETCH 1ST CLRREC  CL0J123";
      XPCL010();
    end
  end
  ;
  ;
  while (CL0JW01.CL0JWDON == "N") /* while not done*/
    ;
    ;
      /* accumulate the total adjustment merchandise value*/
    ;
    CL0JW01.CL0JWVCH = 0;
    CL0JW01.CL0JWVCH = CLRREC.CLNNTPRC * CLRREC.CLRCLMQ;
    if (CLRREC.CLICRDFL == "D")
      CL0JW01.CL0JWMCH = CL0JW01.CL0JWMCH - CL0JW01.CL0JWVCH;
    else
      CL0JW01.CL0JWMCH = CL0JW01.CL0JWMCH + CL0JW01.CL0JWVCH;
    end
    ;
    ;
    set SQLCA empty;
    call "IO1370" ("N1", SQLCA, CLRREC) {isNoRefresh = yes, isExternal = yes}; /* get the next clrrec*/
    if (SQLCA.VAGen_SQLCODE == 0) /* good return,*/
      /* next sentence*/
    else
      if (SQLCA.VAGen_SQLCODE == 100)
        CL0JW01.CL0JWDON = "Y"; /* we're done*/
      else
        TA1REC.TA1TBLKE = "FETCH NEXT CLADJ   CL0J123";
        XPCL010();
      end
    end
  end
  ;
  set SQLCA empty;
  call "IO1370" ("C1", SQLCA, CLRREC) {isNoRefresh = yes, isExternal = yes}; /* close cursor*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0) /* if the select-set return code is ok*/
    /* next sentence*/
  else
    TA1REC.TA1TBLKE = "CLOSE CLADJ SET (CL0J123)";
    XPCL010();
  end
  ;
  ;
  ;
  ;
  ;
end // end KL0J123

// check validity of ivc nbr
Function KL0J124()
   /* ************************************************************/
   /* *     check the validity of the invoice number entered    **/
   /* *           on the screen                                 **/
   /* *                                                         **/
   /* *                                                         **/
   /* *                                                         **/
   /* *                                                         **/
   /* *                                                         **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0J124"; /* set current process name*/
  ;
  ;
  ;
  if (KL0JM001.CL0JWINB == 0)
    KL0JM001.CL0JWINB = 1;
  end
  ;
  if (KL0JM001.CL0JWINB <= CL0JW01.CL0JWICT)
    CL0JW01.CL0JWINX = KL0JM001.CL0JWINB;
    KL0JM001.CL0JWINB = CL0JW06.IV0IVCID[CL0JWINX];
  end
  ;
  ;
  ;
  if (KL0JM001.CL0JWINB in CL0JW06.IV0IVCID)
    CLWREC.IV0IVCID = CL0JW06.IV0IVCID[sysVar.arrayIndex];
    set KL0JM001.CL0JWINB initialAttributes;
    CL0JW01.CL0JWNIR = "Y"; /* new invoice requested*/
  else
    /* MOVE "not a valid invoice id " TO EZEMSG;*/
    converseLib.validationFailed(188);
    set KL0JM001.CL0JWINB cursor, modified, bold;
    CLXERRF = "Y"; /* move y to error flag*/
    return;
  end
  ;
  ;
  ;
  ;
  ;
end // end KL0J124

// update claim g/l table
Function KL0J130()
   /* *************************************************************/
   /* *  this routine is used to update the claims g/l table*/
   /* *  and any comments that might pertain to it.*/
   /* **/
   /* *************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0J130"; /* set current process name*/
  ;
  CL0JW01.CLIGLAM = 0;
  ;
  ;
  KL0JS38(); /* get current date/time before updates*/
  ;
  ;
  CLXREC.CLXLINEX = 1; /* move 1 to screen pointer*/
  ;
  ;
  while (CLXREC.CLXLINEX <= 11)
    if (CL0JW04.CL0JWCUP[CLXLINEX] == "Y" /* comment update*/
     || CL0JW04.CL0JWGUP[CLXLINEX] == "Y") /* g/l update*/
      KL0JS45(); /* build image of clirecord*/
      KL0JS41(); /* update comments*/
      KL0JS42(); /* update claims g/l table*/
    end
    CLXREC.CLXLINEX = CLXREC.CLXLINEX + 1;
  end
  ;
  ;
  if (CLXREC.CLXERRF == "N"
   && KL0JM001.IV0IVCID != 0)
    set CLIREC empty;
    set SQLCA empty;
    CLIREC.CLACLMNB = CLAREC.CLACLMNB;
    CLIREC.CLHSEQNB = CLAREC.CLACSQNB;
    CLIREC.IV0IVCID = KL0JM001.IV0IVCID;
    CLXREC.CLXORDIV = KL0JM001.IV0IVCID;
    CLIREC.IV0PARTN = CLXREC.CLXPARTN;
    CLIREC.CLICRDFL = "*";
    CL0JW07.CL0JWSQL = "SC"; /* count nbr of gl's on this invoice*/
    call "IO1300" (CL0JW07, SQLCA, CLIREC) {isNoRefresh = yes, isExternal = yes};
    if (CL0JW07.CL0JWIN1 >= 0)
      CLIREC.ZZZCHGCT = CL0JW07.CL0JWCN1;
    else
      CLIREC.ZZZCHGCT = 0;
    end
    CL0JW01.CL0JWNOG = CLIREC.ZZZCHGCT; /* count returned in zzchgct*/
    if (SQLCA.VAGen_SQLCODE == 0) /* if no errors*/
      KL0JS44(); /* update g/l flag on invoice record*/
    end
  end
  ;
  ;
  if (CLXREC.CLXERRF == "N")
    set CLIREC empty;
    set SQLCA empty;
    set CL0JW07 empty;
    CLIREC.CLACLMNB = CLAREC.CLACLMNB;
    CLIREC.CLHSEQNB = CLAREC.CLACSQNB;
    CLIREC.CLICRDFL = "D";
    CLIREC.IV0IVCID = -1;
    CL0JW07.CL0JWSQL = "SC"; /* count nbr of debits on claim*/
    ;
    call "IO1300" (CL0JW07, SQLCA, CLIREC) {isNoRefresh = yes, isExternal = yes};
    if (CL0JW07.CL0JWIN1 >= 0)
      CLIREC.ZZZCHGCT = CL0JW07.CL0JWCN1;
    else
      CLIREC.ZZZCHGCT = 0;
    end
    CL0JW01.CL0JWNOD = CLIREC.ZZZCHGCT; /* count returned in zzchgct*/
    if (SQLCA.VAGen_SQLCODE == 0) /* if no errors*/
      KL0JS43(); /* update claim header*/
    end
  end
  ;
  ;
  if (CLXREC.CLXERRF == "N") /* if no errors updating*/
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.commit();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
    
  else
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.rollback();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
    
  end
  ;
  ;
end // end KL0J130

// act upon enter key
Function KL0J131()
   /* ************************************************************/
   /* *  act upon enter key                                     **/
   /* *                                                         **/
   /* *  pf 1, 3, 4, 7, 8 & 12 were acted upon in               **/
   /* *  cl0j110.                                               **/
   /* *                                                         **/
   /* *  the other pf keys are acted upon here, after editing   **/
   /* *  and updating have occured.                             **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0J131"; /* set current process name*/
  ;
  CLWREC.CLHSEQNB = KL0JM001.CLHSEQNB;
  ;
  if (CL0JW01.CL0JWNSR == "Y" /* if new sequence number requested*/
   || CL0JW01.CL0JWNIR == "Y") /* if new invoice nbr requested*/
    CLXREC.CLXBLDSC = "Y";
    return;
  else
    if ("Y" in CL0JW04.CL0JWCUP
     || "Y" in CL0JW04.CL0JWGUP)
      CLXREC.CLXBLDSC = "Y";
      return;
    else
      if (KL0JM001.CL0JWICT > CL0JW01.CL0JWINX)
        CL0JW01.CL0JWINX = CL0JW01.CL0JWINX + 1;
        CLWREC.IV0IVCID = CL0JW06.IV0IVCID[CL0JWINX];
        CLXREC.CLXBLDSC = "Y";
        return;
      end
    end
  end
  ;
  ;
  if (CL0JW01.CL0JWCLF == "Y" /* if complete-loop-flag = yes*/
   || KL0JM001.CLHSEQNB != CLWREC.CLHSEQNB) /* did seq# change?*/
    KL0J133(); /* set up next sequence nbr*/
    return;
  end
  ;
  ;
  CLIREC.CLACLMNB = CLAREC.CLACLMNB;
  CLIREC.CLHSEQNB = CLAREC.CLACSQNB;
  CLIREC.CLICRDFL = "S";
  ;
   /* delete rows with 'r' or 's' in clicrdfl*/
  call "IO1300" ("DC", SQLCA, CLIREC) {isNoRefresh = yes, isExternal = yes};
  ;
  ;
  ;
   /* *** where to go *****/
  if (COMMAREA.CAFROMAP == "KL0L")
    COMMAREA.CATOAP = "KL0E";
    XPCL002();
  else
    COMMAREA.CATOAP = COMMAREA.CAFROMAP;
    XPCL002();
  end
  ;
  ;
  ;
  ;
  ;
end // end KL0J131

// act upon pf keys
Function KL0J132()
   /* ************************************************************/
   /* *  act upon pf keys                                       **/
   /* *                                                         **/
   /* *  pf 1, 3, 4, 7, 8 & 12 were acted upon in               **/
   /* *  cl0j110.                                               **/
   /* *                                                         **/
   /* *  the other pf keys are acted upon here, after editing   **/
   /* *  and updating have occured.                             **/
   /* *                                                         **/
   /* 10-16-92  sgorga  deleted comment with obsolete field.    **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0J132"; /* set current process name*/
  ;
  CLWREC.CLHSEQNB = KL0JM001.CLHSEQNB;
  ;
   /* delete rows with 'r' or 's' in clicrdfl*/
   /* CALL IO1300 'DC',SQLCA,CLIREC (NOMAPS,NONCSP;*/
  ;
  if (converseVar.eventKey is pf2)
    if (CLAREC.CLAMEIND == "Y") /* if there is a memo*/
      if (KL0JM001.CLHSEQNB != 0)
        KL0JS02();
      else
        set KL0JM001.CLHSEQNB cursor, modified, bold;
        converseLib.validationFailed(13);
          /* MOVE 'PF2 IS NOT VALID WITHOUT SEQUENCE NUMBER' TO EZEMSG;*/
        CLXREC.CLXBLDSC = "N"; /* just to make sure flag off*/
        CLXREC.CLXERRF = "Y";
      end
    else
      converseLib.validationFailed(31); /* no memo exists for claim*/
      CLXREC.CLXBLDSC = "N"; /* just to make sure flag off*/
      CLXREC.CLXERRF = "Y";
    end
    return;
  end
  ;
  if (converseVar.eventKey is pf5) /* claim header*/
    KL0JS05();
    return;
  end
  ;
  if (converseVar.eventKey is pf13) /* ** traffic*/
    KL0JS13();
    return;
  end
  ;
  if (converseVar.eventKey is pf15)
    KL0JS15(); /* summ opt*/
    return;
  end
  ;
  if (converseVar.eventKey is pf18) /* 1-4-88*/
    KL0JS18(); /* claim comment*/
    return;
  end
  ;
  if (converseVar.eventKey is pf20) /* 1-4-88*/
    KL0JS20(); /* memo comment*/
    return;
  end
  ;
  ;
end // end KL0J132

// set up next sequence nbr
Function KL0J133()
   /* ************************************************************/
   /* *  set up next sequence number on 'enter' key             **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0J133"; /* set current process name*/
  ;
  ;
  if (CL0JW01.CL0JWCLF == "Y") /* if complete-loop-flag = yes*/
    if (CL0JW01.CL0JWFTT == "Y") /* if first time thru loop move*/
      KL0JM001.CLHSEQNB = 0; /* 0 to seq# so after increment =1*/
      CL0JW01.CL0JWFTT = "N"; /* reset first-time-thru flag to no*/
    else
      /* next sentence*/
    end
    CL0JW01.CL0JWSQH = KL0JM001.CLHSEQNB + 1; /* add 1 to seq#*/
    if (CL0JW01.CL0JWSQH <= CLAREC.CLACSQNB)
      CLWREC.CLHSEQNB = CL0JW01.CL0JWSQH; /* move as 'after'*/
      KL0JM001.CLHSEQNB = CL0JW01.CL0JWSQH; /* move to map*/
      CLIREC.CLHSEQNB = CL0JW01.CL0JWSQH; /* move to clirec*/
      CLXREC.CLXBLDSC = "Y"; /* build-screen-flag = yes*/
      CL0JW01.CL0JWMIF = "N";
      CLXREC.CLXMAXLN[1] = 11; /* move 11 to max# lines per screen*/
      CLXREC.CLXARY1X[1] = 1; /* move 1 to 1st line pointer*/
      CL0JW01.CL0JWLAR = 0; /* move 0 to array indicator*/
    else /* so count will be at one after inc.*/
      CL0JW01.CL0JWMIF = "N";
      CL0JW01.CL0JWCLF = "N";
      CLXREC.CLXBLDSC = "N";
      VAGen_EZEMSG = "LAST SEQ# FOR THIS CLAIM";
      /* MOVE 190 TO EZEMNO;*/
      return;
    end
  else
    if (KL0JM001.CLHSEQNB != CLWREC.CLHSEQNB) /* did seq# change?*/
       /* ******  move 'after' seq# to clwrec*/
       /* ******  clear map for next seq#*/
      if (KL0JM001.CLHSEQNB <= CLAREC.CLACSQNB)
        CLWREC.CLHSEQNB = KL0JM001.CLHSEQNB;
        CLXREC.CLXBLDSC = "Y"; /* want to build screen*/
        CL0JW01.CL0JWMIF = "N";
        CLXREC.CLXEOSF = "Y"; /* move y to end of screen*/
        CLXREC.CLXMAXLN[1] = 11; /* move 11 to max# lines per screen*/
        CLXREC.CLXARY1X[1] = 1; /* move 1 to 1st line pointer*/
        CL0JW01.CL0JWLAR = 0; /* move 0 to array indicator*/
        set KL0JM001 initial;
      else
        converseLib.validationFailed(14);
        CLXREC.CLXBLDSC = "N";
        set KL0JM001.CLHSEQNB cursor, bold;
        return;
      end
    end
  end
  ;
  ;
  ;
  ;
  ;
end // end KL0J133

// exit appl via enter or pf key
Function KL0J140()
   /* ************************************************************/
   /* *  act upon pf keys                                       **/
   /* *                                                         **/
   /* *  pf 1, 3, 4, 7, 8 & 12 were acted upon in               **/
   /* *  cl0j110.                                               **/
   /* *                                                         **/
   /* *  the other pf keys are acted upon here, after editing   **/
   /* *  and updating have occured.                             **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0J140"; /* set current process name*/
  ;
  ;
  ;
  if (converseVar.eventKey is enter)
    KL0J131(); /* act upon enter key*/
  else
    KL0J132(); /* act upon pf key*/
  end
  ;
  ;
end // end KL0J140

// pf 1 action
Function KL0JS01()
   /* ************************************************************/
   /* *      handle the entry of pfkey 1                        **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  ;
  CLXREC.CLXEDITF = "N"; /* we don't want to do edits*/
  ;
  COMMAREA.CATOAP = "GD00"; /* memo screen*/
  ;
  XPCL002();
  ;
  ;
  ;
  ;
end // end KL0JS01

// pf 2 action
Function KL0JS02()
   /* ************************************************************/
   /* *      handle the entry of pfkey 2                        **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  ;
  CLXREC.CLXEDITF = "N"; /* we don't want to do edits*/
  CLXREC.CLXEOSF = "Y"; /* we are done with this screen*/
  CLXREC.CLXEOAF = "Y"; /* we are done with this application*/
  ;
  COMMAREA.CATOAP = "KL0M"; /* memo screen*/
  XPCL002();
  ;
end // end KL0JS02

// pf3 exit to claims
Function KL0JS03()
  ;
  ;
  ;
      /* skip edits/update, go to higher level in claims*/
  ;
  COMMAREA.CATOAP = "KL0A"; /* go to claims menu*/
  ;
  XPCL002(); /* common claims exit*/
  ;
  ;
  ;
end // end KL0JS03

// pf4 exit to master menu
Function KL0JS04()
  ;
  ;
  ;
      /* skip edits/update, go to goal master menu*/
  ;
  COMMAREA.CATOAP = "MN0M"; /* go to master menu*/
  ;
  XPCL002(); /* common claims exit*/
  ;
  ;
  ;
end // end KL0JS04

// pf 5 action
Function KL0JS05()
   /* ************************************************************/
   /* *      handle the entry of pfkey 5                        **/
   /* *        claim header                                     **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  ;
  ;
  COMMAREA.CATOAP = "KL0E"; /* claim header screen*/
  XPCL002();
  ;
  ;
end // end KL0JS05

// pf 7 action
Function KL0JS07()
   /* ************************************************************/
   /* *    this process handles the entry of pf key 7           **/
   /* *             (paging backward)                           **/
   /* *                                                         **/
   /* *                                                         **/
   /* *                                                         **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  ;
  ;
  ;
  if (CL0JW01.CL0JWNOG <= 11) /* if all records will fit*/
    CL0JW01.CL0JWOST = 0;
    converseLib.validationFailed(7);
  else
    CL0JW01.CL0JWOST = CL0JW01.CL0JWOST - 11;
    if (CL0JW01.CL0JWOST <= 0)
      CL0JW01.CL0JWOST = 0;
      converseLib.validationFailed(7);
    end
  end
  ;
  ;
  ;
  ;
     /* force build new screen*/
  ;
  CLXREC.CLXBLDSC = "Y"; /* yes bld the screen again. might be additions*/
  ;
  ;
  ;
end // end KL0JS07

// pf 8 action
Function KL0JS08()
   /* ************************************************************/
   /* *   this process handles the entry of pf key 8            **/
   /* *           (paging forward)                              **/
   /* *                                                         **/
   /* *                                                         **/
   /* *                                                         **/
   /* *                                                         **/
   /* ************************************************************/
  ;
      /* move first line to the array index*/
  ;
  ;
  if (KL0JM001.CL0JWNOG < 11) /* all fit on one screen*/
    CL0JW01.CL0JWOST = 0;
    converseLib.validationFailed(3);
    return;
  else
    CL0JW01.CL0JWNBR = CL0JW01.CL0JWOST + 11;
    if (CL0JW01.CL0JWNBR > KL0JM001.CL0JWNOG)
      converseLib.validationFailed(3);
      return;
    else
      CL0JW01.CL0JWOST = CL0JW01.CL0JWNBR;
    end
  end
  ;
     /* force build new screen*/
  ;
  CLXREC.CLXBLDSC = "Y"; /* yes bld the screen*/
  ;
end // end KL0JS08

// pf 13 action
Function KL0JS13()
   /* ************************************************************/
   /* *      handle the entry of pfkey 13                       **/
   /* *        ** application dependent **                      **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  ;
  CLXREC.CLXEDITF = "N"; /* we don't want to do edits*/
  CLXREC.CLXEOSF = "Y"; /* we are done with this screen*/
  CLXREC.CLXEOAF = "Y"; /* we are done with this application*/
  ;
   /* ** application dependent ***/
  COMMAREA.CATOAP = "KL0I"; /* traffic*/
  XPCL002();
  ;
  ;
end // end KL0JS13

// pf 15 action
Function KL0JS15()
   /* ************************************************************/
   /* *      handle the entry of pfkey 15                       **/
   /* *        ** application dependent **                      **/
   /* *                                                         **/
   /* * Maintenance Log                                         **/
   /* * 11-11-91  twatso added code for 'osd' to be treated like**/
   /* *                  'def' for dec 91 installation          **/
   /* ************************************************************/
  ;
  ;
  CLXREC.CLXEDITF = "N"; /* we don't want to do edits*/
  CLXREC.CLXEOSF = "Y"; /* we are done with this screen*/
  CLXREC.CLXEOAF = "Y"; /* we are done with this application*/
  ;
   /* ** application dependent ***/
  ;
  if (CLAREC.CLAWSENF == "N") /* worksheet enter flag*/
    if (KL0JM001.YCTCD == "RTS")
      COMMAREA.CATOAP = "KL0O"; /* rts rtn auth*/
      XPCL002();
    end
    if (KL0JM001.YCTCD == "DEF"
     || KL0JM001.YCTCD == "CDR"
     || KL0JM001.YCTCD == "OSD")
      COMMAREA.CATOAP = "KL0R"; /* def rtn auth*/
      XPCL002();
    end
    if (KL0JM001.YCTCD == "ADJ")
      COMMAREA.CATOAP = "KL0L"; /* adjustment summary*/
      XPCL002();
    end
  else
    if (KL0JM001.YCTCD == "RTS")
      COMMAREA.CATOAP = "KL0U"; /* rts rtn auth*/
      XPCL002();
    end
    if (KL0JM001.YCTCD == "DEF"
     || KL0JM001.YCTCD == "DFO"
     || KL0JM001.YCTCD == "CDR"
     || KL0JM001.YCTCD == "OSD")
      COMMAREA.CATOAP = "KL0V"; /* def rtn auth*/
      XPCL002();
    end
  end
  ;
  if (KL0JM001.YCTCD == "NIL")
    COMMAREA.CATOAP = "KL0X"; /* def rtn auth*/
    XPCL002();
  else
    converseLib.validationFailed(24); /* pf key not valid for claim type*/
    CLXREC.CLXERRF = "Y";
    return;
  end
end // end KL0JS15

// pf 18 action
Function KL0JS18()
   /* ************************************************************/
   /* *      handle the entry of pfkey 18                       **/
   /* *      claim comments                                     **/
   /* ************************************************************/
  ;
  CLXREC.CLXEDITF = "N"; /* we don't want to do edits*/
  CLXREC.CLXEOSF = "Y"; /* we are done with this screen*/
  CLXREC.CLXEOAF = "Y"; /* we are done with this application*/
  ;
  CLWREC.CLWMCMNT = "N";
  COMMAREA.CATOAP = "KL0G";
  ;
  XPCL002();
  ;
end // end KL0JS18

// pk 20 action
Function KL0JS20()
   /* ************************************************************/
   /* *      handle the entry of pfkey 20                       **/
   /* *      memo  comments                                     **/
   /* ************************************************************/
  ;
  CLXREC.CLXEDITF = "N"; /* we don't want to do edits*/
  CLXREC.CLXEOSF = "Y"; /* we are done with this screen*/
  CLXREC.CLXEOAF = "Y"; /* we are done with this application*/
  ;
  CLWREC.CLWMCMNT = "Y";
  COMMAREA.CATOAP = "KL0G";
  ;
  XPCL002();
  ;
end // end KL0JS20

// modify entered fields
Function KL0JS26()
   /* ************************************************************/
   /* *  since the map must be re-shown to the user             **/
   /* *  before editing has been done, set fields modified to   **/
   /* *  keep track of all the fields entered by the user.      **/
   /* *  the user will only need to re-do the pf key or enter   **/
   /* *  key, not enter the data again.                         **/
   /* *                                                         **/
   /* *  Maintenance History:                                   **/
   /* *                                                         **/
   /* *  01-19-90 CHELLM Renamed CL0JM001.GLCD as CLACD         **/
   /* *                                                         **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0JS26"; /* set current process name*/
  ;
  if (KL0JM001.CLHSEQNB is modified)
    set KL0JM001.CLHSEQNB modified;
  end
  ;
  if (KL0JM001.CLICRDFL[CLXSCRNX] is modified)
    set KL0JM001.CLICRDFL[CLXSCRNX] modified;
  end
  ;
  if (KL0JM001.GLACD[CLXSCRNX] is modified)
    set KL0JM001.GLACD[CLXSCRNX] modified;
  end
  ;
  if (KL0JM001.CLIGLAM[CLXSCRNX] is modified)
    set KL0JM001.CLIGLAM[CLXSCRNX] modified;
  end
  ;
  if (KL0JM001.CLIGLNFL[CLXSCRNX] is modified)
    set KL0JM001.CLIGLNFL[CLXSCRNX] modified;
  end
  ;
  if (KL0JM001.CLGCOMNT[CLXSCRNX] is modified)
    CL0JW01.CL0JWCFL = "Y";
    set KL0JM001.CLGCOMNT[CLXSCRNX] modified;
  else
    CL0JW01.CL0JWCFL = "N";
  end
  ;
end // end KL0JS26

// figure seq# and get memo
Function KL0JS28()
   /* * 10-22-90 bcourt change proc named as sgrp to be sgrp*/
  ;
  CLXREC.CLXCPROC = "CL0JS28"; /* set current process name*/
  ;
   /* if the claim is completed, only want to show g/l's that*/
   /* were created before the claim became a memo. if the claim*/
   /* is in an open status, show all g/l's regardless of date.*/
  ;
  ;
  set CLHREC empty; /* else set key to find*/
  CLHREC.CLHSEQNB = CLWREC.CLHSEQNB; /* memo in clhrec.*/
  CLHREC.CLACLMNB = CLAREC.CLACLMNB;
  call "IO1290" ("SA", SQLCA, CLHREC) {isNoRefresh = yes, isExternal = yes};
  if (SQLCA.VAGen_SQLCODE == 0) /* if memo found check to*/
    KL0JM001.CLHMEMNB = CLHREC.CLHMEMNB; /* see if it has a memo#*/
    CL0JW01.ZZZCHGDT = CLHREC.ZZZCHGDT; /* save date for selecting*/
    CL0JW01.ZZZCHGTM = CLHREC.ZZZCHGTM; /* g/l's*/
    if (CLHREC.CLHMEMNB != 0)
                                   /* if memo number found give error*/
      converseLib.validationFailed(192); /* cant chg data sinc memo exists*/
    end
  else
    if (SQLCA.VAGen_SQLCODE == 100) /* memo not on file for this invoice*/
      KL0JM001.CLHMEMNB = 0;
      CL0JW01.ZZZCHGDT = 999999999; /* accept all dates*/
      CL0JW01.ZZZCHGTM = 9999; /* accept all times*/
    else
      TA1REC.TA1DBASE = "DCLAIM";
      TA1REC.TA1TBLVU = "VCLMEM01";
      TA1REC.TA1TBLKE = "GETTING MEMO RECORD IN CL0JS28";
      XPCL010();
    end
  end
  ;
  ;
end // end KL0JS28

// get claim type & status descr
Function KL0JS29()
   /* * 10-22-90 bcourt change proc named as sgrp to be sgrp*/
  ;
  CLXREC.CLXCPROC = "CL0JS29"; /* set current process name*/
  ;
  ;
        /* get claim type abbreviation*/
  if (KL0JM001.YCTCD in YCTTBL.YCTCD)
    if (YCTTBL.XXXSTAT[sysVar.arrayIndex] == "A")
      KL0JM001.YCTABRV = YCTTBL.YCTABRV[sysVar.arrayIndex];
       /* MOVE YCTTBL.YCTDBOCL(EZETST) TO CL0JW01.CL0JWYCT;*/
    end
  end
         /* get claim status description*/
  if (KL0JM001.YCSCD in YCSTBL.YCSCD)
    if (YCSTBL.XXXSTAT[sysVar.arrayIndex] == "A")
      KL0JM001.YCSSDESC = YCSTBL.YCSSDESC[sysVar.arrayIndex];
    end
  end
  ;
  ;
end // end KL0JS29

// read CLAREC for status
Function KL0JS30()
   /* ***********************************************************/
   /* new process (added 05-15-91 by tw)*/
     /* check the status of the claim so do not display*/
     /* cancelled claims on the screen*/
     /* also need to reset clwrec each time so sequence of the*/
     /* application does not get messed up.*/
  ;
  ;
   /* ***********************************************************/
  ;
  CLXREC.CLXCPROC = "CL0JS30"; /* set current process name*/
  set CLAREC empty;
  CLAREC.CLACLMNB = CLIREC.CLACLMNB;
  ;
  call "IO1160" ("S ", SQLCA, CLAREC) {isNoRefresh = yes, isExternal = yes}; /* get current record*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
                           /* ;if cancelled we don't want it later*/
    if (CLAREC.YCSCD1 == "CAN"
     || CLAREC.YCSCD1 == "DEN")
      CLXREC.CLXTESTF = "C";
    end
    ;
  else
    if (SQLCA.VAGen_SQLCODE != 100) /* ok if not found, but not ok elsewise*/
      TA1REC.TA1DBASE = "DCLAIM";
      TA1REC.TA1TBLVU = "VCLHDR01";
      XPCL010(); /* abend*/
    end
  end
  ;
  CLAREC.CLAGROUP = CLWREC.CLAGROUP;
  ;
end // end KL0JS30

// date routine
Function KL0JS38()
   /* *** gets date and moves to ta2rec*/
  ;
  CLXREC.CLXCPROC = "CL0JS38"; /* set current process name*/
  ;
  ;
  set TA2REC empty;
  TA2REC.TA2DTOPT = "GETDATE";
  call "TA0040" (TA2REC) {isNoRefresh = yes, isExternal = yes};
  ;
  ;
end // end KL0JS38

// update comments when no gl chg
Function KL0JS41()
   /* *************************************************************/
   /* *     comments are checked to see if they changed.  if*/
   /* *     field was blank, but now is filled, then we have an*/
   /* *     add situation.  if the field was not blank, but now*/
   /* *     IT IS, THEN WE HAVE A DELETE SITUATION.if the*/
   /* *     'after' comment field is ne to 'before' comment*/
   /* *     field, and both are ne blank, then have upd situation.*/
   /* **/
   /* *************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0JS41"; /* set current process name*/
  ;
  ;
  CL0JW01.CL0JWUCM = "N";
  ;
  ;
  if (CL0JW04.CL0JWCUP[CLXLINEX] == "Y" /* if supposed to update comment*/
   || KL0JM001.CLICRDFL[CLXLINEX] == "X")
    /* next sentence*/
  else
    return;
  end
  ;
  ;
  set CLGREC empty;
  ;
  ;
  CLGREC.CLACLMNB = KL0JM001.CLACLMNB;
  CLGREC.CLHSEQNB = KL0JM001.CLHSEQNB;
  CLGREC.CL2ISNBR = 0;
  CLGREC.CLGCMTYP = "G";
  if (CLIREC.CLGCMSEQ == 0)
    CL0JW01.CLGCMSEQ = CL0JW01.CLGCMSEQ + 1;
    CL0JW03.CLGCMSEQ = CL0JW01.CLGCMSEQ;
    CLGREC.CLGCMSEQ = CL0JW01.CLGCMSEQ;
    CL0JW01.CL0JWUCM = "Y";
  else
    CLGREC.CLGCMSEQ = CLIREC.CLGCMSEQ;
  end
  ;
  ;
  call "IO1260" ("S ", SQLCA, CLGREC) {isNoRefresh = yes, isExternal = yes};
  if (SQLCA.VAGen_SQLCODE == 0 /* a good return*/
   || SQLCA.VAGen_SQLCODE == 100) /* or not found*/
    /* next sentence*/
  else
    TA1REC.TA1DBASE = "DCLAIM";
    TA1REC.TA1TBLVU = "VCLCOM01";
    XPCL010();
  end
  ;
  ;
      /* if we get here then we know that the record*/
      /* exists... we delete it and if needed add*/
      /* it back*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0) /* if record was on file*/
    call "IO1260" ("D ", SQLCA, CLGREC) {isNoRefresh = yes, isExternal = yes}; /* delete it to keep*/
    if (SQLCA.VAGen_SQLCODE == 0) /* the keys straight*/
       /* next sentence*/
    else
      if (SQLCA.VAGen_SQLCODE == -911)
        CLXREC.CLXERRF = "Y";
        converseLib.validationFailed(4);
        return;
      else
        TA1REC.TA1DBASE = "DCLAIM";
        TA1REC.TA1TBLVU = "VCLCOM01";
        XPCL010();
      end
    end
  end
  ;
  ;
  if (KL0JM001.CLICRDFL[CLXLINEX] == "X") /* if deleting g/l record*/
    return;
  else
    if (CL0JW04.CL0JWCOM[CLXLINEX] != " " /* if there was a comment*/
     && KL0JM001.CLGCOMNT[CLXLINEX] == " ") /* but was removed*/
      CL0JW03.CLGCMSEQ = 0; /* remove sequence number*/
      CL0JW01.CL0JWUCM = "Y";
      return; /* already deleted, so go back*/
    end
  end
  ;
  ;
  set CLGREC empty;
  CLGREC.CLACLMNB = KL0JM001.CLACLMNB;
  CLGREC.CLHSEQNB = KL0JM001.CLHSEQNB;
  CLGREC.CL2ISNBR = 0;
  CLGREC.CLGCMTYP = "G";
  CLGREC.CLGCMSEQ = CL0JW03.CLGCMSEQ;
  CLGREC.CLGCOMNT = KL0JM001.CLGCOMNT[CLXLINEX];
  CLGREC.ZZZCHGTM = TA2TIMHM;
  CLGREC.ZZZCHGDT = TA2REC.TA2GRGGN;
  set SQLCA empty;
  call "IO1260" ("A ", SQLCA, CLGREC) {isNoRefresh = yes, isExternal = yes}; /* add the record*/
  if (SQLCA.VAGen_SQLCODE == 0)
    /* next sentence*/
  else
    TA1REC.TA1DBASE = "DCLAIM";
    TA1REC.TA1TBLVU = "VCLCOM01";
    XPCL010();
  end
  ;
  ;
  ;
  ;
end // end KL0JS41

// have add/update
Function KL0JS42()
   /* *************************************************************/
    /* when a record has been added to the screen this routine is*/
    /* called to add the record to clirec, and clgrec if a*/
    /* comment was entered.  also updates existing records*/
  ;
    /* Maintenance History:*/
  ;
    /* 01-19-90 chellm DB2/CSP structure changes. Replaced XGETBL*/
             /* with PFJREC (DPROFT.VGLCDS01). Added code to*/
           /* translate PFJBKIFL, PFJRESFL flags. Renamed XGEXREF*/
            /* as PFJXREF and XGEFBTYP as iv6FBTYP.*/
    /* 02-16-90 BCOURT set PFJREC empty.*/
    /* 12-20-90 CHELLM Force Face Bank type to 'F' if GL is NBQ.*/
  ;
   /* *************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0JS42"; /* set current process name*/
  ;
  if (KL0JM001.CLICRDFL[CLXLINEX] == " " /* if no action to be taken*/
   && CL0JW01.CL0JWUCM == "N")           /* and comments were not updated*/
    return;
  end
  ;
  ;
  call "IO1300" ("SB", SQLCA, CLIREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE == 0
   || SQLCA.VAGen_SQLCODE == 100)
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DCLAIM";
    TA1REC.TA1TBLVU = "VCLGLX01";
    TA1REC.TA1LOCAT[2] = "SELECT B";
    CLXREC.XXXWDTE = KL0JM001.CLACLMNB;
    TA1REC.TA1TBLKE = CLXREC.XXXWDTE;
    XPCL010();
  end
  ;
   /* if user wants to use different percentage than on the*/
   /* override, the program needs to keep the override on the*/
   /* database and also add the new percentage record.*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    if (CLIREC.CLIGLOIN == "Y") /* if override*/
       /* next sentence - want to keep old record and add new one*/
    else
      /* IF CL0JM001.CLICRDFL(CLXLINEX) = 'R';*/
        /* MOVE 'R' TO CLIREC.CLIGLFIV;*/
        /* PERFORM XQCLIR0;*/
        /* IF EZESQCOD = 0;*/
          /* ; next sentence*/
        /* ELSE ;*/
          /* PERFORM XPCL003;*/
        /* END ;*/
      /* ELSE ;*/
      call "IO1300" ("DB", SQLCA, CLIREC) {isNoRefresh = yes, isExternal = yes}; /* delete the record*/
      if (SQLCA.VAGen_SQLCODE == 0)
         /* next sentence*/
      else
        TA1REC.TA1DBASE = "DCLAIM";
        TA1REC.TA1TBLVU = "VCLGLX01";
        TA1REC.TA1LOCAT[2] = "DELETE B";
        CLXREC.XXXWDTE = KL0JM001.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE;
        XPCL010();
      end
    end
  end
  ;
  ;
  if (KL0JM001.CLICRDFL[CLXLINEX] == "X") /* if delete was requested*/
    if (KL0JM001.IV6FBTYP[CLXLINEX] != "B")
      if (CL0JW02.PFJXREF[CLXLINEX] == "NBQ")
        if (CL0JW02.CLICRDFL[CLXLINEX] == "D")
          CL0JW01.CLIGLAM = CL0JW01.CLIGLAM + CL0JW02.CLIGLAM[CLXLINEX];
        else
          if (CL0JW02.CLICRDFL[CLXLINEX] == "C")
            CL0JW01.CLIGLAM = CL0JW01.CLIGLAM - CL0JW02.CLIGLAM[CLXLINEX];
          end
        end
      else
        if (CL0JW02.CLICRDFL[CLXLINEX] == "D")
          CL0JW01.CLIGLAM = CL0JW01.CLIGLAM - CL0JW02.CLIGLAM[CLXLINEX];
        else
          if (CL0JW02.CLICRDFL[CLXLINEX] == "C")
            CL0JW01.CLIGLAM = CL0JW01.CLIGLAM + CL0JW02.CLIGLAM[CLXLINEX];
          end
        end
      end
    end
    return; /* already deleted, so go back*/
  end
  ;
  ;
  CLIREC.CLIGROUP = CL0JW03.CLIGROUP;
  ;
  ;
  if (KL0JM001.CLICRDFL[CLXLINEX] == "C"
   || KL0JM001.CLICRDFL[CLXLINEX] == "D")
    /* OR CL0JM001.CLICRDFL(CLXLINEX) EQ 'R';*/
    if (CLIREC.CLIADVSQ == 0)
      /* OR CL0JM001.CLICRDFL(CLXLINEX) = 'R';*/
      CL0JW01.CLIADVSQ = CL0JW01.CLIADVSQ + 1;
      CLIREC.CLIADVSQ = CL0JW01.CLIADVSQ;
    end
    /* IF CL0JM001.CLICRDFL(CLXLINEX) = 'R';*/
      /* MOVE 'E' TO CLIREC.CLIGLFIV;*/
      /* MOVE 'Y' TO CLIREC.CLIIGOFL;*/
    /* END ;*/
    ;
     /* save correct percent*/
    ;
    if (KL0JM001.CLIGLPC[CLXLINEX] > 0)
       /* clirec.cliglfiv should equal 'e'*/
      CLIREC.CLIGLPC = KL0JM001.CLIGLPC[CLXLINEX];
    else
      if (KL0JM001.IV6GLPCT[CLXLINEX] > 0)
         /* clirec.cliglfiv should equal 'i'*/
        CLIREC.CLIGLPC = KL0JM001.IV6GLPCT[CLXLINEX];
      else
        CLIREC.CLIGLPC = 0;
      end
    end
    ;
     /* when adding a copy of an override record, need to*/
     /* change the override flag and the claim number*/
    ;
    if (CLIREC.CLIGLOIN == "Y")
      CLIREC.CLIGLFIV = "F"; /* override reversal*/
      CLIREC.CLIGLOIN = "N";
      CLIREC.CLIIGOFL = "N";
      CLIREC.CLACLMNB = KL0JM001.CLACLMNB;
      ;
       /* change apply flag if reversing an override*/
      ;
      CLIREC.CLIIGOFL = "N";
      ;
    else
      if (CLIREC.CLIGLFIV == "I" /* if reversing invoice*/
       || CLIREC.CLIGLFIV == "R")
        if (KL0JM001.CLICRDFL[CLXLINEX] == "C"
         || KL0JM001.CLICRDFL[CLXLINEX] == "D")
          CLIREC.CLIIGOFL = "N";
        end
      else
        CLIREC.CLIIGOFL = KL0JM001.CLIIGOFL[CLXLINEX];
      end
    end
    ;
                               /* (begin 11-17-89 addition)*/
    ;
    set PFJREC empty; /* 2-16-90*/
    set SQLCA empty;
    PFJREC.GLACD = KL0JM001.GLACD[CLXLINEX];
    ;
    call "IO4360" ("S ", SQLCA, PFJREC) {isNoRefresh = yes, isExternal = yes}; /* get gl code info*/
    ;
    if (SQLCA.VAGen_SQLCODE == 0)
      ;
      if (PFJREC.PFJBNKIF == "A"
       || PFJREC.PFJBNKIF == "C"
       || PFJREC.PFJBNKIF == "F")
        if (PFJREC.PFJXREF == "NBQ") /* 12-20-90*/
          CLIREC.IV6FBTYP = "F"; /* 12-20-90*/
        else
          CLIREC.IV6FBTYP = "B";
        end
      else
        if (PFJREC.PFJBNKIF == "N")
          CLIREC.IV6FBTYP = "F";
        else
          converseLib.validationFailed(604);
                                   /* G/L tbl maint required - call sys dev*/
          CLXREC.CLXERRF = "Y";
          return;
        end
      end
      ;
      CLIREC.PFJXREF = PFJREC.PFJXREF;
      ;
    else
      TA1REC.TA1DBASE = "DPROFT";
      TA1REC.TA1TBLVU = "VGLCDS01";
      CLXREC.XXXWDTE = KL0JM001.CLACLMNB;
      TA1REC.TA1TBLKE = CLXREC.XXXWDTE;
      XPCL010();
    end
    ;
    ;
    KL0JS46(); /* calculate amount*/
    KL0JS48(); /* set clicrdfl*/
    CLIREC.GLACD = KL0JM001.GLACD[CLXLINEX];
    ;
  end
  ;
                             /* (end 11-17-89 addition)*/
  ;
  CLIREC.ZZZCHGDT = TA2REC.TA2GRGGN;
  CLIREC.ZZZCHGTM = TA2REC.TA2TIMHM;
  ;
  ;
  call "IO1300" ("A ", SQLCA, CLIREC) {isNoRefresh = yes, isExternal = yes}; /* add record to clirec*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DCLAIM";
    TA1REC.TA1TBLVU = "VCLGLX01";
    TA1REC.TA1LOCAT[2] = "ADD";
    CLXREC.XXXWDTE = KL0JM001.CLACLMNB;
    TA1REC.TA1TBLKE = CLXREC.XXXWDTE;
    XPCL010();
  end
  ;
  ;
  ;
  ;
end // end KL0JS42

// Update the Claim Header/CLAREC
Function KL0JS43()
   /* 10-22-90 bcourt change proc named as sgrp to be sgrp*/
      /* *******************************************************/
      /* clarec needs to be changed due to adds/changes/deletes*/
      /* on the adjustment products/sizes.*/
  ;
      /* all changes are kept in cl0jw01.*/
      /* clarec has flags that must not be changed until we*/
      /* leave this appl.  they are:*/
         /* cladbocl - does this claim have debits?*/
         /* claestvl - keep original value*/
           /* note - we don't directly update this until leave*/
           /* the appl.  we keep the delta (changed) amount in*/
           /* cl0jw01.cl0jwvch (value change)*/
  ;
      /* this allows us to update the same zzzchgct as was brouht*/
      /* in by clwrec in the commarea, or to read the current*/
      /* clarec and apply the changes to it.*/
      /* *******************************************************/
  ;
  CLXREC.CLXCPROC = "CL0JS43"; /* set current process name*/
  ;
  call "IO1160" ("S ", SQLCA, CLAREC) {isNoRefresh = yes, isExternal = yes}; /* get current record*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DCLAIM";
    TA1REC.TA1TBLVU = "VCLHDR01";
    XPCL010(); /* abend*/
  end
  ;
  ;
  if (CL0JW01.CL0JWNOD > 0   /* at least one debit*/
   && CLAREC.CLADBOCL == "Y" /* and flag already set*/
   && CL0JW01.CLIGLAM == 0)  /* and amount didnt change*/
    return; /* no update needed*/
  end
  ;
  ;
  if (CL0JW01.CL0JWNOD == 0  /* if no debits on claim*/
   && CLAREC.CLADBOCL == "N" /* and flag is not set*/
   && CL0JW01.CLIGLAM == 0)  /* and amount didnt change*/
    return; /* no update needed*/
  end
  ;
  ;
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
     /* apply changes to clarec*/
    if (CL0JW01.CL0JWNOD > 0) /* at least one debit*/
      CLAREC.CLADBOCL = "Y"; /* move y to claim header*/
    else
      CLAREC.CLADBOCL = "N"; /* move n to claim header*/
    end
      /* add the accumulated gl amounts to the est clm value*/
    CLAREC.CLAESTVL = CLAREC.CLAESTVL + CL0JW01.CLIGLAM;
    ;
    CLAREC.ZZZCHGTM = TA2TIMHM;
    CLAREC.ZZZCHGDT = TA2REC.TA2GRGGN;
    ;
    call "IO1160" ("U ", SQLCA, CLAREC) {isNoRefresh = yes, isExternal = yes}; /* replace clarec*/
    ;
    if (SQLCA.VAGen_SQLCODE == 0)
       /* ezertn*/
    else
      TA1REC.TA1DBASE = "DCLAIM";
      TA1REC.TA1TBLVU = "VCLHDR01";
      XPCL010(); /* abend*/
    end
  else
    TA1REC.TA1DBASE = "DCLAIM";
    TA1REC.TA1TBLVU = "VCLHDR01";
    XPCL010(); /* abend*/
  end
  ;
  ;
end // end KL0JS43

// update g/l flag on clb rec
Function KL0JS44()
   /* 10-22-90 bcourt change proc named as sgrp to be sgrp*/
      /* *******************************************************/
    /* the g/l indicator on the clb rec needs to be updated*/
    /* if it changed*/
      /* *******************************************************/
  ;
  CLXREC.CLXCPROC = "CL0JS44"; /* set current process name*/
  ;
  ;
  set CLBREC empty;
  CLBREC.CLACLMNB = CLAREC.CLACLMNB;
  CLBREC.IV0IVCID = KL0JM001.IV0IVCID;
  CLXREC.CLXORDIV = KL0JM001.IV0IVCID;
  CLBREC.IV0PARTN = CLXREC.CLXPARTN;
  ;
  call "IO1180" ("S ", SQLCA, CLBREC) {isNoRefresh = yes, isExternal = yes}; /* get current record*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DCLAIM";
    TA1REC.TA1TBLVU = "VCLIVX01";
    XPCL010(); /* abend*/
  end
  ;
  ;
  if (CL0JW01.CL0JWNOG > 0 /* at least one gl*/
   && CLBREC.CLBGLIND == "Y") /* and flag already set*/
    return;
  end
  ;
  ;
  if (CL0JW01.CL0JWNOG == 0 /* at no g/l's*/
   && CLBREC.CLBGLIND == "N") /* and flag is not set*/
    return;
  end
  ;
  ;
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
     /* apply changes to clbrec*/
    if (CL0JW01.CL0JWNOG > 0) /* at least one debit*/
      CLBREC.CLBGLIND = "Y"; /* set g/l indicator to yes*/
    else
      CLBREC.CLBGLIND = "N"; /* set g/l indicator to no*/
    end
    ;
    CLBREC.ZZZCHGTM = TA2TIMHM;
    CLBREC.ZZZCHGDT = TA2REC.TA2GRGGN;
    ;
    call "IO1180" ("U ", SQLCA, CLBREC) {isNoRefresh = yes, isExternal = yes}; /* update clbrec*/
    ;
    if (SQLCA.VAGen_SQLCODE == 0)
       /* ezertn*/
    else
      TA1REC.TA1DBASE = "DCLAIM";
      TA1REC.TA1TBLVU = "VCLIVX01";
      XPCL010(); /* abend*/
    end
  else
    TA1REC.TA1DBASE = "DCLAIM";
    TA1REC.TA1TBLVU = "VCLIVX01";
    XPCL010(); /* abend*/
  end
  ;
  ;
end // end KL0JS44

// build new cli record
Function KL0JS45()
   /* *************************************************************/
   /* * when a record has been added to the screen this routine is*/
   /* * called to add the record to clirec, and clgrec if a*/
   /* * comment was entered.*/
   /* **/
   /* * Maintenance History:*/
   /* **/
   /* * 01-19-90 chellm  Renamed CLINMTFL as CLIADMAT*/
   /* **/
   /* *************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0JS45"; /* set current process name*/
  ;
  ;
  set CLIREC empty;
  ;
  ;
  if (CL0JW04.CL0JWAPT[CLXLINEX] == 0) /* if no record existed before*/
     /* set up normal defaults*/
    CLIREC.CLACLMNB = KL0JM001.CLACLMNB; /* then build whole new*/
    CLIREC.CLHSEQNB = CLWREC.CLHSEQNB; /* record*/
    CLIREC.CLIADMAT = "N";
    CLIREC.IV6GLSEQ = " ";
    CLIREC.XHDCD = " ";
    CLIREC.OP2LNINB = 0;
    CLIREC.SY1STNBR = " ";
    CLIREC.CLIGLNFL = " ";
    CLIREC.SY2CLRID = " ";
    CLIREC.XDMCD = " ";
    CLIREC.CLIGLOIN = "N";
    CLIREC.XGPCD = CLAREC.XGPCD;
    CLIREC.IV0IVCID = KL0JM001.IV0IVCID;
    CLXREC.CLXORDIV = KL0JM001.IV0IVCID;
    CLIREC.IV0PARTN = CLXREC.CLXPARTN;
    CLIREC.CLIIGOFL = KL0JM001.CLIIGOFL[CLXLINEX];
    CL0JW01.CLIADVSQ = CL0JW01.CLIADVSQ + 1;
    CLIREC.CLIADVSQ = CL0JW01.CLIADVSQ;
    CLIREC.CLGCMSEQ = 0;
    CLIREC.CLIGLFIV = CL0JW04.CLIGLFIV[CLXLINEX];
  else
    CL0JW01.CL0JW05X = CL0JW04.CL0JWAPT[CLXLINEX];
    CLIREC.CLIGROUP = CL0JW05.CLIGROUP[CL0JW05X];
    if (CLIREC.CLIGLOIN == " ")
      CLIREC.CLIGLOIN = "N";
    end
  end
  ;
  ;
  CL0JW03.CLIGROUP = CLIREC.CLIGROUP;
  ;
  ;
  ;
  ;
end // end KL0JS45

// calculate new cli amount
Function KL0JS46()
   /* *************************************************************/
   /* * calculate new cli amount*/
   /* * 03-06-91 CHELLM Change calculation that accumulates GL*/
   /* *          amounts to correctly handle NBQ GL's.*/
   /* *************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0JS46"; /* set current process name*/
  ;
  CLIREC.CLIGLAM = KL0JM001.CLIGLAM[CLXLINEX];
  ;
  ;
  if (CLIREC.CLIGLAM < 0)
    CLIREC.CLIGLAM = CLIREC.CLIGLAM * -1;
  end
  if (KL0JM001.IV6FBTYP[CLXLINEX] != "B")
    /* AND CL0JM001.CLICRDFL(CLXLINEX) NE 'R';*/
    if (CL0JW04.CL0JWSFL[CLXLINEX] == "C") /* if from claims table*/
      if (PFJREC.PFJXREF != "NBQ")
        if (CL0JW02.CLICRDFL[CLXLINEX] == "D") /* back out previous amt*/
          CL0JW01.CLIGLAM = CL0JW01.CLIGLAM - CL0JW02.CLIGLAM[CLXLINEX];
        else
          if (CL0JW02.CLICRDFL[CLXLINEX] == "C")
            CL0JW01.CLIGLAM = CL0JW01.CLIGLAM + CL0JW02.CLIGLAM[CLXLINEX];
          end
        end
      else
          /* for NBQ GL's, the CR DB usage is opposite from other GL's*/
        if (CL0JW02.CLICRDFL[CLXLINEX] == "D") /* back out previous amt*/
          CL0JW01.CLIGLAM = CL0JW01.CLIGLAM + CL0JW02.CLIGLAM[CLXLINEX];
        else
          if (CL0JW02.CLICRDFL[CLXLINEX] == "C")
            CL0JW01.CLIGLAM = CL0JW01.CLIGLAM - CL0JW02.CLIGLAM[CLXLINEX];
          end
        end
      end
       /* ELSE ;*/
    end
    if (PFJREC.PFJXREF != "NBQ")
      if (KL0JM001.CLICRDFL[CLXLINEX] == "D")
        CL0JW01.CLIGLAM = CL0JW01.CLIGLAM + CLIREC.CLIGLAM;
      else
        if (KL0JM001.CLICRDFL[CLXLINEX] == "C")
          CL0JW01.CLIGLAM = CL0JW01.CLIGLAM - CLIREC.CLIGLAM;
        end
      end
    else
       /* for NBQ GL's the Cr Db usage is opposite from other GL's*/
      if (KL0JM001.CLICRDFL[CLXLINEX] == "D")
        CL0JW01.CLIGLAM = CL0JW01.CLIGLAM - CLIREC.CLIGLAM;
      else
        if (KL0JM001.CLICRDFL[CLXLINEX] == "C")
          CL0JW01.CLIGLAM = CL0JW01.CLIGLAM + CLIREC.CLIGLAM;
        end
      end
    end
  end
  ;
  ;
  ;
  ;
end // end KL0JS46

// set clicrdfl
Function KL0JS48()
   /* *************************************************************/
   /* *     figure out what is supposed to be in the*/
   /* *     debit/credit flag*/
   /* *************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0JS48"; /* set current process name*/
  ;
  ;
   /* IF CL0JM001.CLICRDFL(CLXLINEX) = 'R';if line is replicated*/
    /* IF CLIREC.CLICRDFL = 'C'      ; was a credit before*/
      /* MOVE 'R' TO CLIREC.CLICRDFL;*/
    /* ELSE ;*/
      /* MOVE 'S' TO CLIREC.CLICRDFL;*/
    /* END ;*/
   /* ELSE ;*/
  CLIREC.CLICRDFL = KL0JM001.CLICRDFL[CLXLINEX];
   /* END ;*/
  ;
  ;
  ;
  ;
  ;
end // end KL0JS48

// validate the comment
Function KL0JS51()
   /* ************************************************************/
   /* *     validate the comment                                **/
   /* *                                                         **/
   /* *                                                         **/
   /* *                                                         **/
   /* *                                                         **/
   /* *                                                         **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0JS51"; /* set current process name*/
  ;
  ;
  if (KL0JM001.CLICRDFL[CLXLINEX] == " "
   && CL0JW04.CL0JWSFL[CLXLINEX] == "I"
   && KL0JM001.CLGCOMNT[CLXLINEX] is modified
   && KL0JM001.CLGCOMNT[CLXLINEX] != " ")
    converseLib.validationFailed(193); /* g/l from invoice - d/c to enter comment*/
    set KL0JM001.CLGCOMNT[CLXLINEX] cursor, modified, bold;
    CLXERRF = "Y"; /* move y to error flag*/
    return;
  end
  ;
   /* if reversing an override,need to save claim number that is*/
   /* displayed in comments field as a comment for the reversal.*/
  ;
  if (CL0JW04.CLIGLOIN[CLXLINEX] == "Y"
   && CL0JW04.CL0JWSFL[CLXLINEX] == "C")
    if (CL0JW04.CLIGLFIV[CLXLINEX] == "E"
     || CL0JW04.CLIGLFIV[CLXLINEX] == "B")
      if (KL0JM001.CLICRDFL[CLXLINEX] == "C"
       || KL0JM001.CLICRDFL[CLXLINEX] == "D")
        set KL0JM001.CLGCOMNT[CLXLINEX] modified;
        CL0JW04.CL0JWCUP[CLXLINEX] = "Y";
      end
    end
  end
  ;
  if (KL0JM001.CLGCOMNT[CLXLINEX] != CL0JW02.CLGCOMNT[CLXLINEX])
    CL0JW04.CL0JWCUP[CLXLINEX] = "Y";
  end
end // end KL0JS51

// validate g/l percent & amount
Function KL0JS52()
   /* ************************************************************/
   /* *     validate the g/l percent and amount                 **/
   /* *                                                         **/
   /* *  Maintance History:                                     **/
   /* *                                                         **/
   /* *  01-19-90 CHELLM renamed CL0JM001.GLCD as GLACD         **/
   /* *                          XGEFBTYP as IV6FBTYP           **/
   /* *  01-08-91 CHELLM Added CL0JS63 to edit the amount field **/
   /* *                  of NBQ GL codes.                       **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0JS52"; /* set current process name*/
  ;
  if (KL0JM001.CLIGLPC[CLXLINEX] > 99)
    converseLib.validationFailed(183);
    set KL0JM001.CLIGLPC[CLXLINEX] cursor, modified, bold;
    CLXREC.CLXERRF = "Y"; /* move y to error flag*/
  end
  ;
   /* ************************************************************/
   /* if the user enters the record on the screen they can only*/
   /* enter a gl percent or gl amt but not both.  if the records*/
   /* came from invoices then both the percent and the amount*/
   /* are allowed.*/
   /* ************************************************************/
  ;
  if (KL0JM001.CLIGLPC[CLXLINEX] != 0 /* IF THE PERCENT IS ENTERED*/
   && KL0JM001.CLIGLAM[CLXLINEX] != 0) /* AND THE AMOUNT IS ENTERED*/
    if (CL0JW04.CLIGLOIN[CLXLINEX] == "Y") /* if override*/
       /* next sentence*/
    else
      if (CL0JW04.CLIGLFIV[CLXLINEX] == "E") /* IF REC entered, ERROR*/
        converseLib.validationFailed(184); /* either pct or amt...not both*/
        set KL0JM001.CLIGLPC[CLXLINEX] cursor, modified, bold;
        set KL0JM001.CLIGLAM[CLXLINEX] modified, bold;
        CLXREC.CLXERRF = "Y"; /* move y to error flag*/
        return;
      end
    end
  end
  ;
  ;
  if (CL0JW04.CLIGLFIV[CLXLINEX] == "I" /* IF REC FROM INV. NO ERROR*/
   || CL0JW04.CLIGLFIV[CLXLINEX] == "R" /* IF REC FROM INV. NO ERROR*/
   || CL0JW04.CLIGLFIV[CLXLINEX] == "F" /* IF REC FROM override reversal*/
   || CL0JW04.CLIGLOIN[CLXLINEX] == "Y") /* if rec is override, no error*/
    /* next sentence....no error*/
  else
    if (KL0JM001.IV6FBTYP[CLXLINEX] == "B"
     && KL0JM001.CLIGLAM[CLXLINEX] != 0)
      converseLib.validationFailed(166); /* cant have amount with bank type*/
      CLXREC.CLXERRF = "Y";
      set KL0JM001.CLIGLAM[CLXLINEX] cursor, modified, bold;
      return;
    else
      if (KL0JM001.IV6FBTYP[CLXLINEX] == "F"
       && KL0JM001.CLIGLPC[CLXLINEX] != 0)
        if (CLWREC.CLWMNOPT == 10
         || CLWREC.CLWMNOPT == 11
         || CLWREC.CLWMNOPT == 12)
          converseLib.validationFailed(168); /* percent is invalid*/
          CLXREC.CLXERRF = "Y";
          set KL0JM001.CLIGLPC[CLXLINEX] cursor, modified, bold;
          return;
        end
      end
    end
  end
  ;
  ;
  if (CL0JW04.CLIGLFIV[CLXLINEX] == "I" /* IF REC FROM INV. NO ERROR*/
   || CL0JW04.CLIGLFIV[CLXLINEX] == "R" /* IF REC FROM INV. NO ERROR*/
   || CL0JW04.CLIGLFIV[CLXLINEX] == "F" /* IF REC FROM override reveral*/
   || CL0JW04.CLIGLOIN[CLXLINEX] == "Y") /* IF REC is override, NO ERROR*/
    /* next sentence....no error*/
  else
    if (KL0JM001.CLIGLPC[CLXLINEX] != 0)
      if (KL0JM001.GLACD[CLXLINEX] == "596" 
       || KL0JM001.GLACD[CLXLINEX] == "595" /* added 6-7-91*/
       || KL0JM001.GLACD[CLXLINEX] == "592" /* "*/
       || KL0JM001.GLACD[CLXLINEX] == "597" /* "*/
       || KL0JM001.GLACD[CLXLINEX] == "599" /* "*/
       || KL0JM001.GLACD[CLXLINEX] == "746" 
       || KL0JM001.GLACD[CLXLINEX] == "750")
        converseLib.validationFailed(169); /* percent is invalid*/
        CLXREC.CLXERRF = "Y";
        set KL0JM001.CLIGLPC[CLXLINEX] cursor, modified, bold;
        return;
      end
    end
  end
  ;
  ;
  if (KL0JM001.CLIGLAM[CLXLINEX] < 0)
    if (CL0JW04.CL0JWSFL[CLXLINEX] == "I" /* if from invoice*/
     || CL0JW04.CLIGLOIN[CLXLINEX] == "Y") /* if an override*/
      /* next sentece....no error*/
    else
      converseLib.validationFailed(195); /* amount must be positive*/
      CLXREC.CLXERRF = "Y";
      set KL0JM001.CLIGLAM[CLXLINEX] cursor, modified, bold;
      return;
    end
  end
  ;
  ;
   /* if the percent is not entered check to see if the gl amount*/
   /* is entered.  if the line isn't blank than at least one of*/
   /* the two fields must be entered.  error if not*/
  ;
  if (KL0JM001.CLICRDFL[CLXLINEX] == "C")
     /* the g/l percent is allowed to be zero when zeroing*/
     /* out a previous invoice g/l with a credit entry*/
  else
    if (KL0JM001.CLIGLAM[CLXLINEX] == 0
     && KL0JM001.CLIGLPC[CLXLINEX] == 0)
      converseLib.validationFailed(182); /* either pct or amt must be entered*/
      set KL0JM001.CLIGLPC[CLXLINEX] cursor, modified, bold;
      set KL0JM001.CLIGLAM[CLXLINEX] modified, bold;
      CLXREC.CLXERRF = "Y"; /* move y to error flag*/
      return;
    end
  end
  ;
   /* check the Profitability GL table to see if NBQ GL's exist.*/
                        /* below added 1-8-91*/
  set SQLCA empty;
  set PFJREC empty;
  ;
  PFJREC.GLACD = KL0JM001.GLACD[CLXLINEX];
  ;
  call "IO4360" ("S ", SQLCA, PFJREC) {isNoRefresh = yes, isExternal = yes}; /* select PFJREC*/
  if (SQLCA.VAGen_SQLCODE == 0) /* if good return check for NBQ GL*/
    if (PFJREC.PFJXREF == "NBQ"
     && KL0JM001.CLICRDFL[CLXLINEX] == "C")
      KL0JS63(); /* edit the Nike Bank GL amount*/
      if (CLXREC.CLXERRF == "Y" /* if error found*/
       || CL0JW01.CL0JWNBF == "Y") /* or warning found*/
        return;
      end
    end
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      /* next sentence*/
    else
      TA1REC.TA1TBLKE = "FETCHING PFJREC  (CL0NS21)";
      XPCL010();
    end
  end
               /* end 1-8-91 addition*/
  ;
  set KL0JM001.IV6GLPCT[CLXLINEX] initialAttributes;
  set KL0JM001.CLIGLPC[CLXLINEX] initialAttributes;
  set KL0JM001.CLIGLAM[CLXLINEX] initialAttributes;
end // end KL0JS52

// validate g/l code
Function KL0JS53()
   /* ************************************************************/
   /* *     validate g/l code                                   **/
   /* *                                                         **/
   /* *  Maintenance History:                                   **/
   /* *                                                         **/
   /* *  01-19-90 CHELLM Replaced the XGETBL with PFJREC&IO4360.**/
   /* *           added code to translate the PFJBNKIF&PFJRESFL **/
   /* *           to XGEFBTYP & XGECPOFL.                       **/
   /* *  02-16-90 BCOURT give err 173 for g/l status = 'I'.     **/
   /* *  10-22-90 BCOURT allow certain banked g/ls if were used **/
   /* *                  to pay InStorePromo invoices.          **/
   /* *  02-27-91 CHELLM Allow entry of NBQ gl code for shipping**/
   /* *                  charges. (GL value = '980')            **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0JS53"; /* set current process name*/
  ;
  ;
   /* if user has override g/l pct*/
   /* and reversed the override g/l pct*/
   /* and entered another pct, all for the same gl code,*/
   /* then no more entries are allowed against the same gl code*/
  ;
   /* IF CL0JM001.GLACD(CLXLINEX) IN CL0JW05.GLACD;*/
    /* AND CL0JW05.CLIGLOIN(EZETST) EQ 'Y';*/
    /* IF CL0JM001.GLACD(CLXLINEX) IN CL0JW05.GLACD;*/
      /* AND CL0JW05.CLIGLFIV(EZETST) EQ 'F'; reversed the ovrd*/
      /* IF CL0JM001.GLACD(CLXLINEX) IN CL0JW05.GLACD;*/
        /* AND 'N' IN CL0JW05.CLIGLOIN(EZETST);*/
        /* AND 'E' IN CL0JW05.CLIGLFIV(EZETST);*/
   /* MOVE 423 TO EZEMNO; g/l entry not allowed..use previous entr*/
        /* SET CL0JM001.GLACD(CLXLINEX) CURSOR,MODIFIED,BRIGHT;*/
        /* MOVE 'Y' TO CLXREC.CLXERRF;*/
        /* EZERTN;*/
      /* END ;*/
    /* END ;*/
   /* END ;*/
  ;
    /* edit entered g/l code to make sure it is correct for acct*/
    /* class xaucd and freight class code yctcd*/
  if (KL0JM001.GLACD[CLXLINEX] is modified)
    if (KL0JM001.GLACD[CLXLINEX] == "595"
     || KL0JM001.GLACD[CLXLINEX] == "596"
     || KL0JM001.GLACD[CLXLINEX] == "597"
     || KL0JM001.GLACD[CLXLINEX] == "599")
      if (CLAREC.YCTCD != "SCO")
        if (KL0JM001.XAUCD == "93")
          KL0JM001.GLACD[CLXLINEX] = "597";
                 /* SET CL0JM001.GLACD(CLXLINEX) MODIFIED,BRIGHT;*/
        else
          KL0JM001.GLACD[CLXLINEX] = "599";
                 /* SET CL0JM001.GLACD(CLXLINEX) MODIFIED,BRIGHT;*/
        end
      end
    end
  end
  ;
         /* get gl description*/
  if (KL0JM001.GLACD[CLXLINEX] != " ")
    if (KL0JM001.GLACD[CLXLINEX] is modified)
                                 /* (begin 01-19-90 addition)*/
      set PFJREC empty; /* 2-16-90 add*/
      PFJREC.GLACD = KL0JM001.GLACD[CLXLINEX];
      ;
      set SQLCA empty;
      call "IO4360" ("S ", SQLCA, PFJREC) {isNoRefresh = yes, isExternal = yes}; /* get gl code info*/
      ;
      if (SQLCA.VAGen_SQLCODE == 0
       && PFJREC.XXXSTAT == "A")
         /* next sentence*/
      else
        if (SQLCA.VAGen_SQLCODE == 100
         || SQLCA.VAGen_SQLCODE == 0) /* 2-16-90 status = 'I'*/
          converseLib.validationFailed(173); /* g/l not valid*/
          set KL0JM001.GLACD[CLXLINEX] cursor, modified, bold;
          CLXREC.CLXERRF = "Y"; /* move y to error flag*/
          KL0JM001.GLADESC[CLXLINEX] = " ";
          return;
        end
      end
                               /* (end 01-19-90 addition)*/
    else
      return;
    end
  else
          /* if any field is entered gl code must not be blank*/
    if (KL0JM001.CLIGLPC[CLXLINEX] != 0
     || KL0JM001.CLIGLAM[CLXLINEX] != 0
     || KL0JM001.CLGCOMNT[CLXLINEX] != " "
     || KL0JM001.CLICRDFL[CLXLINEX] != " ")
      ;
      converseLib.validationFailed(174); /* g/l required*/
      set KL0JM001.GLACD[CLXLINEX] cursor, modified, bold;
      CLXREC.CLXERRF = "Y";
      return;
    else
      set KL0JM001.GLACD[CLXLINEX] initialAttributes;
      return;
    end
  end
  ;
   /* 10-22-90 allow 'B'anked g/l if from the invoice*/
  ;
  if (PFJREC.PFJXREF == "NBQ" /* g/l used to pay ivc with nike bank $*/
   && CL0JW04.CLIGLFIV[CLXLINEX] != "I"
   && KL0JM001.GLACD[CLXLINEX] != "980")
    /* 02-28-91 GLACD 980 is NBQ FREIGHT replenishment*/
    converseLib.validationFailed(59);
                                   /* g/l code valid only on 'nbc' clm type*/
    set KL0JM001.GLACD[CLXLINEX] cursor, modified, bold;
    CLXREC.CLXERRF = "Y";
    return;
  else
    if (CLAREC.YCTCD != "NBC"  /* if not an nbc claim type*/
     && PFJREC.PFJRESFL == "B" /* and nbc-only gl code(01-19-90)*/
     && KL0JM001.GLACD[CLXLINEX] != "980") /* this NBQ can be entered*/
      converseLib.validationFailed(59);
      set KL0JM001.GLACD[CLXLINEX] cursor, modified, bold;
      CLXREC.CLXERRF = "Y";
      return;
    end
  end
  ;
  KL0JM001.GLADESC[CLXLINEX] = PFJREC.GLADESC; /* (01-19-90)*/
  ;
  if (PFJREC.PFJBNKIF == "A" /* translate the face or banked*/
   || PFJREC.PFJBNKIF == "C" /* discount code (01-19-90)*/
   || PFJREC.PFJBNKIF == "F")
    if (PFJREC.PFJXREF == "NBQ") /* for entered NBQ GL code (980) force to F*/
      KL0JM001.IV6FBTYP = "F";
    else
      KL0JM001.IV6FBTYP = "B";
    end
  else
    if (PFJREC.PFJBNKIF == "N")
      KL0JM001.IV6FBTYP = "F";
    else
      converseLib.validationFailed(604);
                                   /* G/L tbl maint required - call sys dev*/
      CLXREC.CLXERRF = "Y";
      return;
    end
  end
  ;
end // end KL0JS53

// edit credit/debit code
Function KL0JS54()
   /* ************************************************************/
   /* *     validate credit/debit code                          **/
   /* *                                                         **/
   /* *  Maintenance History:                                   **/
   /* *                                                         **/
   /* *  01-19-90 CHELLM renamed CL0JM001.GLCD CLACD            **/
   /* *                                                         **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0JS54"; /* set current process name*/
  ;
  ;
      /* if credit/debit code is entered it must be c,d or x*/
  ;
  ;
  if (KL0JM001.CLICRDFL[CLXLINEX] == " "
   && CL0JW02.CLICRDFL[CLXLINEX] != " ")
    /* IF CL0JW02.CLICRDFL(CLXLINEX) EQ 'R';*/
      /* MOVE 'D' TO CL0JM001.CLICRDFL(CLXLINEX);*/
    /* ELSE ;*/
    /* IF CL0JW02.CLICRDFL(CLXLINEX) EQ 'S';*/
      /* MOVE 'C' TO CL0JM001.CLICRDFL(CLXLINEX);*/
    /* ELSE ;*/
    KL0JM001.CLICRDFL[CLXLINEX] = CL0JW02.CLICRDFL[CLXLINEX];
    /* END ;*/
    /* END ;*/
  end
  ;
  ;
  if (KL0JM001.CLICRDFL[CLXLINEX] != " ")
    if (KL0JM001.CLICRDFL[CLXLINEX] == "C"
     || KL0JM001.CLICRDFL[CLXLINEX] == "D"
     || KL0JM001.CLICRDFL[CLXLINEX] == "X")
      /* OR CL0JM001.CLICRDFL(CLXLINEX) = 'R';*/
      /* next sentence*/
    else
      converseLib.validationFailed(171);
      set KL0JM001.CLICRDFL[CLXLINEX] cursor, modified, bold;
      CLXREC.CLXERRF = "Y"; /* move y to error flag*/
      return;
    end
  else
    ;
    if (KL0JM001.CLGCOMNT[CLXLINEX] is modified
     && KL0JM001.GLACD[CLXLINEX] not modified
     && KL0JM001.CLIGLPC[CLXLINEX] not modified
     && KL0JM001.CLIGLAM[CLXLINEX] not modified)
      return;
    else
      if (KL0JM001.GLACD[CLXLINEX] is modified
       || KL0JM001.CLIGLPC[CLXLINEX] is modified
       || KL0JM001.CLIGLAM[CLXLINEX] is modified)
        ;
        converseLib.validationFailed(172); /* credit/debit code is required*/
        set KL0JM001.CLICRDFL[CLXLINEX] cursor, bold;
        CLXREC.CLXERRF = "Y";
        return;
      end
    end
  end
  ;
  ;
  if (KL0JM001.CLICRDFL[CLXLINEX] != " "
   && CL0JW02.CLICRDFL[CLXLINEX] != " ")
    if (KL0JM001.CLICRDFL[CLXLINEX] == "C"
     && CL0JW02.CLICRDFL[CLXLINEX] == "C")
       /* next sentence*/
    else
      if (KL0JM001.CLICRDFL[CLXLINEX] == "D"
       && CL0JW02.CLICRDFL[CLXLINEX] == "D")
         /* next sentence*/
      else
        ;
         /* if cr/dr sel field has changed*/
        ;
        if (CL0JW04.CL0JWSFL[CLXLINEX] == "C")
          if (CL0JW04.CLIGLFIV[CLXLINEX] == "I"
           || CL0JW04.CLIGLFIV[CLXLINEX] == "F")
            converseLib.validationFailed(214);
                                   /* g/l already dbt/crd...can only delete*/
            set KL0JM001.CLICRDFL[CLXLINEX] cursor, modified, bold;
            CLXREC.CLXERRF = "Y";
            return;
          end
        end
      end
    end
  end
  ;
  ;
      /* if the user wants to credit this line, then*/
      /* the amount on the screen must be positive*/
      /* and the source for this line must be from*/
      /* the 'I'nvoice or an override*/
  ;
  ;
                             /* (begin 12-20-90 addition)*/
  ;
  set PFJREC empty;
  PFJREC.GLACD = KL0JM001.GLACD[CLXLINEX];
  ;
  set SQLCA empty;
  call "IO4360" ("S ", SQLCA, PFJREC) {isNoRefresh = yes, isExternal = yes}; /* get gl code info*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0
   && PFJREC.XXXSTAT == "A")
     /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == 100
     || SQLCA.VAGen_SQLCODE == 0)
      converseLib.validationFailed(173); /* g/l not valid*/
      set KL0JM001.GLACD[CLXLINEX] cursor, modified, bold;
      CLXREC.CLXERRF = "Y"; /* move y to error flag*/
      KL0JM001.GLADESC[CLXLINEX] = " ";
      return;
    end
  end
  ;
                           /* (end 12-20-90 addition)*/
  ;
  if (KL0JM001.CLICRDFL[CLXLINEX] == "C"
   && KL0JM001.CLIGLAM[CLXLINEX] < 0
   && PFJREC.PFJXREF != "NBQ") /* 12-20-90*/
    if (CL0JW04.CL0JWSFL[CLXLINEX] == "I"
     || CL0JW04.CLIGLOIN[CLXLINEX] == "Y")
      converseLib.validationFailed(185); /* amt must be positive to credit*/
      set KL0JM001.CLICRDFL[CLXLINEX] cursor, modified, bold;
      CLXREC.CLXERRF = "Y";
      return;
    end
  end
  ;
  ;
  if (KL0JM001.CLICRDFL[CLXLINEX] == "D"
   && PFJREC.PFJXREF == "NBQ") /* 12-20-90*/
    converseLib.validationFailed(681); /* can't debit NBQ GL, use NBC claim*/
    set KL0JM001.CLICRDFL[CLXLINEX] cursor, modified, bold;
    CLXREC.CLXERRF = "Y";
    return;
  end
  ;
      /* if the user wants to debit this line, then*/
      /* the amount on the screen must be negative*/
      /* and the source for this line must be from*/
      /* the 'I'nvoice or an override*/
  ;
  if (KL0JM001.CLICRDFL[CLXLINEX] == "D"
   && KL0JM001.CLIGLAM[CLXLINEX] > 0)
    if (CL0JW04.CL0JWSFL[CLXLINEX] == "I"
     || CL0JW04.CLIGLOIN[CLXLINEX] == "Y")
      converseLib.validationFailed(189); /* amt must be minus to debit*/
      set KL0JM001.CLICRDFL[CLXLINEX] cursor, modified, bold;
      CLXREC.CLXERRF = "Y";
      return;
    end
  end
  ;
  ;
      /* if the user wants to replicate this line, then*/
      /* the g/l must be already debited/credited (as*/
      /* detemined by being from the claims g/l table)*/
      /* and it must be an "invoice" g/l rather than an*/
      /* "entered" g/l.*/
  ;
   /* IF CL0JM001.CLICRDFL(CLXLINEX) = 'R';*/
    /* IF CL0JW04.CL0JWSFL(CLXLINEX) = 'C';*/
      /* AND CL0JW04.CLIGLFIV(CLXLINEX) EQ 'I';*/
      /* ;next sentence*/
    /* ELSE ;*/
      /* IF CL0JW04.CLIGLFIV(CLXLINEX) EQ 'R';*/
        /* MOVE 68 TO EZEMNO; this line already replicated once*/
        /* SET CL0JM001.CLICRDFL(CLXLINEX) CURSOR,MODIFIED,BRIGHT*/
        /* MOVE 'Y' TO CLXREC.CLXERRF;*/
        /* EZERTN;*/
      /* ELSE ;*/
        /* MOVE 55 TO EZEMNO; must be from ivc & from claims tbl*/
       /* SET CL0JM001.CLICRDFL(CLXLINEX) CURSOR,MODIFIED,BRIGHT;*/
       /* MOVE 'Y' TO CLXREC.CLXERRF;*/
       /* EZERTN;*/
     /* END ;*/
   /* END ;*/
   /* END ;*/
  ;
  ;
     /* if the user wants to delete this line, then*/
     /* the line cannot be from the invoice file*/
  ;
  if (KL0JM001.CLICRDFL[CLXLINEX] == "X")
    if (CL0JW04.CL0JWSFL[CLXLINEX] == "I")
      converseLib.validationFailed(194); /* cannot delete...this is invoice g/l*/
      set KL0JM001.CLICRDFL[CLXLINEX] cursor, modified, bold;
      CLXREC.CLXERRF = "Y";
      return;
    else
      if (CL0JW04.CLIGLOIN[CLXLINEX] == "Y")
        converseLib.validationFailed(194); /* cannot delete...this is invoice g/l*/
        set KL0JM001.CLICRDFL[CLXLINEX] cursor, modified, bold;
        CLXREC.CLXERRF = "Y";
        return;
      end
    end
  end
  ;
end // end KL0JS54

// edit apply flag
Function KL0JS55()
   /* ************************************************************/
   /* *     validate claim apply flag                           **/
   /* *                                                         **/
   /* *  Maintenance History:                                   **/
   /* *                                                         **/
   /* * 01-19-90 CHELLM renamed CL0JM001.GLCD as GLACD          **/
   /* *                 renamed CL0JW02.GLCD as GLACD           **/
   /* *                                                         **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0JS55"; /* set current process name*/
  ;
  ;
      /* if apply flag is entered it must be y/n*/
  ;
  ;
  if (KL0JM001.CLIIGOFL[CLXLINEX] == " "
   || KL0JM001.CLIIGOFL[CLXLINEX] == "Y"
   || KL0JM001.CLIIGOFL[CLXLINEX] == "N")
     /* next sentence*/
  else
    CLXREC.CLXERRF = "Y";
    set KL0JM001.CLIIGOFL[CLXLINEX] cursor, bold;
    converseLib.validationFailed(419); /* apply flag must be 'y' 'n' or blank*/
  end
  ;
   /* default apply flag*/
  ;
  if (KL0JM001.CLIIGOFL[CLXLINEX] == " ")
    if (CL0JW04.CLIGLOIN[CLXLINEX] == "Y")
       /* reversing g/l*/
      KL0JM001.CLIIGOFL[CLXLINEX] = "N";
    else
      if (KL0JM001.CLIGLAM[CLXLINEX] > 0)
        KL0JM001.CLIIGOFL[CLXLINEX] = "N";
      else
        if (KL0JM001.CLIGLAM[CLXLINEX] == 0)
          KL0JM001.CLIIGOFL[CLXLINEX] = "Y";
        end
      end
    end
  else
    if (KL0JM001.CLIGLAM[CLXLINEX] > 0
     && KL0JM001.CLIGLPC[CLXLINEX] == 0)
      KL0JM001.CLIIGOFL[CLXLINEX] = "N";
    end
  end
  ;
  ;
   /* cannot have matching g/l rows where apply flag eq 'y'*/
  ;
  CLXREC.CLXTESTF = "N";
  if (KL0JM001.CLIIGOFL[CLXLINEX] == "Y"
   && CL0JW02.GLACD[CLXLINEX] == " " /* have new g/l*/
   && KL0JM001.GLACD[CLXLINEX] != " ")
    ;
    KL0JS59(); /* look for multiple apply flags*/
    ;
  else
     /* check for user changing apply flag on existing rows*/
    ;
    if (KL0JM001.CLIIGOFL[CLXLINEX] == "Y"
     && KL0JM001.CLIIGOFL[CLXLINEX] is modified
     && CL0JW02.GLACD[CLXLINEX] == KL0JM001.GLACD[CLXLINEX])
      ;
      KL0JS59(); /* look for multiple apply flags*/
    end
  end
end // end KL0JS55

// edit deleting of row
Function KL0JS56()
   /* ************************************************************/
   /* *     make sure delete of row is possible                 **/
   /* *  check for deletion of a row that would otherwise*/
   /* *  make it impossible to delete the desired row.          **/
   /* *                                                         **/
   /* *  Maintenance History:                                   **/
   /* *                                                         **/
   /* *  01-19-90 CHELLM renamed CL0JM001.GLCD as GLACD         **/
   /* *                  renamed CL0Jw05.GLCD as GLACD          **/
   /* *                  renamed CLirec.GLCD as GLACD           **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0JS56"; /* set current process name*/
  ;
  ;
   /* cannot delete reversed invoice row where there is a*/
   /* matching entered g/l row.*/
  ;
  CLXREC.CLXYCSX = 1;
  CLXREC.CLXTESTF = "Y";
  ;
  while (CLXREC.CLXYCSX <= KL0JM001.CL0JWNOG /* nbr of g/l's on screen*/
   && CLXREC.CLXTESTF == "Y")
    ;
    if (KL0JM001.GLACD[CLXLINEX] in CL0JW05.GLACD from CLXYCSX)
      CLXREC.CLXYCSX = sysVar.arrayIndex;
      if (CL0JW05.CLIGLFIV[CLXYCSX] == "I" /* found invoice g/l*/
       || CL0JW05.CLIGLFIV[CLXYCSX] == "F") /* found reversed override g/l*/
          /* next sentence*/
      else
        if (CL0JW05.CLIGLFIV[CLXYCSX] == "E")
           /* cl0jwost eq 0,11,22 etc. for first,second,third page*/
          if (CLXREC.CLXYCSX <= CL0JW01.CL0JWOST)
            CLXREC.CLXTESTF = "N"; /* on previous screen*/
          else
            CL0JW01.CL0JWNBR = CLXREC.CLXYCSX - CL0JW01.CL0JWOST;
             /* see if row is to be deleted*/
            if (KL0JM001.CLICRDFL[CL0JWNBR] == "X")
               /* next sentence*/
            else
              CLXREC.CLXTESTF = "N"; /* found entered g/l*/
            end
          end
        end
      end
    end
    ;
    CLXREC.CLXYCSX = CLXREC.CLXYCSX + 1;
    ;
  end
  ;
  ;
  if (CLXREC.CLXTESTF == "N")
    converseLib.validationFailed(420); /* cannot delete...apply flag is set to yes*/
    set KL0JM001.CLICRDFL[CLXLINEX] cursor, modified, bold;
    CLXREC.CLXERRF = "Y";
    return;
  end
  ;
end // end KL0JS56

// edit apply flag on same screen
Function KL0JS57()
   /* ************************************************************/
   /* *     found apply flag eq 'y' now see if it is on the     **/
   /* *   same screen and has been changed to 'n' by the user.  **/
   /* *   (called from cl0js59 only)                            **/
   /* *                                                         **/
   /* *  Maintenance History:                                   **/
   /* *                                                         **/
   /* *  01-19-90 CHELLM renamed CL0JM001.GLCD as GLACD         **/
   /* *  10-22-90 BCOURT improve comments.                      **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0JS57"; /* set current process name*/
  ;
  ;
  ;
   /* found same g/l code with apply flag eq 'y' somewhere in*/
   /* array. now see if it is on the screen being shown and*/
   /* has been changed to apply flag eq 'n'*/
  ;
  if (CLXREC.CLXYCSX <= CL0JW01.CL0JWOST) /* found g/l on previous screen*/
     /* cannot have matching g/ls with apply flag eq y*/
    converseLib.validationFailed(421);
    CLXREC.CLXERRF = "Y";
    if (CL0JW04.CL0JWSFL[CLXLINEX] == "I") /* from invoice*/
       /* not allowed to change fields on invoice g/l*/
      set KL0JM001.CLIIGOFL[CLXLINEX] cursor, protect, modified, bold;
    else
      set KL0JM001.CLIIGOFL[CLXLINEX] cursor, modified, bold;
    end
    return;
  end
  ;
    /* find current line on map*/
  CL0JW01.CL0JWNBR = CLXREC.CLXYCSX - CL0JW01.CL0JWOST;
  if (KL0JM001.GLACD[CLXLINEX] == KL0JM001.GLACD[CL0JWNBR]
   && KL0JM001.CLIIGOFL[CL0JWNBR] == "Y")
    ;
    if (CL0JW04.CL0JWSFL[CL0JWNBR] == "I" /* from invoice*/
     && KL0JM001.CLICRDFL[CL0JWNBR] == "D")
      return; /* apply flag will be changed to 'n' later*/
    end
    if (CL0JW02.CLICRDFL[CL0JWNBR] == " "
     && KL0JM001.CLICRDFL[CL0JWNBR] != " ")
      return; /* apply flag will be changed to 'n' later*/
    end
    if (CLXREC.CLXLINEX == CL0JW01.CL0JWNBR)
      return; /* found same line as being edited*/
    end
    if (KL0JM001.CLICRDFL[CL0JWNBR] == "X")
      return; /* row will be deleted*/
    end
     /* cannot have matching g/ls with apply flag eq y*/
    converseLib.validationFailed(421);
    CLXREC.CLXERRF = "Y";
    if (CL0JW04.CL0JWSFL[CLXLINEX] == "I") /* from invoice*/
       /* not allowed to change fields on invoice g/l*/
      set KL0JM001.CLIIGOFL[CLXLINEX] cursor, protect, modified, bold;
    else
      set KL0JM001.CLIIGOFL[CLXLINEX] cursor, modified, bold;
    end
    if (CL0JW04.CL0JWSFL[CL0JWNBR] == "I") /* from invoice*/
       /* not allowed to change fields on invoice g/l*/
      set KL0JM001.CLIIGOFL[CL0JWNBR] cursor, protect, modified, bold;
    else
      set KL0JM001.CLIIGOFL[CL0JWNBR] cursor, modified, bold;
    end
    return;
    ;
    CLXREC.CLXYCRX = CLXREC.CLXYCRX + 1;
    ;
  end
end // end KL0JS57

// edit duplicate row
Function KL0JS58()
   /* ************************************************************/
   /* *     validate credit/debit code has not been entered*/
   /* *     on previous line. this statement group has to       **/
   /* *     follow the editing of the apply flag, so the apply  **/
   /* *     flag will be correctly set.                         **/
   /* *                                                         **/
   /* *  Maintenance History:                                   **/
   /* *                                                         **/
   /* *  01-19-90 CHELLM renamed CL0JW05.GLCD as GLACD          **/
   /* *                  renamed CL0JM001.GLCD as GLACD         **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0JS58"; /* set current process name*/
  ;
   /* allowed to enter only one credit and one debit row on the*/
   /* screen (excluding override rows)*/
   /* the exception is on line item charges: there can be*/
   /* multiple debits and credits.*/
  ;
  CLXREC.CLXYCSX = 1;
   /* IF CL0JM001.CLIIGOFL(CLXLINEX) EQ 'Y';*/
  while (KL0JM001.GLACD[CLXLINEX] in CL0JW05.GLACD from CLXYCSX)
    CLXREC.CLXYCSX = sysVar.arrayIndex;
    if (CL0JW05.CLIGLOIN[CLXYCSX] == "Y") /* if override row*/
       /* next sentence - show all overrides that exist*/
    else
      if (CL0JW05.CLICRDFL[CLXYCSX] == KL0JM001.CLICRDFL[CLXLINEX])
        ;
          /* skipping line item processing charges*/
        if (CL0JW05.PFJXREF[CLXYCSX] in YCGTBL.PFJXREF) /* if invc discount*/
          if (CLXYCSX < CL0JW01.CL0JWOST)
             /* found error on previous screen*/
            KL0JS70(); /* show error message*/
          end
           /* checking for changes on map*/
          CL0JW01.CL0JWNBR = CLXREC.CLXYCSX - CL0JW01.CL0JWOST;
          if (CL0JW01.CL0JWNBR == CLXREC.CLXLINEX)
             /* next sentence - dealing with line being edited*/
          else
            if (KL0JM001.CLICRDFL[CL0JWNBR] == KL0JM001.CLICRDFL[CLXLINEX])
              KL0JS70(); /* show error message*/
            end
          end
        end
      end
    end
    ;
    CLXREC.CLXYCSX = CLXREC.CLXYCSX + 1;
    ;
  end
   /* END ;*/
  ;
  ;
    /* check entered g/l's for user entering multiple c/d for one*/
    /* g/l*/
  ;
  if (converseVar.validationMsgNum == 425 /* credit row already exists*/
   || converseVar.validationMsgNum == 426) /* debit row already exists*/
     /* next sentence - already found error*/
  else
      /* start at first entered row*/
    CL0JW01.CL0JWNBR = KL0JM001.CL0JWNOG - CL0JW01.CL0JWOST;
    if (CLXREC.CLXLINEX > CL0JW01.CL0JWNBR) /* only look at entered rows*/
      CLXREC.CLXYCSX = 1;
      ;
      while (KL0JM001.GLACD[CLXLINEX] in KL0JM001.GLACD from CLXYCSX)
        CLXREC.CLXYCSX = sysVar.arrayIndex;
        if (CLXREC.CLXYCSX == CLXREC.CLXLINEX)
           /* next sentence - dealing with line being edited*/
        else
          ;
            /* skipping line item processing charges*/
          if (CL0JW05.PFJXREF[CLXYCSX] in YCGTBL.PFJXREF /* if invc discount*/
           && KL0JM001.CLICRDFL[CLXYCSX] == KL0JM001.CLICRDFL[CLXLINEX])
            KL0JS70(); /* show error message*/
          end
        end
        ;
        CLXREC.CLXYCSX = CLXREC.CLXYCSX + 1;
        ;
      end
    end
  end
end // end KL0JS58

// validate multiple apply flags
Function KL0JS59()
   /* ************************************************************/
   /* *     validate claim apply flag*/
   /* *                                                         **/
   /* *  Maintenance History:                                   **/
   /* *                                                         **/
   /* *  01-19-90 CHELLM renamed CL0JW05.GLCD as GLACD          **/
   /* *                  renamed CL0JM001.GLCD as GLACD         **/
   /* *                                                         **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0JS59"; /* set current process name*/
  ;
  ;
   /* cannot have matching g/l rows where apply flag eq 'y'*/
  ;
   /* need to check for occurance in existing g/l's*/
  ;
  CLXREC.CLXYCSX = 1;
  while (CLXREC.CLXYCSX <= KL0JM001.CL0JWNOG) /* nbr of g/l's on map*/
    ;
    if (KL0JM001.GLACD[CLXLINEX] in CL0JW05.GLACD from CLXYCSX)
      CLXREC.CLXYCSX = sysVar.arrayIndex;
                                   /* next row with desired g/l code*/
      if (CL0JW05.CLIIGOFL[sysVar.arrayIndex] == "N") /* apply flag eq 'n'*/
         /* next sentence*/
      else
         /* cl0jwost eq 0 if haven't paged up or down yet, it will*/
         /* eq the last line on the map (11,22..etc) if we have paged*/
        ;
        CL0JW01.CL0JWNBR = CL0JW01.CL0JWOST + CLXREC.CLXLINEX;
        if (CL0JW01.CL0JWNBR == sysVar.arrayIndex)
          return; /* found same line as being edited*/
        else
           /* check if user changed value on screen*/
          KL0JS57();
          if (CLXREC.CLXERRF == "Y")
            return;
          end
        end
      end
    end
    ;
    CLXREC.CLXYCSX = CLXREC.CLXYCSX + 1;
    ;
  end
  ;
   /* ************************************************************/
   /* ************************************************************/
  ;
  ;
    /* check entered g/l's for multiple apply flags = 'y' for*/
    /* the same g/l*/
  ;
  if (converseVar.validationMsgNum == 421) /* multiple apply flags = 'y'*/
     /* next sentence - already found error*/
  else
      /* start at first entered row*/
    CL0JW01.CL0JWNBR = KL0JM001.CL0JWNOG - CL0JW01.CL0JWOST;
    if (CLXREC.CLXLINEX > CL0JW01.CL0JWNBR) /* only look at entered rows*/
      ;
      CLXREC.CLXYCSX = 1;
      while (KL0JM001.GLACD[CLXLINEX] in KL0JM001.GLACD from CLXYCSX)
        CLXREC.CLXYCSX = sysVar.arrayIndex;
        if (CLXREC.CLXYCSX == CLXREC.CLXLINEX)
           /* next sentence - dealing with line being edited*/
        else
          if (KL0JM001.CLIIGOFL[CLXYCSX] == "Y")
            if (KL0JM001.CLICRDFL[CLXYCSX] == "X")
               /* next sentence - row is to be deleted*/
            else
              if (CL0JW02.CLICRDFL[CLXYCSX] == " "
               && KL0JM001.CLICRDFL[CLXYCSX] != " ")
                 /* next sentence - apply flag will be changed later*/
              else
                converseLib.validationFailed(421); /* multiple apply flags exist*/
                CLXREC.CLXERRF = "Y";
                if (CL0JW04.CL0JWSFL[CLXLINEX] == "I") /* if from invoice*/
                   /* not allowed to change any fields on invoice g/l's*/
                  set KL0JM001.CLIIGOFL[CLXLINEX] cursor, protect, modified, bold;
                else
                  set KL0JM001.CLIIGOFL[CLXLINEX] cursor, modified, bold;
                end
                return;
              end
            end
          end
        end
        ;
        CLXREC.CLXYCSX = CLXREC.CLXYCSX + 1;
        ;
      end
    end
  end
end // end KL0JS59

// write w05 tbl, read cli & iv6
Function KL0JS60()
   /* *************************************************************/
   /* *  write cli record to cl0jw05 table, read both*/
   /* *  cli rec and iv6 rec*/
   /* **/
   /* *  Maintenance History:*/
   /* **/
   /* *  11-17-89 CHELLM renamed CL0JW01.GLCD as GLACD*/
   /* **/
   /* *************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0JS60"; /* set current process name*/
  ;
  CL0JW05.CLIGROUP[CL0JW05X] = CLIREC.CLIGROUP;
  CL0JW01.CL0JWNOG = CL0JW01.CL0JWNOG + 1;
  CL0JW05.CL0JWSFL[CL0JW05X] = "C";
  KL0J007(); /* get next iv6 record*/
  ;
    /* if showing an override reversal, don't*/
    /* want to show the original override, so*/
    /* read past it.*/
    /* after batch has run, the original override*/
    /* has the cligloin = 'n' and won't show if from a*/
    /* different invoice.*/
  ;
             /* BEFORE BATCH*/
   /* glcd  apply flag   override flag   indicator*/
   /* 846   Y              Y             B/E (row not to be shown)*/
   /* 846   N              N             F*/
  ;
             /* AFTER BATCH*/
   /* glcd  apply flag   override flag   indicator*/
   /* 846   N              N             B/E (row not to be shown)*/
   /* 846   N              Y             F*/
  ;
  ;
  if (CLIREC.CLIGLFIV == "F")
     /* save values until original override is read*/
    CL0JW01.GLACD = CLIREC.GLACD;
    CL0JW01.CLIGLPC = CLIREC.CLIGLPC;
    CL0JW01.CLIGLOIN = CLIREC.CLIGLOIN;
    KL0J008(); /* get next cli record*/
  else
    KL0J008(); /* get next cli record*/
  end
  ;
  ;
  if (CL0JW01.GLACD != " ")
    if (CL0JW01.CLIGLOIN == "N") /* not been thru batch yet*/
      if (CLIREC.CLIGLOIN == "Y" /* override flag*/
       && CLIREC.CLIIGOFL == "Y" /* apply flag*/
       && CLIREC.GLACD == CL0JW01.GLACD
       && CLIREC.CLIGLPC == CL0JW01.CLIGLPC)
         /* found original override, read past it*/
        KL0J008(); /* get next cli record*/
        CL0JW01.GLACD = " ";
      end
    else
      if (CL0JW01.CLIGLOIN == "Y") /* have been thru batch*/
        if (CLIREC.CLIGLOIN == "N" /* override flag*/
         && CLIREC.CLIIGOFL == "N" /* apply flag*/
         && CLIREC.GLACD == CL0JW01.GLACD
         && CLIREC.CLIGLPC == CL0JW01.CLIGLPC)
           /* found original override, read past it*/
          KL0J008(); /* get next cli record*/
          CL0JW01.GLACD = " ";
        end
      end
    end
  end
  ;
  CL0JW01.CL0JW05X = CL0JW01.CL0JW05X + 1;
  ;
  ;
end // end KL0JS60

// write iv6 rec to w05, read iv6
Function KL0JS61()
   /* ************************************************************/
   /* *      build a cli rec image from the iv6 record and      **/
   /* *      write it to the cl0jw05 table...read the next      **/
   /* *      iv6rec                                             **/
   /* *                                                         **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0JS61"; /* set up current process name*/
  ;
  ;
  KL0J006(); /* build image of clirec*/
  CL0JW05.CLIGROUP[CL0JW05X] = CL0JW03.CLIGROUP;
  CL0JW01.CL0JWNOG = CL0JW01.CL0JWNOG + 1;
  CL0JW05.CL0JWSFL[CL0JW05X] = "I";
  KL0J007(); /* get next iv6 record*/
  CL0JW01.CL0JW05X = CL0JW01.CL0JW05X + 1;
  ;
  ;
  ;
  ;
end // end KL0JS61

// write cli rec to w05, read cli
Function KL0JS62()
   /* *************************************************************/
   /* *  write cli record to cl0jw05 table, read next*/
   /* *  cli rec*/
   /* **/
   /* *  Maintenance History:*/
   /* **/
   /* *  01-19-90 CHELLM renamed CL0JW01.GLCD to GLACD*/
   /* **/
   /* **/
   /* *************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0JS62"; /* set current process name*/
  ;
  CL0JW05.CLIGROUP[CL0JW05X] = CLIREC.CLIGROUP;
  CL0JW01.CL0JWNOG = CL0JW01.CL0JWNOG + 1;
  CL0JW05.CL0JWSFL[CL0JW05X] = "C";
  ;
    /* if showing an override reversal, don't*/
    /* want to show the original override, so*/
    /* read past it.*/
    /* after batch has run, the original override*/
    /* has the cligloin = 'n' and won't show if from a*/
    /* different invoice.*/
  ;
             /* BEFORE BATCH*/
   /* glcd  apply flag   override flag   indicator*/
   /* 846   Y              Y             B/E (row not to be shown)*/
   /* 846   N              N             F*/
  ;
             /* AFTER BATCH*/
   /* glcd  apply flag   override flag   indicator*/
   /* 846   N              N             B/E (row not to be shown)*/
   /* 846   n              Y             F*/
  ;
  ;
  if (CLIREC.CLIGLFIV == "F")
     /* save values until original override is read*/
    CL0JW01.GLACD = CLIREC.GLACD;
    CL0JW01.CLIGLPC = CLIREC.CLIGLPC;
    CL0JW01.CLIGLOIN = CLIREC.CLIGLOIN;
    KL0J008(); /* get next cli record*/
  else
    KL0J008(); /* get next cli record*/
  end
  ;
  ;
  if (CL0JW01.GLACD != " ")
    if (CL0JW01.CLIGLOIN == "N") /* not been thru batch yet*/
      if (CLIREC.CLIGLOIN == "Y" /* override flag*/
       && CLIREC.CLIIGOFL == "Y" /* apply flag*/
       && CLIREC.GLACD == CL0JW01.GLACD
       && CLIREC.CLIGLPC == CL0JW01.CLIGLPC)
         /* found original override, read past it*/
        KL0J008(); /* get next cli record*/
        CL0JW01.GLACD = " ";
      end
    else
      if (CL0JW01.CLIGLOIN == "Y") /* have been thru batch*/
        if (CLIREC.CLIGLOIN == "N" /* override flag*/
         && CLIREC.CLIIGOFL == "N" /* apply flag*/
         && CLIREC.GLACD == CL0JW01.GLACD
         && CLIREC.CLIGLPC == CL0JW01.CLIGLPC)
           /* found original override, read past it*/
          KL0J008(); /* get next cli record*/
          CL0JW01.GLACD = " ";
        end
      end
    end
  end
  ;
  ;
  ;
   /* IF CLIREC.CLIGLFIV = 'F';*/
    /* ; save values until original override is read*/
    /* MOVE CLIREC.GLaCD TO CL0JW01.GLACD;*/
    /* PERFORM CL0J008               ; get next cli record*/
   /* ELSE ;*/
    /* PERFORM CL0J008               ; get next cli record*/
   /* END ;*/
   /* ;*/
   /* ;*/
   /* IF CL0JW01.GLACD NE ' ';*/
    /* IF CLIREC.CLIGLOIN = 'Y';*/
      /* AND CLIREC.GLaCD = CL0JW01.GLACD;*/
      /* PERFORM CL0J008             ; get next cli record*/
      /* MOVE ' ' TO CL0JW01.GLACD;*/
    /* END ;*/
   /* END ;*/
  ;
  CL0JW01.CL0JW05X = CL0JW01.CL0JW05X + 1;
end // end KL0JS62

// Edit the amount for NBQ GL's
Function KL0JS63()
   /* ************************************************************/
   /* *  Edit the GL amount of Nike Bank GL's.  Flag an error   **/
   /* *  if the entered GL amount is greater than the original  **/
   /* *  invoice amount.                                        **/
   /* *                                                         **/
   /* * 12-31-90 CHELLM  Group created.                         **/
   /* *                                                         **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0JS63"; /* set current process name*/
  ;
  ;
  if (CL0JW03.IV0PARTN == " "
   || CL0JW03.IV0IVCID == 0) /* if no invoice*/
    return;
  end
  ;
  IV6REC.IV0PARTN = CL0JW03.IV0PARTN;
  IV6REC.IV0IVCID = CL0JW03.IV0IVCID;
  IV6REC.OP2LNINB = -1; /* get all gl records*/
  ;
  CL0JW01.CL0JWDON = "N"; /* init done-flag*/
  ;
  set SQLCA empty;
  call "IO1080" ("SS", SQLCA, IV6REC) {isNoRefresh = yes, isExternal = yes};
              /* ; select the set of all invoice GL records*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0) /* if the select-set return code is ok*/
    /* next sentence*/
  else
    TA1REC.TA1TBLKE = "SELCT IV6 SET (CL0JS63)";
    XPCL010();
  end
  ;
  ;
  set SQLCA empty;
  call "IO1080" ("SN", SQLCA, IV6REC) {isNoRefresh = yes, isExternal = yes}; /* first record of the set*/
  if (SQLCA.VAGen_SQLCODE == 0) /* if we found a first record*/
    /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == 100) /* no first record found*/
      CL0JW01.CL0JWDON = "N";
    else
      TA1REC.TA1TBLKE = "FETCH 1ST IV6 REC CL0JS63";
      XPCL010();
    end
  end
  ;
  ;
  while (CL0JW01.CL0JWDON == "N") /* while not done*/
    ;
     /* Match the screen GL to the invoice GL*/
    ;
    if (KL0JM001.GLACD[CLXLINEX] == IV6REC.GLACD)
      if (KL0JM001.CLIGLAM[CLXLINEX] > IV6REC.IV6GLAMT)
        set KL0JM001.CLIGLAM[CLXLINEX] cursor, modified, bold;
        CLXREC.CLXERRF = "Y";
        converseLib.validationFailed(683);
      end
    end
    ;
    ;
    set SQLCA empty;
    call "IO1080" ("SN", SQLCA, IV6REC) {isNoRefresh = yes, isExternal = yes}; /* get the next IV6 rec*/
    if (SQLCA.VAGen_SQLCODE == 0) /* good return,*/
      /* next sentence*/
    else
      if (SQLCA.VAGen_SQLCODE == 100)
        CL0JW01.CL0JWDON = "Y"; /* we're done*/
      else
        TA1REC.TA1TBLKE = "FETCH NEXT IV6 REC/CL0JS63";
        XPCL010();
      end
    end
  end
  ;
  set SQLCA empty;
  call "IO1080" ("CS", SQLCA, IV6REC) {isNoRefresh = yes, isExternal = yes}; /* close cursor*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0) /* if the select-set return code is ok*/
    /* next sentence*/
  else
    TA1REC.TA1TBLKE = "CLOSE IV6 SET (CL0JS63)";
    XPCL010();
  end
  ;
  ;
  ;
end // end KL0JS63

// Warning Edits
Function KL0JS64()
   /* ************************************************************/
   /* *  Show a warning message to the user if any Nike Bank    **/
   /* *  GL amount that has been entered is less than the       **/
   /* *  original invoice amount.                               **/
   /* *                                                         **/
   /* * 12-31-90 CHELLM  Group created.                         **/
   /* *                                                         **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0JS64"; /* set current process name*/
  ;
  if (CLXREC.CLXERRF == "Y") /* if errors exist*/
    CL0JW01.CL0JWNBF = "N"; /* don't show warnings*/
    return;
  end
  ;
  if (CL0JW03.IV0PARTN == " "
   || CL0JW03.IV0IVCID == 0) /* if no invoice*/
    return;
  end
  ;
  IV6REC.IV0PARTN = CL0JW03.IV0PARTN;
  IV6REC.IV0IVCID = CL0JW03.IV0IVCID;
  IV6REC.OP2LNINB = -1; /* get all gl records*/
  ;
  CL0JW01.CL0JWDON = "N"; /* init done-flag*/
  ;
  set SQLCA empty;
  call "IO1080" ("SS", SQLCA, IV6REC) {isNoRefresh = yes, isExternal = yes};
              /* ; select the set of all invoice GL records*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0) /* if the select-set return code is ok*/
    /* next sentence*/
  else
    TA1REC.TA1TBLKE = "SELCT IV6 SET (CL0JS64)";
    XPCL010();
  end
  ;
  ;
  set SQLCA empty;
  call "IO1080" ("SN", SQLCA, IV6REC) {isNoRefresh = yes, isExternal = yes}; /* first record of the set*/
  if (SQLCA.VAGen_SQLCODE == 0) /* if we found a first record*/
    /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == 100) /* no first record found*/
      CL0JW01.CL0JWDON = "N";
    else
      TA1REC.TA1TBLKE = "FETCH 1ST IV6 REC CL0JS64";
      XPCL010();
    end
  end
  ;
  ;
  while (CL0JW01.CL0JWDON == "N") /* while not done*/
    ;
     /* Match the screen GL to the invoice GL*/
      /* Dont compare if the screen amount is less than 0*/
      /* This means the amount has been defaulted from the invoice*/
      /* since invoice amounts are displayed as negative amounts.*/
    ;
    if (KL0JM001.GLACD[CLXLINEX] == IV6REC.GLACD)
      CL0JW01.CL0JWDON = "Y"; /* GL found so we're done*/
      if (KL0JM001.CLIGLAM[CLXLINEX] < IV6REC.IV6GLAMT
       && KL0JM001.CLIGLAM[CLXLINEX] > 0) /* and the amount is a credit*/
        set KL0JM001.CLIGLAM[CLXLINEX] cursor, bold;
        CL0JW01.CL0JWNBF = "Y";
        converseLib.validationFailed(678);
      end
      ;
    end
    ;
    ;
    set SQLCA empty;
    call "IO1080" ("SN", SQLCA, IV6REC) {isNoRefresh = yes, isExternal = yes}; /* get the next IV6 rec*/
    if (SQLCA.VAGen_SQLCODE == 0) /* good return,*/
      /* next sentence*/
    else
      if (SQLCA.VAGen_SQLCODE == 100)
        CL0JW01.CL0JWDON = "Y"; /* we're done*/
      else
        TA1REC.TA1TBLKE = "FETCH NEXT IV6 REC/CL0JS64";
        XPCL010();
      end
    end
  end
  ;
  set SQLCA empty;
  call "IO1080" ("CS", SQLCA, IV6REC) {isNoRefresh = yes, isExternal = yes}; /* close cursor*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0) /* if the select-set return code is ok*/
    /* next sentence*/
  else
    TA1REC.TA1TBLKE = "CLOSE IV6 SET (CL0JS64)";
    XPCL010();
  end
  ;
  ;
  ;
end // end KL0JS64

// show error for duplicate row
Function KL0JS70()
   /* ************************************************************/
   /* *     show error for duplicate rows that have same*/
   /* *     g/l's*/
   /* *                                                         **/
   /* *                                                         **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0JS70"; /* set current process name*/
  ;
  if (KL0JM001.CLICRDFL[CLXLINEX] == "C")
    converseLib.validationFailed(425); /* credit row already entered for this g/l*/
    CLXREC.CLXERRF = "Y";
    set KL0JM001.CLICRDFL[CLXLINEX] cursor, modified, bold;
    return;
  else
    if (KL0JM001.CLICRDFL[CLXLINEX] == "D")
      converseLib.validationFailed(426); /* debit row already entered for this*/
                                   /* g/l*/
      CLXREC.CLXERRF = "Y";
      set KL0JM001.CLICRDFL[CLXLINEX] cursor, modified, bold;
      return;
    end
  end
end // end KL0JS70

//*** RECORD=CL0JW01 ****
// Maintenance History
// 
// 10-11-91  DB2 Chgs  sgorga  Added xhdkey, xhdcd, & xgpcd
//           to this working storage.  This allowed gpc code
//           to be part of key in looking up handle code in
//           kl0j103.
// ***********************
Record CL0JW01 type basicRecord
  10 CL0JWEOB CL0JWEOB ; 
  10 CLADBOCL CLADBOCL ; 
  10 CL0JWNOD CL0JWNOD ; 
  10 CLIGLAM CLIGLAM ; 
  10 CL0JWNOG CL0JWNOG ; 
  10 CL0JWUCM CL0JWUCM ; 
  10 CLGCMSEQ CLGCMSEQ ; 
  10 CL0JWNBR CL0JWNBR ; 
  10 CL0JWOST CL0JWOST ; 
  10 CL0JWEO6 CL0JWEO6 ; 
  10 CL0JWDON CL0JWDON ; 
  10 CL0JWNBF CL0JWNBF ; 
  10 CL0JWNBW CL0JWNBW ; 
  10 CL0JWTGL CL0JWTGL ; 
  10 CL0JWMCH CL0JWMCH ; 
  10 CL0JWDWP CL0JWDWP ; 
  10 CL0JWEOI CL0JWEOI ; 
  10 CL0JWCFL CL0JWCFL ; 
  10 CL0JWCLF CL0JWCLF ; 
  10 CL0JWMIF CL0JWMIF ; 
  10 CL0JWNSR CL0JWNSR ; 
  10 CL0JWNIR CL0JWNIR ; 
  10 CL0JWNIF CL0JWNIF ; 
  10 CLIADVSQ CLIADVSQ ; 
  10 CL0JWHLD CL0JWHLD ; 
  10 CL0JWICT CL0JWICT ; 
  10 CL0JW03X CL0JW03X ; 
  10 CL0JW04X CL0JW04X ; 
  10 CL0JW05X CL0JW05X ; 
  10 CL0JW03M CL0JW03M ; 
  10 CL0JW04M CL0JW04M ; 
  10 CL0JW05M CL0JW05M ; 
  10 CL0JWSQH CL0JWSQH ; 
  10 CL0JWAR1 CL0JWAR1 ; 
  10 CL0JWLAR CL0JWLAR ; 
  10 CL0JWCTR CL0JWCTR ; 
  10 CL0JWFTT CL0JWFTT ; 
  10 CL0JWYCT CL0JWYCT ; 
  10 CL0JWDCF CL0JWDCF ; 
  10 CL0JWIFG CL0JWIFG ; 
  10 CL0JWRFI CL0JWRFI ; 
  10 CL0JWAUP CL0JWAUP ; 
  10 CL0JWVCH CL0JWVCH ; 
  10 CL0JWZDT CL0JWZDT ; 
  10 CL0JWZTM CL0JWZTM ; 
  10 CL0JWINB CL0JWINB ; 
  10 CL0JWINX CL0JWINX ; 
  10 CL0JWTLM CL0JWTLM ; 
  10 GLACD GLACD ; 
  10 CLIGLOIN CLIGLOIN ; 
  10 CLIGLPC CLIGLPC ; 
  10 ZZZCHGDT ZZZCHGDT ; 
  10 ZZZCHGTM ZZZCHGTM ; 
  10 CL0JWMSG CL0JWMSG ; 
    15 CL0JWMOD CL0JWMOD ; 
    15 CL0JWNCL CL0JWNCL ; 
    15 CL0JWMS1 CL0JWMS1 ; 
    15 CL0JWCIV CL0JWCIV ; 
    15 CL0JWMS2 CL0JWMS2 ; 
    15 CL0JWIIV CL0JWIIV ; 
  10 XHDKEY XHDKEY ; 
    15 XHDCD XHDCD ; 
    15 XGPCD XGPCD ; 
end // end CL0JW01

//*** RECORD=CL0JW02 ****
// store original values for screen.  compare cl0jw02 values
// against the values on the screen after the converse to
// see if a field was changed.
// ;*
// ;* 2-27-97 chellm added pfjxref for defining NBQ Gl's
// ***********************
Record CL0JW02 type basicRecord
  5 CL0JW2GP CL0JW2GP ; 
    10 CLICRDFL CLICRDFL [11] ; 
    10 GLACD GLACD [11] ; 
    10 CLIGLPC CLIGLPC [11] ; 
    10 CLIIGOFL CLIIGOFL [11] ; 
    10 CLIGLAM CLIGLAM [11] ; 
    10 CLGCOMNT CLGCOMNT [11] ; 
    10 PFJXREF PFJXREF [11] ; 
end // end CL0JW02

//*** RECORD=CL0JW03 ****
// ******************  Claim GL Code Table  *******************
// 
// DB2 Table:           DCLAIM.VCLGLX01
// 
// Copylib Member:      DCL00216
// 
// I/O Mod:             IO1300
// 
// Key to DB2 Table:    claclmnb
//                      clhseqnb
//                      clicrdfl
//                      glcd
// 
// Date Created:        03/01/87
// 
// Maintenance Log:
// 
//   Date    Init.      Comment
// --------  -----      ---------------------------------------
// 03-01-87   PAG       Initial record creation
// 10-12-92   sgorga    renamed cllseqnb to clhseqnb
// 
// ***********************
Record CL0JW03 type basicRecord
  5 CLIGROUP CLIGROUP ; 
    10 CLACLMNB CLACLMNB ; 
    10 CLHSEQNB CLHSEQNB ; 
    10 CLICRDFL CLICRDFL ; 
    10 GLACD GLACD ; 
    10 PFJXREF PFJXREF ; 
    10 XGPCD XGPCD ; 
    10 SY1STNBR SY1STNBR ; 
    10 SY2CLRID SY2CLRID ; 
    10 XDMCD XDMCD ; 
    10 IV0PARTN IV0PARTN ; 
    10 IV0IVCID IV0IVCID ; 
    10 IV6FBTYP IV6FBTYP ; 
    10 OP2LNINB OP2LNINB ; 
    10 IV6GLSEQ IV6GLSEQ ; 
    10 XHDCD XHDCD ; 
    10 CLIIGOFL CLIIGOFL ; 
    10 CLIGLAM CLIGLAM ; 
    10 CLIGLPC CLIGLPC ; 
    10 CLIGLOIN CLIGLOIN ; 
    10 CLIGLPPT CLIGLPPT ; 
    10 CLIGLNFL CLIGLNFL ; 
    10 CLIADVSQ CLIADVSQ ; 
    10 YMDCD YMDCD ; 
    10 CLIADMAT CLIADMAT ; 
    10 YAPCD YAPCD ; 
    10 CLICARCT CLICARCT ; 
    10 CLICARMO CLICARMO ; 
    10 XSECD XSECD ; 
    10 XSTCD XSTCD ; 
    10 YSRSLSRG YSRSLSRG ; 
    10 CLICALPC CLICALPC ; 
    10 CLGCMSEQ CLGCMSEQ ; 
    10 CLIGLFIV CLIGLFIV ; 
    10 ZZZCHGDT ZZZCHGDT ; 
    10 ZZZCHGTM ZZZCHGTM ; 
    10 ZZZCHGCT ZZZCHGCT ; 
end // end CL0JW03

//*** RECORD=CL0JW04 ****
// hold values that relate to lines on the screen but are
// not displayed to the user.
// ***********************
Record CL0JW04 type basicRecord
  5 CL0JW4GP CL0JW4GP ; 
    10 CL0JWCUP CL0JWCUP [11] ; 
    10 CL0JWGUP CL0JWGUP [11] ; 
    10 CL0JWAPT CL0JWAPT [11] ; 
    10 CLGCMSEQ CLGCMSEQ [11] ; 
    10 CLIADVSQ CLIADVSQ [11] ; 
    10 CL0JWSFL CL0JWSFL [11] ; 
    10 CLIIGOFL CLIIGOFL [11] ; 
    10 CLIGLFIV CLIGLFIV [11] ; 
    10 CLIGLOIN CLIGLOIN [11] ; 
    10 CL0JWCOM CL0JWCOM [11] ; 
      15 * char(2) ; 
      15 SY1STNBR SY1STNBR ; 
      15 * char(1) ; 
      15 SY2CLRID SY2CLRID ; 
      15 * char(1) ; 
      15 XDMCD XDMCD ; 
      15 * char(5) ; 
end // end CL0JW04

//*** RECORD=CL0JW05 ****
// ******************  Claim GL Code Table  *******************
// 
// this record is used to hold all g/l's that will appear
// on the screen.
// 
// 
// DB2 Table:           DCLAIM.VCLGLX01
// 
// Copylib Member:      DCL00216
// 
// I/O Mod:             IO1300
// 
// Key to DB2 Table:    claclmnb
//                      clhseqnb
//                      clicrdfl
//                      glcd
// 
// Date Created:        03/01/87
// 
// Maintenance Log:
// 
//   Date    Init.      Comment
// --------  -----      ---------------------------------------
// 03-01-87   PAG       Initial record creation
// 10-16-92   sgorga    renamed cllseqnb to clhseqnb.
// 
// ***********************
Record CL0JW05 type basicRecord
  3 CL0JW5GP CL0JW5GP ; 
    5 CL0JWSFL CL0JWSFL [200] ; 
    5 CLIGROUP CLIGROUP [200] ; 
      10 CLACLMNB CLACLMNB ; 
      10 CLHSEQNB CLHSEQNB ; 
      10 CLICRDFL CLICRDFL ; 
      10 GLACD GLACD ; 
      10 PFJXREF PFJXREF ; 
      10 XGPCD XGPCD ; 
      10 SY1STNBR SY1STNBR ; 
      10 SY2CLRID SY2CLRID ; 
      10 XDMCD XDMCD ; 
      10 IV0PARTN IV0PARTN ; 
      10 IV0IVCID IV0IVCID ; 
      10 IV6FBTYP IV6FBTYP ; 
      10 OP2LNINB OP2LNINB ; 
      10 IV6GLSEQ IV6GLSEQ ; 
      10 XHDCD XHDCD ; 
      10 CLIIGOFL CLIIGOFL ; 
      10 CLIGLAM CLIGLAM ; 
      10 CLIGLPC CLIGLPC ; 
      10 CLIGLOIN CLIGLOIN ; 
      10 CLIGLPPT CLIGLPPT ; 
      10 CLIGLNFL CLIGLNFL ; 
      10 CLIADVSQ CLIADVSQ ; 
      10 YMDCD YMDCD ; 
      10 CLIADMAT CLIADMAT ; 
      10 YAPCD YAPCD ; 
      10 CLICARCT CLICARCT ; 
      10 CLICARMO CLICARMO ; 
      10 XSECD XSECD ; 
      10 XSTCD XSTCD ; 
      10 YSRSLSRG YSRSLSRG ; 
      10 CLICALPC CLICALPC ; 
      10 CLGCMSEQ CLGCMSEQ ; 
      10 CLIGLFIV CLIGLFIV ; 
      10 ZZZCHGDT ZZZCHGDT ; 
      10 ZZZCHGTM ZZZCHGTM ; 
      10 ZZZCHGCT ZZZCHGCT ; 
end // end CL0JW05

//*** RECORD=CL0JW06 ****
//  Hold up to 200 invoice numbers for display on this map.
// 
//  Maintenance History:
//  10-22-90 BCOURT  add prologue.
// 
// ***********************
Record CL0JW06 type basicRecord
  5 CL0JW6GP CL0JW6GP ; 
    10 IV0PARTN IV0PARTN [200] ; 
    10 IV0IVCID IV0IVCID [200] ; 
end // end CL0JW06

//*** RECORD=CL0JW07 ****
// pass calculated sums from database.  if no rows exist
// that fit the where clause then null values are passed in
// the sum fields. for this reason the indicator fields need to
// be checked.  if the indicator is negative or zero move zero
// to the sum field.
// ***********************
Record CL0JW07 type basicRecord
  5 CL0JW5GR CL0JW5GR ; 
    10 CL0JWSQL CL0JWSQL ; 
    10 CL0JWCN1 CL0JWCN1 ; 
    10 CL0JWCN2 CL0JWCN2 ; 
    10 CL0JWSM1 CL0JWSM1 ; 
    10 CL0JWIN1 CL0JWIN1 ; 
end // end CL0JW07

//*** RECORD=CL0JW08 ****
// pass calculated sums from database.  if no rows exist
// that fit the where clause then null values are passed in
// the sum fields. for this reason the indicator fields need to
// be checked.  if the indicator is negative or zero move zero
// to the sum field.
// ***********************
Record CL0JW08 type basicRecord
  5 CL0JW8GR CL0JW8GR ; 
    10 CL0JWSQL CL0JWSQL ; 
    10 CL0JWCN1 CL0JWCN1 ; 
    10 CL0JWIN1 CL0JWIN1 ; 
end // end CL0JW08

// maximum filled cl0jw03 bucket
DataItem CL0JW03M num(3)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// index for cl0jw03 array
DataItem CL0JW03X num(3)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// maximum filled cl0jw04 bucket
DataItem CL0JW04M num(3)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// index for cl0jw04 array
DataItem CL0JW04X num(3)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// maximum filled cl0jw05 bucket
DataItem CL0JW05M num(3)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// index for cl0jw05 array
DataItem CL0JW05X num(3)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// group level for cl0jw02 record
DataItem CL0JW2GP char(847)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// group level of cl0jw04 record
DataItem CL0JW4GP char(352)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// group level for cl0jw05 record
DataItem CL0JW5GP char(16800)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// record group level
DataItem CL0JW5GR char(20)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// group level for cl0jw06 record
DataItem CL0JW6GP char(1000)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// record group level
DataItem CL0JW8GR char(8)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// array ptr for each screen line
DataItem CL0JWAPT smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// 1st 11 of array flag
DataItem CL0JWAR1 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// update-to-clarec-flag y/n
DataItem CL0JWAUP char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// field modified flag
DataItem CL0JWCFL char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// CLAREC.Iv0IVCID
DataItem CL0JWCIV num(8)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// complete loop  flag
DataItem CL0JWCLF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// counter for db item
DataItem CL0JWCN1 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// counter for db item
DataItem CL0JWCN2 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// screen comment
DataItem CL0JWCOM char(20)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// counter
DataItem CL0JWCTR smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// update-this-comment-flag
DataItem CL0JWCUP char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// debit on claim flag
DataItem CL0JWDCF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// done flag
DataItem CL0JWDON char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// done-with-primary recs flag
DataItem CL0JWDWP char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// end-of-iv6-records-flag
DataItem CL0JWEO6 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// end-of-clb-records-flag
DataItem CL0JWEOB char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// end-of-cli-recs flag
DataItem CL0JWEOI char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// first time thru loop flag
DataItem CL0JWFTT char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// update-this-g/l-flag
DataItem CL0JWGUP char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// invoice id hold area
DataItem CL0JWHLD num(8)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// count of invoices for claim
DataItem CL0JWICT smallint {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// first of that invoice flag
DataItem CL0JWIFG char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// CLBREC.IV0ivcid
DataItem CL0JWIIV num(8)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// indicator for db item
DataItem CL0JWIN1 smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// invoice number
DataItem CL0JWINB int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// seq nbr of inv
DataItem CL0JWINX num(4)  {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// where-are-we-in-array
DataItem CL0JWLAR smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Total merchandise amount
DataItem CL0JWMCH decimal(11,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// more invoice flag
DataItem CL0JWMIF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// 'ORDMOD'
DataItem CL0JWMOD char(7)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// 'HD IVC='
DataItem CL0JWMS1 char(7)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// 'PMY='
DataItem CL0JWMS2 char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// log message
DataItem CL0JWMSG char(40)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Nike Bank warning flag
DataItem CL0JWNBF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// working storage number
DataItem CL0JWNBR smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Warning shown flag
DataItem CL0JWNBW char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// 'NCLM'
DataItem CL0JWNCL char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// no-invoices-for-clm flag
DataItem CL0JWNIF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// new-invoice-requested flag
DataItem CL0JWNIR char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// number of debits on claim
DataItem CL0JWNOD smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// nbr of g/ls for this invoice
DataItem CL0JWNOG smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// new sequence-nbr-requested fl
DataItem CL0JWNSR char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// offset from 1st ivc bucket
DataItem CL0JWOST smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// records from invoice flag y/n
DataItem CL0JWRFI char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// record-source flag
DataItem CL0JWSFL char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// sum for database item
DataItem CL0JWSM1 decimal(15,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// seq# hold area
DataItem CL0JWSQH smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// sql selection
DataItem CL0JWSQL char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Total NBQ GL amount
DataItem CL0JWTGL decimal(11,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// total lines for the map
DataItem CL0JWTLM num(3)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// comments were updated
DataItem CL0JWUCM char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// claim est. value running total
DataItem CL0JWVCH decimal(11,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// yct flag
DataItem CL0JWYCT char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// zzzchg date
DataItem CL0JWZDT int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// zzzchgtim
DataItem CL0JWZTM smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

