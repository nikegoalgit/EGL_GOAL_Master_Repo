package kl02;

import corpcom1.*;
import corpcom3.XPCL002;
import corpcom3.XPCL008;
import corpcom3.XPCL010;
import corpcom3.XPCL011;
import corpcom4.XSENTRY;
import corpcom4.XSPF1;
import corpcom4.XSPF4;
import corpcom4.XSSEGTR;
import corpcom5.CLZREC;
import corpcom5.COMMAREA;
import corpcom5.ERRSQLCA;
import corpcom6.SQLCA;
import corpcom7.XXXCURDT;
import corpcom7.XXXRVNBR;
import corpx1.XGPTBL;
import corpx1.XWHTBL;
import corpy2.YATTBL;
import corpy2.YCICD;
import corpy2.YCRTBL;
import corpy2.YCSTBL;
import corpy2.YCTTBL;
import corpy2.YUATBL;
import ku.common.KUCREC;
import ku.common.KUMREC;
import ta.common.TA1REC;
import ta.common.TA2REC;
import vv.common.VDMACT01;
//*** PROGRAM=KL02 ****
// ************************************************************
// KL02 Return and Inspection Summary
// 
// Overview: Inquiry only screen to list all Returns and all
//           Inspections for the Claim Number.
// 
//           Select 1, several, or all Returns or Inspections
//           for review.  Can not select both types at once.
// 
//           May enter Claim Number for new list.
// 
//           This screen valid only for Claims NOT entered
//           from a worksheet, and for Claim Types
//           RTS, RFL, DEF, CDR.
// 
// Maintenance History:
// Date      By     Rev Description of Change
// --------  ---    --  --------------------------------------
// 08-25-88  bcourt  0  create
// 12-12-88  mhalst     modify program to allow 100 inspectns
//                      also, add scrolling for inspections
// 12-28-88  mhalst     Use DEF and RTS headers instead of
//                      items when summing totals. Also allow
//                      PF20 for claim type ERA.
// 01-17-89  mhalst     CL469 Fix so user cannot 'X' when
//                      claim is in inquiry statuses.
// 02-28-89  jwood      added noncsp option to calls
// 02-28-89  jwood      added xssegtr logic
// 03-22-89  mhalst     Increase returns array to 50
// 05-19-89  bcourt     DB2 structure change: CLAREC, KUCREC,
//                      KUMREC, XGPTBL, XWHTBL.
// 01-19-90  gdecke     DB2 structure change for january.
// 01-31-90  sgorga     Modified pgm to go directly to the CL0Z
//                      (RTS Inspections) inspection screen
//                      when claim type is a Consumer Defective
//                      Return claim (CDR) and the claim reason
//                      code is RTS.  stmt grp #cl02s20.
// 
// 02-08-90  sgorga     In statement group #CL02S20 -
//                      Modified pgm to go directly to the
//                      Claim Hdr comments screen when:
//                       1) The inspection summary screen CL02
//                          (this application) was entered by
//                          selecting menu option 9 and
//                       2) The pf20 key is then pressed and
//                       3) It's the initial inspection on the
//                          claim
//                       Note:  the field clwrec.clwmapfm
//                              is being used to pass to appl.
//                              'CL0G' the fact that the pf20
//                              key was pressed in this applic.
// 
//                       In main process # CL02130 -
//                       Modified pgm to default to the Claim
//                       Hdr screen (CL0E) when 'Enter' is
//                       pressed (and no new claim # has been
//                       keyed in).  Previously defaulted to
//                       CL0A, the Claim Menu screen.
// 
//                       Also, included code: if a claim
//                       inspection is selected that is a 'cdr'
//                       claim type with a reason code of 'rts'
//                       the flow is to the CL0Z rts inspection
//                       application (rather than to the CL0Y
//                       def inspection appl, which is where
//                       CDR claim types have always gone,
//                       regardless of reason code).
// 
// 04-03-90 sgorga  DB2 structure changes.  Regen only.
//  #cl909  12-04-90  gdecke  add logic to handle sales sample
//                            claims.
//  #cl0    05-28-91  gdecke  allow whse 51,32,04 mix: cl02s20
//          08-08-91  wjohns  Renamed application and commarea
//                              referrences to renamed claims
//                              appls.
// 10-31-91 twatso  added code for osd to be handled the same
//                  as def claim types. Will be installed in
//                  december 1991
// 01-13-92 sgorga  Set ta1rec empty - kl02001.
// 03-30-93 Jcarey  Increased nbr of returns limit to 100
// 10-21-93 GDECKE  Fix bad reference to status cd2:alias=ycscd
// 10-26-93 GDECKE  Clear out clwrec select list before kl02130
//                  fills is with inspection sequence numbers
// 01-20-94 JCAREY  When a return is deleted, added code to
//                  delete any matching vdmact01 records.
//                  para kl02930.
// 02-13-97 kshaw   replaced clxlinex with cl02w01.cl2rtndx
//                  because the number of returns outgrew
//                  the physical size of clxlinex.
//                  stmt groups effected:
//                  kl02001
//                  kl02101
//                  cl02w01 ws record
// 07-17-01 DSINHA  Added SAP RTN SO NBR as display field on
//                  map KL02M001.
// ************************************************************
// *********************
Program KL02 type textUIProgram //VAGen Info - main text program
  {
  includeReferencedFunctions = yes, allowUnqualifiedItemReferences = yes, 
  throwNrfEofExceptions = yes, handleHardIOErrors = no, V60ExceptionCompatibility = yes, 
  I4GLItemsNullable = no, textLiteralDefaultIsString = no, localSQLScope = yes, 
  msgTablePrefix = "CL00", inputRecord = COMMAREA, segmented = yes
  }

  // Data Declarations
  CL02W01 CL02W01; // record
  CL02W02 CL02W02; // record
  CL2REC CL2REC; // record
  CLAREC CLAREC; // record
  CLCREC CLCREC; // record
  CLGREC CLGREC; // record
  CLHREC CLHREC; // record
  CLJREC CLJREC; // record
  CLLREC CLLREC; // record
  CLMREC CLMREC; // record
  CLOREC CLOREC; // record
  CLWREC CLWREC; // record
  CLXREC CLXREC; // record
  CLZREC CLZREC; // record
  COMMAREA COMMAREA ; // record
  ERRSQLCA ERRSQLCA; // record
  KUCREC KUCREC; // record
  KUMREC KUMREC; // record
  SQLCA SQLCA; // record
  TA1REC TA1REC; // record
  TA2REC TA2REC; // record
  VDMACT01 VDMACT01; // record

  // VAGen Info - items needed for migration
  VAGen_EZESYS char(8);
  VAGen_EZEREPLY num(1);
  VAGen_EZE_WAIT_TIME bin(9,2);
  VAGen_EZE_ITEMLEN int;

  // Use Declarations
  use XGPTBL {deleteAfterUse = yes}; // table
  use XWHTBL {deleteAfterUse = yes}; // table
  use YATTBL {deleteAfterUse = yes}; // table
  use YCRTBL {deleteAfterUse = yes}; // table
  use YCSTBL {deleteAfterUse = yes}; // table
  use YCTTBL {deleteAfterUse = yes}; // table
  use YUATBL {deleteAfterUse = yes}; // table
  use KL02M.KL02M001 // form
   {
    pfKeyEquate = no
  };

  function main()
    // VAGen Info - initialization needed for migration
    VAGen_EZESYS = VGLib.getVAGSysType();
    KL02000: KL02000();
    ;
    ;
    exit program;
    ;
    ;
    ;
    KL02001: KL02001();
    KL02050: KL02050();
    KL02100: KL02100();
    KL02101: KL02101();
    KL02110: KL02110();
    KL02120: KL02120();
    KL02130: KL02130();
  end // end main
end // end KL02

// application main logic
Function KL02000()
   /* ************************************************************/
   /* *   this is the "main logic" for the application.         **/
   /* *                                                         **/
   /* *   xsentry checks to ensure that this application was    **/
   /* *         entered from another csp application.           **/
   /* *   xclentry checks to ensure that the claim header has   **/
   /* *         been flagged as "in use" if this application    **/
   /* *         does updates.                                   **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  ;
  KL02001(); /* initilize the application*/
  ;
  CL02W01.XXXRVNBR = "00"; /* appl maintainence revision number*/
  ;
  CLXREC.CLXEOAF = "N"; /* set end-of-application flag to 'no'*/
  ;
  while (CLXREC.CLXEOAF == "N") /* while not end-of-aplication*/
    KL02050(); /* process the application screen(s)*/
  end
  ;
  COMMAREA.CATOAP = "KL0A";
  XPCL002(); /* exit application*/
  ;
  ;
end // end KL02000

// initialize application
Function KL02001()
   /* ************************************************************/
   /* *      initialize the application working storage         **/
   /* *                                                         **/
   /* *  describe what happens in this process                  **/
   /* ************************************************************/
   /* MAINTENANCE HISTORY*/
   /* 01-13-92  sgorga  Set ta1rec empty.*/
   /* ************************************************************/
  ;
  converseVar.commitOnConverse = 1; /* force db2 to commit on each screen*/
                                   /* converse*/
  VGVar.handleHardIOErrors = 1; /* return control to program if hard db2*/
                                   /* error*/
  ;
   /* TEMP001;*/
  ;
  XSENTRY(); /* check entered thru main menu*/
  XSSEGTR(); /* set segmented transaction id*/
  XPCL011(); /* claims entry module*/
  XPCL008(); /* reset clwrec.activity code*/
  ;
  set CLXREC empty; /* clear out the "common" working*/
                                   /* storage*/
  set CL02W01 empty;
  set CL02W02 empty; /* 4/89*/
  ;
    /* put today's date in working-storage*/
  ;
  set TA1REC empty;
  set TA2REC empty;
  TA2REC.TA2RTNCD = 0;
  TA2REC.TA2DTOPT = "GETDATE";
  ;
  call "TA0040" (TA2REC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (TA2REC.TA2RTNCD == 0)
    CL02W01.XXXCURDT = TA2REC.TA2GRGGN; /* today's ccyymmdd*/
    CLXREC.XXXCDTE = TA2REC.TA2GRGGN; /* today's yymmdd*/
    CLXREC.XXXCTIME = TA2REC.TA2TIME; /* current time*/
  else
    CL02W01.XXXCURDT = 0;
  end
  ;
  ;
  CL02W01.CL02WFST = "Y"; /* first time through*/
  CL02W02.CL02WBTF = "Y"; /* build insp. table*/
  ;
  CLXREC.CLXEOAF = "N"; /* set application-done-switch to 'no'*/
  ;
  CLXREC.CLXCSCRN = "KL02M001"; /* set first screen name*/
  ;
  CLXREC.CLXSNAME[1] = "KL02M001";
  ;
  CLXREC.CLXMAXLN[1] = 8; /* max lines on map 1*/
  ;
  CLXREC.CLXARAYX = 1; /* index to array*/
  CL02W01.CL2RTNDX = 1; /* index to map line*/
  ;
  ;
end // end KL02001

// main screen branch control
Function KL02050()
   /* ************************************************************/
   /* *   control process the application screen(s)             **/
   /* *                                                         **/
   /* *  note that this process is being performed in a         **/
   /* *  "while loop" until the end-of-application flag is set  **/
   /* *  to 'y'.                                                **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL02050"; /* set current process name*/
  ;
  ;
  if (CLXREC.CLXCSCRN in CLXREC.CLXSNAME) /* if current-screen-name is*/
    CLXREC.CLXSCRNX = sysVar.arrayIndex; /* in the screen-array, then set*/
  end /* the screen-index*/
  ;
  ;
  CLXREC.CLXEOSF = "N"; /* set end-of-screen flag to 'no'*/
  CLXREC.CLXBLDSC = "Y"; /* set build screen flag to 'yes'*/
  ;
  ;
  if (CLXREC.CLXSCRNX == 1) /* if screen cl02m001*/
    while (CLXREC.CLXEOSF == "N") /* while not end-of-screen*/
      KL02100(); /* process screen cl02m001*/
    end
  else
    TA1REC.TA1TBLKE = "CLAIMS UNKNOWN SCREEN NAME";
    XPCL010();
  end
  ;
  ;
   /* at this point;*/
       /* if the end-of-application flag (clxeoaf ) = 'n'*/
         /* the perform will return to the top of cl0%050...*/
       /* else*/
         /* the perform will auto return to cl0%000.*/
  ;
  ;
end // end KL02050

// Return/Inspection Summary scrn
Function KL02100()
   /* ************************************************************/
   /* *    process screen cl02m001                              **/
   /* *                                                         **/
   /* *  note - this process is being performed in a            **/
   /* *     "while loop" from cl02050 until the end-of-screen   **/
   /* *     flag (clxeosfl) is set to 'y'.                      **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL02100"; /* set current process name*/
  ;
  if (CLXREC.CLXBLDSC == "Y")
    KL02101(); /* build screen because new record*/
  end /* to display*/
  ;
  CLXREC.CLXBLDSC = "N"; /* skip build screen next time thru*/
    /* skip build when have errors to show, or pf12 was keyed*/
  ;
  converse KL02M001 ;
  ;
  CLXREC.CLXMSG = " "; /* set non-ezemno error message to*/
                                   /* spaces*/
  CLXREC.CLXERRF = "N"; /* re-set error flag*/
  ;
  ;
  KL02110(); /* handle any special PF key entries*/
    /* may exit appl from this process*/
  ;
  if (converseVar.eventKey is pf7 /* if user withes scrolling*/
   || converseVar.eventKey is pf8)
    return; /* go back and display*/
  end
  ;
  if (CLXREC.CLXERRF == "N") /* if no PF key errors*/
    KL02120(); /* edit screen entries*/
  end
  ;
  ;
      /* determine next action*/
  ;
  if (CLXREC.CLXERRF == "Y" /* if screen has errors*/
   || converseVar.eventKey is pf12) /* or user wants to see same screen*/
    CLXREC.CLXBLDSC = "N"; /* do not rebuild screen, just reshow*/
  else
    KL02130(); /* act upon pf key*/
  end
  ;
  ;
   /* at this point;*/
     /* if the end-of-screen flag (clxeosf) is 'n'*/
       /* the perform returns to top of process cl0%100.*/
     /* else*/
       /* the perform returns to cl0%050.*/
  ;
  ;
end // end KL02100

// build screen-top,btm left/rght
Function KL02101()
   /* ************************************************************/
   /* Maintenance History                             **/
   /* Date     Userid    Description                          **/
   /* 07/17/01  DSINHA    Get the SAP Return SO number from    **/
   /* DCLAIM.VCLARX01 table                **/
   /* ************************************************************/
   /* *        this process initializes screen cl02m001         **/
   /* *  it will read the necessary tables                      **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL02101"; /* set current process name*/
  ;
  set KL02M001 initial; /* init field values and attributes*/
  CL02W01.CL02WARY = " "; /* clear working storage array*/
  CL02W01.CL02MTRC = 0; /* zero map totals*/
  CL02W01.CL02MRC2 = 0;
  CL02W01.CL02WINF = " "; /* init INSP exists flag*/
  CL02W01.CL02WRFF = " "; /* init RFSL exists flag*/
  CL02W01.CL02WNCF = " "; /* init NCLM exists flag*/
  ;
  CL02W01.CL02WMOR = "N"; /* init clm has under 8 lines*/
  ;
  KL02M001.CLACLMNB = CLAREC.CLACLMNB;
  CL02W01.CLACLMNB = CLAREC.CLACLMNB; /* and w-s*/
  KL02M001.XXXRVNBR = CL02W01.XXXRVNBR;
  KL02M001.XXXCURDT = CL02W01.CL02WTDY; /* today's date*/
  ;
  if (CL02W01.CL02WFST == "Y")
    KL02SEC(); /* edit claim from cl0a or fastpath*/
  end
  ;
  if (CLXREC.CLXERRF == "Y") /* if found error, show screen*/
    return;
  end
  ;
  ;
    /* ******************************/
    /* build top of screen*/
    /* ******************************/
  ;
  KL02SMO(); /* get more data bases*/
  ;
   /* * TCS Change begin - 07/17/01*/
  ;
  CLCREC.CLACLMNB = CLAREC.CLACLMNB; /* claim nbr*/
  CLCREC.CLCPMAR = "Y"; /* Primary Flag*/
  ;
  KL02S30(); /* get SAP return SO Number*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    KL02M001.ARCREFNB = CLCREC.ARCREFNB; /* SAP Rtn SO Nbr*/
  end
  ;
  KL02S35(); /* Close cursor*/
  ;
   /* * TCS Change end   - 07/17/01*/
  ;
  KL02M001.CLACLMNB = CLAREC.CLACLMNB; /* claim nbr*/
  KL02M001.KUCCOID = CLAREC.KUCCOID; /* customer company*/
  KL02M001.KUMSTRID = CLAREC.KUMSTRID; /* customer store*/
  KL02M001.XNXCD = CLAREC.XNXCD; /* customer dept*/
  KL02M001.YCSCD = CLAREC.YCSCD; /* claim status*/
  KL02M001.XGPCD = CLAREC.XGPCD; /* general product class*/
  KL02M001.YCTCD = CLAREC.YCTCD; /* claim type*/
  KL02M001.YCRCD = CLAREC.YCRCD; /* claim reason*/
  ;
  CL02W01.CL02WSAM = "N"; /* init. sales sample claim flag*/
  if (CLAREC.CLAORIGI == "B") /* if origin is sales sample batch*/
                                   /* gener.*/
    if (CLWREC.CLWMNOPT == 4 /* get and show the sales sample claim*/
     /* nbr.*/
     || CLWREC.CLWMNOPT == 14
     || CLWREC.CLWMNOPT == 17)
      KL02SSC(); /* get sample claim number from comment*/
                                   /* line*/
      set KL02M001.CL02MSAM initialAttributes;
      set KL02M001.CL02MNBR initialAttributes;
      set KL02M001.CL02MCLM initialAttributes;
      if (CL02W01.CL02WSAM == "N") /* if sample claim nbr not found*/
        CLXREC.CLXERRF = "Y";
        converseLib.validationFailed(659);
        set KL02M001.CL02MCLM cursor, modified, bold;
      else
        KL02M001.CL02MCLM = CL02W01.CL02WCLM;
      end
    else
      if (CL02W01.CL02WSWF == "Y") /* if message previously shown trat the*/
        set KL02M001.CL02MSAM protect, invisible;
                                   /* blank out sample claim number*/
        set KL02M001.CL02MNBR protect, invisible; /* if claim origin is not batch*/
        set KL02M001.CL02MCLM protect, invisible;
      else
        set KL02M001.CL02MSAM initialAttributes;
        set KL02M001.CL02MNBR initialAttributes;
         /* if origin is batch and menu option not 4,14,17 send message*/
        CLXREC.CLXERRF = "Y";
        converseLib.validationFailed(670);
        set KL02M001.CL02MCLM cursor, modified, bold;
        CL02W01.CL02WSWF = "Y"; /* flag indicates message was shown*/
      end
    end
  else
    set KL02M001.CL02MSAM protect, invisible; /* blank out sample claim number*/
    set KL02M001.CL02MNBR protect, invisible; /* if claim origin is not batch*/
    set KL02M001.CL02MCLM protect, invisible;
  end
  ;
  KL02M001.KUCCONM = KUMREC.KUMSTRNM; /* store name 12/88*/
  ;
  KL02M001.CLJTATHQ = CLAREC.CLATQTY; /* auth qty*/
  KL02M001.CLJRAXDT = CLJREC.CLJRAXDT; /* auth expire date*/
  ;
  if (CLAREC.YCSCD in YCSTBL.YCSCD) /* claim status short desc*/
    KL02M001.YCSSDESC = YCSTBL.YCSSDESC[sysVar.arrayIndex];
  else
    KL02M001.YCSSDESC = " ";
  end
  ;
  if (CLAREC.XGPCD in XGPTBL.XGPCD) /* g.p.c. abbrev*/
    KL02M001.XGPABRV = XGPTBL.XGPABRV[sysVar.arrayIndex];
  else
    KL02M001.XGPABRV = " ";
  end
  ;
  if (CLAREC.YCTCD in YCTTBL.YCTCD) /* claim type abbrev*/
    KL02M001.YCTABRV = YCTTBL.YCTABRV[sysVar.arrayIndex];
  else
    KL02M001.YCTABRV = " ";
  end
  ;
  if (CLAREC.YCRCD in YCRTBL.YCRCD) /* claim reason desc*/
    KL02M001.YCRDESC = YCRTBL.YCRDESC[sysVar.arrayIndex];
  else
    KL02M001.YCRDESC = " ";
  end
  ;
    /* ************************************/
    /* build bottom left returns*/
    /* ************************************/
  ;
  set CLLREC empty;
  set SQLCA empty;
  ;
  CLLREC.CLACLMNB = CLAREC.CLACLMNB;
  CLLREC.CLLRTNNB = -1; /* get all return nbrs*/
  ;
  call "IO1310" ("SS", SQLCA, CLLREC) {isNoRefresh = yes, isExternal = yes}; /* set all returns for clm*/
  ;
  if (SQLCA.VAGen_SQLCODE != 0
   && SQLCA.VAGen_SQLCODE != 100)
    TA1REC.TA1DBASE = "DCLAIM";
    TA1REC.TA1TBLVU = "VCLRTN";
    CLXREC.CLXORDIV = CLAREC.CLACLMNB;
    TA1REC.TA1TBLKE = CLXREC.CLXORDIV;
    TA1REC.TA1LOCAT[4] = "BAD SELECT SET";
    XPCL010(); /* abend*/
  end
  ;
  ;
  CL02W01.CL2RTNDX = 1; /* init array to 1*/
  call "IO1310" ("SN", SQLCA, CLLREC) {isNoRefresh = yes, isExternal = yes}; /* first clm*/
  ;
  while (SQLCA.VAGen_SQLCODE == 0)
    CL02W01.CLLRTNNB[CL2RTNDX] = CLLREC.CLLRTNNB;
     /* accum totals*/
    CL02W01.CL02MTRC = CL02W01.CL02MTRC + CLLREC.CLLNBRCV;
    if (CLLREC.CLLWRDT == CL02W01.XXXCURDT) /* if recieved today*/
      CL02W01.CL02MRC2 = CL02W01.CL02MRC2 + CLLREC.CLLNBRCV;
    end
     /* move to map*/
    if (CL02W01.CL2RTNDX <= CLXREC.CLXMAXLN[1]) /* max 8 lines on map*/
      KL02M001.CLLWRDT[CL2RTNDX] = CLLREC.CLLWRDT;
      KL02M001.CLLRTDSP[CL2RTNDX] = CLLREC.CLLRTDSP;
      KL02M001.CLLNBRCV[CL2RTNDX] = CLLREC.CLLNBRCV;
      KL02M001.XWHCD[CL2RTNDX] = CLLREC.XWHCD;
    end
     /* set flags to indicate what type of returns exist  (*CL729v*/
    if (CLLREC.CLLRTDSP == "RFSD") /* RFSd return exists   CWH 9/18/89*)*/
      CL02W01.CL02WRFF = "Y";
    end
    if (CLLREC.CLLRTDSP == "NCLM") /* NCLM return exists*/
      CL02W01.CL02WNCF = "Y";
    end
    if (CLLREC.CLLRTDSP == "INSP") /* INSP return exists*/
      CL02W01.CL02WINF = "Y";
    end
     /* get next return*/
    CL02W01.CL2RTNDX = CL02W01.CL2RTNDX + 1;
    call "IO1310" ("SN", SQLCA, CLLREC) {isNoRefresh = yes, isExternal = yes}; /* next clm*/
  end
  ;
  if (SQLCA.VAGen_SQLCODE == 100)
    call "IO1310" ("CS", SQLCA, CLLREC) {isNoRefresh = yes, isExternal = yes}; /* close set*/
  end
  ;
  if (SQLCA.VAGen_SQLCODE != 0
   && SQLCA.VAGen_SQLCODE != 100)
    TA1REC.TA1DBASE = "DCLAIM";
    TA1REC.TA1TBLVU = "VCLRTN";
    CLXREC.CLXORDIV = CLAREC.CLACLMNB;
    TA1REC.TA1TBLKE = CLXREC.CLXORDIV;
    TA1REC.TA1LOCAT[4] = "BAD FETCH NEXT OR CLOSE SET";
    XPCL010(); /* abend*/
  end
  ;
  ;
  CL02W01.CL02WMXR = CL02W01.CL2RTNDX; /* 1 over last filled index*/
  ;
  ;
    /* ************************************/
    /* add to number of cartons using the sample claim*/
    /* if this is a sample claim*/
    /* ************************************/
  ;
  if (CL02W01.CL02WSAM == "Y") /* if this is a sample claim*/
    set CLLREC empty;
    set SQLCA empty;
    ;
    CLLREC.CLACLMNB = CL02W01.CL02WCLM;
    CLLREC.CLLRTNNB = -1; /* get all return nbrs*/
    ;
    call "IO1310" ("SS", SQLCA, CLLREC) {isNoRefresh = yes, isExternal = yes};
                                   /* set all returns for clm*/
    ;
    if (SQLCA.VAGen_SQLCODE != 0
     && SQLCA.VAGen_SQLCODE != 100)
      TA1REC.TA1DBASE = "DCLAIM";
      TA1REC.TA1TBLVU = "VCLRTN";
      CLXREC.CLXORDIV = CLAREC.CLACLMNB;
      TA1REC.TA1TBLKE = CLXREC.CLXORDIV;
      TA1REC.TA1LOCAT[4] = "BAD SELECT SET";
      XPCL010(); /* abend*/
    end
    ;
    ;
    CL02W01.CL2RTNDX = 1; /* init array to 1*/
    call "IO1310" ("SN", SQLCA, CLLREC) {isNoRefresh = yes, isExternal = yes}; /* first clm*/
    ;
    while (SQLCA.VAGen_SQLCODE == 0)
      CL02W01.CLLRTNNB[CL2RTNDX] = CLLREC.CLLRTNNB;
       /* accum totals*/
      CL02W01.CL02MTRC = CL02W01.CL02MTRC + CLLREC.CLLNBRCV;
      if (CLLREC.CLLWRDT == CL02W01.XXXCURDT) /* if recieved today*/
        CL02W01.CL02MRC2 = CL02W01.CL02MRC2 + CLLREC.CLLNBRCV;
      end
       /* get next return*/
      CL02W01.CL2RTNDX = CL02W01.CL2RTNDX + 1;
      call "IO1310" ("SN", SQLCA, CLLREC) {isNoRefresh = yes, isExternal = yes}; /* next clm*/
    end
    ;
    if (SQLCA.VAGen_SQLCODE == 100)
      call "IO1310" ("CS", SQLCA, CLLREC) {isNoRefresh = yes, isExternal = yes}; /* close set*/
    end
    ;
    if (SQLCA.VAGen_SQLCODE != 0
     && SQLCA.VAGen_SQLCODE != 100)
      TA1REC.TA1DBASE = "DCLAIM";
      TA1REC.TA1TBLVU = "VCLRTN";
      CLXREC.CLXORDIV = CLAREC.CLACLMNB;
      TA1REC.TA1TBLKE = CLXREC.CLXORDIV;
      TA1REC.TA1LOCAT[4] = "BAD FETCH NEXT OR CLOSE SET";
      XPCL010(); /* abend*/
    end
  end /* end of routine to add extra sales*/
                                   /* sample claim counts*/
  ;
  sysVar.arrayIndex = CL02W01.CL02WMXR - 1;
  if (sysVar.arrayIndex > CLXREC.CLXMAXLN[1])
    CL02W01.CL02WMOR = "Y"; /* mark claim has more than 8 retns*/
  end
  ;
  ;
    /* ************************************/
    /* get bottom right inspections*/
    /* ************************************/
  ;
  if (CL02W02.CL02WBTF == "Y") /* need to build table*/
    CL02W01.CL02MTIQ = 0;
    CL02W01.CL02MIQ2 = 0;
    CL02W01.CL02MTIA = 0;
    KL02102(); /* so do it*/
    CL02W02.CL02WIDX = 1; /* and reset index*/
  end
  ;
   /* now move table section to map*/
  CL02W01.CL2RTNDX = 1; /* set screen index*/
  CLXREC.CLXARAYX = CL02W02.CL02WIDX; /* and table index*/
  while (CL02W01.CL2RTNDX <= CLXREC.CLXMAXLN[1]
   && CL02W02.CL02WIDX != 0) /* skip this if no inspecs 4/89*/
    if (CLXREC.CLXARAYX > CL02W01.CL02WMXI) /* end of table*/
      KL02M001.CL02MSLI[CL2RTNDX] = " ";
      KL02M001.CL2ISNBR[CL2RTNDX] = 0;
      KL02M001.YCICD[CL2RTNDX] = " ";
      KL02M001.CL02MQTY[CL2RTNDX] = 0;
      KL02M001.CLHMEMNB[CL2RTNDX] = 0;
      KL02M001.CLHSEQNB[CL2RTNDX] = 0;
      KL02M001.CLHMEMAM[CL2RTNDX] = 0;
    else
      KL02M001.CL2ISNBR[CL2RTNDX] = CL02W02.CL2ISNBR[CLXARAYX];
      KL02M001.YCICD[CL2RTNDX] = CL02W02.YCICD[CLXARAYX];
      KL02M001.CL02MQTY[CL2RTNDX] = CL02W02.CL02WQTY[CLXARAYX];
      KL02M001.CLHMEMNB[CL2RTNDX] = CL02W02.CLHMEMNB[CLXARAYX];
      KL02M001.CLHSEQNB[CL2RTNDX] = CL02W02.CLHSEQNB[CLXARAYX];
      KL02M001.CLHMEMAM[CL2RTNDX] = CL02W02.CLHMEMAM[CLXARAYX];
      CLXREC.CLXARAYX = CLXREC.CLXARAYX + 1;
    end
    CL02W01.CL2RTNDX = CL02W01.CL2RTNDX + 1;
  end
  ;
  ;
    /* ********************/
    /* move totals to map*/
    /* ********************/
  ;
  KL02M001.CL02MTRC = CL02W01.CL02MTRC;
  KL02M001.CL02MRC2 = CL02W01.CL02MRC2;
  KL02M001.CL02MTIQ = CL02W01.CL02MTIQ;
  KL02M001.CL02MIQ2 = CL02W01.CL02MIQ2;
  KL02M001.CL02MTIA = CL02W01.CL02MTIA;
  ;
  ;
    /* ************/
    /* set flags*/
    /* ************/
  ;
  CL02W01.CL02WCHG = "N"; /* mark map as not changed*/
  CL02W01.CL02WFST = "N"; /* mark claim as not first*/
  ;
  if (CL02W01.CL02WMOR == "Y")
    converseLib.validationFailed(489); /* more than 8 lines, call sys devel*/
    CLXREC.CLXERRF = "Y";
  end
  ;
  ;
    /* *******************************/
    /* set unused selects askip,dark*/
    /* *******************************/
  ;
  sysVar.arrayIndex = CL02W01.CL02WMXR; /* number returns*/
  while (sysVar.arrayIndex <= CLXREC.CLXMAXLN[1])
    set KL02M001.CL02MSLR[sysVar.arrayIndex] skip, invisible;
    sysVar.arrayIndex = sysVar.arrayIndex + 1;
  end
  ;
  ;
  sysVar.arrayIndex = 1;
  while (sysVar.arrayIndex <= CLXREC.CLXMAXLN[1])
    if (KL02M001.CL2ISNBR[sysVar.arrayIndex] == 0) /* nothing here*/
      set KL02M001.CL02MSLI[sysVar.arrayIndex] skip, invisible;
    end
    sysVar.arrayIndex = sysVar.arrayIndex + 1;
  end
  ;
  ;
    /* **************************************************/
    /* set cursor to claim or inspec, default to return*/
    /* **************************************************/
  ;
  if (CL02W01.CL02WMXR <= 1) /* no returns*/
    if (CL02W01.CL02WMXI == 0)
      converseLib.validationFailed(495); /* No Returns and no Inspecstions for*/
                                   /* Claim*/
      set KL02M001.CLACLMNB cursor;
    else
      set KL02M001.CL02MSLI[1] cursor;
    end
  end
  ;
  ;
end // end KL02101

// Build inspections table
Function KL02102()
    /* ************************************/
    /* Build table of inspections*/
    /* ************************************/
  ;
  set CL02W02 empty;
  set CL2REC empty;
  set SQLCA empty;
  ;
  CL2REC.CLACLMNB = CLAREC.CLACLMNB;
  CL2REC.CL2ISNBR = -1; /* get all insp nbrs*/
  CL2REC.CLHSEQNB = -1;
  ;
  call "IO2870" ("S1", SQLCA, CL2REC) {isNoRefresh = yes, isExternal = yes}; /* set all inspecs for clm*/
  ;
  if (SQLCA.VAGen_SQLCODE != 0
   && SQLCA.VAGen_SQLCODE != 100)
    TA1REC.TA1DBASE = "DCLAIM";
    TA1REC.TA1TBLVU = "VRINSP";
    CLXREC.CLXORDIV = CLAREC.CLACLMNB;
    TA1REC.TA1TBLKE = CLXREC.CLXORDIV;
    TA1REC.TA1LOCAT[4] = "BAD SELECT SET";
    XPCL010(); /* abend*/
  end
  ;
  call "IO2870" ("N1", SQLCA, CL2REC) {isNoRefresh = yes, isExternal = yes}; /* first clm*/
  ;
  while (SQLCA.VAGen_SQLCODE == 0)
    CL02W02.CL02WIDX = CL02W02.CL02WIDX + 1;
    CL02W01.CL02MQTY = 0;
    CL02W02.CL2ISNBR[CL02WIDX] = CL2REC.CL2ISNBR;
    CL02W02.CLHSEQNB[CL02WIDX] = CL2REC.CLHSEQNB;
    KL02SIS(); /* fetch memo, RTS & DEF items; accum totals*/
     /* move to table*/
    CL02W02.YCICD[CL02WIDX] = CL2REC.YCICD;
    CL02W02.CL02WQTY[CL02WIDX] = CL02W01.CL02MQTY;
    CL02W02.CLHSEQNB[CL02WIDX] = CL2REC.CLHSEQNB;
    CL02W02.CLHMEMNB[CL02WIDX] = CLHREC.CLHMEMNB;
    CL02W02.CLHMEMAM[CL02WIDX] = CLHREC.CLHMEMAM;
     /* get next return*/
    call "IO2870" ("N1", SQLCA, CL2REC) {isNoRefresh = yes, isExternal = yes}; /* next clm*/
  end
  ;
  if (SQLCA.VAGen_SQLCODE == 100)
    call "IO2870" ("C1", SQLCA, CL2REC) {isNoRefresh = yes, isExternal = yes}; /* close set*/
  end
  ;
  if (SQLCA.VAGen_SQLCODE != 0
   && SQLCA.VAGen_SQLCODE != 100)
    TA1REC.TA1DBASE = "DCLAIM";
    TA1REC.TA1TBLVU = "VRINSP";
    CLXREC.CLXORDIV = CLAREC.CLACLMNB;
    TA1REC.TA1TBLKE = CLXREC.CLXORDIV;
    TA1REC.TA1LOCAT[4] = "BAD FETCH NEXT OR CLOSE";
    XPCL010(); /* abend*/
  end
  ;
  CL02W01.CL02WMXI = CL02W02.CL02WIDX; /* set max*/
  CL02W02.CL02WBTF = "N"; /* don't build table*/
  ;
end // end KL02102

// validate PF keys, act on some
Function KL02110()
   /* ************************************************************/
   /* *  validate pf keys                                       **/
   /* *                                                         **/
   /* *  the only keys acted upon at this time are pf 1, 2, 3,  **/
   /* *  4, 5 and fastpath                                      **/
   /* *                                                         **/
   /* *  the other keys are just verified that they are used    **/
   /* *  by this application.  if the pf key is not recognized, **/
   /* *  it reshows the map with an error message.              **/
   /* *                                                         **/
   /* *  these other pf keys are acted upon after the editing   **/
   /* *  and updating have occured.                             **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL02110"; /* set current process name*/
  ;
  set KL02M001.CATOAP initialAttributes; /* reset cursor,bright*/
  set KL02M001.CAITEM initialAttributes;
  ;
  ;
      /* check for fastpath option/item*/
  ;
  if (converseVar.eventKey is enter)
    if (KL02M001.CATOAP != " ") /* if fastpath option entered,*/
      COMMAREA.CATOAP = KL02M001.CATOAP;
      COMMAREA.CAITEM = KL02M001.CAITEM;
      XPCL002(); /* exit application*/
    else
      if (KL02M001.CAITEM != " ")
        set KL02M001.CAITEM cursor, bold;
        converseLib.validationFailed(1); /* item not allowed without option*/
        CLXREC.CLXERRF = "Y"; /* mark as error*/
        return;
      end
    end
  end
  ;
  ;
  if (converseVar.eventKey is enter) /* normal 'enter'*/
    return;
  end
  ;
  ;
  if (converseVar.eventKey is pf1) /* skip edit/updt, go to 'help'*/
    XSPF1();
    TA1REC.TA1TBLKE = "CANT TRANSFER TO GD0G REQUESTED APPL";
    XPCL010(); /* serious error if cant*/
                                   /* transfer...abend*/
  end
  ;
  ;
  if (converseVar.eventKey is pf2)
    if (CLAREC.CLAMEIND == "Y") /* if have memo on claim*/
      COMMAREA.CATOAP = "KL0M"; /* go to memo screen*/
      XPCL002();
    else
      converseLib.validationFailed(11); /* else can't use pf 2*/
      CLXREC.CLXERRF = "Y"; /* mark as error*/
      return;
    end
  end
  ;
  if (converseVar.eventKey is pf3)
    COMMAREA.CATOAP = "KL0A"; /* skip edit/updt, go to claims menu*/
    XPCL002(); /* common claims exit*/
  end
  ;
  ;
  if (converseVar.eventKey is pf4) /* go to master menu*/
    XSPF4();
  end
  ;
  ;
  if (converseVar.eventKey is pf5)
    COMMAREA.CATOAP = "KL0E"; /* skip edit/updt, go to claim header*/
    XPCL002(); /* common claims exit*/
  end
  ;
   /* now check pf7 or pf8*/
  ;
  if (converseVar.eventKey is pf7)
    if (CL02W02.CL02WIDX == 1) /* if allready at top*/
      converseLib.validationFailed(7); /* at top of data*/
      CLXREC.CLXERRF = "Y";
    else
      CLXREC.CLXBLDSC = "Y";
      CL02W02.CL02WIDX = CL02W02.CL02WIDX - CLXREC.CLXMAXLN[1];
      if (CL02W02.CL02WIDX <= 0)
        CL02W02.CL02WIDX = 1;
      end
    end
    return;
  end
  ;
  if (converseVar.eventKey is pf8)
    CLXREC.CLXARAYX = CL02W02.CL02WIDX + CLXREC.CLXMAXLN[1];
    if (CLXREC.CLXARAYX > CL02W01.CL02WMXI)
      converseLib.validationFailed(3); /* at end of data*/
      CLXREC.CLXERRF = "Y";
    else
      CLXREC.CLXBLDSC = "Y";
      CL02W02.CL02WIDX = CL02W02.CL02WIDX + CLXREC.CLXMAXLN[1];
      if (CL02W02.CL02WIDX > CL02W01.CL02WMXI)
        CL02W02.CL02WIDX = CL02W01.CL02WMXI;
      end
    end
    return;
  end
  ;
  ;
  if (converseVar.eventKey is pf12) /* do edit, re-show map*/
    return;
  end
  ;
  ;
  if (converseVar.eventKey is pf18) /* go to cl0g*/
    KL02S18(); /* claim comment screen*/
    return; /* may leave appl, or return with err*/
  end
  ;
  ;
  if (converseVar.eventKey is pf20) /* go to kl0y/z with new inspec*/
    KL02S20(); /* clm must have a return*/
    return; /* may leave appl, or return with err*/
  end
  ;
  ;
  if (converseVar.eventKey is pa1 /* improper pa key used*/
   || converseVar.eventKey is pa2 
   || converseVar.eventKey is pa3)
    converseLib.clearScreen();
    
    converseLib.validationFailed(62); /* PA key causes loss of data*/
    CLXREC.CLXERRF = "Y"; /* mark as error*/
    return;
  end
  ;
  ;
      /* pf key not valid*/
  ;
  converseLib.validationFailed(2); /* pf key not valid*/
  CLXREC.CLXERRF = "Y"; /* mark with error*/
  ;
  ;
end // end KL02110

// edit screen M001 entries
Function KL02120()
   /* ************************************************************/
   /* *     this process handles all edits of screen fields,    **/
   /* *          entries into screen cl0%m001                   **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL02120"; /* set current process name*/
  ;
  CLXREC.CLXERRF = "N"; /* init error flag*/
  CL02W01.CL02WNRT = 0; /* init nbr rtns selected*/
  CL02W01.CL02WDRT = 0; /* init nbr rtns selected*/
  CL02W01.CL02WNIS = 0; /* init nbr inspec selected*/
  CL02W01.CL02WDIS = 0; /* init nbr inspec selected*/
  ;
  sysVar.arrayIndex = CL02W01.CL02WMXR - 1; /* for actual active returns*/
  if (CLXREC.CLXMAXLN[1] < sysVar.arrayIndex) /* or full map*/
    sysVar.arrayIndex = CLXREC.CLXMAXLN[1];
  end
  while (sysVar.arrayIndex > 0)
    set KL02M001.CL02MSLR[sysVar.arrayIndex] initialAttributes; /* reset cursor, bright*/
    sysVar.arrayIndex = sysVar.arrayIndex - 1;
  end
  ;
  sysVar.arrayIndex = CL02W01.CL02WMXI; /* for inspections*/
  if (CLXREC.CLXMAXLN[1] < sysVar.arrayIndex) /* or full map*/
    sysVar.arrayIndex = CLXREC.CLXMAXLN[1];
  end
  while (sysVar.arrayIndex > 0)
    set KL02M001.CL02MSLI[sysVar.arrayIndex] initialAttributes; /* reset cursor, bright*/
    sysVar.arrayIndex = sysVar.arrayIndex - 1;
  end
  ;
  set KL02M001.CLACLMNB initialAttributes;
  ;
  ;
    /* ****************************************/
    /* edit select code for return/inspection*/
    /* ****************************************/
  ;
  sysVar.arrayIndex = CLXREC.CLXMAXLN[1]; /* max 8 map lines*/
  while (sysVar.arrayIndex > 0)
    KL02SEL(); /* edit changed select code*/
    sysVar.arrayIndex = sysVar.arrayIndex - 1;
  end
  ;
  ;
    /* ***************************/
    /* edit changed claim number*/
    /* ***************************/
  ;
  if (KL02M001.CLACLMNB != CL02W01.CLACLMNB)
    KL02SCL(); /* edit changed claim number*/
  end
  ;
  ;
    /* ****************************/
    /* field combination edits*/
    /* ****************************/
  ;
    /* can't select both return & inspection*/
  ;
  if (CLXREC.CLXERRF == "Y") /* if errors*/
    return; /* skip rest*/
  end
  ;
  if (CL02W01.CL02WNIS != 0
   && CL02W01.CL02WNRT != 0)
    converseLib.validationFailed(491); /* select rtn or inspec, not both*/
    CLXREC.CLXERRF = "Y"; /* mark as error*/
    sysVar.arrayIndex = CLXREC.CLXMAXLN[1]; /* bright each select*/
    while (sysVar.arrayIndex > 0)
      if (KL02M001.CL02MSLI[sysVar.arrayIndex] != " ") /* inspection select*/
        set KL02M001.CL02MSLI[sysVar.arrayIndex] cursor, bold;
      end
      if (KL02M001.CL02MSLR[sysVar.arrayIndex] != " ") /* returns select*/
        set KL02M001.CL02MSLR[sysVar.arrayIndex] cursor, bold;
      end
      sysVar.arrayIndex = sysVar.arrayIndex - 1;
    end
    return; /* skip rest*/
  end
  ;
  ;
    /* **********************************/
    /* set cursor, default to return(1)*/
    /* **********************************/
  ;
  if (CL02W01.CL02WNIS > 0) /* in selected any insp, set cursor*/
    set KL02M001.CL02MSLI[1] cursor;
  end
  ;
  ;
    /* ********************/
    /* hold claim number*/
    /* ********************/
  ;
  CL02W01.CLACLMNB = KL02M001.CLACLMNB; /* claim number*/
  ;
  ;
    /* ********************************************************/
    /* if select all inspections, propogate 's' in select codes*/
    /* ********************************************************/
  ;
  if (KL02M001.CL02MSLI[1] == "A") /* inspection*/
    sysVar.arrayIndex = 1;
    while (sysVar.arrayIndex <= CL02W01.CL02WMXI)
      CL02W02.CL02WSLI[sysVar.arrayIndex] = "S"; /* fill w-s array*/
      if (sysVar.arrayIndex <= CLXREC.CLXMAXLN[1]) /* fill map*/
        if (KL02M001.CL2ISNBR[sysVar.arrayIndex] != 0)
          KL02M001.CL02MSLI[sysVar.arrayIndex] = "S";
        else
          KL02M001.CL02MSLI[sysVar.arrayIndex] = " ";
        end
      end
      sysVar.arrayIndex = sysVar.arrayIndex + 1;
    end
    return; /* done with edit*/
  end
  ;
  ;
    /* ********************************************************/
    /* if select all returns, propogate 's' in select codes*/
    /* ********************************************************/
  ;
  if (KL02M001.CL02MSLR[1] == "A") /* return*/
    sysVar.arrayIndex = 1;
    while (sysVar.arrayIndex < CL02W01.CL02WMXR)
      CL02W01.CL02MSLR[sysVar.arrayIndex] = "S"; /* fill w-s array*/
      if (sysVar.arrayIndex <= CLXREC.CLXMAXLN[1]) /* fill map*/
        if (CL02W01.CLLRTNNB[sysVar.arrayIndex] != 0)
          KL02M001.CL02MSLR[sysVar.arrayIndex] = "S";
        else
          KL02M001.CL02MSLR[sysVar.arrayIndex] = " ";
        end
      end
      sysVar.arrayIndex = sysVar.arrayIndex + 1;
    end
    return; /* done with edit*/
  end
  ;
  ;
    /* ************************************/
    /* hold new values in working-storage*/
    /* ************************************/
  ;
    /* select code 'a' was done above with EZERTN*/
    /* note: cl02widx is set to first line displayed on*/
          /* screen, so we use it to set clxarayx to unload*/
          /* selection codes from screen to table*/
  ;
  sysVar.arrayIndex = 1;
  CLXREC.CLXARAYX = CL02W02.CL02WIDX;
  while (sysVar.arrayIndex <= CLXREC.CLXMAXLN[1]
   && CL02W02.CL02WIDX != 0) /* skip this if no inspecs 4/89*/
    if (CLXREC.CLXARAYX <= CL02W01.CL02WMXI)
      CL02W02.CL02WSLI[CLXARAYX] = KL02M001.CL02MSLI[sysVar.arrayIndex];
    end
    CL02W01.CL02MSLR[sysVar.arrayIndex] = KL02M001.CL02MSLR[sysVar.arrayIndex];
    sysVar.arrayIndex = sysVar.arrayIndex + 1;
    CLXREC.CLXARAYX = CLXREC.CLXARAYX + 1;
  end
  ;
  ;
  ;
end // end KL02120

// act upon valid ENTER/PF keys
Function KL02130()
   /* ************************************************************/
   /* *  act upon enter key                                     **/
   /* *                                                         **/
   /* *  PF 1, 2, 3, 4, & 5 were acted upon in cl02110.         **/
   /* *                                                         **/
   /* *  The other pf keys are acted upon here, after editing   **/
   /* *  and updating have occured.                             **/
   /* *                                                         **/
   /* ************************************************************/
   /* *    M A I N T E N A N C E     H I S T O R Y     L O G    **/
   /* *---------------------------------------------------------**/
   /* *    DATE    PGMR    DESCRIPTION                          **/
   /* *---------------------------------------------------------**/
   /* *  02-08-90  sgorga                                       **/
   /* *    Modified code to default to the Claim Hdr screen CL0E**/
   /* *    when 'Enter' is pressed and no new claim nbr has     **/
   /* *    been keyed in.                                       **/
   /* *    Also added code (at end of process) to go to cl0z    **/
   /* *    application if claim type is 'cdr' and reason code   **/
   /* *    is 'rts'.                                            **/
   /* *  08-08-91  wjohns                                       **/
   /* *    Changed application names for transfers.             **/
   /* *  10-26-93  GDECKE  CLEAR CLWREC SELECT LIST BEFORE      **/
   /* *                    LOADING WITH INSPECTION NUMBERS      **/
   /* *  01-20-94  JCAREY  ADDED COMMENT ABOUT VDMACT01.        **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL02130"; /* set current process name*/
  ;
  ;
    /* All PF keys have been acted upon,*/
    /* this is ENTER flow*/
  ;
  if (CL02W01.CL02WCHG == "Y") /* if new claim # entered*/
    CLXREC.CLXBLDSC = "Y"; /* go re-build screen*/
    converseLib.validationFailed(492); /* new claim*/
    return;
  end
  ;
  ;
  if (CL02W01.CL02WNRT == 0 /* if no selections made*/
   && CL02W01.CL02WDRT == 0 
   && CL02W01.CL02WNIS == 0 
   && CL02W01.CL02WDIS == 0)
    COMMAREA.CATOAP = "KL0E"; /* go to claim hdr*/
    XPCL002();
  end
  ;
  ;
    /* set up map return*/
  ;
  CLWREC.CLWMAPFM = "KL02M001"; /* return to kl02*/
  ;
  ;
    /* if returns selected, go to cl0t*/
  ;
  if (CL02W01.CL02WNRT != 0) /* if returns selected*/
     /* put return nbrs and select code in clwrec*/
    sysVar.arrayIndex = 1;
    while (sysVar.arrayIndex < CL02W01.CL02WMXR) /* move to max - 1*/
      CLWREC.CLWSELCD[sysVar.arrayIndex] = CL02W01.CL02MSLR[sysVar.arrayIndex];
      CLWREC.CLWCLMNB[sysVar.arrayIndex] = CL02W01.CLLRTNNB[sysVar.arrayIndex];
      sysVar.arrayIndex = sysVar.arrayIndex + 1;
    end
     /* move max nbr*/
    CLWREC.CLWMXIDX = CL02W01.CL02WMXR - 1;
    CLWREC.CLWCLIDX = 1; /* start map with this index to table*/
    COMMAREA.CATOAP = "KL0T"; /* go to special services log screen*/
    XPCL002();
  end
  ;
  ;
    /* if returns deleted,*/
  ;
  if (CL02W01.CL02WDRT != 0) /* if returns deleted*/
    CL2REC.CLACLMNB = CL02W01.CLACLMNB;
    CL2REC.CLHSEQNB = -1;
    CL2REC.CL2ISNBR = -1;
    ;
    KL02900(); /* select scan cl2rec*/
    ;
    ;
    KL02901(); /* select next cl2rec*/
    sysVar.arrayIndex = 1;
    while (sysVar.arrayIndex < CL02W01.CL02WMXR) /* move to max - 1*/
      if (CL02W01.CL02MSLR[sysVar.arrayIndex] == "X")
        if (SQLCA.VAGen_SQLCODE == 100)
          CLLREC.CLACLMNB = CL02W01.CLACLMNB;
          CLLREC.CLLRTNNB = -1;
          KL02920(); /* select scan cllrec*/
          ;
          KL02921(); /* select next cllrec*/
          if (SQLCA.VAGen_SQLCODE == 0)
            while (SQLCA.VAGen_SQLCODE == 0)
              if (CLLREC.XWHCD == KL02M001.XWHCD[sysVar.arrayIndex]
               && CLLREC.CLLWRDT == KL02M001.CLLWRDT[sysVar.arrayIndex])
                CL02W01.CL02WSRT = "Y"; /* non-solitary return flag*/
                if (CL02W01.CL02WSRT == "Y")
                  CLLREC.CLACLMNB = CL02W01.CLACLMNB;
                  CLLREC.CLLRTNNB = CL02W01.CLLRTNNB[sysVar.arrayIndex];
                  CLZREC.XWHCD = CLLREC.XWHCD;
                  CLZREC.TF1CARCD = CLLREC.TF1CARCD;
                  CLZREC.CLLWRDT = CLLREC.CLLWRDT;
                  CL02W01.CLLNBRCV = CLLREC.CLLNBRCV;
                  ;
                  ;
                  KL02930(); /* delete cllrec & vdmact01*/
                  if (CL02W01.CLLRTNNB[sysVar.arrayIndex] == CLAREC.CLACRTNB)
                    KL02S30();
                                   /* update claim header current return #*/
                  end
                  ;
                  ;
                  KL02940(); /* select unique clzrec*/
                  if (SQLCA.VAGen_SQLCODE == 0)
                    if (CLLREC.CLLRTDSP != "RFSD")
                      CLZREC.CLLNBRCV = CLZREC.CLLNBRCV - CL02W01.CLLNBRCV;
                      CLZREC.ZZZCHGDT = CL02W01.XXXCURDT;
                      CLZREC.ZZZCHGTM = CLXREC.XXXCHHMM;
                      KL02945(); /* update clzrec*/
                    end
                  end
                end
              end
              KL02921(); /* select next cllrec*/
            end
            KL02922(); /* close scan cllrec*/
          end
        else
          CLLREC.CLACLMNB = CL02W01.CLACLMNB;
          CLLREC.CLLRTNNB = -1;
          KL02920(); /* select scan cllrec*/
          ;
          KL02921(); /* select next cllrec*/
          if (SQLCA.VAGen_SQLCODE == 0)
            KL02921(); /* select next cllrec*/
            if (SQLCA.VAGen_SQLCODE == 100)
              KL02922(); /* close scan cllrec*/
              set KL02M001.CL02MSLR[sysVar.arrayIndex] cursor, bold;
              CLXREC.CLXERRF = "Y"; /* error*/
              converseLib.validationFailed(535); /* inspection records exist*/
              return; /* return*/
            else
              KL02922(); /* close scan cllrec*/
              ;
              CLLREC.CLACLMNB = CL02W01.CLACLMNB;
              CLLREC.CLLRTNNB = -1;
              KL02920(); /* select scan cllrec*/
              ;
              KL02921(); /* select next cllrec*/
              if (SQLCA.VAGen_SQLCODE == 0)
                while (SQLCA.VAGen_SQLCODE == 0)
                  if (CLLREC.XWHCD == KL02M001.XWHCD[sysVar.arrayIndex]
                   && CLLREC.CLLWRDT == KL02M001.CLLWRDT[sysVar.arrayIndex])
                    CL02W01.CL02WSRT = "Y"; /* solitary return flag*/
                    if (CL02W01.CL02WSRT == "Y")
                      CLLREC.CLACLMNB = CL02W01.CLACLMNB;
                      CLLREC.CLLRTNNB = CL02W01.CLLRTNNB[sysVar.arrayIndex];
                      CLZREC.XWHCD = CLLREC.XWHCD;
                      CLZREC.TF1CARCD = CLLREC.TF1CARCD;
                      CLZREC.CLLWRDT = CLLREC.CLLWRDT;
                      CL02W01.CLLNBRCV = CLLREC.CLLNBRCV;
                      ;
                      ;
                      KL02930(); /* delete cllrec*/
                      if (CL02W01.CLLRTNNB[sysVar.arrayIndex] == CLAREC.CLACRTNB)
                        KL02S30();
                                   /* update claim header current return #*/
                      end
                      ;
                      ;
                      KL02940(); /* select unique clzrec*/
                      if (SQLCA.VAGen_SQLCODE == 0)
                        if (CLLREC.CLLRTDSP != "RFSD")
                          CLZREC.CLLNBRCV = CLZREC.CLLNBRCV -                           CL02W01.CLLNBRCV;
                          CLZREC.ZZZCHGDT = CL02W01.XXXCURDT;
                          CLZREC.ZZZCHGTM = CLXREC.XXXCHHMM;
                          KL02945(); /* update clzrec*/
                        end
                      end
                    end
                  end
                  KL02921(); /* select next cllrec*/
                end
                KL02922(); /* close scan cllrec*/
              end
            end
          end
        end
        ;
      end
      sysVar.arrayIndex = sysVar.arrayIndex + 1;
    end
    if (sysVar.arrayIndex == CL02W01.CL02WMXR) /* move to max - 1*/
      KL02902(); /* close scan cl2rec*/
    end
    CLXREC.CLXBLDSC = "Y";
    return; /* return*/
  end
  ;
  ;
  ;
    /* if inspections deleted,*/
  ;
  if (CL02W01.CL02WDIS != 0) /* if inspection deleted*/
    sysVar.arrayIndex = 1;
    while (sysVar.arrayIndex <= CLXREC.CLXMAXLN[1])
      if (KL02M001.CL02MSLI[sysVar.arrayIndex] == "X")
        if (KL02M001.CL02MQTY[sysVar.arrayIndex] != 0)
          set KL02M001.CL02MSLI[sysVar.arrayIndex] cursor, bold;
          CLXREC.CLXERRF = "Y"; /* error*/
          converseLib.validationFailed(558); /* not solitary return*/
          return; /* return*/
        else
          CL2REC.CLACLMNB = KL02M001.CLACLMNB;
          CL2REC.CL2ISNBR = KL02M001.CL2ISNBR[sysVar.arrayIndex];
          KL02903(); /* delete cl2rec*/
          if (CL02W01.CL02WSAM == "Y") /* if sales sample claim*/
            CL2REC.CLACLMNB = CL02W01.CL02WCLM;
            CL2REC.CL2ISNBR = KL02M001.CL2ISNBR[sysVar.arrayIndex];
            KL02903(); /* delete sales sample 2nd clm cl2rec*/
          end
          ;
          ;
          CLOREC.CLACLMNB = KL02M001.CLACLMNB;
          CLOREC.CL2ISNBR = KL02M001.CL2ISNBR[sysVar.arrayIndex];
          CLOREC.CLHSEQNB = KL02M001.CLHSEQNB[sysVar.arrayIndex];
          if (CLXREC.CLXERRF != "Y")
            KL02905(); /* delete clorec*/
          end
          ;
          ;
          CLMREC.CLACLMNB = KL02M001.CLACLMNB;
          CLMREC.CL2ISNBR = KL02M001.CL2ISNBR[sysVar.arrayIndex];
          CLMREC.CLHSEQNB = KL02M001.CLHSEQNB[sysVar.arrayIndex];
          if (CLXREC.CLXERRF != "Y")
            KL02906(); /* delete clmrec*/
          end
        end
      end
      sysVar.arrayIndex = sysVar.arrayIndex + 1;
    end
    CLXREC.CLXBLDSC = "Y";
    CL02W02.CL02WBTF = "Y";
    return; /* return*/
  end
  ;
    /* assume inspections selected*/
  ;
  COMMAREA.CATOAP = "KL0A"; /* default map flow to claim menu*/
  ;
   /* clear out all occurances of clwrec select table*/
  sysVar.arrayIndex = 1;
  while (sysVar.arrayIndex <= 200) /* move to max*/
    CLWREC.CLWSELCD[sysVar.arrayIndex] = " ";
    CLWREC.CLWCLMNB[sysVar.arrayIndex] = 0;
    sysVar.arrayIndex = sysVar.arrayIndex + 1;
  end
  ;
   /* put insp nbrs and sel code in clwrec*/
  sysVar.arrayIndex = 1;
  while (sysVar.arrayIndex <= CL02W01.CL02WMXI) /* move to max*/
    CLWREC.CLWSELCD[sysVar.arrayIndex] = CL02W02.CL02WSLI[sysVar.arrayIndex];
    CLWREC.CLWCLMNB[sysVar.arrayIndex] = CL02W02.CL2ISNBR[sysVar.arrayIndex];
    sysVar.arrayIndex = sysVar.arrayIndex + 1;
  end
   /* move max nbr*/
  CLWREC.CLWMXIDX = CL02W01.CL02WMXI;
  CLWREC.CLWCLIDX = 1;
  ;
    /* move first selected insp nbr to clwrec*/
  ;
  if ("S" in CLWREC.CLWSELCD)
    CLWREC.CL2ISNBR = CLWREC.CLWCLMNB[sysVar.arrayIndex];
  end
  ;
  ;
               /* decide which inspection appl to flow to*/
                  /* (rts-cl0z or def-cl0y, osd-kl0y*/
  ;
   /* Note:*/
   /* The test " ycttbl.yctdef(ezetst) eq 'y' " is looking for*/
   /* defective claim types and would actually pick up 'def',*/
   /* 'dfo' and 'nil' claim types since all three are*/
   /* considered def claim types.  However, this application*/
   /* doesn't allow 'dfo' or 'nil' claim types.*/
   /* 10-31-91 twatso added code for osd so it is handled as def*/
   /* to be installed in dec. 91.*/
  ;
   /* 02-08-90*/
  if (CLAREC.YCTCD in YCTTBL.YCTCD) /* sets ezetst index*/
    if (YCTTBL.YCTCDRF[sysVar.arrayIndex] == "Y" /* if 'cdr' claim type*/
     && CLAREC.YCRCD == "RTS")                   /* if 'rts' claim reason code*/
      COMMAREA.CATOAP = "KL0Z"; /* go to rts inspection screen*/
    else
      if (CLAREC.YCTCD in YCTTBL.YCTCD)
        if (YCTTBL.YCTCDRF[sysVar.arrayIndex] == "Y" /* if 'cdr' claim type*/
         || YCTTBL.YCTDEF[sysVar.arrayIndex] == "Y") /* if 'def' claim typeor 'osd'*/
          /* OR YCTTBL.YCT-OSD-FL(EZETST) EQ 'Y'; /* if 'osd' claim type*/
          COMMAREA.CATOAP = "KL0Y"; /* defective claim type*/
        else
          COMMAREA.CATOAP = "KL0Z"; /* RTS claim type*/
        end
      end
    end
  end
  ;
  ;
  XPCL002(); /* leave cl02 application*/
  ;
  ;
end // end KL02130

// select set from cl2rec
Function KL02900()
   /* **************************************/
   /* select set from cl2rec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO2870" ("S1", SQLCA, CL2REC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        TA1REC.TA1LOCAT[2] = "CL02900"; /* location*/
        TA1REC.TA1MAP = "CL02M001";
        TA1REC.TA1DBASE = "DCLAIM  ";
        TA1REC.TA1TBLVU = "VRINSP01";
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE;
        TA1REC.TA1LOCAT[4] = "IO2870";
        ;
        XPCL010(); /* error diagnosis routine*/
        ;
        return;
      end
    end
  end
end // end KL02900

// fetch next from cl2rec
Function KL02901()
   /* **************************************/
   /* fetch next from cl2rec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO2870" ("N1", SQLCA, CL2REC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        TA1REC.TA1LOCAT[2] = "CL02901"; /* location*/
        TA1REC.TA1MAP = "CL02M001";
        TA1REC.TA1DBASE = "DCLAIM  ";
        TA1REC.TA1TBLVU = "VRINSP01";
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE;
        TA1REC.TA1LOCAT[4] = "IO2870";
        ;
        XPCL010(); /* error diagnosis routine*/
        ;
        return;
      end
    end
  end
end // end KL02901

// close cursor for cl2rec
Function KL02902()
   /* **************************************/
   /* close cl2rec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO2870" ("C1", SQLCA, CL2REC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        TA1REC.TA1LOCAT[2] = "CL02902"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO2870";
        TA1REC.TA1MAP = "CL02M001";
        TA1REC.TA1DBASE = "DCLAIM  ";
        TA1REC.TA1TBLVU = "VRINSP01";
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE;
        ;
        XPCL010(); /* error diagnosis routine*/
        ;
        return;
      end
    end
  end
end // end KL02902

// delete for cl2rec
Function KL02903()
   /* **************************************/
   /* delete cl2rec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO2870" ("D ", SQLCA, CL2REC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        TA1REC.TA1LOCAT[2] = "CL02903"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO2870";
        TA1REC.TA1MAP = "CL02M001";
        TA1REC.TA1DBASE = "DCLAIM  ";
        TA1REC.TA1TBLVU = "VRINSP01";
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE;
        ;
        XPCL010(); /* error diagnosis routine*/
        ;
        return;
      end
    end
  end
end // end KL02903

// delete for clorec
Function KL02905()
   /* **************************************/
   /* delete clorec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO1340" ("D ", SQLCA, CLOREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        TA1REC.TA1LOCAT[2] = "CL02905"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO1340";
        TA1REC.TA1MAP = "CL02M001";
        TA1REC.TA1DBASE = "DCLAIM  ";
        TA1REC.TA1TBLVU = "VDEFHD01";
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE;
        ;
        XPCL010(); /* error diagnosis routine*/
        ;
        return;
      end
    end
  end
end // end KL02905

// delete for clmrec
Function KL02906()
   /* **************************************/
   /* delete clmrec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO1320" ("D ", SQLCA, CLMREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        TA1REC.TA1LOCAT[2] = "CL02906"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO1320";
        TA1REC.TA1MAP = "CL02M001";
        TA1REC.TA1DBASE = "DCLAIM  ";
        TA1REC.TA1TBLVU = "VRTSHD01";
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE;
        ;
        XPCL010(); /* error diagnosis routine*/
        ;
        return;
      end
    end
  end
end // end KL02906

// select scan on cllrec
Function KL02920()
   /* **************************************/
   /* select scan on cllrec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO1310" ("SS ", SQLCA, CLLREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        ;
        TA1REC.TA1LOCAT[2] = "CL02920"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO1310"; /* location*/
        TA1REC.TA1DBASE = "DCLAIM"; /* database name*/
        TA1REC.TA1TBLVU = "VCLRTN01"; /* table view name*/
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* table key*/
        ;
        XPCL010(); /* error diagnosis routine*/
      end
    end
  end
end // end KL02920

// select next on cllrec
Function KL02921()
   /* **************************************/
   /* select next on cllrec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO1310" ("SN ", SQLCA, CLLREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        ;
        TA1REC.TA1LOCAT[2] = "CL02921"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO1310"; /* location*/
        TA1REC.TA1DBASE = "DCLAIM"; /* database name*/
        TA1REC.TA1TBLVU = "VCLRTN01"; /* table view name*/
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* table key*/
        ;
        XPCL010(); /* error diagnosis routine*/
      end
    end
  end
end // end KL02921

// close scan on cllrec
Function KL02922()
   /* **************************************/
   /* close scan on cllrec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO1310" ("CS ", SQLCA, CLLREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        ;
        TA1REC.TA1LOCAT[2] = "CL02922"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO1310"; /* location*/
        TA1REC.TA1DBASE = "DCLAIM"; /* database name*/
        TA1REC.TA1TBLVU = "VCLRTN01"; /* table view name*/
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* table key*/
        ;
        XPCL010(); /* error diagnosis routine*/
      end
    end
  end
end // end KL02922

// delete cllrec
Function KL02930()
   /* ****************************************************/
   /* delete on cllrec and corresponding dvmact01 record*/
   /*  */
   /* 01/20/94 jcarey Added code to delete any matching*/
   /* dvmact01 records.*/
   /* ****************************************************/
  ;
  set SQLCA empty;
  call "IO1310" ("D ", SQLCA, CLLREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
        return;
      else
        ;
        TA1REC.TA1LOCAT[2] = "CL02930"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO1310"; /* location*/
        TA1REC.TA1DBASE = "DCLAIM"; /* database name*/
        TA1REC.TA1TBLVU = "VCLRTN01"; /* table view name*/
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* table key*/
        ;
        XPCL010(); /* error diagnosis routine*/
      end
    end
  end
  ;
  set SQLCA empty;
  set VDMACT01 empty;
  VDMACT01.CLACLMNB = CLLREC.CLACLMNB;
  VDMACT01.CLLRTNNB = CLLREC.CLLRTNNB;
  call "IO0870" ("D ", SQLCA, VDMACT01) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE == 0
   || SQLCA.VAGen_SQLCODE == -811
   || SQLCA.VAGen_SQLCODE == +100)
    return;
  else
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      TA1REC.TA1LOCAT[2] = "CL02930"; /* location*/
      TA1REC.TA1LOCAT[4] = "IO0870"; /* location*/
      TA1REC.TA1DBASE = "DCLAIM"; /* database name*/
      TA1REC.TA1TBLVU = "VDMACT01"; /* table view name*/
      CLXREC.XXXWDTE = CLAREC.CLACLMNB;
      TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* table key*/
      XPCL010(); /* error diagnosis routine*/
    end
  end
end // end KL02930

// select unique on clzrec
Function KL02940()
   /* **************************************/
   /* select unique on clzrec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO2830" ("S  ", SQLCA, CLZREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        ;
        TA1REC.TA1LOCAT[2] = "CL02940"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO2830"; /* location*/
        TA1REC.TA1DBASE = "DCLAIM"; /* database name*/
        TA1REC.TA1TBLVU = "VCLCTN01"; /* table view name*/
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* table key*/
        ;
        XPCL010(); /* error diagnosis routine*/
      end
    end
  end
end // end KL02940

// update on clzrec
Function KL02945()
   /* **************************************/
   /* update on clzrec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO2830" ("U  ", SQLCA, CLZREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        ;
        TA1REC.TA1LOCAT[2] = "CL02945"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO2830"; /* location*/
        TA1REC.TA1DBASE = "DCLAIM"; /* database name*/
        TA1REC.TA1TBLVU = "VCLCTN01"; /* table view name*/
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* table key*/
        ;
        XPCL010(); /* error diagnosis routine*/
      end
    end
  end
end // end KL02945

// edit PF18, leave CL02 or error
Function KL02S18()
   /* ************************************************************/
   /* *                                                         **/
   /* *  edit Claim is valid for PF 18 action                   **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL02S18"; /* set current process name*/
  ;
  ;
  ;
  if (converseVar.eventKey is pf18) /* transfer to claim comments*/
    CLXREC.CLXEOSF = "Y";
    CLXREC.CLXEOAF = "Y";
    CLWREC.CLWMCMNT = "N";
    COMMAREA.CATOAP = "KL0G";
  end
  ;
  ;
  ;
  ;
  XPCL002(); /* leave cl02 application*/
  ;
  ;
end // end KL02S18

// edit PF20, leave CL02 or error
Function KL02S20()
   /* ************************************************************/
   /* *  edit Claim is valid for PF 20 action                   **/
   /* *                                                         **/
   /* *  Claim must have at least one return number             **/
   /* *  If not, re-show map with message                       **/
   /* *  If OK, leave CL02 for CL0Y/Z.                          **/
   /* *                                                         **/
   /* ************************************************************/
   /* *    M A I N T E N A N C E     H I S T O R Y    L O G     **/
   /* *---------------------------------------------------------**/
   /* *    DATE   PGMR   DESCRIPTION                            **/
   /* *---------------------------------------------------------**/
   /* *  02-28-90 bcourt prevent next inspection if at insp 99. **/
   /* *  03-01-90 bcourt skip above test if have no inspections.**/
   /* *  02-08-90  SGORGA                                       **/
   /* *    See appliciation prologue comments.                  **/
   /* *  08-08-91  wjohns                                       **/
   /* *    changed application names for transfers.             **/
   /* *  05-05-93  BCOURT  add menu option 19, like option 09.  **/
   /* *  10-21-93  GDECKE  SEND MSG TO KL0A IF WRONG MENU OPTION**/
   /* *  10-26-93  GDECKE  CLEAR OUT CLWREC SELECT LIST BEFORE  **/
   /* *                    MOVING VALUES INTO IT.               **/
   /* *                                                         **/
   /* ************************************************************/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL02S20"; /* set current process name*/
  ;
    /* check max nbr returns on Claim*/
  ;
  if (CL02W01.CL02WMXR <= 1) /* max is 1 above actual number*/
    converseLib.validationFailed(525); /* inspec not allowed until return is*/
                                   /* logged*/
    CLXREC.CLXERRF = "Y";
    return;
  end
  ;
  if (CL02W01.CL02WUDF == "N")
    converseLib.validationFailed(540); /* pf20 not valid in inquiry mode*/
    CLXREC.CLXERRF = "Y";
    return;
  end
  ;
  if (CL02W01.CL02WMXI > 0
   && CL02W02.CL2ISNBR[CL02WMXI] == 99) /* 2-28-90 add edit*/
    converseLib.validationFailed(609); /* claim insp # at max of 99; start new*/
                                   /* clm;*/
    CLXREC.CLXERRF = "Y";
    return;
  end
  ;
   /* if warehouse for current return is not equal to commarea*/
   /* warehouse, user cannot use pf20*/
  ;
  if (KL02M001.XWHCD[1] != COMMAREA.XWHCD)
    if (COMMAREA.XWHCD == "04" /* it's ok for WHSE 04,32,AND 51*/
     || COMMAREA.XWHCD == "32" /* to use THE OTHER'S warehouse*/
     || COMMAREA.XWHCD == "51")
      if (KL02M001.XWHCD[1] == "04"
       || KL02M001.XWHCD[1] == "32"
       || KL02M001.XWHCD[1] == "51")
        /* next sentence*/
      else
        converseLib.validationFailed(557); /* warehouse inconsistent*/
        CLXREC.CLXERRF = "Y";
        set KL02M001.XWHCD[1] skip, bold;
        return;
      end
    else
      converseLib.validationFailed(557); /* warehouse inconsistent*/
      CLXREC.CLXERRF = "Y";
      set KL02M001.XWHCD[1] skip, bold;
      return;
    end
  end
  ;
   /* Prevent an insp (PF20) if the sole return(s)*/
   /* logged are RFSD and/or NCLM.*/
  ;
  if (CL02W01.CL02WINF != "Y") /* no returns logged for inspection*/
    if (CL02W01.CL02WRFF == "Y"
     && CL02W01.CL02WNCF == "Y")
      converseLib.validationFailed(600); /* ; new insp not allowed for nclm/rfsd*/
                                   /* ret*/
      CLXREC.CLXERRF = "Y";
      return;
    else
      if (CL02W01.CL02WRFF == "Y") /* if only refusals exist*/
        converseLib.validationFailed(598); /* new insp not allowed for nclm/rfsd*/
                                   /* ret*/
        CLXREC.CLXERRF = "Y";
        return;
      else
        if (CL02W01.CL02WNCF == "Y") /* if only nclm exist*/
          converseLib.validationFailed(599); /* new insp not allowed for nclm/rfsd*/
                                   /* ret*/
          CLXREC.CLXERRF = "Y";
          return;
        else
           /* NEXT SENTENCE*/
        end
      end
    end
  end
  ;
    /* set up map return*/
  ;
  CLWREC.CLWMAPFM = "KL02M001"; /* return to kl02*/
  ;
  COMMAREA.CATOAP = "KL0A"; /* default map flow to claim menu*/
  ;
  ;
   /* CLEAR OUT ALL OCCURANCES IN CLWREC SELECT LIST BEFORE REUSING*/
   /* FOR INSPECTION NUMBERS*/
  ;
  sysVar.arrayIndex = 1;
  while (sysVar.arrayIndex <= 200)
    CLWREC.CLWSELCD[sysVar.arrayIndex] = " ";
    CLWREC.CLWCLMNB[sysVar.arrayIndex] = 0;
    sysVar.arrayIndex = sysVar.arrayIndex + 1;
  end
  ;
   /* put new insp nbr and sel code in clwrec*/
  ;
  CLWREC.CLWSELCD[1] = "S";
  CLWREC.CLWCLMNB[1] = 0;
  CLWREC.CLHSEQNB = CLAREC.CLACSQNB;
  ;
   /* move max nbr & starting index*/
  CLWREC.CLWMXIDX = 1;
  CLWREC.CLWCLIDX = 1;
  ;
    /* move first selected insp nbr to clwrec*/
  if ("S" in CLWREC.CLWSELCD)
    CLWREC.CL2ISNBR = CLWREC.CLWCLMNB[sysVar.arrayIndex];
  end
  ;
  ;
   /* decide where to flow to*/
  ;
   /* *                                                         **/
   /* *  NOTE:  There is a test used in the below code:         **/
   /* *          "or ycttbl.yctdef(ezetst) eq 'y'".             **/
   /* *         This test is used to select 'DEF' claim types,  **/
   /* *         although there are two other claim types with   **/
   /* *         that flag = 'y';  'DFO' and 'NIL'.  I am told   **/
   /* *         that this application does not allow those two  **/
   /* *         claim types "in", so this is supposed to be a   **/
   /* *         safe test for getting only 'DEF' claim types.   **/
   /* *  There are now 3 other claim types - osd is the next    **/
   /* *  one added - and is coded for in this statement group   **/
   /* *  so that it is treated the same as defectives consistently*/
   /* *  Will be installed in Dec.91.  twatso 10-31-91          **/
   /* *                                                         **/
  ;
  KL02SCC(); /* ck for clm hdr comments*/
  ;
  if (CLAREC.YCTCD in YCTTBL.YCTCD) /* sets ezetst index*/
    if (CLWREC.CLWMNOPT == 9  /* if menu opt 9*/
     || CLWREC.CLWMNOPT == 17 /* or menu opt 17*/
     || CLWREC.CLWMNOPT == 19) /* or menu opt 19 5-5-93*/
      if (CL02W01.CL02WMXI == 0 /* if no inspections*/
       && CL02W01.CL02WCCF == "Y") /* if clm hdr comments do exist*/
        CLWREC.CLWMCMNT = "N"; /* indicates comment screen Kl0gm001*/
        CLWREC.CLWMAPFM = "PF20 KEY"; /* pass that pf20 was entered*/
        COMMAREA.CATOAP = "KL0G"; /* go to clm hdr comment screen*/
      else
        if (YCTTBL.YCTCDRF[sysVar.arrayIndex] == "Y" /* if 'cdr' claim type*/
         && CLAREC.YCRCD == "RTS")                   /* if 'rts' claim reason code*/
          COMMAREA.CATOAP = "KL0Z"; /* go to rts inspection screen*/
        else
          if (YCTTBL.YCTCDRF[sysVar.arrayIndex] == "Y" /* if 'cdr' claim type*/
           || YCTTBL.YCTDEF[sysVar.arrayIndex] == "Y") /* if 'def' claim type, or 'osd*/
           /* OR YCTTBL.YCT-OSD-FL(EZETST) EQ 'Y';/* if 'osd' claim type*/
            COMMAREA.CATOAP = "KL0Y"; /* go to def inspection screen*/
          else
            COMMAREA.CATOAP = "KL0Z"; /* go to rts inspection screen*/
          end
        end
      end
    end
  end
  ;
  if (COMMAREA.CATOAP == "KL0A")
    CLWREC.CLWEZMNO = 19;
  end
  ;
  XPCL002(); /* leave kl02 application*/
  ;
  ;
end // end KL02S20

// Read DCLAIM.VCLARX01
Function KL02S30()
   /* **************************************************************/
   /* *  SELECT THE DCLAIM.VCLARX01 LINE TO GET SAP RTN SO NBR **/
   /* ***********************************************************/
   /* *    M A I N T E N A N C E     H I S T O R Y             **/
   /* *--------------------------------------------------------**/
   /* *    DATE    USER    DESCRIPTION                         **/
   /* *--------------------------------------------------------**/
   /* *  07-27-01  DSINHA  created                             **/
   /* ***********************************************************/
  ;
  CLXREC.CLXCPROC = "READ-VCLARX"; /* set current process name*/
  ;
  set SQLCA empty; /* CLEAR SQL RECORD*/
  call "IO1170" ("S1", SQLCA, CLCREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0) /* RECORD FOUND*/
    TA1REC.TA1LOCAT[2] = "KL02S30"; /* LOCATION*/
    TA1REC.TA1LOCAT[4] = "IO1170"; /* LOCATION*/
    TA1REC.TA1DBASE = "DCLAIM"; /* DATABASE*/
    TA1REC.TA1TBLVU = "VCLARX01"; /* TABLE VIEW*/
    CLXREC.XXXWDTE = CLAREC.CLACLMNB; /* CLAIM NUMBER*/
    TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* TABLE KEY*/
    XPCL010(); /* ERROR DIAGNOSIS ROUTINE*/
  end
  ;
   /* ***** FETCH THE FIRST LINE FOR THE CLAIM FROM THE ARX TABLE*/
  ;
  set SQLCA empty; /* CLEAR SQL RECORD*/
  call "IO1170" ("N1", SQLCA, CLCREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE == 0 /* RECORD FOUND*/
   || SQLCA.VAGen_SQLCODE == 100) /* not found*/
   /* next sentence*/
  else
    TA1REC.TA1LOCAT[2] = "KL02S30-FETCH"; /* LOCATION*/
    TA1REC.TA1LOCAT[4] = "IO1170"; /* LOCATION*/
    TA1REC.TA1DBASE = "DCLAIM"; /* DATABASE*/
    TA1REC.TA1TBLVU = "VCLARX01"; /* TABLE VIEW*/
    CLXREC.XXXWDTE = CLAREC.CLACLMNB; /* CLAIM NUMBER*/
    TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* TABLE KEY*/
    XPCL010(); /* ERROR DIAGNOSIS ROUTINE*/
  end
  ;
  ;
end // end KL02S30

// close cursor DCLAIM.VCLARX01
Function KL02S35()
   /* **************************************************************/
   /* *  SELECT THE DCLAIM.VCLARX01 LINE TO GET SAP RTN SO NBR **/
   /* ***********************************************************/
   /* *    M A I N T E N A N C E     H I S T O R Y             **/
   /* *--------------------------------------------------------**/
   /* *    DATE    USER    DESCRIPTION                         **/
   /* *--------------------------------------------------------**/
   /* *  07-17-01  DSINHA  created                             **/
   /* ***********************************************************/
  ;
  CLXREC.CLXCPROC = "CLOSE-VCLARX"; /* set current process name*/
  ;
  set SQLCA empty; /* CLEAR SQL RECORD*/
  call "IO1170" ("C1", SQLCA, CLCREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0) /* RECORD FOUND*/
    TA1REC.TA1LOCAT[2] = "KL02S35"; /* LOCATION*/
    TA1REC.TA1LOCAT[4] = "IO1170"; /* LOCATION*/
    TA1REC.TA1DBASE = "DCLAIM"; /* DATABASE*/
    TA1REC.TA1TBLVU = "VCLARX01"; /* TABLE VIEW*/
    CLXREC.XXXWDTE = CLAREC.CLACLMNB; /* CLAIM NUMBER*/
    TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* TABLE KEY*/
    XPCL010(); /* ERROR DIAGNOSIS ROUTINE*/
  end
end // end KL02S35

// Search for Claim Hdr Comments
Function KL02SCC()
   /* ***********************************************************/
   /* *  Check the Claims Comments Table for Claim Hdr comments**/
   /* *  (claim type code = 'C ') on a claim.                  **/
   /* *  If yes, move 'y' to the claim-hdr-comments-flag,      **/
   /* *  'CL02WCCF'.                                           **/
   /* ***********************************************************/
   /* *  MAINTENANCE HISTORY                                   **/
   /* *  02-26-90  sgorga  created                             **/
   /* *  02-21-93  BCOURT  allow 'B' comment types from CSW    **/
   /* *                    to function exactly as 'C' types.   **/
   /* ***********************************************************/
  CLXREC.CLXCPROC = "CL02SCC"; /* set current process name*/
  ;
  CL02W01.CL02WCCF = "N"; /* init claim hdr comments flag to no*/
  ;
  set CLGREC empty; /* init. claims comment record*/
  set SQLCA empty; /* init. sqlca*/
  CLGREC.CLACLMNB = CLAREC.CLACLMNB; /* claim nbr*/
  CLGREC.CLGCMTYP = "C ";
                                   /* look for only claim-hdr type comments*/
  call "IO1260" ("SE", SQLCA, CLGREC) {isNoRefresh = yes, isExternal = yes}; /* CK FOR CLM HDR COMMENTS*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0 /* row found*/
   || SQLCA.VAGen_SQLCODE == -811) /* multiple rows found*/
    CL02W01.CL02WCCF = "Y"; /* yes to claim hdr comments flag*/
  else
    if (SQLCA.VAGen_SQLCODE == +100) /* row not found*/
       /* next sentence*/
    else
      TA1REC.TA1DBASE = "DCLAIM"; /* bad sql code, so abend*/
      TA1REC.TA1TBLVU = "VCLCOM01";
      CLXREC.XXXWDTE = CLAREC.CLACLMNB; /* move to num field*/
      TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* and then to key*/
      XPCL010(); /* std abend routine for claims*/
    end
  end
   /* ********************************************************/
  ;
   /* CSW is the consumer services orders and claims*/
   /* they will send comment type 'B' to the IBM.*/
   /* 'B' are protected on KL0G comment change screen*/
   /* Yet they must be seen during this PF20 flow.*/
  ;
  if (CL02W01.CL02WCCF != "Y") /* if needed, continue looking*/
    CLGREC.CLGCMTYP = "B "; /* for comments existence*/
    set SQLCA empty; /* init. sqlca*/
    CLGREC.CLACLMNB = CLAREC.CLACLMNB; /* claim nbr*/
                                  /* look for only CSW type comments*/
    call "IO1260" ("SE", SQLCA, CLGREC) {isNoRefresh = yes, isExternal = yes}; /* do comments exist?*/
    ;
    if (SQLCA.VAGen_SQLCODE == 0 /* row found*/
     || SQLCA.VAGen_SQLCODE == -811) /* multiple rows found*/
      CL02W01.CL02WCCF = "Y"; /* yes to csw comments found flag*/
    else
      if (SQLCA.VAGen_SQLCODE == +100) /* row not found*/
         /* next sentence*/
      else
        TA1REC.TA1DBASE = "DCLAIM"; /* bad sql code, so abend*/
        TA1REC.TA1TBLVU = "VCLCOM0B";
        CLXREC.XXXWDTE = CLAREC.CLACLMNB; /* move to num field*/
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* and then to key*/
        XPCL010(); /* std abend routine for claims*/
      end
    end
  end
end // end KL02SCC

// edit claim number
Function KL02SCL()
  CLXREC.CLXCPROC = "CL02SCL"; /* current name*/
  ;
  if (KL02M001.CLACLMNB == 0)
    set KL02M001.CLACLMNB cursor, bold;
    converseLib.validationFailed(5); /* claim number required*/
    CLXREC.CLXERRF = "Y"; /* mark as error*/
    return;
  end
  ;
  ;
  set CLAREC empty;
  set SQLCA empty;
  CLAREC.CLACLMNB = KL02M001.CLACLMNB;
  ;
  call "IO1160" ("S ", SQLCA, CLAREC) {isNoRefresh = yes, isExternal = yes}; /* select unique*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0) /* claim found*/
    /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      set KL02M001.CLACLMNB cursor, bold;
      converseLib.validationFailed(5); /* claim not found*/
      CLXREC.CLXERRF = "Y"; /* mark as error*/
      return;
    else
      TA1REC.TA1DBASE = "DCLAIM";
      TA1REC.TA1TBLVU = "VCLHDR";
      CLXREC.CLXORDIV = CLAREC.CLACLMNB; /* unpack field*/
      TA1REC.TA1TBLKE = CLXREC.CLXORDIV;
      XPCL010(); /* abend*/
    end
  end
  ;
  ;
  KL02SEC(); /* edit claim is valid for screen*/
  ;
  ;
end // end KL02SCL

// edit claim, valid for screen
Function KL02SEC()
   /* ********************************************************************/
   /* *     M A I N T E N A N C E     H I S T O R Y    L O G            **/
   /* *-----------------------------------------------------------------**/
   /* *    DATE    PGMR    DESCRIPTION                                  **/
   /* *-----------------------------------------------------------------**/
   /* *  10-21-93  GDECKE  Fix bad reference to status cd2:alias=ycscd. **/
   /* ********************************************************************/
  CLXREC.CLXCPROC = "CL02SEC"; /* current name*/
  ;
  ;
  if (KL02M001.CLACLMNB == 0)
    set KL02M001.CLACLMNB cursor, bold;
    converseLib.validationFailed(5); /* claim number required*/
    CLXREC.CLXERRF = "Y"; /* mark as error*/
    return;
  end
  ;
   /* set update flag based on security/claim status*/
  ;
  CL02W01.CL02WUDF = "N"; /* set update flag to no*/
  ;
  if (CLWREC.CLWACTIV == "I")
    /* skip*/
  else
    if (COMMAREA.CAALVL[6] == "Y" /* distribution add*/
     || COMMAREA.CACLVL[6] == "Y") /* distribution change*/
      CL02W01.CL02WUDF = "Y"; /* set update flag to yes*/
    end
  end
  ;
  if (CL02W01.CL02WUDF == "N")
     /* next sentence*/
  else
    if (CLAREC.YCSCD1 in YCSTBL.YCSCD) /* check claim status*/
      if (YCSTBL.YCSAINPF[sysVar.arrayIndex] == "N")
        if (CLAREC.YCSCD1 == "RIP" /* these status always allow input*/
         || CLAREC.YCSCD1 == "RAA" 
         || CLAREC.YCSCD1 == "ERA" 
         || CLAREC.YCSCD1 == "RPA") /* 062089 return pending authorization*/
          /* skip*/
        else
          CL02W01.CL02WUDF = "N";
        end
      end
    end
  end
  ;
  ;
  if (CLAREC.CLAWSENF == "Y") /* if worksheet entered claim*/
    CL02W01.CLACLMNB = KL02M001.CLACLMNB; /* skip re-edit 4/89*/
    set KL02M001.CLACLMNB cursor, bold;
    converseLib.validationFailed(493); /* claim not valid for this screen*/
    CLXREC.CLXERRF = "Y"; /* mark as error*/
    return;
  end
  ;
  ;
  if (CLAREC.YCTCD in YCTTBL.YCTCD) /* test claim type:*/
    if (YCTTBL.YCTCDRF[sysVar.arrayIndex] == "Y" /* consumer defective*/
     || YCTTBL.YCTDEF[sysVar.arrayIndex] == "Y"  /* defective, or 'osd'*/
     || YCTTBL.YCTRTSF[sysVar.arrayIndex] == "Y" /* return to stock*/
     /* OR YCTTBL.YCT-OSD-FL(EZETST) EQ*/
     /* 'Y';/* off shore defective*/
     || CLAREC.YCTCD == "RFL")                   /* refusal*/
      CL02W01.CL02WCHG = "Y"; /* mark clm nbr changed*/
    else
      CL02W01.CLACLMNB = KL02M001.CLACLMNB; /* skip re-edit 4/89*/
      set KL02M001.CLACLMNB cursor, bold;
      converseLib.validationFailed(494); /* not correct claim type for this*/
                                   /* screen*/
      CLXREC.CLXERRF = "Y"; /* mark as error*/
    end
  else
    CL02W01.CLACLMNB = KL02M001.CLACLMNB; /* skip re-edit 4/89*/
    set KL02M001.CLACLMNB cursor, bold;
    converseLib.validationFailed(494); /* not correct claim type for this*/
                                   /* screen*/
    CLXREC.CLXERRF = "Y"; /* mark as error*/
  end
  ;
  ;
    /* *************************************************/
    /* reset flag to skip these edits after first claim*/
    /* *************************************************/
  ;
  CL02W01.CL02WFST = "N"; /* mark claim as not first one*/
  ;
  if (CLXREC.CLXERRF == "N") /* no error*/
    CL02W02.CL02WBTF = "Y"; /* so rebuild array*/
  end
  ;
end // end KL02SEC

// edit select codes
Function KL02SEL()
  CLXREC.CLXCPROC = "CL02SEL"; /* current name*/
  ;
    /* edit each select code individually, from right to left,*/
    /* ezetst is index to map line*/
  ;
  ;
  if (KL02M001.CL02MSLI[sysVar.arrayIndex] == " ") /* edit inspection select*/
    /* next sentence*/
  else
    if (KL02M001.CL02MSLI[sysVar.arrayIndex] == "X")
      if (CL02W01.CL02WUDF == "N" /* no update allowed*/
       || KL02M001.YCICD[sysVar.arrayIndex] == "CMP")
        converseLib.validationFailed(368); /* delete not allowed*/
        set KL02M001.CL02MSLI[sysVar.arrayIndex] cursor, bold;
        CLXREC.CLXERRF = "Y";
      else
        CL02W01.CL02WDIS = CL02W01.CL02WDIS + 1; /* count insp deletes*/
      end
    else
      if (KL02M001.CL02MSLI[sysVar.arrayIndex] == "S")
        CL02W01.CL02WNIS = CL02W01.CL02WNIS + 1;
                                   /* count inspection selects*/
      else
        if (sysVar.arrayIndex == 1 /* first select may be 'a'll*/
         && KL02M001.CL02MSLI[sysVar.arrayIndex] == "A")
          CL02W01.CL02WNIS = CL02W01.CL02WNIS + 1; /* count inspection selects*/
        else
          set KL02M001.CL02MSLI[sysVar.arrayIndex] cursor, bold;
          converseLib.validationFailed(490); /* valid select is ' ','s','x' or 'a'*/
          CLXREC.CLXERRF = "Y";
        end
      end
    end
  end
  ;
  ;
  if (KL02M001.CL02MSLR[sysVar.arrayIndex] == " ") /* edit return select*/
    /* next sentence*/
  else
    if (KL02M001.CL02MSLR[sysVar.arrayIndex] == "S")
      CL02W01.CL02WNRT = CL02W01.CL02WNRT + 1; /* count return selects*/
    else
      if (KL02M001.CL02MSLR[sysVar.arrayIndex] == "X")
        if (CL02W01.CL02WUDF == "N") /* no update allowed*/
          converseLib.validationFailed(368); /* delete not allowed*/
          set KL02M001.CL02MSLR[sysVar.arrayIndex] cursor, bold;
          CLXREC.CLXERRF = "Y";
        else
          CL02W01.CL02WDRT = CL02W01.CL02WDRT + 1; /* count return selects*/
        end
      else
        if (sysVar.arrayIndex == 1 /* first select may be 'a'll*/
         && KL02M001.CL02MSLR[sysVar.arrayIndex] == "A")
          CL02W01.CL02WNRT = CL02W01.CL02WNRT + 1; /* count return selects*/
        else
          set KL02M001.CL02MSLR[sysVar.arrayIndex] cursor, bold;
          converseLib.validationFailed(490); /* valid select is ' ','s' or 'a'*/
          CLXREC.CLXERRF = "Y";
        end
      end
    end
  end
  ;
  ;
end // end KL02SEL

// get memo,RTS&DEF items; totals
Function KL02SIS()
  CLXREC.CLXCPROC = "CL02SIS"; /* current ID*/
  ;
    /* ************************************************/
    /* get single memo record for completed inspection*/
    /* ************************************************/
  ;
  set CLHREC empty;
  set SQLCA empty;
  ;
  if (CL2REC.CLHSEQNB > 0)
    CLHREC.CLACLMNB = CLAREC.CLACLMNB;
    CLHREC.CLHSEQNB = CL2REC.CLHSEQNB;
    ;
    call "IO1290" ("SA", SQLCA, CLHREC) {isNoRefresh = yes, isExternal = yes}; /* get unique memo*/
    if (SQLCA.VAGen_SQLCODE == 0
     || SQLCA.VAGen_SQLCODE == 100)
       /* check if multiple inspecs on memo*/
      if (CLHREC.CLHSEQNB in CL02W02.CLHSEQNB)
        if (sysVar.arrayIndex == CL02W02.CL02WIDX)
           /* accum total memo amount*/
          CL02W01.CL02MTIA = CL02W01.CL02MTIA + CLHREC.CLHMEMAM;
        end
      end
    else
      TA1REC.TA1DBASE = "DCLAIM";
      TA1REC.TA1TBLVU = "VCLMEM01";
      TA1REC.TA1LOCAT[4] = "GET UNIQUE MEMO FOR INSP SEQ";
      CLXREC.CLXORDIV = CLAREC.CLACLMNB;
      TA1REC.TA1TBLKE = CLXREC.CLXORDIV;
      XPCL010(); /* abend*/
    end
  end
  ;
  ;
    /* *************************************************/
    /* RTS header for inspection & sequence nbr*/
    /* *************************************************/
  ;
  set CLMREC empty;
  set SQLCA empty;
  ;
  CLMREC.CLACLMNB = CLAREC.CLACLMNB;
  CLMREC.CL2ISNBR = CL2REC.CL2ISNBR;
  CLMREC.CLHSEQNB = CL2REC.CLHSEQNB;
  ;
  call "IO1320" ("S ", SQLCA, CLMREC) {isNoRefresh = yes, isExternal = yes}; /* get RTS header*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
     /* add line total*/
    CL02W01.CL02MQTY = CL02W01.CL02MQTY + CLMREC.CLMTRTSQ;
    CL02W01.CL02MQTY = CL02W01.CL02MQTY + CLMREC.CLMTNCRQ;
     /* add map total to date*/
    CL02W01.CL02MTIQ = CL02W01.CL02MTIQ + CLMREC.CLMTRTSQ;
    CL02W01.CL02MTIQ = CL02W01.CL02MTIQ + CLMREC.CLMTNCRQ;
     /* add map total today*/
    if (CLMREC.ZZZCHGDT == CL02W01.XXXCURDT)
      CL02W01.CL02MIQ2 = CL02W01.CL02MIQ2 + CLMREC.CLMTRTSQ;
      CL02W01.CL02MIQ2 = CL02W01.CL02MIQ2 + CLMREC.CLMTNCRQ;
    end
    ;
  else
    if (SQLCA.VAGen_SQLCODE != 100) /* bad db2 error*/
      TA1REC.TA1DBASE = "DCLAIM";
      TA1REC.TA1TBLVU = "VRTSHD01";
      CLXREC.CLXORDIV = CLAREC.CLACLMNB;
      TA1REC.TA1TBLKE = CLXREC.CLXORDIV;
      XPCL010(); /* abend*/
    end
  end
  ;
  ;
    /* *************************************************/
    /* get DEF header for inspection & sequence nbr*/
    /* *************************************************/
  ;
  set CLOREC empty;
  set SQLCA empty;
  ;
  CLOREC.CLACLMNB = CLAREC.CLACLMNB;
  CLOREC.CL2ISNBR = CL2REC.CL2ISNBR;
  CLOREC.CLHSEQNB = CL2REC.CLHSEQNB;
  ;
  call "IO1340" ("S ", SQLCA, CLOREC) {isNoRefresh = yes, isExternal = yes}; /* get RTS header*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
     /* add line total*/
    CL02W01.CL02MQTY = CL02W01.CL02MQTY + CLOREC.CLOTDFQY;
    CL02W01.CL02MQTY = CL02W01.CL02MQTY + CLOREC.CLMTNCRQ;
     /* add map total to date*/
    CL02W01.CL02MTIQ = CL02W01.CL02MTIQ + CLOREC.CLOTDFQY;
    CL02W01.CL02MTIQ = CL02W01.CL02MTIQ + CLOREC.CLMTNCRQ;
     /* add map total today*/
    if (CLOREC.ZZZCHGDT == CL02W01.XXXCURDT)
      CL02W01.CL02MIQ2 = CL02W01.CL02MIQ2 + CLOREC.CLOTDFQY;
      CL02W01.CL02MIQ2 = CL02W01.CL02MIQ2 + CLOREC.CLMTNCRQ;
    end
    ;
  else
    if (SQLCA.VAGen_SQLCODE != 100) /* bad db2 error*/
      TA1REC.TA1DBASE = "DCLAIM";
      TA1REC.TA1TBLVU = "VDEFHD01";
      CLXREC.CLXORDIV = CLAREC.CLACLMNB;
      TA1REC.TA1TBLKE = CLXREC.CLXORDIV;
      XPCL010(); /* abend*/
    end
  end
  ;
  ;
  ;
end // end KL02SIS

// get more files (cmpny, RA hdr)
Function KL02SMO()
  ;
    /* Maintenance History:*/
    /* 05-31-90 CHELLM Added select from dcust.vcmpny01 to get*/
                    /* cust legal entity.*/
  ;
   /* *************************************************************/
  ;
  CLXREC.CLXCPROC = "CL02SMO"; /* current*/
  ;
  ;
    /* get customer company row*/
  ;
  set KUMREC empty;
  set KUCREC empty;
  set SQLCA empty;
  KUMREC.KUCCOID = CLAREC.KUCCOID;
  KUMREC.KUMSTRID = CLAREC.KUMSTRID;
  ;
  call "IO0340" ("S ", SQLCA, KUMREC) {isNoRefresh = yes, isExternal = yes}; /* select unique*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    CLWREC.KUCCONM = KUMREC.KUMSTRNM; /* hold cust name to pass along*/
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      set KUMREC empty;
    else
      TA1REC.TA1DBASE = "DCUST";
      TA1REC.TA1TBLVU = "VCMPNY";
      CLXREC.CLXORDIV = CLAREC.KUCCOID;
      TA1REC.TA1TBLKE = CLXREC.CLXORDIV;
      XPCL010();
    end
  end
  ;
      /* get customer legal entiy  xlecd*/
  set SQLCA empty;
  KUCREC.KUCCOID = CLAREC.KUCCOID;
  ;
  call "IO0240" ("S ", SQLCA, KUCREC) {isNoRefresh = yes, isExternal = yes}; /* select unique*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    CLWREC.XLECD = KUCREC.XLECD; /* hold cust legal entity to pass*/
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      set KUCREC empty;
    else
      TA1REC.TA1DBASE = "DCUST";
      TA1REC.TA1TBLVU = "VCMPNY";
      CLXREC.CLXORDIV = CLAREC.KUCCOID;
      TA1REC.TA1TBLKE = CLXREC.CLXORDIV;
      XPCL010();
    end
  end
  ;
    /* get claim Return Auth Header row*/
  ;
  set CLJREC empty;
  set SQLCA empty;
  CLJREC.CLACLMNB = CLAREC.CLACLMNB;
  ;
  call "IO1270" ("S ", SQLCA, CLJREC) {isNoRefresh = yes, isExternal = yes}; /* select unique*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      set CLJREC empty;
    else
      TA1REC.TA1DBASE = "DCLAIM";
      TA1REC.TA1TBLVU = "VRAHDR";
      CLXREC.CLXORDIV = CLAREC.CLACLMNB;
      TA1REC.TA1TBLKE = CLXREC.CLXORDIV;
      XPCL010();
    end
  end
  ;
  ;
end // end KL02SMO

// Search for Sample Rtn Comments
Function KL02SSC()
   /* ***********************************************************/
   /* *  Check the Claims Comments Table for Sample Return     **/
   /* *  claim pair comment(claim type code = 'S ') on a claim.**/
   /* *  If found move comment to cl02w01 for use showing on   **/
   /* *  map cl02m001.                                         **/
   /* ***********************************************************/
   /* *  MAINTENANCE HISTORY                                   **/
   /* *  10-16-90  gdecke  created                             **/
   /* ***********************************************************/
  CLXREC.CLXCPROC = "CL02SSC"; /* set current process name*/
  set CLGREC empty; /* init. claims comment record*/
  set SQLCA empty; /* init. sqlca*/
  CLGREC.CLACLMNB = CLAREC.CLACLMNB; /* claim nbr*/
  CLGREC.CLHSEQNB = 1; /* claim sequence number*/
  CLGREC.CL2ISNBR = 0; /* inspection number*/
  CLGREC.CLGCMSEQ = 1; /* comment sequence number*/
  CLGREC.CLGCMTYP = "S ";
                                   /* look for only claim-hdr type comments*/
  call "IO1260" ("S ", SQLCA, CLGREC) {isNoRefresh = yes, isExternal = yes}; /* CK FOR CLM HDR COMMENTS*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0) /* row found*/
    CL02W01.CLGCOMNT = CLGREC.CLGCOMNT; /* move comment to w/s table*/
    CL02W01.CL02WSAM = "Y"; /* turn on sample claim indicator*/
  else
    if (SQLCA.VAGen_SQLCODE == +100) /* row not found*/
      CL02W01.CLGCOMNT = " "; /* clear comment on w/s table*/
    else
      TA1REC.TA1DBASE = "DCLAIM"; /* bad sql code, so abend*/
      TA1REC.TA1TBLVU = "VCLCOM01";
      CLXREC.XXXWDTE = CLAREC.CLACLMNB; /* move to num field*/
      TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* and then to key*/
      XPCL010(); /* std abend routine for claims*/
    end
  end
end // end KL02SSC

//*** RECORD=CL02W01 ****
// working-storage for CL02
// 
// hold data here for use in application
// 
// duplicate of map.  Used to tell if map changed and field
// needs to be edited.
// 
// hold rtn number and inspection number to pass to next applic
// 
// ============================================================
// 02-13-97   kshaw   added cl2rtndx to replace clxlinex
//                    because the number of returns outgrew
//                    the size of clxlinex.
//                    clxlinex num 2   old
//                    cl2rtndx bin 4   new
//                    Increase size of:
//                    cl02mslr   100 to 200
//                    cllrtnnb   100 to 200
// ============================================================
// ***********************
Record CL02W01 type basicRecord
  10 CLACLMNB CLACLMNB ; 
  10 CL02WFST CL02WFST ; 
  10 CL02WCHG CL02WCHG ; 
  10 CL02WMOD CL02WMOD ; 
  10 CL02WUDF CL02WUDF ; 
  10 CL02WMOR CL02WMOR ; 
  10 CL02WNRT CL02WNRT ; 
  10 CL02WDRT CL02WDRT ; 
  10 CL02WSRT CL02WSRT ; 
  10 CL02WNIS CL02WNIS ; 
  10 CL02WDIS CL02WDIS ; 
  10 CL02WMXR CL02WMXR ; 
  10 CL02WMXI CL02WMXI ; 
  10 CL02MQTY CL02MQTY ; 
  10 CL02MTRC CL02MTRC ; 
  10 CL02MRC2 CL02MRC2 ; 
  10 CL02MTIQ CL02MTIQ ; 
  10 CL02MIQ2 CL02MIQ2 ; 
  10 CL02MTIA CL02MTIA ; 
  10 CLLNBRCV CLLNBRCV ; 
  10 XXXCURDT XXXCURDT ; 
    15 * num(2) ; 
    15 CL02WTDY CL02WTDY ; 
  10 XXXRVNBR XXXRVNBR ; 
  10 CL02WARY CL02WARY ; 
    15 CL02MSLR CL02MSLR [200] ; 
    15 CLLRTNNB CLLRTNNB [200] ; 
  10 CL02WINF CL02WINF ; 
  10 CL02WRFF CL02WRFF ; 
  10 CL02WNCF CL02WNCF ; 
  10 CL02WSWF CL02WSWF ; 
  10 CL02WCCF CL02WCCF ; 
  10 CL02WSAM CL02WSAM ; 
  10 CLGCOMNT CLGCOMNT ; 
    15 CL02WCLM CL02WCLM ; 
    15 * char(51) ; 
  10 CL2RTNDX CL2RTNDX ; 
end // end CL02W01

Record CL02W02 type basicRecord
  5 CL02WIDX CL02WIDX ; 
  5 CL02WBTF CL02WBTF ; 
  5 CL02WTBL CL02WTBL [100] ; 
    10 CL02WSLI CL02WSLI ; 
    10 CL2ISNBR CL2ISNBR ; 
    10 YCICD YCICD ; 
    10 CL02WQTY CL02WQTY ; 
    10 CLHMEMNB CLHMEMNB ; 
    10 CLHSEQNB CLHSEQNB ; 
    10 CLHMEMAM CLHMEMAM ; 
end // end CL02W02

// total inspected qty today
DataItem CL02MIQ2 num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = nullFill, inputRequired = no
}
end

// inspected quantity (units)
DataItem CL02MQTY num(8)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = nullFill, inputRequired = no
}
end

// total returned cartons today
DataItem CL02MRC2 num(5)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// select return
DataItem CL02MSLR char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// total inspected amount
DataItem CL02MTIA num(12,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = nullFill, inputRequired = no
}
end

// total inspected quantity
DataItem CL02MTIQ num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = nullFill, inputRequired = no
}
end

// total returned cartons
DataItem CL02MTRC num(5)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = nullFill, inputRequired = no
}
end

// match map arry:rtns & inspecs
DataItem CL02WARY char(600)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// build table (Y/N)
DataItem CL02WBTF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Claim Hdr Comments Flag
DataItem CL02WCCF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// clm nbr changed y/n
DataItem CL02WCHG char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// claim number
DataItem CL02WCLM num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// number inspections deleted
DataItem CL02WDIS smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// number returns deleted
DataItem CL02WDRT smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// first claim for applic y/n
DataItem CL02WFST char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Index for table
DataItem CL02WIDX smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// INSP disp exists for claim fl
DataItem CL02WINF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// clm nbr changed 'modified'
DataItem CL02WMOD char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// have more than 8 lines
DataItem CL02WMOR char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// max nbr inspec in array
DataItem CL02WMXI smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// max nbr returns in array
DataItem CL02WMXR smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// NCLM disp exists for claim fl
DataItem CL02WNCF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// number inspections selected
DataItem CL02WNIS smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// number returns selected
DataItem CL02WNRT smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Total qty for inspection
DataItem CL02WQTY int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// RFSD disp exists for claim fl
DataItem CL02WRFF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// sales sample claim flag
DataItem CL02WSAM char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// selection code
DataItem CL02WSLI char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// solitary return flag
DataItem CL02WSRT char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// sales sample warning msg flag
DataItem CL02WSWF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Inspections table
DataItem CL02WTBL char(22)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// map date yymmdd
DataItem CL02WTDY num(6)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// user has change authority
DataItem CL02WUDF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// return index
DataItem CL2RTNDX smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

