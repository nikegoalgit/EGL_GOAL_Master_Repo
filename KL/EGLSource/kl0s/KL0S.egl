package kl0s;

import corpcom1.*;
import corpcom3.XPCL002;
import corpcom3.XPCL010;
import corpcom3.XPCL011;
import corpcom4.XSCLSFL;
import corpcom4.XSENTRY;
import corpcom4.XSPF4;
import corpcom4.XSSEGTR;
import corpcom5.CLYREC;
import corpcom5.COMMAREA;
import corpcom5.ERRSQLCA;
import corpcom6.SQLCA;
import corpcom7.XXXRVNBR;
import corpx1.XGPTBL;
import corpx2.XXXUSRID;
import corpy2.YATTBL;
import corpy2.YCEADJRQ;
import corpy2.YCEAOVRF;
import corpy2.YCECD;
import corpy2.YCEDESC;
import corpy2.YCETBL;
import corpy2.YCRTBL;
import corpy2.YCSTBL;
import corpy2.YCTTBL;
import corpy2.YUATBL;
import corpz3.ZZZCHGCT;
import corpz3.ZZZCHGDT;
import ku.common.KUCREC;
import ta.common.TA1REC;
import ta.common.TA2REC;
//*** PROGRAM=KL0S ****
// ************************************************************
// kL0S - Claims Exceptions Display/Override
// 
// overview: The purpose of this application is to display the
//           exceptions for the claim. All exceptions will be
//           retained, even after the error has been corrected.
//           Some of the exceptions the user will be able to
//           override on this application and others they will
//           need to go to the appropriate application and make
//           the necessary changes.
// 
// 
// ************************************************************
// 
// Maintenance History:
// 
//   Date    Who     Description of Change
// --------  ---     ------------------------------------------
// 08-23-88  MHALST  Program Creation
// 12-16-88  mhalst  Correct program to look at commarea and
//                   clwrec to set inquiry mode.
// 02-27-89  jwood   added noncsp option to calls
// 02-27-89  jwood   added xssegtr logic
// 05-19-89  bcourt  DB2 structure changes: CLAREC, KUCREC,
//                   XGPTBL.
// 01-19-90  chellm  DB2 structure changes regen only
// 06-10-91  twatso  DB2 structure changes: KUCREC: regen only
// 08-08-91  wjohns  Renamed application and commarea
//                     referrences to renamed claims appls.
// 01-13-92  sgorga  Set ta2rec empty.
// 10-29-93  GDECKE  CHANGE CLAREC.YCSCD TO CLAREC.YCSCD1
// 07-29-98  NJANA   Expand the working storage to load CLXCP01
//                   table to 400 from 150.
// ************************************************************
// *********************
Program KL0S type textUIProgram //VAGen Info - main text program
  {
  includeReferencedFunctions = yes, allowUnqualifiedItemReferences = yes, 
  throwNrfEofExceptions = yes, handleHardIOErrors = no, V60ExceptionCompatibility = yes, 
  I4GLItemsNullable = no, textLiteralDefaultIsString = no, localSQLScope = yes, 
  msgTablePrefix = "CL00", inputRecord = COMMAREA, segmented = yes
  }

  // Data Declarations
  CL0SW01 CL0SW01; // record
  CL0SW02 CL0SW02; // record
  CL1REC CL1REC; // record
  CLAREC CLAREC; // record
  CLWREC CLWREC; // record
  CLXREC CLXREC; // record
  CLYREC CLYREC; // record
  COMMAREA COMMAREA ; // record
  ERRSQLCA ERRSQLCA; // record
  KUCREC KUCREC; // record
  SQLCA SQLCA; // record
  TA1REC TA1REC; // record
  TA2REC TA2REC; // record

  // VAGen Info - items needed for migration
  VAGen_EZESYS char(8);
  VAGen_EZEREPLY num(1);
  VAGen_EZE_WAIT_TIME bin(9,2);
  VAGen_EZE_ITEMLEN int;

  // Use Declarations
  use XGPTBL {deleteAfterUse = yes}; // table
  use YATTBL {deleteAfterUse = yes}; // table
  use YCETBL {deleteAfterUse = yes}; // table
  use YCRTBL {deleteAfterUse = yes}; // table
  use YCSTBL {deleteAfterUse = yes}; // table
  use YCTTBL {deleteAfterUse = yes}; // table
  use YUATBL {deleteAfterUse = yes}; // table
  use KL0SM.KL0SM001 // form
   {
    pfKeyEquate = no
  };

  function main()
    // VAGen Info - initialization needed for migration
    VAGen_EZESYS = VGLib.getVAGSysType();
    KL0S000: KL0S000();
    KL0S001: KL0S001();
    KL0S050: KL0S050();
    KL0S100: KL0S100();
    KL0S101: KL0S101();
    KL0S110: KL0S110();
    KL0S120: KL0S120();
    KL0S200: KL0S200();
    KL0S130: KL0S130();
  end // end main
end // end KL0S

// application main logic
Function KL0S000()
   /* ************************************************************/
   /* *   this is the "main logic" for the application.         **/
   /* *                                                         **/
   /* *   xsentry checks to ensure that this application was    **/
   /* *         entered from another csp application.           **/
   /* *   xclentry checks to ensure that the claim header has   **/
   /* *         been flagged as "in use" if this application    **/
   /* *         does updates.                                   **/
   /* *                                                         **/
   /* *                                                         **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  ;
  KL0S001(); /* initilize the application*/
  ;
  CL0SW01.XXXRVNBR = "1"; /* appl maintainence revision number*/
  ;
  CLXREC.CLXEOAF = "N"; /* set end-of-application flag to 'no'*/
  ;
  while (CLXREC.CLXEOAF == "N") /* while not end-of-aplication*/
    KL0S050(); /* process the application screen(s)*/
  end
  ;
  COMMAREA.CATOAP = "KL0A";
  XPCL002();
end // end KL0S000

// initialize application
Function KL0S001()
   /* ************************************************************/
   /* *      initialize the application working storage         **/
   /* *                                                         **/
   /* *  describe what happens in this process                  **/
   /* *                                                         **/
   /* *                                                         **/
   /* *                                                         **/
   /* ************************************************************/
   /* TEMP001                         ;routine to jam commarea*/
  ;
  converseVar.commitOnConverse = 1; /* force db2 to commit on each screen converse*/
  VGVar.handleHardIOErrors = 1; /* return control to program if hard db2 error*/
  ;
  ;
  XSENTRY(); /* check entered thru main menu*/
  XSSEGTR(); /* set segmented transaction id*/
  set CLAREC empty; /* clear out header*/
  XPCL011(); /* claims entry module*/
  ;
  ;
  set CLXREC empty; /* clear out the "common" working*/
                                   /* storage*/
  ;
  ;
     /* put staements here to initalize your working-storage(s),*/
     /* e.g. constants, messages, '-' for dates.*/
  ;
  set KL0SM001 initial;
  set CL0SW01 empty;
  set CL0SW02 empty;
  set TA1REC empty;
  set TA2REC empty;
  set KUCREC empty;
  ;
  TA2REC.TA2DTOPT = "GETDATE"; /* get current date/time*/
  call "TA0040" (TA2REC) {isNoRefresh = yes, isExternal = yes};
  ;
  CL0SW01.XXXRVNBR = "00"; /* current revision*/
  CL0SW01.CL0SWINQ = "N"; /* default inquiry to no*/
  ;
  CLXREC.CLXEOAF = "N"; /* set application-done-switch to 'no'*/
  if (CLAREC.CLACLMNB != 0) /* we have a passed claim header*/
    CLXREC.CLXBLDSC = "Y"; /* set to build screen from commarea*/
  else /* no header*/
    CLWREC.CLWEZMNO = 236; /* claim number required*/
    COMMAREA.CATOAP = "KL0A"; /* get out if no header*/
    XPCL002();
  end
  ;
  ;
  CLXREC.CLXCSCRN = "KL0SM001"; /* set first screen name*/
  ;
  CLXREC.CLXSNAME[1] = "KL0SM001"; /* initialize the names of the*/
  ;
  CLXREC.CLXMAXLN[1] = 10; /* max lines on map 1*/
  CLXREC.CLXARY1X[1] = 1; /* start line on map 1*/
  ;
  CLXREC.CLXARAYX = 1; /* index to array*/
  CLXREC.CLXLINEX = 1; /* index to map line*/
  ;
  KL0S005(); /* build array & screen heading*/
  ;
end // end KL0S001

// Build array of exceptions
Function KL0S005()
   /* ************************************************************/
   /* *        This process performs the following functions:   **/
   /* *  1.  Build header portions of screen                    **/
   /* *  2.  Check user id against claims authorization table   **/
   /* *      and switch to inquiry mode if user is not author-  **/
   /* *      ized to override exceptions.                       **/
   /* *  3.  Build table of exceptions for claim.               **/
   /* ************************************************************/
   /* *    M A I N T E N A N C E     H I S T O R Y     L O G    **/
   /* *---------------------------------------------------------**/
   /* *   DATE   PGMR   DESCRIPTION                             **/
   /* *---------------------------------------------------------**/
   /* * 02-28-90 bcourt check for array maximum; show err message*/
   /* * 10-29-93 GDECKE  CHANGE CLAREC.YCSCD TO CLAREC.YCSCD1   **/
   /* * 07-29-98 NJANA   Change the maximum array(CLEXCP01)     **/
   /* *                  to 400 from 150                        **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0S005"; /* set current process name*/
  ;
  KL0SM001.CLACLMNB = CLAREC.CLACLMNB;
  KL0SM001.KUCCOID = CLAREC.KUCCOID;
  KL0SM001.KUMSTRID = CLAREC.KUMSTRID;
  KL0SM001.XNXCD = CLAREC.XNXCD;
  ;
  if (CLWREC.KUCCONM != " ") /* we allready have the name*/
    KL0SM001.KUCCONM = CLWREC.KUCCONM; /* so move it*/
  else /* we have to get it*/
    KUCREC.KUCCOID = CLAREC.KUCCOID;
    call "IO0240" ("S ", SQLCA, KUCREC) {isNoRefresh = yes, isExternal = yes}; /* try to find it*/
    if (SQLCA.VAGen_SQLCODE == 0)
      KL0SM001.KUCCONM = KUCREC.KUCCONM;
    else
      if (SQLCA.VAGen_SQLCODE == 100) /* not found*/
        KL0SM001.KUCCONM = "UNKNOWN CUSTOMER";
      else /* bad DB2 error*/
        TA1REC.TA1LOCAT[1] = CLXREC.CLXCPROC;
        TA1REC.TA1DBASE = "DCUST";
        TA1REC.TA1TBLVU = "VCMPNY01";
        XPCL010();
      end
    end
  end
  ;
  KL0SM001.YCSCD = CLAREC.YCSCD1; /* claim status*/
  if (KL0SM001.YCSCD in YCSTBL.YCSCD)
    KL0SM001.YCSSDESC = YCSTBL.YCSSDESC[sysVar.arrayIndex];
  else
    KL0SM001.YCSSDESC = "UNKNOWN";
  end
  ;
  KL0SM001.CLACTCNM = CLAREC.CLACTCNM; /* cust. contact*/
  ;
  KL0SM001.XGPCD = CLAREC.XGPCD; /* GPC code*/
  if (KL0SM001.XGPCD in XGPTBL.XGPCD)
    KL0SM001.XGPABRV = XGPTBL.XGPABRV[sysVar.arrayIndex];
  else
    KL0SM001.XGPABRV = "??????";
  end
  ;
  KL0SM001.YCTCD = CLAREC.YCTCD; /* claim type*/
  if (KL0SM001.YCTCD in YCTTBL.YCTCD)
    KL0SM001.YCTABRV = YCTTBL.YCTABRV[sysVar.arrayIndex];
  else
    KL0SM001.YCTABRV = "??????";
  end
  ;
  KL0SM001.YCRCD = CLAREC.YCRCD; /* claim reason*/
  if (KL0SM001.YCRCD in YCRTBL.YCRCD)
    KL0SM001.YCRSDESC = YCRTBL.YCRSDESC[sysVar.arrayIndex];
  else
    KL0SM001.YCRSDESC = "UNKNOWN";
  end
  ;
  KL0SM001.IV0IVCID = CLAREC.IV0IVCID; /* invoice number*/
  ;
  KL0SM001.OP1CUPO = CLAREC.OP1CUPO; /* customer po*/
  ;
  if (CLAREC.YCSCD1 in YCSTBL.YCSCD) /* if claim status in table*/
    if (YCSTBL.YCSAINPF[sysVar.arrayIndex] == "N") /* and allow input flag is no*/
      CL0SWINQ = "Y"; /* then force program to inquiry*/
    end
  end
  ;
   /* now check if this user can override exceptions*/
  ;
  KL0SS35(); /* set inquiry flag*/
  ;
   /* now we will get and load all exception records*/
  ;
  CL1REC.CLACLMNB = CLAREC.CLACLMNB;
  call "IO2840" ("S1", SQLCA, CL1REC) {isNoRefresh = yes, isExternal = yes}; /* get set of records*/
  if (SQLCA.VAGen_SQLCODE != 0) /* we got problems*/
    TA1REC.TA1LOCAT[1] = CLXREC.CLXCPROC;
    TA1REC.TA1LOCAT[2] = "OPEN";
    TA1REC.TA1DBASE = "DCLAIM";
    TA1REC.TA1TBLVU = "VCLXCP01";
    XPCL010();
  end
  ;
  CL0SW02.CL0SWAS = 0; /* number of items is 0*/
  CL0SW02.CL0SWAX = 0; /* start index at zero*/
  while (SQLCA.VAGen_SQLCODE == 0) /* start loading*/
    call "IO2840" ("N1", SQLCA, CL1REC) {isNoRefresh = yes, isExternal = yes}; /* get next record*/
    if (SQLCA.VAGen_SQLCODE == 100) /* at end*/
      call "IO2840" ("C1", SQLCA, CL1REC) {isNoRefresh = yes, isExternal = yes}; /* close set*/
      SQLCA.VAGen_SQLCODE = 100; /* to break out of while loop*/
    else
      if (SQLCA.VAGen_SQLCODE != 0) /* we got problems*/
        TA1REC.TA1LOCAT[1] = CLXREC.CLXCPROC;
        TA1REC.TA1LOCAT[2] = "FETCH";
        TA1REC.TA1DBASE = "DCLAIM";
        TA1REC.TA1TBLVU = "VCLXCP01";
        XPCL010();
      else
        CL0SW02.CL0SWAS = CL0SW02.CL0SWAS + 1; /* max aray index loaded*/
        CL0SW02.CL0SWAX = CL0SW02.CL0SWAX + 1; /* aray index*/
        CL0SW02.CL2ISNBR[CL0SWAX] = CL1REC.CL2ISNBR;
        CL0SW02.CLLRTNNB[CL0SWAX] = CL1REC.CLLRTNNB;
        CL0SW02.YCECD[CL0SWAX] = CL1REC.YCECD;
        if (CL1REC.YCECD in YCETBL.YCECD)
          CL0SW02.YCEDESC[CL0SWAX] = YCETBL.YCEDESC[sysVar.arrayIndex];
          CL0SW02.YCEAOVRF[CL0SWAX] = YCETBL.YCEAOVRF[sysVar.arrayIndex];
          CL0SW02.YCEADJRQ[CL0SWAX] = YCETBL.YCEADJRQ[sysVar.arrayIndex];
        else
          CL0SW02.YCEDESC[CL0SWAX] = "UNKNOWN";
          CL0SW02.YCEAOVRF[CL0SWAX] = "N";
          CL0SW02.YCEADJRQ[CL0SWAX] = "N";
        end
        if (CL1REC.CL1XOFL != " " /* flag changed before*/
         && CL1REC.ZZZCHGDT != TA2REC.TA2GRGGN) /* and different date*/
          CL0SW02.YCEAOVRF[CL0SWAX] = "N"; /* so protect*/
        end
        CL0SW02.CL1XOFL[CL0SWAX] = CL1REC.CL1XOFL;
        CL0SW02.CL1CLMN2[CL0SWAX] = CL1REC.CL1CLMN2;
        CL0SW02.XXXUSRID[CL0SWAX] = CL1REC.XXXUSRID;
        CL0SW02.ZZZCHGDT[CL0SWAX] = CL1REC.ZZZCHGDT;
        CL0SW02.ZZZCHGCT[CL0SWAX] = CL1REC.ZZZCHGCT;
      end
    end
  end
  CL0SW02.CL0SWAX = 1; /* and reset to 1*/
  ;
   /* TCS change begins- 07/29/98*/
  if (CL0SW02.CL0SWAS > 400) /* 07-29-98 check array physical maximum*/
    CL0SW02.CL0SWAS = 400; /* reset to max*/
    converseLib.validationFailed(610); /* call user analyst to change program*/
    CLXREC.CLXERRF = "Y";
    CLXREC.CLXUPDTF = "N"; /* stop update*/
  end
   /* TCS change ends  - 07/29/98*/
  ;
end // end KL0S005

// Main CL0W branch control
Function KL0S050()
   /* ************************************************************/
   /* *   control process the application screen(s)             **/
   /* *                                                         **/
   /* *  note that this process is being performed in a         **/
   /* *  "while loop" until the end-of-application flag is set  **/
   /* *  to 'y'.                                                **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0S050"; /* set current process name*/
  ;
  ;
  if (CLXREC.CLXCSCRN in CLXREC.CLXSNAME) /* if current-screen-name is*/
    CLXREC.CLXSCRNX = sysVar.arrayIndex; /* in the screen-array, then set*/
  end /* the screen-index*/
  ;
  ;
  CLXREC.CLXEOSF = "N"; /* set end-of-screen flag to 'no'*/
  CLXREC.CLXERRF = "N"; /* reset error flag*/
  ;
  if (CLXREC.CLXSCRNX == 1) /* if screen CL0WM001*/
    while (CLXREC.CLXEOSF == "N") /* while not end-of-screen*/
      KL0S100(); /* process screen CL0WM001*/
    end
  else
    TA1REC.TA1TBLKE = "CLAIMS UNKNOWN SCREEN NAME";
    XPCL010();
  end
  ;
  ;
   /* at this point;*/
       /* if the end-of-application flag (clxeoaf ) = 'n'*/
         /* the perform will return to the top of CL0W050...*/
       /* else*/
         /* the perform will auto return to CL0W000.*/
  ;
  ;
  ;
end // end KL0S050

// Claim Exceptions Screen
Function KL0S100()
   /* ************************************************************/
   /* *    process screen CL0SM001                              **/
   /* *                                                         **/
   /* *  note - this process is being performed in a            **/
   /* *     "while loop" from CL0S050 until the end-of-screen   **/
   /* *     flag (clxeosfl) is set to 'y'.                      **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0S100"; /* set current process name*/
  KL0SM001.XXXPRCNM = "KL0S100"; /* and move to screen*/
  ;
  if (CLXREC.CLXBLDSC == "Y")
    KL0S101(); /* build screen because new record*/
  end /* to display or pf7/pf8 keyed*/
  ;
  CLXREC.CLXBLDSC = "N"; /* skip build screen next time thru*/
    /* skip build when have errors to show, or pf12 was keyed*/
  ;
  KL0SM001.XXXPRCNM = "KL0S100"; /* move process name*/
  KL0SM001.XXXCURDT = VGVar.currentShortGregorianDate; /* move in date*/
  KL0SM001.XXXRVNBR = CL0SW01.XXXRVNBR; /* and rev. number*/
  ;
  converse KL0SM001 ;
  ;
  ;
  CLXREC.CLXMSG = " "; /* set non-ezemno error message to space*/
  CLXREC.CLXERRF = "N"; /* re-set error flag*/
  ;
  CLXREC.CLXEDITF = "N"; /* reset edits flag*/
  KL0SS25(); /* reset screen and check for entries*/
  ;
  KL0S110(); /* handle any special entries*/
    /* may exit appl from this process*/
  ;
  ;
  if (CLXREC.CLXEDITF == "Y") /* if we still want to edit*/
    KL0S120(); /* go edit screen entries*/
  end
  ;
      /* determine next action*/
  ;
  if (CLXREC.CLXERRF == "Y" /* if screen has errors*/
   || converseVar.eventKey is pf12) /* or user wants to see same screen*/
    CLXREC.CLXBLDSC = "N"; /* do not rebuild screen, just reshow*/
  else
    if (CLXREC.CLXUPDTF == "Y") /* need to do updates*/
      KL0S200(); /* go update data base*/
    end
    KL0S130(); /* act upon enter/pf key*/
  end
  ;
  ;
  ;
   /* at this point;*/
     /* if the end-of-screen flag (clxeosf) is 'n'*/
       /* the perform returns to top of process cl0%100.*/
     /* else*/
       /* the perform returns to cl0%050.*/
  ;
  ;
  ;
end // end KL0S100

// Initialize screen CL0SM001
Function KL0S101()
   /* ************************************************************/
   /* *        This process will build the lower portion of     **/
   /* *  the screen from the table of exceptions for this claim **/
   /* *  The starting index has allready been set, so all we    **/
   /* *  have to do is load the 10 lines of array info onto     **/
   /* *  the screen.                                            **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0S101"; /* set current process name*/
  ;
  CLXREC.CLXLINEX = 1; /* reset screen index*/
  CL0SW01.CL0SWCFL = "N"; /* cursor position flag*/
  CLXREC.CLXARAYX = CL0SW02.CL0SWAX;
  while (CLXREC.CLXLINEX <= CLXREC.CLXMAXLN[CLXSCRNX])
    if (CLXREC.CLXARAYX > CL0SW02.CL0SWAS) /* past array max*/
      KL0SM001.CL0SMIRN[CLXLINEX] = " ";
      KL0SM001.YCECD[CLXLINEX] = " ";
      KL0SM001.YCEDESC[CLXLINEX] = " ";
      KL0SM001.YCEAOVRF[CLXLINEX] = " ";
      set KL0SM001.YCEAOVRF[CLXLINEX] skip, invisible;
      KL0SM001.CL0SMACN[CLXLINEX] = 0;
      set KL0SM001.CL0SMACN[CLXLINEX] skip, invisible;
      KL0SM001.XXXUSRID[CLXLINEX] = " ";
      KL0SM001.CL0SMDTE[CLXLINEX] = 0;
    else
      if (CL0SW02.CL2ISNBR[CLXARAYX] != 0)
        KL0SM001.CL0SMIRN[CLXLINEX] = CL0SW02.CL2ISNBR[CLXARAYX];
      else
        KL0SM001.CL0SMIRN[CLXLINEX] = CL0SW02.CLLRTNNB[CLXARAYX];
      end
      KL0SM001.YCECD[CLXLINEX] = CL0SW02.YCECD[CLXARAYX];
      KL0SM001.YCEDESC[CLXLINEX] = CL0SW02.YCEDESC[CLXARAYX];
      KL0SM001.YCEAOVRF[CLXLINEX] = CL0SW02.CL1XOFL[CLXARAYX];
      if (CL0SW02.YCEAOVRF[CLXARAYX] == "Y" /* override allowed*/
       && CL0SW01.CL0SWINQ == "N")          /* and not inquiry mode*/
        set KL0SM001.YCEAOVRF[CLXLINEX] normal;
        if (CL0SW01.CL0SWCFL == "N") /* have not set cursor position*/
          set KL0SM001.YCEAOVRF[CLXLINEX] cursor; /* so set it*/
          CL0SW01.CL0SWCFL = "Y"; /* and set flag*/
        end
      else
        set KL0SM001.YCEAOVRF[CLXLINEX] skip;
        set KL0SM001.CL0SMACN[CLXLINEX] skip;
      end
      KL0SM001.CL0SMACN[CLXLINEX] = CL0SW02.CL1CLMN2[CLXARAYX];
      if (CL0SW02.YCEADJRQ[CLXARAYX] == "Y" /* adj clm can be entered*/
       && CL0SW01.CL0SWINQ == "N")          /* and not inquiry mode*/
        set KL0SM001.CL0SMACN[CLXLINEX] normal;
      else
        set KL0SM001.CL0SMACN[CLXLINEX] skip, invisible;
      end
      KL0SM001.XXXUSRID[CLXLINEX] = CL0SW02.XXXUSRID[CLXARAYX];
      CLXREC.XXXWDTE = CL0SW02.ZZZCHGDT[CLXARAYX];
      KL0SM001.CL0SMDTE[CLXLINEX] = CLXREC.XXXWYMD;
      CLXREC.CLXARAYX = CLXREC.CLXARAYX + 1;
    end
    CLXREC.CLXLINEX = CLXREC.CLXLINEX + 1;
  end
  if (CL0SW01.CL0SWCFL == "N") /* cursor position not set*/
    set KL0SM001.CATOAP cursor; /* so put it on the bottom*/
  end
  ;
end // end KL0S101

// Validate PF keys
Function KL0S110()
   /* ************************************************************/
   /* *  validate pf keys                                       **/
   /* *                                                         **/
   /* *  the only keys acted upon at this time are pf 1, 3 & 4  **/
   /* *  and fastpath                                           **/
   /* *                                                         **/
   /* *  the other keys are just verified that they are used    **/
   /* *  by this application.  if the pf key is not recognized, **/
   /* *  the application resets all modified fields to remain   **/
   /* *  modified, then reshows the map with an error message.  **/
   /* *                                                         **/
   /* *  these other pf keys are acted upon after the editing   **/
   /* *  and updating have occured.                             **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0S110"; /* set current process name*/
  ;
     /* if you want to use pa2 to ezeclos, for testing only,*/
     /* then use stmnt group 'tests01' or some non-std name*/
  ;
  ;
  ;
  if (converseVar.eventKey is enter) /* normal 'enter'*/
    if (KL0SM001.CATOAP != " ") /* if fastpath option entered,*/
      COMMAREA.CATOAP = KL0SM001.CATOAP;
      COMMAREA.CAITEM = KL0SM001.CAITEM;
      XPCL002(); /* exit application*/
    end
    return;
  end
  ;
  if (converseVar.eventKey is pf1) /* 'help'*/
    KL0SS01();
  end
  ;
  if (converseVar.eventKey is pf3)
    KL0SS03(); /* skip edit, update - exit*/
  end
  ;
  if (converseVar.eventKey is pf4)
    KL0SS04(); /* skip edit, update - exit*/
  end
  ;
  if (converseVar.eventKey is pf5 /* goto claim header*/
   || converseVar.eventKey is pf7 /* scroll backward*/
   || converseVar.eventKey is pf8) /* scroll forward*/
    return; /* do update, then perform PF function*/
  end
  ;
  if (converseVar.eventKey is pf12) /* validate only*/
    return;
  end
  ;
  if (converseVar.eventKey is pa1
   || converseVar.eventKey is pa2
   || converseVar.eventKey is pa3)
    converseLib.validationFailed(62); /* pa keys cause loss of data*/
    converseLib.clearScreen();
     /* redisplay map*/
    CLXREC.CLXERRF = "Y";
    return;
  end
  ;
  ;
   /* other pf keys follow the same format*/
  ;
   /* if ezeaid is pf key ??*/
     /* ezertn*/
   /* end*/
  ;
  ;
  ;
      /* pf key not valid*/
  ;
  converseLib.validationFailed(2); /* pf key not valid*/
  CLXREC.CLXEDITF = "N"; /* do not edit map, just re-show it*/
  CLXREC.CLXERRF = "Y"; /* and set error flag*/
  ;
  ;
end // end KL0S110

// Process screen M001 entries
Function KL0S120()
   /* ************************************************************/
   /* *     this process handles all edits of screen fields,    **/
   /* *          and any subsequent updating, required by       **/
   /* *          entries into screen CL0SM001                   **/
   /* *                                                         **/
   /* *     Note that if claim/user is inquiry only,            **/
   /* *     all fields are protected so nothing can get         **/
   /* *     changed.                                            **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0S120"; /* set current process name*/
  ;
  CLXREC.CLXUPDTF = "N"; /* reset update flag*/
  CLXREC.CLXLINEX = CLXREC.CLXMAXLN[CLXSCRNX];
  CLXREC.CLXARAYX = CL0SW02.CL0SWAX; /* and table index*/
  CLXREC.CLXARAYX = CLXREC.CLXARAYX + CLXREC.CLXMAXLN[CLXSCRNX];
  CLXREC.CLXARAYX = CLXREC.CLXARAYX - 1; /* so we look at proper line*/
  while (CLXREC.CLXLINEX >= 1)
    if (CLXREC.CLXARAYX > CL0SW02.CL0SWAS) /* past array max*/
      /* next sentence (user can't change line)*/
    else
      if (KL0SM001.YCEAOVRF[CLXLINEX] == CL0SW02.CL1XOFL[CLXARAYX]
       && KL0SM001.CL0SMACN[CLXLINEX] == CL0SW02.CL1CLMN2[CLXARAYX])
        /* next sentence (user didn't change anything)*/
      else
        CLXREC.CLXUPDTF = "Y"; /* will update*/
        KL0SS31(); /* validate screen line*/
      end
    end
    CLXREC.CLXLINEX = CLXREC.CLXLINEX - 1;
    CLXREC.CLXARAYX = CLXREC.CLXARAYX - 1;
  end
  ;
  if (CLXREC.CLXERRF == "Y" /* have errors*/
   || converseVar.eventKey is pf12) /* or validate only*/
    CLXREC.CLXUPDTF = "N"; /* not ok to update*/
  end
end // end KL0S120

// Act upon valid PF keys, map 1
Function KL0S130()
   /* ************************************************************/
   /* *  act upon pf keys                                       **/
   /* *                                                         **/
   /* *  pf 1, 3, 4, 7, 8, 10, 11 & 12 were acted upon in       **/
   /* *  cl0%110.                                               **/
   /* *                                                         **/
   /* *  the other pf keys are acted upon here, after editing   **/
   /* *  and updating have occured.                             **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0S130"; /* set current process name*/
  ;
  if (converseVar.eventKey is enter)
    if (CLXREC.CLXEDITF == "N") /* nothing entered on screen*/
      KL0S131(); /* set transfer-to appl*/
      XPCL002();
    end
    return; /* enter is ok*/
  end
  ;
  if (converseVar.eventKey is pf5) /* transfer to claim header (CL0E)*/
    KL0SS05();
    return;
  end
  ;
  if (converseVar.eventKey is pf7) /* scroll backward*/
    KL0SS07();
    return;
  end
  ;
  if (converseVar.eventKey is pf8) /* scroll forward*/
    KL0SS08();
    return;
  end
  ;
      /* pf key not valid*/
  ;
  converseLib.validationFailed(2); /* pf key not valid*/
  CLXREC.CLXEDITF = "N"; /* do not edit map, just re-show it*/
  ;
  ;
  ;
end // end KL0S130

// set up 'enter' flow
Function KL0S131()
   /* ************************************************************/
   /* *     this process handles the control of flow to the     **/
   /* *        next application when the enter key is pressed.  **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0S131"; /* set current process name*/
  ;
  ;
  if (CLAREC.YITCD == "Y" /* addl ibm invoices*/
   || CLAREC.YITCD == "A" /* addl dec invoices*/
   || CLAREC.YITCD == "M") /* addl old ibm invoices*/
    COMMAREA.CATOAP = "KL0N";
    return;
  end
  ;
  ;
  XSCLSFL(); /* set next application*/
  ;
  ;
end // end KL0S131

// Add/Update Claims Records
Function KL0S200()
   /* ************************************************************/
   /* *     This process will insert and/or change all claim    **/
   /* *     records required.                                   **/
   /* ************************************************************/
   /* MAINTENANCE HISTORY                           **/
   /* 01-13-92  sgorga  Set ta2rec empty.                       **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0S200"; /* set process name*/
  ;
   /* First we get the current date & time to put in the records*/
  set TA2REC empty;
  TA2REC.TA2DTOPT = "GETDATE"; /* get current date/time*/
  call "TA0040" (TA2REC) {isNoRefresh = yes, isExternal = yes};
  ;
   /* Now figure out what exceptions to update*/
  ;
  CLXREC.CLXLINEX = 1; /* reset screen index*/
  CLXREC.CLXARAYX = CL0SW02.CL0SWAX;
  while (CLXREC.CLXLINEX <= CLXREC.CLXMAXLN[CLXSCRNX])
    if (CLXREC.CLXARAYX > CL0SW02.CL0SWAS /* past array max*/
     || CLXREC.CLXERRF == "Y")            /* or had errors*/
      CLXREC.CLXLINEX = 25; /* so we can stop loop*/
    else
      if (CL0SW02.CL1XOFL[CLXARAYX] != KL0SM001.YCEAOVRF[CLXLINEX]
       || CL0SW02.CL1CLMN2[CLXARAYX] != KL0SM001.CL0SMACN[CLXLINEX])
        KL0SS41(); /* go and update exception*/
      end
    end
    CLXREC.CLXLINEX = CLXREC.CLXLINEX + 1;
    CLXREC.CLXARAYX = CLXREC.CLXARAYX + 1;
  end
  if (CLXREC.CLXERRF == "Y") /* we had update problems*/
    return; /* so stop updating*/
  end
  ;
   /* Now update the claim header*/
  ;
  call "IO1160" ("S ", SQLCA, CLAREC) {isNoRefresh = yes, isExternal = yes}; /* get current header*/
  if (SQLCA.VAGen_SQLCODE != 0) /* bad problems*/
    TA1REC.TA1DBASE = "DCLAIM";
    TA1REC.TA1TBLVU = "VCLHDR01";
    TA1REC.TA1TBLKE = "READ FOR UPDATE";
    XPCL010();
  end
  ;
  if (CLAREC.YCSCD1 in YCSTBL.YCSCD) /* if in table*/
    CLAREC.YCSACTCD = YCSTBL.YCSACTCD[sysVar.arrayIndex];
  end
  CLAREC.ZZZCHGDT = TA2REC.TA2GRGGN;
  CLAREC.ZZZCHGTM = TA2REC.TA2TIMHM;
  call "IO1160" ("U ", SQLCA, CLAREC) {isNoRefresh = yes, isExternal = yes}; /* update it*/
  if (SQLCA.VAGen_SQLCODE == 100) /* record changed by another user*/
    converseLib.validationFailed(18); /* record changed by another user*/
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.rollback();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
     /* restore records*/
    CLXREC.CLXERRF = "Y";
    return;
  else
    if (SQLCA.VAGen_SQLCODE != 0) /* bad problems*/
      TA1REC.TA1DBASE = "DCLAIM";
      TA1REC.TA1TBLVU = "VCLHDR01";
      XPCL010();
    end
  end
  ;
   /* Now update our internal table*/
  ;
  CLXREC.CLXLINEX = 1; /* reset screen index*/
  CLXREC.CLXARAYX = CL0SW02.CL0SWAX;
  while (CLXREC.CLXLINEX <= CLXREC.CLXMAXLN[CLXSCRNX])
    if (CLXREC.CLXARAYX > CL0SW02.CL0SWAS) /* past array max*/
      CLXREC.CLXLINEX = 25; /* so we can stop loop*/
    else
      if (CL0SW02.CL1XOFL[CLXARAYX] != KL0SM001.YCEAOVRF[CLXLINEX]
       || CL0SW02.CL1CLMN2[CLXARAYX] != KL0SM001.CL0SMACN[CLXLINEX])
        CL0SW02.CL1XOFL[CLXARAYX] = KL0SM001.YCEAOVRF[CLXLINEX];
        CL0SW02.CL1CLMN2[CLXARAYX] = KL0SM001.CL0SMACN[CLXLINEX];
        CL0SW02.XXXUSRID[CLXARAYX] = COMMAREA.CAUSERID;
        KL0SM001.XXXUSRID[CLXLINEX] = COMMAREA.CAUSERID;
        CL0SW02.ZZZCHGDT[CLXARAYX] = TA2REC.TA2GRGGN;
        KL0SM001.CL0SMDTE[CLXLINEX] = TA2REC.TA2GRGGN;
      end
    end
    CLXREC.CLXLINEX = CLXREC.CLXLINEX + 1;
    CLXREC.CLXARAYX = CLXREC.CLXARAYX + 1;
  end
  ;
   /* and finally, commit db2 changes*/
  ;
  VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
  VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
  sysLib.commit();
  VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
  
  ;
end // end KL0S200

// pf1 help
Function KL0SS01()
  ;
  ;
  ;
      /* skip edits/updates, exit to goal documentation*/
  ;
  COMMAREA.CAFROMAP = COMMAREA.CACURRAP;
  COMMAREA.CACURRAP = "GD0G";
  transfer to program "GD0G" passing COMMAREA;
  ;
  TA1REC.TA1TBLKE = "CANT TRANSFER TO GD0G REQUESTED APPL";
  XPCL010(); /* serious error if cant*/
                                   /* transfer...abend*/
  ;
  ;
  ;
end // end KL0SS01

// pf3 exit to claims
Function KL0SS03()
  ;
  ;
  ;
      /* skip edits/update, go to higher level in claims*/
  ;
  ;
  COMMAREA.CATOAP = "KL0A"; /* go to claims menu*/
  ;
  XPCL002(); /* common claims exit*/
  ;
  ;
  ;
end // end KL0SS03

// pf4 exit to master menu
Function KL0SS04()
  ;
  ;
  ;
      /* skip edits/update, go to goal master menu*/
  ;
  XSPF4(); /* go and do it*/
  ;
end // end KL0SS04

// pf5 exit to CL0E (Claim hdr)
Function KL0SS05()
  ;
      /* skip edits/update, go to higher level in claims*/
  ;
  ;
  COMMAREA.CATOAP = "KL0E"; /* go to claim header*/
  ;
  XPCL002(); /* common claims exit*/
  ;
  ;
  ;
end // end KL0SS05

// Scroll Backward
Function KL0SS07()
  ;
      /* Scroll screen backward*/
  ;
  ;
  if (CL0SW02.CL0SWAX == 1) /* can't scroll back any more*/
    converseLib.validationFailed(7); /* at top of data*/
    CLXREC.CLXERRF = "Y";
  else
    CL0SW02.CL0SWAX = CL0SW02.CL0SWAX - CLXREC.CLXMAXLN[CLXSCRNX];
    if (CL0SW02.CL0SWAX < 1)
      CL0SW02.CL0SWAX = 1;
    end
    CLXREC.CLXBLDSC = "Y";
  end
  ;
  ;
end // end KL0SS07

// Scroll Forward
Function KL0SS08()
  ;
      /* Scroll screen Forward*/
  ;
  ;
  CL0SW02.CL0SWAX = CL0SW02.CL0SWAX + CLXREC.CLXMAXLN[CLXSCRNX];
  if (CL0SW02.CL0SWAX > CL0SW02.CL0SWAS) /* over table max*/
    converseLib.validationFailed(3); /* at end of data*/
    CL0SW02.CL0SWAX = CL0SW02.CL0SWAX - CLXREC.CLXMAXLN[CLXSCRNX];
    CLXREC.CLXERRF = "Y";
  else
    CLXREC.CLXBLDSC = "Y";
  end
  ;
  ;
end // end KL0SS08

// Reset map attributes
Function KL0SS25()
  ;
   /* This process resets the map attributes for the table*/
   /* of exceptions. Because the SET NORMAL command also*/
   /* clears the 'autoskip', we will need to look at our*/
   /* exceptions table to see if we need to reset it.*/
  ;
  CLXREC.CLXLINEX = 1; /* reset screen index*/
  CLXREC.CLXARAYX = CL0SW02.CL0SWAX;
  while (CLXREC.CLXLINEX <= CLXREC.CLXMAXLN[CLXSCRNX])
    if (CLXREC.CLXARAYX > CL0SW02.CL0SWAS) /* past array max*/
      /* next sentence (user can't touch this line)*/
    else
      set KL0SM001.YCEAOVRF[CLXLINEX] normal;
      set KL0SM001.CL0SMACN[CLXLINEX] normal;
      if (CL0SW02.YCEAOVRF[CLXARAYX] == "Y" /* override allowed*/
       && CL0SW01.CL0SWINQ == "N")          /* and not inquiry mode*/
        if (CL0SW02.CL1XOFL[CLXARAYX] != KL0SM001.YCEAOVRF[CLXLINEX])
          CLXREC.CLXEDITF = "Y"; /* things have changed*/
        end
      else
        set KL0SM001.YCEAOVRF[CLXLINEX] skip;
      end
      if (CL0SW02.YCEADJRQ[CLXARAYX] == "Y" /* adj clm can be entered*/
       && CL0SW01.CL0SWINQ == "N")          /* and not inquiry mode*/
        if (CL0SW02.CL1CLMN2[CLXARAYX] != KL0SM001.CL0SMACN[CLXLINEX])
          CLXREC.CLXEDITF = "Y"; /* things have changed*/
        end
      else
        set KL0SM001.CL0SMACN[CLXLINEX] skip;
      end
    end
    CLXREC.CLXLINEX = CLXREC.CLXLINEX + 1;
    CLXREC.CLXARAYX = CLXREC.CLXARAYX + 1;
  end
  ;
end // end KL0SS25

// Validate screen line item
Function KL0SS31()
  ;
   /* Validate screen line item.  Note that indexes have*/
   /* been set by the CL0S120 module.*/
  ;
  if (KL0SM001.YCEAOVRF[CLXLINEX] != "Y"
   && KL0SM001.YCEAOVRF[CLXLINEX] != " ")
    VAGen_EZEMSG = "VALID CODES ARE Y OR BLANK";
    set KL0SM001.YCEAOVRF[CLXLINEX] cursor, bold;
    CLXREC.CLXERRF = "Y";
  end
  ;
  if (KL0SM001.CL0SMACN[CLXLINEX] != 0)
    if (KL0SM001.YCEAOVRF[CLXLINEX] != "Y") /* must be y*/
      converseLib.validationFailed(37); /* data is not valid*/
      set KL0SM001.YCEAOVRF[CLXLINEX] cursor, bold;
      set KL0SM001.CL0SMACN[CLXLINEX] bold;
      CLXREC.CLXERRF = "Y";
    else
      KL0SS32(); /* validate claim*/
    end
  end
  ;
end // end KL0SS31

// Validate adj. claim number
Function KL0SS32()
  ;
   /* Validate the adjustment claim number entered by the user*/
  ;
  CLAREC.CLACLMNB = KL0SM001.CL0SMACN[CLXLINEX];
  call "IO1160" ("S ", SQLCA, CLAREC) {isNoRefresh = yes, isExternal = yes}; /* try to find it*/
  if (SQLCA.VAGen_SQLCODE == 100) /* not valid*/
    converseLib.validationFailed(5); /* claim number not found*/
    set KL0SM001.CL0SMACN[CLXLINEX] cursor, bold;
    CLAREC.CLAGROUP = CLWREC.CLAGROUP; /* move back claim*/
    return; /* can't continue of not found*/
  else
    if (SQLCA.VAGen_SQLCODE != 0) /* bad problems*/
      TA1REC.TA1LOCAT[2] = "CL0SS32";
      TA1REC.TA1DBASE = "DCLAIM";
      TA1REC.TA1TBLVU = "VCLHDR01";
      XPCL010();
    end
  end
  ;
  if (CLAREC.YCTCD != "ADJ") /* must be an adjustment*/
    VAGen_EZEMSG = "MUST BE AN ADJUSTMENT CLAIM TYPE";
    set KL0SM001.CL0SMACN[CLXLINEX] cursor, bold;
    CLXREC.CLXERRF = "Y";
  else
    if (CLAREC.YCSCD1 == "CAN" /* claim cancelled*/
     || CLAREC.YCSCD1 == "DEN") /* or denied*/
      VAGen_EZEMSG = "ADJUSTMENT CLAIM IS CANCELLED OR DENIED";
      set KL0SM001.CL0SMACN[CLXLINEX] cursor, bold;
      CLXREC.CLXERRF = "Y";
    end
  end
  ;
  CLAREC.CLAGROUP = CLWREC.CLAGROUP; /* move back claim*/
  ;
end // end KL0SS32

// Check for Change/Inquiry
Function KL0SS35()
   /* ************************************************************/
   /* *  This statement group will check to see if the user is  **/
   /* *  allowed to override exception or should be inquiry     **/
   /* *  only.                                                  **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0SS35"; /* set current process name*/
  ;
  if (CLWREC.CLWACTIV != "I") /* global inquiry flag*/
    if (COMMAREA.CAADDFL == "Y" /* add flag*/
     || COMMAREA.CACHGFL == "Y") /* change flag*/
       /* next sentence                    ; global flags ok*/
    else
      CL0SW01.CL0SWINQ = "Y"; /* inquiry only*/
      return; /* and get out*/
    end
  else
    CL0SW01.CL0SWINQ = "Y"; /* inquiry only*/
    return;
  end
  ;
   /* now check to see if this user is allowed*/
  ;
  CLYREC.XXXUSRID = COMMAREA.CAUSERID;
  call "IO2650" ("SB", SQLCA, CLYREC) {isNoRefresh = yes, isExternal = yes}; /* see if there*/
  if (SQLCA.VAGen_SQLCODE == 100) /* not found*/
    CL0SW01.CL0SWINQ = "Y"; /* so set inquiry*/
    converseLib.validationFailed(378); /* user not authorized to change*/
  else
    if (SQLCA.VAGen_SQLCODE != 0) /* we got problems*/
      TA1REC.TA1DBASE = "DCLAIM";
      TA1REC.TA1TBLVU = "VCLATH01";
      XPCL010();
    else
      if (CLYREC.XXXSTAT == "A") /* user is active*/
         /* next sentence (all is well)*/
      else
        CL0SW01.CL0SWINQ = "Y"; /* so set inquiry*/
        converseLib.validationFailed(378); /* user not authorized to change*/
      end
    end
  end
  ;
end // end KL0SS35

// Update exception records
Function KL0SS41()
   /* *************************************************************/
   /* *     This statement group will update the exception       **/
   /* *     records that the user has changed on the screen.     **/
   /* *                                                          **/
   /* *************************************************************/
  ;
  CL1REC.CLACLMNB = CLAREC.CLACLMNB;
  CL1REC.CL2ISNBR = CL0SW02.CL2ISNBR[CLXARAYX];
  CL1REC.CLLRTNNB = CL0SW02.CLLRTNNB[CLXARAYX];
  CL1REC.YCECD = CL0SW02.YCECD[CLXARAYX];
  call "IO2840" ("S ", SQLCA, CL1REC) {isNoRefresh = yes, isExternal = yes};
  if (SQLCA.VAGen_SQLCODE != 0)
    TA1REC.TA1DBASE = "DCLAIM";
    TA1REC.TA1TBLVU = "VCLXCP01";
    TA1REC.TA1TBLKE = "READ FOR UPDATE";
    XPCL010();
  end
  CL1REC.CL1XOFL = KL0SM001.YCEAOVRF[CLXLINEX];
  CL1REC.CL1CLMN2 = KL0SM001.CL0SMACN[CLXLINEX];
  CL1REC.XXXUSRID = COMMAREA.CAUSERID;
  CL1REC.ZZZCHGDT = TA2REC.TA2GRGGN;
  CL1REC.ZZZCHGTM = TA2REC.TA2TIMHM;
  call "IO2840" ("U ", SQLCA, CL1REC) {isNoRefresh = yes, isExternal = yes};
  if (SQLCA.VAGen_SQLCODE != 0)
    TA1REC.TA1DBASE = "DCLAIM";
    TA1REC.TA1TBLVU = "VCLXCP01";
    TA1REC.TA1TBLKE = "UPDATE";
    XPCL010();
  end
  ;
end // end KL0SS41

//*** RECORD=CL0SW01 ****
// Working Storage Record for program CL0S
// 
// This record is used for working storage fields used only
// by program CL0S.
// 
// ***********************
Record CL0SW01 type basicRecord
  10 XXXRVNBR XXXRVNBR ; 
  10 CL0SWINQ CL0SWINQ ; 
  10 CL0SWCFL CL0SWCFL ; 
end // end CL0SW01

//*** RECORD=CL0SW02 ****
// ************************************************************
// *  This record is used to store all exceptions for a claim
// *  number.  This is done once in the program, then the user
// *  can scroll forward and backward in this table.
// ************************************************************
// Maintenance History:
//  date     by      why
// 02-27-90  bcourt  expand table from 100 to 150;re clm 499104
//                   Also changed CL0S005 with hardcoded 150.
// 07-29-98  NJana   expand table from 150 to 400;re clm
//                    2914341.Also changed CL0S005 with
//                    hardcoded 400.
// ************************************************************
// ***********************
Record CL0SW02 type basicRecord
  10 CL0SWAX CL0SWAX ; 
  10 CL0SWAS CL0SWAS ; 
  10 CL0SWARY CL0SWARY [400] ; 
    15 CL2ISNBR CL2ISNBR ; 
    15 CLLRTNNB CLLRTNNB ; 
    15 YCECD YCECD ; 
    15 YCEAOVRF YCEAOVRF ; 
    15 YCEADJRQ YCEADJRQ ; 
    15 YCEDESC YCEDESC ; 
    15 CL1XOFL CL1XOFL ; 
    15 CL1CLMN2 CL1CLMN2 ; 
    15 XXXUSRID XXXUSRID ; 
    15 ZZZCHGDT ZZZCHGDT ; 
    15 ZZZCHGCT ZZZCHGCT ; 
end // end CL0SW02

// Group item for array
DataItem CL0SWARY char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Number of rows in array
DataItem CL0SWAS smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Index for array
DataItem CL0SWAX smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Cursor positioned flag
DataItem CL0SWCFL char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Inquiry mode flag
DataItem CL0SWINQ char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

