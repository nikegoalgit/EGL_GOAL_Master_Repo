package kl0x;

import corpcom1.*;
import corpcom2.XQWREC;
import corpcom3.XPCL002;
import corpcom3.XPCL010;
import corpcom3.XPCL011;
import corpcom4.XSENTRY;
import corpcom4.XSPF1;
import corpcom4.XSPF4;
import corpcom4.XSSEGTR;
import corpcom5.COMMAREA;
import corpcom5.ERRSQLCA;
import corpcom6.SQLCA;
import corpx1.XATCD;
import corpx1.XAUCD;
import corpx1.XAUTBL;
import corpx1.XCOCD;
import corpx1.XDMCD;
import corpx1.XGPCD;
import corpx1.XGPTBL;
import corpx1.XUMTBL;
import corpx2.XNXCD;
import corpx2.XPYCD;
import corpx2.XQACD;
import corpx2.XUMCD;
import corpy2.YATTBL;
import corpy2.YCCTBL;
import corpy2.YCSTBL;
import corpy2.YCTCD;
import corpy2.YCTTBL;
import corpy2.YDDCD;
import corpy2.YDFCD;
import corpy2.YDFKEY;
import corpy2.YDFTBL;
import corpy2.YUATBL;
import corpz3.ZZZCHGCT;
import fy.common.FY1FCTYC;
import fy.common.FY1REC;
import iv.common.IV0IVCID;
import iv.common.IV0PARTN;
import iv.common.IV3GLNUP;
import iv.common.IV3LNSQ;
import ku.common.KUCCOID;
import ku.common.KUCCONM;
import ku.common.KUIPRDID;
import ku.common.KUMSTRID;
import op.common.OP2LNINB;
import op.common.OP2PRCOF;
import op.common.OP2PRCVF;
import pc.common.PC3POIDT;
import pc.common.PC6REC;
import sp.common.SP5REC;
import sy.common.SY1REC;
import sy.common.SY1STNBR;
import sy.common.SY2CLRID;
import sy.common.SY2REC;
import sy.common.SY5REC;
import sy.common.SY5SZID;
import sy.common.SY6REC;
import sy.common.SYCREC;
import ta.common.TA1REC;
import ta.common.TA2REC;
//*** PROGRAM=KL0X ****
// ************************************************************
// international claim defective  entry/update/inquiry screens.
// 
// the two main parts of the defective application are:
//   1) adding defective header and detail data
//   2) updating and inquiring against the defective detail
//      data.
// 
// the claim header data is given to cl0x application thru the
// clargroup level inside clwrec.
// 
// for phase 1 of the application we have to add 2 db2 records
// that would normally be in existence already.  they are
// cljrec (return authorization) and cllrec (actual return).
// (note: the add logic for these two records will go away when
// phase b & c are installed). therefore, if the records do not
// exist then there is a flag set for each record.  once all
// three header records exist the user can then begin to add
// detail data.
// 
// the add detail will continue to add as long as there is a
// style number entered.
// 
// ************************************************************
// maintenance history log:
//   date    by whom rev description of change
// --------  ------- --- ------------------------------------
// 06/02/87  ctrouw  0   create application
// 11/25/87  ctrouw      fixed deadlock problem
// 08-01-88  bcourt  1   change DB2 records;
//                       drop CLLREC, actual return,
//                       add  CL2REC, inspection.
// 02-28-89  jwood   -   added noncsp option to calls
// 02-28-89  jwood   -   added xssegtr logic
// 05-19-89  bcourt      DB2 structure changes: CLAREC,SYCREC
//                       SY2REC.  CL0XSAH move GPC and YCT
//                       abbrevs to map 5 and 10. Add both tbls
// 08-01-89  gdecke      DB2 structure changes: CLAREC,clpREC
//                       cl2REC.
// 09-22-89  bcourt      DB2 structure changes: PD1REC.
// 12-06-89  gdecke      default quality code to '01'.
// 01-19-90  gdecke      DB2 structure changes for january.
// 02-22-90  chellm      Replaced DWPROD.VFCTY001 with DFCTY
//                       .VFCTY001. REplaced IO0870 with
//                       IO2810 and renamed PD1.. items as FY1.
// 04-03-90  sgorga      DB2 structure changes.  Regen only.
// 05-31-90  chellm      added edit for product brand - claim
//                       brand mis-match.
// 06-14-90  chellm      db2 structure changes. replaced
//                       pd2rec with pc6rec to edit fcty po nbr
// 06-21-90  chellm      Changed the factory PO Number edit
//                       back to just a warning only to allow
//                       for old PO Nbrs since deleted from
//                       DPRODC.VPOITM01.
// 08-08-90  chellm      fix factory code & po nbr edit for
//                       apprl claims.
// 11-09-90  bcourt  DB2 structure changes.  Regen only.
// 01-09-91  GDECKE  #CL920,CL974. COLOR/DIMENSION CHANGES.
// 02-12-91  GDECKE  #CL0. FEB. DB2 TABLE CHANGES.
// 02-18-91  GDECKE  INITIALIZE CL2TOSLF IN CL0XSBJ
// 04-23-91  sgorga  Added code to force '01' to UOM field when
//    about to be updated with a blank uom - CL0X130. Removed a
//    2nd useless 'select' call to IO1305  - CL0XSCC. Chgd code
//    to show error msg #688 instead of abending - CL0XSVD,SVP.
//    Uncommented code to allow replication of contract po nbr
//    on cl0xm005 detail screen - CL0XSCH.  Added code to make
//    a "post" error msg for the Error Diag Rpt to help find
//    where the occassional blank uom cd comes from - CL0X130.
//    Minor changes to: CL0XSCE,SFH,SFT.
// 06-06-91  sgorga  Added code to re-edit po/fcty combo, if
//             found invalid, with parent fcty cd.
//             Added code to re-edit po/fcty combo each time
//             style or color are modified.
//             Corrected errors:  Coded to display correct err
//             msg when color/dim is invalid;  coded to hi-lite
//             dim when color/dim is invalid,  coded to default
//             dim to '00' (like color does) instead of giving
//             error msg;  coded to re-validate color/dim if
//             dim is changed instead of accepting invalid dim!
//             Deleted code moving fields to themselves.
//             Changed: CL0XSCC, SCK, SCN, SBA, SCH, SFJ, S01,
//                      S02, S04, 130.
// 06-20-91  sgorga  Fixed production bug preventing summary
//                   screen from updating fcty cd, def cd, and
//                   credit qty cd when user changed them. (see
//                   -SJF).  Changes to CL0XSFJ, 200, 230.
// 08-08-91  wjohns  Renamed application and commarea
//                     referrences to renamed claims appls.
// 09-19-91  wjohns  changed proc and sgrp fro "cl" to "kl".
// 01-22-92  lgross  When inspection complete is answered 'y'
//              application will check to see if this is being
//              entered after the 20th of the month.  If after,
//              a warning message will be displayed before the
//              value will be accepted.
//              Changed: KL0XSHG, SHO, SIC, SIG, 001, 130, 230
// 02-07-92  lgross   Price calculated will be approximately
//               98% of price type '03'. Changed: S70
// 02-07-92  lgross   Allow qty only updates on summary screen
//                changed: KL0XSFQ
// 04-05-92  lgross  Added edit to check for zero price or
//              price not available for that style
//              Changed : KL0X130,  KL0XS72, KL0XSPR, KL0XSCC
// 05-12-92  lgross Edit will no longer allow zeroes in color
//              and dimension codes when editing style, color
//              and dimension. Changed: KL0XSNC
// 11-12-93  GDECKE  NOV. 93' DB2 TABLE CHANGES - KL0XSHP,SFU.
// 03-11-94 BCourt  Rename SY6CSTFL to XQACD, DB2 table changes
//              Add country & currency defaults to KL0XS72.
// 12-19-94 Sgorga  Removed edit restricting PO fcty date to be
//                  less than 28 months.  There are no longer
//                  time restrictions for credit on NIL def
//                  returns.  FYI - the PO fcty date edits tend
//                  to be WARNINGS.  Msg shows once...
// 01/27/97 CTRAN   Made changes to KL0X130, KL0XSCN, KL0XSCM
//                  and KL0XSPR to validate style, color and
//                  dimension.  display error-message when
//                  users leave these fields BLANK
//                  comment out all reference that allow blank
//                  style in kl0x130 when exertn
//                  commented out reference to cl0xwctr in
//                  above stmt groups.
// 01/27/97 kshaw   Made changes to KL0X130 for pf15 and enter
//                  pf15 exits no updates or edits.
//                  enter updates and remains within screen.
// 02/25/97 kshaw   Made changes to KL0X130 default 00 for dim
// 02/16/99 RDHANU  Made changes to KL0XS70 to pick up dim
//                  and color code from map.
// 11/28/01 SVIJAY  RECOMPILED DUE TO CHANGES IN CLPREC.
// ************************************************************
// *********************
Program KL0X type textUIProgram //VAGen Info - main text program
  {
  includeReferencedFunctions = yes, allowUnqualifiedItemReferences = yes, 
  throwNrfEofExceptions = yes, handleHardIOErrors = no, V60ExceptionCompatibility = yes, 
  I4GLItemsNullable = no, textLiteralDefaultIsString = no, localSQLScope = yes, 
  msgTablePrefix = "CL00", inputRecord = COMMAREA, segmented = yes
  }

  // Data Declarations
  CL0XW01 CL0XW01; // record
  CL0XW02 CL0XW02; // record
  CL0XW03 CL0XW03; // record
  CL0XW04 CL0XW04; // record
  CL0XW05 CL0XW05; // record
  CL0XW06 CL0XW06; // record
  CL0XW07 CL0XW07; // record
  CL2REC CL2REC; // record
  CLAREC CLAREC; // record
  CLOREC CLOREC; // record
  CLPREC CLPREC; // record
  CLWREC CLWREC; // record
  CLXREC CLXREC; // record
  COMMAREA COMMAREA ; // record
  ERRSQLCA ERRSQLCA; // record
  FY1REC FY1REC; // record
  PC6REC PC6REC; // record
  SP5REC SP5REC; // record
  SQLCA SQLCA; // record
  SY1REC SY1REC; // record
  SY2REC SY2REC; // record
  SY5REC SY5REC; // record
  SY6REC SY6REC; // record
  SYCREC SYCREC; // record
  TA1REC TA1REC; // record
  TA2REC TA2REC; // record
  XQWREC XQWREC; // record

  // VAGen Info - items needed for migration
  VAGen_EZESYS char(8);
  VAGen_EZEREPLY num(1);
  VAGen_EZE_WAIT_TIME bin(9,2);
  VAGen_EZE_ITEMLEN int;

  // Use Declarations
  use XAUTBL {deleteAfterUse = yes}; // table
  use XGPTBL {deleteAfterUse = yes}; // table
  use XUMTBL {deleteAfterUse = yes}; // table
  use YATTBL {deleteAfterUse = yes}; // table
  use YCCTBL {deleteAfterUse = yes}; // table
  use YCSTBL {deleteAfterUse = yes}; // table
  use YCTTBL {deleteAfterUse = yes}; // table
  use YDFTBL {deleteAfterUse = yes}; // table
  use YUATBL {deleteAfterUse = yes}; // table
  use KL0XM.KL0XM005,  // forms
      KL0XM.KL0XM010
   {
    pfKeyEquate = no
  };

  function main()
    // VAGen Info - initialization needed for migration
    VAGen_EZESYS = VGLib.getVAGSysType();
    KL0X000: KL0X000();

    exit program;

    KL0X001: KL0X001();
    KL0X050: KL0X050();
    KL0X100: KL0X100();
    KL0X130: KL0X130();
    KL0X110: KL0X110();
    KL0X200: KL0X200();
    KL0X230: KL0X230();
    KL0X210: KL0X210();
  end // end main
end // end KL0X

// application main logic
Function KL0X000()

   /* ***********************************************************/
   /* *   THIS IS THE "main logic" FOR THE APPLICATION.        **/
   /* *                                                        **/
   /* *   xsentry checks to ensure that this application was   **/
   /* *           ENTERED FROM ANOTHER CSP APPLICATION.        **/
   /* *   xclentry checks to ensure that the claim header has  **/
   /* *           been flagged as "in use" if this application **/
   /* *           does updates.                                **/
   /* *                                                        **/
   /* ***********************************************************/


  KL0X001(); /* initialize the application*/

  KL0XM010.XXXRVNBR = "0"; /* appl maintenance revision number*/
  KL0XM005.XXXRVNBR = "0"; /* appl maintenance revision number*/

  CLXREC.CLXEOAF = "N"; /* set end-of-application flag to 'no'*/

  while (CLXREC.CLXEOAF == "N") /* while no end-of-application*/
    KL0X050(); /* process the application screen(s)*/
  end

  COMMAREA.CATOAP = "KL0A";
  XPCL002();
end // end KL0X000

// initialize application
Function KL0X001()

   /* ************************************************************/
   /* *       initialize the application working storage        **/
   /* ************************************************************/
   /* MAINTENANCE HISTORY                         **/
   /* 01-13-92  sgorga  Set ta1rec, ta2rec, errsqlca, cl0xw03,  **/
   /* cl0xw04, and cl0xw05 empty.             **/
   /* 01-22-92  lgross  initialize cl0xw01.cl0xwicf to 'n'      **/
   /* move date to clxrec.xxxcdte             **/
   /* ************************************************************/


  converseVar.commitOnConverse = 1; /* force db2 to commit on each screen converse*/
  VGVar.handleHardIOErrors = 1; /* return control to program if hard db2 error*/
  KL0XSAK(); /* set all recs and maps empty*/

   /* TEMP001              ;  ---> remove after test <---*/

  XSENTRY(); /* check entered thru main menu*/
  XSSEGTR(); /* set segmented transaction id*/
  XPCL011(); /* claims entry module*/
  set CLXREC empty; /* clear out the "commom working*/
                                   /* storage"*/
  set TA1REC empty;
  set TA2REC empty;
  set CL0XW03 empty;
  set CL0XW04 empty;
  set CL0XW05 empty;
  set ERRSQLCA empty;

  KL0XSAA(); /* retrieve all header info*/


  CLXREC.CLXEOAF = "N"; /* set application-done-switch to 'no'*/
  CLXREC.CLXSNAME[1] = "KL0XM005"; /* initialize the names of*/
  CLXREC.CLXSNAME[2] = "KL0XM010"; /* the screens used in*/
  CLXREC.CLXSNAME[3] = " "; /* this application.*/
  CLXREC.CLXMAXLN[2] = 10; /* max linex on map 2*/
  CLXREC.CLXARY1X[2] = 1; /* start line on map 2*/
  CLXREC.CLXARAYX = 1; /* index to array*/
  CLXREC.CLXLINEX = 1; /* index to map line*/
  CL0XW01.CL0XWICF = "N"; /* set warning eof warning switch to no*/

  KL0XSAG(); /* get todays date*/
  CL0XW02.CL0XWPED = TA2REC.TA2GRGGN; /* store todays date*/
  CLXREC.XXXCDTE = TA2REC.TA2GRGGN; /* to be used to check eom*/

end // end KL0X001

// main cl0x branch control
Function KL0X050()
   /* *************************************************************/
   /* *        control process the application screen(s)         **/
   /* *                                                          **/
   /* *  note: this process is being performed in a "while loop" **/
   /* *        until the end-of-application flag is set to "Y".  **/
   /* *                                                          **/
   /* *************************************************************/


  CLXREC.CLXCPROC = "CL0X050"; /* set current process name*/

  if (CLXREC.CLXCSCRN in CLXREC.CLXSNAME) /* if current-screen-name is*/
    CLXREC.CLXSCRNX = sysVar.arrayIndex; /* in the screen-array, then*/
  else /* set index*/
    CLXREC.CLXEOAF = "Y"; /* no screen found*/
    return; /* end application*/
  end

  CLXREC.CLXEOSF = "N"; /* set end-of-screen flag to "no"*/
  CL0XW01.CL0XWDEF = "N"; /* set end-of-detail flag to "no"*/
  CL0XW01.CL0XWBLD = "N"; /* build temp work file*/

  KL0XSAH(); /* move cl0xw01 header info to cl0xm005,010*/

  if (CLXREC.CLXSCRNX == 1) /* if screen cl0xm005*/
    while (CLXREC.CLXEOSF == "N") /* while not end-of-screen*/
      KL0X100(); /* process screen cl0xm005*/
    end
  else
    if (CLXREC.CLXSCRNX == 2) /* if screen cl0xm010*/
      while (CLXREC.CLXEOSF == "N") /* while not end-of-screen*/
        KL0X200(); /* process screen cl0xm010*/
      end
    end
  end

    /* at this point:*/
        /* if the end-of-application flag (clxeoaf) eq 'n'*/
          /* the perform will return to the top of cl0x050;*/
        /* else*/
          /* the perform will auto return to cl0x000*/
        /* end*/


end // end KL0X050

// control module for adds
Function KL0X100()

   /* *************************************************************/
   /* *     execute process                                      **/
   /* *                                                          **/
   /* * note - this process is being performed in a "while loop" **/
   /* *        from cl0x050 until the end-of-screen flag         **/
   /* *        (clxeosfl) is set to 'y'.                         **/
   /* *                                                          **/
   /* *   the execute process will perform either the defective  **/
   /* *   header or detail process depending on:                 **/
   /* *                                                          **/
   /* *     header - if the claim number and seq number have a   **/
   /* *              memo written against them, then they are    **/
   /* *              considered closed and the user will return  **/
   /* *              to kl0xm005 screen.                         **/
   /* *                                                          **/
   /* *     detail - the detail screen will display all the      **/
   /* *              header info and the user will enter all the **/
   /* *              required data.  the while loop is stopped   **/
   /* *              when the user does not enter a nike prod id **/
   /* *              and presses enter.                          **/
   /* *                                                          **/
   /* *    pf keys - the pf keys will terminate the entire add   **/
   /* *              loop and go back to cl0x050 process.        **/
   /* *                                                          **/
   /* *************************************************************/

  CLXREC.CLXCPROC = "CL0X100"; /* set current process name*/
  CLXREC.CLXMSG = " "; /* set error mssg to spaces*/
  CLXREC.CLXERRF = "N"; /* set error flag off*/
  CL0XW01.CL0XWWRF = "N"; /* set warning flag off*/

  if (CL0XW01.CL0XWUDF == "N") /* if update flag = 'n'*/
    CLXREC.CLXEOSF = "Y"; /* set end of screen flag*/
    CLXREC.CLXCSCRN = "KL0XM010"; /* set for next screen*/
    return;
  end

   /* if header not complete add header & actual return*/

  if (CL0XW01.CL0XWHDF == "N") /* header not complete flag*/
    KL0XSBE(); /* add inspection & def header*/
  end

   /* update the defective detail*/

  if (CL0XW01.CL0XWHDF == "Y") /* if header is complete*/
    set KL0XM005.SY1STNBR cursor, modified; /* set nike prod id*/
    set KL0XM005.SY2CLRID modified; /* to be modified to force*/
    set KL0XM005.XDMCD modified;
    set KL0XM005.XUMCD modified; /* fields.*/
    while (CL0XW01.CL0XWDEF == "N" /* end of detail flag*/
     && CLXREC.CLXEOSF == "N"   /* end of screen flag*/
     && CLXREC.CLXEOAF == "N") /* end of application flag*/
      KL0X130(); /* add def detail data*/
    end
  end

end // end KL0X100

// validate screen m005 pf keys
Function KL0X110()

   /* *************************************************************/
   /* *  validate pf keys                                        **/
   /* *                                                          **/
   /* *  the only keys acted upon at this time are pf1, 3 & 4    **/
   /* *  and fastpath.                                           **/
   /* *                                                          **/
   /* *  the other keys are just verified that they are used by  **/
   /* *  this application.  if the pf key is not recognized,     **/
   /* *  the APPLICATION RESETS ALL MODIFIED FIELDS TO REMAIN    **/
   /* *  modified, the reshows the map with an error message.    **/
   /* *                                                          **/
   /* *  these other pf keys are acted upon after the editing    **/
   /* *  and updating have occured.                              **/
   /* *                                                          **/
   /* *************************************************************/

  CLXREC.CLXCPROC = "CL0X110"; /* set current process name*/

  if (converseVar.eventKey is enter)
    if (KL0XM005.CATOAP != " ") /* if fastpath option entered*/
      COMMAREA.CATOAP = KL0XM005.CATOAP;
      COMMAREA.CAITEM = KL0XM005.CAITEM;
      XPCL002(); /* exit application*/
      return;
    else
      return;
    end
  end

  if (converseVar.eventKey is pf1)
    XSPF1();
  end

  if (converseVar.eventKey is pf2)
    if (CLAREC.CLAMEIND == "Y")
      COMMAREA.CATOAP = "KL0M";
      CLXREC.CLXEDITF = "Y";
      CLXREC.CLXEOSF = "Y";
      CLXREC.CLXEOAF = "Y";
      XPCL002();
      return;
    else
      converseLib.validationFailed(31); /* no memo exists for this claim*/
      return;
    end
  end

  if (converseVar.eventKey is pf3)
    COMMAREA.CATOAP = "KL0A";
    CLXREC.CLXEOSF = "Y"; /* end of screen*/
    CLXREC.CLXEOAF = "Y"; /* end of application*/
    XPCL002();
    return;
  end

  if (converseVar.eventKey is pf4)
    XSPF4();
  end

  if (converseVar.eventKey is pf12
   || converseVar.eventKey is pf15
   || converseVar.eventKey is pf5)
    return;
  end

  converseLib.validationFailed(2); /* invalid pf key*/

end // end KL0X110

// add/display defective detail
Function KL0X130()

   /* *************************************************************/
   /* *                process screen kl0xm005                   **/
   /* *                                                          **/
   /* * note - this is being performed in a "while loop" from    **/
   /* *        cl0x100 until:                                    **/
   /* *                                                          **/
   /* *        cl0xw01.cl0xwdhf eq 'y' (end of detail flag)      **/
   /* *        clxrec.clxeosf eq 'y'   (end of screen flag)      **/
   /* *        clxrec.clxeoaf eq 'y'   (end of appl flag)        **/
   /* *                                                          **/
   /* *        this is the defective detail add screen.          **/
   /* *                                                          **/
   /* * Maintenance History:                                     **/
   /* *                                                          **/
   /* *  05-31-90 chellm Added product brand - claim brand       **/
   /* *                  mis-match edit CL0XSBC.                 **/
   /* 04-23-91  SGORGA  Added code to force '01' to              **/
   /* cl0xm005.xumcd if cl0xm005.xumcd is blank.  This    **/
   /* code needs to precede the transfer (in this process)**/
   /* to process CL0XSCC (where cl0xm005.xumcd is used to **/
   /* update the uom field in the dclaim.vdefit01 table). **/
   /* 06-06-91  SGORGA  Corrected error.  Color/dim were being   **/
   /* validated only if color had been modified.       **/
   /* Added "if color OR DIM has been modified,        **/
   /* perform -SCN process."                           **/
   /* 08-08-91  wjohns  Rename application names for transfers   **/
   /* 01-13-92  sgorga  Set ta1rec and errsqlca empty.           **/
   /* 01-23-92  lgross  allow value of 'n' in cl0micf            **/
   /* 04-02-92  lgross added call to kl0xsprc to get price for   **/
   /* given style and gpc. This will be used as an edit**/
   /* for missing prices for styles or*/
   /* zero prices.  Prices will be updated to*/
   /* to database in kl0xscc*/
   /* *************************************************************/

  CLXREC.CLXCPROC = "CL0X130"; /* set current process name*/
  KL0XM005.XXXPRCNM = "KL0X130"; /* set current process name*/
  KL0XM005.XXXCURDT = VGVar.currentShortGregorianDate; /* move date to screen*/
  KL0XM005.XXXRVNBR = "1"; /* move rev. nbr to screen*/

   /* the following if statements are used to determined*/
   /* if an error occurred in the edit routine and where*/
   /* the first error occurred on the screen.  the edit is*/
   /* done from the top down allowing for blank fields to*/
   /* be defaulted from the prior line on the screen. this*/
   /* requires tracking the first error encountered to*/
   /* set the cursor and error message properly.*/

  if (CLXREC.CLXERRF == "Y" /* if error encountered*/
   || converseVar.validationMsgNum != 0) /* will display on screen*/
    if (CL0XW01.CL0XWCOL == 1) /* if error occurred in po nbr*/
      set KL0XM005.CL0XMFPO[CL0XWHDX] cursor; /* set cursor & error msg.*/
      if (CL0XW01.CL0XWERR == 9999)
        converseLib.validationFailed();
      else
        converseLib.validationFailed(CL0XW01.CL0XWERR);
      end
    else
      if (CL0XW01.CL0XWCOL == 2) /* if error occurred in fact cd*/
        set KL0XM005.FY1FCTYC[CL0XWHDX] cursor; /* set cursor & error msg*/
        if (CL0XW01.CL0XWERR == 9999)
          converseLib.validationFailed();
        else
          converseLib.validationFailed(CL0XW01.CL0XWERR);
        end
      else
        if (CL0XW01.CL0XWCOL == 3) /* if error occurred in def cd*/
          set KL0XM005.YDFCD[CL0XWHDX] cursor; /* set cursor & error msg*/
          if (CL0XW01.CL0XWERR == 9999)
            converseLib.validationFailed();
          else
            converseLib.validationFailed(CL0XW01.CL0XWERR);
          end
        else
          if (CL0XW01.CL0XWCOL == 4) /* if error occurred in cr qnty*/
            set KL0XM005.CLPDEFQ[CL0XWHDX] cursor;
                                   /* set cursor & error msg*/
            if (CL0XW01.CL0XWERR == 9999)
              converseLib.validationFailed();
            else
              converseLib.validationFailed(CL0XW01.CL0XWERR);
            end
            /* ELSE*/
                                  /* MOVE 'N' TO CL0XW01.CL0XWERRS  /**/
                                   /* will turn off style error*/
                                  /* END*/
          end /* /*switch - if errors on detail*/
        end /* line, these messages will be*/
      end /* shown before no price for*/
    end /* that style message*/
  else
    KL0XM005.SY1STNBR = " "; /* if no errors from edit*/
    KL0XM005.SY2CLRID = " "; /* clear the fields on*/
    KL0XM005.XDMCD = "00";
    KL0XM005.XUMCD = " "; /* detail.*/
    KL0XM005.SY1SSTNM = " ";
    KL0XM005.SY2CLRAB = " ";
    KL0XM005.XUMDESC = " ";
    KL0XM005.CL0XMICF = " ";
    set KL0XM005.SY1STNBR cursor, modified; /* set nike prod id to*/
    set KL0XM005.SY2CLRID modified; /* modified to force*/
    set KL0XM005.XDMCD modified;
    set KL0XM005.XUMCD modified;
    CL0XW01.CL0XWIDX = 1; /* if no error*/
    while (CL0XW01.CL0XWIDX < 21) /* clear screen of*/
      KL0XM005.CL0XMFPO[CL0XWIDX] = 0; /* detail data.*/
      KL0XM005.FY1FCTYC[CL0XWIDX] = " ";
      KL0XM005.YDFCD[CL0XWIDX] = " ";
      KL0XM005.CLPDEFQ[CL0XWIDX] = 0;
      CL0XW01.CL0XWIDX = CL0XW01.CL0XWIDX + 1;
    end
  end

  if (CL0XW01.CL0XWBLD == "Y")
    KL0XM005.SY1STNBR = " ";
    KL0XM005.SY2CLRID = " "; /* clear the fields on*/
    KL0XM005.XUMCD = " "; /* detail.*/
    KL0XM005.XDMCD = "00";
    KL0XM005.SY1SSTNM = " ";
    KL0XM005.SY2CLRAB = " ";
    KL0XM005.XUMDESC = " ";
    KL0XM005.CL0XMICF = " ";
    set KL0XM005.SY1STNBR cursor, modified; /* set nike prod id to*/
    set KL0XM005.SY2CLRID modified; /* modified to force*/
    set KL0XM005.XDMCD modified;
    set KL0XM005.XUMCD modified;
    CL0XW01.CL0XWIDX = 1;
    while (CL0XW01.CL0XWIDX < 21) /* clear screen of*/
      KL0XM005.CL0XMFPO[CL0XWIDX] = 0; /* detail data.*/
      KL0XM005.FY1FCTYC[CL0XWIDX] = " ";
      KL0XM005.YDFCD[CL0XWIDX] = " ";
      KL0XM005.CLPDEFQ[CL0XWIDX] = 0;
      CL0XW01.CL0XWIDX = CL0XW01.CL0XWIDX + 1;
    end
    CL0XW01.CL0XWBLD = "N";
  end

  converse KL0XM005 ;

  CLXREC.CLXMSG = " "; /* set error mssg to spaces*/
  CLXREC.CLXERRF = "N"; /* set error flag off*/
  CL0XW01.CL0XWBLD = "N";
  CL0XW01.CL0XWHDX = 0; /* index used to track first error*/
  CL0XW01.CL0XWCOL = 0; /* column in which first error occured*/
  CL0XW01.CL0XWERR = 0; /* holds error msg number*/
  CL0XW01.CL0XWCTR = 0; /* update counter*/
  CL0XW01.CL0XWIDX = 1; /* set screen index to 1*/

  KL0X110(); /* handle any special entries*/
    /* may exit appl from this process*/
  if (converseVar.validationMsgNum != 0) /* error encountered from cl0x110*/
    return; /* invalid pf key*/
  end

  if (converseVar.eventKey is pf2
   || converseVar.eventKey is pf3)
    return;
  end

  if (converseVar.eventKey is pf5)
    COMMAREA.CATOAP = "KL0E";
    CLXREC.CLXEOSF = "Y";
    CLXREC.CLXEOAF = "Y";
    XPCL002();
    return;
  end

  if (converseVar.eventKey is pf12)
    if (KL0XM005.CL0XMICF == " "
     || KL0XM005.CL0XMICF == "Y"
     || KL0XM005.CL0XMICF == "N")
      set KL0XM005.CL0XMICF initialAttributes;
      if (KL0XM005.CL0XMICF == "Y")
        set KL0XM005.CL0XMICF modified;
      end
    else
      converseLib.validationFailed(19);
      CLXREC.CLXERRF = "Y";
      set KL0XM005.CL0XMICF cursor, modified, bold;
    end
  end


  if (converseVar.eventKey is pf15)
    CLXREC.CLXEOSF = "Y";
    CLXREC.CLXCSCRN = "KL0XM010";
    return;
  end


  if (KL0XM005.SY1STNBR == " "
   || KL0XM005.SY2CLRID == " "
   || KL0XM005.XDMCD == " ")
    CLXREC.CLXERRF = "Y";
    converseLib.validationFailed(767);
    return;
  end

   /* IF KL0XM005.SY2CLRID IS MODIFIED*/
   /* OR KL0XM005.XDMCD IS MODIFIED;*/
  KL0XSCN(); /* validate color/dim*/
   /* END;*/

   /* IF KL0XM005.SY1STNBR IS MODIFIED*/
   /* OR KL0XM005.XUMCD IS MODIFIED;*/
  KL0XSCM(); /* validate style number/uom*/
  KL0XSBC(); /* validate product brand code*/
   /* END;*/
  if (CLXREC.CLXERRF == "Y")
    /* IF EZEMNO = 689                  /* will display style, dim*/
    /* OR EZEMNO = 200                /* errors if found - otherwise*/
    /* OR EZEMNO = 409                /* this message can be overridden*/
    /* OR EZEMNO = 767;               /* with style price message.*/
    return;
  end

  if (KL0XM005.SY2CLRID is modified /* check only if something has*/
   || KL0XM005.XDMCD is modified    /* changed*/
   || KL0XM005.SY1STNBR is modified /**/
   || KL0XM005.XUMCD is modified)  
    /* OR CL0XW01.CL0XWERRS = 'Y';       /* message hasn't appeared yet*/
    KL0XSPR(); /* check for zero or no price*/
  end
  if (CLXREC.CLXERRF == "Y" /* if errors or warnings*/
   || converseVar.validationMsgNum != 0) /* encountered, skip update*/
    return; /* ezertn*/
  end

  if (converseVar.eventKey is pf12) /* edit only*/
    CLXREC.CLXERRF = "Y";
    return; /* skip update*/
  end
  while (CL0XW01.CL0XWIDX < 21) /* max number of entries on screen*/
    KL0XSBA(); /* edit full screen of data*/
    CL0XW01.CL0XWIDX = CL0XW01.CL0XWIDX + 1;
  end
  if (CLXREC.CLXERRF == "Y" /* if errors or warnings*/
   || converseVar.validationMsgNum != 0) /* encountered, skip update*/
    return; /* ezertn*/
  end

   /* 04-23-91  Below we have added code to move '01' to*/
     /* cl0xm005.xumcd if cl0xm005.xumcd is blank.  This is to*/
     /* prevent dclaim.vdefit01 from being updated in process*/
     /* CL0XSCC with a blank UOM.  (A blank UOM on the database*/
     /* causes batch processing to abend.)  We shouldn't need to*/
     /* force a UOM code, but we don't yet know why the blank*/
     /* UOM code is appearing.*/
     /* From the code, it looks like the blank UOM would come*/
     /* from the DPROD.VSTYLE01 database in process CL0XSCM.*/
     /* However, we don't know for sure.  Therfore, we have*/
     /* added additional code just before the perform of CL0XSCC,*/
     /* to print a 'post' error msg on the Error Diagnosis Rpt if*/
     /* the cl0xm005.xumcd is blank.  We hope the post error msg*/
     /* will help solve the mystery of where the blank UOM is*/
     /* coming from.*/
     /* If this mystery is solved, these comments and code can be*/
     /* be deleted.  Same with the CL0XW01.CL0XWMSG fields being*/
     /* used for the post message.*/

  set TA1REC empty;
  set ERRSQLCA empty;

  if (KL0XM005.XUMCD == " ")
                                   /* if the uom on the detail map = spaces*/
    KL0XM005.XUMCD = "01"; /* force '01' to UOM for updt to*/
                                   /* vdefit01*/
      /* ** Below is Post Msg for Error Diag Rpt ***/
    TA1REC.TA1TYPE = "DB2"; /* show error type*/
    TA1REC.TA1FUNC = "POST"; /* show this is a 'post' err msg*/
    TA1PGMNM = "CL0X    "; /* show which application*/
    TA1REC.TA1LOCAT[1] = "CL0X130 ";
                                   /* show which process post is in*/
    TA1REC.TA1LOCAT[2] = "FORCED \"";
                                   /* Added message to say we had a*/
    TA1REC.TA1LOCAT[3] = "01\" FOR ";
                                   /* blank UOM and had to force '01'*/
    TA1REC.TA1LOCAT[4] = "UOM UPDT";
                                   /* to UOM for update in cl0xscc.*/
    TA1REC.TA1MAP = "KL0XM005";
                                   /* show which map this occurs in*/
    TA1REC.TA1DBTBL = "UPDATED VDEFIT01"; /* show database involved*/
    CL0XW01.CL0XWLT1 = "CLM#"; /* w01 msg area*/
    CL0XW01.CL0XWCLN = KL0XM005.CLACLMNB; /* move clm# to w01 msg*/
    CL0XW01.CL0XWLT2 = ",STYLE=";
    CL0XW01.CL0XWSTY = KL0XM005.SY1STNBR; /* move style to w01 msg*/
    CL0XW01.CL0XWLT3 = ",COLR=";
    CL0XW01.CL0XWCLR = KL0XM005.SY2CLRID; /* move color to w01 msg*/
    CL0XW01.CL0XWLT4 = ",GPC";
    CL0XW01.CL0XWGP0 = KL0XM005.XGPCD; /* move gpc to w01.msg*/
    TA1REC.TA1TBLKE = CL0XW01.CL0XWMSG; /* move key info to ta1rec*/
    try
      call "TA0020" (TA1REC, ERRSQLCA) {isNoRefresh = yes, isExternal = yes};
    end /* msg then return*/
      /* ** End of Post Msg for Error Diag Rpt ***/
  end


  CL0XW01.CL0XWIDX = 1; /* move 1 to index*/
  while (CL0XW01.CL0XWIDX < 21) /* add up to 20 detail*/
    KL0XSCC(); /* entries on screen.*/
    CL0XW01.CL0XWIDX = CL0XW01.CL0XWIDX + 1;
  end

  if (CL0XW01.CL0XWUPD == "Y")
    KL0XSHP();
  end

  if (KL0XM005.CL0XMICF == " "
   || KL0XM005.CL0XMICF == "N")
    set KL0XM005.CL0XMICF initialAttributes;
  else
    KL0XSHG(); /* edit insp flag and update*/
    return;
  end

   /* IF EZEAID IS PF5;           moved prior to edits and updates*/
   /* MOVE 'KL0E' TO COMMAREA.CATOAP;*/
   /* MOVE 'Y' TO CLXREC.CLXEOSF;*/
   /* MOVE 'Y' TO CLXREC.CLXEOAF;*/
   /* PERFORM XPCL002;*/
   /* EZERTN;*/
   /* END;*/

   /* IF EZEAID IS PF15    /* move to prior edits no updates*/
  if (converseVar.eventKey is enter) /* update remain in screen*/
    if (CL0XW01.CL0XWCTR == 0)
      CLXREC.CLXERRF = "Y";
      converseLib.validationFailed(768); /* must enter defect data for style*/
      return;
    else
      return;
    end
  end

   /* kshaw commented out and added above if cond to make the damn*/
   /* screen have a little integrety.*/

   /* IF EZEAID IS PF15;*/
   /* MOVE 'Y' TO CLXREC.CLXEOSF;*/
   /* MOVE 'KL0XM010' TO CLXREC.CLXCSCRN;*/
   /* EZERTN;*/
   /* END;*/

   /* IF EZEAID IS ENTER;*/
   /* IF CL0XW01.CL0XWCTR EQ 0;*/
      /* IF KL0XM005.SY1STNBR EQ ' ';*/
      /* IF KL0XM005.SY2CLRID EQ ' '*/
      /* OR KL0XM005.SY2CLRID EQ '00 ';*/
   /* MOVE 'Y' TO CLXREC.CLXEOSF;*/
   /* MOVE 'KL0XM010' TO CLXREC.CLXCSCRN;*/
   /* EZERTN;*/
      /* END;*/
      /* END;*/
   /* end;*/
   /* end;*/

end // end KL0X130

// retrieve all def. detail recs.
Function KL0X200()

   /* *************************************************************/
   /* *       execute process                                    **/
   /* *                                                          **/
   /* *  note - this process is being performed in a             **/
   /* *         "while loop" from cl0x050 until end-of-screen    **/
   /* *         flag (clxeosfl) is set to 'y'.                   **/
   /* *                                                          **/
   /* *  MAINTENANCE HISTORY                                     **/
   /* *                                                          **/
   /* *  06-20-91  sgorga  Moving 'N' instead of ' ' to cl0xwlin.**/
   /* *************************************************************/

  CLXREC.CLXCPROC = "CL0X200"; /* set current process name*/

  CL0XW01.CL0XWIDX = 1;
  while (CL0XW01.CL0XWIDX < 13)
    KL0XM010.CL0XMSEL[CL0XWIDX] = " ";
    KL0XM010.SY1STNBR[CL0XWIDX] = " "; /* this will clear all fields*/
    KL0XM010.SY2CLRID[CL0XWIDX] = " "; /* on the summary screen.*/
    KL0XM010.XDMCD[CL0XWIDX] = " ";
    KL0XM010.SY1SSTNM[CL0XWIDX] = " ";
    KL0XM010.SY2CLRAB[CL0XWIDX] = " ";
    KL0XM010.XUMCD[CL0XWIDX] = " ";
    KL0XM010.CL0XMFPO[CL0XWIDX] = 0;
    KL0XM010.FY1FCTYC[CL0XWIDX] = " ";
    KL0XM010.YDFCD[CL0XWIDX] = " ";
    KL0XM010.CLPDEFQ[CL0XWIDX] = 0;
    CL0XW01.CL0XWLIN[CL0XWIDX] = "N"; /* 06-20-91*/
    CL0XW01.CL0XWIDX = CL0XW01.CL0XWIDX + 1;
  end

  CLXREC.CLXMSG = " "; /* set error message blank*/
  CLXREC.CLXERRF = "N"; /* re-set error flag*/
  CL0XW01.CL0XWELF = "N"; /* set end of header flag*/

  if (CL0XW01.CL0XWBLD == "Y")
    KL0XSFC(); /* purge temp work file*/
    KL0XSFA(); /* load temp work file*/
    set SYCREC empty;
    if (CL0XW01.CL0XWCCT < 3)
      CL0XW01.CL0XWCNT = 0;
    else
      CL0XW01.CL0XWDCT = CL0XW01.CL0XWCCT / 2;
      CL0XW01.CL0XWDCT = CL0XW01.CL0XWDCT * 2;
      if (CL0XW01.CL0XWDCT == CL0XW01.CL0XWCCT)
        CL0XW01.CL0XWCNT = CL0XW01.CL0XWCCT - 2;
      else
        CL0XW01.CL0XWCNT = CL0XW01.CL0XWCCT - 1;
      end
    end
    CL0XW01.CL0XWBLD = "N";
  else
    if (converseVar.eventKey is pf7 /* these are all scrolling keys*/
     || converseVar.eventKey is pf8 /* and will no reload work file.*/
     || converseVar.eventKey is pf17
     || converseVar.eventKey is pf18
     || CL0XW01.CL0XWSKP == "X")   
      /* next sentence*/
    else
      KL0XSFC(); /* purge temp work file*/
      KL0XSFA(); /* load temp work file*/
      set SYCREC empty;
      CL0XW01.CL0XWCNT = 0; /* record count of work file*/
    end
  end

  CL0XW01.CL0XWSKP = " ";
  CL0XW01.CL0XWIN = 0; /* line count on screen*/
  CL0XW01.CL0XWCN = 1; /* record count of work file*/
  set CL0XW05 empty; /* per screen.*/

  while (CL0XW01.CL0XWCN < 3) /* 2 work file recs fill screen*/
    KL0XSFD(); /* read temp work file*/
    CL0XW01.CL0XWCN = CL0XW01.CL0XWCN + 1;
  end

  while (CL0XW01.CL0XWELF == "N" /* end of list screen flag*/
   && CLXREC.CLXEOSF == "N"   /* end of screen flag*/
   && CLXREC.CLXEOAF == "N") /* end of application flag*/
    KL0X230(); /* display list screen*/
  end

end // end KL0X200

// handle special entries
Function KL0X210()

  CLXREC.CLXCPROC = "CL0X210"; /* set current process name*/

  if (converseVar.eventKey is enter)
    if (KL0XM010.CATOAP != " ") /* if fastpath choosen*/
      COMMAREA.CATOAP = KL0XM010.CATOAP;
      COMMAREA.CAITEM = KL0XM010.CAITEM;
      KL0XSFC(); /* purge temp file*/
      XPCL002(); /* exit application*/
      return;
    else
      return;
    end
  end

  if (converseVar.eventKey is pf1) /* help*/
    KL0XSFC(); /* purge temp file*/
    XSPF1();
  end

  if (converseVar.eventKey is pf2)
    if (CLAREC.CLAMEIND == "Y")
      KL0XSFC();
      COMMAREA.CATOAP = "KL0M";
      CLXREC.CLXEOSF = "Y";
      CLXREC.CLXEOAF = "Y";
      CLXREC.CLXEDITF = "Y";
      XPCL002();
      return;
    else
      converseLib.validationFailed(31); /* no memo exists for this claim*/
      return;
    end
  end

  if (converseVar.eventKey is pf3)
    KL0XSFC(); /* purge temp file*/
    COMMAREA.CATOAP = "CL0M";
    CLXREC.CLXEOSF = "Y"; /* end of screen*/
    CLXREC.CLXEOAF = "Y"; /* end of application*/
    XPCL002();
    return;
  end

  if (converseVar.eventKey is pf4) /* master menu*/
    KL0XSFC(); /* purge temp file*/
    XSPF4();
  end

  if (converseVar.eventKey is pf5 /* pf keys used for scrolling*/
   || converseVar.eventKey is pf7 
   || converseVar.eventKey is pf8 
   || converseVar.eventKey is pf12
   || converseVar.eventKey is pf15
   || converseVar.eventKey is pf17
   || converseVar.eventKey is pf18)
    return;
  end

  converseLib.validationFailed(2); /* invalid pf key*/

end // end KL0X210

// display summary of defect dtls
Function KL0X230()

   /* ******************************************************/
   /* *                                                   **/
   /* *    process kl0xm010                               **/
   /* *                                                   **/
   /* *  note: that this process is being performed in a  **/
   /* *        "while loop" from cl0x200 until:           **/
   /* *                                                   **/
   /* *  this is a summary list of defective products     **/
   /* *  entered against a claim.  the user can enter     **/
   /* *  1 value in the cl0xm010.cl0xmsel (select) field: **/
   /* *                                                   **/
   /* *  'x' - delete this defective item from the claim  **/
   /* *                                                   **/
   /* *  the user will enter a 'y' in the inspection      **/
   /* *  complete field to inform the program the the     **/
   /* *  inspection is complete.  the process-complete    **/
   /* *  date will be updated in cl2rec (inspection)      **/
   /* *  and the claim status will be changed to "rpm"    **/
   /* *  in clarec (claim header).                        **/
   /* *                                                   **/
   /* *  the flow from this screen is:                    **/
   /* *                                                   **/
   /* *    pf1 - go back to help menu.                    **/
   /* *    pf2 - go to memo*/
   /* *    pf3 - go back to previous application.         **/
   /* *    pf4 - go to master menu.                       **/
   /* *    pf7 - scroll backward                          **/
   /* *    pf8 - scroll forward                           **/
   /* *    pf10- go to "cl0w" shipping charges map and    **/
   /* *          back to "cl0x" def. map                  **/
   /* *    pf14- go to "cl0j" general ledger map and then **/
   /* *          back to "cl0x" def. map                  **/
   /* *    pf15- go to kl0xm005 - detail screen           **/
   /* *    pf17- scroll to first screen                   **/
   /* *    pf18- scroll to last screen                    **/
   /* *    enter - with no selection or changes go to     **/
   /* *            "kl0e" claim header.                   **/
   /* *                                                   **/
   /* ******************************************************/
   /* **/
   /* *  MAINTENANCE HISTORY*/
   /* **/
   /* *  06-20-91  sgorga  Moving 'N' instead of ' ' and 'Y'*/
   /* *                    instead of 'X' to field cl0xw01.-*/
   /* *                    cl0xwlin(cl0xwidx).*/
   /* *  08-08-91  wjohns  Renamed application names for*/
                         /* transfers*/
   /* *  01-21-92  lgross Added call to kl0xsic to check for eom when*/
   /* *                   when cl0xmicf is set to 'y' when pf12 is pressed.*/
   /* *                   Also check cl0xwicf ne 'y' before purging temp*/
   /* *                   files when enter is pressed and cl0xmicf set to*/
   /* *                   'y'.*/
   /* *******************************************************/

  CLXREC.CLXCPROC = "CL0X230"; /* set current process name*/
  KL0XM010.XXXPRCNM = "KL0X230"; /* set current process name*/
  KL0XM010.XXXCURDT = VGVar.currentShortGregorianDate; /* move date to screen*/
  KL0XM005.XXXRVNBR = "1"; /* revision number*/

  if (converseVar.validationMsgNum == 0)
    set KL0XM010.CL0XMSEL[1] cursor;
  end

  if (CL0XW01.CL0XWUDF == "N") /* update flag = "n"*/
    set KL0XM010.CL0XMICF skip; /* set all fields on screen to*/
    set KL0XM010.CATOAP cursor; /* autoskip*/
    converseLib.validationFailed(370); /* add action not valid during inquiry*/
    CL0XW01.CL0XWIDX = 1;
    while (CL0XW01.CL0XWIDX < 13)
      set KL0XM010.CL0XMSEL[CL0XWIDX] skip, invisible;
      set KL0XM010.SY1STNBR[CL0XWIDX] skip;
      set KL0XM010.SY2CLRID[CL0XWIDX] skip;
      set KL0XM010.XDMCD[CL0XWIDX] skip;
      set KL0XM010.CL0XMFPO[CL0XWIDX] skip;
      set KL0XM010.FY1FCTYC[CL0XWIDX] skip;
      set KL0XM010.XUMCD[CL0XWIDX] skip;
      set KL0XM010.YDFCD[CL0XWIDX] skip;
      set KL0XM010.CLPDEFQ[CL0XWIDX] skip;
      CL0XW01.CL0XWIDX = CL0XW01.CL0XWIDX + 1;
    end
  else
    if (CLXREC.CLXERRF == "N")
      set KL0XM010.CL0XMSEL[1] cursor;
      CL0XW01.CL0XWIDX = 1;
      while (CL0XW01.CL0XWIDX < 13)
        set KL0XM010.CL0XMSEL[CL0XWIDX] initialAttributes;
        set KL0XM010.SY1STNBR[CL0XWIDX] initialAttributes;
        set KL0XM010.SY2CLRID[CL0XWIDX] initialAttributes;
        set KL0XM010.XDMCD[CL0XWIDX] initialAttributes;
        set KL0XM010.XUMCD[CL0XWIDX] initialAttributes;
        set KL0XM010.CL0XMFPO[CL0XWIDX] initialAttributes;
        set KL0XM010.FY1FCTYC[CL0XWIDX] initialAttributes;
        set KL0XM010.XUMCD[CL0XWIDX] initialAttributes;
        set KL0XM010.YDFCD[CL0XWIDX] initialAttributes;
        set KL0XM010.CLPDEFQ[CL0XWIDX] initialAttributes;
        CL0XW01.CL0XWIDX = CL0XW01.CL0XWIDX + 1;
      end
    end
    CL0XW01.CL0XWIDX = 1;
    while (CL0XW01.CL0XWIDX < 13)
      if (KL0XM010.SY1STNBR[CL0XWIDX] == " "
       && KL0XM010.SY2CLRID[CL0XWIDX] == " "
       && KL0XM010.XDMCD[CL0XWIDX] == " "
       && KL0XM010.SY1SSTNM[CL0XWIDX] == " "
       && KL0XM010.SY2CLRAB[CL0XWIDX] == " "
       && KL0XM010.XUMCD[CL0XWIDX] == " "
       && KL0XM010.CL0XMFPO[CL0XWIDX] == 0
       && KL0XM010.FY1FCTYC[CL0XWIDX] == " "
       && KL0XM010.YDFCD[CL0XWIDX] == " "
       && KL0XM010.CLPDEFQ[CL0XWIDX] == 0)
        set KL0XM010.CL0XMSEL[CL0XWIDX] skip, invisible;
        set KL0XM010.SY1STNBR[CL0XWIDX] skip, invisible;
        set KL0XM010.SY2CLRID[CL0XWIDX] skip, invisible;
        set KL0XM010.XDMCD[CL0XWIDX] skip, invisible;
        set KL0XM010.XUMCD[CL0XWIDX] skip, invisible;
        set KL0XM010.CL0XMFPO[CL0XWIDX] skip, invisible;
        set KL0XM010.FY1FCTYC[CL0XWIDX] skip, invisible;
        set KL0XM010.YDFCD[CL0XWIDX] skip, invisible;
        set KL0XM010.CLPDEFQ[CL0XWIDX] skip, invisible;
      end
      CL0XW01.CL0XWIDX = CL0XW01.CL0XWIDX + 1;
    end
  end

  converse KL0XM010 ;

  CL0XW01.CL0XWBLD = "N";
  CLXREC.CLXERRF = "N"; /* 06-18-90*/
  KL0X210(); /* handle special entries*/

  if (converseVar.validationMsgNum != 0) /* error encountered from cl0x210*/
    return;
  end

  if (KL0XM010.CAITEM != " ") /* set screen to selected*/
    CL0XW01.CL0XWCNT = 0;
    CL0XW01.CL0XWXDA = KL0XM010.CAITEM;
    CL0XW01.CL0XWEND = "N";
    while (CL0XW01.CL0XWEND == "N")
      KL0XSFZ(); /* style and/or color*/
    end
    KL0XM010.CAITEM = " ";
    CL0XW01.CL0XWXDA = " ";
    return;
  end

  if (converseVar.eventKey is enter)
    if (KL0XM010 is modified
     || CL0XW01.CL0XWFLG == "X")
      /* next sentence*/
    else
      KL0XSFC(); /* purge temp file*/
      COMMAREA.CATOAP = "KL0E";
      CLXREC.CLXEOSF = "Y";
      CLXREC.CLXEOAF = "Y";
      XPCL002();
      return;
    end
  end

  if (converseVar.eventKey is pf2
   || converseVar.eventKey is pf3)
    return;
  end

  if (converseVar.eventKey is pf12)
    if (KL0XM010.CL0XMICF == " "
     || KL0XM010.CL0XMICF == "N"
     || KL0XM010.CL0XMICF == "Y")
      set KL0XM010.CL0XMICF initialAttributes; /* edit insp flag*/
      if (KL0XM010.CL0XMICF == "Y")
        KL0XSIC(); /* check for eom flag*/
      end
    else
      converseLib.validationFailed(19);
      CLXREC.CLXERRF = "Y";
      set KL0XM010.CL0XMICF cursor, modified, bold;
    end
  end

  CL0XW01.CL0XWIDX = 12;
  while (CL0XW01.CL0XWIDX > 0)
    if (KL0XM010.CL0XMSEL[CL0XWIDX] is modified)
      if (KL0XM010.CL0XMSEL[CL0XWIDX] == " ")
        CL0XW01.CL0XWLIN[CL0XWIDX] = "N";
      else
        if (KL0XM010.CL0XMSEL[CL0XWIDX] == "X")
          CL0XW01.CL0XWLIN[CL0XWIDX] = "Y";
        else
          converseLib.validationFailed(19);
          CLXREC.CLXERRF = "X";
          set KL0XM010.CL0XMSEL[CL0XWIDX] cursor, modified, bold;
          if (KL0XM010.CLPDEFQ[CL0XWIDX] is modified)
            set KL0XM010.CLPDEFQ[CL0XWIDX] modified;
          end
          if (KL0XM010.YDFCD[CL0XWIDX] is modified)
            set KL0XM010.YDFCD[CL0XWIDX] modified;
          end
          if (KL0XM010.CL0XMFPO[CL0XWIDX] is modified)
            set KL0XM010.CL0XMFPO[CL0XWIDX] modified;
          end
          if (KL0XM010.FY1FCTYC[CL0XWIDX] is modified)
            set KL0XM010.FY1FCTYC[CL0XWIDX] modified;
          end
          if (KL0XM010.XUMCD[CL0XWIDX] is modified)
            set KL0XM010.XUMCD[CL0XWIDX] modified;
          end
          return;
        end
      end
    end
    if (KL0XM010.CLPDEFQ[CL0XWIDX] is modified
     && KL0XM010.CL0XMSEL[CL0XWIDX] == " ")
      CL0XW01.CL0XWLIN[CL0XWIDX] = "Y";
      KL0XSFG();
    end
    if (KL0XM010.YDFCD[CL0XWIDX] is modified
     && KL0XM010.CL0XMSEL[CL0XWIDX] == " ")
      CL0XW01.CL0XWLIN[CL0XWIDX] = "Y";
      KL0XSFH();
    end
    if (KL0XM010.CL0XMSEL[CL0XWIDX] == " ")
      KL0XSFI();
      KL0XSFJ();
    end
    if (KL0XM010.XUMCD[CL0XWIDX] is modified
     && KL0XM010.CL0XMSEL[CL0XWIDX] == " ")
      CL0XW01.CL0XWLIN[CL0XWIDX] = "Y";
      KL0XSFT();
    end
    CL0XW01.CL0XWIDX = CL0XW01.CL0XWIDX - 1;
  end

  if (converseVar.validationMsgNum != 0)
    return;
  end

  if (converseVar.eventKey is pf12)
    return;
  end

  CL0XW01.CL0XWFLG = " ";
  CL0XW01.CL0XWIDX = 12;
  while (CL0XW01.CL0XWIDX > 0)
    if (CL0XW01.CL0XWLIN[CL0XWIDX] == "Y")
      KL0XSFN();
      CL0XW01.CL0XWLIN[CL0XWIDX] = "N";
    end
    CL0XW01.CL0XWIDX = CL0XW01.CL0XWIDX - 1;
  end

  if (CL0XW01.CL0XWUPD == "Y")
    KL0XSFU();
  end

  if (KL0XM010.CL0XMICF == " " /* is complete flag set?*/
   || KL0XM010.CL0XMICF == "N")
    set KL0XM010.CL0XMICF initialAttributes;
  else
    KL0XSHO(); /* edit insp flag and update*/
    if (converseVar.eventKey is enter
     && CL0XW01.CL0XWICF != "Y") /* end of month flag*/
      KL0XSFC(); /* purge temp file*/
      COMMAREA.CATOAP = "KL0E";
      CLXREC.CLXEOSF = "Y";
      CLXREC.CLXEOAF = "Y";
      XPCL002();
      return;
    end
    return;
  end

  if (converseVar.eventKey is pf5)
    KL0XSFC();
    COMMAREA.CATOAP = "KL0E";
    CLXREC.CLXEOSF = "Y";
    CLXREC.CLXEOAF = "Y";
    XPCL002();
    return;
  end

  if (converseVar.eventKey is pf15)
    KL0XSFC(); /* purge temp work file*/
    CLXREC.CLXEOSF = "Y"; /* end of screen flag*/
    CL0XW01.CL0XWELF = "Y"; /* end of list flag*/
    CLXREC.CLXCSCRN = "KL0XM005"; /* go to prior screen*/
    return;
  end

  if (converseVar.eventKey is pf7) /* to scroll backward*/
    if (CL0XW01.CL0XWCNT < 3) /* if lt 3 already at top*/
      set KL0XM010 alarm; /* of data*/
      converseLib.validationFailed(7);
      return;
    else
      CL0XW01.CL0XWELF = "Y"; /* end of list flag*/
      if (CL0XW01.CL0XWCNT < 4) /* if lt 4 set counter to show*/
        CL0XW01.CL0XWCNT = 0; /* 1st screen of data.*/
        return;
      else
        CL0XW01.CL0XWCNT = CL0XW01.CL0XWCNT - 4; /* subtract 4 to show*/
        return; /* prior screen of data*/
      end
    end
  end

  if (converseVar.eventKey is pf8) /* to scroll forward*/
    CL0XW01.CL0XWELF = "Y"; /* set end of list flag*/
    if (CL0XW01.CL0XWCNT >= CL0XW01.CL0XWHC) /* check at end of data?*/
      if (CL0XW01.CL0XWHC > 0)
        CL0XW01.CL0XWCNT = CL0XW01.CL0XWHC - 1;
      else
        CL0XW01.CL0XWCNT = 0;
      end
    end
    return;
  end

  if (converseVar.eventKey is pf17) /* set to 1st screen of data*/
    CL0XW01.CL0XWELF = "Y"; /* end of list flag*/
    CL0XW01.CL0XWCNT = 0; /* set counter to zero*/
    converseLib.validationFailed(7);
    set KL0XM010 alarm;
    return;
  end

  if (converseVar.eventKey is pf18) /* set last screen of data*/
    CL0XW01.CL0XWELF = "Y"; /* end of list flag*/
    if (CL0XW01.CL0XWHC <= 2) /* if le 2 only 1 page exists*/
      CL0XW01.CL0XWCNT = 0; /* move 0 to counter.*/
      return;
    else
      CL0XW01.CL0XWCNT = CL0XW01.CL0XWHC - 2; /* set to last screen*/
      return;
    end
  end

end // end KL0X230

// select cursor from pc6rec
Function KL0XS01()

    /* Maintenance History:*/
   /* 06-14-90  CHELLM  Replaced pd2rec with pc6rec for fcty po*/
                     /* number verification.*/
   /* 06-06-91  sgorga  Deleted 4 moves of fields to themselves.*/

   /* *************************************************************/


  CLXREC.CLXCPROC = "CL0XS01"; /* set current proc name*/

  set SQLCA empty;
  call "IO3310" (CL0XW07, SQLCA, PC6REC) {isNoRefresh = yes, isExternal = yes};
                                   /* dprodc.vpoitm01 061490*/

  if (SQLCA.VAGen_SQLCODE == 0
   || SQLCA.VAGen_SQLCODE == 100)
    CL0XW01.CL0XWDLC = 0; /* deadlock count*/
    CL0XW01.CL0XWDFL = "N";
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -911) /* deadlock*/
    CL0XW01.CL0XWDLC = CL0XW01.CL0XWDLC + 1;
    if (CL0XW01.CL0XWDLC > 2)
      converseLib.validationFailed(4); /* database busy*/
      CL0XW01.CL0XWDFL = "N"; /* deadlock flag*/
      CLXREC.CLXERRF = "Y"; /* error flag*/
    end
    return;
  end

  if (SQLCA.VAGen_SQLCODE != 0)
    TA1REC.TA1LOCAT[2] = "CL0XS01"; /* location*/
    TA1REC.TA1LOCAT[4] = "IO3310"; /* location*/
    TA1REC.TA1DBASE = "DPRODC"; /* database*/
    TA1REC.TA1TBLVU = "VPOITM01"; /* table view*/
    CLXREC.XXXWDTE = CLAREC.CLACLMNB; /* claim number*/
    TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* table key*/

    XPCL010(); /* error diagnosis routine*/

  end
end // end KL0XS01

// validate po/fcty combo- pc6rec
Function KL0XS02()

    /* Maintenance History:*/
   /* 06-14-90  CHELLM  Replaced pd2rec with pc6rec for fcty po*/
                     /* number verification.*/
   /* 06-06-91  sgorga  Moved code, performed if sql code = 100,*/
             /* from this process to process -SCK to follow the*/
             /* re-edit of po/fcty combo (using parent fcty cd)*/
             /* if the combo is still invalid (not found).*/
             /* Deleted 4 moves of fields to themselves.*/
             /* Wanted to hi-lite 'style' & 'color' when po/*/
             /* fcty combo is invalid, but both fields are edited*/
             /* later in CL0X & are un-hi-lited if found valid.*/
   /* *************************************************************/


  CLXREC.CLXCPROC = "CL0XS02"; /* set current proc name*/

  set SQLCA empty;
  call "IO3310" ("N3", SQLCA, PC6REC) {isNoRefresh = yes, isExternal = yes}; /* dprodc.vpoitm01 061490*/


  if (SQLCA.VAGen_SQLCODE == +0)
    CL0XW01.CLPVLDFL[CL0XWIDX] = "Y"; /* yes, po combo is valid*/
    CL0XW01.CL0XWWPF[CL0XWIDX] = "N"; /* set warning flag*/
  else
    if (SQLCA.VAGen_SQLCODE == +100)
      CL0XW01.CLPVLDFL[CL0XWIDX] = "N"; /* no, po combo is not valid*/
    else
      TA1REC.TA1DBASE = "DWPROD";
      TA1REC.TA1TBLVU = "VPDFPO01";
      TA1REC.TA1LOCAT[2] = "CL0XS02";
      TA1REC.TA1LOCAT[2] = "SEL UNQ";
      XPCL010(); /* error abort routine*/
    end
  end

end // end KL0XS02

// close set pc6rec
Function KL0XS03()

    /* Maintenance History:*/
    /* 06-14-90 CHELLM Replaced pd2rec with pc6rec for fcty po*/
                    /* number verification.*/

   /* *************************************************************/


  CLXREC.CLXCPROC = "CL0XS03"; /* set current proc name*/
  set SQLCA empty;

  call "IO3310" ("C3", SQLCA, PC6REC) {isNoRefresh = yes, isExternal = yes}; /* dprodc.vpoitm01 061490*/

  if (SQLCA.VAGen_SQLCODE != 0)

    if (SQLCA.VAGen_SQLCODE == -911) /* deadlock*/
      converseLib.validationFailed(4); /* database busy*/
      CLXREC.CLXERRF = "Y"; /* error flag*/
      return;
    else
      TA1REC.TA1LOCAT[2] = "CL0XS03"; /* location*/
      TA1REC.TA1LOCAT[4] = "IO3310"; /* location*/
      TA1REC.TA1DBASE = "DPRODC"; /* database*/
      TA1REC.TA1TBLVU = "VPOITM01"; /* table view*/
      CLXREC.XXXWDTE = CLAREC.CLACLMNB; /* claim number*/
      TA1REC.TA1TBLKE = CLXREC.XXXWDTE; /* table key*/

      XPCL010(); /* error diagnosis routine*/

    end
  end
end // end KL0XS03

// select next pc6rec
Function KL0XS04()

    /* Maintenance History:*/
    /* 06-14-90 CHELLM Replaced pd2rec with pc6rec for fcty po*/
                    /* number verification.*/
    /* 06-18-90 CHELLM Changed the Fcty - PO Nbr edit to a*/
                    /* warning only.*/
    /* 06-06-91 sgorga  Moved code, performed if sqlcode = 100,*/
             /* from this process to process -SFJ to follow the*/
             /* re-edit of po/fcty combo (using parent fcty cd)*/
             /* if the combo is still invalid (not found).*/
   /* *************************************************************/


  CLXREC.CLXCPROC = "CL0XS04"; /* set current proc name*/


  set SQLCA empty;
  call "IO3310" ("N3", SQLCA, PC6REC) {isNoRefresh = yes, isExternal = yes}; /* dprodc.vpoitm01 061490*/


  if (SQLCA.VAGen_SQLCODE == +0)
    CL0XW01.CLPVLDFL[CL0XWIDX] = "Y"; /* yes, po/fcty combo is valid*/
    CL0XW01.CL0XWWPF[CL0XWIDX] = "N";
  else
    if (SQLCA.VAGen_SQLCODE == +100)
      CL0XW01.CLPVLDFL[CL0XWIDX] = "N"; /* no, po combo is not valid*/
    else
      TA1REC.TA1DBASE = "DWPROD";
      TA1REC.TA1TBLVU = "VPDFPO01";
      TA1REC.TA1LOCAT[2] = "CL0XS04";
      XPCL010(); /* abort*/
    end
  end



end // end KL0XS04

// prod price style/color dflts
Function KL0XS70()
   /* 02-07-92  lgross changed hard coded sy5rec.xpycd from '05'*/
   /* to '03'.  Added calculation to compute approximately*/
   /* 98% of this price.*/
   /* 04/05/92  lgross move calculated price to cl0xw01 record, rather*/
   /* than cl0xw02 record because this statement group will*/
   /* be called from kl0x130 rather than kl0xscc*/

  SY5REC.XGPCD = KL0XM005.XGPCD; /* general prod.class*/
  SY5REC.SY1STNBR = KL0XM005.SY1STNBR; /* style*/

   /* style default price has these defaults in the key*/
  /* Commented to move the map variables*/
  /* MOVE '***' TO SY5REC.SY2CLRID;*/
  /* MOVE '**' TO SY5REC.XDMCD;*/
  SY5REC.SY5SZID = 0; /* default size id*/

  SY5REC.XPYCD = "03"; /* price type*/
  SY5REC.XQACD = "01"; /* qualitity code*/

  SY5REC.SY2CLRID = KL0XM005.SY2CLRID; /* move map variables*/
  SY5REC.XDMCD = KL0XM005.XDMCD;
  call "IO0380" ("S ", SQLCA, SY5REC) {isNoRefresh = yes, isExternal = yes}; /* single select*/
  if (SQLCA.VAGen_SQLCODE == 0)
   /* next sentence*/
  else
   /* If row not found for colorcode and dimension from map*/
    SY5REC.SY2CLRID = "***"; /* default color code*/
    SY5REC.XDMCD = "**"; /* default dimension*/
    call "IO0380" ("S ", SQLCA, SY5REC) {isNoRefresh = yes, isExternal = yes}; /* single select*/
  end

  CL0XW01.CLNGRPRC = 0;

  if (SQLCA.VAGen_SQLCODE == 0) /* check for good return*/
    /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      return;
    else
      TA1REC.TA1DBASE = "DPROD";
      TA1REC.TA1TBLVU = "VPRICE01";
      TA1REC.TA1LOCAT[2] = "CL0XS70";
      XPCL010(); /* abort*/
    end
  end

   /* find current price among 6 possible prices*/
   /* new/future date is first, oldest date is last*/
   /* price effective date is today*/
   /* new calculation of price computes approximately 98% of*/
   /* price type '03'*/
  sysVar.arrayIndex = 1; /* check dates ascending seq*/
  while (sysVar.arrayIndex < 7)
    if (SY5REC.SY5PCEDT[sysVar.arrayIndex] <= CL0XW02.CL0XWPED) /* price effective date*/
      CL0XW02.CL0X-WK-PRC = 0; /* initialize work price*/
      CL0XW02.CL0X-WK-PRC = SY5REC.SY5PRCUN[sysVar.arrayIndex] - .02; /* compute*/
      CL0XW02.CL0X-WK-PRC = CL0XW02.CL0X-WK-PRC / 1.0025; /* calculated*/
      CL0XW01.CLNGRPRC = mathLib.round(CL0XW02.CL0X-WK-PRC / 1.015, -mathLib.decimals(CL0XW01.CLNGRPRC)); /* price*/
      sysVar.arrayIndex = 9; /* force loop end*/
    end
    sysVar.arrayIndex = sysVar.arrayIndex + 1;
  end

end // end KL0XS70

// prod cost style/color dflts
Function KL0XS72()
   /* ****************************************************************/
   /* 04-05-92 lgross moved price to cl0xw01 rather than cl0xw02   **/
   /* because sgrp will be called from kl0x130 rather     **/
   /* than kl0xscc                                        **/
   /* 03-11-94 BCourt  Rename SY6CSTFL to XQACD.                   **/
   /* Add country and currency defaults for price.**/
   /* ****************************************************************/

  SY6REC.XGPCD = KL0XM005.XGPCD; /* general prod.class*/
  SY6REC.SY1STNBR = KL0XM005.SY1STNBR; /* style*/

   /* style default price has these defaults in the key*/
  SY6REC.SY2CLRID = KL0XM005.SY2CLRID; /* default color code*/
  SY6REC.XDMCD = KL0XM005.XDMCD; /* default dimension*/

  SY6REC.XCOCD = "01";
  SY6REC.XQACD = "01"; /* quality code /*3-11-94 rename*/
  SY6REC.XCT-CTRY-CD = "USA"; /* 3-11-94 add country*/
  SY6REC.ZFC-CRCY-CD = "USD"; /* 3-11-94 add currency*/

  call "IO0360" ("S ", SQLCA, SY6REC) {isNoRefresh = yes, isExternal = yes}; /* single select*/

  CL0XW01.CLNGRPRC = 0;

  if (SQLCA.VAGen_SQLCODE == 0) /* check for good return*/
    /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      return;
    else
      TA1REC.TA1DBASE = "DPROD";
      TA1REC.TA1TBLVU = "VDCOST01";
      TA1REC.TA1LOCAT[2] = "CL0XS72";
      XPCL010(); /* abort*/
    end
  end

   /* find current cost among 6 possible costs*/
   /* new/future date is first, oldest date is last*/
   /* price effective date is today*/

  sysVar.arrayIndex = 1; /* check dates ascending seq*/
  while (sysVar.arrayIndex < 7)
    if (SY6REC.SY6CSEDT[sysVar.arrayIndex] <= CL0XW02.CL0XWPED) /* price effective date*/
      CL0XW01.CLNGRPRC = SY6REC.SY6CSTUN[sysVar.arrayIndex];
      sysVar.arrayIndex = 9; /* force loop end*/
    end
    sysVar.arrayIndex = sysVar.arrayIndex + 1;
  end

end // end KL0XS72

// validate claim number
Function KL0XSAA()

   /* ************************************************************/
   /* *  this is the execute process that will check to see if  **/
   /* *  the 3 header pieces of data exist.                     **/
   /* *                                                         **/
   /* *          cljrec - return authorization                  **/
   /* *          cl2rec - actual inspection                     **/
   /* *          clorec - defective header data                 **/
   /* *                                                         **/
   /* *  the cl0xw01.cl0xwudf (update flag) is set to 'y' or 'n'**/
   /* *  for the entire program from here.                      **/
   /* *                                                         **/
   /* *  the controller for which screen is presented to the    **/
   /* *  user is done here also.                                **/
   /* *                                                         **/
   /* *  if add mode:            kl0xm001          kl0xm005     **/
   /* *  (header does not exist)  x - header                    **/
   /* *  (header does exist       x - detail                    **/
   /* *                                                         **/
   /* *  if change mode:                                        **/
   /* *  (header does not exist)  x - header                    **/
   /* *  (header does exist                         x - summary **/
   /* *                                                         **/
   /* *  if inquiry mode:                           x - summary **/
   /* *                                                         **/
   /* ************************************************************/

  CLXREC.CLXCPROC = "CL0XSAA"; /* set current process name*/
  CL0XW01.CLACLMNB = CLAREC.CLACLMNB; /* move data to working storage*/
  CL0XW01.CLHSEQNB = CLWREC.CLHSEQNB;
  CL0XW01.CL2ISNBR = CLAREC.CLACISNB; /* inspection nbr*/
  CL0XW01.XGPCD = CLAREC.XGPCD;
  CL0XW01.YCTCD = CLAREC.YCTCD;
  CL0XW01.KUCCONM = CLWREC.KUCCONM;
  CL0XW01.KUCCOID = CLAREC.KUCCOID;
  CL0XW01.KUMSTRID = CLAREC.KUMSTRID;
  CL0XW01.XNXCD = CLAREC.XNXCD;
  KL0XM005.CLATQTY = CLAREC.CLATQTY;
  KL0XM010.CLATQTY = CLAREC.CLATQTY;

  CL0XW01.CL0XWUDF = "N"; /* set update flag to no*/
  CL0XW01.CL0XWEHF = "N"; /* set end of header flag*/
  CL0XW01.CL0XWDEF = "N"; /* set end of detail flag*/

  KL0XSAG(); /* retrieve todays date*/

  CLXREC.XXXCDTE = TA2REC.TA2GRGGN; /* move date to clxrec*/
  CLXREC.XXXFLYY = CLXREC.XXXCYY;
  CLXREC.XXXFLMM = CLXREC.XXXCMM;
  CLXREC.XXXFLDD = CLXREC.XXXCDD;
  CLXREC.XXXSEP5 = "-";
  CLXREC.XXXSEP6 = "-";
  CL0XW01.CL0XMIDT = CLXREC.XXXFLDT;

  set CLOREC empty;
  CLOREC.CLACLMNB = CL0XW01.CLACLMNB; /* claim number*/
  CLOREC.CLHSEQNB = CL0XW01.CLHSEQNB; /* sequence nbr*/
  CLOREC.CL2ISNBR = CL0XW01.CL2ISNBR; /* inspection nbr*/
  KL0XSAC(); /* check defective header exists*/

  set CL2REC empty;
  CL2REC.CLACLMNB = CL0XW01.CLACLMNB; /* claim number*/
  CL2REC.CLHSEQNB = CL0XW01.CLHSEQNB; /* sequence nbr*/
  CL2REC.CL2ISNBR = CL0XW01.CL2ISNBR; /* inspection nbr*/
  KL0XSAD(); /* check actual return exists*/

  if (CL0XW01.CL0XWLFL == "Y" /* actual return add flag*/
   || CL0XW01.CL0XWOFL == "Y") /* defective header add flag*/
    CL0XW01.CL0XWHDF = "N"; /* header is not complete flag*/
  else
    CL0XW01.CL0XWHDF = "Y"; /* header is complete*/
  end

  CLAREC.CLACSQNB = 1;
   /* check values to see if the detail can be updated.*/

  if (COMMAREA.CAFRMAPP == "KL0W"
   || COMMAREA.CAFRMAPP == "KL0J")
    CLXREC.CLXCSCRN = "KL0XM010";
    CL0XW01.CL0XWUDF = "N"; /* force inquiry mode*/
  else
    /* next sentence*/
  end

  if (CLWREC.CLWACTIV == "I")
    CL0XW01.CL0XWUDF = "N";
    CLXREC.CLXCSCRN = "KL0XM010";
  else
    if (CLWREC.CLHSEQNB == CLAREC.CLACSQNB)
      if (CL2REC.CL2ISXDT == CLXREC.XXXCDTE
       /* if not done, or finished today*/
       || CL2REC.CL2ISXDT == 0)
        if (CL0XW01.CL0XWHDF == "N") /* check to see which screen*/
          CLXREC.CLXCSCRN = "KL0XM005"; /* to go to.*/
          CL0XW01.CL0XWUDF = "Y";
        else
          if (CLWREC.CLWACTIV == "C")
            CLXREC.CLXCSCRN = "KL0XM010";
            CL0XW01.CL0XWUDF = "Y";
          else
            CLXREC.CLXCSCRN = "KL0XM005";
            CL0XW01.CL0XWUDF = "Y";
          end
        end
      else
        CL0XW01.CL0XWUDF = "N";
        CLXREC.CLXCSCRN = "KL0XM010";
      end
    else
      CLXREC.CLXCSCRN = "KL0XM010";
      CL0XW01.CL0XWUDF = "N";
    end
  end

end // end KL0XSAA

// check if defect header exists
Function KL0XSAC()

  call "IO1340" ("S ", SQLCA, CLOREC) {isNoRefresh = yes, isExternal = yes}; /* def hdr*/

  if (SQLCA.VAGen_SQLCODE == +0)
    CL0XW01.CL0XWOFL = "N"; /* set actual return add flag to 'n'*/
  else
    if (SQLCA.VAGen_SQLCODE == +100)
      CL0XW01.CL0XWOFL = "Y"; /* set defective header add flag to 'y'*/
    else
      TA1REC.TA1DBASE = "DCLAIM";
      TA1REC.TA1TBLVU = "VDEFHDR01";
      TA1REC.TA1LOCAT[2] = "CL0XSAC";
      XPCL010(); /* error abort routine*/
    end
  end

end // end KL0XSAC

// check actual return
Function KL0XSAD()

  call "IO2870" ("S ", SQLCA, CL2REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == +0)
    CL0XW01.CL0XWLFL = "N"; /* set actual return add flag to 'n'*/
    CLXREC.XXXWDTE = CL2REC.CL2ISBDT;
    CLXREC.XXXFLMM = CLXREC.XXXWMM; /* format long month*/
    CLXREC.XXXFLDD = CLXREC.XXXWDD; /* format long month*/
    CLXREC.XXXFLYY = CLXREC.XXXWYY; /* format long month*/
    CLXREC.XXXSEP5 = "-";
    CLXREC.XXXSEP6 = "-";
    CL0XW01.CL0XMIDT = CLXREC.XXXFLDT;
    CL0XW01.CL2ISXDT = CL2REC.CL2ISXDT;
  else
    if (SQLCA.VAGen_SQLCODE == +100)
      CL0XW01.CL0XWLFL = "Y"; /* set return auth. add flag to 'y'*/
      CL0XW01.CL0XMICF = "N";
    else
      TA1REC.TA1DBASE = "DCLAIM";
      TA1REC.TA1TBLVU = "VRINSP01";
      TA1REC.TA1LOCAT[2] = "CL0XSAD";
      XPCL010(); /* error abort routine*/
    end
  end

end // end KL0XSAD

// get todays date
Function KL0XSAG()

  CLXREC.CLXCPROC = "CL0XSAG";

  set TA2REC empty;
  TA2REC.TA2DTOPT = "GETDATE";
  call "TA0040" (TA2REC) {isNoRefresh = yes, isExternal = yes};

  if (TA2REC.TA2RTNCD != 0)
    CLXREC.CLXVALDT = "N"; /* set valid date flag to no*/
    XPCL010();
  else
    CLXREC.CLXVALDT = "Y"; /* set valid date flag to yes*/
  end

end // end KL0XSAG

// move data to screen headings
Function KL0XSAH()

  KL0XM010.CLACLMNB = CL0XW01.CLACLMNB;
  KL0XM010.CLHSEQNB = CL0XW01.CLHSEQNB;
  KL0XM010.KUCCONM = CL0XW01.KUCCONM;
  KL0XM010.KUCCOID = CL0XW01.KUCCOID;
  KL0XM010.KUMSTRID = CL0XW01.KUMSTRID;
  KL0XM010.XNXCD = CL0XW01.XNXCD;
  KL0XM010.XGPCD = CL0XW01.XGPCD;
  KL0XM010.YCTCD = CL0XW01.YCTCD;

  KL0XM005.CLACLMNB = CL0XW01.CLACLMNB;
  KL0XM005.CLHSEQNB = CL0XW01.CLHSEQNB;
  KL0XM005.KUCCONM = CL0XW01.KUCCONM;
  KL0XM005.KUCCOID = CL0XW01.KUCCOID;
  KL0XM005.KUMSTRID = CL0XW01.KUMSTRID;
  KL0XM005.XNXCD = CL0XW01.XNXCD;
  KL0XM005.XGPCD = CL0XW01.XGPCD;
  KL0XM005.YCTCD = CL0XW01.YCTCD;


   /* 5/89 add code to move abbrevs to maps*/

  if (CL0XW01.XGPCD in XGPTBL.XGPCD /* g.p.c. code*/
   && XGPTBL.XXXSTAT[sysVar.arrayIndex] == "A")
    KL0XM005.XGPABRV = XGPTBL.XGPABRV[sysVar.arrayIndex];
    KL0XM010.XGPABRV = XGPTBL.XGPABRV[sysVar.arrayIndex];
  end

  if (CL0XW01.YCTCD in YCTTBL.YCTCD /* claim type*/
   && YCTTBL.XXXSTAT[sysVar.arrayIndex] == "A")
    KL0XM005.YCTABRV = YCTTBL.YCTABRV[sysVar.arrayIndex];
    KL0XM010.YCTABRV = YCTTBL.YCTABRV[sysVar.arrayIndex];
  end

end // end KL0XSAH

// set all records and maps empty
Function KL0XSAK()
   /* *********************** CL0XSAK ****************************/

    /* Maintenance History:*/
    /* 02-22-90 CHELLM Renamed PD1.. items as FY1.. items.*/
    /* 06-14-90 CHELLM Replaced pd2rec with pc6rec.*/
   /* ************************************************************/


  KL0XM005.CL0XMJAQ = 0;
  set CLAREC empty;
  set CLXREC empty;
  set CLWREC empty;
  set CL0XW01 empty;
  set CL0XW02 empty;
  set CL0XW03 empty;
  set CL0XW04 empty;
  set CL0XW05 empty;
  set CL0XW06 empty;
  set CL0XW07 empty;
  set CL2REC empty; /* inspection recd*/
  set CLOREC empty;
  set CLPREC empty;
  CLPREC.XQACD = "0";
  CLPREC.IV0PARTN = "0";
  set FY1REC empty;
  set PC6REC empty;
  set SYCREC empty;
  set SY1REC empty;
  set SY2REC empty;
  set SY5REC empty;
  set SY6REC empty;
  set TA1REC empty;
  set TA2REC empty;

end // end KL0XSAK

// edit screen data
Function KL0XSBA()
   /* *************************************************************/
   /* * MAINTENANCE HISTORY*/
   /* **/
   /* *  06-06-91  sgorga  Moved processes -SCJ and -SCK from -SCH*/
   /* *                because they are at the same level as -SCH.*/
   /* *               Added code to re-edit po/fcty combo each*/
   /* *               time style or color is modified.*/
   /* *************************************************************/
  CLXREC.CLXCPROC = "CL0XSBA"; /* set current process name*/

  if (KL0XM005.CL0XMFPO[CL0XWIDX] != 0   /* if factory p.o. entered*/
   || KL0XM005.FY1FCTYC[CL0XWIDX] != " " /* or factory code entered*/
   || KL0XM005.YDFCD[CL0XWIDX] != " "    /* or defective code entered*/
   || KL0XM005.CLPDEFQ[CL0XWIDX] != 0)   /* or quantity entered*/
    KL0XSCH(); /* Replicate fcty cd & po on screen, if*/
                                   /* necessary*/
    KL0XSCJ(); /* validate factory code*/
    if (KL0XM005.SY1STNBR is modified /* If style has been modified*/
     || KL0XM005.SY2CLRID is modified) /* or color has been modified*/
      CL0XW01.CL0XWWPF[CL0XWIDX] = "N"; /* (to re-edit combo in -SCK)*/
    end
    KL0XSCK(); /* set up to validate po/fcty combo*/
    KL0XSCE(); /* validate defective code*/
    KL0XSCD(); /* validate credit quantity*/
    if (CLXREC.CLXERRF == "N") /* if no error we have a valid row*/
      CL0XW01.CL0XWCTR = CL0XW01.CL0XWCTR + 1;
    end
  else
    set KL0XM005.CL0XMFPO[CL0XWIDX] initialAttributes; /* set factory po defined*/
    set KL0XM005.FY1FCTYC[CL0XWIDX] initialAttributes; /* set factory code defined*/
    set KL0XM005.YDFCD[CL0XWIDX] initialAttributes; /* set defective code defined*/
    set KL0XM005.CLPDEFQ[CL0XWIDX] initialAttributes; /* set credit qty defined*/
  end

end // end KL0XSBA

// edit product brand code
Function KL0XSBC()
   /* *************************************************************/

    /* Edit the product brand code for customer-product legal*/
    /* entity mis-match.*/

    /* Maintenance History:*/
    /* 05-31-90 CHELLM created*/
    /* 06-26-90 CHELLM Skip the brand code edit if no product*/
                    /* was entered.*/

   /* *************************************************************/

  TA1REC.TA1LOCAT[2] = "CL0XSBC";



   /* If either the claim or the invoice was set up prior*/
   /* to 06-01-90 it doesnt have a brand code, so make sure*/
   /* the legal entity of customer match the legal entity of*/
   /* the product.*/

  if (CLAREC.XBCCD == " ")
    return; /* Product is OK*/
  end



  if (SY1REC.XBCCD != " ") /* if product was found to edit*/
    if (SY1REC.XBCCD != CLAREC.XBCCD) /* if brand codes don't match*/
      converseLib.validationFailed(611); /* Product brand must match claim brand*/
      CLXREC.CLXERRF = "Y";
      CL0XW01.CL0XWCOL = 0;
      set KL0XM005.SY1STNBR cursor, modified, bold;
    end
  end

end // end KL0XSBC

// add required header table info
Function KL0XSBE()

  KL0XSAG(); /* get todays date*/

  if (CL0XW01.CL0XWLFL == "Y") /* go add actual return row*/
    KL0XSBF(); /* cllrec*/
  end

  if (CL0XW01.CL0XWOFL == "Y") /* go add defective header row*/
    KL0XSBG(); /* clorec*/
  end

  if (CLXREC.CLXERRF == "Y")
    /* next sentence*/
  else
    if (CL0XW01.CL0XWLFL == "N" /* add actual return row sucessful*/
     && CL0XW01.CL0XWOFL == "N") /* add defective header row successful*/
      CL0XW01.CL0XWHDF = "Y"; /* end of header flag*/
    end
  end

end // end KL0XSBE

// setup add inspection row
Function KL0XSBF()

  CLXREC.CLXCPROC = "CL0XSBF";

  CL2REC.CLACLMNB = KL0XM005.CLACLMNB;
  CL2REC.CLHSEQNB = KL0XM005.CLHSEQNB;
   /* -------> in future, use map value*/
  CL2REC.CL2ISNBR = CL0XW01.CL2ISNBR; /* inspection nbr*/

  call "IO2870" ("S ", SQLCA, CL2REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == +0)
    CL0XW01.CL0XWLFL = "N"; /* set actual return add flag to 'n'*/
  else
    if (SQLCA.VAGen_SQLCODE == +100)
      KL0XSBJ(); /* add actual return row*/
    else
      if (SQLCA.VAGen_SQLCODE == -911)
        converseLib.validationFailed(4);
        CLXREC.CLXERRF = "Y";
      else
        TA1REC.TA1TBLVU = "DCLAIM";
        TA1REC.TA1TBLVU = "VRINSP01";
        TA1REC.TA1LOCAT[2] = "CL0XSBF";
        XPCL010(); /* error abort routine*/
      end
    end
  end

end // end KL0XSBF

// setup add defective header row
Function KL0XSBG()

  CLOREC.CLACLMNB = KL0XM005.CLACLMNB;
  CLOREC.CLHSEQNB = KL0XM005.CLHSEQNB;
    /* ----> in future, use map value*/
  CLOREC.CL2ISNBR = CL0XW01.CL2ISNBR;

   /* inquire to see if defective header exists*/
  call "IO1340" ("S ", SQLCA, CLOREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == +0)
    CL0XW01.CL0XWOFL = "N"; /* set defective header flag to 'n'*/
  else
    if (SQLCA.VAGen_SQLCODE == +100)
      KL0XSBK(); /* add defective header*/
    else
      if (SQLCA.VAGen_SQLCODE == -911)
        CLXREC.CLXERRF = "Y";
        converseLib.validationFailed(4);
      else
        TA1REC.TA1DBASE = "DCLAIM";
        TA1REC.TA1TBLVU = "VDEFHD01";
        TA1REC.TA1LOCAT[2] = "CL0XSBG";
        XPCL010(); /* error abort routine*/
      end
    end
  end

end // end KL0XSBG

// add inspection row
Function KL0XSBJ()

  set CL2REC empty;

  CL2REC.CLACLMNB = KL0XM005.CLACLMNB;
  CL2REC.CLHSEQNB = KL0XM005.CLHSEQNB;
  CL2REC.XXXUSRID = COMMAREA.CAUSERID; /* TSK# 716 AHOWAR 10/30/91*/
  CL2REC.XWHCD = COMMAREA.XWHCD; /* TSK# 716 AHOWAR 10/30/91*/
    /* ------> in future, use map value*/
  CL2REC.CL2ISNBR = CL0XW01.CL2ISNBR; /* inspection nbr*/
  CL2REC.YCICD = "WSE";
  CL2REC.CLJRDIND = "D";
  CL2REC.CL2TOSLF = "N"; /* GDECKE 02-18-91 CLM TO STOCK LOCATE FLAG*/
  CL2REC.CL2ISBDT = TA2REC.TA2GRGGN;
  CL2REC.ZZZCHGDT = TA2REC.TA2GRGGN;
  CL2REC.ZZZCHGTM = TA2REC.TA2TIMHM;

  call "IO2870" ("A ", SQLCA, CL2REC) {isNoRefresh = yes, isExternal = yes}; /* add actual inspec row*/

  if (SQLCA.VAGen_SQLCODE == +0)
    CL0XW01.CL0XWLFL = "N"; /* set actual return add flag to 'n'*/
  else
    if (SQLCA.VAGen_SQLCODE == -911)
      CLXREC.CLXERRF = "Y";
      converseLib.validationFailed(4);
    else
      TA1REC.TA1DBASE = "DCLAIM";
      TA1REC.TA1TBLVU = "VRINSP01";
      TA1REC.TA1LOCAT[2] = "CL0XSBJ";
      XPCL010(); /* error abort routine*/
    end
  end

end // end KL0XSBJ

// add defective header row
Function KL0XSBK()

  CLXREC.CLXCPROC = "CL0XSBK";

  set CLOREC empty;

  CLOREC.CLACLMNB = KL0XM005.CLACLMNB;
  CLOREC.CLHSEQNB = KL0XM005.CLHSEQNB;
    /* ----> in future, use map value*/
  CLOREC.CL2ISNBR = CL0XW01.CL2ISNBR; /* inspection number*/
  CLOREC.ZZZCHGDT = TA2REC.TA2GRGGN;
  CLOREC.ZZZCHGTM = TA2REC.TA2TIMHM;

  call "IO1340" ("A ", SQLCA, CLOREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == +0)
    CL0XW01.CL0XWOFL = "N"; /* set defective header flag to 'n'*/
  else
    if (SQLCA.VAGen_SQLCODE == -911)
      CLXREC.CLXERRF = "Y";
      converseLib.validationFailed(4);
    else
      TA1REC.TA1DBASE = "DCLAIM";
      TA1REC.TA1TBLVU = "VDEFHD01";
      TA1REC.TA1LOCAT[2] = "CL0XSBK";
      XPCL010(); /* error abort routine*/
    end
  end

end // end KL0XSBK

// add detail rows
Function KL0XSCC()

    /* Maintenance History:*/
    /* 06-14-90 CHELLM Renamed FY2FTYPO to PC3POIDT.*/
    /* 04-23-91 sgorga  Deleted a 2nd unnecessary "select" call*/
       /* to IO1350 that followed the 1st "select call to IO1350.*/
    /* 04-05-92 lgross removed logic to find price for style by*/
    /* gpc.  This will now be accomplished by a call*/
    /* from kl0x130 for kl0xspr.  Will move price from*/
    /* field in cl0xw01.*/
   /* *************************************************************/


  CLXREC.CLXCPROC = "CL0XSCC";

  if (KL0XM005.CL0XMFPO[CL0XWIDX] == 0
   && KL0XM005.FY1FCTYC[CL0XWIDX] == " "
   && KL0XM005.YDFCD[CL0XWIDX] == " "
   && KL0XM005.CLPDEFQ[CL0XWIDX] == 0)
    return;
  end

  KL0XSAG(); /* get todays date*/

  set CLPREC empty;
  CL0XW01.CLGCMSEQ = 0;

   /* the fields below will check for a unique row*/
   /* The map fields are being moved to clprec to add or*/
   /* update detail rows in dclaim.vdefit01*/

  CLPREC.CLACLMNB = KL0XM005.CLACLMNB;
  CLPREC.CLHSEQNB = KL0XM005.CLHSEQNB;
     /* ----> in future, use map value*/
  CLPREC.CL2ISNBR = CL0XW01.CL2ISNBR; /* inspection number*/
  CLPREC.IV0IVCID = 0;
  CLPREC.IV0PARTN = "0";
  CLPREC.XGPCD = KL0XM005.XGPCD;
  CLPREC.SY1STNBR = KL0XM005.SY1STNBR;
  CLPREC.SY2CLRID = KL0XM005.SY2CLRID;
  CLPREC.XDMCD = KL0XM005.XDMCD;
  CLPREC.XUMCD = KL0XM005.XUMCD;
  CLPREC.FY1FCTYC = KL0XM005.FY1FCTYC[CL0XWIDX];

   /* PO Date conversion added 06-14-90*/
  if (KL0XM005.CL0XMFPO[CL0XWIDX] != 0)
    CLXREC.XXXWYMD = KL0XM005.CL0XMFPO[CL0XWIDX];
    if (CLXREC.XXXWYY < 50)
      CLXREC.XXXWCC = 20;
    else
      CLXREC.XXXWCC = 19;
    end
    CLPREC.PC3POIDT = CLXREC.XXXWCYMD;
  else
    CLPREC.PC3POIDT = KL0XM005.CL0XMFPO[CL0XWIDX];
  end

  CLPREC.YDFCD = KL0XM005.YDFCD[CL0XWIDX];
  CLPREC.XQACD = "01";

  CL0XW02.CLNGRPRC[CL0XWIDX] = CL0XW01.CLNGRPRC; /* lgross 4-5-92*/

  CLPREC.CLKCLPRC = CL0XW02.CLNGRPRC[CL0XWIDX];

  call "IO1350" ("S ", SQLCA, CLPREC) {isNoRefresh = yes, isExternal = yes};
                                   /* if defective detail exists*/

  if (SQLCA.VAGen_SQLCODE == +0) /* meaning record exists so this will be*/
                                   /* an update*/
    KL0XSDB(); /* this process updates a defective detail record*/
  else
    if (SQLCA.VAGen_SQLCODE == +100) /* rec doesn't exist so this will be an add*/
      KL0XSDA(); /* this process adds a defective detail record*/
    else
      TA1REC.TA1DBASE = "DCLAIM";
      TA1REC.TA1TBLVU = "VDEFIT01";
      TA1REC.TA1LOCAT[2] = "CL0XSCC";
      TA1REC.TA1LOCAT[4] = "BAD SEL"; /* abend on bad select*/
      XPCL010(); /* error abort routine*/
    end
  end

  KL0XM005.CL0XMFPO[CL0XWIDX] = 0;
  KL0XM005.FY1FCTYC[CL0XWIDX] = " ";
  KL0XM005.YDFCD[CL0XWIDX] = " ";
  KL0XM005.CLPDEFQ[CL0XWIDX] = 0;
  CL0XW01.CL0XWUPD = "Y";

end // end KL0XSCC

// check credit quantity
Function KL0XSCD()

  if (KL0XM005.CLPDEFQ[CL0XWIDX] == 0) /* if credit quantity zero*/
    converseLib.validationFailed(21); /* required field*/
    set KL0XM005.CLPDEFQ[CL0XWIDX] cursor, modified, bold;
    CLXREC.CLXERRF = "Y";
    if (CL0XWHDX == 0)
      CL0XW01.CL0XWHDX = CL0XW01.CL0XWIDX;
      CL0XW01.CL0XWERR = 21;
      CL0XW01.CL0XWCOL = 4;
    end
  else
    set KL0XM005.CLPDEFQ[CL0XWIDX] initialAttributes;
  end

end // end KL0XSCD

// validate defective code
Function KL0XSCE()

  if (KL0XM005.YDFCD[CL0XWIDX] != " ")
    CL0XW01.YDFCD = KL0XM005.YDFCD[CL0XWIDX];
    CL0XW01.CL0XWGPC = KL0XM005.XGPCD;
    if (CL0XW01.YDFKEY in YDFTBL.YDFKEY)
      if (YDFTBL.XXXSTAT[sysVar.arrayIndex] == "A")
        set KL0XM005.YDFCD[CL0XWIDX] initialAttributes;
      else
        CLXREC.CLXERRF = "Y";
        set KL0XM005.YDFCD[CL0XWIDX] cursor, modified, bold;
        converseLib.validationFailed(410); /* no record exist*/
        if (CL0XW01.CL0XWHDX == 0)
          CL0XW01.CL0XWHDX = CL0XW01.CL0XWIDX;
          CL0XW01.CL0XWERR = 410;
          CL0XW01.CL0XWCOL = 3;
        end
      end
    else
      CLXREC.CLXERRF = "Y";
      set KL0XM005.YDFCD[CL0XWIDX] cursor, modified, bold;
      converseLib.validationFailed(410); /* no record exist*/
      if (CL0XW01.CL0XWHDX == 0)
        CL0XW01.CL0XWHDX = CL0XW01.CL0XWIDX;
        CL0XW01.CL0XWERR = 410;
        CL0XW01.CL0XWCOL = 3;
      end
    end
  else
    CLXREC.CLXERRF = "Y";
    set KL0XM005.YDFCD[CL0XWIDX] cursor, modified, bold;
    converseLib.validationFailed(21); /* this is a required field*/
    if (CL0XW01.CL0XWHDX == 0)
      CL0XW01.CL0XWHDX = CL0XW01.CL0XWIDX;
      CL0XW01.CL0XWERR = 21;
      CL0XW01.CL0XWCOL = 3;
    end
  end

end // end KL0XSCE

// retrieve factory/po defaults
Function KL0XSCH()
   /* *************************************************************/
   /* *  MAINTENANCE HISTORY                                     **/
   /* *                                                          **/
   /* *  04-23-91 sgorga  Un-commented code to allow the         **/
   /* *     contract po nbr to replicate down the page in scrn05.**/
   /* *  06-06-91 sgorga  Removed -SCJ and -SCK processes from   **/
   /* *     being performed in this process because they are at  **/
   /* *     at the same level as this process and having them in **/
   /* *     here interfered with re-editing the po/fcty combo.   **/
   /* *     -SCJ and -SCK were moved to -SBA. Added comments.    **/
   /* *************************************************************/

  CLXREC.CLXCPROC = "CL0XSCH";

   /* below commented out 6-18-90;  valid values must be entered*/
  if (CL0XW01.CL0XWIDX == 1) /* If the 1st screen entry is being looked at*/
      /* IF CL0XM005.FY1FCTYC(CL0XWIDX) EQ ' ';*/
        /* OR CL0XM005.CL0XMFPO(CL0XWIDX) EQ 0;*/
        /* CL0XSCO                     ; retrieve default values*/
      /* END ;*/
  else
    CL0XW01.CL0XWINX = CL0XW01.CL0XWIDX - 1;
                                   /* Point INX to prev line on screen*/
      /* IF CL0XM005.CL0XMFPO(CL0XWINX) EQ 0;*/
        /* AND CL0XM005.FY1FCTYC(CL0XWINX) EQ ' ';*/
        /* IF CL0XM005.CL0XMFPO(CL0XWIDX) EQ 0;*/
          /* OR CL0XM005.FY1FCTYC(CL0XWIDX) EQ ' ';*/
          /* CL0XSCO;*/
        /* END ;*/
      /* ELSE ;*/

     /* ** Below checks if fcty cd and cntrt po # need replicated.*/
     /* ** If cntrt po # is blank & fcty cd isn't '99', replicate*/
     /* ** cntrt po # by moving the previous cntrt po # to*/
     /* ** current (IDX).  If fcty cd is blank, same idea.*/

    if (KL0XM005.CL0XMFPO[CL0XWIDX] == 0
     && KL0XM005.FY1FCTYC[CL0XWIDX] != "99")
      KL0XM005.CL0XMFPO[CL0XWIDX] = KL0XM005.CL0XMFPO[CL0XWINX];
      CL0XW01.CL0XWWPF[CL0XWIDX] = CL0XW01.CL0XWWPF[CL0XWINX];
      CL0XW01.CLPVLDFL[CL0XWIDX] = CL0XW01.CLPVLDFL[CL0XWINX];
      if (CL0XW01.CL0XWWPF[CL0XWINX] == "Y")
        set KL0XM005.CL0XMFPO[CL0XWIDX] cursor, bold;
      end
    end
    if (KL0XM005.FY1FCTYC[CL0XWIDX] == " ")
      KL0XM005.FY1FCTYC[CL0XWIDX] = KL0XM005.FY1FCTYC[CL0XWINX];
      CL0XW01.CL0XWWRF[CL0XWIDX] = CL0XW01.CL0XWWRF[CL0XWINX];
      CL0XW01.CLPVLDFL[CL0XWIDX] = CL0XW01.CLPVLDFL[CL0XWINX];
      if (CL0XW01.CL0XWWRF[CL0XWINX] == "Y")
        set KL0XM005.FY1FCTYC[CL0XWIDX] cursor, bold;
      end
    end
  end
   /* END ;*/

end // end KL0XSCH

// validate factory code
Function KL0XSCJ()
   /* *********************** CL0XSCJ *****************************/

    /* Maintenance History:*/
    /* 02-22-90 CHELLM Renamed PD1.. items as FY1.. items.*/
             /* Replaced DWPROD.VFCTY001 with DFCTY.VFCTY001.*/
             /* Replaced IO0870 with IO2810.*/

   /* *************************************************************/

  CLXREC.CLXCPROC = "CL0XSCJ";

   /* IF CL0XW01.CL0XWWRF(CL0XWIDX) EQ 'Y';*/
    /* MOVE 'N' TO CL0XW01.CL0XWWRF(CL0XWIDX);*/
   /* END ;*/

  set KL0XM005.FY1FCTYC[CL0XWIDX] initialAttributes;
   /* IF CL0XM005.FY1FCTYC(CL0XWIDX) IS MODIFIED;*/
    /* ;next sentence*/
   /* ELSE ;*/
    /* EZERTN;*/
   /* END ;*/


  if (KL0XM005.XGPCD == "03") /* if apprl claim*/
    if (KL0XM005.CL0XMFPO[CL0XWIDX] != 0)
      set KL0XM005.FY1FCTYC[CL0XWIDX] cursor, modified, bold;
      converseLib.validationFailed(625); /* if fcty = 99, PO must be blank*/
      CLXREC.CLXERRF = "Y";
      CL0XW01.CL0XWFLG = "X";
      return;
    end
    if (KL0XM005.FY1FCTYC[CL0XWIDX] != "  ")
      set KL0XM005.FY1FCTYC[CL0XWIDX] cursor, modified, bold;
      converseLib.validationFailed(624); /* fcty not allowed on apprl claims*/
      CLXREC.CLXERRF = "Y";
      CL0XW01.CL0XWFLG = "X";
      return;
    end
    return; /* ok; factory or po not needed for apprl claims*/
  end


  if (KL0XM005.FY1FCTYC[CL0XWIDX] == "99"
   && KL0XM005.CL0XMFPO[CL0XWIDX] != 0)
    set KL0XM005.FY1FCTYC[CL0XWIDX] cursor, modified, bold;
    converseLib.validationFailed(614); /* if fcty = 99, PO must be blank*/
    CLXREC.CLXERRF = "Y";
    CL0XW01.CL0XWFLG = "X";
    return;
  end




  if (KL0XM005.FY1FCTYC[CL0XWIDX] == "  ")
    set KL0XM005.FY1FCTYC[CL0XWIDX] cursor, modified, bold;
    converseLib.validationFailed(620); /* if fcty = 99, PO must be blank*/
    CLXREC.CLXERRF = "Y";
    CL0XW01.CL0XWFLG = "X";
    return;
  end


  set FY1REC empty;

  FY1REC.XGPCD = KL0XM005.XGPCD; /* (02-22-90)*/
  FY1REC.FY1FCTYC = KL0XM005.FY1FCTYC[CL0XWIDX];

  call "IO2810" ("S ", SQLCA, FY1REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == +0)
    set KL0XM005.FY1FCTYC[CL0XWIDX] initialAttributes;
    /* IF CL0XW01.CLPVLDFL(CL0XWIDX) EQ 'Y';*/
    /* next sentence*/
    /* ELSE ;*/
      /* MOVE 'N' TO CL0XW01.CLPVLDFL(CL0XWIDX); set warning flag*/
    /* END ;*/
  else
    if (SQLCA.VAGen_SQLCODE == +100)
      set KL0XM005.FY1FCTYC[CL0XWIDX] cursor, modified, bold;
      if (CL0XW01.CL0XWHDX == 0)
        CL0XW01.CL0XWHDX = CL0XW01.CL0XWIDX;
        CL0XW01.CL0XWERR = 363;
        CL0XW01.CL0XWCOL = 2;
      end
      converseLib.validationFailed(363);
      CLXREC.CLXERRF = "Y";
      /* MOVE 'Y' TO CL0XW01.CL0XWWRF(CL0XWIDX); set warning flag*/
      /* MOVE 'Y' TO CL0XW01.CLPVLDFL(CL0XWIDX); set warning flag*/
    else
      TA1REC.TA1DBASE = "DFCTY";
      TA1REC.TA1TBLVU = "VFCTY001";
      TA1REC.TA1LOCAT[2] = "CL0XSCJ";
      TA1REC.TA1LOCAT[2] = "SEL UNQ";
      XPCL010(); /* error abort routine*/
    end
  end

end // end KL0XSCJ

// edit po/fcty combo
Function KL0XSCK()
   /* *************************************************************/
    /* Maintenance History:*/

   /* 02-22-90  CHELLM  Renamed PD1.. items as FY1.. items.*/
   /* 06-14-90  CHELLM  Replaced pd2rec with pc6rec to edit fcty*/
                     /* PO Number.*/
   /* 06-18-90  CHELLM  Changed PO - fcty edit to warning only*/
   /* 06-06-91  sgorga  Added code to do the following:*/
           /* - If the po/fcty combo is not valid (sqlcode =*/
             /* 100; not found), try again using the parent*/
             /* factory code.  If that combo IS valid, it won't*/
             /* be necessary for the warning msg (#364).*/
           /* - Moved code from -S02 (from sqlcode = 100*/
             /* due to invalid combo) to this process to occur*/
             /* after the re-edit if combo is still invalid.*/
           /* - Deleted redundate move to pc6rec.xdmcd.*/
   /* *************************************************************/

  CLXREC.CLXCPROC = "CL0XSCK";

   /* IF CLXREC.CLXERRF = 'Y'        ;  if errors already exist*/
    /* EZERTN                       ;  don't edit combination yet*/
   /* END ;*/

  set KL0XM005.CL0XMFPO[CL0XWIDX] initialAttributes;

  if (KL0XM005.CL0XMFPO[CL0XWIDX] is modified)
    if (CL0XW01.CL0XWWPF[CL0XWIDX] == "Y")
      CL0XW01.CL0XWWPF[CL0XWIDX] = "N";
      return;
    end
  else
    CL0XW01.CL0XWWPF[CL0XWIDX] = "N";
  end

  if (KL0XM005.CL0XMFPO[CL0XWIDX] == 0
   && KL0XM005.FY1FCTYC[CL0XWIDX] != "99"
   && KL0XM005.FY1FCTYC[CL0XWIDX] != " ")
    converseLib.validationFailed(623);
    CL0XW01.CL0XWFLG = "X";
    CLXREC.CLXERRF = "Y";
    CL0XW01.CLPVLDFL[CL0XWIDX] = "N";
    set KL0XM005.CL0XMFPO[CL0XWIDX] cursor, modified, bold;
    return;
  end


  if (KL0XM005.CL0XMFPO[CL0XWIDX] != 0
   && KL0XM005.FY1FCTYC[CL0XWIDX] == "99")
    set KL0XM005.CL0XMFPO[CL0XWIDX] cursor, modified, bold;
    converseLib.validationFailed(614);
    CL0XW01.CL0XWFLG = "X";
    CLXREC.CLXERRF = "Y";
    CL0XW01.CLPVLDFL[CL0XWIDX] = "N";
    return;
  end


  if (KL0XM005.CL0XMFPO[CL0XWIDX] == 0)
    return;
  end

   /* PO Date conversion added 06-14-90*/

  CLXREC.XXXWYMD = KL0XM005.CL0XMFPO[CL0XWIDX];
  if (CLXREC.XXXWYY < 50)
    CLXREC.XXXWCC = 20;
  else
    CLXREC.XXXWCC = 19;
  end

    /* * Set up pc6rec fields for call to database **/
    /* * This info will be used to validate PO/Fcty combo*/

  set PC6REC empty;
  set CL0XW07 empty;
  CL0XW07.CL0XWDT1 = CLXREC.XXXWCYMD;
  CL0XW07.CL0XWDT2 = CLXREC.XXXWCYMD;
  CLPREC.PC3POIDT = CLXREC.XXXWCYMD;

  PC6REC.PC3POIDT = CLXREC.XXXWCYMD; /* Use po id nbr*/
  PC6REC.FY1FCTYC = KL0XM005.FY1FCTYC[CL0XWIDX]; /* and factory cd*/
  PC6REC.XGPCD = KL0XM005.XGPCD; /* and gpc*/
  PC6REC.SY1STNBR = KL0XM005.SY1STNBR; /* and style*/
  PC6REC.SY2CLRID = KL0XM005.SY2CLRID; /* and color*/
  PC6REC.XDMCD = "*"; /* to validate po/fcty combo*/
  PC6REC.PCFSECD = "*";
  PC6REC.PC4ORTYP = "*";
  PC6REC.XQACD = "*";
  PC6REC.XOWCD = "*";
  PC6REC.XPGCD = "*";
  PC6REC.XUMCD = "*";
  PC6REC.XWHCD = "*";
  PC6REC.PC2INSEG = "*";
  PC6REC.PC2CUXID = "*";
  PC6REC.PC6ETSDT = -1;
  PC6REC.YMTCD = "*";
  PC6REC.PC6PLAN = -1;
  PC6REC.XDSCD = "*";
  PC6REC.YSMXDV = "*";
  PC6REC.PC6STAT = "*";

  CL0XW07.CL0XWSQL = "S3"; /* 'S3' is used to declare the cursor*/
  CL0XW01.CL0XWDFL = "Y"; /* deadlock flag*/
  CL0XW01.CL0XWDLC = 0; /* deadlock count*/

  while (CL0XW01.CL0XWDFL == "Y")
    KL0XS01(); /* set cursor up to validate po/fcty combo*/
  end
  if (SQLCA.VAGen_SQLCODE == 0)
    KL0XS02(); /* validate po/fcty combo (select next pc6rec)*/
  end
  KL0XS03(); /* close cursor*/

    /* *If PO/Fcty Combo Invalid, Try Again Using Parent Fcty Cd*/

  if (CL0XW01.CLPVLDFL[CL0XWIDX] == "N") /* if po/fcty combo not valid*/
    PC6REC.FY1FCTYC = FY1REC.FY1PFYCD; /* re-edit with parent fcty cd*/
    CL0XW07.CL0XWSQL = "S3"; /* 'S3' is used to declare the cursor*/
    CL0XW01.CL0XWDFL = "Y"; /* deadlock flag*/
    CL0XW01.CL0XWDLC = 0; /* deadlock count*/
    while (CL0XW01.CL0XWDFL == "Y")
      KL0XS01(); /* set cursor up to validate po/fcty combo*/
    end
    if (SQLCA.VAGen_SQLCODE == 0)
      KL0XS02(); /* validate po/fcty combo (select next pc6rec)*/
      if (CL0XW01.CLPVLDFL[CL0XWIDX] == "N")
                                   /* 5/91 this code moved from -S02*/
        CL0XW01.CL0XWWPF[CL0XWIDX] = "Y"; /* set warning flag*/
        CLXREC.CLXERRF = "Y"; /* set error flag*/
        converseLib.validationFailed(364); /* po combo invalid msg*/
        set KL0XM005.CL0XMFPO[CL0XWIDX] cursor, modified, bold;
        set KL0XM005.FY1FCTYC[CL0XWIDX] modified, bold;
        if (CL0XW01.CL0XWHDX == 0)
          CL0XW01.CL0XWHDX = CL0XW01.CL0XWIDX;
          CL0XW01.CL0XWERR = 364; /* po combo invalid msg*/
          CL0XW01.CL0XWCOL = 1; /* shows po combo is the problem*/
        end
      end
    end
    KL0XS03(); /* close cursor*/
  end


  KL0XSVP();
                                   /* Validate P.O. Delivery Date*/

end // end KL0XSCK

// validate style
Function KL0XSCM()
   /* ***************** MAINTENANCE SECTION *****************************/
   /* COMMENTED OUT KL0XM005.SY1STNBR EQ ' '*/
   /*  */
   /*  */
   /* *******************************************************************/

  CLXREC.CLXCPROC = "CL0XSCM";

   /* IF CL0XW01.CL0XWCTR EQ 0;*/
   /* IF KL0XM005.SY1STNBR EQ ' ';*/
   /* EZERTN;*/
   /* END;*/
   /* END;*/

  set SY1REC empty;
  SY1REC.SY1STNBR = KL0XM005.SY1STNBR;
  SY1REC.XGPCD = KL0XM005.XGPCD;

  call "IO0120" ("S ", SQLCA, SY1REC) {isNoRefresh = yes, isExternal = yes}; /* inquire on style table*/

  if (SQLCA.VAGen_SQLCODE == +0)
    set KL0XM005.SY1STNBR initialAttributes;
    if (KL0XM005.XUMCD == " ")
      KL0XM005.XUMCD = SY1REC.XUMCD;
      set KL0XM005.XUMCD initialAttributes;
    else
      KL0XSCP(); /* validate uom*/
    end
  else
    if (SQLCA.VAGen_SQLCODE == +100)
      CLXREC.CLXERRF = "Y";
      set KL0XM005.SY1STNBR cursor, modified, bold;
      converseLib.validationFailed(200); /* no record exists*/
      CL0XW01.CL0XWCOL = 0;
    else
      TA1REC.TA1DBASE = "DCLAIM";
      TA1REC.TA1TBLVU = "VSTYLE01";
      TA1REC.TA1LOCAT[2] = "CL0XSCM";
      XPCL010(); /* error abort routine*/
    end
  end

end // end KL0XSCM

// validate color/dim
Function KL0XSCN()
   /* *************************************************************/
   /* * MAINTENANCE HISTORY                                      **/
   /* *                                                          **/
   /* * 06-06-91 sgorga  Wrong err msg (200) displayed for       **/
   /* *      invalid color/dim cd.  Replaced it with err msg 689.**/
   /* *      Dim field wasn't hi-liting when color/dim was       **/
   /* *      invalid.  Now dim cd is set to modified,bright.     **/
   /* *      Changed the color cd to be set modified instead of  **/
   /* *      defined when the colr/dim is valid - and added dim  **/
   /* *      to be set modified.                                 **/
   /* *      Blank color cd was defaulting to '00' but blank     **/
   /* *      dim cd wasn't, therefore causing an err msg.  Fixed **/
   /* *      blank dim cd to default to '00' also.               **/
   /* *      Set color/dim to 'normal' from 'defined' to stop    **/
   /* *      the po combo edit from occurring over and over when **/
   /* *      color or dim has been modified.                     **/
   /* **   removed logic to insert '00' when sy2clrid eq '  '     **/
   /* **   or '00';*/
   /* **   01/24/97 CTRAN COMMENTED OUT CODES THAT ALLOWS STYLE*/
   /* **            EQUALS BLANK*/
   /* *************************************************************/
  CLXREC.CLXCPROC = "CL0XSCN";

   /* IF CL0XW01.CL0XWCTR EQ 0;*/
   /* IF KL0XM005.SY1STNBR EQ ' ';*/
   /* OR KL0XM005.SY2CLRID EQ '00 ';*/
   /* EZERTN;*/
   /* END;*/

  set SY2REC empty;

   /* IF KL0XM005.SY2CLRID EQ ' ';*/
                                   /* If color field was left blank,*/
   /* MOVE '00 ' TO KL0XM005.SY2CLRID;        /* default it to zeros.*/
   /* END;*/

                                  /* IF KL0XM005.XDMCD EQ ' ';        /**/
                                   /* If dimension field was left blank,*/
    /* MOVE '00 ' TO KL0XM005.XDMCD;    /* default it to zeros.*/
   /* END;*/

  SY2REC.XGPCD = KL0XM005.XGPCD;
  SY2REC.SY1STNBR = KL0XM005.SY1STNBR;
  SY2REC.SY2CLRID = KL0XM005.SY2CLRID;
  SY2REC.XDMCD = KL0XM005.XDMCD;

  call "IO0130" ("S ", SQLCA, SY2REC) {isNoRefresh = yes, isExternal = yes}; /* EDIT DPROD.VCOLOR01*/

  if (SQLCA.VAGen_SQLCODE == +0) /* if color and dim cd valid*/
    set KL0XM005.SY2CLRID normal;
    set KL0XM005.XDMCD normal;
  else
    if (SQLCA.VAGen_SQLCODE == +100) /* if color and dim cd not valid*/
      CLXREC.CLXERRF = "Y";
      set KL0XM005.SY2CLRID cursor, modified, bold; /* hi-lite color field*/
      set KL0XM005.XDMCD modified, bold; /* hi-lite dimension field*/
      converseLib.validationFailed(689); /* Nike color and/or dimension cd is not valid*/
      CL0XW01.CL0XWCOL = 0;
    else
      TA1REC.TA1DBASE = "DPROD";
      TA1REC.TA1TBLVU = "VCOLOR01";
      TA1REC.TA1LOCAT[2] = "CL0XSCN";
      XPCL010();
    end
  end

end // end KL0XSCN

// validate uom
Function KL0XSCP()

  CLXREC.CLXCPROC = "CL0XSCP";

  if (KL0XM005.XUMCD in XUMTBL.XUMCD)
    if (XUMTBL.XXXSTAT[sysVar.arrayIndex] == "A")
      set KL0XM005.XUMCD initialAttributes;
    else
      CLXREC.CLXERRF = "Y";
      converseLib.validationFailed(409); /* no record exists*/
      CL0XW01.CL0XWCOL = 0;
      if (KL0XM005.SY1STNBR is modified)
        set KL0XM005.XUMCD modified, bold;
      else
        set KL0XM005.SY1STNBR modified;
        set KL0XM005.XUMCD cursor, modified, bold;
      end
    end
  else
    CLXREC.CLXERRF = "Y";
    converseLib.validationFailed(409); /* no record exists*/
    CL0XW01.CL0XWCOL = 0;
    if (KL0XM005.SY1STNBR is modified)
      set KL0XM005.XUMCD modified, bold;
    else
      set KL0XM005.SY1STNBR modified;
      set KL0XM005.XUMCD cursor, modified, bold;
    end
  end

end // end KL0XSCP

// add defective detail
Function KL0XSDA()
   /* *    KL0XSDA  --  ADD DEFECTIVE DETAIL*/
   /* ****************************************************************/
   /* *    M A I N T E N A N C E     H I S T O R Y    L O G         **/
   /* *-------------------------------------------------------------**/
   /* *  CHNG#   DATE   PGMR    DESCRIPTION                         **/
   /* *-------------------------------------------------------------**/
   /* *  #0    02/25/92 GDECKE  USE ABEND TO PREVENT BAD DATA       **/
   /* *-------------------------------------------------------------**/

  CLXREC.CLXCPROC = "CL0XSDA";
  CLPREC.CLPDEFQ = KL0XM005.CLPDEFQ[CL0XWIDX];
  CLPREC.CLPDEFQ = KL0XM005.CLPDEFQ[CL0XWIDX];
  CLPREC.CLPVLDFL = CL0XW01.CLPVLDFL[CL0XWIDX];
  CLPREC.CLKPRCFF = "P";
  CLPREC.ZZZCHGDT = TA2REC.TA2GRGGN;
  CLPREC.ZZZCHGTM = TA2REC.TA2TIMHM;

  CLPREC.IV0IVCID = 0;
  CLPREC.IV0PARTN = "0";
  CLPREC.XQACD = "01";

  CL0XW01.CLATQTY = CL0XW01.CLATQTY + KL0XM005.CLPDEFQ[CL0XWIDX];
  CL0XW01.CL0XWTCA = KL0XM005.CLPDEFQ[CL0XWIDX] * CLPREC.CLKCLPRC;
  CL0XW01.CLAESTVL = CL0XW01.CLAESTVL + CL0XW01.CL0XWTCA;

    /* USE ABEND TO PREVENT BAD DATA*/

  if (CLPREC.XUMCD in XUMTBL.XUMCD)
     /* NEXT SENTENCE*/
  else
    TA1REC.TA1DBASE = "DCLAIM";
    TA1REC.TA1TBLVU = "DEF-XUM2";
    TA1REC.TA1LOCAT[2] = "KL0XSDA";
    XPCL010(); /* error abort routine*/
  end


  if (CLPREC.XDMCD == " ")
    TA1REC.TA1DBASE = "DCLAIM";
    TA1REC.TA1TBLVU = "DEF-XDM2";
    TA1REC.TA1LOCAT[2] = "KL0XSDA";
    XPCL010(); /* error abort routine*/
  end


  if (CLPREC.SY2CLRID == " ")
    TA1REC.TA1DBASE = "DCLAIM";
    TA1REC.TA1TBLVU = "DEF-CLR2";
    TA1REC.TA1LOCAT[2] = "KL0XSDA";
    XPCL010(); /* error abort routine*/
  end


  call "IO1350" ("A ", SQLCA, CLPREC) {isNoRefresh = yes, isExternal = yes}; /* add defective detail*/

  if (SQLCA.VAGen_SQLCODE == +0)
    CL0XW01.CL0XWJAQ = CL0XW01.CL0XWJAQ + KL0XM005.CLPDEFQ[CL0XWIDX];
  else
    if (SQLCA.VAGen_SQLCODE == -911)
      CLXREC.CLXERRF = "Y";
      converseLib.validationFailed(4); /* database is busy*/
    else
      TA1REC.TA1DBASE = "DCLAIM";
      TA1REC.TA1TBLVU = "VDEFIT01";
      TA1REC.TA1LOCAT[2] = "CL0XSDA";
      XPCL010(); /* error abort routine*/
    end
  end

end // end KL0XSDA

// update defective detail
Function KL0XSDB()
   /* *   KLUXSDB  --  UPDATE DEFECTIVE DETAIL*/
   /* **************************************************************/
   /* *   M A I N T E N A N C E    H I S T O R Y    L O G         **/
   /* *-----------------------------------------------------------**/
   /* *   CHNG#    DATE    PGMR    DESCRIPTION                    **/
   /* *-----------------------------------------------------------**/
   /* *  #CL0    02/25/92  GDECKE  USE ABEND TO PREVENT BAD DATA  **/
   /* *-----------------------------------------------------------**/


  CLXREC.CLXCPROC = "CL0XSDB";

  CLPREC.CLPDEFQ = CLPREC.CLPDEFQ + KL0XM005.CLPDEFQ[CL0XWIDX];
  CLPREC.CLPVLDFL = CL0XW01.CLPVLDFL[CL0XWIDX];
  CLPREC.CLKPRCFF = "P";
  CLPREC.ZZZCHGDT = TA2REC.TA2GRGGN;
  CLPREC.ZZZCHGTM = TA2REC.TA2TIMHM;

  CL0XW01.CLATQTY = CL0XW01.CLATQTY + KL0XM005.CLPDEFQ[CL0XWIDX];
  CL0XW01.CL0XWTCA = KL0XM005.CLPDEFQ[CL0XWIDX] * CLPREC.CLKCLPRC;
  CL0XW01.CLAESTVL = CL0XW01.CLAESTVL + CL0XW01.CL0XWTCA;
  CLPREC.XQACD = "01";

    /* if the data got messed up abend the program.*/

  if (CLPREC.XUMCD in XUMTBL.XUMCD)
    /* next sentence*/
  else
    TA1REC.TA1DBASE = "DCLAIM";
    TA1REC.TA1TBLVU = "DEF-UOM1";
    TA1REC.TA1LOCAT[2] = "KL0XSDB";
    XPCL010(); /* error abort routine*/
  end

  if (CLPREC.XDMCD == " ")
    TA1REC.TA1DBASE = "DCLAIM";
    TA1REC.TA1TBLVU = "DEF-XDM1";
    TA1REC.TA1LOCAT[2] = "KL0XSDB";
    XPCL010(); /* error abort routine*/
  end

  if (CLPREC.SY2CLRID == " ")
    TA1REC.TA1DBASE = "DCLAIM";
    TA1REC.TA1TBLVU = "DEF-CLR1";
    TA1REC.TA1LOCAT[2] = "KL0XSDB";
    XPCL010(); /* error abort routine*/
  end


  call "IO1350" ("U ", SQLCA, CLPREC) {isNoRefresh = yes, isExternal = yes}; /* updt defective detail*/

  if (SQLCA.VAGen_SQLCODE == +0)
    CL0XW01.CL0XWJAQ = CL0XW01.CL0XWJAQ + KL0XM005.CLPDEFQ[CL0XWIDX];
  else
    TA1REC.TA1DBASE = "DCLAIM";
    TA1REC.TA1TBLVU = "VDEFIT01";
    TA1REC.TA1LOCAT[2] = "CL0XSDB";
    XPCL010(); /* error abort routine*/
  end

end // end KL0XSDB

// read all claim defectives
Function KL0XSFA()

  set CLPREC empty;
  CLPREC.CLACLMNB = KL0XM010.CLACLMNB; /* this will select*/
  CLPREC.CLHSEQNB = KL0XM010.CLHSEQNB; /* all defective detail*/
     /* ----> in future, use map value*/
  CLPREC.CL2ISNBR = CL0XW01.CL2ISNBR; /* inspection number*/
  CLPREC.IV0IVCID = -1;
  CLPREC.XGPCD = "**";
  CLPREC.SY1STNBR = "******";
  CLPREC.SY2CLRID = "***";
  CLPREC.XDMCD = "**";
  CLPREC.XQACD = "**"; /* 10-04-90*/
  CLPREC.XUMCD = "**"; /* 10-04-90*/

  call "IO1350" ("S1", SQLCA, CLPREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == +0)
    /* next sentence*/
  else
    TA1REC.TA1DBASE = "DCLAIM";
    TA1REC.TA1TBLVU = "VDEFIT01";
    TA1REC.TA1LOCAT[2] = "CL0XSFA";
    TA1REC.TA1LOCAT[4] = "SEL SET";
    XPCL010(); /* error abort routine*/
  end

  CL0XW01.CL0XWEND = "N"; /* end of select data flag*/
  CL0XW01.CL0XWRSW = "N";
  CL0XW01.CL0XWCNT = 0; /* work file record count*/
  CL0XW01.CL0XWHC = 0; /* hold total work file count*/
  CL0XW01.CL0XWIDX = 0;
  CL0XW04.CL0XW4CT = 0; /* set work file count for add*/
  CL0XW04.CL0XW4RC = 0; /* set return code to zero*/
  CL0XW04.CL0XW4FC = "A"; /* set for add*/
  CL0XW04.CL0XW4AP = "KL0X"; /* application name*/
  set CL0XW03 empty;
  CL0XW03.CL0XW3LG = 240; /* record length*/

  while (CL0XW01.CL0XWEND == "N") /* add to temp work file*/
    KL0XSFB(); /* until no more data.*/
  end

  set SQLCA empty;
  call "IO1350" ("C1", SQLCA, CLPREC) {isNoRefresh = yes, isExternal = yes}; /* close cursor*/
  if (SQLCA.VAGen_SQLCODE != 0)
    TA1REC.TA1DBASE = "DCLAIM";
    TA1REC.TA1TBLVU = "VDEFIT01";
    TA1REC.TA1LOCAT[2] = "CL0XSFA";
    TA1REC.TA1LOCAT[4] = "CLS SET";
    XPCL010(); /* error abort routine*/
  end

  VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
  VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
  sysLib.commit();
  VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
  
end // end KL0XSFA

// load temp storage
Function KL0XSFB()

    /* Maintenance History:*/
    /* 06-14-90 CHELLM Renamed FY2FTYPO to PC3POIDT.*/

   /* *************************************************************/


  CLXREC.CLXCPROC = "CL0XSFB";

  set SQLCA empty;
  call "IO1350" ("N1", SQLCA, CLPREC) {isNoRefresh = yes, isExternal = yes}; /* select next*/

  if (SQLCA.VAGen_SQLCODE == +0)
    /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == +100)
      if (CL0XW01.CL0XWRSW == "N") /* if true no records were*/
        converseLib.validationFailed(243); /* were selected*/
      end
      if (CL0XW01.CL0XWIDX > 0)
        CL0XW01.CL0XWCNT = CL0XW01.CL0XWCNT + 1; /* adds last record*/
        CL0XW04.CL0XW4CT = CL0XW01.CL0XWCNT; /* to temp work file*/
        call "TA0050" (CL0XW03, CL0XW04) {isNoRefresh = yes, isExternal = yes};
        if (CL0XW04.CL0XW4RC != 0) /* if bad return code*/
          TA1REC.TA1TYPE = "TMP";
          TA1REC.TA1FUNC = "ABND";
          TA1REC.TA1PGMNM = "CL0XSFB";
          TA1REC.TA1DBASE = " ";
          TA1REC.TA1TBLVU = " ";
          TA1REC.TA1MAP = " ";
          TA1REC.TA1TBLKE = KL0XM010.CLACLMNB;
          TA1REC.TA1LOC = "LOADING TEMP WORK FILE";
          XPCL010();
        end
      end
      CL0XW01.CL0XWHC = CL0XW01.CL0XWCNT;
      CL0XW01.CL0XWRSW = "N";
      CL0XW01.CL0XWEND = "Y";
      return;
    else
      TA1REC.TA1TYPE = "DB2";
      TA1REC.TA1FUNC = "ABND";
      TA1REC.TA1PGMNM = "CL0XSFB";
      TA1REC.TA1DBASE = "DCLAIM";
      TA1REC.TA1TBLVU = "VDEFIT01";
      TA1REC.TA1TBLKE = KL0XM010.CLACLMNB;
      XPCL010(); /* error abort routine*/
    end
  end

  CL0XW01.CL0XWRSW = "Y"; /* records selected switch*/
  CL0XW01.CL0XWIDX = CL0XW01.CL0XWIDX + 1; /* increment index*/
  set CL0XW05 empty;

  CL0XW05.SY1STNBR = CLPREC.SY1STNBR; /* move data to w05.*/
  CL0XW05.SY2CLRID = CLPREC.SY2CLRID;
  CL0XW05.XDMCD = CLPREC.XDMCD;
  CL0XW05.YDDCD = CLPREC.YDDCD;
  CL0XW05.XUMCD = CLPREC.XUMCD;
  CL0XW05.CLKCLPRC = CLPREC.CLKCLPRC;
  CL0XW05.FY1FCTYC = CLPREC.FY1FCTYC;
  CL0XW05.PC3POIDT = CLPREC.PC3POIDT;
  CL0XW05.CLPCRTNB = CLPREC.CLPCRTNB;
  CL0XW05.YDFCD = CLPREC.YDFCD;
  CL0XW05.CLPDEFQ = CLPREC.CLPDEFQ;
  CL0XW05.ZZZCHGCT = CLPREC.ZZZCHGCT;

  CL0XW03.CL0XW3DA[CL0XWIDX] = CL0XW05.CL0XW5RL;

  if (CL0XW01.CL0XWIDX == 6) /* will store up to 6*/
    CL0XW01.CL0XWCNT = CL0XW01.CL0XWCNT + 1; /* db2 records to 1 tmp*/
    CL0XW04.CL0XW4CT = CL0XW01.CL0XWCNT; /* work file record*/
    call "TA0050" (CL0XW03, CL0XW04) {isNoRefresh = yes, isExternal = yes};
    if (CL0XW04.CL0XW4RC != 0)
      TA1REC.TA1TYPE = "TMP";
      TA1REC.TA1FUNC = "ABND";
      TA1REC.TA1PGMNM = "CL0XSFB";
      TA1REC.TA1DBASE = " ";
      TA1REC.TA1TBLVU = " ";
      TA1REC.TA1MAP = " ";
      TA1REC.TA1TBLKE = KL0XM010.CLACLMNB;
      TA1REC.TA1LOC = "LOADING TEMP WORK FILE";
      XPCL010(); /* error abort routine*/
    else
      CL0XW01.CL0XWIDX = 0;
      set CL0XW03 empty;
      CL0XW03.CL0XW3LG = 240;
    end
  end

end // end KL0XSFB

// purge temp work file
Function KL0XSFC()

  CL0XW04.CL0XW4CT = 0;
  CL0XW04.CL0XW4AP = "KL0X"; /* application name*/
  CL0XW04.CL0XW4RC = 0;
  CL0XW04.CL0XW4FC = "P"; /* set to purge*/

  set CL0XW03 empty;
  CL0XW03.CL0XW3LG = 240;

  call "TA0050" (CL0XW03, CL0XW04) {isNoRefresh = yes, isExternal = yes};

  if (CL0XW04.CL0XW4RC != 0)
    TA1REC.TA1TYPE = "TMP";
    TA1REC.TA1FUNC = "ABND";
    TA1REC.TA1TBLVU = "TMPWRKFL";
    TA1REC.TA1DBASE = " ";
    TA1REC.TA1MAP = " ";
    TA1REC.TA1TBLKE = " ";
    TA1REC.TA1PGMNM = "CL0XSFC";
    TA1REC.TA1LOC = "PURGING TEMP WORK FILE";
    XPCL010();
  end

end // end KL0XSFC

// read temp work file
Function KL0XSFD()

  CL0XW04.CL0XW4RC = 0; /* return code*/
  CL0XW03.CL0XW3LG = 240; /* record length*/
  CL0XW01.CL0XWCNT = CL0XW01.CL0XWCNT + 1; /* increment read count*/
  CL0XW01.CL0XWLCT = CL0XW01.CL0XWCNT;
  CL0XW04.CL0XW4CT = CL0XW01.CL0XWCNT;
  CL0XW04.CL0XW4FC = "R"; /* set to read*/
  CL0XW04.CL0XW4AP = "KL0X"; /* application name*/

  if (CL0XW01.CL0XWCNT > CL0XW01.CL0XWHC)
    if (converseVar.validationMsgNum == 0)
      converseLib.validationFailed(3); /* at end of data*/
      set KL0XM010 alarm;
    end
    CL0XW01.CL0XWCN = 3;
    CL0XW01.CL0XWLCT = CL0XW01.CL0XWHC;
    return;
  end

  call "TA0050" (CL0XW03, CL0XW04) {isNoRefresh = yes, isExternal = yes};

  if (CL0XW04.CL0XW4RC == 0) /* good return*/
    CL0XW01.CL0XWCCT = CL0XW01.CL0XWCNT;
  else
    if (CL0XW04.CL0XW4RC == 7) /* end of data in work file*/
      CL0XW01.CL0XWCN = 3;
      CL0XW01.CL0XWLCT = CL0XW01.CL0XWHC;
      return;
    else
      CL0XW01.CL0XWCN = 3;
      TA1REC.TA1TYPE = "TMP";
      TA1REC.TA1FUNC = "ABND";
      TA1REC.TA1PGMNM = "CL0XSFD";
      TA1REC.TA1DBASE = " ";
      TA1REC.TA1TBLVU = " ";
      TA1REC.TA1MAP = " ";
      TA1REC.TA1TBLKE = KL0XM010.CLACLMNB;
      TA1REC.TA1LOC = "READING TEMP WORK FILE";
      XPCL010(); /* abort routine*/
    end
  end

  CL0XW01.CL0XWIDX = 1;

  while (CL0XW01.CL0XWIDX < 7) /* one work record will fill*/
    CL0XW01.CL0XWIN = CL0XW01.CL0XWIN + 1; /* 6 lines on screen*/
    KL0XSFE(); /* move data to screen*/
    CL0XW01.CL0XWIDX = CL0XW01.CL0XWIDX + 1;
  end

  if (CL0XW01.CL0XWCNT >= CL0XW01.CL0XWHC)
    if (converseVar.validationMsgNum == 0)
      converseLib.validationFailed(3); /* end of data*/
      set KL0XM010 alarm;
    end
  end

  set CL0XW03 empty;
  set CL0XW04 empty;

end // end KL0XSFD

// move data to screen
Function KL0XSFE()

    /* Maintenance History:*/
    /* 06-14-90 CHELLM Renamed fy2ftypo map fields to cl0xmfpo.*/
                    /* Renamed w-s fields to pc3poidt.*/
                   /* Added a date conversion to put century into*/
                    /* the w-s date field when moved from the map*/
   /* *************************************************************/


  if (CL0XW03.CL0XW3DA[CL0XWIDX] == " ")
    return;
  end

  CL0XW01.CL0XWCT1[CL0XWIN] = CL0XW01.CL0XWIDX;
  CL0XW01.CL0XWCT2[CL0XWIN] = CL0XW04.CL0XW4CT;
  CL0XW05.CL0XW5RL = CL0XW03.CL0XW3DA[CL0XWIDX];

  KL0XM010.SY1STNBR[CL0XWIN] = CL0XW05.SY1STNBR;
  KL0XM010.SY2CLRID[CL0XWIN] = CL0XW05.SY2CLRID;
  KL0XM010.XDMCD[CL0XWIN] = CL0XW05.XDMCD;
  KL0XM010.XUMCD[CL0XWIN] = CL0XW05.XUMCD;

   /* added 06-14-90*/
  CLXREC.XXXWCYMD = CL0XW05.PC3POIDT;
  KL0XM010.CL0XMFPO[CL0XWIN] = CLXREC.XXXWYMD;

  KL0XM010.FY1FCTYC[CL0XWIN] = CL0XW05.FY1FCTYC;
  KL0XM010.YDFCD[CL0XWIN] = CL0XW05.YDFCD;
  KL0XM010.CLPDEFQ[CL0XWIN] = CL0XW05.CLPDEFQ;
  CL0XW01.CL0XWCT1[CL0XWIN] = CL0XW01.CL0XWIDX;
  CL0XW01.CL0XWCT2[CL0XWIN] = CL0XW01.CL0XWCNT;

  CL0XW06.SY1STNBR[CL0XWIN] = CL0XW05.SY1STNBR;
  CL0XW06.SY2CLRID[CL0XWIN] = CL0XW05.SY2CLRID;
  CL0XW06.XDMCD[CL0XWIN] = CL0XW05.XDMCD;
  CL0XW06.YDDCD[CL0XWIN] = CL0XW05.YDDCD;
  CL0XW06.XUMCD[CL0XWIN] = CL0XW05.XUMCD;
  CL0XW06.CLKCLPRC[CL0XWIN] = CL0XW05.CLKCLPRC;
  CL0XW06.FY1FCTYC[CL0XWIN] = CL0XW05.FY1FCTYC;
  CL0XW06.PC3POIDT[CL0XWIN] = CL0XW05.PC3POIDT;
  CL0XW06.CLPCRTNB[CL0XWIN] = CL0XW05.CLPCRTNB;
  CL0XW06.YDFCD[CL0XWIN] = CL0XW05.YDFCD;
  CL0XW06.CLPDEFQ[CL0XWIN] = CL0XW05.CLPDEFQ;
  CL0XW06.ZZZCHGCT[CL0XWIN] = CL0XW05.ZZZCHGCT;

  if (KL0XM010.XGPCD == SYCREC.XGPCD
   && CL0XW05.SY1STNBR == SYCREC.SY1STNBR
   && CL0XW05.SY2CLRID == SYCREC.SY2CLRID
   && CL0XW05.XDMCD == SYCREC.XDMCD)
    /* next sentence*/
  else
    SYCREC.XGPCD = KL0XM010.XGPCD;
    SYCREC.SY1STNBR = CL0XW05.SY1STNBR;
    SYCREC.SY2CLRID = CL0XW05.SY2CLRID;
    SYCREC.XDMCD = CL0XW05.XDMCD;
    call "IO0560" ("S ", SQLCA, SYCREC) {isNoRefresh = yes, isExternal = yes}; /* read sycrec*/
    if (SQLCA.VAGen_SQLCODE == +0)
      /* next sentence*/
    else
      if (SQLCA.VAGen_SQLCODE == +100)
        set SYCREC empty;
      else
        TA1REC.TA1DBASE = "PROD";
        TA1REC.TA1TBLVU = "VCOLOR02";
        TA1REC.TA1LOCAT[2] = "CL0XSFE";
        XPCL010(); /* abort*/
      end
    end
  end

  KL0XM010.SY1SSTNM[CL0XWIN] = SYCREC.SY1SSTNM;
  KL0XM010.SY2CLRAB[CL0XWIN] = SYCREC.SY2CLRAB;

end // end KL0XSFE

// check credit quantity
Function KL0XSFG()

  if (KL0XM010.CLPDEFQ[CL0XWIDX] == 0)
    converseLib.validationFailed(21);
    set KL0XM010.CLPDEFQ[CL0XWIDX] cursor, modified, bold;
    CLXREC.CLXERRF = "Y";
  else
    set KL0XM010.CLPDEFQ[CL0XWIDX] initialAttributes;
  end

end // end KL0XSFG

// validate defective code
Function KL0XSFH()

  CL0XW01.YDFCD = KL0XM010.YDFCD[CL0XWIDX];
  CL0XW01.CL0XWGPC = KL0XM010.XGPCD;
  if (CL0XW01.YDFKEY in YDFTBL.YDFKEY)
    if (YDFTBL.XXXSTAT[sysVar.arrayIndex] == "A")
      set KL0XM010.YDFCD[CL0XWIDX] initialAttributes;
    else
      CLXREC.CLXERRF = "Y";
      set KL0XM010.YDFCD[CL0XWIDX] cursor, modified, bold;
      converseLib.validationFailed(410);
    end
  else
    CLXREC.CLXERRF = "Y";
    set KL0XM010.YDFCD[CL0XWIDX] cursor, modified, bold;
    converseLib.validationFailed(410);
  end

end // end KL0XSFH

// validate factory code
Function KL0XSFI()

   /* *************************************************************/

    /* Maintenance History:*/
    /* 02-22-90 CHELLM Renamed PD1.. items as FY1.. items.*/
             /* Replaced DWPROD.VFCTY001 with DFCTY.VFCTY001.*/
             /* Replaced IO0870 with IO2810.*/

   /* *************************************************************/

  CLXREC.CLXCPROC = "CL0XSFI";

  if (KL0XM010.FY1FCTYC[CL0XWIDX] is modified
   || KL0XM010.CL0XMFPO[CL0XWIDX] is modified)
    /* next sentence*/
    CL0XW01.CL0XWLIN[CL0XWIDX] = "Y";
  else
     /* MOVE 'N' TO CL0XW01.CL0XWWRF(CL0XWIDX);*/
    return;
  end

  set KL0XM010.FY1FCTYC[CL0XWIDX] initialAttributes;
  set FY1REC empty;

  if (KL0XM010.FY1FCTYC[CL0XWIDX] == " "
   && KL0XM010.CL0XMFPO[CL0XWIDX] == 0)
    KL0XSFO(); /* defalut the factory code*/
     /* EZERTN;*/
  end

  if (KL0XM010.FY1FCTYC[CL0XWIDX] == "99"
   && KL0XM010.CL0XMFPO[CL0XWIDX] != 0)
    set KL0XM010.FY1FCTYC[CL0XWIDX] cursor, modified, bold;
    converseLib.validationFailed(614);
    CL0XW01.CL0XWFLG = "X";
    CLXREC.CLXERRF = "Y";
     /* MOVE 'Y' TO CL0XW01.CL0XWWRF(CL0XWIDX);*/
     /* MOVE 'N' TO CL0XW01.CLPVLDFL(CL0XWIDX);*/
    return;
  end

  if (KL0XM010.FY1FCTYC[CL0XWIDX] == "  ")
    set KL0XM010.FY1FCTYC[CL0XWIDX] cursor, modified, bold;
    converseLib.validationFailed(620);
    CL0XW01.CL0XWFLG = "X";
    CLXREC.CLXERRF = "Y";
     /* MOVE 'Y' TO CL0XW01.CL0XWWRF(CL0XWIDX);*/
     /* MOVE 'N' TO CL0XW01.CLPVLDFL(CL0XWIDX);*/
    return;
  end

  FY1REC.XGPCD = KL0XM010.XGPCD;
                                   /* (02-22-90)*/
  FY1REC.FY1FCTYC = KL0XM010.FY1FCTYC[CL0XWIDX];

  call "IO2810" ("S ", SQLCA, FY1REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == +0)
    /* MOVE 'Y' TO CL0XW01.CLPVLDFL(CL0XWIDX);*/
    /* MOVE 'N' TO CL0XW01.CL0XWWRF(CL0XWIDX);*/
    /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == +100)
      set KL0XM010.FY1FCTYC[CL0XWIDX] cursor, modified, bold;
      converseLib.validationFailed(363);
      CL0XW01.CL0XWFLG = "X";
      CLXREC.CLXERRF = "Y";
      /* MOVE 'Y' TO CL0XW01.CL0XWWRF(CL0XWIDX);*/
      /* MOVE 'N' TO CL0XW01.CLPVLDFL(CL0XWIDX);*/
    else
      TA1REC.TA1DBASE = "DFCTY";
      TA1REC.TA1TBLVU = "VFCTY001";
      TA1REC.TA1LOCAT[2] = "CL0XSFI";
      XPCL010(); /* abort*/
    end
  end

end // end KL0XSFI

// validate p.o. number
Function KL0XSFJ()
   /* ************************************************************/

   /* Maintenance History:*/
   /* 02-22-90  CHELLM  Renamed PD1.. items as FY1.. items.*/
   /* 06-14-90  CHELLM  Replaced PD2REC with PC6REC for PO Edit*/
   /* 06-18-90  CHELLM  Converted the PO - Fcty edit to just*/
                     /* a warning only.*/
   /* 06-06-91  sgorga  Added code to do the following -*/
             /* If the po/fcty  combo is not valid (sql cd = 100;*/
             /* not found), try again using the parent fcty cd.*/
             /* If that combo IS valid, it won't be necessary*/
             /* for warning msg #364 to appear on the screen.*/
             /* Moved code from -S04 (code that goes with sql*/
             /* code = 100 due to invalid combo) to occur in*/
             /* this process, after the re-edit of combo.*/
             /* Deleted redundate move to pc6rec.xdmcd.*/
   /* 06-20-91  sgorga  Fixed old-time production bug.  Summary*/
             /* screen wouldn't  update fcty cd, def cd, or*/
             /* credit qty unless the po nbr id had been changed*/
             /* too, because a flag was set in this process that*/
             /* prevented the update processes from being*/
             /* executed if CL0XM010.CL0XMFPO(CL0XWIDX) wasn't*/
             /* modified.  Deleted the 'Move 'N' to cl0xw01.-*/
             /* cl0xwlin(cl0xwidx) line.*/
   /* ************************************************************/

  CLXREC.CLXCPROC = "CL0XSFJ";

  if (CLXREC.CLXERRF == "Y") /* if errors already exist*/
    return; /* DON't edit combination yet*/
  end

  set KL0XM010.CL0XMFPO[CL0XWIDX] initialAttributes;

  if (KL0XM010.CL0XMFPO[CL0XWIDX] is modified)
    CL0XW01.CL0XWLIN[CL0XWIDX] = "Y";
    if (CL0XW01.CL0XWWPF[CL0XWIDX] == "Y")
      CL0XW01.CL0XWWPF[CL0XWIDX] = "N";
      return;
    end
  else
    CL0XW01.CL0XWWPF[CL0XWIDX] = "N";
    return; /* if the edit is ever changed to a hard edit*/
  end /* THAT's all you need to do for CL0XM010)*/


  if (KL0XM010.CL0XMFPO[CL0XWIDX] == 0
   && KL0XM010.FY1FCTYC[CL0XWIDX] != "99"
   && KL0XM010.FY1FCTYC[CL0XWIDX] != "  ")
    set KL0XM010.CL0XMFPO[CL0XWIDX] cursor, modified, bold;
    converseLib.validationFailed(623);
    CL0XW01.CL0XWFLG = "X";
    CLXREC.CLXERRF = "Y";
    /* MOVE 'Y' TO CL0XW01.CL0XWWRF(CL0XWIDX);*/
    CL0XW01.CLPVLDFL[CL0XWIDX] = "N";
    return;
  end

  if (KL0XM010.CL0XMFPO[CL0XWIDX] == 0)
    KL0XSFP();
    return; /* force edit of fcty po combo*/
  end

   /* PO Date conversion added 06-14-90*/

  CLXREC.XXXWYMD = KL0XM010.CL0XMFPO[CL0XWIDX];
  if (CLXREC.XXXWYY < 50)
    CLXREC.XXXWCC = 20;
  else
    CLXREC.XXXWCC = 19;
  end

    /* * Set up pc6rec fields for call to database **/
    /* * This info will be used to validate po/fcty combo*/

  set PC6REC empty;
  set CL0XW07 empty;
  CL0XW07.CL0XWDT1 = CLXREC.XXXWCYMD;
  CL0XW07.CL0XWDT2 = CLXREC.XXXWCYMD;

  PC6REC.PC3POIDT = CLXREC.XXXWYMD; /* Use po id nbr*/
  PC6REC.FY1FCTYC = KL0XM010.FY1FCTYC[CL0XWIDX]; /* and factory cd*/
  PC6REC.XGPCD = KL0XM010.XGPCD; /* and gpc*/
  PC6REC.SY1STNBR = KL0XM010.SY1STNBR[CL0XWIDX]; /* and style*/
  PC6REC.SY2CLRID = KL0XM010.SY2CLRID[CL0XWIDX]; /* and color*/
  PC6REC.XDMCD = "*";
  PC6REC.PCFSECD = "*";
  PC6REC.PC4ORTYP = "*";
  PC6REC.XQACD = "*";
  PC6REC.XOWCD = "*";
  PC6REC.XPGCD = "*";
  PC6REC.XUMCD = "*";
  PC6REC.XWHCD = "*";
  PC6REC.PC2INSEG = "*";
  PC6REC.PC2CUXID = "*";
  PC6REC.PC6ETSDT = -1;
  PC6REC.YMTCD = "*";
  PC6REC.PC6PLAN = -1;
  PC6REC.XDSCD = "*";
  PC6REC.YSMXDV = "*";
  PC6REC.PC6STAT = "*";

  CL0XW07.CL0XWSQL = "S3"; /* 'S3' is used to declare the cursor*/
  CL0XW01.CL0XWDFL = "Y"; /* deadlock flag*/
  CL0XW01.CL0XWDLC = 0; /* deadlock count*/

  while (CL0XW01.CL0XWDFL == "Y")
    KL0XS01(); /* set cursor up to validate po/fcty combo*/
  end
  if (SQLCA.VAGen_SQLCODE == 0)
    KL0XS04(); /* validate po/fcty combo (select next pc6rec)*/
  end
  KL0XS03(); /* close cursor*/

   /* *If PO/Fcty Combo Invalid, Try Again Using Parent Fcty Cd*/

  if (CL0XW01.CLPVLDFL[CL0XWIDX] == "N") /* If po/fcty combo not valid*/
    PC6REC.FY1FCTYC = FY1REC.FY1PFYCD;
                                   /* use parent fcty cd to re-edit*/
    CL0XW07.CL0XWSQL = "S3"; /* 'S3' is used to declare the cursor*/
    CL0XW01.CL0XWDFL = "Y"; /* deadlock flag*/
    CL0XW01.CL0XWDLC = 0; /* deadlock count*/
    while (CL0XW01.CL0XWDFL == "Y")
      KL0XS01(); /* set cursor up to validate po/fcty combo*/
    end
    if (SQLCA.VAGen_SQLCODE == 0)
      KL0XS04(); /* validate po/fcty combo (select next pc6rec)*/
      if (CL0XW01.CLPVLDFL[CL0XWIDX] == "N") /* If po/fcty combo is not valid*/
        CL0XW01.CL0XWFLG = "X";
        CLXREC.CLXERRF = "Y";
        CL0XW01.CL0XWWPF[CL0XWIDX] = "Y";
        converseLib.validationFailed(364); /* po combo is not valid*/
        set KL0XM010.CL0XMFPO[CL0XWIDX] cursor, modified, bold;
      end
    end
    KL0XS03(); /* close cursor*/
  end

  KL0XSVD();
                                   /* Validate P.O. Delivery Date*/

end // end KL0XSFJ

// update changes
Function KL0XSFN()
    /* KL0XSFN -- UPDATE CHANGES*/
   /* *******************************************************************/
      /* M A I N T E N C E    H I S T O R Y     L O G                 **/
   /* -----------------------------------------------------------------**/
   /* #CHNG   DATE    PGMR    DESCRIPTION                             **/
   /* -----------------------------------------------------------------**/
    /* #0   02/25/92  GDECKE  USE ABEND TO PREVENT BAD DATA           **/
   /* *******************************************************************/

  set CLPREC empty;
  CLPREC.IV0PARTN = "0";
  CLPREC.XQACD = "0";

  if (KL0XM010.CL0XMSEL[CL0XWIDX] == " ")
    if (CL0XW01.CL0XWLIN[CL0XWIDX] == "Y")
      KL0XSFQ(); /* delete and add detail*/
      if (CL0XW01.CL0XWDUP[CL0XWIDX] == "X")
        return;
      end
    else
      KL0XSFR(); /* get def detail for update*/
      if (converseVar.validationMsgNum != 0
       && converseVar.validationMsgNum != 9)
        return;
      end
      if (KL0XM010.CLPDEFQ[CL0XWIDX] != CLPREC.CLPDEFQ)
        KL0XSFS(); /* accum total*/
      end
      CLPREC.CLPDEFQ = KL0XM010.CLPDEFQ[CL0XWIDX];
      KL0XSAG(); /* get todays date*/
      CLPREC.ZZZCHGDT = TA2REC.TA2GRGGN;
      CLPREC.ZZZCHGTM = TA2REC.TA2TIMHM;

    /* USE ABEND TO PREVENT BAD DATA*/

      if (CLPREC.XUMCD in XUMTBL.XUMCD)
     /* NEXT SENTENCE*/
      else
        TA1REC.TA1DBASE = "DCLAIM";
        TA1REC.TA1TBLVU = "DEF-XUM3";
        TA1REC.TA1LOCAT[2] = "KL0XSFN";
        XPCL010(); /* abort*/
      end

      if (CLPREC.XDMCD == " ")
        TA1REC.TA1DBASE = "DCLAIM";
        TA1REC.TA1TBLVU = "DEF-XDM3";
        TA1REC.TA1LOCAT[2] = "KL0XSFN";
        XPCL010(); /* abort*/
      end

      if (CLPREC.SY2CLRID == " ")
        TA1REC.TA1DBASE = "DCLAIM";
        TA1REC.TA1TBLVU = "DEF-CLR3";
        TA1REC.TA1LOCAT[2] = "KL0XSFN";
        XPCL010(); /* abort*/
      end


      call "IO1350" ("U ", SQLCA, CLPREC) {isNoRefresh = yes, isExternal = yes}; /* replace clprec*/
    end
  else
    KL0XSFR();
    if (converseVar.validationMsgNum != 0
     && converseVar.validationMsgNum != 9)
      return;
    end
    CL0XW01.CL0XWOAM = CLPREC.CLPDEFQ * CLPREC.CLKCLPRC;
    CL0XW01.CL0XWTOA = CL0XW01.CL0XWTOA + CL0XW01.CL0XWOAM;
    CL0XW01.CL0XWTOQ = CL0XW01.CL0XWTOQ + CLPREC.CLPDEFQ;
    call "IO1350" ("D ", SQLCA, CLPREC) {isNoRefresh = yes, isExternal = yes}; /* delete clprec*/
  end

  if (SQLCA.VAGen_SQLCODE == +0)
    /* next sentence*/
  else
    if (KL0XM010.CL0XMSEL == " ")
      TA1REC.TA1LOCAT[4] = "UPD REC";
    else
      TA1REC.TA1LOCAT[4] = "DEL REC";
    end
    TA1REC.TA1DBASE = "DCLAIM";
    TA1REC.TA1TBLVU = "VDEFIT01";
    TA1REC.TA1LOCAT[2] = "CL0XSFN";
    XPCL010(); /* abort*/
  end

  if (KL0XM010.CL0XMSEL[CL0XWIDX] == "X")
    KL0XM010.SY1SSTNM[CL0XWIDX] = " ";
    KL0XM010.SY2CLRAB[CL0XWIDX] = " ";
    KL0XM010.CL0XMSEL[CL0XWIDX] = " ";
    KL0XM010.SY1STNBR[CL0XWIDX] = " ";
    KL0XM010.SY2CLRID[CL0XWIDX] = " ";
    KL0XM010.XDMCD[CL0XWIDX] = " ";
    KL0XM010.XUMCD[CL0XWIDX] = " ";
    KL0XM010.FY1FCTYC[CL0XWIDX] = " ";
    KL0XM010.CL0XMFPO[CL0XWIDX] = 0;
    KL0XM010.YDFCD[CL0XWIDX] = " ";
    KL0XM010.CLPDEFQ[CL0XWIDX] = 0;
  end

  CL0XW05.SY1STNBR = KL0XM010.SY1STNBR[CL0XWIDX];
  CL0XW05.SY2CLRID = KL0XM010.SY2CLRID[CL0XWIDX];
  CL0XW05.XDMCD = KL0XM010.XDMCD[CL0XWIDX];
  CL0XW05.XUMCD = KL0XM010.XUMCD[CL0XWIDX];
  CL0XW05.FY1FCTYC = KL0XM010.FY1FCTYC[CL0XWIDX];

   /* PO Date conversion added 06-14-90*/
  if (KL0XM010.CL0XMFPO[CL0XWIDX] != 0)
    CLXREC.XXXWYMD = KL0XM010.CL0XMFPO[CL0XWIDX];
    if (CLXREC.XXXWYY < 50)
      CLXREC.XXXWCC = 20;
    else
      CLXREC.XXXWCC = 19;
    end
    CL0XW05.PC3POIDT = CLXREC.XXXWCYMD;
  else
    CL0XW05.PC3POIDT = KL0XM010.CL0XMFPO[CL0XWIDX];
  end

  CL0XW05.YDFCD = KL0XM010.YDFCD[CL0XWIDX];
  CL0XW05.CLPDEFQ = KL0XM010.CLPDEFQ[CL0XWIDX];
  CL0XW05.CLKCLPRC = CL0XW06.CLKCLPRC[CL0XWIDX];
  if (CL0XW01.CL0XWLIN[CL0XWIDX] == "Y")
    CL0XW05.ZZZCHGCT = 0;
  else
    CL0XW05.ZZZCHGCT = CL0XW06.ZZZCHGCT[CL0XWIDX] + 1;
  end

  CL0XW04.CL0XW4RC = 0;
  CL0XW03.CL0XW3LG = 240;
  CL0XW04.CL0XW4CT = CL0XW01.CL0XWCT2[CL0XWIDX];
  CL0XW04.CL0XW4FC = "R";
  CL0XW04.CL0XW4AP = "KL0X";

  call "TA0050" (CL0XW03, CL0XW04) {isNoRefresh = yes, isExternal = yes};

  if (CL0XW04.CL0XW4RC == 0)
    /* next sentence*/
  else
    TA1REC.TA1TYPE = "TMP";
    TA1REC.TA1FUNC = "ABND";
    TA1REC.TA1PGMNM = "CL0XSFN";
    TA1REC.TA1DBASE = " ";
    TA1REC.TA1TBLVU = " ";
    TA1REC.TA1MAP = " ";
    TA1REC.TA1TBLKE = KL0XM010.CLACLMNB;
    TA1REC.TA1LOC = "READING TEMP WORK FILE";
    XPCL010(); /* abort*/
  end

  CL0XW01.CL0XWCX = CL0XW01.CL0XWCT1[CL0XWIDX];
  CL0XW03.CL0XW3DA[CL0XWCX] = CL0XW05.CL0XW5RL;
  CL0XW04.CL0XW4RC = 0;
  CL0XW03.CL0XW3LG = 240;
  CL0XW04.CL0XW4CT = CL0XW01.CL0XWCT2[CL0XWIDX];
  CL0XW04.CL0XW4AP = "KL0X";
  CL0XW04.CL0XW4FC = "U";

  call "TA0050" (CL0XW03, CL0XW04) {isNoRefresh = yes, isExternal = yes};

  if (CL0XW04.CL0XW4RC == 0)
    /* next sentence*/
  else
    TA1REC.TA1TYPE = "TMP";
    TA1REC.TA1FUNC = "ABND";
    TA1REC.TA1PGMNM = "CL0XSFN";
    TA1REC.TA1DBASE = " ";
    TA1REC.TA1TBLVU = " ";
    TA1REC.TA1MAP = " ";
    TA1REC.TA1TBLKE = KL0XM010.CLACLMNB;
    TA1REC.TA1LOC = "UPDATING TEMP WORK FILE";
    XPCL010();
  end

  CL0XW06.SY1STNBR[CL0XWIDX] = CL0XW05.SY1STNBR;
  CL0XW06.SY2CLRID[CL0XWIDX] = CL0XW05.SY2CLRID;
  CL0XW06.XDMCD[CL0XWIDX] = CL0XW05.XDMCD;
  CL0XW06.XUMCD[CL0XWIDX] = CL0XW05.XUMCD;
  CL0XW06.CLKCLPRC[CL0XWIDX] = CL0XW05.CLKCLPRC;
  CL0XW06.FY1FCTYC[CL0XWIDX] = CL0XW05.FY1FCTYC;
  CL0XW06.PC3POIDT[CL0XWIDX] = CL0XW05.PC3POIDT;
  CL0XW06.YDFCD[CL0XWIDX] = CL0XW05.YDFCD;
  CL0XW06.CLPDEFQ[CL0XWIDX] = CL0XW05.CLPDEFQ;
  CL0XW06.ZZZCHGCT[CL0XWIDX] = CL0XW05.ZZZCHGCT;
  CL0XW01.CL0XWUPD = "Y";

end // end KL0XSFN

// factory code default
Function KL0XSFO()

  if (KL0XM010.XGPCD in YCCTBL.XGPCD)
    if (YCCTBL.XXXSTAT[sysVar.arrayIndex] == "A")
      KL0XM010.FY1FCTYC[CL0XWIDX] = YCCTBL.YCCFCTYC[sysVar.arrayIndex];
      /* MOVE 'Y' TO CL0XW01.CLPVLDFL(CL0XWIDX);*/
      set KL0XM010.FY1FCTYC[CL0XWIDX] initialAttributes;
    else
      CLXREC.CLXERRF = "Y";
      /* MOVE 'N' TO CL0XW01.CLPVLDFL(CL0XWIDX);*/
      converseLib.validationFailed(401);
      set KL0XM010.FY1FCTYC[CL0XWIDX] cursor, modified, bold;
    end
  else
    CLXREC.CLXERRF = "Y";
    /* MOVE 'N' TO CL0XW01.CLPVLDFL(CL0XWIDX);*/
    converseLib.validationFailed(401);
    set KL0XM010.FY1FCTYC[CL0XWIDX] cursor, modified, bold;
  end

end // end KL0XSFO

// factory po default
Function KL0XSFP()

  if (KL0XM010.XGPCD in YCCTBL.XGPCD)
    if (YCCTBL.XXXSTAT[sysVar.arrayIndex] == "A")
      KL0XM010.CL0XMFPO[CL0XWIDX] = YCCTBL.YCCFTYPO[sysVar.arrayIndex];
      CL0XW01.CLPVLDFL[CL0XWIDX] = "N";
      set KL0XM010.CL0XMFPO[CL0XWIDX] initialAttributes;
    else
      CLXREC.CLXERRF = "Y";
      CL0XW01.CLPVLDFL[CL0XWIDX] = "Y";
      converseLib.validationFailed(408);
      set KL0XM010.CL0XMFPO[CL0XWIDX] cursor, modified, bold;
    end
  else
    CLXREC.CLXERRF = "Y";
    CL0XW01.CLPVLDFL[CL0XWIDX] = "Y";
    converseLib.validationFailed(408);
    set KL0XM010.CL0XMFPO[CL0XWIDX] cursor, modified, bold;
  end

end // end KL0XSFP

// delete and add def. detail
Function KL0XSFQ()

    /* Maintenance History:*/
    /* 06-14-90 CHELLM Renamed FY2FTYPO to PC3POIDT.*/
    /* 02-05-92 lgross  Changed call to IO1350 to 'sa' and 'd2'*/
    /* to check for quantity.  This will allow record to be changed*/
    /* for quantity without other fields changed.*/
   /* *************************************************************/


  CL0XW01.CL0XWDUP[CL0XWIDX] = " ";
  CLPREC.CLACLMNB = KL0XM010.CLACLMNB;
  CLPREC.CLHSEQNB = KL0XM010.CLHSEQNB;
     /* ----> in future, use map value*/
  CLPREC.CL2ISNBR = CL0XW01.CL2ISNBR; /* inspection number*/
  CLPREC.IV0IVCID = 0;
  CLPREC.IV0PARTN = "0";
  CLPREC.XGPCD = KL0XM010.XGPCD;
  CLPREC.SY1STNBR = CL0XW06.SY1STNBR[CL0XWIDX];
  CLPREC.SY2CLRID = CL0XW06.SY2CLRID[CL0XWIDX];
  CLPREC.XDMCD = CL0XW06.XDMCD[CL0XWIDX];
  CLPREC.YDDCD = CL0XW06.YDDCD[CL0XWIDX];
  CLPREC.CLKCLPRC = CL0XW06.CLKCLPRC[CL0XWIDX];
  CLPREC.CLPCRTNB = CL0XW06.CLPCRTNB[CL0XWIDX];
  CLPREC.XUMCD = KL0XM010.XUMCD[CL0XWIDX];
  CLPREC.FY1FCTYC = KL0XM010.FY1FCTYC[CL0XWIDX];
  CLPREC.CLPDEFQ = KL0XM010.CLPDEFQ[CL0XWIDX]; /* move qty from map*/

   /* PO Date conversion added 06-14-90*/
  if (KL0XM010.CL0XMFPO[CL0XWIDX] != 0)
    CLXREC.XXXWYMD = KL0XM010.CL0XMFPO[CL0XWIDX];
    if (CLXREC.XXXWYY < 50)
      CLXREC.XXXWCC = 20;
    else
      CLXREC.XXXWCC = 19;
    end
    CLPREC.PC3POIDT = CLXREC.XXXWCYMD;
  else
    CLPREC.PC3POIDT = KL0XM010.CL0XMFPO[CL0XWIDX];
  end

  CLPREC.YDFCD = KL0XM010.YDFCD[CL0XWIDX];
  CLPREC.XQACD = "01";

  call "IO1350" ("SA", SQLCA, CLPREC) {isNoRefresh = yes, isExternal = yes}; /* inquire defective detail*/

  if (SQLCA.VAGen_SQLCODE == +0)
    CLXREC.CLXERRF = "Y";
    set KL0XM010.CL0XMSEL[CL0XWIDX] cursor;
    set KL0XM010.SY1STNBR[CL0XWIDX] skip, bold;
    set KL0XM010.SY2CLRID[CL0XWIDX] skip, bold;
    set KL0XM010.XDMCD[CL0XWIDX] skip, bold;
    set KL0XM010.XUMCD[CL0XWIDX] modified, bold;
    set KL0XM010.FY1FCTYC[CL0XWIDX] modified, bold;
    set KL0XM010.CL0XMFPO[CL0XWIDX] modified, bold;
    set KL0XM010.YDFCD[CL0XWIDX] modified, bold;
    set KL0XM010.CLPDEFQ[CL0XWIDX] modified, bold;
    CL0XW01.CL0XWDUP[CL0XWIDX] = "X";
    converseLib.validationFailed(411);
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
    set KL0XM010.CL0XMSEL[CL0XWIDX] initialAttributes;
    set KL0XM010.SY1STNBR[CL0XWIDX] initialAttributes;
    set KL0XM010.SY2CLRID[CL0XWIDX] initialAttributes;
    set KL0XM010.XDMCD[CL0XWIDX] initialAttributes;
    set KL0XM010.XUMCD[CL0XWIDX] initialAttributes;
    set KL0XM010.FY1FCTYC[CL0XWIDX] initialAttributes;
    set KL0XM010.CL0XMFPO[CL0XWIDX] initialAttributes;
    set KL0XM010.YDFCD[CL0XWIDX] initialAttributes;
    set KL0XM010.CLPDEFQ[CL0XWIDX] initialAttributes;
  else
    TA1REC.TA1DBASE = "DCLAIM";
    TA1REC.TA1TBLVU = "VDEFIT01";
    TA1REC.TA1LOCAT[2] = "CL0XSFQ";
    TA1REC.TA1LOCAT[4] = "SEL UNQ";
    XPCL010(); /* abort*/
  end

  KL0XSAG(); /* get todays date*/

  CLPREC.ZZZCHGDT = TA2REC.TA2GRGGN;
  CLPREC.ZZZCHGTM = TA2REC.TA2TIMHM;
  CLPREC.ZZZCHGCT = 0;
  CLPREC.CLKPRCFF = "P";
  CLPREC.CLPVLDFL = CL0XW01.CLPVLDFL[CL0XWIDX];
  CLPREC.CLPDEFQ = KL0XM010.CLPDEFQ[CL0XWIDX];
  CLPREC.XQACD = "01";

  call "IO1350" ("A ", SQLCA, CLPREC) {isNoRefresh = yes, isExternal = yes}; /* add defective detail*/

  if (SQLCA.VAGen_SQLCODE == +0)
    /* next sentence*/
  else
    TA1REC.TA1DBASE = "DCLAIM";
    TA1REC.TA1TBLVU = "VDEFIT01";
    TA1REC.TA1LOCAT[2] = "CL0XSFQ";
    TA1REC.TA1LOCAT[4] = "ADD REC";
    XPCL010(); /* abort*/
  end

  CLPREC.XUMCD = CL0XW06.XUMCD[CL0XWIDX];
  CLPREC.FY1FCTYC = CL0XW06.FY1FCTYC[CL0XWIDX];
  CLPREC.PC3POIDT = CL0XW06.PC3POIDT[CL0XWIDX];
  CLPREC.YDFCD = CL0XW06.YDFCD[CL0XWIDX];
  CLPREC.CLPDEFQ = CL0XW06.CLPDEFQ[CL0XWIDX]; /* move from previous*/
  CLPREC.ZZZCHGCT = CL0XW06.ZZZCHGCT[CL0XWIDX];
  CLPREC.XQACD = "01";

  call "IO1350" ("SA", SQLCA, CLPREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == +0)
    /* next sentence*/
  else
    TA1REC.TA1DBASE = "DCLAIM";
    TA1REC.TA1TBLVU = "VDEFIT01";
    TA1REC.TA1LOCAT[2] = "CL0XSFQ";
    TA1REC.TA1LOCAT[4] = "SEL UNQ";
    XPCL010(); /* abort*/
  end

  if (KL0XM010.CLPDEFQ[CL0XWIDX] != CLPREC.CLPDEFQ)
    KL0XSFS();
  end

  call "IO1350" ("D2", SQLCA, CLPREC) {isNoRefresh = yes, isExternal = yes}; /* delete defective detail*/

  if (SQLCA.VAGen_SQLCODE == +0)
    /* next sentence*/
  else
    TA1REC.TA1DBASE = "DCLAIM";
    TA1REC.TA1TBLVU = "VDEFIT01";
    TA1REC.TA1LOCAT[2] = "CL0XSFQ";
    TA1REC.TA1LOCAT[4] = "DEL REC";
    XPCL010(); /* abort*/
  end

end // end KL0XSFQ

// set def detail for update
Function KL0XSFR()

    /* Maintenance History:*/
    /* 06-14-90 CHELLM Renamed FY2FTYPO to PC3POIDT.*/

   /* *************************************************************/


  CLPREC.CLACLMNB = KL0XM010.CLACLMNB;
  CLPREC.CLHSEQNB = KL0XM010.CLHSEQNB;
     /* ----> in future, use map value*/
  CLPREC.CL2ISNBR = CL0XW01.CL2ISNBR; /* inspection number*/
  CLPREC.IV0IVCID = 0;
  CLPREC.IV0PARTN = "0";
  CLPREC.XGPCD = KL0XM010.XGPCD;
  CLPREC.SY1STNBR = CL0XW06.SY1STNBR[CL0XWIDX];
  CLPREC.SY2CLRID = CL0XW06.SY2CLRID[CL0XWIDX];
  CLPREC.XDMCD = CL0XW06.XDMCD[CL0XWIDX];
  CLPREC.YDDCD = CL0XW06.YDDCD[CL0XWIDX];
  CLPREC.XUMCD = CL0XW06.XUMCD[CL0XWIDX];
  CLPREC.CLKCLPRC = CL0XW06.CLKCLPRC[CL0XWIDX];
  CLPREC.FY1FCTYC = CL0XW06.FY1FCTYC[CL0XWIDX];
  CLPREC.PC3POIDT = CL0XW06.PC3POIDT[CL0XWIDX];
  CLPREC.CLPCRTNB = CL0XW06.CLPCRTNB[CL0XWIDX];
  CLPREC.YDFCD = CL0XW06.YDFCD[CL0XWIDX];
  CLPREC.ZZZCHGCT = CL0XW06.ZZZCHGCT[CL0XWIDX];
  CLPREC.XQACD = "01";

  call "IO1350" ("S ", SQLCA, CLPREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == +0)
    set KL0XM010.CL0XMSEL[CL0XWIDX] initialAttributes;
    set KL0XM010.SY1STNBR[CL0XWIDX] initialAttributes;
    set KL0XM010.SY2CLRID[CL0XWIDX] initialAttributes;
    set KL0XM010.XDMCD[CL0XWIDX] initialAttributes;
    set KL0XM010.XUMCD[CL0XWIDX] initialAttributes;
    set KL0XM010.FY1FCTYC[CL0XWIDX] initialAttributes;
    set KL0XM010.CL0XMFPO[CL0XWIDX] initialAttributes;
    set KL0XM010.YDFCD[CL0XWIDX] initialAttributes;
  else
    if (SQLCA.VAGen_SQLCODE == +100)
      converseLib.validationFailed(18);
      CLXREC.CLXERRF = "Y";
      set KL0XM010.CL0XMSEL[CL0XWIDX] cursor;
      set KL0XM010.SY1STNBR[CL0XWIDX] bold;
      set KL0XM010.SY2CLRID[CL0XWIDX] bold;
      set KL0XM010.XDMCD[CL0XWIDX] bold;
      set KL0XM010.XUMCD[CL0XWIDX] modified, bold;
      set KL0XM010.FY1FCTYC[CL0XWIDX] modified, bold;
      set KL0XM010.CL0XMFPO[CL0XWIDX] modified, bold;
      set KL0XM010.YDFCD[CL0XWIDX] modified, bold;
      return;
    else
      if (SQLCA.VAGen_SQLCODE == -911)
        converseLib.validationFailed(18);
        CLXREC.CLXERRF = "Y";
        set KL0XM010.CL0XMSEL[CL0XWIDX] cursor;
        set KL0XM010.SY1STNBR[CL0XWIDX] bold;
        set KL0XM010.SY2CLRID[CL0XWIDX] bold;
        set KL0XM010.XDMCD[CL0XWIDX] bold;
        set KL0XM010.XUMCD[CL0XWIDX] modified, bold;
        set KL0XM010.FY1FCTYC[CL0XWIDX] modified, bold;
        set KL0XM010.CL0XMFPO[CL0XWIDX] modified, bold;
        set KL0XM010.YDFCD[CL0XWIDX] modified, bold;
        return;
      else
        TA1REC.TA1DBASE = "DCLAIM";
        TA1REC.TA1TBLVU = "VDEFIT01";
        TA1REC.TA1LOCAT[2] = "CL0XSFR";
        XPCL010(); /* abort*/
      end
    end
  end

end // end KL0XSFR

// store total amounts
Function KL0XSFS()

  if (CL0XW01.CL0XWUDF == "N")
    return;
  end

  CL0XW01.CL0XWOAM = CLPREC.CLPDEFQ * CLPREC.CLKCLPRC;
  CL0XW01.CL0XWNAM = KL0XM010.CLPDEFQ[CL0XWIDX] * CLPREC.CLKCLPRC;
  CL0XW01.CL0XWTOA = CL0XW01.CL0XWTOA + CL0XW01.CL0XWOAM;
  CL0XW01.CL0XWTNA = CL0XW01.CL0XWTNA + CL0XW01.CL0XWNAM;
  CL0XW01.CL0XWTOQ = CL0XW01.CL0XWTOQ + CLPREC.CLPDEFQ;
  CL0XW01.CL0XWTNQ = CL0XW01.CL0XWTNQ + KL0XM010.CLPDEFQ[CL0XWIDX];

end // end KL0XSFS

// edit unit of measure
Function KL0XSFT()
                                    /* 4/91 sgorga*/
  CLXREC.CLXCPROC = "CL0XSFT"; /* corrected to move correct process*/
                                   /* name*/

  if (KL0XM010.XUMCD[CL0XWIDX] in XUMTBL.XUMCD)
    if (XUMTBL.XXXSTAT[sysVar.arrayIndex] == "A")
      set KL0XM010.XUMCD[CL0XWIDX] initialAttributes;
    else
      set KL0XM010.XUMCD[CL0XWIDX] cursor, modified, bold;
      CLXREC.CLXERRF = "Y";
      converseLib.validationFailed(409);
    end
  else
    set KL0XM010.XUMCD[CL0XWIDX] cursor, modified, bold;
    CLXREC.CLXERRF = "Y";
    converseLib.validationFailed(409);
  end

end // end KL0XSFT

// add totals to clarec
Function KL0XSFU()
    /* KL0XSFU  --  ADD TOTALS TO CLAREC*/

   /* **********************************************************************/
   /* *     M A I N T E N A N C E      H I S T O R Y     L O G            **/
   /* *-------------------------------------------------------------------**/
   /* *   DATE    PGMR    DESCRIPTION                                     **/
   /* *-------------------------------------------------------------------**/
   /* * 11-12-93  GDECKE  REMOVE OVERLAPPING MOVE                         **/
   /* **********************************************************************/

  CL0XW01.CL0XWBLD = "N";
  if (CL0XW01.CL0XWUDF == "N")
    return;
  end

  if (CL0XW01.CL0XWTOA == 0
   && CL0XW01.CL0XWTNA == 0
   && CL0XW01.CL0XWTOQ == 0
   && CL0XW01.CL0XWTNQ == 0)
    return;
  end

  CLAREC.CLACLMNB = KL0XM010.CLACLMNB;

  call "IO1160" ("S ", SQLCA, CLAREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == +0)
    /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4);
      CLXREC.CLXERRF = "Y";
      CL0XW01.CL0XWBLD = "Y";
      CL0XW01.CL0XWELF = "Y";
      CL0XW01.CL0XWOAM = 0;
      CL0XW01.CL0XWNAM = 0;
      CL0XW01.CL0XWTOA = 0;
      CL0XW01.CL0XWTNA = 0;
      CL0XW01.CL0XWTOQ = 0;
      CL0XW01.CL0XWTNQ = 0;
      CL0XW01.CLATQTY = 0;
      CL0XW01.CLAESTVL = 0;
      CL0XW01.CL0XWUPD = "N";
      return;
    else
      TA1REC.TA1DBASE = "DCLAIM";
      TA1REC.TA1TBLVU = "VCLHDR01";
      TA1REC.TA1LOCAT[2] = "CL0XSFU";
      XPCL010(); /* abort*/
    end
  end


  CL0XW01.CLAESTVL = CLAREC.CLAESTVL * -1;
  CL0XW01.CLAESTVL = CL0XW01.CLAESTVL - CL0XW01.CL0XWTOA;
  CL0XW01.CLAESTVL = CL0XW01.CLAESTVL + CL0XW01.CL0XWTNA;
  CLAREC.CLAESTVL = CL0XW01.CLAESTVL * -1;

  CLAREC.CLATQTY = CLAREC.CLATQTY - CL0XW01.CL0XWTOQ;
  CLAREC.CLATQTY = CLAREC.CLATQTY + CL0XW01.CL0XWTNQ;

  KL0XSAG();

  CLAREC.ZZZCHGDT = TA2REC.TA2GRGGN;
  CLAREC.ZZZCHGTM = TA2REC.TA2TIMHM;
  CLAREC.CLAWSENF = "Y"; /* worksheet entry flag*/

  call "IO1160" ("U ", SQLCA, CLAREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == +0)
    /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4);
      CL0XW01.CL0XWOAM = 0;
      CL0XW01.CL0XWNAM = 0;
      CL0XW01.CL0XWTOA = 0;
      CL0XW01.CL0XWTNA = 0;
      CL0XW01.CL0XWTOQ = 0;
      CL0XW01.CL0XWTNQ = 0;
      CL0XW01.CLATQTY = 0;
      CL0XW01.CLAESTVL = 0;
      CL0XW01.CL0XWUPD = "N";
      CLXREC.CLXERRF = "Y";
      CL0XW01.CL0XWBLD = "Y";
      CL0XW01.CL0XWELF = "Y";
      return;
    else
      TA1REC.TA1DBASE = "DCLAIM";
      TA1REC.TA1TBLVU = "VDEFIT01";
      TA1REC.TA1LOCAT[2] = "CL0XSFU";
      XPCL010(); /* abort*/
    end
  end

  CLOREC.CLACLMNB = KL0XM010.CLACLMNB;
  CLOREC.CLHSEQNB = KL0XM010.CLHSEQNB;
    /* ----> in future, use map value*/
  CLOREC.CL2ISNBR = CL0XW01.CL2ISNBR; /* inspection number*/

  call "IO1340" ("S ", SQLCA, CLOREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == +0)
    /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4);
      CLXREC.CLXERRF = "Y";
      CL0XW01.CL0XWBLD = "Y";
      CL0XW01.CL0XWELF = "Y";
      CL0XW01.CL0XWOAM = 0;
      CL0XW01.CL0XWNAM = 0;
      CL0XW01.CL0XWTOA = 0;
      CL0XW01.CL0XWTNA = 0;
      CL0XW01.CL0XWTOQ = 0;
      CL0XW01.CL0XWTNQ = 0;
      CL0XW01.CLATQTY = 0;
      CL0XW01.CLAESTVL = 0;
      CL0XW01.CL0XWUPD = "N";
      return;
    else
      TA1REC.TA1DBASE = "DCLAIM";
      TA1REC.TA1TBLVU = "VCLHDR01";
      TA1REC.TA1LOCAT[2] = "CL0XSFU";
      XPCL010();
    end
  end


  CLOREC.CLODMAMT = CLOREC.CLODMAMT - CL0XW01.CL0XWTOA;
  CLOREC.CLODMAMT = CLOREC.CLODMAMT + CL0XW01.CL0XWTNA;

  CLOREC.CLOTDFQY = CLOREC.CLOTDFQY - CL0XW01.CL0XWTOQ;
  CLOREC.CLOTDFQY = CLOREC.CLOTDFQY + CL0XW01.CL0XWTNQ;

  CLOREC.ZZZCHGDT = TA2REC.TA2GRGGN;
  CLOREC.ZZZCHGTM = TA2REC.TA2TIMHM;

  call "IO1340" ("U ", SQLCA, CLOREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == +0)
    /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4);
      CLXREC.CLXERRF = "Y";
      CL0XW01.CL0XWBLD = "Y";
      CL0XW01.CL0XWELF = "Y";
      CL0XW01.CL0XWOAM = 0;
      CL0XW01.CL0XWNAM = 0;
      CL0XW01.CL0XWTOA = 0;
      CL0XW01.CL0XWTNA = 0;
      CL0XW01.CL0XWTOQ = 0;
      CL0XW01.CL0XWTNQ = 0;
      CL0XW01.CLATQTY = 0;
      CL0XW01.CLAESTVL = 0;
      CL0XW01.CL0XWUPD = "N";
      return;
    else
      TA1REC.TA1DBASE = "DCLAIM";
      TA1REC.TA1TBLVU = "VDEFIT01";
      TA1REC.TA1LOCAT[2] = "CL0XSFU";
      XPCL010(); /* abend*/
    end
  end

  KL0XM005.CLATQTY = CLAREC.CLATQTY;
  KL0XM010.CLATQTY = CLAREC.CLATQTY;
  CL0XW01.CL0XWOAM = 0;
  CL0XW01.CL0XWNAM = 0;
  CL0XW01.CL0XWTOA = 0;
  CL0XW01.CL0XWTNA = 0;
  CL0XW01.CL0XWTOQ = 0;
  CL0XW01.CL0XWTNQ = 0;
  CL0XW01.CLATQTY = 0;
  CL0XW01.CLAESTVL = 0;
  CL0XW01.CL0XWUPD = "N";

end // end KL0XSFU

// go to specified style/color
Function KL0XSFZ()

  CL0XW04.CL0XW4RC = 0;
  CL0XW03.CL0XW3LG = 240;
  CL0XW01.CL0XWCNT = CL0XW01.CL0XWCNT + 1;
  CL0XW04.CL0XW4CT = CL0XW01.CL0XWCNT;
  CL0XW04.CL0XW4FC = "R";
  CL0XW04.CL0XW4AP = "KL0X";

  if (CL0XW01.CL0XWCNT > CL0XW01.CL0XWHC)
    set KL0XM010 alarm;
    converseLib.validationFailed(9);
    if (CL0XW01.CL0XWLCT < 3)
      CL0XW01.CL0XWCNT = 0;
    else
      CL0XW01.CL0XWCNT = CL0XW01.CL0XWLCT - 3;
    end
    CL0XW01.CL0XWEND = "Y";
    return;
  end

  call "TA0050" (CL0XW03, CL0XW04) {isNoRefresh = yes, isExternal = yes};

  if (CL0XW04.CL0XW4RC == 0)
    /* next sentence*/
  else
    if (CL0XW04.CL0XW4RC == 7)
      converseLib.validationFailed(9);
      set KL0XM010 alarm;
      if (CL0XW01.CL0XWLCT < 3)
        CL0XW01.CL0XWCNT = 0;
      else
        CL0XW01.CL0XWCNT = CL0XWLCT - 3;
      end
      CL0XW01.CL0XWEND = "Y";
      return;
    else
      TA1REC.TA1TYPE = "TMP";
      TA1REC.TA1FUNC = "ABND";
      TA1REC.TA1PGMNM = "CL0XSFZ";
      TA1REC.TA1DBASE = " ";
      TA1REC.TA1TBLVU = " ";
      TA1REC.TA1TBLKE = KL0XM010.CLACLMNB;
      TA1REC.TA1LOC = "READING TEMP WORK FILE";
      XPCL010(); /* abort*/
    end
  end

  CL0XW01.CL0XWIDX = 1;

  while (CL0XW01.CL0XWIDX < 7)
    CL0XW05.CL0XW5RL = CL0XW03.CL0XW3DA[CL0XWIDX];
    if (CL0XW01.SY1STNBR == CL0XW05.SY1STNBR)
      if (CL0XW01.SY2CLRID != " ")
        if (CL0XW01.SY2CLRID == CL0XW05.SY2CLRID)
          CL0XW01.CL0XWEND = "Y";
          CL0XW01.CL0XWELF = "Y";
          CL0XW01.CL0XWSKP = "X";
          CL0XW01.CL0XWIDX = 7;
          CL0XW01.CL0XWCNT = CL0XW01.CL0XWCNT - 1;
        end
      else
        CL0XW01.CL0XWEND = "Y";
        CL0XW01.CL0XWELF = "Y";
        CL0XW01.CL0XWSKP = "X";
        CL0XW01.CL0XWIDX = 7;
        CL0XW01.CL0XWCNT = CL0XW01.CL0XWCNT - 1;
      end
    end
    CL0XW01.CL0XWIDX = CL0XW01.CL0XWIDX + 1;
  end

end // end KL0XSFZ

// check if inspection complete
Function KL0XSHG()
   /* ***********************************************************************/
   /* 01-22-92  lgross if cl0xmicf = 'y' check for eom indicator          **/
   /* if eom indicator is yes, don't update files send   **/
   /* warning message back                               **/
   /* ***********************************************************************/
  CLXREC.CLXCPROC = "CL0XSHG"; /* set current process name*/

  if (KL0XM005.CL0XMICF == "Y") /* if insp. complete*/
    KL0XSIG(); /* check for eom*/
  else
    CLXREC.CLXERRF = "Y"; /* error*/
    converseLib.validationFailed(19);
    set KL0XM005.CL0XMICF cursor, modified, bold;
    return;
  end

  if (CL0XW01.CL0XWICF == "Y") /* if eom warning indicator = 'y'*/
    return; /* don't update files*/
  end
  KL0XSAG(); /* retrieve todays date*/

  set CL2REC empty;
  CL2REC.CLACLMNB = CL0XW01.CLACLMNB;
  CL2REC.CLHSEQNB = CL0XW01.CLHSEQNB;
  CL2REC.CL2ISNBR = CL0XW01.CL2ISNBR; /* inspection nbr*/

  KL0XSHI(); /* update completion date*/
                                 /* ; in actual return*/
  set CLAREC empty;
  CLAREC.CLACLMNB = CL0XW01.CLACLMNB;
  KL0XSHJ(); /* update the claim header*/
                                 /* ; status code*/

  CL0XW01.CL0XWDEF = "Y";
  CLXREC.CLXEOSF = "Y";
  CLXREC.CLXEOAF = "Y";
  COMMAREA.CATOAP = "KL0E";
  XPCL002(); /* transfer out of application*/

end // end KL0XSHG

// ret & update actual return
Function KL0XSHI()

  CLXREC.CLXCPROC = "CL0XSHI";

  call "IO2870" ("S ", SQLCA, CL2REC) {isNoRefresh = yes, isExternal = yes}; /* retrieve inspection*/

  if (SQLCA.VAGen_SQLCODE == +0)
    KL0XSHM(); /* update inspection*/
  else
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(18);
      CLXREC.CLXERRF = "Y";
      return;
    else
      TA1REC.TA1DBASE = "DCLAIM";
      TA1REC.TA1TBLVU = "VRINSP01";
      TA1REC.TA1LOCAT[2] = "CL0XSHI";
      XPCL010(); /* error abort routine*/
    end
  end


end // end KL0XSHI

// ret & update claim header
Function KL0XSHJ()

  CLXREC.CLXCPROC = "CL0XSHJ";

  call "IO1160" ("S ", SQLCA, CLAREC) {isNoRefresh = yes, isExternal = yes}; /* retrieve claim record*/

  if (SQLCA.VAGen_SQLCODE == +0)
    KL0XSHN(); /* update clarec*/
  else
    if (SQLCA.VAGen_SQLCODE == -911)
      CLXREC.CLXERRF = "Y";
      converseLib.validationFailed(18);
      return;
    end
  end

end // end KL0XSHJ

// replace cllrec
Function KL0XSHM()

  CLXREC.CLXCPROC = "CL0XSHM";

  CL2REC.CL2ISXDT = TA2REC.TA2GRGGN; /* proc/inspec completion date*/
  CL2REC.XXXUSRID = COMMAREA.CAUSERID;
  CL2REC.ZZZCHGDT = TA2REC.TA2GRGGN;
  CL2REC.ZZZCHGTM = TA2REC.TA2TIMHM;

  call "IO2870" ("U ", SQLCA, CL2REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == +0)
    /* next sentence*/
  else
    TA1REC.TA1DBASE = "DCLAIM";
    TA1REC.TA1TBLVU = "VRINSP01";
    TA1REC.TA1LOCAT[2] = "CL0XSHM";
    XPCL010(); /* error abort routine*/
  end

end // end KL0XSHM

// replace clarec
Function KL0XSHN()

  CLXREC.CLXCPROC = "CL0XSHN";

  CLAREC.YCSCD1 = "RPM"; /* current status*/
  if (CLAREC.YCSCD1 in YCSTBL.YCSCD)
    if (YCSTBL.XXXSTAT[sysVar.arrayIndex] == "A")
      CLAREC.YCSACTCD = YCSTBL.YCSACTCD[sysVar.arrayIndex];
      CLAREC.YCSRPTEX = YCSTBL.YCSRPTEX[sysVar.arrayIndex];
      CLAREC.CLASCGBY = COMMAREA.CAUSERID; /* track userid of update*/
    end
  end

  CLAREC.ZZZCHGDT = TA2REC.TA2GRGGN;
  CLAREC.ZZZCHGTM = TA2REC.TA2TIMHM;
  CLAREC.CLAWSENF = "Y"; /* worksheet entry flag*/

  call "IO1160" ("U ", SQLCA, CLAREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == +0)
    /* next sentence*/
  else
    TA1REC.TA1DBASE = "DCLAIM";
    TA1REC.TA1TBLVU = "VCLHDR01";
    TA1REC.TA1LOCAT[2] = "CL0XSHN";
    XPCL010(); /* error abort routine*/
  end

end // end KL0XSHN

// check insp complete flag
Function KL0XSHO()
   /* *****************************************************************/
   /* 01-22-92  lgross   Added call to kl0xsic when cloxmicf eq 'y' **/
   /* Don't update records when cloxwicf eq 'y'  **/
   /* *****************************************************************/

  CLXREC.CLXCPROC = "CL0XSHO";

  if (KL0XM010.CL0XMICF == "Y") /* if insp. complete*/
    KL0XSIC(); /* check for eom date*/
  else
    converseLib.validationFailed(19);
    CLXREC.CLXERRF = "Y";
    set KL0XM010.CL0XMICF cursor, modified, bold;
    return;
  end

  if (CL0XW01.CL0XWICF == "Y") /* eom warning given*/
    return; /* don't update files*/
  end
  KL0XSAG(); /* todays date*/

  set CL2REC empty;
  CL2REC.CLACLMNB = KL0XM010.CLACLMNB;
  CL2REC.CLHSEQNB = KL0XM010.CLHSEQNB;
   /* ---------> in future, use map value*/
  CL2REC.CL2ISNBR = CL0XW01.CL2ISNBR; /* inspection nbr*/

  KL0XSHI(); /* update complete date*/
                                  /* ; in actual return*/
  set CLAREC empty;
  CLAREC.CLACLMNB = KL0XM010.CLACLMNB;

  KL0XSHJ(); /* update the claim header*/
                                  /* ; status code*/
  CL0XW01.CL0XWELF = "Y";
  CLXREC.CLXEOSF = "Y";
  CLXREC.CLXEOAF = "Y";
  COMMAREA.CATOAP = "KL0E";

end // end KL0XSHO

// add totals to clarec
Function KL0XSHP()
      /* kl0xshp -- add totals to clarec*/
   /* *******************************************************************/
   /* *     M A I N T E N A N C E     H I S T O R Y    L O G           **/
   /* *----------------------------------------------------------------**/
   /* *   DATE    PGMR    DESCRIPTION                                  **/
   /* *----------------------------------------------------------------**/
   /* * 11-12-93  GDECKE  REMOVE OVERLAPPING MOVE                      **/
   /* *******************************************************************/

  CL0XW01.CL0XWBLD = "N";
  if (CL0XW01.CL0XWUDF == "N")
    return;
  end

  if (CL0XW01.CLAESTVL == 0
   && CL0XW01.CLATQTY == 0)
    return;
  end

  CLAREC.CLACLMNB = KL0XM005.CLACLMNB;

  call "IO1160" ("S ", SQLCA, CLAREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == +0)
    /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(339);
      CLXREC.CLXERRF = "Y";
      CL0XW01.CL0XWBLD = "Y";
      CL0XW01.CLAESTVL = 0;
      CL0XW01.CLATQTY = 0;
      CL0XW01.CL0XWTCQ = 0;
      CL0XW01.CL0XWUPD = "N";
      return;
    else
      TA1REC.TA1DBASE = "DCLAIM";
      TA1REC.TA1TBLVU = "VCLHDR01";
      TA1REC.TA1LOCAT[2] = "CL0XSHP";
      XPCL010(); /* abort*/
    end
  end


  CLAREC.CLAESTVL = CLAREC.CLAESTVL - CL0XW01.CLAESTVL;
  CLAREC.CLATQTY = CLAREC.CLATQTY + CL0XW01.CLATQTY;

  KL0XSAG(); /* todays date*/

  CLAREC.ZZZCHGDT = TA2REC.TA2GRGGN;
  CLAREC.ZZZCHGTM = TA2REC.TA2TIMHM;
  CLAREC.CLAWSENF = "Y"; /* worksheet entry flag*/

  call "IO1160" ("U ", SQLCA, CLAREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == +0)
    /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(339);
      CLXREC.CLXERRF = "Y";
      CL0XW01.CL0XWBLD = "Y";
      CL0XW01.CLAESTVL = 0;
      CL0XW01.CLATQTY = 0;
      CL0XW01.CL0XWTCQ = 0;
      CL0XW01.CL0XWUPD = "N";
      return;
    else
      TA1REC.TA1DBASE = "DCLAIM";
      TA1REC.TA1TBLVU = "VCLHDR01";
      TA1REC.TA1LOCAT[2] = "CL0XSHP";
      XPCL010(); /* abort*/
    end
  end

  CLOREC.CLACLMNB = KL0XM005.CLACLMNB;
  CLOREC.CLHSEQNB = KL0XM005.CLHSEQNB;
     /* ----> in future, use map value*/
  CLOREC.CL2ISNBR = CL0XW01.CL2ISNBR; /* inspection number*/

  call "IO1340" ("S ", SQLCA, CLOREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == +0)
    /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(339);
      CLXREC.CLXERRF = "Y";
      CL0XW01.CL0XWBLD = "Y";
      CL0XW01.CLAESTVL = 0;
      CL0XW01.CLATQTY = 0;
      CL0XW01.CL0XWTCQ = 0;
      CL0XW01.CL0XWUPD = "N";
      return;
    else
      TA1REC.TA1DBASE = "DCLAIM";
      TA1REC.TA1TBLVU = "VCLRTN01";
      TA1REC.TA1LOCAT[2] = "CL0XSHP";
      XPCL010(); /* abort*/
    end
  end


  CLOREC.CLODMAMT = CLOREC.CLODMAMT + CL0XW01.CLAESTVL;
  CLOREC.CLOTDFQY = CLOREC.CLOTDFQY + CL0XW01.CLATQTY;
  CLOREC.ZZZCHGDT = TA2REC.TA2GRGGN;
  CLOREC.ZZZCHGTM = TA2REC.TA2TIMHM;

  call "IO1340" ("U ", SQLCA, CLOREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == +0)
    /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(339);
      CLXREC.CLXERRF = "Y";
      CL0XW01.CL0XWBLD = "Y";
      CL0XW01.CLAESTVL = 0;
      CL0XW01.CLATQTY = 0;
      CL0XW01.CL0XWTCQ = 0;
      CL0XW01.CL0XWUPD = "N";
      return;
    else
      TA1REC.TA1DBASE = "DCLAIM";
      TA1REC.TA1TBLVU = "VCLRTN01";
      TA1REC.TA1LOCAT[2] = "CL0XSHP";
      XPCL010();
    end
  end

  KL0XM005.CLATQTY = CLAREC.CLATQTY;
  KL0XM010.CLATQTY = CLAREC.CLATQTY;
  KL0XM005.CL0XMJAQ = CL0XW01.CL0XWJAQ;
  CL0XW01.CLAESTVL = 0;
  CL0XW01.CLATQTY = 0;
  CL0XW01.CL0XWTCQ = 0;
  CL0XW01.CL0XWUPD = "N";

end // end KL0XSHP

// CHECK FOR PAST 20TH OF MONTH
Function KL0XSIC()
   /* This statement group will check the date of the month the inspection*/
   /* flag is being entered.  If this is the 20th of the month or later,*/
   /* 'y' will not be accepted until a warning message has been*/
   /* displayed.  If the user does not change the value entered, the*/
   /* application will accept 'y' in the inspection complete field.*/
   /* 01-22-92     lgross           installation*/
   /* **********************************************************************/
  if (CL0XW01.CL0XWICF == "Y") /* if warning has already been given*/
    CL0XW01.CL0XWICF = "N"; /* accept value entered*/
  else
    if (CLXREC.XXXCDD > 20) /* if at the end of the month*/
      CL0XW01.CL0XWICF = "Y"; /* set warning indicator*/
      converseLib.validationFailed(699); /* display warning message*/
      CLXREC.CLXERRF = "Y";
      set KL0XM010.CL0XMICF cursor, modified, bold;
      return;
    else
      CL0XW01.CL0XWICF = "N"; /* accept value entered*/
    end
  end
end // end KL0XSIC

// CHECK FOR PAST 20TH OF MONTH
Function KL0XSIG()
   /* This statement group will check the date of the month the inspection*/
   /* flag is being entered.  If this is the 20th of the month or later,*/
   /* 'y' will not be accepted until a warning message has been*/
   /* displayed.  If the user does not change the value entered, the*/
   /* application will accept 'y' in the inspection complete field.*/
   /* 01-22-92     lgross           installation*/
   /* **********************************************************************/
  if (CL0XW01.CL0XWICF == "Y") /* if warning has already been given*/
    CL0XW01.CL0XWICF = "N"; /* accept value entered*/
  else
    if (CLXREC.XXXCDD > 20) /* if at the end of the month*/
      CL0XW01.CL0XWICF = "Y"; /* set warning indicator*/
      converseLib.validationFailed(699); /* display warning message*/
      CLXREC.CLXERRF = "Y";
      set KL0XM005.CL0XMICF cursor, modified, bold;
      return;
    else
      CL0XW01.CL0XWICF = "N"; /* accept value entered*/
    end
  end
end // end KL0XSIG

// obtain prices for this style
Function KL0XSPR()
   /* **************************************************************/
   /* this statement group will obtain prices for the given style**/
   /* based on gpc code                                          **/
   /* 04/05/92   lgross   created sgrp                           **/
   /* 01/24/97   CTRAN    COMMENTED KL0XM005.SY1STNBR EQ ' '     **/
   /* **************************************************************/
   /* IF KL0XM005.SY1STNBR EQ ' ';  /* no need to check if style number*/
   /* EZERTN;                          /* is not entered*/
   /* END;*/
  if (KL0XM005.XGPCD == "02") /* if footwear, use vprice01*/
    KL0XS70();
  else
    if (KL0XM005.XGPCD == "03") /* if apparel use vcost01*/
      KL0XS72();
    else /* all others have zero value*/
      CL0XW01.CLNGRPRC = 0;
      return;
    end
  end
  if (CL0XW01.CLNGRPRC == 0) /* if zero price listed or no price*/
                                   /* found*/
    converseLib.validationFailed(729); /* issue message and don't update*/
    set KL0XM005.SY1STNBR cursor, modified, bold;
                                  /* set cursor to style number*/
     /* MOVE 'Y' TO CL0XW01.CL0XWERRS  /* set style error message flag*/
    CLXREC.CLXERRF = "Y";
  end
end // end KL0XSPR

// Validate PO Delivery Date
Function KL0XSVD()
   /* *************************************************************/
   /* Validate P.O. Number Delivery Date*/
   /*  */
   /* (As of Dec. '94, only checking that PO date is not greater)*/
   /* (than the current date.  If yes, warning 597 appears.     )*/
   /*  */
   /* 04-23-91  sgorga  Changed code to give err msg #688 instead of*/
   /* abending when call to ta0040 gets bad rtn cd.*/
   /* 12-19-94  sgorga  Removed edit to check that fcty po date wasn't*/
   /* older than 28 months.  There are no longer time*/
   /* restrictions for credit on NIL def returns.*/
   /*  */
   /* **************************************************************/

  CLXREC.CLXCPROC = "KL0XSVD";

  CLXREC.XXXWCYMD = 0;

  CLXREC.XXXWCYMD = KL0XM010.CL0XMFPO[CL0XWIDX];
  if (CLXREC.XXXWDD == 01 /* If the delivery month is Jan.*/
   || CLXREC.XXXWDD == 02) /* or Feb.*/
    if (CLXREC.XXXWYY > 57)
                                   /* the delivery year is new year*/
      CLXREC.XXXWCC = 019;
                                   /* following the production year.*/
    else
      CLXREC.XXXWCC = 020;
    end
    if (CLXREC.XXXWYY == 99)
      CLXREC.XXXWYY = 00;
    else
      CLXREC.XXXWYY = CLXREC.XXXWYY + 1;
    end
    CLXREC.XXXWMM = CLXREC.XXXWDD;
    CLXREC.XXXWDD = 01;
  else
    if (CLXREC.XXXWYY > 57)
      CLXREC.XXXWCC = 019;
    else
      CLXREC.XXXWCC = 020;
    end
    CLXREC.XXXWMM = CLXREC.XXXWDD;
    CLXREC.XXXWDD = 01;
  end

  set TA2REC empty;
  TA2REC.TA2DBDFN = CLXREC.XXXWCYMD;
  CLXREC.XXXWCYMD = CL0XW02.CL0XWPED;
  TA2REC.TA2DBDTN = CLXREC.XXXWCYMD;
  if (TA2REC.TA2DBDFN > TA2REC.TA2DBDTN) /* Fcty po date has been typed*/
    CLXREC.CLXERRF = "Y"; /* wrong.  Shows as > today's date.*/
    converseLib.validationFailed(597); /* Warning: po fcty date invalid*/
    set KL0XM010.CL0XMFPO[CL0XWIDX] cursor, modified, bold;
    CL0XW01.CL0XWCOL = 1;
    move CL0XWIDX to CL0XWHDX withV60Compat;
    return;
  end

end // end KL0XSVD

// Validate PO Delivery Date
Function KL0XSVP()
   /* *******************************************************************/
   /* Validate P.O. Number Delivery Date*/
   /*  */
   /* (As of Dec. '94, only checking that PO date is not greater)*/
   /* (than the current date.  If yes, warning 597 appears.     )*/
   /*  */
   /* 03-12-90  bcourt show data when abend: bad rtn in ta0040*/
   /* 04-23-91  sgorga  Changed code to give err msg #688 instead of*/
   /* abending when call to ta0040 gets bad rtn cd.*/
   /* 12-19-94  sgorga  Removed edit to check that fcty po date wasn't*/
   /* older than 28 months.  There are no longer time*/
   /* restrictions for credit on NIL def returns.*/
   /*  */
   /* *******************************************************************/

  CLXREC.CLXCPROC = "KL0XSVP";

  CLXREC.XXXWCYMD = 0;

  if (KL0XM005.CL0XMFPO[CL0XWIDX] == 0)
    return;
  end

  CLXREC.XXXWCYMD = KL0XM005.CL0XMFPO[CL0XWIDX];
  if (CLXREC.XXXWDD == 01 /* if the delivery month is January*/
   || CLXREC.XXXWDD == 02) /* or February*/
    if (CLXREC.XXXWYY > 57) /* the delevery year is the new*/
      CLXREC.XXXWCC = 019;
                                   /* year following the production*/
    else /* year.*/
      CLXREC.XXXWCC = 020;
    end
    if (CLXREC.XXXWYY == 99)
      CLXREC.XXXWYY = 00;
    else
      CLXREC.XXXWYY = CLXREC.XXXWYY + 1;
    end
    CLXREC.XXXWMM = CLXREC.XXXWDD;
    CLXREC.XXXWDD = 01;
  else
    if (CLXREC.XXXWYY > 57)
      CLXREC.XXXWCC = 019;
    else
      CLXREC.XXXWCC = 020;
    end
    CLXREC.XXXWMM = CLXREC.XXXWDD;
    CLXREC.XXXWDD = 01;
  end

  set TA2REC empty;
  TA2REC.TA2DBDFN = CLXREC.XXXWCYMD;
  CLXREC.XXXWCYMD = CL0XW02.CL0XWPED;
  TA2REC.TA2DBDTN = CLXREC.XXXWCYMD;
  if (TA2REC.TA2DBDFN > TA2REC.TA2DBDTN) /* Fcty po date has been typed*/
    CLXREC.CLXERRF = "Y"; /* wrong.  Shows as > today's date.*/
    CL0XW01.CL0XWERR = 597; /* Warning: po fcty date invalid*/
    CL0XW01.CLPVLDFL[CL0XWIDX] = "Y";
    set KL0XM005.CL0XMFPO[CL0XWIDX] cursor, modified, bold;
    CL0XW01.CL0XWCOL = 1;
    move CL0XWIDX to CL0XWHDX withV60Compat;
    return;
  end

end // end KL0XSVP

//*** RECORD=CL0XW01 ****
// 08-01-88 bcourt add inspection number
// 04-23-91 SGORGA Added a message field (CL0XWMSG) to be moved
//        to TA1REC.TA1TBLKE when 'post' message is created in
//        process CL0W130.  Delete these fields if the 'post'
//        code is ever deleted.
// 01-22-92 lgross added cl0xwicf - eom indicator flag
// 04-21-92 LGROSS added clngrprc - claims gross unit price
// ***********************
Record CL0XW01 type basicRecord
  5 CL0XWGP CL0XWGP ; 
    10 CL0XWFL CL0XWFL ; 
      15 CL0XWLFL CL0XWLFL ; 
      15 CL0XWOFL CL0XWOFL ; 
      15 CL0XWHDF CL0XWHDF ; 
      15 CL0XWDEF CL0XWDEF ; 
      15 CL0XWELF CL0XWELF ; 
      15 CL0XWLDF CL0XWLDF ; 
      15 CL0XWEHF CL0XWEHF ; 
      15 CL0XWEDF CL0XWEDF ; 
      15 CL0XWUDF CL0XWUDF ; 
      15 CL0XWWRF CL0XWWRF [20] ; 
      15 CL0XWWPF CL0XWWPF [20] ; 
      15 CL0XWDFL CL0XWDFL ; 
      15 CL0XWICF CL0XWICF ; 
    10 CLACLMNB CLACLMNB ; 
    10 CLHSEQNB CLHSEQNB ; 
    10 CL2ISNBR CL2ISNBR ; 
    10 KUCCOID KUCCOID ; 
    10 KUMSTRID KUMSTRID ; 
    10 XNXCD XNXCD ; 
    10 KUCCONM KUCCONM ; 
    10 XGPCD XGPCD ; 
    10 YCTCD YCTCD ; 
    10 XATCD XATCD ; 
    10 XAUCD XAUCD ; 
    10 CL0XMIDT CL0XMIDT ; 
    10 CL0XMICF CL0XMICF ; 
    10 CL2ISXDT CL2ISXDT ; 
    10 CLJNCRFL CLJNCRFL ; 
    10 CLPVLDFL CLPVLDFL [20] ; 
    10 CL0XWIDX CL0XWIDX ; 
    10 CL0XWHDX CL0XWHDX ; 
    10 CL0XWCOL CL0XWCOL ; 
    10 CL0XWERR CL0XWERR ; 
    10 CL0XWINX CL0XWINX ; 
    10 CL0XWRSW CL0XWRSW ; 
    10 CL0XWJAQ CL0XWJAQ ; 
    10 CL0XWCNT CL0XWCNT ; 
    10 CL0XWCCT CL0XWCCT ; 
    10 CL0XWDCT CL0XWDCT ; 
    10 CL0XWCTR CL0XWCTR ; 
    10 CL0XWDLC CL0XWDLC ; 
    10 CL0XWEND CL0XWEND ; 
    10 CL0XWUPD CL0XWUPD ; 
    10 CL0XWCMP CL0XWCMP ; 
    10 CL0XWBLD CL0XWBLD ; 
    10 CL0XWFLG CL0XWFLG ; 
    10 CL0XWSKP CL0XWSKP ; 
    10 CL0XWHC CL0XWHC ; 
    10 CL0XWIN CL0XWIN ; 
    10 CL0XWCN CL0XWCN ; 
    10 CL0XWCX CL0XWCX ; 
    10 CL0XWDUP CL0XWDUP [12] ; 
    10 CL0XWLIN CL0XWLIN [12] ; 
    10 CL0XWCT1 CL0XWCT1 [12] ; 
    10 CL0XWCT2 CL0XWCT2 [12] ; 
    10 CL0XWLCT CL0XWLCT ; 
    10 CL2ISBDT CL2ISBDT ; 
    10 CLGCMSEQ CLGCMSEQ ; 
    10 CLAESTVL CLAESTVL ; 
    10 CLATQTY CLATQTY ; 
    10 CL0XWTCQ CL0XWTCQ ; 
    10 CL0XWTCA CL0XWTCA ; 
    10 CL0XWOAM CL0XWOAM ; 
    10 CL0XWNAM CL0XWNAM ; 
    10 CL0XWTOA CL0XWTOA ; 
    10 CL0XWTNA CL0XWTNA ; 
    10 CL0XWTOQ CL0XWTOQ ; 
    10 CL0XWTNQ CL0XWTNQ ; 
    10 CL0XWXDA CL0XWXDA ; 
      15 SY1STNBR SY1STNBR ; 
      15 SY2CLRID SY2CLRID ; 
      15 * char(11) ; 
      15 YDFKEY YDFKEY ; 
        20 YDFCD YDFCD ; 
        20 CL0XWGPC CL0XWGPC ; 
    10 CL0XWMSG CL0XWMSG ; 
      15 CL0XWLT1 CL0XWLT1 ; 
      15 CL0XWCLN CL0XWCLN ; 
      15 CL0XWLT2 CL0XWLT2 ; 
      15 CL0XWSTY CL0XWSTY ; 
      15 CL0XWLT3 CL0XWLT3 ; 
      15 CL0XWCLR CL0XWCLR ; 
      15 CL0XWLT4 CL0XWLT4 ; 
      15 CL0XWGP0 CL0XWGP0 ; 
    10 CLNGRPRC CLNGRPRC ; 
end // end CL0XW01

//*** RECORD=CL0XW02 ****
// ************************************************************
// 
// this is an array of data used for the product summary, map 1
// 
// the product summary processes one invoice at a time.
// since one invoice may contain only 200 products, this
// working-storage array occurs 200 times.
// 
// cl0lmsel = select column.  value may be:
//     s product selected, show detail sizes
//     x product deleted from claim
//     v product already viewed at the detail size level
// 
// cl0lwchf = change flag.  value may be:
//     c  product changed
//     a  product added
//    ' ' no action
// ************************************************************
// ***********************
Record CL0XW02 type basicRecord
  10 IV0PARTN IV0PARTN ; 
  10 IV0IVCID IV0IVCID ; 
  10 CL0XWASZ CL0XWASZ ; 
  10 CL0XWPAY CL0XWPAY [20] ; 
    15 CL0XWFL1 CL0XWFL1 ; 
    15 CL0XMSEL CL0XMSEL ; 
    15 ZZZCHGCT ZZZCHGCT ; 
    15 CL0XWCHF CL0XWCHF ; 
    15 CL0XWVCH CL0XWVCH ; 
    15 CL0XWFL2 CL0XWFL2 ; 
    15 SY1STNBR SY1STNBR ; 
    15 SY2CLRID SY2CLRID ; 
    15 XDMCD XDMCD ; 
    15 SY5SZID SY5SZID ; 
    15 XQACD XQACD ; 
    15 XUMCD XUMCD ; 
    15 CLNGRPRC CLNGRPRC ; 
    15 CLRCLMQ CLRCLMQ ; 
    15 CL0XWFL3 CL0XWFL3 ; 
    15 OP2LNINB OP2LNINB ; 
    15 KUIPRDID KUIPRDID ; 
    15 XPYCD XPYCD ; 
    15 XCOCD XCOCD ; 
    15 OP2PRCOF OP2PRCOF ; 
    15 OP2PRCVF OP2PRCVF ; 
    15 IV3GLNUP IV3GLNUP ; 
    15 IV3LNSQ IV3LNSQ ; 
    15 CL0XWFL4 CL0XWFL4 ; 
    15 CLICRDFL CLICRDFL ; 
    15 XGPCD XGPCD ; 
    15 CLKPRCFF CLKPRCFF ; 
    15 CLRRQTQ CLRRQTQ ; 
  10 CL0XWPCP CL0XWPCP ; 
  10 CL0XWCLP CL0XWCLP ; 
  10 CL0XWSTP CL0XWSTP ; 
  10 CL0XWPED CL0XWPED ; 
  10 CL0X-WK-PRC CL0X-WK-PRC ; 
end // end CL0XW02

//*** RECORD=CL0XW03 ****
// first parameter from call to ta0050
// - length of data for temp storage
// - data for temp storage
// ***********************
Record CL0XW03 type basicRecord
  5 CL0XW3RL CL0XW3RL ; 
    10 CL0XW3LG CL0XW3LG ; 
    10 CL0XW3DA CL0XW3DA [6] ; 
    10 CL0XW3FL CL0XW3FL ; 
end // end CL0XW03

//*** RECORD=CL0XW04 ****
// second parameter for call to ta0050
// - application id
// - count (returned for add, sent for read or update
// - function code (r=read, u=update, a=add, p=purge)
// - return code (0=good, 3=length error, 4=qid error 7=eof)
// ***********************
Record CL0XW04 type basicRecord
  5 CL0XW4RL CL0XW4RL ; 
    10 CL0XW4AP CL0XW4AP ; 
    10 CL0XW4CT CL0XW4CT ; 
    10 CL0XW4FC CL0XW4FC ; 
    10 CL0XW4RC CL0XW4RC ; 
end // end CL0XW04

//*** RECORD=CL0XW05 ****
// stores up to 5 lines screen data to 1 temp storage record
// Maintenance  By Why
// -------- ------ --------------------------------------------
// 08-01-88 bcourt change PD1FCTYC  to FY1FCTYC
//                        PD2FTYPO  to FY2FTYPO
// 
// ***********************
Record CL0XW05 type basicRecord
  5 CL0XW5RL CL0XW5RL ; 
    10 SY1STNBR SY1STNBR ; 
    10 SY2CLRID SY2CLRID ; 
    10 XDMCD XDMCD ; 
    10 YDDCD YDDCD ; 
    10 XUMCD XUMCD ; 
    10 CLKCLPRC CLKCLPRC ; 
    10 FY1FCTYC FY1FCTYC ; 
    10 PC3POIDT PC3POIDT ; 
    10 CLPCRTNB CLPCRTNB ; 
    10 YDFCD YDFCD ; 
    10 CLPDEFQ CLPDEFQ ; 
    10 ZZZCHGCT ZZZCHGCT ; 
end // end CL0XW05

//*** RECORD=CL0XW06 ****
// Maintenace   BY WHY
// -------- ------ --------------------------------------------
// 08-01-88 bcourt change PD1FCTYC  to FY1FCTYC
//                        PD2FTYPO  to FY2FTYPO
// 
// ***********************
Record CL0XW06 type basicRecord
  5 CL0XW6RL CL0XW6RL [12] ; 
    10 SY1STNBR SY1STNBR ; 
    10 SY2CLRID SY2CLRID ; 
    10 XDMCD XDMCD ; 
    10 YDDCD YDDCD ; 
    10 XUMCD XUMCD ; 
    10 CLKCLPRC CLKCLPRC ; 
    10 FY1FCTYC FY1FCTYC ; 
    10 PC3POIDT PC3POIDT ; 
    10 CLPCRTNB CLPCRTNB ; 
    10 YDFCD YDFCD ; 
    10 CLPDEFQ CLPDEFQ ; 
    10 ZZZCHGCT ZZZCHGCT ; 
end // end CL0XW06

//*** RECORD=CL0XW07 ****
// IO3310:
// pass PO Number Date to iomod.
// 06-14-90 CHELLM Created record.
// ***********************
Record CL0XW07 type basicRecord
  10 CL0XWSQL CL0XWSQL ; 
  10 CL0XWCN1 CL0XWCN1 ; 
  10 CL0XWDT1 CL0XWDT1 ; 
  10 CL0XWDT2 CL0XWDT2 ; 
end // end CL0XW07

DataItem CL0X-WK-PRC decimal(11,4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// map insp-flag
DataItem CL0XMICF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// map insp-date
DataItem CL0XMIDT char(8)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// cl0xm005 map select
DataItem CL0XMSEL char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data for temp storage
DataItem CL0XW3DA char(40)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler
DataItem CL0XW3FL char(155)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// length of data
DataItem CL0XW3LG num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

DataItem CL0XW3RL char(399)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// application id
DataItem CL0XW4AP char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// record number
DataItem CL0XW4CT num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// function code
DataItem CL0XW4FC char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// return code
DataItem CL0XW4RC num(1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

DataItem CL0XW4RL char(10)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem CL0XW5RL char(38)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// cl0xw06 group length
DataItem CL0XW6RL char(38)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// size of product or detail aray
DataItem CL0XWASZ smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// build temp storage
DataItem CL0XWBLD char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// current counter
DataItem CL0XWCCT int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// change flag (y,a, or ' ')
DataItem CL0XWCHF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// cl_clm_nbr
DataItem CL0XWCLN char(8)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// default price by style,color
DataItem CL0XWCLP decimal(7,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// sy_colr_cd_id
DataItem CL0XWCLR char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// update complete flag
DataItem CL0XWCMP char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// work file counter
DataItem CL0XWCN smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// counter for db item
DataItem CL0XWCN1 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// ws counter
DataItem CL0XWCNT int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// hold column number
DataItem CL0XWCOL smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// occurs of temp record
DataItem CL0XWCT1 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// record count
DataItem CL0XWCT2 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// update counter
DataItem CL0XWCTR int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// index
DataItem CL0XWCX smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// counter
DataItem CL0XWDCT int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// detail complete flag
DataItem CL0XWDEF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// deadlock flag
DataItem CL0XWDFL char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// deadlock counter
DataItem CL0XWDLC int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// PO Number Date
DataItem CL0XWDT1 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// PO Number Date
DataItem CL0XWDT2 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = nullFill, inputRequired = no
}
end

// if duplicate record
DataItem CL0XWDUP char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// end of detail flag
DataItem CL0XWEDF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// end of header flag
DataItem CL0XWEHF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// end of list flag
DataItem CL0XWELF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// end of detail lines on screen
DataItem CL0XWEND char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// hold error number
DataItem CL0XWERR smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// all the internal flags
DataItem CL0XWFL char(51)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data for db2 update ----------
DataItem CL0XWFL1 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data from invc or claims -----
DataItem CL0XWFL2 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data from invc only ----------
DataItem CL0XWFL3 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data from claim only ---------
DataItem CL0XWFL4 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// warning flag
DataItem CL0XWFLG char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// cl0xw01 group level
DataItem CL0XWGP char(441)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// xgpcd
DataItem CL0XWGP0 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// gpc for ydf key
DataItem CL0XWGPC char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// hold counter
DataItem CL0XWHC smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// header complete flag
DataItem CL0XWHDF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// hold screen index
DataItem CL0XWHDX smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

DataItem CL0XWICF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// screen index-1
DataItem CL0XWIDX smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// index to screen
DataItem CL0XWIN smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// screen index-2
DataItem CL0XWINX smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// total added quantity
DataItem CL0XWJAQ int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// last record read
DataItem CL0XWLCT int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// end of detail list flag
DataItem CL0XWLDF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// (l) actual return add flag
DataItem CL0XWLFL char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// indicates modified line
DataItem CL0XWLIN char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// literal 'clm#'
DataItem CL0XWLT1 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// literal ',style='
DataItem CL0XWLT2 char(7)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// literal ',colr='
DataItem CL0XWLT3 char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// literal ',gpc'
DataItem CL0XWLT4 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// message for 'post' in cl0x130
DataItem CL0XWMSG char(40)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// new amount
DataItem CL0XWNAM decimal(11,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// old amount
DataItem CL0XWOAM decimal(11,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// (o) defective header add flag
DataItem CL0XWOFL char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// product array ----------------
DataItem CL0XWPAY char(79)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// product price/cost pct
DataItem CL0XWPCP decimal(5,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// prod price effective date
DataItem CL0XWPED int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// no records selected switch
DataItem CL0XWRSW char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// skip read
DataItem CL0XWSKP char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// sql selection
DataItem CL0XWSQL char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// default price by style
DataItem CL0XWSTP decimal(7,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// sy_sty_nbr
DataItem CL0XWSTY char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// total claim amount
DataItem CL0XWTCA decimal(11,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// total claim qty
DataItem CL0XWTCQ int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// total new amount
DataItem CL0XWTNA decimal(11,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// total new quantity
DataItem CL0XWTNQ int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// total old amount
DataItem CL0XWTOA decimal(11,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// total old quantity
DataItem CL0XWTOQ int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// updates allowed flag
DataItem CL0XWUDF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// clarec update flag
DataItem CL0XWUPD char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// value chnge,add db/cr claestvl
DataItem CL0XWVCH decimal(11,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// warning flag po number
DataItem CL0XWWPF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// warning flag factory code
DataItem CL0XWWRF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem CL0XWXDA char(25)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

