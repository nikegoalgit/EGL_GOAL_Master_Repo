package kl0k;

import corpcom1.CLAREC;
import corpcom1.CLHREC;
import corpcom1.CLIADMAT;
import corpcom1.CLIADVSQ;
import corpcom1.CLICARCT;
import corpcom1.CLICARMO;
import corpcom1.CLICRDFL;
import corpcom1.CLIGLAM;
import corpcom1.CLIGLFIV;
import corpcom1.CLIGLNFL;
import corpcom1.CLIGLPC;
import corpcom1.CLIIGOFL;
import corpcom1.CLIREC;
import corpcom1.CLWREC;
import corpcom1.CLXREC;
import corpcom2.XQWREC;
import corpcom3.XPCL002;
import corpcom3.XPCL010;
import corpcom3.XPCL011;
import corpcom4.XSENTRY;
import corpcom4.XSSEGTR;
import corpcom5.COMMAREA;
import corpcom5.ERRSQLCA;
import corpcom5.GLACD;
import corpcom5.GLADESC;
import corpcom6.SQLCA;
import corpx1.XDMCD;
import corpx1.XGPCD;
import corpx1.XSNTBL;
import corpx1.XSTTBL;
import corpx2.XSECD;
import corpx2.XSTCD;
import corpy2.YAPCD;
import corpy2.YAPTBL;
import corpy2.YATTBL;
import corpy2.YCSSDESC;
import corpy2.YCSTBL;
import corpy2.YCTABRV;
import corpy2.YCTTBL;
import corpy2.YMDCD;
import corpy2.YMDTBL;
import corpy2.YUATBL;
import corpz3.ZZZCHGDT;
import corpz3.ZZZCHGTM;
import iv.common.IV0PARTN;
import iv.common.IV6FBTYP;
import iv.common.IV6GLSEQ;
import ku.common.KUCCONM;
import op.common.OP2LNINB;
import pf.common.PFJREC;
import pf.common.PFJXREF;
import sy.common.SY1STNBR;
import sy.common.SY2CLRID;
import ta.common.TA1REC;
import ta.common.TA2REC;
//*** PROGRAM=KL0K ****
// ************************************************************
// kl0k - nike bank claim general ledger
// 
// this is a single-screen application.  this screen can be
// used to inquire, add, change and delete gl entries.
// 
// three db2 tables are used:
//   dclaim.vclhdr01  clarec (claim header) dcl00203 io1160
//     is used to prompt the header information for the top
//     of the screen.
// 
//   dclaim.vclmem01  clhrec (memo)   dcl00215  io1290
//     is used to bring back the memo number located in
//     the top part of the screen.  if a memo does exist,
//     the program protects the screen body from data entry.
// 
//   dclaim.vclglx01   clirec (general ledger) dcl00216  io1160
//     is used to store the gl entry information.  if any
//     entries exist, these are brought back for display
//     for the initial converse.  if no memo exists and
//     security permits, all fields are open for changing
//     or deleting the entry.
// 
// all header fields are protected.
// 
// the only fields required to create a gl entry are:
//   c/d, gl code and gl amount.  the alw pct field
//   will default to 100% if no other percent is entered.
//   the nk am field will default to n if y is not entered.
// 
//   various fields within the claim header record (clarec)
//   are updated based on a gl entry.  see the program.
// 
// a line is deleted by typing an x in the c/d field.
// 
// the same gl code and gl c/d codes can be used multiple
// times.  each line is kept unique by assigning a sequence
// number to the line entry (cliadvsq).  this sequence number
// is transparent to the user.
// 
// amounts:  the claim header estimated value (clarec.claestvl)
// is affected each time a gl entry is successfully updated.
// debits carry a positive value, credits carry a negative
// value.  the total on the screen is informational only
// and reflects the net value of all gl entries on the screen.
// 
// updates:  the screen updates information with pf5 or  enter.
// 
// ============================================================
// as of the time this application was created, the claim
// sequence number has been darkened on the screen.  apparently
// at this time an nbc or daa claim will never have more than
// one sequence number for the claim.  the program was
// originally coded to handle more than one sequence number
// with the option to select previous sequence numbers and
// look at what gl entries had existed before the memo was
// created.  (once a memo is created, the detail data cannot
// be changed).  you will notice some code that has been
// commented out--this was to be used for the multiple-sequence
// number situation.  it is being left in the program in case
// the application is opened up to allow for multiple seq #'s.
// only some of the code has been prepared--it has not been
// tested, so beware.  cl0j can be used as a guide if the
// seq # situation changes.
// 
// maintenance history:
// date      by      rev description of change
// --------  ---     --  --------------------------------------
// 06-10-87  obecke   0  created application.
// 08-02-88  ctrouw   0  database changes
// 01-06-89  ctrouw   0  changed edit routine to allow blanks
// 02-01-89  jwood    0  added noncsp option to calls
// 02-01-89  jwood    0  added xssegtr logic
// 05-16-89  gdecke   0  fix memo number problem, table changes
// 01-19-90  chellm   0  deleted xgetbl and replaced it with
//                       pfjrec & io4360. renamed cl0kw02.glcd
//                       as glacd and renamed cl0km001.glcd&
//                       xgedesc as glacd and gladesc.
// 08-08-91  wjohns   0  Renamed application and commarea
//                         referrences to renamed appls.
// 09-18-91  ahowar   0  changed proc and sgrp from "cl"to"kl".
// 01-13-92  sgorga      Set ta1rec, ta2rec empty.  kl0k001
// 11-02-92  BCOURT      Change map G/L amt from 5.2 to 6.2
//                       and map total amt from 6.2- to 9.2-
//                       This will allow million dollar claims
//                       to show the total correctly.
// 11-05-92  BCOURT      Change map total G/L amt to allow ','.
// ************************************************************
// *********************
Program KL0K type textUIProgram //VAGen Info - main text program
  {
  includeReferencedFunctions = yes, allowUnqualifiedItemReferences = yes, 
  throwNrfEofExceptions = yes, handleHardIOErrors = no, V60ExceptionCompatibility = yes, 
  I4GLItemsNullable = no, textLiteralDefaultIsString = no, localSQLScope = yes, 
  msgTablePrefix = "CL00", inputRecord = COMMAREA, segmented = yes
  }

  // Data Declarations
  CL0KW01 CL0KW01; // record
  CL0KW02 CL0KW02; // record
  CL0KW04 CL0KW04; // record
  CLAREC CLAREC; // record
  CLHREC CLHREC; // record
  CLIREC CLIREC; // record
  CLWREC CLWREC; // record
  CLXREC CLXREC; // record
  COMMAREA COMMAREA ; // record
  ERRSQLCA ERRSQLCA; // record
  PFJREC PFJREC; // record
  SQLCA SQLCA; // record
  TA1REC TA1REC; // record
  TA2REC TA2REC; // record
  XQWREC XQWREC; // record

  // VAGen Info - items needed for migration
  VAGen_EZESYS char(8);
  VAGen_EZEREPLY num(1);
  VAGen_EZE_WAIT_TIME bin(9,2);
  VAGen_EZE_ITEMLEN int;

  // Use Declarations
  use YMDTBL {deleteAfterUse = yes}; // table
  use YAPTBL {deleteAfterUse = yes}; // table
  use XSTTBL {deleteAfterUse = yes}; // table
  use YUATBL {deleteAfterUse = yes}; // table
  use YATTBL {deleteAfterUse = yes}; // table
  use YCTTBL {deleteAfterUse = yes}; // table
  use YCSTBL {deleteAfterUse = yes}; // table
  use XSNTBL {deleteAfterUse = yes}; // table
  use KL0KM.KL0KM001 // form
   {
    pfKeyEquate = no
  };

  function main()
    // VAGen Info - initialization needed for migration
    VAGen_EZESYS = VGLib.getVAGSysType();
    KL0K000: KL0K000();
    ;
    ;
    exit program;
    ;
    ;
    ;
    KL0K001: KL0K001();
    KL0K050: KL0K050();
    KL0K100: KL0K100();
    KL0K101: KL0K101();
    KL0K110: KL0K110();
    KL0K120: KL0K120();
    KL0K140: KL0K140();
    KL0K130: KL0K130();
  end // end main
end // end KL0K

// application main logic
Function KL0K000()
   /* ************************************************************/
   /* *   this is the "main logic" for the application.         **/
   /* *                                                         **/
   /* *   xsentry checks to ensure that this application was    **/
   /* *         entered from another csp application.           **/
   /* *   xclentry checks to ensure that the claim header has   **/
   /* *         been flagged as "in use" if this application    **/
   /* *         does updates.                                   **/
   /* *                                                         **/
   /* *                                                         **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  ;
  KL0K001(); /* initilize the application*/
  ;
  ;
  CLXREC.CLXEOAF = "N"; /* set end-of-application flag to 'no'*/
  ;
  while (CLXREC.CLXEOAF == "N") /* while not end-of-aplication*/
    KL0K050(); /* process the application screen(s)*/
  end
  ;
  COMMAREA.CATOAP = "KL0A";
  XPCL002(); /* exit application*/
  ;
  ;
  ;
end // end KL0K000

// initialize application
Function KL0K001()
   /* ************************************************************/
   /* *      initialize the application working storage         **/
   /* *                                                         **/
   /* *  describe what happens in this process                  **/
   /* ************************************************************/
   /* MAINTENANCE HISTORY                            **/
   /* 01-13-92  sgorga  Set ta1rec & ta2rec empty.              **/
   /* ************************************************************/
  ;
  ;
  converseVar.commitOnConverse = 1; /* force db2 to commit on each screen converse*/
  VGVar.handleHardIOErrors = 1; /* return control to program if hard db2 error*/
  ;
  ;
   /* TEMP001;*/
  ;
  XSENTRY(); /* check entered thru main menu*/
  XSSEGTR(); /* set segmented transaction id*/
  XPCL011(); /* claims entry module*/
  ;
  ;
  set TA1REC empty;
  set TA2REC empty;
  set CLXREC empty; /* clear out the "common" working*/
                                   /* storage*/
  set CL0KW01 empty; /* clear working storage*/
  ;
  ;
  CLXREC.CLXEOAF = "N"; /* set application-done-switch to 'no'*/
  ;
  ;
  CLXREC.CLXSNAME[1] = "KL0KM001"; /* initialize the names of the*/
   /* screens used by this appl*/
  ;
  ;
  ;
  ;
end // end KL0K001

// main cl0k branch control
Function KL0K050()
   /* ************************************************************/
   /* *   control process the application screen(s)             **/
   /* *                                                         **/
   /* *  note that this process is being performed in a         **/
   /* *  "while loop" until the end-of-application flag is set  **/
   /* *  to 'y'.                                                **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0K050"; /* set current process name*/
  ;
  ;
  CLXREC.CLXCSCRN = "KL0KM001";
  if (CLXREC.CLXCSCRN in CLXREC.CLXSNAME) /* if current-screen-name is*/
    CLXREC.CLXSCRNX = sysVar.arrayIndex; /* in the screen-array, then set*/
  end /* the screen-index*/
  ;
  ;
  CLXREC.CLXEOSF = "N"; /* set end-of-screen flag to 'no'*/
  CLXREC.CLXBLDSC = "Y"; /* set build screen flag to 'yes'*/
  ;
  ;
  ;
  if (CLXREC.CLXSCRNX == 1) /* if screen Kl0km001*/
    while (CLXREC.CLXEOSF == "N") /* while not end-of-screen*/
      KL0K100(); /* process screen cl0km001*/
    end
  else
    TA1REC.TA1TBLKE = "CLAIMS UNKNOWN SCREEN NAME";
    XPCL010();
  end
  ;
  ;
   /* at this point;*/
       /* if the end-of-application flag (clxeoaf ) = 'n'*/
         /* the perform will return to the top of cl0k050...*/
       /* else*/
         /* the perform will automatically return to cl0k000.*/
  ;
  ;
  ;
end // end KL0K050

// converse screen m001
Function KL0K100()
   /* ************************************************************/
   /* *    process screen cl0km001                              **/
   /* *                                                         **/
   /* *  note - this process is being performed in a            **/
   /* *     "while loop" from cl0k050 until the end-of-screen   **/
   /* *     flag (clxeosfl) is set to 'y'.                      **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0K100"; /* set current process name*/
  ;
  if (CLXREC.CLXBLDSC == "Y")
    KL0K101(); /* build screen because new record*/
  end /* to display or pf7/pf8 keyed*/
  ;
  CLXREC.CLXBLDSC = "N"; /* skip build screen next time thru*/
    /* skip build when have errors to show, or pf12 was keyed*/
  ;
  CLXREC.CLXCURLN = 1;
  while (CLXCURLN <= 12)
    if (KL0KM001.CL0KMDAR[CLXCURLN] == "  00")
      KL0KM001.CL0KMDAR[CLXCURLN] = "    ";
    else
       /* next sentence*/
    end
    CLXREC.CLXCURLN = CLXREC.CLXCURLN + 1;
  end
  ;
  ;
  KL0KM001.XXXRVNBR = "00";
  KL0KM001.XXXPRCNM = "KL0K100"; /* move process to map*/
  KL0KM001.XXXCURDT = VGVar.currentShortGregorianDate;
  ;
  ;
  ;
  converse KL0KM001 ;
  ;
  ;
  CLXREC.CLXERRF = "N"; /* re-set error flag*/
  CL0KW01.CL0KWSIA = "N"; /* set stay-in-appl flag to 'no'*/
  ;
  ;
  CLXREC.CLXCURLN = 1;
  while (CLXREC.CLXCURLN <= 12)
    KL0KS26(); /* check for modif to*/
    CLXREC.CLXCURLN = CLXREC.CLXCURLN + 1; /* fields*/
  end
  ;
  ;
  if (CLXREC.CLXEDITF == "Y")
     /* next sentence*/
  end
  ;
  ;
  ;
  KL0K110(); /* handle any special entries*/
    /* may exit appl from this process*/
  ;
  ;
  if (CLXREC.CLXEDITF == "Y") /* if we still want to edit*/
    KL0K120(); /* go edit screen entries*/
  end
  ;
  ;
      /* determine next action*/
  ;
  if (CLXREC.CLXERRF == "Y" /* if screen has errors*/
   || converseVar.eventKey is pf12)
    CLXREC.CLXBLDSC = "N"; /* do not rebuild screen, just reshow*/
  else
    KL0K140();
                                   /* go update/add/delete data base 1-4-88*/
    /* CL0KS2A          drop 1-4-88  ; go update data base*/
  end
  ;
  ;
  ;
  if (CL0KW01.CL0KWSIA == "Y") /* if supposed to stay in this application*/
     /* next sentence*/
  else
    KL0K130(); /* act upon pf key*/
  end
  ;
  ;
   /* at this point;*/
     /* if the end-of-screen flag (clxeosf) is 'n'*/
       /* the perform returns to top of process cl0k100.*/
     /* else*/
       /* the perform returns to cl0k050.*/
  ;
  ;
end // end KL0K100

// build screen cl0km001
Function KL0K101()
  ;
  ;
  ;
  set KL0KM001 initial;
  ;
  ;
  KL0KS10(); /* get claim header data*/
  ;
  KL0KS12(); /* check if memo exists for sequence number*/
  ;
  KL0KS14(); /* get gl records*/
  ;
  KL0KS16(); /* move gl records to map*/
  ;
  if (KL0KM001.CLHMEMNB > 0)
    VAGen_EZEMSG = "CANNOT CHANGE DATA SINCE MEMO ALREADY CREATED";
    KL0KS18();
  else
    if (CLWREC.CLWACTIV == "I")
         /* OR COMMAREA.CAALVL NE 'Y';*/
         /* OR COMMAREA.CACLVL NE 'Y';*/
      KL0KS18();
    else
       /* next sentence*/
    end
  end
  ;
  ;
  ;
end // end KL0K101

// validate screen m001 pf keys
Function KL0K110()
   /* ************************************************************/
   /* *  validate pf keys                                       **/
   /* *                                                         **/
   /* *  the only keys acted upon at this time are pf 3, 4      **/
   /* *  and fastpath                                           **/
   /* *                                                         **/
   /* *  the other keys are just verified that they are used    **/
   /* *  by this application.  if the pf key is not recognized, **/
   /* *  the application resets all modified fields to remain   **/
   /* *  modified, then reshows the map with an error message.  **/
   /* *                                                         **/
   /* *  these other pf keys are acted upon after the editing   **/
   /* *  and updating have occured.                             **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0K110"; /* set current process name*/
  ;
  ;
  ;
  if (converseVar.eventKey is pf1)
    KL0KS01(); /* skip edit, update - exit*/
  end
  ;
  if (converseVar.eventKey is pf3)
    KL0KS03(); /* skip edit, update - exit*/
  end
  ;
  if (converseVar.eventKey is pf4)
    KL0KS04(); /* skip edit, update - exit*/
  end
  ;
  ;
  ;
      /* check for fastpath option/item*/
  ;
  if (KL0KM001.CATOAP != " ") /* if fastpath option entered,*/
    COMMAREA.CATOAP = KL0KM001.CATOAP;
    COMMAREA.CAITEM = KL0KM001.CAITEM;
    XPCL002(); /* exit application*/
  end
  ;
  if (KL0KM001.CATOAP == " ")
    if (KL0KM001.CAITEM != " ")
      converseLib.validationFailed(1);
      CLXREC.CLXEDITF = "N"; /* set do-edits-flag to no*/
      CLXREC.CLXERRF = "Y";
      set KL0KM001.CATOAP cursor, modified, bold;
      set KL0KM001.CAITEM modified, bold;
      return;
    end
  end
  ;
  ;
  ;
      /* pf key not valid*/
  ;
  if (converseVar.eventKey is enter
   || converseVar.eventKey is pf1  
   || converseVar.eventKey is pf2  
   || converseVar.eventKey is pf7  
   || converseVar.eventKey is pf8  
   || converseVar.eventKey is pf5  
   || converseVar.eventKey is pf12 
   || converseVar.eventKey is pf18 /* 1-4-88 add*/
   || converseVar.eventKey is pf20) /* 1-4-88 add*/
     /* next sentence*/
  else
    converseLib.validationFailed(2); /* pf key not valid*/
    CLXREC.CLXEDITF = "N";
    CLXREC.CLXERRF = "N";
    CLXREC.CLXBLDSC = "N";
    ;
  end
  ;
  ;
  ;
end // end KL0K110

// process screen m001 entries
Function KL0K120()
   /* ************************************************************/
   /* *     this process handles all edits of screen fields,    **/
   /* *          and any subsequent updating, required by       **/
   /* *          entries into screen cl0km001                   **/
   /* *                                                         **/
   /* *  Maintenance History:                                   **/
   /* *                                                         **/
   /* *  01-19-90 CHELLM renamed CL0KM001.GLCD to GLACD         **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0K120"; /* set current process name*/
  ;
  ;
   /* *******************************************/
   /* edit data base array changed lines*/
   /* *******************************************/
  CLXREC.CLXCURLN = 12;
  ;
  while (CLXREC.CLXCURLN > 0) /* edit from bottom up*/
    if (KL0KM001.CLICRDFL[CLXCURLN] == "X")
      CL0KW02.CL0KWMOD[CLXCURLN] = "D"; /* tag for update*/
    else
      ;
       /* if all fields are blank*/
       /* and looking at line that did contain data*/
      ;
      if (KL0KM001.CLICRDFL[CLXCURLN] == " "
       && KL0KM001.GLACD[CLXCURLN] == " "
       && KL0KM001.XSTCD[CLXCURLN] == " "
       && KL0KM001.CL0KMDAR[CLXCURLN] == " "
       && KL0KM001.CLICARCT[CLXCURLN] == 0
       && KL0KM001.CLIADMAT[CLXCURLN] == " "
       && KL0KM001.YMDCD[CLXCURLN] == " "
       && KL0KM001.YAPCD[CLXCURLN] == " "
       && KL0KM001.CLIGLAM[CLXCURLN] == 0
       && CLXREC.CLXCURLN <= CLXREC.CLXLSTAX)
        CL0KW02.CL0KWMOD[CLXCURLN] = "D"; /* tag for update*/
      else
        if (KL0KM001.CLIGLAM[CLXCURLN] is modified)
          CL0KW02.CL0KWMOD[CLXCURLN] = "C"; /* tag for update*/
        end
        KL0KS1A(); /* amt is required,*/
        ;
        if (KL0KM001.YAPCD[CLXCURLN] is modified)
          CL0KW02.CL0KWMOD[CLXCURLN] = "C"; /* tag for update*/
          KL0KS1B();
        end
        ;
        if (KL0KM001.YMDCD[CLXCURLN] is modified)
          CL0KW02.CL0KWMOD[CLXCURLN] = "C"; /* tag for update*/
          KL0KS1C();
        end
        ;
        if (KL0KM001.CLIADMAT[CLXCURLN] is modified)
          CL0KW02.CL0KWMOD[CLXCURLN] = "C"; /* tag for update*/
          KL0KS1D();
        end
        ;
        if (KL0KM001.CL0KMDAR[CLXCURLN] is modified)
          CL0KW02.CL0KWMOD[CLXCURLN] = "C"; /* tag for update*/
          KL0KS1E();
        end
        ;
        if (KL0KM001.CLICARCT[CLXCURLN] is modified)
          CL0KW02.CL0KWMOD[CLXCURLN] = "C"; /* tag for update*/
          CL0KW02.CL0KWCAR[CLXCURLN] = KL0KM001.CLICARCT[CLXCURLN];
           /* no edits are done on this field--apparently anything goes*/
        end
        ;
        if (KL0KM001.XSTCD[CLXCURLN] is modified)
          CL0KW02.CL0KWMOD[CLXCURLN] = "C"; /* tag for update*/
          KL0KS1F();
        end
        ;
        if (KL0KM001.CLICALPC[CLXCURLN] is modified)
          CL0KW02.CL0KWMOD[CLXCURLN] = "C"; /* tag for update*/
          KL0KS1G();
        end
        ;
        if (KL0KM001.GLACD[CLXCURLN] is modified)
          CL0KW02.CL0KWMOD[CLXCURLN] = "C";
        end
        KL0KS1H();
        ;
        if (KL0KM001.CLICRDFL[CLXCURLN] is modified)
          CL0KW02.CL0KWMOD[CLXCURLN] = "C"; /* tag for update*/
        end
        KL0KS1I();
      end
      ;
      ;
      if (CL0KW02.CL0KWMOD[CLXCURLN] == "C")
        if (CL0KW02.CL0KWPCT[CLXCURLN] == 0
         && CL0KW02.CLIGLAM[CLXCURLN] > 0)
          CL0KW02.CL0KWPCT[CLXCURLN] = 100;
          KL0KM001.CLICALPC[CLXCURLN] = 100;
        end
        if (CL0KW02.CL0KWNEF[CLXCURLN] == "Y")
          CL0KW02.CL0KWMOD[CLXCURLN] = "A";
        end
      end
      ;
      ;
    end
    CLXREC.CLXCURLN = CLXREC.CLXCURLN - 1;
  end
end // end KL0K120

// act upon valid pf keys, map 1
Function KL0K130()
   /* ************************************************************/
   /* *  act upon pf keys                                       **/
   /* *                                                         **/
   /* *  pf 1, 3, 4, 7, 8 & 12 were acted upon in               **/
   /* *  cl0k110.                                               **/
   /* *                                                         **/
   /* *  the other pf keys are acted upon here, after editing   **/
   /* *  and updating have occured.                             **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0K130"; /* set current process name*/
  ;
  ;
  ;
  if (converseVar.eventKey is enter)
    if (CLXREC.CLXERRF == "N")
      KL0KS3A();
    else
      return; /* 1-4-88*/
       /* used to be 'next sent', but change if-else to if,if if*/
       /* so put ezertn in here.*/
    end
  end
  ;
  if (converseVar.eventKey is pf2)
    if (KL0KM001.CLHMEMNB > 0)
      KL0KS02();
    else
      converseLib.validationFailed(11); /* pf 2 invalid--memo does not exist*/
      CLXREC.CLXBLDSC = "N"; /* don't rebuild screen*/
      return;
    end
  end
  ;
  if (converseVar.eventKey is pf5) /* claim header*/
    KL0KS05();
  end
  ;
  if (converseVar.eventKey is pf12)
    CLXREC.CLXBLDSC = "N";
    CLXREC.CLXEDITF = "Y";
    return; /* add 1-4-88*/
  end
  ;
  if (converseVar.eventKey is pf18) /* add 1-4-88*/
    KL0KS8A();
  end
  ;
  if (converseVar.eventKey is pf20) /* add 1-4-88*/
    KL0KS20();
  end
  ;
  converseLib.validationFailed(2); /* invalid pf key*/
  CLXREC.CLXEDITF = "N";
  ;
  ;
  ;
end // end KL0K130

// update/add/delete clirec table
Function KL0K140()
   /* *************************************************************/
   /* *  decide if tables are add, change, delete*/
   /* **/
   /* *  Maintenance History:*/
   /* **/
   /* *  01-19-90 CHELLM renamed CL0KM001.GLCD as GLACD*/
   /* **/
   /* **/
   /* *************************************************************/
  ;
  CLXREC.CLXCPROC = "CL0K140"; /* process name*/
  ;
  set TA2REC empty;
  TA2REC.TA2DTOPT = "GETDATE";
  call "TA0040" (TA2REC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (TA2REC.TA2RTNCD != 0)
    converseLib.validationFailed(4);
    CLXERRF = "Y";
    CLXBLDSC = "N";
    return;
  else
    CL0KW01.ZZZCHGDT = TA2REC.TA2GRGGN;
    CL0KW01.ZZZCHGTM = TA2REC.TA2TIMHM;
  end
  ;
  ;
  CLXREC.CLXARAYX = 1;
  ;
  while (CLXREC.CLXARAYX <= 12)
    if (CL0KW02.CL0KWMOD[CLXARAYX] == "D") /* if line was a delete*/
      KL0KS2B(); /* perform delete - clirec*/
      CL0KW01.CL0KWSIA = "Y";
      CLXREC.CLXBLDSC = "Y";
    else
      if (CL0KW02.CL0KWMOD[CLXARAYX] == "A") /* if line was a new add*/
        KL0KS2C(); /* perform add - clirec*/
        CL0KW01.CL0KWSIA = "Y";
        CLXREC.CLXBLDSC = "Y";
      else
        ;
        if (CL0KW02.CL0KWMOD[CLXARAYX] == "C") /* if line was changed*/
          if (KL0KM001.CLICRDFL[CLXARAYX] != CL0KW02.CLICRDFL[CLXARAYX]
           || KL0KM001.GLACD[CLXARAYX] != CL0KW02.GLACD[CLXARAYX])
            KL0KS2G(); /* update with changes to the key*/
            CL0KW01.CL0KWSIA = "Y";
            CLXREC.CLXBLDSC = "Y";
          else
            KL0KS2D(); /* update - no changes to key involved*/
            CL0KW01.CL0KWSIA = "Y";
            CLXREC.CLXBLDSC = "Y";
          end
        end
        ;
      end
    end
    ;
    CLXREC.CLXARAYX = CLXARAYX + 1;
  end
  ;
  VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
  VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
  sysLib.commit();
  VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
  
  ;
  ;
end // end KL0K140

// select set from clirec
Function KL0K911()
   /* **************************************/
   /* select set from clirec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO1300" ("S2", SQLCA, CLIREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        TA1REC.TA1LOCAT[2] = "CL0K911"; /* location*/
        TA1REC.TA1MAP = "CL0KM001";
        TA1REC.TA1DBASE = "DCLAIM  ";
        TA1REC.TA1TBLVU = "VCLGLX01";
        CL0KW01.CL0KWNUM = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CL0KW01.CL0KWNUM;
        TA1REC.TA1LOCAT[4] = "IO1300";
        ;
        XPCL010(); /* error diagnosis routine*/
        ;
        return;
      end
    end
  end
end // end KL0K911

// fetch next from clirec
Function KL0K912()
   /* **************************************/
   /* fetch next from clirec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO1300" ("N2", SQLCA, CLIREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        TA1REC.TA1LOCAT[2] = "CL0K912"; /* location*/
        TA1REC.TA1MAP = "CL0KM001";
        TA1REC.TA1DBASE = "DCLAIM  ";
        TA1REC.TA1TBLVU = "VCLGLX01";
        CL0KW01.CL0KWNUM = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CL0KW01.CL0KWNUM;
        TA1REC.TA1LOCAT[4] = "IO1300";
        ;
        XPCL010(); /* error diagnosis routine*/
        ;
        return;
      end
    end
  end
end // end KL0K912

// close cursor for clirec
Function KL0K913()
   /* **************************************/
   /* close cursor clirec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO1300" ("C2", SQLCA, CLIREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        TA1REC.TA1LOCAT[2] = "CL0K913"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO1300";
        TA1REC.TA1MAP = "CL0IM001";
        TA1REC.TA1DBASE = "DCLAIM  ";
        TA1REC.TA1TBLVU = "VCLGLX01";
        CL0KW01.CL0KWNUM = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CL0KW01.CL0KWNUM;
        ;
        XPCL010(); /* error diagnosis routine*/
        ;
        return;
      end
    end
  end
end // end KL0K913

// delete unique from clirec
Function KL0K915()
   /* **************************************/
   /* delete unique on clirec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO1300" ("DB", SQLCA, CLIREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        ;
        TA1REC.TA1LOCAT[2] = "CL0K915"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO1300"; /* location*/
        TA1REC.TA1DBASE = "DCLAIM"; /* database name*/
        TA1REC.TA1TBLVU = "VCLGLC01"; /* table view name*/
        CL0KW01.CL0KWNUM = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CL0KW01.CL0KWNUM; /* table key*/
        ;
        XPCL010(); /* error diagnosis routine*/
      end
    end
  end
end // end KL0K915

// add unique to clirec
Function KL0K916()
   /* **************************************/
   /* add unique on clirec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO1300" ("A ", SQLCA, CLIREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        ;
        TA1REC.TA1LOCAT[2] = "CL0K916"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO1300"; /* location*/
        TA1REC.TA1DBASE = "DCLAIM"; /* database name*/
        TA1REC.TA1TBLVU = "VCLGLC01"; /* table view name*/
        CL0KW01.CL0KWNUM = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CL0KW01.CL0KWNUM; /* table key*/
        ;
        XPCL010(); /* error diagnosis routine*/
      end
    end
  end
end // end KL0K916

// update unique from clirec
Function KL0K917()
   /* **************************************/
   /* update unique on clirec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO1300" ("UB", SQLCA, CLIREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        ;
        TA1REC.TA1LOCAT[2] = "CL0K917"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO1300"; /* location*/
        TA1REC.TA1DBASE = "DCLAIM"; /* database name*/
        TA1REC.TA1TBLVU = "VCLGLC01"; /* table view name*/
        CL0KW01.CL0KWNUM = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CL0KW01.CL0KWNUM; /* table key*/
        ;
        XPCL010(); /* error diagnosis routine*/
      end
    end
  end
end // end KL0K917

// select unique from clirec
Function KL0K920()
   /* **************************************/
   /* select unique from clirec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO1300" ("SB", SQLCA, CLIREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        TA1REC.TA1LOCAT[2] = "CL0K920"; /* location*/
        TA1REC.TA1MAP = "CL0KM001";
        TA1REC.TA1DBASE = "DCLAIM  ";
        TA1REC.TA1TBLVU = "VCLGLX01";
        CL0KW01.CL0KWNUM = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CL0KW01.CL0KWNUM;
        TA1REC.TA1LOCAT[4] = "IO1300";
        ;
        XPCL010(); /* error diagnosis routine*/
        ;
        return;
      end
    end
  end
end // end KL0K920

// select unique from clarec
Function KL0K924()
   /* **************************************/
   /* select unique on clarec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO1160" ("S ", SQLCA, CLAREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        ;
        TA1REC.TA1LOCAT[2] = "CL0K924"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO1160"; /* location*/
        TA1REC.TA1DBASE = "DCLAIM"; /* database name*/
        TA1REC.TA1TBLVU = "VCLHDR01"; /* table view name*/
        CL0KW01.CL0KWNUM = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CL0KW01.CL0KWNUM; /* table key*/
        ;
        XPCL010(); /* error diagnosis routine*/
      end
    end
  end
end // end KL0K924

// update unique from clarec
Function KL0K927()
   /* **************************************/
   /* update unique on clarec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO1160" ("U ", SQLCA, CLAREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        ;
        TA1REC.TA1LOCAT[2] = "CL0K927"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO1160"; /* location*/
        TA1REC.TA1DBASE = "DCLAIM"; /* database name*/
        TA1REC.TA1TBLVU = "VCLHDR01"; /* table view name*/
        CL0KW01.CL0KWNUM = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CL0KW01.CL0KWNUM; /* table key*/
        ;
        XPCL010(); /* error diagnosis routine*/
      end
    end
  end
end // end KL0K927

// select unique from clhrec
Function KL0K934()
   /* **************************************/
   /* select unique on clhrec*/
   /* **************************************/
  ;
  set SQLCA empty;
  call "IO1290" ("SA", SQLCA, CLHREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        ;
        TA1REC.TA1LOCAT[2] = "CL0K934"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO1290"; /* location*/
        TA1REC.TA1DBASE = "DCLAIM"; /* database name*/
        TA1REC.TA1TBLVU = "VCLMEM01"; /* table view name*/
        CL0KW01.CL0KWNUM = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CL0KW01.CL0KWNUM; /* table key*/
        ;
        XPCL010(); /* error diagnosis routine*/
      end
    end
  end
end // end KL0K934

// select max seq # from clirec
Function KL0K944()
   /* **************************************/
   /* select max seq # from clirec*/
   /* **************************************/
  ;
  set CL0KW04 empty;
  CL0KW04.CL0KWSQL = "MX"; /* find maximum sequence number*/
  call "IO1300" (CL0KW04, SQLCA, CLIREC) {isNoRefresh = yes, isExternal = yes};
  ;
  if (SQLCA.VAGen_SQLCODE != 0)
    ;
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* database is busy*/
      CLXREC.CLXERRF = "Y";
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* next sentence*/
      else
        TA1REC.TA1LOCAT[2] = "CL0K944"; /* location*/
        TA1REC.TA1MAP = "CL0KM001";
        TA1REC.TA1DBASE = "DCLAIM  ";
        TA1REC.TA1TBLVU = "VCLGLX01";
        CL0KW01.CL0KWNUM = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CL0KW01.CL0KWNUM;
        TA1REC.TA1LOCAT[4] = "IO1300";
        ;
        XPCL010(); /* error diagnosis routine*/
        ;
        return;
      end
    end
  end
end // end KL0K944

// pf1 help
Function KL0KS01()
  ;
  ;
  ;
      /* skip edits/updates, exit to goal documentation*/
  ;
  COMMAREA.CATOAP = "GD00";
  XPCL002();
  ;
  TA1REC.TA1TBLKE = "CANT TRANSFER TO GD00 REQUESTED APPL";
  XPCL010(); /* serious error if cant*/
                                   /* transfer...abend*/
  ;
  ;
  ;
end // end KL0KS01

Function KL0KS02()
   /* ************************************************************/
   /* *      handle the entry of pfkey 2                        **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  ;
  CLXREC.CLXEDITF = "N"; /* we don't want to do edits*/
  CLXREC.CLXEOSF = "Y"; /* we are done with this screen*/
  CLXREC.CLXEOAF = "Y"; /* we are done with this application*/
  ;
  COMMAREA.CATOAP = "KL0M"; /* memo screen*/
  XPCL002();
  ;
  ;
  ;
  ;
end // end KL0KS02

// pf3 exit to claims
Function KL0KS03()
  ;
  ;
  ;
      /* skip edits/update, go to higher level in claims*/
  ;
  COMMAREA.CATOAP = "KL0A"; /* go to claims menu*/
  ;
  XPCL002(); /* common claims exit*/
  ;
  ;
  ;
end // end KL0KS03

// pf4 exit to master menu
Function KL0KS04()
  ;
  ;
  ;
      /* skip edits/update, go to goal master menu*/
  ;
  COMMAREA.CATOAP = "MN0M"; /* go to master menu*/
  ;
  XPCL002(); /* common claims exit*/
  ;
  ;
  ;
end // end KL0KS04

// pf 5 action
Function KL0KS05()
   /* ************************************************************/
   /* *      handle the entry of pfkey 5                        **/
   /* *        claim header                                     **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  ;
  CLXREC.CLXEDITF = "N"; /* we don't want to do edits*/
  CLXREC.CLXEOSF = "Y"; /* we are done with this screen*/
  CLXREC.CLXEOAF = "Y"; /* we are done with this application*/
  ;
  COMMAREA.CATOAP = "KL0E"; /* claim header screen*/
  XPCL002();
  ;
  ;
  ;
end // end KL0KS05

// get claim header data
Function KL0KS10()
  ;
  ;
  ;
  KL0KM001.CLWSEQNB = CLAREC.CLACSQNB;
  CL0KW01.CL0KWTDT = CLAREC.CLASTTDT;
  ;
  CL0KW01.CL0KWMEM = CLWREC.CLHMEMNB;
                                   /* move memo nbr to scrn (if one)*/
  CL0KW01.CL0KWBOC = CLAREC.CLADBOCL; /* save this for later*/
  ;
  CL0KW01.CL0KWEST = CLAREC.CLAESTVL; /* keep amt and adjust as*/
                                         /* ; entries are made*/
  ;
  if (CLAREC.YCTCD in YCTTBL.YCTCD) /* get claim type abrv*/
    CL0KW01.YCTABRV = YCTTBL.YCTABRV[sysVar.arrayIndex]; /* move to map*/
  else
    CL0KW01.YCTABRV = " "; /* move blanks to map*/
  end
  ;
  if (CLAREC.YCSCD1 in YCSTBL.YCSCD) /* get short status desc*/
    CL0KW01.YCSSDESC = YCSTBL.YCSSDESC[sysVar.arrayIndex];
    if (YCSTBL.YCSAINPF[sysVar.arrayIndex] == "Y")
      set KL0KM001.CLICRDFL[1] cursor;
    else
      CLWREC.CLWACTIV = "I";
      CLWREC.CLWMNOPT = 4;
      set KL0KM001.CATOAP cursor;
    end
  else
    TA1REC.TA1TBLKE = "YCSCD NOT IN YCSTBL";
    XPCL010();
  end
  ;
  ;
  ;
end // end KL0KS10

// determine if memo exists
Function KL0KS12()
  ;
  ;
  ;
  set CLHREC empty;
  ;
  CLHREC.CLACLMNB = CLAREC.CLACLMNB; /* load claim and seq nbr,*/
  if (CLAREC.CLACSQNB < 2)
    CLHREC.CLHSEQNB = 1;
  else
    CLHREC.CLHSEQNB = CLAREC.CLACSQNB - 1; /* memo seq is one less*/
     /* than curr seq nbr on clhdr*/
  end
   /* MOVE CLAREC.CLACSQNB TO CLHREC.CLHSEQNB; & look for memo nbr*/
  ;
  KL0K934(); /* select unique clhrec*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0) /* if memo nbr found*/
    CL0KW01.CL0KWMEM = CLHREC.CLHMEMNB; /* move to ws*/
    set KL0KM001.CLWSEQNB initialAttributes;
  else
    if (SQLCA.VAGen_SQLCODE == 100) /* if memo not found*/
      if (KL0KM001.CLWSEQNB >= CLAREC.CLACSQNB)
        /* NEXT SENTENCE*/
      else
        converseLib.validationFailed(12); /* "memo not found, try another sequence #"*/
        set KL0KM001.CLWSEQNB cursor, bold;
      end
    end
  end
                           /* ;why show msg 182?????? see above*/
                               /* ;  is this really appropriate??*/
  ;
  ;
end // end KL0KS12

// retrieve gl records
Function KL0KS14()
  ;
  ;
  ;
  ;
  CLXREC.CLXARAYX = 1;
  CLXREC.CLXLSTAX = 0;
  CL0KW01.CL0KWGLT = 0; /* zero out screen g/l total*/
  ;
  set CL0KW02 empty;
  ;
  while (CLXREC.CLXARAYX <= 12)
    CL0KW02.CL0KWNEF[CLXARAYX] = "Y";
    CLXREC.CLXARAYX = CLXREC.CLXARAYX + 1;
  end
  ;
  CLXREC.CLXARAYX = 1;
  ;
  set CLIREC empty;
  CLIREC.CLACLMNB = CLAREC.CLACLMNB;
  CLIREC.CLHSEQNB = 1;
  ;
  KL0K911(); /* select set 'clirec'*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    while (SQLCA.VAGen_SQLCODE == 0
     && CLXREC.CLXARAYX <= 12)
      KL0K912();
      if (SQLCA.VAGen_SQLCODE == 0)
        CL0KW02.CL0KWNEF[CLXARAYX] = "N";
        KL0KS15();
      else
        if (SQLCA.VAGen_SQLCODE == 100)
           /* next sentence*/
        end
      end
    end
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      converseLib.validationFailed(9); /* "no records exist"*/
    else
      if (SQLCA.VAGen_SQLCODE == -911)
        converseLib.validationFailed(4);
        CLXERRF = "Y";
        CLXBLDSC = "Y";
      end
    end
    ;
  end
  ;
  KL0K913(); /* close set clirec*/
  ;
end // end KL0KS14

// move gl records to w.s.
Function KL0KS15()
   /* *******************************************************/
   /* *    move gl records to w.s.                         **/
   /* *                                                    **/
   /* * save the entire record because of the way the iomod**/
   /* * works.  the below fields are not necessarily used  **/
   /* * by cl0k but are part of clirec.                    **/
   /* *                                                    **/
   /* *  Maintenance History:                              **/
   /* *                                                    **/
   /* *  01-19-90 CHELLM  replaced the XGETBL with PFJREC  **/
   /* *                  and IO4360 to get GLASDESC.       **/
   /* *                  renamed XGEXREF to PFJXREF        **/
   /* *  02-16-90 BCOURT init PFJREC.                      **/
   /* *******************************************************/
  ;
  CL0KW02.PFJXREF[CLXARAYX] = CLIREC.PFJXREF;
  CL0KW02.XGPCD[CLXARAYX] = CLIREC.XGPCD;
  CL0KW02.SY1STNBR[CLXARAYX] = CLIREC.SY1STNBR;
  CL0KW02.SY2CLRID[CLXARAYX] = CLIREC.SY2CLRID;
  CL0KW02.XDMCD[CLXARAYX] = CLIREC.XDMCD;
  CL0KW02.IV0PARTN[CLXARAYX] = CLIREC.IV0PARTN;
  CL0KW02.CL0KWIID[CLXARAYX] = CLIREC.IV0IVCID;
  CL0KW02.CLIGLNFL[CLXARAYX] = CLIREC.CLIGLNFL;
  CL0KW02.CL0KWZDT[CLXARAYX] = CLIREC.ZZZCHGDT;
  CL0KW02.CL0KWZTM[CLXARAYX] = CLIREC.ZZZCHGTM;
  CL0KW02.CL0KWZCT[CLXARAYX] = CLIREC.ZZZCHGCT;
  CL0KW02.IV0PARTN[CLXARAYX] = CLIREC.IV0PARTN;
  CL0KW02.OP2LNINB[CLXARAYX] = CLIREC.OP2LNINB;
  CL0KW02.CLIIGOFL[CLXARAYX] = CLIREC.CLIIGOFL;
  CL0KW02.CLIGLFIV[CLXARAYX] = CLIREC.CLIGLFIV;
  CL0KW02.IV6FBTYP[CLXARAYX] = CLIREC.IV6FBTYP;
  CL0KW02.IV6GLSEQ[CLXARAYX] = CLIREC.IV6GLSEQ;
  CL0KW02.CLIADVSQ[CLXARAYX] = CLIREC.CLIADVSQ;
  ;
   /* *******************************************************/
   /* these are the clirec fields actually used by cl0k map:*/
   /* *******************************************************/
  CL0KW02.CLICRDFL[CLXARAYX] = CLIREC.CLICRDFL;
  CL0KW02.GLACD[CLXARAYX] = CLIREC.GLACD;
  CL0KW02.CL0KWPCT[CLXARAYX] = CLIREC.CLICALPC;
  CL0KW02.XSTCD[CLXARAYX] = CLIREC.XSTCD;
  CL0KW02.XSECD[CLXARAYX] = CLIREC.XSECD;
  CL0KW02.CL0KWD2[CLXARAYX] = CLIREC.XSECD;
  CL0KW02.CLICARMO[CLXARAYX] = CLIREC.CLICARMO;
  CL0KW02.CL0KWD3[CLXARAYX] = CLIREC.CLICARMO;
  CL0KW02.CL0KWCAR[CLXARAYX] = CLIREC.CLICARCT;
  CL0KW02.CLIADMAT[CLXARAYX] = CLIREC.CLIADMAT;
  CL0KW02.YMDCD[CLXARAYX] = CLIREC.YMDCD;
  CL0KW02.YAPCD[CLXARAYX] = CLIREC.YAPCD;
  CL0KW02.CLIGLAM[CLXARAYX] = CLIREC.CLIGLAM;
  ;
  ;
                             /* (begin 11-17-89 addition)*/
  ;
  set PFJREC empty; /* 2-16-90 add*/
  PFJREC.GLACD = CLIREC.GLACD;
  ;
  set SQLCA empty;
  call "IO4360" ("S ", SQLCA, PFJREC) {isNoRefresh = yes, isExternal = yes}; /* get gl code info*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    CL0KW02.GLADESC[CLXARAYX] = PFJREC.GLASDESC;
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      CL0KW02.GLADESC[CLXARAYX] = " ";
                                   /* if none, move spaces to desc*/
    else
      TA1REC.TA1DBASE = "DPROFT";
      TA1REC.TA1TBLVU = "VGLCDS01";
      CLXREC.XXXWDTE = CLIREC.CLACLMNB;
      TA1REC.TA1TBLKE = CLXREC.XXXWDTE;
      XPCL010();
    end
  end
                             /* (end 11-17-89 addition)*/
  ;
  if (CL0KW02.CLICRDFL[CLXARAYX] == "C")
    CL0KW01.CL0KWGLT = CL0KW01.CL0KWGLT + CL0KW02.CLIGLAM[CLXARAYX] * -1;
  else
    CL0KW01.CL0KWGLT = CL0KW01.CL0KWGLT + CL0KW02.CLIGLAM[CLXARAYX];
  end
  ;
  ;
  ;
  CLXREC.CLXLSTAX = CLXREC.CLXLSTAX + 1; /* accumulate array total*/
  CLXREC.CLXARAYX = CLXREC.CLXARAYX + 1; /* bump to next array number*/
  ;
  ;
  ;
end // end KL0KS15

// move w.s. to map
Function KL0KS16()
   /* ********************************************************/
   /* * move header to map...yahoo here we go                **/
   /* **/
   /* *  Maintenance History:*/
   /* **/
   /* *  01-19-90 CHELLM renamed cl0kw02.glcd & cl0kw02.xgedesc*/
   /* *                  as glacd and gladesc.*/
   /* **/
   /* ********************************************************/
  KL0KM001.CLACLMNB = CLAREC.CLACLMNB;
  KL0KM001.KUCCOID = CLAREC.KUCCOID;
  KL0KM001.KUMSTRID = CLAREC.KUMSTRID;
  KL0KM001.XNXCD = CLAREC.XNXCD;
  KL0KM001.KUCCONM = CLWREC.KUCCONM;
  KL0KM001.CLWSEQNB = CLAREC.CLACSQNB;
  KL0KM001.CLACTCNM = CLAREC.CLACTCNM;
  KL0KM001.CLHMEMNB = CL0KW01.CL0KWMEM;
  KL0KM001.YCTCD = CLAREC.YCTCD;
  KL0KM001.YCTABRV = CL0KW01.YCTABRV;
  KL0KM001.YCSCD = CLAREC.YCSCD1;
  KL0KM001.YCSSDESC = CL0KW01.YCSSDESC;
  KL0KM001.CLASTTDT = CL0KW01.CL0KWTDT;
  ;
   /* **********************************************/
   /* set array counter and map counters*/
   /* **********************************************/
  ;
  CLXREC.CLXMAXLN = 0; /* keep track of how full map is*/
  CLXREC.CLXCURLN = 1; /* start with map line 1*/
   /* **********************************************/
   /* move detail lines to map                   **/
   /* **********************************************/
  ;
  while (CLXREC.CLXCURLN <= 12)
    KL0KM001.CLICRDFL[CLXCURLN] = CL0KW02.CLICRDFL[CLXCURLN];
    KL0KM001.GLACD[CLXCURLN] = CL0KW02.GLACD[CLXCURLN];
    KL0KM001.GLADESC[CLXCURLN] = CL0KW02.GLADESC[CLXCURLN];
    KL0KM001.CLICALPC[CLXCURLN] = CL0KW02.CL0KWPCT[CLXCURLN];
    KL0KM001.XSTCD[CLXCURLN] = CL0KW02.XSTCD[CLXCURLN];
    KL0KM001.CL0KMDAR[CLXCURLN] = CL0KW02.CL0KWD1[CLXCURLN];
    KL0KM001.CLICARCT[CLXCURLN] = CL0KW02.CL0KWCAR[CLXCURLN];
    KL0KM001.CLIADMAT[CLXCURLN] = CL0KW02.CLIADMAT[CLXCURLN];
    KL0KM001.YMDCD[CLXCURLN] = CL0KW02.YMDCD[CLXCURLN];
    KL0KM001.YAPCD[CLXCURLN] = CL0KW02.YAPCD[CLXCURLN];
    KL0KM001.CLIGLAM[CLXCURLN] = CL0KW02.CLIGLAM[CLXCURLN];
    ;
    /* **********************************************/
     /* if the last record has been moved, then    **/
     /* 'total amount' to gl desc field and        **/
     /* accumulated total to the gl amt field,     **/
     /* and  blank out the remaining fields*/
    /* **********************************************/
    CLXREC.CLXMAXLN = CLXREC.CLXMAXLN + 1;
    CLXREC.CLXCURLN = CLXREC.CLXCURLN + 1;
    ;
  end
  ;
  KL0KM001.CL0KWGLT = CL0KW01.CL0KWGLT;
end // end KL0KS16

// protect gl recs from change
Function KL0KS18()
   /* ***********************************************************/
   /* *                                                        **/
   /* *             protect gl recs from change                **/
   /* *                                                        **/
   /* *  Maintenance History:                                  **/
   /* *                                                        **/
   /* *  01-19-90 CHELLM renamed cl0km001.glcd as glacd        **/
   /* *                  renamed cl0km001.xgedesc as gladesc   **/
   /* *                                                        **/
   /* *                                                        **/
   /* ***********************************************************/
  set KL0KM001.CATOAP cursor;
  ;
  CLXREC.CLXCURLN = 1;
  ;
  while (CLXREC.CLXCURLN <= 12)
    set KL0KM001.CLICRDFL[CLXCURLN] skip;
    set KL0KM001.GLACD[CLXCURLN] skip;
    set KL0KM001.GLADESC[CLXCURLN] skip;
    set KL0KM001.CLICALPC[CLXCURLN] skip;
    set KL0KM001.XSTCD[CLXCURLN] skip;
    set KL0KM001.CL0KMDAR[CLXCURLN] skip;
    set KL0KM001.CLICARCT[CLXCURLN] skip;
    set KL0KM001.CLIADMAT[CLXCURLN] skip;
    set KL0KM001.YMDCD[CLXCURLN] skip;
    set KL0KM001.YAPCD[CLXCURLN] skip;
    set KL0KM001.CLIGLAM[CLXCURLN] skip;
    ;
    CLXREC.CLXCURLN = CLXREC.CLXCURLN + 1;
  end
end // end KL0KS18

// edit gl amount--gl amount
Function KL0KS1A()
   /* ************************************************************/
   /* *                                                         **/
   /* *  edit gl amount -- gl amount                            **/
   /* *                                                         **/
   /* *  Maintenance History:                                   **/
   /* *                                                         **/
   /* *  01-19-90 CHELLM renamed cl0km001.glcd as glacd         **/
   /* *  03-06-90 CHELLM when an error occurs on the screen     **/
   /* *           prevent the overlay of the original gl amt    **/
   /* *           so the est clm value gets updated correctly   **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  if (KL0KM001.CLIGLAM[CLXCURLN] == 0)
    if (KL0KM001.CLICRDFL[CLXCURLN] > " "
     || KL0KM001.GLACD[CLXCURLN] > " "
     || KL0KM001.XSTCD[CLXCURLN] > " "
     || KL0KM001.CL0KMDAR[CLXCURLN] > " "
     || KL0KM001.CLICARCT[CLXCURLN] > 0
     || KL0KM001.CLIADMAT[CLXCURLN] > " "
     || KL0KM001.YMDCD[CLXCURLN] > " "
     || KL0KM001.YAPCD[CLXCURLN] > " ")
      converseLib.validationFailed(186);
      set KL0KM001.CLIGLAM[CLXCURLN] cursor, modified, bold;
      CLXREC.CLXERRF = "Y";
    else
    end
  else
    /* ***********************************************/
     /* if an existing entry had the gl amt changed,*/
     /* move the existing amount to cl0kwglw and the*/
     /* new amt to cl0kwglm.  this will be used later*/
     /* for updating clarec.claestvl (cl0ks2a)*/
    /* ***********************************************/
    /* IF CL0KW02.CL0KWMOD(CLXCURLN) EQ 'C';*/
    CL0KW02.CL0KWGLW[CLXCURLN] = CL0KW02.CLIGLAM[CLXCURLN];
    CL0KW02.CL0KWGLM[CLXCURLN] = KL0KM001.CLIGLAM[CLXCURLN];
    /* END ;*/
    ;
    /* ************************************************/
    set KL0KM001.CLIGLAM[CLXCURLN] initialAttributes;
    /* MOVE CL0KM001.CLIGLAM(CLXCURLN) TO CL0KW02.CLIGLAM(CLXCURLN)*/
  end /* above line commented out 3-6-90 because when a screen*/
         /* error occurred the original gl-amount was overlayed*/
         /* here with the new gl amount.  therefore, when CL0KS2G*/
        /* tried to calculate the new CL0KWEST the original value*/
         /* was not used and resulted in a zero net change to*/
         /* the estimated claim value in CLAREC.*/
end // end KL0KS1A

// edit product line--prod line
Function KL0KS1B()
  ;
  ;
  ;
  if (KL0KM001.YAPCD[CLXCURLN] > " ")
    if (KL0KM001.YAPCD[CLXCURLN] in YAPTBL.YAPCD)
      set KL0KM001.YAPCD[CLXCURLN] initialAttributes;
      CL0KW02.YAPCD[CLXCURLN] = KL0KM001.YAPCD[CLXCURLN];
    else
      converseLib.validationFailed(180); /* "product line is not valid"*/
      set KL0KM001.YAPCD[CLXCURLN] cursor, modified, bold;
      CLXREC.CLXERRF = "Y";
    end
  else
    set KL0KM001.YAPCD[CLXCURLN] initialAttributes;
    CL0KW02.YAPCD[CLXCURLN] = KL0KM001.YAPCD[CLXCURLN];
  end
  ;
  ;
  ;
end // end KL0KS1B

// edit adv. media code--med
Function KL0KS1C()
  ;
  ;
  ;
  if (KL0KM001.YMDCD[CLXCURLN] > " ")
    if (KL0KM001.YMDCD[CLXCURLN] in YMDTBL.YMDCD)
      set KL0KM001.YMDCD[CLXCURLN] initialAttributes;
      CL0KW02.YMDCD[CLXCURLN] = KL0KM001.YMDCD[CLXCURLN];
    else
      converseLib.validationFailed(179);
                                   /* "advertising media code is not valid"*/
      set KL0KM001.YMDCD[CLXCURLN] cursor, modified, bold;
      CLXREC.CLXERRF = "Y";
    end
  else
    set KL0KM001.YMDCD[CLXCURLN] initialAttributes;
    CL0KW02.YMDCD[CLXCURLN] = KL0KM001.YMDCD[CLXCURLN];
  end
  ;
  ;
  ;
end // end KL0KS1C

// edit nike ad matrl--nk am
Function KL0KS1D()
  ;
  ;
  ;
  if (KL0KM001.CLIADMAT[CLXCURLN] > " ")
    if (KL0KM001.CLIADMAT[CLXCURLN] == "Y"
     || KL0KM001.CLIADMAT[CLXCURLN] == "N"
     || KL0KM001.CLIADMAT[CLXCURLN] == "M")
                                   /* mixed types(CL658E cwh 6-13-89)*/
      set KL0KM001.CLIADMAT[CLXCURLN] initialAttributes;
      CL0KW02.CLIADMAT[CLXCURLN] = KL0KM001.CLIADMAT[CLXCURLN];
    else
      converseLib.validationFailed(178); /* "nike ad material--enter y or n"*/
      set KL0KM001.CLIADMAT[CLXCURLN] cursor, modified, bold;
      CLXREC.CLXERRF = "Y";
    end
  else
    KL0KM001.CLIADMAT[CLXCURLN] = "N";
    set KL0KM001.CLIADMAT[CLXCURLN] initialAttributes;
    CL0KW02.CLIADMAT[CLXCURLN] = KL0KM001.CLIADMAT[CLXCURLN];
  end
  ;
  ;
  ;
end // end KL0KS1D

// edit date adver. ran--dar code
Function KL0KS1E()
  ;
  ;
  ;
  if (KL0KM001.CL0KMDAR[CLXCURLN] > " ")
    /* ******************************************************/
     /* break down the screen dar code in WORKING STORAGE  **/
    /* ******************************************************/
    CL0KW02.CL0KWD1[CLXCURLN] = KL0KM001.CL0KMDAR[CLXCURLN];
    ;
    if (CL0KW02.CL0KWD2[CLXCURLN] in XSNTBL.XSECD)
      if (CL0KW02.CL0KWD2[CLXCURLN] == "FA"
       && CL0KW02.CL0KWD3[CLXCURLN] >= 7
       && CL0KW02.CL0KWD3[CLXCURLN] <= 12)
        set KL0KM001.CL0KMDAR[CLXCURLN] initialAttributes;
        CL0KW02.XSECD[CLXCURLN] = CL0KW02.CL0KWD2[CLXCURLN];
        CL0KW02.CLICARMO[CLXCURLN] = CL0KW02.CL0KWD3[CLXCURLN];
      else
        if (CL0KW02.CL0KWD2[CLXCURLN] == "SP"
         && CL0KW02.CL0KWD3[CLXCURLN] >= 1
         && CL0KW02.CL0KWD3[CLXCURLN] <= 6)
          set KL0KM001.CL0KMDAR[CLXCURLN] initialAttributes;
          CL0KW02.XSECD[CLXCURLN] = CL0KW02.CL0KWD2[CLXCURLN];
          CL0KW02.CLICARMO[CLXCURLN] = CL0KW02.CL0KWD3[CLXCURLN];
        else
          converseLib.validationFailed(177); /* "dar code is not valid"*/
          set KL0KM001.CL0KMDAR[CLXCURLN] cursor, modified, bold;
          CLXREC.CLXERRF = "Y";
        end
      end
    else
      converseLib.validationFailed(177); /* "dar code is not valid"*/
      set KL0KM001.CL0KMDAR[CLXCURLN] cursor, modified, bold;
      CLXREC.CLXERRF = "Y";
    end
    ;
    ;
  else
    set KL0KM001.CL0KMDAR[CLXCURLN] initialAttributes;
    CL0KW02.CL0KWD1[CLXCURLN] = KL0KM001.CL0KMDAR[CLXCURLN];
    CL0KW02.XSECD[CLXCURLN] = CL0KW02.CL0KWD2[CLXCURLN];
    CL0KW02.CLICARMO[CLXCURLN] = CL0KW02.CL0KWD3[CLXCURLN];
  end
  ;
  ;
end // end KL0KS1E

// edit sales region code--reg cd
Function KL0KS1F()
  ;
  ;
  ;
  if (KL0KM001.XSTCD[CLXCURLN] > " ")
    if (KL0KM001.XSTCD[CLXCURLN] in XSTTBL.XSTCD)
      set KL0KM001.XSTCD[CLXCURLN] initialAttributes;
      CL0KW02.XSTCD[CLXCURLN] = KL0KM001.XSTCD[CLXCURLN];
    else
      converseLib.validationFailed(176); /* "sales region code is not valid"*/
      set KL0KM001.XSTCD[CLXCURLN] cursor, modified, bold;
      CLXREC.CLXERRF = "Y";
    end
  else
    set KL0KM001.XSTCD[CLXCURLN] initialAttributes;
    CL0KW02.XSTCD[CLXCURLN] = KL0KM001.XSTCD[CLXCURLN];
  end
  ;
  ;
  ;
end // end KL0KS1F

// edit ad allow percent--alw pct
Function KL0KS1G()
  ;
  ;
  ;
  if (KL0KM001.CLICALPC[CLXCURLN] > 0)
    if (KL0KM001.CLICALPC[CLXCURLN] <= 100)
      set KL0KM001.CLICALPC[CLXCURLN] initialAttributes;
      CL0KW02.CL0KWPCT[CLXCURLN] = KL0KM001.CLICALPC[CLXCURLN];
    else
      converseLib.validationFailed(175); /* "ad alw pct is not valid"*/
      set KL0KM001.CLICALPC[CLXCURLN] cursor, modified, bold;
      CLXREC.CLXERRF = "Y";
    end
  else
    if (KL0KM001.CLICALPC[CLXCURLN] == 0
     && KL0KM001.CLIGLAM[CLXCURLN] > 0)
      KL0KM001.CLICALPC[CLXCURLN] = 100;
      set KL0KM001.CLICALPC[CLXCURLN] initialAttributes;
      CL0KW02.CL0KWPCT[CLXCURLN] = KL0KM001.CLICALPC[CLXCURLN];
    end
  end
  ;
  ;
  ;
end // end KL0KS1G

// edit gl code--gl code
Function KL0KS1H()
   /* *************************************************************/
   /* *                                                          **/
   /* *    edit gl-code                                          **/
   /* *                                                          **/
   /* *  Maintenance History:                                    **/
   /* *                                                          **/
   /* *  01-19-90 CHELLM replaced xgetbl with pfjrec and io4360. **/
   /* *           added code to translate the coop only flag from**/
   /* *           pfjresfl                                       **/
   /* *  02-16-90 BCOURT test g/l status for PFJREC.             **/
   /* *************************************************************/
  if (KL0KM001.GLACD[CLXCURLN] == " ")
    if (KL0KM001.XSTCD[CLXCURLN] > " "
     || KL0KM001.CL0KMDAR[CLXCURLN] > " "
     || KL0KM001.CLICARCT[CLXCURLN] > 0
     || KL0KM001.CLIADMAT[CLXCURLN] > " "
     || KL0KM001.YMDCD[CLXCURLN] > " "
     || KL0KM001.YAPCD[CLXCURLN] > " "
     || KL0KM001.CLIGLAM[CLXCURLN] > 0)
      converseLib.validationFailed(174); /* "g/l code is required"*/
      set KL0KM001.GLACD[CLXCURLN] cursor, modified, bold;
      CLXREC.CLXERRF = "Y";
    end
    return;
  else
                                /* (begin 01-19-90 addition)*/
    ;
    set PFJREC empty; /* 2-16-90 add*/
    PFJREC.GLACD = KL0KM001.GLACD[CLXCURLN];
    ;
    set SQLCA empty;
    call "IO4360" ("S ", SQLCA, PFJREC) {isNoRefresh = yes, isExternal = yes}; /* get gl code info*/
    ;
    if (SQLCA.VAGen_SQLCODE == 0
     && PFJREC.XXXSTAT == "A") /* 2-16-90 add*/
      /* next sentence*/
    else
      if (SQLCA.VAGen_SQLCODE == 100
       || SQLCA.VAGen_SQLCODE == 0) /* 2-16-90 status = 'I'*/
        CL0KW02.GLADESC[CLXCURLN] = " ";
        if (KL0KM001.GLACD[CLXCURLN] > " ")
          converseLib.validationFailed(173); /* "gl code is not valid"*/
          set KL0KM001.GLACD[CLXCURLN] cursor, modified, bold;
          CLXREC.CLXERRF = "Y";
          return;
        else
          set KL0KM001.GLACD[CLXCURLN] initialAttributes;
          return;
        end
      else
        TA1REC.TA1DBASE = "DPROFT";
        TA1REC.TA1TBLVU = "VGLCDS01";
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE;
        XPCL010();
      end
    end
  end
                             /* (end 11-17-89 addition)*/
  ;
  if (CLAREC.YCTCD != "NBC" /* not an nbc claim*/
   && PFJREC.PFJRESFL == "B") /* but g/l is for nbc only*/
    converseLib.validationFailed(59); /* this gl only for nbc claims*/
    CLXREC.CLXERRF = "Y";
    set KL0KM001.GLACD[CLXCURLN] cursor, modified, bold;
    return;
  end
  ;
  ;
  if (CLAREC.YCTCD == "DAA") /* a daa claim*/
    if (PFJREC.PFJBNKIF == "A" /* but g/l is bank*/
     || PFJREC.PFJBNKIF == "C" /* but g/l is bank*/
     || PFJREC.PFJBNKIF == "F") /* but g/l is bank*/
      converseLib.validationFailed(61); /* this gl only for nbc claims*/
      CLXREC.CLXERRF = "Y";
      set KL0KM001.GLACD[CLXCURLN] cursor, modified, bold;
      return;
    end
  end
                                     /* (begin 01-19-90 changes)*/
  ;
  CL0KW02.GLADESC[CLXCURLN] = PFJREC.GLADESC;
  ;
  if (PFJREC.PFJBNKIF == "A"
   || PFJREC.PFJBNKIF == "C"
   || PFJREC.PFJBNKIF == "F")
    CL0KW02.IV6FBTYP[CLXCURLN] = "B";
  else
    if (PFJREC.PFJBNKIF == "N")
      CL0KW02.IV6FBTYP[CLXCURLN] = "F";
    else
      converseLib.validationFailed(604);
                                   /* G/L tbl maint required - call sys dev*/
      CLXREC.CLXERRF = "Y";
      return;
    end
  end
                                     /* (end 01-19-90 changes)*/
  ;
  set KL0KM001.GLACD[CLXCURLN] initialAttributes;
  ;
  ;
end // end KL0KS1H

// edit debit/credit field--c/d
Function KL0KS1I()
   /* ***********************************************************/
   /* *                                                        **/
   /* *  edit debit/credit field -- c/d                       **/
   /* *                                                        **/
   /* *  Maintenance History:                                  **/
   /* *                                                        **/
   /* *  01-19-90 CHELLM renamed CL0KM001.GLCD as GLACD        **/
   /* *                                                        **/
   /* *                                                        **/
   /* ***********************************************************/
  ;
  if (KL0KM001.CLICRDFL[CLXCURLN] > " "
   && KL0KM001.CLICRDFL[CLXCURLN] != "D"
   && KL0KM001.CLICRDFL[CLXCURLN] != "C"
   && KL0KM001.CLICRDFL[CLXCURLN] != "X")
    converseLib.validationFailed(171); /* debit/credit: c(credit), d(debit*/
                                 /* ;   x(delete)*/
    set KL0KM001.CLICRDFL[CLXCURLN] cursor, modified, bold;
    CLXREC.CLXERRF = "Y";
  else
    if (KL0KM001.CLICRDFL[CLXCURLN] == " ")
      if (KL0KM001.GLACD[CLXCURLN] > " "
       || KL0KM001.XSTCD[CLXCURLN] > " "
       || KL0KM001.CL0KMDAR[CLXCURLN] > " "
       || KL0KM001.CLICARCT[CLXCURLN] > 0
       || KL0KM001.CLIADMAT[CLXCURLN] > " "
       || KL0KM001.YMDCD[CLXCURLN] > " "
       || KL0KM001.YAPCD[CLXCURLN] > " "
       || KL0KM001.CLIGLAM[CLXCURLN] > 0)
        converseLib.validationFailed(171); /* debit/credit: c(credit), d(debit*/
                                     /* ;   x(delete)*/
        set KL0KM001.CLICRDFL[CLXCURLN] cursor, modified, bold;
        CLXREC.CLXERRF = "Y";
      else
         /* next sentence*/
      end
    else
      set KL0KM001.CLICRDFL[CLXCURLN] initialAttributes;
    end
  end
  ;
  ;
  ;
  ;
  ;
end // end KL0KS1I

// pf 20 action memo comment
Function KL0KS20()
   /* ************************************************************/
   /* *      handle the entry of pfkey 20                       **/
   /* *        memo  comment                                    **/
   /* * add 1-4-88                                              **/
   /* ************************************************************/
  ;
  CLXREC.CLXEDITF = "N"; /* we don't want to do edits*/
  CLXREC.CLXEOSF = "Y"; /* we are done with this screen*/
  CLXREC.CLXEOAF = "Y"; /* we are done with this application*/
  ;
  CLWREC.CLWMCMNT = "Y";
  ;
  COMMAREA.CATOAP = "KL0G"; /* memo  comment screen*/
  XPCL002();
  ;
  ;
end // end KL0KS20

// modify entered fields
Function KL0KS26()
   /* ************************************************************/
   /* *  since the map must be re-shown to the user             **/
   /* *  before editing has been done, set fields modified to   **/
   /* *  keep track of all the fields entered by the user.      **/
   /* *  the user will only need to re-do the pf key or enter   **/
   /* *  key, not enter the data again.                         **/
   /* *                                                         **/
   /* *  Maintenance History:                                   **/
   /* *                                                         **/
   /* *  01-19-90 CHELLM renamed cl0km001.glcd as glacd         **/
   /* *                                                         **/
   /* *                                                         **/
   /* *                                                         **/
   /* ************************************************************/
  ;
  ;
    /* for every entry field on the map,*/
    /* do this:*/
  ;
    /* if map.field modified*/
      /* set map.field modified*/
    /* end*/
  ;
  ;
  ;
  if (KL0KM001.CLWSEQNB is modified)
    set KL0KM001.CLWSEQNB modified;
  end
  ;
  if (KL0KM001.CLIGLAM[CLXCURLN] is modified)
    set KL0KM001.CLIGLAM[CLXCURLN] modified;
    CLXREC.CLXEDITF = "Y";
  end
  ;
  if (KL0KM001.YAPCD[CLXCURLN] is modified)
    set KL0KM001.YAPCD[CLXCURLN] modified;
    CLXREC.CLXEDITF = "Y";
  end
  ;
  if (KL0KM001.YMDCD[CLXCURLN] is modified)
    set KL0KM001.YMDCD[CLXCURLN] modified;
    CLXREC.CLXEDITF = "Y";
  end
  ;
  if (KL0KM001.CLIADMAT[CLXCURLN] is modified)
    set KL0KM001.CLIADMAT[CLXCURLN] modified;
    CLXREC.CLXEDITF = "Y";
  end
  ;
  if (KL0KM001.CLICARCT[CLXCURLN] is modified)
    set KL0KM001.CLICARCT[CLXCURLN] modified;
    CLXREC.CLXEDITF = "Y";
  end
  ;
  if (KL0KM001.CL0KMDAR[CLXCURLN] is modified)
    set KL0KM001.CL0KMDAR[CLXCURLN] modified;
    CLXREC.CLXEDITF = "Y";
  end
  ;
  if (KL0KM001.XSTCD[CLXCURLN] is modified)
    set KL0KM001.XSTCD[CLXCURLN] modified;
    CLXREC.CLXEDITF = "Y";
  end
  ;
  if (KL0KM001.CLICALPC[CLXCURLN] is modified)
    set KL0KM001.CLICALPC[CLXCURLN] modified;
    CLXREC.CLXEDITF = "Y";
  end
  ;
  if (KL0KM001.GLACD[CLXCURLN] is modified)
    set KL0KM001.GLACD[CLXCURLN] modified;
    CLXREC.CLXEDITF = "Y";
  end
  ;
  if (KL0KM001.CLICRDFL[CLXCURLN] is modified)
    set KL0KM001.CLICRDFL[CLXCURLN] modified;
    CLXREC.CLXEDITF = "Y";
  end
  ;
  ;
  ;
  ;
end // end KL0KS26

// perform delete - clirec
Function KL0KS2B()
   /* **********************************************************/
   /* *           perform delete - clirec                     **/
   /* *                                                       **/
   /* *  Maintenance History:                                 **/
   /* *                                                       **/
   /* *  01-19-90 CHELLM renamed cl0kw02.glcd as glacd        **/
   /* *                                                       **/
   /* *                                                       **/
   /* **********************************************************/
  set CLIREC empty;
  CLIREC.CLACLMNB = CLAREC.CLACLMNB;
  CLIREC.CLHSEQNB = CLAREC.CLACSQNB;
  CLIREC.CLICRDFL = CL0KW02.CLICRDFL[CLXARAYX];
  CLIREC.GLACD = CL0KW02.GLACD[CLXARAYX];
  CLIREC.CLIADVSQ = CL0KW02.CLIADVSQ[CLXARAYX];
  CLIREC.ZZZCHGCT = CL0KW02.CL0KWZCT[CLXARAYX];
  ;
  ;
  KL0K917(); /* check if record exists & lock it*/
  if (SQLCA.VAGen_SQLCODE == 0) /* record exists*/
    KL0K915(); /* delete the record*/
    if (SQLCA.VAGen_SQLCODE == 0)
      ;
      if (CL0KW02.CLICRDFL[CLXARAYX] == "C")
        CL0KW01.CL0KWEST = CL0KW01.CL0KWEST + CL0KW02.CLIGLAM[CLXARAYX];
        KL0KS2F(); /* perform update to clarec*/
      else
        CL0KW01.CL0KWEST = CL0KW01.CL0KWEST - CL0KW02.CLIGLAM[CLXARAYX];
        KL0KS2F(); /* perform update to clarec*/
      end
      ;
    end
  else
    if (SQLCA.VAGen_SQLCODE == 100) /* if no record found,*/
      converseLib.validationFailed(18); /* can't delete it*/
      CLXREC.CLXBLDSC = "Y";
      CLXREC.CLXERRF = "Y";
      return;
    else
      if (SQLCA.VAGen_SQLCODE == -911)
        converseLib.validationFailed(4); /* -911 database busy, try to update again*/
      end
    end
  end
  ;
  VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
  VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
  sysLib.commit();
  VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
  
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
end // end KL0KS2B

// update 'add' to clirec
Function KL0KS2C()
   /* *********************************************************/
   /* *                                                      **/
   /* *           update 'add' to clirec                     **/
   /* *                                                      **/
   /* *  Maintenance History:                                **/
   /* *                                                      **/
   /* *  01-19-90 CHELLM renamed  CL0KM001.GLCD as GLACD     **/
   /* *  03-06-90 CHELLM when an error occurs on the screen  **/
   /* *           prevent the overlay of the original gl amt **/
   /* *           so the est clm value gets updated correctly**/
   /* *                                                      **/
   /* *********************************************************/
  ;
   /* --------------*/
  KL0KS2H(); /* get new sequence nbr for new add*/
   /* --------------*/
  ;
  set CLIREC empty;
  CLIREC.CLACLMNB = CLAREC.CLACLMNB;
  CLIREC.CLHSEQNB = CLAREC.CLACSQNB;
  CLIREC.CLICRDFL = KL0KM001.CLICRDFL[CLXARAYX];
  CLIREC.GLACD = KL0KM001.GLACD[CLXARAYX];
  CLIREC.CLIADVSQ = CL0KW02.CLIADVSQ[CLXARAYX];
  ;
  KL0K920(); /* ; check if record exists*/
  if (SQLCA.VAGen_SQLCODE == 0) /* record exists*/
     /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == 100) /* if no record found, add record*/
      CL0KW02.CLIGLNFL[CLXARAYX] = "N";
      if (CL0KW02.CLIADMAT[CLXARAYX] == " ")
        CL0KW02.CLIADMAT[CLXARAYX] = "N";
      else
         /* next sentence*/
      end
      CLIREC.ZZZCHGDT = CL0KW01.ZZZCHGDT;
      CLIREC.ZZZCHGTM = CL0KW01.ZZZCHGTM;
                                              /* (below added 3-6-90)*/
      CL0KW02.CLIGLAM[CLXARAYX] = CL0KW02.CL0KWGLM[CLXARAYX];
      ;
      KL0KS2E(); /* load record for update*/
      KL0K916();
      if (SQLCA.VAGen_SQLCODE == 0)
        ;
        if (KL0KM001.CLICRDFL[CLXARAYX] == "C")
          CL0KW01.CL0KWEST = CL0KW01.CL0KWEST - CL0KW02.CLIGLAM[CLXARAYX];
          KL0KS2F(); /* perform update to clarec*/
        else
          CL0KW01.CL0KWEST = CL0KW01.CL0KWEST + CL0KW02.CLIGLAM[CLXARAYX];
          KL0KS2F(); /* perform update to clarec*/
        end
        ;
      end
    end
  end
  ;
  ;
end // end KL0KS2C

// update 'change' to clirec
Function KL0KS2D()
   /* *********************************************************/
   /* *                                                      **/
   /* *         update 'change' to clirec                    **/
   /* *                                                      **/
   /* *  Maintenance History:                                **/
   /* *                                                      **/
   /* *  01-19-90 CHELLM renamce CL0KW02.GLCD as GLACD       **/
   /* *  03-06-90 CHELLM when an error occurs on the screen  **/
   /* *           prevent the overlay of the original gl amt **/
   /* *           so the est clm value gets updated correctly**/
   /* *                                                      **/
   /* *                                                      **/
   /* *********************************************************/
  ;
  set CLIREC empty;
  CLIREC.CLACLMNB = CLAREC.CLACLMNB;
  CLIREC.CLHSEQNB = CLAREC.CLACSQNB;
  CLIREC.CLICRDFL = CL0KW02.CLICRDFL[CLXARAYX];
  CLIREC.GLACD = CL0KW02.GLACD[CLXARAYX];
  CLIREC.CLIADVSQ = CL0KW02.CLIADVSQ[CLXARAYX];
  CLIREC.ZZZCHGCT = CL0KW02.CL0KWZCT[CLXARAYX];
  ;
  KL0K920(); /* select unique*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0) /* if record exists*/
    CLIREC.ZZZCHGDT = CL0KW01.ZZZCHGDT;
    CLIREC.ZZZCHGTM = CL0KW01.ZZZCHGTM;
                                            /* (below added 3-6-90)*/
    CL0KW02.CLIGLAM[CLXARAYX] = CL0KW02.CL0KWGLM[CLXARAYX];
    ;
    KL0KS2E(); /* load record to clirec*/
    KL0K917(); /* update clirec*/
    ;
    if (SQLCA.VAGen_SQLCODE == 0) /* if record exists*/
      if (KL0KM001.CLICRDFL[CLXARAYX] == "C")
        CL0KW01.CL0KWEST = CL0KW01.CL0KWEST + CL0KW02.CL0KWGLW[CLXARAYX];
        CL0KW01.CL0KWEST = CL0KW01.CL0KWEST - CL0KW02.CL0KWGLM[CLXARAYX];
        KL0KS2F();
      else
        CL0KW01.CL0KWEST = CL0KW01.CL0KWEST - CL0KW02.CL0KWGLW[CLXARAYX];
        CL0KW01.CL0KWEST = CL0KW01.CL0KWEST + CL0KW02.CL0KWGLM[CLXARAYX];
        KL0KS2F();
      end
    else
      TA1REC.TA1LOCAT[2] = "CL0KS2D"; /* location*/
      TA1REC.TA1LOCAT[4] = "IO1300"; /* location*/
      TA1REC.TA1DBASE = "DCLAIM"; /* database name*/
      TA1REC.TA1TBLVU = "VCLGLX01"; /* table view name*/
      CL0KW01.CL0KWNUM = CLAREC.CLACLMNB;
      TA1REC.TA1TBLKE = CL0KW01.CL0KWNUM; /* table key*/
      XPCL010(); /* problems with the call--abort*/
    end
  else
    if (SQLCA.VAGen_SQLCODE == 100) /* if no record found,*/
      converseLib.validationFailed(9);
    else
      if (SQLCA.VAGen_SQLCODE == -911)
        converseLib.validationFailed(4); /* -911 database busy, try to update again*/
        CLXERRF = "Y";
        CLXBLDSC = "Y";
      else /* otherwise*/
        TA1REC.TA1LOCAT[2] = "CL0KS2D"; /* location*/
        TA1REC.TA1LOCAT[4] = "IO1300"; /* location*/
        TA1REC.TA1DBASE = "DCLAIM"; /* database name*/
        TA1REC.TA1TBLVU = "VCLGLX01"; /* table view name*/
        CL0KW01.CL0KWNUM = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CL0KW01.CL0KWNUM; /* table key*/
        XPCL010(); /* problems with the call--abort*/
      end
    end
  end
  ;
  ;
  ;
  ;
  ;
  ;
end // end KL0KS2D

// load 'change' record to clirec
Function KL0KS2E()
   /* ************************************************/
   /* move non-map saved fields from original*/
   /* retrieval back out to clirec.  if an 'add'*/
   /* situation, fills with blanks except for*/
   /* those fields overridden in next step of cl0ks2c*/
   /* **/
   /* *  Maintenance History:*/
   /* **/
   /* *  01-19-90 CHELLM renamed cl0kw02.glcd as glacd*/
   /* *                  renamed xgexref as pfjxref*/
   /* **/
   /* **/
   /* ************************************************/
  CLIREC.PFJXREF = CL0KW02.PFJXREF[CLXARAYX];
  CLIREC.XGPCD = CL0KW02.XGPCD[CLXARAYX];
  CLIREC.SY1STNBR = CL0KW02.SY1STNBR[CLXARAYX];
  CLIREC.SY2CLRID = CL0KW02.SY2CLRID[CLXARAYX];
  CLIREC.XDMCD = CL0KW02.XDMCD[CLXARAYX];
  CLIREC.IV0PARTN = CL0KW02.IV0PARTN[CLXARAYX];
  CLIREC.IV0IVCID = CL0KW02.CL0KWIID[CLXARAYX];
  CLIREC.CLIGLNFL = CL0KW02.CLIGLNFL[CLXARAYX];
  CLIREC.OP2LNINB = CL0KW02.OP2LNINB[CLXARAYX];
  CLIREC.CLIIGOFL = CL0KW02.CLIIGOFL[CLXARAYX];
  CLIREC.CLIGLFIV = CL0KW02.CLIGLFIV[CLXARAYX];
  CLIREC.IV6FBTYP = CL0KW02.IV6FBTYP[CLXARAYX];
  CLIREC.IV6GLSEQ = CL0KW02.IV6GLSEQ[CLXARAYX];
  CLIREC.ZZZCHGDT = CL0KW02.CL0KWZDT[CLXARAYX];
  CLIREC.ZZZCHGTM = CL0KW02.CL0KWZTM[CLXARAYX];
  ;
   /* ************************************************/
   /* these are the map fields used by cl0k*/
   /* ************************************************/
  CLIREC.CLICRDFL = KL0KM001.CLICRDFL[CLXARAYX];
  CLIREC.GLACD = KL0KM001.GLACD[CLXARAYX];
  CLIREC.PFJXREF = CL0KW02.PFJXREF[CLXARAYX];
  CLIREC.CLICALPC = CL0KW02.CL0KWPCT[CLXARAYX];
  CLIREC.XSTCD = CL0KW02.XSTCD[CLXARAYX];
  CLIREC.XSECD = CL0KW02.XSECD[CLXARAYX];
  CLIREC.CLICARMO = CL0KW02.CLICARMO[CLXARAYX];
  CLIREC.CLICARCT = CL0KW02.CL0KWCAR[CLXARAYX];
  CLIREC.CLIADMAT = CL0KW02.CLIADMAT[CLXARAYX];
  CLIREC.YMDCD = CL0KW02.YMDCD[CLXARAYX];
  CLIREC.YAPCD = CL0KW02.YAPCD[CLXARAYX];
  CLIREC.CLIGLAM = CL0KW02.CLIGLAM[CLXARAYX];
  ;
  ;
  ;
  ;
end // end KL0KS2E

// perform update to clarec
Function KL0KS2F()
  ;
  ;
  ;
  if (CL0KW02.CLICRDFL[CLXARAYX] == "D")
    if (CLAREC.YCTCD in YCTTBL.YCTCD
     && YCTTBL.YCTDBOCL[sysVar.arrayIndex] != "Y")
      CL0KW01.CL0KWBOC = "Y";
    else
      /* next sentence*/
    end
  end
  ;
  ;
  KL0K924();
  if (SQLCA.VAGen_SQLCODE == 0)
    /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4);
      CLXREC.CLXERRF = "Y";
      return;
    else
      TA1REC.TA1DBASE = "DCLAIM";
      TA1REC.TA1TBLVU = "VCLHDR01";
      XPCL010(); /* abort*/
    end
  end
  ;
  ;
  CLAREC.CLAESTVL = CL0KW01.CL0KWEST;
  CLAREC.CLADBOCL = CL0KW01.CL0KWBOC;
  KL0K927(); /* update clarec*/
  if (SQLCA.VAGen_SQLCODE == 0)
     /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      converseLib.validationFailed(18);
      CLXERRF = "Y";
      CLXBLDSC = "Y";
      return;
    else
      if (SQLCA.VAGen_SQLCODE == -911)
        converseLib.validationFailed(4);
      else
        TA1REC.TA1DBASE = "DCLAIM";
        TA1REC.TA1TBLVU = "VCLHDR01";
        XPCL010(); /* abort*/
      end
    end
  end
  ;
  ;
  ;
end // end KL0KS2F

// update with 'key' changed
Function KL0KS2G()
   /* ***********************************************************/
   /* *                                                        **/
   /* *        update with 'key' changed                       **/
   /* *                                                        **/
   /* * Maintenance History:                                   **/
   /* *                                                        **/
   /* *  01-19-90 CHELLM renamed cl0kw02.glcd as glacd         **/
   /* *  03-06-90 CHELLM when an error occurs on the screen    **/
   /* *           prevent the overlay of the original gl amt   **/
   /* *           so the est clm value gets updated correctly  **/
   /* *                                                        **/
   /* *                                                        **/
   /* ***********************************************************/
  ;
  set CLIREC empty;
  CLIREC.CLACLMNB = CLAREC.CLACLMNB;
  CLIREC.CLHSEQNB = CLAREC.CLACSQNB;
  CLIREC.CLICRDFL = CL0KW02.CLICRDFL[CLXARAYX];
  CLIREC.GLACD = CL0KW02.GLACD[CLXARAYX];
  CLIREC.CLIADVSQ = CL0KW02.CLIADVSQ[CLXARAYX];
  CLIREC.ZZZCHGCT = CL0KW02.CL0KWZCT[CLXARAYX];
  ;
  ;
  CLIREC.ZZZCHGDT = CL0KW01.ZZZCHGDT;
  CLIREC.ZZZCHGTM = CL0KW01.ZZZCHGTM;
  ;
  KL0K917(); /* check if record exists & lock it*/
  if (SQLCA.VAGen_SQLCODE == 0) /* record exists*/
    KL0K915(); /* delete the record*/
    if (SQLCA.VAGen_SQLCODE == 0)
      if (CL0KW02.CLICRDFL[CLXARAYX] == "C")
        CL0KW01.CL0KWEST = CL0KW01.CL0KWEST + CL0KW02.CLIGLAM[CLXARAYX];
        KL0KS2F();
      else
        CL0KW01.CL0KWEST = CL0KW01.CL0KWEST - CL0KW02.CLIGLAM[CLXARAYX];
        KL0KS2F();
      end
    end
    ;
  else
    if (SQLCA.VAGen_SQLCODE == 100) /* if no record found,*/
      converseLib.validationFailed(9);
      CLXREC.CLXBLDSC = "Y";
      CLXREC.CLXERRF = "Y";
      return;
    end
  end
  ;
  ;
  set CLIREC empty;
  CLIREC.CLACLMNB = CLAREC.CLACLMNB;
  CLIREC.CLHSEQNB = CLAREC.CLACSQNB;
  CLIREC.CLICRDFL = KL0KM001.CLICRDFL[CLXARAYX];
  CLIREC.GLACD = KL0KM001.GLACD[CLXARAYX];
  CLIREC.IV0PARTN = CL0KW02.IV0PARTN[CLXARAYX];
  CLIREC.IV0IVCID = CL0KW02.CL0KWIID[CLXARAYX];
  CLIREC.OP2LNINB = CL0KW02.OP2LNINB[CLXARAYX];
  CLIREC.CLIADVSQ = CL0KW02.CLIADVSQ[CLXARAYX]; /* 03-06-90*/
  CLIREC.ZZZCHGDT = CL0KW01.ZZZCHGDT;
  CLIREC.ZZZCHGTM = CL0KW01.ZZZCHGTM;
  ;
  CL0KW02.CLIGLAM[CLXARAYX] = CL0KW02.CL0KWGLM[CLXARAYX];
  ;
  KL0KS2E(); /* load record for update*/
  ;
  KL0K916();
  if (SQLCA.VAGen_SQLCODE == 0)
    if (KL0KM001.CLICRDFL[CLXARAYX] == "C")
      CL0KW01.CL0KWEST = CL0KW01.CL0KWEST - CL0KW02.CLIGLAM[CLXARAYX];
      KL0KS2F();
    else
      CL0KW01.CL0KWEST = CL0KW01.CL0KWEST + CL0KW02.CLIGLAM[CLXARAYX];
      KL0KS2F();
    end
  end
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
end // end KL0KS2G

// get new seq nbr for new rec
Function KL0KS2H()
  ;
  ;
  ;
  ;
  set CLIREC empty;
  CLIREC.CLACLMNB = CLAREC.CLACLMNB;
  CLIREC.CLHSEQNB = CLAREC.CLACSQNB;
  ;
  KL0K944(); /* get max seq number already on file*/
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    CLIREC.CLIADVSQ = CL0KW04.CL0KWCN1;
    CL0KW02.CLIADVSQ[CLXARAYX] = CLIREC.CLIADVSQ + 1;
    return;
  end
end // end KL0KS2H

// process enter key
Function KL0KS3A()
  ;
  ;
  ;
  if (CLWREC.CLWMNOPT == 1)
    COMMAREA.CATOAP = "KL0E";
    CLXREC.CLXBLDSC = "N";
    CLXREC.CLXEOSF = "Y";
    CLXREC.CLXEOAF = "Y";
    XPCL002();
  else
    if (CLWREC.CLWMNOPT == 4)
      COMMAREA.CATOAP = "KL0E";
      CLXREC.CLXBLDSC = "N";
      CLXREC.CLXEOSF = "Y";
      CLXREC.CLXEOAF = "Y";
      XPCL002();
    else
      if (CLWREC.CLWMNOPT == 5)
        COMMAREA.CATOAP = "KL0E";
        CLXREC.CLXBLDSC = "N";
        CLXREC.CLXEOSF = "Y";
        CLXREC.CLXEOAF = "Y";
        XPCL002();
      else
        if (COMMAREA.CAFRMSYS == "KL")
          COMMAREA.CATOAP = COMMAREA.CAFROMAP;
        else
          COMMAREA.CATOAP = "KL0E";
          XPCL002();
        end
      end
    end
  end
  ;
  ;
  ;
end // end KL0KS3A

// pf 18 action claim comment
Function KL0KS8A()
   /* ************************************************************/
   /* *      handle the entry of pfkey 18                       **/
   /* *        claim comment                                    **/
   /* * add 1-4-88                                              **/
   /* ************************************************************/
  ;
  CLXREC.CLXEDITF = "N"; /* we don't want to do edits*/
  CLXREC.CLXEOSF = "Y"; /* we are done with this screen*/
  CLXREC.CLXEOAF = "Y"; /* we are done with this application*/
  ;
  CLWREC.CLWMCMNT = "N";
  ;
  COMMAREA.CATOAP = "KL0G"; /* claim comment screen*/
  XPCL002();
  ;
  ;
end // end KL0KS8A

//*** RECORD=CL0KW01 ****
// ******************  cl0k working storage *******************
// 
// this record is used to hold clirec, which is updated
// updated to the database,and misc application-only
// work items.
// 
// clirec
// -------------------------------------
// DB2 Table:           DCLAIM.VCLGLX01
// Copylib Member:      DCL00216
// I/O Mod:             IO1300
// Key to DB2 Table:    claclmnb
//                      clhseqnb
//                      clicrdfl
//                      glcd
// 
// 
// ***********************
Record CL0KW01 type basicRecord
  5 CL0KW1GP CL0KW1GP ; 
    10 CL0KWSIA CL0KWSIA ; 
    10 ZZZCHGDT ZZZCHGDT ; 
    10 ZZZCHGTM ZZZCHGTM ; 
    10 YCTABRV YCTABRV ; 
    10 YCSSDESC YCSSDESC ; 
    10 CL0KWTDT CL0KWTDT ; 
    10 KUCCONM KUCCONM ; 
    10 CL0KWMEM CL0KWMEM ; 
    10 CL0KWEST CL0KWEST ; 
    10 CL0KWBOC CL0KWBOC ; 
    10 CL0KWACT CL0KWACT ; 
    10 CL0KWLF CL0KWLF ; 
    10 CL0KWGLT CL0KWGLT ; 
    10 CL0KWNUM CL0KWNUM ; 
end // end CL0KW01

//*** RECORD=CL0KW02 ****
// ******************  cl0k working storage *******************
// 
// this record is used to hold clirec, which is updated
// updated to the database,and misc application-only
// work items.
// 
// clirec
// -------------------------------------
// DB2 Table:           DCLAIM.VCLGLX01
// Copylib Member:      DCL00216
// I/O Mod:             IO1300
// Key to DB2 Table:    claclmnb
//                      clhseqnb
//                      clicrdfl
//                      glcd
// 
// 
// ***********************
Record CL0KW02 type basicRecord
  5 CL0KW2GP CL0KW2GP ; 
    10 CLICRDFL CLICRDFL [12] ; 
    10 GLACD GLACD [12] ; 
    10 GLADESC GLADESC [12] ; 
    10 PFJXREF PFJXREF [12] ; 
    10 XGPCD XGPCD [12] ; 
    10 SY1STNBR SY1STNBR [12] ; 
    10 SY2CLRID SY2CLRID [12] ; 
    10 XDMCD XDMCD [12] ; 
    10 IV0PARTN IV0PARTN [12] ; 
    10 CL0KWIID CL0KWIID [12] ; 
    10 CLIGLAM CLIGLAM [12] ; 
    10 CL0KWGLW CL0KWGLW [12] ; 
    10 CL0KWGLM CL0KWGLM [12] ; 
    10 CLIGLPC CLIGLPC [12] ; 
    10 CLIGLNFL CLIGLNFL [12] ; 
    10 YMDCD YMDCD [12] ; 
    10 CLICARCT CLICARCT [12] ; 
    10 CLIADMAT CLIADMAT [12] ; 
    10 YAPCD YAPCD [12] ; 
    10 CL0KWCAR CL0KWCAR [12] ; 
    10 CLICARMO CLICARMO [12] ; 
    10 XSECD XSECD [12] ; 
    10 XSTCD XSTCD [12] ; 
    10 CL0KWPCT CL0KWPCT [12] ; 
    10 OP2LNINB OP2LNINB [12] ; 
    10 CLIIGOFL CLIIGOFL [12] ; 
    10 CLIGLFIV CLIGLFIV [12] ; 
    10 IV6FBTYP IV6FBTYP [12] ; 
    10 IV6GLSEQ IV6GLSEQ [12] ; 
    10 CL0KWZDT CL0KWZDT [12] ; 
    10 CL0KWZTM CL0KWZTM [12] ; 
    10 CL0KWZCT CL0KWZCT [12] ; 
    10 CLIADVSQ CLIADVSQ [12] ; 
    10 CL0KWNEF CL0KWNEF [12] ; 
    10 CL0KWMOD CL0KWMOD [12] ; 
    10 CL0KWD1 CL0KWD1 [12] ; 
      15 CL0KWD2 CL0KWD2 ; 
      15 CL0KWD3 CL0KWD3 ; 
end // end CL0KW02

//*** RECORD=CL0KW04 ****
// pass maximum sequence number by claim from dclaim.vclglx01.
// pass io-count from dclaim.vclglx01
// pass io-summ from dclaim.vclglx01
// pass io-ind from dclaim.vclglx01
// ***********************
Record CL0KW04 type basicRecord
  5 CL0KW4GR CL0KW4GR ; 
    10 CL0KWSQL CL0KWSQL ; 
    10 CL0KWCN1 CL0KWCN1 ; 
end // end CL0KW04

// cl0kw01 record group level
DataItem CL0KW1GP char(93)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// cl0kw02 record group level
DataItem CL0KW2GP char(1500)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// record group level
DataItem CL0KW4GR char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// clarec zzzchgdt
DataItem CL0KWACT smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// cladbocl cl-dbt-on-clm-fl
DataItem CL0KWBOC char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// cl-coop-ad-run-nnt
DataItem CL0KWCAR smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// io max
DataItem CL0KWCN1 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// breakdown for dar
DataItem CL0KWD1 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// xsncd
DataItem CL0KWD2 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// clicarmo
DataItem CL0KWD3 num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// clarec claestvl
DataItem CL0KWEST decimal(11,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// map-changed gl amt
DataItem CL0KWGLM decimal(11,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// accumulates gl amts
DataItem CL0KWGLT num(10,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// original gl amt
DataItem CL0KWGLW decimal(11,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// iv-ivc-id
DataItem CL0KWIID int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// loop flag
DataItem CL0KWLF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// cl-memo-nbr
DataItem CL0KWMEM int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = nullFill, inputRequired = no
}
end

// tag for update flag
DataItem CL0KWMOD char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// new-entry flag
DataItem CL0KWNEF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// convert binary to numeric
DataItem CL0KWNUM num(10)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// cl-coop-ad-alw-pct
DataItem CL0KWPCT smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// stay in application flag
DataItem CL0KWSIA char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// sql selection
DataItem CL0KWSQL char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// cl-clm-stat-dt
DataItem CL0KWTDT int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// change count
DataItem CL0KWZCT num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// change date
DataItem CL0KWZDT num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// change time
DataItem CL0KWZTM num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

