package kl0l;

import corpcom1.*;
import corpcom2.XQWREC;
import corpcom3.XPCL002;
import corpcom3.XPCL010;
import corpcom3.XPCL011;
import corpcom4.XSENTRY;
import corpcom4.XSSEGTR;
import corpcom5.COMMAREA;
import corpcom5.ERRSQLCA;
import corpcom6.SQLCA;
import corpx1.XATCD;
import corpx1.XAUTBL;
import corpx1.XBK-BK-SESN-CD;
import corpx1.XCOCD;
import corpx1.XDMCD;
import corpx1.XGPCD;
import corpx1.XGPTBL;
import corpx1.XOBTBL;
import corpx1.XOCTBL;
import corpx1.XOTTBL;
import corpx1.XQATBL;
import corpx1.XUMTBL;
import corpx2.XPYCD;
import corpx2.XQACD;
import corpx2.XUMCD;
import corpy2.YATTBL;
import corpy2.YCRTBL;
import corpy2.YCSTBL;
import corpy2.YDSTBL;
import corpy2.YITCD;
import corpy2.YUATBL;
import corpz3.ZZZCHGCT;
import iv.common.IV0IVCID;
import iv.common.IV0PARTN;
import iv.common.IV3GLNUP;
import iv.common.IV3LNSQ;
import iv.common.IV3REC;
import iv.common.IV4GUP;
import iv.common.IV4REC;
import iv.common.IV4SHPQ;
import iv.common.IVANBLFL;
import iv.common.IVAREC;
import iv.common.IVEREC;
import ku.common.KUCREC;
import ku.common.KUIPRDID;
import op.common.OP-BK-MO;
import op.common.OP-BK-YR;
import op.common.OP2LNINB;
import op.common.OP2PRCVF;
import sp.common.SP5REC;
import sp.common.SP5SZPR;
import sy.common.SY1STNBR;
import sy.common.SY2CLRID;
import sy.common.SY4IDDSC;
import sy.common.SY4REC;
import sy.common.SY4SZSCL;
import sy.common.SY5REC;
import sy.common.SY5SZID;
import sy.common.SY6REC;
import sy.common.SYCREC;
import ta.common.TA1REC;
import ta.common.TA2REC;
import vv.common.VCUCPX01;
import ww.common.WCU1710;
//*** PROGRAM=KL0L ****
// ************************************************************
// claims product adjustment screens -
//                  product summary list
//                  product descriptions list
//                  product detail, sizes
// 
// overview: pick up all products from all invoices associated
//           with the claim number.  show the user all the
//           products.  the user may credit/debit a product
//           either at the product level or the detail size
//           level.  only those products credited/debited are
//           attached to the claim.
// 
//           the user may enter products to debit or credit
//           on the claim.
// 
//           inquiry or change mode shows all the products
//           attached to the claim.
// 
// statement groups are named:
//   cl0lsi# initialization
//   cl0lss# related to map 1 or map 5 summary screens
//   cl0lsd# related to map 10 detail screen
//   cl0lsp# related to product array
//   cl0lse# map edits
// 
// a product may be worked at the product level:
//     data has clicrdfl ne ' '
//          and sy5szid eq 0
//   or the size level:
//     data has clicrdfl ne ' '
//          and sy5szid ne 0
//     do not show cr/db on the product summary map.
// 
// data base error -911 is data base deadlock.  it closes the
// cursor and rollsback all i/o since the last converse or
// call commit.  this application checks for -911 only on
// inquiry, update and replace - for individual records.
// when this error occurs on a select set,  we lose our place.
// so we abend the application.  the action on a -911 may
//    loop 4 times, waiting 1 second each time (cl0ls1s)
// or give ezemno # 4 - data base deadlock, re-try action.
// 
// 
// 
// maintenance history:
// date      by     rev description of change
// --------  ---    --  --------------------------------------
// 04-10-87  lhughe  0  create model for claims appl
// 04-28-87  bcourt  0  convert to cl0l
// 06-03-88  ctrouw  0  change to store gross and net price
// 06-06-88  mhalst  0  Convert to IOmods
// 08-02-88  ctrouw  0  database changes
// 08-16-88  ctrouw  0  fixed bug with 'CA' and changin qty
// 09-23-88  ctrouw  0  price override
// 11-02-88  ctrouw  0  fix cl0lsao not to add duplicates
// 01-06-88  ctrouw  0  fixed seq nbr in cl0lsp6
// 02-01-89  jwood   0  added noncsp option to calls
// 02-01-89  jwood   0  added xssegtr logic
// 03-23-89  bcourt  0  drop IV0REC from table list.
// 04-26-89  gdecke  0  switch from xot to xob - sport/casual
// 05-16-89  gdecke  0  DB2 structure changes: clarec, kucrec,
//                      sycrec.
// 09-22-89  bcourt  0  remove 5-16 ref to unused tables: X CT,
//                      X WH; & recs: CL I, SY 2.
// 01-19-90  bcourt  0  DB2 structure changes: clhrec, kucrec,
//                      ivarec.  regen only
// 04-06-90  chellm     DB2 structure changes BRAND,IVOVR, etc.
// 04-10-90  chellm     Add xum&xqa to price override table
//                      product key when creating, updating,
//                      & selecting Invoice Price Overrides
//                      (CL6REC).
// 05-31-90  chellm     Add edit for claim-product brand code
//                      mis-match.
// 08-03-90  gdecke     change maximum number of products in
//                      cl0lw02 table to 500.
// 01-09-91  gdecke #CL920,CL974. COLOR/DIMENSION CHANGES.
// 02-15-91  CHELLM     Feb DB2 changes. Changed SY5PRCFL of
//                      SY5REC to XQACD.
// 06-14-91  sgorga     DB2 changes. Replaced KU2REC with
//                      KUIREC.  Chgd processes CL0L302, S40.
// 08-08-91  wjohns     Renamed application and commarea
//                        referrences to renamed claims appls.
// 09-18-91  ahowar     changed proc and sgrp from "cl" to "kl"
// 01-13-92  sgorga     Set ta1rec, ta2rec empty.  kl0lsup,001.
//                      Set KL0LM001, 005, 010 clear in -001.
// 03-13-92  sgorga     Added fields xbk-bk-sesn-cd & op-bk-yr
//                      to be moved from iv3rec to cl0lw02 rec
//                      to clrrec.  kl0lsp4, kl0lsad, cl0lw02.
// 04-13-92  twatso     added field op-bk-mo where yr was befor
// 06-03-93  jcarey     added code to allow side1 brands on
//                      nike claims. side1 converted to nike
//                      as of 6/1/93. see kl0lsbc
// 03-11-94 BCOURT  rename SY6REC.SY6CSTFL to XQACD in KL0LS72.
//             Default values for country & currency.
// 11-06-97 RCHAUV  CHANGES FOR CLAIM REASON CODE CONVERSION
// 09-23-98 NJANA   Change the product array size to 900 in
//                  KL0L102.The same change is maintained
//                  in  the record CL0LW02.
// ************************************************************
// *********************
Program KL0L type textUIProgram //VAGen Info - main text program
  {
  includeReferencedFunctions = yes, allowUnqualifiedItemReferences = yes, 
  throwNrfEofExceptions = yes, handleHardIOErrors = no, V60ExceptionCompatibility = yes, 
  I4GLItemsNullable = no, textLiteralDefaultIsString = no, localSQLScope = yes, 
  msgTablePrefix = "CL00", inputRecord = COMMAREA, segmented = yes
  }

  // Data Declarations
  CL0LW01 CL0LW01; // record
  CL0LW02 CL0LW02; // record
  CL0LW03 CL0LW03; // record
  CL0LW04 CL0LW04; // record
  CL6REC CL6REC; // record
  CLAREC CLAREC; // record
  CLBREC CLBREC; // record
  CLHREC CLHREC; // record
  CLRREC CLRREC; // record
  CLWREC CLWREC; // record
  CLXREC CLXREC; // record
  COMMAREA COMMAREA ; // record
  ERRSQLCA ERRSQLCA; // record
  IV3REC IV3REC; // record
  IV4REC IV4REC; // record
  IVAREC IVAREC; // record
  IVEREC IVEREC; // record
  KUCREC KUCREC; // record
  SP5REC SP5REC; // record
  SQLCA SQLCA; // record
  SY4REC SY4REC; // record
  SY5REC SY5REC; // record
  SY6REC SY6REC; // record
  SYCREC SYCREC; // record
  TA1REC TA1REC; // record
  TA2REC TA2REC; // record
  VCUCPX01 VCUCPX01; // record
  WCU1710 WCU1710; // record
  XQWREC XQWREC; // record

  // VAGen Info - items needed for migration
  VAGen_EZESYS char(8);
  VAGen_EZEREPLY num(1);
  VAGen_EZE_WAIT_TIME bin(9,2);
  VAGen_EZE_ITEMLEN int;

  // Use Declarations
  use XAUTBL {deleteAfterUse = yes}; // table
  use XGPTBL {deleteAfterUse = yes}; // table
  use XOCTBL {deleteAfterUse = yes}; // table
  use XOBTBL {deleteAfterUse = yes}; // table
  use XOTTBL {deleteAfterUse = yes}; // table
  use XQATBL {deleteAfterUse = yes}; // table
  use XUMTBL {deleteAfterUse = yes}; // table
  use YATTBL {deleteAfterUse = yes}; // table
  use YCRTBL {deleteAfterUse = yes}; // table
  use YCSTBL {deleteAfterUse = yes}; // table
  use YDSTBL {deleteAfterUse = yes}; // table
  use YUATBL {deleteAfterUse = yes}; // table
  use KL0LM.KL0LM001,  // forms
      KL0LM.KL0LM005, 
      KL0LM.KL0LM010
   {
    pfKeyEquate = no
  };

  function main()
    // VAGen Info - initialization needed for migration
    VAGen_EZESYS = VGLib.getVAGSysType();
    KL0L000: KL0L000();


    exit program;



    KL0L001: KL0L001();
    KL0L050: KL0L050();
    KL0L100: KL0L100();
    KL0L102: KL0L102();
    KL0L104: KL0L104();
    KL0L110: KL0L110();
    KL0L120: KL0L120();
    KL0L130: KL0L130();
    KL0L140: KL0L140();
    KL0L200: KL0L200();
    KL0L204: KL0L204();
    KL0L210: KL0L210();
    KL0L220: KL0L220();
    KL0L300: KL0L300();
    KL0L302: KL0L302();
    KL0L304: KL0L304();
    KL0L310: KL0L310();
    KL0L320: KL0L320();
    KL0L330: KL0L330();
    KL0L340: KL0L340();
  end // end main
end // end KL0L

// application main logic
Function KL0L000()
   /* ************************************************************/
   /* *   this is the "main logic" for the application.         **/
   /* *                                                         **/
   /* *   perform initialization, set application revision nbrs,**/
   /* *   then do main perform until done with application      **/
   /* *                                                         **/
   /* ************************************************************/


  KL0L001(); /* initilize the application*/

  KL0LM001.XXXRVNBR = 0; /* appl maintainence revision number*/
  KL0LM005.XXXRVNBR = 0; /* appl maintainence revision number*/
  KL0LM010.XXXRVNBR = 0; /* appl maintainence revision number*/


  CLXREC.CLXEOAF = "N"; /* set end-of-application flag to 'no'*/

  while (CLXREC.CLXEOAF == "N") /* while not end-of-aplication*/
    KL0L050(); /* process the application screen(s)*/
  end

  KL0LSAU();


  COMMAREA.CATOAP = "KL0A"; /* return here = bad transfer*/
  XPCL002(); /* try again*/



end // end KL0L000

// initialize w-s, set values
Function KL0L001()
   /* ************************************************************/
   /* *      initialize the application working storage         **/
   /* *                                                         **/
   /* *  clear records, working-storage, initialize values      **/
   /* ************************************************************/
   /* MAINTENANCE HISTORY                    **/
   /* 01-13-92  sgorga  Set ta1rec, ta2rec empty.  Also, setting**/
   /* maps KL0LM001, M005, & M010 to clear.   **/
   /* ************************************************************/


  converseVar.commitOnConverse = 1; /* force db2 to commit on each screen converse*/
  VGVar.handleHardIOErrors = 1; /* return control to program if hard db2 error*/
  set KL0LM001 initial; /* clear screen*/
  set KL0LM005 initial; /* clear screen*/
  set KL0LM010 initial; /* clear screen*/

   /* TEMP001                       ;*** temp routine for testing*/

  XSENTRY(); /* check entered thru main menu*/
  XSSEGTR(); /* set segmented transaction id*/
  XPCL011(); /* claims entry module*/


  set TA1REC empty;
  set TA2REC empty;
  set CLXREC empty; /* clear out the "common" working*/
                                   /* storage*/
  set CL0LW01 empty;

  if (CLAREC.CLACSQNB > 1)
    CL0LW01.CLACSQNB = CLAREC.CLACSQNB - 1;
  else
    CL0LW01.CLACSQNB = 1;
  end

   /* SET CL0LW02 EMPTY; done for each claim/invoice in cl0l102*/
   /* MOVE 200 TO CL0LW02.CL0LWASZ;200 is prod array occurences*/

   /* SET CL0LW03 EMPTY; done for each product in cl0l302*/
   /* MOVE 40 TO CL0LW03.CL0LWASZ ;40 is detl sizes array length*/


     /* *************************/
     /* initialize flags and w-s*/
     /* *************************/

  CL0LW01.CL0LWIEF = "N"; /* invoice/claim xref end of file*/
  CL0LW01.CL0LW1PR = "Y"; /* first time to put products in array*/
  CL0LW01.CL0LWAUP = "N"; /* clarec does not need updating*/
  CL0LW01.CLADBOCL = CLAREC.CLADBOCL; /* hold debit-on-clm flag*/
  CL0LW01.CLADJIND = CLAREC.CLADJIND; /* hold adjustment-on-clm flag*/
  CL0LW01.CL0LWLST = 0; /* last invc processed*/


  TA2REC.TA2RTNCD = 0; /* get curr date/time*/
  TA2REC.TA2DTOPT = "GETDATE";

  call "TA0040" (TA2REC) {isNoRefresh = yes, isExternal = yes};

  if (TA2REC.TA2RTNCD == 0)
    CL0LW01.CL0LWPED = TA2REC.TA2GRGGN; /* price effective date*/
  else
    CL0LW01.CL0LWPED = 0;
  end


     /* *********************************/
     /* set up w-s array of screen names*/
     /* *********************************/

  CLXREC.CLXCSCRN = "KL0LM001"; /* first screen of application*/

  CLXREC.CLXBLDAY = "Y"; /* build array for first map*/

  CLXREC.CLXSNAME[1] = "KL0LM001"; /* initialize the names of the*/
  CLXREC.CLXSNAME[2] = "KL0LM005"; /* screens used in this appl*/
  CLXREC.CLXSNAME[3] = "KL0LM010";

  CLXREC.CLXMAXLN[1] = 11; /* max lines on map 1*/

  CLXREC.CLXMAXLN[2] = 11; /* max lines on map 2*/

  CLXREC.CLXMAXLN[3] = 11; /* max lines on map 3*/

  KL0LM001.XXXPRCNM = "KL0L100"; /* process name that shows map*/
  KL0LM005.XXXPRCNM = "KL0L200";
  KL0LM010.XXXPRCNM = "KL0L300";


     /* ***********************************/
     /* put current date in various places*/
     /* ***********************************/

  KL0LM001.XXXCURDT = VGVar.currentShortGregorianDate; /* date onto 3 maps*/
  KL0LM005.XXXCURDT = VGVar.currentShortGregorianDate;
  KL0LM010.XXXCURDT = VGVar.currentShortGregorianDate;

  CLXREC.XXXCYMD = VGVar.currentShortGregorianDate; /* yymmdd current date*/
  if (CLXREC.XXXCYY > 56) /* set century based on year*/
    CLXREC.XXXCCC = 19;
  else
    CLXREC.XXXCCC = 20;
  end


     /* **************************/
     /* move data to map headings*/
     /* **************************/

  KL0LSI1(); /* put claim heading info onto 3 maps*/
           /* ; except invoice number*/


     /* ***************************/
     /* find indexes for later use*/
     /* ***************************/


  if (CLAREC.YCRCD != " ")
    if (CLAREC.YCRCD in YCRTBL.YCRCD) /* claim reason*/
      CLXREC.CLXYCRX = sysVar.arrayIndex;
    else
      TA1REC.TA1TBLKE = "CLAIM REASON NOT IN YCRTBL";
      XPCL010(); /* abort cl0l*/
    end
  else
    CLXREC.CLXYCRX = 0; /* default to 0*/
  end


  if (CLAREC.YCSCD1 in YCSTBL.YCSCD) /* claim status*/
    CLXREC.CLXYCSX = sysVar.arrayIndex;
  else
    TA1REC.TA1LOCAT[1] = "CL0L001";
    TA1REC.TA1LOCAT[3] = CLAREC.YCSCD1;
    CLXREC.XXXWDTE = CLAREC.CLACLMNB;
    TA1LOCAT[4] = CLXREC.XXXWDTE;
    TA1REC.TA1TBLKE = "INVALID CLAIM STATUS - KEY IN LOCATION";
    XPCL010(); /* abort cl0l*/
  end


     /* note - cl0e, claim header, verifies that an invoice*/
     /* was entered for claim type 'adj'.  order type is*/
     /* required for an invoice.  so should always be in*/
     /* the table.*/
  if (CLAREC.XOBCD in XOBTBL.XOBCD) /* order type table*/
    CL0LW01.CL0LWXOT = sysVar.arrayIndex;
  else
    CL0LW01.CL0LWXOT = 0;
  end



     /* ***********************************************/
     /* determine if map is inquiry or add/change mode*/
     /* ***********************************************/

  KL0LSI2(); /* determine if force to inquiry mode*/

  if (CL0LW01.CL0LWINQ == "Y") /* if inquiry mode*/
    KL0LSS2(); /* protect map 1 input fields*/
    KL0LSD2(); /* protect map 10 input fields*/
  end


     /* **************************************************/
     /* read customer company vcmpny01,*/
     /* to get cu-cusku-ind.  this tells us there*/
     /* may be customer product id's for the nike prod id*/
     /* **************************************************/

  KUCREC.KUCCOID = CLAREC.KUCCOID;

  call "IO0240" ("S ", SQLCA, KUCREC) {isNoRefresh = yes, isExternal = yes}; /* read company record*/

  if (SQLCA.VAGen_SQLCODE == 0)
     /* next sentence               ; have company*/
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      KUCREC.KUCSKIND = " "; /* no company = no sku*/
      KUCREC.XAUCD = " "; /* no company = no acct class*/
    else
      TA1REC.TA1DBASE = "DCUST";
      TA1REC.TA1TBLVU = "VCMPNY01";
      XPCL010(); /* abend*/
    end
  end


     /* ****************************************************/
     /* find company account type code, for product pricing*/
     /* ****************************************************/

  CL0LW01.XATCD = " ";
  if (KUCREC.XAUCD in XAUTBL.XAUCD)
    CL0LW01.XATCD = XAUTBL.XATCD[sysVar.arrayIndex];
  end

     /* ********************************************************/
     /* read invoice speciality table to get:*/
       /* price/cost indicator - use product price or cost?*/
       /* price/cost type - either xpycd or xcocd*/
       /* price/cost pct - signed percent field to add to 100%*/
                        /* to make a multiplier for the std*/
                        /* price/cost value.*/
     /* table record may have blanks in order type or acct class,*/
     /* so the order of reading is:*/
     /* 1. read for acct type, acct class & order type*/
        /* if not found,*/
     /* 2. read for acct type, acct class & blank o/t*/
        /* if not found,*/
     /* 3. read for acct type, blank acct class & blank o/t*/
        /* if not found,*/
          /* zero price/cost indicator, so clngrprc is 0.*/
     /* ********************************************************/

     /* data from the company*/

  IVEREC.XATCD = CL0LW01.XATCD; /* account type*/
  IVEREC.XAUCD = KUCREC.XAUCD; /* account class*/
  IVEREC.XOTCD = CLAREC.XOTCD; /* order type*/

  call "IO1450" ("S ", SQLCA, IVEREC) {isNoRefresh = yes, isExternal = yes}; /* select unique*/

  if (SQLCA.VAGen_SQLCODE == 0)
     /* next sentence, matched all 3 codes*/
  else
    IVEREC.XOTCD = " ";
    call "IO1450" ("S ", SQLCA, IVEREC) {isNoRefresh = yes, isExternal = yes}; /* select unique*/
    if (SQLCA.VAGen_SQLCODE == 0)
       /* next sentence, matched 2 codes*/
    else
      IVEREC.XAUCD = " ";
      call "IO1450" ("S ", SQLCA, IVEREC) {isNoRefresh = yes, isExternal = yes}; /* select unique*/
      if (SQLCA.VAGen_SQLCODE == 0)
         /* next sentence, matched 1 code*/
      else
        IVEREC.IVEPCIND = " "; /* no match at all*/
        IVEREC.IVEPCTYP = " ";
        IVEREC.IVEPCPCT = 0;
      end
    end
  end


     /* *******************/
     /* release data bases*/
     /* *******************/

  VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
  VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
  sysLib.commit();
  VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value



end // end KL0L001

// decide which map to show
Function KL0L050()
   /* ************************************************************/
   /* *   control process the application screen(s)             **/
   /* *                                                         **/
   /* *  note that this process is being performed in a         **/
   /* *  "while loop" until the end-of-application flag is set  **/
   /* *  to 'y'.                                                **/
   /* *                                                         **/
   /* ************************************************************/

  CLXREC.CLXCPROC = "CL0L050"; /* set current process name*/


  sysVar.arrayIndex = 0;

  if (CLXREC.CLXCSCRN in CLXREC.CLXSNAME) /* if current-screen-name is*/
    CLXREC.CLXSCRNX = sysVar.arrayIndex; /* in the screen-array, then set*/
  end /* the screen-index*/


  CLXREC.CLXEOSF = "N"; /* set end-of-screen flag to 'no'*/
  CLXREC.CLXBLDSC = "Y"; /* set build screen flag to 'yes'*/

   /* note - clxblday flag set in cl0l140 or cl0l340-pfkey action*/


  if (CLXREC.CLXSCRNX == 1) /* if screen cl0lm001*/
    while (CLXREC.CLXEOSF == "N") /* show map 1 until user*/
      KL0L100(); /* done with it*/
    end
  else
    if (CLXREC.CLXSCRNX == 2) /* if screen cl0lm005*/
      while (CLXREC.CLXEOSF == "N") /* show map 5 until user*/
        KL0L200(); /* is done with it*/
      end
    else
      if (CLXREC.CLXSCRNX == 3) /* if screen cl0lm010*/
        while (CLXREC.CLXEOSF == "N") /* show map 10 until user*/
          KL0L300(); /* is done with it*/
        end
      else
        TA1REC.TA1TBLKE = "CLAIMS UNKNOWN SCREEN NAME";
        XPCL010();
      end
    end
  end


   /* at this point;*/
       /* if the end-of-application flag (clxeoaf ) = 'n'*/
         /* the perform will return to the top of cl0l050...*/
       /* else*/
         /* the perform will auto return to cl0l000.*/



end // end KL0L050

// map 1 product summary
Function KL0L100()
   /* ************************************************************/
   /* *    process screen cl0lm001                              **/
   /* *                                                         **/
   /* *  note - this process is being performed in a            **/
   /* *     "while loop" from cl0l050 until the end-of-screen   **/
   /* *     flag (clxeosfl) is set to 'y'.                      **/
   /* *                                                         **/
   /* ************************************************************/

  CLXREC.CLXCPROC = "CL0L100"; /* set current process name*/
  KL0LM001.XXXPRCNM = "KL0L100"; /* set current process name*/
  if (converseVar.validationMsgNum == 4
   || converseVar.validationMsgNum == 18)
    CL0LW01.CL0LWVCH = 0;
    CL0LW01.CL0LWQCH = 0;
    CLXREC.CLXBLDAY = "Y";
    CLXREC.CLXBLDSC = "Y";
    CL0LW01.CL0LW1PR = "Y";
  end


  if (CLXREC.CLXBLDAY == "Y") /* build w-s array of products for ivc*/
    set KL0LM001.CL0LMSEL[1] cursor, initialAttributes;
    KL0L102();
    CLXREC.CLXBLDAY = "N"; /* skip build array next time thru*/

    if (CLXREC.CLXBLDSC == "Y")
      KL0L104(); /* build screen*/
      CLXREC.CLXBLDSC = "N"; /* skip build screen next time thru*/
    end
  else
    if (CLXREC.CLXERRF == "Y") /* skip build screen if have errors*/
       /* next sentence*/
    else
      if (converseVar.validationMsgNum == 0 /* build if no warnings*/
       || converseVar.validationMsgNum == 412
       || converseVar.validationMsgNum == 413
       || converseVar.eventKey is pf6       /* or from pf6*/
       || converseVar.eventKey is pf7       /* or from pf7*/
       || converseVar.eventKey is pf8       /* or from pf8*/
       || converseVar.eventKey is pf9)      /* or from pf9*/
        set KL0LM001.CL0LMSEL[1] cursor, initialAttributes;
        if (CLXREC.CLXBLDSC == "Y")
           /* build screen for new invc, pf7/8, or pf12 same map*/
          KL0L104();
          CLXREC.CLXBLDSC = "N"; /* skip build screen next time thru*/
        end
      end
    end
  end



  converse KL0LM001 ;


      /* ********************************************************/
      /* may have warning message in ezemno, with clxerrf = 'n'.*/
      /* clxerrf = 'y' only when field set modified.*/
      /* ********************************************************/

  if (CLXREC.CLXERRF == "Y")
    /* next sentence*/
  else
    sysVar.arrayIndex = 1;
    while (sysVar.arrayIndex < 12)
      CL0LW01.CL0LWMOD[sysVar.arrayIndex] = "N";
      sysVar.arrayIndex = sysVar.arrayIndex + 1;
    end
  end

  CLXREC.CLXMSG = " "; /* set non-ezemno error message to*/
                                   /* spaces*/
  CLXREC.CLXERRF = "N"; /* re-set error flag*/
  converseLib.validationFailed(0);

  if (KL0LM001 is modified) /* if there were entries*/
    CLXREC.CLXEDITF = "Y"; /* then set do-edits-fl = 'yes'*/
  else
    CLXREC.CLXEDITF = "N"; /* if no entries, then no edits*/
    CLXREC.CLXLINEX = 1;
    while (CLXREC.CLXLINEX < 12)
      CL0LW01.CL0LWWRN[CLXLINEX] = "N";
      CLXREC.CLXLINEX = CLXREC.CLXLINEX + 1;
    end
  end



  KL0L110(); /* edit pf keys*/


  if (CLXREC.CLXEOSF == "Y") /* if end of screen*/
    return; /* exit the perform*/
  end



  if (CLXREC.CLXEDITF == "Y") /* if we still want to edit*/
    KL0L120(); /* go edit screen entries*/
  end


      /* determine next action*/

  if (CLXREC.CLXERRF == "Y") /* if screen has errors*/
     /* next sentence               ;   don't update*/
  else
    if (converseVar.validationMsgNum != 0
     && converseVar.validationMsgNum != 412
     && converseVar.validationMsgNum != 413)
      /* next sentence*/
    else
      if (converseVar.eventKey is pf12) /* or user wants to see same screen*/
         /* next sentence*/
      else
        if (CL0LW01.CL0LWUPD == "Y"
         && CL0LW01.CL0LWINQ != "Y")
          KL0L130(); /* go update data base*/
          if (converseVar.validationMsgNum == 18) /* change count error*/
            return;
          end
          CL0LW01.CL0LWUPD = "N";
        end
        KL0L140(); /* act upon pf key*/
      end
    end
  end

  CLXREC.CLXEDITF = "N";


   /* at this point;*/
     /* if the end-of-screen flag (clxeosf) is 'n'*/
       /* the perform returns to top of process cl0l100.*/
     /* else*/
       /* the perform returns to cl0l050.*/



end // end KL0L100

// map 1 & 5 build prod ary 4 ivc
Function KL0L102()
   /* ****************************************************/
   /* *        read all invoices (if any) for the claim,*/
   /* *        read invoice, load array*/
   /* *        read next invoice, set e.o.f. flag*/
   /* **/
   /* *09-23-98 NJana  Change the product array size to 900*/
   /* ****************************************************/

  CLXREC.CLXCPROC = "CL0L102"; /* set current process name*/


     /* ***************************/
     /* clear array, set constants*/
     /* ***************************/

  set CL0LW02 empty;
   /* TCS change begins - 09/23/98*/
  CL0LW02.CL0LWASZ = 900; /* 900 is product array occurences*/

   /* TCS change ends  -  09/23/98*/
  CL0LW01.CL0LWTSH[1] = 0; /* invc total ship qty*/
  CL0LW01.CLRRQTQ[1] = 0; /* invc total cust requested qty*/
  CL0LW01.CLRCLMQ[1] = 0; /* invc total claim qty*/
  CL0LW01.CL0LWTVL[1] = 0; /* invc total claim value*/

  CL0LW01.YITCD = " "; /* invoice type code*/
  CL0LW01.CL0LWALL = "N"; /* all products changed*/

     /* ********************************************/
     /* select set of invoices on claim/invc xref*/
     /* need to do this for each new invoice, since*/
     /* db2 cursor pointer is lost on each converse*/
     /* ********************************************/

  CLBREC.CLACLMNB = CLAREC.CLACLMNB; /* current claim nbr*/
  CLBREC.CLBPMIVC = "*"; /* get all invoices*/

  call "IO1180" ("S3", SQLCA, CLBREC) {isNoRefresh = yes, isExternal = yes}; /* set of invc/claim xref*/

  CLBREC.IV0IVCID = 0; /* prepare for 'while' below*/
  CL0LW01.CL0LWMAT = "N";
   /* cl0lwlst was init in cl0l001 to 0*/
   /* and reset below, in cl0lsb2*/

  if (SQLCA.VAGen_SQLCODE == 0) /* if have invoices on this claim*/
     /* **************************************/
     /* get invoice after last processed invc*/
     /* **************************************/
    while (CL0LW01.CL0LWMAT == "N")

      call "IO1180" ("N3", SQLCA, CLBREC) {isNoRefresh = yes, isExternal = yes}; /* fetch first invoice*/

       /* note - now ezesqcod is for the fetch, not the select set*/
      if (SQLCA.VAGen_SQLCODE == 0) /* if have invoice, back to 'while'*/
        if (CL0LW01.CL0LW1PR == "Y")
          CL0LW01.CL0LWLST = CLBREC.IV0IVCID;
          CL0LW01.CL0LW1PR = "N";
        end
        if (CL0LW01.CL0LWLST == CLBREC.IV0IVCID)
          CL0LW01.CL0LWMAT = "Y";
          CL0LW01.CLBSRIND = CLBREC.CLBSRIND;
          KL0LSB2();
        end
      else
        if (SQLCA.VAGen_SQLCODE == 100) /* if no invc in invc/claim xref*/
           /* *********************/
           /* no invoices on claim*/
           /* *********************/
          call "IO1180" ("C3", SQLCA, CLBREC) {isNoRefresh = yes, isExternal = yes}; /* close set*/
          CL0LW01.CL0LWIEF = "Y"; /* MARK END OF INVOICES*/
          CL0LW01.CL0LWMAT = "Y";
          if (CL0LW01.CL0LW1PR == "Y") /* if first read in invc set*/
            CL0LW01.CL0LW1PR = "N";
             /* *************************************************/
             /* no invoices on claim, use claim products, if any*/
             /* *************************************************/
            KL0LSB1();
          end
        else
           /* *************************************/
           /* bad i/o on fetch for invc/claim xref*/
           /* *************************************/
          TA1REC.TA1DBASE = "DCLAIM";
          TA1REC.TA1TBLVU = "VCLIVX01";
          XPCL010(); /* abend*/
        end
      end
    end
  else
     /* ******************************************/
     /* bad i/o on select set for invc/claim xref*/
     /* ******************************************/
    TA1REC.TA1DBASE = "DCLAIM";
    TA1REC.TA1TBLVU = "VCLIVX01";
    XPCL010(); /* abend*/
  end


  VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
  VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
  sysLib.commit();
  VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
   /* release data bases*/


     /* ************************************************/
     /* set array pointers to i.d. last array entry + 1*/
     /* and to start building screen from array # 1*/
     /* ************************************************/


  CLXREC.CLXLSTAX = CLXREC.CLXARAYX; /* hold last entry +1 in array*/
        /* clxlstax points to first empty slot in the array*/


  CLXREC.CLXARAYX = 1; /* start map at first entry*/



end // end KL0L102

// map 1 move array to map
Function KL0L104()
   /* ************************************************************/
   /* *        this process builds screen cl0lm001*/
   /* *        the data is from the w-s array cl0lw02.*/
   /* *        scrolling affects the indexes in cl0l140*/
   /* **/
   /* ************************************************************/

  CLXREC.CLXCPROC = "CL0L104"; /* set current process name*/


     /* *************/
     /* set pointers*/
     /* *************/

  CLXREC.CLXLINEX = 1; /* start at map line 1*/

    /* note - array index, clxarayx, set in cl0l102, 104 & 140*/
  CLXREC.CLXMAPMX = CLXREC.CLXMAXLN[CLXSCRNX]; /* max lines on map*/
    /* may be changed if w/s array ends before map is filled.*/
    /* see below*/

  CL0LW01.CL0LWDNE = "N"; /* not already done*/

  if (CLXREC.CLXARAYX < 1)
    CLXREC.CLXARAYX = 1;
  end


     /* ************************/
     /* clear orig values array*/
     /* ************************/

  sysVar.arrayIndex = 1; /* clear array of orig values*/
  while (sysVar.arrayIndex <= CLXREC.CLXMAXLN[CLXSCRNX]) /* FOR EACH MAP LINE*/
    CL0LW01.CL0LWORQ[sysVar.arrayIndex] = 0; /* reqst qty*/
    CL0LW01.CL0LWOCQ[sysVar.arrayIndex] = 0; /* clm qty*/
    CL0LW01.CL0LWOVL[sysVar.arrayIndex] = 0; /* clm value*/
    CL0LW01.CL0LWCHK[sysVar.arrayIndex] = "N";
    sysVar.arrayIndex = sysVar.arrayIndex + 1;
  end


     /* ************************************/
     /* move data to map, clear rest of map*/
     /* ************************************/

  while (CLXREC.CLXLINEX <= CLXREC.CLXMAXLN[CLXSCRNX]) /* scrnx = map 1*/
    if (CLXREC.CLXARAYX < CLXREC.CLXLSTAX) /* if not at end of array*/
      if (CL0LW02.SY1STNBR[CLXARAYX] == " ")
        if (CL0LW02.CL0LWDLT[CLXARAYX] == "X")
          KL0LS30();
          KL0LSP7();
          CLXREC.CLXARAYX = CLXREC.CLXARAYX + 1; /* array index*/
          CLXREC.CLXLINEX = CLXREC.CLXLINEX + 1;
        else
           /* ************************************/
           /* at end of array, but not end of map*/
           /* allow user to enter data*/
           /* ************************************/
           /* IF CL0LW01.CL0LWDNE EQ 'N';*/
             /* MOVE 'Y' TO CL0LW01.CL0LWDNE;*/
             /* CLXREC.CLXMAPMX = CLXREC.CLXLINEX - 1;*/
           /* END ;*/
          KL0LSP7(); /* clear map line, unprotect product*/
          CLXREC.CLXLINEX = CLXREC.CLXLINEX + 1;
          CLXREC.CLXARAYX = CLXREC.CLXARAYX + 1;
        end
      else
        KL0LS30();
        CLXREC.CLXARAYX = CLXREC.CLXARAYX + 1;
        CLXREC.CLXLINEX = CLXREC.CLXLINEX + 1;
      end
    else
      if (CL0LW01.CL0LWDNE == "N")
        CL0LW01.CL0LWDNE = "Y";
        CLXREC.CLXMAPMX = CLXREC.CLXLINEX - 1;
      end
      KL0LSP7();
      CLXREC.CLXLINEX = CLXREC.CLXLINEX + 1;
    end
  end


     /* *********************************************************/
     /* move invc totals to the map, may get ship qty in cl0ls30*/
     /* *********************************************************/

  KL0LM001.SY1STNBR[12] = "TOTALS";
  KL0LM001.IV3LNSQ[12] = CL0LW01.CL0LWTSH[1];
  KL0LM001.CLRRQTQ[12] = CL0LW01.CLRRQTQ[1];
  KL0LM001.CLRCLMQ[12] = CL0LW01.CLRCLMQ[1];
  KL0LM001.CLAESTVL[12] = CL0LW01.CL0LWTVL[1];
  set KL0LM001.IV3LNSQ[12] skip;
  set KL0LM001.CLRRQTQ[12] skip;
  set KL0LM001.CLRCLMQ[12] skip;
  set KL0LM001.CLAESTVL[12] skip;


     /* *******************/
     /* release data bases*/
     /* *******************/

  VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
  VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
  sysLib.commit();
  VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value



end // end KL0L104

// map 1 edit pf keys
Function KL0L110()
   /* ************************************************************/
   /* *  validate pf keys                                       **/
   /* *                                                         **/
   /* *  the only keys acted upon at this time are pf 1, 3 & 4  **/
   /* *  and fastpath                                           **/
   /* *                                                         **/
   /* *  the other keys are just verified that they are used    **/
   /* *  by this application.  if the pf key is not recognized, **/
   /* *  the application resets all modified fields to remain   **/
   /* *  modified, then reshows the map with an error message.  **/
   /* *                                                         **/
   /* *  these other pf keys are acted upon after the editing   **/
   /* *  and updating have occured.                             **/
   /* *                                                         **/
   /* ************************************************************/

  CLXREC.CLXCPROC = "CL0L110"; /* set current process name*/


     /* use pa2 to ezeclos, for testing only,*/
   /* BETHS01;*/


      /* *******************************/
      /* check for fastpath option/item*/
      /* *******************************/

      /* same as in cl0l210 & cl0l310*/

  if (KL0LM001.CATOAP == " " /* if fastpath appl is kl0l,*/
   || KL0LM001.CATOAP == "KL0L")
    if (KL0LM001.CAITEM != " ") /* and have item -*/
       /* **********************************/
       /* try to find product in curr array*/
       /* **********************************/
       /* ignore color and dimension*/

      sysVar.arrayIndex = 1;
      CL0LW01.CL0LWPRX = 0; /* init product index*/

      while (sysVar.arrayIndex < CLXREC.CLXLSTAX) /* search w/s array*/
        if (KL0LM001.CAITEM <= CL0LW02.SY1STNBR[sysVar.arrayIndex])
          CL0LW01.CL0LWPRX = sysVar.arrayIndex; /* hold index for use in cl0l140*/
          sysVar.arrayIndex = 9000; /* force loop end*/
        else
          sysVar.arrayIndex = sysVar.arrayIndex + 1;
        end
      end

      if (CL0LW01.CL0LWPRX == 0) /* prod gt any in array*/
         /* clxlstax = next available ' ' entry*/
        CL0LW01.CL0LWPRX = CLXREC.CLXLSTAX - 1; /* force to last array prod*/
      end

      KL0LM001.CAITEM = " "; /* clear map field*/

      return;
    else
       /* *************************************/
       /* next sentence - fastpath not entered*/
       /* *************************************/
    end
  else
     /* *******************************************/
     /* plain, old, ordinary fastpath - just leave*/
     /* *******************************************/
    COMMAREA.CATOAP = KL0LM001.CATOAP; /* jump to next applica*/
    COMMAREA.CAITEM = KL0LM001.CAITEM;
    XPCL002();
    return;
  end



  if (converseVar.eventKey is enter) /* normal 'enter'*/
    return;
  end

  if (converseVar.eventKey is pf1)
    KL0LS01(); /* skip edit/update - exit*/
    return;
  end

  if (converseVar.eventKey is pf3)
    KL0LS03(); /* skip edit, update - exit*/
    return;
  end

  if (converseVar.eventKey is pf4)
    KL0LS04(); /* skip edit, update - exit*/
    return;
  end

  if (converseVar.eventKey is pf5) /* claim header after edit & update*/
    return;
  end

  if (converseVar.eventKey is pf6) /* claim header after edit & update*/
    return;
  end

  if (converseVar.eventKey is pf7) /* page back after edit & update*/
    return;
  end

  if (converseVar.eventKey is pf8) /* page forward after edit & update*/
    return;
  end

  if (converseVar.eventKey is pf9) /* claim header after edit & update*/
    CLXREC.CLXARAYX = CLXREC.CLXLSTAX - 11;
    return;
  end

  if (converseVar.eventKey is pf11) /* scroll right, to map 5*/
    return; /* after edit & update*/
  end

  if (converseVar.eventKey is pf12) /* edit only*/
    return;
  end

  if (converseVar.eventKey is pf13) /* traffic screen after edit & update*/
    return;
  end

  if (converseVar.eventKey is pf14) /* general ledger screen after edit & update*/
    return;
  end


      /* *****************/
      /* pf key not valid*/
      /* *****************/

  converseLib.validationFailed(2); /* pf key not valid*/
  CLXREC.CLXERRF = "Y";

  if (CL0LW01.CL0LWINQ == "N")
                                   /* if in add or change mode, not inquiry*/
    KL0LS26(); /* set fields modfd so user no re-key*/
  end
  CLXREC.CLXEDITF = "N"; /* do not edit map, just re-show it*/



end // end KL0L110

// map 1 edit map data
Function KL0L120()
       /* * * **************************************** * **/
     /* *                                                  **/
   /* *       keep this the same as cl0l220 & cl0l320        **/
     /* *                                                  **/
       /* * * **************************************** * **/

    /* Maintenance history:*/

    /* 05-31-90 CHELLM Add edit for Claim Brand-Product Brand*/
                    /* mis-match CL0LSBC.*/

   /* *******************************************************/
        /* this process handles all edits of screen fields,*/

    /* do individual field edits first,*/
      /* proceed from bottom right to top left*/
    /* do field combination edits, if applicable*/

    /* when error free, use map data to add/change array*/

   /* *******************************************************/

  CLXREC.CLXCPROC = "CL0L120"; /* set current process name*/


     /* *******************************************/
     /* loop from bottom to top, edit data entered*/
     /* *******************************************/


    /* note - there may be 'added' product lines, so*/
           /* last data on map may not be equal to clxarayx,*/
           /* so add in clxlinex to cl0lwinx value.*/

           /* use cl0lwinx as pointer to array - kept in sync*/
           /* with clxlinex as it goes backwards through map*/
           /* pointing to existing array entry,*/
           /* or new array entries.*/

  CL0LW01.CL0LWEXT = 0;
  CLXREC.CLXLINEX = 1;

  while (CLXREC.CLXLINEX <= CLXREC.CLXMAXLN[CLXSCRNX])
    CL0LW01.CL0LWINX = CLXREC.CLXARAYX - 1 - CLXREC.CLXMAPMX;
    CL0LW01.CL0LWINX = CL0LW01.CL0LWINX + CLXREC.CLXLINEX;

    if (CL0LW01.CL0LWINX < 1)
      CL0LW01.CL0LWINX = 1;
    end

    if (KL0LM001.SY1STNBR[CLXLINEX] is modified
     || KL0LM001.SY2CLRID[CLXLINEX] is modified
     || KL0LM001.XDMCD[CLXLINEX] is modified)
      /* next sentence*/
    else
      if (KL0LM001.SY1STNBR[CLXLINEX] == " ")
        CL0LW01.CL0LWEXT = CL0LW01.CL0LWEXT + 1;
      end
    end

    CL0LW01.CL0LWERR[CLXLINEX] = "N";
    CL0LW01.CL0LWSYC = "N";
    set KL0LM001.CL0LMSEL[CLXLINEX] initialAttributes;
    if (CL0LW01.CL0LW1WN[CLXLINEX] == "N")
      set KL0LM001.SY1STNBR[CLXLINEX] initialAttributes;
    end

    if (KL0LM001.XDMCD[CLXLINEX] is modified
     || KL0LM001.SY2CLRID[CLXLINEX] is modified
     || KL0LM001.SY1STNBR[CLXLINEX] is modified)
      CL0LW01.CL0LW1WN[CLXLINEX] = "N";
      if (KL0LM001.SY1STNBR[CLXLINEX] == " ")
        KL0LM001.SY1STNBR[CLXLINEX] = CL0LW02.SY1STNBR[CL0LWINX];
      end
      if (KL0LM001.SY2CLRID[CLXLINEX] == " ")
        KL0LM001.SY2CLRID[CLXLINEX] = CL0LW02.SY2CLRID[CL0LWINX];
      end
      if (KL0LM001.XDMCD[CLXLINEX] == " ")
        KL0LM001.XDMCD[CLXLINEX] = CL0LW02.XDMCD[CL0LWINX];
      end
      if (KL0LM001.SY1STNBR[CLXLINEX] != " ")
        KL0LSE0();
        KL0LSE5();
        KL0LSBC(); /* edit prod brand-claim brand mis-match*/
                                   /* (5-31-90)*/
      end
      if (CL0LW01.CL0LWERR[CLXLINEX] == "Y")
        set KL0LM001.CL0LMSEL[CLXLINEX] cursor, modified, bold;
      end
    end
    if (KL0LM001.CL0LMSEL[CLXLINEX] == "C"
     || KL0LM001.CL0LMSEL[CLXLINEX] == "D"
     || KL0LM001.CL0LMSEL[CLXLINEX] == "S")
      sysVar.arrayIndex = 1;
      while (sysVar.arrayIndex < CLXREC.CLXLSTAX)
        if (KL0LM001.SY1STNBR[CLXLINEX] == CL0LW02.SY1STNBR[sysVar.arrayIndex]
         && KL0LM001.SY2CLRID[CLXLINEX] == CL0LW02.SY2CLRID[sysVar.arrayIndex]
         && KL0LM001.XDMCD[CLXLINEX] == CL0LW02.XDMCD[sysVar.arrayIndex]
         && sysVar.arrayIndex != CL0LW01.CL0LWINX)
          if (KL0LM001.CL0LMSEL[CLXLINEX] == CL0LW02.CLICRDFL[sysVar.arrayIndex])
            converseLib.validationFailed(209);
            set KL0LM001.CL0LMSEL[CLXLINEX] cursor, modified, bold;
            set KL0LM001.SY1STNBR[CLXLINEX] modified, bold;
            CLXREC.CLXERRF = "Y";
            CL0LW01.CL0LWERR[CLXLINEX] = "Y";
          else
            if (CL0LW02.CLICRDFL[sysVar.arrayIndex] == " ")
              CL0LW01.CL0LWIEX = 1;
              while (CL0LW01.CL0LWIEX < 12)
                if (KL0LM001.SY1STNBR[CLXLINEX] == KL0LM001.SY1STNBR[CL0LWIEX]
                 && KL0LM001.SY2CLRID[CLXLINEX] == KL0LM001.SY2CLRID[CL0LWIEX]
                 && KL0LM001.XDMCD[CLXLINEX] == KL0LM001.XDMCD[CL0LWIEX]
                 && CLXREC.CLXLINEX != CL0LW01.CL0LWIEX)
                  if (KL0LM001.CL0LMSEL[CLXLINEX] == KL0LM001.CL0LMSEL[CL0LWIEX]
                   || KL0LM001.CL0LMSEL[CL0LWIEX] == " ")
                    converseLib.validationFailed(209);
                    set KL0LM001.CL0LMSEL[CLXLINEX] cursor, modified, bold;
                    set KL0LM001.SY1STNBR[CLXLINEX] modified, bold;
                    CLXREC.CLXERRF = "Y";
                    CL0LW01.CL0LWERR[CLXLINEX] = "Y";
                    CL0LW01.CL0LWIEX = 12;
                  end
                end
                CL0LW01.CL0LWIEX = CL0LW01.CL0LWIEX + 1;
              end
            end
          end
          if (KL0LM001.CL0LMSEL[CLXLINEX] == "S"
           && CL0LW02.CLICRDFL[CL0LWINX] == " ")
            converseLib.validationFailed(209);
            set KL0LM001.CL0LMSEL[CLXLINEX] cursor, modified, bold;
            set KL0LM001.SY1STNBR[CLXLINEX] modified, bold;
            CLXREC.CLXERRF = "Y";
            CL0LW01.CL0LWERR[CLXLINEX] = "Y";
          end
          if (CL0LW02.CL0LMLVL[sysVar.arrayIndex] == "S")
            set KL0LM001.CL0LMSEL[CLXLINEX] cursor, modified, bold;
            set KL0LM001.SY1STNBR[CLXLINEX] bold;
            converseLib.validationFailed(203);
            CLXREC.CLXERRF = "Y";
            CL0LW01.CL0LWERR[CLXLINEX] = "Y";
          end
          if (CL0LW01.CL0LWERR[CLXLINEX] == "Y")
            sysVar.arrayIndex = 9000;
          end
        end
        sysVar.arrayIndex = sysVar.arrayIndex + 1;
      end
    end
    CLXREC.CLXLINEX = CLXREC.CLXLINEX + 1;
  end

  CLXREC.CLXLINEX = CLXREC.CLXMAXLN[CLXSCRNX];

  while (CLXREC.CLXLINEX > 0)
    CL0LW01.CL0LWINX = CLXREC.CLXARAYX - 1 - CLXREC.CLXMAPMX;
    CL0LW01.CL0LWINX = CL0LW01.CL0LWINX + CLXREC.CLXLINEX;

    if (CL0LW01.CL0LWINX < 1)
      CL0LW01.CL0LWINX = 1;
    end

    if (CL0LW01.CL0LWERR[CLXLINEX] == "Y")
      if (KL0LM001.CLRRQTQ[CLXLINEX] is modified)
        set KL0LM001.CLRRQTQ[CLXLINEX] modified;
      end
      if (KL0LM001.CLRCLMQ[CLXLINEX] is modified)
        set KL0LM001.CLRCLMQ[CLXLINEX] modified;
      end
      if (KL0LM001.CLKPRCFF[CLXLINEX] is modified)
        set KL0LM001.CLKPRCFF[CLXLINEX] modified;
      end
      if (KL0LM001.CLNGRPRC[CLXLINEX] is modified)
        set KL0LM001.CLNGRPRC[CLXLINEX] modified;
      end
    else
      if (CL0LW01.CL0LWINX >= CL0LW02.CL0LWASZ)
        converseLib.validationFailed(412);
        CL0LW01.CL0LWERR[CLXLINEX] = "Y";
        CLXREC.CLXERRF = "Y";
        set KL0LM001.CL0LMSEL[CLXLINEX] cursor, modified, bold;
      end

         /* IF CL0LM001.CLICRDFL(CLXLINEX) EQ ' ';*/
           /* AND CL0LM001.CL0LMLVL(CLXLINEX) EQ ' ';*/
           /* AND CL0LM001.SY1STNBR(CLXLINEX) EQ ' ';*/
           /* AND CL0LM001.SY2CLRID(CLXLINEX) EQ ' ';*/
           /* AND CL0LM001.XDMCD(CLXLINEX) EQ ' ';*/
           /* AND CL0LM001.IV3LNSQ(CLXLINEX) EQ 0;*/
           /* AND CL0LM001.IV3GLNUP(CLXLINEX) EQ 0;*/
           /* AND CL0LM001.CLRRQTQ(CLXLINEX) EQ 0;*/
           /* AND CL0LM001.CLKPRCFF(CLXLINEX) EQ ' ';*/
           /* AND CL0LM001.CLNGRPRC(CLXLINEX) EQ 0;*/
           /* AND CL0LM001.CL0LMVPR(CLXLINEX) EQ ' ';*/
           /* AND CL0LM001.CLAESTVL(CLXLINEX) EQ 0;*/
           /* IF CL0LM001.CL0LMSEL(CLXLINEX) NE ' ';*/
             /* AND CL0LM001.CL0LMSEL(CLXLINEX) NE 'SA';*/
             /* AND CL0LM001.CL0LMSEL(CLXLINEX) NE 'A';*/
             /* AND CL0LM001.CL0LMSEL(CLXLINEX) NE 'CA';*/
             /* AND CL0LM001.CL0LMSEL(CLXLINEX) NE 'DA';*/
             /* AND CL0LM001.CL0LMSEL(CLXLINEX) NE 'RC';*/
             /* AND CL0LM001.CL0LMSEL(CLXLINEX) NE 'RD';*/
             /* MOVE ' ' TO CL0LM001.CL0LMSEL(CLXLINEX);*/
           /* END ;*/
         /* END ;*/

      if (KL0LM001.CL0LMSEL[CLXLINEX] == " "
       && KL0LM001.CLICRDFL[CLXLINEX] == " "
       && KL0LM001.CL0LMLVL[CLXLINEX] == " "
       && KL0LM001.SY1STNBR[CLXLINEX] == " "
       && KL0LM001.SY2CLRID[CLXLINEX] == " "
       && KL0LM001.XDMCD[CLXLINEX] == " "
       && KL0LM001.IV3LNSQ[CLXLINEX] == 0
       && KL0LM001.IV3GLNUP[CLXLINEX] == 0
       && KL0LM001.CLRRQTQ[CLXLINEX] == 0
       && KL0LM001.CLKPRCFF[CLXLINEX] == " "
       && KL0LM001.CLNGRPRC[CLXLINEX] == 0
       && KL0LM001.CL0LMVPR[CLXLINEX] == " "
       && KL0LM001.CLAESTVL[CLXLINEX] == 0)
        set KL0LM001.CL0LMSEL[CLXLINEX] initialAttributes;
        CL0LW01.CL0LWMOD[CLXLINEX] = "N";
        CL0LW02.CL0LWCHF[CL0LWINX] = " ";
      else


        if (KL0LM001.CLNGRPRC[CLXLINEX] is modified)
          KL0LSE1(); /* ** claim price ***/
        else
          if (CL0LW01.CL0LWINQ != "Y" /* reset warning attributes*/
           && CL0LW02.CL0LMLVL[CL0LWINX] == "P") /* if worked at prod level*/
            set KL0LM001.CLNGRPRC[CLXLINEX] initialAttributes;
          end
        end

        if (CL0LW01.CL0LWINQ != "Y")
          if (KL0LM001.CLKPRCFF[CLXLINEX] == " ")
            if (KL0LM001.CL0LMSEL[CLXLINEX] == "C"
             || KL0LM001.CL0LMSEL[CLXLINEX] == "D")
              KL0LSE0();
              KL0LSE2();
            end
          end
        end

        if (KL0LM001.CLKPRCFF[CLXLINEX] is modified)
          KL0LSE0(); /* read style/color rec, if needed*/
          KL0LSE2(); /* ** price from flag ***/
        else
          if (CL0LW01.CL0LWINQ != "Y" /* reset warning attributes*/
           && CL0LW02.CL0LMLVL[CL0LWINX] == "P") /* if worked at prod level*/
            set KL0LM001.CLKPRCFF[CLXLINEX] initialAttributes;
          end
        end

        if (CL0LW01.CL0LWINQ != "Y"
         && KL0LM001.CL0LMSEL[CLXLINEX] != "X"
         && CL0LW02.CL0LMLVL[CL0LWINX] != "S")
          if (KL0LM001.CL0LMSEL[CLXLINEX] == "C"
           || KL0LM001.CL0LMSEL[CLXLINEX] == "D"
           || CL0LW02.CLICRDFL[CL0LWINX] == "C"
           || CL0LW02.CLICRDFL[CL0LWINX] == "D")
            if (KL0LM001.CLRRQTQ[CLXLINEX] == 0)
              converseLib.validationFailed(231);
              set KL0LM001.CLRRQTQ[CLXLINEX] cursor, modified, bold;
              CL0LW01.CL0LWERR[CLXLINEX] = "Y";
              CLXREC.CLXERRF = "Y";
            else
              set KL0LM001.CLRRQTQ[CLXLINEX] initialAttributes;
            end
          end
        end

        if (KL0LM001.CLRCLMQ[CLXLINEX] is modified)
          KL0LSE3(); /* ** claim quantity ***/
        else
          if (CL0LW01.CL0LWINQ != "Y" /* reset warning attributes*/
           && CL0LW02.CL0LMLVL[CL0LWINX] == "P") /* if worked at prod level*/
            set KL0LM001.CLRCLMQ[CLXLINEX] initialAttributes;
          end
        end

        if (KL0LM001.CLRRQTQ[CLXLINEX] is modified)
          KL0LSE4(); /* ** customer requested qty ***/
        else
          if (CL0LW01.CL0LWINQ != "Y" /* reset warning attributes*/
           && CL0LW02.CL0LMLVL[CL0LWINX] == "P") /* if worked at prod level*/
            set KL0LM001.CLRRQTQ[CLXLINEX] initialAttributes;
          end
        end

        if (KL0LM001.CL0LMSEL[CLXLINEX] == " "
         && KL0LM001.CLICRDFL[CLXLINEX] == " "
         && KL0LM001.CL0LMSEL[CLXLINEX] != "X"
         && KL0LM001.CL0LMSEL[1] != "CA"
         && KL0LM001.CL0LMSEL[1] != "DA")
          if (KL0LM001.CLRRQTQ[CLXLINEX] > 0)
            converseLib.validationFailed(8);
            set KL0LM001.CL0LMSEL[CLXLINEX] cursor, modified, bold;
            CLXREC.CLXERRF = "Y";
            CL0LW01.CL0LWERR[CLXLINEX] = "Y";
          end
          if (KL0LM001.CLRCLMQ[CLXLINEX] > 0)
            converseLib.validationFailed(8);
            set KL0LM001.CL0LMSEL[CLXLINEX] cursor, modified, bold;
            CLXREC.CLXERRF = "Y";
            CL0LW01.CL0LWERR[CLXLINEX] = "Y";
          end
        end

         /* ********************************/
         /* if product added, do more edits*/
         /* ********************************/

        if (CL0LW02.CL0LWCHF[CL0LWINX] == "A")
          if (KL0LM001.CLICRDFL[CLXLINEX] == " ")
            if (KL0LM001.CL0LMSEL[CLXLINEX] == " "
             || KL0LM001.CL0LMSEL[CLXLINEX] == "CA"
             || KL0LM001.CL0LMSEL[CLXLINEX] == "DA")
               /* AND CL0LM001.CL0LMSEL(1) NE 'CA';*/
               /* AND CL0LM001.CL0LMSEL(1) NE 'DA';*/
               /* select code required*/
              converseLib.validationFailed(224); /* new prod requires sel code s/c/d/x*/
              CLXREC.CLXERRF = "Y";
              CL0LW01.CL0LWERR[CLXLINEX] = "Y";
              set KL0LM001.CL0LMSEL[CLXLINEX] cursor, modified, bold;
              set KL0LM001.SY1STNBR[CLXLINEX] modified, bold;
            end
          end
        end

        if (KL0LM001.CL0LMSEL[CLXLINEX] is modified)
          CL0LW01.CL0LMSEL = KL0LM001.CL0LMSEL[CLXLINEX];
          KL0LSE6(); /* ** select code ***/
        else
          if (CL0LW01.CL0LWINQ != "Y" /* reset warning attributes*/
           && CL0LW02.CL0LMLVL[CL0LWINX] == "P") /* if worked at prod level*/
            set KL0LM001.CL0LMSEL[CLXLINEX] initialAttributes;
          end
        end

        if (CL0LW01.CL0LWERR[CLXLINEX] != "Y"
         && CL0LW01.CL0LWMOD[CLXLINEX] == "Y")

          KL0LS80(); /* move data to array*/

          CL0LW01.CL0LMSEL = " ";

           /* ***************************************************/
           /* combination edits, for the single line*/
           /* cl0lwchf set in each edit, when data is error free*/
           /* ***************************************************/

          if (CL0LW02.CL0LWCHF[CL0LWINX] == "Y" /* if line changed*/
           || CL0LW02.CL0LWCHF[CL0LWINX] == "A")
            CL0LW01.CL0LWUPD = "Y";
             /* ****************************************************/
             /* if customer claims qty eq 0, deflt to requested qty*/
             /* ****************************************************/
            if (CL0LW02.CLRCLMQ[CL0LWINX] == 0)
              KL0LM001.CLRCLMQ[CLXLINEX] = KL0LM001.CLRRQTQ[CLXLINEX];
              if (CL0LW02.CLICRDFL[CL0LWINX] == "C"
               || KL0LM001.CL0LMSEL[CLXLINEX] == "C")
                if (KL0LM001.CLRRQTQ[CLXLINEX] < 0)
                  CL0LW02.CLRCLMQ[CL0LWINX] = KL0LM001.CLRRQTQ[CLXLINEX] * -1;
                else
                  CL0LW02.CLRCLMQ[CL0LWINX] = KL0LM001.CLRRQTQ[CLXLINEX];
                end
              else
                CL0LW02.CLRCLMQ[CL0LWINX] = KL0LM001.CLRRQTQ[CLXLINEX];
              end
            end

            if (CL0LW02.IVANBLFL == "Y") /* net bill flag*/
              CL0LW01.CLAESTVL = CL0LW02.CLNNTPRC[CL0LWINX] * CL0LW02.CLRCLMQ[CL0LWINX];
            else
              CL0LW01.CLAESTVL = CL0LW02.CLNGRPRC[CL0LWINX] * CL0LW02.CLRCLMQ[CL0LWINX];
            end

            if (CL0LW02.CLICRDFL[CL0LWINX] == "C")
                                   /* show credit as negative*/
              if (CL0LW01.CLAESTVL > 0)
                CL0LW01.CLAESTVL = CL0LW01.CLAESTVL * -1;
              end
            end

            if (KL0LM001.CL0LMVPR[CLXLINEX] == "V")
              CL0LW01.CLAESTVL = KL0LM001.CLAESTVL[CLXLINEX];
            else
              KL0LM001.CLAESTVL[CLXLINEX] = CL0LW01.CLAESTVL;
            end

            KL0LSPT();

            CL0LW01.CL0LWMOD[CLXLINEX] = "N";

          end
        else
          if (KL0LM001.CL0LMSEL[CLXLINEX] is modified)
            if (CL0LW01.CL0LMSEL != " ")
              set KL0LM001.CL0LMSEL[CLXLINEX] modified;
            end
          end
        end
      end
    end
    CLXREC.CLXLINEX = CLXREC.CLXLINEX - 1;
  end


  if (KL0LM001.IV0IVCID is modified)
    CL0LW01.CL0LWIVC = KL0LM001.IV0IVCID;
    KL0LSE7(); /* invoice number*/
    KL0LM001.IV0IVCID = CL0LW01.CL0LWIVC;
  end


     /* *************************************/
     /* move changed totals to bottom of map*/
     /* *************************************/

  KL0LM001.SY1STNBR[12] = "TOTALS";
  KL0LM001.IV3LNSQ[12] = CL0LW01.CL0LWTSH[1];
  KL0LM001.CLRRQTQ[12] = CL0LW01.CLRRQTQ[1];
  KL0LM001.CLRCLMQ[12] = CL0LW01.CLRCLMQ[1];
  KL0LM001.CLAESTVL[12] = CL0LW01.CL0LWTVL[1];
  set KL0LM001.CLRRQTQ[12] protect;
  set KL0LM001.CLRCLMQ[12] protect;


     /* *******************/
     /* release data bases*/
     /* *******************/

  VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
  VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
  sysLib.commit();
  VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value



end // end KL0L120

// map 1 & 5 update data bases
Function KL0L130()
   /* *************************************************/
   /* *  update data base(s) as needed*/
   /* **/
   /* *  look at each product line,*/
   /* *    if changed at product level, not size level*/
   /* *       update data base*/
   /* *    if added at product level, not size level*/
   /* *       add to data base*/
   /* *    if deleted*/
   /* *       delete product & any sizes from data base*/
   /* **************************************************/

  CLXREC.CLXCPROC = "CL0L130"; /* set current process name*/


        /* * * ****************************************** * **/
      /* *                                                    **/
    /* *           keep similar to cl0l330                      **/
      /* *                                                    **/
        /* * * ****************************************** * **/

     /* update one screen's data before go to next screen*/
     /* when credit/debit all was done, update all data*/

  sysVar.arrayIndex = 1;
  while (sysVar.arrayIndex < 12)
    CL0LW01.CL0LWCHK[sysVar.arrayIndex] = "N";
    sysVar.arrayIndex = sysVar.arrayIndex + 1;
  end

  CL0LW01.CL0LWINX = 1; /* index to map*/

  if (CL0LW01.CL0LWALL == "Y") /* all prods changed by ca/da*/
    CL0LW01.CL0LWHLD = CLXREC.CLXARAYX;
    CLXREC.CLXARAYX = 1; /* go through entire w02 array*/
    CL0LW01.CL0LWEND = CLXREC.CLXLSTAX - 1; /* end 'while'*/
  else
    CL0LW01.CL0LWEND = CLXREC.CLXMAPMX;
     /* ***********************************************************/
     /* arayx  = next avail array entry, 1 after entry put on map*/
     /* next array entry - mapmx =  first array entry moved to map*/
     /* start of array = map line 1*/
     /* ***********************************************************/
    CL0LW01.CL0LWHLD = CLXREC.CLXARAYX;
    CLXREC.CLXARAYX = CLXREC.CLXARAYX - CLXREC.CLXMAPMX;

    if (CLXREC.CLXARAYX < 1)
      CLXREC.CLXARAYX = 1;
    end

  end


  CL0LW01.CL0LWCTR = 0;
  while (CL0LW01.CL0LWINX <= CL0LW01.CL0LWEND)
    if (CL0LW02.CL0LWCHF[CLXARAYX] == "Y")
      if (CL0LW02.CL0LMSEL[CLXARAYX] == "X")
        CL0LW01.CL0LWCTR = CL0LW01.CL0LWCTR + 1;
      end
      if (CL0LW02.CL0LMSEL[CLXARAYX] == "X")
         /* ***************/
         /* delete product*/
         /* ***************/
        if (CL0LW02.CLICRDFL[CLXARAYX] == "B")
          CL0LW02.CLICRDFL[CLXARAYX] = "C";
          KL0LSDL();
          CL0LW02.CLICRDFL[CLXARAYX] = "D";
          KL0LSDL();
          CL0LW02.CLICRDFL[CLXARAYX] = "B";
          CL0LW02.CL0LWCHF[CLXARAYX] = " ";
        else
          KL0LSDL(); /* delete data base*/
          CL0LW02.CL0LWCHF[CLXARAYX] = " "; /* action taken*/
        end
        if (converseVar.validationMsgNum == 18
         || converseVar.validationMsgNum == 4)
          return;
        end
        CL0LW02.CL0LWUSI[CLXARAYX] = "Y";
        set KL0LM001.CL0LMSEL[CL0LWINX] initialAttributes;
      else
        if (CL0LW02.CLICRDFL[CLXARAYX] == "C"
         || CL0LW02.CLICRDFL[CLXARAYX] == "D")
           /* **********************/
           /* change or add product*/
           /* **********************/
           /* other codes indicate prod worked at size level*/
          KL0LSUP(); /* update data base*/
           /* never have this when updating 'all' records*/
          if (converseVar.validationMsgNum == 18
           || converseVar.validationMsgNum == 4)
             /* have change count error, re-show map*/
            CLXREC.CLXARAYX = CLXREC.CLXARAYX - CL0LW01.CL0LWINX + 1;
             /* reset array pointer to map line 1*/
            return;
          end

          CL0LW02.ZZZCHGCT[CLXARAYX] = CLRREC.ZZZCHGCT;
          CL0LW02.CL0LWCHF[CLXARAYX] = " "; /* action taken*/
        end
      end
    else
      if (CL0LW02.CL0LWCHF[CLXARAYX] == "A" /* if added product i.d.*/
       && CL0LW02.CL0LMLVL[CLXARAYX] == "P") /* and no sizes*/
         /* ************/
         /* add product*/
         /* ************/
        if (CL0LW02.CLICRDFL[CLXARAYX] == "C"
         || CL0LW02.CLICRDFL[CLXARAYX] == "D")
           /* other codes indicate prod worked at size level*/
          KL0LSAD(); /* add record*/
          CL0LW02.CL0LWCHF[CLXARAYX] = " "; /* action taken*/
        else
          /* CL0LW01.CL0LWCTR = CL0LW01.CL0LWCTR + 1 ; 2/89*/
        end
      else
        if (CL0LW02.SY1STNBR[CLXARAYX] == " ") /* prd was deleted previously*/
          CL0LW01.CL0LWCTR = CL0LW01.CL0LWCTR + 1; /* 2/89*/
        end
      end
    end

    CLXREC.CLXARAYX = CLXREC.CLXARAYX + 1;
    CL0LW01.CL0LWINX = CL0LW01.CL0LWINX + 1;
  end

  CLXREC.CLXARAYX = CLXREC.CLXARAYX - 1;

  if (CL0LW01.CL0LWCTR == CL0LW01.CL0LWEND)
     /* have had delete activity against all products on screen*/
    CL0LW01.CLBSRIND = "N"; /* no products exist for invoice*/
    CL0LW01.CL0LWBUP = "Y"; /* update clbrec*/
  end

  if (CL0LW01.CL0LWAUP == "Y")
    KL0LSAU();
    CL0LW01.CL0LWAUP = "N";
  end


     /* **************************************/
     /* if changed all records, reset pointer*/
     /* **************************************/

  if (CL0LW01.CL0LWALL == "Y")
    CL0LW01.CL0LWALL = "N";
  end

  CLXREC.CLXARAYX = CL0LW01.CL0LWHLD;


     /* *******************/
     /* release data bases*/
     /* *******************/

  VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
  VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
  sysLib.commit();
  VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
   /* release data bases*/



end // end KL0L130

// map 1 & 5 pf key action
Function KL0L140()
   /* ********************************************************/
   /* *  act upon pf keys*/
   /* **/
   /* *  pf 1, 3, 4 and 12 wre acted upon*/
   /* *  in cl0l110 or cl0l210 or cl0l310*/
   /* **/
   /* *  the other pf keys are acted upon here, after editing*/
   /* *  and updating have occured.*/
   /* **/
   /* ********************************************************/

  CLXREC.CLXCPROC = "CL0L140"; /* set current process name*/

    /* note - done for all maps 1,  map 5 and map 10*/
    /* (product summary and product descriptions)*/


  if (converseVar.eventKey is enter)
    KL0LS00(); /* too long to keep here*/
    return;
  end


  if (converseVar.eventKey is pf5)
    KL0LS05(); /* claim header*/
    return;
  end

  if (converseVar.eventKey is pf6)
    KL0LS06(); /* max scroll back*/
    return;
  end

  if (converseVar.eventKey is pf7)
    KL0LS07(); /* scroll back*/
    return;
  end

  if (converseVar.eventKey is pf8)
    KL0LS08(); /* scroll forward*/
    return;
  end

  if (converseVar.eventKey is pf9)
    KL0LS09(); /* max scroll forward*/
    return;
  end

  if (converseVar.eventKey is pf10)
    KL0LS10(); /* scroll left  to map 1*/
    return;
  end

  if (converseVar.eventKey is pf11)
    KL0LS11(); /* scroll right to map 5*/
    return;
  end

  if (converseVar.eventKey is pf12) /* edit only*/
    return;
  end

  if (converseVar.eventKey is pf13)
    KL0LS13(); /* traffic*/
    return;
  end

  if (converseVar.eventKey is pf14)
    KL0LS14(); /* general ledger*/
    return;
  end



end // end KL0L140

// map 5 product summ descrptions
Function KL0L200()
   /* ************************************************************/
   /* *     process screen cl0lm005                             **/
   /* *                                                         **/
   /* *  note that this process is being performed in a         **/
   /* *      "while loop" from cl0l050 until the end-of-screen  **/
   /* *      flag (clxeosf) gets set to 'y'                     **/
   /* *                                                         **/
   /* ************************************************************/

  CLXREC.CLXCPROC = "CL0L200"; /* set current process name*/
  if (converseVar.validationMsgNum == 4
   || converseVar.validationMsgNum == 18)
    CL0LW01.CL0LWVCH = 0;
    CL0LW01.CL0LWQCH = 0;
    CLXREC.CLXBLDAY = "Y";
    CLXREC.CLXBLDSC = "Y";
    CL0LW01.CL0LW1PR = "Y";
  end


  if (CLXREC.CLXBLDAY == "Y")
    set KL0LM005.CL0LMSEL[1] cursor;
    KL0L102(); /* build w-s array same as for map 1*/
    CLXREC.CLXBLDAY = "N"; /* skip build array next time thru*/

    if (CLXREC.CLXBLDSC == "Y")
      KL0L204(); /* build screen because new record*/
      CLXREC.CLXBLDSC = "N"; /* or pf7/pf8 keyed*/
    end
  else
    if (CLXREC.CLXERRF == "Y") /* if had error, skip scrn build*/
       /* next sentence*/
    else
      if (converseVar.validationMsgNum == 0 /* build if no warnings*/
       || converseVar.eventKey is pf7       /* or from pf7*/
       || converseVar.eventKey is pf8)      /* or from pf8*/
        set KL0LM005.CL0LMSEL[1] cursor;
        if (CLXREC.CLXBLDSC == "Y")
          KL0L204(); /* build screen because new record*/
          CLXREC.CLXBLDSC = "N"; /* or pf7/pf8 keyed*/
        end
      end
    end
  end




  converse KL0LM005 ;

     /* **************************************************/
     /* may have warning mesg in ezemno and clxerrf = 'n'*/
     /* clxerrf = 'y' only when a field was set modified*/
     /* **************************************************/

  CLXREC.CLXMSG = " "; /* set non-ezemno error message to*/
                                   /* spaces*/
  CLXREC.CLXERRF = "N"; /* re-set error flag*/
  converseLib.validationFailed(0);


  if (KL0LM005 is modified) /* if there were entries*/
    CLXREC.CLXEDITF = "Y"; /* then set do-edits-fl to 'y'*/
  else
    CLXREC.CLXEDITF = "N"; /* if no entries, then no edits*/
  end



  KL0L210(); /* handle any special entries*/

  if (CLXREC.CLXEOSF == "Y")
    return;
  end



  if (CLXREC.CLXEDITF == "Y") /* if we still want to edit*/
    KL0L220(); /* go edit screen entries*/
  end


      /* determine next action*/

  if (CLXREC.CLXERRF == "Y" /* if screen has errors*/
   || converseVar.validationMsgNum != 0)
     /* next sentence*/
  else
    if (converseVar.eventKey is pf12) /* or user wants to see same screen*/
       /* next sentence*/
    else
      if (CL0LW01.CL0LWUPD == "Y")
        KL0L130();
                                   /* same as in map 1, go update data base*/
        if (converseVar.validationMsgNum == 18) /* change count error*/
          return;
        end
        CL0LW01.CL0LWUPD = "N";
      end
      KL0L140(); /* act upon pf key*/
    end
  end



   /* at this point;*/
     /* if the end-of-screen flag (clxeosf) is 'n'*/
       /* the perform returns to top of process cl0l100.*/
     /* else*/
       /* the perform returns to cl0l050.*/



end // end KL0L200

// map 5 move array to map
Function KL0L204()
   /* %get cl0l104*/
   /* ************************************************************/
   /* *        this process initializes screen cl0lm005         **/
   /* *        it will read the w-s array cl0lw02               **/
   /* *        scroll changes the index in cl0l140              **/
   /* ************************************************************/

  CLXREC.CLXCPROC = "CL0L204"; /* set current process name*/


  CLXREC.CLXLINEX = 1; /* start at map line 1*/
  CL0LW01.CL0LWDNE = "N"; /* not done with filling map*/

    /* note - array index set in cl0l102 and cl0l104*/

  while (CLXREC.CLXLINEX <= CLXREC.CLXMAXLN[CLXSCRNX]) /* scrnx = map 5*/
    if (CLXREC.CLXARAYX < CLXREC.CLXLSTAX) /* if not at end of array*/
       /* *****************/
       /* move data to map*/
       /* *****************/
      KL0LS40(); /* build each screen line*/
      CLXREC.CLXLINEX = CLXREC.CLXLINEX + 1; /* increment map*/
      CLXREC.CLXARAYX = CLXREC.CLXARAYX + 1; /* & array index*/
    else
       /* ************************************/
       /* at end of array, but not end of map*/
       /* ************************************/
      if (CL0LW01.CL0LWDNE == "N")
        CL0LW01.CL0LWDNE = "Y";
        CLXREC.CLXMAPMX = CLXREC.CLXLINEX - 1;
      end
       /* clear map line*/
      KL0LM005.CL0LMSEL[CLXLINEX] = " ";
      KL0LM005.CL0LMLVL[CLXLINEX] = " ";
      KL0LM005.CLICRDFL[CLXLINEX] = " ";
      KL0LM005.SY1STNBR[CLXLINEX] = " ";
      KL0LM005.SY2CLRID[CLXLINEX] = " ";
      KL0LM005.XDMCD[CLXLINEX] = " ";
      KL0LM005.KUIPRDID[CLXLINEX] = " ";
      KL0LM005.SY1SSTNM[CLXLINEX] = " ";
      KL0LM005.SY2CLRAB[CLXLINEX] = " ";

      CLXREC.CLXLINEX = CLXREC.CLXLINEX + 1;
    end
  end


     /* *******************/
     /* release data bases*/
     /* *******************/

  VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
  VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
  sysLib.commit();
  VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value



end // end KL0L204

// map 5 edit pf keys
Function KL0L210()
   /* ************************************************************/
   /* *  validate pf keys                                       **/
   /* *                                                         **/
   /* *  the only keys acted upon at this time are pf 1, 3 & 4  **/
   /* *  and fastpath                                           **/
   /* *                                                         **/
   /* *  the other keys are just verified that they are used    **/
   /* *  by this application.  if the pf key is not recognized, **/
   /* *  the application resets all modified fields to remain   **/
   /* *  modified, then reshows the map with an error message.  **/
   /* *                                                         **/
   /* *  these other pf keys are acted upon after the editing   **/
   /* *  and updating have occured.                             **/
   /* *                                                         **/
   /* ************************************************************/

  CLXREC.CLXCPROC = "CL0L210"; /* set current process name*/

     /* if you want to use pa2 to ezeclos, for testing only,*/
     /* then use stmnt group 'tests01' or some non-std name*/
   /* BETHS01;*/


      /* *******************************/
      /* check for fastpath option/item*/
      /* *******************************/

      /* same as cl0l110 & cl0l310*/

  if (KL0LM005.CATOAP == " " /* if fastpath appl is kl0l,*/
   || KL0LM005.CATOAP == "KL0L")
    if (KL0LM005.CAITEM != " ") /* and have item -*/
       /* **********************************/
       /* try to find product in curr array*/
       /* **********************************/
       /* ignore color and dimension*/

      sysVar.arrayIndex = 1;
      CL0LW01.CL0LWPRX = 0; /* init product index*/

      while (sysVar.arrayIndex < CLXREC.CLXLSTAX) /* search w/s array*/
        if (KL0LM005.CAITEM <= CL0LW02.SY1STNBR[sysVar.arrayIndex])
          CL0LW01.CL0LWPRX = sysVar.arrayIndex; /* hold index for use in cl0l140*/
          sysVar.arrayIndex = 9000; /* force loop end*/
        else
          sysVar.arrayIndex = sysVar.arrayIndex + 1;
        end
      end

      if (CL0LW01.CL0LWPRX == 0) /* prod gt any in array*/
         /* clxlstax = next available ' ' entry*/
        CL0LW01.CL0LWPRX = CLXREC.CLXLSTAX - 1; /* force to last array prod*/
      end

      KL0LM005.CAITEM = " "; /* clear map field*/

      return;
    else
       /* *************************************/
       /* next sentence - fastpath not entered*/
       /* *************************************/
    end
  else
     /* *******************************************/
     /* plain, old, ordinary fastpath - just leave*/
     /* *******************************************/
    COMMAREA.CATOAP = KL0LM005.CATOAP; /* jump to next applica*/
    COMMAREA.CAITEM = KL0LM005.CAITEM;
    XPCL002();
    return;
  end


  if (converseVar.eventKey is enter) /* normal 'enter'*/
    return;
  end

  if (converseVar.eventKey is pf1) /* 'help'*/
    KL0LS01();
    return;
  end

  if (converseVar.eventKey is pf3)
    KL0LS03(); /* skip edit, update - exit*/
    return;
  end

  if (converseVar.eventKey is pf4)
    KL0LS04(); /* skip edit, update - exit*/
    return;
  end

  if (converseVar.eventKey is pf5) /* claim header*/
    return;
  end

  if (converseVar.eventKey is pf7) /* page back*/
    return;
  end

  if (converseVar.eventKey is pf8) /* page forward*/
    return;
  end

  if (converseVar.eventKey is pf10) /* page left*/
    return;
  end

  if (converseVar.eventKey is pf13) /* traffic*/
    return;
  end

  if (converseVar.eventKey is pf14) /* general ledger*/
    return;
  end


      /* pf key not valid*/

  converseLib.validationFailed(2); /* pf key not valid*/
  CLXREC.CLXERRF = "Y";
  KL0LSS1(); /* set fields modfd so user no re-key*/
  CLXREC.CLXEDITF = "N"; /* do not edit map, just re-show it*/



end // end KL0L210

// map 5 edit map data
Function KL0L220()
   /* ************************************************************/
   /* *     this process handles all edits of select code*/
   /* *          entries into screen cl0lm005*/
   /* **/
   /* ************************************************************/

  CLXREC.CLXCPROC = "CL0L220"; /* set current process name*/


        /* *  *  **************************************** * **/
      /* *                                                    **/
    /* *       keep this the same as cl0l120 & cl0l320          **/
      /* *                                                    **/
        /* *  *  **************************************** * **/


     /* *******************************************/
     /* loop from bottom to top, edit data entered*/
     /* *******************************************/

  CLXREC.CLXLINEX = CLXREC.CLXMAXLN[CLXSCRNX]; /* init index to max*/

    /* note - there may be 'added' product lines, so*/
           /* last data on map may not be equal to clxarayx,*/
           /* so add in clxlinex to cl0lwinx value.*/

           /* use cl0lwinx as pointer to array - kept in sync*/
           /* with clxlinex as it goes backwards through map*/
           /* pointing to existing array entry,*/
           /* or new array entries.*/


  while (CLXREC.CLXLINEX > 0) /* go from line 11 to line 1*/
     /* ***********************************************************/
     /* arayx - 1 = last array entry moved to map,*/
     /* last array entry - mapmx =  1 before array entry put on map*/
     /* 1 before ay entry + linex = current array entry for linex.*/
     /* ***********************************************************/
    CL0LW01.CL0LWINX = CLXREC.CLXARAYX - 1 - CLXREC.CLXMAPMX;
    CL0LW01.CL0LWINX = CL0LW01.CL0LWINX + CLXREC.CLXLINEX;

    if (CL0LW01.CL0LWINX < 1)
      CL0LW01.CL0LWINX = 1;
    end

    if (CL0LW01.CL0LWINX >= CL0LW02.CL0LWASZ) /* if cant add more prods,*/
      TA1REC.TA1TBLKE = "EXCEEDED CL0LW02 PRODUCT ARRAY SIZE";
      XPCL010(); /* abend*/
    end

    if (KL0LM005.CL0LMSEL[CLXLINEX] is modified)
      CL0LW01.CL0LMSEL = KL0LM005.CL0LMSEL[CLXLINEX];
      KL0LSE6(); /* ** select code ***/
      KL0LM005.CL0LMSEL[CLXLINEX] = CL0LW01.CL0LMSEL;
    else
      if (CL0LW01.CL0LWINQ != "I" /* reset warning attributes*/
       && CL0LW02.CL0LMLVL[CL0LWINX] != "P") /* if worked at prod level*/
        set KL0LM005.CL0LMSEL[CLXLINEX] initialAttributes;
      end
    end

    if (CL0LW02.CL0LWCHF[CL0LWINX] == "Y" /* if line changed*/
     || CL0LW02.CL0LWCHF[CL0LWINX] == "A")
      CL0LW01.CL0LWUPD = "Y";
    end

    CLXREC.CLXLINEX = CLXREC.CLXLINEX - 1;
  end


  if (KL0LM005.IV0IVCID is modified)
    CL0LW01.CL0LWIVC = KL0LM005.IV0IVCID;
    KL0LSE7(); /* invoice number*/
    KL0LM005.IV0IVCID = CL0LW01.CL0LWIVC;
  end


     /* *******************/
     /* release data bases*/
     /* *******************/

  VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
  VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
  sysLib.commit();
  VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value



end // end KL0L220

// map 10 detail sizes
Function KL0L300()
   /* ************************************************************/
   /* *    process screen cl0lm010 detail sizes                 **/
   /* *                                                         **/
   /* *  note - this process is being performed in a            **/
   /* *     "while loop" from cl0l050 until the end-of-screen   **/
   /* *     flag (clxeosfl) is set to 'y'.                      **/
   /* *                                                         **/
   /* ************************************************************/


  CLXREC.CLXCPROC = "CL0L300"; /* set current process name*/
  if (converseVar.validationMsgNum == 4
   || converseVar.validationMsgNum == 18)
    CL0LW01.CL0LWVCH = 0;
    CL0LW01.CL0LWQCH = 0;
    CLXREC.CLXBLDAY = "Y";
    CLXREC.CLXBLDSC = "Y";
    CL0LW01.CL0LW1PR = "Y";
  end

  if (CLXREC.CLXBLDAY == "Y") /* build w/s array of product sizes*/
    set KL0LM010.CL0LMSEL[1] cursor, initialAttributes;
    KL0L302(); /* max 40 sizes*/
    CLXREC.CLXBLDAY = "N";

    if (CLXREC.CLXBLDSC == "Y")
      KL0L304(); /* build screen*/
      CLXREC.CLXBLDSC = "N";
    end
  else
    if (CLXREC.CLXERRF == "Y") /* if error, skip scrn bld*/
       /* next sentence*/
    else
      if (converseVar.validationMsgNum == 0 /* build if no warnings*/
       || converseVar.validationMsgNum == 412
       || converseVar.eventKey is pf7       /* or from pf7*/
       || converseVar.eventKey is pf8)      /* or from pf8*/
        set KL0LM010.CL0LMSEL[1] cursor, initialAttributes;
        if (CLXREC.CLXBLDSC == "Y")
          KL0L304(); /* build screen fir new invc*/
          CLXREC.CLXBLDSC = "N"; /* to display, or pf7/8*/
        end
      end
    end
  end



  converse KL0LM010 ;

     /* *********************************************************/
     /* may give warning mesg, with just ezemno & clxerrf = 'n'.*/
     /* clxerrf set = 'y' only when a field is set modified*/
     /* *********************************************************/

  if (CLXREC.CLXERRF == "Y")
    /* next sentence*/
  else
    sysVar.arrayIndex = 1;
    while (sysVar.arrayIndex < 12)
      CL0LW01.CL0LWMOD[sysVar.arrayIndex] = "N";
      sysVar.arrayIndex = sysVar.arrayIndex + 1;
    end
  end

  CLXREC.CLXMSG = " "; /* set non-ezemno error message to*/
                                   /* spaces*/
  CLXREC.CLXERRF = "N"; /* re-set error flag*/
  converseLib.validationFailed(0);


  if (KL0LM010 is modified) /* if there were entries*/
    CLXREC.CLXEDITF = "Y"; /* then set do-edits-fl to 'yes'*/
  else
    CLXREC.CLXEDITF = "N"; /* if no entries, then no edits*/
    CLXREC.CLXLINEX = 1;
    while (CLXREC.CLXLINEX < 12)
      CL0LW01.CL0LWWRN[CLXLINEX] = "N";
      CLXREC.CLXLINEX = CLXREC.CLXLINEX + 1;
    end
  end



  KL0L310(); /* edit pf keys*/


  if (CLXREC.CLXEOSF == "Y") /* if end of screen*/
    return; /* exit the perform*/
  end



  if (CLXREC.CLXEDITF == "Y") /* if we still want to edit*/
    KL0L320(); /* go edit screen entries*/
  else
    CL0LW01.CL0LWINX = 1;
    while (CL0LW01.CL0LWINX < 12)
      if (KL0LM010.SY4IDDSC[CL0LWINX] == " ")
        if (CL0LW01.CL0LWINQ == "N")
          set KL0LM010.SY4IDDSC[CL0LWINX] normal;
        else
          set KL0LM010.SY4IDDSC[CL0LWINX] initialAttributes;
        end
      else
        set KL0LM010.SY4IDDSC[CL0LWINX] initialAttributes;
        set KL0LM010.CL0LMSEL[CL0LWINX] initialAttributes;
        set KL0LM010.CLICRDFL[CL0LWINX] initialAttributes;
        set KL0LM010.IV4SHPQ[CL0LWINX] initialAttributes;
        set KL0LM010.IV4GUP[CL0LWINX] initialAttributes;
        set KL0LM010.CLRRQTQ[CL0LWINX] initialAttributes;
        set KL0LM010.CLRCLMQ[CL0LWINX] initialAttributes;
        set KL0LM010.CLKPRCFF[CL0LWINX] initialAttributes;
        set KL0LM010.CLNGRPRC[CL0LWINX] initialAttributes;
        set KL0LM010.CLAESTVL[CL0LWINX] initialAttributes;
      end
      CL0LW01.CL0LWINX = CL0LW01.CL0LWINX + 1;
    end
  end


      /* determine next action*/

  if (CLXREC.CLXERRF == "Y") /* if screen has errors*/
     /* next sentence*/
  else
    if (converseVar.validationMsgNum != 0
     && converseVar.validationMsgNum != 412)
      /* next sentence*/
    else
      if (converseVar.eventKey is pf12) /* or user wants to see same screen*/
         /* next sentence*/
      else
        if (CL0LW01.CL0LWUPD == "Y"
         && CL0LW01.CL0LWINQ != "Y")
          KL0L330(); /* go update data base*/
          if (converseVar.validationMsgNum == 18) /* change count error*/
            return;
          end
          CL0LW01.CL0LWUPD = "N";
        end
        KL0L340(); /* act upon pf key*/
      end
    end
  end

  if (CLXREC.CLXBLDSC == "Y")
    CL0LW01.CLAESTVL = 0;
    CL0LW01.CL0LWEV = 0;
    CL0LW02.CLAESTVL[CL0LWCAX] = 0;
    CL0LW01.CL0LWIDX = 1;
    while (CL0LW01.CL0LWIDX <= CLXREC.CLXLSTSZ)
      if (CL0LW03.CL0LMSEL[CL0LWIDX] == "X")
        /* next sentence*/
      else
        if (CL0LW02.IVANBLFL == "Y")
          CL0LW01.CL0LWEV = CL0LW03.CLRCLMQ[CL0LWIDX] * CL0LW03.CLNNTPRC[CL0LWIDX];
        else
          CL0LW01.CL0LWEV = CL0LW03.CLRCLMQ[CL0LWIDX] * CL0LW03.CLNGRPRC[CL0LWIDX];
        end
        if (CL0LW03.CLICRDFL[CL0LWIDX] == "C")
          CL0LW01.CL0LWEV = CL0LW01.CL0LWEV * -1;
        end
        CL0LW02.CLAESTVL[CL0LWCAX] = CL0LW02.CLAESTVL[CL0LWCAX] + CL0LW01.CL0LWEV;
      end
      CL0LW01.CL0LWIDX = CL0LW01.CL0LWIDX + 1;
    end
  end


   /* at this point;*/
     /* if the end-of-screen flag (clxeosf) is 'n'*/
       /* the perform returns to top of process cl0l300.*/
     /* else*/
       /* the perform returns to cl0l050.*/



end // end KL0L300

// map 10 build size array 4 prod
Function KL0L302()
   /* ************************************************************/
   /* *        read all sizes for product selected on summary*/
   /* **/
   /* *  MAINTENANCE HISTORY*/
   /* *  06-14-92  sgorga  DB2 Chgs.  Replaced KU2REC with KUIREC.*/
   /* *                    Replaced call 'S ' with 'SB'.*/
   /* *  08-01-97  sarumu  Replaced VCUSKU01 table access by VCUCPX01*/
   /* *                    access.*/
   /* ************************************************************/

  CLXREC.CLXCPROC = "CL0L302"; /* set current process name*/


      /* ************************************************/
      /* cl0lwcax index was set to the first 's'elect in*/
      /* the product array by process cl0l140/cl0ls00.*/
      /* it is incremented in process cl0l340.*/

      /* each process checks that the*/
      /* product is not worked at product level*/
      /* (cl0lw02.cl0lmlvl(.) eq 'p').  these will not*/
      /* be selected, even on a 'select all'.*/
      /* ************************************************/


      /* ********************************/
      /* clear size array, set constants*/
      /* ********************************/

  set CL0LW03 empty;
  CL0LW03.CL0LWASZ = 80; /* 40 is detail size array length*/

  CL0LW01.CL0LWTSH[2] = 0; /* tot shipped qty*/
  CL0LW01.CLRRQTQ[2] = 0; /* tot cust reqsted qty*/
  CL0LW01.CLRCLMQ[2] = 0; /* tot claim qty*/
  CL0LW01.CL0LWTVL[2] = 0; /* tot claim value*/

  CL0LW01.CL0LWCLP = 0; /* color price default*/
  CL0LW01.CL0LWSTP = 0; /* style price default*/

  CL0LW01.CL0LWALL = "N"; /* all sizes changed*/

  CL0LW02.CL0LMSEL[CL0LWCAX] = "V"; /* mark curr prod 'v'iewed*/


      /* *************************/
      /* build map product header*/
      /* *************************/

   /* ****************************/
   /* move nike product id to map*/
   /* ****************************/

  KL0LM010.SY1STNBR = CL0LW02.SY1STNBR[CL0LWCAX];
  KL0LM010.SY2CLRID = CL0LW02.SY2CLRID[CL0LWCAX];
  if (CL0LW02.XDMCD[CL0LWCAX] == "00")
    KL0LM010.XDMCD = " ";
  else
    KL0LM010.XDMCD = CL0LW02.XDMCD[CL0LWCAX];
  end



   /* GET CL0LS40*/
   /* GET CL0LS30*/
      /* **************************************************/
      /* find customer product id, either from the cl0lw02*/
      /* array (taken off the invoice product record,*/
      /* or previously gotten for map 5)*/
      /* or from the customer sku record.*/
      /* **************************************************/

  set WCU1710 empty;

  if (CL0LW02.KUIPRDID[CL0LWCAX] != " ") /* have invoice cust prod id*/
     /* or got cust prod id previously*/
    KL0LM010.KUIPRDID = CL0LW02.KUIPRDID[CL0LWCAX];
  else
    WCU1710-INQUIRY-OPTION = "2"; /* Nike product id look up*/
    WCU1710-IN-CU-CO-ID = KUCREC.KUCCOID; /* company*/
    WCU1710-XNX-DEPT-ID-XREF = 0; /* customer dept id cross ref*/
    if (CLAREC.IV0IVCID > 0) /* get product xref date*/
      WCU1710-CU-PROD-XREF-EDT = KL0LM001.IV0IVCDT;
    else
      WCU1710-CU-PROD-XREF-EDT = CLAREC.CLASETDT;
    end
    WCU1710-IN-XGP-GPC-CD = CL0LW02.XGPCD[CL0LWCAX]; /* g.p.c.*/
    WCU1710-IN-SY-STY-NBR = CL0LW02.SY1STNBR[CL0LWCAX]; /* style*/
    WCU1710-IN-SY-COLR-CD-ID = CL0LW02.SY2CLRID[CL0LWCAX]; /* color*/
    WCU1710-IN-XDM-DIM-CD = CL0LW02.XDMCD[CL0LWCAX]; /* dimension*/
    WCU1710-IN-SY-SZ-ID = 0; /* zero size id*/
    /* if quality code is blank default it to '01'*/
    if (CL0LW02.XQACD[CL0LWCAX] != " ")
      WCU1710-IN-XQA-QUAL-CD = CL0LW02.XQACD[CL0LWCAX];
    else
      WCU1710-IN-XQA-QUAL-CD = "01";
    end
    call "CU1710" (WCU1710) {isNoRefresh = yes, isExternal = yes}; /* get customer product id xref*/
    if (WCU1710-RETURN-CODE == 0)
      KL0LM010.KUIPRDID = WCU1710.CU-CUST-PROD-ID[1];
      CL0LW02.KUIPRDID[CL0LWCAX] = WCU1710.CU-CUST-PROD-ID[1];
    else
      KL0LM010.KUIPRDID = " ";
    end
  end


   /* *******************************************/
   /* move quality code & unit of measure to map*/
   /* *******************************************/

  KL0LM010.XQACD = CL0LW02.XQACD[CL0LWCAX];

  if (KL0LM010.XQACD in XQATBL.XQACD)
    KL0LM010.XQAABRV = XQATBL.XQAABRV[sysVar.arrayIndex];
  end


  KL0LM010.XUMCD = CL0LW02.XUMCD[CL0LWCAX];

  if (KL0LM010.XUMCD in XUMTBL.XUMCD)
    KL0LM010.XUMDESC = XUMTBL.XUMDESC[sysVar.arrayIndex];
  end


     /* ***************************************/
     /* get product style & color descriptions*/
     /* nike product id must be on product file*/
     /* ***************************************/

  CL0LW01.CL0LWSYC = "N"; /* init have sycrec indicator*/

  SYCREC.XGPCD = CL0LW02.XGPCD[CL0LWCAX];
  SYCREC.SY1STNBR = CL0LW02.SY1STNBR[CL0LWCAX];
  SYCREC.SY2CLRID = CL0LW02.SY2CLRID[CL0LWCAX];
  SYCREC.XDMCD = CL0LW02.XDMCD[CL0LWCAX];

  call "IO0560" ("S ", SQLCA, SYCREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    CL0LW01.CL0LWSYC = "Y"; /* have sycrec*/
    KL0LM010.SY1SSTNM = SYCREC.SY1SSTNM;
    KL0LM010.SY2CLRAB = SYCREC.SY2CLRAB;
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      CL0LW01.CL0LWSYC = "E"; /* sycrec error*/
      converseLib.validationFailed(206); /* product not found*/
      CLXREC.CLXERRF = "Y";
      set KL0LM010.SY1STNBR cursor, bold;
      return;
    else
      TA1REC.TA1DBASE = "DPROD";
      TA1REC.TA1TBLVU = "VCOLOR02";
      XPCL010(); /* abend*/
    end
  end


      /* *********************************************/
      /* get size scale record, for size descriptions*/
      /* *********************************************/

  if (SYCREC.SY4SZSCL != " ")
    SY4REC.SY4SZSCL = SYCREC.SY4SZSCL; /* scale code*/

    call "IO0040" ("S ", SQLCA, SY4REC) {isNoRefresh = yes, isExternal = yes}; /* i/o mod for single select*/

    if (SQLCA.VAGen_SQLCODE == 0) /* check for good return*/
       /* next sentence*/
    else
      if (SQLCA.VAGen_SQLCODE == 100) /* if scale code not found*/
        sysVar.arrayIndex = 1;
        while (sysVar.arrayIndex < 41) /* move constant to all size descrips*/
          SY4REC.SY4IDDSC[sysVar.arrayIndex] = "UNKWN";
          sysVar.arrayIndex = sysVar.arrayIndex + 1;
        end
      else
        TA1REC.TA1DBASE = "DPROD"; /* data base name*/
        TA1REC.TA1TBLVU = "VSCALE01"; /* table view*/
        XPCL010(); /* common abend routine*/
      end
    end
  else
    sysVar.arrayIndex = 1;
    while (sysVar.arrayIndex < 41) /* move constant to all size descrips*/
      SY4REC.SY4IDDSC[sysVar.arrayIndex] = "UNKWN";
      sysVar.arrayIndex = sysVar.arrayIndex + 1;
    end
  end


     /* *****************************/
     /* build size array for product*/
     /* *****************************/

  CLXREC.CLXCURSZ = 1; /* start at array(1)*/

     /* if 'use invoice' eq Y, then data is from the invc*/
     /* else it's from the claim*/

  if (CL0LW02.CL0LWUSI[CL0LWCAX] == "Y") /* if use invoice for sizes*/
    KL0LSDI(); /* read invoice to get sizes*/
  else
    KL0LSDC(); /* read claim to get sizes*/
  end


     /* *********************************************/
     /* if first size for product is zero, then have*/
     /* no sizes.  give warning.*/
     /* *********************************************/

  if (CL0LW03.SY5SZID[1] == 0)
    converseLib.validationFailed(215); /* no sizes for product, enter size*/
    if (CL0LW02.CL0LMLVL[CL0LWCAX] == "S") /* level of work = size*/
      CL0LW02.CL0LMLVL[CL0LWCAX] = " "; /* chgs to level = unknown*/
    end
  end



  VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
  VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
  sysLib.commit();
  VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
   /* release data bases*/



     /* ************************************************/
     /* set array pointers to i.d. last array entry + 1*/
     /* and to start building screen from array # 1*/
     /* ************************************************/

  CLXREC.CLXLSTSZ = CLXREC.CLXCURSZ; /* hold next empty arry size*/

  CLXREC.CLXCURSZ = 1; /* start map from size 1*/




end // end KL0L302

// map 10 move size array to map
Function KL0L304()
   /* ***************************************/
   /* *  this process builds screen cl0lm010*/
   /* *  data is from w-s size array cl0lw03*/
   /* *  scrolling is done in cl0l340*/
   /* ***************************************/

  CLXREC.CLXCPROC = "CL0L304"; /* set current process name*/


     /* *************/
     /* set pointers*/
     /* *************/

    /* use clxrec.clxcursz to point to cl0lw03*/
    /* set in cl0l302, 304 and 340*/

  CLXREC.CLXLINEX = 1; /* start top of map*/

  CLXREC.CLXMAPMX = CLXREC.CLXMAXLN[CLXSCRNX]; /* max lines on map*/
    /* may be changed if w/s array ends before map is filled.*/
    /* see below*/

  CL0LW01.CL0LWDNE = "N"; /* not already done*/


     /* ************************/
     /* clear orig values array*/
     /* ************************/

  sysVar.arrayIndex = 1;
  while (sysVar.arrayIndex <= CLXREC.CLXMAXLN[CLXSCRNX]) /* for each map line*/
    CL0LW01.CL0LWORQ[sysVar.arrayIndex] = 0; /* reqst qty*/
    CL0LW01.CL0LWOCQ[sysVar.arrayIndex] = 0; /* clm qty*/
    CL0LW01.CL0LWOVL[sysVar.arrayIndex] = 0; /* clm value*/
    CL0LW01.CL0LWCHK[sysVar.arrayIndex] = "N";
    sysVar.arrayIndex = sysVar.arrayIndex + 1;
  end


     /* ************************************/
     /* move data to map, clear rest of map*/
     /* ************************************/
   /* GET CL0L104*/

  while (CLXREC.CLXLINEX <= CLXREC.CLXMAXLN[CLXSCRNX]) /* scrnx = map 10*/
    if (CLXREC.CLXCURSZ < CLXREC.CLXLSTSZ) /* if not at end of array*/
      if (CL0LW03.SY5SZID[CLXCURSZ] == 0)
        if (CL0LW03.CL0LWDLT[CLXCURSZ] == "X")
          KL0LSS7();
        end
      else
         /* *****************/
         /* move data to map*/
         /* *****************/
        KL0LS50(); /* build each screen line*/
      end
      CLXREC.CLXCURSZ = CLXREC.CLXCURSZ + 1; /* array index*/
      CLXREC.CLXLINEX = CLXREC.CLXLINEX + 1;
    else
       /* ************************************/
       /* at end of array, but not end of map*/
       /* allow user to enter data*/
       /* ************************************/
      if (CL0LW01.CL0LWDNE == "N")
        CL0LW01.CL0LWDNE = "Y";
        CLXREC.CLXMAPMX = CLXREC.CLXLINEX - 1; /* nbr lines used on map*/
      end
      KL0LSS7(); /* clear map line, unprt size*/
      CLXREC.CLXLINEX = CLXREC.CLXLINEX + 1;
    end
  end


     /* **********************************************************/
     /* move product totals to the map,map get shp qty in cl0ls50*/
     /* **********************************************************/

  KL0LM010.SY4IDDSC[12] = "TOTAL";
  KL0LM010.IV4SHPQ[12] = CL0LW01.CL0LWTSH[2];
  KL0LM010.CLRRQTQ[12] = CL0LW01.CLRRQTQ[2];
  KL0LM010.CLRCLMQ[12] = CL0LW01.CLRCLMQ[2];
  KL0LM010.CLAESTVL[12] = CL0LW01.CL0LWTVL[2];


     /* *******************/
     /* release data bases*/
     /* *******************/

  VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
  VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
  sysLib.commit();
  VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value



end // end KL0L304

// map 10 edit pf keys
Function KL0L310()
   /* ************************************************************/
   /* *  validate pf keys                                       **/
   /* *                                                         **/
   /* *  the only keys acted upon at this time are pf 1, 3 & 4  **/
   /* *  and fastpath                                           **/
   /* *                                                         **/
   /* *  the other keys are just verified that they are used    **/
   /* *  by this application.  if the pf key is not recognized, **/
   /* *  the application resets all modified fields to remain   **/
   /* *  modified, then reshows the map with an error message.  **/
   /* *                                                         **/
   /* *  these other pf keys are acted upon after the editing   **/
   /* *  and updating have occured.                             **/
   /* *                                                         **/
   /* ************************************************************/

  CLXREC.CLXCPROC = "CL0L310"; /* set current process name*/


     /* use pa2 to ezeclos, for testing only,*/
   /* BETHS01;*/


      /* *******************************/
      /* check for fastpath option/item*/
      /* *******************************/

      /* same as cl0l110 & cl0l210*/

  if (KL0LM010.CATOAP == " " /* if fastpath appl is cl0l,*/
   || KL0LM010.CATOAP == "KL0L")
    if (KL0LM010.CAITEM != " ") /* and have item -*/
       /* **********************************/
       /* try to find product in curr array*/
       /* **********************************/
       /* ignore color and dimension*/

      sysVar.arrayIndex = 1;
      CL0LW01.CL0LWPRX = 0; /* init product index*/

      while (sysVar.arrayIndex < CLXREC.CLXLSTAX) /* search w/s array*/
        if (KL0LM010.CAITEM == CL0LW02.SY1STNBR[sysVar.arrayIndex])
          CL0LW01.CL0LWPRX = sysVar.arrayIndex; /* hold index for use in cl0l140*/
          sysVar.arrayIndex = 9000; /* force loop end*/
        else
          if (KL0LM010.CAITEM < CL0LW02.SY1STNBR[sysVar.arrayIndex])
            CLXREC.CLXERRF = "Y";
            CLXREC.CLXEDITF = "N"; /* skip map edits*/
            converseLib.validationFailed(208); /* product not found*/
            set KL0LM010.CAITEM cursor, bold;
            KL0LSD1();
                                   /* set fields modified so user no re-key*/
            return;
          else
            sysVar.arrayIndex = sysVar.arrayIndex + 1; /* continue table search*/
          end
        end
      end

      KL0LM010.CAITEM = " "; /* clear map field*/

      return;
    else
       /* *************************************/
       /* next sentence - fastpath not entered*/
       /* *************************************/
    end
  else
     /* *******************************************/
     /* plain, old, ordinary fastpath - just leave*/
     /* *******************************************/
    COMMAREA.CATOAP = KL0LM010.CATOAP; /* jump to next applica*/
    COMMAREA.CAITEM = KL0LM010.CAITEM;
    XPCL002();
    return;
  end


  if (converseVar.eventKey is enter) /* normal 'enter'*/
    return;
  end

  if (converseVar.eventKey is pf1)
    KL0LS01(); /* skip edit/update - exit*/
    return;
  end

  if (converseVar.eventKey is pf3)
    KL0LS03(); /* skip edit, update - exit*/
    return;
  end

  if (converseVar.eventKey is pf4)
    KL0LS04(); /* skip edit, update - exit*/
    return;
  end

  if (converseVar.eventKey is pf5) /* claim header after edit & update*/
    return;
  end

  if (converseVar.eventKey is pf7) /* page back after edit & update*/
    return;
  end

  if (converseVar.eventKey is pf8) /* page forward after edit & update*/
    return;
  end

  if (converseVar.eventKey is pf12) /* edit only*/
    return;
  end

  if (converseVar.eventKey is pf13) /* traffic screen after edit & update*/
    return;
  end

  if (converseVar.eventKey is pf14) /* general ledger screen after edit & update*/
    return;
  end

  if (converseVar.eventKey is pf15) /* product summary list*/
    return;
  end



      /* pf key not valid*/

  converseLib.validationFailed(2); /* pf key not valid*/
  CLXREC.CLXERRF = "Y";
  KL0LSD1(); /* set fields modfd so user no re-key*/
  CLXREC.CLXEDITF = "N"; /* do not edit map, just re-show it*/



end // end KL0L310

// map 10 edit map data
Function KL0L320()
       /* * * **************************************** * **/
     /* *                                                  **/
   /* *      keep this the same as cl0l120 & cl0l220         **/
     /* *                                                  **/
       /* * * **************************************** * **/

   /* ************************************************************/
   /* *     this process handles all edits of screen fields,    **/
   /* *          and any subsequent updating, required by       **/
   /* *          entries into screen cl0lm010                   **/
   /* ************************************************************/
  CLXREC.CLXCPROC = "CL0L320"; /* set current process name*/
  set KL0LM010.CL0LMSEL[1] cursor;

   /* GET CL0L120*/
   /* *******************************************************/
        /* this process handles all edits of screen fields,*/

    /* do individual field edits first,*/
      /* proceed from bottom right to top left*/
    /* do field combination edits, if applicable*/

    /* when error free, use map data to add/change array*/

   /* *******************************************************/

  CLXREC.CLXLINEX = 1;

  while (CLXREC.CLXLINEX <= CLXREC.CLXMAXLN[CLXSCRNX])
    CL0LW01.CL0LWINX = CLXREC.CLXCURSZ - 1 - CLXREC.CLXMAPMX;
    CL0LW01.CL0LWINX = CL0LW01.CL0LWINX + CLXREC.CLXLINEX;

    if (CL0LW01.CL0LWINX < 1)
      CL0LW01.CL0LWINX = 1;
    end

    CL0LW01.CL0LWERR[CLXLINEX] = "N";

    set KL0LM010.CL0LMSEL[CLXLINEX] initialAttributes;
    if (CL0LW01.CL0LW1WN[CLXLINEX] == "N")
      set KL0LM010.SY4IDDSC[CLXLINEX] initialAttributes;
    end

    if (KL0LM010.SY4IDDSC[CLXLINEX] is modified)
      CL0LW01.CL0LWSHP[CLXLINEX] = "N";
      CL0LW01.CL0LW1WN[CLXLINEX] = "N";
      if (KL0LM010.SY4IDDSC[CLXLINEX] == " ")
        KL0LM010.SY4IDDSC[CLXLINEX] = CL0LW03.SY4IDDSC[CL0LWINX];
      end
      if (KL0LM010.SY4IDDSC[CLXLINEX] != " ")
        KL0LSE9();
      end
      if (CL0LW01.CL0LWERR[CLXLINEX] == "Y")
        set KL0LM010.CL0LMSEL[CLXLINEX] cursor, modified, bold;
      end
    end
    if (KL0LM010.CL0LMSEL[CLXLINEX] == "C"
     || KL0LM010.CL0LMSEL[CLXLINEX] == "D")
      sysVar.arrayIndex = 1;
      while (sysVar.arrayIndex < CLXREC.CLXLSTSZ)
        if (CL0LW03.SY5SZID[CL0LWINX] == CL0LW03.SY5SZID[sysVar.arrayIndex]
         && CL0LW03.SY5SZID[sysVar.arrayIndex] != 0
         && sysVar.arrayIndex != CL0LW01.CL0LWINX)
          if (KL0LM010.CL0LMSEL[CLXLINEX] == CL0LW03.CLICRDFL[sysVar.arrayIndex])
            converseLib.validationFailed(209);
            set KL0LM010.CL0LMSEL[CLXLINEX] cursor, modified, bold;
            set KL0LM010.SY4IDDSC[CLXLINEX] modified, bold;
            CLXREC.CLXERRF = "Y";
            CL0LW01.CL0LWERR[CLXLINEX] = "Y";
            sysVar.arrayIndex = 9000;
          else
            if (CL0LW03.CLICRDFL[sysVar.arrayIndex] == " ")
              CL0LW01.CL0LWIEX = 1;
              while (CL0LW01.CL0LWIEX < 12)
                if (KL0LM010.SY4IDDSC[CLXLINEX] == KL0LM010.SY4IDDSC[CL0LWIEX]
                 && CLXREC.CLXLINEX != CL0LW01.CL0LWIEX)
                  if (KL0LM010.CL0LMSEL[CLXLINEX] == KL0LM010.CL0LMSEL[CL0LWIEX]
                   || KL0LM010.CL0LMSEL[CL0LWIEX] == " ")
                    converseLib.validationFailed(209);
                    set KL0LM010.CL0LMSEL[CLXLINEX] cursor, modified, bold;
                    set KL0LM010.SY4IDDSC[CLXLINEX] modified, bold;
                    CLXREC.CLXERRF = "Y";
                    CL0LW01.CL0LWERR[CLXLINEX] = "Y";
                    CL0LW01.CL0LWIEX = 12;
                    sysVar.arrayIndex = 9000;
                  end
                end
                CL0LW01.CL0LWIEX = CL0LW01.CL0LWIEX + 1;
              end
            end
          end
        end
        sysVar.arrayIndex = sysVar.arrayIndex + 1;
      end
    end
    CLXREC.CLXLINEX = CLXREC.CLXLINEX + 1;
  end

     /* *******************************************/
     /* loop from bottom to top, edit data entered*/
     /* *******************************************/

    /* note - there may be 'added' product lines, so*/
           /* last data on map may not be equal to clxcursz,*/
           /* so add in clxlinex to cl0lwinx value.*/

           /* use cl0lwinx as pointer to array - kept in sync*/
           /* with clxlinex as it goes backwards through map*/
           /* pointing to existing array entry,*/
           /* or new array entries.*/

  CLXREC.CLXLINEX = CLXREC.CLXMAXLN[CLXSCRNX];

  while (CLXREC.CLXLINEX > 0)
     /* ***********************************************************/
     /* cursz - 1 = last array entry moved to map,*/
     /* last array entry - mapmx =  1 before array entry put on map*/
     /* 1 before ay entry + linex = current array entry for linex.*/
     /* ***********************************************************/
    CL0LW01.CL0LWINX = CLXREC.CLXCURSZ - 1 - CLXREC.CLXMAPMX;
    CL0LW01.CL0LWINX = CL0LW01.CL0LWINX + CLXREC.CLXLINEX;

    if (CL0LW01.CL0LWINX < 1)
      CL0LW01.CL0LWINX = 1;
    end

    if (CL0LW01.CL0LWERR[CLXLINEX] == "Y")
      if (KL0LM010.CLRRQTQ[CLXLINEX] is modified)
        set KL0LM010.CLRRQTQ[CLXLINEX] modified;
      end
      if (KL0LM010.CLRCLMQ[CLXLINEX] is modified)
        set KL0LM010.CLRCLMQ[CLXLINEX] modified;
      end
      if (KL0LM010.CLKPRCFF[CLXLINEX] is modified)
        set KL0LM010.CLKPRCFF[CLXLINEX] modified;
      end
      if (KL0LM010.CLNGRPRC[CLXLINEX] is modified)
        set KL0LM010.CLNGRPRC[CLXLINEX] modified;
      end
      if (KL0LM010.CL0LMSEL[CLXLINEX] is modified)
        set KL0LM010.CL0LMSEL[CLXLINEX] modified;
      end
    else
      if (CL0LW01.CL0LWINX >= CL0LW03.CL0LWASZ)
        converseLib.validationFailed(412);
        CL0LW01.CL0LWERR[CLXLINEX] = "Y";
        CLXREC.CLXERRF = "Y";
        set KL0LM010.CL0LMSEL[CLXLINEX] cursor, modified, bold;
      end

      if (KL0LM010.CLICRDFL[CLXLINEX] == " "
       && KL0LM010.SY4IDDSC[CLXLINEX] == " "
       && KL0LM010.IV4SHPQ[CLXLINEX] == 0
       && KL0LM010.IV4GUP[CLXLINEX] == 0
       && KL0LM010.CLRRQTQ[CLXLINEX] == 0
       && KL0LM010.CLRCLMQ[CLXLINEX] == 0
       && KL0LM010.CLKPRCFF[CLXLINEX] == " "
       && KL0LM010.CLAESTVL[CLXLINEX] == 0)
        if (KL0LM010.CL0LMSEL[CLXLINEX] != " "
         && KL0LM010.CL0LMSEL[CLXLINEX] != "CA"
         && KL0LM010.CL0LMSEL[CLXLINEX] != "DA"
         && KL0LM010.CL0LMSEL[CLXLINEX] != "RC"
         && KL0LM010.CL0LMSEL[CLXLINEX] != "RD")
          KL0LM010.CL0LMSEL[CLXLINEX] = " ";
        end
      end

      if (KL0LM010.CL0LMSEL[CLXLINEX] == " "
       && KL0LM010.CLICRDFL[CLXLINEX] == " "
       && KL0LM010.SY4IDDSC[CLXLINEX] == " "
       && KL0LM010.IV4SHPQ[CLXLINEX] == 0
       && KL0LM010.IV4GUP[CLXLINEX] == 0
       && KL0LM010.CLRRQTQ[CLXLINEX] == 0
       && KL0LM010.CLRCLMQ[CLXLINEX] == 0
       && KL0LM010.CLKPRCFF[CLXLINEX] == " "
       && KL0LM010.CLAESTVL[CLXLINEX] == 0)
        set KL0LM010.CL0LMSEL[CLXLINEX] initialAttributes;
        CL0LW01.CL0LWMOD[CLXLINEX] = "N";
        CL0LW03.CL0LWCHF[CL0LWINX] = " ";
      else

        if (KL0LM010.CLNGRPRC[CLXLINEX] is modified)
          KL0LSE1(); /* ** claim price ***/
        else
          if (CL0LW01.CL0LWINQ != "Y") /* reset warning attributes*/
            set KL0LM010.CLNGRPRC[CLXLINEX] initialAttributes;
          end
        end

        if (CL0LW01.CL0LWINQ != "Y")
          if (KL0LM010.CLKPRCFF[CLXLINEX] == " ")
            if (KL0LM010.CL0LMSEL[CLXLINEX] == "C"
             || KL0LM010.CL0LMSEL[CLXLINEX] == "D")
              KL0LSE8();
            end
          end
        end

        if (KL0LM010.CLKPRCFF[CLXLINEX] is modified)
          KL0LSE8(); /* ** price from flag ***/
        else
          if (CL0LW01.CL0LWINQ != "Y") /* reset warning attributes*/
            set KL0LM010.CLKPRCFF[CLXLINEX] initialAttributes;
          end
        end

        if (KL0LM010.CLRCLMQ[CLXLINEX] is modified)
          KL0LSE3(); /* ** claim quantity ***/
        else
          if (CL0LW01.CL0LWINQ != "Y") /* reset warning attributes*/
            set KL0LM010.CLRCLMQ[CLXLINEX] initialAttributes;
          end
        end

        if (KL0LM010.CLRRQTQ[CLXLINEX] is modified)
          KL0LSE4(); /* ** customer requested qty ***/
        else
          if (CL0LW01.CL0LWINQ != "Y") /* reset warning attributes*/
            set KL0LM010.CLRRQTQ[CLXLINEX] initialAttributes;
          end
        end

        if (CL0LW01.CL0LWINQ != "Y"
         && KL0LM010.CL0LMSEL[CLXLINEX] != "X")
          if (KL0LM010.CL0LMSEL[CLXLINEX] == "C"
           || KL0LM010.CL0LMSEL[CLXLINEX] == "D"
           || CL0LW03.CLICRDFL[CL0LWINX] == "C"
           || CL0LW03.CLICRDFL[CL0LWINX] == "D")
            if (KL0LM010.CLRRQTQ[CLXLINEX] == 0)
              converseLib.validationFailed(231);
              set KL0LM010.CLRRQTQ[CLXLINEX] cursor, modified, bold;
              CL0LW01.CL0LWERR[CLXLINEX] = "Y";
              CLXREC.CLXERRF = "Y";
            else
              set KL0LM010.CLRRQTQ[CLXLINEX] initialAttributes;
            end
          end
        end

        if (KL0LM010.CL0LMSEL[CLXLINEX] == "C"
         || KL0LM010.CL0LMSEL[CLXLINEX] == "D")
          if (KL0LM010.SY4IDDSC[CLXLINEX] == " ")
            set KL0LM010.SY4IDDSC[CLXLINEX] cursor, modified, bold;
            CLXREC.CLXERRF = "Y";
            CL0LW01.CL0LWERR[CLXLINEX] = "Y";
            converseLib.validationFailed(220);
          else
            if (CL0LW01.CL0LWINQ != "Y")
              set KL0LM010.SY4IDDSC[CLXLINEX] initialAttributes;
            end
          end
        end

        if (KL0LM010.CL0LMSEL[CLXLINEX] == " "
         && KL0LM010.CLICRDFL[CLXLINEX] == " "
         && KL0LM010.CL0LMSEL[1] != "CA"
         && KL0LM010.CL0LMSEL[1] != "DA")
          if (KL0LM010.CLRCLMQ[CLXLINEX] > 0)
            set KL0LM010.CL0LMSEL[CLXLINEX] cursor, modified, bold;
            CLXREC.CLXERRF = "Y";
            CL0LW01.CL0LWERR[CLXLINEX] = "Y";
            converseLib.validationFailed(8);
          end
          if (KL0LM010.CLRRQTQ[CLXLINEX] > 0)
            set KL0LM010.CL0LMSEL[CLXLINEX] cursor, modified, bold;
            CLXREC.CLXERRF = "Y";
            CL0LW01.CL0LWERR[CLXLINEX] = "Y";
            converseLib.validationFailed(8);
          end
        end

         /* *****************************/
         /* if size added, do more edits*/
         /* *****************************/
        if (CL0LW03.CL0LWCHF[CL0LWINX] == "A")
          if (KL0LM010.CLICRDFL[CLXLINEX] == " ") /* no action given*/
            if (KL0LM010.CL0LMSEL[CLXLINEX] == " "
             || KL0LM010.CL0LMSEL[CLXLINEX] == "CA"
             || KL0LM010.CL0LMSEL[CLXLINEX] == "DA")
               /* AND CL0LM010.CL0LMSEL(1) NE 'CA';*/
               /* AND CL0LM010.CL0LMSEL(1) NE 'DA';*/
               /* must have select c/d/x*/
              converseLib.validationFailed(223); /* new size requires sel cd c/d/x*/
              CLXREC.CLXERRF = "Y";
              CL0LW01.CL0LWERR[CLXLINEX] = "Y";
              set KL0LM010.CL0LMSEL[CLXLINEX] cursor, modified, bold;
              set KL0LM010.SY4IDDSC[CLXLINEX] bold;
            end
          end
        end

        if (KL0LM010.CL0LMSEL[CLXLINEX] is modified)
          KL0LSEA(); /* ** select code ***/
        else
          if (CL0LW01.CL0LWINQ != "Y") /* reset warning attributes*/
            set KL0LM010.CL0LMSEL[CLXLINEX] initialAttributes;
          end
        end

        if (CL0LW01.CL0LWERR[CLXLINEX] != "Y"
         && CL0LW01.CL0LWMOD[CLXLINEX] == "Y")

          KL0LS81();

           /* *************************************************/
           /* combination edits for single line*/
           /* cl0lwchf set in each edit, when the data is good*/
           /* *************************************************/

          if (CL0LW03.CL0LWCHF[CL0LWINX] == "Y" /* if line changed*/
           || CL0LW03.CL0LWCHF[CL0LWINX] == "A")
            CL0LW01.CL0LWUPD = "Y";
             /* ****************************************************/
             /* if customer claims qty eq 0, deflt to requested qty*/
             /* ****************************************************/
            if (CL0LW03.CLRCLMQ[CL0LWINX] == 0)
              if (CL0LW03.CLICRDFL[CL0LWINX] == "C"
               || KL0LM010.CLICRDFL[CLXLINEX] == "C")
                if (KL0LM010.CLRRQTQ[CLXLINEX] > 0)
                  CL0LW03.CLRCLMQ[CL0LWINX] = KL0LM010.CLRRQTQ[CLXLINEX];
                  KL0LM010.CLRCLMQ[CLXLINEX] = CL0LW03.CLRCLMQ[CL0LWINX] * -1;
                else
                  KL0LM010.CLRCLMQ[CLXLINEX] = KL0LM010.CLRRQTQ[CLXLINEX];
                  CL0LW03.CLRCLMQ[CL0LWINX] = KL0LM010.CLRCLMQ[CLXLINEX] * -1;
                end
              else
                KL0LM010.CLRCLMQ[CLXLINEX] = KL0LM010.CLRRQTQ[CLXLINEX];
                CL0LW03.CLRCLMQ[CL0LWINX] = KL0LM010.CLRCLMQ[CLXLINEX];
              end
            end

            if (CL0LW02.IVANBLFL == "Y") /* net bill flag*/
              CL0LW01.CLAESTVL = CL0LW03.CLNNTPRC[CL0LWINX] * CL0LW03.CLRCLMQ[CL0LWINX];
            else
              CL0LW01.CLAESTVL = CL0LW03.CLNGRPRC[CL0LWINX] * CL0LW03.CLRCLMQ[CL0LWINX];
            end

            if (CL0LW03.CLICRDFL[CL0LWINX] == "C")
              if (CL0LW01.CLAESTVL > 0)
                CL0LW01.CLAESTVL = CL0LW01.CLAESTVL * -1;
              end
            end

            KL0LM010.CLAESTVL[CLXLINEX] = CL0LW01.CLAESTVL;

            KL0LSDT(); /* total qty & value changes*/

            CL0LW01.CL0LWMOD[CLXLINEX] = "N";

          end
        end
      end
    end

    CLXREC.CLXLINEX = CLXREC.CLXLINEX - 1;
  end


     /* *************************************/
     /* move changed totals to bottom of map*/
     /* *************************************/

  KL0LM010.SY4IDDSC[12] = "TOTAL";
  KL0LM010.IV4SHPQ[12] = CL0LW01.CL0LWTSH[2];
  KL0LM010.CLRRQTQ[12] = CL0LW01.CLRRQTQ[2];
  KL0LM010.CLRCLMQ[12] = CL0LW01.CLRCLMQ[2];
  KL0LM010.CLAESTVL[12] = CL0LW01.CL0LWTVL[2];
  set KL0LM010.CLRRQTQ[12] protect;
  set KL0LM010.CLRCLMQ[12] protect;


     /* *******************/
     /* release data bases*/
     /* *******************/

  VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
  VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
  sysLib.commit();
  VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value



end // end KL0L320

// map 10 update data bases
Function KL0L330()
   /* GET CL0L130*/
   /* *************************************************/
   /* *  update data base(s) as needed*/
   /* **/
   /* *  look at each size line,*/
   /* *    if changed*/
   /* *       update data base*/
   /* *    if added*/
   /* *       add to data base*/
   /* *    if deleted*/
   /* *       delete one size from data base*/
   /* **************************************************/

  CLXREC.CLXCPROC = "CL0L330"; /* set current process name*/

  sysVar.arrayIndex = 1;
  while (sysVar.arrayIndex < 12)
    CL0LW01.CL0LWCHK[sysVar.arrayIndex] = "N";
    sysVar.arrayIndex = sysVar.arrayIndex + 1;
  end

     /* **************************************************/
     /* check all sizes to see if have mix of db and cr -*/
     /* then move 'b' to product w02 array cr/db code*/
     /* **************************************************/

  sysVar.arrayIndex = 1;
  CL0LW01.CL0LWHVC = "N";
  CL0LW01.CL0LWHVD = "N";
  CL0LW01.CL0LWVP = "N";
  CL0LW01.CL0LWPRC = 0;

  while (sysVar.arrayIndex < CLXREC.CLXLSTSZ)
    if (CL0LW03.CL0LMSEL[sysVar.arrayIndex] == "X")
      /* next sentence*/
    else
      if (CL0LW03.CLICRDFL[sysVar.arrayIndex] == "C")
        CL0LW01.CL0LWHVC = "Y";
        CL0LW02.CLICRDFL[CL0LWCAX] = "C";
      else
        if (CL0LW03.CLICRDFL[sysVar.arrayIndex] == "D")
          CL0LW01.CL0LWHVD = "Y";
          CL0LW02.CLICRDFL[CL0LWCAX] = "D";
        end
      end
    end

    if (CL0LW03.CL0LMSEL[sysVar.arrayIndex] != "X"
     && CL0LW03.CLICRDFL[sysVar.arrayIndex] != " ")
      if (CL0LW01.CL0LWPRC == 0)
        CL0LW01.CL0LWPRC = CL0LW03.CLNGRPRC[sysVar.arrayIndex];
      else
        if (CL0LW03.CLNGRPRC[sysVar.arrayIndex] != CL0LW01.CL0LWPRC)
          CL0LW01.CL0LWVP = "Y";
        end
      end
      if (CL0LW01.CL0LWVP == "N")
        CL0LW02.CLKPRCFF[CL0LWCAX] = CL0LW03.CLKPRCFF[sysVar.arrayIndex];
        CL0LW02.CLNGRPRC[CL0LWCAX] = CL0LW03.CLNGRPRC[sysVar.arrayIndex];
        CL0LW02.CLNNTPRC[CL0LWCAX] = CL0LW03.CLNNTPRC[sysVar.arrayIndex];
      end
    end
    sysVar.arrayIndex = sysVar.arrayIndex + 1;
  end

  CL0LW02.OP2PRCVF[CL0LWCAX] = CL0LW01.CL0LWVP;

  if (CL0LW01.CL0LWHVC == "Y"
   && CL0LW01.CL0LWHVD == "Y")
    CL0LW02.CLICRDFL[CL0LWCAX] = "B";
  end


     /* update one screen's data before go to next screen*/
     /* unless credit/debit all, then update all records*/

  CL0LW01.CL0LWINX = 1; /* index to map*/

  CL0LW01.CL0LWHLD = CLXREC.CLXCURSZ;
  CLXREC.CLXCURSZ = 1; /* loop all in array w03*/
  CL0LW01.CL0LWEND = CLXREC.CLXLSTSZ; /* end 'while'*/

  CL0LW01.CL0LWCTR = 0;
  while (CLXREC.CLXCURSZ < CL0LW01.CL0LWEND)
    if (CL0LW03.CL0LMSEL[CLXCURSZ] != "X")
      if (CL0LW03.CLNGRPRC[CLXCURSZ] != CL0LW02.CLNGRPRC[CL0LWCAX]
       || CL0LW03.CLNNTPRC[CLXCURSZ] != CL0LW02.CLNNTPRC[CL0LWCAX])
        if (CL0LW02.CLNGRPRC[CL0LWCAX] != 0
         || CL0LW02.CLNNTPRC[CL0LWCAX] != 0)
          CL0LW01.CL0LWVP = "Y";
        end
      end
    end

    if (CL0LW03.CL0LWCHF[CLXCURSZ] == "Y")
      if (CL0LW03.CL0LMSEL[CLXCURSZ] == "X")
         /* ************/
         /* delete size*/
         /* ************/
        CL0LW01.CL0LWCTR = CL0LW01.CL0LWCTR + 1;
        KL0LSDS(); /* delete data base for 1 size*/
        if (converseVar.validationMsgNum == 18
         || converseVar.validationMsgNum == 4)
          return;
        end
      else
        if (CL0LW03.CLICRDFL[CLXCURSZ] == "C"
         || CL0LW03.CLICRDFL[CLXCURSZ] == "D")
           /* *******************/
           /* change or add size*/
           /* *******************/
          KL0LSUP(); /* update data base*/

          if (converseVar.validationMsgNum == 18
           || converseVar.validationMsgNum == 4)
             /* have change count error, re-show map*/
            CLXREC.CLXCURSZ = CLXREC.CLXCURSZ - CL0LW01.CL0LWINX + 1;
             /* reset array pointer to map line 1*/
            return;
          end
           /* ************************/
           /* update prod array flags*/
           /* ************************/
          KL0LSPA(); /* move sz info to prod array w02*/
        end
      end
    else
      if (CL0LW03.CL0LWCHF[CLXCURSZ] == "A") /* if added product size*/
        if (CL0LW03.CLICRDFL[CLXCURSZ] == "C"
         || CL0LW03.CLICRDFL[CLXCURSZ] == "D")
           /* *********/
           /* add size*/
           /* *********/
          KL0LSAD(); /* add record*/
           /* ************************/
           /* update prod array flags*/
           /* ************************/
          KL0LSPA(); /* move sz info to prod array w02*/
        end
      end
      if (CL0LW03.CLICRDFL[CLXCURSZ] == " ")
        CL0LW01.CL0LWCTR = CL0LW01.CL0LWCTR + 1;
      end
    end

    CLXREC.CLXCURSZ = CLXREC.CLXCURSZ + 1;
    CL0LW01.CL0LWINX = CL0LW01.CL0LWINX + 1;
  end

  CL0LW01.CL0LWEND = CLXREC.CLXLSTSZ - 1;

  if (CL0LW01.CL0LWCTR == CL0LW01.CL0LWEND)
    CL0LW02.CL0LMSEL[CLXARAYX] = "X";
    CL0LW02.CL0LMLVL[CLXARAYX] = " ";
    CL0LW02.OP2PRCVF[CLXARAYX] = " ";
    CL0LW02.CL0LWUSI[CLXARAYX] = "Y";
    CL0LW01.CL0LWUPD = "Y";
  end

  if (CL0LW01.CL0LWAUP == "Y")
    KL0LSAU();
    CL0LW01.CL0LWAUP = "N";
  end


      /* ***************************************/
      /* if credit all/debit all, reset pointer*/
      /* ***************************************/

  if (CL0LW01.CL0LWALL == "Y")
    CL0LW01.CL0LWALL = "N";
  end

  sysVar.arrayIndex = 1;
  while (sysVar.arrayIndex < 12)
    if (KL0LM010.CL0LMSEL[sysVar.arrayIndex] == "X")
      KL0LM010.CLRRQTQ[sysVar.arrayIndex] = 0;
      KL0LM010.CLRCLMQ[sysVar.arrayIndex] = 0;
      KL0LM010.CLAESTVL[sysVar.arrayIndex] = 0;
      KL0LM010.SY4IDDSC[sysVar.arrayIndex] = " ";
      KL0LM010.IV4SHPQ[sysVar.arrayIndex] = 0;
      KL0LM010.CLKPRCFF[sysVar.arrayIndex] = " ";
      KL0LM010.IV4GUP[sysVar.arrayIndex] = 0;
      KL0LM010.CLNGRPRC[sysVar.arrayIndex] = 0;
      KL0LM010.CL0LMSEL[sysVar.arrayIndex] = " ";
      KL0LM010.CLICRDFL[sysVar.arrayIndex] = " ";
    end
    sysVar.arrayIndex = sysVar.arrayIndex + 1;
  end

  CLXREC.CLXCURSZ = CL0LW01.CL0LWHLD;


      /* ******************/
      /* release data base*/
      /* ******************/

  VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
  VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
  sysLib.commit();
  VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
   /* release data bases*/



end // end KL0L330

// map 10 pf key action
Function KL0L340()
   /* ********************************************************/
   /* *  act upon pf keys*/
   /* **/
   /* *  pf 1, 3, and 4 were acted upon in cl0l310*/
   /* **/
   /* *  enter and pf 15 are acted upon here, after editing*/
   /* *  and updating have occured.  other pf keys are done*/
   /* *  in cl0l140, same as for maps 1 and 5.*/
   /* **/
   /* ********************************************************/

  CLXREC.CLXCPROC = "CL0L340"; /* set current process name*/


  if (converseVar.eventKey is enter)
     /* ****************************************************/
     /* test for entered product in caitem, re-start detail*/
     /* ****************************************************/
    if (CL0LW01.CL0LWPRX != 0) /* if product index was set in cl0l310*/
      CLXREC.CLXBLDAY = "Y"; /* build array for new product*/
      CLXREC.CLXBLDSC = "Y"; /* build screen*/
      CL0LW01.CL0LWCAX = CL0LW01.CL0LWPRX;
       /* reset prod summary pointer to lowest prod # viewed*/
      if (CL0LW01.CL0LWCAX < CLXREC.CLXARAYX)
        CLXREC.CLXARAYX = CL0LW01.CL0LWCAX;
      end
      CL0LW01.CL0LWPRX = 0;
      return;
    end

    if (KL0LM010 is modified)
      return;
    end

    if (CL0LW01.CL0LWESP == "N") /* if not end of selected prods*/
      /* GET CL0LS00*/
       /* *******************************************/
       /* find next selected product to show on detl*/
       /* *******************************************/
      CL0LW01.CL0LWINX = CL0LW01.CL0LWCAX; /* hold prod index*/

      sysVar.arrayIndex = 1;
      CL0LW01.CL0LWCAX = 0; /* init to 0*/

      while (sysVar.arrayIndex < CLXREC.CLXLSTAX)
        if (CL0LW02.CL0LMSEL[sysVar.arrayIndex] == "S") /* check each product in array*/
          if (CL0LW02.CL0LMLVL[sysVar.arrayIndex] == "P") /* if worked at prod level*/
            CL0LW02.CL0LMSEL[sysVar.arrayIndex] = " "; /* can't select product*/
          else
            CL0LW01.CL0LWCAX = sysVar.arrayIndex; /* hold pointer for detail map*/
            sysVar.arrayIndex = 9000;
          end
        end
        sysVar.arrayIndex = sysVar.arrayIndex + 1;
      end

      if (CL0LW01.CL0LWCAX != 0) /* if found a 's'elect,*/
        CLXREC.CLXBLDAY = "Y"; /* build map 10 size array*/
        CLXREC.CLXBLDSC = "Y"; /* build map 10*/
        return;
      else
         /* cl0lwesp set to 'n' in cl0l104/cl0ls00*/
        CL0LW01.CL0LWCAX = CL0LW01.CL0LWINX; /* restore index*/
        CLXREC.CLXARAYX = CL0LW01.CL0LWFST;
        CL0LW01.CL0LWESP = "Y";
        CLXREC.CLXBLDSC = "Y";
        CLXREC.CLXEOSF = "Y";
        CLXREC.CLXCSCRN = "KL0LM001";
        return;
      end
    end

     /* *******************************************/
     /* no more selected products, return to map 1*/
     /* don't re-build array, restart at arayx =*/
     /* first product selected*/
     /* *******************************************/
    CLXREC.CLXBLDSC = "Y";
    CLXREC.CLXEOSF = "Y";
    CLXREC.CLXARAYX = CL0LW01.CL0LWFST;
    CLXREC.CLXCSCRN = "KL0LM001";
    return;

  end


     /* **********************************************/
     /* pf 15 skips any other selected, but not shown*/
     /* products, and returns now to map 1*/
     /* **********************************************/

  if (converseVar.eventKey is pf15)
    CLXREC.CLXCSCRN = "KL0LM001"; /* next screen, prod summary*/
    CLXREC.CLXBLDSC = "Y";
    CLXREC.CLXEOSF = "Y";
    XPCL002();
    return;
  end


     /* **************************************************/
     /* all other pf keys follow same flow as map 1 and 5*/
     /* **************************************************/

  KL0L140(); /* other  pf keys, same as map 1/5*/



end // end KL0L340

// 'enter' action
Function KL0LS00()
   /* ************************/
   /* *  act upon 'enter' key*/
   /* **/
   /* ************************/

     /* ***************************************************/
     /* test for entered product in caitem, re-start summary*/
     /* ***************************************************/

  TA1REC.TA1LOCAT[2] = "CL0LS00";
  if (CL0LW01.CL0LWPRX != 0) /* if product index was set in cl0l110*/
    CLXREC.CLXBLDSC = "Y";
    CLXREC.CLXARAYX = CL0LW01.CL0LWPRX;
    CL0LW01.CL0LWPRX = 0;
    return;
  end


     /* *******************************************/
     /* test for selected line items, go to detail*/
     /* *******************************************/
  sysVar.arrayIndex = 1;
  CL0LW01.CL0LWCAX = 0; /* init to 0*/

  while (sysVar.arrayIndex < CLXREC.CLXLSTAX)
    if (CL0LW02.CL0LMSEL[sysVar.arrayIndex] == "S") /* check each product in array*/
      if (CL0LW02.CL0LMLVL[sysVar.arrayIndex] == "P")
        CL0LW02.CL0LMSEL[sysVar.arrayIndex] = " ";
      else
        CL0LW01.CL0LWCAX = sysVar.arrayIndex; /* hold pointer for detail map*/
        sysVar.arrayIndex = 9000;
      end
    end
    sysVar.arrayIndex = sysVar.arrayIndex + 1;
  end

  if (CL0LW01.CL0LWCAX != 0) /* if found a 's'elect,*/
    CLXREC.CLXCSCRN = "KL0LM010"; /* go to detail map 10*/
     /* hold pointer to restart map 1/5 display, if return*/
    CLXREC.CLXARAYX = CL0LW01.CL0LWCAX;
    CL0LW01.CL0LWESP = "N"; /* not end of selected prods*/
    CLXREC.CLXBLDAY = "Y"; /* build map 10 size array*/
    CLXREC.CLXBLDSC = "Y"; /* build screen*/
    CLXREC.CLXEOSF = "Y"; /* end of map 1/5*/
    return;
  end


     /* **********************************************************/
     /* no product was selected -*/
     /* test for entrd ivc, re-start summry if map.ivc ne w02.ivc*/
     /* when entered, process cl0l102 is expecting to have*/
     /* already read the next invoice.  so we must read it here.*/
     /* no processing is done with it until cl0l102*/
     /* **********************************************************/

  CLXREC.CLXORDIV = 0;

     /* check both maps 1 & 5 for changed invoice*/

  if (KL0LM001.IV0IVCID != CL0LW02.IV0IVCID)
    CLXREC.CLXORDIV = KL0LM001.IV0IVCID;
  end

  if (KL0LM005.IV0IVCID != CL0LW02.IV0IVCID)
    CLXREC.CLXORDIV = KL0LM005.IV0IVCID;
  end

  if (CLXREC.CLXORDIV != 0) /* have new invoice nbr*/
    CLBREC.IV0IVCID = 0; /* force the 'while ne' below*/
    CLBREC.CLACLMNB = CLAREC.CLACLMNB; /* current claim nbr*/
    CLBREC.CLBPMIVC = "*"; /* get all invoices*/

    call "IO1180" ("S3", SQLCA, CLBREC) {isNoRefresh = yes, isExternal = yes};
                                   /* sel set invc/claim xref*/

    CL0LW01.CL0LWIEF = "N"; /* init end of file*/

    if (SQLCA.VAGen_SQLCODE == 0) /* if have invoices on this claim*/
       /* ****************************/
       /* get user selected invoice*/
       /* ****************************/
      while (CL0LW01.CL0LWIEF == "N"
       && CLXREC.CLXORDIV != CLBREC.IV0IVCID)

        call "IO1180" ("N3", SQLCA, CLBREC) {isNoRefresh = yes, isExternal = yes}; /* fst inv on claim*/
         /* note - now ezesqcod is for the fetch, not the select set*/

        if (SQLCA.VAGen_SQLCODE == 0)
           /* return to 'while' test for equality*/
        else
          if (SQLCA.VAGen_SQLCODE == 100) /* if no invoices in invc/claim xref*/
             /* *********************************/
             /* no match on invoice found, error*/
             /* note - this shouldn't happen*/
             /* because edit was done in cl0l120*/
             /* *********************************/
            call "IO1180" ("C3", SQLCA, CLBREC) {isNoRefresh = yes, isExternal = yes}; /* close set*/
            CL0LW01.CL0LWIEF = "Y"; /* mark e.o.f. on inv/clm xref*/
            CL0LW02.IV0PARTN = 0; /* no invoice available*/
            CL0LW02.IV0IVCID = 0;
            converseLib.validationFailed(91); /* invoice not attached to claim*/
            CLXREC.CLXERRF = "Y"; /* array index = 1*/
            return;
          else
            TA1REC.TA1DBASE = "DCLAIM";
            TA1REC.TA1TBLVU = "VCLIVX01";
            XPCL010(); /* abend*/
          end
        end
      end
      call "IO1180" ("C3", SQLCA, CLBREC) {isNoRefresh = yes, isExternal = yes}; /* close set*/

      if (CL0LW01.CL0LWIEF == "N") /* not end of file*/
         /* found invoice*/
        CLXREC.CLXBLDAY = "Y";
        CLXREC.CLXBLDSC = "Y";
        CL0LW01.CL0LWLST = CLBREC.IV0IVCID;
        return;
      end
    else
      TA1REC.TA1DBASE = "DCLAIM"; /* set not open*/
      TA1REC.TA1TBLVU = "VCLIVX01";
      XPCL010(); /* abend*/
    end
  end


    /* ***********************************************************/
    /* test to see if clbrec needs to be updated*/
    /* ***********************************************************/

  if (CL0LW01.CL0LWBUP == "Y"
   && CL0LW02.IV0IVCID != 0
   && CL0LW02.IV0PARTN != " ")
    CLBREC.CLACLMNB = CLAREC.CLACLMNB;
    CLBREC.IV0IVCID = CL0LW02.IV0IVCID;
    CLBREC.IV0PARTN = CL0LW02.IV0PARTN;
    call "IO1180" ("S ", SQLCA, CLBREC) {isNoRefresh = yes, isExternal = yes};

    if (SQLCA.VAGen_SQLCODE != 0)
      TA1REC.TA1DBASE = "DCLAIM";
      TA1REC.TA1TBLVU = "XQCLBI0";
      XPCL010();
    end

    CLBREC.CLBSRIND = CL0LW01.CLBSRIND;

    call "IO1180" ("U ", SQLCA, CLBREC) {isNoRefresh = yes, isExternal = yes};

    if (SQLCA.VAGen_SQLCODE != 0)
      TA1REC.TA1DBASE = "DCLAIM";
      TA1REC.TA1TBLVU = "XQCLBR0";
      XPCL010();
    end

  end

  CL0LW01.CL0LWBUP = "N";

    /* *****************************************************/
    /* if screen Kl0lm001 has been modified, return to same*/
    /* screen until updating is complete.*/
    /* *****************************************************/
  if (CLXREC.CLXSCRNX == 1) /* working with KL0LM001*/
    if (KL0LM001 is modified)
      CLXREC.CLXBLDSC = "Y";
      CLXREC.CLXARAYX = CL0LW01.CL0LWFST;
      if (CLXREC.CLXARAYX < 1)
        CLXREC.CLXARAYX = 1;
      end
      return;
    end
  else
    if (CLXREC.CLXSCRNX == 2) /* working with KL0LM005*/
      if (KL0LM005 is modified)
        CLXREC.CLXBLDSC = "Y";
        CLXREC.CLXARAYX = CL0LW01.CL0LWFST;
        if (CLXREC.CLXARAYX < 1)
          CLXREC.CLXARAYX = 1;
        end
        return;
      end
    end
  end

    /* ***********************************************************/
    /* test for next invoice on ivc/clm xref, to bld array & show*/
    /* ***********************************************************/

  if (CL0LW01.CL0LWIEF == "N")
    CLXREC.CLXBLDAY = "Y";
    CLXREC.CLXBLDSC = "Y";
    return;
  end


     /* ******************************************/
     /* other possible actions on the 'enter' key*/
     /* all leave this application*/
     /* ******************************************/

   /* MOVE 'Y' TO CLXREC.CLXEOSF      ; force appl end*/
   /* MOVE 'Y' TO CLXREC.CLXEOAF;*/


  if (CLWREC.CLWMNOPT == 1) /* in 'add' path*/
    COMMAREA.CATOAP = "KL0E"; /* g/l*/
    XPCL002();
    return;
  end

  if (CLWREC.CLWMNOPT == 4 /* in 'inquiry'*/
   || CLWREC.CLWMNOPT == 5) /* or 'change' path*/
    if (COMMAREA.CAFROMAP == "KL0E" /* and on std path*/
     || COMMAREA.CAFROMAP == "KL0F" /* address*/
     || COMMAREA.CAFROMAP == "KL0G" /* comments*/
     || COMMAREA.CAFROMAP == "KL0H" /* addl a/r*/
     || COMMAREA.CAFROMAP == "KL0I" /* traffic*/
     || COMMAREA.CAFROMAP == "KL0N") /* addl invc*/
      COMMAREA.CATOAP = "KL0E";
      XPCL002();
      return;
    end
  end


  if (COMMAREA.CAFRMSYS == "KL") /* if fastpath in from claims*/
    COMMAREA.CATOAP = COMMAREA.CAFROMAP; /* return to sender*/
    XPCL002();
    return;
  end


  COMMAREA.CATOAP = "KL0E"; /* claim header*/
  XPCL002();



end // end KL0LS00

// pf1 help
Function KL0LS01()



      /* skip edits/updates, exit to goal documentation*/


  COMMAREA.CATOAP = "GD0G";

  CLXREC.CLXEOSF = "Y";
  CLXREC.CLXEOAF = "Y";

  XPCL002();
end // end KL0LS01

// pf3 exit to claims
Function KL0LS03()



      /* skip edits/update, go to claim menu in claims*/

    /* drop use of clwmapfm - seems that cl0e is putting*/
    /* in cl0e value - should be only cl0a, cl0b, cl0c,cl0d*/

   /* IF CLWREC.CLWMAPFM NE ' ' ;return to first top level map*/
    /* MOVE CLWREC.CLWAPPFM TO COMMAREA.CATOAP;*/
    /* MOVE 'Y' TO CLXREC.CLXEOSF;*/
    /* MOVE 'Y' TO CLXREC.CLXEOAF;*/
   /* ELSE ;*/
  COMMAREA.CATOAP = "KL0A"; /* go to claims menu*/
  CLXREC.CLXEOSF = "Y";
  CLXREC.CLXEOAF = "Y";
  CL0LW01.CL0LWAUP = "N"; /* do not update the claim header*/
  XPCL002();
   /* END ;*/



end // end KL0LS03

// pf4 exit to master menu
Function KL0LS04()



      /* skip edits/update, go to goal master menu*/

  COMMAREA.CATOAP = "MN0M"; /* go to master menu*/

  CLXREC.CLXEOSF = "Y"; /* end of screen*/
  CLXREC.CLXEOAF = "Y"; /* end of application*/
  CL0LW01.CL0LWAUP = "N"; /* do not update the claim header*/


  XPCL002();
end // end KL0LS04

// pf 5 action
Function KL0LS05()
   /* ************************************************************/
   /* *      handle the entry of pfkey 5                        **/
   /* *        claim header                                     **/
   /* *                                                         **/
   /* ************************************************************/


  CLXREC.CLXEOSF = "Y"; /* we are done with this screen*/
  CLXREC.CLXEOAF = "Y"; /* we are done with this application*/

  COMMAREA.CATOAP = "KL0E"; /* claim header screen*/


  XPCL002();
end // end KL0LS05

// pf 6 action
Function KL0LS06()
   /* ************************************************************/
   /* *    this process handles the entry of pf key 6           **/
   /* *             (max paging backward)                       **/
   /* *                                                         **/
   /* *    since use different index names in summary & detail  **/
   /* *    arrays, test for screen 1/2 = map 1/5                **/
   /* *    arrays,       or screen 3   = map 10                 **/
   /* ************************************************************/


  if (CLXREC.CLXSCRNX == 1
   || CLXREC.CLXSCRNX == 2)

     /* ************************************/
     /* can't go back beyond start of array*/
     /* ************************************/

    CLXREC.CLXARAYX = 1;
    converseLib.validationFailed(210); /* at end of data - enter ivc at top*/
  else

     /* ************************************/
     /* can't go back beyond start of array*/
     /* ************************************/

    CLXREC.CLXCURSZ = 1;
    converseLib.validationFailed(3); /* at end of data*/
  end


     /* ***********************/
     /* force build new screen*/
     /* ***********************/

  CLXREC.CLXBLDSC = "Y";



end // end KL0LS06

// pf 7 action
Function KL0LS07()
   /* ************************************************************/
   /* *    this process handles the entry of pf key 7           **/
   /* *             (paging backward)                           **/
   /* *                                                         **/
   /* *    since use differenct index names in summary & detail **/
   /* *    arrays, test for screen 1/2 = map 1/5                **/
   /* *    arrays,       or screen 3   = map 10                 **/
   /* ************************************************************/


  if (CLXREC.CLXSCRNX == 1
   || CLXREC.CLXSCRNX == 2)
     /* **************************************************/
     /* decrement array by number of lines for map 1/5*/
     /* subtract max lines used on last map, then max lines-*/
     /* since start with clxarayx at end of map*/
     /* **************************************************/
    CLXREC.CLXARAYX = CLXREC.CLXARAYX - CLXREC.CLXMAPMX;
    CLXREC.CLXARAYX = CLXREC.CLXARAYX - CLXREC.CLXMAXLN[CLXSCRNX];

     /* ************************************/
     /* can't go back beyond start of array*/
     /* ************************************/
    if (CLXREC.CLXARAYX < 1)
      CLXREC.CLXARAYX = 1;
      converseLib.validationFailed(7); /* at top of data*/
    end
  else
     /* **************************************************/
     /* decrement array by number of lines for map 10*/
     /* subtract max lines used on last map, then max lines-*/
     /* since start with clxcursz at end of map*/
     /* **************************************************/
    CLXREC.CLXCURSZ = CLXREC.CLXCURSZ - CLXREC.CLXMAPMX;
    CLXREC.CLXCURSZ = CLXREC.CLXCURSZ - CLXREC.CLXMAXLN[CLXSCRNX];

     /* ************************************/
     /* can't go back beyond start of array*/
     /* ************************************/
    if (CLXREC.CLXCURSZ < 1)
      CLXREC.CLXCURSZ = 1;
      converseLib.validationFailed(7); /* at top of data*/
    end
  end


     /* ***********************/
     /* force build new screen*/
     /* ***********************/

  CLXREC.CLXBLDSC = "Y";



end // end KL0LS07

// pf 8 action
Function KL0LS08()
   /* ************************************************************/
   /* *   this process handles the entry of pf key 8            **/
   /* *           (paging forward)                              **/
   /* *                                                         **/
   /* *   since different array index names are used for        **/
   /* *   summary & detail arrays, split this in two            **/
   /* ************************************************************/


  if (CLXREC.CLXSCRNX == 1
   || CLXREC.CLXSCRNX == 2)

     /* ******************************************/
     /* no need to increment array since clxarayx*/
     /* points to next array entry to be shown*/
     /* ******************************************/
    /* CLXREC.CLXARAYX=CLXREC.CLXARAYX + CLXREC.CLXMAXLN(CLXSCRNX);*/

     /* **********************************************/
     /* can't go further forward than array is filled*/
     /* **********************************************/
    if (CLXREC.CLXARAYX >= CLXREC.CLXLSTAX)
      CLXREC.CLXARAYX = CLXREC.CLXLSTAX - 1;

      if (CLXREC.CLXARAYX < 1)
        CLXREC.CLXARAYX = 1;
      end

      if (CL0LW02.IV0IVCID != 0)
         /* *******************************************/
         /* if have invoice for claim, put out message*/
         /* depending on end of file flag*/
         /* *******************************************/
        if (CL0LW01.CL0LWIEF == "Y")
          converseLib.validationFailed(204); /* at end of data on last invc*/
        else
          converseLib.validationFailed(199); /* to see next invc or dtls, hit enter*/
        end
      else
         /* *********************************************/
         /* no invoice for claim, but at end of products*/
         /* *********************************************/
        converseLib.validationFailed(3); /* at end of data*/
      end
    end
  else
     /* **********************************************/
     /* no need to increment array since clxcursz*/
     /* points to next array entry to be shown*/
     /* **********************************************/
    /* CLXREC.CLXCURSZ=CLXREC.CLXCURSZ + CLXREC.CLXMAXLN(CLXSCRNX);*/

     /* **********************************************/
     /* can't go further forward than array is filled*/
     /* **********************************************/
    if (CLXREC.CLXCURSZ >= CLXREC.CLXLSTSZ)
      CLXREC.CLXCURSZ = CLXREC.CLXLSTSZ - 1;
      if (CLXREC.CLXCURSZ < 1)
        CLXREC.CLXCURSZ = 1;
      end
      converseLib.validationFailed(227); /* end of sizes for prod, hit enter*/
    end
  end


     /* ***********************/
     /* force build new screen*/
     /* ***********************/

  CLXREC.CLXBLDSC = "Y";



end // end KL0LS08

// pf 9 action
Function KL0LS09()
   /* ************************************************************/
   /* *   this process handles the entry of pf key 9            **/
   /* *           (max paging forward)                          **/
   /* *                                                         **/
   /* *   since different array index names are used for        **/
   /* *   summary & detail arrays, split this in two            **/
   /* ************************************************************/


  if (CLXREC.CLXSCRNX == 1
   || CLXREC.CLXSCRNX == 2)

     /* **********************************************/
     /* can't go further forward than array is filled*/
     /* **********************************************/

    if (CLXREC.CLXARAYX >= CLXREC.CLXLSTAX)
      CLXREC.CLXARAYX = CLXREC.CLXLSTAX - 1;

      if (CLXREC.CLXARAYX < 1)
        CLXREC.CLXARAYX = 1;
      end

      if (CL0LW02.IV0IVCID != 0)
         /* *******************************************/
         /* if have invoice for claim, put out message*/
         /* depending on end of file flag*/
         /* *******************************************/
        if (CL0LW01.CL0LWIEF == "Y")
          converseLib.validationFailed(204); /* at end of data on last invc*/
        else
          converseLib.validationFailed(199); /* to see next invc or dtls, hit enter*/
        end
      else
         /* *********************************************/
         /* no invoice for claim, but at end of products*/
         /* *********************************************/
        converseLib.validationFailed(3); /* at end of data*/
      end
    else
      if (CL0LW01.CL0LWIEF == "Y")
        converseLib.validationFailed(204); /* at end of data on last invc*/
      else
        converseLib.validationFailed(199); /* to see next invc or dtls, hit enter*/
      end
    end
  else
     /* **********************************************/
     /* no need to increment array since clxcursz*/
     /* points to next array entry to be shown*/
     /* **********************************************/
    /* CLXREC.CLXCURSZ=CLXREC.CLXCURSZ + CLXREC.CLXMAXLN(CLXSCRNX);*/

     /* **********************************************/
     /* can't go further forward than array is filled*/
     /* **********************************************/
    if (CLXREC.CLXCURSZ >= CLXREC.CLXLSTSZ)
      CLXREC.CLXCURSZ = CLXREC.CLXLSTSZ - 1;
      if (CLXREC.CLXCURSZ < 1)
        CLXREC.CLXCURSZ = 1;
      end
      converseLib.validationFailed(227); /* end of sizes for prod, hit enter*/
    end
  end


     /* ***********************/
     /* force build new screen*/
     /* ***********************/

  CLXREC.CLXBLDSC = "Y";



end // end KL0LS09

// pf 10 action
Function KL0LS10()
   /* ************************************************************/
   /* *      handle the entry of pfkey 10                       **/
   /* *      scroll left to product summary map 1               **/
   /* *                                                         **/
   /* ************************************************************/


  CLXREC.CLXEOSF = "Y"; /* we are done with this screen*/

  CLXREC.CLXCSCRN = "KL0LM001"; /* next screen for process 050*/


     /* *********************************************************/
     /* re-set array pointer to start at same prod as on descrip*/
     /* *********************************************************/

  CLXREC.CLXARAYX = CLXREC.CLXARAYX - CLXREC.CLXMAPMX;
                                   /* # lines used on map*/

  if (CLXREC.CLXARAYX < 1) /* can't go below start of array*/
    CLXREC.CLXARAYX = 1;
  end




end // end KL0LS10

// pf 11 action
Function KL0LS11()
   /* ************************************************************/
   /* *      handle the entry of pfkey 11                       **/
   /* *      scroll right to product description map 5          **/
   /* *                                                         **/
   /* ************************************************************/


  CLXREC.CLXEOSF = "Y"; /* we are done with this screen*/

  CLXREC.CLXCSCRN = "KL0LM005"; /* next screen for process 050*/


   /* GET CL0LS10*/
     /* *********************************************************/
     /* re-set array pointer to start at same prod as on summary*/
     /* *********************************************************/

  CLXREC.CLXARAYX = CLXREC.CLXARAYX - CLXREC.CLXMAPMX;
                                   /* # lines used on map*/

  if (CLXREC.CLXARAYX < 1) /* can't go below start of array*/
    CLXREC.CLXARAYX = 1;
  end


end // end KL0LS11

// pf 13 action
Function KL0LS13()
   /* ************************************************************/
   /* *      handle the entry of pfkey 13                       **/
   /* *        traffic                                          **/
   /* *                                                         **/
   /* ************************************************************/


  CLXREC.CLXEOSF = "Y"; /* we are done with this screen*/
  CLXREC.CLXEOAF = "Y"; /* we are done with this application*/

  COMMAREA.CATOAP = "KL0I"; /* traffic*/


  XPCL002();
end // end KL0LS13

// pf 14 action
Function KL0LS14()
   /* ************************************************************/
   /* *      handle the entry of pfkey 14 -                     **/
   /* *      general ledger                                     **/
   /* *                                                         **/
   /* ************************************************************/


  CLXREC.CLXEOSF = "Y"; /* we are done with this screen*/
  CLXREC.CLXEOAF = "Y"; /* we are done with this application*/


  COMMAREA.CATOAP = "KL0J"; /* claim g/l*/


  XPCL002();
end // end KL0LS14

// -911 db error-wait one second
Function KL0LS1S()

    /* this routine waits one second. used for data base deadlock*/
    /* error trapping.*/
    /* ezetim has format hh:mm:ss, character*/
    /* convert to numeric format, then add 1 second*/

  CL0LW01.CL0LWTM1 = VGVar.currentFormattedTime; /* original time at start*/
  CL0LW01.CL0LWTHL = CL0LW01.CL0LWTHF;
  CL0LW01.CL0LWTML = CL0LW01.CL0LWTMF;
  CL0LW01.CL0LWTSL = CL0LW01.CL0LWTSF;

  CL0LW01.CL0LWSS1 = CL0LW01.CL0LWTSL;
  CL0LW01.CL0LWMM1 = CL0LW01.CL0LWTML;

  CL0LW01.CL0LWSS1 = CL0LW01.CL0LWSS1 + 1; /* original time + 1 second*/

  CL0LW01.CL0LWTM1 = VGVar.currentFormattedTime; /* current time*/

  while (CL0LW01.CL0LWTSL < CL0LW01.CL0LWSS1 /* loop while current time*/
   && CL0LW01.CL0LWTML <= CL0LW01.CL0LWMM1) /* less than orig + 1 sec*/
    CL0LW01.CL0LWTHL = CL0LW01.CL0LWTHF;
    CL0LW01.CL0LWTML = CL0LW01.CL0LWTMF;
    CL0LW01.CL0LWTSL = CL0LW01.CL0LWTSF;
    CL0LW01.CL0LWTM1 = VGVar.currentFormattedTime; /* current time*/
  end



end // end KL0LS1S

// map 1 modify entered fields
Function KL0LS26()
   /* ************************************************************/
   /* *  since the map must be re-shown to the user             **/
   /* *  before editing has been done, set fields modified to   **/
   /* *  keep track of all the fields entered by the user.      **/
   /* *  the user will only need to re-do the pf key or enter   **/
   /* *  key, not enter the data again.                         **/
   /* ************************************************************/


  if (KL0LM001.IV0IVCID is modified)
    set KL0LM001.IV0IVCID modified;
  end



  sysVar.arrayIndex = 1;

  while (sysVar.arrayIndex <= CLXREC.CLXMAXLN[CLXSCRNX])
    if (KL0LM001.CL0LMSEL[sysVar.arrayIndex] is modified)
      set KL0LM001.CL0LMSEL[sysVar.arrayIndex] modified;
    end
    if (KL0LM001.CLRRQTQ[sysVar.arrayIndex] is modified)
      set KL0LM001.CLRRQTQ[sysVar.arrayIndex] modified;
    end
    if (KL0LM001.CLRCLMQ[sysVar.arrayIndex] is modified)
      set KL0LM001.CLRCLMQ[sysVar.arrayIndex] modified;
    end
    if (KL0LM001.CLKPRCFF[sysVar.arrayIndex] is modified)
      set KL0LM001.CLKPRCFF[sysVar.arrayIndex] modified;
    end
    if (KL0LM001.CLNGRPRC[sysVar.arrayIndex] is modified)
      set KL0LM001.CLNGRPRC[sysVar.arrayIndex] modified;
    end
    sysVar.arrayIndex = sysVar.arrayIndex + 1;
  end



end // end KL0LS26

// map 1 build line
Function KL0LS30()
   /* ************************************************************/
   /* *         build line to show on map 1, product summary    **/
   /* *                                                         **/
   /* ************************************************************/

  if (CLXREC.CLXLINEX == 1)
    CL0LW01.CL0LWFST = CLXREC.CLXARAYX;
  end

     /* **************************************************/
     /* protect data line if product worked at size level*/
     /* **************************************************/

  if (CL0LW02.CL0LMLVL[CLXARAYX] == "S")
    set KL0LM001.CLRRQTQ[CLXLINEX] protect;
    set KL0LM001.CLRCLMQ[CLXLINEX] protect;
    set KL0LM001.CLKPRCFF[CLXLINEX] protect;
    set KL0LM001.CLNGRPRC[CLXLINEX] protect;
  else
    if (CL0LW01.CL0LWINQ == "N")
      set KL0LM001.CLRRQTQ[CLXLINEX] initialAttributes;
      set KL0LM001.CLRCLMQ[CLXLINEX] initialAttributes;
      set KL0LM001.CLKPRCFF[CLXLINEX] initialAttributes;
      set KL0LM001.CLNGRPRC[CLXLINEX] initialAttributes;
      set KL0LM001.CL0LMSEL[CLXLINEX] initialAttributes;
      set KL0LM005.CL0LMSEL[CLXLINEX] initialAttributes;
    end
  end

  if (CL0LW02.CL0LMSEL[CLXARAYX] == "X")
    KL0LSP7();
    set KL0LM001.CL0LMSEL[CLXLINEX] initialAttributes;
    set KL0LM001.CLICRDFL[CLXLINEX] initialAttributes;
    set KL0LM001.CL0LMLVL[CLXLINEX] initialAttributes;
    CL0LW02.CL0LWDLT[CLXARAYX] = "X";
    CL0LW01.CL0LWHVC = "N";
    CL0LW01.CL0LWHVD = "N";
    CL0LW02.CL0LMLVL[CLXARAYX] = " ";
    CL0LW02.CLICRDFL[CLXARAYX] = " ";
    CL0LW02.CL0LMSEL[CLXARAYX] = " ";
    CL0LW02.XGPCD[CLXARAYX] = " ";
    CL0LW02.SY1STNBR[CLXARAYX] = " ";
    CL0LW02.SY2CLRID[CLXARAYX] = " ";
    CL0LW02.XDMCD[CLXARAYX] = " ";
    CL0LW02.KUIPRDID[CLXARAYX] = " ";
    CL0LW02.SY5SZID[CLXARAYX] = 0;
    CL0LW02.XUMCD[CLXARAYX] = " ";
    CL0LW02.IV3LNSQ[CLXARAYX] = 0;
    CL0LW02.IV3GLNUP[CLXARAYX] = 0;
    CL0LW02.CLRRQTQ[CLXARAYX] = 0;
    CL0LW02.CLRCLMQ[CLXARAYX] = 0;
    CL0LW02.CLKPRCFF[CLXARAYX] = " ";
    CL0LW02.CLNGRPRC[CLXARAYX] = 0;
    CL0LW02.CLNNTPRC[CLXARAYX] = 0;
    CL0LW02.OP2PRCVF[CLXARAYX] = " ";
    CL0LW02.CLAESTVL[CLXARAYX] = 0;
    CL0LW01.CL0LWOCQ[CLXLINEX] = 0;
    CL0LW01.CL0LWORQ[CLXLINEX] = 0;
    return;
  end


     /* ************/
     /* select code*/
     /* ************/


  KL0LM001.CL0LMSEL[CLXLINEX] = CL0LW02.CL0LMSEL[CLXARAYX];


     /* ******************************************/
     /* credit/debit code*/
     /* ******************************************/

  KL0LM001.CLICRDFL[CLXLINEX] = CL0LW02.CLICRDFL[CLXARAYX];


     /* ************************/
     /* product/size level code*/
     /* ************************/

  if (CL0LW02.CL0LMLVL[CLXARAYX] == "S") /* if work at size level*/
    KL0LM001.CL0LMLVL[CLXLINEX] = "Y"; /* show detail = 'y'*/
  else
    KL0LM001.CL0LMLVL[CLXLINEX] = " ";
  end


     /* ****************/
     /* nike product id*/
     /* ****************/

  KL0LM001.SY1STNBR[CLXLINEX] = CL0LW02.SY1STNBR[CLXARAYX];
  set KL0LM001.SY1STNBR[CLXLINEX] initialAttributes;

  KL0LM001.SY2CLRID[CLXLINEX] = CL0LW02.SY2CLRID[CLXARAYX];
  set KL0LM001.SY2CLRID[CLXLINEX] initialAttributes;

  if (CL0LW02.XDMCD[CLXARAYX] == "00")
    KL0LM001.XDMCD[CLXLINEX] = " ";
  else
    KL0LM001.XDMCD[CLXLINEX] = CL0LW02.XDMCD[CLXARAYX];
  end
  set KL0LM001.XDMCD[CLXLINEX] initialAttributes;


     /* *************************/
     /* invoice shipped quantity*/
     /* *************************/

  KL0LM001.IV3LNSQ[CLXLINEX] = CL0LW02.IV3LNSQ[CLXARAYX];


     /* **************/
     /* invoice price*/
     /* **************/

  KL0LM001.IV3GLNUP[CLXLINEX] = CL0LW02.IV3GLNUP[CLXARAYX];


     /* *********************/
     /* cust qty & claim qty*/
     /* *********************/

  if (CL0LW02.CLICRDFL[CLXARAYX] == "C")
    if (CL0LW02.CLRCLMQ[CLXARAYX] > 0)
      KL0LM001.CLRCLMQ[CLXLINEX] = CL0LW02.CLRCLMQ[CLXARAYX] * -1;
      CL0LW01.CL0LWOCQ[CLXLINEX] = CL0LW02.CLRCLMQ[CLXARAYX];
    else
      KL0LM001.CLRCLMQ[CLXLINEX] = CL0LW02.CLRCLMQ[CLXARAYX];
      CL0LW01.CL0LWOCQ[CLXLINEX] = CL0LW02.CLRCLMQ[CLXARAYX] * -1;
    end
    if (CL0LW02.CLRRQTQ[CLXARAYX] > 0)
      KL0LM001.CLRRQTQ[CLXLINEX] = CL0LW02.CLRRQTQ[CLXARAYX] * -1;
      CL0LW01.CL0LWORQ[CLXLINEX] = CL0LW02.CLRRQTQ[CLXARAYX];
    else
      KL0LM001.CLRRQTQ[CLXLINEX] = CL0LW02.CLRRQTQ[CLXARAYX];
      CL0LW01.CL0LWORQ[CLXLINEX] = CL0LW02.CLRRQTQ[CLXARAYX] * -1;
    end
  else
    KL0LM001.CLRCLMQ[CLXLINEX] = CL0LW02.CLRCLMQ[CLXARAYX];
    KL0LM001.CLRRQTQ[CLXLINEX] = CL0LW02.CLRRQTQ[CLXARAYX];
    CL0LW01.CL0LWOCQ[CLXLINEX] = CL0LW02.CLRCLMQ[CLXARAYX];
    CL0LW01.CL0LWORQ[CLXLINEX] = CL0LW02.CLRRQTQ[CLXARAYX];
  end

     /* ******************/
     /* "price from" flag*/
     /* ******************/

  KL0LM001.CLKPRCFF[CLXLINEX] = CL0LW02.CLKPRCFF[CLXARAYX];


     /* **********************************/
     /* if net bill, move net price*/
     /* else move gross price.*/
     /* if sizes have different prices,*/
     /* move 'v' to price variable? field*/
     /* **********************************/

  if (CL0LW02.IVANBLFL == "Y") /* net bill flag*/
    KL0LM001.CLNGRPRC[CLXLINEX] = CL0LW02.CLNNTPRC[CLXARAYX];
  else
    KL0LM001.CLNGRPRC[CLXLINEX] = CL0LW02.CLNGRPRC[CLXARAYX];
  end

  if (CL0LW02.OP2PRCVF[CLXARAYX] == "Y")
    KL0LM001.CL0LMVPR[CLXLINEX] = "V";
  else
    KL0LM001.CL0LMVPR[CLXLINEX] = " ";
  end

  if (KL0LM001.CL0LMVPR[CLXLINEX] == "V")
    CL0LW02.CLNNTPRC[CLXARAYX] = 0;
    CL0LW02.CLNGRPRC[CLXARAYX] = 0;
  end

     /* ***************************************/
     /* claim amount = claim price x claim qty*/
     /* ***************************************/

  if (KL0LM001.CL0LMVPR[CLXLINEX] == "V")
    CL0LW01.CLAESTVL = CL0LW02.CLAESTVL[CLXARAYX];
    KL0LM001.CLNGRPRC[CLXLINEX] = 0;
  else
    if (CL0LW02.IVANBLFL == "Y") /* net bill flag*/
      CL0LW01.CLAESTVL = CL0LW02.CLNNTPRC[CLXARAYX] * CL0LW02.CLRCLMQ[CLXARAYX];
    else
      CL0LW01.CLAESTVL = CL0LW02.CLNGRPRC[CLXARAYX] * CL0LW02.CLRCLMQ[CLXARAYX];
    end

    if (CL0LW02.CLICRDFL[CLXARAYX] == "C")
      if (CL0LW01.CLAESTVL > 0)
        CL0LW01.CLAESTVL = CL0LW01.CLAESTVL * -1;
      end
    end
  end

  KL0LM001.CLAESTVL[CLXLINEX] = CL0LW01.CLAESTVL;

     /* hold old value, use to calc chg in cl0l120*/
  if (CL0LW01.CLAESTVL < 0)
    CL0LW01.CL0LWOVL[CLXLINEX] = CL0LW01.CLAESTVL * -1;
  else
    CL0LW01.CL0LWOVL[CLXLINEX] = CL0LW01.CLAESTVL;
  end

end // end KL0LS30

// map 5 build line
Function KL0LS40()
   /* **************************************************************/
   /* *  MAINTENANCE HISTORY*/
   /* *  06-14-91  sgorga  DB2 Chgs. Replaced KU2REC with KUIREC.*/
   /* *                    Replaced call 'S ' with 'SB'.*/
   /* *  07-11-97  sarumu  DB2 Chgs. Replaced KUIREC with VCUCPX01.*/
   /* **************************************************************/

   /* ************************************************************/
   /* *     build line to show on map 5, product descriptions   **/
   /* *                                                         **/
   /* ************************************************************/
   /* GET CL0LS30*/

  TA1REC.TA1LOCAT[2] = "CL0LS40";

     /* ************/
     /* select code*/
     /* ************/

  KL0LM005.CL0LMSEL = CL0LW02.CL0LMSEL[CLXARAYX];


     /* ******************/
     /* credit/debit code*/
     /* ******************/

  KL0LM005.CLICRDFL[CLXLINEX] = CL0LW02.CLICRDFL[CLXARAYX];


     /* ************************/
     /* product/size level code*/
     /* ************************/

  if (CL0LW02.CL0LMLVL[CLXARAYX] == "S") /* if size level*/
    KL0LM005.CL0LMLVL[CLXLINEX] = "Y"; /* then have details*/
  else
    KL0LM005.CL0LMLVL[CLXLINEX] = " ";
  end


     /* ****************/
     /* nike product id*/
     /* ****************/

  KL0LM005.SY1STNBR[CLXLINEX] = CL0LW02.SY1STNBR[CLXARAYX];
  if (CL0LW02.SY2CLRID[CLXARAYX] == "00 ")
    KL0LM005.SY2CLRID[CLXLINEX] = " ";
  else
    KL0LM005.SY2CLRID[CLXLINEX] = CL0LW02.SY2CLRID[CLXARAYX];
  end
  if (CL0LW02.XDMCD[CLXARAYX] == "00")
    KL0LM005.XDMCD[CLXLINEX] = " ";
  else
    KL0LM005.XDMCD[CLXLINEX] = CL0LW02.XDMCD[CLXARAYX];
  end


     /* **************************************************/
     /* find customer product id, either from the cl0lw02*/
     /* array (taken off the invoice product record)*/
     /* or from the customer product xref record.*/
     /* **************************************************/
  set WCU1710 empty;

  if (CL0LW02.KUIPRDID[CLXARAYX] != " ") /* have invoice cust prod id*/
     /* or got cust prod id previously*/
    KL0LM005.KUIPRDID[CLXLINEX] = CL0LW02.KUIPRDID[CLXARAYX];
  else
    WCU1710-INQUIRY-OPTION = "2"; /* Nike product id look up*/
    WCU1710-IN-CU-CO-ID = KUCREC.KUCCOID; /* company id*/
    WCU1710-XNX-DEPT-ID-XREF = 0; /* department id*/
    if (CLAREC.IV0IVCID > 0) /* get product xref date*/
      WCU1710-CU-PROD-XREF-EDT = KL0LM005.IV0IVCDT;
    else
      WCU1710-CU-PROD-XREF-EDT = CLAREC.CLASETDT;
    end
    WCU1710-IN-XGP-GPC-CD = CL0LW02.XGPCD[CLXARAYX]; /* gpc code*/
    WCU1710-IN-SY-STY-NBR = CL0LW02.SY1STNBR[CLXARAYX]; /* style*/
    WCU1710-IN-SY-COLR-CD-ID = CL0LW02.SY2CLRID[CLXARAYX]; /* color*/
    WCU1710-IN-XDM-DIM-CD = CL0LW02.XDMCD[CLXARAYX]; /* dimension*/
    WCU1710-IN-SY-SZ-ID = 0; /* size id*/

   /* if quality code is blank default it to '01'*/
    if (CL0LW02.XQACD[CLXARAYX] != " ") /* quality code*/
      WCU1710-IN-XQA-QUAL-CD = CL0LW02.XQACD[CLXARAYX];
    else
      WCU1710-IN-XQA-QUAL-CD = "01";
    end

    set SQLCA empty;

    call "CU1710" (WCU1710) {isNoRefresh = yes, isExternal = yes}; /* get customer product id*/
    if (WCU1710-RETURN-CODE == 0)
      KL0LM005.KUIPRDID[CLXLINEX] = WCU1710.CU-CUST-PROD-ID[1];
      CL0LW02.KUIPRDID[CLXARAYX] = WCU1710.CU-CUST-PROD-ID[1];
    else
      KL0LM005.KUIPRDID[CLXLINEX] = " ";
    end
  end


     /* ***************************************/
     /* get product style & color descriptions*/
     /* ***************************************/

  SYCREC.XGPCD = CL0LW02.XGPCD[CLXARAYX];
  SYCREC.SY1STNBR = CL0LW02.SY1STNBR[CLXARAYX];
  SYCREC.SY2CLRID = CL0LW02.SY2CLRID[CLXARAYX];
  SYCREC.XDMCD = CL0LW02.XDMCD[CLXARAYX];

  call "IO0560" ("S ", SQLCA, SYCREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    KL0LM005.SY1SSTNM[CLXLINEX] = SYCREC.SY1SSTNM;
    KL0LM005.SY2CLRAB[CLXLINEX] = SYCREC.SY2CLRAB;
  else
    KL0LM005.SY1SSTNM[CLXLINEX] = " ";
    KL0LM005.SY2CLRAB[CLXLINEX] = " ";
  end



end // end KL0LS40

// map 10 build line
Function KL0LS50()
   /* ************************************************************/
   /* *         build line to show on map 10, product detail    **/
   /* *                                                         **/
   /* ************************************************************/

  TA1REC.TA1LOCAT[2] = "CL0LS50";
     /* ************/
     /* select code*/
     /* ************/

  KL0LM010.CL0LMSEL[CLXLINEX] = CL0LW03.CL0LMSEL[CLXCURSZ];


     /* ******************/
     /* credit/debit code*/
     /* ******************/

  KL0LM010.CLICRDFL[CLXLINEX] = CL0LW03.CLICRDFL[CLXCURSZ];


      /* *****************/
      /* size description*/
      /* *****************/

  sysVar.arrayIndex = CL0LW03.SY5SZID[CLXCURSZ];

  KL0LM010.SY4IDDSC[CLXLINEX] = SY4REC.SY4IDDSC[sysVar.arrayIndex];
  set KL0LM010.SY4IDDSC[CLXLINEX] initialAttributes;


     /* ********************************************************/
     /* if working from an invoice with products from the claim*/
     /* then read the invoice to get the shipped qty*/
     /* and invoice gross price*/
     /* ********************************************************/

  if (CL0LW02.IV0IVCID != 0 /* have invoice*/
   && CL0LW01.YITCD == "I"  /* from the I.B.M.*/
   && CL0LW03.IV4SHPQ[CLXCURSZ] == 0) /* and don't have invc price*/
     /* read iv4rec to get 2 fields*/
    IV4REC.IV0PARTN = CL0LW02.IV0PARTN;
    IV4REC.IV0IVCID = CL0LW02.IV0IVCID;
    IV4REC.OP2LNINB = CL0LW02.OP2LNINB[CL0LWCAX];
    IV4REC.SY5SZID = CL0LW03.SY5SZID[CLXCURSZ];

    call "IO1130" ("S ", SQLCA, IV4REC) {isNoRefresh = yes, isExternal = yes}; /* get ivc item size record*/

    if (SQLCA.VAGen_SQLCODE == 0)
      CL0LW03.IV4SHPQ[CLXCURSZ] = IV4REC.IV4SHPQ;
      if (CL0LW02.IVANBLFL == "Y") /* net bill flag*/
        CL0LW03.IV4GUP[CLXCURSZ] = IV4REC.IV4NUP;
      else
        CL0LW03.IV4GUP[CLXCURSZ] = IV4REC.IV4GUP;
      end
       /* add to map total for product*/
      CL0LW01.CL0LWTSH[2] = CL0LW01.CL0LWTSH[2] + IV4REC.IV4SHPQ;
    end
  end


     /* *************************/
     /* invoice shipped quantity*/
     /* *************************/

  KL0LM010.IV4SHPQ[CLXLINEX] = CL0LW03.IV4SHPQ[CLXCURSZ];


     /* **************/
     /* invoice price*/
     /* **************/

  KL0LM010.IV4GUP[CLXLINEX] = CL0LW03.IV4GUP[CLXCURSZ];


     /* *********************/
     /* cust qty & claim qty*/
     /* *********************/

  if (CL0LW03.CLICRDFL[CLXCURSZ] == "C")
    KL0LM010.CLRRQTQ[CLXLINEX] = CL0LW03.CLRRQTQ[CLXCURSZ] * -1;
    KL0LM010.CLRCLMQ[CLXLINEX] = CL0LW03.CLRCLMQ[CLXCURSZ] * -1;
  else
    KL0LM010.CLRCLMQ[CLXLINEX] = CL0LW03.CLRCLMQ[CLXCURSZ];
    KL0LM010.CLRRQTQ[CLXLINEX] = CL0LW03.CLRRQTQ[CLXCURSZ];
  end


     /* hold map original values, used to calc chg in cl0l320*/
  CL0LW01.CL0LWOCQ[CLXLINEX] = CL0LW03.CLRCLMQ[CLXCURSZ];
  CL0LW01.CL0LWORQ[CLXLINEX] = CL0LW03.CLRRQTQ[CLXCURSZ];


     /* ******************/
     /* "price from" flag*/
     /* ******************/

  KL0LM010.CLKPRCFF[CLXLINEX] = CL0LW03.CLKPRCFF[CLXCURSZ];


     /* ***********/
     /* size price*/
     /* ***********/

  if (CL0LW02.IVANBLFL == "Y") /* net bill flag*/
    KL0LM010.CLNGRPRC[CLXLINEX] = CL0LW03.CLNNTPRC[CLXCURSZ];
  else
    KL0LM010.CLNGRPRC[CLXLINEX] = CL0LW03.CLNGRPRC[CLXCURSZ];
  end


     /* ***************************************/
     /* claim amount = claim price x claim qty*/
     /* ***************************************/

  if (CL0LW02.IVANBLFL == "Y") /* net bill flag*/
    CL0LW01.CLAESTVL = CL0LW03.CLNNTPRC[CLXCURSZ] * CL0LW03.CLRCLMQ[CLXCURSZ];
  else
    CL0LW01.CLAESTVL = CL0LW03.CLNGRPRC[CLXCURSZ] * CL0LW03.CLRCLMQ[CLXCURSZ];
  end

  if (CL0LW03.CLICRDFL[CLXCURSZ] == "C") /* show credit as negative*/
    CL0LW01.CLAESTVL = CL0LW01.CLAESTVL * -1;
  end

  KL0LM010.CLAESTVL[CLXLINEX] = CL0LW01.CLAESTVL;

     /* hold map original value, use to calc chg in cl0l320*/
  CL0LW01.CL0LWOVL[CLXLINEX] = CL0LW01.CLAESTVL;

  if (KL0LM010.SY4IDDSC[CLXLINEX] != " ")
    if (CL0LW01.CL0LWINQ == "N")
      set KL0LM010.SY4IDDSC[CLXLINEX] initialAttributes;
      set KL0LM010.CL0LMSEL[CLXLINEX] initialAttributes;
      set KL0LM010.CLICRDFL[CLXLINEX] initialAttributes;
      set KL0LM010.CLRRQTQ[CLXLINEX] initialAttributes;
      set KL0LM010.CLRCLMQ[CLXLINEX] initialAttributes;
      set KL0LM010.IV4SHPQ[CLXLINEX] initialAttributes;
      set KL0LM010.IV4GUP[CLXLINEX] initialAttributes;
      set KL0LM010.CLKPRCFF[CLXLINEX] initialAttributes;
      set KL0LM010.CLNGRPRC[CLXLINEX] initialAttributes;
      set KL0LM010.CLAESTVL[CLXLINEX] initialAttributes;
    end
  end


end // end KL0LS50

// prod price style/color dflts
Function KL0LS70()
   /* GET OP0IS22*/
      /* *******************************************************/
      /* * read db2 price by style or style & color for defaults*/
      /* **/
      /* * first - if price-size code = s or c or z (any):*/
      /* * _ read price default for style (all colors,dims,sizes)*/
      /* * - hold price in cl0lwstp (style price)*/
      /* **/
      /* * second - if price-size code = c or z:*/
      /* *  - read price deflt for style & color & dim(all sizes)*/
      /* *  - hold price in cl0lwclp (color price)*/
      /* **/
      /* * sgrp done from cl0lspp, with cl0lw02(cl0lwinx)*/
      /* *            and cl0lsps, with cl0lw02(cl0lwcax)*/
      /* **/
      /* * 02-15-91 CHELLM Renamed SY5PRCVL to XQACD*/
      /* **/
      /* **/
      /* **/
      /* *******************************************************/

  TA1REC.TA1LOCAT[2] = "CL0LS70";
  CL0LW01.CL0LWSTP = 0; /* zero price defaults*/
  CL0LW01.CL0LWCLP = 0;


      /* *****************************/
      /* * get style price record*/
      /* *****************************/

   /* GET OP0IS97*/
  SY5REC.XGPCD = CLAREC.XGPCD; /* general prod.class*/

  if (CLXREC.CLXSCRNX == 1) /* map 1*/
    SY5REC.SY1STNBR = CL0LW02.SY1STNBR[CL0LWINX]; /* style*/
  else /* map 10*/
    SY5REC.SY1STNBR = CL0LW02.SY1STNBR[CL0LWCAX]; /* style*/
  end

   /* style default price has these defaults in the key*/
  SY5REC.SY2CLRID = "***"; /* default color code*/
  SY5REC.XDMCD = "**"; /* default dimension*/
  SY5REC.SY5SZID = 0; /* default size id*/

  SY5REC.XPYCD = IVEREC.IVEPCTYP; /* price type code*/
  if (CLXREC.CLXSCRNX == 1) /* map 1*/
    SY5REC.XQACD = CL0LW02.XQACD[CL0LWINX]; /* quality code*/
  else /* map 10*/
    SY5REC.XQACD = CL0LW02.XQACD[CL0LWCAX]; /* quality code*/
  end

  call "IO0380" ("S ", SQLCA, SY5REC) {isNoRefresh = yes, isExternal = yes}; /* i/o mod for single select*/

  if (SQLCA.VAGen_SQLCODE == 0) /* check for good return*/
    /* GET OP0IS28*/
     /* find current price among 6 possible prices*/
     /* new/future date is first, oldest date is last*/
     /* price effective date is today*/
    sysVar.arrayIndex = 1; /* check dates ascending seq*/
    while (sysVar.arrayIndex < 7)
      if (SY5REC.SY5PCEDT[sysVar.arrayIndex] <= CL0LW01.CL0LWPED)
                                   /* price effective date*/
        CL0LW01.CL0LWSTP = SY5REC.SY5PRCUN[sysVar.arrayIndex]; /* hold style price*/
        sysVar.arrayIndex = 9; /* force loop end*/
      end
      sysVar.arrayIndex = sysVar.arrayIndex + 1;
    end

  else
    if (SQLCA.VAGen_SQLCODE == 100) /* if price record not found,*/
      CL0LW01.CL0LWSTP = 0; /* force zero prices*/
    else
      TA1REC.TA1DBASE = "DPROD"; /* data base name*/
      TA1REC.TA1TBLVU = "VPRICE01"; /* table view*/
      TA1REC.TA1TBLKE = SY5REC.SY5KEY; /* key value*/
      TA1REC.TA1LOCAT[4] = "IO0380"; /* i/o mod*/
      XPCL010(); /* common abend routine*/
    end
  end


      /* ******************************/
      /* * check if need second read*/
      /* ******************************/

  if (SYCREC.SY1PRCZS == "C" /* if have price by color or size*/
   || SYCREC.SY1PRCZS == "Z") /* get second default*/
    /* next sentence*/
  else /* else use only style default*/
    return;
  end


      /* *******************************************/
      /* * get style/color/dimension price record*/
      /* *******************************************/

     /* other sy5rec key data moved above*/

  if (CLXREC.CLXSCRNX == 1) /* map 1*/
    SY5REC.SY2CLRID = CL0LW02.SY2CLRID[CL0LWINX]; /* color*/
    SY5REC.XDMCD = CL0LW02.XDMCD[CL0LWINX]; /* dimension*/
  else /* map 10*/
    SY5REC.SY2CLRID = CL0LW02.SY2CLRID[CL0LWCAX]; /* color*/
    SY5REC.XDMCD = CL0LW02.XDMCD[CL0LWCAX]; /* dimension*/
  end
  SY5REC.SY5SZID = 0; /* default size id*/

   /* GET OP0IS97*/
  call "IO0380" ("S ", SQLCA, SY5REC) {isNoRefresh = yes, isExternal = yes}; /* i/o mod for single select*/

  if (SQLCA.VAGen_SQLCODE == 0) /* check for good return*/
    /* GET OP0IS28*/
     /* find current price among 6 possible prices*/
     /* new/future date is first, oldest date is last*/
     /* price effective date is today*/
    sysVar.arrayIndex = 1; /* check dates ascending seq*/
    while (sysVar.arrayIndex < 7)
      if (SY5REC.SY5PCEDT[sysVar.arrayIndex] <= CL0LW01.CL0LWPED)
                                   /* price effective date*/
        CL0LW01.CL0LWCLP = SY5REC.SY5PRCUN[sysVar.arrayIndex]; /* hold color price*/
        sysVar.arrayIndex = 9; /* force loop end*/
      end
      sysVar.arrayIndex = sysVar.arrayIndex + 1;
    end

  else
    if (SQLCA.VAGen_SQLCODE == 100) /* price not found*/
      CL0LW01.CL0LWCLP = 0; /* forces price = 0*/
    else
      TA1REC.TA1DBASE = "DPROD"; /* data base name*/
      TA1REC.TA1TBLVU = "VPRICE01"; /* table view*/
      TA1REC.TA1TBLKE = SY5REC.SY5KEY; /* key value*/
      TA1REC.TA1LOCAT[4] = "IO0380"; /* i/o mod*/
      XPCL010(); /* common abend routine*/
    end
  end



end // end KL0LS70

// prod cost style/color dflts
Function KL0LS72()
   /* GET OP0IS22*/
      /* *******************************************************/
      /* * read db2 cost by style or style & color for defaults*/
      /* **/
      /* * first - if price-size code = s or c or z (any):*/
      /* * _ read cost default for style (all colors,dims,sizes)*/
      /* * - hold cost in cl0lwstp (style price)*/
      /* **/
      /* * second - if price-size code = c or z:*/
      /* *  - read cost deflt for style & color & dim(all sizes)*/
      /* *  - hold cost in cl0lwclp (color price)*/
      /* **/
      /* * executed from cl0lspp, with cl0lw02(cl0lwinx)*/
      /* *           and cl0lsps, with cl0lw02(cl0lwcax)*/
   /* ** maintenance log  ***************************************/
   /* 03-11-94 BCOURT  rename sy6cstfl to xqacd.*/
   /* Default values for country & currency.*/
   /* ***********************************************************/

  TA1REC.TA1LOCAT[2] = "CL0LS72";
  CL0LW01.CL0LWSTP = 0; /* zero price defaults*/
  CL0LW01.CL0LWCLP = 0;


      /* *****************************/
      /* * get style price record*/
      /* *****************************/

  SY6REC.XGPCD = CLAREC.XGPCD; /* general prod.class*/
  if (CLXREC.CLXSCRNX == 1) /* map 1*/
    SY6REC.SY1STNBR = CL0LW02.SY1STNBR[CL0LWINX]; /* style*/
    SY6REC.XQACD = CL0LW02.XQACD[CL0LWINX]; /* quality code 3-11-94*/
    SY6REC.SY2CLRID = CL0LW02.SY2CLRID[CL0LWINX]; /* color*/
    SY6REC.XDMCD = CL0LW02.XDMCD[CL0LWINX]; /* dimension*/
  else /* map 10*/
    SY6REC.SY1STNBR = CL0LW02.SY1STNBR[CL0LWCAX]; /* style*/
    SY6REC.XQACD = CL0LW02.XQACD[CL0LWCAX]; /* quality code 3-11-94*/
    SY6REC.SY2CLRID = CL0LW02.SY2CLRID[CL0LWCAX]; /* color*/
    SY6REC.XDMCD = CL0LW02.XDMCD[CL0LWCAX];
  end

  SY6REC.XCOCD = IVEREC.IVEPCTYP; /* cost type code*/
  SY6REC.XCT-CTRY-CD = "USA"; /* 3-11-94 default country*/
  SY6REC.ZFC-CRCY-CD = "USD"; /* 3-11-94 default currency*/

  call "IO0360" ("S ", SQLCA, SY6REC) {isNoRefresh = yes, isExternal = yes}; /* i/o mod for single select*/

  if (SQLCA.VAGen_SQLCODE == 0) /* check for good return*/
    /* GET OP0IS28*/
     /* find current cost among 6 possible costs*/
     /* new/future date is first, oldest date is last*/
     /* price effective date is today*/
    sysVar.arrayIndex = 1; /* check dates ascending seq*/
    while (sysVar.arrayIndex < 7)
      if (SY6REC.SY6CSEDT[sysVar.arrayIndex] <= CL0LW01.CL0LWPED)
                                   /* price effective date*/
        CL0LW01.CL0LWSTP = SY6REC.SY6CSTUN[sysVar.arrayIndex]; /* hold style price*/
        sysVar.arrayIndex = 9; /* force loop end*/
      end
      sysVar.arrayIndex = sysVar.arrayIndex + 1;
    end

  else
    if (SQLCA.VAGen_SQLCODE == 100) /* if price record not found,*/
      CL0LW01.CL0LWSTP = 0; /* force zero prices*/
    else
      TA1REC.TA1DBASE = "DPROD"; /* data base name*/
      TA1REC.TA1TBLVU = "VDCOST01"; /* table view*/
      XPCL010(); /* common abend routine*/
    end
  end


      /* ******************************/
      /* * check if need second read*/
      /* ******************************/

  if (SYCREC.SY1PRCZS == "C" /* if have price by color or size*/
   || SYCREC.SY1PRCZS == "Z") /* get second default*/
    /* next sentence*/
  else /* else use only style default*/
    return;
  end


      /* *******************************************/
      /* * get style/color/dimension cost record*/
      /* *******************************************/

     /* other sy6rec key data moved above*/

  if (CLXREC.CLXSCRNX == 1) /* map 1*/
    SY6REC.SY2CLRID = CL0LW02.SY2CLRID[CL0LWINX]; /* color*/
    SY6REC.XDMCD = CL0LW02.XDMCD[CL0LWINX]; /* dimension*/
  else /* map 10*/
    SY6REC.SY2CLRID = CL0LW02.SY2CLRID[CL0LWCAX]; /* color*/
    SY6REC.XDMCD = CL0LW02.XDMCD[CL0LWCAX]; /* dimension*/
  end

   /* GET OP0IS97*/
  call "IO0360" ("S ", SQLCA, SY6REC) {isNoRefresh = yes, isExternal = yes}; /* i/o mod for single select*/

  if (SQLCA.VAGen_SQLCODE == 0) /* check for good return*/
    /* GET OP0IS28*/
     /* find current cost among 6 possible costs*/
     /* new/future date is first, oldest date is last*/
     /* price effective date is today*/
    sysVar.arrayIndex = 1; /* check dates ascending seq*/
    while (sysVar.arrayIndex < 7)
      if (SY6REC.SY6CSEDT[sysVar.arrayIndex] <= CL0LW01.CL0LWPED)
                                   /* price effective date*/
        CL0LW01.CL0LWCLP = SY6REC.SY6CSTUN[sysVar.arrayIndex]; /* hold color price*/
        sysVar.arrayIndex = 9; /* force loop end*/
      end
      sysVar.arrayIndex = sysVar.arrayIndex + 1;
    end

  else
    if (SQLCA.VAGen_SQLCODE == 100) /* price not found*/
      CL0LW01.CL0LWCLP = 0; /* forces price = 0*/
    else
      TA1REC.TA1DBASE = "DPROD"; /* data base name*/
      TA1REC.TA1TBLVU = "VDCOST01"; /* table view*/
      XPCL010(); /* common abend routine*/
    end
  end



end // end KL0LS72

// size price for size array
Function KL0LS74()
     /* ******************/
     /* get price by size*/
     /* ******************/

  TA1REC.TA1LOCAT[2] = "CL0LS74";

   /* GET OP0IS97*/
   /* *********************/
   /* set up data base key*/
   /* *********************/

  SY5REC.XGPCD = CLAREC.XGPCD; /* general prod.class*/
  SY5REC.SY1STNBR = CL0LW02.SY1STNBR[CL0LWCAX]; /* style*/
  SY5REC.SY2CLRID = CL0LW02.SY2CLRID[CL0LWCAX]; /* color*/
  SY5REC.XDMCD = CL0LW02.XDMCD[CL0LWCAX]; /* & dimension*/
  SY5REC.SY5SZID = CL0LW03.SY5SZID[CL0LWINX]; /* & size*/
  SY5REC.XPYCD = IVEREC.IVEPCTYP; /* price type code*/
  SY5REC.XQACD = CL0LW02.XQACD[CL0LWCAX]; /* quality code*/

  call "IO0380" ("S ", SQLCA, SY5REC) {isNoRefresh = yes, isExternal = yes}; /* i/o mod for single select*/

  if (SQLCA.VAGen_SQLCODE == 0) /* pick out price effec.today*/
    /* GET OP0IS28*/
     /* find current price among 6 possible prices*/
     /* new/future date is first, oldest date is last*/
     /* price effective date is today*/
    sysVar.arrayIndex = 1; /* check dates ascending seq*/
    while (sysVar.arrayIndex < 7)
      if (SY5REC.SY5PCEDT[sysVar.arrayIndex] <= CL0LW01.CL0LWPED)
                                   /* price effective date*/
        CL0LW03.CLNGRPRC[CL0LWINX] = SY5REC.SY5PRCUN[sysVar.arrayIndex] * CL0LWPCP / 100;
        CL0LW03.CLNNTPRC[CL0LWINX] = CL0LW03.CLNGRPRC[CL0LWINX];
        sysVar.arrayIndex = 9; /* force loop end*/
      end
      sysVar.arrayIndex = sysVar.arrayIndex + 1;
    end
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      CL0LW03.CLNGRPRC[CL0LWINX] = 0;
    else
      if (SQLCA.VAGen_SQLCODE == -911)
        converseLib.validationFailed(4); /* deadlock, retry action*/
        CLXREC.CLXERRF = "Y";
      else
        TA1REC.TA1DBASE = "DPROD"; /* data base name*/
        TA1REC.TA1TBLVU = "VPRICE01"; /* table view*/
        TA1REC.TA1TBLKE = SY5REC.SY5KEY; /* key value*/
        TA1REC.TA1LOCAT[4] = "IO0380"; /* i/o mod*/
        XPCL010(); /* common abend routine*/
      end
    end
  end



end // end KL0LS74

// move data from map to w.s.
Function KL0LS80()

  if (CL0LW01.CL0LWMOD[CLXLINEX] == "Y")
    /* next sentence*/
  else
    return;
  end

  if (CL0LW01.CL0LMSEL == "RC"
   || CL0LW01.CL0LMSEL == "RD"
   || CL0LW01.CL0LMSEL == "CA"
   || CL0LW01.CL0LMSEL == "DA"
   || CL0LW01.CL0LMSEL == "SA"
   || CL0LW01.CL0LMSEL == "A")
    CL0LW01.CL0LWMOD[CLXLINEX] = "N";
  end

  if (CL0LW01.CL0LMSEL == "S"
   || CL0LW01.CL0LMSEL == "A"
   || CL0LW01.CL0LMSEL == "SA")
    if (CL0LW02.CLICRDFL[CL0LWINX] == " ")
      KL0LM001.CLRRQTQ[CLXLINEX] = CL0LW02.CLRRQTQ[CL0LWINX];
      KL0LM001.CLRCLMQ[CLXLINEX] = CL0LW02.CLRCLMQ[CL0LWINX];
      KL0LM001.CLKPRCFF[CLXLINEX] = CL0LW02.CLKPRCFF[CL0LWINX];
      KL0LM001.CLAESTVL[CLXLINEX] = CL0LW02.CLAESTVL[CL0LWINX];
    end
  end

  if (CL0LW01.CL0LMSEL == "X"
   && CL0LW02.CL0LMLVL[CL0LWINX] == "P")
    KL0LM001.CLKPRCFF[CLXLINEX] = CL0LW02.CLKPRCFF[CL0LWINX];
    KL0LM001.CLAESTVL[CLXLINEX] = CL0LW02.CLAESTVL[CL0LWINX];
    if (CL0LW02.CLICRDFL[CL0LWINX] == "C")
      if (CL0LW02.CLRCLMQ[CL0LWINX] > 0)
        KL0LM001.CLRCLMQ[CLXLINEX] = CL0LW02.CLRCLMQ[CL0LWINX] * -1;
      else
        KL0LM001.CLRCLMQ[CLXLINEX] = CL0LW02.CLRCLMQ[CL0LWINX];
      end
      if (CL0LW02.CLRRQTQ[CL0LWINX] > 0)
        KL0LM001.CLRRQTQ[CLXLINEX] = CL0LW02.CLRRQTQ[CL0LWINX] * -1;
      else
        KL0LM001.CLRRQTQ[CLXLINEX] = CL0LW02.CLRRQTQ[CL0LWINX];
      end
    else
      if (CL0LW02.CLICRDFL[CL0LWINX] == "D")
        KL0LM001.CLRCLMQ[CLXLINEX] = CL0LW02.CLRCLMQ[CL0LWINX];
        KL0LM001.CLRRQTQ[CLXLINEX] = CL0LW02.CLRRQTQ[CL0LWINX];
      end
    end
  end

  if (CL0LW01.CL0LMSEL == "S")
    CL0LW02.CL0LMSEL[CL0LWINX] = CL0LW01.CL0LMSEL;
    return;
  end

  if (CL0LW01.CL0LMSEL == "X")
    CL0LW02.CL0LMSEL[CL0LWINX] = CL0LW01.CL0LMSEL;
    CL0LW02.CL0LWCHF[CL0LWINX] = "Y";
    return;
  end

  if (CL0LW01.CL0LMSEL == "A"
   || CL0LW01.CL0LMSEL == "SA")
    CL0LW01.CL0LMSEL = "S";
    sysVar.arrayIndex = 1;
    while (sysVar.arrayIndex < CLXREC.CLXLSTAX)
      if (CL0LW02.SY1STNBR[sysVar.arrayIndex] != " ")
        CL0LW02.CL0LMSEL[sysVar.arrayIndex] = "S";
      end
      sysVar.arrayIndex = sysVar.arrayIndex + 1;
    end

    sysVar.arrayIndex = 1;
    while (sysVar.arrayIndex <= CLXREC.CLXMAXLN[CLXSCRNX])
      if (KL0LM001.SY1STNBR[sysVar.arrayIndex] != " "
       || KL0LM005.SY1STNBR[sysVar.arrayIndex] != " ")
        KL0LM001.CL0LMSEL[sysVar.arrayIndex] = "S";
        KL0LM005.CL0LMSEL[sysVar.arrayIndex] = "S";
      end
      sysVar.arrayIndex = sysVar.arrayIndex + 1;
    end
    return;
  end

  if (CL0LW02.CL0LWCHF[CL0LWINX] != "A")
    CL0LW02.CL0LWCHF[CL0LWINX] = "Y";
  end

  CL0LW02.CLKPRCFF[CL0LWINX] = KL0LM001.CLKPRCFF[CLXLINEX];

  if (CL0LW02.CLKPRCFF[CL0LWINX] == "E"
   || CL0LW02.CLKPRCFF[CL0LWINX] == "P")
    CL0LW02.CLNGRPRC[CL0LWINX] = KL0LM001.CLNGRPRC[CLXLINEX];
    CL0LW02.CLNNTPRC[CL0LWINX] = KL0LM001.CLNGRPRC[CLXLINEX];
  end

  if (CL0LW02.CLICRDFL[CL0LWINX] == "C"
   || KL0LM001.CL0LMSEL[CLXLINEX] == "C")
    if (KL0LM001.CLRCLMQ[CLXLINEX] > 0)
      CL0LW02.CLRCLMQ[CL0LWINX] = KL0LM001.CLRCLMQ[CLXLINEX];
      KL0LM001.CLRCLMQ[CLXLINEX] = CL0LW02.CLRCLMQ[CL0LWINX] * -1;
    else
      CL0LW02.CLRCLMQ[CL0LWINX] = KL0LM001.CLRCLMQ[CLXLINEX] * -1;
    end
    if (KL0LM001.CLRRQTQ[CLXLINEX] > 0)
      CL0LW02.CLRRQTQ[CL0LWINX] = KL0LM001.CLRRQTQ[CLXLINEX];
      KL0LM001.CLRRQTQ[CLXLINEX] = CL0LW02.CLRRQTQ[CL0LWINX] * -1;
    else
      CL0LW02.CLRRQTQ[CL0LWINX] = KL0LM001.CLRRQTQ[CLXLINEX] * -1;
    end
  else
    CL0LW02.CLRCLMQ[CL0LWINX] = KL0LM001.CLRCLMQ[CLXLINEX];
    CL0LW02.CLRRQTQ[CL0LWINX] = KL0LM001.CLRRQTQ[CLXLINEX];
  end

  if (CL0LW01.CL0LMSEL == "CA")
    CL0LW01.CL0LMSEL = " ";
    KL0LM001.CL0LMSEL[CLXLINEX] = " ";
    CL0LW01.CL0LWALL = "Y";

    sysVar.arrayIndex = 1;
    while (sysVar.arrayIndex < CLXREC.CLXLSTAX)
      if (CL0LW02.SY1STNBR[sysVar.arrayIndex] != " "
       && CL0LW02.CL0LWDLT[sysVar.arrayIndex] != "X"
       && CL0LW02.CL0LMSEL[sysVar.arrayIndex] != "X"
       && CL0LW02.IV3LNSQ[sysVar.arrayIndex] != 0)
        if (CL0LW02.OP2PRCVF[sysVar.arrayIndex] == "Y"
         || CL0LW02.CL0LMLVL[sysVar.arrayIndex] == "S")
          CL0LW02.CL0LMSEL[sysVar.arrayIndex] = "S";
          converseLib.validationFailed(413);
        else
          CL0LW02.CLICRDFL[sysVar.arrayIndex] = "C";
          CL0LW02.CLRRQTQ[sysVar.arrayIndex] = CL0LW02.IV3LNSQ[sysVar.arrayIndex];
          CL0LW02.CLRCLMQ[sysVar.arrayIndex] = CL0LW02.IV3LNSQ[sysVar.arrayIndex];
          CL0LW02.SY5SZID[sysVar.arrayIndex] = 0;
          CL0LW02.CL0LMLVL[sysVar.arrayIndex] = "P";
          if (CL0LW02.CL0LWCHF[sysVar.arrayIndex] == "A")
            /* next sentence*/
          else
            CL0LW02.CL0LWCHF[sysVar.arrayIndex] = "Y";
          end
        end
      end
      sysVar.arrayIndex = sysVar.arrayIndex + 1;
    end

    sysVar.arrayIndex = 1;
    while (sysVar.arrayIndex <= CLXREC.CLXMAXLN[CLXSCRNX])
      if (KL0LM001.SY1STNBR[sysVar.arrayIndex] != " "
       && KL0LM001.IV3LNSQ[sysVar.arrayIndex] != 0)
        if (KL0LM001.CL0LMVPR[sysVar.arrayIndex] == "V"
         || KL0LM001.CL0LMLVL[sysVar.arrayIndex] == "Y")
          KL0LM001.CL0LMSEL[sysVar.arrayIndex] = "S";
          KL0LM005.CL0LMSEL[sysVar.arrayIndex] = "S";
        else
          KL0LM001.CL0LMSEL[sysVar.arrayIndex] = "C";
          KL0LM005.CL0LMSEL[sysVar.arrayIndex] = "C";
          CL0LW01.CL0LWIND = CL0LW01.CL0LWINX + sysVar.arrayIndex - 1;
          if (KL0LM001.CLRRQTQ[sysVar.arrayIndex] != 0)
            if (KL0LM001.CLRRQTQ[sysVar.arrayIndex] > 0)
              KL0LM001.CLRRQTQ[sysVar.arrayIndex] = KL0LM001.CLRRQTQ[sysVar.arrayIndex] * -1;
            end
            CL0LW02.CLRRQTQ[CL0LWIND] = KL0LM001.CLRRQTQ[sysVar.arrayIndex] * -1;
          else
            KL0LM001.CLRRQTQ[sysVar.arrayIndex] = KL0LM001.IV3LNSQ[sysVar.arrayIndex] * -1;
          end
          if (KL0LM001.CLRCLMQ[sysVar.arrayIndex] != 0)
            if (KL0LM001.CLRCLMQ[sysVar.arrayIndex] > 0)
              KL0LM001.CLRCLMQ[sysVar.arrayIndex] = KL0LM001.CLRCLMQ[sysVar.arrayIndex] * -1;
            end
            CL0LW02.CLRCLMQ[CL0LWIND] = KL0LM001.CLRCLMQ[sysVar.arrayIndex] * -1;
          else
            KL0LM001.CLRCLMQ[sysVar.arrayIndex] = KL0LM001.CLRRQTQ[sysVar.arrayIndex];
            CL0LW02.CLRCLMQ[CL0LWIND] = KL0LM001.CLRCLMQ[sysVar.arrayIndex] * -1;
          end
          CL0LW01.CL0LWOCQ[sysVar.arrayIndex] = KL0LM001.CLRCLMQ[sysVar.arrayIndex];
          CL0LW01.CL0LWORQ[sysVar.arrayIndex] = KL0LM001.CLRRQTQ[sysVar.arrayIndex];
          CL0LW01.CL0LWCLQ = KL0LM001.CLRCLMQ[sysVar.arrayIndex];
          CL0LW01.CL0LWPRI = KL0LM001.CLNGRPRC[sysVar.arrayIndex];
          CL0LW01.CL0LWECV = CL0LW01.CL0LWCLQ * CL0LW01.CL0LWPRI;
          CL0LW01.CL0LWOVL[sysVar.arrayIndex] = CL0LW01.CL0LWECV;
          KL0LM001.CLAESTVL[sysVar.arrayIndex] = CL0LW01.CL0LWECV;
        end
      end
      sysVar.arrayIndex = sysVar.arrayIndex + 1;
    end

    CL0LW01.CLRRQTQ[1] = 0;
    CL0LW01.CLRCLMQ[1] = 0;
    sysVar.arrayIndex = 1;
    while (sysVar.arrayIndex < CLXREC.CLXLSTAX)
      if (CL0LW02.SY1STNBR[sysVar.arrayIndex] != " "
       && CL0LW02.CL0LWDLT[sysVar.arrayIndex] != "X"
       && CL0LW02.CL0LMSEL[sysVar.arrayIndex] != "X"
       && CL0LW02.IV3LNSQ[sysVar.arrayIndex] != 0)
        KL0LSAT();
      end
      sysVar.arrayIndex = sysVar.arrayIndex + 1;
    end

    return;
  end

  if (CL0LW01.CL0LMSEL == "DA")
    CL0LW01.CL0LMSEL = " ";
    KL0LM001.CL0LMSEL[CLXLINEX] = " ";
    CL0LW01.CL0LWALL = "Y";

    sysVar.arrayIndex = 1;
    while (sysVar.arrayIndex < CLXREC.CLXLSTAX)
      if (CL0LW02.SY1STNBR[sysVar.arrayIndex] != " "
       && CL0LW02.CL0LWDLT[sysVar.arrayIndex] != "X"
       && CL0LW02.CL0LMSEL[sysVar.arrayIndex] != "X"
       && CL0LW02.IV3LNSQ[sysVar.arrayIndex] != 0)
        if (CL0LW02.OP2PRCVF[sysVar.arrayIndex] == "Y"
         || CL0LW02.CL0LMLVL[sysVar.arrayIndex] == "S")
          converseLib.validationFailed(413);
          CL0LW02.CL0LMSEL[sysVar.arrayIndex] = "S";
        else
          CL0LW02.CLICRDFL[sysVar.arrayIndex] = "D";
          CL0LW02.CLRRQTQ[sysVar.arrayIndex] = CL0LW02.IV3LNSQ[sysVar.arrayIndex];
          CL0LW02.CLRCLMQ[sysVar.arrayIndex] = CL0LW02.IV3LNSQ[sysVar.arrayIndex];
          CL0LW02.SY5SZID[sysVar.arrayIndex] = 0;
          CL0LW02.CL0LMLVL[sysVar.arrayIndex] = "P";
          if (CL0LW02.CL0LWCHF[sysVar.arrayIndex] == "A")
            /* next sentence*/
          else
            CL0LW02.CL0LWCHF[sysVar.arrayIndex] = "Y";
          end
        end
      end
      sysVar.arrayIndex = sysVar.arrayIndex + 1;
    end

    sysVar.arrayIndex = 1;
    while (sysVar.arrayIndex <= CLXREC.CLXMAXLN[CLXSCRNX])
      if (KL0LM001.SY1STNBR[sysVar.arrayIndex] != " "
       && KL0LM001.IV3LNSQ[sysVar.arrayIndex] != 0)
        if (KL0LM001.CL0LMVPR[sysVar.arrayIndex] == "V"
         || KL0LM001.CL0LMLVL[sysVar.arrayIndex] == "Y")
          KL0LM001.CL0LMSEL[sysVar.arrayIndex] = "S";
          KL0LM005.CL0LMSEL[sysVar.arrayIndex] = "S";
        else
          KL0LM001.CL0LMSEL[sysVar.arrayIndex] = "D";
          KL0LM005.CL0LMSEL[sysVar.arrayIndex] = "D";
          CL0LW01.CL0LWIND = CL0LW01.CL0LWINX + sysVar.arrayIndex - 1;
          if (KL0LM001.CLRRQTQ[sysVar.arrayIndex] != 0)
            CL0LW02.CLRRQTQ[CL0LWIND] = KL0LM001.CLRRQTQ[sysVar.arrayIndex];
          else
            KL0LM001.CLRRQTQ[sysVar.arrayIndex] = KL0LM001.IV3LNSQ[sysVar.arrayIndex];
          end
          if (KL0LM001.CLRCLMQ[sysVar.arrayIndex] != 0)
            CL0LW02.CLRCLMQ[CL0LWIND] = KL0LM001.CLRCLMQ[sysVar.arrayIndex];
          else
            KL0LM001.CLRCLMQ[sysVar.arrayIndex] = KL0LM001.CLRRQTQ[sysVar.arrayIndex];
            CL0LW02.CLRCLMQ[CL0LWIND] = KL0LM001.CLRRQTQ[sysVar.arrayIndex];
          end
          CL0LW01.CL0LWOCQ[sysVar.arrayIndex] = KL0LM001.CLRCLMQ[sysVar.arrayIndex];
          CL0LW01.CL0LWORQ[sysVar.arrayIndex] = KL0LM001.CLRRQTQ[sysVar.arrayIndex];
          CL0LW01.CL0LWCLQ = KL0LM001.CLRCLMQ[sysVar.arrayIndex];
          CL0LW01.CL0LWPRI = KL0LM001.CLNGRPRC[sysVar.arrayIndex];
          CL0LW01.CL0LWECV = CL0LW01.CL0LWCLQ * CL0LW01.CL0LWPRI;
          CL0LW01.CL0LWOVL[sysVar.arrayIndex] = CL0LW01.CL0LWECV;
          KL0LM001.CLAESTVL[sysVar.arrayIndex] = CL0LW01.CL0LWECV;
        end
      end
      sysVar.arrayIndex = sysVar.arrayIndex + 1;
    end

    CL0LW01.CLRRQTQ[1] = 0;
    CL0LW01.CLRCLMQ[1] = 0;
    sysVar.arrayIndex = 1;
    while (sysVar.arrayIndex < CLXREC.CLXLSTAX)
      if (CL0LW02.SY1STNBR[sysVar.arrayIndex] != " "
       && CL0LW02.CL0LWDLT[sysVar.arrayIndex] != "X"
       && CL0LW02.CL0LMSEL[sysVar.arrayIndex] != "X"
       && CL0LW02.IV3LNSQ[sysVar.arrayIndex] != 0)
        KL0LSAT();
      end
      sysVar.arrayIndex = sysVar.arrayIndex + 1;
    end

    return;
  end


  if (CL0LW01.CL0LMSEL == "C"
   || CL0LW01.CL0LMSEL == "D")
    if (CL0LW02.CLICRDFL[CL0LWINX] == " ")
      CL0LW02.CL0LWCHF[CL0LWINX] = "A";
    end
    CL0LW02.CLICRDFL[CL0LWINX] = CL0LW01.CL0LMSEL;
    KL0LM001.CLICRDFL[CLXLINEX] = CL0LW01.CL0LMSEL;
    KL0LM005.CLICRDFL[CLXLINEX] = CL0LW01.CL0LMSEL;
    CL0LW01.CL0LMSEL = " ";
    KL0LM001.CL0LMSEL[CLXLINEX] = " ";
    CL0LW02.SY5SZID[CL0LWINX] = 0;
    CL0LW02.CL0LMLVL[CL0LWINX] = "P";
    return;
  end

  if (CL0LW01.CL0LMSEL == "RC"
   || CL0LW01.CL0LMSEL == "RD")
    CL0LW01.CL0LWNAX = CLXREC.CLXLSTAX;
    sysVar.arrayIndex = 1;
    while (sysVar.arrayIndex < CLXREC.CLXLSTAX)
      if (CL0LW01.CL0LMSEL == "RC")
        if (CL0LW02.CLICRDFL[sysVar.arrayIndex] == "C")
          KL0LSSY();
        end
      else
        if (CL0LW01.CL0LMSEL == "RD")
          if (CL0LW02.CLICRDFL[sysVar.arrayIndex] == "D")
            KL0LSSY();
          end
        end
      end
      sysVar.arrayIndex = sysVar.arrayIndex + 1;
    end
    if (CL0LW01.CL0LWNAX > CLXREC.CLXLSTAX)
      sysVar.arrayIndex = CLXREC.CLXLSTAX;
      while (sysVar.arrayIndex < CL0LW01.CL0LWNAX)
        KL0LSAT();
        sysVar.arrayIndex = sysVar.arrayIndex + 1;
      end
      CLXREC.CLXARAYX = CLXREC.CLXLSTAX;
      CLXREC.CLXLSTAX = CL0LW01.CL0LWNAX;
      CL0LW01.CL0LWUPD = "Y";
      CLXREC.CLXBLDSC = "Y";
      CL0LW01.CL0LWALL = "Y";
      set KL0LM001.CL0LMSEL[1] initialAttributes;
    else
      set KL0LM001.CL0LMSEL[1] cursor, bold;
      if (converseVar.validationMsgNum == 0)
        if (CL0LW01.CL0LMSEL == "RC")
          converseLib.validationFailed(414);
        else
          converseLib.validationFailed(415);
        end
      end
    end
  end


end // end KL0LS80

// move data from map to w.s.
Function KL0LS81()

  if (CL0LW01.CL0LWMOD[CLXLINEX] == "Y")
    /* next sentence*/
  else
    return;
  end

  if (KL0LM010.CL0LMSEL[CLXLINEX] == "CA"
   || KL0LM010.CL0LMSEL[CLXLINEX] == "DA"
   || KL0LM010.CL0LMSEL[CLXLINEX] == "RC"
   || KL0LM010.CL0LMSEL[CLXLINEX] == "RD")
    CL0LW01.CL0LWMOD[CLXLINEX] = "N";
  end

  if (KL0LM010.CL0LMSEL[CLXLINEX] == "X")
    KL0LM010.CLKPRCFF[CLXLINEX] = CL0LW03.CLKPRCFF[CL0LWINX];
    if (CL0LW03.CLICRDFL[CL0LWINX] == "C")
      if (CL0LW03.CLRCLMQ[CL0LWINX] > 0)
        KL0LM010.CLRCLMQ[CLXLINEX] = CL0LW03.CLRCLMQ[CL0LWINX] * -1;
      else
        KL0LM010.CLRCLMQ[CLXLINEX] = CL0LW03.CLRCLMQ[CL0LWINX];
      end
      if (CL0LW03.CLRRQTQ[CL0LWINX] > 0)
        KL0LM010.CLRRQTQ[CLXLINEX] = CL0LW03.CLRRQTQ[CL0LWINX] * -1;
      else
        KL0LM010.CLRRQTQ[CLXLINEX] = CL0LW03.CLRRQTQ[CL0LWINX];
      end
    else
      if (CL0LW03.CLICRDFL[CL0LWINX] == "D")
        KL0LM010.CLRCLMQ[CLXLINEX] = CL0LW03.CLRCLMQ[CL0LWINX];
        KL0LM010.CLRRQTQ[CLXLINEX] = CL0LW03.CLRRQTQ[CL0LWINX];
      end
    end
  end

  if (KL0LM010.CL0LMSEL[CLXLINEX] == "X")
    CL0LW03.CL0LMSEL[CL0LWINX] = KL0LM010.CL0LMSEL[CLXLINEX];
    CL0LW03.CL0LWCHF[CL0LWINX] = "Y";
    return;
  end

  if (CL0LW03.CL0LWCHF[CL0LWINX] != "A")
    CL0LW03.CL0LWCHF[CL0LWINX] = "Y";
  end

  CL0LW03.CLKPRCFF[CL0LWINX] = KL0LM010.CLKPRCFF[CLXLINEX];

  if (CL0LW03.CLKPRCFF[CL0LWINX] == "E"
   || CL0LW03.CLKPRCFF[CL0LWINX] == "P")
    CL0LW03.CLNGRPRC[CL0LWINX] = KL0LM010.CLNGRPRC[CLXLINEX];
    CL0LW03.CLNNTPRC[CL0LWINX] = KL0LM010.CLNGRPRC[CLXLINEX];
  end

  if (CL0LW03.CLICRDFL[CL0LWINX] == "C"
   || KL0LM010.CL0LMSEL[CLXLINEX] == "C")
    if (KL0LM010.CLRCLMQ[CLXLINEX] > 0)
      CL0LW03.CLRCLMQ[CL0LWINX] = KL0LM010.CLRCLMQ[CLXLINEX];
      KL0LM010.CLRCLMQ[CLXLINEX] = CL0LW03.CLRCLMQ[CL0LWINX] * -1;
    else
      CL0LW03.CLRCLMQ[CL0LWINX] = KL0LM010.CLRCLMQ[CLXLINEX] * -1;
    end
    if (KL0LM010.CLRRQTQ[CLXLINEX] > 0)
      CL0LW03.CLRRQTQ[CL0LWINX] = KL0LM010.CLRRQTQ[CLXLINEX];
      KL0LM010.CLRRQTQ[CLXLINEX] = CL0LW03.CLRRQTQ[CL0LWINX] * -1;
    else
      CL0LW03.CLRRQTQ[CL0LWINX] = KL0LM010.CLRRQTQ[CLXLINEX] * -1;
    end
  else
    CL0LW03.CLRCLMQ[CL0LWINX] = KL0LM010.CLRCLMQ[CLXLINEX];
    CL0LW03.CLRRQTQ[CL0LWINX] = KL0LM010.CLRRQTQ[CLXLINEX];
  end

  if (KL0LM010.CL0LMSEL[CLXLINEX] == "CA")
    KL0LM010.CL0LMSEL[CLXLINEX] = " ";
    CL0LW02.CL0LMLVL[CL0LWCAX] = "S";
    CL0LW01.CL0LWALL = "Y";

    if (CL0LW02.CLICRDFL[CL0LWCAX] == " ")
      CL0LW02.CLICRDFL[CL0LWCAX] = "C";
    end

    sysVar.arrayIndex = 1;
    while (sysVar.arrayIndex < CLXREC.CLXLSTSZ)
      if (CL0LW03.SY5SZID[sysVar.arrayIndex] != 0
       && CL0LW03.CL0LWDLT[sysVar.arrayIndex] != "X"
       && CL0LW03.CL0LMSEL[sysVar.arrayIndex] != "X"
       && CL0LW03.IV4SHPQ[sysVar.arrayIndex] != 0)
        CL0LW03.CLICRDFL[sysVar.arrayIndex] = "C";
        CL0LW03.CLRRQTQ[sysVar.arrayIndex] = CL0LW03.IV4SHPQ[sysVar.arrayIndex];
        CL0LW03.CLRCLMQ[sysVar.arrayIndex] = CL0LW03.IV4SHPQ[sysVar.arrayIndex];
        if (CL0LW03.CL0LWCHF[sysVar.arrayIndex] == "A")
          /* next sentence*/
        else
          CL0LW03.CL0LWCHF[sysVar.arrayIndex] = "Y";
        end
      end
      sysVar.arrayIndex = sysVar.arrayIndex + 1;
    end

    sysVar.arrayIndex = 1;
    while (sysVar.arrayIndex <= CLXREC.CLXMAXLN[CLXSCRNX])
      if (KL0LM010.SY4IDDSC[sysVar.arrayIndex] != " "
       && KL0LM010.IV4SHPQ[sysVar.arrayIndex] != 0)
        KL0LM010.CLICRDFL[sysVar.arrayIndex] = "C";
        CL0LW01.CL0LWIND = CL0LW01.CL0LWINX + sysVar.arrayIndex - 1;
        if (KL0LM010.CLRRQTQ[sysVar.arrayIndex] != 0)
          if (KL0LM010.CLRRQTQ[sysVar.arrayIndex] > 0)
            KL0LM010.CLRRQTQ[sysVar.arrayIndex] = KL0LM010.CLRRQTQ[sysVar.arrayIndex] * -1;
          end
          CL0LW03.CLRRQTQ[sysVar.arrayIndex] = KL0LM010.CLRRQTQ[sysVar.arrayIndex] * -1;
        else
          KL0LM010.CLRRQTQ[sysVar.arrayIndex] = KL0LM010.IV4SHPQ[sysVar.arrayIndex] * -1;
        end
        if (KL0LM010.CLRCLMQ[sysVar.arrayIndex] != 0)
          if (KL0LM010.CLRCLMQ[sysVar.arrayIndex] > 0)
            KL0LM010.CLRCLMQ[sysVar.arrayIndex] = KL0LM010.CLRCLMQ[sysVar.arrayIndex] * -1;
          end
          CL0LW03.CLRCLMQ[sysVar.arrayIndex] = KL0LM010.CLRCLMQ[sysVar.arrayIndex] * -1;
        else
          KL0LM010.CLRCLMQ[sysVar.arrayIndex] = KL0LM010.CLRRQTQ[sysVar.arrayIndex];
          CL0LW03.CLRCLMQ[sysVar.arrayIndex] = KL0LM010.CLRCLMQ[sysVar.arrayIndex] * -1;
        end
        CL0LW01.CL0LWOCQ[sysVar.arrayIndex] = KL0LM010.CLRCLMQ[sysVar.arrayIndex] * -1;
        CL0LW01.CL0LWORQ[sysVar.arrayIndex] = KL0LM010.CLRRQTQ[sysVar.arrayIndex] * -1;
        CL0LW01.CL0LWCLQ = KL0LM010.CLRCLMQ[sysVar.arrayIndex];
        CL0LW01.CL0LWPRI = KL0LM010.CLNGRPRC[sysVar.arrayIndex];
        CL0LW01.CL0LWECV = CL0LW01.CL0LWCLQ * CL0LW01.CL0LWPRI;
        CL0LW01.CL0LWOVL[sysVar.arrayIndex] = CL0LW01.CL0LWECV;
        KL0LM010.CLAESTVL[sysVar.arrayIndex] = CL0LW01.CL0LWECV;
      end
      sysVar.arrayIndex = sysVar.arrayIndex + 1;
    end

    sysVar.arrayIndex = 1;
    while (sysVar.arrayIndex < CLXREC.CLXLSTSZ)
      if (CL0LW03.SY5SZID[sysVar.arrayIndex] != 0
       && CL0LW03.CL0LWDLT[sysVar.arrayIndex] != "X"
       && CL0LW03.CL0LMSEL[sysVar.arrayIndex] != "X"
       && CL0LW03.IV4SHPQ[sysVar.arrayIndex] != 0)
        KL0LSST();
      end
      sysVar.arrayIndex = sysVar.arrayIndex + 1;
    end

    return;
  end

  if (KL0LM010.CL0LMSEL[CLXLINEX] == "DA")
    KL0LM010.CL0LMSEL[CLXLINEX] = " ";
    CL0LW02.CL0LMLVL[CL0LWCAX] = "S";
    CL0LW01.CL0LWALL = "Y";

    if (CL0LW02.CLICRDFL[CL0LWCAX] == " ")
      CL0LW02.CLICRDFL[CL0LWCAX] = "D";
    end

    sysVar.arrayIndex = 1;
    while (sysVar.arrayIndex < CLXREC.CLXLSTSZ)
      if (CL0LW03.SY5SZID[sysVar.arrayIndex] != 0
       && CL0LW03.CL0LWDLT[sysVar.arrayIndex] != "X"
       && CL0LW03.CL0LMSEL[sysVar.arrayIndex] != "X"
       && CL0LW03.IV4SHPQ[sysVar.arrayIndex] != 0)
        CL0LW03.CLICRDFL[sysVar.arrayIndex] = "D";
        CL0LW03.CLRRQTQ[sysVar.arrayIndex] = CL0LW03.IV4SHPQ[sysVar.arrayIndex];
        CL0LW03.CLRCLMQ[sysVar.arrayIndex] = CL0LW03.IV4SHPQ[sysVar.arrayIndex];
        if (CL0LW03.CL0LWCHF[sysVar.arrayIndex] == "A")
          /* next sentence*/
        else
          CL0LW03.CL0LWCHF[sysVar.arrayIndex] = "Y";
        end
      end
      sysVar.arrayIndex = sysVar.arrayIndex + 1;
    end

    sysVar.arrayIndex = 1;
    while (sysVar.arrayIndex <= CLXREC.CLXMAXLN[CLXSCRNX])
      if (KL0LM010.SY4IDDSC[sysVar.arrayIndex] != " "
       && KL0LM010.IV4SHPQ[sysVar.arrayIndex] != 0)
        KL0LM010.CLICRDFL[sysVar.arrayIndex] = "D";
        CL0LW01.CL0LWIND = CL0LW01.CL0LWINX + sysVar.arrayIndex - 1;
        if (KL0LM010.CLRRQTQ[sysVar.arrayIndex] != 0)
          CL0LW03.CLRRQTQ[sysVar.arrayIndex] = KL0LM010.CLRRQTQ[sysVar.arrayIndex];
        else
          KL0LM010.CLRRQTQ[sysVar.arrayIndex] = KL0LM010.IV4SHPQ[sysVar.arrayIndex];
        end
        if (KL0LM010.CLRCLMQ[sysVar.arrayIndex] != 0)
          CL0LW03.CLRCLMQ[sysVar.arrayIndex] = KL0LM010.CLRCLMQ[sysVar.arrayIndex];
        else
          KL0LM010.CLRCLMQ[sysVar.arrayIndex] = KL0LM010.CLRRQTQ[sysVar.arrayIndex];
          CL0LW03.CLRCLMQ[sysVar.arrayIndex] = KL0LM010.CLRRQTQ[sysVar.arrayIndex];
        end
        CL0LW01.CL0LWOCQ[sysVar.arrayIndex] = KL0LM010.CLRCLMQ[sysVar.arrayIndex];
        CL0LW01.CL0LWORQ[sysVar.arrayIndex] = KL0LM010.CLRRQTQ[sysVar.arrayIndex];
        CL0LW01.CL0LWCLQ = KL0LM010.CLRCLMQ[sysVar.arrayIndex];
        CL0LW01.CL0LWPRI = KL0LM010.CLNGRPRC[sysVar.arrayIndex];
        CL0LW01.CL0LWECV = CL0LW01.CL0LWCLQ * CL0LW01.CL0LWPRI;
        CL0LW01.CL0LWOVL[sysVar.arrayIndex] = CL0LW01.CL0LWECV;
        KL0LM010.CLAESTVL[sysVar.arrayIndex] = CL0LW01.CL0LWECV;
      end
      sysVar.arrayIndex = sysVar.arrayIndex + 1;
    end

    sysVar.arrayIndex = 1;
    while (sysVar.arrayIndex < CLXREC.CLXLSTSZ)
      if (CL0LW03.SY5SZID[sysVar.arrayIndex] != 0
       && CL0LW03.CL0LWDLT[sysVar.arrayIndex] != "X"
       && CL0LW03.CL0LMSEL[sysVar.arrayIndex] != "X"
       && CL0LW03.IV4SHPQ[sysVar.arrayIndex] != 0)
        KL0LSST();
      end
      sysVar.arrayIndex = sysVar.arrayIndex + 1;
    end

    return;
  end


  if (KL0LM010.CL0LMSEL[CLXLINEX] == "C"
   || KL0LM010.CL0LMSEL[CLXLINEX] == "D")
    if (CL0LW03.CLICRDFL[CL0LWINX] == " ")
      CL0LW03.CL0LWCHF[CL0LWINX] = "A";
    end
    CL0LW03.CLICRDFL[CL0LWINX] = KL0LM010.CL0LMSEL[CLXLINEX];
    KL0LM010.CLICRDFL[CLXLINEX] = KL0LM010.CL0LMSEL[CLXLINEX];
    KL0LM010.CL0LMSEL[CLXLINEX] = " ";
    CL0LW02.CL0LMLVL[CL0LWCAX] = "S";
    if (CL0LW02.CLICRDFL[CL0LWCAX] == " ")
      CL0LW02.CLICRDFL[CL0LWCAX] = CL0LW03.CLICRDFL[CL0LWINX];
    end
    return;
  end

  if (KL0LM010.CL0LMSEL[CLXLINEX] == "RC"
   || KL0LM010.CL0LMSEL[CLXLINEX] == "RD")
    CL0LW01.CL0LWNSZ = CLXREC.CLXLSTSZ;
    sysVar.arrayIndex = 1;
    while (sysVar.arrayIndex < CLXREC.CLXLSTSZ)
      if (KL0LM010.CL0LMSEL[CLXLINEX] == "RC")
        if (CL0LW03.CLICRDFL[sysVar.arrayIndex] == "C")
          KL0LSSZ();
        end
      else
        if (KL0LM010.CL0LMSEL[CLXLINEX] == "RD")
          if (CL0LW03.CLICRDFL[sysVar.arrayIndex] == "D")
            KL0LSSZ();
          end
        end
      end
      sysVar.arrayIndex = sysVar.arrayIndex + 1;
    end
    if (CL0LW01.CL0LWNSZ > CLXREC.CLXLSTSZ)
      CL0LW02.CLICRDFL[CL0LWCAX] = "B";
      sysVar.arrayIndex = CLXREC.CLXLSTSZ;
      while (sysVar.arrayIndex < CL0LW01.CL0LWNSZ)
        KL0LSST();
        sysVar.arrayIndex = sysVar.arrayIndex + 1;
      end
      CLXREC.CLXLSTSZ = CL0LW01.CL0LWNSZ;
      CL0LW01.CL0LWUPD = "Y";
      CLXREC.CLXBLDSC = "Y";
      CL0LW01.CL0LWALL = "Y";
      CLXREC.CLXCURSZ = 1;
      set KL0LM010.CL0LMSEL[1] initialAttributes;
    else
      set KL0LM010.CL0LMSEL[1] cursor, bold;
      if (converseVar.validationMsgNum == 0)
        if (KL0LM010.CL0LMSEL[CLXLINEX] == "RC")
          converseLib.validationFailed(414);
        else
          converseLib.validationFailed(415);
        end
      end
    end
  end


end // end KL0LS81

// add clm adj record
Function KL0LSAD()


    /* Maintenance History:*/
    /* 04-10-90 CHELLM added XUMCD and XQACD to the product key*/
                    /* for selecting invoice price overrides.*/
    /* 01-13-92 sgorga Add xbk-bk-sesn-cd & op-bk-yr as fields to*/
    /* be moved from the cl0lw02 rec to clrrec.*/
    /* 04-17-92 sgorga Added op-bk-mo (following wherever*/
    /* op-bk-yr is used).*/
    /* 10-30-97 RCHAUV reason code conversion - no more S10*/
   /* *************************************************************/

   /* ***********************************/
   /* *  add data base adjustment record*/
   /* ***********************************/

  set CLRREC empty; /* initialize record*/

  TA1REC.TA1LOCAT[2] = "CL0LSAD";

     /* ****************************/
     /* mark need to change clm hdr*/
     /* ****************************/

  CL0LW01.CLADJIND = "Y"; /* clm hdr has adjustment recs*/
  CL0LW01.CL0LWAUP = "Y"; /* flag clm hdr for update*/
  CL0LW01.CLBSRIND = "Y"; /* inv adjustment indicator*/
  CL0LW01.CL0LWBUP = "Y"; /* flag to update clbrec*/


      /* *******************************************/
      /* move key data to clrrec, incl change count*/
      /* *******************************************/

  CLRREC.CLACLMNB = CLAREC.CLACLMNB; /* claim number*/
  CLRREC.CLHSEQNB = CLAREC.CLACSQNB; /* sequence number*/
  CLRREC.IV0PARTN = CL0LW02.IV0PARTN; /* invoice nbr*/
  CLRREC.IV0IVCID = CL0LW02.IV0IVCID;

  CLRREC.XGPCD = CLAREC.XGPCD;
  if (CLXREC.CLXSCRNX != 3) /* diff for diff maps*/
    CLRREC.CLICRDFL = CL0LW02.CLICRDFL[CLXARAYX]; /* cr or db*/
    CLRREC.SY1STNBR = CL0LW02.SY1STNBR[CLXARAYX];
    CLRREC.SY2CLRID = CL0LW02.SY2CLRID[CLXARAYX];
    CLRREC.XDMCD = CL0LW02.XDMCD[CLXARAYX];
    CLRREC.SY5SZID = CL0LW02.SY5SZID[CLXARAYX];
    CLRREC.OP2LNINB = CL0LW02.OP2LNINB[CLXARAYX];
    CLRREC.ZZZCHGCT = CL0LW02.ZZZCHGCT[CLXARAYX];
  else
    CLRREC.CLICRDFL = CL0LW03.CLICRDFL[CLXCURSZ]; /* cr or db*/
    CLRREC.SY1STNBR = CL0LW02.SY1STNBR[CL0LWCAX];
    CLRREC.SY2CLRID = CL0LW02.SY2CLRID[CL0LWCAX];
    CLRREC.XDMCD = CL0LW02.XDMCD[CL0LWCAX];
    CLRREC.SY5SZID = CL0LW03.SY5SZID[CLXCURSZ];
    CLRREC.OP2LNINB = CL0LW02.OP2LNINB[CL0LWCAX];
    CLRREC.ZZZCHGCT = CL0LW03.ZZZCHGCT[CLXCURSZ];
  end


     /* *************************************/
     /* check for cr/db to mark claim header*/
     /* *************************************/

  if (CLRREC.CLICRDFL == "D") /* if debit entry*/
    if (CL0LW01.CLADBOCL == "N") /* and clm hdr not marked*/
      CL0LW01.CLADBOCL = "Y"; /* mark claim header*/
    end
  end


      /* move in clrrec data*/

  if (CLXREC.CLXSCRNX != 3)
    CLRREC.XQACD = CL0LW02.XQACD[CLXARAYX];
    CLRREC.XUMCD = CL0LW02.XUMCD[CLXARAYX];
    CLRREC.XCOCD = CL0LW02.XCOCD[CLXARAYX];
    CLRREC.XBK-BK-SESN-CD = CL0LW02.XBK-BK-SESN-CD[CLXARAYX];
                                   /* sgorga*/
    CLRREC.OP-BK-YR = CL0LW02.OP-BK-YR[CLXARAYX]; /* sgorga*/
    CLRREC.OP-BK-MO = CL0LW02.OP-BK-MO[CLXARAYX]; /* sgorga 4-17*/

    CLRREC.CLNGRPRC = CL0LW02.CLNGRPRC[CLXARAYX];
    CLRREC.CLNNTPRC = CL0LW02.CLNNTPRC[CLXARAYX];
    CLRREC.CLKPRCFF = CL0LW02.CLKPRCFF[CLXARAYX];
    if (CL0LW02.CLRRQTQ[CLXARAYX] < 0)
      CLRREC.CLRRQTQ = CL0LW02.CLRRQTQ[CLXARAYX] * -1;
    else
      CLRREC.CLRRQTQ = CL0LW02.CLRRQTQ[CLXARAYX];
    end
    if (CL0LW02.CLRCLMQ[CLXARAYX] < 0)
      CLRREC.CLRCLMQ = CL0LW02.CLRCLMQ[CLXARAYX] * -1;
    else
      CLRREC.CLRCLMQ = CL0LW02.CLRCLMQ[CLXARAYX];
    end
  else
    CLRREC.XQACD = CL0LW02.XQACD[CL0LWCAX];
    CLRREC.XUMCD = CL0LW02.XUMCD[CL0LWCAX];
    CLRREC.XCOCD = CL0LW02.XCOCD[CL0LWCAX];
    CLRREC.XBK-BK-SESN-CD = CL0LW02.XBK-BK-SESN-CD[CL0LWCAX];
                                   /* sgorga*/
    CLRREC.OP-BK-YR = CL0LW02.OP-BK-YR[CL0LWCAX]; /* sgorga*/
    CLRREC.OP-BK-MO = CL0LW02.OP-BK-MO[CL0LWCAX]; /* sgorga 4-17*/

    CLRREC.CLNGRPRC = CL0LW03.CLNGRPRC[CLXCURSZ];
    CLRREC.CLNNTPRC = CL0LW03.CLNNTPRC[CLXCURSZ];
    CLRREC.CLKPRCFF = CL0LW03.CLKPRCFF[CLXCURSZ];
    if (CL0LW03.CLRRQTQ[CLXCURSZ] < 0)
      CLRREC.CLRRQTQ = CL0LW03.CLRRQTQ[CLXCURSZ] * -1;
    else
      CLRREC.CLRRQTQ = CL0LW03.CLRRQTQ[CLXCURSZ];
    end
    if (CL0LW03.CLRCLMQ[CLXCURSZ] < 0)
      CLRREC.CLRCLMQ = CL0LW03.CLRCLMQ[CLXCURSZ] * -1;
    else
      CLRREC.CLRCLMQ = CL0LW03.CLRCLMQ[CLXCURSZ];
    end
  end


  TA2REC.TA2RTNCD = 0; /* get curr data/time*/
  TA2REC.TA2DTOPT = "GETDATE";

  call "TA0040" (TA2REC) {isNoRefresh = yes, isExternal = yes};

  if (TA2REC.TA2RTNCD == 0)
    CLRREC.ZZZCHGDT = TA2REC.TA2GRGGN;
    CLRREC.ZZZCHGTM = TA2REC.TA2TIMHM;
  else
    CLRREC.ZZZCHGDT = 0;
    CLRREC.ZZZCHGTM = 0;
  end


  call "IO1370" ("A ", SQLCA, CLRREC) {isNoRefresh = yes, isExternal = yes}; /* add record*/

  if (SQLCA.VAGen_SQLCODE == 0)
     /* all o.k.*/
  else
    TA1REC.TA1DBASE = "DCLAIM";
    TA1REC.TA1TBLVU = "VCLADJ01";
    XPCL010(); /* abend*/
  end

  if (CLXREC.CLXSCRNX != 3)
    if (CLRREC.CLICRDFL == "C"
     && CLRREC.CLKPRCFF == "I")
      CL0LW01.CLICRDFL = "D";
      CL0LW01.XGPCD = CLRREC.XGPCD;
      CL0LW01.SY1STNBR = CLRREC.SY1STNBR;
      CL0LW01.SY2CLRID = CLRREC.SY2CLRID;
      CL0LW01.XDMCD = CLRREC.XDMCD;
      CL0LW01.XQACD = CLRREC.XQACD;
      CL0LW01.XUMCD = CLRREC.XUMCD;
      CL0LW01.CLKPRCFF = "E";
      if (CL0LW01.CL0LWKEY in CL0LW02.CL0LWKEY)
        CL0LW01.CL6OVPRC = CL0LW02.CLNGRPRC[sysVar.arrayIndex];
        KL0LSAO(); /* add price override*/
      else
        CL0LW01.CLKPRCFF = "P";
        if (CL0LW01.CL0LWKEY in CL0LW02.CL0LWKEY)
          CL0LW01.CL6OVPRC = CL0LW02.CLNGRPRC[sysVar.arrayIndex];
          KL0LSAO(); /* add price override*/
        end
      end
    else
      if (CLRREC.CLICRDFL == "D")
        if (CLRREC.CLKPRCFF == "E"
         || CLRREC.CLKPRCFF == "P")
          CL0LW01.CLICRDFL = "C";
          CL0LW01.XGPCD = CLRREC.XGPCD;
          CL0LW01.SY1STNBR = CLRREC.SY1STNBR;
          CL0LW01.SY2CLRID = CLRREC.SY2CLRID;
          CL0LW01.XDMCD = CLRREC.XDMCD;
          CL0LW01.XQACD = CLRREC.XQACD;
          CL0LW01.XUMCD = CLRREC.XUMCD;
          CL0LW01.SY5SZID = CLRREC.SY5SZID;
          CL0LW01.CLKPRCFF = "I";
           /* IF CLAREC.YCRCD EQ 'S10' OR*/
           /* NO MORE S10 - 10/30/97 rchauv*/
          if (CL0LW01.CL0LWKEY in CL0LW02.CL0LWKEY)
            CL0LW01.CL6OVPRC = CLRREC.CLNGRPRC;
            KL0LSAO(); /* add price override*/
          else
            CL0LW01.CLKPRCFF = "O";
            if (CL0LW01.CL0LWKEY in CL0LW02.CL0LWKEY)
              CL0LW01.CL6OVPRC = CLRREC.CLNGRPRC;
              KL0LSAO(); /* add price override*/
            end
          end
        end
      end
    end
  else
    if (CLRREC.CLICRDFL == "C"
     && CLRREC.CLKPRCFF == "I")
      CL0LW01.CL0LWCDF = "D";
      CL0LW01.CL0LWSIZ = CLRREC.SY5SZID;
      CL0LW01.CL0LWPFF = "E";
      if (CL0LW01.CL0LWKY3 in CL0LW03.CL0LWKY3)
        CL0LW01.CL6OVPRC = CL0LW03.CLNGRPRC[sysVar.arrayIndex];
        KL0LSAO(); /* add price override*/
      else
        CL0LW01.CL0LWPFF = "P";
        if (CL0LW01.CL0LWKY3 in CL0LW03.CL0LWKY3)
          CL0LW01.CL6OVPRC = CL0LW03.CLNGRPRC[sysVar.arrayIndex];
          KL0LSAO(); /* add price override*/
        end
      end
    else
      if (CLRREC.CLICRDFL == "D")
        if (CLRREC.CLKPRCFF == "E"
         || CLRREC.CLKPRCFF == "P")
          CL0LW01.CL0LWCDF = "C";
          CL0LW01.CL0LWSIZ = CLRREC.SY5SZID;
          CL0LW01.CL0LWPFF = "I";
          /* IF CLAREC.YCRCD EQ 'S10'  /* NO MORE S10 - 10/39/97 RCHAUV*/
           /* IF CL0LW01.CL0LWKY3 IN CL0LW03.CL0LWKY3;*/
           /* MOVE CLRREC.CLNGRPRC TO CL0LW01.CL6OVPRC;*/
           /* KL0LSAO;               /* add price override*/
           /* ELSE;*/
           /* MOVE 'O' TO CL0LW01.CL0LWPFF;*/
           /* IF CL0LW01.CL0LWKY3 IN CL0LW03.CL0LWKY3;*/
           /* MOVE CLRREC.CLNGRPRC TO CL0LW01.CL6OVPRC;*/
           /* KL0LSAO;             /* add price override*/
           /* END;*/
          /* END;*/
        end
      end
    end
  end


end // end KL0LSAD

// check price override to add
Function KL0LSAO()


    /* Maintenance History:*/
    /* 04-10-90 CHELLM Added XQACD and XUMCD to the product key*/
                    /* when selecting invoice price overrides.*/

   /* *************************************************************/

  CLXREC.CLXCPROC = "CL0LSAO";

  set CL6REC empty;
  CL6REC.IV0PARTN = CLRREC.IV0PARTN;
  CL6REC.IV0IVCID = CLRREC.IV0IVCID;
  CL6REC.XGPCD = CLRREC.XGPCD;
  CL6REC.SY1STNBR = CLRREC.SY1STNBR;
  CL6REC.SY2CLRID = CLRREC.SY2CLRID;
  CL6REC.XDMCD = CLRREC.XDMCD;
  CL6REC.XQACD = CLRREC.XQACD;
  CL6REC.XUMCD = CLRREC.XUMCD;
  CL6REC.SY5SZID = CLRREC.SY5SZID;
  CL6REC.CLACLMNB = CLRREC.CLACLMNB;

  call "IO2950" ("S ", SQLCA, CL6REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      /* next sentence*/
    else
      if (SQLCA.VAGen_SQLCODE == -911)
        converseLib.validationFailed(4);
        CLXREC.CLXERRF = "Y";
        VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
        VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
        sysLib.rollback();
        VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
        
        return;
      else
        TA1REC.TA1LOCAT[2] = "CL0LSAO";
        TA1REC.TA1LOCAT[4] = "IO2950";
        TA1REC.TA1DBASE = "DCLAIM";
        TA1REC.TA1TBLVU = "VIVOVR01";
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE;
        XPCL010();
      end
    end
  end

  set CL6REC empty;
  CL6REC.IV0PARTN = CLRREC.IV0PARTN;
  CL6REC.IV0IVCID = CLRREC.IV0IVCID;
  CL6REC.XGPCD = CLRREC.XGPCD;
  CL6REC.SY1STNBR = CLRREC.SY1STNBR;
  CL6REC.SY2CLRID = CLRREC.SY2CLRID;
  CL6REC.XDMCD = CLRREC.XDMCD;
  CL6REC.XQACD = CLRREC.XQACD;
  CL6REC.XUMCD = CLRREC.XUMCD;
  CL6REC.SY5SZID = CLRREC.SY5SZID;
  CL6REC.CLACLMNB = CLRREC.CLACLMNB;
  CL6REC.CL6OVPRC = CL0LW01.CL6OVPRC;
  CL6REC.CLHMEMNB = 0;
  CL6REC.ZZZCHGDT = TA2REC.TA2GRGGN;
  CL6REC.ZZZCHGTM = TA2REC.TA2TIMHM;
  CL6REC.ZZZCHGCT = 0;

  call "IO2950" ("A ", SQLCA, CL6REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    CL0LW01.CL0LWPFL = "Y";
  else
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4);
      CLXREC.CLXERRF = "Y";
      VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
      VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
      sysLib.rollback();
      VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
      
      return;
    else
      TA1REC.TA1LOCAT[2] = "CL0LSAO";
      TA1REC.TA1LOCAT[4] = "IO2950";
      TA1REC.TA1DBASE = "DCLAIM";
      TA1REC.TA1TBLVU = "VIVOVR01";
      CLXREC.XXXWDTE = CLAREC.CLACLMNB;
      TA1REC.TA1TBLKE = CLXREC.XXXWDTE;
      XPCL010();
    end
  end

end // end KL0LSAO

// map 1 ca/da accum totals
Function KL0LSAT()
   /* GET CL0LSPT*/
         /* * * * ********************** * **/
       /* *                                  **/
     /* *       keep similar to cl0lspt        **/
       /* *                                  **/
         /* * * * ********************** * **/

     /* old/original values = 0 for credit all/debit all*/
     /* index is ezetst, not clxlinex*/

     /* *******************************************************/
     /* if debit line, add to map totals and to clarec totals*/
     /* if credit line, subtract from map totals & clarec tots*/
     /* if neither, skip totaling*/
     /* *******************************************************/

  if (CL0LW02.CLICRDFL[sysVar.arrayIndex] == "D") /* add in debit change*/
    CL0LW01.CLRRQTQ[1] = CL0LW01.CLRRQTQ[1] + CL0LW02.CLRRQTQ[sysVar.arrayIndex];

    CL0LW01.CLRCLMQ[1] = CL0LW01.CLRCLMQ[1] + CL0LW02.CLRCLMQ[sysVar.arrayIndex];
     /* also add clarec total qty*/
    CL0LW01.CL0LWQCH = CL0LW01.CL0LWQCH + CL0LW02.CLRCLMQ[sysVar.arrayIndex];

    if (CL0LW02.IVANBLFL == "Y") /* net bill flag*/
      CL0LW01.CLAESTVL = CL0LW02.CLNNTPRC[sysVar.arrayIndex] * CL0LW02.CLRCLMQ[sysVar.arrayIndex];
    else
      CL0LW01.CLAESTVL = CL0LW02.CLNGRPRC[sysVar.arrayIndex] * CL0LW02.CLRCLMQ[sysVar.arrayIndex];
    end
    CL0LW01.CL0LWTVL[1] = CL0LW01.CL0LWTVL[1] + CL0LW01.CLAESTVL;
     /* also add clarec total value*/
    CL0LW01.CL0LWVCH = CL0LW01.CL0LWVCH + CL0LW01.CLAESTVL;
  else
    if (CL0LW02.CLICRDFL[sysVar.arrayIndex] == "C") /* subtract out credit chgs*/
      CL0LW01.CLRRQTQ[1] = CL0LW01.CLRRQTQ[1] - CL0LW02.CLRRQTQ[sysVar.arrayIndex];

      CL0LW01.CLRCLMQ[1] = CL0LW01.CLRCLMQ[1] - CL0LW02.CLRCLMQ[sysVar.arrayIndex];
       /* also subtract clarec total qty*/
      CL0LW01.CL0LWQCH = CL0LW01.CL0LWQCH - CL0LW02.CLRCLMQ[sysVar.arrayIndex];

      if (CL0LW02.IVANBLFL == "Y") /* net bill flag*/
        CL0LW01.CLAESTVL = CL0LW02.CLNNTPRC[sysVar.arrayIndex] * CL0LW02.CLRCLMQ[sysVar.arrayIndex];
      else
        CL0LW01.CLAESTVL = CL0LW02.CLNGRPRC[sysVar.arrayIndex] * CL0LW02.CLRCLMQ[sysVar.arrayIndex];
      end
      CL0LW01.CL0LWTVL[1] = CL0LW01.CL0LWTVL[1] - CL0LW01.CLAESTVL;
       /* also subt clarec total value*/
      CL0LW01.CL0LWVCH = CL0LW01.CL0LWVCH - CL0LW01.CLAESTVL;
    end
  end



end // end KL0LSAT

// update clarec
Function KL0LSAU()
      /* *******************************************************/
      /* clarec needs to be changed due to adds/changes/deletes*/
      /* on the adjustment products/sizes.*/

      /* all changes are kept in cl0lw01.*/
      /* clarec has flags that must not be changed until we*/
      /* leave this appl.  they are:*/
         /* cladjind - does this claim have adjustments?*/
         /* cladbocl - does this claim have debits?*/
         /* clatqty - original claim quantity*/
         /* claestvl - keep original claim value*/

      /* note - we don't directly update this until leave*/
      /* the appl.  we keep the delta (changed) amount in*/
         /* cl0lw01.cl0lwvch (value change)*/
         /* cl0lw01.cl0lwqch (qty change)*/
      /* this allows us to update the same zzzchgct as brought*/
      /* in by clwrec in the commarea, or to read the current*/
      /* clarec and apply the changes to it.*/
      /* *******************************************************/

  TA1REC.TA1LOCAT[2] = "CL0LSAU";
  CLRREC.CLACLMNB = CLAREC.CLACLMNB;
  CLRREC.CLHSEQNB = CLAREC.CLACSQNB; /* sequence number*/
  set CL0LW04 empty;
  CL0LW04.CL0LWOPT = "SC";

  call "IO1370" (CL0LW04, SQLCA, CLRREC) {isNoRefresh = yes, isExternal = yes}; /* get count of records*/

  if (SQLCA.VAGen_SQLCODE == 0)
    /* next sentence*/
  else
    TA1REC.TA1DBASE = "DCLAIM";
    TA1REC.TA1TBLVU = "XQCLRI1";
    XPCL010();
  end

  if (CL0LW04.CL0LWIDR < 0) /* counter is 'null' from DB2*/
    CL0LW04.CL0LWCNT = 0; /* so set it to zero*/
  end

  if (CL0LW04.CL0LWCNT == 0)
    CL0LW01.CLADJIND = "N";
    CL0LW01.CLADBOCL = "N";
    CL0LW01.CL0LWAUP = "Y";
  end

  if (CL0LW01.CL0LWAUP == "N")
    return;
  end

  while (CL0LW01.CL0LWAUP == "Y") /* until clarec is updated*/

    CLAREC.CLADJIND = CL0LW01.CLADJIND; /* have adjust records*/
    CLAREC.CLADBOCL = CL0LW01.CLADBOCL; /* debit on claim flag*/
    CLAREC.CLAESTVL = CLAREC.CLAESTVL + CL0LW01.CL0LWVCH; /* change value*/
    CLAREC.CLATQTY = CLAREC.CLATQTY + CL0LW01.CL0LWQCH; /* change qty*/

    call "IO1160" ("U ", SQLCA, CLAREC) {isNoRefresh = yes, isExternal = yes}; /* replace clarec*/

    if (SQLCA.VAGen_SQLCODE == 0)
      CL0LW01.CL0LWAUP = "N"; /* update o.k.*/
      CL0LW01.CL0LWVCH = 0;
      CL0LW01.CL0LWQCH = 0;
    else
      if (SQLCA.VAGen_SQLCODE == -911)
        converseLib.validationFailed(4); /* deadlock, retry action*/
        CLXREC.CLXERRF = "Y";
      else
        if (SQLCA.VAGen_SQLCODE == 100)
           /* *********************************/
           /* record not found on update,*/
           /* probably have change count error*/
           /* *********************************/

          call "IO1160" ("S ", SQLCA, CLAREC) {isNoRefresh = yes, isExternal = yes}; /* get current rec*/

          if (SQLCA.VAGen_SQLCODE == 0)
             /* o.k., loop back to 'while'*/
          else
            if (SQLCA.VAGen_SQLCODE == -911)
              converseLib.validationFailed(4); /* deadlock, retry action*/
              CLXREC.CLXERRF = "Y";
            else
              TA1REC.TA1DBASE = "DCLAIM";
              TA1REC.TA1TBLVU = "VCLHDR01";
              XPCL010(); /* abend*/
            end
          end
        else
          if (SQLCA.VAGen_SQLCODE == -911)
            converseLib.validationFailed(4); /* deadlock, retry action*/
            CLXREC.CLXERRF = "Y";
          else
            TA1REC.TA1DBASE = "DCLAIM";
            TA1REC.TA1TBLVU = "VCLHDR01";
            XPCL010(); /* abend*/
          end
        end
      end
    end
  end


  VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
  VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
  sysLib.commit();
  VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
   /* release data bases*/



end // end KL0LSAU

// cntrl bld array for no invoice
Function KL0LSB1()
   /* ************************************************************/
   /* *   since have no invoice associated with the claim*/
   /* *   initialize the array, and try to fill with products*/
   /* *   from the claim*/
   /* ************************************************************/


  CL0LW02.IV0PARTN = "0"; /* no invoice available*/
  CL0LW02.IV0IVCID = 0;
  CL0LW02.IVANBLFL = "N"; /* not net bill*/

  if (converseVar.validationMsgNum == 0)
    converseLib.validationFailed(196); /* warning - no invc assoc with claim*/
  end

  CLXREC.CLXARAYX = 1; /* array index = 1*/
  CLXREC.CLXLSTAX = 1; /* last array index used = 1*/
  CL0LW01.CL0LWLST = 0; /* last prod key put in array*/

  if (CLAREC.CLADJIND == "Y") /* if have products on claim*/
    KL0LSP6(); /* load array from claim products*/
  end



end // end KL0LSB1

// cntrl bld array for invoice
Function KL0LSB2()
   /* **************************************************/
   /* *   use invoice from claim/invoice xref table*/
   /* *   to get all the products for a single invoice*/
   /* *   and build w-s array, up to 600 products*/
   /* **/

    /* Maintenance History:*/
    /* 04-10-90 CHELLM Added XQACD and XUMCD to the product key*/
                    /* when selecting invoice price overrides.*/

   /* *************************************************************/


     /* *******************************/
     /* hold invoice as last processed*/
     /* *******************************/

  TA1REC.TA1LOCAT[2] = "CL0LSB2";
  CL0LW01.CL0LWLST = CLBREC.IV0IVCID;
  CL0LW01.YITCD = CLBREC.YITCD; /* invc type (ibm,dec,other)*/


  CLXREC.CLXARAYX = 1; /* init array pointers*/


     /* **************************************/
     /* move invoice info to all map headings*/
     /* **************************************/

  CL0LW02.IV0PARTN = CLBREC.IV0PARTN;
  CL0LW02.IV0IVCID = CLBREC.IV0IVCID;

  KL0LM001.IV0IVCID = CLBREC.IV0IVCID;
  KL0LM005.IV0IVCID = CLBREC.IV0IVCID;
  KL0LM010.IV0IVCID = CLBREC.IV0IVCID;
  KL0LM001.IV0IVCDT = CLBREC.IV0IVCDT;
  KL0LM005.IV0IVCDT = CLBREC.IV0IVCDT;


     /* *****************************************/
     /* read invoice header to get net bill flag*/
     /* *****************************************/

  IVAREC.IV0PARTN = CLBREC.IV0PARTN;
  IVAREC.IV0IVCID = CLBREC.IV0IVCID;

  call "IO1040" ("S  ", SQLCA, IVAREC) {isNoRefresh = yes, isExternal = yes}; /* read invoice*/

  if (SQLCA.VAGen_SQLCODE == 0
   && IVAREC.IVANBLFL != " ")
    CL0LW02.IVANBLFL = IVAREC.IVANBLFL;
  else
    CL0LW02.IVANBLFL = "N";
  end


     /* move flag to maps*/

  KL0LM001.IVANBLFL = CL0LW02.IVANBLFL;
  KL0LM005.IVANBLFL = CL0LW02.IVANBLFL;
  KL0LM010.IVANBLFL = CL0LW02.IVANBLFL;

       /* *****************************************/
       /* determine if invoice has price overrides*/
       /* *****************************************/

  CL6REC.IV0PARTN = CL0LW02.IV0PARTN; /* for this invoice,*/
  CL6REC.IV0IVCID = CL0LW02.IV0IVCID;

  CL6REC.XGPCD = "**";
  CL6REC.SY1STNBR = "******";
  CL6REC.SY2CLRID = "***";
  CL6REC.XDMCD = "**";
  CL6REC.XQACD = "**";
  CL6REC.XUMCD = "**";
  CL6REC.SY5SZID = -1;

  call "IO2950" ("SS", SQLCA, CL6REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    call "IO2950" ("SN", SQLCA, CL6REC) {isNoRefresh = yes, isExternal = yes};
    if (SQLCA.VAGen_SQLCODE == 0)
      CL0LW01.CL0LWPFL = "Y"; /* price override flag*/
    else
      if (SQLCA.VAGen_SQLCODE == 100)
        CL0LW01.CL0LWPFL = "N"; /* price override flag*/
      else
        TA1REC.TA1LOCAT[2] = "CL0LSB2";
        TA1REC.TA1LOCAT[4] = "IO2950";
        TA1REC.TA1DBASE = "DCLAIM";
        TA1REC.TA1TBLVU = "VCLADJ01";
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE;
        XPCL010(); /* abend*/
      end
    end
  else
    TA1REC.TA1LOCAT[2] = "CL0LSB2";
    TA1REC.TA1LOCAT[4] = "IO2950";
    TA1REC.TA1DBASE = "DCLAIM";
    TA1REC.TA1TBLVU = "VIVOVR01";
    CLXREC.XXXWDTE = CLAREC.CLACLMNB;
    TA1REC.TA1TBLKE = CLXREC.XXXWDTE;
    XPCL010(); /* abend*/
  end

  call "IO2950" ("CS", SQLCA, CL6REC) {isNoRefresh = yes, isExternal = yes};


     /* ******************************************/
     /* determine where to get products for array*/
     /* ******************************************/

     /* fetch prod for invc from claim*/

  CLRREC.CLACLMNB = CLAREC.CLACLMNB; /* claim number*/
  CLRREC.CLHSEQNB = CL0LW01.CLACSQNB; /* sequence number*/

  CLRREC.IV0PARTN = CL0LW02.IV0PARTN; /* for this invoice,*/
  CLRREC.IV0IVCID = CL0LW02.IV0IVCID;

  CLRREC.XGPCD = "**";
  CLRREC.SY1STNBR = "******"; /* get all products*/
  CLRREC.SY2CLRID = "***";
  CLRREC.XDMCD = "**";
  CLRREC.CLICRDFL = "*"; /* get both cr and debits*/

  call "IO1370" ("S2", SQLCA, CLRREC) {isNoRefresh = yes, isExternal = yes};
                                   /* select clm prods for invc*/
  set CL0LW04 empty;
  CL0LW04.CL0LWOPT = "N2"; /* move in fetch code*/


     /* ******************/
     /* read first record*/
     /* ******************/

  if (SQLCA.VAGen_SQLCODE == 0) /* have set open*/
    call "IO1370" ("N2", SQLCA, CLRREC) {isNoRefresh = yes, isExternal = yes}; /* first read*/
     /* note - ezesqcod is now for fetch, not set*/
    if (SQLCA.VAGen_SQLCODE == 0) /* process data below*/
       /* next sentence*/
    else
      if (SQLCA.VAGen_SQLCODE == 100)
        call "IO1370" ("C2", SQLCA, CLRREC) {isNoRefresh = yes, isExternal = yes}; /* close set*/
        CL0LW01.CLBSRIND = "N"; /* no products on claim*/
        CL0LW01.CL0LWBUP = "Y"; /* update clbrec switch*/
        SQLCA.VAGen_SQLCODE = 100; /* so if's below work ok*/
      else
        TA1REC.TA1DBASE = "DCLAIM";
        TA1REC.TA1TBLVU = "VCLADJ01";
        XPCL010(); /* abend*/
      end
    end
  else
    TA1REC.TA1DBASE = "DCLAIM";
    TA1REC.TA1TBLVU = "VCLADJ01";
    XPCL010(); /* abend*/
  end

     /* *******************************/
     /* take products from claim if:*/
        /* claim has products, or*/
        /* inquiry mode, or*/
        /* invc is not I.B.M.*/
     /* take products from invoice if:*/
        /* no products on claim*/
     /* take products from claim if:*/
        /* other situations*/
     /* *******************************/

     /* **********************************************************/
     /* clarec.cladjind shows we have products already*/
     /* associated with the claim.  since there was at least one*/
     /* invoice/claim xref record, store only the products*/
     /* from the claim with the invoice shown at map top*/
     /* **********************************************************/
  if (CL0LW01.CLBSRIND == "Y" /* if claim has products*/
   || CL0LW01.CL0LWINQ == "Y" /* or inquiry mode,*/
   || CL0LW01.YITCD != "I")   /* or invc not I.B.M.*/
    if (SQLCA.VAGen_SQLCODE == 0)
      KL0LSP5(); /* load claim products into w-s array*/
    else
      if (converseVar.validationMsgNum == 0)
        converseLib.validationFailed(198);
      end
    end
     /* use cl0lsp6 to store products in array*/
  else
    if (SQLCA.VAGen_SQLCODE == 100) /* no clm prods found for invc*/
       /* invoice has no data on claim adj records*/
      KL0LSP4(); /* fetch prod from invc, store in array*/
    else
      KL0LSP5(); /* default to get prod from claim*/
    end
  end


     /* **********************************************/
     /* read next invoice to determine if end of file*/
     /* **********************************************/

  call "IO1180" ("N3", SQLCA, CLBREC) {isNoRefresh = yes, isExternal = yes}; /* next inv on claim xref*/

  if (SQLCA.VAGen_SQLCODE == 0) /* if have another invoice, o.k.*/
    CL0LW01.CL0LWLST = CLBREC.IV0IVCID;
  else
    if (SQLCA.VAGen_SQLCODE == 100) /* if at end of file, set flag*/
      CL0LW01.CL0LWIEF = "Y";
      call "IO1180" ("C3", SQLCA, CLBREC) {isNoRefresh = yes, isExternal = yes}; /* close set*/
    else
      TA1REC.TA1DBASE = "DCLAIM";
      TA1REC.TA1TBLVU = "VCLIVX01";
      XPCL010(); /* abend*/
    end
  end



end // end KL0LSB2

// edit prod-claim brand mismatch
Function KL0LSBC()
   /* *************************************************************/

    /* Edit the product brand code for customer-product legal*/
    /* entity mis-match.*/

    /* Maintenance History:*/
    /* 05-31-90 CHELLM created*/
    /* 06-03-93 JCAREY allowed side1 brands (05) on nike claims*/
    /* (01). side1 brand now part of nike*/
   /* *************************************************************/

  TA1REC.TA1LOCAT[2] = "CL0LEBC";

  if (KL0LM001.CL0LMSEL[CLXLINEX] == "X" /* deleting don't need t edit*/
   || CL0LW01.CL0LWSYC != "Y")           /* or invalid product (no sycrec)*/
    return; /* don't need to edit*/
  end

   /* If either the claim or the invoice was set up prior*/
   /* to 06-01-90 it doesnt have a brand code, so make sure*/
   /* the legal entity of customer match the legal entity of*/
   /* the product.*/
  if (CLAREC.XBCCD == " ")

    if (CLWREC.XLECD == "01") /* If Nike Customer*/
      if (SYCREC.XBCCD == "01") /* and not Nike Product*/
                                  /* ; Product's xle is OK*/
      else
        converseLib.validationFailed(634); /* Product's XLE must match Cust XLE*/
        CLXREC.CLXERRF = "Y";
        CL0LW01.CL0LWERR[CLXLINEX] = "Y";
        set KL0LM001.SY1STNBR[CLXLINEX] modified, bold;
        return;
      end
    end

    if (CLWREC.XLECD == "05") /* If Side 1 Customer*/
      if (SYCREC.XBCCD == "05" /* and Side 1 Product*/
       || SYCREC.XBCCD == "06" /* or Relay  product*/
       || SYCREC.XBCCD == "07") /* or i.e    product*/
                                 /* ;  then Product xle is OK*/
      else
        converseLib.validationFailed(634); /* Product's XLE must match Cust XLE*/
        CLXREC.CLXERRF = "Y";
        CL0LW01.CL0LWERR[CLXLINEX] = "Y";
        set KL0LM001.SY1STNBR[CLXLINEX] modified, bold;
        return;
      end
    end

    /* GET XOTEDIT*/
     /* check the division code value against allowable*/
     /* division codes for the claims order type.*/

    if (CLAREC.XOTCD in XOTTBL.XOTCD)

      if (SYCREC.XDVCD1 == XOTTBL.XDVCD1[sysVar.arrayIndex]
       || SYCREC.XDVCD1 == XOTTBL.XDVCD2[sysVar.arrayIndex]
       || SYCREC.XDVCD1 == XOTTBL.XDVCD3[sysVar.arrayIndex]
       || SYCREC.XDVCD1 == XOTTBL.XDVCD4[sysVar.arrayIndex]
       || SYCREC.XDVCD1 == XOTTBL.XDVCD5[sysVar.arrayIndex])
         /* next sentence*/
      else
        converseLib.validationFailed(637); /* the product brand must match the*/
        CLXREC.CLXERRF = "Y"; /* claims division or new division*/
        CL0LW01.CL0LWERR[CLXLINEX] = "Y";
        set KL0LM001.SY1STNBR[CLXLINEX] modified, bold;
      end
    else
      converseLib.validationFailed(096); /* order type not on system table*/
      CLXREC.CLXERRF = "Y";
    end

  else

    if (SYCREC.XBCCD != CLAREC.XBCCD) /* if brand codes don't match*/
      if (SYCREC.XBCCD == "01" /* nike brand and side1 brand*/
       && CLAREC.XBCCD == "05") /* so bypass check 6/1/93*/
       /* next sentence*/
      else
        converseLib.validationFailed(611); /* Product brand must match claim brand*/
        CLXREC.CLXERRF = "Y";
        CL0LW01.CL0LWERR[CLXLINEX] = "Y";
        set KL0LM001.SY1STNBR[CLXLINEX] modified, bold;
        return;
      end
    end

  end


end // end KL0LSBC

// check price override to select
Function KL0LSCO()

  CLXREC.CLXCPROC = "CL0LSCO";

  CL0LW01.CL0LWSWZ = "N";
  CL0LW01.CL0LWPCE = 0;
  CL0LW01.CLHMEMNB = 0;
  CL0LW01.CL0LWVAR = " ";

  if (CL0LW01.CL0LWPFL != "Y")
    SQLCA.VAGen_SQLCODE = 100;
    return;
  end

  call "IO2950" ("SS", SQLCA, CL6REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4);
      CLXREC.CLXERRF = "Y";
      VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
      VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
      sysLib.rollback();
      VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
      
      return;
    else
      TA1REC.TA1LOCAT[2] = "CL0LSCO";
      TA1REC.TA1LOCAT[4] = "IO2950";
      TA1REC.TA1DBASE = "DCLAIM";
      TA1REC.TA1TBLVU = "VIVOVR01";
      CLXREC.XXXWDTE = CLAREC.CLACLMNB;
      TA1REC.TA1TBLKE = CLXREC.XXXWDTE;
      XPCL010();
    end
  end


  CL0LW01.CL0LWEOF = "N";

  while (CL0LW01.CL0LWEOF == "N")

    call "IO2950" ("SN", SQLCA, CL6REC) {isNoRefresh = yes, isExternal = yes};

    if (SQLCA.VAGen_SQLCODE == 0)
      if (CL6REC.CLHMEMNB > 0)
        CL0LW01.CL0LWSWZ = "Y";
        if (CL0LW01.CL0LWPCE == 0
         && CL0LW01.CLHMEMNB == 0)
          CL0LW01.CL0LWPCE = CL6REC.CL6OVPRC;
          CL0LW01.CLHMEMNB = CL6REC.CLHMEMNB;
        end
        if (CL6REC.CLHMEMNB != CL0LW01.CLHMEMNB)
          CL0LW01.CL0LWEOF = "Y";
        else
          if (CL6REC.CL6OVPRC == CL0LW01.CL0LWPCE)
            /* next sentence*/
          else
            CL0LW01.CL0LWPCE = 0;
            CL0LW01.CL0LWVAR = "Y";
            CL0LW01.CL0LWEOF = "Y";
          end
        end
      end
    else
      if (SQLCA.VAGen_SQLCODE == 100)
        CL0LW01.CL0LWEOF = "Y";
      else
        TA1REC.TA1LOCAT[2] = "CL0LSSO";
        TA1REC.TA1LOCAT[4] = "IO2950";
        TA1REC.TA1DBASE = "DCLAIM";
        TA1REC.TA1TBLVU = "VIVOVR01";
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE;
        XPCL010();
      end
    end
  end

  call "IO2950" ("CS", SQLCA, CL6REC) {isNoRefresh = yes, isExternal = yes};

end // end KL0LSCO

// map 10 set modifd fields modfd
Function KL0LSD1()
   /* ************************************************************/
   /* *  since the map must be re-shown to the user             **/
   /* *  before editing has been done, set fields modified to   **/
   /* *  keep track of all the fields entered by the user.      **/
   /* *  the user will only need to re-do the pf key or enter   **/
   /* *  key, not enter the data again.                         **/
   /* ************************************************************/


  sysVar.arrayIndex = 1;

  while (sysVar.arrayIndex <= CLXREC.CLXMAXLN[CLXSCRNX])
    if (KL0LM010.CL0LMSEL[sysVar.arrayIndex] is modified)
      set KL0LM010.CL0LMSEL[sysVar.arrayIndex] modified;
    end
    if (KL0LM010.CLRRQTQ[sysVar.arrayIndex] is modified)
      set KL0LM010.CLRRQTQ[sysVar.arrayIndex] modified;
    end
    if (KL0LM010.CLRCLMQ[sysVar.arrayIndex] is modified)
      set KL0LM010.CLRCLMQ[sysVar.arrayIndex] modified;
    end
    if (KL0LM010.CLKPRCFF[sysVar.arrayIndex] is modified)
      set KL0LM010.CLKPRCFF[sysVar.arrayIndex] modified;
    end
    if (KL0LM010.CLNGRPRC[sysVar.arrayIndex] is modified)
      set KL0LM010.CLNGRPRC[sysVar.arrayIndex] modified;
    end
    sysVar.arrayIndex = sysVar.arrayIndex + 1;
  end



end // end KL0LSD1

// map 10 protect for inquirymode
Function KL0LSD2()
     /* ***********************************/
     /* protect all input fields on map 10*/
     /* ***********************************/


  sysVar.arrayIndex = 1;

      /* note - really should use 'clxscrnx'*/
      /* instead of '3' to mean map 10,*/
      /* but it has not been initialized until cl0l050*/

  while (sysVar.arrayIndex <= CLXREC.CLXMAXLN[3])
    set KL0LM010.CLRRQTQ[sysVar.arrayIndex] skip;
    set KL0LM010.CLRCLMQ[sysVar.arrayIndex] skip;
    set KL0LM010.CLKPRCFF[sysVar.arrayIndex] skip;
    set KL0LM010.CLNGRPRC[sysVar.arrayIndex] skip;
    sysVar.arrayIndex = sysVar.arrayIndex + 1;
  end



end // end KL0LSD2

// bld ary from prod size on clm
Function KL0LSDC()
   /* GET CL0LSP2*/
     /* ******************************************************/
     /* store sizes from the claim record(s) for the selected*/
     /* product.*/
     /* ******************************************************/

  TA1REC.TA1LOCAT[2] = "CL0LSDC";
  CLRREC.CLACLMNB = CLAREC.CLACLMNB; /* claim number*/
  CLRREC.CLHSEQNB = CL0LW01.CLACSQNB; /* sequence number*/

  CLRREC.IV0PARTN = CL0LW02.IV0PARTN; /* for this invoice,*/
  CLRREC.IV0IVCID = CL0LW02.IV0IVCID;

  CLRREC.XGPCD = CLAREC.XGPCD;
  CLRREC.SY1STNBR = CL0LW02.SY1STNBR[CL0LWCAX];
  CLRREC.SY2CLRID = CL0LW02.SY2CLRID[CL0LWCAX];
  CLRREC.XDMCD = CL0LW02.XDMCD[CL0LWCAX];
  CLRREC.CLICRDFL = "*"; /* all credits/debits for product*/


  call "IO1370" ("S2", SQLCA, CLRREC) {isNoRefresh = yes, isExternal = yes}; /* clm sizes for product*/


     /* ****************************************/
     /* fetch and load of the w/s array*/
     /* from the claim adjustment product table*/
     /* ****************************************/

  if (SQLCA.VAGen_SQLCODE == 0) /* have set of prods for invoice*/
    call "IO1370" ("N2", SQLCA, CLRREC) {isNoRefresh = yes, isExternal = yes}; /* first read*/
     /* note - ezesqcod is now for fetch, not set*/
    if (SQLCA.VAGen_SQLCODE == 0) /* process data below*/
       /* next sentence*/
    else
      if (SQLCA.VAGen_SQLCODE == 100)
        call "IO1370" ("C2", SQLCA, CLRREC) {isNoRefresh = yes, isExternal = yes}; /* close set*/
        CL0LW03.SY5SZID[1] = 0; /* force error 215 - no sizes*/
        return;
      else
        TA1REC.TA1DBASE = "DCLAIM";
        TA1REC.TA1TBLVU = "VCLADJ01";
        XPCL010(); /* abend*/
      end
    end
  else
    TA1REC.TA1DBASE = "DCLAIM"; /* set not open*/
    TA1REC.TA1TBLVU = "VCLADJ01";
    XPCL010(); /* abend*/
  end


  CL0LW01.CL0LWPEF = "N"; /* not end of product file*/

  while (CL0LW01.CL0LWPEF == "N") /* while not product end of file -*/
    if (CLXREC.CLXCURSZ <= CL0LW03.CL0LWASZ) /* dont exceed array size*/
       /* accum map totals for all sizes on the product*/
      if (CL0LW02.IVANBLFL == "Y") /* net bill flag*/
        CL0LW01.CLAESTVL = CLRREC.CLRCLMQ * CLRREC.CLNNTPRC;
      else
        CL0LW01.CLAESTVL = CLRREC.CLRCLMQ * CLRREC.CLNGRPRC;
      end
      if (CLRREC.CLICRDFL == "D") /* debit claim, adds to tots*/
        CL0LW01.CLRCLMQ[2] = CL0LW01.CLRCLMQ[2] + CLRREC.CLRCLMQ;
        CL0LW01.CLRRQTQ[2] = CL0LW01.CLRRQTQ[2] + CLRREC.CLRRQTQ;
        CL0LW01.CL0LWTVL[2] = CL0LW01.CL0LWTVL[2] + CL0LW01.CLAESTVL;
      else /* credit claim, subts from tots*/
        CL0LW01.CLRCLMQ[2] = CL0LW01.CLRCLMQ[2] - CLRREC.CLRCLMQ;
        CL0LW01.CLRRQTQ[2] = CL0LW01.CLRRQTQ[2] - CLRREC.CLRRQTQ;
        CL0LW01.CL0LWTVL[2] = CL0LW01.CL0LWTVL[2] - CL0LW01.CLAESTVL;
      end

      CL0LW03.ZZZCHGCT[CLXCURSZ] = CLRREC.ZZZCHGCT;
      CL0LW03.SY5SZID[CLXCURSZ] = CLRREC.SY5SZID;
      CL0LW03.CLRRQTQ[CLXCURSZ] = CLRREC.CLRRQTQ;
      CL0LW03.CLRCLMQ[CLXCURSZ] = CLRREC.CLRCLMQ;
      CL0LW03.CLKPRCFF[CLXCURSZ] = CLRREC.CLKPRCFF;
      CL0LW03.CLNGRPRC[CLXCURSZ] = CLRREC.CLNGRPRC;
      CL0LW03.CLNNTPRC[CLXCURSZ] = CLRREC.CLNNTPRC;
      CL0LW03.CLICRDFL[CLXCURSZ] = CLRREC.CLICRDFL;

      CLXREC.CLXCURSZ = CLXREC.CLXCURSZ + 1; /* increment array index*/

      call "IO1370" ("N2", SQLCA, CLRREC) {isNoRefresh = yes, isExternal = yes}; /* next product record*/
      if (SQLCA.VAGen_SQLCODE == 0)
         /* next sentence           ; loop within 'while' to load array*/
      else
        if (SQLCA.VAGen_SQLCODE == 100)
          call "IO1370" ("C2", SQLCA, CLRREC) {isNoRefresh = yes, isExternal = yes}; /* close set*/
          CL0LW01.CL0LWPEF = "Y"; /* product end of file*/
        else
          TA1REC.TA1DBASE = "DCLAIM";
          TA1REC.TA1TBLVU = "VCLADJ01";
          XPCL010(); /* abend*/
        end
      end
    else
      TA1REC.TA1TBLKE = "EXCEEDED CL0LW03 DETAIL SIZES ARRAY";
      XPCL010(); /* abend*/
    end
  end



end // end KL0LSDC

// bld ary from prod size on invc
Function KL0LSDI()
   /* GET CL0LSP4*/
     /* *********************************************************/
     /* since we got the products from the invoice, now get the*/
     /* product's sizes from the invoice, using the invoice*/
     /* as shown on the map.*/
     /* *********************************************************/

    /* Maintenance History:*/
    /* 04-10-90 CHELLM Added XQACD and XUMCD to the product key*/
                    /* when selecting invoice price overrides.*/

   /* *************************************************************/


  TA1REC.TA1LOCAT[2] = "CL0LSDI";
  IV4REC.IV0PARTN = CL0LW02.IV0PARTN;
  IV4REC.IV0IVCID = CL0LW02.IV0IVCID;

  IV4REC.OP2LNINB = CL0LW02.OP2LNINB[CL0LWCAX]; /* specific product lin*/
  IV4REC.SY5SZID = 0; /* to get all sizes*/

  call "IO1130" ("SS", SQLCA, IV4REC) {isNoRefresh = yes, isExternal = yes}; /* select set for invc*/

  if (SQLCA.VAGen_SQLCODE == 0) /* have set of sizes for product*/
    call "IO1130" ("SN", SQLCA, IV4REC) {isNoRefresh = yes, isExternal = yes}; /* first read*/
     /* note - ezesqcod is now for fetch, not set*/
    if (SQLCA.VAGen_SQLCODE == 0) /* process data below*/
       /* next sentence*/
    else
      if (SQLCA.VAGen_SQLCODE == 100)
        call "IO1130" ("CS", SQLCA, IV4REC) {isNoRefresh = yes, isExternal = yes}; /* close set*/
        CL0LW03.SY5SZID[1] = 0; /* force size 1*/
        return;
      else
        TA1REC.TA1LOCAT[3] = "A";
        TA1REC.TA1DBASE = "DINVC";
        TA1REC.TA1TBLVU = "VIVSIZ01";
        XPCL010(); /* abend*/
      end
    end
  else
    TA1REC.TA1LOCAT[3] = "B";
    TA1REC.TA1DBASE = "DINVC"; /* set not open*/
    TA1REC.TA1TBLVU = "VIVSIZ01";
    XPCL010(); /* abend*/
  end


  CL0LW01.CL0LWPEF = "N"; /* not product end of file*/

  while (CL0LW01.CL0LWPEF == "N") /* while not product end of file -*/
    if (CLXREC.CLXCURSZ <= CL0LW03.CL0LWASZ) /* dont exceed array size*/
       /* accum total of all sizes from the invc product*/
      CL0LW01.CL0LWTSH[2] = CL0LW01.CL0LWTSH[2] + IV4REC.IV4SHPQ;
       /* cl0lw01.clrrqtq(2) = 0    ; 0 until user enters data*/
       /* cl0lw01.clrclmq(2) = 0    ; 0 until user enters data*/
       /* cl0lw01.cl0lwtvl(2) = 0   ; 0 until user enters data*/

      CL0LW03.ZZZCHGCT[CLXCURSZ] = 0;
      CL0LW03.SY5SZID[CLXCURSZ] = IV4REC.SY5SZID;
      CL0LW03.IV4SHPQ[CLXCURSZ] = IV4REC.IV4SHPQ;
      if (CL0LW02.IVANBLFL == "Y") /* net bill flag*/
        CL0LW03.IV4GUP[CLXCURSZ] = IV4REC.IV4NUP;
      else
        CL0LW03.IV4GUP[CLXCURSZ] = IV4REC.IV4GUP;
      end
      if (CL0LW01.CL0LWPFL == "Y")
        CL6REC.IV0PARTN = CL0LW02.IV0PARTN;
        CL6REC.IV0IVCID = CL0LW02.IV0IVCID;
        CL6REC.XGPCD = CLAREC.XGPCD;
        CL6REC.SY1STNBR = CL0LW02.SY1STNBR[CL0LWCAX];
        CL6REC.SY2CLRID = CL0LW02.SY2CLRID[CL0LWCAX];
        CL6REC.XDMCD = CL0LW02.XDMCD[CL0LWCAX];
        CL6REC.XQACD = CL0LW02.XQACD[CL0LWCAX];
        CL6REC.XUMCD = CL0LW02.XUMCD[CL0LWCAX];
        CL6REC.SY5SZID = IV4REC.SY5SZID;

        KL0LSSO(); /* select set price overrides*/

        if (SQLCA.VAGen_SQLCODE == 0
         && CL6REC.CLHMEMNB > 0)
          CL0LW03.CLNGRPRC[CLXCURSZ] = CL6REC.CL6OVPRC;
          CL0LW03.CLNNTPRC[CLXCURSZ] = CL6REC.CL6OVPRC;
          CL0LW03.CLKPRCFF[CLXCURSZ] = "O";
          call "IO2950" ("CS", SQLCA, CL6REC) {isNoRefresh = yes, isExternal = yes};
        else
          call "IO2950" ("CS", SQLCA, CL6REC) {isNoRefresh = yes, isExternal = yes};
          CL6REC.IV0PARTN = CL0LW02.IV0PARTN;
          CL6REC.IV0IVCID = CL0LW02.IV0IVCID;
          CL6REC.XGPCD = CLAREC.XGPCD;
          CL6REC.SY1STNBR = CL0LW02.SY1STNBR[CL0LWCAX];
          CL6REC.SY2CLRID = CL0LW02.SY2CLRID[CL0LWCAX];
          CL6REC.XDMCD = CL0LW02.XDMCD[CL0LWCAX];
          CL6REC.XQACD = CL0LW02.XQACD[CL0LWCAX];
          CL6REC.XUMCD = CL0LW02.XUMCD[CL0LWCAX];
          CL6REC.SY5SZID = 0;

          KL0LSSO(); /* select set price overrides*/

          if (SQLCA.VAGen_SQLCODE == 0
           && CL6REC.CLHMEMNB > 0)
            CL0LW03.CLNGRPRC[CLXCURSZ] = CL6REC.CL6OVPRC;
            CL0LW03.CLNNTPRC[CLXCURSZ] = CL6REC.CL6OVPRC;
            CL0LW03.CLKPRCFF[CLXCURSZ] = "O";
          else
            CL0LW03.CLNGRPRC[CLXCURSZ] = IV4REC.IV4GUP;
            CL0LW03.CLNNTPRC[CLXCURSZ] = IV4REC.IV4NUP;
            CL0LW03.CLKPRCFF[CLXCURSZ] = "I";
          end
          call "IO2950" ("CS", SQLCA, CL6REC) {isNoRefresh = yes, isExternal = yes};
        end
      else
        CL0LW03.CLNGRPRC[CLXCURSZ] = IV4REC.IV4GUP;
        CL0LW03.CLNNTPRC[CLXCURSZ] = IV4REC.IV4NUP;
        CL0LW03.CLKPRCFF[CLXCURSZ] = "I";
      end

      CLXREC.CLXCURSZ = CLXREC.CLXCURSZ + 1; /* increment array index*/

      call "IO1130" ("SN", SQLCA, IV4REC) {isNoRefresh = yes, isExternal = yes}; /* first next*/
      if (SQLCA.VAGen_SQLCODE == 0)
         /* next sentence           ; loop within 'while' to load array*/
      else
        if (SQLCA.VAGen_SQLCODE == 100)
          call "IO1130" ("CS", SQLCA, IV4REC) {isNoRefresh = yes, isExternal = yes}; /* close set*/
          CL0LW01.CL0LWPEF = "Y"; /* size end of file*/
        else
          TA1REC.TA1LOCAT[3] = "C";
          TA1REC.TA1DBASE = "DINVC";
          TA1REC.TA1TBLVU = "VIVSIZ01";
          XPCL010(); /* abend*/
        end
      end
    else
      TA1REC.TA1TBLKE = "EXCEEDED CL0LW03 DETAIL SIZES ARRAY";
      XPCL010(); /* abend*/
    end
  end



end // end KL0LSDI

// delete clm adj record(s)
Function KL0LSDL()
   /* **********************************************/
   /* *  delete data base for product, and sizes*/
   /* *  only done from cl0l130, not for indiv size*/
   /* **********************************************/

  TA1REC.TA1LOCAT[2] = "CL0LSDL";
  if (CL0LW02.CL0LWDLT[CLXARAYX] == "X")
    return;
  end

   /* move key data to clrrec to get set of all sizes*/

  CLRREC.CLACLMNB = CLAREC.CLACLMNB; /* claim number*/
  CLRREC.CLHSEQNB = CLAREC.CLACSQNB; /* sequence number*/
  CLRREC.IV0PARTN = CL0LW02.IV0PARTN;
  CLRREC.IV0IVCID = CL0LW02.IV0IVCID;
  CLRREC.CLICRDFL = CL0LW02.CLICRDFL[CLXARAYX];

  CLRREC.XGPCD = CLAREC.XGPCD;
  CLRREC.SY1STNBR = CL0LW02.SY1STNBR[CLXARAYX];
  CLRREC.SY2CLRID = CL0LW02.SY2CLRID[CLXARAYX];
  CLRREC.XDMCD = CL0LW02.XDMCD[CLXARAYX];
  CLRREC.OP2LNINB = CL0LW02.OP2LNINB[CLXARAYX];

  call "IO1370" ("S2", SQLCA, CLRREC) {isNoRefresh = yes, isExternal = yes}; /* open set*/

  if (SQLCA.VAGen_SQLCODE == 0)
    /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* deadlock*/
      CLXREC.CLXERRF = "Y";
      VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
      VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
      sysLib.rollback();
      VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
      
      return;
    else
      TA1REC.TA1DBASE = "DCLAIM";
      TA1REC.TA1TBLVU = "VCLADJ01";
      XPCL010();
    end
  end

  CL0LW01.CL0LWDEL = "N"; /* delete flag*/
  while (CL0LW01.CL0LWDEL == "N")

    call "IO1370" ("N2", SQLCA, CLRREC) {isNoRefresh = yes, isExternal = yes}; /* fetch record*/

    if (SQLCA.VAGen_SQLCODE == 0)

      KL0LSDO(); /* check price override*/

      if (CLXREC.CLXERRF == "Y")
        return;
      end

      call "IO1370" ("D ", SQLCA, CLRREC) {isNoRefresh = yes, isExternal = yes}; /* delete record*/
      if (SQLCA.VAGen_SQLCODE == 0
       || SQLCA.VAGen_SQLCODE == 100)
        CL0LW01.CL0LWAUP = "Y"; /* update clm value*/
      else
        if (SQLCA.VAGen_SQLCODE == -911)
          converseLib.validationFailed(4); /* deadlock, retry action*/
          CLXREC.CLXERRF = "Y";
          VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
          VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
          sysLib.rollback();
          VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
          
          return;
        else
          TA1REC.TA1DBASE = "DCLAIM"; /* error on delete*/
          TA1REC.TA1TBLVU = "VCLADJ01";
          XPCL010(); /* abend*/
        end
      end
    else
      if (SQLCA.VAGen_SQLCODE == 100) /* no record found on read for updt*/
        call "IO1370" ("C2", SQLCA, CLRREC) {isNoRefresh = yes, isExternal = yes}; /* close cursor*/
        CL0LW01.CL0LWDEL = "Y";
      else
        if (SQLCA.VAGen_SQLCODE == -911)
          converseLib.validationFailed(4); /* deadlock, retry action*/
          CLXREC.CLXERRF = "Y";
          VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
          VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
          sysLib.rollback();
          VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
          
          return;
        else
          TA1REC.TA1DBASE = "DCLAIM"; /* error on read for update*/
          TA1REC.TA1TBLVU = "VCLADJ01";
          XPCL010(); /* abend*/
        end
      end
    end
  end


end // end KL0LSDL

// check price override to delete
Function KL0LSDO()


    /* Maintenance History:*/
    /* 04-10-90 CHELLM Added XQACD and XUMCD to the product key*/
                    /* when selecting invoice price overrides.*/

   /* *************************************************************/

  CLXREC.CLXCPROC = "CL0LSDO";

  if (CL0LW01.CL0LWPFL != "Y")
    SQLCA.VAGen_SQLCODE = 100;
    return;
  end

  SQLCA.VAGen_SQLCODE = 0;
  CL6REC.IV0PARTN = CLRREC.IV0PARTN;
  CL6REC.IV0IVCID = CLRREC.IV0IVCID;
  CL6REC.XGPCD = CLRREC.XGPCD;
  CL6REC.SY1STNBR = CLRREC.SY1STNBR;
  CL6REC.SY2CLRID = CLRREC.SY2CLRID;
  CL6REC.XDMCD = CLRREC.XDMCD;
  CL6REC.XQACD = CLRREC.XQACD;
  CL6REC.XUMCD = CLRREC.XUMCD;
  CL6REC.SY5SZID = CLRREC.SY5SZID;
  CL6REC.CLACLMNB = CLRREC.CLACLMNB;

  call "IO2950" ("S ", SQLCA, CL6REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      return;
    else
      if (SQLCA.VAGen_SQLCODE == -911)
        converseLib.validationFailed(4);
        CLXREC.CLXERRF = "Y";
        VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
        VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
        sysLib.rollback();
        VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
        
        return;
      else
        TA1REC.TA1LOCAT[2] = "CL0LSDO";
        TA1REC.TA1LOCAT[4] = "IO2950";
        TA1REC.TA1DBASE = "DCLAIM";
        TA1REC.TA1TBLVU = "VIVOVR01";
        CLXREC.XXXWDTE = CLAREC.CLACLMNB;
        TA1REC.TA1TBLKE = CLXREC.XXXWDTE;
        XPCL010();
      end
    end
  end

  if (CL6REC.CLHMEMNB > 0) /* override is not pending*/
    return;
  end


  call "IO2950" ("D ", SQLCA, CL6REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  else
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4);
      CLXREC.CLXERRF = "Y";
      VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
      VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
      sysLib.rollback();
      VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
      
      return;
    else
      TA1REC.TA1LOCAT[2] = "CL0LSDO";
      TA1REC.TA1LOCAT[4] = "IO2950";
      TA1REC.TA1DBASE = "DCLAIM";
      TA1REC.TA1TBLVU = "VIVOVR01";
      CLXREC.XXXWDTE = CLAREC.CLACLMNB;
      TA1REC.TA1TBLKE = CLXREC.XXXWDTE;
      XPCL010();
    end
  end

end // end KL0LSDO

// delete clm adj record size
Function KL0LSDS()
   /* GET CL0LSDL*/
   /* **************************************/
   /* *  delete data base for just one size*/
   /* **/
   /* **************************************/

  TA1REC.TA1LOCAT[2] = "CL0LSDS";
  if (CL0LW03.CL0LWDLT[CLXCURSZ] == "X")
    return;
  end

      /* move key data to clrrec to get set one size*/

  CLRREC.CLACLMNB = CLAREC.CLACLMNB; /* claim number*/
  CLRREC.CLHSEQNB = CLAREC.CLACSQNB; /* sequence number*/
  CLRREC.IV0PARTN = CL0LW02.IV0PARTN;
  CLRREC.IV0IVCID = CL0LW02.IV0IVCID;
  CLRREC.CLICRDFL = CL0LW03.CLICRDFL[CLXCURSZ];

  CLRREC.XGPCD = CLAREC.XGPCD;
  CLRREC.SY1STNBR = CL0LW02.SY1STNBR[CL0LWCAX];
  CLRREC.SY2CLRID = CL0LW02.SY2CLRID[CL0LWCAX];
  CLRREC.XDMCD = CL0LW02.XDMCD[CL0LWCAX];
  CLRREC.SY5SZID = CL0LW03.SY5SZID[CLXCURSZ]; /* size id*/
  CLRREC.OP2LNINB = CL0LW02.OP2LNINB[CL0LWCAX];
  CLRREC.ZZZCHGCT = CL0LW03.ZZZCHGCT[CLXCURSZ]; /* change count*/

  KL0LSDO(); /* check price override*/

  if (CLXREC.CLXERRF == "Y")
    return;
  end

  call "IO1370" ("D ", SQLCA, CLRREC) {isNoRefresh = yes, isExternal = yes}; /* delete record*/
  if (SQLCA.VAGen_SQLCODE == 0
   || SQLCA.VAGen_SQLCODE == 100)
     /* o.k.*/
    CL0LW01.CL0LWAUP = "Y"; /* adjust claim value*/
  else
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* deadlock, retry action*/
      CLXREC.CLXERRF = "Y";
      VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
      VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
      sysLib.rollback();
      VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
      
    else
      TA1REC.TA1DBASE = "DCLAIM"; /* error on delete*/
      TA1REC.TA1TBLVU = "VCLADJ01";
      XPCL010(); /* abend*/
    end
  end

  CL0LW03.CL0LWDLT[CLXCURSZ] = "X";
  CL0LW03.CLICRDFL[CLXCURSZ] = " ";
  CL0LW03.CL0LMSEL[CLXCURSZ] = " ";
  CL0LW03.CL0LWCHF[CLXCURSZ] = " ";
  CL0LW03.SY4IDDSC[CLXCURSZ] = " ";
  CL0LW03.CLRRQTQ[CLXCURSZ] = 0;
  CL0LW03.CLRCLMQ[CLXCURSZ] = 0;
  CL0LW03.SY5SZID[CLXCURSZ] = 0;
  CL0LW03.IV4SHPQ[CLXCURSZ] = 0;
  CL0LW03.IV4GUP[CLXCURSZ] = 0;
  CL0LW03.CLKPRCFF[CLXCURSZ] = " ";
  CL0LW03.CLNGRPRC[CLXCURSZ] = 0;


end // end KL0LSDS

// map 10 accum tot qty/valu chgs
Function KL0LSDT()
   /* GET CL0LSdT*/
     /* *******************************************************/
     /* if line cancelled, do below, reverse add/subtract*/
     /* if debit line, add to map totals and to clarec totals*/
     /* if credit line, subtract from map totals & clarec tots*/
     /* if neither, skip totaling*/

     /* adjust w01 counters(2) for product size totals*/
        /* and w01 counters(1) for summary product totals*/
     /* *******************************************************/

  if (CL0LW02.CLICRDFL[CL0LWCAX] != " "
   && CL0LW02.CLICRDFL[CL0LWCAX] != "B"
   && CL0LW03.CLICRDFL[CL0LWINX] != " ")
    if (CL0LW02.CLICRDFL[CL0LWCAX] != CL0LW03.CLICRDFL[CL0LWINX])
      CL0LW02.CLICRDFL[CL0LWCAX] = "B";
    end
  end

  if (CL0LW01.CL0LWINX < 2
   || CL0LW03.CLICRDFL[CL0LWINX] != " "
   || CL0LW02.CLICRDFL[CL0LWCAX] == "B")
    /* next sentence*/
  else
    CL0LW01.CL0LWSUB = CL0LW01.CL0LWINX - 1;
    CL0LW01.CL0LWFIN = "N";
    while (CL0LW01.CL0LWFIN == "N")
      if (KL0LM010.CL0LMSEL[CL0LWSUB] != " ")
        if (CL0LW03.CLICRDFL[CL0LWINX] != KL0LM010.CL0LMSEL[CL0LWSUB])
          CL0LW02.CLICRDFL[CL0LWCAX] = "B";
          CL0LW01.CL0LWFIN = "Y";
        else
          if (CL0LW01.CL0LWSUB < 2)
            CL0LW01.CL0LWFIN = "Y";
          else
            CL0LW01.CL0LWSUB = CL0LW01.CL0LWSUB - 1;
          end
        end
      else
        if (CL0LW01.CL0LWSUB < 2)
          CL0LW01.CL0LWFIN = "Y";
        else
          CL0LW01.CL0LWSUB = CL0LW01.CL0LWSUB - 1;
        end
      end
    end
  end


  if (KL0LM010.CL0LMSEL[CLXLINEX] == "X") /* line cancelled*/
    if (CL0LW03.CLICRDFL[CL0LWINX] != " ")
       /* (2) = detail total, (1) = product total*/
      CL0LW01.CLRRQTQ[2] = CL0LW01.CLRRQTQ[2] - KL0LM010.CLRRQTQ[CLXLINEX];
      CL0LW01.CLRRQTQ[1] = CL0LW01.CLRRQTQ[1] - KL0LM010.CLRRQTQ[CLXLINEX];
      CL0LW01.CLRCLMQ[2] = CL0LW01.CLRCLMQ[2] - KL0LM010.CLRCLMQ[CLXLINEX];
      CL0LW01.CLRCLMQ[1] = CL0LW01.CLRCLMQ[1] - KL0LM010.CLRCLMQ[CLXLINEX];
       /* also subtract clarec total qty*/
      CL0LW01.CL0LWQCH = CL0LW01.CL0LWQCH - KL0LM010.CLRCLMQ[CLXLINEX];
       /* claestvl calc before get here, signed for db/cr*/
      CL0LW01.CL0LWTVL[2] = CL0LW01.CL0LWTVL[2] - CL0LW01.CLAESTVL;
      CL0LW01.CL0LWTVL[1] = CL0LW01.CL0LWTVL[1] - CL0LW01.CLAESTVL;
       /* also subt clarec total value*/
      CL0LW01.CL0LWVCH = CL0LW01.CL0LWVCH - CL0LW01.CLAESTVL;

       /* ******************************************/
       /* modify product summary by size cancelled-*/
       /* (subtract value chng from w02(cl0lwcax))*/
       /* if size cr/db = prod cr/db code,*/
         /* subtract size clm qty from prod clm qty*/
         /* subtract size rqt qty from prod rqt qty*/
       /* else*/
         /* add size clm qty to prod clm qty*/
         /* add size rqt qty to prod rqt qty*/
       /* product totals are all positive.*/
       /* ******************************************/
      if (CL0LW03.CLICRDFL[CL0LWINX] == "C" /* if size exists*/
       || CL0LW03.CLICRDFL[CL0LWINX] == "D")
        CL0LW01.CL0LWQTY = KL0LM010.CLRRQTQ[CLXLINEX];
        if (CL0LW03.CLICRDFL[CL0LWINX] == CL0LW02.CLICRDFL[CL0LWCAX]
         || CL0LW02.CLICRDFL[CL0LWCAX] == "B")
          CL0LW02.CLRRQTQ[CL0LWCAX] = CL0LW02.CLRRQTQ[CL0LWCAX] - CL0LWQTY;
        else
          CL0LW02.CLRRQTQ[CL0LWCAX] = CL0LW02.CLRRQTQ[CL0LWCAX] + CL0LWQTY;
        end

        CL0LW01.CL0LWQTY = KL0LM010.CLRCLMQ[CLXLINEX];
        if (CL0LW03.CLICRDFL[CL0LWINX] == CL0LW02.CLICRDFL[CL0LWCAX]
         || CL0LW02.CLICRDFL[CL0LWCAX] == "B")
          CL0LW02.CLRCLMQ[CL0LWCAX] = CL0LW02.CLRCLMQ[CL0LWCAX] - CL0LWQTY;
        else
          CL0LW02.CLRCLMQ[CL0LWCAX] = CL0LW02.CLRCLMQ[CL0LWCAX] + CL0LWQTY;
        end
      end
    end


     /* *********************/
     /* move 0 to old values*/
     /* *********************/
    CL0LW01.CL0LWORQ[CLXLINEX] = 0;
    CL0LW01.CL0LWOCQ[CLXLINEX] = 0;
    CL0LW01.CL0LWOVL[CLXLINEX] = 0;
     /* MOVE 0 TO CL0LM010.CLRRQTQ(CLXLINEX);*/
     /* MOVE 0 TO CL0LM010.CLRCLMQ(CLXLINEX);*/
     /* MOVE 0 TO CL0LM010.CLAESTVL(CLXLINEX);*/
     /* MOVE ' ' TO CL0LM010.SY4IDDSC(CLXLINEX);*/
     /* MOVE 0 TO CL0LM010.IV4SHPQ(CLXLINEX);*/
     /* MOVE ' ' TO CL0LM010.CLKPRCFF(CLXLINEX);*/
     /* MOVE 0 TO CL0LM010.IV4GUP(CLXLINEX);*/
     /* MOVE 0 TO CL0LM010.CLNGRPRC(CLXLINEX);*/
     /* MOVE ' ' TO CL0LM010.CL0LMSEL(CLXLINEX);*/
     /* MOVE ' ' TO CL0LM010.CLICRDFL(CLXLINEX);*/
    return;
  end


     /* **************************************************/
     /* standard debit/credit, accum map & product totals*/
     /* **************************************************/

  if (CL0LW01.CL0LWMOD[CLXLINEX] == "Y")
    /* next sentence*/
  else
    return;
  end

  if (KL0LM010.CLICRDFL[CLXLINEX] == "D" /* add in debit change*/
   || CL0LW03.CLICRDFL[CL0LWINX] == "D")
     /* new qty - old qty, then add to totals*/
    CL0LWQTY = KL0LM010.CLRRQTQ[CLXLINEX] - CL0LW01.CL0LWORQ[CLXLINEX];
    CL0LW01.CLRRQTQ[2] = CL0LW01.CLRRQTQ[2] + CL0LW01.CL0LWQTY;
    CL0LW01.CLRRQTQ[1] = CL0LW01.CLRRQTQ[1] + CL0LW01.CL0LWQTY;

     /* new qty - old qty, then add to totals*/
    CL0LWQTY = KL0LM010.CLRCLMQ[CLXLINEX] - CL0LW01.CL0LWOCQ[CLXLINEX];
    CL0LW01.CLRCLMQ[2] = CL0LW01.CLRCLMQ[2] + CL0LW01.CL0LWQTY;
    CL0LW01.CLRCLMQ[1] = CL0LW01.CLRCLMQ[1] + CL0LW01.CL0LWQTY;
     /* also add clarec total qty*/
    CL0LW01.CL0LWQCH = CL0LW01.CL0LWQCH + CL0LW01.CL0LWQTY;

     /* new value - old value, then add to totals*/
     /* cl0lw01.claestvl was calc in cl0l320 before came here*/
     /* already signed for db/cr*/
    CL0LWQTY = CL0LW01.CLAESTVL - CL0LW01.CL0LWOVL[CLXLINEX];
    CL0LW01.CL0LWTVL[2] = CL0LW01.CL0LWTVL[2] + CL0LW01.CL0LWQTY;
    CL0LW01.CL0LWTVL[1] = CL0LW01.CL0LWTVL[1] + CL0LW01.CL0LWQTY;
     /* also add clarec total value*/
    CL0LW01.CL0LWVCH = CL0LW01.CL0LWVCH + CL0LW01.CL0LWQTY;
  else
    if (KL0LM010.CLICRDFL[CLXLINEX] == "C" /* subtract out credit chgs*/
     || CL0LW03.CLICRDFL[CL0LWINX] == "C")
       /* new qty - old qty, then subt to totals*/
      if (KL0LM010.CLRRQTQ[CLXLINEX] < 0)
        CL0LW01.CL0LWQTY = KL0LM010.CLRRQTQ[CLXLINEX] * -1;
      else
        CL0LW01.CL0LWQTY = KL0LM010.CLRRQTQ[CLXLINEX];
      end
      CL0LW01.CL0LWQTY = CL0LW01.CL0LWQTY - CL0LW01.CL0LWORQ[CLXLINEX];
      CL0LW01.CLRRQTQ[2] = CL0LW01.CLRRQTQ[2] - CL0LW01.CL0LWQTY;
      CL0LW01.CLRRQTQ[1] = CL0LW01.CLRRQTQ[1] - CL0LW01.CL0LWQTY;

       /* new qty - old qty, then subt to totals*/
      if (KL0LM010.CLRCLMQ[CLXLINEX] < 0)
        CL0LW01.CL0LWQTY = KL0LM010.CLRCLMQ[CLXLINEX] * -1;
      else
        CL0LW01.CL0LWQTY = KL0LM010.CLRCLMQ[CLXLINEX];
      end
      CL0LW01.CL0LWQTY = CL0LW01.CL0LWQTY - CL0LW01.CL0LWOCQ[CLXLINEX];
      CL0LW01.CLRCLMQ[2] = CL0LW01.CLRCLMQ[2] - CL0LW01.CL0LWQTY;
      CL0LW01.CLRCLMQ[1] = CL0LW01.CLRCLMQ[1] - CL0LW01.CL0LWQTY;
       /* also subtract clarec total qty*/
      CL0LW01.CL0LWQCH = CL0LW01.CL0LWQCH - CL0LW01.CL0LWQTY;

       /* new value - old value, then add delta to totals*/
       /* cl0lw01.claestvl was calc in cl0l120 before came here*/
       /* already signed for db/cr*/
      CL0LWQTY = CL0LW01.CLAESTVL - CL0LW01.CL0LWOVL[CLXLINEX];
      CL0LW01.CL0LWTVL[2] = CL0LW01.CL0LWTVL[2] + CL0LW01.CL0LWQTY;
      CL0LW01.CL0LWTVL[1] = CL0LW01.CL0LWTVL[1] + CL0LW01.CL0LWQTY;
       /* also add clarec total value*/
      CL0LW01.CL0LWVCH = CL0LW01.CL0LWVCH + CL0LW01.CL0LWQTY;
    end
  end


     /* ******************************************/
     /* add size changes to product summary,*/
     /* (add value chng to w02(cl0lwcax))*/
     /* if size cr/db = prod cr/db code,*/
       /* add size clm qty to prod clm qty*/
       /* add size rqt qty to prod rqt qty*/
     /* else*/
       /* subtract size clm qty from prod clm qty*/
       /* subtract size rqt qty from prod rqt qty*/
     /* product totals are all positive.*/
     /* ******************************************/

  if (CL0LW03.CLICRDFL[CL0LWINX] == "C" /* if size exists*/
   || CL0LW03.CLICRDFL[CL0LWINX] == "D")
     /* new qty - old qty, then add to product summary*/
    CL0LW01.CL0LWQTY = KL0LM010.CLRRQTQ[CLXLINEX];
    if (CL0LW03.CLICRDFL[CL0LWINX] == "C")
      CL0LW01.CL0LWQTY = CL0LW01.CL0LWQTY + CL0LW01.CL0LWORQ[CLXLINEX];
    else
      CL0LW01.CL0LWQTY = CL0LW01.CL0LWQTY - CL0LW01.CL0LWORQ[CLXLINEX];
    end
    if (CL0LW03.CLICRDFL[CL0LWINX] == CL0LW02.CLICRDFL[CL0LWCAX]
     || CL0LW02.CLICRDFL[CL0LWCAX] == "B")
      CL0LW02.CLRRQTQ[CL0LWCAX] = CL0LW02.CLRRQTQ[CL0LWCAX] + CL0LWQTY;
    else
      CL0LW02.CLRRQTQ[CL0LWCAX] = CL0LW02.CLRRQTQ[CL0LWCAX] - CL0LWQTY;
    end

     /* new qty - old qty, then add to product summary*/
    CL0LW01.CL0LWQTY = KL0LM010.CLRCLMQ[CLXLINEX];
    if (CL0LW03.CLICRDFL[CL0LWINX] == "C")
      CL0LW01.CL0LWQTY = CL0LW01.CL0LWQTY + CL0LW01.CL0LWOCQ[CLXLINEX];
    else
      CL0LW01.CL0LWQTY = CL0LW01.CL0LWQTY - CL0LW01.CL0LWOCQ[CLXLINEX];
    end
    if (CL0LW03.CLICRDFL[CL0LWINX] == CL0LW02.CLICRDFL[CL0LWCAX]
     || CL0LW02.CLICRDFL[CL0LWCAX] == "B")
      CL0LW02.CLRCLMQ[CL0LWCAX] = CL0LW02.CLRCLMQ[CL0LWCAX] + CL0LWQTY;
    else
      CL0LW02.CLRCLMQ[CL0LWCAX] = CL0LW02.CLRCLMQ[CL0LWCAX] - CL0LWQTY;
    end
  end

  if (CL0LW01.CL0LWSHP[CLXLINEX] == "Y")
    CL0LW01.CL0LWTSH[2] = CL0LW01.CL0LWTSH[2] + KL0LM010.IV4SHPQ[CLXLINEX];
    CL0LW01.CL0LWSHP[CLXLINEX] = "N";
  end


     /* **************************************/
     /* move current map values to old values*/
     /* **************************************/

  if (CL0LW03.CLICRDFL[CL0LWINX] == "C")
    CL0LW01.CL0LWORQ[CLXLINEX] = KL0LM010.CLRRQTQ[CLXLINEX] * -1;
    CL0LW01.CL0LWOCQ[CLXLINEX] = KL0LM010.CLRCLMQ[CLXLINEX] * -1;
    CL0LW01.CL0LWOVL[CLXLINEX] = CL0LW01.CLAESTVL;
  else
    CL0LW01.CL0LWORQ[CLXLINEX] = KL0LM010.CLRRQTQ[CLXLINEX];
    CL0LW01.CL0LWOCQ[CLXLINEX] = KL0LM010.CLRCLMQ[CLXLINEX];
    CL0LW01.CL0LWOVL[CLXLINEX] = CL0LW01.CLAESTVL;
  end


end // end KL0LSDT

// get style/color sycrec
Function KL0LSE0()
     /* ****************************************/
     /* nike product id must be on product file*/
     /* ****************************************/

  TA1REC.TA1LOCAT[2] = "CL0LSE0";
  if (KL0LM001.CL0LMSEL[CLXLINEX] == "X")
    return;
  end

  CL0LW01.CL0LWMOD[CLXLINEX] = "Y";
  if (CL0LW01.CL0LWSYC != "N") /* if have sycrec, or found error, exit*/
    return;
  end


  SYCREC.XGPCD = CLAREC.XGPCD;
  SYCREC.SY1STNBR = KL0LM001.SY1STNBR[CLXLINEX];
  if (KL0LM001.SY2CLRID[CLXLINEX] == " ")
    SYCREC.SY2CLRID = "00 ";
  else
    SYCREC.SY2CLRID = KL0LM001.SY2CLRID[CLXLINEX];
  end
  if (KL0LM001.XDMCD[CLXLINEX] == " ")
    SYCREC.XDMCD = "00";
  else
    SYCREC.XDMCD = KL0LM001.XDMCD[CLXLINEX];
  end

  call "IO0560" ("S ", SQLCA, SYCREC) {isNoRefresh = yes, isExternal = yes}; /* validate nike prod id*/

  if (SQLCA.VAGen_SQLCODE == 0)
    CL0LW01.CL0LWSYC = "Y"; /* have sycrec*/
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      CL0LW01.CL0LWSYC = "E"; /* sycrec error*/
      converseLib.validationFailed(200); /* nike prod id is not valid*/
      CLXREC.CLXERRF = "Y";
      CL0LW01.CL0LWERR[CLXLINEX] = "Y";
      if (KL0LM001.XDMCD[CLXLINEX] != " ")
        set KL0LM001.XDMCD[CLXLINEX] cursor, modified, bold;
      end
      if (KL0LM001.SY2CLRID[CLXLINEX] != " ")
        set KL0LM001.SY2CLRID[CLXLINEX] cursor, modified, bold;
      end
      set KL0LM001.SY1STNBR[CLXLINEX] cursor, modified, bold;
    else
      if (SQLCA.VAGen_SQLCODE == -911)
        converseLib.validationFailed(4); /* deadlock, retry action*/
      else
        TA1REC.TA1DBASE = "DPROD";
        TA1REC.TA1TBLVU = "VCOLOR02";
        XPCL010(); /* abend*/
      end
    end
  end



end // end KL0LSE0

// map 1 & 10 edit claim price
Function KL0LSE1()
   /* ************************************************************/
   /* *     edit claim price*/
   /* **/
   /* ************************************************************/

     /* can not enter price unless 'price from' is 'e'*/

  if (CLXREC.CLXSCRNX == 1) /* map 1*/
    if (KL0LM001.CL0LMSEL[CLXLINEX] == "X"
     || KL0LM001.CL0LMSEL[CLXLINEX] == "S"
     || KL0LM001.CL0LMSEL[CLXLINEX] == "A"
     || KL0LM001.CL0LMSEL[CLXLINEX] == "SA")
      return;
    end
    CL0LW01.CL0LWMOD[CLXLINEX] = "Y";
    if (KL0LM001.CLNGRPRC[CLXLINEX] != 0)
      if (KL0LM001.CLKPRCFF[CLXLINEX] != "E") /* entered price*/
        converseLib.validationFailed(222); /* cant enter price*/
        CLXREC.CLXERRF = "Y";
        CL0LW01.CL0LWERR[CLXLINEX] = "Y";
        set KL0LM001.CLKPRCFF[CLXLINEX] cursor, bold;
        set KL0LM001.CLNGRPRC[CLXLINEX] modified, bold;
        return;
      end
    end

    if (KL0LM001.CLKPRCFF[CLXLINEX] == "E"
     && KL0LM001.CLNGRPRC[CLXLINEX] == 0)
      CLXREC.CLXERRF = "Y";
      CL0LW01.CL0LWERR[CLXLINEX] = "Y";
      converseLib.validationFailed(217);
      set KL0LM001.CLNGRPRC[CLXLINEX] cursor, modified, bold;
      set KL0LM001.CLKPRCFF[CLXLINEX] modified, bold;
      return;
    end

    set KL0LM001.CLNGRPRC[CLXLINEX] initialAttributes;
    set KL0LM001.CLKPRCFF[CLXLINEX] initialAttributes;

    if (KL0LM001.CLNGRPRC[CLXLINEX] == 0)
      KL0LM001.CLNGRPRC[CLXLINEX] = CL0LW02.CLNGRPRC[CL0LWINX];
    end

  else /* map 10*/
    if (KL0LM010.CL0LMSEL[CLXLINEX] == "X")
      set KL0LM010.CLNGRPRC[CLXLINEX] initialAttributes;
      return;
    end
    CL0LW01.CL0LWMOD[CLXLINEX] = "Y";
    if (KL0LM010.CLNGRPRC[CLXLINEX] != 0)
      if (KL0LM010.CLKPRCFF[CLXLINEX] != "E") /* entered price*/
        converseLib.validationFailed(222); /* cant enter price*/
        CLXREC.CLXERRF = "Y";
        CL0LW01.CL0LWERR[CLXLINEX] = "Y";
        set KL0LM010.CLKPRCFF[CLXLINEX] cursor, bold;
        set KL0LM010.CLNGRPRC[CLXLINEX] modified, bold;
        return;
      end
    end

    if (KL0LM010.CLKPRCFF[CLXLINEX] == "E"
     && KL0LM010.CLNGRPRC[CLXLINEX] == 0)
      CLXREC.CLXERRF = "Y";
      CL0LW01.CL0LWERR[CLXLINEX] = "Y";
      converseLib.validationFailed(217);
      set KL0LM010.CLNGRPRC[CLXLINEX] cursor, modified, bold;
      set KL0LM010.CLKPRCFF[CLXLINEX] modified, bold;
      return;
    end

    set KL0LM010.CLNGRPRC[CLXLINEX] initialAttributes;
    set KL0LM010.CLKPRCFF[CLXLINEX] initialAttributes;

    if (KL0LM010.CLNGRPRC[CLXLINEX] == 0)
      KL0LM010.CLNGRPRC[CLXLINEX] = CL0LW03.CLNGRPRC[CL0LWINX];
    end
  end

end // end KL0LSE1

// map 1 edit price from flag
Function KL0LSE2()
   /* *********************************/
   /* *     edit price from flag*/
   /* **/
   /* *********************************/


    /* Maintenance History:*/
    /* 04-10-90 CHELLM Added XQACD and XUMCD to the product key*/
                    /* when selecting invoice price overrides.*/

   /* *************************************************************/

     /* note - cl0lwinx = array pointer, kept in sync with*/
     /* clxlinex in cl0l120.*/

  TA1REC.TA1LOCAT[2] = "CL0LSE2";
  if (KL0LM001.CL0LMSEL[CLXLINEX] == "X"
   || KL0LM001.CL0LMSEL[CLXLINEX] == "S"
   || KL0LM001.CL0LMSEL[CLXLINEX] == "A"
   || KL0LM001.CL0LMSEL[CLXLINEX] == "SA")
    return;
  end

  CL0LW01.CL0LWMOD[CLXLINEX] = "Y";

  if (KL0LM001.CLKPRCFF[CLXLINEX] == "I") /* take price from invoice*/
    if (KL0LM001.IV0IVCID != 0 /* must have invoice for 'i'*/
     && CL0LW01.YITCD == "I")  /* an I.B.M. invoice*/
      set KL0LM001.CLKPRCFF[CLXLINEX] initialAttributes;
    else
      converseLib.validationFailed(205); /* 'price from' not valid, no invoice*/
      set KL0LM001.CLKPRCFF[CLXLINEX] cursor, modified, bold;
      CLXREC.CLXERRF = "Y";
      CL0LW01.CL0LWERR[CLXLINEX] = "Y";
      return;
    end
  else
    if (KL0LM001.CLKPRCFF[CLXLINEX] == "E" /* user entered price*/
     || KL0LM001.CLKPRCFF[CLXLINEX] == "P") /* take price from product*/
      set KL0LM001.CLKPRCFF[CLXLINEX] initialAttributes;
    else
      if (KL0LM001.SY1STNBR[CLXLINEX] == " " /* allow ' '*/
       && KL0LM001.CLKPRCFF[CLXLINEX] == " ")
        set KL0LM001.CLKPRCFF[CLXLINEX] initialAttributes;
      else
        converseLib.validationFailed(201); /* 'price from' not valid, 'i' 'p' or*/
                                   /* 'e'*/
        set KL0LM001.CLKPRCFF[CLXLINEX] cursor, modified, bold;
        CLXREC.CLXERRF = "Y";
        CL0LW01.CL0LWERR[CLXLINEX] = "Y";
        return;
      end
    end
  end


     /* **************/
     /* field is o.k.*/
     /* **************/

     /* *****************************/
     /* now act upon the code*/
     /* user wants price taken from:*/
     /* *****************************/

     /* **********************/
     /* price must be entered*/
     /* **********************/

  if (KL0LM001.CLKPRCFF[CLXLINEX] == "E"
   && KL0LM001.CLNGRPRC[CLXLINEX] == 0)
    CLXREC.CLXERRF = "Y";
    CL0LW01.CL0LWERR[CLXLINEX] = "Y";
    converseLib.validationFailed(217); /* price required for code 'e'*/
    set KL0LM001.CLNGRPRC[CLXLINEX] cursor, modified, bold;
    set KL0LM001.CLKPRCFF[CLXLINEX] modified, bold;
    return;
  end


     /* ***************************/
     /* price must be from invoice*/
     /* ***************************/

  if (KL0LM001.CLKPRCFF[CLXLINEX] == "I")
    CL6REC.IV0PARTN = CL0LW02.IV0PARTN;
    CL6REC.IV0IVCID = CL0LW02.IV0IVCID;
    CL6REC.XGPCD = CLAREC.XGPCD;
    CL6REC.SY1STNBR = CL0LW02.SY1STNBR[CL0LWINX];
    CL6REC.SY2CLRID = CL0LW02.SY2CLRID[CL0LWINX];
    CL6REC.XDMCD = CL0LW02.XDMCD[CL0LWINX];
    CL6REC.XQACD = CL0LW02.XQACD[CL0LWINX];
    CL6REC.XUMCD = CL0LW02.XUMCD[CL0LWINX];
    CL6REC.SY5SZID = 0;

    KL0LSSO(); /* select set price override*/

    if (SQLCA.VAGen_SQLCODE == 0
     && CL6REC.CLHMEMNB > 0)
      CL0LW02.CLNGRPRC[CL0LWINX] = CL6REC.CL6OVPRC;
      CL0LW02.CLNNTPRC[CL0LWINX] = CL6REC.CL6OVPRC;
      KL0LM001.CLNGRPRC[CLXLINEX] = CL6REC.CL6OVPRC;
      KL0LM001.CLKPRCFF[CLXLINEX] = "O";
      KL0LM001.CL0LMVPR[CLXLINEX] = " ";
    else
      IV3REC.IV0PARTN = CL0LW02.IV0PARTN;
      IV3REC.IV0IVCID = CL0LW02.IV0IVCID;
      IV3REC.OP2LNINB = CL0LW02.OP2LNINB[CL0LWINX];

      call "IO1100" ("S ", SQLCA, IV3REC) {isNoRefresh = yes, isExternal = yes}; /* read*/

      if (SQLCA.VAGen_SQLCODE == 0)
        CL0LW02.CLNGRPRC[CL0LWINX] = IV3REC.IV3GLNUP;
        CL0LW02.CLNNTPRC[CL0LWINX] = IV3REC.IV3NLNUP;
        if (CL0LW02.IVANBLFL == "Y") /* net bill flag*/
          KL0LM001.CLNGRPRC[CLXLINEX] = IV3REC.IV3NLNUP;
        else
          KL0LM001.CLNGRPRC[CLXLINEX] = IV3REC.IV3GLNUP;
        end
        CL0LW02.OP2PRCVF[CL0LWINX] = IV3REC.OP2PRCVF;
         /* have just 1 field in cl0lw02, so only move 'y'*/
         /* IF IV3REC.OP2PRCOF EQ 'Y';*/
           /* MOVE IV3REC.OP2PRCOF TO CL0LW02.OP2PRCVF(CL0LWINX);*/
         /* END ;*/
        if (CL0LW02.OP2PRCVF[CL0LWINX] == "Y") /* flag price if by size*/
          KL0LM001.CL0LMVPR[CLXLINEX] = "V";
        else
          KL0LM001.CL0LMVPR[CLXLINEX] = " ";
        end
      else
        converseLib.validationFailed(205); /* 'price from' not valid, no invoice*/
        set KL0LM001.CLKPRCFF[CLXLINEX] cursor, modified, bold;
        CLXREC.CLXERRF = "Y";
        CL0LW01.CL0LWERR[CLXLINEX] = "Y";
        CL0LW02.CLNGRPRC[CL0LWINX] = 0;
        CL0LW02.CLNNTPRC[CL0LWINX] = 0;
        CL0LW02.OP2PRCVF[CL0LWINX] = " ";
      end
    end

    call "IO2950" ("CS", SQLCA, CL6REC) {isNoRefresh = yes, isExternal = yes};

    return;
  end


     /* ********************************/
     /* price is taken from the product*/
     /* ********************************/

  if (KL0LM001.CLKPRCFF[CLXLINEX] == "P")
    KL0LSPP(); /* get product price*/
    if (CL0LW02.CLNGRPRC[CL0LWINX] == 0
     && CL0LW02.CLNNTPRC[CL0LWINX] == 0)
      converseLib.validationFailed(226); /* warn-prod price not found*/
      set KL0LM001.CLNGRPRC[CLXLINEX] cursor, bold;
      CL0LW02.OP2PRCVF[CL0LWINX] = " ";
      CL0LW01.CL0LWWRN[CLXLINEX] = "Y";
    end
  end



end // end KL0LSE2

// map 1 & 10 edit claim qty
Function KL0LSE3()
   /* *********************************/
   /* *     edit claim quantity*/
   /* **/
   /* *********************************/


   /* there is no edit of this field*/

  if (CLXREC.CLXSCRNX == 1)
    set KL0LM001.CLRCLMQ[CLXLINEX] initialAttributes;

    if (KL0LM001.CL0LMSEL[CLXLINEX] == "X"
     || KL0LM001.CL0LMSEL[CLXLINEX] == "S"
     || KL0LM001.CL0LMSEL[CLXLINEX] == "A"
     || KL0LM001.CL0LMSEL[CLXLINEX] == "SA")
      return;
    end
    CL0LW01.CL0LWMOD[CLXLINEX] = "Y";

  else
    set KL0LM010.CLRCLMQ[CLXLINEX] initialAttributes;

    if (KL0LM010.CL0LMSEL[CLXLINEX] == "X")
      return;
    end

    CL0LW01.CL0LWMOD[CLXLINEX] = "Y";
  end

end // end KL0LSE3

// map 1 & 10 edit cust rqstd qty
Function KL0LSE4()
   /* *********************************/
   /* *     edit cust requested qty*/
   /* **/
   /* *********************************/


   /* there is no edit of this field*/

  if (CLXREC.CLXSCRNX == 1)
    set KL0LM001.CLRRQTQ[CLXLINEX] initialAttributes;

    if (KL0LM001.CL0LMSEL[CLXLINEX] == "X"
     || KL0LM001.CL0LMSEL[CLXLINEX] == "S"
     || KL0LM001.CL0LMSEL[CLXLINEX] == "A"
     || KL0LM001.CL0LMSEL[CLXLINEX] == "SA")
      return;
    end
    CL0LW01.CL0LWMOD[CLXLINEX] = "Y";

    if (CL0LW02.CLICRDFL[CL0LWINX] == "C"
     || CL0LW02.CLICRDFL[CL0LWINX] == "D"
     || KL0LM001.CL0LMSEL[CLXLINEX] == "C"
     || KL0LM001.CL0LMSEL[CLXLINEX] == "D")
      if (KL0LM001.CLRRQTQ[CLXLINEX] == 0)
        converseLib.validationFailed(231);
        CLXREC.CLXERRF = "Y";
        CL0LW01.CL0LWERR[CLXLINEX] = "Y";
        set KL0LM001.CLRRQTQ[CLXLINEX] cursor, modified, bold;
      end
    end

  else
    set KL0LM010.CLRRQTQ[CLXLINEX] initialAttributes;

    if (KL0LM010.CL0LMSEL[CLXLINEX] == "X")
      return;
    end

    CL0LW01.CL0LWMOD[CLXLINEX] = "Y";

    if (CL0LW03.CLICRDFL[CL0LWINX] == "C"
     || CL0LW03.CLICRDFL[CL0LWINX] == "D"
     || KL0LM010.CL0LMSEL[CLXLINEX] == "C"
     || KL0LM010.CL0LMSEL[CLXLINEX] == "D")
      if (KL0LM010.CLRRQTQ[CLXLINEX] == 0)
        converseLib.validationFailed(231);
        CLXREC.CLXERRF = "Y";
        CL0LW01.CL0LWERR[CLXLINEX] = "Y";
        set KL0LM010.CLRRQTQ[CLXLINEX] cursor, modified, bold;
        return;
      end
    end
  end

end // end KL0LSE4

// map 1 edit nike product i.d.
Function KL0LSE5()
   /* ******************************/
   /* *   edit nike product i.d.*/
   /* **/
   /* ******************************/


    /* Maintenance History:*/
    /* 04-10-90 CHELLM Added XQACD and XUMCD to the product key*/
                    /* when selecting invoice price overrides.*/

   /* *************************************************************/

     /* if user entered 'x' to cancel, skip edits*/

  TA1REC.TA1LOCAT[2] = "CL0LSE5";
  if (KL0LM001.CL0LMSEL[CLXLINEX] == "X")
    set KL0LM001.SY1STNBR[CLXLINEX] initialAttributes;
    set KL0LM001.SY2CLRID[CLXLINEX] initialAttributes;
    set KL0LM001.XDMCD[CLXLINEX] initialAttributes;
    return;
  end

  CL0LW01.CL0LWMOD[CLXLINEX] = "Y";

     /* set new array and map indexes*/

  if (CL0LW01.CL0LWCHK[CLXLINEX] != "Y")
    if (CL0LW01.CL0LWINX >= CLXREC.CLXARAYX)
      CLXREC.CLXARAYX = CLXREC.CLXARAYX + 1; /* next avail array*/
      CLXREC.CLXARAYX = CLXREC.CLXARAYX + CL0LW01.CL0LWEXT;
      CLXREC.CLXLSTAX = CLXREC.CLXARAYX; /* total # array entries*/
      CLXREC.CLXMAPMX = CLXREC.CLXMAPMX + 1; /* total # map lines from aray*/
      CLXREC.CLXMAPMX = CLXREC.CLXMAPMX + CL0LW01.CL0LWEXT;
      CL0LW01.CL0LWEXT = 0;
    end
  end

  if (KL0LM001.CL0LMSEL[CLXLINEX] == "S"
   || KL0LM001.CL0LMSEL[CLXLINEX] == "SA"
   || KL0LM001.CL0LMSEL[CLXLINEX] == "A")
    CL0LW02.CL0LWCHF[CL0LWINX] = " ";
  else
    CL0LW02.CL0LWCHF[CL0LWINX] = "A"; /* mark as added*/
  end

  CL0LW01.CL0LWCHK[CLXLINEX] = "Y";
  CL0LW02.CL0LWDLT[CL0LWINX] = " ";

     /* **************************/
     /* move map product to array*/
     /* **************************/

  CL0LW02.SY1STNBR[CL0LWINX] = KL0LM001.SY1STNBR[CLXLINEX];

  if (KL0LM001.SY2CLRID[CLXLINEX] == " ")
    CL0LW02.SY2CLRID[CL0LWINX] = "00 ";
    KL0LM001.SY2CLRID[CLXLINEX] = "00 ";
  else
    CL0LW02.SY2CLRID[CL0LWINX] = KL0LM001.SY2CLRID[CLXLINEX];
  end

  if (KL0LM001.XDMCD[CLXLINEX] == " ")
    CL0LW02.XDMCD[CL0LWINX] = "00";
    KL0LM001.XDMCD[CLXLINEX] = "00";
  else
    CL0LW02.XDMCD[CL0LWINX] = KL0LM001.XDMCD[CLXLINEX];
  end

  CL0LW02.XGPCD[CL0LWINX] = CLAREC.XGPCD; /* hold g.p.c.*/


     /* **********************************/
     /* nike product id on product file*/
     /* edit done by cl0lse0 from cl0l120*/
     /* **********************************/

  if (CL0LW01.CL0LWSYC == "Y") /* have style/color record*/
    CL0LW02.XUMCD[CL0LWINX] = SYCREC.XUMCD; /* unit of measure*/
    CL0LW01.SY4SZSCL = SYCREC.SY4SZSCL; /* size scale for pricing*/
  else
    converseLib.validationFailed(200); /* nike prod id is not valid*/
    CLXREC.CLXERRF = "Y";
    CL0LW01.CL0LWERR[CLXLINEX] = "Y";
    set KL0LM001.SY1STNBR[CLXLINEX] cursor, modified, bold;
    return;
  end


     /* * / * / * / * / * / * / * / * / * / * / * / * /*/
     /* phase b enhancement - enter quality code on map*/

  CL0LW02.XQACD[CL0LWINX] = "01"; /* default to first quality*/

     /* * / * / * / * / * / * / * / * / * / * / * / * /*/


     /* *************/
     /* product o.k.*/
     /* *************/

  set KL0LM001.SY1STNBR[CLXLINEX] initialAttributes; /* reset attributes*/
  set KL0LM001.SY2CLRID[CLXLINEX] initialAttributes;
  set KL0LM001.XDMCD[CLXLINEX] initialAttributes;



     /* **********************************/
     /* if have invoice, do more checking*/
     /* **********************************/

  if (KL0LM001.IV0IVCID == 0 /* if no invoice, done with edit*/
   || CL0LW01.YITCD != "I")  /* or not I.B.M. invoice*/
    if (KL0LM001.CLKPRCFF[CLXLINEX] == " " /* if no price from flag*/
     || KL0LM001.CLKPRCFF[CLXLINEX] == "P")
      if (CL0LW02.CLICRDFL[CL0LWINX] == "C" /* and product worked here*/
       || CL0LW02.CLICRDFL[CL0LWINX] == "D" 
       || KL0LM001.CL0LMSEL[CLXLINEX] == "C"
       || KL0LM001.CL0LMSEL[CLXLINEX] == "D")
        CL0LW02.CLKPRCFF[CL0LWINX] = "P"; /* to product*/
        KL0LM001.CLKPRCFF[CLXLINEX] = "P";
        KL0LSPP(); /* get product price*/
        if (converseVar.validationMsgNum == 226)
          if (CL0LW02.CLNGRPRC[CL0LWINX] != 0
           && CL0LW02.CLNNTPRC[CL0LWINX] != 0)
            set KL0LM001.CLNGRPRC[CLXLINEX] initialAttributes;
            converseLib.validationFailed(0);
          end
        end
      end
    end

    return;
  end


   /* ************************************************************/
   /* if claim has I.B.M. invoice, then product could be on invc*/
   /* ************************************************************/

  IV3REC.IV0PARTN = CL0LW02.IV0PARTN;
  IV3REC.IV0IVCID = CL0LW02.IV0IVCID;

  IV3REC.SY1STNBR = CL0LW02.SY1STNBR[CL0LWINX];
  IV3REC.SY2CLRID = CL0LW02.SY2CLRID[CL0LWINX];
  IV3REC.XDMCD = CL0LW02.XDMCD[CL0LWINX];
  IV3REC.XLCCD = "**"; /* all life cycles*/
  IV3REC.XQACD = "**"; /* and all qualities*/
  IV3REC.OP2LNINB = -1; /* and all line items*/

  call "IO1100" ("S2", SQLCA, IV3REC) {isNoRefresh = yes, isExternal = yes}; /* select set*/
  if (SQLCA.VAGen_SQLCODE != 0)
    TA1REC.TA1DBASE = "DINVC";
    TA1REC.TA1TBLVU = "VIVITM01";
    XPCL010();
  end

  call "IO1100" ("N2", SQLCA, IV3REC) {isNoRefresh = yes, isExternal = yes}; /* select first record*/

  if (SQLCA.VAGen_SQLCODE == 0)
    call "IO1100" ("C2", SQLCA, IV3REC) {isNoRefresh = yes, isExternal = yes}; /* close set*/
     /* order line item number*/
    CL0LW02.OP2LNINB[CL0LWINX] = IV3REC.OP2LNINB;
     /* shipped qty*/
    CL0LW02.IV3LNSQ[CL0LWINX] = IV3REC.IV3LNSQ; /* to w/s*/
    KL0LM001.IV3LNSQ[CLXLINEX] = IV3REC.IV3LNSQ; /* to map*/
     /* invoice price*/
    CL0LW02.IV3GLNUP[CL0LWINX] = IV3REC.IV3GLNUP;
    KL0LM001.IV3GLNUP[CLXLINEX] = IV3REC.IV3GLNUP;
  else
    call "IO1100" ("C2", SQLCA, IV3REC) {isNoRefresh = yes, isExternal = yes}; /* close set*/
    converseLib.validationFailed(208); /* warning - product is not on the invoice*/
    set KL0LM001.SY1STNBR[CLXLINEX] bold;
    set KL0LM001.CL0LMSEL[CLXLINEX] cursor, modified, bold;
    CL0LW01.CL0LW1WN[CLXLINEX] = "Y";
    CL0LW01.CL0LWERR[CLXLINEX] = "Y";
    CLXREC.CLXERRF = "Y";
     /* default price from flag to product value*/
    if (KL0LM001.CLKPRCFF[CLXLINEX] == " "
     || KL0LM001.CLKPRCFF[CLXLINEX] == "P")
      CL0LW02.CLKPRCFF[CL0LWINX] = "P";
      KL0LM001.CLKPRCFF[CLXLINEX] = "P";
      KL0LSPP(); /* get product price*/
    end
    return;
  end


  if (KL0LM001.CLKPRCFF[CLXLINEX] == " " /* default price from code*/
   || KL0LM001.CLKPRCFF[CLXLINEX] == "I")
    if (CL0LW01.CL0LWPFL == "Y")
      CL6REC.IV0PARTN = CL0LW02.IV0PARTN;
      CL6REC.IV0IVCID = CL0LW02.IV0IVCID;
      CL6REC.XGPCD = CL0LW02.XGPCD[CL0LWINX];
      CL6REC.SY1STNBR = CL0LW02.SY1STNBR[CL0LWINX];
      CL6REC.SY2CLRID = CL0LW02.SY2CLRID[CL0LWINX];
      CL6REC.XDMCD = CL0LW02.XDMCD[CL0LWINX];
      CL6REC.XQACD = CL0LW02.XQACD[CL0LWINX];
      CL6REC.XUMCD = CL0LW02.XUMCD[CL0LWINX];
      CL6REC.SY5SZID = 0;

      KL0LSSO(); /* check for override price*/

      if (CLXREC.CLXERRF == "Y")
        return;
      end
      if (SQLCA.VAGen_SQLCODE == 0
       && CL6REC.CLHMEMNB > 0)
        CL0LW02.CLNGRPRC[CL0LWINX] = CL6REC.CL6OVPRC;
        CL0LW02.CLNNTPRC[CL0LWINX] = CL6REC.CL6OVPRC;
        KL0LM001.CLNGRPRC[CLXLINEX] = CL6REC.CL6OVPRC;
        CL0LW02.CLKPRCFF[CL0LWINX] = "O";
        KL0LM001.CLKPRCFF[CLXLINEX] = "O";
        call "IO2950" ("CS", SQLCA, CL6REC) {isNoRefresh = yes, isExternal = yes};
        return;
      else
        call "IO2950" ("CS", SQLCA, CL6REC) {isNoRefresh = yes, isExternal = yes};
        CL6REC.IV0PARTN = CL0LW02.IV0PARTN;
        CL6REC.IV0IVCID = CL0LW02.IV0IVCID;
        CL6REC.XGPCD = CL0LW02.XGPCD[CL0LWINX];
        CL6REC.SY1STNBR = CL0LW02.SY1STNBR[CL0LWINX];
        CL6REC.SY2CLRID = CL0LW02.SY2CLRID[CL0LWINX];
        CL6REC.XDMCD = CL0LW02.XDMCD[CL0LWINX];
        CL6REC.XQACD = CL0LW02.XQACD[CL0LWINX];
        CL6REC.XUMCD = CL0LW02.XUMCD[CL0LWINX];
        CL6REC.SY5SZID = -1;
        KL0LSCO();
        if (CL0LW01.CL0LWSWZ == "Y")
          CL0LW02.CLNGRPRC[CL0LWINX] = CL0LW01.CL0LWPCE;
          CL0LW02.CLNNTPRC[CL0LWINX] = CL0LW01.CL0LWPCE;
          KL0LM001.CLNGRPRC[CLXLINEX] = CL0LW01.CL0LWPCE;
          CL0LW02.CLKPRCFF[CL0LWINX] = "O";
          KL0LM001.CLKPRCFF[CLXLINEX] = "O";
          CL0LW02.CL0LMLVL[CL0LWINX] = "S";
          if (IV3REC.OP2PRCVF == "Y")
            CL0LW02.OP2PRCVF[CL0LWINX] = "Y";
            KL0LM001.CL0LMVPR[CLXLINEX] = "V";
            CL0LW02.CLNGRPRC[CL0LWINX] = 0;
            CL0LW02.CLNNTPRC[CL0LWINX] = 0;
            KL0LM001.CLNGRPRC[CLXLINEX] = 0;
          else
            CL0LW02.OP2PRCVF[CL0LWINX] = CL0LW01.CL0LWVAR;
            KL0LM001.CL0LMVPR[CLXLINEX] = "V";
          end
          return;
        end
      end
    end
  end

  if (KL0LM001.CLKPRCFF[CLXLINEX] == " " /* default price from code*/
   || KL0LM001.CLKPRCFF[CLXLINEX] == "I")
    CL0LW02.CLKPRCFF[CL0LWINX] = "I";
    KL0LM001.CLKPRCFF[CLXLINEX] = "I";
    CL0LW02.CLNGRPRC[CL0LWINX] = IV3REC.IV3GLNUP; /* and price*/
    CL0LW02.CLNNTPRC[CL0LWINX] = IV3REC.IV3NLNUP; /* and price*/
    if (CL0LW02.IVANBLFL == "Y")
      KL0LM001.CLNGRPRC[CLXLINEX] = IV3REC.IV3NLNUP;
    else
      KL0LM001.CLNGRPRC[CLXLINEX] = IV3REC.IV3GLNUP;
    end
    CL0LW02.OP2PRCVF[CL0LWINX] = IV3REC.OP2PRCVF;
  end



end // end KL0LSE5

// map 1 edit select code
Function KL0LSE6()
   /* *********************************/
   /* *     edit select code*/
   /* **/
   /* *********************************/

     /* note - cl0lwinx points to array entry*/
     /* kept in sync with clxlinex in cl0l120*/


     /* ********************************************************/
     /* cl0lw01.cl0lmsel has select code from either map 1 or 5*/
     /* all map action, 'set field defined', is done for 2 maps*/
     /* ********************************************************/


      /* ************************************************/
      /* validate code, then do more edits for each code*/
      /* ************************************************/

  if (CL0LW01.CL0LMSEL == "A"  /* select all*/
   || CL0LW01.CL0LMSEL == "C"  /* credit product*/
   || CL0LW01.CL0LMSEL == "D"  /* debit product*/
   || CL0LW01.CL0LMSEL == "S"  /* select product*/
   || CL0LW01.CL0LMSEL == "X"  /* delete product*/
   || CL0LW01.CL0LMSEL == "CA" /* credit all*/
   || CL0LW01.CL0LMSEL == "DA" /* debit all*/
   || CL0LW01.CL0LMSEL == "SA" /* select all*/
   || CL0LW01.CL0LMSEL == "RC" /* replicate all credits*/
   || CL0LW01.CL0LMSEL == "RD" /* replicate all debits*/
   || CL0LW01.CL0LMSEL == " ") /* no select code*/
     /* next sentence*/
  else
    converseLib.validationFailed(8); /* selection code is not valid*/
    CLXREC.CLXERRF = "Y";
    CL0LW01.CL0LWERR[CLXLINEX] = "Y";
    set KL0LM001.CL0LMSEL[CLXLINEX] cursor, modified, bold;
    set KL0LM005.CL0LMSEL[CLXLINEX] cursor, modified, bold;
    set KL0LM001.CLRCLMQ[CLXLINEX] modified;
    set KL0LM001.CLRRQTQ[CLXLINEX] modified;
    return;
  end


  if (CL0LW01.CL0LMSEL == " ") /* if blank entered,return*/
    CL0LW02.CL0LMSEL[CL0LWINX] = " ";
    set KL0LM001.CL0LMSEL[CLXLINEX] initialAttributes;
    set KL0LM005.CL0LMSEL[CLXLINEX] initialAttributes;
    return;
  end

  CL0LW01.CL0LWMOD[CLXLINEX] = "Y";

  if (CL0LW01.CL0LWINQ == "Y"
   && CL0LW01.CL0LMSEL != "S"
   && CL0LW01.CL0LMSEL != "A"
   && CL0LW01.CL0LMSEL != "SA")
    converseLib.validationFailed(8);
    CLXREC.CLXERRF = "Y";
    CL0LW01.CL0LWERR[CLXLINEX] = "Y";
    set KL0LM001.CL0LMSEL[CLXLINEX] cursor, modified, bold;
    return;
  end

  if (KL0LM001.SY1STNBR[CLXLINEX] == " "
   && KL0LM001.CL0LMSEL[CLXLINEX] != "CA"
   && KL0LM001.CL0LMSEL[CLXLINEX] != "DA"
   && KL0LM001.CL0LMSEL[CLXLINEX] != "RC"
   && KL0LM001.CL0LMSEL[CLXLINEX] != "RD"
   && KL0LM001.CL0LMSEL[CLXLINEX] != "SA")
    converseLib.validationFailed(372);
    CLXREC.CLXERRF = "Y";
    CL0LW01.CL0LWERR[CLXLINEX] = "Y";
    set KL0LM001.SY1STNBR[CLXLINEX] cursor;
    set KL0LM001.CL0LMSEL[CLXLINEX] modified, bold;
    set KL0LM005.SY1STNBR[CLXLINEX] cursor;
    set KL0LM005.CL0LMSEL[CLXLINEX] modified, bold;
    return;
  end

  if (KL0LM001.CL0LMSEL[CLXLINEX] == "C"
   || KL0LM001.CL0LMSEL[CLXLINEX] == "D")
    if (KL0LM001.CL0LMVPR[CLXLINEX] == "V")
      converseLib.validationFailed(413);
      CLXREC.CLXERRF = "Y";
      CL0LW01.CL0LWERR[CLXLINEX] = "Y";
      set KL0LM001.CL0LMSEL[CLXLINEX] cursor, modified, bold;
      set KL0LM005.CL0LMSEL[CLXLINEX] cursor, modified, bold;
      return;
    end
  end


      /* ***************************************/
      /* 'credit all' or 'debit all' only valid*/
      /* when products are pulled from invoice*/
      /* not when products come from claim*/
      /* ***************************************/

  if (CL0LW01.CL0LMSEL == "RC"
   || CL0LW01.CL0LMSEL == "RD")
    /* next sentence*/
  else
    if (CL0LW01.CL0LMSEL == "CA"
     || CL0LW01.CL0LMSEL == "DA")
      sysVar.arrayIndex = 1;
      while (sysVar.arrayIndex <= CLXREC.CLXLSTAX)
        if (CL0LW02.CLICRDFL[sysVar.arrayIndex] == "C"
         || CL0LW02.CLICRDFL[sysVar.arrayIndex] == "D"
         || CL0LW02.CLICRDFL[sysVar.arrayIndex] == "B")
          CLXREC.CLXERRF = "Y";
          CL0LW01.CL0LWERR[CLXLINEX] = "Y";
          converseLib.validationFailed(211);
          set KL0LM001.CL0LMSEL[CLXLINEX] cursor, modified, bold;
          set KL0LM005.CL0LMSEL[CLXLINEX] cursor, modified, bold;
          sysVar.arrayIndex = 9000;
        end
        sysVar.arrayIndex = sysVar.arrayIndex + 1;
      end
      if (CL0LW01.CL0LWERR[CLXLINEX] == "Y")
        return;
      end
    end
  end


      /* *****************************************************/
      /* 'credit all' or 'debit all' or 'replicate credit' or*/
      /* 'replicate debit' only valid on first line*/
      /* *****************************************************/

  if (CL0LW01.CL0LMSEL == "CA"
   || CL0LW01.CL0LMSEL == "DA"
   || CL0LW01.CL0LMSEL == "RC"
   || CL0LW01.CL0LMSEL == "RD")
    if (CL0LW01.CL0LWINX != 1) /* if not on first product*/
      converseLib.validationFailed(229); /* must be on line 1*/
      CLXREC.CLXERRF = "Y";
      CL0LW01.CL0LWERR[CLXLINEX] = "Y";
      set KL0LM001.CL0LMSEL[CLXLINEX] cursor, modified, bold;
      set KL0LM005.CL0LMSEL[CLXLINEX] cursor, modified, bold;
      return;
    end
  end

  if (CL0LW01.CL0LMSEL == "CA"
   || CL0LW01.CL0LMSEL == "DA"
   || CL0LW01.CL0LMSEL == "RC"
   || CL0LW01.CL0LMSEL == "RD"
   || CL0LW01.CL0LMSEL == "SA")
    if (CLXREC.CLXERRF == "Y"
     || converseVar.validationMsgNum != 0)
      set KL0LM001.CL0LMSEL[CLXLINEX] modified, bold;
      set KL0LM005.CL0LMSEL[CLXLINEX] modified;
      return;
    end
  end


      /* **********************************************/
      /* can only debit products added to the invoice,*/
      /* must credit products taken from the invoice*/
      /* **********************************************/

    /* dropped 6-18-87, per gary hattan*/

   /* IF CL0LW02.IV0IVCID NE 0        ; if claim has invoice,*/
    /* and cl0lw01.yitcd eq 'i'      ; for I.B.M.*/
    /* IF CL0LW02.CL0LWCHF(CL0LWINX) EQ 'A' ; adding product*/
      /* IF CL0LW01.CL0LMSEL EQ 'C';*/
        /* OR CL0LW01.CL0LMSEL EQ 'CA';*/
   /* MOVE 212 TO EZEMNO        ; can only db prod added to invc*/
        /* MOVE 'Y' TO CLXREC.CLXERRF;*/
      /* SET CL0LM001.CL0LMSEL(CLXLINEX) CURSOR,MODIFIED,BRIGHT;*/
      /* SET CL0LM005.CL0LMSEL(CLXLINEX) CURSOR,MODIFIED,BRIGHT;*/
        /* EZERTN;*/
      /* END ;*/
    /* ELSE                          ; changing product*/
      /* IF CL0LW01.CL0LMSEL EQ 'D';*/
        /* OR CL0LW01.CL0LMSEL EQ 'DA';*/
    /* MOVE 213 TO EZEMNO        ; can only cr prod from an invc*/
        /* MOVE 'Y' TO CLXREC.CLXERRF;*/
      /* SET CL0LM001.CL0LMSEL(CLXLINEX) CURSOR,MODIFIED,BRIGHT;*/
      /* SET CL0LM005.CL0LMSEL(CLXLINEX) CURSOR,MODIFIED,BRIGHT;*/
        /* EZERTN;*/
      /* END ;*/
    /* END ;*/
   /* END ;*/


      /* ****************************************************/
      /* changed or added products have limited select codes -*/
      /* cant select for detail once cr/db at prod level*/
      /* and cant chg cr to db, or db to cr,*/
      /* ****************************************************/

  if (CL0LW02.CL0LMLVL[CL0LWINX] == "P") /* at product level*/
    if (CL0LW01.CL0LMSEL == "A" /* select all*/
     || CL0LW01.CL0LMSEL == "S" /* select prod*/
     || CL0LW01.CL0LMSEL == "SA") /* select all*/
      converseLib.validationFailed(202); /* cant select detail*/
      CLXREC.CLXERRF = "Y";
      CL0LW01.CL0LWERR[CLXLINEX] = "Y";
      set KL0LM001.CL0LMSEL[CLXLINEX] cursor, modified, bold;
      set KL0LM005.CL0LMSEL[CLXLINEX] cursor, modified, bold;
      return;
    end

     /* ************************************************/
     /* line previously worked, cant chg db/cr to cr/db*/
     /* ************************************************/
    if (CL0LW02.CLICRDFL[CL0LWINX] == "C" /* previous c/d value*/
     || CL0LW02.CLICRDFL[CL0LWINX] == "D")
      if (CL0LW01.CL0LMSEL != "X"
       && CL0LW01.CL0LMSEL != "RC"
       && CL0LW01.CL0LMSEL != "RD")
        converseLib.validationFailed(214); /* can not chg db/cr except to cancel*/
        CLXREC.CLXERRF = "Y";
        CL0LW01.CL0LWERR[CLXLINEX] = "Y";
        set KL0LM001.CL0LMSEL[CLXLINEX] cursor, modified, bold;
        set KL0LM005.CL0LMSEL[CLXLINEX] cursor, modified, bold;
        return;
      end
    end
  else
    if (CL0LW02.CL0LMLVL[CL0LWINX] == "S") /* worked at size level*/
      if (CL0LW01.CL0LMSEL == "C"  /* credit prod*/
       || CL0LW01.CL0LMSEL == "D"  /* debit prod*/
       || CL0LW01.CL0LMSEL == "CA" /* credit all*/
       || CL0LW01.CL0LMSEL == "DA") /* debit all*/
        converseLib.validationFailed(203); /* must select detail*/
        CLXREC.CLXERRF = "Y";
        CL0LW01.CL0LWERR[CLXLINEX] = "Y";
        set KL0LM001.CL0LMSEL[CLXLINEX] cursor, modified, bold;
        set KL0LM005.CL0LMSEL[CLXLINEX] cursor, modified, bold;
        return;
      end
    else
       /* line not worked yet*/
    end
  end


     /* *****************************/
     /* add security check on delete*/
     /* *****************************/

  if (CL0LW01.CL0LMSEL == "X") /* if trying to delete*/
    if (COMMAREA.CADELFL == "N") /* must have valid security*/
      converseLib.validationFailed(16); /* user-id not auth to delete*/
      CLXREC.CLXERRF = "Y";
      CL0LW01.CL0LWERR[CLXLINEX] = "Y";
      set KL0LM001.CL0LMSEL[CLXLINEX] cursor, modified, bold;
      set KL0LM005.CL0LMSEL[CLXLINEX] cursor, modified, bold;
      return;
    end
  end


  set KL0LM001.CL0LMSEL[CLXLINEX] initialAttributes;
  set KL0LM005.CL0LMSEL[CLXLINEX] initialAttributes;

end // end KL0LSE6

// map 1 edit invoice nbr
Function KL0LSE7()
   /* ***************************/
   /* *     edit invoice number*/
   /* **/
   /* ***************************/


     /* used in cl0l120 & cl0l220, so use common*/
     /* field cl0lw01.cl0lwivc for both maps*/


     /* *******************************************/
     /* once an invoice is associated with a claim*/
     /* the claim must always have invoice(s)*/
     /* *******************************************/

  TA1REC.TA1LOCAT[2] = "CL0LSE7";
  if (CL0LW02.IV0IVCID != 0) /* if claim has 1 invoice,*/
    if (CL0LW01.CL0LWIVC == 0) /* and map was zeroed by user*/
      converseLib.validationFailed(207); /* invoice required on this claim*/
      CL0LW01.CL0LWIVC = CL0LW02.IV0IVCID; /* move back orig nbr*/
      CLXREC.CLXERRF = "Y";
      set KL0LM001.IV0IVCID cursor, modified, bold;
      set KL0LM005.IV0IVCID cursor, modified, bold;
      return;
    end
  end


     /* **************************************************/
     /* invoice must already be associated with the claim*/
     /* can not add invoices on this screen,*/
     /* use cl0f, add'l invoices/claim xref*/
     /* **************************************************/

  CLXREC.CLXORDIV = CL0LW01.CL0LWIVC; /* find partition number*/
  CLBREC.IV0IVCID = CL0LW01.CL0LWIVC;
  CLBREC.IV0PARTN = CLXREC.CLXPARTN;
  CLBREC.CLACLMNB = CLAREC.CLACLMNB;

  call "IO1180" ("S ", SQLCA, CLBREC) {isNoRefresh = yes, isExternal = yes}; /* read by ivc nbr*/

  if (SQLCA.VAGen_SQLCODE == 0)
    set KL0LM001.IV0IVCID initialAttributes;
    set KL0LM005.IV0IVCID initialAttributes;
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      converseLib.validationFailed(91); /* invoice is not attached to claim*/
      CLXREC.CLXERRF = "Y";
      set KL0LM001.IV0IVCID cursor, modified, bold;
      set KL0LM005.IV0IVCID cursor, modified, bold;
    else
      TA1REC.TA1DBASE = "DCLAIM";
      TA1REC.TA1TBLVU = "VCLIVX01";
      XPCL010(); /* abend*/
    end
  end



end // end KL0LSE7

// map 10 edit price from flag
Function KL0LSE8()
       /* * ******************************************** **/
     /* *                                                  **/
   /* *               keep in sync with cl0lse2              **/
     /* *                                                  **/
       /* * ******************************************** **/

    /* Maintenance History:*/
    /* 04-10-90 CHELLM Added XQACD and XUMCD to the product key*/
                    /* when selecting invoice price overrides.*/

   /* *************************************************************/


   /* GET CL0LSE2*/
   /* *********************************/
   /* *     edit price from flag*/
   /* **/
   /* *********************************/

     /* note - cl0lwinx = array pointer, kept in sync with*/
     /* clxlinex in cl0l320.*/


  TA1REC.TA1LOCAT[2] = "CL0LSE8";
  if (KL0LM010.CL0LMSEL[CLXLINEX] == "X")
    set KL0LM010.CLKPRCFF[CLXLINEX] initialAttributes;
    return;
  end

  CL0LW01.CL0LWMOD[CLXLINEX] = "Y";

  if (KL0LM010.CLKPRCFF[CLXLINEX] == "I") /* take price from invoice*/
    if (KL0LM010.IV0IVCID != 0 /* must have invoice for 'i'*/
     && CL0LW01.YITCD == "I")  /* I.B.M. invoice*/
      set KL0LM010.CLKPRCFF[CLXLINEX] initialAttributes;
    else
      converseLib.validationFailed(205); /* 'price from' not valid, no invoice*/
      set KL0LM010.CLKPRCFF[CLXLINEX] cursor, modified, bold;
      CL0LW01.CL0LWERR[CLXLINEX] = "Y";
      CLXREC.CLXERRF = "Y";
      return;
    end
  else
    if (KL0LM010.CLKPRCFF[CLXLINEX] == "E" /* user entered price*/
     || KL0LM010.CLKPRCFF[CLXLINEX] == "P") /* take price from product*/
      set KL0LM010.CLKPRCFF[CLXLINEX] initialAttributes;
    else
      if (KL0LM010.SY4IDDSC[CLXLINEX] == " " /* allow ' '*/
       && KL0LM010.CLKPRCFF[CLXLINEX] == " ")
        set KL0LM010.CLKPRCFF[CLXLINEX] initialAttributes;
      else
        converseLib.validationFailed(201); /* 'price from' not valid, 'i' 'p' or*/
                                   /* 'e'*/
        set KL0LM010.CLKPRCFF[CLXLINEX] cursor, modified, bold;
        CLXREC.CLXERRF = "Y";
        CL0LW01.CL0LWERR[CLXLINEX] = "Y";
        return;
      end
    end
  end


  if (KL0LM010.CLKPRCFF[CLXLINEX] == "E"
   && KL0LM010.CLNGRPRC[CLXLINEX] == 0)
    converseLib.validationFailed(217); /* price required*/
    CLXREC.CLXERRF = "Y";
    CL0LW01.CL0LWERR[CLXLINEX] = "Y";
    set KL0LM010.CLNGRPRC[CLXLINEX] cursor, modified, bold;
    set KL0LM010.CLKPRCFF[CLXLINEX] modified, bold;
    return;
  end


     /* *******************/
     /* price from invoice*/
     /* *******************/

  if (KL0LM010.CLKPRCFF[CLXLINEX] == "I")
    CL6REC.IV0PARTN = CL0LW02.IV0PARTN;
    CL6REC.IV0IVCID = CL0LW02.IV0IVCID;
    CL6REC.XGPCD = CLAREC.XGPCD;
    CL6REC.SY1STNBR = CL0LW02.SY1STNBR[CL0LWCAX];
    CL6REC.SY2CLRID = CL0LW02.SY2CLRID[CL0LWCAX];
    CL6REC.XDMCD = CL0LW02.XDMCD[CL0LWCAX];
    CL6REC.XQACD = CL0LW02.XQACD[CL0LWCAX];
    CL6REC.XUMCD = CL0LW02.XUMCD[CL0LWCAX];
    CL6REC.SY5SZID = CL0LW03.SY5SZID[CL0LWINX];

    KL0LSSO(); /* select set price override*/

    if (SQLCA.VAGen_SQLCODE == 0
     && CL6REC.CLHMEMNB > 0)
      CL0LW03.CLNGRPRC[CL0LWINX] = CL6REC.CL6OVPRC;
      CL0LW03.CLNNTPRC[CL0LWINX] = CL6REC.CL6OVPRC;
      KL0LM010.CLNGRPRC[CLXLINEX] = CL6REC.CL6OVPRC;
      KL0LM010.CLKPRCFF[CLXLINEX] = "O";
      CL0LW03.CLKPRCFF[CL0LWINX] = "O";

      call "IO2950" ("CS", SQLCA, CL6REC) {isNoRefresh = yes, isExternal = yes};

    else
      CL6REC.IV0PARTN = CL0LW02.IV0PARTN;
      CL6REC.IV0IVCID = CL0LW02.IV0IVCID;
      CL6REC.XGPCD = CLAREC.XGPCD;
      CL6REC.SY1STNBR = CL0LW02.SY1STNBR[CL0LWCAX];
      CL6REC.SY2CLRID = CL0LW02.SY2CLRID[CL0LWCAX];
      CL6REC.XDMCD = CL0LW02.XDMCD[CL0LWCAX];
      CL6REC.XQACD = CL0LW02.XQACD[CL0LWCAX];
      CL6REC.XUMCD = CL0LW02.XUMCD[CL0LWCAX];
      CL6REC.SY5SZID = 0;

      call "IO2950" ("CS", SQLCA, CL6REC) {isNoRefresh = yes, isExternal = yes};

      KL0LSSO(); /* select set price override*/

      if (SQLCA.VAGen_SQLCODE == 0
       && CL6REC.CLHMEMNB > 0)
        CL0LW03.CLNGRPRC[CL0LWINX] = CL6REC.CL6OVPRC;
        CL0LW03.CLNNTPRC[CL0LWINX] = CL6REC.CL6OVPRC;
        KL0LM010.CLNGRPRC[CLXLINEX] = CL6REC.CL6OVPRC;
        KL0LM010.CLKPRCFF[CLXLINEX] = "O";
        CL0LW03.CLKPRCFF[CL0LWINX] = "O";

        call "IO2950" ("CS", SQLCA, CL6REC) {isNoRefresh = yes, isExternal = yes};

      else

        call "IO2950" ("CS", SQLCA, CL6REC) {isNoRefresh = yes, isExternal = yes};

        IV4REC.IV0PARTN = CL0LW02.IV0PARTN;
        IV4REC.IV0IVCID = CL0LW02.IV0IVCID;
        IV4REC.OP2LNINB = CL0LW02.OP2LNINB[CL0LWCAX];
        IV4REC.SY5SZID = CL0LW03.SY5SZID[CL0LWINX];

        call "IO1130" ("S ", SQLCA, IV4REC) {isNoRefresh = yes, isExternal = yes}; /* read*/

        if (SQLCA.VAGen_SQLCODE == 0)
          CL0LW03.CLNGRPRC[CL0LWINX] = IV4REC.IV4GUP;
          CL0LW03.CLNNTPRC[CL0LWINX] = IV4REC.IV4NUP;
          if (CL0LW02.IVANBLFL == "Y")
            KL0LM010.CLNGRPRC[CLXLINEX] = CL0LW03.CLNNTPRC[CL0LWINX];
          else
            KL0LM010.CLNGRPRC[CLXLINEX] = CL0LW03.CLNGRPRC[CL0LWINX];
          end
        else
          converseLib.validationFailed(205); /* 'price from' not valid, no invoice*/
          set KL0LM010.CLKPRCFF[CLXLINEX] cursor, modified, bold;
          CLXREC.CLXERRF = "Y";
          CL0LW01.CL0LWERR[CLXLINEX] = "Y";
          CL0LW03.CLNGRPRC[CL0LWINX] = 0;
          CL0LW03.CLNNTPRC[CL0LWINX] = 0;
        end
      end
    end
    return;
  end


     /* ***********************/
     /* use product size price*/
     /* ***********************/

  if (KL0LM010.CLKPRCFF[CLXLINEX] == "P")
    CL0LW03.CLNGRPRC[CL0LWINX] = 0; /* init to zero*/
    CL0LW03.CLNNTPRC[CL0LWINX] = 0; /* init to zero*/
    KL0LSPS(); /* get price size default*/

    if (CL0LW03.CLNGRPRC[CL0LWINX] == 0
     && CL0LW03.CLNNTPRC[CL0LWINX] == 0)
      converseLib.validationFailed(225); /* warn-price not found for size*/
      set KL0LM010.SY4IDDSC[CLXLINEX] cursor, bold;
    end
  end



end // end KL0LSE8

// map 10 edit product size
Function KL0LSE9()
   /* GET OP0HSGE*/
         /* ******************************************************/
         /* this sgrp edits the size entered*/

         /* size edits:  1. edit entered map size for format*/
                      /* 2. check size division codes*/
                      /* 3. see if size division match allowable*/
                          /* division codes from ordr typ table.*/
                      /* 4. check size fringe/gut indicators*/
         /* ******************************************************/

    /* Maintenance History:*/
    /* 04-10-90 CHELLM Added XQACD and XUMCD to the product key*/
                    /* when selecting invoice price overrides.*/

   /* *************************************************************/


     /* if user entered 'x' to cancel line, then skip edit*/

  TA1REC.TA1LOCAT[2] = "CL0LSE9";
  if (KL0LM010.CL0LMSEL[CLXLINEX] == "X")
    set KL0LM010.SY4IDDSC[CLXLINEX] initialAttributes; /* reset attributes*/
    return;
  end

  CL0LW01.CL0LWMOD[CLXLINEX] = "Y";

     /* set new array and map indexes*/

  if (CL0LW01.CL0LWCHK[CLXLINEX] != "Y")
    if (CL0LW01.CL0LWINX >= CLXREC.CLXCURSZ)
      CLXREC.CLXMAPMX = CLXREC.CLXLINEX;
      CLXREC.CLXCURSZ = CL0LW01.CL0LWINX + 1;
      CLXREC.CLXLSTSZ = CL0LW01.CL0LWINX + 1;
    end
  end

  CL0LW03.CL0LWCHF[CL0LWINX] = "A"; /* mark as added*/
  CL0LW01.CL0LWCHK[CLXLINEX] = "Y";
  CL0LW03.CL0LWDLT[CL0LWINX] = " ";

  CL0LW03.SY4IDDSC[CL0LWINX] = KL0LM010.SY4IDDSC[CLXLINEX]; /* size desc*/

     /* without an order type on the claim, cant edit sizes*/

  if (CL0LW01.CL0LWXOT == 0)
    converseLib.validationFailed(216); /* cant enter size without o/t on clm*/
    CLXREC.CLXERRF = "Y";
    CL0LW01.CL0LWERR[CLXLINEX] = "Y";
    set KL0LM010.SY4IDDSC[CLXLINEX] cursor, modified, bold;
    return;
  end


     /* now start edits on the size -*/
     /* as these edits progress, you can only*/
     /* go to the next edit if the previous one was good.*/

    /* size edit number 1*/
       /* based on the size input format, verify size*/

   /* ***************************/
   /* edit alpha size for valid*/
   /* ***************************/
   /* GET OP0HSG6*/
  sysVar.arrayIndex = 1;

  while (sysVar.arrayIndex <= 40)
    if (KL0LM010.SY4IDDSC[CLXLINEX] == SY4REC.SY4IDDSC[sysVar.arrayIndex])
      CL0LW01.CL0LWSID = sysVar.arrayIndex;
      sysVar.arrayIndex = 99;
    else
      sysVar.arrayIndex = sysVar.arrayIndex + 1;
    end
  end

  if (sysVar.arrayIndex != 99) /* if not found*/
    set KL0LM010.SY4IDDSC[CLXLINEX] cursor, modified, bold;
    CLXREC.CLXERRF = "Y";
    CL0LW01.CL0LWERR[CLXLINEX] = "Y";
    converseLib.validationFailed(219); /* alpha size not valid*/
    return;
  end


   /* ******************************/
   /* size edit number 2*/
        /* check size division code*/
   /* ******************************/

  if (SYCREC.XDVCD[CL0LWSID] == " ")
    CLXREC.CLXERRF = "Y";
    CL0LW01.CL0LWERR[CLXLINEX] = "Y";
    converseLib.validationFailed(220); /* size not valid for division code*/
    set KL0LM010.SY4IDDSC[CLXLINEX] cursor, modified, bold;
    return;
  end


    /* *************************************************/
    /* edit check number 3*/
      /* match style div to allowed divs for order type*/
    /* *************************************************/

  if (SYCREC.XDVCD[CL0LWSID] == XOTTBL.XDVCD1[CL0LWXOT])
     /* next sentence*/
  else
    if (SYCREC.XDVCD[CL0LWSID] == XOTTBL.XDVCD2[CL0LWXOT])
       /* next sentence*/
    else
      if (SYCREC.XDVCD[CL0LWSID] == XOTTBL.XDVCD3[CL0LWXOT])
         /* next sentence*/
      else
        CLXREC.CLXERRF = "Y";
        CL0LW01.CL0LWERR[CLXLINEX] = "Y";
        converseLib.validationFailed(220); /* size not valid for div code*/
        set KL0LM010.SY4IDDSC[CLXLINEX] cursor, modified, bold;
        return;
      end
    end
  end


   /* ***********************************/
   /* edit check number 4*/
     /* check size fringe gut indicators*/
   /* ***********************************/

  if (XOTTBL.XOTXTRAS[CL0LWXOT] == "Y") /* if order type allows extras*/
     /* next sentence*/
  else
    if (SYCREC.SY3FRGUT[CL0LWSID] == "X") /* if size is extra*/
      CLXREC.CLXERRF = "Y";
      CL0LW01.CL0LWERR[CLXLINEX] = "Y";
      converseLib.validationFailed(221); /* size not valid for fringe/gut*/
      set KL0LM010.SY4IDDSC[CLXLINEX] cursor, modified, bold;
      return;
    end
  end


     /* *************/
     /* size is o.k.*/
     /* *************/

  CL0LW03.SY5SZID[CL0LWINX] = CL0LW01.CL0LWSID; /* hold size i.d.*/
  CL0LW03.SY4IDDSC[CL0LWINX] = SY4REC.SY4IDDSC[CL0LWSID];
                                   /* size desc*/
  CL0LW01.CL0LWSHP[CLXLINEX] = "Y";

  set KL0LM010.SY4IDDSC[CLXLINEX] initialAttributes; /* reset attributes*/

     /* *******************************************/
     /* if price from flag is blank, default value*/
     /* *******************************************/

  if (KL0LM010.IV0IVCID == 0 /* if no invoice*/
   || CL0LW01.YITCD != "I")  /* or ivc not on I.B.M.*/
    if (KL0LM010.CLKPRCFF[CLXLINEX] == " "
     || KL0LM010.CLKPRCFF[CLXLINEX] == "P")
      KL0LM010.CLKPRCFF[CLXLINEX] = "P"; /* deflt to product prce*/
      CL0LW03.CLKPRCFF[CL0LWINX] = "P";
      KL0LSPS(); /* get price for new size*/
    end

    return;
  end


   /* GET CL0LSE5*/
     /* **************************************************/
     /* claim has I.B.M. invoice, default price from invc*/
     /* **************************************************/

  IV4REC.IV0PARTN = CL0LW02.IV0PARTN;
  IV4REC.IV0IVCID = CL0LW02.IV0IVCID;

  IV4REC.OP2LNINB = CL0LW02.OP2LNINB[CL0LWCAX];
  IV4REC.SY5SZID = CL0LW03.SY5SZID[CL0LWINX];

  call "IO1130" ("S ", SQLCA, IV4REC) {isNoRefresh = yes, isExternal = yes}; /* get the record*/

  if (SQLCA.VAGen_SQLCODE == 0)
     /* shipped qty*/
    CL0LW03.IV4SHPQ[CL0LWINX] = IV4REC.IV4SHPQ; /* to w/s*/
    KL0LM010.IV4SHPQ[CLXLINEX] = IV4REC.IV4SHPQ; /* to map*/
     /* invoice price*/
    CL0LW03.IV4GUP[CL0LWINX] = IV4REC.IV4GUP;
    KL0LM010.IV4GUP[CLXLINEX] = IV4REC.IV4GUP;
    set KL0LM010.SY4IDDSC[CLXLINEX] initialAttributes;
  else
    converseLib.validationFailed(208); /* warning - size is not on the invoice*/
    set KL0LM010.SY4IDDSC[CLXLINEX] bold;
    set KL0LM010.CL0LMSEL[CLXLINEX] cursor, modified, bold;
    CL0LW01.CL0LWERR[CLXLINEX] = "Y";
    CLXREC.CLXERRF = "Y";
     /* default price from flag to product value*/
    if (KL0LM010.CLKPRCFF[CLXLINEX] == " "
     || KL0LM010.CLKPRCFF[CLXLINEX] == "P")
      KL0LM010.CLKPRCFF[CLXLINEX] = "P"; /* deflt to product prce*/
      CL0LW03.CLKPRCFF[CL0LWINX] = "P";
      KL0LSPS(); /* get price for new size*/
    end
    return;
  end


  if (KL0LM010.CLKPRCFF[CLXLINEX] == " " /* default price from code*/
   || KL0LM010.CLKPRCFF[CLXLINEX] == "I")
    if (CL0LW01.CL0LWPFL == "Y")
      CL6REC.IV0PARTN = CL0LW02.IV0PARTN;
      CL6REC.IV0IVCID = CL0LW02.IV0IVCID;
      CL6REC.XGPCD = KL0LM010.XGPCD;
      CL6REC.SY1STNBR = KL0LM010.SY1STNBR;
      CL6REC.SY2CLRID = KL0LM010.SY2CLRID;
      CL6REC.XDMCD = KL0LM010.XDMCD;
      CL6REC.XQACD = KL0LM010.XQACD;
      CL6REC.XUMCD = KL0LM010.XUMCD;
      CL6REC.SY5SZID = CL0LW01.CL0LWSID;

      KL0LSSO(); /* check for price overrride*/

      if (CLXREC.CLXERRF == "Y")
        return;
      end
      if (SQLCA.VAGen_SQLCODE == 0
       && CL6REC.CLHMEMNB > 0)
        CL0LW03.CLNGRPRC[CL0LWINX] = CL6REC.CL6OVPRC;
        CL0LW03.CLNNTPRC[CL0LWINX] = CL6REC.CL6OVPRC;
        CL0LW03.CLKPRCFF[CL0LWINX] = "O";
        KL0LM010.CLKPRCFF[CLXLINEX] = "O";

        call "IO2950" ("CS", SQLCA, CL6REC) {isNoRefresh = yes, isExternal = yes};

      else
        CL6REC.IV0PARTN = CL0LW02.IV0PARTN;
        CL6REC.IV0IVCID = CL0LW02.IV0IVCID;
        CL6REC.XGPCD = KL0LM010.XGPCD;
        CL6REC.SY1STNBR = KL0LM010.SY1STNBR;
        CL6REC.SY2CLRID = KL0LM010.SY2CLRID;
        CL6REC.XDMCD = KL0LM010.XDMCD;
        CL6REC.XQACD = KL0LM010.XQACD;
        CL6REC.XUMCD = KL0LM010.XUMCD;
        CL6REC.SY5SZID = 0;

        call "IO2950" ("CS", SQLCA, CL6REC) {isNoRefresh = yes, isExternal = yes};

        KL0LSSO(); /* check for price overrride*/

        if (CLXREC.CLXERRF == "Y")
          return;
        end

        if (SQLCA.VAGen_SQLCODE == 0
         && CL6REC.CLHMEMNB > 0)
          CL0LW03.CLNGRPRC[CL0LWINX] = CL6REC.CL6OVPRC;
          CL0LW03.CLNNTPRC[CL0LWINX] = CL6REC.CL6OVPRC;
          CL0LW03.CLKPRCFF[CL0LWINX] = "O";
          KL0LM010.CLKPRCFF[CLXLINEX] = "O";
        end

        call "IO2950" ("CS", SQLCA, CL6REC) {isNoRefresh = yes, isExternal = yes};

      end
    end
  end


  if (KL0LM010.CLKPRCFF[CLXLINEX] == " " /* default price from code*/
   || KL0LM010.CLKPRCFF[CLXLINEX] == "I")
    CL0LW03.CLKPRCFF[CL0LWINX] = "I";
    KL0LM010.CLKPRCFF[CLXLINEX] = "I";
    CL0LW03.CLNGRPRC[CL0LWINX] = IV4REC.IV4GUP; /* and price*/
    CL0LW03.CLNNTPRC[CL0LWINX] = IV4REC.IV4NUP; /* and price*/
    if (CL0LW02.IVANBLFL == "Y") /* net bill flag*/
      KL0LM010.CLNGRPRC[CLXLINEX] = IV4REC.IV4NUP;
    else
      KL0LM010.CLNGRPRC[CLXLINEX] = IV4REC.IV4GUP;
    end
  end



end // end KL0LSE9

// map 10 edit select code
Function KL0LSEA()
       /* * ***********************************************/
     /* *                                                  **/
   /* *             keep in sync with cl0lse6                **/
     /* *                                                  **/
       /* * ***********************************************/

   /* GET CL0LSE6*/
     /* ************************/
     /* *   edit select code*/
     /* *   map 10, detail*/
     /* ************************/

     /* note - cl0lwinx points to array entry*/
     /* kept in sync with clxlinex in cl0l320*/


      /* ************************************************/
      /* validate code, then do more edits for each code*/
      /* ************************************************/

  if (KL0LM010.CL0LMSEL[CLXLINEX] == "C"  /* credit product*/
   || KL0LM010.CL0LMSEL[CLXLINEX] == "D"  /* debit product*/
   || KL0LM010.CL0LMSEL[CLXLINEX] == "X"  /* delete product*/
   || KL0LM010.CL0LMSEL[CLXLINEX] == "CA" /* credit all*/
   || KL0LM010.CL0LMSEL[CLXLINEX] == "DA" /* debit all*/
   || KL0LM010.CL0LMSEL[CLXLINEX] == "RC" /* replicate all credits*/
   || KL0LM010.CL0LMSEL[CLXLINEX] == "RD" /* replicate all debits*/
   || KL0LM010.CL0LMSEL[CLXLINEX] == " ") /* no select code*/
     /* next sentence*/
  else
    converseLib.validationFailed(8); /* selection code is not valid*/
    CLXREC.CLXERRF = "Y";
    CL0LW01.CL0LWERR[CLXLINEX] = "Y";
    set KL0LM010.CL0LMSEL[CLXLINEX] cursor, modified, bold;
    set KL0LM010.CLRCLMQ[CLXLINEX] modified;
    set KL0LM010.CLRRQTQ[CLXLINEX] modified;
    return;
  end


  if (KL0LM010.CL0LMSEL[CLXLINEX] == " ") /* if blank entered,return*/
    set KL0LM010.CL0LMSEL[CLXLINEX] initialAttributes;
    return;
  end

  CL0LW01.CL0LWMOD[CLXLINEX] = "Y";

  if (CL0LW01.CL0LWINQ == "Y")
    converseLib.validationFailed(8);
    CLXREC.CLXERRF = "Y";
    CL0LW01.CL0LWERR[CLXLINEX] = "Y";
    set KL0LM010.CL0LMSEL[CLXLINEX] cursor, modified, bold;
    return;
  end

      /* ***************************************/
      /* 'credit all' or 'debit all' only valid*/
      /* when entered on line 1*/
      /* ***************************************/

  if (KL0LM010.CL0LMSEL[CLXLINEX] == "CA"
   || KL0LM010.CL0LMSEL[CLXLINEX] == "DA"
   || KL0LM010.CL0LMSEL[CLXLINEX] == "RC"
   || KL0LM010.CL0LMSEL[CLXLINEX] == "RD")
    if (CL0LW01.CL0LWINX != 1)
      converseLib.validationFailed(229);
      CLXREC.CLXERRF = "Y";
      CL0LW01.CL0LWERR[CLXLINEX] = "Y";
      set KL0LM010.CL0LMSEL[CLXLINEX] cursor, modified, bold;
      return;
    else

          /* ***************************************/
          /* 'credit all' or 'debit all' only valid*/
          /* when products are pulled from invoice*/
          /* not when products come from claim*/
          /* ***************************************/

      if (KL0LM010.CL0LMSEL[CLXLINEX] == "RC"
       || KL0LM010.CL0LMSEL[CLXLINEX] == "RD")
        /* next sentence*/
      else
        sysVar.arrayIndex = 1;
        while (sysVar.arrayIndex <= CLXREC.CLXLSTSZ)
          if (CL0LW03.CLICRDFL[sysVar.arrayIndex] == "C"
           || CL0LW03.CLICRDFL[sysVar.arrayIndex] == "D")
            converseLib.validationFailed(211); /* some prod or sizes already db/cr*/
            CLXREC.CLXERRF = "Y";
            CL0LW01.CL0LWERR[CLXLINEX] = "Y";
            set KL0LM010.CL0LMSEL[CLXLINEX] cursor, modified, bold;
            sysVar.arrayIndex = 9000;
          end
          sysVar.arrayIndex = sysVar.arrayIndex + 1;
        end
      end
      if (CL0LW01.CL0LWERR[CLXLINEX] == "Y")
        return;
      end
    end
  end

  if (KL0LM010.CL0LMSEL[CLXLINEX] == "CA"
   || KL0LM010.CL0LMSEL[CLXLINEX] == "DA"
   || KL0LM010.CL0LMSEL[CLXLINEX] == "RC"
   || KL0LM010.CL0LMSEL[CLXLINEX] == "RD")
    if (CLXREC.CLXERRF == "Y"
     || converseVar.validationMsgNum != 0)
      set KL0LM010.CL0LMSEL[CLXLINEX] modified;
      return;
    end
  end

      /* **********************************************/
      /* can only debit products added to the invoice,*/
      /* must credit products taken from the invoice*/
      /* **********************************************/

      /* code dropped 6-18-87, per gary hattan*/

   /* IF CL0LW02.IV0IVCID NE 0        ; if claim has invoice,*/
    /* AND CL0LW01.YITCD EQ 'I'      ; for I.B.M.*/
    /* IF CL0LW02.CL0LWCHF(CL0LWCAX) EQ 'A' ; adding product*/
      /* IF CL0LM010.CL0LMSEL(CLXLINEX) EQ 'C';*/
        /* OR CL0LM010.CL0LMSEL(CLXLINEX) EQ 'CA';*/
   /* MOVE 212 TO EZEMNO        ; can only db prod added to invc*/
        /* MOVE 'Y' TO CLXREC.CLXERRF;*/
      /* SET CL0LM010.CL0LMSEL(CLXLINEX) CURSOR,MODIFIED,BRIGHT;*/
        /* EZERTN;*/
      /* END ;*/
    /* ELSE                          ; changing product*/
      /* IF CL0LM010.CL0LMSEL(CLXLINEX) EQ 'D';*/
        /* OR CL0LM010.CL0LMSEL(CLXLINEX) EQ 'DA';*/
   /* MOVE 213 TO EZEMNO        ; can only cr prod from an invc*/
        /* MOVE 'Y' TO CLXREC.CLXERRF;*/
      /* SET CL0LM010.CL0LMSEL(CLXLINEX) CURSOR,MODIFIED,BRIGHT;*/
        /* EZERTN;*/
      /* END ;*/
    /* END ;*/
   /* END ;*/


     /* ****************************************************/
     /* changed products have limited select codes -*/
     /* cant chg cr to db, or db to cr,*/
     /* and cant select for detail once cr/db at prod level*/
     /* ****************************************************/

  if (CL0LW03.CLICRDFL[CL0LWINX] == "C" /* previous c/d value*/
   || CL0LW03.CLICRDFL[CL0LWINX] == "D")
    if (KL0LM010.CL0LMSEL[CLXLINEX] != "X"
     && KL0LM010.CL0LMSEL[CLXLINEX] != "RC"
     && KL0LM010.CL0LMSEL[CLXLINEX] != "RD")
      converseLib.validationFailed(214); /* can not chg db/cr except to cancel*/
      CLXREC.CLXERRF = "Y";
      CL0LW01.CL0LWERR[CLXLINEX] = "Y";
      set KL0LM010.CL0LMSEL[CLXLINEX] cursor, modified, bold;
      return;
    end
  end


     /* *****************************/
     /* add security check on delete*/
     /* *****************************/

  if (KL0LM010.CL0LMSEL[CLXLINEX] == "X") /* if user trying to delete*/
    if (COMMAREA.CADELFL == "N") /* must have valid security*/
      converseLib.validationFailed(16); /* user-id not auth to delete*/
      CLXREC.CLXERRF = "Y";
      CL0LW01.CL0LWERR[CLXLINEX] = "Y";
      set KL0LM010.CL0LMSEL[CLXLINEX] cursor, modified, bold;
      return;
    end
  end


      /* ********************************************/
      /* select code is valid, now move to the array*/
        /* if 'c' or 'd', move to array c/d flag*/
        /* if 'x', move to w/s array select*/
      /* ********************************************/

  set KL0LM010.CL0LMSEL[CLXLINEX] initialAttributes;
  CL0LW02.CL0LMSEL[CL0LWCAX] = " ";


end // end KL0LSEA

// move claim info to 3 map hdrs
Function KL0LSI1()
   /* ********************************************/
     /* move data from clarec, clwrec, and tables*/
   /* ********************************************/

  KL0LM001.CLACLMNB = CLAREC.CLACLMNB; /* claim number*/
  KL0LM005.CLACLMNB = CLAREC.CLACLMNB;
  KL0LM010.CLACLMNB = CLAREC.CLACLMNB;

  KL0LM001.XGPCD = CLAREC.XGPCD; /* general product class*/
  KL0LM005.XGPCD = CLAREC.XGPCD;
  KL0LM010.XGPCD = CLAREC.XGPCD;

  KL0LM001.KUCCOID = CLAREC.KUCCOID; /* company number*/
  KL0LM005.KUCCOID = CLAREC.KUCCOID;
  KL0LM010.KUCCOID = CLAREC.KUCCOID;

  KL0LM001.KUMSTRID = CLAREC.KUMSTRID; /* store id*/
  KL0LM005.KUMSTRID = CLAREC.KUMSTRID;
  KL0LM010.KUMSTRID = CLAREC.KUMSTRID;

  KL0LM001.XNXCD = CLAREC.XNXCD; /* customer dept code*/
  KL0LM005.XNXCD = CLAREC.XNXCD;
  KL0LM010.XNXCD = CLAREC.XNXCD;

  KL0LM001.KUCCONM = CLWREC.KUCCONM; /* customer company name*/
  KL0LM005.KUCCONM = CLWREC.KUCCONM;
  KL0LM010.KUCCONM = CLWREC.KUCCONM;

  KL0LM001.CLACTCNM = CLAREC.CLACTCNM; /* customer contact name*/
  KL0LM005.CLACTCNM = CLAREC.CLACTCNM;
  KL0LM010.CLACTCNM = CLAREC.CLACTCNM;

  KL0LM001.OP1CUPO = CLAREC.OP1CUPO; /* customer purchase order*/
  KL0LM005.OP1CUPO = CLAREC.OP1CUPO;
  KL0LM010.OP1CUPO = CLAREC.OP1CUPO;

  KL0LM001.SP1ID = CLAREC.SP1ID; /* sales program*/
  KL0LM005.SP1ID = CLAREC.SP1ID;

  KL0LM001.XOBCD = CLAREC.XOBCD; /* order type*/
  KL0LM005.XOBCD = CLAREC.XOBCD;

  KL0LM001.XOCCD = CLAREC.XOCCD; /* order class*/
  KL0LM005.XOCCD = CLAREC.XOCCD;


    /* **********************************/
    /* move table descriptions to map(s)*/
    /* **********************************/

  if (CLAREC.XGPCD in XGPTBL.XGPCD) /* g.p.c.*/
    KL0LM001.XGPABRV = XGPTBL.XGPABRV[sysVar.arrayIndex];
    KL0LM005.XGPABRV = XGPTBL.XGPABRV[sysVar.arrayIndex];
    KL0LM010.XGPABRV = XGPTBL.XGPABRV[sysVar.arrayIndex];
  end

  if (CLAREC.XOBCD in XOBTBL.XOBCD) /* order type*/
    KL0LM001.XOBABRV = XOBTBL.XOBABRV[sysVar.arrayIndex];
    KL0LM005.XOBABRV = XOBTBL.XOBABRV[sysVar.arrayIndex];
  end

  if (CLAREC.XOCCD in XOCTBL.XOCCD) /* order class*/
    KL0LM001.XOCABRV = XOCTBL.XOCABRV[sysVar.arrayIndex];
    KL0LM005.XOCABRV = XOCTBL.XOCABRV[sysVar.arrayIndex];
  end



end // end KL0LSI1

// decide to force inquiry mode
Function KL0LSI2()
     /* *******************/
     /* set inq flag to no*/
     /* *******************/

  TA1REC.TA1LOCAT[2] = "CL0LSI2";
  CL0LW01.CL0LWINQ = "N"; /* init to inquiry = no*/


     /* *********************************/
     /* if claim menu option was inquiry*/
     /* *********************************/

  if (CLWREC.CLWACTIV == "I") /* if menu option selected inquiry*/
    CL0LW01.CL0LWINQ = "Y"; /* force inquiry mode*/
    return;
  end


     /* *************************************************/
     /* if claim menu option was add or change, continue*/
     /* *************************************************/


     /* *************************/
     /* check goal menu security*/
     /* *************************/

  if (COMMAREA.CAADDFL == "Y" /* add-sales,traffic,credit,co-op*/
   || COMMAREA.CACHGFL == "Y") /* chg-sales,traffic,credit,co-op*/
     /* o.k. to add or change*/
  else
    CL0LW01.CL0LWINQ = "Y"; /* force to inquiry mode*/
    converseLib.validationFailed(29); /* chg to inq due to security*/
    return;
  end


     /* ********************************/
     /* check claim status allows input*/
     /* ********************************/

  if (YCSTBL.YCSAINPF[CLXYCSX] == "N") /* if claim status does not*/
    CL0LW01.CL0LWINQ = "Y"; /* allow input, force inquiry mode*/
    converseLib.validationFailed(26); /* chg to inq due to clm status*/
    return;
  end


     /* ************************************/
     /* if claim & seq nbr has been written*/
     /* as a memo, then force inquiry*/
     /* ************************************/


  CLHREC.CLACLMNB = CLAREC.CLACLMNB; /* current claim nbr*/
  CLHREC.CLHSEQNB = CL0LW01.CLACSQNB; /* current seq nbr (= '01')*/

  sysVar.arrayIndex = 0; /* repeat i/o*/
  CL0LW01.CL0LWSQC = -911; /* check for data base deadlock*/

  while (CL0LW01.CL0LWSQC == -911)
    call "IO1290" ("SA", SQLCA, CLHREC) {isNoRefresh = yes, isExternal = yes}; /* inquiry to memo table*/
    CL0LW01.CL0LWSQC = SQLCA.VAGen_SQLCODE;

    if (SQLCA.VAGen_SQLCODE == 0) /* if memo record with memo nbr*/
      if (CLHREC.CLHMEMNB != 0)
        CL0LW01.CL0LWINQ = "Y"; /* force inquiry*/
        converseLib.validationFailed(127); /* chg to inq due to memo status*/
      end
    else
      if (SQLCA.VAGen_SQLCODE == 100)
         /* memo not found, so can't force inquiry*/
      else
        if (SQLCA.VAGen_SQLCODE == -911 /* data base deadlock*/
         && sysVar.arrayIndex < 5)      /* try again, 4 times*/
          sysVar.arrayIndex = sysVar.arrayIndex + 1;
          KL0LS1S(); /* wait 1 second*/
        else
          TA1REC.TA1DBASE = "DCLAIM";
          TA1REC.TA1TBLVU = "VCLMEM01";
          XPCL010(); /* abort cl0l*/
        end
      end
    end
  end



end // end KL0LSI2

// bld ary 4 ivc, frm prod on ivc
Function KL0LSP4()
     /* *********************************************************/
     /* clarec.cladjind shows we do not have products already*/
     /* associated with the claim.  since there was at least one*/
     /* invoice/claim xref record, store the products*/
     /* from the invoice, using the invoice*/
     /* as shown on the map.*/
     /* *********************************************************/
    /* Maintenance History:*/
    /* 04-10-90 CHELLM Added XQACD and XUMCD to the product key*/
                    /* when selecting invoice price overrides.*/
    /* 03-13-92 sgorga DB2 changes.  Added xbk-bk-sesn-ck and*/
    /* op-bk-yr as fields to be moved from IV3REC to CL0LW02.*/
    /* 04-13-92 twatso DB2 changes.  Added op-bk-mo with yr code*/
     /* *********************************************************/

  TA1REC.TA1LOCAT[2] = "CL0LSP4";
  IV3REC.IV0PARTN = CL0LW02.IV0PARTN;
  IV3REC.IV0IVCID = CL0LW02.IV0IVCID;
  IV3REC.SY1STNBR = "******";
  IV3REC.SY2CLRID = "***";
  IV3REC.XDMCD = "**";
  IV3REC.XLCCD = "**";
  IV3REC.XQACD = "**";

  IV3REC.OP2LNINB = -1; /* get all line item numbers*/

  call "IO1100" ("S2", SQLCA, IV3REC) {isNoRefresh = yes, isExternal = yes}; /* select set for invc*/

  if (SQLCA.VAGen_SQLCODE == 0) /* have set open*/
    call "IO1100" ("N2", SQLCA, IV3REC) {isNoRefresh = yes, isExternal = yes}; /* first read*/
     /* note - ezesqcod is now for fetch, not set*/
    if (SQLCA.VAGen_SQLCODE == 0) /* process data below*/
       /* next sentence*/
    else
      if (SQLCA.VAGen_SQLCODE == 100)
        call "IO1100" ("C2", SQLCA, IV3REC) {isNoRefresh = yes, isExternal = yes}; /* close set*/
        if (converseVar.validationMsgNum == 0)
          converseLib.validationFailed(197); /* no products on invoice*/
        end
        return;
      else
        TA1REC.TA1DBASE = "DINVC";
        TA1REC.TA1TBLVU = "VIVITM01";
        XPCL010(); /* abend*/
      end
    end
  else
    TA1REC.TA1DBASE = "DINVC"; /* file not opened*/
    TA1REC.TA1TBLVU = "VIVITM01";
    XPCL010(); /* abend*/
  end


  CL0LW01.CL0LWTSH[1] = 0;
  CL0LW01.CL0LWPEF = "N"; /* not product end of file*/

  while (CL0LW01.CL0LWPEF == "N") /* while not product end of file -*/
    if (CLXREC.CLXARAYX <= CL0LW02.CL0LWASZ) /* dont exceed array size*/
       /* accum total of all prods on the invc*/
      CL0LW01.CL0LWTSH[1] = CL0LW01.CL0LWTSH[1] + IV3REC.IV3LNSQ;
       /* cl0lw01.clrrqtq = 0      ; 0 until user enters data*/
       /* cl0lw01.clrclmq = 0      ; 0 until user enters data*/
       /* cl0lw01.cl0lwtvl = 0     ; 0 until user enters data*/

      CL0LW02.ZZZCHGCT[CLXARAYX] = 0;

       /* sure hope the xgpcd is right*/
       /* leave cl0lmlvl blank since user will choose prod/size level*/

      CL0LW02.XGPCD[CLXARAYX] = CLAREC.XGPCD;
      CL0LW02.SY1STNBR[CLXARAYX] = IV3REC.SY1STNBR;
      CL0LW02.SY2CLRID[CLXARAYX] = IV3REC.SY2CLRID;
      CL0LW02.XDMCD[CLXARAYX] = IV3REC.XDMCD;
      CL0LW02.SY5SZID[CLXARAYX] = IV3REC.IV3NBRSZ;
      CL0LW02.XQACD[CLXARAYX] = IV3REC.XQACD;
      CL0LW02.XUMCD[CLXARAYX] = IV3REC.XUMCD;
      CL0LW02.XBK-BK-SESN-CD[CLXARAYX] = IV3REC.XBK-BK-SESN-CD;
                                   /* sgorga*/
      CL0LW02.OP-BK-YR[CLXARAYX] = IV3REC.OP-BK-YR; /* sgorga*/
      CL0LW02.OP-BK-MO[CLXARAYX] = IV3REC.OP-BK-MO; /* twatso*/
      if (CL0LW01.CL0LWPFL == "Y")
        CL6REC.IV0PARTN = CL0LW02.IV0PARTN;
        CL6REC.IV0IVCID = CL0LW02.IV0IVCID;
        CL6REC.XGPCD = CLAREC.XGPCD;
        CL6REC.SY1STNBR = IV3REC.SY1STNBR;
        CL6REC.SY2CLRID = IV3REC.SY2CLRID;
        CL6REC.XDMCD = IV3REC.XDMCD;
        CL6REC.XQACD = IV3REC.XQACD;
        CL6REC.XUMCD = IV3REC.XUMCD;
        CL6REC.SY5SZID = 0;

        KL0LSSO(); /* select set price overrides*/

        if (SQLCA.VAGen_SQLCODE == 0
         && CL6REC.CLHMEMNB > 0)
          CL0LW02.CLNGRPRC[CLXARAYX] = CL6REC.CL6OVPRC;
          CL0LW02.CLNNTPRC[CLXARAYX] = CL6REC.CL6OVPRC;
          CL0LW02.CLKPRCFF[CLXARAYX] = "O";
          call "IO2950" ("CS", SQLCA, CL6REC) {isNoRefresh = yes, isExternal = yes};
        else
          call "IO2950" ("CS", SQLCA, CL6REC) {isNoRefresh = yes, isExternal = yes};
          CL6REC.IV0PARTN = CL0LW02.IV0PARTN;
          CL6REC.IV0IVCID = CL0LW02.IV0IVCID;
          CL6REC.XGPCD = CLAREC.XGPCD;
          CL6REC.SY1STNBR = IV3REC.SY1STNBR;
          CL6REC.SY2CLRID = IV3REC.SY2CLRID;
          CL6REC.XDMCD = IV3REC.XDMCD;
          CL6REC.XQACD = IV3REC.XQACD;
          CL6REC.XUMCD = IV3REC.XUMCD;
          CL6REC.SY5SZID = -1;
          KL0LSCO();
          if (CL0LW01.CL0LWSWZ == "Y")
            CL0LW02.CLNGRPRC[CLXARAYX] = CL0LW01.CL0LWPCE;
            CL0LW02.CLNNTPRC[CLXARAYX] = CL0LW01.CL0LWPCE;
            CL0LW02.CLKPRCFF[CLXARAYX] = "O";
            CL0LW02.CL0LMLVL[CLXARAYX] = "S";
            if (IV3REC.OP2PRCVF == "Y")
              CL0LW02.OP2PRCVF[CLXARAYX] = "Y";
              CL0LW02.CLNGRPRC[CLXARAYX] = 0;
              CL0LW02.CLNNTPRC[CLXARAYX] = 0;
            else
              CL0LW02.OP2PRCVF[CLXARAYX] = CL0LW01.CL0LWVAR;
            end
          else
            CL0LW02.CLNGRPRC[CLXARAYX] = IV3REC.IV3GLNUP;
            CL0LW02.CLNNTPRC[CLXARAYX] = IV3REC.IV3NLNUP;
            CL0LW02.CLKPRCFF[CLXARAYX] = "I";
            CL0LW02.OP2PRCVF[CLXARAYX] = IV3REC.OP2PRCVF;
          end
        end
      else
        CL0LW02.CLNGRPRC[CLXARAYX] = IV3REC.IV3GLNUP;
        CL0LW02.CLNNTPRC[CLXARAYX] = IV3REC.IV3NLNUP;
        CL0LW02.CLKPRCFF[CLXARAYX] = "I";
        CL0LW02.OP2PRCVF[CLXARAYX] = IV3REC.OP2PRCVF;
      end
      CL0LW02.OP2LNINB[CLXARAYX] = IV3REC.OP2LNINB;
      CL0LW02.KUIPRDID[CLXARAYX] = IV3REC.KUIPRDID;
      CL0LW02.XPYCD[CLXARAYX] = IV3REC.XPYCD;
      CL0LW02.XCOCD[CLXARAYX] = IV3REC.XCOCD;
       /* have only 1 field in cl0lw02, so hold only 'y'*/
       /* IF IV3REC.OP2PRCOF EQ 'Y';*/
         /* MOVE IV3REC.OP2PRCOF TO CL0LW02.OP2PRCVF(CLXARAYX);*/
       /* END ;*/
      if (CL0LW02.IVANBLFL == "Y") /* net bill flag*/
        CL0LW02.IV3GLNUP[CLXARAYX] = IV3REC.IV3NLNUP;
      else
        CL0LW02.IV3GLNUP[CLXARAYX] = IV3REC.IV3GLNUP;
      end
      CL0LW02.IV3LNSQ[CLXARAYX] = IV3REC.IV3LNSQ;

      CL0LW02.CL0LWUSI[CLXARAYX] = "Y"; /* yes,use invc for sizes*/

      CLXREC.CLXARAYX = CLXREC.CLXARAYX + 1; /* increment array index*/

      call "IO1100" ("N2", SQLCA, IV3REC) {isNoRefresh = yes, isExternal = yes}; /* fetch next*/
      if (SQLCA.VAGen_SQLCODE == 0)
         /* next sentence           ; loop within 'while' to load array*/
      else
        if (SQLCA.VAGen_SQLCODE == 100)
          call "IO1100" ("C2", SQLCA, IV3REC) {isNoRefresh = yes, isExternal = yes}; /* close set*/
          CL0LW01.CL0LWPEF = "Y"; /* product end of file*/
        else
          TA1REC.TA1DBASE = "DINVC";
          TA1REC.TA1TBLVU = "VIVITM01";
          XPCL010(); /* abend*/
        end
      end
    else
      TA1REC.TA1TBLKE = "EXCEEDED CL0LW02 PRODUCT ARRAY SIZE";
      XPCL010(); /* abend*/
    end
  end




end // end KL0LSP4

// actual bld arry frm prd on clm
Function KL0LSP5()

     /* **********************************************************/
     /* both cl0lsb2 and cl0lsp6 use this sgrp.*/
     /* which does the actual fetch and load of the w/s array*/
     /* from the claim adjustment product table.*/
     /* the first fetch is done in cl0lsb2 and cl0lsp6.*/
     /* **********************************************************/

  TA1REC.TA1LOCAT[2] = "CL0LSP5";
  CL0LW01.CL0LWPEF = "N"; /* not end of product file*/
  CL0LW01.CL0LWTSH[1] = 0;

  while (CL0LW01.CL0LWPEF == "N") /* while not product end of file -*/
    if (CLXREC.CLXARAYX <= CL0LW02.CL0LWASZ) /* dont exceed array size*/
       /* accum map totals for all products on the invoice*/
       /* cl0lw01.cl0lwtsh is calc in read invc  shipped qty,cl0ls30*/
       /* ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?  ? ? ? ? ?  ?*/
       /* need to get shipped qty here, so total on first screen*/
       /* shows total of all products on the invoice.*/
       /* current method only adds ship qty when moved to screen*/
       /* note - don't add ship qty if prod same as previous.*/
       /* ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?  ? ? ? ? ?  ?*/
      if (CL0LW02.IVANBLFL == "Y") /* net bill flag*/
        CL0LW01.CLAESTVL = CLRREC.CLRCLMQ * CLRREC.CLNNTPRC;
      else
        CL0LW01.CLAESTVL = CLRREC.CLRCLMQ * CLRREC.CLNGRPRC;
      end
      if (CLRREC.CLICRDFL == "D") /* debit claim, adds to tots*/
        CL0LW01.CLRCLMQ[1] = CL0LW01.CLRCLMQ[1] + CLRREC.CLRCLMQ;
        CL0LW01.CLRRQTQ[1] = CL0LW01.CLRRQTQ[1] + CLRREC.CLRRQTQ;
        CL0LW01.CL0LWTVL[1] = CL0LW01.CL0LWTVL[1] + CL0LW01.CLAESTVL;
      else /* assume have credit*/
        CL0LW01.CLRCLMQ[1] = CL0LW01.CLRCLMQ[1] - CLRREC.CLRCLMQ;
        CL0LW01.CLRRQTQ[1] = CL0LW01.CLRRQTQ[1] - CLRREC.CLRRQTQ;
        CL0LW01.CL0LWTVL[1] = CL0LW01.CL0LWTVL[1] - CL0LW01.CLAESTVL;
      end

       /* may have same prod twice, worked at prod & size levels*/
       /* so put prod level and first of size level into array*/
      CL0LW01.CL0LWINX = CLXREC.CLXARAYX - 1;
      if (CL0LW01.CL0LWINX == 0) /* force valid index*/
        CL0LW01.CL0LWINX = 1;
      end
      if (CLRREC.SY1STNBR == CL0LW02.SY1STNBR[CL0LWINX]
       && CLRREC.SY2CLRID == CL0LW02.SY2CLRID[CL0LWINX]
       && CLRREC.XDMCD == CL0LW02.XDMCD[CL0LWINX]
       && CLRREC.XGPCD == CL0LW02.XGPCD[CL0LWINX]
       && CLRREC.SY5SZID != 0)
         /* use same product, diff size, diff/same cr/db code*/
         /* sum sizes to show on summary screen*/
        if (CLRREC.CLICRDFL == "C")
          CL0LW02.CLRCLMQ[CL0LWINX] = CL0LW02.CLRCLMQ[CL0LWINX] - CLRREC.CLRCLMQ;
          CL0LW02.CLRRQTQ[CL0LWINX] = CL0LW02.CLRRQTQ[CL0LWINX] - CLRREC.CLRRQTQ;
          CL0LW01.CL0LWEV = CL0LW01.CL0LWEV - CL0LW01.CLAESTVL;
          CL0LW02.CLAESTVL[CL0LWINX] = CL0LW01.CL0LWEV;
        else
          CL0LW02.CLRCLMQ[CL0LWINX] = CL0LW02.CLRCLMQ[CL0LWINX] + CLRREC.CLRCLMQ;
          CL0LW02.CLRRQTQ[CL0LWINX] = CL0LW02.CLRRQTQ[CL0LWINX] + CLRREC.CLRRQTQ;
          CL0LW01.CL0LWEV = CL0LW01.CL0LWEV + CL0LW01.CLAESTVL;
          CL0LW02.CLAESTVL[CL0LWINX] = CL0LW01.CL0LWEV;
        end

        if (CLRREC.CLNGRPRC != CL0LW02.CLNGRPRC[CL0LWINX]
         || CLRREC.CLNNTPRC != CL0LW02.CLNNTPRC[CL0LWINX])
          CL0LW02.OP2PRCVF[CL0LWINX] = "Y"; /* flag size price varies*/
        end
         /* test each size for mixed cr/db codes*/
        if (CLRREC.CLICRDFL == "C")
          CL0LW01.CL0LWHVC = "Y";
        else
          if (CLRREC.CLICRDFL == "D")
            CL0LW01.CL0LWHVD = "Y";
          end
        end
         /* if mixed db/cr, show as 'b'oth*/
        if (CL0LW01.CL0LWHVC == "Y"
         && CL0LW01.CL0LWHVD == "Y")
          CL0LW02.CLICRDFL[CL0LWINX] = "B";
        end

      else
        CL0LW01.CL0LWINX = CLXREC.CLXARAYX - 1;
        if (CL0LW01.CL0LWINX == 0)
          CL0LW01.CL0LWINX = 1;
        end

        CL0LW02.ZZZCHGCT[CLXARAYX] = CLRREC.ZZZCHGCT;
        CL0LW02.SY1STNBR[CLXARAYX] = CLRREC.SY1STNBR;
        CL0LW02.SY2CLRID[CLXARAYX] = CLRREC.SY2CLRID;
        CL0LW02.XDMCD[CLXARAYX] = CLRREC.XDMCD;
        CL0LW02.SY5SZID[CLXARAYX] = CLRREC.SY5SZID;
        CL0LW02.OP2LNINB[CLXARAYX] = CLRREC.OP2LNINB;
        CL0LW02.XQACD[CLXARAYX] = CLRREC.XQACD;
        CL0LW02.XUMCD[CLXARAYX] = CLRREC.XUMCD;
        CL0LW02.CLNGRPRC[CLXARAYX] = CLRREC.CLNGRPRC;
        CL0LW02.CLNNTPRC[CLXARAYX] = CLRREC.CLNNTPRC;
        CL0LW02.CLICRDFL[CLXARAYX] = CLRREC.CLICRDFL;
        CL0LW02.XGPCD[CLXARAYX] = CLRREC.XGPCD;
        CL0LW02.CLKPRCFF[CLXARAYX] = CLRREC.CLKPRCFF;
        if (CLRREC.CLICRDFL == "C")
          CL0LW02.CLRCLMQ[CLXARAYX] = CLRREC.CLRCLMQ * -1;
          CL0LW02.CLRRQTQ[CLXARAYX] = CLRREC.CLRRQTQ * -1;
          if (CL0LW02.IVANBLFL == "Y")
            CL0LW01.CL0LWEV = CL0LW02.CLRCLMQ[CLXARAYX] * CLRREC.CLNNTPRC;
          else
            CL0LW01.CL0LWEV = CL0LW02.CLRCLMQ[CLXARAYX] * CLRREC.CLNGRPRC;
          end
          CL0LW02.CLAESTVL[CLXARAYX] = CL0LW01.CL0LWEV;
        else
          CL0LW02.CLRCLMQ[CLXARAYX] = CLRREC.CLRCLMQ;
          CL0LW02.CLRRQTQ[CLXARAYX] = CLRREC.CLRRQTQ;
          if (CL0LW02.IVANBLFL == "Y")
            CL0LW01.CL0LWEV = CL0LW02.CLRCLMQ[CLXARAYX] * CLRREC.CLNNTPRC;
          else
            CL0LW01.CL0LWEV = CL0LW02.CLRCLMQ[CLXARAYX] * CLRREC.CLNGRPRC;
          end
          CL0LW02.CLAESTVL[CLXARAYX] = CL0LW01.CL0LWEV;
        end

        CL0LW01.CL0LWHVC = "N";
        CL0LW01.CL0LWHVD = "N";
        if (CLRREC.CLICRDFL == "C")
          CL0LW01.CL0LWHVC = "Y";
        else
          if (CLRREC.CLICRDFL == "D")
            CL0LW01.CL0LWHVD = "Y";
          end
        end

        if (CLRREC.SY5SZID == 0)
          CL0LW02.CL0LMLVL[CLXARAYX] = "P"; /* worked at prod lvl*/
        else
          CL0LW02.CL0LMLVL[CLXARAYX] = "S"; /* worked at size lvl*/
        end

        if (CL0LW02.IV0IVCID != 0
         && CL0LW01.YITCD == "I"
         && CL0LW02.IV3LNSQ[CLXARAYX] == 0)
          IV3REC.IV0PARTN = CL0LW02.IV0PARTN;
          IV3REC.IV0IVCID = CL0LW02.IV0IVCID;
          IV3REC.OP2LNINB = CL0LW02.OP2LNINB[CLXARAYX];

          call "IO1100" ("S ", SQLCA, IV3REC) {isNoRefresh = yes, isExternal = yes};

          if (SQLCA.VAGen_SQLCODE == 0)
            CL0LW02.IV3LNSQ[CLXARAYX] = IV3REC.IV3LNSQ;
            if (CL0LW02.IVANBLFL == "Y")
              CL0LW02.IV3GLNUP[CLXARAYX] = IV3REC.IV3NLNUP;
            else
              CL0LW02.IV3GLNUP[CLXARAYX] = IV3REC.IV3GLNUP;
            end
            CL0LW01.CL0LWTSH[1] = CL0LW01.CL0LWTSH[1] + IV3REC.IV3LNSQ;
          end
        end

        CLXREC.CLXARAYX = CLXREC.CLXARAYX + 1; /* increment array index*/
      end

      call "IO1370" (CL0LW04, SQLCA, CLRREC) {isNoRefresh = yes, isExternal = yes}; /* next product rec*/
      if (SQLCA.VAGen_SQLCODE == 0)
         /* next sentence           ; loop within 'while' to load array*/
      else
        if (SQLCA.VAGen_SQLCODE == 100)
          CL0LW01.CL0LWPEF = "Y"; /* product end of file*/
          CL0LW01.CL0LWINX = CLXREC.CLXARAYX - 1;
          if (CL0LW01.CL0LWINX == 0)
            CL0LW01.CL0LWINX = 1;
          end

        else
          TA1REC.TA1DBASE = "DCLAIM";
          TA1REC.TA1TBLVU = "VCLADJ01";
          XPCL010(); /* abend*/
        end
      end
    else
      TA1REC.TA1TBLKE = "EXCEEDED CL0LW02 PRODUCT ARRAY SIZE";
      XPCL010(); /* abend*/
    end
  end




end // end KL0LSP5

// bld array from prod on claim
Function KL0LSP6()


     /* **************************************************/
     /* clarec.cladjind shows we have products already*/
     /* associated with the claim.  since there was no*/
     /* invoice/claim xref record, get all the products*/
     /* from the claim*/
     /* **************************************************/

  TA1REC.TA1LOCAT[2] = "CL0LSP6";
  CLRREC.CLACLMNB = CLAREC.CLACLMNB; /* claim number*/
  CLRREC.CLHSEQNB = CL0LW01.CLACSQNB; /* sequence number*/
  CLRREC.XGPCD = "**"; /* and g.p.c.*/

  CLRREC.SY1STNBR = "******"; /* get all products*/
  CLRREC.SY2CLRID = "***";
  CLRREC.XDMCD = "**";
  CLRREC.CLICRDFL = "*"; /* get both cr and debits*/

  call "IO1370" ("S1", SQLCA, CLRREC) {isNoRefresh = yes, isExternal = yes}; /* select set of clm prods*/
  set CL0LW04 empty;
  CL0LW04.CL0LWOPT = "N1"; /* move in fetch option*/

     /* *************************/
     /* read first record in set*/
     /* *************************/

  if (SQLCA.VAGen_SQLCODE == 0) /* have set open*/
    call "IO1370" ("N1", SQLCA, CLRREC) {isNoRefresh = yes, isExternal = yes}; /* first read*/
     /* note - ezesqcod is now for fetch, not set*/
    if (SQLCA.VAGen_SQLCODE == 0) /* process data*/
      KL0LSP5();
    else
      if (SQLCA.VAGen_SQLCODE == 100)
        call "IO1370" ("C1", SQLCA, CLRREC) {isNoRefresh = yes, isExternal = yes}; /* close set*/
        if (converseVar.validationMsgNum == 0)
          converseLib.validationFailed(198); /* no products on claim*/
        end
        return;
      else
        TA1REC.TA1DBASE = "DCLAIM";
        TA1REC.TA1TBLVU = "VCLADJ01";
        XPCL010(); /* abend*/
      end
    end
  else
    TA1REC.TA1DBASE = "DCLAIM";
    TA1REC.TA1TBLVU = "VCLADJ01";
    XPCL010(); /* abend*/
  end



end // end KL0LSP6

// map 1 clear line,unprt product
Function KL0LSP7()
     /* ***************************************/
     /* clear map line, unprotect nike prod id*/
     /* ***************************************/

  if (CL0LW01.CL0LWINQ == "N") /* if not inquiry mode,*/
     /* *************************/
     /* unprotect nike prod id*/
     /* allow user to enter data*/
     /* *************************/
    set KL0LM001.SY1STNBR[CLXLINEX] normal;
    set KL0LM001.SY2CLRID[CLXLINEX] normal;
    set KL0LM001.CLRRQTQ[CLXLINEX] normal;
    set KL0LM001.CLRCLMQ[CLXLINEX] normal;
    set KL0LM001.CLKPRCFF[CLXLINEX] normal;
    set KL0LM001.CL0LMSEL[CLXLINEX] normal;
    set KL0LM005.CL0LMSEL[CLXLINEX] normal;
    set KL0LM001.CLNGRPRC[CLXLINEX] normal;
    set KL0LM001.XDMCD[CLXLINEX] normal;
  end


     /* *****************/
     /* clear map line*/
     /* *****************/

  KL0LM001.CL0LMSEL[CLXLINEX] = " ";
  KL0LM001.CLICRDFL[CLXLINEX] = " ";
  KL0LM001.CL0LMLVL[CLXLINEX] = " ";
  KL0LM001.SY1STNBR[CLXLINEX] = " ";
  KL0LM001.SY2CLRID[CLXLINEX] = " ";
  KL0LM001.XDMCD[CLXLINEX] = " ";
  KL0LM001.IV3LNSQ[CLXLINEX] = 0;
  KL0LM001.IV3GLNUP[CLXLINEX] = 0;
  KL0LM001.CLRRQTQ[CLXLINEX] = 0;
  KL0LM001.CLRCLMQ[CLXLINEX] = 0;
  KL0LM001.CLKPRCFF[CLXLINEX] = " ";
  KL0LM001.CLNGRPRC[CLXLINEX] = 0;
  KL0LM001.CL0LMVPR[CLXLINEX] = " ";
  KL0LM001.CLAESTVL[CLXLINEX] = 0;



end // end KL0LSP7

// add w03 sizes to w02 prod summ
Function KL0LSPA()
     /* ************************************/
     /* update product array with size info*/
     /* ************************************/

     /* *************************************/
     /* mark product as worked at size level*/
     /* *************************************/

  CL0LW02.SY5SZID[CL0LWCAX] = CL0LW03.SY5SZID[CLXCURSZ];
  CL0LW02.CL0LMLVL[CL0LWCAX] = "S";


     /* *********************************************/
     /* make product summary w02 reflect size detail*/
     /* *********************************************/

   /* ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?*/
   /* this does not work when size prices vary*/
   /* need to actually accum total of size prices, then divide*/
   /* by number of sizes.  also need to accum total size value,*/
   /* using cr/db sign, to put into cl0lw02 to prod summ value.*/
   /* ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?*/

   /* does size price vary from other size price?*/

  CL0LW02.CLKPRCFF[CL0LWCAX] = CL0LW03.CLKPRCFF[CLXCURSZ];
  CL0LW02.CLNGRPRC[CL0LWCAX] = CL0LW03.CLNGRPRC[CLXCURSZ];
  CL0LW02.CLNNTPRC[CL0LWCAX] = CL0LW03.CLNNTPRC[CLXCURSZ];


     /* **************************************/
     /* mark product as from clm, not invoice*/
     /* **************************************/

  CL0LW02.CL0LWUSI[CL0LWCAX] = "N"; /* do not use ivc for size dtls*/


     /* ********************************/
     /* action was taken on size detail*/
     /* ********************************/

  CL0LW03.CL0LWCHF[CLXCURSZ] = " ";
  CL0LW03.ZZZCHGCT[CLXCURSZ] = CLRREC.ZZZCHGCT;



end // end KL0LSPA

// get price from product
Function KL0LSPP()
         /* * * ********************************* * **/
       /* *                                           **/
     /* *           keep similar to cl0lsps             **/
       /* *                                           **/
         /* * * ********************************* * **/


   /* GET OP0I020*/
     /* *****************************************************/
     /* get product price using same method as orders, op0i.*/
     /* also consider the invoice special pricing table,iverec.*/
     /* if price is done by size, then use the first valid size*/
     /* as the product price.  a price varies flag will be*/
     /* set when size prices differ within a product*/
     /* *****************************************************/

  TA1REC.TA1LOCAT[2] = "CL0LSPP";
  if (CL0LW01.CL0LWSYC == "Y") /* if have style/color record*/
     /* next sentence*/
  else
    CL0LW02.CLNGRPRC[CL0LWINX] = 0; /* else leave now*/
    CL0LW02.CLNNTPRC[CL0LWINX] = 0;
    return;
  end


   /* GET OP0IS24*/
      /* *******************************************************/
      /* * if sales pgm has product pricing (clarec.sp1id ne ' ')*/
      /* *   then also get product price -*/
      /* *   use lower price value*/
      /* * else*/
      /* *   (sales pgm may not have product pricing)*/
      /* *   use invoice speciality table, iverec,*/
      /* *     price/cost indicator to access either:*/
      /* *     product price table sy5rec*/
      /* *     or*/
      /* *     product cost table sy6rec*/
      /* **/
      /* *    if product price-size code = z:*/
      /* *      default size from ydstbl, use prod scale code,*/
      /* *      then:*/
      /* *        read price/cost default for style,color,size*/
      /* *        use price/cost directly from valid sz on prodct*/
      /* *    else*/
      /* *      if color default price/cost ne 0*/
      /* *        use it*/
      /* *      else*/
      /* *        use style default price/cost.*/
      /* *******************************************************/


      /* *********************/
      /* * pricing flags*/
      /* *********************/

  CL0LW02.OP2PRCVF[CL0LWINX] = "N"; /* price vary flag*/

  CL0LW02.CLNGRPRC[CL0LWINX] = 0;
  CL0LW02.CLNNTPRC[CL0LWINX] = 0;
  CL0LW01.SP5SZPR = 0;


      /* get sales pgm prices - or -*/
      /* get style and style/color price/cost defaults to use*/
      /* when there is no price by size for the product*/

  if (CLAREC.SP1ID != " ") /* if have sales program*/
    /* GET OM0QS99*/
     /* *****************************************/
     /* get sales program product pricing record*/
     /* *****************************************/
    SP5REC.SP1ID = CLAREC.SP1ID; /* set-up key for prod price*/
    SP5REC.XGPCD = CLAREC.XGPCD;
    SP5REC.SY1STNBR = CL0LW02.SY1STNBR[CL0LWINX];
    SP5REC.SY2CLRID = CL0LW02.SY2CLRID[CL0LWINX];
    SP5REC.XDMCD = CL0LW02.XDMCD[CL0LWINX];

    call "IO0110" ("S ", SQLCA, SP5REC) {isNoRefresh = yes, isExternal = yes}; /* i/o mod for inquiry*/

    if (SQLCA.VAGen_SQLCODE == 0) /* check for good rc*/
       /* use default size code to get correct price*/
       /* don't have product price, all prices are by size*/
      if (SYCREC.SY4SZSCL in YDSTBL.SY4SZSCL)
        CL0LW01.SP5SZPR = SP5REC.SP5SZPR[sysVar.arrayIndex];
      end
    end
  end


     /* ******************/
     /* get product price*/
     /* ******************/

  if (IVEREC.IVEPCIND == "P") /* invc specl codes from cl0l001*/
    KL0LS70(); /* product price defaults*/
  else
    if (IVEREC.IVEPCIND == "C")
      KL0LS72(); /* product cost defaults*/
    end
     /* note ivepcind may be blank, if not found in cl0l001*/
  end

   /* get op0is24*/
   /* use product price, if any*/

   /* SET TOTAL ADJUST TO PRICE/COST, USING INVC SPECIAL TABLE*/
  CL0LW01.CL0LWPCP = IVEREC.IVEPCPCT + 100;

   /* style/color defaults were set above, cl0ls70 or cl0ls72*/
  if (CL0LW01.CL0LWCLP != 0)
     /* use color default price/cost*/
    CL0LW02.CLNGRPRC[CL0LWINX] = CL0LWCLP * CL0LWPCP / 100;
  else
     /* use style default price/cost*/
    CL0LW02.CLNGRPRC[CL0LWINX] = CL0LWSTP * CL0LWPCP / 100;
  end
  CL0LW02.CLNNTPRC[CL0LWINX] = CL0LW02.CLNGRPRC[CL0LWINX];


     /* ***************************************************/
     /* if sales prgm had a price, and product had a price*/
     /* use lower value for the claim price*/
     /* ***************************************************/

  if (CL0LW01.SP5SZPR != 0
   && CL0LW02.CLNGRPRC[CL0LWINX] != 0)
    if (CL0LW01.SP5SZPR < CL0LW02.CLNGRPRC[CL0LWINX])
      CL0LW02.CLNGRPRC[CL0LWINX] = CL0LW01.SP5SZPR;
      CL0LW02.CLNNTPRC[CL0LWINX] = CL0LW01.SP5SZPR;
    end
  end


     /* *****************/
     /* put price on map*/
     /* *****************/

  KL0LM001.CLNGRPRC[CLXLINEX] = CL0LW02.CLNGRPRC[CL0LWINX];



end // end KL0LSPP

// map 10 get price for size
Function KL0LSPS()
         /* * * ******************************** * **/
       /* *                                          **/
     /* *          keep similar to cl0lspp             **/
       /* *                                          **/
         /* * * ******************************** * **/

   /* GET CL0LSPP*/
   /* GET OP0I020*/
     /* *****************************************************/
     /* get product price using same method as orders, op0i.*/
     /* also consider the invoice special pricing table,iverec.*/
     /* if price is done by size, then use the correct valid size*/
     /* as the product price.*/
     /* *****************************************************/

   /* GET OP0IS24*/
      /* *******************************************************/
      /* * if sales pgm has product pricing (clarec.sp1id ne ' ')*/
      /* *   then also get product price -*/
      /* *   use the lower price value*/
      /* * else*/
      /* *   (sales pgm may not have product pricing)*/
      /* *   use invoice speciality table, iverec,*/
      /* *     price/cost indicator to access either:*/
      /* *     product price table sy5rec*/
      /* *     or*/
      /* *     product cost table sy6rec*/
      /* **/
      /* *    if product price-size code = z:*/
      /* *      read price/cost default for style,color,size*/
      /* *      use price/cost directly into valid size on prodct*/
      /* *    else*/
      /* *      if color default price/cost ne 0*/
      /* *        use it*/
      /* *      else*/
      /* *        use style default price/cost.*/
      /* *******************************************************/

      /* ************/
      /* init values*/
      /* ************/

  TA1REC.TA1LOCAT[2] = "CL0LSPS";
  CL0LW03.CLNGRPRC[CL0LWINX] = 0;
  CL0LW03.CLNNTPRC[CL0LWINX] = 0;
  CL0LW01.SP5SZPR = 0;


      /* get sales pgm prices - or -*/
      /* get style and style/color price/cost defaults to use*/
      /* when there is no price by size for the product*/

  if (CLAREC.SP1ID != " ") /* if sales program code*/
    /* GET OM0QS99*/
     /* *****************************************/
     /* get sales program product pricing record*/
     /* *****************************************/
    SP5REC.SP1ID = CLAREC.SP1ID; /* set-up key for prod price*/
    SP5REC.XGPCD = CLAREC.XGPCD;
    SP5REC.SY1STNBR = CL0LW02.SY1STNBR[CL0LWCAX];
    SP5REC.SY2CLRID = CL0LW02.SY2CLRID[CL0LWCAX];
    SP5REC.XDMCD = CL0LW02.XDMCD[CL0LWCAX];

    call "IO0110" ("S ", SQLCA, SP5REC) {isNoRefresh = yes, isExternal = yes}; /* i/o mod for inquiry*/

    if (SQLCA.VAGen_SQLCODE == 0) /* check for good rc*/
      sysVar.arrayIndex = CL0LW03.SY5SZID[CL0LWINX]; /* size i.d.*/
      CL0LW01.SP5SZPR = SP5REC.SP5SZPR[sysVar.arrayIndex];
    end
  end


     /* ******************/
     /* get product price*/
     /* ******************/

   /* get only once for many sizes on product*/
  if (CL0LW01.CL0LWCLP == 0 /* don't have defaults*/
   && CL0LW01.CL0LWSTP == 0)
    if (IVEREC.IVEPCIND == "P") /* invc specl codes from cl0l001*/
      KL0LS70(); /* product price defaults*/
    else
      if (IVEREC.IVEPCIND == "C")
        KL0LS72(); /* product cost defaults*/
      end
       /* note ivepcind may be blank, if not found in cl0l001*/
    end

     /* SET TOTAL ADJUST TO PRICE/COST, USING INVC SPECIAL TABLE*/
    CL0LW01.CL0LWPCP = IVEREC.IVEPCPCT + 100;
  end

   /* get op0is24*/
  if (SYCREC.SY1PRCZS == "Z") /* if might have size price*/
    if (IVEREC.IVEPCIND == "P") /* invc specl codes from cl0l001*/
      KL0LS74(); /* size price*/
    else
      if (IVEREC.IVEPCIND == "C")
        CL0LW03.CLNGRPRC[CL0LWINX] = 0; /* no cost by size*/
        CL0LW03.CLNNTPRC[CL0LWINX] = 0;
      end
       /* note ivepcind may be blank, if not found in cl0l001*/
    end
  else
     /* style/color defaults were set above, cl0ls70 or cl0ls72*/
    if (CL0LW01.CL0LWCLP != 0)
       /* use color default price/cost*/
      CL0LW03.CLNGRPRC[CL0LWINX] = CL0LWCLP * CL0LWPCP / 100;
    else
       /* use style default price/cost*/
      CL0LW03.CLNGRPRC[CL0LWINX] = CL0LWSTP * CL0LWPCP / 100;
    end
    CL0LW03.CLNNTPRC[CL0LWINX] = CL0LW03.CLNGRPRC[CL0LWINX];
  end


     /* *********************************************/
     /* if sales pgm had price and product had price*/
     /* use the lower value for the claim price*/
     /* *********************************************/

  if (CL0LW01.SP5SZPR != 0
   && CL0LW03.CLNGRPRC[CL0LWINX] != 0)
    if (CL0LW01.SP5SZPR < CL0LW03.CLNGRPRC[CL0LWINX])
      CL0LW03.CLNGRPRC[CL0LWINX] = CL0LW01.SP5SZPR;
      CL0LW03.CLNNTPRC[CL0LWINX] = CL0LW01.SP5SZPR;
    end
  end


      /* ***********************/
      /* move size price to map*/
      /* ***********************/

  KL0LM010.CLNGRPRC[CLXLINEX] = CL0LW03.CLNGRPRC[CL0LWINX];



end // end KL0LSPS

// map 1 accum total qty/valu chg
Function KL0LSPT()
     /* *******************************************************/
     /* if cancel line, do below, reverse add/subtract*/
     /* if debit line, add to map totals and to clarec totals*/
     /* if credit line, subtract from map totals & clarec tots*/
     /* if neither, skip totaling*/
     /* *******************************************************/

  if (KL0LM001.CL0LMSEL[CLXLINEX] == "X") /* line cancelled*/
    if (CL0LW02.CLICRDFL[CL0LWINX] == " ")
      return;
    end
    CL0LW01.CLRRQTQ[1] = CL0LW01.CLRRQTQ[1] - KL0LM001.CLRRQTQ[CLXLINEX];
    CL0LW01.CLRCLMQ[1] = CL0LW01.CLRCLMQ[1] - KL0LM001.CLRCLMQ[CLXLINEX];

    CL0LW01.CL0LWQCH = CL0LW01.CL0LWQCH - KL0LM001.CLRCLMQ[CLXLINEX];
     /* cl0lw01.claestvl was calc in cl0l120 before came here*/
     /* value field is signed for db/cr*/
    if (KL0LM001.CLICRDFL[CLXLINEX] == "D"
     || KL0LM001.CLRRQTQ[CLXLINEX] >= 0)
      CL0LW01.CL0LWTVL[1] = CL0LW01.CL0LWTVL[1] - CL0LW01.CLAESTVL;
      CL0LW01.CL0LWVCH = CL0LW01.CL0LWVCH - CL0LW01.CLAESTVL;
    else
      CL0LW01.CL0LWTVL[1] = CL0LW01.CL0LWTVL[1] - CL0LW01.CLAESTVL;
      CL0LW01.CL0LWVCH = CL0LW01.CL0LWVCH - CL0LW01.CLAESTVL;
    end

     /* ************************/
     /* move zero to old values*/
     /* ************************/
    CL0LW01.CL0LWORQ[CLXLINEX] = 0;
    CL0LW01.CL0LWOCQ[CLXLINEX] = 0;
    CL0LW01.CL0LWOVL[CLXLINEX] = 0;
    KL0LM001.CLRRQTQ[CLXLINEX] = 0;
    KL0LM001.CLRCLMQ[CLXLINEX] = 0;
    KL0LM001.CLAESTVL[CLXLINEX] = 0;

    return;
  end

   /* IF CL0LM001.CLRRQTQ(CLXLINEX) IS MODIFIED;*/
     /* OR CL0LM001.CLRCLMQ(CLXLINEX) IS MODIFIED;*/
     /* OR CL0LM001.CLNGRPRC(CLXLINEX) IS MODIFIED;*/
     /* OR CL0LM001.CLKPRCFF(CLXLINEX) IS MODIFIED;*/
     /* OR CL0LM001.XDMCD(CLXLINEX) IS MODIFIED;*/
     /* OR CL0LM001.SY1STNBR(CLXLINEX) IS MODIFIED;*/
     /* OR CL0LM001.SY2CLRID(CLXLINEX) IS MODIFIED;*/
    /* ;next sentence*/
   /* ELSE ;*/
     /* EZERTN;*/
   /* END ;*/

  if (CL0LW01.CL0LWMOD[CLXLINEX] == "Y")
    /* next sentence*/
  else
    return;
  end

  if (KL0LM001.CLICRDFL[CLXLINEX] == "D" /* add in debit change*/
   || CL0LW02.CLICRDFL[CL0LWINX] == "D"  
   || KL0LM001.CLRRQTQ[CLXLINEX] >= 0)  
     /* new qty - old qty, then add to totals*/
    CL0LWQTY = KL0LM001.CLRRQTQ[CLXLINEX] - CL0LW01.CL0LWORQ[CLXLINEX];
    CL0LW01.CLRRQTQ[1] = CL0LW01.CLRRQTQ[1] + CL0LW01.CL0LWQTY;

     /* new qty - old qty, then add to totals*/
    CL0LWQTY = KL0LM001.CLRCLMQ[CLXLINEX] - CL0LW01.CL0LWOCQ[CLXLINEX];
    CL0LW01.CLRCLMQ[1] = CL0LW01.CLRCLMQ[1] + CL0LW01.CL0LWQTY;
     /* also add clarec total qty*/
    CL0LW01.CL0LWQCH = CL0LW01.CL0LWQCH + CL0LW01.CL0LWQTY;

     /* new value - old value, then add to totals*/
     /* cl0lw01.claestvl was calc in cl0l120 before came here*/
     /* value is signed field for db/cr*/
    CL0LWQTY = CL0LW01.CLAESTVL - CL0LW01.CL0LWOVL[CLXLINEX];
    CL0LW01.CL0LWTVL[1] = CL0LW01.CL0LWTVL[1] + CL0LW01.CL0LWQTY;
     /* also add clarec total value*/
    CL0LW01.CL0LWVCH = CL0LW01.CL0LWVCH + CL0LW01.CL0LWQTY;
  else
    if (KL0LM001.CLICRDFL[CLXLINEX] == "C"
     || CL0LW02.CLICRDFL[CL0LWINX] == "C")
       /* new qty - old qty, then subt to totals*/
      if (KL0LM001.CLRRQTQ[CLXLINEX] < 0)
        CL0LW01.CL0LWQTY = KL0LM001.CLRRQTQ[CLXLINEX] * -1;
      else
        CL0LW01.CL0LWQTY = KL0LM001.CLRRQTQ[CLXLINEX];
      end
      CL0LW01.CL0LWQTY = CL0LW01.CL0LWQTY - CL0LW01.CL0LWORQ[CLXLINEX];
      CL0LW01.CLRRQTQ[1] = CL0LW01.CLRRQTQ[1] - CL0LW01.CL0LWQTY;

       /* new qty - old qty, then subt to totals*/
      if (KL0LM001.CLRCLMQ[CLXLINEX] < 0)
        CL0LW01.CL0LWQTY = KL0LM001.CLRCLMQ[CLXLINEX] * -1;
      else
        CL0LW01.CL0LWQTY = KL0LM001.CLRCLMQ[CLXLINEX];
      end
      CL0LW01.CL0LWQTY = CL0LW01.CL0LWQTY - CL0LW01.CL0LWOCQ[CLXLINEX];
      CL0LW01.CLRCLMQ[1] = CL0LW01.CLRCLMQ[1] - CL0LW01.CL0LWQTY;
       /* also subtract clarec total qty*/
      CL0LW01.CL0LWQCH = CL0LW01.CL0LWQCH - CL0LW01.CL0LWQTY;

       /* new value - old value, then add to totals*/
       /* cl0lw01.claestvl was calc in cl0l120 before came here*/
       /* value is signed field for db/cr*/
      CL0LWQTY = CL0LW01.CLAESTVL + CL0LW01.CL0LWOVL[CLXLINEX];
      CL0LW01.CL0LWTVL[1] = CL0LW01.CL0LWTVL[1] + CL0LW01.CL0LWQTY;
       /* also add signed clarec total value*/
      CL0LW01.CL0LWVCH = CL0LW01.CL0LWVCH + CL0LW01.CL0LWQTY;
    end
  end


     /* **************************************/
     /* move current map values to old values*/
     /* **************************************/

  if (KL0LM001.CLICRDFL[CLXLINEX] == "C"
   || CL0LW02.CLICRDFL[CL0LWINX] == "C")
    CL0LW01.CL0LWORQ[CLXLINEX] = KL0LM001.CLRRQTQ[CLXLINEX] * -1;
    CL0LW01.CL0LWOCQ[CLXLINEX] = KL0LM001.CLRCLMQ[CLXLINEX] * -1;
  else
    CL0LW01.CL0LWORQ[CLXLINEX] = KL0LM001.CLRRQTQ[CLXLINEX];
    CL0LW01.CL0LWOCQ[CLXLINEX] = KL0LM001.CLRCLMQ[CLXLINEX];
  end

  CL0LW01.CL0LWOVL[CLXLINEX] = CL0LW01.CLAESTVL;

end // end KL0LSPT

// map 5 set fields modified
Function KL0LSS1()
   /* ************************************************************/
   /* *  since the map must be re-shown to the user             **/
   /* *  before editing has been done, set fields modified to   **/
   /* *  keep track of all the fields entered by the user.      **/
   /* *  the user will only need to re-do the pf key or enter   **/
   /* *  key, not enter the data again.                         **/
   /* ************************************************************/


  if (KL0LM005.IV0IVCID is modified)
    set KL0LM005.IV0IVCID modified;
  end



  sysVar.arrayIndex = 1;

  while (sysVar.arrayIndex <= CLXREC.CLXMAXLN[CLXSCRNX])
    if (KL0LM005.CL0LMSEL[sysVar.arrayIndex] is modified)
      set KL0LM005.CL0LMSEL[sysVar.arrayIndex] modified;
    end
    sysVar.arrayIndex = sysVar.arrayIndex + 1;
  end



end // end KL0LSS1

// map 1 protect for inquiry mode
Function KL0LSS2()
     /* **********************************/
     /* protect all input fields on map 1*/
     /* **********************************/


  sysVar.arrayIndex = 1;

    /* note - really should use 'clxscrnx' instead of '1'*/
    /* to represent map 1*/
    /* for index, but it has not been initialized (see cl0l050)*/

  while (sysVar.arrayIndex <= CLXREC.CLXMAXLN[1])
    set KL0LM001.CLRRQTQ[sysVar.arrayIndex] skip;
    set KL0LM001.CLRCLMQ[sysVar.arrayIndex] skip;
    set KL0LM001.CLKPRCFF[sysVar.arrayIndex] skip;
    set KL0LM001.CLNGRPRC[sysVar.arrayIndex] skip;
    sysVar.arrayIndex = sysVar.arrayIndex + 1;
  end



end // end KL0LSS2

// map 10 clear line, unprot size
Function KL0LSS7()
     /* *************************************/
     /* clear map line, unprotect size field*/
     /* *************************************/


  if (CL0LW01.CL0LWINQ == "N") /* if not in inquiry mo*/
     /* *************************/
     /* unprotect nike prod size*/
     /* allow user to enter data*/
     /* *************************/
    set KL0LM010.SY4IDDSC[CLXLINEX] normal;
    set KL0LM010.CL0LMSEL[CLXLINEX] normal;
    set KL0LM010.CLRRQTQ[CLXLINEX] normal;
    set KL0LM010.CLRCLMQ[CLXLINEX] normal;
    set KL0LM010.CLKPRCFF[CLXLINEX] normal;
    set KL0LM010.CLNGRPRC[CLXLINEX] normal;
  end


  KL0LM010.CL0LMSEL[CLXLINEX] = " ";
  KL0LM010.CLICRDFL[CLXLINEX] = " ";
  KL0LM010.SY4IDDSC[CLXLINEX] = " ";
  KL0LM010.IV4SHPQ[CLXLINEX] = 0;
  KL0LM010.IV4GUP[CLXLINEX] = 0;
  KL0LM010.CLRRQTQ[CLXLINEX] = 0;
  KL0LM010.CLRCLMQ[CLXLINEX] = 0;
  KL0LM010.CLKPRCFF[CLXLINEX] = " ";
  KL0LM010.CLNGRPRC[CLXLINEX] = 0;
  KL0LM010.CLAESTVL[CLXLINEX] = 0;



end // end KL0LSS7

// check price override to select
Function KL0LSSO()

  CLXREC.CLXCPROC = "CL0LSSO";

  if (CL0LW01.CL0LWPFL != "Y")
    SQLCA.VAGen_SQLCODE = 100;
    return;
  end

  call "IO2950" ("SS", SQLCA, CL6REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4);
      CLXREC.CLXERRF = "Y";
      VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
      VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
      sysLib.rollback();
      VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
      
      return;
    else
      TA1REC.TA1LOCAT[2] = "CL0LSSO";
      TA1REC.TA1LOCAT[4] = "IO2950";
      TA1REC.TA1DBASE = "DCLAIM";
      TA1REC.TA1TBLVU = "VIVOVR01";
      CLXREC.XXXWDTE = CLAREC.CLACLMNB;
      TA1REC.TA1TBLKE = CLXREC.XXXWDTE;
      XPCL010();
    end
  end


  call "IO2950" ("SN", SQLCA, CL6REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      return;
    else
      TA1REC.TA1LOCAT[2] = "CL0LSSO";
      TA1REC.TA1LOCAT[4] = "IO2950";
      TA1REC.TA1DBASE = "DCLAIM";
      TA1REC.TA1TBLVU = "VIVOVR01";
      CLXREC.XXXWDTE = CLAREC.CLACLMNB;
      TA1REC.TA1TBLKE = CLXREC.XXXWDTE;
      XPCL010();
    end
  end

end // end KL0LSSO

// map 10 ca/da accum totals
Function KL0LSST()
   /* GET CL0LSDT*/
   /* GET CL0LSpT*/
         /* * * * ******************************** * * * * **/
       /* *                                                  **/
     /* *          keep similar to cl0lsdt & cl0lspt           **/
       /* *                                                  **/
         /* * * * ******************************** * * * * **/

     /* old/original value = 0 on credit all/debit all*/
     /* index is ezetst, not clxlinex*/

     /* *******************************************************/
     /* if debit line, add to map totals and to clarec totals*/
     /* if credit line, subtract from map totals & clarec tots*/
     /* if neither, skip totaling*/

     /* adjust w01 counters(2) for product size totals*/
        /* and w01 counters(1) for summary product totals*/
     /* *******************************************************/


     /* **************************************************/
     /* standard debit/credit, accum map & product totals*/
     /* **************************************************/

  if (CL0LW03.CLICRDFL[sysVar.arrayIndex] == "D") /* add in debit change*/
    CL0LW01.CLRRQTQ[2] = CL0LW01.CLRRQTQ[2] + CL0LW03.CLRRQTQ[sysVar.arrayIndex];
    CL0LW01.CLRRQTQ[1] = CL0LW01.CLRRQTQ[1] + CL0LW03.CLRRQTQ[sysVar.arrayIndex];

    CL0LW01.CLRCLMQ[2] = CL0LW01.CLRCLMQ[2] + CL0LW03.CLRCLMQ[sysVar.arrayIndex];
    CL0LW01.CLRCLMQ[1] = CL0LW01.CLRCLMQ[1] + CL0LW03.CLRCLMQ[sysVar.arrayIndex];
     /* also add clarec total qty*/
    CL0LW01.CL0LWQCH = CL0LW01.CL0LWQCH + CL0LW03.CLRCLMQ[sysVar.arrayIndex];

    if (CL0LW02.IVANBLFL == "Y") /* net bill flag*/
      CL0LW01.CLAESTVL = CL0LW03.CLNNTPRC[sysVar.arrayIndex] * CL0LW03.CLRCLMQ[sysVar.arrayIndex];
    else
      CL0LW01.CLAESTVL = CL0LW03.CLNGRPRC[sysVar.arrayIndex] * CL0LW03.CLRCLMQ[sysVar.arrayIndex];
    end
    CL0LW01.CL0LWTVL[2] = CL0LW01.CL0LWTVL[2] + CL0LW01.CLAESTVL;
    CL0LW01.CL0LWTVL[1] = CL0LW01.CL0LWTVL[1] + CL0LW01.CLAESTVL;
     /* also add clarec total value*/
    CL0LW01.CL0LWVCH = CL0LW01.CL0LWVCH + CL0LW01.CLAESTVL;
  else
    if (CL0LW03.CLICRDFL[sysVar.arrayIndex] == "C") /* subtract out credit chgs*/
      CL0LW01.CLRRQTQ[2] = CL0LW01.CLRRQTQ[2] - CL0LW03.CLRRQTQ[sysVar.arrayIndex];
      CL0LW01.CLRRQTQ[1] = CL0LW01.CLRRQTQ[1] - CL0LW03.CLRRQTQ[sysVar.arrayIndex];

      CL0LW01.CLRCLMQ[2] = CL0LW01.CLRCLMQ[2] - CL0LW03.CLRCLMQ[sysVar.arrayIndex];
      CL0LW01.CLRCLMQ[1] = CL0LW01.CLRCLMQ[1] - CL0LW03.CLRCLMQ[sysVar.arrayIndex];
       /* also subtract clarec total qty*/
      CL0LW01.CL0LWQCH = CL0LW01.CL0LWQCH - CL0LW03.CLRCLMQ[sysVar.arrayIndex];

      if (CL0LW02.IVANBLFL == "Y") /* net bill flag*/
        CL0LW01.CLAESTVL = CL0LW03.CLNNTPRC[sysVar.arrayIndex] * CL0LW03.CLRCLMQ[sysVar.arrayIndex];
      else
        CL0LW01.CLAESTVL = CL0LW03.CLNGRPRC[sysVar.arrayIndex] * CL0LW03.CLRCLMQ[sysVar.arrayIndex];
      end
      CL0LW01.CL0LWTVL[2] = CL0LW01.CL0LWTVL[2] - CL0LW01.CLAESTVL;
      CL0LW01.CL0LWTVL[1] = CL0LW01.CL0LWTVL[1] - CL0LW01.CLAESTVL;
       /* also subt clarec total value*/
      CL0LW01.CL0LWVCH = CL0LW01.CL0LWVCH - CL0LW01.CLAESTVL;
    end
  end


     /* ******************************************/
     /* add size changes to product summary,*/
     /* (add value chng to w02(cl0lwcax))*/
     /* if size cr/db = prod cr/db code,*/
       /* add size clm qty to prod clm qty*/
       /* add size rqt qty to prod rqt qty*/
     /* else*/
       /* subtract size clm qty from prod clm qty*/
       /* subtract size rqt qty from prod rqt qty*/
     /* product totals are all positive.*/
     /* ******************************************/

  if (CL0LW03.CLICRDFL[sysVar.arrayIndex] == "C" /* if size exists*/
   || CL0LW03.CLICRDFL[sysVar.arrayIndex] == "D")
    if (CL0LW03.CLICRDFL[sysVar.arrayIndex] == "C")
      CL0LW01.CL0LWQTY = CL0LW03.CLRRQTQ[sysVar.arrayIndex] * -1;
    else
      CL0LW01.CL0LWQTY = CL0LW03.CLRRQTQ[sysVar.arrayIndex];
    end
    if (CL0LW03.CLICRDFL[sysVar.arrayIndex] == CL0LW02.CLICRDFL[CL0LWCAX]
     || CL0LW02.CLICRDFL[CL0LWCAX] == "B")
      CL0LW02.CLRRQTQ[CL0LWCAX] = CL0LW02.CLRRQTQ[CL0LWCAX] + CL0LWQTY;
    else
      CL0LW02.CLRRQTQ[CL0LWCAX] = CL0LW02.CLRRQTQ[CL0LWCAX] - CL0LWQTY;
    end

    if (CL0LW03.CLICRDFL[sysVar.arrayIndex] == "C")
      CL0LW01.CL0LWQTY = CL0LW03.CLRCLMQ[sysVar.arrayIndex] * -1;
    else
      CL0LW01.CL0LWQTY = CL0LW03.CLRCLMQ[sysVar.arrayIndex];
    end
    if (CL0LW03.CLICRDFL[sysVar.arrayIndex] == CL0LW02.CLICRDFL[CL0LWCAX]
     || CL0LW02.CLICRDFL[CL0LWCAX] == "B")
      CL0LW02.CLRCLMQ[CL0LWCAX] = CL0LW02.CLRCLMQ[CL0LWCAX] + CL0LWQTY;
    else
      CL0LW02.CLRCLMQ[CL0LWCAX] = CL0LW02.CLRCLMQ[CL0LWCAX] - CL0LWQTY;
    end
  end



end // end KL0LSST

// replicate credits or debits
Function KL0LSSY()

    /* **********************************************************/
    /* replicate all credits found at the product level and make*/
    /* them a debit by using the 'rc' code in the select field*/
    /* or replicate all debits found at the product level and*/
    /* make them a credit by using the 'rd' code in the select*/
    /* field.*/
    /* **********************************************************/


  if (CL0LW01.CL0LWNAX < CL0LW02.CL0LWASZ)
    /* next sentence*/
  else
    converseLib.validationFailed(412);
    return;
  end

  if (CL0LW02.CL0LMLVL[sysVar.arrayIndex] == "S")
    CL0LW02.CL0LMSEL[sysVar.arrayIndex] = "S";
    converseLib.validationFailed(413);
    return;
  end

  if (CL0LW02.CL0LMLVL[sysVar.arrayIndex] == "P")
    /* next sentence*/
  else
    return;
  end

  CL0LW01.CL0LWTSX = 1;

  while (CL0LW01.CL0LWTSX < CLXREC.CLXLSTAX)
    if (CL0LW02.SY1STNBR[CL0LWTSX] == CL0LW02.SY1STNBR[sysVar.arrayIndex]
     && CL0LW02.SY2CLRID[CL0LWTSX] == CL0LW02.SY2CLRID[sysVar.arrayIndex]
     && sysVar.arrayIndex != CL0LW01.CL0LWTSX)
      if (CL0LW01.CL0LMSEL == "RC")
        if (CL0LW02.CLICRDFL[CL0LWTSX] == "D")
          CL0LW01.CL0LWTSX = 9000;
        end
      else
        if (CL0LW01.CL0LMSEL == "RD")
          if (CL0LW02.CLICRDFL[CL0LWTSX] == "C")
            CL0LW01.CL0LWTSX = 9000;
          end
        end
      end
    end
    CL0LW01.CL0LWTSX = CL0LW01.CL0LWTSX + 1;
  end

  if (CL0LW01.CL0LWTSX >= 9000)
    return;
  end

  if (CL0LW01.CL0LMSEL == "RC")
    CL0LW02.CLICRDFL[CL0LWNAX] = "D";
  else
    if (CL0LW01.CL0LMSEL == "RD")
      CL0LW02.CLICRDFL[CL0LWNAX] = "C";
    end
  end

  CL0LW02.CL0LWCHF[CL0LWNAX] = "A";
  CL0LW02.CL0LMSEL[CL0LWNAX] = " ";
  CL0LW02.ZZZCHGCT[CL0LWNAX] = 0;
  CL0LW02.SY5SZID[CL0LWNAX] = 0;
  CL0LW02.CL0LMLVL[CL0LWNAX] = "P";
  CL0LW02.CL0LWUSI[CL0LWNAX] = CL0LW02.CL0LWUSI[sysVar.arrayIndex];
  CL0LW02.XGPCD[CL0LWNAX] = CL0LW02.XGPCD[sysVar.arrayIndex];
  CL0LW02.SY1STNBR[CL0LWNAX] = CL0LW02.SY1STNBR[sysVar.arrayIndex];
  CL0LW02.SY2CLRID[CL0LWNAX] = CL0LW02.SY2CLRID[sysVar.arrayIndex];
  CL0LW02.XDMCD[CL0LWNAX] = CL0LW02.XDMCD[sysVar.arrayIndex];
  CL0LW02.OP2LNINB[CL0LWNAX] = CL0LW02.OP2LNINB[sysVar.arrayIndex];
  CL0LW02.KUIPRDID[CL0LWNAX] = CL0LW02.KUIPRDID[sysVar.arrayIndex];
  CL0LW02.XQACD[CL0LWNAX] = CL0LW02.XQACD[sysVar.arrayIndex];
  CL0LW02.XUMCD[CL0LWNAX] = CL0LW02.XUMCD[sysVar.arrayIndex];
  CL0LW02.XPYCD[CL0LWNAX] = CL0LW02.XPYCD[sysVar.arrayIndex];
  CL0LW02.XCOCD[CL0LWNAX] = CL0LW02.XCOCD[sysVar.arrayIndex];
  CL0LW02.IV3LNSQ[CL0LWNAX] = CL0LW02.IV3LNSQ[sysVar.arrayIndex];
  CL0LW02.IV3GLNUP[CL0LWNAX] = CL0LW02.IV3GLNUP[sysVar.arrayIndex];
  CL0LW02.OP2PRCVF[CL0LWNAX] = CL0LW02.OP2PRCVF[sysVar.arrayIndex];

  if (CL0LW01.CL0LMSEL == "RC")
    if (CL0LW02.CLAESTVL[sysVar.arrayIndex] > 0)
      CL0LW02.CLAESTVL[CL0LWNAX] = CL0LW02.CLAESTVL[sysVar.arrayIndex];
    else
      CL0LW02.CLAESTVL[CL0LWNAX] = CL0LW02.CLAESTVL[sysVar.arrayIndex] * -1;
    end
    if (CL0LW02.CLRRQTQ[sysVar.arrayIndex] > 0)
      CL0LW02.CLRRQTQ[CL0LWNAX] = CL0LW02.CLRRQTQ[sysVar.arrayIndex];
    else
      CL0LW02.CLRRQTQ[CL0LWNAX] = CL0LW02.CLRRQTQ[sysVar.arrayIndex] * -1;
    end
    if (CL0LW02.CLRCLMQ[sysVar.arrayIndex] > 0)
      CL0LW02.CLRCLMQ[CL0LWNAX] = CL0LW02.CLRCLMQ[sysVar.arrayIndex];
    else
      CL0LW02.CLRCLMQ[CL0LWNAX] = CL0LW02.CLRCLMQ[sysVar.arrayIndex] * -1;
    end
  else
    if (CL0LW01.CL0LMSEL == "RD")
      CL0LW02.CLAESTVL[CL0LWNAX] = CL0LW02.CLAESTVL[sysVar.arrayIndex];
      CL0LW02.CLRRQTQ[CL0LWNAX] = CL0LW02.CLRRQTQ[sysVar.arrayIndex];
      CL0LW02.CLRCLMQ[CL0LWNAX] = CL0LW02.CLRCLMQ[sysVar.arrayIndex];
    end
  end

  CL0LW02.CLKPRCFF[CL0LWNAX] = CL0LW02.CLKPRCFF[sysVar.arrayIndex];
  CL0LW02.CLNGRPRC[CL0LWNAX] = CL0LW02.CLNGRPRC[sysVar.arrayIndex];
  CL0LW02.CLNNTPRC[CL0LWNAX] = CL0LW02.CLNNTPRC[sysVar.arrayIndex];
  CL0LW01.CL0LWTSH[1] = CL0LW01.CL0LWTSH[1] + CL0LW02.IV3LNSQ[CL0LWNAX];

  CL0LW01.CL0LWNAX = CL0LW01.CL0LWNAX + 1;

end // end KL0LSSY

// replicate credits or debits
Function KL0LSSZ()

    /* *********************************************************/
    /* replicate all credits found at the size level and make*/
    /* them a debit by using the 'rc' code in the select field*/
    /* or replicate all debits found at the size level and make*/
    /* them a credit by using the 'rd' code in the select field.*/
    /* *********************************************************/


  if (CL0LW01.CL0LWNSZ < CL0LW03.CL0LWASZ)
    /* next sentence*/
  else
    converseLib.validationFailed(412);
    return;
  end

  CL0LW01.CL0LWTSX = 1;

  while (CL0LW01.CL0LWTSX < CLXREC.CLXLSTSZ)
    if (CL0LW03.SY5SZID[CL0LWTSX] == CL0LW03.SY5SZID[sysVar.arrayIndex]
     && sysVar.arrayIndex != CL0LW01.CL0LWTSX)
      if (KL0LM010.CL0LMSEL[CLXLINEX] == "RC")
        if (CL0LW03.CLICRDFL[CL0LWTSX] == "D")
          CL0LW01.CL0LWTSX = 9000;
        end
      else
        if (KL0LM010.CL0LMSEL[CLXLINEX] == "RD")
          if (CL0LW03.CLICRDFL[CL0LWTSX] == "C")
            CL0LW01.CL0LWTSX = 9000;
          end
        end
      end
    end
    CL0LW01.CL0LWTSX = CL0LW01.CL0LWTSX + 1;
  end

  if (CL0LW01.CL0LWTSX >= 9000)
    return;
  end

  if (KL0LM010.CL0LMSEL[CLXLINEX] == "RC")
    CL0LW03.CLICRDFL[CL0LWNSZ] = "D";
  else
    if (KL0LM010.CL0LMSEL[CLXLINEX] == "RD")
      CL0LW03.CLICRDFL[CL0LWNSZ] = "C";
    end
  end

  CL0LW03.CL0LWCHF[CL0LWNSZ] = "A";
  CL0LW03.CL0LMSEL[CL0LWNSZ] = " ";
  CL0LW03.ZZZCHGCT[CL0LWNSZ] = 0;
  CL0LW03.SY5SZID[CL0LWNSZ] = CL0LW03.SY5SZID[sysVar.arrayIndex];
  CL0LW03.SY4IDDSC[CL0LWNSZ] = CL0LW03.SY4IDDSC[sysVar.arrayIndex];
  CL0LW03.IV4SHPQ[CL0LWNSZ] = CL0LW03.IV4SHPQ[sysVar.arrayIndex];
  CL0LW03.IV4GUP[CL0LWNSZ] = CL0LW03.IV4GUP[sysVar.arrayIndex];
  CL0LW03.CLRRQTQ[CL0LWNSZ] = CL0LW03.CLRRQTQ[sysVar.arrayIndex];
  CL0LW03.CLRCLMQ[CL0LWNSZ] = CL0LW03.CLRCLMQ[sysVar.arrayIndex];
  CL0LW03.CLKPRCFF[CL0LWNSZ] = CL0LW03.CLKPRCFF[sysVar.arrayIndex];
  CL0LW03.CLNGRPRC[CL0LWNSZ] = CL0LW03.CLNGRPRC[sysVar.arrayIndex];
  CL0LW03.CLNNTPRC[CL0LWNSZ] = CL0LW03.CLNNTPRC[sysVar.arrayIndex];
  CL0LW01.CL0LWTSH[2] = CL0LW01.CL0LWTSH[2] + CL0LW03.IV4SHPQ[CL0LWNSZ];

  CL0LW01.CL0LWNSZ = CL0LW01.CL0LWNSZ + 1;

end // end KL0LSSZ

// check price override to update
Function KL0LSUO()


    /* Maintenance History:*/
    /* 04-10-90 CHELLM Added XQACD and XUMCD to the product key*/
                    /* when selecting invoice price overrides.*/

    /* 10-22-97 RCHAUV reason code conversion - no more S10*/
   /* *****************************************************************/

  CLXREC.CLXCPROC = "CL0LSUO";

  SQLCA.VAGen_SQLCODE = 0;

  if (CLRREC.CLICRDFL == "C"
   && CLRREC.CLKPRCFF != "I"
   && CLRREC.CLKPRCFF != "O")
    KL0LSDO(); /* check override price for delete*/
    return;
  end

  if (CLRREC.CLICRDFL == "D"
   && CLRREC.CLKPRCFF != "E"
   && CLRREC.CLKPRCFF != "P")
    KL0LSDO(); /* check override price for delete*/
    return;
  end

  if (CL0LW01.CL0LWPFL == "Y")
    CL6REC.IV0PARTN = CLRREC.IV0PARTN;
    CL6REC.IV0IVCID = CLRREC.IV0IVCID;
    CL6REC.XGPCD = CLRREC.XGPCD;
    CL6REC.SY1STNBR = CLRREC.SY1STNBR;
    CL6REC.SY2CLRID = CLRREC.SY2CLRID;
    CL6REC.XDMCD = CLRREC.XDMCD;
    CL6REC.XQACD = CLRREC.XQACD;
    CL6REC.XUMCD = CLRREC.XUMCD;
    CL6REC.SY5SZID = CLRREC.SY5SZID;
    CL6REC.CLACLMNB = CLRREC.CLACLMNB;

    call "IO2950" ("S ", SQLCA, CL6REC) {isNoRefresh = yes, isExternal = yes};

    if (SQLCA.VAGen_SQLCODE == 0)
      /* next sentence*/
    else
      if (SQLCA.VAGen_SQLCODE == 100)
        /* next sentence*/
      else
        if (SQLCA.VAGen_SQLCODE == -911)
          converseLib.validationFailed(4);
          CLXREC.CLXERRF = "Y";
          VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
          VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
          sysLib.rollback();
          VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
          
          return;
        else
          TA1REC.TA1LOCAT[2] = "CL0LSUO";
          TA1REC.TA1LOCAT[4] = "IO2950";
          TA1REC.TA1DBASE = "DCLAIM";
          TA1REC.TA1TBLVU = "VIVOVR01";
          CLXREC.XXXWDTE = CLAREC.CLACLMNB;
          TA1REC.TA1TBLKE = CLXREC.XXXWDTE;
          XPCL010();
        end
      end
    end
  end

  if (SQLCA.VAGen_SQLCODE == 100
   || CL0LW01.CL0LWPFL != "Y")
    set CL6REC empty;
    CL6REC.IV0PARTN = CLRREC.IV0PARTN;
    CL6REC.IV0IVCID = CLRREC.IV0IVCID;
    CL6REC.XGPCD = CLRREC.XGPCD;
    CL6REC.SY1STNBR = CLRREC.SY1STNBR;
    CL6REC.SY2CLRID = CLRREC.SY2CLRID;
    CL6REC.XDMCD = CLRREC.XDMCD;
    CL6REC.XQACD = CLRREC.XQACD;
    CL6REC.XUMCD = CLRREC.XUMCD;
    CL6REC.SY5SZID = CLRREC.SY5SZID;
    CL6REC.CLACLMNB = CLRREC.CLACLMNB;
    if (CLXREC.CLXSCRNX != 3)
      if (CLRREC.CLICRDFL == "C"
       && CLRREC.CLKPRCFF == "I")
        CL0LW01.CLICRDFL = "D";
        CL0LW01.XGPCD = CLRREC.XGPCD;
        CL0LW01.SY1STNBR = CLRREC.SY1STNBR;
        CL0LW01.SY2CLRID = CLRREC.SY2CLRID;
        CL0LW01.XDMCD = CLRREC.XDMCD;
        CL0LW01.XQACD = CLRREC.XQACD;
        CL0LW01.XUMCD = CLRREC.XUMCD;
        CL0LW01.CLKPRCFF = "E";
        if (CL0LW01.CL0LWKEY in CL0LW02.CL0LWKEY)
          CL0LW01.CL6OVPRC = CL0LW02.CLNGRPRC[sysVar.arrayIndex];
          KL0LSAO(); /* add price override*/
        end
      else
        if (CLRREC.CLICRDFL == "D")
          if (CLRREC.CLKPRCFF == "E"
           || CLRREC.CLKPRCFF == "P")
            CL0LW01.CLICRDFL = "C";
            CL0LW01.XGPCD = CLRREC.XGPCD;
            CL0LW01.SY1STNBR = CLRREC.SY1STNBR;
            CL0LW01.SY2CLRID = CLRREC.SY2CLRID;
            CL0LW01.XDMCD = CLRREC.XDMCD;
            CL0LW01.XQACD = CLRREC.XQACD;
            CL0LW01.XUMCD = CLRREC.XUMCD;
            CL0LW01.CLKPRCFF = "I";
             /* IF CLAREC.YCRCD EQ 'S10'    /**/
                                      /* 10/30/97 NO MORE S10 rchauv*/
             /* IF CL0LW01.CL0LWKEY IN CL0LW02.CL0LWKEY;*/
             /* MOVE CLRREC.CLNGRPRC TO CL0LW01.CL6OVPRC;*/
             /* KL0LSAO;             /* add price override*/
             /* ELSE;*/
               /* MOVE 'O' TO CL0LW01.CLKPRCFF;*/
               /* IF CL0LW01.CL0LWKEY IN CL0LW02.CL0LWKEY;*/
               /* MOVE CLRREC.CLNGRPRC TO CL0LW01.CL6OVPRC;*/
               /* KL0LSAO;           /* add price override*/
               /* END;*/
             /* END;*/
          end
        end
      end
    else
      if (CLRREC.CLICRDFL == "C"
       && CLRREC.CLKPRCFF == "I")
        CL0LW01.CL0LWCDF = "D";
        CL0LW01.CL0LWSIZ = CLRREC.SY5SZID;
        CL0LW01.CL0LWPFF = "E";
        if (CL0LW01.CL0LWKY3 in CL0LW03.CL0LWKY3)
          CL0LW01.CL6OVPRC = CL0LW03.CLNGRPRC[sysVar.arrayIndex];
          KL0LSAO(); /* add price override*/
        end
      else
        if (CLRREC.CLICRDFL == "D")
          if (CLRREC.CLKPRCFF == "E"
           || CLRREC.CLKPRCFF == "P")
            CL0LW01.CL0LWCDF = "C";
            CL0LW01.CL0LWSIZ = CLRREC.SY5SZID;
            CL0LW01.CL0LWPFF = "I";
             /* IF CLAREC.YCRCD EQ 'S10' /**/
                                   /* 10/30/97 NO MORE S10 rchauv*/
             /* IF CL0LW01.CL0LWKY3 IN CL0LW03.CL0LWKY3;*/
             /* MOVE CLRREC.CLNGRPRC TO CL0LW01.CL6OVPRC;*/
             /* KL0LSAO;             /* add price override*/
             /* ELSE;*/
               /* MOVE 'O' TO CL0LW01.CL0LWPFF;*/
               /* IF CL0LW01.CL0LWKY3 IN CL0LW03.CL0LWKY3;*/
               /* MOVE CLRREC.CLNGRPRC TO CL0LW01.CL6OVPRC;*/
               /* KL0LSAO;           /* add price override*/
               /* END;*/
             /* END;*/
          end
        end
      end
    end
    return;
  end


  if (CL6REC.CLHMEMNB > 0) /* override is not pending*/
    return;
  end

  CL6REC.CL6OVPRC = CLRREC.CLNGRPRC;

  CL6REC.ZZZCHGDT = TA2REC.TA2GRGGN;
  CL6REC.ZZZCHGTM = TA2REC.TA2TIMHM;

  call "IO2950" ("U ", SQLCA, CL6REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  else
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4);
      CLXREC.CLXERRF = "Y";
      VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
      VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
      sysLib.rollback();
      VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
      
      return;
    else
      TA1REC.TA1LOCAT[2] = "CL0LSUO";
      TA1REC.TA1LOCAT[4] = "IO2950";
      TA1REC.TA1DBASE = "DCLAIM";
      TA1REC.TA1TBLVU = "VIVOVR01";
      CLXREC.XXXWDTE = CLAREC.CLACLMNB;
      TA1REC.TA1TBLKE = CLXREC.XXXWDTE;
      XPCL010();
    end
  end

end // end KL0LSUO

// update clm adj record
Function KL0LSUP()
   /* ************************************************/
   /* *  update data base by changing existing record*/
   /* ************************************************/
   /* MAINTNENACE HISTORY*/
   /* 01-13-92  sgorga  Set ta2rec empty.*/
   /* ************************************************/

     /* *********************************/
     /* mark need to change claim header*/
     /* *********************************/

  TA1REC.TA1LOCAT[2] = "CL0LSUP";
  CL0LW01.CL0LWAUP = "Y"; /* flag clm hdr for update*/

  CL0LW01.CLADJIND = "Y"; /* turn on 'have adjust' flag*/


      /* *******************************************/
      /* move key data to clrrec, incl change count*/
      /* *******************************************/

  CLRREC.CLACLMNB = CLAREC.CLACLMNB; /* claim number*/
  CLRREC.CLHSEQNB = CLAREC.CLACSQNB; /* sequence number*/
  CLRREC.IV0PARTN = CL0LW02.IV0PARTN; /* invoice nbr*/
  CLRREC.IV0IVCID = CL0LW02.IV0IVCID;

  CLRREC.XGPCD = CLAREC.XGPCD;
  if (CLXREC.CLXSCRNX != 3) /* diff moves for maps*/
    CLRREC.CLICRDFL = CL0LW02.CLICRDFL[CLXARAYX]; /* cr or db*/
    CLRREC.SY1STNBR = CL0LW02.SY1STNBR[CLXARAYX];
    CLRREC.SY2CLRID = CL0LW02.SY2CLRID[CLXARAYX];
    CLRREC.XDMCD = CL0LW02.XDMCD[CLXARAYX];
    CLRREC.SY5SZID = CL0LW02.SY5SZID[CLXARAYX];
    CLRREC.OP2LNINB = CL0LW02.OP2LNINB[CLXARAYX];
    CLRREC.ZZZCHGCT = CL0LW02.ZZZCHGCT[CLXARAYX];
  else
    CLRREC.CLICRDFL = CL0LW03.CLICRDFL[CLXCURSZ]; /* cr or db*/
    CLRREC.SY1STNBR = CL0LW02.SY1STNBR[CL0LWCAX];
    CLRREC.SY2CLRID = CL0LW02.SY2CLRID[CL0LWCAX];
    CLRREC.XDMCD = CL0LW02.XDMCD[CL0LWCAX];
    CLRREC.SY5SZID = CL0LW03.SY5SZID[CLXCURSZ];
    CLRREC.OP2LNINB = CL0LW02.OP2LNINB[CL0LWCAX];
    CLRREC.ZZZCHGCT = CL0LW03.ZZZCHGCT[CLXCURSZ];
  end


     /* *************************************/
     /* check for cr/db to mark claim header*/
     /* *************************************/

  if (CLRREC.CLICRDFL == "D") /* if debit entry*/
    if (CL0LW01.CLADBOCL == "N") /* and clm hdr not marked*/
      CL0LW01.CLADBOCL = "Y"; /* mark claim header*/
    end
  end

   /* move in clrrec data*/
  if (CLXREC.CLXSCRNX != 3)
    CLRREC.XQACD = CL0LW02.XQACD[CLXARAYX];
    CLRREC.XUMCD = CL0LW02.XUMCD[CLXARAYX];
    CLRREC.XCOCD = CL0LW02.XCOCD[CLXARAYX];

    CLRREC.CLNGRPRC = CL0LW02.CLNGRPRC[CLXARAYX];
    CLRREC.CLNNTPRC = CL0LW02.CLNNTPRC[CLXARAYX];
    CLRREC.CLKPRCFF = CL0LW02.CLKPRCFF[CLXARAYX];
    if (CL0LW02.CLRRQTQ[CLXARAYX] < 0)
      CLRREC.CLRRQTQ = CL0LW02.CLRRQTQ[CLXARAYX] * -1;
    else
      CLRREC.CLRRQTQ = CL0LW02.CLRRQTQ[CLXARAYX];
    end
    if (CL0LW02.CLRCLMQ[CLXARAYX] < 0)
      CLRREC.CLRCLMQ = CL0LW02.CLRCLMQ[CLXARAYX] * -1;
    else
      CLRREC.CLRCLMQ = CL0LW02.CLRCLMQ[CLXARAYX];
    end
    CL0LW02.ZZZCHGCT[CLXARAYX] = CL0LW02.ZZZCHGCT[CLXARAYX] + 1;
  else
    CLRREC.XQACD = CL0LW02.XQACD[CL0LWCAX];
    CLRREC.XUMCD = CL0LW02.XUMCD[CL0LWCAX];
    CLRREC.XCOCD = CL0LW02.XCOCD[CL0LWCAX];

    CLRREC.CLNGRPRC = CL0LW03.CLNGRPRC[CLXCURSZ];
    CLRREC.CLNNTPRC = CL0LW03.CLNNTPRC[CLXCURSZ];
    CLRREC.CLKPRCFF = CL0LW03.CLKPRCFF[CLXCURSZ];
    CLRREC.CLRRQTQ = CL0LW03.CLRRQTQ[CLXCURSZ];
    CLRREC.CLRCLMQ = CL0LW03.CLRCLMQ[CLXCURSZ];
    if (CL0LW03.CLNGRPRC[CLXCURSZ] != CL0LW02.CLNGRPRC[CL0LWCAX]
     /* AND CL0LW03.CLNNTPRC(CLXCURSZ) NE CL0LW02.CLNNTPRC(CL0LWCAX)*/
     && CL0LW02.CLNGRPRC[CL0LWCAX] != 0)
       /* AND CL0LW02.CLNNTPRC(CL0LWCAX) NE 0;*/
      CL0LW02.OP2PRCVF[CL0LWCAX] = "Y";
    end
    CL0LW03.ZZZCHGCT[CLXCURSZ] = CL0LW03.ZZZCHGCT[CLXCURSZ] + 1;
  end

  set TA2REC empty;
  TA2REC.TA2RTNCD = 0; /* get curr date/time*/
  TA2REC.TA2DTOPT = "GETDATE";
  call "TA0040" (TA2REC) {isNoRefresh = yes, isExternal = yes};
  if (TA2REC.TA2RTNCD == 0)
    CLRREC.ZZZCHGDT = TA2REC.TA2GRGGN;
    CLRREC.ZZZCHGTM = TA2REC.TA2TIMHM;
  else
    CLRREC.ZZZCHGDT = 0;
    CLRREC.ZZZCHGTM = 0;
  end

  call "IO1370" ("U ", SQLCA, CLRREC) {isNoRefresh = yes, isExternal = yes}; /* replace record*/
  if (SQLCA.VAGen_SQLCODE == 0)
    KL0LSUO(); /* check price override*/
    if (CLXREC.CLXERRF == "Y")
      return;
    end
  else
    if (SQLCA.VAGen_SQLCODE == -911)
      converseLib.validationFailed(4); /* deadlock, retry action*/
      CLXREC.CLXERRF = "Y";
      VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
      VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
      sysLib.rollback();
      VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
      
      return;
    else

       /* ***********************************************/
       /* check for change count error or missing record*/
       /* ***********************************************/
      call "IO1370" ("S ", SQLCA, CLRREC) {isNoRefresh = yes, isExternal = yes}; /* is record there?*/
      if (SQLCA.VAGen_SQLCODE == 0)
        if (CL0LW01.CL0LWALL == "Y") /* if changing all records*/
           /* cant show map error, since not in sync*/
          TA1REC.TA1DBASE = "DCLAIM";
          TA1REC.TA1TBLVU = "VCLADJ01";
          XPCL010(); /* abend*/
        end

        converseLib.validationFailed(18); /* data base changed by another user*/
        CLXREC.CLXERRF = "Y";
        VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
        VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
        sysLib.rollback();
        VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value

        if (CLXREC.CLXSCRNX != 3)
          CL0LW02.CL0LWCHF[CLXARAYX] = "N"; /* reset change flag*/
          set KL0LM001.SY1STNBR[CL0LWINX] cursor, modified, bold;
          if (KL0LM001.SY2CLRID[CL0LWINX] != " ")
            set KL0LM001.SY2CLRID[CL0LWINX] modified, bold;
          end
          if (KL0LM001.XDMCD[CL0LWINX] != " ")
            set KL0LM001.XDMCD[CL0LWINX] modified, bold;
          end
           /* move to array(arayx), see cl0lsp5*/
          CL0LW02.ZZZCHGCT[CLXARAYX] = CLRREC.ZZZCHGCT;
          CL0LW02.SY5SZID[CLXARAYX] = CLRREC.SY5SZID;
          CL0LW02.XQACD[CLXARAYX] = CLRREC.XQACD;
          CL0LW02.XUMCD[CLXARAYX] = CLRREC.XUMCD;
          CL0LW02.CLNGRPRC[CLXARAYX] = CLRREC.CLNGRPRC;
          CL0LW02.CLNNTPRC[CLXARAYX] = CLRREC.CLNNTPRC;
          CL0LW02.CLRCLMQ[CLXARAYX] = CLRREC.CLRCLMQ;
          CL0LW02.CLICRDFL[CLXARAYX] = CLRREC.CLICRDFL;
          CL0LW02.XGPCD[CLXARAYX] = CLRREC.XGPCD;
          CL0LW02.CLKPRCFF[CLXARAYX] = CLRREC.CLKPRCFF;
          CL0LW02.CLRRQTQ[CLXARAYX] = CLRREC.CLRRQTQ;

          if (CLRREC.SY5SZID == 0)
            CL0LW02.CL0LMLVL[CLXARAYX] = "P"; /* worked at prod lvl*/
          else
            CL0LW02.CL0LMLVL[CLXARAYX] = "S"; /* worked at size lvl*/
          end

           /* MOVE ARYAX TO MAP(WINX), for just 1 line*/
          if (CLXREC.CLXSCRNX == 1)
            KL0LS30(); /* move data to one map line*/
          else
            KL0LS40(); /* move data to map 5 line*/
          end
        else
          CL0LW03.CL0LWCHF[CLXCURSZ] = "N"; /* reset change flag*/
          set KL0LM010.SY4IDDSC[CL0LWINX] cursor, modified, bold;
           /* move to array(arayx), see cl0lsd3*/
          CL0LW03.ZZZCHGCT[CLXCURSZ] = CLRREC.ZZZCHGCT;
          CL0LW03.SY5SZID[CLXCURSZ] = CLRREC.SY5SZID;
          CL0LW03.CLRRQTQ[CLXCURSZ] = CLRREC.CLRRQTQ;
          CL0LW03.CLRCLMQ[CLXCURSZ] = CLRREC.CLRCLMQ;
          CL0LW03.CLKPRCFF[CLXCURSZ] = CLRREC.CLKPRCFF;
          CL0LW03.CLNGRPRC[CLXCURSZ] = CLRREC.CLNGRPRC;
          CL0LW03.CLNNTPRC[CLXCURSZ] = CLRREC.CLNNTPRC;
          CL0LW03.CLICRDFL[CLXCURSZ] = CLRREC.CLICRDFL;

           /* MOVE cursz TO MAP(WINX), for just 1 line*/
          KL0LS50(); /* move data to map 10 line*/
        end
      else
        if (SQLCA.VAGen_SQLCODE == -911)
          converseLib.validationFailed(4); /* deadlock, retry action*/
          CLXREC.CLXERRF = "Y";
          VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
          VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
          sysLib.rollback();
          VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
          
        else
           /* *****************************/
           /* product not found, so add it*/
           /* *****************************/
          KL0LSAD();
        end
      end
    end
  end



end // end KL0LSUP

//*** RECORD=CL0LW01 ****
// claims adjustment program main working storage
// 
// used to hold values and flags during map processing
// 
// 04-10-90  Added xumcd and xqacd to the cl0lwkey product key.
// chellm
// 
// ***********************
Record CL0LW01 type basicRecord
  10 CL0LWKEY CL0LWKEY ; 
    20 CLICRDFL CLICRDFL ; 
    20 XGPCD XGPCD ; 
    20 SY1STNBR SY1STNBR ; 
    20 SY2CLRID SY2CLRID ; 
    20 XDMCD XDMCD ; 
    20 XQACD XQACD ; 
    20 XUMCD XUMCD ; 
    20 CLKPRCFF CLKPRCFF ; 
  10 CL0LWKY3 CL0LWKY3 ; 
    20 CL0LWCDF CL0LWCDF ; 
    20 CL0LWSIZ CL0LWSIZ ; 
    20 CL0LWPFF CL0LWPFF ; 
  10 CL0LWINQ CL0LWINQ ; 
  10 CL0LWSWZ CL0LWSWZ ; 
  10 CL0LWPCE CL0LWPCE ; 
  10 CL0LWVAR CL0LWVAR ; 
  10 CLHMEMNB CLHMEMNB ; 
  10 CL0LWEOF CL0LWEOF ; 
  10 CL6OVPRC CL6OVPRC ; 
  10 CL0LW1PR CL0LW1PR ; 
  10 CLACSQNB CLACSQNB ; 
  10 CL0LWPFL CL0LWPFL ; 
  10 CL0LWLST CL0LWLST ; 
  10 CL0LWNSZ CL0LWNSZ ; 
  10 CL0LWNAX CL0LWNAX ; 
  10 CL0LWFST CL0LWFST ; 
  10 CL0LWEXT CL0LWEXT ; 
  10 CL0LWIEF CL0LWIEF ; 
  10 CL0LWMAT CL0LWMAT ; 
  10 CL0LWVP CL0LWVP ; 
  10 CL0LWPEF CL0LWPEF ; 
  10 CL0LWESP CL0LWESP ; 
  10 CL0LWUPD CL0LWUPD ; 
  10 CL0LWAUP CL0LWAUP ; 
  10 CL0LWBUP CL0LWBUP ; 
  10 CL0LWDEL CL0LWDEL ; 
  10 CLADBOCL CLADBOCL ; 
  10 CLADJIND CLADJIND ; 
  10 CLBSRIND CLBSRIND ; 
  10 CL0LWDNE CL0LWDNE ; 
  10 CL0LWFIN CL0LWFIN ; 
  10 CL0LWSHP CL0LWSHP [11] ; 
  10 CL0LWINX CL0LWINX ; 
  10 CL0LWIND CL0LWIND ; 
  10 CL0LWTSX CL0LWTSX ; 
  10 CL0LWIEX CL0LWIEX ; 
  10 CL0LWSUB CL0LWSUB ; 
  10 CL0LWCAX CL0LWCAX ; 
  10 CL0LWVCH CL0LWVCH ; 
  10 CL0LWQCH CL0LWQCH ; 
  10 CLAESTVL CLAESTVL ; 
  10 CLNGRPRC CLNGRPRC ; 
  10 CLNNTPRC CLNNTPRC ; 
  10 CL0LWPRC CL0LWPRC ; 
  10 CL0LWALL CL0LWALL ; 
  10 CL0LWHLD CL0LWHLD ; 
  10 CL0LWEND CL0LWEND ; 
  10 CL0LWPED CL0LWPED ; 
  10 CL0LWPRX CL0LWPRX ; 
  10 CL0LWSYC CL0LWSYC ; 
  10 SY4SZSCL SY4SZSCL ; 
  10 IV0IVCID IV0IVCID ; 
  10 YITCD YITCD ; 
  10 CL0LWIVC CL0LWIVC ; 
  10 CL0LWECV CL0LWECV ; 
  10 CL0LWEV CL0LWEV ; 
  10 CL0LWIDX CL0LWIDX ; 
  10 CL0LWCLQ CL0LWCLQ ; 
  10 CL0LWQY1 CL0LWQY1 ; 
  10 CL0LWQY2 CL0LWQY2 ; 
  10 CL0LWPRI CL0LWPRI ; 
  10 CL0LMSEL CL0LMSEL ; 
  10 CL0LWXOT CL0LWXOT ; 
  10 CL0LWHVC CL0LWHVC ; 
  10 CL0LWHVD CL0LWHVD ; 
  10 CL0LWSTP CL0LWSTP ; 
  10 CL0LWCLP CL0LWCLP ; 
  10 SP5SZPR SP5SZPR ; 
  10 SY5SZID SY5SZID ; 
  10 SY4IDDSC SY4IDDSC ; 
    15 CL0LWSZN CL0LWSZN ; 
      20 CL0LWDGT CL0LWDGT [5] ; 
  10 CL0LWSID CL0LWSID ; 
  10 CL0LWPCP CL0LWPCP ; 
  10 XATCD XATCD ; 
  10 CL0LWQTY CL0LWQTY ; 
  10 CL0LWWRN CL0LWWRN [11] ; 
  10 CL0LWERR CL0LWERR [11] ; 
  10 CL0LWCHK CL0LWCHK [11] ; 
  10 CL0LWMOD CL0LWMOD [11] ; 
  10 CL0LWOLD CL0LWOLD [11] ; 
    15 CL0LWORQ CL0LWORQ ; 
    15 CL0LWOCQ CL0LWOCQ ; 
    15 CL0LWOVL CL0LWOVL ; 
  10 CL0LWTTL CL0LWTTL [2] ; 
    15 CL0LWTSH CL0LWTSH ; 
    15 CLRRQTQ CLRRQTQ ; 
    15 CLRCLMQ CLRCLMQ ; 
    15 CL0LWTVL CL0LWTVL ; 
  10 CL0LWTM1 CL0LWTM1 ; 
    15 CL0LWTHF CL0LWTHF ; 
    15 * char(1) ; 
    15 CL0LWTMF CL0LWTMF ; 
    15 * char(1) ; 
    15 CL0LWTSF CL0LWTSF ; 
  10 CL0LWTM2 CL0LWTM2 ; 
    15 CL0LWTM3 CL0LWTM3 ; 
      20 CL0LWTHL CL0LWTHL ; 
      20 CL0LWTML CL0LWTML ; 
    15 CL0LWTSL CL0LWTSL ; 
  10 CL0LWMM1 CL0LWMM1 ; 
  10 CL0LWSS1 CL0LWSS1 ; 
  10 CL0LWSQC CL0LWSQC ; 
  10 CL0LWCTR CL0LWCTR ; 
  10 CL0LW1WN CL0LW1WN [11] ; 
end // end CL0LW01

//*** RECORD=CL0LW02 ****
// ************************************************************
// 
// this is an array of data used for the product summary, map 1
// 
// the product summary processes one invoice at a time.
// since one invoice may contain only 200 products, this
// working-storage array occurs 200 times.
// 
// cl0lmsel = select column.  value may be:
//     s product selected, show detail sizes
//     x product deleted from claim
//     v product already viewed at the detail size level
// 
// cl0lwchf = change flag.  value may be:
//     c  product changed
//     a  product added
//    ' ' no action
// 
// Maintenance History:
// 
// 04-10-90 chellm  moved xqacd and xumcd to the product key
//                  CL0LWKEY.
// 03-13-92 sgorga  db2 chg.  added xbk-bk-sesn-cd and ob-bk-yr
//                  field.
// 04-17-92 sgorga  DB2 chg.  Added ob-bk-mo.
// 09-23-98 NJana   Change the product array size to 900
// ************************************************************
// ***********************
Record CL0LW02 type basicRecord
  10 IV0PARTN IV0PARTN ; 
  10 IV0IVCID IV0IVCID ; 
  10 IVANBLFL IVANBLFL ; 
  10 CL0LWASZ CL0LWASZ ; 
  10 CL0LWPAY CL0LWPAY [900] ; 
    15 CL0LWUSI CL0LWUSI ; 
    15 CL0LMLVL CL0LMLVL ; 
    15 CL0LMSEL CL0LMSEL ; 
    15 ZZZCHGCT ZZZCHGCT ; 
    15 CL0LWCHF CL0LWCHF ; 
    15 CL0LWKEY CL0LWKEY ; 
      20 CLICRDFL CLICRDFL ; 
      20 XGPCD XGPCD ; 
      20 SY1STNBR SY1STNBR ; 
      20 SY2CLRID SY2CLRID ; 
      20 XDMCD XDMCD ; 
      20 XQACD XQACD ; 
      20 XUMCD XUMCD ; 
      20 CLKPRCFF CLKPRCFF ; 
    15 XBK-BK-SESN-CD XBK-BK-SESN-CD ; 
    15 OP-BK-YR OP-BK-YR ; 
    15 OP-BK-MO OP-BK-MO ; 
    15 SY5SZID SY5SZID ; 
    15 OP2LNINB OP2LNINB ; 
    15 KUIPRDID KUIPRDID ; 
  10 CL0LW2GB CL0LW2GB [900] ; 
    15 XPYCD XPYCD ; 
    15 XCOCD XCOCD ; 
    15 IV3LNSQ IV3LNSQ ; 
    15 IV3GLNUP IV3GLNUP ; 
    15 CLRRQTQ CLRRQTQ ; 
    15 CLRCLMQ CLRCLMQ ; 
    15 CLNGRPRC CLNGRPRC ; 
    15 CLNNTPRC CLNNTPRC ; 
    15 OP2PRCVF OP2PRCVF ; 
    15 CLAESTVL CLAESTVL ; 
    15 CL0LWDLT CL0LWDLT ; 
end // end CL0LW02

//*** RECORD=CL0LW03 ****
// ************************************************************
// 
// this is an array of product sizes used for detail map 10.
// 
// the detail screen processes one product at a time.  since
// one product may contain up to 40 sizes, this array occurs
// 40 times.
// 
// the select code may be c, ca, d, da, or x to credit,
// credit all, debit, debit all, or cancel the size.
// 
// 
// ***********************
Record CL0LW03 type basicRecord
  10 CL0LWASZ CL0LWASZ ; 
  10 CL0LWDAY CL0LWDAY [80] ; 
    15 CL0LMSEL CL0LMSEL ; 
    15 ZZZCHGCT ZZZCHGCT ; 
    15 CL0LWCHF CL0LWCHF ; 
    15 CL0LWKY3 CL0LWKY3 ; 
      20 CLICRDFL CLICRDFL ; 
      20 SY5SZID SY5SZID ; 
      20 CLKPRCFF CLKPRCFF ; 
    15 SY4IDDSC SY4IDDSC ; 
    15 IV4SHPQ IV4SHPQ ; 
    15 IV4GUP IV4GUP ; 
    15 CLRRQTQ CLRRQTQ ; 
    15 CLRCLMQ CLRCLMQ ; 
    15 CLNGRPRC CLNGRPRC ; 
    15 CLNNTPRC CLNNTPRC ; 
    15 CL0LWDLT CL0LWDLT ; 
end // end CL0LW03

//*** RECORD=CL0LW04 ****
// ************************************************************
// * This record is used in the call to IO1370 with the 'SC'
// * option. This option returns a count of the records in
// * the DCLAIM.VCLADJ01 table (CLRREC) for the given claim
// * number. NO FUTHER FIELDS SHOULD BE ADDED TO THIS RECORD
// * unless IO1370 is changed.
// ************************************************************
// ***********************
Record CL0LW04 type basicRecord
  10 CL0LWOPT CL0LWOPT ; 
  10 CL0LWCNT CL0LWCNT ; 
  10 CL0LWIDR CL0LWIDR ; 
end // end CL0LW04

// cr/db level-Product/Size/unknw
DataItem CL0LMLVL char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// map selection code
DataItem CL0LMSEL char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// y/n first load of prod array
DataItem CL0LW1PR char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// warning flags
DataItem CL0LW1WN char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// product array segment-b
DataItem CL0LW2GB char(38)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// all prods/sizes changed(ca/da)
DataItem CL0LWALL char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// size of product or detail aray
DataItem CL0LWASZ smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// y/n clarec needs updating
DataItem CL0LWAUP char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// y/n clbrec needs updating
DataItem CL0LWBUP char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// current array index
DataItem CL0LWCAX smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// credit debit flag
DataItem CL0LWCDF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// change flag (y,a, or ' ')
DataItem CL0LWCHF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// check edit of style nbr
DataItem CL0LWCHK char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// default price by style,color
DataItem CL0LWCLP decimal(7,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// temp claim qty
DataItem CL0LWCLQ int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

DataItem CL0LWCNT int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// counts number of deletes
DataItem CL0LWCTR int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// detail size array ------------
DataItem CL0LWDAY char(42)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// y/n delete flag
DataItem CL0LWDEL char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// digit in size description
DataItem CL0LWDGT char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// delete flag
DataItem CL0LWDLT char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// y/n done with partial map info
DataItem CL0LWDNE char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// temp est claim value
DataItem CL0LWECV decimal(11,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// end of while loop
DataItem CL0LWEND smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// end switch
DataItem CL0LWEOF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// error switch
DataItem CL0LWERR char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// y/n end of selected products
DataItem CL0LWESP char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// temp est claim value
DataItem CL0LWEV decimal(11,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// counts blank lines on screen
DataItem CL0LWEXT smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// end of while loop flag
DataItem CL0LWFIN char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// first line of cl0lm001
DataItem CL0LWFST smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// hold index
DataItem CL0LWHLD smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// have Credit for product
DataItem CL0LWHVC char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// have Debit for product
DataItem CL0LWHVD char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Null indicator for DB2
DataItem CL0LWIDR smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// size index
DataItem CL0LWIDX smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// y/n invc/clm xref end of file
DataItem CL0LWIEF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// index
DataItem CL0LWIEX smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// index
DataItem CL0LWIND smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// y/n inquiry mode
DataItem CL0LWINQ char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// general purpose index
DataItem CL0LWINX smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// name used in cl0lse7 edit
DataItem CL0LWIVC int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// product key
DataItem CL0LWKEY char(19)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// size key
DataItem CL0LWKY3 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// last invoice processed
DataItem CL0LWLST int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// match last invoice
DataItem CL0LWMAT char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// mm
DataItem CL0LWMM1 num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// line modified flag
DataItem CL0LWMOD char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// next product array
DataItem CL0LWNAX smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// next size array
DataItem CL0LWNSZ smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// map old claim qty
DataItem CL0LWOCQ int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// map old values,use to calc chg
DataItem CL0LWOLD char(14)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem CL0LWOPT char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// map old cust requested qty
DataItem CL0LWORQ int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// map old value
DataItem CL0LWOVL decimal(11,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// product array ----------------
DataItem CL0LWPAY char(51)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// price
DataItem CL0LWPCE decimal(9,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// product price/cost pct
DataItem CL0LWPCP decimal(5,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// prod price effective date
DataItem CL0LWPED int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// y/n product end of file
DataItem CL0LWPEF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// price from flag
DataItem CL0LWPFF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// price overrride flag
DataItem CL0LWPFL char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// gross unit price
DataItem CL0LWPRC decimal(9,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// temp claim price
DataItem CL0LWPRI decimal(9,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// index to user selected prodct
DataItem CL0LWPRX smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// qty change, add db/cr clatqty
DataItem CL0LWQCH int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// used in calculations
DataItem CL0LWQTY decimal(11,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// temp qty
DataItem CL0LWQY1 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// temp qty
DataItem CL0LWQY2 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// shp qty changed flag
DataItem CL0LWSHP char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// size id (same as sy5szid)
DataItem CL0LWSID smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// size id
DataItem CL0LWSIZ smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// ezesqcod used in -911 retry
DataItem CL0LWSQC int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// ss
DataItem CL0LWSS1 num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// default price by style
DataItem CL0LWSTP decimal(7,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// prior index
DataItem CL0LWSUB smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// size switch
DataItem CL0LWSWZ char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// no sycrec,yes have,error readg
DataItem CL0LWSYC char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// size redefine numeric format
DataItem CL0LWSZN num(5)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// hh
DataItem CL0LWTHF char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// hh
DataItem CL0LWTHL num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// hh:mm:ss
DataItem CL0LWTM1 char(8)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// hhmmss
DataItem CL0LWTM2 num(6)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// hhmm
DataItem CL0LWTM3 num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// mm
DataItem CL0LWTMF char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// mm
DataItem CL0LWTML num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// ss
DataItem CL0LWTSF char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// map total invoice shipped qty
DataItem CL0LWTSH int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// ss
DataItem CL0LWTSL num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// index
DataItem CL0LWTSX smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// map 1(1) & 10(2) total fields
DataItem CL0LWTTL char(18)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// map total claim value
DataItem CL0LWTVL decimal(11,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// y/n claim prods need updating
DataItem CL0LWUPD char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// y/n use ivc for sizes,else clm
DataItem CL0LWUSI char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// price vary flag
DataItem CL0LWVAR char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// value chnge,add db/cr claestvl
DataItem CL0LWVCH decimal(11,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// y/n varying price
DataItem CL0LWVP char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// warning switch
DataItem CL0LWWRN char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// xottbl index
DataItem CL0LWXOT smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

