package gd0m;
import corpcom1.*;
import corpcom4.*;
import corpcom5.*;
import corpcom6.XMGDM;
import corpcom7.*;
import corpx1.*;
import corpx2.*;
import corpy2.*;
import corpz3.*;
import gd.common.*;
import ta.common.*;
//*** PROGRAM=GD0M ****
// 11-11-88  John Wood     added xssegtr logic
// 03-08-89  jwood         added ypptbl logic
// 05-16-89  vcowan        added xobtbl logic
// 04-10-90  jwood         added XBCTBL logic
// 01-15-91  vcowan        xsicd dropped from ysvtbl
// 06-15-91  vcowan        delete ycltbl & ylgtbl displays
// *********************
Program GD0M type textUIProgram //VAGen Info - main text program
  {
  includeReferencedFunctions = yes, allowUnqualifiedItemReferences = yes, 
  throwNrfEofExceptions = yes, handleHardIOErrors = no, V60ExceptionCompatibility = yes, 
  I4GLItemsNullable = no, textLiteralDefaultIsString = no, localSQLScope = yes, 
  inputRecord = COMMAREA, segmented = yes
  }

  // Data Declarations
  COMMAREA COMMAREA ; // record
  GD0MWBO GD0MWBO; // record
  GD0MWLE GD0MWLE; // record
  GD0MWOP GD0MWOP; // record
  GD0MWPD GD0MWPD; // record
  GD0MWPP GD0MWPP; // record
  GD0MWRT GD0MWRT; // record
  GD0MWSV GD0MWSV; // record
  GD0MWTT GD0MWTT; // record
  GD0MWTY GD0MWTY; // record
  GD3REC GD3REC; // record
  GD4REC GD4REC; // record
  GDWREC GDWREC; // record

  // VAGen Info - items needed for migration
  VAGen_EZESYS char(8);
  VAGen_EZEREPLY num(1);
  VAGen_EZE_WAIT_TIME bin(9,2);
  VAGen_EZE_ITEMLEN int;

  // Use Declarations
  use XGLTBL {deleteAfterUse = yes}; // table
  use XBCTBL; // table
  use XBOTBL {deleteAfterUse = yes}; // table
  use XLETBL; // table
  use XOBTBL {deleteAfterUse = yes}; // table
  use XOPTBL {deleteAfterUse = yes}; // table
  use XRTTBL {deleteAfterUse = yes}; // table
  use XSCTBL {deleteAfterUse = yes}; // table
  use XSSTBL {deleteAfterUse = yes}; // table
  use XTTTBL {deleteAfterUse = yes}; // table
  use YADTBL {deleteAfterUse = yes}; // table
  use YGRTBL {deleteAfterUse = yes}; // table
  use YPDTBL {deleteAfterUse = yes}; // table
  use YPPTBL {deleteAfterUse = yes}; // table
  use YSBTBL; // table
  use YSVTBL {deleteAfterUse = yes}; // table
  use YSYTBL {deleteAfterUse = yes}; // table
  use YTYTBL {deleteAfterUse = yes}; // table
  use XMGDM.XMGDM002 // form
   {
    pfKeyEquate = no
  };

  function main()
    // VAGen Info - initialization needed for migration
    VAGen_EZESYS = VGLib.getVAGSysType();
    GD0M100: GD0M100();

     /* *************************************************************/



    if (GDWICSP == "XRT") /* sales rep assoc. type*/
      goto GD0M130;
    end

    if (GDWICSP == "XSC") /* sales agency assoc. type*/
      goto GD0M150;
    end

    if (GDWICSP == "XSS") /* sales agency assoc. type*/
      goto GD0M170;
    end

    if (GDWICSP == "XTT") /* sales territory table*/
      goto GD0M190;
    end

    if (GDWICSP == "YAD") /* advertising pgm code table*/
      goto GD0M210;
    end


    if (GDWICSP == "XOP") /* ORDER TYPE PROFILDE CD TBLE*/
      goto GD0M230;
    end


    if (GDWICSP == "YTY")
      goto GD0M250;
    end


    if (GDWICSP == "YPD")
      goto GD0M270;
    end


    if (GDWICSP == "YSY")
      goto GD0M290;
    end


    if (GDWICSP == "YGR")
      goto GD0M310;
    end


    if (GDWICSP == "XBO")
      goto GD0M330;
    end




    if (GDWICSP == "YSV")
      goto GD0M370;
    end

    if (GDWICSP == "YPP")
      goto GD0M390;
    end

    if (GDWICSP == "XOB")
      goto GD0M410;
    end


    if (GDWICSP == "XBC")
      goto GD0M430;
    end


    if (GDWICSP == "XLE")
      goto GD0M450;
    end


    if (GDWICSP == "YSB")
      goto GD0M470;
    end

    goto GD0M130; /* fail safe catch*/

    GD0M130: GD0M130();
    goto GD0M140;
     /* ***********************************************************/



    GD0M140: GD0M140();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0M130.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0M140;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0M130; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0M140; /* recoverse map*/

      else

        goto GD0M130; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0M130; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0M130;

    end



    GD0M150: GD0M150();
    goto GD0M160;
     /* ***********************************************************/



    GD0M160: GD0M160();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0M150.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0M160;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0M150; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0M160; /* recoverse map*/

      else

        goto GD0M150; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0M150; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0M150;

    end



    GD0M170: GD0M170();
    goto GD0M180;
     /* ***********************************************************/



    GD0M180: GD0M180();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0M170.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0M180;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0M170; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0M180; /* recoverse map*/

      else

        goto GD0M170; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0M170; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0M170;

    end



    GD0M190: GD0M190();
    goto GD0M200;
     /* ***********************************************************/



    GD0M200: GD0M200();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0M190.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0M200;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0M190; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0M200; /* recoverse map*/

      else

        goto GD0M190; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0M190; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0M190;

    end



    GD0M210: GD0M210();
    goto GD0M220;
     /* ***********************************************************/



    GD0M220: GD0M220();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0M210.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0M220;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0M210; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0M220; /* recoverse map*/

      else

        goto GD0M210; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0M210; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0M210;

    end



    GD0M230: GD0M230();
    goto GD0M240;
     /* ***********************************************************/



    GD0M240: GD0M240();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0M230.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0M240;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0M230; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0M240; /* recoverse map*/

      else

        goto GD0M230; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0M230; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0M230;

    end



    GD0M250: GD0M250();
     /* GET GD0M.GD0M230*/
    goto GD0M260;
     /* ***********************************************************/



    GD0M260: GD0M260();
     /* GET GD0M.GD0M240*/

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0M250.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0M260;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0M250; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0M260; /* recoverse map*/

      else

        goto GD0M250; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0M250; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0M250;

    end



    GD0M270: GD0M270();
    goto GD0M280;
     /* ***********************************************************/



    GD0M280: GD0M280();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0M270.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0M280;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0M270; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0M280; /* recoverse map*/

      else

        goto GD0M270; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0M270; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0M270;

    end



    GD0M290: GD0M290();
    goto GD0M300;
     /* ***********************************************************/



    GD0M300: GD0M300();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0M290.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0M300;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0M290; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0M300; /* recoverse map*/

      else

        goto GD0M290; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0M290; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0M290;

    end



    GD0M310: GD0M310();
    goto GD0M320;
     /* ***********************************************************/



    GD0M320: GD0M320();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0M310.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0M320;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0M310; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0M320; /* recoverse map*/

      else

        goto GD0M310; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0M310; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0M310;

    end



    GD0M330: GD0M330();
    goto GD0M340;
     /* ***********************************************************/



    GD0M340: GD0M340();
     /* GET GD0M.GD0M340*/

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0M330.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0M340;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0M330; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0M340; /* recoverse map*/

      else

        goto GD0M330; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0M330; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0M330;

    end



    GD0M370: GD0M370();
    goto GD0M380;
     /* ***********************************************************/



    GD0M380: GD0M380();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0M370.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0M380;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0M370; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0M380; /* recoverse map*/

      else

        goto GD0M370; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0M370; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0M370;

    end



    GD0M390: GD0M390();
    goto GD0M400;
     /* ***********************************************************/



    GD0M400: GD0M400();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0M390.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0M400;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0M390; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0M400; /* recoverse map*/

      else

        goto GD0M390; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0M390; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0M390;

    end



    GD0M410: GD0M410();
    goto GD0M420;
     /* ***********************************************************/



    GD0M420: GD0M420();
     /* GET GD0M.GD0M420*/

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0M410.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0M420;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0M410; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0M420; /* recoverse map*/

      else

        goto GD0M410; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0M410; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0M410;

    end



    GD0M430: GD0M430();
    goto GD0M440;
     /* ***********************************************************/



    GD0M440: GD0M440();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0M430.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0M440;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0M430; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0M440; /* recoverse map*/

      else

        goto GD0M430; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0M430; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0M430;

    end



    GD0M450: GD0M450();
    goto GD0M460;
     /* ***********************************************************/



    GD0M460: GD0M460();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0M460.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0M460;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0M450; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0M460; /* recoverse map*/

      else

        goto GD0M450; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0M450; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0M450;

    end



    GD0M470: GD0M470();
    goto GD0M480;
     /* ***********************************************************/



    GD0M480: GD0M480();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0M470.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0M480;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0M470; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0M480; /* recoverse map*/

      else

        goto GD0M470; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0M470; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0M470;

    end



  end // end main
end // end GD0M

// Check fast path and initialize
Function GD0M100()


     /* ********************************************************/
     /* * This process intializes program work areas, checks  **/
     /* * user security, and edits the option and item field. **/
     /* *              Flow depending on table                **/
     /* ********************************************************/

     /* check security.*/

   /* ************************************************************/
  XSENTRY(); /* removed for testing  <<<<<<<<<<*/
   /* ************************************************************/

   /* ************************************************************/
  XSSEGTR(); /* 11/88 jw - set segmented trans id*/
   /* ************************************************************/

   /* MOVE 'CSP' TO COMMAREA.CASYSINT ; by security for testing*/
   /* MOVE 'RCONNO' TO COMMAREA.CAUSERID; by security for testing*/

  set GDWREC empty;
  set GD3REC empty;

  GD3REC.GD349B = " "; /* initialize working storage.*/
  GDWREC.GDWFLAGS = " "; /* initialize application flags.*/

     /* Find commarea.cafromap on table, if not there, save*/
     /* original application name in working storage.*/

  GDWREC.GDWTID = COMMAREA.CAFROMAP;
  if (GDWREC.GDWTID in XGLTBL.XGLTAPP)
    XSGDG12();
  else
    XSGDG14();
  end

  if (GDWREC.GDWEDIT == "F")

       /* not found on table, means it must be users application.*/
       /* save users application for PF2 direct return.*/

    GDWREC.GDWFMAPP = COMMAREA.CAFROMAP;
  end

  if (COMMAREA.CAITEM != GD3REC.GD320B) /* does item field have data.*/

            /* The first three bytes of the item field are the csp*/
       /* option. ,*/

    GDWREC.GDWITEM = COMMAREA.CAITEM; /* take it apart,*/

       /* Retreive the first column of the csp table based on the*/
       /* item option.  If the specified item is not a csp table*/
       /* then it must be an error. In this case display the csp*/
       /* tables as we normally would but with an error message*/
       /* for a invalid csp table option.*/

              /* SEARCH FOR SPECIFIED OPTION ON CSP TABLE.*/

    XSGDG10(); /* search for specified option on csp.*/

    if (GDWREC.GDWEDIT == "P") /* tran code found on csp*/

      if (XGLTBL.XGLTAPP[sysVar.arrayIndex] != "GD0M")

        COMMAREA.CATOAP = "GD0G"; /* invalid*/
        COMMAREA.CAITEM = GDWREC.GDWITEM; /* transfer*/
                                                  /* to gd0g display*/
        XSEXIT();

      else

        exit stack;

      end

    else /* not on table, must be outside CSP table appl.*/

      COMMAREA.CATOAP = "GD0G"; /* invalid CSP table*/
      COMMAREA.CAITEM = GDWREC.GDWITEM; /* transfer to GD0G table*/
                                                /* display*/
      XSEXIT();

    end /* if found on CSP table.*/

  end /* item field blank.  default to main menu.*/

  exit stack;




   /* *************************************************************/
end // end GD0M100

// clear screen, format display
Function GD0M130()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0M130 or GD0M140               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0MWRT empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0M130";


  XSGDG22();

  XMGDM002.XMGDMHED = "  XRT SALES REP ASSOCIATION TYPE TABLE";

  GD3REC.GD3PEND1 = "SALES     SALES          S";
  GD3REC.GD3PEND2 = "ALES                  ALLO";
  GD3REC.GD3PEND3 = "W   STATUS                ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "CODE      ABBREV       DES";
  GD3REC.GD3PEND2 = "CRIPTION              SPLI";
  GD3REC.GD3PEND3 = "T    CODE                 ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0MS51(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0M130

// display XRT table values
Function GD0M140()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0M140

// clear screen, format display
Function GD0M150()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0M150 or GD0M160               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD4REC empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0M150";


  XSGDG22();

  XMGDM002.XMGDMHED = "XSC SALES AGENCY ACCOCIATION CLASS TABLE";

  GD3REC.GD3PEND1 = "CODE      DESCRIPTION     ";
  GD3REC.GD3PEND2 = "                     ABBRE";
  GD3REC.GD3PEND3 = "V     STATUS              ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====      ================";
  GD3REC.GD3PEND2 = "==============       =====";
  GD3REC.GD3PEND3 = "=     ======              ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0MS52(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0M150

// display XSC table values
Function GD0M160()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0M160

// clear screen, format display
Function GD0M170()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0M170 or GD0M180               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD4REC empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0M170";


  XSGDG22();

  XMGDM002.XMGDMHED = "XSS SALES AGENCY ACCOCIATION TYPE TABLE";

  GD3REC.GD3PEND1 = "CODE      DESCRIPTION     ";
  GD3REC.GD3PEND2 = "                     ABBRE";
  GD3REC.GD3PEND3 = "V     STATUS              ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====      ================";
  GD3REC.GD3PEND2 = "==============       =====";
  GD3REC.GD3PEND3 = "=     ======              ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0MS53(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0M170

// display XSS table values
Function GD0M180()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0M180

// clear screen, format display
Function GD0M190()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0M190 or GD0M200               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0MWTT empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0M190";


  XSGDG22();

  XMGDM002.XMGDMHED = "XTT SALES TERRITORY CODE TABLE";

  GD3REC.GD3PEND1 = "CODE       DESCRIPTION    ";
  GD3REC.GD3PEND2 = "                      ABBR";
  GD3REC.GD3PEND3 = "EV     STATUS             ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====       ===============";
  GD3REC.GD3PEND2 = "===============       ====";
  GD3REC.GD3PEND3 = "==     ======             ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0MS54(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0M190

// display XTT table values
Function GD0M200()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0M200

// clear screen, format display
Function GD0M210()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0M210 or GD0M220               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD4REC empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0M210";


  XSGDG22();

  XMGDM002.XMGDMHED = "YAD NB ADVERTISING CODE TABLE";

  GD3REC.GD3PEND1 = "CODE      DESCRIPTION     ";
  GD3REC.GD3PEND2 = "                     ABBRE";
  GD3REC.GD3PEND3 = "V     STATUS              ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====      ================";
  GD3REC.GD3PEND2 = "==============       =====";
  GD3REC.GD3PEND3 = "=     ======              ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0MS55(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0M210

// display YAD table values
Function GD0M220()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0M220

// clear screen, format display
Function GD0M230()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0M230 or GD0M240               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0MWOP empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0M230";


  XSGDG22();

  XMGDM002.XMGDMHED = "XOP ORDER TYPE PROFILE CODE TABLE";

  GD3REC.GD3PEND1 = "XOP CODE    GPC CODE    DE";
  GD3REC.GD3PEND2 = "SCRIPTION                 ";
  GD3REC.GD3PEND3 = "       STATUS             ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "========    ========    ==";
  GD3REC.GD3PEND2 = "==========================";
  GD3REC.GD3PEND3 = "==     ======             ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0MS56(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0M230

// display XOP table values
Function GD0M240()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0M240

// clear screen, format display
Function GD0M250()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0M250 or GD0M260               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0MWTY empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0M250";


  XSGDG22();

  XMGDM002.XMGDMHED = "YTY INCOME STATEMENT TYPE TABLE";

  GD3REC.GD3PEND1 = "CODE ABBREV SHORT DESCRIPT";
  GD3REC.GD3PEND2 = ". LONG DESCRIPTION (48 OUT";
  GD3REC.GD3PEND3 = " OF 60 CHARACTERS)       S";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "==== ====== ==============";
  GD3REC.GD3PEND2 = "= ========================";
  GD3REC.GD3PEND3 = "======================== T";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0MS57(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0M250

// display yty table values
Function GD0M260()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0M260

// clear screen, format display
Function GD0M270()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0M270 or GD0M280               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0MWPD empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0M270";


  XSGDG22();

  XMGDM002.XMGDMHED = "YPD DATA TYPE TABLE";

  GD3REC.GD3PEND1 = "CODE SHORT DSC.  LONG DESC";
  GD3REC.GD3PEND2 = "RIPTION                   ";
  GD3REC.GD3PEND3 = "                         S";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "==== ========== ==========";
  GD3REC.GD3PEND2 = "==========================";
  GD3REC.GD3PEND3 = "======================== T";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0MS58(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0M270

// display ypd table values
Function GD0M280()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0M280

// clear screen, format display
Function GD0M290()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0M210 or GD0M220               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD4REC empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0M290";


  XSGDG22();

  XMGDM002.XMGDMHED = "YSY SOURCE SYSTEM CODE TABLE";

  GD3REC.GD3PEND1 = "CODE      DESCRIPTION     ";
  GD3REC.GD3PEND2 = "                     ABBRE";
  GD3REC.GD3PEND3 = "V     STATUS              ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====      ================";
  GD3REC.GD3PEND2 = "==============       =====";
  GD3REC.GD3PEND3 = "=     ======              ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0MS59(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0M290

// display YSY table values
Function GD0M300()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0M300

// clear screen, format display
Function GD0M310()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0M310 or GD0M320               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD4REC empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0M290";


  XSGDG22();

  XMGDM002.XMGDMHED = "YGR SALES GROUP CODE TABLE";

  GD3REC.GD3PEND1 = "CODE      DESCRIPTION     ";
  GD3REC.GD3PEND2 = "                     ABBRE";
  GD3REC.GD3PEND3 = "V     STATUS              ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====      ================";
  GD3REC.GD3PEND2 = "==============       =====";
  GD3REC.GD3PEND3 = "=     ======              ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0MS60(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0M310

// display YGR table values
Function GD0M320()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0M320

// clear screen, format display
Function GD0M330()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0M330 or GD0M340               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0MWBO empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0M330";


  XSGDG22();

  XMGDM002.XMGDMHED = "XBO GPC BACK ORDER VALUE TABLE";

  GD3REC.GD3PEND1 = "GPC    BO-USE     BO-USE  ";
  GD3REC.GD3PEND2 = "    GPC BO    GPC BO     S";
  GD3REC.GD3PEND3 = "TATUS                     ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "CODE  LINE QTY?  ORD VALUE";
  GD3REC.GD3PEND2 = "?   MIN QTY   MIN VALUE  =";
  GD3REC.GD3PEND3 = "=====                     ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0MS61(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0M330

// display XBO table values
Function GD0M340()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0M340

// clear screen, format display
Function GD0M370()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0M370 or GD0M380               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0MWSV empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0M370";


  XSGDG22();

  XMGDM002.XMGDMHED = "  YSV STORE CLASSIFICATION CODE TABLE";

  GD3REC.GD3PEND1 = "S-CLASS   ABBREV  DESCRIPT";
  GD3REC.GD3PEND2 = "ION                       ";
  GD3REC.GD3PEND3 = "    STATUS                ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = " CODE     ======  ========";
  GD3REC.GD3PEND2 = "======================    ";
  GD3REC.GD3PEND3 = "    ======                ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0MS63(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0M370

// display YSV table values
Function GD0M380()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0M380

// clear screen, format display
Function GD0M390()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0M370 or GD0M400               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0MWPP empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0M390";


  XSGDG22();

  XMGDM002.XMGDMHED = "  YPP PRICE POINT CODE TABLE";

  GD3REC.GD3PEND1 = "PRICE PT  DESCRIPTION   PR";
  GD3REC.GD3PEND2 = "C PT LO   PRC PT HI   STAT";
  GD3REC.GD3PEND3 = "US                        ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = " CODE     ============  ==";
  GD3REC.GD3PEND2 = "=======   =========   ====";
  GD3REC.GD3PEND3 = "==                        ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0MS64(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0M390

// display YPP table values
Function GD0M400()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0M400

// clear screen, format display
Function GD0M410()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0M410 or GD0M420               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD4REC empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0M290";


  XSGDG22();

  XMGDM002.XMGDMHED = "XOB BASE ORDER TYPE CODE TABLE";

  GD3REC.GD3PEND1 = "CODE      DESCRIPTION     ";
  GD3REC.GD3PEND2 = "                     ABBRE";
  GD3REC.GD3PEND3 = "V     STATUS              ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====      ================";
  GD3REC.GD3PEND2 = "==============       =====";
  GD3REC.GD3PEND3 = "=     ======              ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0MS65(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0M410

// display XOB table values
Function GD0M420()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0M420

// clear screen, format display
Function GD0M430()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0M430 or GD0M440               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD4REC empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0M290";


  XSGDG22();

  XMGDM002.XMGDMHED = "XBC BRAND CODE TABLE";

  GD3REC.GD3PEND1 = "CODE      DESCRIPTION     ";
  GD3REC.GD3PEND2 = "                     ABBRE";
  GD3REC.GD3PEND3 = "V     STATUS              ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====      ================";
  GD3REC.GD3PEND2 = "==============       =====";
  GD3REC.GD3PEND3 = "=     ======              ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0MS66(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0M430

// display XBC table values
Function GD0M440()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     /* 0M430 or GD0M440               **/
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0M440

// clear screen, format display
Function GD0M450()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0M450 or GD0M460               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0MWLE empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0M450";


  XSGDG22();

  XMGDM002.XMGDMHED = " XLE LEGAL ENTITY CODE TABLE";

  GD3REC.GD3PEND1 = "CODE DESCRIPTION          ";
  GD3REC.GD3PEND2 = "     ABBREV  GL-ENT  STATU";
  GD3REC.GD3PEND3 = "S                         ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "==== =====================";
  GD3REC.GD3PEND2 = "==== ======= ======= =====";
  GD3REC.GD3PEND3 = "=                         ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0MS67(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0M450

// display xle table values
Function GD0M460()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0M460

// clear screen, format display
Function GD0M470()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0M470 or GD0M480               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD4REC empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0M290";


  XSGDG22();

  XMGDM002.XMGDMHED = "YSB SALES REP RESPONSIBILITY TBL";

  GD3REC.GD3PEND1 = "CODE      DESCRIPTION     ";
  GD3REC.GD3PEND2 = "                     ABBRE";
  GD3REC.GD3PEND3 = "V     STATUS              ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====      ================";
  GD3REC.GD3PEND2 = "==============       =====";
  GD3REC.GD3PEND3 = "=     ======              ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0MS68(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0M470

// display YSB table values
Function GD0M480()
   /* GET GD0M480*/



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* GET GD0M480*/
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     /* 0M470 or GD0M480               **/
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0M480

// Formats screen,autoskip XRT
Function GD0MS51()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XRT CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XRTTBL.XRTCD[GDWINDX2] != "99")

    GD0MWRT.XRTCD = XRTTBL.XRTCD[GDWINDX2];
    GD0MWRT.XRTABRV = XRTTBL.XRTABRV[GDWINDX2];
    GD0MWRT.XRTDESC = XRTTBL.XRTDESC[GDWINDX2];
    GD0MWRT.XXXSTAT = XRTTBL.XXXSTAT[GDWINDX2];
    GD0MWRT.XRTSPLIT = XRTTBL.XRTSPLIT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0MWRT.GD0MWRTR;

    set GD0MWRT empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XRTTBL.XRTCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0MS51

// Formats screen,autoskip XSC
Function GD0MS52()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XSC CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XSCTBL.XSCCD[GDWINDX2] != "99")

    GD4REC.GD4CD = XSCTBL.XSCCD[GDWINDX2];
    GD4REC.GD4ABRV = XSCTBL.XSCABRV[GDWINDX2];
    GD4REC.GD4DESC = XSCTBL.XSCDESC[GDWINDX2];
    GD4REC.XXXSTAT = XSCTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD4REC.GD4RECGP;

    set GD4REC empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XSCTBL.XSCCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0MS52

// Formats screen,autoskip XSS
Function GD0MS53()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XSS CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XSSTBL.XSSCD[GDWINDX2] != "99")

    GD4REC.GD4CD = XSSTBL.XSSCD[GDWINDX2];
    GD4REC.GD4ABRV = XSSTBL.XSSABRV[GDWINDX2];
    GD4REC.GD4DESC = XSSTBL.XSSDESC[GDWINDX2];
    GD4REC.XXXSTAT = XSSTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD4REC.GD4RECGP;

    set GD4REC empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XSSTBL.XSSCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0MS53

// Formats screen,autoskip XTT
Function GD0MS54()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XTT CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XTTTBL.XTTCD[GDWINDX2] != 9999)

    GD0MWTT.GD0MWTCD = XTTTBL.XTTCD[GDWINDX2];
    GD0MWTT.XTTABRV = XTTTBL.XTTABRV[GDWINDX2];
    GD0MWTT.XTTDESC = XTTTBL.XTTDESC[GDWINDX2];
    GD0MWTT.XXXSTAT = XTTTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0MWTT.GD0MWTTR;

    set GD0MWTT empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XTTTBL.XTTCD[GDWINDX2] == 9999)

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0MS54

// Formats screen,autoskip YAD
Function GD0MS55()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the yad CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && YADTBL.YADCD[GDWINDX2] != "99")

    GD4REC.GD4CD = YADTBL.YADCD[GDWINDX2];
    GD4REC.GD4ABRV = YADTBL.YADABRV[GDWINDX2];
    GD4REC.XXXSTAT = YADTBL.XXXSTAT[GDWINDX2];
    GD4REC.GD4DESC = YADTBL.YADDESC[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD4REC.GD4RECGP;

    set GD4REC empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (YADTBL.YADCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0MS55

// Formats screen,autoskip XOP
Function GD0MS56()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the xop CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XOPTBL.XOPCD[GDWINDX2] != "9999")

    GD0MWOP.XOPCD = XOPTBL.XOPCD[GDWINDX2];
    GD0MWOP.XGPCD = XOPTBL.XGPCD[GDWINDX2];
    GD0MWOP.XXXSTAT = XOPTBL.XXXSTAT[GDWINDX2];
    GD0MWOP.XOPDESC = XOPTBL.XOPDESC[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0MWOP.GD0MWOPR;

    set GD0MWOP empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XOPTBL.XOPCD[GDWINDX2] == "9999")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0MS56

// Formats screen,autoskip yty
Function GD0MS57()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the yty CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && YTYTBL.YTYCD[GDWINDX2] != "99")

    GD0MWTY.YTYCD = YTYTBL.YTYCD[GDWINDX2];
    GD0MWTY.YTYABRV = YTYTBL.YTYABRV[GDWINDX2];
    GD0MWTY.YTYSDESC = YTYTBL.YTYSDESC[GDWINDX2];
    GD0MWTY.GD0MWDSC = YTYTBL.YTYDESC[GDWINDX2];
    GD0MWTY.XXXSTAT = YTYTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0MWTY.GD0MWTYR;

    set GD0MWTY empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (YTYTBL.YTYCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0MS57

// Formats screen,autoskip yty
Function GD0MS58()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the ypd CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && YPDTBL.YPDCD[GDWINDX2] != "99")

    GD0MWPD.YPDCD = YPDTBL.YPDCD[GDWINDX2];
    GD0MWPD.YPDSDESC = YPDTBL.YPDSDESC[GDWINDX2];
    GD0MWPD.YPDDESC = YPDTBL.YPDDESC[GDWINDX2];
    GD0MWPD.XXXSTAT = YPDTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0MWPD.GD0MWPDR;

    set GD0MWPD empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (YPDTBL.YPDCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0MS58

// Formats screen,autoskip YSY
Function GD0MS59()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the YSY CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && YSYTBL.YSYCD[GDWINDX2] != "99")

    GD4REC.GD4CD = YSYTBL.YSYCD[GDWINDX2];
    GD4REC.GD4ABRV = YSYTBL.YSYABRV[GDWINDX2];
    GD4REC.XXXSTAT = YSYTBL.XXXSTAT[GDWINDX2];
    GD4REC.GD4DESC = YSYTBL.YSYDESC[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD4REC.GD4RECGP;

    set GD4REC empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (YSYTBL.YSYCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0MS59

// Formats screen,autoskip YGR
Function GD0MS60()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the YGR CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && YGRTBL.YGRCD[GDWINDX2] != "99")

    GD4REC.GD4CD = YGRTBL.YGRCD[GDWINDX2];
    GD4REC.GD4ABRV = YGRTBL.YGRABRV[GDWINDX2];
    GD4REC.XXXSTAT = YGRTBL.XXXSTAT[GDWINDX2];
    GD4REC.GD4DESC = YGRTBL.YGRDESC[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD4REC.GD4RECGP;

    set GD4REC empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (YGRTBL.YGRCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0MS60

// Formats screen,autoskip XBO
Function GD0MS61()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the YGR CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XBOTBL.XGPCD[GDWINDX2] != "99")

    GD0MWBO.XGPCD = XBOTBL.XGPCD[GDWINDX2];
    GD0MWBO.XBOLQTY = XBOTBL.XBOLQTY[GDWINDX2];
    GD0MWBO.XBOOVAL = XBOTBL.XBOOVAL[GDWINDX2];
    GD0MWBO.GD0MWBOQ = XBOTBL.XBOMINQ[GDWINDX2];
    GD0MWBO.GD0MWBOV = XBOTBL.XBOMINV[GDWINDX2];
    GD0MWBO.XXXSTAT = XBOTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0MWBO.GD0MWBOR;

    set GD0MWBO empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XBOTBL.XGPCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0MS61

// Formats screen,autoskip YSV
Function GD0MS63()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the YSV CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && YSVTBL.YSVCD[GDWINDX2] != "9999")

    GD0MWSV.YSVCD = YSVTBL.YSVCD[GDWINDX2];
    GD0MWSV.YSVABRV = YSVTBL.YSVABRV[GDWINDX2];
    GD0MWSV.YSVDESC = YSVTBL.YSVDESC[GDWINDX2];
    GD0MWSV.XXXSTAT = YSVTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0MWSV.GD0MWSVR;

    set GD0MWSV empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (YSVTBL.YSVCD[GDWINDX2] == "9999")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0MS63

// Formats screen,autoskip YPP
Function GD0MS64()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the YPP CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && YPPTBL.YPPCD[GDWINDX2] != "99")

    GD0MWPP.YPPCD = YPPTBL.YPPCD[GDWINDX2];
    GD0MWPP.YPPDESC = YPPTBL.YPPDESC[GDWINDX2];
    GD0MWPP.XXXSTAT = YPPTBL.XXXSTAT[GDWINDX2];
    GD0MWPP.GD0MWLOP = YPPTBL.YPPLOPRC[GDWINDX2];
    GD0MWPP.GD0MWHIP = YPPTBL.YPPHIPRC[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0MWPP.GD0MWPPR;

    set GD0MWPP empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (YPPTBL.YPPCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0MS64

// Formats screen,autoskip XOB
Function GD0MS65()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the xob CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XOBTBL.XOBCD[GDWINDX2] != "99")

    GD4REC.GD4CD = XOBTBL.XOBCD[GDWINDX2];
    GD4REC.GD4ABRV = XOBTBL.XOBABRV[GDWINDX2];
    GD4REC.XXXSTAT = XOBTBL.XXXSTAT[GDWINDX2];
    GD4REC.GD4DESC = XOBTBL.XOBDESC[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD4REC.GD4RECGP;

    set GD4REC empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XOBTBL.XOBCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0MS65

// formats screen, auoskip XBC
Function GD0MS66()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XBC CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XBCTBL.XBCCD[GDWINDX2] != "99")

    GD4REC.GD4CD = XBCTBL.XBCCD[GDWINDX2];
    GD4REC.GD4ABRV = XBCTBL.XBCABRV[GDWINDX2];
    GD4REC.XXXSTAT = XBCTBL.XXXSTAT[GDWINDX2];
    GD4REC.GD4DESC = XBCTBL.XBCDESC[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD4REC.GD4RECGP;

    set GD4REC empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XBCTBL.XBCCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0MS66

// Formats screen,autoskip XLE
Function GD0MS67()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XLE CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XLETBL.XLECD[GDWINDX2] != "99")

    GD0MWLE.XLECD = XLETBL.XLECD[GDWINDX2];
    GD0MWLE.XLEDESC = XLETBL.XLEDESC[GDWINDX2];
    GD0MWLE.XLEABRV = XLETBL.XLEABRV[GDWINDX2];
    GD0MWLE.GLAENT = XLETBL.GLAENT[GDWINDX2];
    GD0MWLE.XXXSTAT = XLETBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0MWLE.GD0MWLER;

    set GD0MWLE empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XLETBL.XLECD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0MS67

// FORMATS SCREEN, AUTOSKIP YSB
Function GD0MS68()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the YSB CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && YSBTBL.YSBCD[GDWINDX2] != "99")

    GD4REC.GD4CD = YSBTBL.YSBCD[GDWINDX2];
    GD4REC.GD4ABRV = YSBTBL.YSBABRV[GDWINDX2];
    GD4REC.XXXSTAT = YSBTBL.XXXSTAT[GDWINDX2];
    GD4REC.GD4DESC = YSBTBL.YSBDESC[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD4REC.GD4RECGP;

    set GD4REC empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (YSBTBL.YSBCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0MS68

Record GD0MWBO type basicRecord
  10 GD0MWBOR GD0MWBOR ; 
    20 * char(1) ; 
    20 XGPCD XGPCD ; 
    20 * char(6) ; 
    20 XBOLQTY XBOLQTY ; 
    20 * char(11) ; 
    20 XBOOVAL XBOOVAL ; 
    20 * char(10) ; 
    20 GD0MWBOQ GD0MWBOQ ; 
    20 * char(4) ; 
    20 GD0MWBOV GD0MWBOV ; 
    20 * char(5) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(23) ; 
end // end GD0MWBO

Record GD0MWLE type basicRecord
  10 GD0MWLER GD0MWLER ; 
    20 * char(1) ; 
    20 XLECD XLECD ; 
    20 * char(2) ; 
    20 XLEDESC XLEDESC ; 
    20 * char(1) ; 
    20 XLEABRV XLEABRV ; 
    20 * char(4) ; 
    20 GLAENT GLAENT ; 
    20 * char(6) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(27) ; 
end // end GD0MWLE

Record GD0MWOP type basicRecord
  10 GD0MWOPR GD0MWOPR ; 
    20 * char(3) ; 
    20 XOPCD XOPCD ; 
    20 * char(8) ; 
    20 XGPCD XGPCD ; 
    20 * char(7) ; 
    20 XOPDESC XOPDESC ; 
    20 * char(7) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(16) ; 
end // end GD0MWOP

Record GD0MWPD type basicRecord
  10 GD0MWPDR GD0MWPDR ; 
    20 * char(1) ; 
    20 YPDCD YPDCD ; 
    20 * char(2) ; 
    20 YPDSDESC YPDSDESC ; 
    20 * char(1) ; 
    20 YPDDESC YPDDESC ; 
    20 * char(1) ; 
    20 XXXSTAT XXXSTAT ; 
end // end GD0MWPD

Record GD0MWPP type basicRecord
  10 GD0MWPPR GD0MWPPR ; 
    20 * char(1) ; 
    20 YPPCD YPPCD ; 
    20 * char(7) ; 
    20 YPPDESC YPPDESC ; 
    20 * char(3) ; 
    20 GD0MWLOP GD0MWLOP ; 
    20 * char(5) ; 
    20 GD0MWHIP GD0MWHIP ; 
    20 * char(6) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(27) ; 
end // end GD0MWPP

Record GD0MWRT type basicRecord
  10 GD0MWRTR GD0MWRTR ; 
    20 * char(1) ; 
    20 XRTCD XRTCD ; 
    20 * char(7) ; 
    20 XRTABRV XRTABRV ; 
    20 * char(7) ; 
    20 XRTDESC XRTDESC ; 
    20 * char(7) ; 
    20 XRTSPLIT XRTSPLIT ; 
    20 * char(7) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(19) ; 
end // end GD0MWRT

Record GD0MWSV type basicRecord
  10 GD0MWSVR GD0MWSVR ; 
    20 * char(1) ; 
    20 YSVCD YSVCD ; 
    20 * char(5) ; 
    20 YSVABRV YSVABRV ; 
    20 * char(2) ; 
    20 YSVDESC YSVDESC ; 
    20 * char(10) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(19) ; 
end // end GD0MWSV

Record GD0MWTT type basicRecord
  10 GD0MWTTR GD0MWTTR ; 
    20 GD0MWTCD GD0MWTCD ; 
    20 * char(7) ; 
    20 XTTDESC XTTDESC ; 
    20 * char(7) ; 
    20 XTTABRV XTTABRV ; 
    20 * char(7) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(16) ; 
end // end GD0MWTT

Record GD0MWTY type basicRecord
  10 GD0MWTYR GD0MWTYR ; 
    20 * char(1) ; 
    20 YTYCD YTYCD ; 
    20 * char(2) ; 
    20 YTYABRV YTYABRV ; 
    20 * char(1) ; 
    20 YTYSDESC YTYSDESC ; 
    20 * char(1) ; 
    20 GD0MWDSC GD0MWDSC ; 
    20 * char(1) ; 
    20 XXXSTAT XXXSTAT ; 
end // end GD0MWTY

// XBOMINQ
DataItem GD0MWBOQ num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

DataItem GD0MWBOR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// XBOMINV
DataItem GD0MWBOV num(9,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// i/s type long description
DataItem GD0MWDSC char(48)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// YPPHIPRC
DataItem GD0MWHIP num(7,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

DataItem GD0MWLER char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// YPPLOPRC
DataItem GD0MWLOP num(7,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

DataItem GD0MWOPR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0MWPDR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0MWPPR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0MWRTR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0MWSVR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// sales territory id
DataItem GD0MWTCD num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0MWTTR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0MWTYR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

