package gd0z;
import corpcom1.*;
import corpcom4.*;
import corpcom5.*;
import corpcom7.*;
import corpx1.*;
import corpx2.*;
import corpz3.*;
import gd.common.*;
import ta.common.*;
//*** PROGRAM=GD0Z ****
// Nike On-line Help Menu.
// 
// Overview:
// 
// The GD0Z application is used to maintain the VSAM file which
// contains the Heading, literals and destination transaction
// ID's for the GOAL documentation subsystem.  The application
// uses several flags and their usage is as follows:
// GDWAIDS  -   PF key designator for flow stage.
// GDWRECON -   Re-converse map flag.  used to deliver nasty-
//              grams to the user when they've entered some-
//              thing they shouldn't have.
// GDWSERR  -   Sequential access I/O error flag.
// GDWRERR  -   Random access I/O error flag
// GDWEDIT  -   Edits GD Tran ID's pass or fail.
// 
// Another field which is used is GDWPEND, a pending message
// field, described as a group level with three 26 byte ele-
// mentary fields.  This is used to construct messages which
// are moved into the EZEMSG field of the map.  GDWPEND should
// be moved into EZEMSG with the statement group GDMVMSG.
// This group clears GDWPEND after the move, preventing the
// remanants of an old message from being displayed.  If it is
// necessary to build a message in the flow stage, clearing
// GDWPEND requires another move statement.
// 
//        The application checks the Menu Literal File (MLF)
// and sets flags to indicate empty file, or I/O errors.  If
// the file is empty, the sequential access feature is
// disabled.  The program sets up heading data on the map and
// presents the screen to the user.  The user must enter a
// tran id (Original design terminology, the only tran id's
// used by this system now are GD00, GD01, and GD0Z)  The
// tran id entered is validated against the Transaction Link
// Table (TLT) and if good, the program inquires the MLF,
// and sets an add/update flag depending on the status of the
// read.  No record found means add, record returned normally
// means update.  The data is placed on the map and sent to the
// user.
// 
// Date Created: 04/04/86
//       Author: Dan Loomis
// 
// Maintenance History:
// 
//    Date      By Whom       Overview of Changes Made
//  --------  -----------   ----------------------------
//  04/22/86    Rick C.      - Documentation
//                             - Standards
//                               - Headings
//                               - Code
//                               - Names and Format
// 
//  02/10/88    john w.      - expanded gd2rec to allow 13
//                             lines on map...
//  11/11/88    john w.      - added xssegtr logic
// 
//  04/05/93    vcowan       - chg xgdtbl to xgetbl(europe ver)
// 
// *********************
Program GD0Z type textUIProgram //VAGen Info - main text program
  {
  includeReferencedFunctions = yes, allowUnqualifiedItemReferences = yes, 
  throwNrfEofExceptions = yes, handleHardIOErrors = no, V60ExceptionCompatibility = yes, 
  I4GLItemsNullable = no, textLiteralDefaultIsString = no, localSQLScope = yes, 
  inputRecord = COMMAREA, segmented = yes
  }

  // Data Declarations
  COMMAREA COMMAREA ; // record
  GD2REC GD2REC; // record
  GD3REC GD3REC; // record
  GDTREC GDTREC; // record
  GDWREC GDWREC; // record

  // VAGen Info - items needed for migration
  VAGen_EZESYS char(8);
  VAGen_EZEREPLY num(1);
  VAGen_EZE_WAIT_TIME bin(9,2);
  VAGen_EZE_ITEMLEN int;

  // Use Declarations
  use XGETBL {deleteAfterUse = yes}; // table
  use GD0ZM.GD0ZM001 // form
   {
    pfKeyEquate = no
  };

  function main()
    // VAGen Info - initialization needed for migration
    VAGen_EZESYS = VGLib.getVAGSysType();
    GD0Z100: GD0Z100();
    goto GD0Z200;
     /* ************************************************************/



    GD0Z200: GD0Z200();
    goto GD0Z300;
     /* ************************************************************/



    GD0Z300: GD0Z300();

     /* ************************************************************/


       /* The flags GDWRECON, GDWAIDS, and GDWACCES are set*/
       /* independently of each other.  each flag is reset in the*/
       /* before stage of GD0Z300.*/

    if (GDWREC.GDWRECON == "Y") /* reconverse map*/
      goto GD0Z300;

    end

    if (GDWREC.GDWAIDS == "0") /* enter pressed.*/

      if (GDWREC.GDWACCES == "R") /* random access.*/

                     /* Move Tran ID to key field*/

        GD2REC.GD2TRAN = GD0ZM001.GD0ZMTRN;
        goto GD0Z400; /* read record for replace.*/

      else /* must be sequential.*/

        goto GD0Z900; /* get next sequential record.*/
                  /* ;  Must be sequential.*/
      end

    else /* not enter.*/

      if (GDWREC.GDWAIDS == "Z")
                                     /* cancel and converse blank map*/

        GD3REC.GD3PEND = " ";
        goto GD0Z200; /* sets map clear, reloads date, and pending messages.*/

      else /* unsupported key.*/

        goto GD0Z300;

      end

    end



    GD0Z400: GD0Z400();

     /* ************************************************************/


            /* Add and update functions take place on the same*/
       /* screen.  The function is determined by the setting of*/
       /* gdwswork.gdwfunc, and is given the value of (A)dd or*/
       /* (U)pdate.  The delete function is treated as a special*/
       /* case of the update function.*/


    if (GDWREC.GDWRERR == "Y")
      goto GD0Z300; /* message already formatted.*/

    else /* format data for update/add.*/

              /* Formatting of record and heading data is done*/
                          /* in process GD0Z470.*/

      goto GD0Z470;

    end



    GD0Z470: GD0Z470();
    goto GD0Z500;
     /* ************************************************************/



    GD0Z500: GD0Z500();

     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map, go for it.*/
      goto GD0Z500;

    end

    if (GDWREC.GDWAIDS == "0") /* enter pressed*/

      if (GDWREC.GDWFUNC == "U")
        goto GD0Z550; /* branch to update process.*/

      else

        goto GD0Z700; /* branch to add process.*/

      end /* gdwfunc*/

    end /* not enter*/

    if (GDWREC.GDWAIDS == "3")
      goto GD0Z470;

    end /* not pf3*/

    if (GDWREC.GDWAIDS == "Z") /* PA2 - cancel.*/
      goto GD0Z200;

    end /* not pa2*/

    if (GDWREC.GDWAIDS == "C") /* PF12 delete.*/


      if (GDWREC.GDWDEL == 2) /* confirmed?*/
        GDWREC.GDWDEL = 0; /* reset counter field.*/
        GDWREC.GDWFUNC = "D";
        goto GD0Z550;

      else

        goto GD0Z500; /* first pass, confirmation message pending.*/

      end

    else /* must be unsupported.*/

      goto GD0Z500; /* future pf key options would be inserted here.*/

    end /* pf 12*/



    GD0Z550: GD0Z550();

     /* ************************************************************/


          /* Record is locked or an I/O error was encountered.*/

    if (GDWREC.GDWMLRIO == "Y") /* I/O error.*/
      goto GD0Z500; /* message already formatted.*/

    end

    if (GDWREC.GDWFUNC == "U")
      goto GD0Z600; /* update record*/

    else /* must be a delete.*/

      goto GD0Z800;

    end



    GD0Z600: GD0Z600();

     /* ************************************************************/


    if (GDWREC.GDWRERR == "Y")
      goto GD0Z500; /* converse map with error message.*/

    else

      goto GD0Z200; /* display confirmation message*/

    end



    GD0Z700: GD0Z700();

     /* ************************************************************/


    if (GDWREC.GDWRERR == "Y")
      goto GD0Z500; /* reconverse add/update map*/

    else

      goto GD0Z200; /* display confirmation message.*/

    end



    GD0Z800: GD0Z800();

     /* ************************************************************/


    if (GDWREC.GDWRERR == "Y")
      goto GD0Z500; /* reconverse map*/

    else

      goto GD0Z200; /* display confirmation message.*/

    end



    GD0Z900: GD0Z900();

     /* ************************************************************/


    if (GDWREC.GDWMLRMT == "Y") /* empty to begin with;*/
      goto GD0Z300; /* display message*/

    else

      if (GDWREC.GDWMLREF == "Y") /* end of file?*/
        GDWREC.GDWMLREF = " ";
        GD2REC.GD2TRAN = "    ";
                                     /* reset to beginning of file*/
        set GD2REC position;
        goto GD0Z900; /* get first record of file.*/

      else

        if (GDWREC.GDWSERR == "Y") /* I/O error, display message.*/
          goto GD0Z200;

        else

          GD0ZM001.GD0ZMTRN = GD2REC.GD2TRAN;
                                     /* move Tran ID to map*/
          GDWREC.GDWTID = GD2REC.GD2TRAN; /* and working storage.*/
          goto GD0Z470; /* record retreived, format and display*/
                                     /* it*/

        end

      end

    end



  end // end main
end // end GD0Z

// set eof flag if file empty
Function GD0Z100()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* * Scan file for I/O errors or empty file. If empty file**/
     /* * and user keys enter with blanks in the TRAN-ID field,**/
     /* * a message is displayed, flags are set and the user is**/
     /* * forced to enter a Tran-ID.  If there is an I/O error **/
     /* * on the scana message is formatted, and displayed at  **/
     /* * process GD0Z300                                      **/
     /* *********************************************************/



     /* check security.*/

     /* *********************************************************/
  XSENTRY();
     /* *********************************************************/

     /* *********************************************************/
  XSSEGTR(); /* 11/88 jw - set segmented trans id*/
     /* *********************************************************/

   /* mOVE 'CSP' TO COMMAREA.CASYSINT ;    bypass security*/
   /* MOVE 'TDAWSO' TO COMMAREA.CAUSERID;  bypass security*/

  set GDWREC empty;
  set GD2REC empty;
  set GD3REC empty;

  GD3REC.GD349B = " "; /* initailize working storage*/
  GDWREC.GDWFLAGS = " "; /* initailize application flags*/

  GDWREC.GDWFMAPP = "GD0Z"; /* save from app for PF2.*/



   /* ************************************************************/
  try
    get next GD2REC ;
  end
   /* ************************************************************/



  if (GD2REC is ioError)

    if (GD2REC is endOfFile)
      GDWREC.GDWMLRMT = "Y";
      GD3REC.GD3PEND = " ";

    else /* error, format error message.*/

      GDWREC.GDWSERR = "Y"; /* set seq access error flag*/

      GD3REC.GD3PEND1 = "I/O ERROR READING MENU LIT";
      GD3REC.GD3PEND2 = "ERAL FILE.   SPECIFY TRAN-";
      GD3REC.GD3PEND3 = "ID.                       ";

    end

  else /* no error; set next sequential read to first record.*/

    set GD2REC position;

  end



   /* ************************************************************/
end // end GD0Z100

// clear screen, move message
Function GD0Z200()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a blank screen  **/
     /* *    Display any pending message.                      **/
     /* *********************************************************/


  set GD0ZM001 initial; /* resets all field attributes.*/

  GD0ZM001.GD0ZMDT = VGVar.currentShortGregorianDate;
  GD0ZM001.GD0ZMMAP = "GD0ZM001";
  GD0ZM001.GD0ZMPRO = "GD0Z200";

  GD0ZS20();

  GD0ZS14(); /* sets all other map items to askip attribute.*/

  set GD0ZM001.GD0ZMTRN cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0Z200

// get tran-id for update/add
Function GD0Z300()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* * Blank map for entry of next Tran ID.  If no Tran ID  **/
     /* * entered sequential processing is assumed unless menu **/
     /* * literal file empty, or an I/O error was detected in  **/
     /* * GD0Z100. The recon flag for reconverse is set when   **/
     /* * there is a message for the user indicating that they **/
     /* * did something that they are not allowed to do. The   **/
     /* * flag ireset upon entering the process when the map   **/
     /* * is Re-conversed.                                     **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set GD0ZM001.GD0ZMTRN cursor;



   /* ************************************************************/
  converse GD0ZM001 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (GD0ZM001.GD0ZM2AP is modified
     && GD0ZM001.GD0ZM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = GD0ZM001.GD0ZMITM;
      COMMAREA.CATOAP = GD0ZM001.GD0ZM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      GD0ZS20();
                                   /* and moved into GD0Z.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (GD0ZM001.GD0ZMITM is modified /* item entered*/
     && GD0ZM001.GD0ZMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = GD0ZM001.GD0ZMITM;

      XSGD092(); /* determine desired application, and link.*/
      GD0ZS20(); /* if link fails, a message is formated and*/
                          /* moved into GD0Z.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/


    if (GD0ZM001.GD0ZMTRN is modified /* Tran ID entered and*/
     && GD0ZM001.GD0ZMTRN != GD3REC.GD304B) /* not equal spaces*/

      GDWREC.GDWTID = GD0ZM001.GD0ZMTRN;

      XSGD010(); /* validate Tran ID with TLT.*/

      if (GDWREC.GDWEDIT == "P") /* Tran ID pass edit?*/

        GDWREC.GDWACCES = "R"; /* set random access.*/

         /* Flag used in flow stage to branch to (R) GD0Z400 update*/
                        /* or (S) GD0Z900 scan.*/

        exit stack;

      else /* edit failed set flag for flow stage.*/

        GD3REC.GD3PEND1 = "INVALID TRAN-ID - ENTER A ";
        GD3REC.GD3PEND2 = "VALID TRAN-ID OR LEAVE FIE";
        GD3REC.GD3PEND3 = "LD BLANK FOR NEXT RECORD. ";

        GD0ZS20();

        GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
        set GD0ZM001.GD0ZMTRN cursor, modified, bold;
        exit stack;

      end /* edit pass/fail?*/

    else /* nothing entered, check EOF.*/

        /* These flags set in GD0Z100, and should not be reset.*/

      if (GDWREC.GDWMLRMT == "Y") /* menu literal file empty?*/

        GD3REC.GD3PEND1 = "NO TRAN ID ENTERED AND MEN";
        GD3REC.GD3PEND2 = "U LITERAL FILE EMPTY - SPE";
        GD3REC.GD3PEND3 = "CIFY TRAN-ID              ";
        GD0ZS20();

        GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
        exit stack;

      else /* menu literal file is not empty*/

        if (GDWREC.GDWMLRIO == "Y") /* menu literal file I/O error?*/

          GD3REC.GD3PEND1 = "NO TRAN ID ENTERED AND I/O";
          GD3REC.GD3PEND2 = "ERROR ON MENU LITERAL FILE";
          GD3REC.GD3PEND3 = "SPECIFY TRAN-ID           ";
          GD0ZS20();

          GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
          exit stack;

        else

                /* no MLF error flags set, set scan flag for flow stage.*/
                /* set sequential access flag for flow stage.*/

          GDWREC.GDWACCES = "S";
          exit stack;

        end /* mlf I/O error?*/

      end /* mlf eof?*/

    end /* gd0ztran ne spaces.*/

  end /* not ENTER*/

  if (converseVar.eventKey is pf4)
    XSPF4(); /* return to main goal menu.*/

    GD0ZM001.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* no implementation of PF3 at this*/
                                   /* time.*/
    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from gd0z200 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GD0ZS20();

    exit stack;

  end



   /* ************************************************************/
end // end GD0Z300

// get record and set function
Function GD0Z400()


      /* *********************************************************/
      /* *             This process does the following:         **/
      /* * When an I/O error, EOF or NRF condition is raised the**/
      /* * contents of the record buffer remain unaltered from  **/
      /* * the last successfull I/O operation against the file. **/
      /* *********************************************************/


  GDWREC.GDWACCES = " "; /* reset access flag for next pass.*/
  GDWREC.GDWFUNC = " "; /* reset function flag for next pass.*/
  GDWREC.GDWRERR = " "; /* reset I/O error flag for next pass.*/
  GD2REC.GD2LOTR = " "; /* clear out data area of record.*/



   /* ************************************************************/
  try
    get GD2REC ;
  end
   /* ************************************************************/



  if (GD2REC is ioError) /* Check for I/O error.*/

    if (GD2REC is noRecordFound) /* No record found?*/

                 /* Add new menu, set function flag.*/

      GDWREC.GDWFUNC = "A";
      exit stack;

    else /* other error condition.*/

      GD3REC.GD3PEND1 = "I/O ERROR READING MENU LIT";
      GD3REC.GD3PEND2 = "ERAL FILE.   SPECIFY TRAN-";
      GD3REC.GD3PEND3 = "ID.                       ";
      GD0ZS20();

      GDWREC.GDWRERR = "Y"; /* set random access error flag.*/
      exit stack;

    end

  else /* No error condition, record found.*/

              /* Update or delete, set function flag.*/

    GDWREC.GDWFUNC = "U";
    exit stack;

  end



   /* ************************************************************/
end // end GD0Z400

// format add/update screen.
Function GD0Z470()


      /* ********************************************************/
      /* *        This process performs the following:         **/
      /* * Format map with data. CSP testing facility says that**/
      /* * the fields in a record after a no record found      **/
      /* * condition are uninitialized. If 'unitialized' means **/
      /* * blanks and zeros, leave as is, otherwise, need to   **/
      /* * clear data areas of map for add function. This      **/
      /* * process should not be executed when the map is      **/
      /* * reconversed.                                        **/
      /* ********************************************************/


  if (GDWREC.GDWAIDS == "3")
    GDWREC.GDWTID = GD0ZM001.GD0ZMTRN;

  end

  set GD0ZM001 initial; /* clear map reset all attributes.*/

  GD0ZM001.GD0ZMPRO = "GD0Z500";
  GD0ZM001.GD0ZMMAP = "GD0ZM001";
  GD0ZM001.GD0ZMPF3 = "PF3 = Refresh Screen";
  GDWREC.GDWDEL = 0; /* reset unconfirmed delete flag.*/

  GD0ZM001.GD0ZMTRN = GDWREC.GDWTID; /* restore tran id value.*/

  set GD0ZM001.GD0ZMTRN skip; /* protect Tran id from users.*/
  set GD0ZM001.GD0ZMHED cursor;

      /* Move data from record area to corresponding fields.*/
      /* Moving blanks in case of ADD function is intentional*/
            /* because of potential PF3 refresh request.*/

  GD0ZM001.GD0ZMHED = GD2REC.GD2HEAD;
  GDWREC.GDWINDX1 = 1;

  while (GDWREC.GDWINDX1 <= 13)
                                   /* ******* 2/10/88 jbw...... ********/

    GD0ZM001.GD0ZMLIT[GDWINDX1] = GD2REC.GD2LIT[GDWINDX1];
    GD0ZM001.GD0ZMTID[GDWINDX1] = GD2REC.GD2DTID[GDWINDX1];
    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;

  end

  if (GDWREC.GDWFUNC == "A")
    GD3REC.GD3PEND1 = "NO RECORD FOUND FOR SPECIF"; /* set up error*/
    GD3REC.GD3PEND2 = "IED OPTION.  ADD FUNCTION "; /* message.*/
    GD3REC.GD3PEND3 = "ASSUMED, ENTER DATA.      ";
    GD0ZS10();

  else

    GD3REC.GD3PEND1 = "RECORD FOUND, ENTER CHANGE"; /* set up error*/
    GD3REC.GD3PEND2 = "S.                        "; /* message.*/
    GD3REC.GD3PEND3 = "                          ";
    GD0ZS10();

  end

  exit stack;



   /* ************************************************************/
end // end GD0Z470

// present add/update screen
Function GD0Z500()

      /* *********************************************************/
      /* *                                                      **/
      /* *   This process presents the add and update screen    **/
      /* *                                                      **/
      /* *********************************************************/



  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset re-converse flag.*/
  GDWREC.GDWZMAP = " "; /* reset map edit flag.*/

             /* Data is moved to fields in GD0Z470*/



   /* ************************************************************/
  converse GD0ZM001 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0";
    GDWREC.GDWDEL = 0; /* reset delete confirm count.*/

    if (GD0ZM001 is modified)

      if (GD0ZM001.GD0ZM2AP is modified
       && GD0ZM001.GD0ZM2AP != GD3REC.GD304B)
                                   /* not spaces*/

        COMMAREA.CAITEM = GD0ZM001.GD0ZMITM;
        COMMAREA.CATOAP = GD0ZM001.GD0ZM2AP;
        XSEXIT();

               /* If link to tran id falis, a message is formated,*/
               /* placed in GD0Z.EZEMSG, and the recon flag is set.*/

        XSGD040();
        GD0ZS20();
        GDWREC.GDWRECON = "Y"; /* reconverse, message*/

        exit stack; /* fast path failed.*/

      else /* no fast path entered, item?*/

        if (GD0ZM001.GD0ZMITM is modified /* item entered*/
         && GD0ZM001.GD0ZMITM != GD3REC.GD320B) /* and not blanks*/

          COMMAREA.CAITEM = GD0ZM001.GD0ZMITM;

          XSGD092(); /* determine application and link.  if the link*/
          GD0ZS20(); /* fails, a message is formatted and moved to*/
                          /* GD0ZM001.EZEMSG, and the recon flag is set.*/

          GDWREC.GDWRECON = "Y"; /* reconverse, message*/
          exit stack; /* item transfer failed.*/

        else /* no fast path or item entered, must have been data.*/

                 /* Edit menu heading, must be present.  at least 1 menu*/
             /* literal and destination Tran-ID must be present.  data*/
             /* tran id field requires that a description be present in*/
             /* the corresponding description field.  A description field*/
             /* may be used as a comment entry if the corresponding tran*/
             /* id field is blank.*/

          GD0ZS10();

          if (GDWREC.GDWZMAP == "F")
            GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/

          end

          exit stack;

        end /* if item modified*/

      end /* if fast path modified*/

    else /* nothing entered, reconverse map*/

           /* Allow repeated update/add attempts after an I/O error.*/

      if (GDWREC.GDWRERR == "Y")
        exit stack;

      else /* force some kind of entry.*/

        GD3REC.GD3PEND1 = "NO CHANGES ENTERED.  ENTER";
        GD3REC.GD3PEND2 = " CHANGES OR PRESS PA2 TO C";
        GD3REC.GD3PEND3 = "ANCEL.                    ";

        GD0ZS20(); /* move message to ezemsg, and reset pending message.*/
        GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/

      end

    end /* map modified?*/

  end /* not ENTER key pressed.*/

  if (converseVar.eventKey is pf4)
    XSPF4();
                                   /* return to main goal menu.*/

    GD0ZM001.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* refresh to orginal data.*/
    GDWREC.GDWAIDS = "3";
                                   /* set pf key flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from gd0z200 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  end

  if (converseVar.eventKey is pf12) /* delete record after confirmation.*/

    if (GDWREC.GDWFUNC == "U") /* delete only valid during update.*/
      GDWREC.GDWDEL = GDWREC.GDWDEL + 1;
      GDWREC.GDWAIDS = "C";
      GD3REC.GD3PEND1 = "PRESS PF12 AGAIN TO CONFIR";
      GD3REC.GD3PEND2 = "M DELETE REQUEST.         ";

      GD0ZS20();
      exit stack;

    else /* not an update function.*/

      GD3REC.GD3PEND1 = "DELETE ONLY VALID IF RECOR";
      GD3REC.GD3PEND2 = "D ALREADY ON MLF.         ";
      GDWREC.GDWRECON = "Y";
      GD0ZS20();
      exit stack;

    end /* if gdwfunc eq 'u' and pf 12 pressed.*/

  else /* Unsupported pf key was pressed, send nastygram to user*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GD0ZS20();
    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end /* if pf12*/



   /* ************************************************************/
end // end GD0Z500

// lock record for replace/delete
Function GD0Z550()


     /* *********************************************************/
     /* *         This process does the following:             **/
     /* * The record must be locked with an update immediately **/
     /* * prior to a repalce or delete. No pseudo conversations**/
     /* * can intervien.                                       **/
     /* *********************************************************/

  GDWREC.GDWMLRIO = " "; /* reset I/O error flag.*/



   /* ************************************************************/
  try
    get GD2REC forUpdate ;
  end
   /* ************************************************************/



  if (GD2REC is ioError) /* Check for I/O error.*/

       /* Record cannot have an NRF condition because it was*/
       /* previously inquired.*/

    GD3REC.GD3PEND1 = "I/O ERROR READING MENU LIT";
    GD3REC.GD3PEND2 = "ERAL FILE.   SPECIFY TRAN-";
    GD3REC.GD3PEND3 = "ID.                       ";

    GDWREC.GDWMLRIO = "Y"; /* set random access error flag.*/
    GD0ZS20();

  end

  exit stack;



   /* ************************************************************/
end // end GD0Z550

// replace updated record.
Function GD0Z600()


     /* **********************************************************/
     /* *             This process does the following:          **/
     /* * record locked, all fields edited, replace record. move**/
     /* * buffer and replace record.  note that the data must be**/
     /* * moved into the buffer after the record is locked with **/
     /* * an update process.                                    **/
     /* **********************************************************/


  GD0ZS60(); /* move MAP data to MLF buffer.*/



   /* ************************************************************/
  try
    replace GD2REC ;
  end
   /* ************************************************************/



  if (GD2REC is ioError)
    GDWREC.GDWRERR = "Y"; /* set random access error flag*/

    GD3REC.GD3PEND1 = "I/O ERROR, UPDATE FAILED. "; /* set up error*/
    GD3REC.GD3PEND2 = "TRY AGAIN OR PRESS PA2 TO "; /* message.*/
    GD3REC.GD3PEND3 = "CANCEL.                   ";
    GD0ZS20();

      /* application will branch to GD0Z500 and display message.*/

    exit stack;

  else

    GD3REC.GD3PEND1 = "RECORD UPDATED SUCCESSFULL"; /* set up error*/
    GD3REC.GD3PEND2 = "Y.   ENTER NEXT TRAN ID.  "; /* message.*/
    GD3REC.GD3PEND3 = "                          ";
    exit stack;

      /* application will branch to GD0Z200, which clears and*/
      /* initializes map, and places pending messages in EZEMSG.*/

  end



   /* ************************************************************/
end // end GD0Z600

// add new record
Function GD0Z700()



     /* *********************************************************/
     /* *            This process does the following :         **/
     /* * All fields edited, add record to file. No chance of  **/
     /* * duplicate keys, since add function is assumed when   **/
     /* * user entered a Tran-ID which was not on the file.    **/
     /* *********************************************************/

  GD0ZS60(); /* move data from MAP into MLF buffer.*/



   /* ************************************************************/
  try
    add GD2REC ;
  end
   /* ************************************************************/




  if (GD2REC is ioError)
    GDWREC.GDWRERR = "Y"; /* set seq access error flag*/

    GD3REC.GD3PEND1 = "I/O ERROR, ADD FAILED.  TR"; /* set up error*/
    GD3REC.GD3PEND2 = "Y AGAIN OR PRESS PA2 TO CA"; /* message.*/
    GD3REC.GD3PEND3 = "NCEL.                     ";
    GD0ZS20();
    exit stack;

  else

    GD3REC.GD3PEND1 = "RECORD ADDED SUCCESSFULLY."; /* set up*/
    GD3REC.GD3PEND2 = "  ENTER NEXT TRAN ID.     "; /* message.*/
    GD3REC.GD3PEND3 = "                          ";
    exit stack;

       /* Application will branch to GD0Z200, which clears and*/
       /* initializes map, and places pending messages in EZEMSG.*/

  end



   /* ************************************************************/
end // end GD0Z700

// delete record.
Function GD0Z800()


     /* *********************************************************/
     /* *          This process performs the following:        **/
     /* *    record locked, delete confirmed, delete record.   **/
     /* *********************************************************/



   /* *************************************************************/
  try
    delete GD2REC ;
  end
   /* *************************************************************/



  if (GD2REC is ioError)
    GDWREC.GDWRERR = "Y"; /* set seq access error flag*/

    GD3REC.GD3PEND1 = "I/O ERROR, DELETE FAILED. "; /* set up error*/
    GD3REC.GD3PEND2 = "TRY AGAIN OR PRESS PA2 TO ";
                                   /* message.*/
    GD3REC.GD3PEND3 = "CANCEL.                   ";
    GD0ZS20();
    exit stack;

  else

    GD3REC.GD3PEND1 = "RECORD DELETED SUCCESSFULL"; /* set up error*/
    GD3REC.GD3PEND2 = "Y.   ENTER NEXT TRAN ID.  "; /* message.*/
    GD3REC.GD3PEND3 = "                          ";
    exit stack;

        /* Application will branch to GD0Z200, which clears and*/
        /* initializes map, and places pending messages in EZEMSG.*/

  end



   /* ************************************************************/
end // end GD0Z800

// process sequentially.
Function GD0Z900()


     /* **********************************************************/
     /* *            This process does the following:           **/
     /* *   When an end of file condition is reached, the record**/
     /* * pointer will be reset to AAAAAAAA00000 and another    **/
     /* * attempt to read the file will be made. When this      **/
     /* * happens, a message will be placed in ezemsg that the  **/
     /* * EOF was reached etc...                                **/
     /* * This process must be used so that application does    **/
     /* * not attempt to reset the record key on an empty file. **/
     /* * This process must not be called when GDWMLTMT is      **/
     /* * eq "Y". The only source of a call to this process     **/
     /* * is the flow stage of GD0Z500. Test for empty file     **/
     /* * prior to scan, if empty send message.                 **/
     /* **********************************************************/



  GDWREC.GDWSERR = " "; /* reset I/O error flag;*/

  if (GDWREC.GDWMLRMT == "Y")
    GD3REC.GD3PEND1 = "MENU LITERAL FILE IS EMPTY";
    GD3REC.GD3PEND2 = ".  SPECIFY A TRAN ID.     ";
    GD3REC.GD3PEND3 = "                          ";
    GD0ZS20();
    exit stack;

  end



   /* *************************************************************/
  try
    get next GD2REC ;
  end
   /* *************************************************************/




  if (GD2REC is ioError)

    if (GD2REC is endOfFile) /* set up informative message.*/

           /* A user could start by deleteing all of the records*/
         /* in the MLF and then specifying a sequential read.*/
         /* This condition would exist after an EOF and the*/
         /* last set key equal to spaces.  if not trapped the*/
         /* process would continue reading the file until the*/
         /* cows came home, or until the system crashes.*/

      if (GD2REC.GD2TRAN == GD3REC.GD304B) /* eof on first record?*/
        GDWREC.GDWMLRMT = "Y"; /* set empty file flag.*/

        GD3REC.GD3PEND1 = "MENU LITERAL FILE IS EMPTY";
        GD3REC.GD3PEND2 = ".  SPECIFY A TRAN ID.     ";
        GD3REC.GD3PEND3 = "                          ";
        GD0ZS20();
        exit stack;

      else

        GDWREC.GDWMLREF = "Y"; /* set eof flag.*/
        GD3REC.GD3PEND1 = "END OF FILE ENCOUNTERED.  ";
        GD3REC.GD3PEND2 = "FIRST RECORD RETURNED.  PR";
        GD3REC.GD3PEND3 = "ESS PA2 TO CANCEL.        ";
        GD0ZS20();
        exit stack;

      end

    else /* set up I/O error message.*/

      GDWREC.GDWSERR = "Y"; /* seq access I/O error.*/
      GD3REC.GD3PEND1 = "I/O ERROR READING MENU LIT";
      GD3REC.GD3PEND2 = "ERAL FILE.  SPECIFY A TRAN";
      GD3REC.GD3PEND3 = " ID.                      ";
      GD0ZS20();
      exit stack;

    end

  else

                /* lock tran id with update process.*/

    exit stack;

  end



   /* ************************************************************/
end // end GD0Z900

// GD0Z map edit and validation
Function GD0ZS10()

     /* **********************************************************/
     /* *      This statement group does the following:         **/
     /* *   Edits and validates fields on the GD0Z map.  Forces **/
     /* * heading, and the first destination Tran ID and Descrip**/
     /* * tion to be entered. Subsequent descriptions may be    **/
     /* * entered without a destination tran id and will be     **/
     /* * treated as a comment entry.  If a destination tran id **/
     /* * is entered, the tran id must be on the TLT, and a     **/
     /* * description must be entered entered.                  **/
     /* **********************************************************/

  GD0ZS15(); /* reset map item attributes to original definition.*/

     /* Note that spaces are not valid in the heading, and first*/
     /* Tran ID and its description.*/

  if (GD0ZM001.GD0ZMHED == GD3REC.GD349B) /* heading equal blanks*/
    GD3REC.GD3PEND1 = "HEADING AND AT LEAST ONE D";
    GD3REC.GD3PEND2 = "EST TRAN ID AND ITS DESCRI";
    GD3REC.GD3PEND3 = "PTION MUST BE ENTERED.    ";

    GDWREC.GDWZMAP = "F"; /* map edit fails.*/
    set GD0ZM001.GD0ZMHED cursor, bold; /* place cursor on this field.*/

    GD0ZS20();
    return;

  end

  if (GD0ZM001.GD0ZMTID[1] == GD3REC.GD304B) /* no dest tran id?*/
    GD3REC.GD3PEND1 = "AT LEAST ONE DEST TRAN ID ";
    GD3REC.GD3PEND2 = "AND ITS DESCRIPTION MUST B";
    GD3REC.GD3PEND3 = "E ENTERED.                ";

    GDWREC.GDWZMAP = "F"; /* map edit fails.*/
    set GD0ZM001.GD0ZMTID[1] cursor, bold;
    GD0ZS20();
    return;

  else /* dest tran id entered, proceed with validation and edit.*/

    GDWREC.GDWTID = GD0ZM001.GD0ZMTID[1]; /* tran id entered.*/
    XSGD010(); /* Validate tran id with TLT.*/

    if (GDWREC.GDWEDIT == "P")

                /* Good transaction, description entered?*/

      if (GD0ZM001.GD0ZMLIT[1] == GD3REC.GD349B)
        GD3REC.GD3PEND1 = "DESCRIPTION MUST ACCOMPANY";
        GD3REC.GD3PEND2 = " TRANSACTION.             ";
        GD3REC.GD3PEND3 = "                          ";

        GDWREC.GDWZMAP = "F"; /* map edit fails.*/
        set GD0ZM001.GD0ZMLIT[1] cursor, bold;
        GD0ZS20();
        return;

      else /* description passed edit, check rest of map.*/
             /* minimum requirements meet at this point.*/
             /* user need not have entered anything more.*/
             /* edit and validate anything which was entered.*/

        GDWREC.GDWINDX1 = 2;

        while (GDWREC.GDWINDX1 <= 13) /* ****** 2/10/88 - jbw ******/

             /* Check Tran ID for spaces. If no spaces, validate Tran ID*/
             /* and description field. If spaces allow comment entry in*/
             /* description field.*/

          if (GD0ZM001.GD0ZMTID[GDWINDX1] != GD3REC.GD304B)
            GDWREC.GDWTID = GD0ZM001.GD0ZMTID[GDWINDX1];
            XSGD010(); /* Validate tran id with TLT.*/

            if (GDWREC.GDWEDIT == "P") /* transaction good, description?*/

              if (GD0ZM001.GD0ZMLIT[GDWINDX1] == GD3REC.GD349B)

                             /* Heading equal blanks*/

                GD3REC.GD3PEND1 = "DESCRIPTION MUST ACCOMPANY";
                GD3REC.GD3PEND2 = " TRANSACTION.             ";
                GD3REC.GD3PEND3 = "                          ";
                GDWREC.GDWZMAP = "F"; /* map edit fails.*/
                set GD0ZM001.GD0ZMLIT[GDWINDX1] cursor, bold;
                GD0ZS20();
                return;

              end

            else /* dest tran(gdwindx1) not on table.*/

              GD3REC.GD3PEND1 = "TRAN ID'S MUST BE ADDED TO";
              GD3REC.GD3PEND2 = " TLT BEFORE MENU MAINTENAN";
              GD3REC.GD3PEND3 = "CE IS PERFORMED.          ";
              GDWREC.GDWZMAP = "F"; /* map edit fails.*/
              set GD0ZM001.GD0ZMTID[GDWINDX1] cursor, bold;
              GD0ZS20();
              return;

            end /* transaction test.*/

          end /* tran not equal to spaces.*/

          GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1; /* increment index.*/

        end /* while gdwindx1 le 10*/

      end /* rest of map check.*/

    else /* GD0ZDTID(1) failed validation.*/

      GD3REC.GD3PEND1 = "TRAN ID'S MUST BE ADDED TO";
      GD3REC.GD3PEND2 = " TLT BEFORE MENU MAINTENAN";
      GD3REC.GD3PEND3 = "CE IS PERFORMED.          ";
      GDWREC.GDWZMAP = "F"; /* map edit fails.*/
      set GD0ZM001.GD0ZMTID[1] cursor, bold;
      GD0ZS20();
      return;

    end /* If GD0ZDTID(1) passed validation.*/

  end /* If GD0ZDTID(1) equal spaces.*/



end // end GD0ZS10

// Set map items autoskip
Function GD0ZS14()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/

                        /* GET GD0ZS15*/

  set GD0ZM001.GD0ZMHED skip;
  GDWREC.GDWINDX1 = 1;

  while (GDWREC.GDWINDX1 <= 10)

    set GD0ZM001.GD0ZMLIT[GDWINDX1] skip;
    set GD0ZM001.GD0ZMTID[GDWINDX1] skip;
    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;

  end

  return;



end // end GD0ZS14

// set map items defined;
Function GD0ZS15()

     /* *********************************************************/
     /* *     This statement group does the following:         **/
     /* *   Set all possible map items to their defined        **/
     /* *   attributes.  This clears any item highlighted      **/
     /* *   in error.                                          **/
     /* *********************************************************/


  set GD0ZM001.GD0ZMHED initialAttributes;
  GDWREC.GDWINDX1 = 1;

  while (GDWREC.GDWINDX1 <= 13) /* ***** 2/10/88 - jbw ******/

    set GD0ZM001.GD0ZMLIT[GDWINDX1] initialAttributes;
    set GD0ZM001.GD0ZMTID[GDWINDX1] initialAttributes;
    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;

  end

  return;



end // end GD0ZS15

// Move message field to map
Function GD0ZS20()

     /* *********************************************************/
     /* *       This statement group does the following:       **/
     /* * Move and clear pending message field, set ring bell. **/
     /* *********************************************************/

  GD0ZM001.VAGen_EZEMSG = GD3REC.GD3PEND;
  GD3REC.GD3PEND = " ";

   /* SET GD0ZM001 ALARM;*/
  return;



end // end GD0ZS20

// Move data from map to record.
Function GD0ZS60()

     /* *********************************************************/
     /* *       This statement group does the following:       **/
     /* *       Move data from map to record buffer.           **/
     /* *       Record key should already be in palce.         **/
     /* *********************************************************/

  GD2REC.GD2HEAD = GD0ZM001.GD0ZMHED;
  GDWREC.GDWINDX1 = 1;

  while (GDWREC.GDWINDX1 <= 13) /* ***** 2/10/88 - jbw ******/

    GD2REC.GD2LIT[GDWINDX1] = GD0ZM001.GD0ZMLIT[GDWINDX1];
    GD2REC.GD2DTID[GDWINDX1] = GD0ZM001.GD0ZMTID[GDWINDX1];
    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;

  end

  return;



end // end GD0ZS60

