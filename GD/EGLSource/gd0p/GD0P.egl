package gd0p;
import corpcom1.*;
import corpcom4.*;
import corpcom5.*;
import corpcom6.XMGDM;
import corpcom7.*;
import corpx1.*;
import corpx2.*;
import corpz3.*;
import gd.common.*;
import ta.common.*;
//*** PROGRAM=GD0P ****
// Nike On-line CSP Table Display Application
// 
//                        CSP TABLES
// 
// OVERVIEW:
// 
//     The purpose of the GD0P CSP table  display application
// is to allow users of CSP tables access to these TABLES in
// a fast and efficient manner.
// 
//     This application is driven by the GD0G table display
// application which displays all the valid CSP tables which
// this system is to access. The user then makes a selection
// of which table is to be displayed by entering the code
// (ie. "XCT", {country table}) in the option field. The table
// GD0GWT1 is searched and if the code entered is a valid table
// control is then pass to the application responsible for
// displaying that CSP table. This application displays all the
// allocation CSP tables.
// 
// 
// DATE CREATED: 11/11/86
//       AUTHOR: John Wood (cloned from pgm GD0H)
// 
// 
// MAINTENANCE HISTORY:
// 
//    DATE      BY WHOM          OVERVIEW OF CHANGES MADE
//  -------   ----------     ---------------------------------
//  11-11-88  John Wood      added xssegtr logic
//  06-13-90  John Wood      replaced xcb with xeg
//  08-05-91  vern cowan     add xbdcrcfl to display logic
// *********************
Program GD0P type textUIProgram //VAGen Info - main text program
  {
  includeReferencedFunctions = yes, allowUnqualifiedItemReferences = yes, 
  throwNrfEofExceptions = yes, handleHardIOErrors = no, V60ExceptionCompatibility = yes, 
  I4GLItemsNullable = no, textLiteralDefaultIsString = no, localSQLScope = yes, 
  inputRecord = COMMAREA, segmented = yes
  }

  // Data Declarations
  COMMAREA COMMAREA ; // record
  GD0PWBD GD0PWBD; // record
  GD0PWCD GD0PWCD; // record
  GD0PWDN GD0PWDN; // record
  GD0PWEG GD0PWEG; // record
  GD0PWPK GD0PWPK; // record
  GD0PWPP GD0PWPP; // record
  GD0PWRS GD0PWRS; // record
  GD0PWSM GD0PWSM; // record
  GD0PWSZ GD0PWSZ; // record
  GD3REC GD3REC; // record
  GDWREC GDWREC; // record

  // VAGen Info - items needed for migration
  VAGen_EZESYS char(8);
  VAGen_EZEREPLY num(1);
  VAGen_EZE_WAIT_TIME bin(9,2);
  VAGen_EZE_ITEMLEN int;

  // Use Declarations
  use XBDTBL {deleteAfterUse = yes}; // table
  use XCDTBL {deleteAfterUse = yes}; // table
  use XDNTBL {deleteAfterUse = yes}; // table
  use XEGTBL; // table
  use XGLTBL {deleteAfterUse = yes}; // table
  use XPKTBL {deleteAfterUse = yes}; // table
  use XPPTBL {deleteAfterUse = yes}; // table
  use XRSTBL {deleteAfterUse = yes}; // table
  use XSMTBL {deleteAfterUse = yes}; // table
  use XSZTBL {deleteAfterUse = yes}; // table
  use XMGDM.XMGDM002 // form
   {
    pfKeyEquate = no
  };

  function main()
    // VAGen Info - initialization needed for migration
    VAGen_EZESYS = VGLib.getVAGSysType();
    GD0P100: GD0P100();

     /* *************************************************************/

     /* GD0p150;*/

    if (GDWICSP == "XBD") /* bulk/draw table*/
      goto GD0P110;
    end

    if (GDWICSP == "XEG")
      goto GD0P130;
    end

    if (GDWICSP == "XCD") /* condition code TABLE*/
      goto GD0P150;
    end

    if (GDWICSP == "XSM") /* special commission table*/
      goto GD0P170;
    end

    if (GDWICSP == "XSZ") /* standard size dist TABLE*/
      goto GD0P190;
    end

    if (GDWICSP == "XPK") /* picking code TABLE*/
      goto GD0P210;
    end

    if (GDWICSP == "XPP") /* picking priority table*/
      goto GD0P230;
    end

    if (GDWICSP == "XDN") /* picking priority table*/
      goto GD0P250;
    end

    if (GDWICSP == "XRS") /* picking priority table*/
      goto GD0P270;
    end

    goto GD0P110; /* fail safe catch*/

    GD0P110: GD0P110();
    goto GD0P120;
     /* ***********************************************************/



    GD0P120: GD0P120();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0p110.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0P120;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0P110; /* recoNverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0P120; /* recoNverse map*/

      else

        goto GD0P110; /* recoNverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0P110; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0P110;

    end



    GD0P130: GD0P130();
    goto GD0P140;
     /* ***********************************************************/



    GD0P140: GD0P140();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0p130.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0P140;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0P130; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0P140; /* recoverse map*/

      else

        goto GD0P130; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0P130; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0P130;

    end



    GD0P150: GD0P150();
    goto GD0P160;
     /* ***********************************************************/



    GD0P160: GD0P160();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0p150.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0P160;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0P150; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0P160; /* recoverse map*/

      else

        goto GD0P150; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0P150; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0P150;

    end



    GD0P170: GD0P170();
    goto GD0P180;
     /* ***********************************************************/



    GD0P180: GD0P180();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0P170.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0P180;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0P170; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0P180; /* recoverse map*/

      else

        goto GD0P170; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0P170; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0P170;

    end



    GD0P190: GD0P190();
    goto GD0P200;
     /* ***********************************************************/



    GD0P200: GD0P200();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0P190.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0P200;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0P190; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0P200; /* recoverse map*/

      else

        goto GD0P190; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0P190; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0P190;

    end



    GD0P210: GD0P210();
    goto GD0P220;
     /* ***********************************************************/



    GD0P220: GD0P220();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0P210.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0P220;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0P210; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0P220; /* recoverse map*/

      else

        goto GD0P210; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0P210; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0P210;

    end



    GD0P230: GD0P230();
    goto GD0P240;
     /* ***********************************************************/



    GD0P240: GD0P240();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0P230.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0P240;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0P230; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0P240; /* recoverse map*/

      else

        goto GD0P230; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0P230; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0P230;

    end



    GD0P250: GD0P250();
    goto GD0P260;
     /* ***********************************************************/



    GD0P260: GD0P260();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0P250.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0P250;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0P250; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0P260; /* recoverse map*/

      else

        goto GD0P250; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0P250; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0P250;

    end



    GD0P270: GD0P270();
    goto GD0P280;
     /* ***********************************************************/



    GD0P280: GD0P280();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0P270.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0P270;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0P270; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0P280; /* recoverse map*/

      else

        goto GD0P270; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0P270; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0P270;

    end



  end // end main
end // end GD0P

// Check fast path and initialize
Function GD0P100()


     /* ********************************************************/
     /* * This process intializes program work areas, checks  **/
     /* * user security, and edits the option and item field. **/
     /* *              Flow depending on table                **/
     /* ********************************************************/

     /* check security.*/

   /* ************************************************************/
  XSENTRY(); /* removed for testing  <<<<<<<<<<*/
   /* ************************************************************/

   /* ************************************************************/
  XSSEGTR(); /* 11/88 jw - set segmented trans id*/
   /* ************************************************************/

   /* MOVE 'CSP' TO COMMAREA.CASYSINT ; by security for testing*/
   /* MOVE 'JWOOD ' TO COMMAREA.CAUSERID; by security for testing*/

  set GDWREC empty;
  set GD3REC empty;

  GD3REC.GD349B = " "; /* initialize working storage.*/
  GDWREC.GDWFLAGS = " "; /* initialize application flags.*/

     /* Find commarea.cafromap on table, if not there, save*/
     /* original application name in working storage.*/

  GDWREC.GDWTID = COMMAREA.CAFROMAP;
  if (GDWREC.GDWTID in XGLTBL.XGLTAPP)
    XSGDG12();
  else
    XSGDG14();
  end

  if (GDWREC.GDWEDIT == "F")

       /* not found on table, means it must be users application.*/
       /* save users application for PF2 direct return.*/

    GDWREC.GDWFMAPP = COMMAREA.CAFROMAP;
  end

  if (COMMAREA.CAITEM != GD3REC.GD320B) /* does item field have data.*/

            /* The first three bytes of the item field are the csp*/
       /* option. ,*/

    GDWREC.GDWITEM = COMMAREA.CAITEM; /* take it apart,*/

       /* Retreive the first column of the csp table based on the*/
       /* item option.  If the specified item is not a csp table*/
       /* then it must be an error. In this case display the csp*/
       /* tables as we normally would but with an error message*/
       /* for a invalid csp table option.*/

              /* SEARCH FOR SPECIFIED OPTION ON CSP TABLE.*/

    XSGDG10(); /* search for specified option on csp.*/

    if (GDWREC.GDWEDIT == "P") /* tran code found on csp*/

      if (XGLTBL.XGLTAPP[sysVar.arrayIndex] != "GD0P")

        COMMAREA.CATOAP = "GD0G"; /* invalid*/
        COMMAREA.CAITEM = GDWREC.GDWITEM; /* transfer*/
                                                  /* to gd0g display*/
        XSEXIT();

      else

        exit stack;

      end

    else /* not on table, must be outside CSP table appl.*/

      COMMAREA.CATOAP = "GD0G"; /* invalid CSP table*/
      COMMAREA.CAITEM = GDWREC.GDWITEM; /* transfer to GD0G table*/
                                                /* display*/
      XSEXIT();

    end /* if found on CSP table.*/

  end /* item field blank.  default to main menu.*/

  exit stack;




   /* *************************************************************/
end // end GD0P100

// clear screen, format display
Function GD0P110()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0p110 or GD0p120               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0PWBD empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0P110";


  XSGDG22();

  XMGDM002.XMGDMHED = "  XBD BULK/DRAW TABLE";

  GD3REC.GD3PEND1 = "CODE  DESCRIPTION         ";
  GD3REC.GD3PEND2 = "  ABBREV  |BULK|DRAW| SET ";
  GD3REC.GD3PEND3 = "|XREF|ALLOW|RSRV|CREDIT|S|";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====  ====================";
  GD3REC.GD3PEND2 = "  ======  | ?  | ?  |ASIDE";
  GD3REC.GD3PEND3 = "| ?  |LOC ?| ?  |CHK ? |T|";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0PS50(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0P110

// display XBD table values
Function GD0P120()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0P120

// clear screen, format display
Function GD0P130()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0P130 or GD0P140               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0PWEG empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0P130";


  XSGDG22();

  XMGDM002.XMGDMHED = "  XEG ENGINEERING DIFFERENCE TBL";

  GD3REC.GD3PEND1 = "CODE  DESCRIPTION         ";
  GD3REC.GD3PEND2 = "  ABBREV  STATUS          ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====  ====================";
  GD3REC.GD3PEND2 = "  ======  ======          ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0PS51(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0P130

// display XEG table values
Function GD0P140()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0P140

// clear screen, format display
Function GD0P150()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0P150 or GD0P160               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0PWCD empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0P150";


  XSGDG22();

  XMGDM002.XMGDMHED = "  XCD CONDITION CODE TABLE";

  GD3REC.GD3PEND1 = "COND  CONDITION          C";
  GD3REC.GD3PEND2 = "OND    ON-LINE AL  ORD-ENT";
  GD3REC.GD3PEND3 = " QTY  CALC    STATUS      ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "CODE      DESCRIPTION   AB";
  GD3REC.GD3PEND2 = "BREV   ALLOWED ?   ALLOWED";
  GD3REC.GD3PEND3 = " ?    AVL ?    CODE       ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0PS52(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0P150

// display XCD table values
Function GD0P160()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0P160

// clear screen, format display
Function GD0P170()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0P170 or GD0P180               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0PWSM empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0P170";


  XSGDG22();

  XMGDM002.XMGDMHED = "  XSM SPECIAL COMMISSION TABLE";

  GD3REC.GD3PEND1 = "SPL-CM  SPECIAL COMMISSION";
  GD3REC.GD3PEND2 = "   SPL-CM   SPL-COMM   STA";
  GD3REC.GD3PEND3 = "TUS                       ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = " CODE       DESCRIPTION   ";
  GD3REC.GD3PEND2 = "   ABBREV   REP/ADD ?   CO";
  GD3REC.GD3PEND3 = "DE                        ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0PS53(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0P170

// display XSM table values
Function GD0P180()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0P180

// clear screen, format display
Function GD0P190()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0P190 or GD0P200               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0PWSZ empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0P190";


  XSGDG22();

  XMGDM002.XMGDMHED = "  XSZ STANDARD SIZE DISTRIBUTION TABLE";

  GD3REC.GD3PEND1 = "DIST                      ";
  GD3REC.GD3PEND2 = "             # OF   DIST  ";
  GD3REC.GD3PEND3 = " DIST   DIST   DIST   STAT";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "CODE   STANDARD SIZE DESCR";
  GD3REC.GD3PEND2 = "IPTION       SIZES  PCT01 ";
  GD3REC.GD3PEND3 = " PCT02  PCT03  PCT04  CODE";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0PS54(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0P190

// display XSZ table values
Function GD0P200()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0P200

// clear screen, format display
Function GD0P210()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0P210 or GD0P220               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0PWPK empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0P210";


  XSGDG22();

  XMGDM002.XMGDMHED = "  XPK PICKING CODE TABLE";

  GD3REC.GD3PEND1 = "CODE  DESCRIPTION         ";
  GD3REC.GD3PEND2 = "            ABBREV  STATUS";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====  ====================";
  GD3REC.GD3PEND2 = "==========  ======  ======";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0PS55(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0P210

// display XPK table values
Function GD0P220()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0P220

// clear screen, format display
Function GD0P230()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0P230 or GD0P240               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0PWPP empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0P230";


  XSGDG22();

  XMGDM002.XMGDMHED = "  XPP PICKING PRIORITY TABLE";

  GD3REC.GD3PEND1 = " CODE  DESCRIPTION        ";
  GD3REC.GD3PEND2 = "             ABBREV  STATU";
  GD3REC.GD3PEND3 = "S                         ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = " ====  ===================";
  GD3REC.GD3PEND2 = "===========  ======  =====";
  GD3REC.GD3PEND3 = "=                         ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0PS56(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0P230

// display XPP table values
Function GD0P240()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0P240

// clear screen, format display
Function GD0P250()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0P250 or GD0P260               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0PWDN empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0P230";


  XSGDG22();

  XMGDM002.XMGDMHED = "  XDN DEALLOCATION REASON TABLE";

  GD3REC.GD3PEND1 = " REASON   ALLOC/DE-ALLOC  ";
  GD3REC.GD3PEND2 = "                          ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "  CODE        DESCRIPTION ";
  GD3REC.GD3PEND2 = "                ABBREV    ";
  GD3REC.GD3PEND3 = "STATUS                    ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0PS57(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0P250

// display Xdn table values
Function GD0P260()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0P260

// clear screen, format display
Function GD0P270()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0P270 or GD0P280               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0PWRS empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0P230";


  XSGDG22();

  XMGDM002.XMGDMHED = "  XRS RESERVATION REASON CODE TABLE";

  GD3REC.GD3PEND1 = "RSRV/DE-RSRV  RSRV/DE-RSRV";
  GD3REC.GD3PEND2 = "                 RSRV/DE-R";
  GD3REC.GD3PEND3 = "SRV                       ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "   CODE           DESCRIPT";
  GD3REC.GD3PEND2 = "ION                  ABBRE";
  GD3REC.GD3PEND3 = "V   STATUS                ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0PS58(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0P270

// display Xrs table values
Function GD0P280()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0P280

// Formats screen,autoskip XBD
Function GD0PS50()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XBD CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XBDTBL.XBDCD[GDWINDX2] != "9")

    GD0PWBD.XBDCD = XBDTBL.XBDCD[GDWINDX2];
    GD0PWBD.XBDABRV = XBDTBL.XBDABRV[GDWINDX2];
    GD0PWBD.XBDDESC = XBDTBL.XBDDESC[GDWINDX2];
    GD0PWBD.XBDBKOFL = XBDTBL.XBDBKOFL[GDWINDX2];
    GD0PWBD.XBDRWOFL = XBDTBL.XBDRWOFL[GDWINDX2];
    GD0PWBD.XBDSETFL = XBDTBL.XBDSETFL[GDWINDX2];
    GD0PWBD.XBDXRFCD = XBDTBL.XBDXRFCD[GDWINDX2];
    GD0PWBD.XBDAALOC = XBDTBL.XBDAALOC[GDWINDX2];
    GD0PWBD.XBDRVRFL = XBDTBL.XBDRVRFL[GDWINDX2];
    GD0PWBD.XBDCRCFL = XBDTBL.XBDCRCFL[GDWINDX2];
    GD0PWBD.XXXSTAT = XBDTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0PWBD.GD0PWBDR;

    set GD0PWBD empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XBDTBL.XBDCD[GDWINDX2] == "9")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0PS50

// Formats screen,autoskip XEG
Function GD0PS51()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XEG CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XEGTBL.XEGCD[GDWINDX2] != "999")

    GD0PWEG.XEGCD = XEGTBL.XEGCD[GDWINDX2];
    GD0PWEG.XEGDESC = XEGTBL.XEGDESC[GDWINDX2];
    GD0PWEG.XEGABRV = XEGTBL.XEGABRV[GDWINDX2];
    GD0PWEG.XXXSTAT = XEGTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0PWEG.GD0PWEGR;

    set GD0PWEG empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XEGTBL.XEGCD[GDWINDX2] == "999")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0PS51

// Formats screen,autoskip XCD
Function GD0PS52()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XCD CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XCDTBL.XCDCD[GDWINDX2] != "99")

    GD0PWCD.XCDCD = XCDTBL.XCDCD[GDWINDX2];
    GD0PWCD.XCDDESC = XCDTBL.XCDDESC[GDWINDX2];
    GD0PWCD.XCDABRV = XCDTBL.XCDABRV[GDWINDX2];
    GD0PWCD.XCDOALOC = XCDTBL.XCDOALOC[GDWINDX2];
    GD0PWCD.XCDENTFL = XCDTBL.XCDENTFL[GDWINDX2];
    GD0PWCD.XCDAVCLC = XCDTBL.XCDAVCLC[GDWINDX2];
    GD0PWCD.XXXSTAT = XCDTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0PWCD.GD0PWCDR;

    set GD0PWCD empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XCDTBL.XCDCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0PS52

// Formats screen,autoskip XSM
Function GD0PS53()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XSM CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XSMTBL.XSMCD[GDWINDX2] != "99")

    GD0PWSM.XSMCD = XSMTBL.XSMCD[GDWINDX2];
    GD0PWSM.XSMABRV = XSMTBL.XSMABRV[GDWINDX2];
    GD0PWSM.XSMDESC = XSMTBL.XSMDESC[GDWINDX2];
    GD0PWSM.XSMREPFL = XSMTBL.XSMREPFL[GDWINDX2];
    GD0PWSM.XXXSTAT = XSMTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0PWSM.GD0PWSMR;

    set GD0PWSM empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XSMTBL.XSMCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0PS53

// Formats screen,autoskip XSZ
Function GD0PS54()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XSZ CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XSZTBL.XSZCD[GDWINDX2] != "99")

    GD0PWSZ.XSZCD = XSZTBL.XSZCD[GDWINDX2];
    GD0PWSZ.XSZDESC = XSZTBL.XSZDESC[GDWINDX2];
    GD0PWSZ.GD0PWNSZ = XSZTBL.XSZNBRSZ[GDWINDX2];
    GD0PWSZ.GD0PWPC1 = XSZTBL.XSZPCT1[GDWINDX2];
    GD0PWSZ.GD0PWPC2 = XSZTBL.XSZPCT2[GDWINDX2];
    GD0PWSZ.GD0PWPC3 = XSZTBL.XSZPCT3[GDWINDX2];
    GD0PWSZ.GD0PWPC4 = XSZTBL.XSZPCT4[GDWINDX2];
    GD0PWSZ.XXXSTAT = XSZTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0PWSZ.GD0PWSZR;

    set GD0PWSZ empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XSZTBL.XSZCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0PS54

// Formats screen,autoskip XPK
Function GD0PS55()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XPK CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XPKTBL.XPKCD[GDWINDX2] != "99")

    GD0PWPK.XPKCD = XPKTBL.XPKCD[GDWINDX2];
    GD0PWPK.XPKABRV = XPKTBL.XPKABRV[GDWINDX2];
    GD0PWPK.XPKDESC = XPKTBL.XPKDESC[GDWINDX2];
    GD0PWPK.XXXSTAT = XPKTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0PWPK.GD0PWPKR;

    set GD0PWPK empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XPKTBL.XPKCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0PS55

// Formats screen,autoskip XPP
Function GD0PS56()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XPP CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XPPTBL.XPPCD[GDWINDX2] != "99")

    GD0PWPP.XPPCD = XPPTBL.XPPCD[GDWINDX2];
    GD0PWPP.XPPABRV = XPPTBL.XPPABRV[GDWINDX2];
    GD0PWPP.XPPDESC = XPPTBL.XPPDESC[GDWINDX2];
    GD0PWPP.XXXSTAT = XPPTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0PWPP.GD0PWPPR;

    set GD0PWPP empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XPPTBL.XPPCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0PS56

// Formats screen,autoskip Xdn
Function GD0PS57()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the Xdn CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XDNTBL.XDNCD[GDWINDX2] != "99")

    GD0PWDN.XDNCD = XDNTBL.XDNCD[GDWINDX2];
    GD0PWDN.XDNABRV = XDNTBL.XDNABRV[GDWINDX2];
    GD0PWDN.XDNDESC = XDNTBL.XDNDESC[GDWINDX2];
    GD0PWDN.XXXSTAT = XDNTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0PWDN.GD0PWDNR;

    set GD0PWDN empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XDNTBL.XDNCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0PS57

// Formats screen,autoskip Xrs
Function GD0PS58()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the Xrs CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XRSTBL.XRSCD[GDWINDX2] != "99")

    GD0PWRS.XRSCD = XRSTBL.XRSCD[GDWINDX2];
    GD0PWRS.XRSABRV = XRSTBL.XRSABRV[GDWINDX2];
    GD0PWRS.XRSDESC = XRSTBL.XRSDESC[GDWINDX2];
    GD0PWRS.XXXSTAT = XRSTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0PWRS.GD0PWRSR;

    set GD0PWRS empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XRSTBL.XRSCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0PS58

//*** RECORD=GD0PWBD ****
// ************************************************************
// *** CREATED: 11-16-86                 BY: JOHN WOOD      ***
// ***                                                      ***
// *** USED BY: GD0P          (SEE PROCESS LIST)            ***
// *** PURPOSE: TO DISPLAY CSP  XBDTBL DATA                 ***
// ************************************************************
// ***********************
Record GD0PWBD type basicRecord
  10 GD0PWBDR GD0PWBDR ; 
    20 XBDCD XBDCD ; 
    20 * char(5) ; 
    20 XBDDESC XBDDESC ; 
    20 * char(2) ; 
    20 XBDABRV XBDABRV ; 
    20 * char(4) ; 
    20 XBDBKOFL XBDBKOFL ; 
    20 * char(4) ; 
    20 XBDRWOFL XBDRWOFL ; 
    20 * char(4) ; 
    20 XBDSETFL XBDSETFL ; 
    20 * char(5) ; 
    20 XBDXRFCD XBDXRFCD ; 
    20 * char(5) ; 
    20 XBDAALOC XBDAALOC ; 
    20 * char(4) ; 
    20 XBDRVRFL XBDRVRFL ; 
    20 * char(5) ; 
    20 XBDCRCFL XBDCRCFL ; 
    20 * char(4) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(1) ; 
end // end GD0PWBD

//*** RECORD=GD0PWCD ****
// **** used by GD0P to SHOW XCDTBL DATA                   ****
// ************************************************************
// ***********************
Record GD0PWCD type basicRecord
  10 GD0PWCDR GD0PWCDR ; 
    20 * char(1) ; 
    20 XCDCD XCDCD ; 
    20 * char(3) ; 
    20 XCDDESC XCDDESC ; 
    20 * char(4) ; 
    20 XCDABRV XCDABRV ; 
    20 * char(7) ; 
    20 XCDOALOC XCDOALOC ; 
    20 * char(11) ; 
    20 XCDENTFL XCDENTFL ; 
    20 * char(10) ; 
    20 XCDAVCLC XCDAVCLC ; 
    20 * char(9) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(8) ; 
end // end GD0PWCD

//*** RECORD=GD0PWDN ****
// ************************************************************
// **** used by gd0p to show xdntbl                         ***
// ***********************
Record GD0PWDN type basicRecord
  10 GD0PWDNR GD0PWDNR ; 
    20 * char(3) ; 
    20 XDNCD XDNCD ; 
    20 * char(4) ; 
    20 XDNDESC XDNDESC ; 
    20 * char(3) ; 
    20 XDNABRV XDNABRV ; 
    20 * char(6) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(23) ; 
end // end GD0PWDN

//*** RECORD=GD0PWEG ****
// **** used by gd0P for XCBTBL   output -- jwood  11-16-86 ***
// ************************************************************
// ***********************
Record GD0PWEG type basicRecord
  10 GD0PWEGR GD0PWEGR ; 
    20 XEGCD XEGCD ; 
    20 * char(3) ; 
    20 XEGDESC XEGDESC ; 
    20 * char(2) ; 
    20 XEGABRV XEGABRV ; 
    20 * char(4) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(39) ; 
end // end GD0PWEG

//*** RECORD=GD0PWPK ****
// **** used by GD0P to SHOW XPKTBL DATA                    ***
// ************************************************************
// ***********************
Record GD0PWPK type basicRecord
  10 GD0PWPKR GD0PWPKR ; 
    20 * char(1) ; 
    20 XPKCD XPKCD ; 
    20 * char(3) ; 
    20 XPKDESC XPKDESC ; 
    20 * char(2) ; 
    20 XPKABRV XPKABRV ; 
    20 * char(4) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(29) ; 
end // end GD0PWPK

//*** RECORD=GD0PWPP ****
// **** used by GD0P to SHOW CSP XPPTBL DATA                ***
// ************************************************************
// ***********************
Record GD0PWPP type basicRecord
  10 GD0PWPPR GD0PWPPR ; 
    20 * char(2) ; 
    20 XPPCD XPPCD ; 
    20 * char(3) ; 
    20 XPPDESC XPPDESC ; 
    20 * char(2) ; 
    20 XPPABRV XPPABRV ; 
    20 * char(4) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(28) ; 
end // end GD0PWPP

//*** RECORD=GD0PWRS ****
// ************************************************************
// **** used by gd0p to show xrstbl                         ***
// ***********************
Record GD0PWRS type basicRecord
  10 GD0PWRSR GD0PWRSR ; 
    20 * char(4) ; 
    20 XRSCD XRSCD ; 
    20 * char(8) ; 
    20 XRSDESC XRSDESC ; 
    20 * char(3) ; 
    20 XRSABRV XRSABRV ; 
    20 * char(6) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(18) ; 
end // end GD0PWRS

//*** RECORD=GD0PWSM ****
// ************************************************************
// *** used by GD0P to SHOW CSP XSMTBL DATA                 ***
// ************************************************************
// ***********************
Record GD0PWSM type basicRecord
  10 GD0PWSMR GD0PWSMR ; 
    20 * char(1) ; 
    20 XSMCD XSMCD ; 
    20 * char(6) ; 
    20 XSMDESC XSMDESC ; 
    20 * char(6) ; 
    20 XSMABRV XSMABRV ; 
    20 * char(6) ; 
    20 XSMREPFL XSMREPFL ; 
    20 * char(8) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(26) ; 
end // end GD0PWSM

//*** RECORD=GD0PWSZ ****
// ************************************************************
// **** used by gd0p to show xsztbl                         ***
// ***********************
Record GD0PWSZ type basicRecord
  10 GD0PWSZR GD0PWSZR ; 
    20 XSZCD XSZCD ; 
    20 * char(4) ; 
    20 XSZDESC XSZDESC ; 
    20 * char(3) ; 
    20 GD0PWNSZ GD0PWNSZ ; 
    20 * char(3) ; 
    20 GD0PWPC1 GD0PWPC1 ; 
    20 * char(2) ; 
    20 GD0PWPC2 GD0PWPC2 ; 
    20 * char(2) ; 
    20 GD0PWPC3 GD0PWPC3 ; 
    20 * char(2) ; 
    20 GD0PWPC4 GD0PWPC4 ; 
    20 * char(4) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(1) ; 
end // end GD0PWSZ

DataItem GD0PWBDR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0PWCDR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0PWDNR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0PWEGR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// number of sizes
DataItem GD0PWNSZ num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// standard size dist pct01
DataItem GD0PWPC1 num(5,3)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// standard size dist pct02
DataItem GD0PWPC2 num(5,3)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// standard size dist pct03
DataItem GD0PWPC3 num(5,3)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// standard size dist pct04
DataItem GD0PWPC4 num(5,3)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

DataItem GD0PWPKR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0PWPPR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0PWRSR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0PWSMR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0PWSZR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

