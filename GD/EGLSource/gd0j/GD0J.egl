package gd0j;
import corpcom1.*;
import corpcom4.*;
import corpcom5.*;
import corpcom6.XMGDM;
import corpcom7.*;
import corpx1.*;
import corpx2.*;
import corpy2.*;
import corpz3.*;
import gd.common.*;
import in1.common.*;
import nl.common.*;
import pc.common.*;
import sy.common.*;
import ta.common.*;
import ts.common.*;
//*** PROGRAM=GD0J ****
// Nike on-line CSP table Display
// 
//                ORDER PROCESS DISPLAY APPLICATION
// 
// OVERVIEW:
// 
//     The purpose of the GD0J Order Process display appl.
// is to allow users of the Order Process CSP tables access to
// these tables in a fast and effieient manner.
// 
//     This application is drivin by the GD0G table display
// application which displays all the valid CSP tabls which
// this system is to access. The user then makes a selection
// of which table is to be displayed by entering the code
// (ie. "XCT", {country table}) in the option field. The table
// GD0GWT1 is then searched and if the code is entered is a
// valid table, control is then passed to the application re-
// ponsible for displaying that CSP table. This application
// displays all the Order Process tables.
// 
// 
// DATE CREATED: 06/07/86
//       AUTHOR: Rick Connoly
// 
// 
// MAINTENANCE HISTORY:
// 
//    DATE      BY WHOM          Over view of changes made
//  --------  ------------    ------------------------------
//  08-18-86  JWOOD           SPELLING ERRORS FOR MAP2 FIXED
//  11-11-88  JWOOD           added xssegtr logic
//  07-27-88  JWOOD           added flds to xvo display
//  02-19-91  vcowan          added flds to ypo display
//  02-25-91  vcowan          added flds to ybt & ybb display
//  04-11-91  vcowan          chg xocxlc1,2 to xlccd1,2 for
//                            csp/db2 chgs of 4-15-91
//  04-30-91  vcowan          add xhdshmm to screen display
//  05-02-91  vcowan          delete xkotbl display
//  05-03-91  vcowan          chg xhdtbl column heading from
//                            from 'minimum' to 'minutes;
//  05-20-91  vcowan          add ysutbl display
//  08-05-91  vcowan          add xpatbl display
//  10-09-91  JWOOD           CHANGED XHD DISPLAY
//  12-09-91  vcowan          added ylatbl display
//  02-07-92  vcowan          added yqttbl display
//  02-10-92  vcowan          added xgbtbl display
//  02-25-92  vcowan          added syrtbl display
//  05-18-92  vcowan          chg edit pattern for xhdshmm and
//                            xhdchg from '00000' to '00.000'
//  05-18-92  vcowan          added xbktbl display
//  06-11-92  vcowan          delete xdvcd from xwhtbl per
//                            june 1992 table change event
//  06-18-92  vcowan          added zcftbl display
//  03-03-92  vcowan          chg title of ycd table
//  07-13-93  JCAMPB          ADD COLS TO YQT TABLE DISPLAY
//  03-15-94  vcowan          add zfc-crcy-cd to xhdtbl display
//                            add zfc-crcy-cd to xwhtbl display
//                            delete recd gd0jwdd per xddtbl
//                            being deinstalled (chyde 12-7-93)
//  09-19-94  vcowan          added ZPRTBL display
//  11-01-94  vcowan          added XPMTBL display
//  01-10-95  vcowan          chg title for XBKTBL per chyde
//  02-08-96  vcowan          csp/db2 tbl structure change:
//                            add: pc-xct-orig-cd -- chg:
//                            yqt-qota-cat-cd char-3 to char-7
//  02-12-96  vcowan          add: pc-xct-orig-cd to scrn dsply
//                            install into prod on 2-16-96
//  05-17-96  vcowan          re-gen: yictbl tbl chg event
//                            install into prod on 5-17-96
//  12-04-96  vcowan          re-gen: xvotbl tbl chg event
//                            install into prod on 12-7-96
//  04-23-97  vcowan          add: displays for following:
//                            xzctbl - dcorp.vdays001 table
//                            yzmtbl - dcorp.vsumcd01 table
//                            install into prod on mm-dd-yy to
//                            be used with Corp Table Single
//                            Source process per D.Annanie
//  11-25-98  vcowan          install using big board processes
//                            apt code = srmt/csp
// *********************
Program GD0J type textUIProgram //VAGen Info - main text program
  {
  includeReferencedFunctions = yes, allowUnqualifiedItemReferences = yes, 
  throwNrfEofExceptions = yes, handleHardIOErrors = no, V60ExceptionCompatibility = yes, 
  I4GLItemsNullable = no, textLiteralDefaultIsString = no, localSQLScope = yes, 
  inputRecord = COMMAREA, segmented = yes
  }

  // Data Declarations
  COMMAREA COMMAREA ; // record
  GD0JW01 GD0JW01; // record
  GD0JWBB GD0JWBB; // record
  GD0JWBK GD0JWBK; // record
  GD0JWBR GD0JWBR; // record
  GD0JWBT GD0JWBT; // record
  GD0JWCD GD0JWCD; // record
  GD0JWCF GD0JWCF; // record
  GD0JWCQ GD0JWCQ; // record
  GD0JWDS GD0JWDS; // record
  GD0JWFA GD0JWFA; // record
  GD0JWFT GD0JWFT; // record
  GD0JWGB GD0JWGB; // record
  GD0JWHD GD0JWHD; // record
  GD0JWHR GD0JWHR; // record
  GD0JWIC GD0JWIC; // record
  GD0JWLA GD0JWLA; // record
  GD0JWOC GD0JWOC; // record
  GD0JWOD GD0JWOD; // record
  GD0JWOM GD0JWOM; // record
  GD0JWOS GD0JWOS; // record
  GD0JWOT GD0JWOT; // record
  GD0JWPA GD0JWPA; // record
  GD0JWPG GD0JWPG; // record
  GD0JWPM GD0JWPM; // record
  GD0JWPR GD0JWPR; // record
  GD0JWSH GD0JWSH; // record
  GD0JWSM GD0JWSM; // record
  GD0JWSO GD0JWSO; // record
  GD0JWSU GD0JWSU; // record
  GD0JWSY GD0JWSY; // record
  GD0JWTD GD0JWTD; // record
  GD0JWVO GD0JWVO; // record
  GD0JWWH GD0JWWH; // record
  GD0JWYP GD0JWYP; // record
  GD0JWYQ GD0JWYQ; // record
  GD0JWZC GD0JWZC; // record
  GD3REC GD3REC; // record
  GDWREC GDWREC; // record

  // VAGen Info - items needed for migration
  VAGen_EZESYS char(8);
  VAGen_EZEREPLY num(1);
  VAGen_EZE_WAIT_TIME bin(9,2);
  VAGen_EZE_ITEMLEN int;

  // Use Declarations
  use SYRTBL {deleteAfterUse = yes}; // table
  use XBRTBL {deleteAfterUse = yes}; // table
  use XBKTBL {deleteAfterUse = yes}; // table
  use XDSTBL {deleteAfterUse = yes}; // table
  use XFATBL {deleteAfterUse = yes}; // table
  use XGBTBL {deleteAfterUse = yes}; // table
  use XGLTBL {deleteAfterUse = yes}; // table
  use XHDTBL {deleteAfterUse = yes}; // table
  use XHRTBL {deleteAfterUse = yes}; // table
  use XOCTBL {deleteAfterUse = yes}; // table
  use XODTBL {deleteAfterUse = yes}; // table
  use XOMTBL {deleteAfterUse = yes}; // table
  use XOSTBL {deleteAfterUse = yes}; // table
  use XOTTBL {deleteAfterUse = yes}; // table
  use XPATBL {deleteAfterUse = yes}; // table
  use XPGTBL {deleteAfterUse = yes}; // table
  use XPMTBL {deleteAfterUse = yes}; // table
  use XSHTBL {deleteAfterUse = yes}; // table
  use XSOTBL {deleteAfterUse = yes}; // table
  use XTDTBL {deleteAfterUse = yes}; // table
  use XVOTBL {deleteAfterUse = yes}; // table
  use XWHTBL {deleteAfterUse = yes}; // table
  use XZCTBL {deleteAfterUse = yes}; // table
  use YBBTBL {deleteAfterUse = yes}; // table
  use YBTTBL {deleteAfterUse = yes}; // table
  use YCDTBL {deleteAfterUse = yes}; // table
  use YCQTBL {deleteAfterUse = yes}; // table
  use YFTTBL {deleteAfterUse = yes}; // table
  use YICTBL {deleteAfterUse = yes}; // table
  use YLATBL {deleteAfterUse = yes}; // table
  use YPOTBL {deleteAfterUse = yes}; // table
  use YQTTBL {deleteAfterUse = yes}; // table
  use YSMTBL {deleteAfterUse = yes}; // table
  use YSUTBL {deleteAfterUse = yes}; // table
  use ZCFTBL {deleteAfterUse = yes}; // table
  use ZPRTBL {deleteAfterUse = yes}; // table
  use XMGDM.XMGDM002 // form
   {
    pfKeyEquate = no
  };

  function main()
    // VAGen Info - initialization needed for migration
    VAGen_EZESYS = VGLib.getVAGSysType();
    GD0J100: GD0J100();

     /* *************************************************************/

    if (GDWICSP == "XBR") /* backorder reason code*/
      goto GD0J110;
    end

    if (GDWICSP == "YIC") /* inventory gl acct table*/
      goto GD0J130;
    end

    if (GDWICSP == "ZCF") /* nil commissions & fees*/
      goto GD0J150;
    end

    if (GDWICSP == "YPO") /* po required table*/
      goto GD0J170;
    end

    if (GDWICSP == "XDS") /* direct ship code table*/
      goto GD0J190;
    end

    if (GDWICSP == "YSU") /* sypply type code table*/
      goto GD0J210;
    end

    if (GDWICSP == "XOC") /* order class code table*/
      goto GD0J230;
    end

    if (GDWICSP == "XOM") /* order maintenance code*/
      goto GD0J250;
    end

    if (GDWICSP == "XOS") /* order status code*/
      goto GD0J270;
    end

    if (GDWICSP == "XOT") /* order type code*/
      goto GD0J290;
    end

    if (GDWICSP == "XSH") /* service hold code table*/
      goto GD0J310;
    end

    if (GDWICSP == "XSO") /* sales office code table*/
      goto GD0J330;
    end

    if (GDWICSP == "XHD") /* packing/handling code table*/
      goto GD0J350;
    end

    if (GDWICSP == "XOD") /* order type discount table*/
      goto GD0J370;
    end

    if (GDWICSP == "XPG") /* packing type table*/
      goto GD0J390;
    end

    if (GDWICSP == "YFT") /* financial transaction type table*/
      goto GD0J410;
    end

    if (GDWICSP == "XTD") /* trade discount table*/
      goto GD0J430;
    end

    if (GDWICSP == "XVO") /* valid sales office ordre type*/
      goto GD0J450;
    end

    if (GDWICSP == "XWH") /* warehouse code table*/
      goto GD0J470;
    end

    if (GDWICSP == "YBT") /* buyer title table*/
      goto GD0J490;
    end

    if (GDWICSP == "YBB") /* buyer resposnibility table*/
      goto GD0J510;
    end

    if (GDWICSP == "YCQ") /* product collections table*/
      goto GD0J530;
    end

    if (GDWICSP == "XHR") /* hold reasons code table*/
      goto GD0J550;
    end

    if (GDWICSP == "YCD") /* refer to credit cechking period*/
      goto GD0J570;
    end

    if (GDWICSP == "XFA") /* force reason code table*/
      goto GD0J590;
    end

    if (GDWICSP == "XPA") /* customer pack code table*/
      goto GD0J610;
    end

    if (GDWICSP == "YLA") /* label attachment code table*/
      goto GD0J630;
    end

    if (GDWICSP == "YQT") /* u.s. customs quota category*/
      goto GD0J650;
    end

    if (GDWICSP == "XGB") /* base gender age table*/
      goto GD0J670;
    end

    if (GDWICSP == "SYR") /* syr - catalog table*/
      goto GD0J690;
    end

    if (GDWICSP == "XBK") /* xbk - bookings season table*/
      goto GD0J710;
    end

    if (GDWICSP == "ZPR") /* zpr - nil invoice signature table*/
      goto GD0J730;
    end

    if (GDWICSP == "XPM") /* xpm - production method table*/
      goto GD0J750;
    end

    if (GDWICSP == "XZC") /* xzc - corp days table*/
      goto GD0J770;
    end

    if (GDWICSP == "YSM") /* ysm - sum code table*/
      goto GD0J790;
    end

    goto GD0J110; /* fail safe catch*/



    GD0J110: GD0J110();
    goto GD0J120;
     /* ***********************************************************/



    GD0J120: GD0J120();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0J110.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0J120;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0J110; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0J120; /* recoverse map*/

      else

        goto GD0J110; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0J110; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0J110;

    end



    GD0J130: GD0J130();
    goto GD0J140;
     /* ***********************************************************/



    GD0J140: GD0J140();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0J130.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0J140;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0J130; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0J140; /* recoverse map*/

      else

        goto GD0J130; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0J130; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0J130;

    end



    GD0J150: GD0J150();
    goto GD0J160;
     /* ***********************************************************/



    GD0J160: GD0J160();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0J150.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0J160;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0J150; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0J160; /* recoverse map*/

      else

        goto GD0J150; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0J150; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0J150;

    end



    GD0J170: GD0J170();
    goto GD0J180;
     /* ***********************************************************/



    GD0J180: GD0J180();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0J170.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0J180;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0J170; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0J180; /* recoverse map*/

      else

        goto GD0J170; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0J170; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0J170;

    end



    GD0J190: GD0J190();
    goto GD0J200;
     /* ***********************************************************/



    GD0J200: GD0J200();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0J190.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0J200;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0J190; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0J200; /* recoverse map*/

      else

        goto GD0J190; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0J190; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0J190;

    end



    GD0J210: GD0J210();
    goto GD0J220;
     /* ***********************************************************/



    GD0J220: GD0J220();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0J110.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0J220;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0J210; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0J220; /* recoverse map*/

      else

        goto GD0J210; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0J210; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0J210;

    end



    GD0J230: GD0J230();
    goto GD0J240;
     /* ***********************************************************/



    GD0J240: GD0J240();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0J230.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0J240;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0J230; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0J240; /* recoverse map*/

      else

        goto GD0J230; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0J230; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0J230;

    end



    GD0J250: GD0J250();
    goto GD0J260;
     /* ***********************************************************/



    GD0J260: GD0J260();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0J250.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0J260;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0J250; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0J260; /* recoverse map*/

      else

        goto GD0J250; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0J250; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0J250;

    end



    GD0J270: GD0J270();
    goto GD0J280;
     /* ***********************************************************/



    GD0J280: GD0J280();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0J270.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0J280;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0J270; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0J280; /* recoverse map*/

      else

        goto GD0J270; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0J270; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0J270;

    end



    GD0J290: GD0J290();
    goto GD0J300;
     /* ***********************************************************/



    GD0J300: GD0J300();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0j290.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0J300;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0J290; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0J300; /* recoverse map*/

      else

        goto GD0J290; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0J290; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0J290;

    end



    GD0J310: GD0J310();
    goto GD0J320;
     /* ***********************************************************/



    GD0J320: GD0J320();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0j310.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0J320;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0J310; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0J320; /* recoverse map*/

      else

        goto GD0J310; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0J310; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0J310;

    end



    GD0J330: GD0J330();
    goto GD0J340;
     /* ***********************************************************/



    GD0J340: GD0J340();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0J330.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0J340;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0J330; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0J340; /* recoverse map*/

      else

        goto GD0J330; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0J330; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0J330;

    end



    GD0J350: GD0J350();
    goto GD0J360;
     /* ***********************************************************/



    GD0J360: GD0J360();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0j350.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0J360;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0J350; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0J360; /* recoverse map*/

      else

        goto GD0J350; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0J350; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0J350;

    end



    GD0J370: GD0J370();
    goto GD0J380;
     /* ***********************************************************/



    GD0J380: GD0J380();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0J370.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0J380;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0J370; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0J380; /* recoverse map*/

      else

        goto GD0J370; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0J370; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0J370;

    end



    GD0J390: GD0J390();
    goto GD0J400;
     /* ***********************************************************/



    GD0J400: GD0J400();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0J390.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0J400;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0J390; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0J400; /* recoverse map*/

      else

        goto GD0J390; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0J390; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0J390;

    end



    GD0J410: GD0J410();
    goto GD0J420;
     /* ***********************************************************/



    GD0J420: GD0J420();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0J410.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0J420;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0J410; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0J420; /* recoverse map*/

      else

        goto GD0J410; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0J410; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0J410;

    end



    GD0J430: GD0J430();
    goto GD0J440;
     /* ***********************************************************/



    GD0J440: GD0J440();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0J430.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0J440;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0J430; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0J440; /* recoverse map*/

      else

        goto GD0J430; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0J430; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0J430;

    end



    GD0J450: GD0J450();
    goto GD0J460;
     /* ***********************************************************/



    GD0J460: GD0J460();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0J450.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0J460;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0J450; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0J460; /* recoverse map*/

      else

        goto GD0J450; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0J450; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0J450;

    end



    GD0J470: GD0J470();
    goto GD0J480;
     /* ***********************************************************/



    GD0J480: GD0J480();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0J470.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0J480;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0J470; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0J480; /* recoverse map*/

      else

        goto GD0J470; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0J470; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0J470;

    end



    GD0J490: GD0J490();
    goto GD0J500;



    GD0J500: GD0J500();
        /* flow logic for gd0j500*/

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0J490.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0J500;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0J490; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0J500; /* recoverse map*/

      else

        goto GD0J490; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0J490; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0J490;

    end



    GD0J510: GD0J510();
    goto GD0J520;
    GD0J520: GD0J520();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0J110.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0J520;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0J510; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0J520; /* recoverse map*/

      else

        goto GD0J510; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0J510; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0J510;

    end




    GD0J530: GD0J530();
    goto GD0J540;
    GD0J540: GD0J540();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0J110.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0J540;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0J530; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0J540; /* recoverse map*/

      else

        goto GD0J530; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0J530; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0J530;

    end



    GD0J550: GD0J550();
    goto GD0J560;
    GD0J560: GD0J560();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0J110.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0J560;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0J550; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0J560; /* recoverse map*/

      else

        goto GD0J550; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0J550; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0J550;

    end



    GD0J570: GD0J570();
    goto GD0J580;


    GD0J580: GD0J580();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0J570.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0J580;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0J570; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0J580; /* recoverse map*/

      else

        goto GD0J570; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0J570; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0J570;

    end



    GD0J590: GD0J590();
    goto GD0J600;
     /* ***********************************************************/



    GD0J600: GD0J600();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0J110.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0J600;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0J590; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0J600; /* recoverse map*/

      else

        goto GD0J590; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0J590; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0J590;

    end



    GD0J610: GD0J610();
    goto GD0J620;
     /* ***********************************************************/



    GD0J620: GD0J620();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0J110.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0J620;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0J610; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0J620; /* recoverse map*/

      else

        goto GD0J610; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0J610; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0J610;

    end



    GD0J630: GD0J630();
    goto GD0J640;
    GD0J640: GD0J640();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0J110.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0J640;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0J630; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0J640; /* recoverse map*/

      else

        goto GD0J630; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0J630; /* sets map clear, reloads date, and*/
                                     /* pending messages.*/

    else /* unsupported key.*/

      goto GD0J630;

    end




    GD0J650: GD0J650();
    goto GD0J660;
    GD0J660: GD0J660();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of gd0j650.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0J660;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0J650; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0J660; /* recoverse map*/

      else

        goto GD0J650; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0J650; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0J650;

    end



    GD0J670: GD0J670();
    goto GD0J680;
    GD0J680: GD0J680();
    /* GET GD0J.GD0j680*/

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0J110.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0J680;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0J670; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0J680; /* recoverse map*/

      else

        goto GD0J670; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0J670; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0J670;

    end



    GD0J690: GD0J690();
    goto GD0J700;
    GD0J700: GD0J700();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0J110.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0J700;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0J690; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0J700; /* recoverse map*/

      else

        goto GD0J690; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0J690; /* sets map clear, reloads date, and*/
                                     /* pending messages.*/

    else /* unsupported key.*/

      goto GD0J690;

    end



    GD0J710: GD0J710();
    goto GD0J720;
    GD0J720: GD0J720();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0J110.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0J720;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0J710; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0J720; /* recoverse map*/

      else

        goto GD0J710; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0J710; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0J710;

    end




    GD0J730: GD0J730();
    goto GD0J740;



    GD0J740: GD0J740();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0J110.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0J740;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0J730; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0J740; /* recoverse map*/

      else

        goto GD0J730; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0J730; /* sets map clear, reloads date, and*/
                                     /* pending messages.*/

    else /* unsupported key.*/

      goto GD0J730;

    end




    GD0J750: GD0J750();

    goto GD0J760;



    GD0J760: GD0J760();
    /* GET GD0J.GD0J760*/

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0J110.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0J760;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0J750; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0J760; /* recoverse map*/

      else

        goto GD0J750; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0J750; /* sets map clear, reloads date, and*/
                                     /* pending messages.*/

    else /* unsupported key.*/

      goto GD0J750;

    end




    GD0J770: GD0J770();

    goto GD0J780;



    GD0J780: GD0J780();
    /* GET GD0J.gd0j780*/
    /* GET GD0J.gd0j780*/

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0J110.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0J780;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0J770; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0J780; /* recoverse map*/

      else

        goto GD0J770; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0J770; /* sets map clear, reloads date, and*/
                                     /* pending messages.*/

    else /* unsupported key.*/

      goto GD0J770;

    end




    GD0J790: GD0J790();

    goto GD0J800;



    GD0J800: GD0J800();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0J110.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0J800;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0J790; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0J800; /* recoverse map*/

      else

        goto GD0J790; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0J790; /* sets map clear, reloads date, and*/
                                     /* pending messages.*/

    else /* unsupported key.*/

      goto GD0J790;

    end




  end // end main
end // end GD0J

// Check fast path and initialize
Function GD0J100()


     /* ********************************************************/
     /* * This process intializes program work areas, checks  **/
     /* * user security, and edits the option and item field. **/
     /* *              Flow depending on table                **/
     /* ********************************************************/

     /* check security.*/

   /* ************************************************************/
  XSENTRY(); /* removed for testing  <<<<<<<<<<*/
   /* ************************************************************/

   /* MOVE 'CSP' TO COMMAREA.CASYSINT ; by security for testing*/
   /* MOVE 'RCONNO' TO COMMAREA.CAUSERID; by security for testing*/

  set GDWREC empty;
  set GD3REC empty;

  GD3REC.GD349B = " "; /* initialize working storage.*/
  GDWREC.GDWFLAGS = " "; /* initialize application flags.*/

     /* Find commarea.cafromap on table, if not there, save*/
     /* original application name in working storage.*/

  GDWREC.GDWTID = COMMAREA.CAFROMAP;
  if (GDWREC.GDWTID in XGLTBL.XGLTAPP)
    XSGDG12();
  else
    XSGDG14();
  end

  if (GDWREC.GDWEDIT == "F")

       /* not found on table, means it must be users application.*/
       /* save users application for PF2 direct return.*/

    GDWREC.GDWFMAPP = COMMAREA.CAFROMAP;
  end

  if (COMMAREA.CAITEM != GD3REC.GD320B) /* does item field have data.*/

            /* The first three bytes of the item field are the csp*/
       /* option. ,*/

    GDWREC.GDWITEM = COMMAREA.CAITEM; /* take it apart,*/

       /* Retreive the first column of the csp table based on the*/
       /* item option.  If the specified item is not a csp table*/
       /* then it must be an error. In this case display the csp*/
       /* tables as we normally would but with an error message*/
       /* for a invalid csp table option.*/

              /* SEARCH FOR SPECIFIED OPTION ON CSP TABLE.*/

    XSGDG10(); /* search for specified option on csp.*/

    if (GDWREC.GDWEDIT == "P") /* tran code found on csp*/

      if (XGLTBL.XGLTAPP[sysVar.arrayIndex] != "GD0J")

        COMMAREA.CATOAP = "GD0G"; /* invalid*/
        COMMAREA.CAITEM = GDWREC.GDWITEM; /* transfer*/
                                                  /* to gd0g display*/
        XSEXIT();

      else

        exit stack;

      end

    else /* not on table, must be outside CSP table appl.*/

      COMMAREA.CATOAP = "GD0G"; /* invalid CSP table*/
      COMMAREA.CAITEM = GDWREC.GDWITEM; /* transfer to GD0G table*/
                                                /* display*/
      XSEXIT();

    end /* if found on CSP table.*/

  end /* item field blank.  default to main menu.*/

  exit stack;




   /* *************************************************************/
end // end GD0J100

// clear screen, format display
Function GD0J110()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0J110 or GD0J120               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0JWBR empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0J110";


  XSGDG22();

  XMGDM002.XMGDMHED = "  XBR BACKORDER REASON CODE TABLE";

  GD3REC.GD3PEND1 = "CODE         DESCRIPTION  ";
  GD3REC.GD3PEND2 = "          ABBREV     STATU";
  GD3REC.GD3PEND3 = "S                         ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====     =================";
  GD3REC.GD3PEND2 = "===       ======     =====";
  GD3REC.GD3PEND3 = "=                         ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0JS50(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0J110

// display XBR table values
Function GD0J120()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0J120

// clear screen, format display
Function GD0J130()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0J130 or GD0J140               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0JWIC empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0J130";


  XSGDG22();

  XMGDM002.XMGDMHED = "YIC INVENTORY GL ACCOUNT TABLE";

  GD3REC.GD3PEND1 = "CODE  SHORT DESCR.   GENER";
  GD3REC.GD3PEND2 = "A LEDGER ACCOUNT          ";
  GD3REC.GD3PEND3 = " STATUS                   ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====  =============  =====";
  GD3REC.GD3PEND2 = "========================= ";
  GD3REC.GD3PEND3 = " ======                   ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0JS51(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0J130

// display XCG table values
Function GD0J140()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0J140

// clear screen, format display
Function GD0J150()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0J150 or GD0J160               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0JWCF empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0J150";


  XSGDG22();

  XMGDM002.XMGDMHED = "ZCF -- NIL COMMISSIONS & FEE TABLE  ";

  GD3REC.GD3PEND1 = "CODE  DESCRIPTION         ";
  GD3REC.GD3PEND2 = "   EFFECTIVE  PERCENT  GRS";
  GD3REC.GD3PEND3 = "  NET  NSHO  CHG  STATUS  ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====  ====================";
  GD3REC.GD3PEND2 = "=    DATE     =======  NET";
  GD3REC.GD3PEND3 = "  BLL  ====  TYP  ======  ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0JS52(); /* format screen and fields to askip*/
                                   /* attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0J150

// display XDD table values
Function GD0J160()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0J160

// clear screen, format display
Function GD0J170()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0J170 or GD0J180               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0JWYP empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0J170";


  XSGDG22();

  XMGDM002.XMGDMHED = "      YPO - PO REQUIRED TABLE        ";

  GD3REC.GD3PEND1 = "CODE        DESCRIPTION   ";
  GD3REC.GD3PEND2 = "                    ABBREV";
  GD3REC.GD3PEND3 = "   STATUS                 ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====     =================";
  GD3REC.GD3PEND2 = "=========           ======";
  GD3REC.GD3PEND3 = "   ======                 ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";


  GD0JS53(); /* FORMAT SCREEN AND FIELDS TO ASKIP ATTRIBUTE.*/


  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0J170

// display XDR table values
Function GD0J180()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0J180

// clear screen, format display
Function GD0J190()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0J190 or GD0J200               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0JWDS empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0J190";


  XSGDG22();

  XMGDM002.XMGDMHED = "  XDS DIRECT SHIP CODE TABLE";

  GD3REC.GD3PEND1 = " DS   DIRECT SHIP         "; /* 10/27/86-JW*/
  GD3REC.GD3PEND2 = " DIR-SHP  DIR-SHP  DIR-SHP"; /* 10/27/86-JW*/
  GD3REC.GD3PEND3 = "  GL CODE   DS DEMAND    S";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "CODE  DESCRIPTION         ";
  GD3REC.GD3PEND2 = "  ABBREV   WHSE ?  ALLOW %";
  GD3REC.GD3PEND3 = "  OFF-FACE    AVAIL ?    T";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0JS54(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0J190

// display XDS table values
Function GD0J200()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0J200

// clear screen, format display
Function GD0J210()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0J110 or GD0J120               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0JWSU empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0J210";


  XSGDG22();

  XMGDM002.XMGDMHED = "  YSU -- SUPPLY TYPE CODE TABLE  ";

  GD3REC.GD3PEND1 = "CODE         DESCRIPTION  ";
  GD3REC.GD3PEND2 = "          ABBREV     STATU";
  GD3REC.GD3PEND3 = "S                         ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====     =================";
  GD3REC.GD3PEND2 = "===       ======     =====";
  GD3REC.GD3PEND3 = "=                         ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0JS55(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0J210

// display YSU table values
Function GD0J220()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0J220

// clear screen, format display
Function GD0J230()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0J230 or GD0J240               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0JWOC empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0J230";


  XSGDG22();

  XMGDM002.XMGDMHED = "  XOC ORDER CLASS CODE  TABLE";

  GD3REC.GD3PEND1 = "CLS                       ";
  GD3REC.GD3PEND2 = "           DIV  FUT A/O  L";
  GD3REC.GD3PEND3 = "IF  LIF PK    PK  STATUS  ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "CD   DESCRIPTION          ";
  GD3REC.GD3PEND2 = "  ABBREV   CD   FL  FL   C";
  GD3REC.GD3PEND3 = "Y1  CY2 PRTY  CD   CODE   ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0JS56(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0J230

// display XOC table values
Function GD0J240()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0J240

// clear screen, format display
Function GD0J250()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0J250 or GD0J260               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0JWOM empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0J250";


  XSGDG22();

  XMGDM002.XMGDMHED = "  XOM ORDER MAINT. REASON CODE TABLE";

  GD3REC.GD3PEND1 = "REASON                    ";
  GD3REC.GD3PEND2 = "                       CAN";
  GD3REC.GD3PEND3 = "CEL   REQ. TYPE   STATUS  ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = " CODE      DESCRIPTION    ";
  GD3REC.GD3PEND2 = "            ABBREV.      F";
  GD3REC.GD3PEND3 = "LAG      CODE       CODE  ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0JS57(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0J250

// display XOM table values
Function GD0J260()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0J260

// clear screen, format display
Function GD0J270()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0J270 or GD0J280               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0JWOS empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0J270";


  XSGDG22();

  XMGDM002.XMGDMHED = "  XOS ORDER STATUS CODE TABLE";

  GD3REC.GD3PEND1 = "CODE        DESCRIPTION   ";
  GD3REC.GD3PEND2 = "          ABBREV    ALW  A";
  GD3REC.GD3PEND3 = "LW    AVL   PR D/A  STATUS";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====     =================";
  GD3REC.GD3PEND2 = "===       ======    CHG  C";
  GD3REC.GD3PEND3 = "NCL   FL    ARRAY    CODE ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0JS58(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0J270

// display XOS table values
Function GD0J280()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0J280

// clear screen, format display
Function GD0J290()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0J290 or GD0J300               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0JWOT empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0J290";


  XSGDG22();

  XMGDM002.XMGDMHED = "  XOT ORDER TYPE CODE TABLE";

  GD3REC.GD3PEND1 = "CODE        DESCRIPTION   ";
  GD3REC.GD3PEND2 = "                    ABBREV";
  GD3REC.GD3PEND3 = "     SHORT ABRV     STATUS";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====     =================";
  GD3REC.GD3PEND2 = "=============       ======";
  GD3REC.GD3PEND3 = "     ==========     ======";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0JS59(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0J290

// display XOT table values
Function GD0J300()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0J300

// clear screen, format display
Function GD0J310()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0J300 or GD0J310               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0JWSH empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0J310";


  XSGDG22();

  XMGDM002.XMGDMHED = "  XSH SERVICE HOLD CODE TABLE";

  GD3REC.GD3PEND1 = "CODE         DESCRIPTION  ";
  GD3REC.GD3PEND2 = "          ABBREV     STATU";
  GD3REC.GD3PEND3 = "S                         ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====     =================";
  GD3REC.GD3PEND2 = "===       ======     =====";
  GD3REC.GD3PEND3 = "=                         ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0JS60(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0J310

// display XSH table values
Function GD0J320()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0J320

// clear screen, format display
Function GD0J330()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0J330 or GD0J340               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0JWSO empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0J330";


  XSGDG22();

  XMGDM002.XMGDMHED = "  XSO SALES OFFICE CODE TABLE";

  GD3REC.GD3PEND1 = "CODE         DESCRIPTION  ";
  GD3REC.GD3PEND2 = "                    SHORT ";
  GD3REC.GD3PEND3 = "NAME     DIV. CODE  STATUS";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====     =================";
  GD3REC.GD3PEND2 = "=============       ======";
  GD3REC.GD3PEND3 = "======   =========  ======";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0JS61(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0J330

// display XSO table values
Function GD0J340()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0J340

// clear screen, format display
Function GD0J350()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0J350 or GD0J360               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0JWHD empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0J350";


  XSGDG22();

  XMGDM002.XMGDMHED = "  XHD PACK AND HANDLING CODE TABLE";

  GD3REC.GD3PEND1 = " KEY  DESCRIPTION         ";
  GD3REC.GD3PEND2 = "           ABBREV UNIT    ";
  GD3REC.GD3PEND3 = " UNIT   GL MINUTES CRCY S ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "===== ====================";
  GD3REC.GD3PEND2 = "========== ======  FL     ";
  GD3REC.GD3PEND3 = "CHARGE  CD ======= ==== T ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0JS62(); /* format screen and fields to askip*/
                                   /* attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0J350

// display XHD table values
Function GD0J360()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0J360

// clear screen, format display
Function GD0J370()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0J370 or GD0J380               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0JWOD empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0J370";


  XSGDG22();

  XMGDM002.XMGDMHED = "  XOD ORDER TYPE DISCOUNT TABLE";

  GD3REC.GD3PEND1 = "OT  NEED      END      TER";
  GD3REC.GD3PEND2 = "M  DIS BANK  OFF FACE ALW ";
  GD3REC.GD3PEND3 = " ALLOW  ALLOW  COOP MAX  S";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "CD  DATE      DATE     COD";
  GD3REC.GD3PEND2 = "E  CD    %      %     CDE ";
  GD3REC.GD3PEND3 = " BANK%  OFF%   GRP DISCT T";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0JS63(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0J370

// display XOD table values
Function GD0J380()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0J380

// clear screen, format display
Function GD0J390()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0J390 or GD0J400               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0JWPG empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0J390";


  XSGDG22();

  XMGDM002.XMGDMHED = "  XPG PACKAGING TYPE TABLE";

  GD3REC.GD3PEND1 = " P/T     PACKAGING TYPE   ";
  GD3REC.GD3PEND2 = "    PKGNG TYPE            ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "CODE        DESCRIPTION   ";
  GD3REC.GD3PEND2 = "      ABRV       STAT     ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0JS64(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0J390

// display XPG table values
Function GD0J400()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0J400

// clear screen, format display
Function GD0J410()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0J400 or GD0J410               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0JWFT empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0J410";


  XSGDG22();

  XMGDM002.XMGDMHED = "YFT FINANCIAL TRANS TYPE TABLE";

  GD3REC.GD3PEND1 = "CODE  SHORT DESCR.  DESCRI";
  GD3REC.GD3PEND2 = "PTION                     ";
  GD3REC.GD3PEND3 = "STATUS                    ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====  ============  ======";
  GD3REC.GD3PEND2 = "========================  ";
  GD3REC.GD3PEND3 = "======                    ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0JS65(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0J410

// display YFT table values
Function GD0J420()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0J420

// clear screen, format display
Function GD0J430()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0J430 or GD0J440               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0JWTD empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0J430";


  XSGDG22();

  XMGDM002.XMGDMHED = "  XTD TRADE DISCOUNT TABLE"; /* 10/27/86-JW*/

  GD3REC.GD3PEND1 = "CODE      DESCRIPTION     "; /* 10/27/86-JW*/
  GD3REC.GD3PEND2 = "     ABBREV.      T/D %   "; /* 10/27/86-JW*/
  GD3REC.GD3PEND3 = "GL BK   GL FC   STATUS    ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====    ==================";
  GD3REC.GD3PEND2 = "==   =======     ======   ";
  GD3REC.GD3PEND3 = "=====   =====   ======    ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0JS66(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0J430

// display XTD table values
Function GD0J440()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0J440
// clear screen, format display
Function GD0J450()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0J450 or GD0J460               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0JWVO empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0J450";


  XSGDG22();

  XMGDM002.XMGDMHED = "XVO BASE ORDER TYPE CONVERSION TABLE";

  GD3REC.GD3PEND1 = "BASE OT  DIV.  BRAND CD  G";
  GD3REC.GD3PEND2 = " P C  SALES OFC  PRODUCT C";
  GD3REC.GD3PEND3 = "AT  ORDER TYP  STATUS     ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "=======  ====  ========  =";
  GD3REC.GD3PEND2 = "====  =========  =========";
  GD3REC.GD3PEND3 = "==  =========  ======     ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0JS67(); /* format screen and fields to askip*/
                                   /* attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0J450

// display XVO table values
Function GD0J460()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0J460

// clear screen, format display
Function GD0J470()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0J470 or GD0J480               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0JWWH empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0J470";


  XSGDG22();

  XMGDM002.XMGDMHED = "  XWH WAREHOUSE CODE TABLE";

  GD3REC.GD3PEND1 = " WH          WAREHOUSE    ";
  GD3REC.GD3PEND2 = "          WH   DA OR TP  C";
  GD3REC.GD3PEND3 = "ITY                 CRCY S";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "CODE           NAME       ";
  GD3REC.GD3PEND2 = "         ABRV  CD CD CD  =";
  GD3REC.GD3PEND3 = "==================  ==== T";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0JS68(); /* format screen and fields to askip*/
                                   /* attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0J470

// display XWH table values
Function GD0J480()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0J480

// clear screen, format ybt tbl
Function GD0J490()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0J490 or GD0J500               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0JWBT empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0J490";


  XSGDG22();

  XMGDM002.XMGDMHED = "  YBT - BUYER TABLE       ";

  GD3REC.GD3PEND1 = "CODE   ABBREV   DESCRITPIO";
  GD3REC.GD3PEND2 = "N                 STATUS  ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====   ======   ==========";
  GD3REC.GD3PEND2 = "===============   ======  ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0JS69(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0J490

// display ybt table values
Function GD0J500()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0J500

// clear screen, format ybb tbl
Function GD0J510()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0J510 or GD0J520               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0JWBB empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0J510";


  XSGDG22();

  XMGDM002.XMGDMHED = "YBB - BUYER RESPONSIBILITY";

  GD3REC.GD3PEND1 = "CODE   ABBREV   DESCRITPIO";
  GD3REC.GD3PEND2 = "N                 STATUS  ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====   ======   ==========";
  GD3REC.GD3PEND2 = "===============   ======  ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0JS70(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0J510

// display ybb table values
Function GD0J520()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0J520

// clear screen, format ybb tbl
Function GD0J530()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0J510 or GD0J520               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0JWCQ empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0J530";


  XSGDG22();

  XMGDM002.XMGDMHED = "YCQ - PRODUCT COLLECTIONS ";

  GD3REC.GD3PEND1 = "CODE   DESCRIPTION        ";
  GD3REC.GD3PEND2 = "               ABBRV    ST";
  GD3REC.GD3PEND3 = "ATUS                      ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====   ===================";
  GD3REC.GD3PEND2 = "============   ======   ==";
  GD3REC.GD3PEND3 = "====                      ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0JS71(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0J530

// display ybb table values
Function GD0J540()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0J540

// clear screen, format XHR tbl
Function GD0J550()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0J510 or GD0J520               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0JWHR empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0J530";


  XSGDG22();

  XMGDM002.XMGDMHED = "XHR - HOLD REASON CODES   ";

  GD3REC.GD3PEND1 = "CODE   DESCRIPTION        ";
  GD3REC.GD3PEND2 = "    ABBREV   STATUS       ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====   ===================";
  GD3REC.GD3PEND2 = "=   ======   ======       ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0JS72(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0J550

// display XHR table values
Function GD0J560()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0J560

// clear screen, format display
Function GD0J570()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0J570 or GD0J580               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0JWCD empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0J570";


  XSGDG22();

  XMGDM002.XMGDMHED = "YCD -- CREDIT CHECK SCHEDULE     ";

  GD3REC.GD3PEND1 = "          CREDIT CHECKING ";
  GD3REC.GD3PEND2 = "DATE          FUTURE CREDI";
  GD3REC.GD3PEND3 = "T CHECKING PERIOD         ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "          ================";
  GD3REC.GD3PEND2 = "====          | FROM |    ";
  GD3REC.GD3PEND3 = "         |  TO  |         ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0JS73(); /* format screen and fields to askip*/
                                   /* attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0J570

// display ycd table values
Function GD0J580()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0J580

// clear screen, format display
Function GD0J590()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0J590 or GD0J600               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0JWFA empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0J590";


  XSGDG22();

  XMGDM002.XMGDMHED = "  XFA -- FORCE REASON CODE TABLE ";

  GD3REC.GD3PEND1 = "CODE  INDICATOR  DESCRIPTI";
  GD3REC.GD3PEND2 = "ON                        ";
  GD3REC.GD3PEND3 = "                 STATUS   ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====  =========  =========";
  GD3REC.GD3PEND2 = "==========================";
  GD3REC.GD3PEND3 = "===============  ======   ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0JS74(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0J590

// display XFA table values
Function GD0J600()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0J600

// clear screen, format display
Function GD0J610()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0J610 or GD0J620               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0JWPA empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0J610";


  XSGDG22();

  XMGDM002.XMGDMHED = " XPA -- CUSTOMER PACK CODE TABLE ";

  GD3REC.GD3PEND1 = "CODE  DESCRITION          ";
  GD3REC.GD3PEND2 = "            ABBREV  STY   ";
  GD3REC.GD3PEND3 = "STY   SPF   INNER  STATUS ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====  ====================";
  GD3REC.GD3PEND2 = "==========  ======  COLR  ";
  GD3REC.GD3PEND3 = "SIZE  PACK  PACK   ====== ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0JS75(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0J610

// display XPA table values
Function GD0J620()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0J620

// clear screen, format ybb tbl
Function GD0J630()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0J630 or GD0J640               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0JWLA empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0J630";


  XSGDG22();

  XMGDM002.XMGDMHED = "YLA--LABEL ATTACHMENT CODE";

  GD3REC.GD3PEND1 = "CODE   DESCRIPTION        ";
  GD3REC.GD3PEND2 = "              ABBREV   STA";
  GD3REC.GD3PEND3 = "TUS                       ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====   ===================";
  GD3REC.GD3PEND2 = "===========   ======   ===";
  GD3REC.GD3PEND3 = "===                       ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0JS76(); /* format screen and fields to askip*/
                                   /* attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0J630

// display YBB table values
Function GD0J640()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0J640

// clear screen, format display
Function GD0J650()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0J650 or GD0J660               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0JWYQ empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0J650";


  XSGDG22();

  XMGDM002.XMGDMHED = "YQT - U.S. CUSTOMS QUOTA CATEGORY";

  GD3REC.GD3PEND1 = "QUOTA   CTRY CTRY SHP FIBE";
  GD3REC.GD3PEND2 = "R     DESCRIPTION         ";
  GD3REC.GD3PEND3 = "                     UNT S";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "CAT     ORIG CODE RGN ====";
  GD3REC.GD3PEND2 = "===== ====================";
  GD3REC.GD3PEND3 = "==================== === T";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0JS77(); /* format screen and fields to askip*/
                                   /* attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0J650

// display YQT table values
Function GD0J660()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0J660

// clear screen, format display
Function GD0J670()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0J110 or GD0J120               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0JWGB empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0J670";


  XSGDG22();

  XMGDM002.XMGDMHED = "  XGB - BASE GENDER AGE TABLE    ";

  GD3REC.GD3PEND1 = "CODE     DESCRIPTION      ";
  GD3REC.GD3PEND2 = "     ABBREV     STATUS    ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====     ===============  ";
  GD3REC.GD3PEND2 = "     ======     =======   ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0JS78(); /* format screen and fields to askip*/
                                   /* attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0J670

// display XGB table values
Function GD0J680()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0J680

// clear screen, format display
Function GD0J690()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0J110 or GD0J120               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0JWSY empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0J690";


  XSGDG22();

  XMGDM002.XMGDMHED = "     SYR - CATALOG TABLE         ";

  GD3REC.GD3PEND1 = "CATALOG  GPC  SEASON  YEAR";
  GD3REC.GD3PEND2 = "  CATALOG DESCRIPTION     ";
  GD3REC.GD3PEND3 = "        STATUS            ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "   ID    ===  ======  ====";
  GD3REC.GD3PEND2 = "  ========================";
  GD3REC.GD3PEND3 = "======  ======            ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0JS79(); /* format screen and fields to askip*/
                                   /* attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0J690

// display SYR table values
Function GD0J700()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0J700

// clear screen, format display
Function GD0J710()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0J510 or GD0J520               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0JWBK empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0J710";


  XSGDG22();

  XMGDM002.XMGDMHED = "XBK--U.S. BOOKINGS SEASON TABLE";

  GD3REC.GD3PEND1 = "CODE  DESCRIPTION       AB";
  GD3REC.GD3PEND2 = "BREV  STATUS              ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====  ===============   ==";
  GD3REC.GD3PEND2 = "====  ======              ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0JS80(); /* format screen and fields to askip*/
                                   /* attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0J710

// display XBK table values
Function GD0J720()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0J720

// clear screen, format display
Function GD0J730()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0J510 or GD0J520               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0JWPR empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0J730";


  XSGDG22();

  XMGDM002.XMGDMHED = "ZPR - NIL INVOICE SIGNATURE TABLE";

  GD3REC.GD3PEND1 = "USER ID  NAME             ";
  GD3REC.GD3PEND2 = "              JOB TITLE   ";
  GD3REC.GD3PEND3 = "                    STATUS";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "======   =================";
  GD3REC.GD3PEND2 = "=============  ===========";
  GD3REC.GD3PEND3 = "=================== ======";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0JS81(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0J730

// display XBK table values
Function GD0J740()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0J740
// clear screen, format display
Function GD0J750()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0J510 or GD0J520               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0JWPM empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0J750";


  XSGDG22();

  XMGDM002.XMGDMHED = "XPM - PRODUCTION METHOD TABLE";

  GD3REC.GD3PEND1 = "CODE  ABBREV  DESCRIPTION ";
  GD3REC.GD3PEND2 = "           S/S CHG  STAT  ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====  ======  ============";
  GD3REC.GD3PEND2 = "=========  =======  ====  ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0JS82(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0J750

// display XBK table values
Function GD0J760()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0J760

// clear screen, format display
Function GD0J770()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0J770 or GD0J780               **/
     /* *********************************************************/

  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0JWZC empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0J750";


  XSGDG22();

  XMGDM002.XMGDMHED = "XZC - CORPORATE CALENDAR TABLE";

  GD3REC.GD3PEND1 = "XZCCLNDT  XZCGLPM1  XZCGLP";
  GD3REC.GD3PEND2 = "M2  XZCGLPM3  XZCFISMO  XZ";
  GD3REC.GD3PEND3 = "CGLEDT  ZZZSDT    ZZZCHGDT";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "========  ========  ======";
  GD3REC.GD3PEND2 = "==  ========  ========  ==";
  GD3REC.GD3PEND3 = "======  ========  ========";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0JS83(); /* format screen and fields to askip*/
                                   /* attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0J770

// display XBK table values
Function GD0J780()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/

  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0J780

// clear screen, format display
Function GD0J790()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0J770 or GD0J780               **/
     /* *********************************************************/

  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0JWSM empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0J750";


  XSGDG22();

  XMGDM002.XMGDMHED = "     YSM - SUM CODE TABLE     ";

  GD3REC.GD3PEND1 = "TBL  SYS  SUM  SUM  SR-CVL";
  GD3REC.GD3PEND2 = "  DESCRIPTION             ";
  GD3REC.GD3PEND3 = "    ST  ZZZSDT    ZZZCHGDT";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "PFX  PFX  ID   CODE ======";
  GD3REC.GD3PEND2 = "  ========================";
  GD3REC.GD3PEND3 = "==  ==  ========  ========";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0JS84(); /* format screen and fields to askip*/
                                   /* attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0J790

// display XBK table values
Function GD0J800()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/

  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0J800

// Formats screen,autoskip XBR
Function GD0JS50()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XBR CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XBRTBL.XBRCD[GDWINDX2] != "99")

    GD0JWBR.XBRCD = XBRTBL.XBRCD[GDWINDX2];
    GD0JWBR.XBRABRV = XBRTBL.XBRABRV[GDWINDX2];
    GD0JWBR.XBRDESC = XBRTBL.XBRDESC[GDWINDX2];
    GD0JWBR.XXXSTAT = XBRTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0JWBR.GD0JWBRR;

    set GD0JWBR empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XBRTBL.XBRCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0JS50

// Formats screen,autoskip YIC
Function GD0JS51()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the YIC CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end



  while (GDWREC.GDWINDX1 <= 14
   && YICTBL.YICCD[GDWINDX2] != 9999)

    GD0JWIC.GD0JWICC = YICTBL.YICCD[GDWINDX2];
    GD0JWIC.YICSDESC = YICTBL.YICSDESC[GDWINDX2];
    GD0JWIC.GLACCT = YICTBL.GLACCT[GDWINDX2];
    GD0JWIC.XXXSTAT = YICTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0JWIC.GD0JWICR;

    set GD0JWIC empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (YICTBL.YICCD[GDWINDX2] == 9999)

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0JS51

// Formats screen,autoskip XDD
Function GD0JS52()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XDD CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && ZCFTBL.ZCF-COMM-FEE-CD[GDWINDX2] != "99")

    GD0JWCF.ZCF-COMM-FEE-CD = ZCFTBL.ZCF-COMM-FEE-CD[GDWINDX2];
    GD0JWCF.ZCF-COMM-FEE-DESC = ZCFTBL.ZCF-COMM-FEE-DESC[GDWINDX2];
    GD0JWCF.GD0JW-ZCF-COMM-FEE-EDT = ZCFTBL.ZCF-COMM-FEE-EDT[GDWINDX2];
    GD0JW01.GD0JW-ZCF-COMM-FEE-PCT = ZCFTBL.ZCF-COMM-FEE-PCT[GDWINDX2];
    GD0JWCF.GD0JW-ZCF-COMM-FEE-PCT1-2 = GD0JW01.GD0JW-ZCF-COMM-FEE-PCT1-2;
    GD0JWCF.GD0JW-ZCF-COMM-FEE-PCT-DOT = ".";
    GD0JWCF.GD0JW-ZCF-COMM-FEE-PCT3-5 = GD0JW01.GD0JW-ZCF-COMM-FEE-PCT3-5;
    GD0JWCF.ZCF-GRS-NET-IND = ZCFTBL.ZCF-GRS-NET-IND[GDWINDX2];
    GD0JWCF.ZCF-NET-BILL-FL = ZCFTBL.ZCF-NET-BILL-FL[GDWINDX2];
    GD0JWCF.ZCF-NISSHO-FL = ZCFTBL.ZCF-NISSHO-FL[GDWINDX2];
    GD0JWCF.ZCHCD = ZCFTBL.ZCHCD[GDWINDX2];
    GD0JWCF.XXXSTAT = ZCFTBL.XXXSTAT[GDWINDX2];

    XMGDM002.XMGDMLIN[GDWINDX1] = GD0JWCF.GD0JWCFR;

    set GD0JWCF empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (ZCFTBL.ZCF-COMM-FEE-CD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0JS52

// Formats screen,autoskip YPO
Function GD0JS53()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the YPO CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && YPOTBL.YPOCD[GDWINDX2] != "99")

    GD0JWYP.YPOCD = YPOTBL.YPOCD[GDWINDX2];
    GD0JWYP.YPOABRV = YPOTBL.YPOABRV[GDWINDX2];
    GD0JWYP.YPODESC = YPOTBL.YPODESC[GDWINDX2];
    GD0JWYP.XXXSTAT = YPOTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0JWYP.GD0JWYPO;

    set GD0JWYP empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (YPOTBL.YPOCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0JS53

// Formats screen,autoskip XDS
Function GD0JS54()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XDS CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XDSTBL.XDSCD[GDWINDX2] != "9")

    GD0JWDS.XDSCD = XDSTBL.XDSCD[GDWINDX2];
    GD0JWDS.XDSABRV = XDSTBL.XDSABRV[GDWINDX2];
    GD0JWDS.XDSDESC = XDSTBL.XDSDESC[GDWINDX2];
    GD0JWDS.XDSWHSEF = XDSTBL.XDSWHSEF[GDWINDX2];
    GD0JWDS.GD0JWPCT = XDSTBL.XDSPCT[GDWINDX2];
    GD0JWDS.GLFCD = XDSTBL.GLFCD[GDWINDX2];
    GD0JWDS.XDSAVDFL = XDSTBL.XDSAVDFL[GDWINDX2];
    GD0JWDS.XXXSTAT = XDSTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0JWDS.GD0JWDSR;

    set GD0JWDS empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XDSTBL.XDSCD[GDWINDX2] == "9")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0JS54

// Formats screen,autoskip XBR
Function GD0JS55()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XBR CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && YSUTBL.YSUCD[GDWINDX2] != "99")

    GD0JWSU.YSUCD = YSUTBL.YSUCD[GDWINDX2];
    GD0JWSU.YSUABRV = YSUTBL.YSUABRV[GDWINDX2];
    GD0JWSU.YSUDESC = YSUTBL.YSUDESC[GDWINDX2];
    GD0JWSU.XXXSTAT = YSUTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0JWSU.GD0JWSUR;

    set GD0JWSU empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (YSUTBL.YSUCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0JS55

// Formats screen,autoskip XOC
Function GD0JS56()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XOC CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XOCTBL.XOCCD[GDWINDX2] != "99")

    GD0JWOC.XOCCD = XOCTBL.XOCCD[GDWINDX2];
    GD0JWOC.XOCDESC = XOCTBL.XOCDESC[GDWINDX2];
    GD0JWOC.XOCABRV = XOCTBL.XOCABRV[GDWINDX2];
    GD0JWOC.XDVCD = XOCTBL.XDVCD[GDWINDX2];
    GD0JWOC.XOCPROPF = XOCTBL.XOCPROPF[GDWINDX2];
    GD0JWOC.XOCFUTRF = XOCTBL.XOCFUTRF[GDWINDX2];
    GD0JWOC.XLCCD1 = XOCTBL.XLCCD1[GDWINDX2];
    GD0JWOC.XLCCD2 = XOCTBL.XLCCD2[GDWINDX2];
    GD0JWOC.XPPCD = XOCTBL.XPPCD[GDWINDX2];
    GD0JWOC.XPKCD = XOCTBL.XPKCD[GDWINDX2];
    GD0JWOC.XXXSTAT = XOCTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0JWOC.GD0JWOCR;

    set GD0JWOC empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XOCTBL.XOCCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0JS56

// Formats screen,autoskip XOM
Function GD0JS57()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XOM, CSP table **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XOMTBL.XOMCD[GDWINDX2] != "99")

    GD0JWOM.XOMCD = XOMTBL.XOMCD[GDWINDX2];
    GD0JWOM.XMRCD = XOMTBL.XMRCD[GDWINDX2];
    GD0JWOM.XOMDESC = XOMTBL.XOMDESC[GDWINDX2];
    GD0JWOM.XOMABRV = XOMTBL.XOMABRV[GDWINDX2];
    GD0JWOM.XOMCANCF = XOMTBL.XOMCANCF[GDWINDX2];
    if (XOMTBL.XXXSTAT[GDWINDX2] == "A")
      GD0JWOM.GD0JWSTA = "ACTIVE";
    else
      if (XOMTBL.XXXSTAT[GDWINDX2] == "I")
        GD0JWOM.GD0JWSTA = "INACTIVE";
      else
        GD0JWOM.GD0JWSTA = XOMTBL.XXXSTAT[GDWINDX2];
      end
    end


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0JWOM.GD0JWOMR;

    set GD0JWOM empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XOMTBL.XOMCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0JS57

// Formats screen,autoskip XOS
Function GD0JS58()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XOS CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XOSTBL.XOSCD[GDWINDX2] != "99")

    GD0JWOS.XOSCD = XOSTBL.XOSCD[GDWINDX2];
    GD0JWOS.XOSABRV = XOSTBL.XOSABRV[GDWINDX2];
    GD0JWOS.XOSDESC = XOSTBL.XOSDESC[GDWINDX2];
    GD0JWOS.XOSALWCH = XOSTBL.XOSALWCH[GDWINDX2];
    GD0JWOS.XOSALWXL = XOSTBL.XOSALWXL[GDWINDX2];
    GD0JWOS.XOSVPRST = XOSTBL.XOSVPRST[GDWINDX2];
    GD0JWOS.XOSAVDFL = XOSTBL.XOSAVDFL[GDWINDX2];
    GD0JWOS.XXXSTAT = XOSTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0JWOS.GD0JWOSR;

    set GD0JWOS empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XOSTBL.XOSCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0JS58

// Formats screen,autoskip XOT
Function GD0JS59()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XOT CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XOTTBL.XOTCD[GDWINDX2] != "99")

    GD0JWOT.XOTCD = XOTTBL.XOTCD[GDWINDX2];
    GD0JWOT.XOTABRV = XOTTBL.XOTABRV[GDWINDX2];
    GD0JWOT.XOTDESC = XOTTBL.XOTDESC[GDWINDX2];
    GD0JWOT.XOTSABRV = XOTTBL.XOTSABRV[GDWINDX2];
    GD0JWOT.XXXSTAT = XOTTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0JWOT.GD0JWOTR;

    set GD0JWOT empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XOTTBL.XOTCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0JS59

// Formats screen,autoskip XSH
Function GD0JS60()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XSH CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XSHTBL.XSHCD[GDWINDX2] != "99")

    GD0JWSH.XSHCD = XSHTBL.XSHCD[GDWINDX2];
    GD0JWSH.XSHABRV = XSHTBL.XSHABRV[GDWINDX2];
    GD0JWSH.XSHDESC = XSHTBL.XSHDESC[GDWINDX2];
    GD0JWSH.XXXSTAT = XSHTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0JWSH.GD0JWSHR;

    set GD0JWSH empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XSHTBL.XSHCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0JS60

// Formats screen,autoskip XSO
Function GD0JS61()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XSO CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XSOTBL.XSOCD[GDWINDX2] != "99")

    GD0JWSO.XSOCD = XSOTBL.XSOCD[GDWINDX2];
    GD0JWSO.XSONM = XSOTBL.XSONM[GDWINDX2];
    GD0JWSO.XSOSNM = XSOTBL.XSOSNM[GDWINDX2];
    GD0JWSO.XXXSTAT = XSOTBL.XXXSTAT[GDWINDX2];
    GD0JWSO.XDVCD = XSOTBL.XDVCD[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0JWSO.GD0JWSOR;

    set GD0JWSO empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XSOTBL.XSOCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0JS61

// Formats screen,autoskip XHD
Function GD0JS62()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XHD CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XHDTBL.XHDKEY[GDWINDX2] != "99999")

    GD0JWHD.XHDKEY = XHDTBL.XHDKEY[GDWINDX2];
    GD0JWHD.XHDABRV = XHDTBL.XHDABRV[GDWINDX2];
    GD0JWHD.XHDDESC = XHDTBL.XHDDESC[GDWINDX2];
    GD0JWHD.XHDUCHFL = XHDTBL.XHDUCHFL[GDWINDX2];
    GD0JW01.GD0JWHC = XHDTBL.XHDCHG[GDWINDX2];
    GD0JWHD.GD0JWHC-POSN1-6 = GD0JW01.GD0JWHC-POSN1-6;
    GD0JWHD.GD0JWHC-DECIMAL = ".";
    GD0JWHD.GD0JWHC-POSN7-9 = GD0JW01.GD0JWHC-POSN7-9;
    GD0JWHD.GLCD = XHDTBL.GLCD[GDWINDX2];
    GD0JW01.GD0JWDSM = XHDTBL.XHDSHMM[GDWINDX2];
    GD0JWHD.GD0JWDSM-POSN1-2 = GD0JW01.GD0JWDSM-POSN1-2;
    GD0JWHD.GD0JWDSM-DECIMAL = ".";
    GD0JWHD.GD0JWDSM-POSN3-5 = GD0JW01.GD0JWDSM-POSN3-5;
    GD0JWHD.ZFC-CRCY-CD = XHDTBL.ZFC-CRCY-CD[GDWINDX2];
    GD0JWHD.XXXSTAT = XHDTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0JWHD.GD0JWHDR;

    set GD0JWHD empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XHDTBL.XHDKEY[GDWINDX2] == "99999")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0JS62

// Formats screen,autoskip XOD
Function GD0JS63()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XOD CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XODTBL.XOTCD[GDWINDX2] != "99")

    GD0JWOD.XOTCD = XODTBL.XOTCD[GDWINDX2];
    GD0JWOD.GD0JWNDT = XODTBL.XODBENDT[GDWINDX2];
    GD0JWOD.GD0JWEDT = XODTBL.XODEENDT[GDWINDX2];
    GD0JWOD.XPTCD = XODTBL.XPTCD[GDWINDX2];
    GD0JWOD.XTDCD = XODTBL.XTDCD[GDWINDX2];
    GD0JWOD.GD0JWBKP = XODTBL.XODTDBKP[GDWINDX2];
    GD0JWOD.GD0JWFCP = XODTBL.XODTDFCP[GDWINDX2];
    GD0JWOD.XAACD = XODTBL.XAACD[GDWINDX2];
    GD0JWOD.GD0JWABK = XODTBL.XODAABKP[GDWINDX2];
    GD0JWOD.GD0JWAFC = XODTBL.XODAAFCP[GDWINDX2];
    GD0JWOD.XCPCD = XODTBL.XCPCD[GDWINDX2];
    GD0JWOD.GD0JWDSC = XODTBL.XODMXDSC[GDWINDX2];
    GD0JWOD.XXXSTAT = XODTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0JWOD.GD0JWODR;

    set GD0JWOD empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XODTBL.XOTCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0JS63

// Formats screen,autoskip XPG
Function GD0JS64()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XPG CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XPGTBL.XPGCD[GDWINDX2] != "99")

    GD0JWPG.XPGCD = XPGTBL.XPGCD[GDWINDX2];
    GD0JWPG.XPGDESC = XPGTBL.XPGDESC[GDWINDX2];
    GD0JWPG.XPGABRV = XPGTBL.XPGABRV[GDWINDX2];
    GD0JWPG.XXXSTAT = XPGTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0JWPG.GD0JWPGR;

    set GD0JWPG empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XPGTBL.XPGCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0JS64

// Formats screen,autoskip YFT
Function GD0JS65()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the YFT CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && YFTTBL.YFTCD[GDWINDX2] != "99")

    GD0JWFT.YFTCD = YFTTBL.YFTCD[GDWINDX2];
    GD0JWFT.YFTSDESC = YFTTBL.YFTSDESC[GDWINDX2];
    GD0JWFT.YFTDESC = YFTTBL.YFTDESC[GDWINDX2];
    GD0JWFT.XXXSTAT = YFTTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0JWFT.GD0JWFTR;

    set GD0JWFT empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (YFTTBL.YFTCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0JS65

// Formats screen,autoskip XTD
Function GD0JS66()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XTD CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XTDTBL.XTDCD[GDWINDX2] != "99")

    GD0JWTD.XTDCD = XTDTBL.XTDCD[GDWINDX2];
    GD0JWTD.XTDDESC = XTDTBL.XTDDESC[GDWINDX2];
    GD0JWTD.XTDABRV = XTDTBL.XTDABRV[GDWINDX2];
    GD0JWTD.GLBCD = XTDTBL.GLBCD[GDWINDX2];
    GD0JWTD.GLFCD = XTDTBL.GLFCD[GDWINDX2];
    GD0JWTD.XXXSTAT = XTDTBL.XXXSTAT[GDWINDX2];
    GD0JWTD.GD0JWTCD = XTDTBL.XTDPCT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0JWTD.GD0JWTDR;

    set GD0JWTD empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XTDTBL.XTDCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0JS66

// Formats screen,autoskip XVO
Function GD0JS67()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XVO CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XVOTBL.XOTCD[GDWINDX2] != "99")

    GD0JWVO.XOBCD = XVOTBL.XOBCD[GDWINDX2];
    GD0JWVO.XDVCD = XVOTBL.XDVCD[GDWINDX2];
    GD0JWVO.XBCCD = XVOTBL.XBCCD[GDWINDX2];
    GD0JWVO.XGPCD = XVOTBL.XGPCD[GDWINDX2];
    GD0JWVO.XSOCD = XVOTBL.XSOCD[GDWINDX2];
    GD0JWVO.XPC-PROD-CAT-CD = XVOTBL.XPC-PROD-CAT-CD[GDWINDX2];
    GD0JWVO.XOTCD = XVOTBL.XOTCD[GDWINDX2];
    GD0JWVO.XXXSTAT = XVOTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0JWVO.GD0JWVOR;

    set GD0JWVO empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XVOTBL.XOTCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0JS67

// Formats screen,autoskip XWH
Function GD0JS68()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XWH CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XWHTBL.XWHCD[GDWINDX2] != "99")

    GD0JWWH.XWHCD = XWHTBL.XWHCD[GDWINDX2];
    GD0JWWH.XWHNM = XWHTBL.XWHNM[GDWINDX2];
    GD0JWWH.XWHSABRV = XWHTBL.XWHSABRV[GDWINDX2];
    GD0JWWH.XDACD = XWHTBL.XDICD[GDWINDX2];
    GD0JWWH.XWOCD = XWHTBL.XWOCD[GDWINDX2];
    GD0JWWH.XWTCD = XWHTBL.XWTCD[GDWINDX2];
    GD0JWWH.GD0JWCTY = XWHTBL.XXXCITY[GDWINDX2];
    GD0JWWH.ZFC-CRCY-CD = XWHTBL.ZFC-CRCY-CD[GDWINDX2];
    GD0JWWH.XXXSTAT = XWHTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0JWWH.GD0JWWHR;

    set GD0JWWH empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XWHTBL.XWHCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0JS68

// Formats screen,autoskip XWH
Function GD0JS69()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XWH CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && YBTTBL.YBTCD[GDWINDX2] != "999")

    GD0JWBT.YBTCD = YBTTBL.YBTCD[GDWINDX2];
    GD0JWBT.YBTABRV = YBTTBL.YBTABRV[GDWINDX2];
    GD0JWBT.YBTDESC = YBTTBL.YBTDESC[GDWINDX2];
    GD0JWBT.XXXSTAT = YBTTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0JWBT.GD0JWYBT;

    set GD0JWBT empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (YBTTBL.YBTCD[GDWINDX2] == "999")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0JS69

// Formats screen,autoskip ybb
Function GD0JS70()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the ybb CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && YBBTBL.YBBCD[GDWINDX2] != "9999")

    GD0JWBB.YBBCD = YBBTBL.YBBCD[GDWINDX2];
    GD0JWBB.YBBABRV = YBBTBL.YBBABRV[GDWINDX2];
    GD0JWBB.YBBDESC = YBBTBL.YBBDESC[GDWINDX2];
    GD0JWBB.XXXSTAT = YBBTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0JWBB.GD0JWYBB;

    set GD0JWBB empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (YBBTBL.YBBCD[GDWINDX2] == "9999")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0JS70

// Formats screen,autoskip ybb
Function GD0JS71()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the ybb CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && YCQTBL.YCQCD[GDWINDX2] != "99")

    GD0JWCQ.YCQCD = YCQTBL.YCQCD[GDWINDX2];
    GD0JWCQ.YCQABRV = YCQTBL.YCQABRV[GDWINDX2];
    GD0JWCQ.YCQDESC = YCQTBL.YCQDESC[GDWINDX2];
    GD0JWCQ.XXXSTAT = YCQTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0JWCQ.GD0JWYCQ;

    set GD0JWCQ empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (YCQTBL.YCQCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0JS71

// Formats screen,autoskip ybb
Function GD0JS72()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XHR CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XHRTBL.XHRCD[GDWINDX2] != "99")

    GD0JWHR.XHRCD = XHRTBL.XHRCD[GDWINDX2];
    GD0JWHR.XHRABRV = XHRTBL.XHRABRV[GDWINDX2];
    GD0JWHR.XHRDESC = XHRTBL.XHRDESC[GDWINDX2];
    GD0JWHR.XXXSTAT = XHRTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0JWHR.GD0JWXHR;

    set GD0JWHR empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XHRTBL.XHRCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0JS72

// Formats screen,autoskip XBR
Function GD0JS73()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the YCD CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && YCDTBL.YCDBDT[GDWINDX2] != 99999999)

    GD0JWCD.YCDBDT = YCDTBL.YCDBDT[GDWINDX2];
    GD0JWCD.YCDFBDT = YCDTBL.YCDFBDT[GDWINDX2];
    GD0JWCD.YCDFXDT = YCDTBL.YCDFXDT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0JWCD.GD0JWYCD;

    set GD0JWCD empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (YCDTBL.YCDBDT[GDWINDX2] == 99999999)

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0JS73

// Formats screen,autoskip XBR
Function GD0JS74()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the Xfa CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XFATBL.XFACD[GDWINDX2] != "99")

    GD0JWFA.XFACD = XFATBL.XFACD[GDWINDX2];
    GD0JWFA.XFAIND = XFATBL.XFAIND[GDWINDX2];
    GD0JWFA.XFADESC = XFATBL.XFADESC[GDWINDX2];
    GD0JWFA.XXXSTAT = XFATBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0JWFA.GD0JWFAR;

    set GD0JWFA empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XFATBL.XFACD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0JS74

// Formats screen,autoskip XPA
Function GD0JS75()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the Xfa CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XPATBL.XPACD[GDWINDX2] != "99")

    GD0JWPA.XPACD = XPATBL.XPACD[GDWINDX2];
    GD0JWPA.XPADESC = XPATBL.XPADESC[GDWINDX2];
    GD0JWPA.XPAABRV = XPATBL.XPAABRV[GDWINDX2];
    GD0JWPA.XPASYCLF = XPATBL.XPASYCLF[GDWINDX2];
    GD0JWPA.XPASYSZF = XPATBL.XPASYSZF[GDWINDX2];
    GD0JWPA.XPASPFFL = XPATBL.XPASPFFL[GDWINDX2];
    GD0JWPA.XPAINTFL = XPATBL.XPAINTFL[GDWINDX2];
    GD0JWPA.XXXSTAT = XPATBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0JWPA.GD0JWPAR;

    set GD0JWPA empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XPATBL.XPACD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0JS75

// Formats screen,autoskip XPA
Function GD0JS76()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XLA CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && YLATBL.YLACD[GDWINDX2] != "99")

    GD0JWLA.YLACD = YLATBL.YLACD[GDWINDX2];
    GD0JWLA.YLADESC = YLATBL.YLADESC[GDWINDX2];
    GD0JWLA.YLAABRV = YLATBL.YLAABRV[GDWINDX2];
    GD0JWLA.XXXSTAT = YLATBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0JWLA.GD0JWLAR;

    set GD0JWLA empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (YLATBL.YLACD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0JS76

// Formats screen,autoskip XBR
Function GD0JS77()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XBR CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && YQTTBL.YQT-QOTA-CAT-CD[GDWINDX2] != "9999999")

    GD0JWYQ.YQT-QOTA-CAT-CD = YQTTBL.YQT-QOTA-CAT-CD[GDWINDX2];
    GD0JWYQ.PC-XCT-ORIG-CD = YQTTBL.PC-XCT-ORIG-CD[GDWINDX2];
    GD0JWYQ.XCTCD = YQTTBL.XCTCD[GDWINDX2];
    GD0JWYQ.YSGCD = YQTTBL.YSGCD[GDWINDX2];
    GD0JWYQ.GD0JW-YQT-QOTA-FIBR-DESC = YQTTBL.YQT-QOTA-FIBR-DESC[GDWINDX2];
    GD0JWYQ.GD0JW-YQT-QOTA-CAT-DESC = YQTTBL.YQT-QOTA-CAT-DESC[GDWINDX2];
    GD0JWYQ.YQT-QOTA-UNT = YQTTBL.YQT-QOTA-UNT[GDWINDX2];
    GD0JWYQ.XXXSTAT = YQTTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0JWYQ.GD0JWYQR;

    set GD0JWYQ empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (YQTTBL.YQT-QOTA-CAT-CD[GDWINDX2] == "9999999")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0JS77

// Formats screen,autoskip XBR
Function GD0JS78()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XBR CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XGBTBL.XGBCD[GDWINDX2] != "99")

    GD0JWGB.XGBCD = XGBTBL.XGBCD[GDWINDX2];
    GD0JWGB.XGBABRV = XGBTBL.XGBABRV[GDWINDX2];
    GD0JWGB.XGBDESC = XGBTBL.XGBDESC[GDWINDX2];
    GD0JWGB.XXXSTAT = XGBTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0JWGB.GD0JWGBR;

    set GD0JWGB empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XGBTBL.XGBCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0JS78

// Formats screen,autoskip XBR
Function GD0JS79()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XBR CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && SYRTBL.SYRCATID[GDWINDX2] != "999999")

    GD0JWSY.SYRCATID = SYRTBL.SYRCATID[GDWINDX2];
    GD0JWSY.XGPCD = SYRTBL.XGPCD[GDWINDX2];
    GD0JWSY.XSECD = SYRTBL.XSECD[GDWINDX2];
    GD0JWSY.GD0JW-SYR-XSNYR = SYRTBL.XSNYR[GDWINDX2];
    GD0JWSY.SYRDESC = SYRTBL.SYRDESC[GDWINDX2];
    GD0JWSY.XXXSTAT = SYRTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0JWSY.GD0JWSYR;

    set GD0JWSY empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (SYRTBL.SYRCATID[GDWINDX2] == "999999")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0JS79

// Formats screen,autoskip ybb
Function GD0JS80()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the ybb CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XBKTBL.XBK-BK-SESN-CD[GDWINDX2] != "99")

    GD0JWBK.XBK-BK-SESN-CD = XBKTBL.XBK-BK-SESN-CD[GDWINDX2];
    GD0JWBK.XBK-BK-SESN-ABRV = XBKTBL.XBK-BK-SESN-ABRV[GDWINDX2];
    GD0JWBK.XBK-BK-SESN-DESC = XBKTBL.XBK-BK-SESN-DESC[GDWINDX2];
    GD0JWBK.XXXSTAT = XBKTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0JWBK.GD0JWXBK;

    set GD0JWBK empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XBKTBL.XBK-BK-SESN-CD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0JS80

// Formats screen,autoskip ybb
Function GD0JS81()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the ybb CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && ZPRTBL.XXXUSRID[GDWINDX2] != "99999999")

    GD0JWPR.XXXUSRID = ZPRTBL.XXXUSRID[GDWINDX2];
    GD0JWPR.XXXUNTXT = ZPRTBL.XXXUNTXT[GDWINDX2];
    GD0JWPR.XXXJOBTL = ZPRTBL.XXXJOBTL[GDWINDX2];
    GD0JWPR.XXXSTAT = ZPRTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0JWPR.GD0JWPRR;

    set GD0JWPR empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (ZPRTBL.XXXUSRID[GDWINDX2] == "99999999")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0JS81

// Formats screen,autoskip ybb
Function GD0JS82()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the ybb CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XPMTBL.XPMCD[GDWINDX2] != "99")

    GD0JWPM.XPMCD = XPMTBL.XPMCD[GDWINDX2];
    GD0JWPM.XPMABRV = XPMTBL.XPMABRV[GDWINDX2];
    GD0JWPM.XPMDESC = XPMTBL.XPMDESC[GDWINDX2];
    GD0JWPM.XPMSMPLF = XPMTBL.XPMSMPLF[GDWINDX2];
    GD0JWPM.XXXSTAT = XPMTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0JWPM.GD0JWPMR;

    set GD0JWPM empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XPMTBL.XPMCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0JS82

// Formats screen,autoskip ybb
Function GD0JS83()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the ybb CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/

  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XZCTBL.XZCCLNDT[GDWINDX2] != 999999999)

    GD0JWZC.GD0JW-XZCCLNDT = XZCTBL.XZCCLNDT[GDWINDX2];
    GD0JWZC.GD0JW-XZCGLPM1 = XZCTBL.XZCGLPM1[GDWINDX2];
    GD0JWZC.GD0JW-XZCGLPM2 = XZCTBL.XZCGLPM2[GDWINDX2];
    GD0JWZC.GD0JW-NL-GEN-LED-PMO3 = XZCTBL.NL-GEN-LED-PMO3[GDWINDX2];
    GD0JWZC.GD0JW-XZCFISMO = XZCTBL.XZCFISMO[GDWINDX2];
    GD0JWZC.GD0JW-XZCGLEDT = XZCTBL.XZCGLEDT[GDWINDX2];
    GD0JWZC.GD0JW-ZZZSDT = XZCTBL.ZZZSDT[GDWINDX2];
    GD0JWZC.GD0JW-ZZZCHGDT = XZCTBL.ZZZCHGDT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0JWZC.GD0JWZCR;

    set GD0JWZC empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XZCTBL.XZCCLNDT[GDWINDX2] == 999999999)

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0JS83

// Formats screen,autoskip ybb
Function GD0JS84()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the ybb CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/

  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && YSMTBL.YSMTBLPF[GDWINDX2] != "999")

    GD0JWSM.YSMTBLPF = YSMTBL.YSMTBLPF[GDWINDX2];
    GD0JWSM.YSMSYSPF = YSMTBL.YSMSYSPF[GDWINDX2];
    GD0JWSM.GD0JW-YSMSUMID = YSMTBL.YSMSUMID[GDWINDX2];
    GD0JWSM.YSMSUMCD = YSMTBL.YSMSUMCD[GDWINDX2];
    GD0JWSM.YSMSRCVL = YSMTBL.YSMSRCVL[GDWINDX2];
    GD0JWSM.YSMSMDSC = YSMTBL.YSMSMDSC[GDWINDX2];
    GD0JWSM.XXXSTAT = YSMTBL.XXXSTAT[GDWINDX2];
    GD0JWSM.GD0JW-ZZZSDT = YSMTBL.ZZZSDT[GDWINDX2];
    GD0JWSM.GD0JW-ZZZCHGDT = YSMTBL.ZZZCHGDT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0JWSM.GD0JWSMR;

    set GD0JWSM empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (YSMTBL.YSMTBLPF[GDWINDX2] == "999")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0JS84

//*** RECORD=GD0JW01 ****
// display line for xhdtbl
// ***********************
Record GD0JW01 type basicRecord
  10 GD0JWDSM GD0JWDSM ; 
    20 GD0JWDSM-POSN1-2 GD0JWDSM-POSN1-2 ; 
    20 GD0JWDSM-POSN3-5 GD0JWDSM-POSN3-5 ; 
  10 GD0JWHC GD0JWHC ; 
    20 GD0JWHC-POSN1-6 GD0JWHC-POSN1-6 ; 
    20 GD0JWHC-POSN7-9 GD0JWHC-POSN7-9 ; 
  10 GD0JW-ZCF-COMM-FEE-PCT GD0JW-ZCF-COMM-FEE-PCT ; 
    20 GD0JW-ZCF-COMM-FEE-PCT1-2 GD0JW-ZCF-COMM-FEE-PCT1-2 ; 
    20 GD0JW-ZCF-COMM-FEE-PCT3-5 GD0JW-ZCF-COMM-FEE-PCT3-5 ; 
end // end GD0JW01

//*** RECORD=GD0JWBB ****
// work record for ybbtbl screen display
//    2-25-91   vcowan  orig definition
// ***********************
Record GD0JWBB type basicRecord
  10 GD0JWYBB GD0JWYBB ; 
    20 YBBCD YBBCD ; 
    20 * char(3) ; 
    20 YBBABRV YBBABRV ; 
    20 * char(3) ; 
    20 YBBDESC YBBDESC ; 
    20 * char(6) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(30) ; 
end // end GD0JWBB

//*** RECORD=GD0JWBK ****
// work record for ybbtbl screen display
//    2-25-91   vcowan  orig definition
// ***********************
Record GD0JWBK type basicRecord
  10 GD0JWXBK GD0JWXBK ; 
    20 * char(1) ; 
    20 XBK-BK-SESN-CD XBK-BK-SESN-CD ; 
    20 * char(3) ; 
    20 XBK-BK-SESN-DESC XBK-BK-SESN-DESC ; 
    20 * char(3) ; 
    20 XBK-BK-SESN-ABRV XBK-BK-SESN-ABRV ; 
    20 * char(6) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(41) ; 
end // end GD0JWBK

Record GD0JWBR type basicRecord
  10 GD0JWBRR GD0JWBRR ; 
    20 XBRCD XBRCD ; 
    20 * char(7) ; 
    20 XBRDESC XBRDESC ; 
    20 * char(7) ; 
    20 XBRABRV XBRABRV ; 
    20 * char(7) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(28) ; 
end // end GD0JWBR

//*** RECORD=GD0JWBT ****
// work record for ybttbl screen display
//    2-25-91   vcowan  orig definition
// ***********************
Record GD0JWBT type basicRecord
  10 GD0JWYBT GD0JWYBT ; 
    20 * char(1) ; 
    20 YBTCD YBTCD ; 
    20 * char(3) ; 
    20 YBTABRV YBTABRV ; 
    20 * char(3) ; 
    20 YBTDESC YBTDESC ; 
    20 * char(6) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(30) ; 
end // end GD0JWBT

//*** RECORD=GD0JWCD ****
// work record for ybbtbl screen display
//    2-25-91   vcowan  orig definition
// ***********************
Record GD0JWCD type basicRecord
  10 GD0JWYCD GD0JWYCD ; 
    20 * char(16) ; 
    20 YCDBDT YCDBDT ; 
    20 * char(16) ; 
    20 YCDFBDT YCDFBDT ; 
    20 * char(13) ; 
    20 YCDFXDT YCDFXDT ; 
    20 * char(9) ; 
end // end GD0JWCD

//*** RECORD=GD0JWCF ****
// work record for ybbtbl screen display
//    2-25-91   vcowan  orig definition
// ***********************
Record GD0JWCF type basicRecord
  10 GD0JWCFR GD0JWCFR ; 
    20 * char(1) ; 
    20 ZCF-COMM-FEE-CD ZCF-COMM-FEE-CD ; 
    20 * char(3) ; 
    20 ZCF-COMM-FEE-DESC ZCF-COMM-FEE-DESC ; 
    20 * char(3) ; 
    20 GD0JW-ZCF-COMM-FEE-EDT GD0JW-ZCF-COMM-FEE-EDT ; 
    20 * char(3) ; 
    20 GD0JW-ZCF-COMM-FEE-PCT1-2 GD0JW-ZCF-COMM-FEE-PCT1-2 ; 
    20 GD0JW-ZCF-COMM-FEE-PCT-DOT GD0JW-ZCF-COMM-FEE-PCT-DOT ; 
    20 GD0JW-ZCF-COMM-FEE-PCT3-5 GD0JW-ZCF-COMM-FEE-PCT3-5 ; 
    20 * char(3) ; 
    20 ZCF-GRS-NET-IND ZCF-GRS-NET-IND ; 
    20 * char(4) ; 
    20 ZCF-NET-BILL-FL ZCF-NET-BILL-FL ; 
    20 * char(4) ; 
    20 ZCF-NISSHO-FL ZCF-NISSHO-FL ; 
    20 * char(5) ; 
    20 ZCHCD ZCHCD ; 
    20 * char(4) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(5) ; 
end // end GD0JWCF

//*** RECORD=GD0JWCQ ****
// work record for ybbtbl screen display
//    2-25-91   vcowan  orig definition
// ***********************
Record GD0JWCQ type basicRecord
  10 GD0JWYCQ GD0JWYCQ ; 
    20 * char(1) ; 
    20 YCQCD YCQCD ; 
    20 * char(4) ; 
    20 YCQDESC YCQDESC ; 
    20 * char(4) ; 
    20 YCQABRV YCQABRV ; 
    20 * char(5) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(25) ; 
end // end GD0JWCQ

Record GD0JWDS type basicRecord
  10 GD0JWDSR GD0JWDSR ; 
    20 * char(1) ; 
    20 XDSCD XDSCD ; 
    20 * char(4) ; 
    20 XDSDESC XDSDESC ; 
    20 * char(2) ; 
    20 XDSABRV XDSABRV ; 
    20 * char(5) ; 
    20 XDSWHSEF XDSWHSEF ; 
    20 * char(7) ; 
    20 GD0JWPCT GD0JWPCT ; 
    20 * char(5) ; 
    20 GLFCD GLFCD ; 
    20 * char(8) ; 
    20 XDSAVDFL XDSAVDFL ; 
    20 * char(8) ; 
    20 XXXSTAT XXXSTAT ; 
end // end GD0JWDS

//*** RECORD=GD0JWFA ****
// 05-30-91   vcowan   xfatbl row display
// ***********************
Record GD0JWFA type basicRecord
  10 GD0JWFAR GD0JWFAR ; 
    20 * char(1) ; 
    20 XFACD XFACD ; 
    20 * char(7) ; 
    20 XFAIND XFAIND ; 
    20 * char(6) ; 
    20 XFADESC XFADESC ; 
    20 * char(4) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(6) ; 
end // end GD0JWFA

Record GD0JWFT type basicRecord
  10 GD0JWFTR GD0JWFTR ; 
    20 * char(1) ; 
    20 YFTCD YFTCD ; 
    20 * char(3) ; 
    20 YFTSDESC YFTSDESC ; 
    20 * char(2) ; 
    20 YFTDESC YFTDESC ; 
    20 * char(4) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(23) ; 
end // end GD0JWFT

Record GD0JWGB type basicRecord
  10 GD0JWGBR GD0JWGBR ; 
    20 * char(1) ; 
    20 XGBCD XGBCD ; 
    20 * char(6) ; 
    20 XGBDESC XGBDESC ; 
    20 * char(7) ; 
    20 XGBABRV XGBABRV ; 
    20 * char(7) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(33) ; 
end // end GD0JWGB

//*** RECORD=GD0JWHD ****
// display line for xhdtbl
// ***********************
Record GD0JWHD type basicRecord
  10 GD0JWHDR GD0JWHDR ; 
    20 XHDKEY XHDKEY ; 
    20 * char(1) ; 
    20 XHDDESC XHDDESC ; 
    20 * char(1) ; 
    20 XHDABRV XHDABRV ; 
    20 * char(3) ; 
    20 XHDUCHFL XHDUCHFL ; 
    20 * char(1) ; 
    20 GD0JWHC-POSN1-6 GD0JWHC-POSN1-6 ; 
    20 GD0JWHC-DECIMAL GD0JWHC-DECIMAL ; 
    20 GD0JWHC-POSN7-9 GD0JWHC-POSN7-9 ; 
    20 * char(1) ; 
    20 GLCD GLCD ; 
    20 * char(2) ; 
    20 GD0JWDSM-POSN1-2 GD0JWDSM-POSN1-2 ; 
    20 GD0JWDSM-DECIMAL GD0JWDSM-DECIMAL ; 
    20 GD0JWDSM-POSN3-5 GD0JWDSM-POSN3-5 ; 
    20 * char(2) ; 
    20 ZFC-CRCY-CD ZFC-CRCY-CD ; 
    20 * char(1) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(1) ; 
end // end GD0JWHD

//*** RECORD=GD0JWHR ****
// work record for ybbtbl screen display
//    2-25-91   vcowan  orig definition
// ***********************
Record GD0JWHR type basicRecord
  10 GD0JWXHR GD0JWXHR ; 
    20 * char(1) ; 
    20 XHRCD XHRCD ; 
    20 * char(4) ; 
    20 XHRDESC XHRDESC ; 
    20 * char(3) ; 
    20 XHRABRV XHRABRV ; 
    20 * char(6) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(35) ; 
end // end GD0JWHR

Record GD0JWIC type basicRecord
  10 GD0JWICR GD0JWICR ; 
    20 GD0JWICC GD0JWICC ; 
    20 * char(2) ; 
    20 YICSDESC YICSDESC ; 
    20 * char(2) ; 
    20 GLACCT GLACCT ; 
    20 * char(4) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(22) ; 
end // end GD0JWIC

//*** RECORD=GD0JWLA ****
// work record for ylatbl screen display
//   12-09-91   vcowan  orig definition
// ***********************
Record GD0JWLA type basicRecord
  10 GD0JWLAR GD0JWLAR ; 
    20 * char(1) ; 
    20 YLACD YLACD ; 
    20 * char(4) ; 
    20 YLADESC YLADESC ; 
    20 * char(3) ; 
    20 YLAABRV YLAABRV ; 
    20 * char(6) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(25) ; 
end // end GD0JWLA

Record GD0JWOC type basicRecord
  10 GD0JWOCR GD0JWOCR ; 
    20 XOCCD XOCCD ; 
    20 * char(3) ; 
    20 XOCDESC XOCDESC ; 
    20 * char(3) ; 
    20 XOCABRV XOCABRV ; 
    20 * char(3) ; 
    20 XDVCD XDVCD ; 
    20 * char(4) ; 
    20 XOCFUTRF XOCFUTRF ; 
    20 * char(3) ; 
    20 XOCPROPF XOCPROPF ; 
    20 * char(3) ; 
    20 XLCCD1 XLCCD1 ; 
    20 * char(3) ; 
    20 XLCCD2 XLCCD2 ; 
    20 * char(3) ; 
    20 XPPCD XPPCD ; 
    20 * char(3) ; 
    20 XPKCD XPKCD ; 
    20 * char(5) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(4) ; 
end // end GD0JWOC

Record GD0JWOD type basicRecord
  10 GD0JWODR GD0JWODR ; 
    20 XOTCD XOTCD ; 
    20 * char(2) ; 
    20 GD0JWNDT GD0JWNDT ; 
    20 * char(2) ; 
    20 GD0JWEDT GD0JWEDT ; 
    20 * char(2) ; 
    20 XPTCD XPTCD ; 
    20 * char(3) ; 
    20 XTDCD XTDCD ; 
    20 * char(2) ; 
    20 GD0JWBKP GD0JWBKP ; 
    20 * char(2) ; 
    20 GD0JWFCP GD0JWFCP ; 
    20 * char(3) ; 
    20 XAACD XAACD ; 
    20 * char(3) ; 
    20 GD0JWABK GD0JWABK ; 
    20 * char(2) ; 
    20 GD0JWAFC GD0JWAFC ; 
    20 * char(2) ; 
    20 XCPCD XCPCD ; 
    20 * char(3) ; 
    20 GD0JWDSC GD0JWDSC ; 
    20 * char(3) ; 
    20 XXXSTAT XXXSTAT ; 
end // end GD0JWOD

Record GD0JWOM type basicRecord
  10 GD0JWOMR GD0JWOMR ; 
    20 * char(2) ; 
    20 XOMCD XOMCD ; 
    20 * char(7) ; 
    20 XOMDESC XOMDESC ; 
    20 * char(7) ; 
    20 XOMABRV XOMABRV ; 
    20 * char(8) ; 
    20 XOMCANCF XOMCANCF ; 
    20 * char(8) ; 
    20 XMRCD XMRCD ; 
    20 * char(4) ; 
    20 GD0JWSTA GD0JWSTA ; 
    20 * char(3) ; 
end // end GD0JWOM

Record GD0JWOS type basicRecord
  10 GD0JWOSR GD0JWOSR ; 
    20 XOSCD XOSCD ; 
    20 * char(7) ; 
    20 XOSDESC XOSDESC ; 
    20 * char(7) ; 
    20 XOSABRV XOSABRV ; 
    20 * char(5) ; 
    20 XOSALWCH XOSALWCH ; 
    20 * char(4) ; 
    20 XOSALWXL XOSALWXL ; 
    20 * char(5) ; 
    20 XOSAVDFL XOSAVDFL ; 
    20 * char(3) ; 
    20 XOSVPRST XOSVPRST ; 
    20 * char(3) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(3) ; 
end // end GD0JWOS

Record GD0JWOT type basicRecord
  10 GD0JWOTR GD0JWOTR ; 
    20 XOTCD XOTCD ; 
    20 * char(7) ; 
    20 XOTDESC XOTDESC ; 
    20 * char(7) ; 
    20 XOTABRV XOTABRV ; 
    20 * char(5) ; 
    20 XOTSABRV XOTSABRV ; 
    20 * char(11) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(5) ; 
end // end GD0JWOT

//*** RECORD=GD0JWPA ****
// 05-30-91   vcowan   xfatbl row display
// ***********************
Record GD0JWPA type basicRecord
  10 GD0JWPAR GD0JWPAR ; 
    20 * char(1) ; 
    20 XPACD XPACD ; 
    20 * char(3) ; 
    20 XPADESC XPADESC ; 
    20 * char(2) ; 
    20 XPAABRV XPAABRV ; 
    20 * char(3) ; 
    20 XPASYCLF XPASYCLF ; 
    20 * char(5) ; 
    20 XPASYSZF XPASYSZF ; 
    20 * char(5) ; 
    20 XPASPFFL XPASPFFL ; 
    20 * char(5) ; 
    20 XPAINTFL XPAINTFL ; 
    20 * char(7) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(4) ; 
end // end GD0JWPA

Record GD0JWPG type basicRecord
  10 GD0JWPGR GD0JWPGR ; 
    20 XPGCD XPGCD ; 
    20 * char(7) ; 
    20 XPGDESC XPGDESC ; 
    20 * char(7) ; 
    20 XPGABRV XPGABRV ; 
    20 * char(7) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(33) ; 
end // end GD0JWPG

//*** RECORD=GD0JWPM ****
// work record for ZPRtbl screen display
//    9-19-94   vcowan  orig definition
// ***********************
Record GD0JWPM type basicRecord
  10 GD0JWPMR GD0JWPMR ; 
    20 * char(1) ; 
    20 XPMCD XPMCD ; 
    20 * char(3) ; 
    20 XPMABRV XPMABRV ; 
    20 * char(2) ; 
    20 XPMDESC XPMDESC ; 
    20 * char(5) ; 
    20 XPMSMPLF XPMSMPLF ; 
    20 * char(6) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(31) ; 
end // end GD0JWPM

//*** RECORD=GD0JWPR ****
// work record for ZPRtbl screen display
//    9-19-94   vcowan  orig definition
// ***********************
Record GD0JWPR type basicRecord
  10 GD0JWPRR GD0JWPRR ; 
    20 XXXUSRID XXXUSRID ; 
    20 * char(1) ; 
    20 XXXUNTXT XXXUNTXT ; 
    20 * char(2) ; 
    20 XXXJOBTL XXXJOBTL ; 
    20 * char(3) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(3) ; 
end // end GD0JWPR

Record GD0JWSH type basicRecord
  10 GD0JWSHR GD0JWSHR ; 
    20 XSHCD XSHCD ; 
    20 * char(7) ; 
    20 XSHDESC XSHDESC ; 
    20 * char(7) ; 
    20 XSHABRV XSHABRV ; 
    20 * char(7) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(28) ; 
end // end GD0JWSH

//*** RECORD=GD0JWSM ****
// work record for xzctbl screen display
//    4-08-97   vcowan  orig definition
// ***********************
Record GD0JWSM type basicRecord
  10 GD0JWSMR GD0JWSMR ; 
    20 YSMTBLPF YSMTBLPF ; 
    20 * char(2) ; 
    20 YSMSYSPF YSMSYSPF ; 
    20 * char(2) ; 
    20 GD0JW-YSMSUMID GD0JW-YSMSUMID ; 
    20 * char(3) ; 
    20 YSMSUMCD YSMSUMCD ; 
    20 * char(3) ; 
    20 YSMSRCVL YSMSRCVL ; 
    20 * char(3) ; 
    20 YSMSMDSC YSMSMDSC ; 
    20 * char(3) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(3) ; 
    20 GD0JW-ZZZSDT GD0JW-ZZZSDT ; 
    20 * char(1) ; 
    20 * char(1) ; 
    20 GD0JW-ZZZCHGDT GD0JW-ZZZCHGDT ; 
end // end GD0JWSM

Record GD0JWSO type basicRecord
  10 GD0JWSOR GD0JWSOR ; 
    20 * char(1) ; 
    20 XSOCD XSOCD ; 
    20 * char(6) ; 
    20 XSONM XSONM ; 
    20 * char(7) ; 
    20 XSOSNM XSOSNM ; 
    20 * char(7) ; 
    20 XDVCD XDVCD ; 
    20 * char(7) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(3) ; 
end // end GD0JWSO

Record GD0JWSU type basicRecord
  10 GD0JWSUR GD0JWSUR ; 
    20 YSUCD YSUCD ; 
    20 * char(7) ; 
    20 YSUDESC YSUDESC ; 
    20 * char(2) ; 
    20 YSUABRV YSUABRV ; 
    20 * char(3) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(28) ; 
end // end GD0JWSU

Record GD0JWSY type basicRecord
  10 GD0JWSYR GD0JWSYR ; 
    20 * char(1) ; 
    20 SYRCATID SYRCATID ; 
    20 * char(3) ; 
    20 XGPCD XGPCD ; 
    20 * char(4) ; 
    20 XSECD XSECD ; 
    20 * char(4) ; 
    20 GD0JW-SYR-XSNYR GD0JW-SYR-XSNYR ; 
    20 * char(2) ; 
    20 SYRDESC SYRDESC ; 
    20 * char(4) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(15) ; 
end // end GD0JWSY

Record GD0JWTD type basicRecord
  10 GD0JWTDR GD0JWTDR ; 
    20 * char(1) ; 
    20 XTDCD XTDCD ; 
    20 * char(5) ; 
    20 XTDDESC XTDDESC ; 
    20 * char(3) ; 
    20 XTDABRV XTDABRV ; 
    20 * char(5) ; 
    20 GD0JWTCD GD0JWTCD ; 
    20 * char(5) ; 
    20 GLBCD GLBCD ; 
    20 * char(5) ; 
    20 GLFCD GLFCD ; 
    20 * char(6) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(7) ; 
end // end GD0JWTD

Record GD0JWVO type basicRecord
  10 GD0JWVOR GD0JWVOR ; 
    20 * char(2) ; 
    20 XOBCD XOBCD ; 
    20 * char(6) ; 
    20 XDVCD XDVCD ; 
    20 * char(6) ; 
    20 XBCCD XBCCD ; 
    20 * char(6) ; 
    20 XGPCD XGPCD ; 
    20 * char(8) ; 
    20 XSOCD XSOCD ; 
    20 * char(9) ; 
    20 XPC-PROD-CAT-CD XPC-PROD-CAT-CD ; 
    20 * char(11) ; 
    20 XOTCD XOTCD ; 
    20 * char(8) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(7) ; 
end // end GD0JWVO

Record GD0JWWH type basicRecord
  10 GD0JWWHR GD0JWWHR ; 
    20 XWHCD XWHCD ; 
    20 * char(1) ; 
    20 XWHNM XWHNM ; 
    20 * char(1) ; 
    20 XWHSABRV XWHSABRV ; 
    20 * char(1) ; 
    20 XDACD XDACD ; 
    20 * char(1) ; 
    20 XWOCD XWOCD ; 
    20 * char(1) ; 
    20 XWTCD XWTCD ; 
    20 * char(2) ; 
    20 GD0JWCTY GD0JWCTY ; 
    20 ZFC-CRCY-CD ZFC-CRCY-CD ; 
    20 * char(2) ; 
    20 XXXSTAT XXXSTAT ; 
end // end GD0JWWH

//*** RECORD=GD0JWYP ****
// record of screen display fpr xpo rows
// ***********************
Record GD0JWYP type basicRecord
  10 GD0JWYPO GD0JWYPO ; 
    20 YPOCD YPOCD ; 
    20 * char(7) ; 
    20 YPODESC YPODESC ; 
    20 * char(7) ; 
    20 YPOABRV YPOABRV ; 
    20 * char(7) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(18) ; 
end // end GD0JWYP

Record GD0JWYQ type basicRecord
  10 GD0JWYQR GD0JWYQR ; 
    20 YQT-QOTA-CAT-CD YQT-QOTA-CAT-CD ; 
    20 * char(1) ; 
    20 PC-XCT-ORIG-CD PC-XCT-ORIG-CD ; 
    20 * char(1) ; 
    20 XCTCD XCTCD ; 
    20 * char(1) ; 
    20 YSGCD YSGCD ; 
    20 * char(2) ; 
    20 GD0JW-YQT-QOTA-FIBR-DESC GD0JW-YQT-QOTA-FIBR-DESC ; 
    20 * char(1) ; 
    20 GD0JW-YQT-QOTA-CAT-DESC GD0JW-YQT-QOTA-CAT-DESC ; 
    20 * char(1) ; 
    20 YQT-QOTA-UNT YQT-QOTA-UNT ; 
    20 * char(1) ; 
    20 XXXSTAT XXXSTAT ; 
end // end GD0JWYQ

//*** RECORD=GD0JWZC ****
// work record for xzctbl screen display
//    4-08-97   vcowan  orig definition
// ***********************
Record GD0JWZC type basicRecord
  10 GD0JWZCR GD0JWZCR ; 
    20 GD0JW-XZCCLNDT GD0JW-XZCCLNDT ; 
    20 * char(2) ; 
    20 GD0JW-XZCGLPM1 GD0JW-XZCGLPM1 ; 
    20 * char(2) ; 
    20 GD0JW-XZCGLPM2 GD0JW-XZCGLPM2 ; 
    20 * char(2) ; 
    20 GD0JW-NL-GEN-LED-PMO3 GD0JW-NL-GEN-LED-PMO3 ; 
    20 * char(2) ; 
    20 GD0JW-XZCFISMO GD0JW-XZCFISMO ; 
    20 * char(2) ; 
    20 GD0JW-XZCGLEDT GD0JW-XZCGLEDT ; 
    20 * char(2) ; 
    20 GD0JW-ZZZSDT GD0JW-ZZZSDT ; 
    20 * char(1) ; 
    20 * char(1) ; 
    20 GD0JW-ZZZCHGDT GD0JW-ZZZCHGDT ; 
end // end GD0JWZC

// NL_GEN_LED_PMO3     gd0j
DataItem GD0JW-NL-GEN-LED-PMO3 num(8)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

DataItem GD0JW-SYR-XSNYR num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// xzc-clndr-dt    gd0j
DataItem GD0JW-XZCCLNDT num(8)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = nullFill, inputRequired = no
}
end

// xzc-fiscal-mo     gd0j
DataItem GD0JW-XZCFISMO num(8)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// xzc-gen-led-edt    gd0j
DataItem GD0JW-XZCGLEDT num(8)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// nl-gen-led-pmo1    gd0j
DataItem GD0JW-XZCGLPM1 num(8)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// nl-gen-led-pmo2    gd0j
DataItem GD0JW-XZCGLPM2 num(8)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// YQT_QOTA_CAT_DESC
DataItem GD0JW-YQT-QOTA-CAT-DESC char(40)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// YQT_QOTA_FIBR_DESC
DataItem GD0JW-YQT-QOTA-FIBR-DESC char(9)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// xxx_sum_id    gd0j
DataItem GD0JW-YSMSUMID num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// zcf-comm-fee-edt
DataItem GD0JW-ZCF-COMM-FEE-EDT num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// zch-comm-fee-pct  numeric-disp
DataItem GD0JW-ZCF-COMM-FEE-PCT num(5,3)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// zcf-comm-fee-pct
DataItem GD0JW-ZCF-COMM-FEE-PCT-DOT char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// zcf-comm-fee-pct  posn 1-2
DataItem GD0JW-ZCF-COMM-FEE-PCT1-2 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// zcf-comm-fee-pct  posn 3-5
DataItem GD0JW-ZCF-COMM-FEE-PCT3-5 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// ZZ_CHNG_CNT    gd0j
DataItem GD0JW-ZZZCHGDT num(8)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// ZZ_SDT    gd0j
DataItem GD0JW-ZZZSDT num(8)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// ad allowance banked %
DataItem GD0JWABK num(5,3)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// ad allowance off-face %
DataItem GD0JWAFC num(5,3)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// trade discount banked %
DataItem GD0JWBKP num(5,3)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

DataItem GD0JWBRR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0JWCFR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// city
DataItem GD0JWCTY char(21)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// max discount % allowed
DataItem GD0JWDSC num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// handling minimum  numeric-disp
DataItem GD0JWDSM num(5,3)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// handling minimum-- decimal
DataItem GD0JWDSM-DECIMAL char(1)  {
  align = right, fillCharacter = " ", inputRequired = no
}
end

// handling minimum -- posn 1-2
DataItem GD0JWDSM-POSN1-2 char(2)  {
  align = right, fillCharacter = " ", inputRequired = no
}
end

// handling minimum-- posn 3-5
DataItem GD0JWDSM-POSN3-5 char(3)  {
  align = right, fillCharacter = " ", inputRequired = no
}
end

DataItem GD0JWDSR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0JWEDT num(8)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

DataItem GD0JWFAR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// trade discount off-face %
DataItem GD0JWFCP num(5,3)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

DataItem GD0JWFTR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0JWGBR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// handling charge   numeric-disp
DataItem GD0JWHC num(9,3)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// handling charge -- decimal
DataItem GD0JWHC-DECIMAL char(1)  {
  align = right, fillCharacter = " ", inputRequired = no
}
end

// handling charge -- posn 1-2
DataItem GD0JWHC-POSN1-6 char(6)  {
  align = right, fillCharacter = " ", inputRequired = no
}
end

// handling charge -- posn 3-5
DataItem GD0JWHC-POSN7-9 char(3)  {
  align = right, fillCharacter = " ", inputRequired = no
}
end

DataItem GD0JWHDR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// inventory account code
DataItem GD0JWICC num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

DataItem GD0JWICR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0JWLAR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// ord dis effective need date
DataItem GD0JWNDT num(8)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

DataItem GD0JWOCR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0JWODR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0JWOMR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0JWOSR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0JWOTR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0JWPAR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0JWPCT num(5,3)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

DataItem GD0JWPGR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0JWPMR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0JWPRR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0JWSHR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// ysmtbl line display  gd0j
DataItem GD0JWSMR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0JWSOR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// xxxstat fld convered to lit
DataItem GD0JWSTA char(8)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0JWSUR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0JWSYR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// trade discount percent
DataItem GD0JWTCD num(5,3)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

DataItem GD0JWTDR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0JWVOR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0JWWHR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0JWXBK char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0JWXHR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0JWYBB char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0JWYBT char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0JWYCD char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0JWYCQ char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0JWYPO char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0JWYQR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// xzctbl line display  gd0j
DataItem GD0JWZCR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

