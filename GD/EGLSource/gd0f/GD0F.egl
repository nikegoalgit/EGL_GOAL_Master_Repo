package gd0f;
import corpcom1.*;
import corpcom4.*;
import corpcom5.*;
import corpcom6.XMGDM;
import corpcom7.*;
import corpx1.*;
import corpx2.*;
import corpy2.*;
import corpz3.*;
import gd.common.*;
import in1.common.*;
import ta.common.*;
//*** PROGRAM=GD0F ****
// Nike on-line CSP table display menu.
// 
//                     CUSTOMER CSP TABLES
// 
// Overview:
// 
//     The purpose of the gd0f customer display application is
// to allow users of customer CSP tables access to these tables
// in a fast and efficient manner.
// 
//     This application is drivin by the GD0G Table display
// application which displays all the valid CSP tables which
// this system is to access. The user then makes a selection
// of which table is to be displayed by entering the code
// (ie. "XCT", {country table} in the option field. The GD0GWT1
// table is then searched and if the code entered is a valid
// table, control is then passed to the application responsible
// for displaying that CSP table. This application displays all
// the customer tables.
// 
// 
// DATE CREATED: 06/07/86
//       AUTHOR: Rick Connoly
// 
// 
// MAINTENANCE HISTORY:
// 
//    DATE      BY WHOM          Overview Of Changes Made
//  --------  -----------    --------------------------------
//  12-08-94  vcowan         orig specs; copied from gd0i for
//                           single-Source Corp Data Project
//                           Tables are DB2 only Tables ...
//                           display for    XAS, XCJ, XCK, XCM,
//                           XCQ, XDP, XFD, XLS, XMH, XUT, YCA,
//                           YCM, YCW, YCB, YCY, YDE, ZFC
//  12-09-94  vcowan         add display for XLATBL
//  01-03-95  vcowan         add display for YBKTBL
//  01-10-95  vcowan         chg title for YBKTBL per chyde
//  01-31-95  vcowan         add display for XLL, XLN, XTY
//  01-31-95  vcowan         add display for XIC
//  05-22-95  vcowan         add display for yns
// *********************
Program GD0F type textUIProgram //VAGen Info - main text program
  {
  includeReferencedFunctions = yes, allowUnqualifiedItemReferences = yes, 
  throwNrfEofExceptions = yes, handleHardIOErrors = no, V60ExceptionCompatibility = yes, 
  I4GLItemsNullable = no, textLiteralDefaultIsString = no, localSQLScope = yes, 
  inputRecord = COMMAREA, segmented = yes
  }

  // Data Declarations
  COMMAREA COMMAREA ; // record
  GD0FWXAS GD0FWXAS; // record
  GD0FWXCJ GD0FWXCJ; // record
  GD0FWXCK GD0FWXCK; // record
  GD0FWXCM GD0FWXCM; // record
  GD0FWXCQ GD0FWXCQ; // record
  GD0FWXDP GD0FWXDP; // record
  GD0FWXFD GD0FWXFD; // record
  GD0FWXIC GD0FWXIC; // record
  GD0FWXLA GD0FWXLA; // record
  GD0FWXLL GD0FWXLL; // record
  GD0FWXLN GD0FWXLN; // record
  GD0FWXLS GD0FWXLS; // record
  GD0FWXMH GD0FWXMH; // record
  GD0FWXTY GD0FWXTY; // record
  GD0FWXUT GD0FWXUT; // record
  GD0FWYBK GD0FWYBK; // record
  GD0FWYCA GD0FWYCA; // record
  GD0FWYCB GD0FWYCB; // record
  GD0FWYCM GD0FWYCM; // record
  GD0FWYCW GD0FWYCW; // record
  GD0FWYCY GD0FWYCY; // record
  GD0FWYDE GD0FWYDE; // record
  GD0FWYNS GD0FWYNS; // record
  GD0FWZFC GD0FWZFC; // record
  GD3REC GD3REC; // record
  GDWREC GDWREC; // record

  // VAGen Info - items needed for migration
  VAGen_EZESYS char(8);
  VAGen_EZEREPLY num(1);
  VAGen_EZE_WAIT_TIME bin(9,2);
  VAGen_EZE_ITEMLEN int;

  // Use Declarations
  use XGLTBL {deleteAfterUse = yes}; // table
  use XASTBL {deleteAfterUse = yes}; // table
  use XCJTBL {deleteAfterUse = yes}; // table
  use XCKTBL {deleteAfterUse = yes}; // table
  use XCMTBL {deleteAfterUse = yes}; // table
  use XCQTBL {deleteAfterUse = yes}; // table
  use XDPTBL {deleteAfterUse = yes}; // table
  use XFDTBL {deleteAfterUse = yes}; // table
  use XICTBL {deleteAfterUse = yes}; // table
  use XLATBL {deleteAfterUse = yes}; // table
  use XLLTBL {deleteAfterUse = yes}; // table
  use XLNTBL {deleteAfterUse = yes}; // table
  use XLSTBL {deleteAfterUse = yes}; // table
  use XMHTBL {deleteAfterUse = yes}; // table
  use XTYTBL {deleteAfterUse = yes}; // table
  use XUTTBL {deleteAfterUse = yes}; // table
  use YBKTBL {deleteAfterUse = yes}; // table
  use YCATBL {deleteAfterUse = yes}; // table
  use YCBTBL {deleteAfterUse = yes}; // table
  use YCMTBL {deleteAfterUse = yes}; // table
  use YCWTBL {deleteAfterUse = yes}; // table
  use YCYTBL {deleteAfterUse = yes}; // table
  use YDETBL {deleteAfterUse = yes}; // table
  use YNSTBL {deleteAfterUse = yes}; // table
  use ZFCTBL {deleteAfterUse = yes}; // table
  use XMGDM.XMGDM002 // form
   {
    pfKeyEquate = no
  };

  function main()
    // VAGen Info - initialization needed for migration
    VAGen_EZESYS = VGLib.getVAGSysType();
    GD0F100: GD0F100();

     /* *************************************************************/
     /* gd0f410;*/

    if (GDWICSP == "XAS") /* consumer services advertisement*/
                                     /* source*/
      goto GD0F110;
    end

    if (GDWICSP == "XCJ") /* consumer system security level*/
      goto GD0F130;
    end

    if (GDWICSP == "XCK") /* consumer services refund reason*/
      goto GD0F150;
    end

    if (GDWICSP == "XCM") /* consumer services shipment method*/
      goto GD0F170;
    end

    if (GDWICSP == "XCQ") /* consumer call interest*/
      goto GD0F190;
    end

    if (GDWICSP == "XDP") /* consumer services deposit status*/
      goto GD0F210;
    end

    if (GDWICSP == "XFD") /* consumer feedback*/
      goto GD0F230;
    end

    if (GDWICSP == "XLS") /* location scan status*/
      goto GD0F250;
    end

    if (GDWICSP == "XMH") /* movable unit hold*/
      goto GD0F270;
    end

    if (GDWICSP == "XUT") /* unit type*/
      goto GD0F290;
    end

    if (GDWICSP == "YCA") /* consumer services consumer activity*/
      goto GD0F310;
    end

    if (GDWICSP == "YCM") /* consumer order status*/
      goto GD0F330;
    end

    if (GDWICSP == "YCW") /* conveyor work order status*/
      goto GD0F350;
    end

    if (GDWICSP == "YCB") /* consumer claim status*/
      goto GD0F370;
    end

    if (GDWICSP == "YCY") /* consumer call type*/
      goto GD0F390;
    end

    if (GDWICSP == "YDE") /* delivery service type*/
      goto GD0F410;
    end

    if (GDWICSP == "ZFC") /* currency*/
      goto GD0F430;
    end


    if (GDWICSP == "XLA") /* lock box address table*/
      goto GD0F450;
    end

    if (GDWICSP == "YBK") /* booking seasons table*/
      goto GD0F470;
    end

    if (GDWICSP == "XLL") /* lane length*/
      goto GD0F490;
    end

    if (GDWICSP == "XLN") /* lane type code*/
      goto GD0F510;
    end

    if (GDWICSP == "XTY") /* lane type code*/
      goto GD0F530;
    end

    if (GDWICSP == "XIC") /* invoice correction reason code*/
      goto GD0F550;
    end

    if (GDWICSP == "YNS") /* nike season by bussiness function*/
      goto GD0F570;
    end


    goto GD0F110; /* default display screen*/



    GD0F110: GD0F110();
    goto GD0F120;
     /* ***********************************************************/



    GD0F120: GD0F120();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of gd0f110.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0F120;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0F110; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0F120; /* recoverse map*/

      else

        goto GD0F110; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0F110; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0F110;

    end



    GD0F130: GD0F130();
    goto GD0F140;
     /* ***********************************************************/



    GD0F140: GD0F140();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of gd0f130.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0F140;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0F130; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0F140; /* recoverse map*/

      else

        goto GD0F130; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0F130; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0F130;

    end



    GD0F150: GD0F150();
    goto GD0F160;
     /* ***********************************************************/



    GD0F160: GD0F160();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of gd0f150.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0F160;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0F150; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0F160; /* recoverse map*/

      else

        goto GD0F150; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0F150; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0F150;

    end



    GD0F170: GD0F170();
    goto GD0F180;
     /* ***********************************************************/



    GD0F180: GD0F180();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of gd0f170.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0F180;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0F170; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0F180; /* recoverse map*/

      else

        goto GD0F170; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0F170; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0F170;

    end



    GD0F190: GD0F190();

    goto GD0F200;
     /* ***********************************************************/


    GD0F200: GD0F200();
    /* GET gd0f.gd0f180*/

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of gd0f170.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0F200;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0F190; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0F200; /* recoverse map*/

      else

        goto GD0F190; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0F190; /* sets map clear, reloads date, and*/
                                     /* pending messages.*/

    else /* unsupported key.*/

      goto GD0F190;

    end



    GD0F210: GD0F210();
    goto GD0F220;
     /* ***********************************************************/



    GD0F220: GD0F220();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of gd0f210.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0F220;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0F210; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0F220; /* recoverse map*/

      else

        goto GD0F210; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0F210; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0F210;

    end



    GD0F230: GD0F230();
    goto GD0F240;
     /* ***********************************************************/



    GD0F240: GD0F240();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of gd0f230.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0F240;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0F230; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0F240; /* recoverse map*/

      else

        goto GD0F230; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0F230; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0F230;

    end



    GD0F250: GD0F250();
    goto GD0F260;
     /* ***********************************************************/



    GD0F260: GD0F260();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of gd0f250.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0F260;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0F250; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0F260; /* recoverse map*/

      else

        goto GD0F250; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0F250; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0F250;

    end



    GD0F270: GD0F270();

    goto GD0F280;
     /* ***********************************************************/


    GD0F280: GD0F280();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of gd0f170.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0F280;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0F270; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0F280; /* recoverse map*/

      else

        goto GD0F270; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0F270; /* sets map clear, reloads date, and*/
                                     /* pending messages.*/

    else /* unsupported key.*/

      goto GD0F270;

    end



    GD0F290: GD0F290();
    goto GD0F300;
     /* ***********************************************************/



    GD0F300: GD0F300();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of gd0f300.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0F300;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0F290; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0F300; /* recoverse map*/

      else

        goto GD0F290; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0F290; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0F290;

    end



    GD0F310: GD0F310();
    goto GD0F320;
     /* ***********************************************************/



    GD0F320: GD0F320();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of gd0f310.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0F320;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0F310; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0F320; /* recoverse map*/

      else

        goto GD0F310; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0F310; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0F310;

    end



    GD0F330: GD0F330();
    goto GD0F340;
     /* ***********************************************************/



    GD0F340: GD0F340();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of gd0f330.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0F340;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0F330; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0F340; /* recoverse map*/

      else

        goto GD0F330; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0F330; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0F330;

    end



    GD0F350: GD0F350();
    goto GD0F360;
     /* ***********************************************************/



    GD0F360: GD0F360();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of gd0f350.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0F360;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0F350; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0F360; /* recoverse map*/

      else

        goto GD0F350; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0F350; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0F350;

    end



    GD0F370: GD0F370();
    goto GD0F380;
     /* ***********************************************************/



    GD0F380: GD0F380();


     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0F370.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0F380;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0F370; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0F380; /* recoverse map*/

      else

        goto GD0F370; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0F370; /* sets map clear, reloads date, and*/
                                     /* pending messages.*/

    else /* unsupported key.*/

      goto GD0F370;

    end



    GD0F390: GD0F390();
    goto GD0F400;
     /* ***********************************************************/



    GD0F400: GD0F400();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of gd0f390.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0F400;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0F390; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0F400; /* recoverse map*/

      else

        goto GD0F390; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0F390; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0F390;

    end



    GD0F410: GD0F410();
    goto GD0F420;
     /* ***********************************************************/



    GD0F420: GD0F420();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of gd0f410.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0F420;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0F410; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0F420; /* recoverse map*/

      else

        goto GD0F410; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0F410; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0F410;

    end



    GD0F430: GD0F430();
    goto GD0F440;
     /* ***********************************************************/



    GD0F440: GD0F440();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of gd0f430.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0F440;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0F430; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0F440; /* recoverse map*/

      else

        goto GD0F430; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0F430; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0F430;

    end



    GD0F450: GD0F450();
    goto GD0F460;
     /* ***********************************************************/



    GD0F460: GD0F460();
     /* GET gd0f.gd0f460*/

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of gd0f450.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0F460;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0F450; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0F460; /* recoverse map*/

      else

        goto GD0F450; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0F450; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0F450;

    end



    GD0F470: GD0F470();
    goto GD0F480;


    GD0F480: GD0F480();
    /* GET GD0J.GD0F480*/

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0J110.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0F480;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0F470; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0F480; /* recoverse map*/

      else

        goto GD0F470; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0F470; /* sets map clear, reloads date, and*/
                                     /* pending messages.*/

    else /* unsupported key.*/

      goto GD0F470;

    end




    GD0F490: GD0F490();
    goto GD0F500;


    GD0F500: GD0F500();
    /* GET GD0F.gd0f500*/

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of gd0f490.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0F500;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0F490; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0F500; /* recoverse map*/

      else

        goto GD0F490; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0F490; /* sets map clear, reloads date, and*/
                                     /* pending messages.*/

    else /* unsupported key.*/

      goto GD0F490;

    end



    GD0F510: GD0F510();
    goto GD0F520;


    GD0F520: GD0F520();
    /* GET GD0F.gd0f520*/

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of gd0f510.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0F520;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0F510; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0F520; /* recoverse map*/

      else

        goto GD0F510; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0F510; /* sets map clear, reloads date, and*/
                                     /* pending messages.*/

    else /* unsupported key.*/

      goto GD0F510;

    end



    GD0F530: GD0F530();
    goto GD0F540;


    GD0F540: GD0F540();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of gd0f530.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0F540;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0F530; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0F540; /* recoverse map*/

      else

        goto GD0F530; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0F530; /* sets map clear, reloads date, and*/
                                     /* pending messages.*/

    else /* unsupported key.*/

      goto GD0F530;

    end



    GD0F550: GD0F550();
    goto GD0F560;


    GD0F560: GD0F560();
    /* GET GD0F.GD0F560*/

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0F550.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0F560;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0F550; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0F560; /* recoverse map*/

      else

        goto GD0F550; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0F550; /* sets map clear, reloads date, and*/
                                     /* pending messages.*/

    else /* unsupported key.*/

      goto GD0F550;

    end



    GD0F570: GD0F570();
    goto GD0F580;


    GD0F580: GD0F580();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of gd0f570.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0F580;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0F570; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0F580; /* recoverse map*/

      else

        goto GD0F570; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0F570; /* sets map clear, reloads date, and*/
                                     /* pending messages.*/

    else /* unsupported key.*/

      goto GD0F570;

    end



  end // end main
end // end GD0F

// Check fast path and initialize
Function GD0F100()


     /* ********************************************************/
     /* * This process intializes program work areas, checks  **/
     /* * user security, and edits the option and item field. **/
     /* *              Flow to gd0f110                        **/
     /* ********************************************************/

     /* check security.*/

   /* ************************************************************/
  XSENTRY(); /* removed for testing  <<<<<<<<<<*/
   /* ************************************************************/

   /* ************************************************************/
  XSSEGTR(); /* 11/88 jw - set segmented trans id*/
   /* ************************************************************/

   /* MOVE 'CSP' TO COMMAREA.CASYSINT ; by security for testing*/
   /* MOVE 'RCONNO' TO COMMAREA.CAUSERID; by security for testing*/

  set GDWREC empty;
  set GD3REC empty;

  GD3REC.GD349B = " "; /* initialize working storage.*/
  GDWREC.GDWFLAGS = " "; /* initialize application flags.*/

     /* Find commarea.cafromap on table, if not there, save*/
     /* original application name in working storage.*/

  GDWREC.GDWTID = COMMAREA.CAFROMAP;
  if (GDWREC.GDWTID in XGLTBL.XGLTAPP)
    XSGDG12();
  else
    XSGDG14();
  end

  if (GDWREC.GDWEDIT == "F")

       /* not found on table, means it must be users application.*/
       /* save users application for PF2 direct return.*/

    GDWREC.GDWFMAPP = COMMAREA.CAFROMAP;
  end

  if (COMMAREA.CAITEM != GD3REC.GD320B) /* does item field have data.*/

            /* The first three bytes of the item field are the csp*/
       /* option. ,*/

    GDWREC.GDWITEM = COMMAREA.CAITEM; /* take it apart,*/

       /* Retreive the first column of the csp table based on the*/
       /* item option.  If the specified item is not a csp table*/
       /* then it must be an error. In this case display the csp*/
       /* tables as we normally would but with an error message*/
       /* for a invalid csp table option.*/

              /* SEARCH FOR SPECIFIED OPTION ON CSP TABLE.*/

    XSGDG10(); /* search for specified option on csp.*/

    if (GDWREC.GDWEDIT == "P") /* tran code found on csp*/

      if (XGLTBL.XGLTAPP[sysVar.arrayIndex] != "GD0F")

        COMMAREA.CATOAP = "GD0G"; /* invalid*/
        COMMAREA.CAITEM = GDWREC.GDWITEM; /* transfer*/
                                                  /* to gd0g display*/
        XSEXIT();

      else

        exit stack;

      end

    else /* not on table, must be outside CSP table appl.*/

      COMMAREA.CATOAP = "GD0G"; /* invalid CSP table*/
      COMMAREA.CAITEM = GDWREC.GDWITEM; /* transfer to GD0G table*/
                                                /* display*/
      XSEXIT();

    end /* if found on CSP table.*/

  end /* item field blank.  default to main menu.*/

  exit stack;




   /* *************************************************************/
end // end GD0F100

// clear screen, format display
Function GD0F110()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to gd0f110 or gd0f120               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0FWXAS empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0F110";


  XSGDG22();

  XMGDM002.XMGDMHED = "XAS - CONSUMER SERVICES ADVERTISEMENT SOURCE";

  GD3REC.GD3PEND1 = "CODE  DESCRIPTION         ";
  GD3REC.GD3PEND2 = "  ABBREV  STAT            ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====  ====================";
  GD3REC.GD3PEND2 = "  ======  ====            ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0FS-DSPLY-XASTBL(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0F110

// display XAS table values
Function GD0F120()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into gd0f.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from gd0f110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0F120

// clear screen, format display
Function GD0F130()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to gd0f130 or gd0f140               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0FWXCJ empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0F130";


  XSGDG22();

  XMGDM002.XMGDMHED = " XCJ CONSUMER SYSTEM SECURITY LEVEL";

  GD3REC.GD3PEND1 = "CODE  DESCRIPTION         ";
  GD3REC.GD3PEND2 = "   ABBREV  STAT           ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====  ====================";
  GD3REC.GD3PEND2 = "=  ======  ====           ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0FS-DSPLY-XCJTBL(); /* format screen and fields to askip*/
                                   /* attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0F130

// display XCJ table values
Function GD0F140()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0G.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0G.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from gd0f110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0F140

// clear screen, format display
Function GD0F150()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to gd0f150 or gd0f160               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0FWXCK empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0F150";


  XSGDG22();

  XMGDM002.XMGDMHED = "XCK CONSUMER SERVICES REFUND REASON";

  GD3REC.GD3PEND1 = "CODE  DESCRIPTION         ";
  GD3REC.GD3PEND2 = "  ABBREV  STAT            ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====  ====================";
  GD3REC.GD3PEND2 = "  ======  ====            ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0FS-DSPLY-XCKTBL(); /* format screen and fields to askip*/
                                   /* attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0F150

// display XCK table values
Function GD0F160()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into gd0f.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display*/
                                   /* application.*/

    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0g.EZEMSG.*/

    GDWREC.GDWRECON = "Y"; /* reconverse, message*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from gd0f110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0F160

// clear screen, format display
Function GD0F170()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to gd0f170 or gd0f180               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0FWXCM empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0F170";


  XSGDG22();

  XMGDM002.XMGDMHED = " XCM CONSUMER SERVICES SHIPMENT METHOD";

  GD3REC.GD3PEND1 = "SHIP   PK   DESCRIPTION   ";
  GD3REC.GD3PEND2 = "        ABBREV  STAT      ";
  GD3REC.GD3PEND3 = "   STATUS                 ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "CODE  CODE  ==============";
  GD3REC.GD3PEND2 = "======  ======  ====      ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0FS-DSPLY-XCMTBL(); /* format screen and fields to askip*/
                                   /* attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0F170

// display XCM table values
Function GD0F180()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into gd0f.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display*/
                                   /* application.*/

    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0g.EZEMSG.*/

    GDWREC.GDWRECON = "Y"; /* reconverse, message*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from gd0f110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0F180

// clear screen, format display
Function GD0F190()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to gd0f190 or gd0f200               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0FWXCQ empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0F190";


  XSGDG22();

  XMGDM002.XMGDMHED = " XCQ - CONSUMER CALL INTEREST  ";

  GD3REC.GD3PEND1 = "CODE  DESCRIPTION         ";
  GD3REC.GD3PEND2 = "  ABBREV  STAT            ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====  ====================";
  GD3REC.GD3PEND2 = "  ======  ====            ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0FS-DSPLY-XCQTBL(); /* format screen and fields to askip*/
                                   /* attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0F190

// display XCQ table values
Function GD0F200()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into gd0f.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display*/
                                   /* application.*/

    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0g.EZEMSG.*/

    GDWREC.GDWRECON = "Y"; /* reconverse, message*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from gd0f110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0F200

// clear screen, format display
Function GD0F210()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to gd0f210 or gd0f220               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0FWXDP empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0F210";


  XSGDG22();

  XMGDM002.XMGDMHED = " XDP CONSUMER SERVICES DEPOSIT STATUS";

  GD3REC.GD3PEND1 = "CODE  DESCRIPTION         ";
  GD3REC.GD3PEND2 = "  ABBREV  STAT            ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====  ====================";
  GD3REC.GD3PEND2 = "  ======  ====            ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0FS-DSPLY-XDPTBL(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0F210

// display XDP table values
Function GD0F220()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into gd0f.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display*/
                                   /* application.*/

    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0g.EZEMSG.*/

    GDWREC.GDWRECON = "Y"; /* reconverse, message*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from gd0f110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0F220

// clear screen, format display
Function GD0F230()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to gd0f230 or gd0f240               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0FWXFD empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0F230";


  XSGDG22();

  XMGDM002.XMGDMHED = " XFD - CONSUMER FEEDBACK TABLE ";

  GD3REC.GD3PEND1 = "CODE  DESCRIPTION         ";
  GD3REC.GD3PEND2 = "            ABBREV  STAT  ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====  ====================";
  GD3REC.GD3PEND2 = "==========  ======  ====  ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0FS-DSPLY-XFDTBL(); /* format screen and fields to askip*/
                                   /* attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0F230

// display XFD table values
Function GD0F240()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into gd0f.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display*/
                                   /* application.*/

    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0g.EZEMSG.*/

    GDWREC.GDWRECON = "Y"; /* reconverse, message*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from gd0f110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0F240

// clear screen, format display
Function GD0F250()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to gd0f250 or gd0f260               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0FWXLS empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0F250";


  XSGDG22();

  XMGDM002.XMGDMHED = " XLS - LOCATION SCAN STATUS   ";

  GD3REC.GD3PEND1 = "WHSE  SCAN  ABBREV  DESCRI";
  GD3REC.GD3PEND2 = "PTION                     ";
  GD3REC.GD3PEND3 = "STAT                      ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "CODE  CODE  ======  ======";
  GD3REC.GD3PEND2 = "========================  ";
  GD3REC.GD3PEND3 = "====                      ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

   /* format screen and fields to askip*/
   /* attribute.*/
  GD0FS-DSPLY-XLSTBL();
  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0F250

// display XLS table values
Function GD0F260()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into gd0f.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display*/
                                   /* application.*/

    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0g.EZEMSG.*/

    GDWREC.GDWRECON = "Y"; /* reconverse, message*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from gd0f110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0F260

// clear screen, format display
Function GD0F270()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to gd0f270 or gd0f280               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0FWXMH empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0F270";


  XSGDG22();

  XMGDM002.XMGDMHED = " XMH - MOVABLE UNIT HOLD TABLE ";

  GD3REC.GD3PEND1 = "CODE  ABBREV  DESCRIPTION ";
  GD3REC.GD3PEND2 = "                     SAS I";
  GD3REC.GD3PEND3 = "D    STAT                 ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====  ======  ============";
  GD3REC.GD3PEND2 = "==================  ======";
  GD3REC.GD3PEND3 = "===  ====                 ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0FS-DSPLY-XMHTBL(); /* format screen and fields to askip*/
                                   /* attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0F270

// display XMH table values
Function GD0F280()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into gd0f.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display*/
                                   /* application.*/

    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0g.EZEMSG.*/

    GDWREC.GDWRECON = "Y"; /* reconverse, message*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from gd0f110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0F280

// clear screen, format display
Function GD0F290()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to gd0f290 or gd0f300               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0FWXUT empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0F290";


  XSGDG22();

  XMGDM002.XMGDMHED = " XUT - UNIT TYPE TABLE        ";

  GD3REC.GD3PEND1 = "CODE  ABBREV  DESCRIPTION ";
  GD3REC.GD3PEND2 = "                          ";
  GD3REC.GD3PEND3 = "                      STAT";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====  ======  ============";
  GD3REC.GD3PEND2 = "==========================";
  GD3REC.GD3PEND3 = "====================  ====";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0FS-DSPLY-XUTTBL(); /* format screen and fields to askip*/
                                   /* attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0F290

// display XUT table values
Function GD0F300()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into gd0f.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display*/
                                   /* application.*/

    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0g.EZEMSG.*/

    GDWREC.GDWRECON = "Y"; /* reconverse, message*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from gd0f110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0F300

// clear screen, format display
Function GD0F310()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to gd0f310 or gd0f320               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0FWYCA empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0F310";


  XSGDG22();

  XMGDM002.XMGDMHED = " YCA CONSUMER SERVICES CONSUMER ACTIVITY";

  GD3REC.GD3PEND1 = "CODE  DESCRIPTION         ";
  GD3REC.GD3PEND2 = "  ABBREV  STAT            ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====  ====================";
  GD3REC.GD3PEND2 = "  ======  ====            ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0FS-DSPLY-YCATBL(); /* format screen and fields to askip*/
                                   /* attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0F310

// display YCA table values
Function GD0F320()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into gd0f.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display*/
                                   /* application.*/

    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0g.EZEMSG.*/

    GDWREC.GDWRECON = "Y"; /* reconverse, message*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from gd0f110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0F320

// clear screen, format display
Function GD0F330()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to gd0f330 or gd0f340               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0FWYCM empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0F330";


  XSGDG22();

  XMGDM002.XMGDMHED = " YCM - CONSUMER ORDER STATUS";

  GD3REC.GD3PEND1 = "CODE  DESCRIPTION         ";
  GD3REC.GD3PEND2 = "  ABBREV  HDR   STAT  OVRD";
  GD3REC.GD3PEND3 = "  STAT                    ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====  ====================";
  GD3REC.GD3PEND2 = "  ======  STAT  SEQ    FL ";
  GD3REC.GD3PEND3 = "  ====                    ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0FS-DSPLY-YCMTBL(); /* format screen and fields to askip*/
                                   /* attribute.*/

  set XMGDM002.XMGDMITM cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0F330

// display YCM table values
Function GD0F340()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into gd0f.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display*/
                                   /* application.*/

    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0g.EZEMSG.*/

    GDWREC.GDWRECON = "Y"; /* reconverse, message*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from gd0f110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0F340

// clear screen, format display
Function GD0F350()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to gd0f350 or gd0f360               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0FWYCW empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0F350";


  XSGDG22();

  XMGDM002.XMGDMHED = " YCW - CONVEYOR WORK ORDER STATUS ";

  GD3REC.GD3PEND1 = "CODE  ABBREV  DESCRIPTION ";
  GD3REC.GD3PEND2 = "                    STAT  ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====  ======  ============";
  GD3REC.GD3PEND2 = "==================  ====  ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0FS-DSPLY-YCWTBL(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDMITM cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0F350

// display YCW table values
Function GD0F360()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into gd0f.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display*/
                                   /* application.*/

    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0g.EZEMSG.*/

    GDWREC.GDWRECON = "Y"; /* reconverse, message*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from gd0f110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0F360

// clear screen, format display
Function GD0F370()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to gd0f470 or gd0f480               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0FWYCB empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0F370";


  XSGDG22();

  XMGDM002.XMGDMHED = " YCB - CONSUMER CLAIM STATUS";

  GD3REC.GD3PEND1 = "CODE  DESCRIPTION         ";
  GD3REC.GD3PEND2 = "  ABBREV   SEQ NBR  STAT  ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====  ====================";
  GD3REC.GD3PEND2 = "  ======  ========  ====  ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0FS-DSPLY-YCBTBL(); /* format screen and fields to askip*/
                                   /* attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0F370

// display YCB table values
Function GD0F380()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into gd0f.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display*/
                                   /* application.*/

    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y"; /* reconverse, message*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from gd0f110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0F380

// clear screen, format display
Function GD0F390()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to gd0f390 or gd0f400               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0FWYCY empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0F390";


  XSGDG22();

  XMGDM002.XMGDMHED = " YCY - CONSUMER CALL TYPE ";

  GD3REC.GD3PEND1 = "CODE  SEQ   DESCRIPTION   ";
  GD3REC.GD3PEND2 = "             STAT         ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====  NBR   ==============";
  GD3REC.GD3PEND2 = "===========  ====         ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0FS-DSPLY-YCYTBL(); /* format screen and fields to askip*/
                                   /* attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0F390

// display YCY table values
Function GD0F400()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into gd0f.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display*/
                                   /* application.*/

    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y"; /* reconverse, message*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from gd0f110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0F400

// clear screen, format display
Function GD0F410()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to gd0f400 or gd0f441               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0FWYDE empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0F410";


  XSGDG22();

  XMGDM002.XMGDMHED = " YDE - DELIVERY SERVICE TYPE  ";

  GD3REC.GD3PEND1 = "CODE  DESCRIPTION         ";
  GD3REC.GD3PEND2 = "            SHORT DESC    ";
  GD3REC.GD3PEND3 = "STAT                      ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====  ====================";
  GD3REC.GD3PEND2 = "==========  ============  ";
  GD3REC.GD3PEND3 = "====                      ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0FS-DSPLY-YDETBL(); /* format screen and fields to askip*/
                                   /* attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0F410

// display YDE table values
Function GD0F420()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into gd0f.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display*/
                                   /* application.*/

    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y"; /* reconverse, message*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from gd0f110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0F420

// clear screen, format display
Function GD0F430()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to gd0f430 or gd0f440               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0FWZFC empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0F430";


  XSGDG22();

  XMGDM002.XMGDMHED = " ZFC - CURRENCY TABLE   ";

  GD3REC.GD3PEND1 = "CODE  DESCRIPTION         ";
  GD3REC.GD3PEND2 = "            STAT          ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====  ====================";
  GD3REC.GD3PEND2 = "==========  ====          ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0FS-DSPLY-ZFCTBL(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0F430

// display ZFC table values
Function GD0F440()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into gd0f.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display*/
                                   /* application.*/

    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y"; /* reconverse, message*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from gd0f110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0F440

// clear screen, format display
Function GD0F450()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to gd0f450 or gd0f460               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0FWXLA empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0F450";


  XSGDG22();

  XMGDM002.XMGDMHED = " XLA - LOCK BOX ADDRESS TABLE";

  GD3REC.GD3PEND1 = "BOX   ADDRESS-LINE 1      ";
  GD3REC.GD3PEND2 = "                     CITY ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "CODE  ADDRESS-LINE 2      ";
  GD3REC.GD3PEND2 = "                     STATE";
  GD3REC.GD3PEND3 = "  ZIP       GL    STAT    ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0FS-DSPLY-XLATBL(); /* format screen and fields to askip*/
                                   /* attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0F450

// display XLA table values
Function GD0F460()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into gd0f.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display*/
                                   /* application.*/

    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y"; /* reconverse, message*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from gd0f110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0F460

// clear screen, format display
Function GD0F470()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0K470 or GD0J480               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0FWYBK empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0F470";


  XSGDG22();

  XMGDM002.XMGDMHED = "YBK--GLOBAL BOOKINGS SEASON TABLE";

  GD3REC.GD3PEND1 = "CODE  DESCRIPTION       AB";
  GD3REC.GD3PEND2 = "BREV  STATUS              ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====  ===============   ==";
  GD3REC.GD3PEND2 = "====  ======              ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0FS-DSPLY-YBKTBL(); /* format screen and fields to askip*/
                                   /* attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0F470

// display XBK table values
Function GD0F480()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0F480

// clear screen, format display
Function GD0F490()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to gd0f110 or gd0f120               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0FWXLL empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0F490";


  XSGDG22();

  XMGDM002.XMGDMHED = "XLL - LANE LENGTH TABLE";

  GD3REC.GD3PEND1 = "CODE  DESCRIPTION  SHORT  ";
  GD3REC.GD3PEND2 = "ABBREV  STAT              ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====  ==========   DESC   ";
  GD3REC.GD3PEND2 = "======  ====              ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0FS-DSPLY-XLLTBL(); /* format screen and fields to askip*/
                                   /* attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0F490

// display XAS table values
Function GD0F500()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into gd0f.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from gd0f110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0F500

// clear screen, format display
Function GD0F510()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to gd0f110 or gd0f120               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0FWXLN empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0F510";


  XSGDG22();

  XMGDM002.XMGDMHED = "XLN - LANE TYPE CODE TABLE";

  GD3REC.GD3PEND1 = "CODE  DESCRIPTION       SH";
  GD3REC.GD3PEND2 = "ORT      ABBREV  MIN    ST";
  GD3REC.GD3PEND3 = "AT                        ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====  ================  DE";
  GD3REC.GD3PEND2 = "SC       ======  CASES  ==";
  GD3REC.GD3PEND3 = "==                        ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0FS-DSPLY-XLNTBL(); /* format screen and fields to askip*/
                                   /* attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0F510

// display XAS table values
Function GD0F520()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into gd0f.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from gd0f110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0F520

// clear screen, format display
Function GD0F530()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to gd0f110 or gd0f120               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0FWXTY empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0F530";


  XSGDG22();

  XMGDM002.XMGDMHED = "XTY - TASK TYPE TABLE";

  GD3REC.GD3PEND1 = "CODE  DESCRIPTION       SH";
  GD3REC.GD3PEND2 = "ORT     ABBREV  STAT      ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====  ================  DE";
  GD3REC.GD3PEND2 = "SC      ======  ====      ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0FS-DSPLY-XTYTBL(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0F530

// display XAS table values
Function GD0F540()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into gd0f.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from gd0f110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0F540

// clear screen, format display
Function GD0F550()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to gd0f550 or gd0f560               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0FWXIC empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0F550";


  XSGDG22();

  XMGDM002.XMGDMHED = "XIC - INVOICE CORRECTIONS REASON TABLE";

  GD3REC.GD3PEND1 = "CODE  DESCRIPTION         ";
  GD3REC.GD3PEND2 = "            SHORT DESC    ";
  GD3REC.GD3PEND3 = "STAT                      ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====  ====================";
  GD3REC.GD3PEND2 = "==========  ============  ";
  GD3REC.GD3PEND3 = "====                      ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0FS-DSPLY-XICTBL(); /* format screen and fields to askip*/
                                   /* attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0F550

// display XAS table values
Function GD0F560()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into gd0f.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from gd0f110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0F560

// clear screen, format display
Function GD0F570()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to gd0f570 or gd0f580               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0FWYNS empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0F570";


  XSGDG22();

  XMGDM002.XMGDMHED = "YNS - NIKE SEASON BY BUSINESS FUNCTION";

  GD3REC.GD3PEND1 = "TABLE KEY SESN SESN YEAR  ";
  GD3REC.GD3PEND2 = "BUS   YEAR DESC       YEAR";
  GD3REC.GD3PEND3 = "  SEASON     SEASON     ST";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "========= CODE =========  ";
  GD3REC.GD3PEND2 = "FUNC  ==============  ABRV";
  GD3REC.GD3PEND3 = "  BEGIN DTE  END DATE   ==";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0FS-DSPLY-YNSTBL(); /* format screen and fields to askip*/
                                   /* attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0F570

// display XAS table values
Function GD0F580()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into gd0f.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from gd0f110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0F580

// Formats screen,autoskip XAU
Function GD0FS-DSPLY-XASTBL()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XAS CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XASTBL.XAS-AD-SRC-CD[GDWINDX2] != "99")

    GD0FWXAS.XAS-AD-SRC-CD = XASTBL.XAS-AD-SRC-CD[GDWINDX2];
    GD0FWXAS.XAS-AD-SRC-DESC = XASTBL.XAS-AD-SRC-DESC[GDWINDX2];
    GD0FWXAS.XAS-AD-SRC-ABRV = XASTBL.XAS-AD-SRC-ABRV[GDWINDX2];
    GD0FWXAS.XXX-STAT = XASTBL.XXX-STAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0FWXAS.GD0FWXAS-GROUP;

    set GD0FWXAS empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XASTBL.XAS-AD-SRC-CD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0FS-DSPLY-XASTBL

// Formats screen,autoskip XCS
Function GD0FS-DSPLY-XCJTBL()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XCJ CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XCJTBL.XCJ-SCRTY-LVL-ID[GDWINDX2] != "99")

    GD0FWXCJ.XCJ-SCRTY-LVL-ID = XCJTBL.XCJ-SCRTY-LVL-ID[GDWINDX2];
    GD0FWXCJ.XCJ-SCRTY-LVL-DESC = XCJTBL.XCJ-SCRTY-LVL-DESC[GDWINDX2];
    GD0FWXCJ.XCJ-SCRTY-LVL-ABRV = XCJTBL.XCJ-SCRTY-LVL-ABRV[GDWINDX2];
    GD0FWXCJ.XXX-STAT = XCJTBL.XXX-STAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0FWXCJ.GD0FWXCJ-GROUP;

    set GD0FWXCJ empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XCJTBL.XCJ-SCRTY-LVL-ID[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0FS-DSPLY-XCJTBL

// Formats screen,autoskip XCF
Function GD0FS-DSPLY-XCKTBL()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XCK CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XCKTBL.XCK-RFND-RSN-CD[GDWINDX2] != "99")

    GD0FWXCK.XCK-RFND-RSN-CD = XCKTBL.XCK-RFND-RSN-CD[GDWINDX2];
    GD0FWXCK.XCK-RFND-RSN-DESC = XCKTBL.XCK-RFND-RSN-DESC[GDWINDX2];
    GD0FWXCK.XCK-RFND-RSN-ABRV = XCKTBL.XCK-RFND-RSN-ABRV[GDWINDX2];
    GD0FWXCK.XXX-STAT = XCKTBL.XXX-STAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0FWXCK.GD0FWXCK-GROUP;

    set GD0FWXCK empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XCKTBL.XCK-RFND-RSN-CD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0FS-DSPLY-XCKTBL

// Formats screen,autoskip XCT
Function GD0FS-DSPLY-XCMTBL()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XCM CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XCMTBL.XCM-SHP-MTHD-CD[GDWINDX2] != "99")

    GD0FWXCM.XCM-SHP-MTHD-CD = XCMTBL.XCM-SHP-MTHD-CD[GDWINDX2];
    GD0FWXCM.XPPCD = XCMTBL.XPPCD[GDWINDX2];
    GD0FWXCM.XCM-SHP-MTHD-DESC = XCMTBL.XCM-SHP-MTHD-DESC[GDWINDX2];
    GD0FWXCM.XCM-SHP-MTHD-ABRV = XCMTBL.XCM-SHP-MTHD-ABRV[GDWINDX2];
    GD0FWXCM.XXX-STAT = XCMTBL.XXX-STAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0FWXCM.GD0FWXCM-GROUP;

    set GD0FWXCM empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XCMTBL.XCM-SHP-MTHD-CD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0FS-DSPLY-XCMTBL

// Formats screen,autoskip XCT
Function GD0FS-DSPLY-XCQTBL()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XCQ CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XCQTBL.XCQ-CALL-INT-CD[GDWINDX2] != "99")

    GD0FWXCQ.XCQ-CALL-INT-CD = XCQTBL.XCQ-CALL-INT-CD[GDWINDX2];
    GD0FWXCQ.XCQ-CALL-INT-DESC = XCQTBL.XCQ-CALL-INT-DESC[GDWINDX2];
    GD0FWXCQ.XCQ-CALL-INT-ABRV = XCQTBL.XCQ-CALL-INT-ABRV[GDWINDX2];

    GD0FWXCQ.XXX-STAT = XCQTBL.XXX-STAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0FWXCQ.GD0FWXCQ-GROUP;

    set GD0FWXCQ empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XCQTBL.XCQ-CALL-INT-CD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0FS-DSPLY-XCQTBL

// Formats screen,autoskip XCA
Function GD0FS-DSPLY-XDPTBL()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XCA CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XDPTBL.XDP-DEP-STAT-CD[GDWINDX2] != "99")

    GD0FWXDP.XDP-DEP-STAT-CD = XDPTBL.XDP-DEP-STAT-CD[GDWINDX2];
    GD0FWXDP.XDP-DEP-STAT-ABRV = XDPTBL.XDP-DEP-STAT-ABRV[GDWINDX2];
    GD0FWXDP.XDP-DEP-STAT-DESC = XDPTBL.XDP-DEP-STAT-DESC[GDWINDX2];
    GD0FWXDP.XXX-STAT = XDPTBL.XXX-STAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0FWXDP.GD0FWXDP-GROUP;

    set GD0FWXDP empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XDPTBL.XDP-DEP-STAT-CD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0FS-DSPLY-XDPTBL

// Formats screen,autoskip XLG
Function GD0FS-DSPLY-XFDTBL()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XFD CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XFDTBL.XFD-FBK-CAT-CD[GDWINDX2] != "99")

    GD0FWXFD.XFD-FBK-CAT-CD = XFDTBL.XFD-FBK-CAT-CD[GDWINDX2];
    GD0FWXFD.XFD-FBK-CAT-ABRV = XFDTBL.XFD-FBK-CAT-ABRV[GDWINDX2];
    GD0FWXFD.XFD-FBK-CAT-DESC = XFDTBL.XFD-FBK-CAT-DESC[GDWINDX2];
    GD0FWXFD.XXX-STAT = XFDTBL.XXX-STAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0FWXFD.GD0FWXFD-GROUP;

    set GD0FWXFD empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XFDTBL.XFD-FBK-CAT-CD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0FS-DSPLY-XFDTBL

// Formats screen,autoskip XAU
Function GD0FS-DSPLY-XICTBL()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the xic CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XICTBL.XIC-IVC-CRCTRSN-CD[GDWINDX2] != "999")

    GD0FWXIC.XIC-IVC-CRCTRSN-CD = XICTBL.XIC-IVC-CRCTRSN-CD[GDWINDX2];
    GD0FWXIC.XIC-CRCT-RSN-DESC = XICTBL.XIC-CRCT-RSN-DESC[GDWINDX2];
    GD0FWXIC.XIC-CRCT-RSN-SDESC = XICTBL.XIC-CRCT-RSN-SDESC[GDWINDX2];
    GD0FWXIC.XXX-STAT = XICTBL.XXX-STAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0FWXIC.GD0FWXIC-GROUP;

    set GD0FWXIC empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XICTBL.XIC-IVC-CRCTRSN-CD[GDWINDX2] == "999")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0FS-DSPLY-XICTBL

// Formats screen,autoskip ZFL
Function GD0FS-DSPLY-XLATBL()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the ZFC CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XLATBL.XLBCD[GDWINDX2] != "99")

    GD0FWXLA.XLBCD = XLATBL.XLBCD[GDWINDX2];
    GD0FWXLA.XXX-ADDR1 = XLATBL.XXX-ADDR1[GDWINDX2];
    GD0FWXLA.XXXCITY = XLATBL.XXXCITY[GDWINDX2];

    XMGDM002.XMGDMLIN[GDWINDX1] = GD0FWXLA.GD0FWXLA-GROUP1;
    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;

    GD0FWXLA.XXX-ADDR2 = XLATBL.XXX-ADDR2[GDWINDX2];
    GD0FWXLA.XSTCD = XLATBL.XSTCD[GDWINDX2];
    GD0FWXLA.XXXZIP = XLATBL.XXXZIP[GDWINDX2];
    GD0FWXLA.GLAENT = XLATBL.GLAENT[GDWINDX2];
    GD0FWXLA.XXXSTAT = XLATBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0FWXLA.GD0FWXLA-GROUP2;

    set GD0FWXLA empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XLATBL.XLBCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0FS-DSPLY-XLATBL

// Formats screen,autoskip XAU
Function GD0FS-DSPLY-XLLTBL()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XAS CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XLLTBL.XLLCD[GDWINDX2] != "99")

    GD0FWXLL.XLLCD = XLLTBL.XLLCD[GDWINDX2];
    GD0FWXLL.XLLDESC = XLLTBL.XLLDESC[GDWINDX2];
    GD0FWXLL.XLLSDESC = XLLTBL.XLLSDESC[GDWINDX2];
    GD0FWXLL.XLLABRV = XLLTBL.XLLABRV[GDWINDX2];
    GD0FWXLL.XXXSTAT = XLLTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0FWXLL.GD0FWXLL-GROUP;

    set GD0FWXLL empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XLLTBL.XLLCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0FS-DSPLY-XLLTBL

// Formats screen,autoskip XAU
Function GD0FS-DSPLY-XLNTBL()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XLN CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XLNTBL.XLNCD[GDWINDX2] != "99")

    GD0FWXLN.XLNCD = XLNTBL.XLNCD[GDWINDX2];
    GD0FWXLN.XLNDESC = XLNTBL.XLNDESC[GDWINDX2];
    GD0FWXLN.XLNSDESC = XLNTBL.XLNSDESC[GDWINDX2];
    GD0FWXLN.XLNABRV = XLNTBL.XLNABRV[GDWINDX2];
    GD0FWXLN.GD0FW-XLNMINCS = XLNTBL.XLNMINCS[GDWINDX2];
    GD0FWXLN.XXXSTAT = XLNTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0FWXLN.GD0FWXLN-GROUP;

    set GD0FWXLN empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XLNTBL.XLNCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0FS-DSPLY-XLNTBL

// Formats screen,autoskip XCT
Function GD0FS-DSPLY-XLSTBL()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XCT CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XLSTBL.XWH-WHSE-CD[GDWINDX2] != "99")

    GD0FWXLS.XWH-WHSE-CD = XLSTBL.XWH-WHSE-CD[GDWINDX2];
    GD0FWXLS.XLS-SCAN-STAT-CD = XLSTBL.XLS-SCAN-STAT-CD[GDWINDX2];
    GD0FWXLS.XLS-SCAN-STAT-ABRV = XLSTBL.XLS-SCAN-STAT-ABRV[GDWINDX2];
    GD0FWXLS.XLS-SCAN-STAT-DESC = XLSTBL.XLS-SCAN-STAT-DESC[GDWINDX2];
    GD0FWXLS.XXX-STAT = XLSTBL.XXX-STAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0FWXLS.GD0FWXLS-GROUP;

    set GD0FWXLS empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XLSTBL.XWH-WHSE-CD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0FS-DSPLY-XLSTBL

// Formats screen,autoskip XCT
Function GD0FS-DSPLY-XMHTBL()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XCT CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XMHTBL.XMH-MOVB-HLD-CD[GDWINDX2] != "999")

    GD0FWXMH.XMH-MOVB-HLD-CD = XMHTBL.XMH-MOVB-HLD-CD[GDWINDX2];
    GD0FWXMH.XMH-MOVB-HLD-ABRV = XMHTBL.XMH-MOVB-HLD-ABRV[GDWINDX2];
    GD0FWXMH.XMH-MOVB-HLD-DESC = XMHTBL.XMH-MOVB-HLD-DESC[GDWINDX2];
    GD0FWXMH.GD0FW-IN-SAS-ID = XMHTBL.INASAID[GDWINDX2];
    GD0FWXMH.XXX-STAT = XMHTBL.XXX-STAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0FWXMH.GD0FWXMH-GROUP;

    set GD0FWXMH empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XMHTBL.XMH-MOVB-HLD-CD[GDWINDX2] == "999")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0FS-DSPLY-XMHTBL

// Formats screen,autoskip XAU
Function GD0FS-DSPLY-XTYTBL()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XLN CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XTYTBL.XTYCD[GDWINDX2] != "99")

    GD0FWXTY.XTYCD = XTYTBL.XTYCD[GDWINDX2];
    GD0FWXTY.XTYDESC = XTYTBL.XTYDESC[GDWINDX2];
    GD0FWXTY.XTYSDESC = XTYTBL.XTYSDESC[GDWINDX2];
    GD0FWXTY.XTYABRV = XTYTBL.XTYABRV[GDWINDX2];
    GD0FWXTY.XXXSTAT = XTYTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0FWXTY.GD0FWXTY-GROUP;

    set GD0FWXTY empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XTYTBL.XTYCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0FS-DSPLY-XTYTBL

// Formats screen,autoskip XND
Function GD0FS-DSPLY-XUTTBL()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XND CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XUTTBL.XUT-UNT-TYP-CD[GDWINDX2] != "99")

    GD0FWXUT.XUT-UNT-TYP-CD = XUTTBL.XUT-UNT-TYP-CD[GDWINDX2];
    GD0FWXUT.XUT-UNT-TYP-ABRV = XUTTBL.XUT-UNT-TYP-ABRV[GDWINDX2];
    GD0FWXUT.XUT-UNT-TYP-DESC = XUTTBL.XUT-UNT-TYP-DESC[GDWINDX2];
    GD0FWXUT.XXX-STAT = XUTTBL.XXX-STAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0FWXUT.GD0FWXUT-GROUP;

    set GD0FWXUT empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XUTTBL.XUT-UNT-TYP-CD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0FS-DSPLY-XUTTBL

// Formats screen,autoskip ybb
Function GD0FS-DSPLY-YBKTBL()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the ybb CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && YBKTBL.XBK-BK-SESN-CD[GDWINDX2] != "99")

    GD0FWYBK.XBK-BK-SESN-CD = YBKTBL.XBK-BK-SESN-CD[GDWINDX2];
    GD0FWYBK.XBK-BK-SESN-ABRV = YBKTBL.XBK-BK-SESN-ABRV[GDWINDX2];
    GD0FWYBK.XBK-BK-SESN-DESC = YBKTBL.XBK-BK-SESN-DESC[GDWINDX2];
    GD0FWYBK.XXXSTAT = YBKTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0FWYBK.GD0FWYBK-GROUP;

    set GD0FWYBK empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (YBKTBL.XBK-BK-SESN-CD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0FS-DSPLY-YBKTBL

// Formats screen,autoskip XNI
Function GD0FS-DSPLY-YCATBL()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XNI CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && YCATBL.YCA-CNSMR-ACT-CD[GDWINDX2] != "99")

    GD0FWYCA.YCA-CNSMR-ACT-CD = YCATBL.YCA-CNSMR-ACT-CD[GDWINDX2];
    GD0FWYCA.YCA-CNSMR-ACT-DESC = YCATBL.YCA-CNSMR-ACT-DESC[GDWINDX2];
    GD0FWYCA.YCA-CNSMR-ACT-ABRV = YCATBL.YCA-CNSMR-ACT-ABRV[GDWINDX2];
    GD0FWYCA.XXX-STAT = YCATBL.XXX-STAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0FWYCA.GD0FWYCA-GROUP;

    set GD0FWYCA empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (YCATBL.YCA-CNSMR-ACT-CD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0FS-DSPLY-YCATBL

// Formats screen,autoskip ZIV
Function GD0FS-DSPLY-YCBTBL()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the ZIV CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && YCBTBL.YCB-CLM-STAT-CD[GDWINDX2] != "99")

    GD0FWYCB.YCB-CLM-STAT-CD = YCBTBL.YCB-CLM-STAT-CD[GDWINDX2];
    GD0FWYCB.YCB-CLM-STAT-DESC = YCBTBL.YCB-CLM-STAT-DESC[GDWINDX2];
    GD0FWYCB.YCB-CLM-STAT-ABRV = YCBTBL.YCB-CLM-STAT-ABRV[GDWINDX2];
    GD0FWYCB.GD0FW-YCB-STAT-SEQ-NBR = YCBTBL.YCB-STAT-SEQ-NBR[GDWINDX2];
    GD0FWYCB.XXX-STAT = YCBTBL.XXX-STAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0FWYCB.GD0FWYCB-GROUP;

    set GD0FWYCB empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (YCBTBL.YCB-CLM-STAT-CD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0FS-DSPLY-YCBTBL

// Formats screen,autoskip XNX
Function GD0FS-DSPLY-YCMTBL()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XNX CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && YCMTBL.YCM-ORD-STAT-CD[GDWINDX2] != "99")

    GD0FWYCM.YCM-ORD-STAT-CD = YCMTBL.YCM-ORD-STAT-CD[GDWINDX2];
    GD0FWYCM.YCM-ORD-STAT-ABRV = YCMTBL.YCM-ORD-STAT-ABRV[GDWINDX2];
    GD0FWYCM.YCM-ORD-STAT-DESC = YCMTBL.YCM-ORD-STAT-DESC[GDWINDX2];
    GD0FWYCM.YCM-HDR-STAT-CD = YCMTBL.YCM-HDR-STAT-CD[GDWINDX2];
    GD0FWYCM.GD0FW-YCM-STAT-SEQ-NBR = YCMTBL.YCM-STAT-SEQ-NBR[GDWINDX2];
    GD0FWYCM.YCM-OVRD-BY-OP-FL = YCMTBL.YCM-OVRD-BY-OP-FL[GDWINDX2];
    GD0FWYCM.XXX-STAT = YCMTBL.XXX-STAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0FWYCM.GD0FWYCM-GROUP;

    set GD0FWYCM empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (YCMTBL.YCM-ORD-STAT-CD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0FS-DSPLY-YCMTBL

// Formats screen,autoskip XSG
Function GD0FS-DSPLY-YCWTBL()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XSG CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && YCWTBL.YCW-WO-STAT-CD[GDWINDX2] != 99)

    GD0FWYCW.YCW-WO-STAT-CD = YCWTBL.YCW-WO-STAT-CD[GDWINDX2];
    GD0FWYCW.YCW-WO-STAT-ABRV = YCWTBL.YCW-WO-STAT-ABRV[GDWINDX2];
    GD0FWYCW.YCW-WO-STAT-DESC = YCWTBL.YCW-WO-STAT-DESC[GDWINDX2];
    GD0FWYCW.XXX-STAT = YCWTBL.XXX-STAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0FWYCW.GD0FWYCW-GROUP;

    set GD0FWYCW empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (YCWTBL.YCW-WO-STAT-CD[GDWINDX2] == 99)

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0FS-DSPLY-YCWTBL

// Formats screen,autoskip XST
Function GD0FS-DSPLY-YCYTBL()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XST CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && YCYTBL.YCY-CALL-TYP-CD[GDWINDX2] != "999")

    GD0FWYCY.YCY-CALL-TYP-CD = YCYTBL.YCY-CALL-TYP-CD[GDWINDX2];
    GD0FWYCY.YCY-CALL-TYP-DESC = YCYTBL.YCY-CALL-TYP-DESC[GDWINDX2];
    GD0FWYCY.GD0FW-YCY-CALLTYP-SEQNBR = YCYTBL.YCY-CALLTYP-SEQNBR[GDWINDX2];
    GD0FWYCY.XXX-STAT = YCYTBL.XXX-STAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0FWYCY.GD0FWYCY-GROUP;

    set GD0FWYCY empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (YCYTBL.YCY-CALL-TYP-CD[GDWINDX2] == "999")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0FS-DSPLY-YCYTBL

// Formats screen,autoskip XMR
Function GD0FS-DSPLY-YDETBL()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the YDE CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && YDETBL.YDE-DLVR-SVC-TYP[GDWINDX2] != 99)

    GD0FWYDE.YDE-DLVR-SVC-TYP = YDETBL.YDE-DLVR-SVC-TYP[GDWINDX2];
    GD0FWYDE.YDE-DLVR-SVC-DESC = YDETBL.YDE-DLVR-SVC-DESC[GDWINDX2];
    GD0FWYDE.YDE-DLVR-SVC-SDESC = YDETBL.YDE-DLVR-SVC-SDESC[GDWINDX2];
    GD0FWYDE.XXX-STAT = YDETBL.XXX-STAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0FWYDE.GD0FWYDE-GROUP;

    set GD0FWYDE empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (YDETBL.YDE-DLVR-SVC-TYP[GDWINDX2] == 99)

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0FS-DSPLY-YDETBL

// Formats screen,autoskip XAU
Function GD0FS-DSPLY-YNSTBL()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the xzc CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && YNSTBL.YNS-RECORD-KEY[GDWINDX2] != "999999EOT")

    GD0FWYNS.YNS-RECORD-KEY = YNSTBL.YNS-RECORD-KEY[GDWINDX2];
    GD0FWYNS.XSE-SESN-CD = YNSTBL.XSE-SESN-CD[GDWINDX2];
    GD0FWYNS.GD0FW-YNS-SESN-YR = YNSTBL.YNS-SESN-YR[GDWINDX2];
    GD0FWYNS.YNS-BUS-FUNC-ID = YNSTBL.YNS-BUS-FUNC-ID[GDWINDX2];
    GD0FWYNS.YNS-SESN-YR-DESC = YNSTBL.YNS-SESN-YR-DESC[GDWINDX2];
    GD0FWYNS.YNS-SESN-YR-ABRV = YNSTBL.YNS-SESN-YR-ABRV[GDWINDX2];
    GD0FWYNS.GD0FW-YNS-SESN-BDT = YNSTBL.YNS-SESN-BDT[GDWINDX2];
    GD0FWYNS.GD0FW-YNS-SESN-XDT = YNSTBL.YNS-SESN-XDT[GDWINDX2];
    GD0FWYNS.XXX-STAT = YNSTBL.XXX-STAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0FWYNS.GD0FWYNS-GROUP;

    set GD0FWYNS empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (YNSTBL.YNS-RECORD-KEY[GDWINDX2] == "999999EOT")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;


end // end GD0FS-DSPLY-YNSTBL

// Formats screen,autoskip XAT
Function GD0FS-DSPLY-ZFCTBL()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the XAT CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && ZFCTBL.ZFC-CRCY-CD[GDWINDX2] != "999")

    GD0FWZFC.ZFC-CRCY-CD = ZFCTBL.ZFC-CRCY-CD[GDWINDX2];
    GD0FWZFC.ZFC-CRCY-DESC = ZFCTBL.ZFC-CRCY-DESC[GDWINDX2];
    GD0FWZFC.XXX-STAT = ZFCTBL.XXX-STAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0FWZFC.GD0FWZFC-GROUP;

    set GD0FWZFC empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (ZFCTBL.ZFC-CRCY-CD[GDWINDX2] == "999")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0FS-DSPLY-ZFCTBL

Record GD0FWXAS type basicRecord
  10 GD0FWXAS-GROUP GD0FWXAS-GROUP ; 
    20 * char(1) ; 
    20 XAS-AD-SRC-CD XAS-AD-SRC-CD ; 
    20 * char(3) ; 
    20 XAS-AD-SRC-DESC XAS-AD-SRC-DESC ; 
    20 * char(2) ; 
    20 XAS-AD-SRC-ABRV XAS-AD-SRC-ABRV ; 
    20 * char(4) ; 
    20 XXX-STAT XXX-STAT ; 
    20 * char(39) ; 
end // end GD0FWXAS

//*** RECORD=GD0FWXCJ ****
// ************** ORDER CREDIT STATUS CODE RECORD  ***********
// 
// This record is used to hold the values for the order status
// code table before they are to be displayed upon the screen.
// This is done to allow proper presentation of the table on
// screen and to allow many tables to use the same map.
// 
// ************************
Record GD0FWXCJ type basicRecord
  10 GD0FWXCJ-GROUP GD0FWXCJ-GROUP ; 
    20 * char(1) ; 
    20 XCJ-SCRTY-LVL-ID XCJ-SCRTY-LVL-ID ; 
    20 * char(3) ; 
    20 XCJ-SCRTY-LVL-DESC XCJ-SCRTY-LVL-DESC ; 
    20 * char(3) ; 
    20 XCJ-SCRTY-LVL-ABRV XCJ-SCRTY-LVL-ABRV ; 
    20 * char(4) ; 
    20 XXX-STAT XXX-STAT ; 
    20 * char(38) ; 
end // end GD0FWXCJ

Record GD0FWXCK type basicRecord
  10 GD0FWXCK-GROUP GD0FWXCK-GROUP ; 
    20 * char(1) ; 
    20 XCK-RFND-RSN-CD XCK-RFND-RSN-CD ; 
    20 * char(3) ; 
    20 XCK-RFND-RSN-DESC XCK-RFND-RSN-DESC ; 
    20 * char(2) ; 
    20 XCK-RFND-RSN-ABRV XCK-RFND-RSN-ABRV ; 
    20 * char(4) ; 
    20 XXX-STAT XXX-STAT ; 
    20 * char(39) ; 
end // end GD0FWXCK

Record GD0FWXCM type basicRecord
  10 GD0FWXCM-GROUP GD0FWXCM-GROUP ; 
    20 * char(1) ; 
    20 XCM-SHP-MTHD-CD XCM-SHP-MTHD-CD ; 
    20 * char(4) ; 
    20 XPPCD XPPCD ; 
    20 * char(3) ; 
    20 XCM-SHP-MTHD-DESC XCM-SHP-MTHD-DESC ; 
    20 * char(2) ; 
    20 XCM-SHP-MTHD-ABRV XCM-SHP-MTHD-ABRV ; 
    20 * char(3) ; 
    20 XXX-STAT XXX-STAT ; 
    20 * char(34) ; 
end // end GD0FWXCM

Record GD0FWXCQ type basicRecord
  10 GD0FWXCQ-GROUP GD0FWXCQ-GROUP ; 
    20 * char(1) ; 
    20 XCQ-CALL-INT-CD XCQ-CALL-INT-CD ; 
    20 * char(3) ; 
    20 XCQ-CALL-INT-DESC XCQ-CALL-INT-DESC ; 
    20 * char(2) ; 
    20 XCQ-CALL-INT-ABRV XCQ-CALL-INT-ABRV ; 
    20 * char(4) ; 
    20 XXX-STAT XXX-STAT ; 
    20 * char(39) ; 
end // end GD0FWXCQ

Record GD0FWXDP type basicRecord
  10 GD0FWXDP-GROUP GD0FWXDP-GROUP ; 
    20 * char(1) ; 
    20 XDP-DEP-STAT-CD XDP-DEP-STAT-CD ; 
    20 * char(3) ; 
    20 XDP-DEP-STAT-DESC XDP-DEP-STAT-DESC ; 
    20 * char(2) ; 
    20 XDP-DEP-STAT-ABRV XDP-DEP-STAT-ABRV ; 
    20 * char(4) ; 
    20 XXX-STAT XXX-STAT ; 
    20 * char(39) ; 
end // end GD0FWXDP

Record GD0FWXFD type basicRecord
  10 GD0FWXFD-GROUP GD0FWXFD-GROUP ; 
    20 * char(1) ; 
    20 XFD-FBK-CAT-CD XFD-FBK-CAT-CD ; 
    20 * char(3) ; 
    20 XFD-FBK-CAT-DESC XFD-FBK-CAT-DESC ; 
    20 * char(2) ; 
    20 XFD-FBK-CAT-ABRV XFD-FBK-CAT-ABRV ; 
    20 * char(4) ; 
    20 XXX-STAT XXX-STAT ; 
    20 * char(29) ; 
end // end GD0FWXFD

Record GD0FWXIC type basicRecord
  10 GD0FWXIC-GROUP GD0FWXIC-GROUP ; 
    20 * char(1) ; 
    20 XIC-IVC-CRCTRSN-CD XIC-IVC-CRCTRSN-CD ; 
    20 * char(2) ; 
    20 XIC-CRCT-RSN-DESC XIC-CRCT-RSN-DESC ; 
    20 * char(2) ; 
    20 XIC-CRCT-RSN-SDESC XIC-CRCT-RSN-SDESC ; 
    20 * char(3) ; 
    20 XXX-STAT XXX-STAT ; 
    20 * char(24) ; 
end // end GD0FWXIC

Record GD0FWXLA type basicRecord
  10 GD0FWXLA-GROUP1 GD0FWXLA-GROUP1 ; 
    20 * char(1) ; 
    20 XLBCD XLBCD ; 
    20 * char(3) ; 
    20 XXX-ADDR1 XXX-ADDR1 ; 
    20 * char(2) ; 
    20 XXXCITY XXXCITY ; 
    20 * char(7) ; 
  10 GD0FWXLA-GROUP2 GD0FWXLA-GROUP2 ; 
    20 * char(6) ; 
    20 XXX-ADDR2 XXX-ADDR2 ; 
    20 * char(3) ; 
    20 XSTCD XSTCD ; 
    20 * char(4) ; 
    20 XXXZIP XXXZIP ; 
    20 * char(2) ; 
    20 GLAENT GLAENT ; 
    20 * char(3) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(6) ; 
end // end GD0FWXLA

Record GD0FWXLL type basicRecord
  10 GD0FWXLL-GROUP GD0FWXLL-GROUP ; 
    20 * char(1) ; 
    20 XLLCD XLLCD ; 
    20 * char(3) ; 
    20 XLLDESC XLLDESC ; 
    20 * char(3) ; 
    20 XLLSDESC XLLSDESC ; 
    20 * char(3) ; 
    20 XLLABRV XLLABRV ; 
    20 * char(7) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(43) ; 
end // end GD0FWXLL

Record GD0FWXLN type basicRecord
  10 GD0FWXLN-GROUP GD0FWXLN-GROUP ; 
    20 * char(1) ; 
    20 XLNCD XLNCD ; 
    20 * char(3) ; 
    20 XLNDESC XLNDESC ; 
    20 * char(2) ; 
    20 XLNSDESC XLNSDESC ; 
    20 * char(3) ; 
    20 XLNABRV XLNABRV ; 
    20 * char(5) ; 
    20 GD0FW-XLNMINCS GD0FW-XLNMINCS ; 
    20 * char(4) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(26) ; 
end // end GD0FWXLN

Record GD0FWXLS type basicRecord
  10 GD0FWXLS-GROUP GD0FWXLS-GROUP ; 
    20 * char(1) ; 
    20 XWH-WHSE-CD XWH-WHSE-CD ; 
    20 * char(4) ; 
    20 XLS-SCAN-STAT-CD XLS-SCAN-STAT-CD ; 
    20 * char(3) ; 
    20 XLS-SCAN-STAT-ABRV XLS-SCAN-STAT-ABRV ; 
    20 * char(2) ; 
    20 XLS-SCAN-STAT-DESC XLS-SCAN-STAT-DESC ; 
    20 * char(4) ; 
    20 XXX-STAT XXX-STAT ; 
    20 * char(23) ; 
end // end GD0FWXLS

Record GD0FWXMH type basicRecord
  10 GD0FWXMH-GROUP GD0FWXMH-GROUP ; 
    20 XMH-MOVB-HLD-CD XMH-MOVB-HLD-CD ; 
    20 * char(3) ; 
    20 XMH-MOVB-HLD-ABRV XMH-MOVB-HLD-ABRV ; 
    20 * char(2) ; 
    20 XMH-MOVB-HLD-DESC XMH-MOVB-HLD-DESC ; 
    20 * char(2) ; 
    20 GD0FW-IN-SAS-ID GD0FW-IN-SAS-ID ; 
    20 * char(3) ; 
    20 XXX-STAT XXX-STAT ; 
    20 * char(19) ; 
end // end GD0FWXMH

Record GD0FWXTY type basicRecord
  10 GD0FWXTY-GROUP GD0FWXTY-GROUP ; 
    20 * char(1) ; 
    20 XTYCD XTYCD ; 
    20 * char(3) ; 
    20 XTYDESC XTYDESC ; 
    20 * char(2) ; 
    20 XTYSDESC XTYSDESC ; 
    20 * char(2) ; 
    20 XTYABRV XTYABRV ; 
    20 * char(5) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(34) ; 
end // end GD0FWXTY

Record GD0FWXUT type basicRecord
  10 GD0FWXUT-GROUP GD0FWXUT-GROUP ; 
    20 * char(1) ; 
    20 XUT-UNT-TYP-CD XUT-UNT-TYP-CD ; 
    20 * char(3) ; 
    20 XUT-UNT-TYP-ABRV XUT-UNT-TYP-ABRV ; 
    20 * char(2) ; 
    20 XUT-UNT-TYP-DESC XUT-UNT-TYP-DESC ; 
    20 * char(2) ; 
    20 XXX-STAT XXX-STAT ; 
    20 * char(1) ; 
end // end GD0FWXUT

//*** RECORD=GD0FWYBK ****
// work record for ybbtbl screen display
//    2-25-91   vcowan  orig definition
// ************************
Record GD0FWYBK type basicRecord
  10 GD0FWYBK-GROUP GD0FWYBK-GROUP ; 
    20 * char(1) ; 
    20 XBK-BK-SESN-CD XBK-BK-SESN-CD ; 
    20 * char(3) ; 
    20 XBK-BK-SESN-DESC XBK-BK-SESN-DESC ; 
    20 * char(3) ; 
    20 XBK-BK-SESN-ABRV XBK-BK-SESN-ABRV ; 
    20 * char(6) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(41) ; 
end // end GD0FWYBK

Record GD0FWYCA type basicRecord
  10 GD0FWYCA-GROUP GD0FWYCA-GROUP ; 
    20 * char(1) ; 
    20 YCA-CNSMR-ACT-CD YCA-CNSMR-ACT-CD ; 
    20 * char(3) ; 
    20 YCA-CNSMR-ACT-DESC YCA-CNSMR-ACT-DESC ; 
    20 * char(2) ; 
    20 YCA-CNSMR-ACT-ABRV YCA-CNSMR-ACT-ABRV ; 
    20 * char(3) ; 
    20 XXX-STAT XXX-STAT ; 
    20 * char(40) ; 
end // end GD0FWYCA

Record GD0FWYCB type basicRecord
  10 GD0FWYCB-GROUP GD0FWYCB-GROUP ; 
    20 * char(1) ; 
    20 YCB-CLM-STAT-CD YCB-CLM-STAT-CD ; 
    20 * char(3) ; 
    20 YCB-CLM-STAT-DESC YCB-CLM-STAT-DESC ; 
    20 * char(2) ; 
    20 YCB-CLM-STAT-ABRV YCB-CLM-STAT-ABRV ; 
    20 * char(2) ; 
    20 GD0FW-YCB-STAT-SEQ-NBR GD0FW-YCB-STAT-SEQ-NBR ; 
    20 * char(3) ; 
    20 XXX-STAT XXX-STAT ; 
    20 * char(30) ; 
end // end GD0FWYCB

Record GD0FWYCM type basicRecord
  10 GD0FWYCM-GROUP GD0FWYCM-GROUP ; 
    20 * char(1) ; 
    20 YCM-ORD-STAT-CD YCM-ORD-STAT-CD ; 
    20 * char(3) ; 
    20 YCM-ORD-STAT-DESC YCM-ORD-STAT-DESC ; 
    20 * char(2) ; 
    20 YCM-ORD-STAT-ABRV YCM-ORD-STAT-ABRV ; 
    20 * char(3) ; 
    20 YCM-HDR-STAT-CD YCM-HDR-STAT-CD ; 
    20 * char(3) ; 
    20 GD0FW-YCM-STAT-SEQ-NBR GD0FW-YCM-STAT-SEQ-NBR ; 
    20 * char(3) ; 
    20 YCM-OVRD-BY-OP-FL YCM-OVRD-BY-OP-FL ; 
    20 * char(5) ; 
    20 XXX-STAT XXX-STAT ; 
    20 * char(22) ; 
end // end GD0FWYCM

Record GD0FWYCW type basicRecord
  10 GD0FWYCW-GROUP GD0FWYCW-GROUP ; 
    20 * char(1) ; // ycw_wo_stat_cd
    20 YCW-WO-STAT-CD YCW-WO-STAT-CD ; 
    20 * char(3) ; 
    20 YCW-WO-STAT-ABRV YCW-WO-STAT-ABRV ; 
    20 * char(2) ; 
    20 YCW-WO-STAT-DESC YCW-WO-STAT-DESC ; 
    20 * char(3) ; 
    20 XXX-STAT XXX-STAT ; 
    20 * char(30) ; 
end // end GD0FWYCW

Record GD0FWYCY type basicRecord
  10 GD0FWYCY-GROUP GD0FWYCY-GROUP ; 
    20 YCY-CALL-TYP-CD YCY-CALL-TYP-CD ; 
    20 * char(3) ; 
    20 GD0FW-YCY-CALLTYP-SEQNBR GD0FW-YCY-CALLTYP-SEQNBR ; 
    20 * char(2) ; 
    20 YCY-CALL-TYP-DESC YCY-CALL-TYP-DESC ; 
    20 * char(3) ; 
    20 XXX-STAT XXX-STAT ; 
    20 * char(37) ; 
end // end GD0FWYCY

Record GD0FWYDE type basicRecord
  10 GD0FWYDE-GROUP GD0FWYDE-GROUP ; 
    20 * char(1) ; // XMR_MNTN_RQT_CD
    20 YDE-DLVR-SVC-TYP YDE-DLVR-SVC-TYP ; 
    20 * char(3) ; 
    20 YDE-DLVR-SVC-DESC YDE-DLVR-SVC-DESC ; 
    20 * char(2) ; 
    20 YDE-DLVR-SVC-SDESC YDE-DLVR-SVC-SDESC ; 
    20 * char(3) ; 
    20 XXX-STAT XXX-STAT ; 
    20 * char(24) ; 
end // end GD0FWYDE

Record GD0FWYNS type basicRecord
  10 GD0FWYNS-GROUP GD0FWYNS-GROUP ; 
    20 YNS-RECORD-KEY YNS-RECORD-KEY ; 
    20 * char(2) ; 
    20 XSE-SESN-CD XSE-SESN-CD ; 
    20 * char(2) ; 
    20 GD0FW-YNS-SESN-YR GD0FW-YNS-SESN-YR ; 
    20 * char(2) ; 
    20 YNS-BUS-FUNC-ID YNS-BUS-FUNC-ID ; 
    20 * char(3) ; 
    20 YNS-SESN-YR-DESC YNS-SESN-YR-DESC ; 
    20 * char(1) ; 
    20 YNS-SESN-YR-ABRV YNS-SESN-YR-ABRV ; 
    20 * char(2) ; 
    20 GD0FW-YNS-SESN-BDT GD0FW-YNS-SESN-BDT ; 
    20 * char(2) ; 
    20 GD0FW-YNS-SESN-XDT GD0FW-YNS-SESN-XDT ; 
    20 * char(2) ; 
    20 XXX-STAT XXX-STAT ; 
    20 * char(1) ; 
end // end GD0FWYNS

Record GD0FWZFC type basicRecord
  10 GD0FWZFC-GROUP GD0FWZFC-GROUP ; 
    20 ZFC-CRCY-CD ZFC-CRCY-CD ; 
    20 * char(3) ; 
    20 ZFC-CRCY-DESC ZFC-CRCY-DESC ; 
    20 * char(3) ; 
    20 XXX-STAT XXX-STAT ; 
    20 * char(38) ; 
end // end GD0FWZFC

// IN_SAS_ID
DataItem GD0FW-IN-SAS-ID num(9)  {
  currency = no, numericSeparator = no, sign = none, align = left, 
  fillCharacter = nullFill, inputRequired = no
}
end

// XLN_LNE_TYP_MIN_CS
DataItem GD0FW-XLNMINCS num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// ycb_stat-seq-nbr
DataItem GD0FW-YCB-STAT-SEQ-NBR num(8)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// ycm_stat_seq_nbr
DataItem GD0FW-YCM-STAT-SEQ-NBR num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// ycy_calltyp_seqnbr
DataItem GD0FW-YCY-CALLTYP-SEQNBR num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// season begin date
DataItem GD0FW-YNS-SESN-BDT num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// season begin date
DataItem GD0FW-YNS-SESN-XDT num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// season year
DataItem GD0FW-YNS-SESN-YR num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

DataItem GD0FWXAS-GROUP char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0FWXCJ-GROUP char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0FWXCK-GROUP char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0FWXCM-GROUP char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0FWXCQ-GROUP char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0FWXDP-GROUP char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0FWXFD-GROUP char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0FWXIC-GROUP char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0FWXLA-GROUP1 char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0FWXLA-GROUP2 char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0FWXLL-GROUP char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0FWXLN-GROUP char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0FWXLS-GROUP char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0FWXMH-GROUP char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0FWXTY-GROUP char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0FWXUT-GROUP char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0FWYBK-GROUP char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0FWYCA-GROUP char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0FWYCB-GROUP char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0FWYCM-GROUP char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0FWYCW-GROUP char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0FWYCY-GROUP char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0FWYDE-GROUP char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0FWYNS-GROUP char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0FWZFC-GROUP char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

