package gd0q;
import corpcom1.*;
import corpcom4.*;
import corpcom5.*;
import corpcom6.XMGDM;
import corpcom7.*;
import corpx1.*;
import corpx2.*;
import corpy2.*;
import corpz3.*;
import gd.common.*;
import ta.common.*;
//*** PROGRAM=GD0Q ****
// Nike On-line CSP Table Display Application
// 
//                        CSP TABLES
// 
// OVERVIEW:
// 
//     The purpose of the GD0Q CSP table  display application
// is to allow users of CSP tables access to these TABLES in
// a fast and efficient manner.
// 
//     This application is driven by the GD0G table display
// application which displays all the valid CSP tables which
// this system is to access. The user then makes a selection
// of which table is to be displayed by entering the code
// (ie. "XCT", {country table}) in the option field. The table
// GD0GWT1 is searched and if the code entered is a valid table
// control is then pass to the application responsible for
// displaying that CSP table. This application displays all the
// allocation CSP tables.
// 
// 
// DATE CREATED:  5/12/87
//       AUTHOR: John Wood (cloned from pgm GD0P)
// 
// 
// MAINTENANCE HISTORY:
// 
//    DATE      BY WHOM          OVERVIEW OF CHANGES MADE
//  -------   ----------     ---------------------------------
//  11-11-88  John Wood      added xssegtr logic
//  10-16-89  John Wood      added YOH display
//  10-16-89  John Wood      added YPU display
//  10-16-89  John Wood      added YPc display
//  10-16-89  John Wood      added YPf display
//  10-16-89  John Wood      added Ysi display
//  10-16-89  John Wood      added YTR display
//  06-14-91  vcowan         regen for 6-14 ydftbl struct chg
//  10-09-91  John Wood      REMOVED YFD DISPLAY
//  10-09-91  John Wood      CHANGED YCS DISPLAY
//  10-09-91  John Wood      CHANGED YCT DISPLAY
//  10-10-91  John Wood      CHANGED YCR DISPLAY
//  11-05-93  vern cowan     per nov 1993 tbl chg event..change
//                           xpotbl.xxxaddr3 to xxx-addr3
//  03-03-94  vern cowan     fix logic problem with yci display
// *********************
Program GD0Q type textUIProgram //VAGen Info - main text program
  {
  includeReferencedFunctions = yes, allowUnqualifiedItemReferences = yes, 
  throwNrfEofExceptions = yes, handleHardIOErrors = no, V60ExceptionCompatibility = yes, 
  I4GLItemsNullable = no, textLiteralDefaultIsString = no, localSQLScope = yes, 
  inputRecord = COMMAREA, segmented = yes
  }

  // Data Declarations
  COMMAREA COMMAREA ; // record
  GD0QWAC GD0QWAC; // record
  GD0QWAP GD0QWAP; // record
  GD0QWCE GD0QWCE; // record
  GD0QWCI GD0QWCI; // record
  GD0QWCP GD0QWCP; // record
  GD0QWCR GD0QWCR; // record
  GD0QWCS GD0QWCS; // record
  GD0QWCT GD0QWCT; // record
  GD0QWDF GD0QWDF; // record
  GD0QWDR GD0QWDR; // record
  GD0QWGL GD0QWGL; // record
  GD0QWIT GD0QWIT; // record
  GD0QWMD GD0QWMD; // record
  GD0QWOA GD0QWOA; // record
  GD0QWOH GD0QWOH; // record
  GD0QWPC GD0QWPC; // record
  GD0QWPF GD0QWPF; // record
  GD0QWPO GD0QWPO; // record
  GD0QWPU GD0QWPU; // record
  GD0QWSI GD0QWSI; // record
  GD0QWSS GD0QWSS; // record
  GD0QWTR GD0QWTR; // record
  GD3REC GD3REC; // record
  GDWREC GDWREC; // record

  // VAGen Info - items needed for migration
  VAGen_EZESYS char(8);
  VAGen_EZEREPLY num(1);
  VAGen_EZE_WAIT_TIME bin(9,2);
  VAGen_EZE_ITEMLEN int;

  // Use Declarations
  use XGLTBL; // table
  use XPOTBL; // table
  use YACTBL; // table
  use YAPTBL; // table
  use YCETBL; // table
  use YCITBL; // table
  use YCPTBL; // table
  use YCRTBL; // table
  use YCSTBL; // table
  use YCTTBL; // table
  use YDFTBL; // table
  use YDRTBL; // table
  use YITTBL; // table
  use YMDTBL; // table
  use YOATBL; // table
  use YOHTBL; // table
  use YPCTBL; // table
  use YPFTBL; // table
  use YPUTBL; // table
  use YSITBL; // table
  use YSSTBL; // table
  use YTRTBL; // table
  use XMGDM.XMGDM002 // form
   {
    pfKeyEquate = no
  };

  function main()
    // VAGen Info - initialization needed for migration
    VAGen_EZESYS = VGLib.getVAGSysType();
    GD0Q100: GD0Q100();

     /* *************************************************************/


    if (GDWICSP == "YCP")
      goto GD0Q110;
    end

    if (GDWICSP == "YAP")
      goto GD0Q130;
    end

    if (GDWICSP == "YMD")
      goto GD0Q150;
    end

    if (GDWICSP == "YCT")
      goto GD0Q170;
    end

    if (GDWICSP == "YDF")
      goto GD0Q190;
    end

    if (GDWICSP == "YSS")
      goto GD0Q210;
    end

    if (GDWICSP == "YDR")
      goto GD0Q230;
    end

    if (GDWICSP == "YCS")
      goto GD0Q250;
    end

    if (GDWICSP == "YCR")
      goto GD0Q270;
    end

    if (GDWICSP == "XGL") /* special fast-path access to display*/
      goto GD0Q290; /* the xgl table for john wood (not for anyone else)*/
    end

    if (GDWICSP == "YCE")
      goto GD0Q310;
    end


    if (GDWICSP == "YIT")
      goto GD0Q330;
    end


    if (GDWICSP == "YCI")
      goto GD0Q350;
    end


    if (GDWICSP == "YAC")
      goto GD0Q370;
    end


    if (GDWICSP == "XPO")
      goto GD0Q390;
    end


    if (GDWICSP == "YOA")
      goto GD0Q410;
    end


    if (GDWICSP == "YOH")
      goto GD0Q430;
    end


    if (GDWICSP == "YPU")
      goto GD0Q450;
    end


    if (GDWICSP == "YSI")
      goto GD0Q470;
    end


    if (GDWICSP == "YPF")
      goto GD0Q490;
    end


    if (GDWICSP == "YPC")
      goto GD0Q510;
    end


    if (GDWICSP == "YTR")
      goto GD0Q530;
    end



    goto GD0Q110; /* FAIL-SAFE CATCH*/

    GD0Q110: GD0Q110();
    goto GD0Q120;
     /* ***********************************************************/



    GD0Q120: GD0Q120();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0Q110.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0Q120;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0Q110; /* recoNverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0Q120; /* recoNverse map*/

      else

        goto GD0Q110; /* recoNverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0Q110; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0Q110;

    end



    GD0Q130: GD0Q130();
    goto GD0Q140;
     /* ***********************************************************/



    GD0Q140: GD0Q140();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0Q130.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0Q140;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0Q130; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0Q140; /* recoverse map*/

      else

        goto GD0Q130; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0Q130; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0Q130;

    end



    GD0Q150: GD0Q150();
    goto GD0Q160;
     /* ***********************************************************/



    GD0Q160: GD0Q160();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0p150.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0Q160;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0Q150; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0Q160; /* recoverse map*/

      else

        goto GD0Q150; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0Q150; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0Q150;

    end



    GD0Q170: GD0Q170();
    goto GD0Q180;
     /* ***********************************************************/



    GD0Q180: GD0Q180();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0Q170.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0Q180;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0Q170; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0Q180; /* recoverse map*/

      else

        goto GD0Q170; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0Q170; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0Q170;

    end



    GD0Q190: GD0Q190();
    goto GD0Q200;
     /* ***********************************************************/



    GD0Q200: GD0Q200();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0Q190.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0Q200;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0Q190; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0Q200; /* recoverse map*/

      else

        goto GD0Q190; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0Q190; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0Q190;

    end



    GD0Q210: GD0Q210();
    goto GD0Q220;
     /* ***********************************************************/



    GD0Q220: GD0Q220();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0Q210.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0Q220;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0Q210; /* reCONVERSe map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0Q220; /* reCONVERSe map*/

      else

        goto GD0Q210; /* reCONVERSe map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0Q210; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0Q210;

    end



    GD0Q230: GD0Q230();
    goto GD0Q240;
     /* ***********************************************************/



    GD0Q240: GD0Q240();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0Q230.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0Q240;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0Q230; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0Q240; /* recoverse map*/

      else

        goto GD0Q230; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0Q230; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0Q230;

    end



    GD0Q250: GD0Q250();
    goto GD0Q260;
     /* ***********************************************************/



    GD0Q260: GD0Q260();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0Q250.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0Q260;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0Q250; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0Q260; /* recoverse map*/

      else

        goto GD0Q250; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0Q250; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0Q250;

    end



    GD0Q270: GD0Q270();
    goto GD0Q280;
     /* ***********************************************************/



    GD0Q280: GD0Q280();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0Q270.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0Q280;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0Q270; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0Q280; /* recoverse map*/

      else

        goto GD0Q270; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0Q270; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0Q270;

    end



    GD0Q290: GD0Q290();
    goto GD0Q300;
     /* ***********************************************************/



    GD0Q300: GD0Q300();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0Q290.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0Q300;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0Q290; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0Q300; /* recoverse map*/

      else

        goto GD0Q290; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0Q290; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0Q290;

    end



    GD0Q310: GD0Q310();
    goto GD0Q320;
     /* ***********************************************************/



    GD0Q320: GD0Q320();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0Q310.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0Q320;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0Q310; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0Q320; /* recoverse map*/

      else

        goto GD0Q310; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0Q310; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0Q310;

    end



    GD0Q330: GD0Q330();
    goto GD0Q340;
     /* ***********************************************************/



    GD0Q340: GD0Q340();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0Q310.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0Q340;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0Q330; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0Q340; /* recoverse map*/

      else

        goto GD0Q330; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0Q330; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0Q330;

    end



    GD0Q350: GD0Q350();
    goto GD0Q360;
     /* ***********************************************************/



    GD0Q360: GD0Q360();
    /* GET GD0Q.GD0Q120*/

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0Q110.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0Q360;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0Q350; /* recoNverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0Q360; /* recoNverse map*/

      else

        goto GD0Q350; /* recoNverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0Q350; /* sets map clear, reloads date, and*/
                                     /* pending messages.*/

    else /* unsupported key.*/

      goto GD0Q350;

    end



    GD0Q370: GD0Q370();
    goto GD0Q380;
     /* ***********************************************************/



    GD0Q380: GD0Q380();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0Q370.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0Q380;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0Q370; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0Q380; /* recoverse map*/

      else

        goto GD0Q370; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0Q370; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0Q370;

    end



    GD0Q390: GD0Q390();
    goto GD0Q400;
     /* ***********************************************************/



    GD0Q400: GD0Q400();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0Q390.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0Q400;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0Q390; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0Q400; /* recoverse map*/

      else

        goto GD0Q390; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0Q390; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0Q390;

    end



    GD0Q410: GD0Q410();
    goto GD0Q420;
     /* ***********************************************************/



    GD0Q420: GD0Q420();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0Q410.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0Q420;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0Q410; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0Q420; /* recoverse map*/

      else

        goto GD0Q410; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0Q410; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0Q410;

    end



    GD0Q430: GD0Q430();
    goto GD0Q440;
     /* ***********************************************************/



    GD0Q440: GD0Q440();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0Q430.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0Q440;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0Q430; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0Q440; /* recoverse map*/

      else

        goto GD0Q430; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0Q430; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0Q430;

    end



    GD0Q450: GD0Q450();
    goto GD0Q460;
     /* ***********************************************************/



    GD0Q460: GD0Q460();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0Q450.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0Q460;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0Q450; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0Q460; /* recoverse map*/

      else

        goto GD0Q450; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0Q450; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0Q450;

    end



    GD0Q470: GD0Q470();
    goto GD0Q480;
     /* ***********************************************************/



    GD0Q480: GD0Q480();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0Q470.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0Q480;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0Q470; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0Q480; /* recoverse map*/

      else

        goto GD0Q470; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0Q470; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0Q470;

    end



    GD0Q490: GD0Q490();
    goto GD0Q500;
     /* ***********************************************************/



    GD0Q500: GD0Q500();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0Q490.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0Q500;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0Q490; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0Q500; /* recoverse map*/

      else

        goto GD0Q490; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0Q490; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0Q490;

    end



    GD0Q510: GD0Q510();
    goto GD0Q520;
     /* ***********************************************************/



    GD0Q520: GD0Q520();
     /* GET GD0Q.GD0Q520*/

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0Q510.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0Q520;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0Q510; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0Q520; /* recoverse map*/

      else

        goto GD0Q510; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0Q510; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0Q510;

    end



    GD0Q530: GD0Q530();
    goto GD0Q540;
     /* ***********************************************************/



    GD0Q540: GD0Q540();

     /* ************************************************************/

     /* ************************************************************/
     /* * The flags GDWRECON, GDWAIDS, and GDWACCES are set       **/
     /* * independently of each other.  each flag is reset in the **/
     /* * before stage of GD0Q530.                                **/
     /* ************************************************************/


    if (GDWREC.GDWRECON == "Y") /* reconverse map*/

      goto GD0Q540;

    end


    if (GDWREC.GDWAIDS == "7") /* scroll table up.*/

      if (GDWREC.GDWINDX2 <= 14
       || GDWREC.GDWSCAN <= 14)

        GDWREC.GDWINDX2 = 1;

      else

        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - GDWREC.GDWINDX1;
        GDWREC.GDWINDX2 = GDWREC.GDWINDX2 - 14;
        GDWREC.GDWSCAN = GDWREC.GDWINDX2;

      end

      if (GDWREC.GDWINDX2 < 1
       || GDWREC.GDWSCAN < 1)

        GDWREC.GDWINDX2 = 1;

      end

      GDWREC.GDWEOC = "N";

      goto GD0Q530; /* recoverse map*/

    end /* not PF7.*/


    if (GDWREC.GDWAIDS == "8") /* scroll table down.*/

      if (GDWREC.GDWEOC == "Y")

        goto GD0Q540; /* recoverse map*/

      else

        goto GD0Q530; /* recoverse map*/

      end

    end /* not PF8.*/


    if (GDWREC.GDWAIDS == "Z") /* cancel and converse blank map*/

      GD3REC.GD3PEND = " ";
      goto GD0Q530; /* sets map clear, reloads date, and pending messages.*/

    else /* unsupported key.*/

      goto GD0Q530;

    end



  end // end main
end // end GD0Q

// Check fast path and initialize
Function GD0Q100()


     /* ********************************************************/
     /* * This process intializes program work areas, checks  **/
     /* * user security, and edits the option and item field. **/
     /* *              Flow depending on table                **/
     /* ********************************************************/

     /* check security.*/

   /* ************************************************************/
  XSENTRY(); /* removed for testing  <<<<<<<<<<*/
   /* ************************************************************/

   /* ************************************************************/
  XSSEGTR(); /* 11/88 jw - set segmented trans id*/
   /* ************************************************************/

   /* MOVE 'CSP' TO COMMAREA.CASYSINT ; by security for testing*/
   /* MOVE 'JWOOD ' TO COMMAREA.CAUSERID; by security for testing*/

  set GDWREC empty;
  set GD3REC empty;

  GD3REC.GD349B = " "; /* initialize working storage.*/
  GDWREC.GDWFLAGS = " "; /* initialize application flags.*/

     /* Find commarea.cafromap on table, if not there, save*/
     /* original application name in working storage.*/

  GDWREC.GDWTID = COMMAREA.CAFROMAP;
  if (GDWREC.GDWTID in XGLTBL.XGLTAPP)
    XSGDG12();
  else
    XSGDG14();
  end

  if (GDWREC.GDWEDIT == "F")

       /* not found on table, means it must be users application.*/
       /* save users application for PF2 direct return.*/

    if (GDWREC.GDWTID == "GD0Q" /* *** SPL*/
     && COMMAREA.CAITEM == "XGL") /* *** FOR JWOOD*/
      GDWREC.GDWEDIT = "P"; /* *** XGL DISPLAY*/
    else
      GDWREC.GDWFMAPP = COMMAREA.CAFROMAP;
    end
  end

  if (COMMAREA.CAITEM != GD3REC.GD320B) /* does item field have data.*/

            /* The first three bytes of the item field are the csp*/
       /* option. ,*/

    GDWREC.GDWITEM = COMMAREA.CAITEM; /* take it apart,*/

       /* Retreive the first column of the csp table based on the*/
       /* item option.  If the specified item is not a csp table*/
       /* then it must be an error. In this case display the csp*/
       /* tables as we normally would but with an error message*/
       /* for a invalid csp table option.*/

    /* ---------------------------------------------------------*/
    if (GDWREC.GDWITEM == "XGL") /* check special fast-path*/
      exit stack; /* entry to xgl table for*/
    else /* jwood (not for anyone else)*/
      /* ---------------------------------------------------------*/
                /* SEARCH FOR SPECIFIED OPTION ON CSP TABLE.*/

      XSGDG10(); /* search for specified option on csp.*/

      if (GDWREC.GDWEDIT == "P") /* tran code found on csp*/

        if (XGLTBL.XGLTAPP[sysVar.arrayIndex] != "GD0Q")

          COMMAREA.CATOAP = "GD0G"; /* invalid*/
          COMMAREA.CAITEM = GDWREC.GDWITEM; /* transfer*/
                                                    /* to gd0g display*/
          XSEXIT();

        else

          exit stack;

        end

      else /* not on table, must be outside CSP table appl.*/

        COMMAREA.CATOAP = "GD0G"; /* invalid CSP table*/
        COMMAREA.CAITEM = GDWREC.GDWITEM; /* transfer to GD0G table*/
                                                  /* display*/
        XSEXIT();

      end /* if found on CSP table.*/
    end /* special trap for xgl*/

  end /* item field blank.  default to main menu.*/

  exit stack;




   /* *************************************************************/
end // end GD0Q100

// clear screen, format display
Function GD0Q110()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0Q110 or GD0Q120               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0QWCP empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0Q110";


  XSGDG22();

  XMGDM002.XMGDMHED = "  YCP CO-OP ANALYST TABLE";

  GD3REC.GD3PEND1 = " CODE   NAME              ";
  GD3REC.GD3PEND2 = "     STATUS               ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = " ====   ==================";
  GD3REC.GD3PEND2 = "==   ======               ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0QS50(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0Q110

// display YCP table values
Function GD0Q120()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0Q120

// clear screen, format display
Function GD0Q130()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0Q130 or GD0Q140               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0QWAP empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0Q130";


  XSGDG22();

  XMGDM002.XMGDMHED = "  YAP CLAIM/COOP ADVERTISING PRODUCT LINE";

  GD3REC.GD3PEND1 = " CODE   DESCRIPTION       ";
  GD3REC.GD3PEND2 = "     ABBREVIATION   STATUS";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = " ====   ==================";
  GD3REC.GD3PEND2 = "==   ============   ======";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0QS51(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0Q130

// display YAP table values
Function GD0Q140()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0Q140

// clear screen, format display
Function GD0Q150()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0Q150 or GD0Q160               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0QWMD empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0Q150";


  XSGDG22();

  XMGDM002.XMGDMHED = "  YMD AD MEDIA CODE TABLE";

  GD3REC.GD3PEND1 = " CODE   DESCRIPTION       ";
  GD3REC.GD3PEND2 = "     ABBREVIATION   STATUS";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = " ====   ==================";
  GD3REC.GD3PEND2 = "==   ============   ======";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0QS52(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0Q150

// display YmD table values
Function GD0Q160()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0Q160

// clear screen, format display
Function GD0Q170()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0Q170 or GD0Q180               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0QWCT empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0Q170";


  XSGDG22();

  XMGDM002.XMGDMHED = "  YCT CLAIM TYPE CODE TABLE";

  GD3REC.GD3PEND1 = "CODE  DESCRIPTION         ";
  GD3REC.GD3PEND2 = "  ABBREV  OSD FL  STATUS  ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====  ====================";
  GD3REC.GD3PEND2 = "  ======  ======  ======  ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0QS53(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0Q170

// display YCT table values
Function GD0Q180()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0Q180

// clear screen, format display
Function GD0Q190()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0Q190 or GD0Q200               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0QWDF empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0Q190";


  XSGDG22();

  XMGDM002.XMGDMHED = "  YDF NATURE OF DEFECT CODE TABLE";

  GD3REC.GD3PEND1 = " CODE  GPC   DESCRIPTION  ";
  GD3REC.GD3PEND2 = "                          ";
  GD3REC.GD3PEND3 = "    STATUS                ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = " ====  ===   =============";
  GD3REC.GD3PEND2 = "==========================";
  GD3REC.GD3PEND3 = "=   ======                ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0QS54(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0Q190

// display YDF table values
Function GD0Q200()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0Q200

// clear screen, format display
Function GD0Q210()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0Q210 or GD0Q220               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0QWSS empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0Q210";


  XSGDG22();

  XMGDM002.XMGDMHED = "  TRANSP SHIPMENT STATUS TABLE";

  GD3REC.GD3PEND1 = "CODE  DESCRIPTION         ";
  GD3REC.GD3PEND2 = "             ABBREV   ALLO";
  GD3REC.GD3PEND3 = "W     ALLOW   STATUS      ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====  ====================";
  GD3REC.GD3PEND2 = "==========   ======   UPDA";
  GD3REC.GD3PEND3 = "TE?  DELETE?  ======      ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0QS55(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0Q210

// display YSS table values
Function GD0Q220()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0Q220

// clear screen, format display
Function GD0Q230()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0Q230 or GD0Q240               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0QWDR empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0Q230";


  XSGDG22();

  XMGDM002.XMGDMHED = "  YDR RETURN CREDIT DENIAL REASON TABLE";

  GD3REC.GD3PEND1 = " CODE   TYP   DESCRIPTION ";
  GD3REC.GD3PEND2 = "                          ";
  GD3REC.GD3PEND3 = "              STATUS      ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = " ====   ===   ============";
  GD3REC.GD3PEND2 = "==========================";
  GD3REC.GD3PEND3 = "============  ======      ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0QS56(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0Q230

// display YDR table values
Function GD0Q240()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0Q240

// clear screen, format display
Function GD0Q250()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0q250 or GD0q260               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0QWCS empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0Q230";


  XSGDG22();

  XMGDM002.XMGDMHED = "  YCS CLAIM STATUS CODE TABLE";

  GD3REC.GD3PEND1 = "CODE  DESCRIPTION         ";
  GD3REC.GD3PEND2 = "            SHORT DESCR.  ";
  GD3REC.GD3PEND3 = " ABBREV  ACTCD  STATUS    ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====  ====================";
  GD3REC.GD3PEND2 = "==========  ============= ";
  GD3REC.GD3PEND3 = " ======  =====  ======    ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0QS57(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0Q250

// display YCS table values
Function GD0Q260()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0Q260

// clear screen, format display
Function GD0Q270()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0Q270 or GD0Q280               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD3REC empty; /* clear out display w-s.*/
  set GD0QWCR empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0Q270";


  XSGDG22();

  XMGDM002.XMGDMHED = "  YCR CLAIM REASON CODE TABLE";

  GD3REC.GD3PEND1 = " CODE DESCRIPTION         ";
  GD3REC.GD3PEND2 = "            ALW  ALW   ALW";
  GD3REC.GD3PEND3 = "   ALW     NPAY    STATUS ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = " ==== ====================";
  GD3REC.GD3PEND2 = "==========  GL   PROD  TRF";
  GD3REC.GD3PEND3 = "C  ARNGT  FRGT FL  ====== ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0QS48(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0Q270

// display YCR table values
Function GD0Q280()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0Q280

// clear screen,format dislay
Function GD0Q290()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0Q290 or GD0Q300               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD3REC empty; /* clear out display w-s.*/
  set GD0QWGL empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0Q230";


  XSGDG22();

  XMGDM002.XMGDMHED = "  XGL GL TABLE-CODE TABLE";

  GD3REC.GD3PEND1 = " CODE   TABLE NAME        ";
  GD3REC.GD3PEND2 = "                  APPL    ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = " ===    ==================";
  GD3REC.GD3PEND2 = "============      ====    ";
  GD3REC.GD3PEND3 = "                          ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0QS59(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0Q290

// display XGL table values
Function GD0Q300()
  converse XMGDM002 ;



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0Q300

// clear screen, format display
Function GD0Q310()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0Q310 or GD0Q320               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD3REC empty; /* clear out display w-s.*/
  set GD0QWCE empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0Q310";


  XSGDG22();

  XMGDM002.XMGDMHED = "  YCE CLAIM EXCEPTION CODE TABLE";

  GD3REC.GD3PEND1 = " CODE   DESCRIPTION       ";
  GD3REC.GD3PEND2 = "                          ";
  GD3REC.GD3PEND3 = "        ALW-OVRRDE FLG   S";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = " ====   ==================";
  GD3REC.GD3PEND2 = "==========================";
  GD3REC.GD3PEND3 = "======  ==============   =";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0QS58(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0Q310

// display YCE table values
Function GD0Q320()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0Q320

// clear screen, format display
Function GD0Q330()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0Q330 or GD0Q340               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD3REC empty; /* clear out display w-s.*/
  set GD0QWIT empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0Q330";


  XSGDG22();

  XMGDM002.XMGDMHED = "  YIT INVOICE TYPE TABLE";

  GD3REC.GD3PEND1 = "CODE  DESCRIPTION         ";
  GD3REC.GD3PEND2 = "            ABBREV  INVOCE";
  GD3REC.GD3PEND3 = " IV-REC  MULTI  STATUS    ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====  ====================";
  GD3REC.GD3PEND2 = "==========  ======  ON IBM";
  GD3REC.GD3PEND3 = "  DFCT   RECS   ======    ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0QS60(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0Q330

// display YIT table values
Function GD0Q340()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0Q340

// clear screen, format display
Function GD0Q350()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0Q350 or GD0Q360               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD3REC empty; /* clear out display w-s.*/
  set GD0QWCI empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0Q350";


  XSGDG22();

  XMGDM002.XMGDMHED = "  YCI CLAIMS INSPECTION STATUS CODE TABLE";

  GD3REC.GD3PEND1 = "CODE  DESCRIPTION         ";
  GD3REC.GD3PEND2 = "            SHORT DESCR   ";
  GD3REC.GD3PEND3 = " MEMO  RESTK  STATUS      ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====  ====================";
  GD3REC.GD3PEND2 = "==========  ============  ";
  GD3REC.GD3PEND3 = " PROC? PROC?  ======      ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0QS61(); /* format screen and fields to askip*/
                                   /* attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0Q350

// display YCP table values
Function GD0Q360()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0Q360

// clear screen, format display
Function GD0Q370()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0Q370 or GD0Q380               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0QWAC empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0Q370";


  XSGDG22();

  XMGDM002.XMGDMHED = "  YAC PRODUCTION AUDIT COMMENT TABLE";

  GD3REC.GD3PEND1 = "CODE  DESCRIPTION         ";
  GD3REC.GD3PEND2 = "              SHORT DESCR.";
  GD3REC.GD3PEND3 = "    ABBREV     STATUS     ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====  ====================";
  GD3REC.GD3PEND2 = "==========    ============";
  GD3REC.GD3PEND3 = "    ======     ======     ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0QS62(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0Q370

// display YAC table values
Function GD0Q380()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0Q380

// clear screen, format display
Function GD0Q390()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0Q370 or GD0Q400               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0QWAC empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0Q390";


  XSGDG22();

  XMGDM002.XMGDMHED = "  XPO PRODUCTION BUYER ADDRESS TABLE";

  GD3REC.GD3PEND1 = "GPC  ADDRESS 3 (25 CHAR.) ";
  GD3REC.GD3PEND2 = "      CITY                ";
  GD3REC.GD3PEND3 = "       BUYER PHONE NO.   S";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "===  =====================";
  GD3REC.GD3PEND2 = "====  ====================";
  GD3REC.GD3PEND3 = "=====  ===============   =";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0QS63(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0Q390

// display XPO table values
Function GD0Q400()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0Q400

// clear screen, format display
Function GD0Q410()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0Q410 or GD0Q420               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0QWOA empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0Q410";


  XSGDG22();

  XMGDM002.XMGDMHED = "  YOA PRODUCTION ORDER AUDIT TYPE TABLE";

  GD3REC.GD3PEND1 = "YOA   GPC   DESCRIPTION   ";
  GD3REC.GD3PEND2 = "                  MEMO O-A";
  GD3REC.GD3PEND3 = "DJ RPT   ONLN  LOCR   STAT";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "CODE  CODE  ==============";
  GD3REC.GD3PEND2 = "================  FLAG FLA";
  GD3REC.GD3PEND3 = "G  FLAG  FLAG  FLAG   ====";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0QS64(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0Q410

// display YOA table values
Function GD0Q420()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0Q420

// clear screen, format display
Function GD0Q430()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0Q430 or GD0Q440               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0QWOH empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0Q430";


  XSGDG22();

  XMGDM002.XMGDMHED = "  YOH PRODUCTION ORDER HOLD TABLE";

  GD3REC.GD3PEND1 = "CODE  DESCRIPTION         ";
  GD3REC.GD3PEND2 = "              SHORT DESCR.";
  GD3REC.GD3PEND3 = "    ABBREV     STATUS     ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====  ====================";
  GD3REC.GD3PEND2 = "==========    ============";
  GD3REC.GD3PEND3 = "    ======     ======     ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0QS65(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0Q430

// display YOH table values
Function GD0Q440()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0Q440

// clear screen, format display
Function GD0Q450()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0Q450 or GD0Q460               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0QWPU empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0Q450";


  XSGDG22();

  XMGDM002.XMGDMHED = "  YPU PRODUCTION ORDER STATUS TABLE";

  GD3REC.GD3PEND1 = "CODE  DESCRIPTION         ";
  GD3REC.GD3PEND2 = "              SHORT DESCR.";
  GD3REC.GD3PEND3 = "    ABBREV     STATUS     ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====  ====================";
  GD3REC.GD3PEND2 = "==========    ============";
  GD3REC.GD3PEND3 = "    ======     ======     ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0QS66(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0Q450

// display YPU table values
Function GD0Q460()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0Q460

// clear screen, format display
Function GD0Q470()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0Q470 or GD0Q480               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0QWSI empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0Q470";


  XSGDG22();

  XMGDM002.XMGDMHED = "  YSI PRODUCTION ORDER SPL INSTR TBL";

  GD3REC.GD3PEND1 = "CODE  DESCRIPTION         ";
  GD3REC.GD3PEND2 = "              SHORT DESCR.";
  GD3REC.GD3PEND3 = "    ABBREV     STATUS     ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====  ====================";
  GD3REC.GD3PEND2 = "==========    ============";
  GD3REC.GD3PEND3 = "    ======     ======     ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0QS67(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0Q470

// display YSI table values
Function GD0Q480()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0Q480

// clear screen, format display
Function GD0Q490()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0Q490 or GD0Q500               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0QWPF empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0Q490";


  XSGDG22();

  XMGDM002.XMGDMHED = "  YPF PRODUCTION PO FORMS TABLE";

  GD3REC.GD3PEND1 = "CODE  DESCRIPTION         ";
  GD3REC.GD3PEND2 = "              SHORT DESCR.";
  GD3REC.GD3PEND3 = "    ABBREV     STATUS     ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====  ====================";
  GD3REC.GD3PEND2 = "==========    ============";
  GD3REC.GD3PEND3 = "    ======     ======     ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0QS68(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0Q490

// display YPF table values
Function GD0Q500()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0Q500

// clear screen, format display
Function GD0Q510()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0Q510 or GD0Q520               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0QWPC empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0Q510";


  XSGDG22();

  XMGDM002.XMGDMHED = "  YPC PO CUSTOMER XREF TYPE TABLE";

  GD3REC.GD3PEND1 = "CODE  DESCRIPTION         ";
  GD3REC.GD3PEND2 = "              SHORT DESCR.";
  GD3REC.GD3PEND3 = "    ABBREV     STATUS     ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====  ====================";
  GD3REC.GD3PEND2 = "==========    ============";
  GD3REC.GD3PEND3 = "    ======     ======     ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0QS70(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0Q510

// display YPC table values
Function GD0Q520()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0Q520

// clear screen, format display
Function GD0Q530()


     /* *********************************************************/
     /* *          This process does the following:            **/
     /* *    Set all heading values needed for a new screen    **/
     /* *    format the new screen with the required table     **/
     /* *    values the protects those fields from the user.   **/
     /* *    DISPLAY ANY PENDING MESSAGE.                      **/
     /* *             Flow to GD0Q530 or GD0Q540               **/
     /* *********************************************************/


  set XMGDM002 initial; /* resets all field attributes.*/
  set GD0QWTR empty; /* clear out display w-s.*/

  XMGDM002.XMGDMDT = VGVar.currentShortGregorianDate;
  XMGDM002.XMGDMMAP = "XMGDM002";
  XMGDM002.XMGDMPRO = "GD0Q530";


  XSGDG22();

  XMGDM002.XMGDMHED = "  YTR PROD TRADE RESTRICTION RSN TBLE";

  GD3REC.GD3PEND1 = "CODE  DESCRIPTION         ";
  GD3REC.GD3PEND2 = "              SHORT DESCR.";
  GD3REC.GD3PEND3 = "    ABBREV     STATUS     ";
  XMGDM002.XMGDMTL1 = GD3REC.GD3PEND;

  GD3REC.GD3PEND1 = "====  ====================";
  GD3REC.GD3PEND2 = "==========    ============";
  GD3REC.GD3PEND3 = "    ======     ======     ";
  XMGDM002.XMGDMTL2 = GD3REC.GD3PEND;

  GD3REC.GD3PEND = " ";

  GD0QS71(); /* format screen and fields to askip attribute.*/

  set XMGDM002.XMGDM2AP cursor; /* put cursor on Tran ID field.*/



   /* ************************************************************/
end // end GD0Q530

// display YTR table values
Function GD0Q540()



     /* *********************************************************/
     /* *           This process does the following:           **/
     /* *  clears the logic flow flags, displays the           **/
     /* *  screen, the determines where to go next depending   **/
     /* *  on what the user has entered. ie scrolling, or      **/
     /* *  transfering.                                        **/
     /* *                                                      **/
     /* *********************************************************/


  GDWREC.GDWAIDS = " "; /* reset pf key flag.*/
  GDWREC.GDWRECON = " "; /* reset reconverse flag.*/
  GDWREC.GDWACCES = " "; /* reset access flag.*/

  converseLib.clearScreen();
  
  set XMGDM002.XMGDMITM cursor;



   /* ************************************************************/
  converse XMGDM002 ;
   /* ************************************************************/



  if (converseVar.eventKey is enter)
    GDWREC.GDWAIDS = "0"; /* set key flag for flow stage.*/

    if (XMGDM002.XMGDM2AP is modified
     && XMGDM002.XMGDM2AP != GD3REC.GD304B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;
      COMMAREA.CATOAP = XMGDM002.XMGDM2AP;

      XSEXIT(); /* link to specified application.*/

      XSGD040(); /* If the link fails, A message is*/
                                   /* formatted,*/
      XSGDG22();
                                   /* and moved into GD0g.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* fast path field not modified.*/

    if (XMGDM002.XMGDMITM is modified /* item entered*/
     && XMGDM002.XMGDMITM != GD3REC.GD320B) /* and not spaces*/

      COMMAREA.CAITEM = XMGDM002.XMGDMITM;

      XSGDG90(); /* determine desired application, and link.*/
      XSGDG22(); /* if link fails, a message is formated and*/
                          /* moved into GD0I.EZEMSG.*/

      GDWREC.GDWRECON = "Y"; /* reconverse, message*/
      exit stack;

    end /* item field not modified.*/

  end /* not ENTER*/


  if (converseVar.eventKey is pf7) /* scroll up csp display table.*/
    GDWREC.GDWAIDS = "7";
    exit stack;

  end


  if (converseVar.eventKey is pf8) /* scroll down csp display table.*/
    GDWREC.GDWAIDS = "8";
    if (GDWREC.GDWEOC == "Y")
      GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
      GD3REC.GD3PEND2 = "EACHED.                   ";
      /* MOVE 'Y' TO GDWSWORK.GDWRECON;  set reconverse flag.*/
      XSGDG22();
    end

    exit stack;

  end

  if (converseVar.eventKey is pf4)
    COMMAREA.CAITEM = " ";
    XSPF4(); /* return to main goal menu.*/

    XMGDM002.VAGen_EZEMSG = COMMAREA.CAMSG;
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    GDWREC.GDWAIDS = "0";
    exit stack;

  end

  if (converseVar.eventKey is pf3) /* return to GD0G CSP table display appl.*/
    GDWREC.GDWAIDS = "3";
    COMMAREA.CAITEM = XMGDM002.XMGDMITM;
    COMMAREA.CATOAP = "GD0G";

    XSEXIT(); /* link to specified application.*/

    XSGDG22(); /* moved into GD0G.EZEMSG.*/

    GDWREC.GDWRECON = "Y";
                                   /* set reconverse flag.*/
    exit stack;

  end

  if (converseVar.eventKey is pa2) /* converse map from GD0I110 execute.*/
    GDWREC.GDWAIDS = "Z";
    exit stack;

  else /* Invalid pf key was pressed, send nastygram to user.*/

    GD3REC.GD3PEND1 = "AN UNSUPPORTED PF KEY WAS ";
    GD3REC.GD3PEND2 = "PRESSED - RETRY.          ";
    GDWREC.GDWRECON = "Y"; /* set reconverse flag.*/
    XSGDG22();

    exit stack;

  end



   /* ************************************************************/
end // end GD0Q540

// Formats screen,autoskip YCR
Function GD0QS48()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the YCE CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && YCRTBL.YCRCD[GDWINDX2] != "999")

    GD0QWCR.YCRCD = YCRTBL.YCRCD[GDWINDX2];
    GD0QWCR.YCRDESC = YCRTBL.YCRDESC[GDWINDX2];
    GD0QWCR.YCRALWGL = YCRTBL.YCRALWGL[GDWINDX2];
    GD0QWCR.YCRALWPR = YCRTBL.YCRALWPR[GDWINDX2];
    GD0QWCR.YCRALWTF = YCRTBL.YCRALWTF[GDWINDX2];
    GD0QWCR.YCRSPARN = YCRTBL.YCRSPARN[GDWINDX2];
    GD0QWCR.YCR-NPAY-FRGT-FL = YCRTBL.YCR-NPAY-FRGT-FL[GDWINDX2];
    GD0QWCR.XXXSTAT = YCRTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0QWCR.GD0QWCRR;

    set GD0QWCR empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (YCRTBL.YCRCD[GDWINDX2] == "999")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0QS48

// Formats screen,autoskip YCP
Function GD0QS50()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the YCP CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && YCPTBL.YCPCD[GDWINDX2] != 9999)

    GD0QWCP.GD0QWCPC = YCPTBL.YCPCD[GDWINDX2];
    GD0QWCP.YCPNM = YCPTBL.YCPNM[GDWINDX2];
    GD0QWCP.XXXSTAT = YCPTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0QWCP.GD0QWCPR;

    set GD0QWCP empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (YCPTBL.YCPCD[GDWINDX2] == 9999)

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0QS50

// Formats screen,autoskip YAP
Function GD0QS51()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the YAP CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && YAPTBL.YAPCD[GDWINDX2] != "99")

    GD0QWAP.GD0QWAPC = YAPTBL.YAPCD[GDWINDX2];
    GD0QWAP.YAPDESC = YAPTBL.YAPDESC[GDWINDX2];
    GD0QWAP.YAPABRV = YAPTBL.YAPABRV[GDWINDX2];
    GD0QWAP.XXXSTAT = YAPTBL.XXXSTAT[GDWINDX2];



    XMGDM002.XMGDMLIN[GDWINDX1] = GD0QWAP.GD0QWAPR;
    set GD0QWAP empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (YAPTBL.YAPCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0QS51

// Formats screen,autoskip YMD
Function GD0QS52()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the YMD CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && YMDTBL.YMDCD[GDWINDX2] != "99")

    GD0QWMD.YMDCD = YMDTBL.YMDCD[GDWINDX2];
    GD0QWMD.YMDDESC = YMDTBL.YMDDESC[GDWINDX2];
    GD0QWMD.YMDABRV = YMDTBL.YMDABRV[GDWINDX2];
    GD0QWMD.XXXSTAT = YMDTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0QWMD.GD0QWMDR;

    set GD0QWMD empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (YMDTBL.YMDCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0QS52

// Formats screen,autoskip YCT
Function GD0QS53()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the YCT CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && YCTTBL.YCTCD[GDWINDX2] != "999")

    GD0QWCT.YCTCD = YCTTBL.YCTCD[GDWINDX2];
    GD0QWCT.YCTABRV = YCTTBL.YCTABRV[GDWINDX2];
    GD0QWCT.YCTDESC = YCTTBL.YCTDESC[GDWINDX2];
    GD0QWCT.YCT-OSD-FL = YCTTBL.YCT-OSD-FL[GDWINDX2];
    GD0QWCT.XXXSTAT = YCTTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0QWCT.GD0QWCTR;

    set GD0QWCT empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (YCTTBL.YCTCD[GDWINDX2] == "999")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0QS53

// Formats screen,autoskip YDF
Function GD0QS54()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the YDF CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && YDFTBL.YDFKEY[GDWINDX2] != "99999")

    GD0QWDF.YDFCD = YDFTBL.YDFKEY[GDWINDX2];
    GD0QWDF.XGPCD = YDFTBL.XGPCD[GDWINDX2];
    GD0QWDF.YDFDESC = YDFTBL.YDFDESC[GDWINDX2];
    GD0QWDF.XXXSTAT = YDFTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0QWDF.GD0QWDFR;

    set GD0QWDF empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (YDFTBL.YDFKEY[GDWINDX2] == "99999")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0QS54

// Formats screen,autoskip YSS
Function GD0QS55()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the YSS CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && YSSTBL.YSSCD[GDWINDX2] != "99")

    GD0QWSS.YSSCD = YSSTBL.YSSCD[GDWINDX2];
    GD0QWSS.YSSDESC = YSSTBL.YSSDESC[GDWINDX2];
    GD0QWSS.YSSABRV = YSSTBL.YSSABRV[GDWINDX2];
    GD0QWSS.YSSUPDFL = YSSTBL.YSSUPDFL[GDWINDX2];
    GD0QWSS.YSSDELFL = YSSTBL.YSSDELFL[GDWINDX2];
    GD0QWSS.XXXSTAT = YSSTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0QWSS.GD0QWSSR;

    set GD0QWSS empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (YSSTBL.YSSCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0QS55

// Formats screen,autoskip YDR
Function GD0QS56()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the YDR CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && YDRTBL.YDRCD[GDWINDX2] != "99")

    GD0QWDR.YDRCD = YDRTBL.YDRCD[GDWINDX2];
    GD0QWDR.YDRCLTPI = YDRTBL.YDRCLTPI[GDWINDX2];
    GD0QWDR.YDRDESC = YDRTBL.YDRDESC[GDWINDX2];
    GD0QWDR.XXXSTAT = YDRTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0QWDR.GD0QWDRR;

    set GD0QWDR empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (YDRTBL.YDRCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0QS56

// Formats screen,autoskip YCS
Function GD0QS57()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the YCS CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && YCSTBL.YCSCD[GDWINDX2] != "999")

    GD0QWCS.YCSCD = YCSTBL.YCSCD[GDWINDX2];
    GD0QWCS.YCSABRV = YCSTBL.YCSABRV[GDWINDX2];
    GD0QWCS.YCSDESC = YCSTBL.YCSDESC[GDWINDX2];
    GD0QWCS.YCSSDESC = YCSTBL.YCSSDESC[GDWINDX2];
    GD0QWCS.YCSACTCD = YCSTBL.YCSACTCD[GDWINDX2];
    GD0QWCS.XXXSTAT = YCSTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0QWCS.GD0QWCSR;

    set GD0QWCS empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (YCSTBL.YCSCD[GDWINDX2] == "999")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0QS57

// Formats screen,autoskip YCe
Function GD0QS58()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the YCE CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && YCETBL.YCECD[GDWINDX2] != "999")

    GD0QWCE.YCECD = YCETBL.YCECD[GDWINDX2];
    GD0QWCE.YCEDESC = YCETBL.YCEDESC[GDWINDX2];
    GD0QWCE.YCEAOVRF = YCETBL.YCEAOVRF[GDWINDX2];
    GD0QWCE.XXXSTAT = YCETBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0QWCE.GD0QWCER;

    set GD0QWCE empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (YCETBL.YCECD[GDWINDX2] == "999")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0QS58

Function GD0QS59()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the xgl CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XGLTBL.XGLTCOD[GDWINDX2] != "999")

    GD0QWGL.XGLTCOD = XGLTBL.XGLTCOD[GDWINDX2];
    GD0QWGL.XGLTDSP = XGLTBL.XGLTDSP[GDWINDX2];
    GD0QWGL.XGLTAPP = XGLTBL.XGLTAPP[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0QWGL.GD0QWGLR;

    set GD0QWGL empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XGLTBL.XGLTCOD[GDWINDX2] == "999")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0QS59

// format screen autoskip YIT
Function GD0QS60()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the YIT CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && YITTBL.YITCD[GDWINDX2] != "99")

    GD0QWIT.YITCD = YITTBL.YITCD[GDWINDX2];
    GD0QWIT.YITDESC = YITTBL.YITDESC[GDWINDX2];
    GD0QWIT.YITABRV = YITTBL.YITABRV[GDWINDX2];
    GD0QWIT.YITIOIBM = YITTBL.YITIOIBM[GDWINDX2];
    GD0QWIT.YITRECDF = YITTBL.YITRECDF[GDWINDX2];
    GD0QWIT.YITMULTF = YITTBL.YITMULTF[GDWINDX2];
    GD0QWIT.XXXSTAT = YITTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0QWIT.GD0QWITR;

    set GD0QWIT empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (YITTBL.YITCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0QS60

// Formats screen,autoskip YCP
Function GD0QS61()
  /* GET GD0QS-61*/

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the YCI CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && YCITBL.YCICD[GDWINDX2] != "999")

    GD0QWCI.YCICD = YCITBL.YCICD[GDWINDX2];
    GD0QWCI.YCIDESC = YCITBL.YCIDESC[GDWINDX2];
    GD0QWCI.YCISDESC = YCITBL.YCISDESC[GDWINDX2];
    GD0QWCI.YCIMPFL = YCITBL.YCIMPFL[GDWINDX2];
    GD0QWCI.YCIRPFL = YCITBL.YCIRPFL[GDWINDX2];
    GD0QWCI.XXXSTAT = YCITBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0QWCI.GD0QWCIR;

    set GD0QWCI empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (YCITBL.YCICD[GDWINDX2] == "999")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the YCP CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && YCPTBL.YCPCD[GDWINDX2] != 9999)

    GD0QWCP.GD0QWCPC = YCPTBL.YCPCD[GDWINDX2];
    GD0QWCP.YCPNM = YCPTBL.YCPNM[GDWINDX2];
    GD0QWCP.XXXSTAT = YCPTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0QWCP.GD0QWCPR;

    set GD0QWCP empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (YCPTBL.YCPCD[GDWINDX2] == 9999)

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0QS61

// format screen autoskip YAC
Function GD0QS62()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the yac CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && YACTBL.YACCD[GDWINDX2] != "99")

    GD0QWAC.YACCD = YACTBL.YACCD[GDWINDX2];
    GD0QWAC.YACDESC = YACTBL.YACDESC[GDWINDX2];
    GD0QWAC.YACSDESC = YACTBL.YACSDESC[GDWINDX2];
    GD0QWAC.YACABRV = YACTBL.YACABRV[GDWINDX2];
    GD0QWAC.XXXSTAT = YACTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0QWAC.GD0QWACR;

    set GD0QWAC empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (YACTBL.YACCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0QS62

// format screen, autoskip XPO
Function GD0QS63()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the xpo CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && XPOTBL.XGPCD[GDWINDX2] != "99")

    GD0QWPO.XGPCD = XPOTBL.XGPCD[GDWINDX2];
    GD0QWPO.GD0QWAD3 = XPOTBL.XXX-ADDR3[GDWINDX2];
    GD0QWPO.XXXCITY = XPOTBL.XXXCITY[GDWINDX2];
    GD0QWPO.XXXPHN = XPOTBL.XXXPHN[GDWINDX2];
    GD0QWPO.XXXSTAT = XPOTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0QWPO.GD0QWPOR;

    set GD0QWPO empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (XPOTBL.XGPCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0QS63

// format screen, autoskip YOA
Function GD0QS64()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the YOA CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && YOATBL.YOACD[GDWINDX2] != "99")

    GD0QWOA.XGPCD = YOATBL.XGPCD[GDWINDX2];
    GD0QWOA.YOACD = YOATBL.YOACD[GDWINDX2];
    GD0QWOA.YOADESC = YOATBL.YOADESC[GDWINDX2];
    GD0QWOA.YOACMFL = YOATBL.YOACMFL[GDWINDX2];
    GD0QWOA.YOAADJFL = YOATBL.YOAADJFL[GDWINDX2];
    GD0QWOA.YOARPTFL = YOATBL.YOARPTFL[GDWINDX2];
    GD0QWOA.YOAINQFL = YOATBL.YOAINQFL[GDWINDX2];
    GD0QWOA.YOALCFL = YOATBL.YOALCFL[GDWINDX2];
    GD0QWOA.XXXSTAT = YOATBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0QWOA.GD0QWOAR;

    set GD0QWOA empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (YOATBL.YOACD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0QS64

// format screen, autoskip YOH
Function GD0QS65()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the YOH CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && YOHTBL.YOHCD[GDWINDX2] != "99")

    GD0QWOH.YOHCD = YOHTBL.YOHCD[GDWINDX2];
    GD0QWOH.YOHDESC = YOHTBL.YOHDESC[GDWINDX2];
    GD0QWOH.YOHSDESC = YOHTBL.YOHSDESC[GDWINDX2];
    GD0QWOH.YOHABRV = YOHTBL.YOHABRV[GDWINDX2];
    GD0QWOH.XXXSTAT = YOHTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0QWOH.GD0QWOHR;

    set GD0QWOH empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (YOHTBL.YOHCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0QS65

// format screen, autoskip YPU
Function GD0QS66()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the YPU CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && YPUTBL.YPUCD[GDWINDX2] != "99")

    GD0QWPU.YPUCD = YPUTBL.YPUCD[GDWINDX2];
    GD0QWPU.YPUDESC = YPUTBL.YPUDESC[GDWINDX2];
    GD0QWPU.YPUSDESC = YPUTBL.YPUSDESC[GDWINDX2];
    GD0QWPU.YPUABRV = YPUTBL.YPUABRV[GDWINDX2];
    GD0QWPU.XXXSTAT = YPUTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0QWPU.GD0QWPUR;

    set GD0QWPU empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (YPUTBL.YPUCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0QS66

// format screen, autoskip YSI
Function GD0QS67()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the YSI CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && YSITBL.YSICD[GDWINDX2] != "99")

    GD0QWSI.YSICD = YSITBL.YSICD[GDWINDX2];
    GD0QWSI.YSIDESC = YSITBL.YSIDESC[GDWINDX2];
    GD0QWSI.YSISDESC = YSITBL.YSISDESC[GDWINDX2];
    GD0QWSI.YSIABRV = YSITBL.YSIABRV[GDWINDX2];
    GD0QWSI.XXXSTAT = YSITBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0QWSI.GD0QWSIR;

    set GD0QWSI empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (YSITBL.YSICD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0QS67

// format screen, autoskip YPF
Function GD0QS68()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the ypf CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && YPFTBL.YPFCD[GDWINDX2] != "99")

    GD0QWPF.YPFCD = YPFTBL.YPFCD[GDWINDX2];
    GD0QWPF.YPFDESC = YPFTBL.YPFDESC[GDWINDX2];
    GD0QWPF.YPFSDESC = YPFTBL.YPFSDESC[GDWINDX2];
    GD0QWPF.YPFABRV = YPFTBL.YPFABRV[GDWINDX2];
    GD0QWPF.XXXSTAT = YPFTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0QWPF.GD0QWPFR;

    set GD0QWPF empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (YPFTBL.YPFCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0QS68

// format screen, autoskip YPC
Function GD0QS70()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the YPC CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && YPCTBL.YPCCD[GDWINDX2] != "99")

    GD0QWPC.YPCCD = YPCTBL.YPCCD[GDWINDX2];
    GD0QWPC.YPCDESC = YPCTBL.YPCDESC[GDWINDX2];
    GD0QWPC.YPCSDESC = YPCTBL.YPCSDESC[GDWINDX2];
    GD0QWPC.YPCABRV = YPCTBL.YPCABRV[GDWINDX2];
    GD0QWPC.XXXSTAT = YPCTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0QWPC.GD0QWPCR;

    set GD0QWPC empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (YPCTBL.YPCCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0QS70

// format screen, autoskip YTR
Function GD0QS71()

     /* *******************************************************/
     /* *      This statment group does the following:       **/
     /* *   Loads the  display table from the YTR CSP table  **/
     /* *   Set map items other than tran id to askip        **/
     /* *   attribute.  This prevents the user from          **/
     /* *   entering data on the screen before the tran id   **/
     /* *   is validated.                                    **/
     /* *******************************************************/


  GDWREC.GDWINDX1 = 1;


  if (GDWREC.GDWAIDS != "7")

    if (GDWREC.GDWAIDS != "8")

      GDWREC.GDWINDX2 = 1;

    end

  end


  while (GDWREC.GDWINDX1 <= 14
   && YTRTBL.YTRCD[GDWINDX2] != "99")

    GD0QWTR.YTRCD = YTRTBL.YTRCD[GDWINDX2];
    GD0QWTR.YTRDESC = YTRTBL.YTRDESC[GDWINDX2];
    GD0QWTR.YTRSDESC = YTRTBL.YTRSDESC[GDWINDX2];
    GD0QWTR.YTRABRV = YTRTBL.YTRABRV[GDWINDX2];
    GD0QWTR.XXXSTAT = YTRTBL.XXXSTAT[GDWINDX2];


    XMGDM002.XMGDMLIN[GDWINDX1] = GD0QWTR.GD0QWTRR;

    set GD0QWTR empty;

    GDWREC.GDWINDX1 = GDWREC.GDWINDX1 + 1;
    GDWREC.GDWINDX2 = GDWREC.GDWINDX2 + 1;

  end


  if (YTRTBL.YTRCD[GDWINDX2] == "99")

    GDWREC.GDWEOC = "Y";
    GD3REC.GD3PEND1 = "END OF CSP TABLE DISPLAY R";
    GD3REC.GD3PEND2 = "EACHED.                   ";
    XSGDG22();

  end


  GDWREC.GDWINDX1 = GDWREC.GDWINDX1 - 1;


  GDWREC.GDWINDX3 = 1;

  while (GDWREC.GDWINDX3 <= 14)

    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    set XMGDM002.XMGDMLIN[GDWINDX3] skip;
    GDWREC.GDWINDX3 = GDWREC.GDWINDX3 + 1;

  end


  if (GDWREC.GDWAIDS != "7")
    GDWREC.GDWSCAN = GDWREC.GDWINDX2;
  end


  return;



end // end GD0QS71

//*** RECORD=GD0QWAC ****
// ************************************************************
// *** CREATED:  9-18-87                 BY: JOHN WOOD      ***
// ***                                                      ***
// *** USED BY: GD0Q          (SEE PROCESS LIST)            ***
// *** PURPOSE: TO DISPLAY CSP  YACTBL DATA                 ***
// ************************************************************
// ***********************
Record GD0QWAC type basicRecord
  10 GD0QWACR GD0QWACR ; 
    20 * char(1) ; 
    20 YACCD YACCD ; 
    20 * char(3) ; 
    20 YACDESC YACDESC ; 
    20 * char(4) ; 
    20 YACSDESC YACSDESC ; 
    20 * char(4) ; 
    20 YACABRV YACABRV ; 
    20 * char(7) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(8) ; 
end // end GD0QWAC

//*** RECORD=GD0QWAP ****
// ************************************************************
// *** CREATED:  5-12-87                 BY: JOHN WOOD      ***
// ***                                                      ***
// *** USED BY: GD0Q          (SEE PROCESS LIST)            ***
// *** PURPOSE: TO DISPLAY CSP  YAPTBL DATA                 ***
// ************************************************************
// ***********************
Record GD0QWAP type basicRecord
  10 GD0QWAPR GD0QWAPR ; 
    20 * char(2) ; 
    20 GD0QWAPC GD0QWAPC ; 
    20 * char(4) ; 
    20 YAPDESC YAPDESC ; 
    20 * char(6) ; 
    20 YAPABRV YAPABRV ; 
    20 * char(8) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(29) ; 
end // end GD0QWAP

//*** RECORD=GD0QWCE ****
// ************************************************************
// *** CREATED:  6-01-87                 BY: JOHN WOOD      ***
// ***                                                      ***
// *** USED BY: GD0Q          (SEE PROCESS LIST)            ***
// *** PURPOSE: TO DISPLAY CSP  YCETBL DATA                 ***
// ************************************************************
// ***********************
Record GD0QWCE type basicRecord
  10 GD0QWCER GD0QWCER ; 
    20 * char(2) ; 
    20 YCECD YCECD ; 
    20 * char(4) ; 
    20 YCEDESC YCEDESC ; 
    20 * char(8) ; 
    20 YCEAOVRF YCEAOVRF ; 
    20 * char(9) ; 
    20 XXXSTAT XXXSTAT ; 
end // end GD0QWCE

//*** RECORD=GD0QWCI ****
// ************************************************************
// *** CREATED:  8-04-88                 BY: JOHN WOOD      ***
// ***                                                      ***
// *** USED BY: GD0Q          (SEE PROCESS LIST)            ***
// *** PURPOSE: TO DISPLAY CSP  YCITBL DATA                 ***
// ************************************************************
// ***********************
Record GD0QWCI type basicRecord
  10 GD0QWCIR GD0QWCIR ; 
    20 YCICD YCICD ; 
    20 * char(3) ; 
    20 YCIDESC YCIDESC ; 
    20 * char(2) ; 
    20 YCISDESC YCISDESC ; 
    20 * char(5) ; 
    20 YCIMPFL YCIMPFL ; 
    20 * char(5) ; 
    20 YCIRPFL YCIRPFL ; 
    20 * char(6) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(9) ; 
end // end GD0QWCI

//*** RECORD=GD0QWCP ****
// ************************************************************
// *** CREATED:  5-12-87                 BY: JOHN WOOD      ***
// ***                                                      ***
// *** USED BY: GD0Q          (SEE PROCESS LIST)            ***
// *** PURPOSE: TO DISPLAY CSP  YCPTBL DATA                 ***
// ************************************************************
// ***********************
Record GD0QWCP type basicRecord
  10 GD0QWCPR GD0QWCPR ; 
    20 * char(1) ; 
    20 GD0QWCPC GD0QWCPC ; 
    20 * char(3) ; 
    20 YCPNM YCPNM ; 
    20 * char(5) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(44) ; 
end // end GD0QWCP

//*** RECORD=GD0QWCR ****
// ************************************************************
// *** CREATED:  5-12-87                 BY: JOHN WOOD      ***
// ***                                                      ***
// *** USED BY: GD0Q          (SEE PROCESS LIST)            ***
// *** PURPOSE: TO DISPLAY CSP  YCRTBL DATA                 ***
// ************************************************************
// ***********************
Record GD0QWCR type basicRecord
  10 GD0QWCRR GD0QWCRR ; 
    20 * char(1) ; 
    20 YCRCD YCRCD ; 
    20 * char(2) ; 
    20 YCRDESC YCRDESC ; 
    20 * char(3) ; 
    20 YCRALWGL YCRALWGL ; 
    20 * char(5) ; 
    20 YCRALWPR YCRALWPR ; 
    20 * char(5) ; 
    20 YCRALWTF YCRALWTF ; 
    20 * char(6) ; 
    20 YCRSPARN YCRSPARN ; 
    20 * char(7) ; 
    20 YCR-NPAY-FRGT-FL YCR-NPAY-FRGT-FL ; 
    20 * char(7) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(3) ; 
end // end GD0QWCR

//*** RECORD=GD0QWCS ****
// ************************************************************
// *** CREATED:  5-12-87                 BY: JOHN WOOD      ***
// ***                                                      ***
// *** USED BY: GD0Q          (SEE PROCESS LIST)            ***
// *** PURPOSE: TO DISPLAY CSP  YCSTBL DATA                 ***
// ************************************************************
// ***********************
Record GD0QWCS type basicRecord
  10 GD0QWCSR GD0QWCSR ; 
    20 YCSCD YCSCD ; 
    20 * char(3) ; 
    20 YCSDESC YCSDESC ; 
    20 * char(2) ; 
    20 YCSSDESC YCSSDESC ; 
    20 * char(3) ; 
    20 YCSABRV YCSABRV ; 
    20 * char(4) ; 
    20 YCSACTCD YCSACTCD ; 
    20 * char(6) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(7) ; 
end // end GD0QWCS

//*** RECORD=GD0QWCT ****
// ************************************************************
// *** CREATED:  5-12-87                 BY: JOHN WOOD      ***
// ***                                                      ***
// *** USED BY: GD0Q          (SEE PROCESS LIST)            ***
// *** PURPOSE: TO DISPLAY CSP  YCTTBL DATA                 ***
// ************************************************************
// ***********************
Record GD0QWCT type basicRecord
  10 GD0QWCTR GD0QWCTR ; 
    20 YCTCD YCTCD ; 
    20 * char(3) ; 
    20 YCTDESC YCTDESC ; 
    20 * char(2) ; 
    20 YCTABRV YCTABRV ; 
    20 * char(4) ; 
    20 YCT-OSD-FL YCT-OSD-FL ; 
    20 * char(7) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(31) ; 
end // end GD0QWCT

//*** RECORD=GD0QWDF ****
// ************************************************************
// *** CREATED:  5-12-87                 BY: JOHN WOOD      ***
// ***                                                      ***
// *** USED BY: GD0Q          (SEE PROCESS LIST)            ***
// *** PURPOSE: TO DISPLAY CSP  YDFTBL DATA                 ***
// ************************************************************
// ***********************
Record GD0QWDF type basicRecord
  10 GD0QWDFR GD0QWDFR ; 
    20 * char(1) ; 
    20 YDFCD YDFCD ; 
    20 * char(3) ; 
    20 XGPCD XGPCD ; 
    20 * char(4) ; 
    20 YDFDESC YDFDESC ; 
    20 * char(5) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(19) ; 
end // end GD0QWDF

//*** RECORD=GD0QWDR ****
// ************************************************************
// *** CREATED:  5-12-87                 BY: JOHN WOOD      ***
// ***                                                      ***
// *** USED BY: GD0Q          (SEE PROCESS LIST)            ***
// *** PURPOSE: TO DISPLAY CSP  YDRTBL DATA                 ***
// ************************************************************
// ***********************
Record GD0QWDR type basicRecord
  10 GD0QWDRR GD0QWDRR ; 
    20 * char(2) ; 
    20 YDRCD YDRCD ; 
    20 * char(4) ; 
    20 YDRCLTPI YDRCLTPI ; 
    20 * char(3) ; 
    20 YDRDESC YDRDESC ; 
    20 * char(4) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(9) ; 
end // end GD0QWDR

//*** RECORD=GD0QWGL ****
// ************************************************************
// *** CREATED:  5-15-87                 BY: JOHN WOOD      ***
// ***                                                      ***
// *** USED BY: GD0Q          (SEE PROCESS LIST)            ***
// *** PURPOSE: TO DISPLAY CSP  xglTBL DATA                 ***
// ************************************************************
// ***********************
Record GD0QWGL type basicRecord
  10 GD0QWGLR GD0QWGLR ; 
    20 * char(1) ; 
    20 XGLTCOD XGLTCOD ; 
    20 * char(4) ; 
    20 XGLTDSP XGLTDSP ; 
    20 * char(6) ; 
    20 XGLTAPP XGLTAPP ; 
    20 * char(30) ; 
end // end GD0QWGL

//*** RECORD=GD0QWIT ****
// ************************************************************
// *** CREATED:  5-12-87                 BY: JOHN WOOD      ***
// ***                                                      ***
// *** USED BY: GD0Q          (SEE PROCESS LIST)            ***
// *** PURPOSE: TO DISPLAY CSP  YMDTBL DATA                 ***
// ************************************************************
// ***********************
Record GD0QWIT type basicRecord
  10 GD0QWITR GD0QWITR ; 
    20 * char(1) ; 
    20 YITCD YITCD ; 
    20 * char(3) ; 
    20 YITDESC YITDESC ; 
    20 * char(2) ; 
    20 YITABRV YITABRV ; 
    20 * char(5) ; 
    20 YITIOIBM YITIOIBM ; 
    20 * char(5) ; 
    20 YITRECDF YITRECDF ; 
    20 * char(6) ; 
    20 YITMULTF YITMULTF ; 
    20 * char(7) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(7) ; 
end // end GD0QWIT

//*** RECORD=GD0QWMD ****
// ************************************************************
// *** CREATED:  5-12-87                 BY: JOHN WOOD      ***
// ***                                                      ***
// *** USED BY: GD0Q          (SEE PROCESS LIST)            ***
// *** PURPOSE: TO DISPLAY CSP  YMDTBL DATA                 ***
// ************************************************************
// ***********************
Record GD0QWMD type basicRecord
  10 GD0QWMDR GD0QWMDR ; 
    20 * char(2) ; 
    20 YMDCD YMDCD ; 
    20 * char(4) ; 
    20 YMDDESC YMDDESC ; 
    20 * char(6) ; 
    20 YMDABRV YMDABRV ; 
    20 * char(8) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(29) ; 
end // end GD0QWMD

//*** RECORD=GD0QWOA ****
// ************************************************************
// *** CREATED: 10-13-89                 BY: JOHN WOOD      ***
// ***                                                      ***
// *** USED BY: GD0Q          (SEE PROCESS LIST)            ***
// *** PURPOSE: TO DISPLAY CSP  XPOTBL DATA                 ***
// ************************************************************
// ***********************
Record GD0QWOA type basicRecord
  10 GD0QWOAR GD0QWOAR ; 
    20 * char(1) ; 
    20 YOACD YOACD ; 
    20 * char(4) ; 
    20 XGPCD XGPCD ; 
    20 * char(3) ; 
    20 YOADESC YOADESC ; 
    20 * char(3) ; 
    20 YOACMFL YOACMFL ; 
    20 * char(4) ; 
    20 YOAADJFL YOAADJFL ; 
    20 * char(5) ; 
    20 YOARPTFL YOARPTFL ; 
    20 * char(5) ; 
    20 YOAINQFL YOAINQFL ; 
    20 * char(5) ; 
    20 YOALCFL YOALCFL ; 
    20 * char(6) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(2) ; 
end // end GD0QWOA

//*** RECORD=GD0QWOH ****
// ************************************************************
// *** CREATED:  9-18-87                 BY: JOHN WOOD      ***
// ***                                                      ***
// *** USED BY: GD0Q          (SEE PROCESS LIST)            ***
// *** PURPOSE: TO DISPLAY CSP  YACTBL DATA                 ***
// ************************************************************
// ***********************
Record GD0QWOH type basicRecord
  10 GD0QWOHR GD0QWOHR ; 
    20 * char(1) ; 
    20 YOHCD YOHCD ; 
    20 * char(3) ; 
    20 YOHDESC YOHDESC ; 
    20 * char(4) ; 
    20 YOHSDESC YOHSDESC ; 
    20 * char(4) ; 
    20 YOHABRV YOHABRV ; 
    20 * char(7) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(8) ; 
end // end GD0QWOH

//*** RECORD=GD0QWPC ****
// ************************************************************
// *** CREATED:  9-18-87                 BY: JOHN WOOD      ***
// ***                                                      ***
// *** USED BY: GD0Q          (SEE PROCESS LIST)            ***
// *** PURPOSE: TO DISPLAY CSP  YACTBL DATA                 ***
// ************************************************************
// ***********************
Record GD0QWPC type basicRecord
  10 GD0QWPCR GD0QWPCR ; 
    20 * char(1) ; 
    20 YPCCD YPCCD ; 
    20 * char(3) ; 
    20 YPCDESC YPCDESC ; 
    20 * char(4) ; 
    20 YPCSDESC YPCSDESC ; 
    20 * char(4) ; 
    20 YPCABRV YPCABRV ; 
    20 * char(7) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(8) ; 
end // end GD0QWPC

//*** RECORD=GD0QWPF ****
// ************************************************************
// *** CREATED:  9-18-87                 BY: JOHN WOOD      ***
// ***                                                      ***
// *** USED BY: GD0Q          (SEE PROCESS LIST)            ***
// *** PURPOSE: TO DISPLAY CSP  YACTBL DATA                 ***
// ************************************************************
// ***********************
Record GD0QWPF type basicRecord
  10 GD0QWPFR GD0QWPFR ; 
    20 * char(1) ; 
    20 YPFCD YPFCD ; 
    20 * char(3) ; 
    20 YPFDESC YPFDESC ; 
    20 * char(4) ; 
    20 YPFSDESC YPFSDESC ; 
    20 * char(4) ; 
    20 YPFABRV YPFABRV ; 
    20 * char(7) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(8) ; 
end // end GD0QWPF

//*** RECORD=GD0QWPO ****
// ************************************************************
// *** CREATED: 10-13-89                 BY: JOHN WOOD      ***
// ***                                                      ***
// *** USED BY: GD0Q          (SEE PROCESS LIST)            ***
// *** PURPOSE: TO DISPLAY CSP  XPOTBL DATA                 ***
// ************************************************************
// ***********************
Record GD0QWPO type basicRecord
  10 GD0QWPOR GD0QWPOR ; 
    20 * char(1) ; 
    20 XGPCD XGPCD ; 
    20 * char(2) ; 
    20 GD0QWAD3 GD0QWAD3 ; 
    20 * char(2) ; 
    20 XXXCITY XXXCITY ; 
    20 * char(2) ; 
    20 XXXPHN XXXPHN ; 
    20 * char(8) ; 
    20 XXXSTAT XXXSTAT ; 
end // end GD0QWPO

//*** RECORD=GD0QWPU ****
// ************************************************************
// *** CREATED:  9-18-87                 BY: JOHN WOOD      ***
// ***                                                      ***
// *** USED BY: GD0Q          (SEE PROCESS LIST)            ***
// *** PURPOSE: TO DISPLAY CSP  YACTBL DATA                 ***
// ************************************************************
// ***********************
Record GD0QWPU type basicRecord
  10 GD0QWPUR GD0QWPUR ; 
    20 * char(1) ; 
    20 YPUCD YPUCD ; 
    20 * char(3) ; 
    20 YPUDESC YPUDESC ; 
    20 * char(4) ; 
    20 YPUSDESC YPUSDESC ; 
    20 * char(4) ; 
    20 YPUABRV YPUABRV ; 
    20 * char(7) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(8) ; 
end // end GD0QWPU

//*** RECORD=GD0QWSI ****
// ************************************************************
// *** CREATED:  9-18-87                 BY: JOHN WOOD      ***
// ***                                                      ***
// *** USED BY: GD0Q          (SEE PROCESS LIST)            ***
// *** PURPOSE: TO DISPLAY CSP  YACTBL DATA                 ***
// ************************************************************
// ***********************
Record GD0QWSI type basicRecord
  10 GD0QWSIR GD0QWSIR ; 
    20 * char(1) ; 
    20 YSICD YSICD ; 
    20 * char(3) ; 
    20 YSIDESC YSIDESC ; 
    20 * char(4) ; 
    20 YSISDESC YSISDESC ; 
    20 * char(4) ; 
    20 YSIABRV YSIABRV ; 
    20 * char(7) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(8) ; 
end // end GD0QWSI

//*** RECORD=GD0QWSS ****
// ************************************************************
// *** CREATED: 11-13-89                 BY: JOHN WOOD      ***
// ***                                                      ***
// *** USED BY: GD0Q          (SEE PROCESS LIST)            ***
// *** PURPOSE: TO DISPLAY CSP  YSSTBL DATA                 ***
// ************************************************************
// ***********************
Record GD0QWSS type basicRecord
  10 GD0QWSSR GD0QWSSR ; 
    20 * char(1) ; 
    20 YSSCD YSSCD ; 
    20 * char(3) ; 
    20 YSSDESC YSSDESC ; 
    20 * char(3) ; 
    20 YSSABRV YSSABRV ; 
    20 * char(6) ; 
    20 YSSUPDFL YSSUPDFL ; 
    20 * char(8) ; 
    20 YSSDELFL YSSDELFL ; 
    20 * char(7) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(9) ; 
end // end GD0QWSS

//*** RECORD=GD0QWTR ****
// ************************************************************
// *** CREATED:  9-18-87                 BY: JOHN WOOD      ***
// ***                                                      ***
// *** USED BY: GD0Q          (SEE PROCESS LIST)            ***
// *** PURPOSE: TO DISPLAY CSP  YACTBL DATA                 ***
// ************************************************************
// ***********************
Record GD0QWTR type basicRecord
  10 GD0QWTRR GD0QWTRR ; 
    20 * char(1) ; 
    20 YTRCD YTRCD ; 
    20 * char(3) ; 
    20 YTRDESC YTRDESC ; 
    20 * char(4) ; 
    20 YTRSDESC YTRSDESC ; 
    20 * char(4) ; 
    20 YTRABRV YTRABRV ; 
    20 * char(7) ; 
    20 XXXSTAT XXXSTAT ; 
    20 * char(8) ; 
end // end GD0QWTR

DataItem GD0QWACR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// YAC-COMNT-DESC
DataItem GD0QWAD3 char(25)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// yap-ad-prodln-cd
DataItem GD0QWAPC num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

DataItem GD0QWAPR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0QWCER char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0QWCIR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// co-op analyst
DataItem GD0QWCPC num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

DataItem GD0QWCPR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0QWCRR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0QWCSR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0QWCTR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0QWDFR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0QWDRR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0QWGLR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0QWITR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0QWMDR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0QWOAR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0QWOHR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0QWPCR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0QWPFR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0QWPOR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0QWPUR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0QWSIR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0QWSSR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem GD0QWTRR char(78)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

