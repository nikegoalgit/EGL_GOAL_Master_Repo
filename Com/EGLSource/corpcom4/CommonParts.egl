package corpcom4;
import corpcom3.*;
import ob.common.*;
// purge temp storage - 2
Function XSAZT2P()

   /* purge temporary storage 2*/

  TA5REC.TA5APPID = "AZF2"; /* appl identification*/
  TA5REC.TA5FNCCD = "P"; /* function code*/
  call "TA0050" (AZOREC, TA5REC) {isNoRefresh = yes, isExternal = yes}; /* temp storage subroutine*/

  if (TA5REC.TA5RTNCD == 0)
    AZWREC.AZWTSF2P = 1;
    AZWREC.AZWTSF2S = 1;
    AZWREC.AZWTSF2M = 1;
  else
    TA1REC.TA1LOCAT[1] = "PRGE TS2";
    TA1REC.TA1LOCAT[2] = "TA0050"; /* io mod called*/
    TA1REC.TA1LOCAT[3] = TA5REC.TA5RTNCD; /* return code*/
    TAEREC.TAEDESC1 = TA5REC.TA5DATA; /* subroutine parms*/
    XSAZENP(); /* post,  no rollback, non db2*/

  end
end // end XSAZT2P

// purge temp carton storage
Function XSAZT3P()

   /* purge temporary storage 3*/

  TA5REC.TA5APPID = "AZF3"; /* appl identification*/
  TA5REC.TA5FNCCD = "P"; /* function code*/
  call "TA0050" (AZDREC, TA5REC) {isNoRefresh = yes, isExternal = yes}; /* temp storage subroutine*/

  if (TA5REC.TA5RTNCD == 0)
    AZWREC.AZWTSF3P = 1;
    AZWREC.AZWTSF3S = 1;
    AZWREC.AZWTSF3M = 1;
  else
    TA1REC.TA1LOCAT[1] = "PRGE TS3";
    TA1REC.TA1LOCAT[2] = "TA0050"; /* io mod called*/
    TA1REC.TA1LOCAT[3] = TA5REC.TA5RTNCD; /* return code*/
    TAEREC.TAEDESC1 = TA5REC.TA5DATA; /* subroutine parms*/
    XSAZENP(); /* post,  no rollback, non db2*/

  end
end // end XSAZT3P

// abort routine
Function XSCCS02()
   /* *******************************************/
   /* * online abort routine for credit system **/
   /* *******************************************/

  TA1REC.TA1TYPE = "DB2"; /* abend type*/
  TA1REC.TA1FUNC = "RETN"; /* abend func*/
  set ERRSQLCA empty; /* clear area*/
  move SQLCA to ERRSQLCA withV60Compat; /* save orig sqlca*/
  VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
  VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
  sysLib.rollback();
  VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
   /* synpoint rollback*/
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes}; /* abend module*/
  COMMAREA.CAUSERA = " "; /* clear user commarea*/
  XSPF4(); /* master menu*/
  exit program; /* master menu failure*/

end // end XSCCS02

// x4crec - check/xlate fld bytes
Function XSCKBYT()


   /* ************************************************************/
   /* *** use the values setup in x4crec                      ****/
   /* *** depending on the value setup in the function fld:   ****/
   /* ***   E = if find character found, exit with rc = 2     ****/
   /* ***   X = if find character found, translate to fill    ****/
   /* *** check each byte for setup length of this field      ****/
   /* *** return codes:                                       ****/
   /* ***   0 = no characters found or translation OK         ****/
   /* ***   2 = characters found for error function           ****/
   /* ***   3 = invalid function code                         ****/
   /* ************************************************************/

  X4CREC.X4CRC = 0;
  X4CREC.X4CCTR = 1;

  if (X4CREC.X4CFNC == "E")
    while (X4CREC.X4CCTR <= X4CREC.X4CLEN
     && X4CREC.X4CRC == 0)
      XSCKERR(); /* <=== check bytes for error value*/
      X4CREC.X4CCTR = X4CREC.X4CCTR + 1;
    end
  else
    if (X4CREC.X4CFNC == "X")
      while (X4CREC.X4CCTR <= X4CREC.X4CLEN)
        XSXLATE(); /* <=== translate byte values*/
        X4CREC.X4CCTR = X4CREC.X4CCTR + 1;
      end
    else
      X4CREC.X4CRC = 3;
    end
  end

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSCKBYT

// x4crec - check for error value
Function XSCKERR()


   /* ************************************************************/
   /* *** if find character found, exit with rc = 2           ****/
   /* ************************************************************/

  if (X4CREC.X4CBYT[X4CCTR] == X4CREC.X4CFND)
    X4CREC.X4CRC = 2;
  end

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSCKERR

// validate extend field
Function XSCLSEX()
    /* ---------- start stmt grp xsclsex -----------------*/
    /* add days to current date and move to cljraxdt*/

   /* ** maintenance log **************************************/
   /* 5-30-93 bcourt  Add comments.  Put date into RAIDT.*/

   /* ------------------------------------------------------*/
   /* 5-30-93 Add code so initial RA setup date = 0 gets filled in.*/

  if (CLJREC.CLJRAIDT == 0) /* if initial date = 0, hold current*/
    CLJREC.CLJRAIDT = CLXREC.XXXCDTE;
  end

   /* ------------------------------------------------------*/
   /* get expiration range, then add to current date*/
  set TA2REC empty;

  if (CLAREC.XGPCD in YCXTBL.XGPCD /* claims expiration date tble*/
   && YCXTBL.XXXSTAT[sysVar.arrayIndex] != "I") /* and not inactive*/
    TA2REC.TA2DYAOD = YCXTBL.YCXXPRDY[sysVar.arrayIndex]; /* # days out to expire*/
  end

  TA2REC.TA2DTOPT = "GETDATE ";

   /* add #-days-out  to  current-date to get new expiration date.*/
  call "TA0040" (TA2REC) {isNoRefresh = yes, isExternal = yes};
  if (TA2REC.TA2RTNCD == 0)
    CLJREC.CLJRAXDT = TA2REC.TA2GRGGN;
  else
    TA1REC.TA1TBLKE = "CREATE EXPIRATION DATE, XSCLSEX";
    XPCL010(); /* abend*/
  end

    /* -----------   end of stmt grp xsclsex  ------------*/

end // end XSCLSEX

// 'enter'flow on cl0e, f, g, h&n
Function XSCLSFL()
   /* ************************************************************/
   /* common statement group to determine the application*/
   /* to flow to.  used in kl0e, claim header*/
                        /* kl0f, claim addresses*/
                        /* kl0g, claim comments,*/
                              /* memo comments*/
                        /* kl0h, a/r reference*/
                        /* kl0n, add'l invoices/cust claim nbrs*/
                        /* kl0s, exceptions*/

   /* this is used on the 'enter' key. kl0e is the header and*/
   /* the others are sub-screens, all with the same flow.*/
   /* 10-31-91 twatso added code so osd has same path as def*/
   /* 5-5-93  BCOURT Add menu option 19, like 09.*/
   /* ************************************************************/

  if (COMMAREA.CAFROMAP == "KL0M") /* if came from memo, return*/
    COMMAREA.CATOAP = "KL0M"; /* memo*/
    return;
  end


     /* ***************************************/
     /* test claim type code to determine flow*/
     /* ***************************************/

  if (CLAREC.YCTCD == "ADJ")
    COMMAREA.CATOAP = "KL0L"; /* adjustment*/
    return;
  end

  if (CLAREC.YCTCD == "DAA"
   || CLAREC.YCTCD == "NBC")
    COMMAREA.CATOAP = "KL0K"; /* nike bank claim g/l*/
    return;
  end

  if (CLAREC.YCTCD == "SCO")
    COMMAREA.CATOAP = "KL0W"; /* shipping charges only*/
    return;
  end

  if (CLAREC.YCTCD == "NIL")
    COMMAREA.CATOAP = "KL0X"; /* international*/
    return;
  end

  if (CLAREC.YCTCD == "DFO")
    COMMAREA.CATOAP = "KL0V"; /* defective products*/
    return;
  end


   /* new code for return authorizations*/

   /* *********************************************************/
   /* flow according to worksheet entered flag*/
   /* *********************************************************/


  if (CLAREC.CLAWSENF == "N")

    if (CLWREC.CLWMNOPT == 9  /* Return Summary Inspection*/
     || CLWREC.CLWMNOPT == 14 /* Return Summary Inquiry*/
     || CLWREC.CLWMNOPT == 17 /* Return Summary Inquiry*/
     || CLWREC.CLWMNOPT == 19) /* 5-5-93*/
      COMMAREA.CATOAP = "KL02";
      return;
    end

    if (CLWREC.CLWMNOPT == 7 /* Special Services Log*/
     || CLWREC.CLWMNOPT == 16) /* Special Services Log*/
      COMMAREA.CATOAP = "KL0T";
      return;
    end

    if (CLAREC.YCTCD == "RTS")
      COMMAREA.CATOAP = "KL0O"; /* return auth rts summary*/
      return;
    end

    if (CLAREC.YCTCD == "RFL")
      COMMAREA.CATOAP = "KL0I"; /* traffic*/
      return;
    end

    if (CLAREC.YCTCD == "DEF"
     || CLAREC.YCTCD == "CDR"
     || CLAREC.YCTCD == "OSD")
      COMMAREA.CATOAP = "KL0R"; /* defective return auth*/
      return;
    end


    COMMAREA.CATOAP = "KL0E"; /* flow back to 'kl0e'*/
  end


     /* default flow to address, an innocent screen*/

  COMMAREA.CATOAP = "KL0F"; /* address, expect yctcd = cdr,def or*/
                                   /* rts*/
end // end XSCLSFL

// inquiry : doc hdr/loc : 0
Function XSCY1I0()


   /* ************************************************************/
   /* *** select unique row from:  document header/location   ****/
   /* *** using the std module:  IO2410                       ****/
   /* *** note: use cyvrec to pass function & date ranges     ****/
   /* ************************************************************/

  CYVREC.CYVFNC = "S ";

  call "IO2410" (CYVREC, SQLCA, CY1REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -911)
    TA1REC.TA1FUNC = "POST";
  else
    TA1REC.TA1FUNC = "RETN";
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1PGMNM = "XSCY1I0 ";
  TA1REC.TA1LOCAT[1] = "IO2410  ";
  TA1REC.TA1LOCAT[3] = "SELECT  ";
  TA1REC.TA1LOCAT[4] = "UNIQUE  ";
  TA1REC.TA1DBASE = "DCYCLE  ";
  TA1REC.TA1TBLVU = "VDOCHD01";
  TA1REC.TA1TBLKE = CY1REC.CY1KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSCY1I0

// inquiry : doc itm/prd : 0
Function XSCY2I0()


   /* ************************************************************/
   /* *** select unique row from:  document item/product      ****/
   /* *** using the std module:  IO2420                       ****/
   /* *** note: use cyvrec to pass function & date ranges     ****/
   /* ************************************************************/

  CYVREC.CYVFNC = "S ";

  call "IO2420" (CYVREC, SQLCA, CY2REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -911)
    TA1REC.TA1FUNC = "POST";
  else
    TA1REC.TA1FUNC = "RETN";
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1PGMNM = "XSCY2I0 ";
  TA1REC.TA1LOCAT[1] = "IO2420  ";
  TA1REC.TA1LOCAT[3] = "SELECT  ";
  TA1REC.TA1LOCAT[4] = "UNIQUE  ";
  TA1REC.TA1DBASE = "DCYCLE  ";
  TA1REC.TA1TBLVU = "VDOCIT01";
  TA1REC.TA1TBLKE = CY2REC.CY2KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSCY2I0

// replace : doc itm/prd : 0
Function XSCY2R0()


   /* ************************************************************/
   /* *** replace unique row in:  document item/product       ****/
   /* *** using the std module:  IO2420                       ****/
   /* *** note: use cyvrec to pass function & date ranges     ****/
   /* *** note: IO process increments record zzzchgct by +1   ****/
   /* ***       but ID's row to update by the old zzzchgct    ****/
   /* ************************************************************/

  CY2REC.ZZZCHGDT = X2CREC.X2CCURDT;
  CY2REC.ZZZCHGTM = X3CREC.X3CCURST;

  CYVREC.CYVFNC = "U ";

  call "IO2420" (CYVREC, SQLCA, CY2REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
     /* ************************************************************/
     /* *** select the original row without a change count      ****/
     /* *** note: select unique does NOT use zzzchgct           ****/
     /* *** note: this puts current version of data in record   ****/
     /* ***       or blanks out record layout = deleted         ****/
     /* ************************************************************/
    XSCY2I0(); /* <=== select unique row*/
    if (SQLCA.VAGen_SQLCODE == 0)
      SQLCA.VAGen_SQLCODE = +100;
      return;
    end
    if (SQLCA.VAGen_SQLCODE == +100)
      CY2REC.CY2DATA = " ";
      return;
    end
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -911)
    TA1REC.TA1FUNC = "POST";
  else
    TA1REC.TA1FUNC = "RETN";
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1PGMNM = "XSCY2R0 ";
  TA1REC.TA1LOCAT[1] = "IO2420  ";
  TA1REC.TA1LOCAT[3] = "REPLACE ";
  TA1REC.TA1LOCAT[4] = "ROW     ";
  TA1REC.TA1DBASE = "DCYCLE  ";
  TA1REC.TA1TBLVU = "VDOCIT01";
  TA1REC.TA1TBLKE = CY2REC.CY2KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSCY2R0

// add : doc case/sz : 0
Function XSCY3A0()


   /* ************************************************************/
   /* *** add unique row to:  document case/size              ****/
   /* *** using the std module:  IO2430                       ****/
   /* *** note: use cyvrec to pass function & date ranges     ****/
   /* *** note: -803 check (=select unique) not necessary     ****/
   /* *** note: IO process initializes zzzchgct to 0          ****/
   /* ************************************************************/

  CY3REC.ZZZSDT = X2CREC.X2CCURDT;
  CY3REC.ZZZCHGDT = X2CREC.X2CCURDT;
  CY3REC.ZZZCHGTM = X3CREC.X3CCURST;

  CYVREC.CYVFNC = "A ";

  call "IO2430" (CYVREC, SQLCA, CY3REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -911)
    TA1REC.TA1FUNC = "POST";
  else
    TA1REC.TA1FUNC = "RETN";
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1PGMNM = "XSCY3A0 ";
  TA1REC.TA1LOCAT[1] = "IO2430  ";
  TA1REC.TA1LOCAT[3] = "ADD     ";
  TA1REC.TA1LOCAT[4] = "ROW     ";
  TA1REC.TA1DBASE = "DCYCLE  ";
  TA1REC.TA1TBLVU = "VDOCSZ01";
  TA1REC.TA1TBLKE = CY3REC.CY3KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSCY3A0

// close : doc case/sz : 1
Function XSCY3C1()


   /* ************************************************************/
   /* *** close select set of:  document case/size            ****/
   /* *** using the std module:  IO2430                       ****/
   /* *** note: use cyvrec to pass function & date ranges     ****/
   /* ************************************************************/

  CYVREC.CYVFNC = "C1";

  call "IO2430" (CYVREC, SQLCA, CY3REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -501)
    SQLCA.VAGen_SQLCODE = 0;
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSCY3C1 ";
  TA1REC.TA1LOCAT[1] = "IO2430  ";
  TA1REC.TA1LOCAT[3] = "CLOSE   ";
  TA1REC.TA1LOCAT[4] = "SETINQ  ";
  TA1REC.TA1DBASE = "DCYCLE  ";
  TA1REC.TA1TBLVU = "VDOCSZ01";
  TA1REC.TA1TBLKE = CY3REC.CY3KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSCY3C1

// fetch : doc case/sz : 1
Function XSCY3F1()


   /* ************************************************************/
   /* *** fetch next row from:  document case/size            ****/
   /* *** using the std module:  IO2430                       ****/
   /* *** note: use cyvrec to pass function & date ranges     ****/
   /* *** note: CSP closes cursor at end of set (+100)        ****/
   /* ***       but w/these io mods the sgrp will close       ****/
   /* ************************************************************/

  CYVREC.CYVFNC = "N1";

  call "IO2430" (CYVREC, SQLCA, CY3REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
    XSCY3C1(); /* <=== std close cursor*/
    if (SQLCA.VAGen_SQLCODE == 0)
      SQLCA.VAGen_SQLCODE = +100;
    end
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSCY3F1 ";
  TA1REC.TA1LOCAT[1] = "IO2430  ";
  TA1REC.TA1LOCAT[3] = "FETCH   ";
  TA1REC.TA1LOCAT[4] = "NEXT    ";
  TA1REC.TA1DBASE = "DCYCLE  ";
  TA1REC.TA1TBLVU = "VDOCSZ01";
  TA1REC.TA1TBLKE = CY3REC.CY3KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSCY3F1

// inquiry : doc case/sz : 0
Function XSCY3I0()


   /* ************************************************************/
   /* *** select unique row from:  document case/size         ****/
   /* *** using the std module:  IO2430                       ****/
   /* *** note: use cyvrec to pass function & date ranges     ****/
   /* ************************************************************/

  CYVREC.CYVFNC = "S ";

  call "IO2430" (CYVREC, SQLCA, CY3REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -911)
    TA1REC.TA1FUNC = "POST";
  else
    TA1REC.TA1FUNC = "RETN";
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1PGMNM = "XSCY3I0 ";
  TA1REC.TA1LOCAT[1] = "IO2430  ";
  TA1REC.TA1LOCAT[3] = "SELECT  ";
  TA1REC.TA1LOCAT[4] = "UNIQUE  ";
  TA1REC.TA1DBASE = "DCYCLE  ";
  TA1REC.TA1TBLVU = "VDOCSZ01";
  TA1REC.TA1TBLKE = CY3REC.CY3KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSCY3I0

// replace : doc case/sz : 0
Function XSCY3R0()


   /* ************************************************************/
   /* *** replace unique row in:  document case/size          ****/
   /* *** using the std module:  IO2430                       ****/
   /* *** note: use cyvrec to pass function & date ranges     ****/
   /* *** note: IO process increments record zzzchgct by +1   ****/
   /* ***       but ID's row to update by the old zzzchgct    ****/
   /* ************************************************************/

  CY3REC.ZZZCHGDT = X2CREC.X2CCURDT;
  CY3REC.ZZZCHGTM = X3CREC.X3CCURST;

  CYVREC.CYVFNC = "U ";

  call "IO2430" (CYVREC, SQLCA, CY3REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
     /* ************************************************************/
     /* *** select the original row without a change count      ****/
     /* *** note: select unique does NOT use zzzchgct           ****/
     /* *** note: this puts current version of data in record   ****/
     /* ***       or blanks out record layout = deleted         ****/
     /* ************************************************************/
    XSCY3I0(); /* <=== select unique row*/
    if (SQLCA.VAGen_SQLCODE == 0)
      SQLCA.VAGen_SQLCODE = +100;
      return;
    end
    if (SQLCA.VAGen_SQLCODE == +100)
      CY3REC.CY3DATA = " ";
      return;
    end
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -911)
    TA1REC.TA1FUNC = "POST";
  else
    TA1REC.TA1FUNC = "RETN";
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1PGMNM = "XSCY3R0 ";
  TA1REC.TA1LOCAT[1] = "IO2430  ";
  TA1REC.TA1LOCAT[3] = "REPLACE ";
  TA1REC.TA1LOCAT[4] = "ROW     ";
  TA1REC.TA1DBASE = "DCYCLE  ";
  TA1REC.TA1TBLVU = "VDOCSZ01";
  TA1REC.TA1TBLKE = CY3REC.CY3KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSCY3R0

// setinq : doc case/sz : 1
Function XSCY3S1()


   /* ************************************************************/
   /* *** select set of rows from:  document case/size        ****/
   /* *** using the std module:  IO2430                       ****/
   /* *** note: use cyvrec to pass function & date ranges     ****/
   /* *** note: the 1st fetch will be in the record layout    ****/
   /* ************************************************************/

  CYVREC.CYVFNC = "S1";

  call "IO2430" (CYVREC, SQLCA, CY3REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE < 0)
    if (SQLCA.VAGen_SQLCODE == -911)
      TA1REC.TA1FUNC = "POST";
    else
      TA1REC.TA1FUNC = "RETN";
    end
    TA1REC.TA1TYPE = "DB2 ";
    TA1REC.TA1PGMNM = "XSCY3S1 ";
    TA1REC.TA1LOCAT[1] = "IO2430  ";
    TA1REC.TA1LOCAT[3] = "SELECT  ";
    TA1REC.TA1LOCAT[4] = "SET     ";
    TA1REC.TA1DBASE = "DCYCLE  ";
    TA1REC.TA1TBLVU = "VDOCSZ01";
    TA1REC.TA1TBLKE = CY3REC.CY3KEY;
    move SQLCA to ERRSQLCA withV60Compat;
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback();
    call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
    return;
  end

   /* ************************************************************/
   /* *** scan/retrieve/fetch first row                       ****/
   /* *** in order to detect not found (+100)                 ****/
   /* *** note: CSP closes cursor at end of set (+100)        ****/
   /* *** note: any loop processing must use this first row   ****/
   /* ***       and fetch the next row at the end of the loop ****/
   /* *** note: fetch handles return code correctly           ****/
   /* ************************************************************/

  XSCY3F1(); /* <=== fetch first row*/

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSCY3S1

// update : doc case/sz : 1
Function XSCY3U1()


   /* ************************************************************/
   /* *** get unique row for update of:  doc case/size        ****/
   /* *** using the std module:  IO2430                       ****/
   /* *** note: IO process DOES move data to record           ****/
   /* ***       therefore, at this time (w/IO modules)        ****/
   /* ***       this will execute the std select unique sgrp  ****/
   /* ***       and                                           ****/
   /* ***       this sgrp should be used/executed so that     ****/
   /* ***       future conversion to native CSP DB2 will      ****/
   /* ***       only have to change/add code in this sgrp     ****/
   /* ***       and regenerate all applications               ****/
   /* *** note: use cyvrec to pass function & date ranges     ****/
   /* ************************************************************/

  XSCY3I0(); /* <=== std select unique*/

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSCY3U1

// add : sel adj.s   : 0
Function XSCY4A0()


   /* ************************************************************/
   /* *** add unique row to:  selected adjustments            ****/
   /* *** using the std module:  IO2460                       ****/
   /* *** note: use cyvrec to pass function & date ranges     ****/
   /* *** note: 0 return code means record already exists     ****/
   /* ***       = setup -803 return code                      ****/
   /* *** note: non-unique rows - duplicates possible         ****/
   /* *** note: IO process initializes zzzchgct to 0          ****/
   /* ************************************************************/

  CY4REC.ZZZSDT = X2CREC.X2CCURDT;
  CY4REC.ZZZCHGDT = X2CREC.X2CCURDT;
  CY4REC.ZZZCHGTM = X3CREC.X3CCURST;

  CYVREC.CYVFNC = "A ";

  call "IO2460" (CYVREC, SQLCA, CY4REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -911)
    TA1REC.TA1FUNC = "POST";
  else
    TA1REC.TA1FUNC = "RETN";
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1PGMNM = "XSCY4A0 ";
  TA1REC.TA1LOCAT[1] = "IO2460  ";
  TA1REC.TA1LOCAT[3] = "ADD     ";
  TA1REC.TA1LOCAT[4] = "ROW     ";
  TA1REC.TA1DBASE = "DCYCLE  ";
  TA1REC.TA1TBLVU = "VCYADJ01";
  TA1REC.TA1TBLKE = CY4REC.CY4KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSCY4A0

// close : sel adj.s   : 1
Function XSCY4C1()


   /* ************************************************************/
   /* *** close select set of:  selected adjustments          ****/
   /* *** using the std module:  IO2460                       ****/
   /* *** note: use cyvrec to pass function & date ranges     ****/
   /* ************************************************************/

  CYVREC.CYVFNC = "C1";

  call "IO2460" (CYVREC, SQLCA, CY4REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -501)
    SQLCA.VAGen_SQLCODE = 0;
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSCY4C1 ";
  TA1REC.TA1LOCAT[1] = "IO2460  ";
  TA1REC.TA1LOCAT[3] = "CLOSE   ";
  TA1REC.TA1LOCAT[4] = "SETINQ  ";
  TA1REC.TA1DBASE = "DCYCLE  ";
  TA1REC.TA1TBLVU = "VCYADJ01";
  TA1REC.TA1TBLKE = CY4REC.CY4KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSCY4C1

// delete : sel adj.s : 1
Function XSCY4D1()


   /* ************************************************************/
   /* *** delete set of rows in:  selected adjustments        ****/
   /* *** using the std module:  IO2460                       ****/
   /* *** note: use cyxrec to pass function & date ranges     ****/
   /* ************************************************************/

  CYVREC.CYVFNC = "D1";

  call "IO2460" (CYVREC, SQLCA, CY4REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0
   || SQLCA.VAGen_SQLCODE == +100)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -911)
    TA1REC.TA1FUNC = "POST";
  else
    TA1REC.TA1FUNC = "RETN";
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1PGMNM = "XSCY4D1 ";
  TA1REC.TA1LOCAT[1] = "IO2460  ";
  TA1REC.TA1LOCAT[3] = "DELETE  ";
  TA1REC.TA1LOCAT[4] = "ROW     ";
  TA1REC.TA1DBASE = "DCYCLE  ";
  TA1REC.TA1TBLVU = "VCYADJ01";
  TA1REC.TA1TBLKE = CY4REC.CY4KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSCY4D1

// fetch : sel adj.s   : 1
Function XSCY4F1()


   /* ************************************************************/
   /* *** fetch next row from:  selected adjustments          ****/
   /* *** using the std module:  IO2460                       ****/
   /* *** note: use cyvrec to pass function & date ranges     ****/
   /* *** note: CSP closes cursor at end of set (+100)        ****/
   /* ***       but w/these io mods the sgrp will close       ****/
   /* ************************************************************/

  CYVREC.CYVFNC = "N1";

  call "IO2460" (CYVREC, SQLCA, CY4REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
    XSCY4C1(); /* <=== std close cursor*/
    if (SQLCA.VAGen_SQLCODE == 0)
      SQLCA.VAGen_SQLCODE = +100;
    end
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSCY4F1 ";
  TA1REC.TA1LOCAT[1] = "IO2460  ";
  TA1REC.TA1LOCAT[3] = "FETCH   ";
  TA1REC.TA1LOCAT[4] = "NEXT    ";
  TA1REC.TA1DBASE = "DCYCLE  ";
  TA1REC.TA1TBLVU = "VCYADJ01";
  TA1REC.TA1TBLKE = CY4REC.CY4KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSCY4F1

// inquiry : cc sel adj.s : 0
Function XSCY4I0()


   /* ************************************************************/
   /* *** select unique row from:  cc selected adj.s          ****/
   /* *** using the std module:  IO2460                       ****/
   /* *** note: use cyvrec to pass function & date ranges     ****/
   /* ************************************************************/

  CYVREC.CYVFNC = "S ";

  call "IO2460" (CYVREC, SQLCA, CY4REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -911)
    TA1REC.TA1FUNC = "POST";
  else
    TA1REC.TA1FUNC = "RETN";
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1PGMNM = "XSCY4I0 ";
  TA1REC.TA1LOCAT[1] = "IO2460  ";
  TA1REC.TA1LOCAT[3] = "SELECT  ";
  TA1REC.TA1LOCAT[4] = "UNIQUE  ";
  TA1REC.TA1DBASE = "DCYCLE  ";
  TA1REC.TA1TBLVU = "VCYADJ01";
  TA1REC.TA1TBLKE = CY4REC.CY4KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSCY4I0

// setinq : sel adj.s   : 1
Function XSCY4S1()


   /* ************************************************************/
   /* *** select set of rows from:  selected adjustments      ****/
   /* *** using the std module:  IO2460                       ****/
   /* *** note: use cyvrec to pass function & date ranges     ****/
   /* *** note: the 1st fetch will be in the record layout    ****/
   /* ************************************************************/

  CYVREC.CYVFNC = "S1";

  call "IO2460" (CYVREC, SQLCA, CY4REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE < 0)
    if (SQLCA.VAGen_SQLCODE == -911)
      TA1REC.TA1FUNC = "POST";
    else
      TA1REC.TA1FUNC = "RETN";
    end
    TA1REC.TA1TYPE = "DB2 ";
    TA1REC.TA1PGMNM = "XSCY4S1 ";
    TA1REC.TA1LOCAT[1] = "IO2460  ";
    TA1REC.TA1LOCAT[3] = "SELECT  ";
    TA1REC.TA1LOCAT[4] = "SET     ";
    TA1REC.TA1DBASE = "DCYCLE  ";
    TA1REC.TA1TBLVU = "VCYADJ01";
    TA1REC.TA1TBLKE = CY4REC.CY4KEY;
    move SQLCA to ERRSQLCA withV60Compat;
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback();
    call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
    return;
  end

   /* ************************************************************/
   /* *** scan/retrieve/fetch first row                       ****/
   /* *** in order to detect not found (+100)                 ****/
   /* *** note: CSP closes cursor at end of set (+100)        ****/
   /* *** note: any loop processing must use this first row   ****/
   /* ***       and fetch the next row at the end of the loop ****/
   /* *** note: fetch handles return code correctly           ****/
   /* ************************************************************/

  XSCY4F1(); /* <=== fetch first row*/

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSCY4S1

// add : req loc.s   : 0
Function XSCY5A0()


   /* ************************************************************/
   /* *** add unique row to:  requested locations             ****/
   /* *** using the std module:  IO2440                       ****/
   /* *** note: use cyvrec to pass function & date ranges     ****/
   /* *** note: 0 return code means record already exists     ****/
   /* ***       = setup -803 return code                      ****/
   /* *** note: non-unique rows - duplicates possible         ****/
   /* *** note: IO process initializes zzzchgct to 0          ****/
   /* ************************************************************/

  CY5REC.ZZZSDT = X2CREC.X2CCURDT;
  CY5REC.ZZZCHGDT = X2CREC.X2CCURDT;
  CY5REC.ZZZCHGTM = X3CREC.X3CCURST;

  CYVREC.CYVFNC = "A ";

  call "IO2440" (CYVREC, SQLCA, CY5REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -911)
    TA1REC.TA1FUNC = "POST";
  else
    TA1REC.TA1FUNC = "RETN";
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1PGMNM = "XSCY5A0 ";
  TA1REC.TA1LOCAT[1] = "IO2440  ";
  TA1REC.TA1LOCAT[3] = "ADD     ";
  TA1REC.TA1LOCAT[4] = "ROW     ";
  TA1REC.TA1DBASE = "DCYCLE  ";
  TA1REC.TA1TBLVU = "VRQLOC01";
  TA1REC.TA1TBLKE = CY5REC.CY5KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSCY5A0

// perform select of cy7rec
Function XSCY7I0()


   /* ************************************************************/
   /* *** select unique row from:  cyc cnt loc                ****/
   /* *** using the std module:  IO2490                       ****/
   /* *** note: use cyvrec to pass function & date ranges     ****/
   /* ************************************************************/

  CYRREC.CYRFNC = "S ";

  call "IO2490" (CYRREC, SQLCA, CY7REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -911)
    TA1REC.TA1FUNC = "POST";
  else
    TA1REC.TA1FUNC = "RETN";
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1PGMNM = "XSCY7I0 ";
  TA1REC.TA1LOCAT[1] = "IO2490  ";
  TA1REC.TA1LOCAT[3] = "SELECT  ";
  TA1REC.TA1LOCAT[4] = "UNIQUE  ";
  TA1REC.TA1DBASE = "DCYCLE  ";
  TA1REC.TA1TBLVU = "VCYLOC01";
  TA1REC.TA1TBLKE = CY7REC.CY7KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSCY7I0

// add days (sub = neg. add)
Function XSCYSAD()


   /* ************************************************************/
   /* *** use the no. of days in the counter fld to indicate  ****/
   /* *** how many days to add (subtract if it is negative)   ****/
   /* *** to the current date & return in the cyw work date   ****/
   /* *** if error: setup fld attr.s & xxxlocid in appl.      ****/
   /* ************************************************************/

  set TA2REC empty;

  TA2REC.TA2DTOPT = "GETDATE ";
  TA2REC.TA2GRTYP = "G";
  TA2REC.TA2DYAOD = CYWREC.CYWCTR01;

  call "TA0040" (TA2REC) {isNoRefresh = yes, isExternal = yes};

  if (TA2REC.TA2RTNCD == 0)
    CYWREC.CYWWKDTE = TA2REC.TA2GRGGN;
    return;
  end

   /* ************************************************************/
   /* *** since ta0020 will not check 'getdate ' return code  ****/
   /* *** and we must prevent further processing,             ****/
   /* *** call ta0020 to display error and return to main menu****/
   /* ************************************************************/

  set TA1REC empty;

  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1TYPE = "APPL";
  TA1REC.TA1PGMNM = "XSCYSAD ";
  TA1REC.TA1LOC = "TA0040 - ADD DAYS TO DATE";
  SQLCA.SQLCAREC = TA2REC.TA2RTNCD;
  call "TA0020" (TA1REC, SQLCA) {isExternal = yes};

  XSPF4();

  exit program;

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSCYSAD

// compare start > end dates
Function XSCYSDC()


   /* ************************************************************/
   /* *** compare cyvrec dates to make sure that the          ****/
   /* *** start date is greater than the end date             ****/
   /* *** note: move start & end dates to cyvrec flds         ****/
   /* *** if error: setup fld attr.s & xxxlocid in appl.      ****/
   /* ************************************************************/

  CYWREC.CYWVERSW = "N";

  if (CYVREC.CYVSDT > CYVREC.CYVEDT)
    CYWREC.CYWVERSW = "Y";
    CYWREC.CYWMSGNO = 0022; /* <--- end > start msg*/
  end

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSCYSDC

// get cics userid
Function XSCYSID()


   /* ************************************************************/
   /* *** obtain the CICS userid for batch job submission     ****/
   /* ************************************************************/

  call "UT0200" (UT1REC) {isNoRefresh = yes, isExternal = yes}; /* Obtain user identification*/

  if (UT1REC.UT1RETCD != 0)
    TA1REC.TA1FUNC = "RETN";
    TA1REC.TA1TYPE = "APPL";
    TA1REC.TA1PGMNM = "XSCYSID ";
    TA1REC.TA1LOC = "OBTAIN CICS USER IDENTIFICATION";
    SQLCA.SQLCAREC = UT1REC.UT1GRPLV;
    call "TA0020" (TA1REC, SQLCA) {isNoRefresh = yes, isExternal = yes};
    CYWREC.CYWERRSW = "Y";
    CYWREC.XXXLOCID = "SIDA";
    CYWREC.CYWMSGNO = 001; /* <--- severe error msg*/
    return;
  end

  CYWREC.CAUSERID = UT1REC.UT1USRID;

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSCYSID

// purge tsqs
Function XSCYSPQ()


   /* ************************************************************/
   /* *** purge both the summary and detail tsq using ta0050  ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** purge summary tsq                                   ****/
   /* ************************************************************/

  TA5REC.TA5APPID = CYWREC.CYWSUMQU;
  TA5REC.TA5FNCCD = "P";

  call "TA0050" ("0001 ", TA5REC) {isNoRefresh = yes, isExternal = yes};

  if (TA5REC.TA5RTNCD == 0
   || TA5REC.TA5RTNCD == 4)
     /* ** next sentence ***/
  else
    CYWREC.CYWERRSW = "Y";
    CYWREC.XXXLOCID = "SPQA";
    CYWREC.CYWMSGNO = 0001; /* <--- severe error msg*/
     /* ** note: do not ezertn ***/
  end

   /* ************************************************************/
   /* *** if the detail tsq ID is greater than spaces,        ****/
   /* *** purge detail tsq (even if error above)              ****/
   /* ************************************************************/

  if (CYWREC.CYWDETQU > " ")
     /* ** next sentence ***/
  else
    return;
  end

  TA5REC.TA5APPID = CYWREC.CYWDETQU;
  TA5REC.TA5FNCCD = "P";

  call "TA0050" ("0001 ", TA5REC) {isNoRefresh = yes, isExternal = yes};

  if (TA5REC.TA5RTNCD == 0
   || TA5REC.TA5RTNCD == 4)
     /* ** next sentence ***/
  else
    CYWREC.CYWERRSW = "Y";
    CYWREC.XXXLOCID = "SPQB";
    CYWREC.CYWMSGNO = 0001; /* <--- severe error msg*/
  end

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSCYSPQ

// validate/xlate input date
Function XSCYSVT()


   /* ************************************************************/
   /* *** validate entered date using ta0040                  ****/
   /* *** note: ta0040 adds century                           ****/
   /* *** note: move input date to cywindte (mmddyy)          ****/
   /* *** note: get formated date from cywwkdte (ccyymmdd)    ****/
   /* *** if error: setup flds attr.s & xxxlocid in appl      ****/
   /* ************************************************************/

  CYWREC.CYWVERSW = "N";

  set TA2REC empty;

  TA2REC.TA2GRGAN = CYWREC.CYWINDTE;

  TA2REC.TA2DTOPT = "GREGGREG";
  TA2REC.TA2GRTYP = "A";

  call "TA0040" (TA2REC) {isNoRefresh = yes, isExternal = yes};

  if (TA2REC.TA2RTNCD == 0)
    CYWREC.CYWWKDTE = TA2REC.TA2GRGGN;
    return;
  end

  CYWREC.CYWVERSW = "Y";
  if (TA2REC.TA2RTNCD == 222)
    CYWREC.CYWMSGNO = 0021; /* <--- invalid date msg*/
  else
    CYWREC.CYWMSGNO = 0001; /* <--- severe error msg*/
  end

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSCYSVT

// xlate ccyymmdd to mmddyy
Function XSCYSXT()


   /* ************************************************************/
   /* *** translate ccyymmdd to mmddyy format                 ****/
   /* *** note: move ccyymmdd format to cywwkdte              ****/
   /* *** note: get mmddyy format from cywindte               ****/
   /* ************************************************************/

  CYWREC.CYWINYY = CYWREC.CYWWKYY;

  CYWREC.CYWINMM = CYWREC.CYWWKMM;

  CYWREC.CYWINDD = CYWREC.CYWWKDD;

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSCYSXT

// VDATRN01 row insert
Function XSDAS-DA1140-ADD()
  /* *********************************************************************/
  /* DA SYSTEM COMMON STATEMENT GROUP - insert for DADMIN.VDATRN01*/
  /* *********************************************************************/

  set SQLCA empty;
  WDA1140.WDA1140-DB2-FUNCTION = "A ";

  call "DA1140" (WDA1140, SQLCA, VDATRN01) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0) /* check for good rc*/
  /* continue*/
  else
    if (SQLCA.VAGen_SQLCODE == -911) /* database busy*/
      DAWREC.DAW-EDIT-ERROR-FL = "Y";
      DAWREC.DAW-INFO-MESSAGE = "DATABASE BUSY - PLEASE TRY AGAIN ";
    else
      if (SQLCA.VAGen_SQLCODE == -803) /* duplicate row*/
        DAWREC.DAW-EDIT-ERROR-FL = "Y";
        DAWREC.DAW-INFO-MESSAGE = "NO ADD/CHG ALLOWED; NEW TRANSACTION ROW ALREADY PROCESSED";
      else
        DAWREC.DAW-EDIT-ERROR-FL = "Y";

        TA1REC.TA1DBASE = "DADMIN  "; /* data base name*/
        TA1REC.TA1TBLVU = "VDATRN01"; /* table view*/
        TA1REC.TA1LOCAT[1] = "INSERT  ";
        TA1REC.TA1LOCAT[2] = "DA1140  ";
        XSDAS-DB2-ABEND-RB();
      end
    end
  end


  /* ************************/
  /* ***************** END XSDAS-DA1140-ADD  ******************************/
  /* ************************/
end // end XSDAS-DA1140-ADD

// VDATRN01 close cursor - C2
Function XSDAS-DA1140-CLOSE()
  /* *********************************************************************/
  /* DA SYSTEM COMMON STATEMENT GROUP - close cursor for DADMIN.VDATRN01*/
  /* *********************************************************************/

  set SQLCA empty;
  WDA1140.WDA1140-DB2-FUNCTION = "C2";

  call "DA1140" (WDA1140, SQLCA, VDATRN01) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0 /* check for good rc*/
   || SQLCA.VAGen_SQLCODE == 100) /* or not found*/
     /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == -911) /* database busy*/
      DAWREC.DAW-EDIT-ERROR-FL = "Y";
      DAWREC.DAW-INFO-MESSAGE = "DATABASE BUSY - PLEASE TRY AGAIN ";
    else
      DAWREC.DAW-EDIT-ERROR-FL = "Y";

      TA1REC.TA1DBASE = "DADMIN  "; /* data base name*/
      TA1REC.TA1TBLVU = "VDATRN01"; /* table view*/
      TA1REC.TA1LOCAT[1] = "CLOSE   ";
      TA1REC.TA1LOCAT[2] = "DA1140  ";
      XSDAS-DB2-ABEND-RB();
    end
  end


  /* *************************/
  /* ***************** END XSDAS-DA1140-CLOSE *****************************/
  /* *************************/
end // end XSDAS-DA1140-CLOSE

// VDATRN01 row delete
Function XSDAS-DA1140-DEL()
  /* *********************************************************************/
  /* DA SYSTEM COMMON STATEMENT GROUP - delete row for DADMIN.VDATRN01*/
  /* *********************************************************************/

  set SQLCA empty;
  WDA1140.WDA1140-DB2-FUNCTION = "D ";

  call "DA1140" (WDA1140, SQLCA, VDATRN01) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0 /* check for good rc*/
   || SQLCA.VAGen_SQLCODE == 100) /* or not found*/
     /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == -911) /* database busy*/
      DAWREC.DAW-EDIT-ERROR-FL = "Y";
      DAWREC.DAW-INFO-MESSAGE = "DATABASE BUSY - PLEASE TRY AGAIN ";
    else
      DAWREC.DAW-EDIT-ERROR-FL = "Y";

      TA1REC.TA1DBASE = "DADMIN  "; /* data base name*/
      TA1REC.TA1TBLVU = "VDATRN01"; /* table view*/
      TA1REC.TA1LOCAT[1] = "DELETE  ";
      TA1REC.TA1LOCAT[2] = "DA1140  ";
      XSDAS-DB2-ABEND-RB();
    end
  end


  /* ***********************/
  /* ***************** END XSDAS-DA1140-DEL *******************************/
  /* ***********************/
end // end XSDAS-DA1140-DEL

// VDATRN01 fetch cursor - N2
Function XSDAS-DA1140-FETCH()
  /* *********************************************************************/
  /* DA SYSTEM COMMON STATEMENT GROUP - fetch next row DADMIN.VDATRN01*/
  /* *********************************************************************/

  set SQLCA empty;
  WDA1140.WDA1140-DB2-FUNCTION = "N2";

  call "DA1140" (WDA1140, SQLCA, VDATRN01) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0 /* check for good rc*/
   || SQLCA.VAGen_SQLCODE == 100) /* or not found*/
     /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == -911) /* database busy*/
      DAWREC.DAW-EDIT-ERROR-FL = "Y";
      DAWREC.DAW-INFO-MESSAGE = "DATABASE BUSY - PLEASE TRY AGAIN ";
    else
      DAWREC.DAW-EDIT-ERROR-FL = "Y";

      TA1REC.TA1DBASE = "DADMIN  "; /* data base name*/
      TA1REC.TA1TBLVU = "VDATRN01"; /* table view*/
      TA1REC.TA1LOCAT[1] = "FETCH   ";
      TA1REC.TA1LOCAT[2] = "DA1140  ";
      XSDAS-DB2-ABEND-RB();
    end
  end


  /* *************************/
  /* ***************** END XSDAS-DA1140-FETCH *****************************/
  /* *************************/
end // end XSDAS-DA1140-FETCH

// VDATRN01 open cursor - S2
Function XSDAS-DA1140-OPEN()
  /* *********************************************************************/
  /* DA SYSTEM COMMON STATEMENT GROUP - Open cursor for DADMIN.VDATRN01*/
  /* *********************************************************************/

  VDATRN01.XXX-TBL-PFX = DAWREC.XXX-TBL-PFX;

  set SQLCA empty;
  WDA1140.WDA1140-DB2-FUNCTION = "S2";

  call "DA1140" (WDA1140, SQLCA, VDATRN01) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0 /* check for good rc*/
   || SQLCA.VAGen_SQLCODE == 100) /* or not found*/
     /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == -911) /* database busy*/
      DAWREC.DAW-EDIT-ERROR-FL = "Y";
      DAWREC.DAW-INFO-MESSAGE = "DATABASE BUSY - PLEASE TRY AGAIN ";
    else
      DAWREC.DAW-EDIT-ERROR-FL = "Y";

      TA1REC.TA1DBASE = "DADMIN  "; /* data base name*/
      TA1REC.TA1TBLVU = "VDATRN01"; /* table view*/
      TA1REC.TA1LOCAT[1] = "OPEN    ";
      TA1REC.TA1LOCAT[2] = "DA1140  ";
      XSDAS-DB2-ABEND-RB();
    end
  end


  /* ************************/
  /* ***************** END XSDAS-DA1140-OPEN ******************************/
  /* ************************/
end // end XSDAS-DA1140-OPEN

// VDATRN01 select unique row
Function XSDAS-DA1140-SEL()
  /* *********************************************************************/
  /* DA SYSTEM COMMON STATEMENT GROUP - select for DADMIN.VDATRN01*/
  /* *********************************************************************/

  set SQLCA empty;
  WDA1140.WDA1140-DB2-FUNCTION = "S ";

  call "DA1140" (WDA1140, SQLCA, VDATRN01) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0 /* check for good rc*/
   || SQLCA.VAGen_SQLCODE == 100) /* or not found*/
     /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == -911) /* database busy*/
      DAWREC.DAW-EDIT-ERROR-FL = "Y";
      DAWREC.DAW-INFO-MESSAGE = "DATABASE BUSY - PLEASE TRY AGAIN ";
    else
      DAWREC.DAW-EDIT-ERROR-FL = "Y";

      TA1REC.TA1DBASE = "DADMIN  "; /* data base name*/
      TA1REC.TA1TBLVU = "VDATRN01"; /* table view*/
      TA1REC.TA1LOCAT[1] = "SELECT  ";
      TA1REC.TA1LOCAT[2] = "DA1140  ";
      XSDAS-DB2-ABEND-RB();
    end
  end


  /* ************************/
  /* ***************** END XSDAS-DA1140-SEL  ******************************/
  /* ************************/
end // end XSDAS-DA1140-SEL

// VDATRN01 select unique row
Function XSDAS-DA1140-SEL-2()
  /* *********************************************************************/
  /* DA SYSTEM COMMON STATEMENT GROUP - select for DADMIN.VDATRN01*/
  /* *********************************************************************/

  set SQLCA empty;
  WDA1140.WDA1140-DB2-FUNCTION = "S*";

  call "DA1140" (WDA1140, SQLCA, VDATRN01) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0   /* check for good rc*/
   || SQLCA.VAGen_SQLCODE == 100 /* or not found*/
   || SQLCA.VAGen_SQLCODE == -803) /* more than one found*/
     /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == -911) /* database busy*/
      DAWREC.DAW-EDIT-ERROR-FL = "Y";
      DAWREC.DAW-INFO-MESSAGE = "DATABASE BUSY - PLEASE TRY AGAIN ";
    else
      DAWREC.DAW-EDIT-ERROR-FL = "Y";

      TA1REC.TA1DBASE = "DADMIN  "; /* data base name*/
      TA1REC.TA1TBLVU = "VDATRN01"; /* table view*/
      TA1REC.TA1LOCAT[1] = "SELECT  ";
      TA1REC.TA1LOCAT[2] = "DA1140  ";
      XSDAS-DB2-ABEND-RB();
    end
  end


  /* ************************/
  /* ***************** END XSDAS-DA1140-SEL  ******************************/
  /* ************************/
end // end XSDAS-DA1140-SEL-2

// VDATRN01 update row
Function XSDAS-DA1140-UPD()
  /* *********************************************************************/
  /* DA SYSTEM COMMON STATEMENT GROUP - update for DADMIN.VDATRN01*/
  /* *********************************************************************/

  set SQLCA empty;
  WDA1140.WDA1140-DB2-FUNCTION = "U ";

  call "DA1140" (WDA1140, SQLCA, VDATRN01) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0 /* check for good rc*/
  )                            /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == -911) /* database busy*/
      DAWREC.DAW-EDIT-ERROR-FL = "Y";
      DAWREC.DAW-INFO-MESSAGE = "DATABASE BUSY - PLEASE TRY AGAIN ";
    else
      DAWREC.DAW-EDIT-ERROR-FL = "Y";

      TA1REC.TA1DBASE = "DADMIN  "; /* data base name*/
      TA1REC.TA1TBLVU = "VDATRN01"; /* table view*/
      TA1REC.TA1LOCAT[1] = "UPDATE  ";
      TA1REC.TA1LOCAT[2] = "DA1140  ";
      XSDAS-DB2-ABEND-RB();
    end
  end


  /* ************************/
  /* ***************** END XSDAS-DA1140-UPD  ******************************/
  /* ************************/
end // end XSDAS-DA1140-UPD

// Abend with rollback
Function XSDAS-DB2-ABEND-RB()
  /* *********************************************************************/
  /* DA SYSTEM COMMON STATEMENT GROUP*/
  /* DB2 return with rollback - will dxfr to main menu*/
  /*  */
  /* This stmt grp will rollback all updates since the last*/
  /* commit, converse or dxfr/xfer.*/
  /*  */
  /* The following fields need to be filled in by the*/
  /* calling process or statement group before entering this routine*/
  /* ta1locat(1) = transaction type  ie: 'ss' 'sn'*/
  /* ta1rec.ta1dbase = data base name (DCORP, etc..)*/
  /* ta1rec.ta1tblvu = data base view (VXOT0001, etc..)*/
  /* *********************************************************************/

  set ERRSQLCA empty;
  move SQLCA to ERRSQLCA withV60Compat;
  TA1REC.TA1TYPE = "DB2";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = COMMAREA.CACURRAP; /* current application*/
  TA1REC.TA1TBLKE = DAWREC.XXX-TBL-PFX; /* move key*/
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback(); /* rollback*/
  try
    call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
  end
  XSPF4();
  exit program; /* master menu failure*/

  /* *********************/
  /* ***************** END XSDAS-RB-ABEND ******************************/
  /* *********************/
end // end XSDAS-DB2-ABEND-RB

// Format DB2 date to MMDDYY
Function XSDAS-FMT-DB2-MDCY()
  /* ******************************************************************/
  /* DA SYSTEM COMMON STATEMENT GROUP - Convert db2 date to MDCY*/
  /* ******************************************************************/

  /* The calling process or statement group must move the database date*/
  /* to DAWREC.DAW-DATE-COMP before entering this routine*/

  DAWREC.DAW-DATE-MDCY-MM = DAWREC.DAW-DATE-COMP-MM;
  DAW-DATE-DASH-1 = "/";
  DAWREC.DAW-DATE-MDCY-DD = DAWREC.DAW-DATE-COMP-DD;
  DAW-DATE-DASH-2 = "/";
  DAWREC.DAW-DATE-MDCY-CC = DAWREC.DAW-DATE-COMP-CC;
  DAWREC.DAW-DATE-MDCY-YY = DAWREC.DAW-DATE-COMP-YY;

  /* The calling process or statement group must move the formated date*/
  /* from DAWREC.DAW-DATE-MDCY after returning from this routine*/
  /* **********************/
  /* ******************* END XSDAS-TO-MMDDYY *****************************/
  /* **********************/
end // end XSDAS-FMT-DB2-MDCY

// PRINT STATEMENT GROUP
Function XSDAS-PRINT-TABLE()
  /* **********************************************************************/
  /* Creates the JCL to print a table. JCL lines are created and stored*/
  /* in a table in XSDAW01. After the table is created its is moved to*/
  /* XSDAW02 - the passing record for TA0070.*/
  /* **********************************************************************/
  /* * * * change class to 'p' and msgclass to j  for production*/

  XSDAW01.XSDAW-JOB-CARD = "//";
  XSDAW01.XSDAW-JOB-NAME = "DA4011";
  XSDAW01.XSDAW-JOB-CARD-INFO = "   JOB (DV,MUR2),'TBLPRINT',";
  XSDAW01.XSDAW-JCL-LINE[1] = XSDAW01.XSDAW-JOB-CARD-LINE;

  /* MOVE "//             CLASS=A," TO XSDAW01.XSDAW-JCL-LINE(2);/* test*/
  XSDAW01.XSDAW-JCL-LINE[2] = "//             CLASS=P,"; /* prod*/
  /* MOVE "//             MSGCLASS=T," TO XSDAW01.XSDAW-JCL-LINE(3);/* test*/
  XSDAW01.XSDAW-JCL-LINE[3] = "//             MSGCLASS=J"; /* prod*/

  XSDAW01.XSDAW-JCL-LINE[4] = "//* ";
  XSDAW01.XSDAW-JCL-LINE[5] = "//* ";

  XSDAW01.XSDAW-OUTPUT-CARD-INFO = "/*OUTPUT RTE1 DEST=";
  if (DAWREC.DAW-PRINTER-ID == " ")
    XSDAW01.XSDAW-OUTPUT-DEST = "LOCAL";
  else
    XSDAW01.XSDAW-OUTPUT-DEST = DAWREC.DAW-PRINTER-ID;
  end
  XSDAW01.XSDAW-JCL-LINE[6] = XSDAW01.XSDAW-OUTPUT-LINE;

  /* MOVE "/*JOBPARM PROCLIB=TEST" TO XSDAW01.XSDAW-JCL-LINE(7);/* for test*/
  XSDAW01.XSDAW-JCL-LINE[7] = "//* "; /* for prod*/

  XSDAW01.XSDAW-JCL-LINE[8] = "//* ";

  XSDAW01.XSDAW-JCL-LINE[9] = "//JOBLIB   DD  DSN=PROD.ONETIME.LOADLIB,DISP=SHR";
  XSDAW01.XSDAW-JCL-LINE[10] = "//         DD  DSN=PROD.COB2.LOADLIB,DISP=SHR";
  XSDAW01.XSDAW-JCL-LINE[11] = "//         DD  DSN=MVS.DSNT.DSNLOAD,DISP=SHR";

  XSDAW01.XSDAW-JCL-LINE[12] = "//* ";

  XSDAW01.XSDAW-PROC-LINE-INFO = "//S0010   EXEC ";
  XSDAW01.XSDAW-PROC = "DA4011";
  XSDAW01.XSDAW-PROC-COMMA = ","; /* for test*/
  XSDAW01.XSDAW-JCL-LINE[13] = XSDAW01.XSDAW-PROC-LINE;

  /* MOVE "//             TYPE='T.'," TO XSDAW01.XSDAW-JCL-LINE(14);/* test*/
  XSDAW01.XSDAW-JCL-LINE[14] = "//*                      "; /* prod*/

  /* MOVE "//             LEVEL='TEST.'," TO XSDAW01.XSDAW-JCL-LINE(15);*/
                                   /* test*/
  XSDAW01.XSDAW-JCL-LINE[15] = "//*                      "; /* prod*/

  /* MOVE "//             OUT='T'," TO XSDAW01.XSDAW-JCL-LINE(16);*/
                                   /* test*/
  XSDAW01.XSDAW-JCL-LINE[16] = "//*                      "; /* prod*/

  XSDAW01.XSDAW-PARM-LINE-INFO = "//             PPARM='";
  XSDAW01.XSDAW-PARM = DAWREC.DAW-PRINT-PARM;
  XSDAW01.XSDAW-PARM-COMMA = "'";
  XSDAW01.XSDAW-JCL-LINE[17] = XSDAW01.XSDAW-PARM-LINE;

  XSDAW01.XSDAW-JCL-LINE[18] = "//*";

  sysVar.arrayIndex = 1;
  while (sysVar.arrayIndex <= 18)
    XSDAW02.XSDAW-JCL-LINE[sysVar.arrayIndex] = XSDAW01.XSDAW-JCL-LINE[sysVar.arrayIndex];
    sysVar.arrayIndex = sysVar.arrayIndex + 1;
  end

  XSDAW02.XSDAW-RETURN-CODE = 0;
  XSDAW02.XSDAW-LINE-COUNT = 18;
  call "TA0070" (XSDAW02) {isNoRefresh = yes, isExternal = yes};
  if (XSDAW02.XSDAW-RETURN-CODE != 0)
    DAWREC.DAW-INFO-MESSAGE = "PRINT REQUEST FAILED - TABLE NOT PRINTED";
  else
    DAWREC.DAW-INFO-MESSAGE = "PRINT REQUEST SUBMITTED - TABLE WILL BE PRINTED";
  end

  /* ************************/
  /* ****************** END XSDAS-PRINT-TABLE *****************************/
  /* ************************/
end // end XSDAS-PRINT-TABLE

// Set VDATRN01 status to pending
Function XSDAS-SET-STATUS()
  /* ******************************************************************/
  /* set status to 'pending'*/
  /* ******************************************************************/

  XSDAS-DA1140-SEL(); /* Select the transaction*/

  if (VDATRN01.DA-CHNG-STAT-IND == "E") /* Still in edit status*/

    VDATRN01.DA-CHNG-STAT-IND = "P";
    XSDAS-DA1140-UPD(); /* Update the transaction*/

  end

  /* ***********************/
  /* ****************** END DA09S-SET-STATUS ***************************/
  /* ***********************/
end // end XSDAS-SET-STATUS

// Create message if XSEXIT fails
Function XSDAS-XSEXIT-CAMSG()
  /* ******************************************************************/
  /* DA SYSTEM COMMON STATEMENT GROUP*/
  /* ******************************************************************/
  /* XSEXIT did not allow a transfer so create the appropriate error*/
  /* message depending on the return code.*/
  /* 0   good return code - transfer authorized*/
  /* 3   no rec found - applicaton non-existant*/
  /* 4   no rec found - transfer not authorized*/
  /* 9   unknown file error*/
  /* ******************************************************************/

  if (COMMAREA.CASECRC == 3)
    COMMAREA.CAMSG = "FASTPATH OPTION IS NOT A VALID APPLICATION";
  end

  if (COMMAREA.CASECRC == 4)
    COMMAREA.CAMSG = "FASTPATH OPTION IS NOT AUTHORIZED ";
  end

  if (COMMAREA.CASECRC == 9)
    COMMAREA.CAMSG = "UNKNOWN SECURITY ERROR - CALL HELP DESK";
  end

  /* *************************/
  /* ***************** END XSDAS-XSEXIT-CAMSG *************************/
  /* *************************/
end // end XSDAS-XSEXIT-CAMSG

// Exit to another application
Function XSDVS-EXIT()
   /* ------------------------------------------------------------*/
   /* Set the application to be invoked for PF1 or PF4.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf1) /* PF1 was pressed*/
    COMMAREA.CATOAP = "GD01"; /* Goal Documentation*/
  end

  if (converseVar.eventKey is pf4) /* PF4 was pressed*/
    COMMAREA.CATOAP = "MN0M"; /* Master Menu*/
  end

   /* ------------------------------------------------------------*/
   /* Save the system work record in the COMMAREA user area.*/
   /* ------------------------------------------------------------*/

  if (COMMAREA.CATOSYS == COMMAREA.CACURSYS) /* Same system*/

    COMMAREA.CAUSERA = DVWREC.CAUSERA; /* Save work record*/
  else
    COMMAREA.CAUSERA = " "; /* Clear user area*/

  end

   /* ------------------------------------------------------------*/
   /* Transfer control to the specified application.*/
   /* ------------------------------------------------------------*/

  XSEXIT(); /* Exit to another application*/

  DVWREC.XXX-MSG-LOC-ID = "XSEXIT"; /* Message location*/

   /* ------------------------------------------------------------*/
   /* Reestablish the COMMAREA application and item fields.*/
   /* ------------------------------------------------------------*/

  COMMAREA.CAEZSG3 = "0"; /* Force zero third character*/
  COMMAREA.CACURRAP = COMMAREA.CAEZSAP; /* Current application*/

  if (converseVar.eventKey is pfkey) /* PF key was pressed*/

    COMMAREA.CATOAP = " "; /* Clear TO application*/

    if (converseVar.eventKey is pf1) /* PF1 was pressed*/
      COMMAREA.CAITEM = " "; /* Clear map name from item*/
    end

  end


end // end XSDVS-EXIT

// application entry validation
Function XSENTRY()



   /* ************************************************************/
      /* this statement group is used to check to see that the **/
      /* user has gone through the proper security checks.  if **/
      /* they have not then the application is immediately     **/
      /* stopped.                                              **/
   /* ************************************************************/


  if (COMMAREA.CASYSINT != "CSP") /* check to see that we came from menu*/
    exit program; /* if not inited by menu then terminate appl*/
  end



end // end XSENTRY

// Exit to another application
Function XSEPS-EXIT()
   /* ------------------------------------------------------------*/
   /* Set the application to be invoked for PF4.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf4) /* PF4 was pressed*/

    COMMAREA.CATOAP = "MN0M"; /* Indicate Master Menu*/

  end


   /* ------------------------------------------------------------*/
   /* Save the application user area in the COMMAREA if indicated.*/
   /* ------------------------------------------------------------*/

   /* Going to an EP app from an EP app*/
  if (COMMAREA.CATOSYS == "EP" /* Xfer in EP system*/
   && COMMAREA.CAFRMSYS == "EP")

    COMMAREA.CAUSERA = EPWREC.EPW-GROUP; /* Save user area*/

  end


   /* ------------------------------------------------------------*/
   /* Transfer control to the specified application.*/
   /* ------------------------------------------------------------*/

  XSEXIT(); /* Exit to another application*/


   /* ------------------------------------------------------------*/
   /* Reestablish the COMMAREA application and item fields.*/
   /* ------------------------------------------------------------*/

  COMMAREA.CAEZSG3 = "0"; /* Force zero third character*/
  COMMAREA.CACURRAP = COMMAREA.CAEZSAP; /* CURR application*/

  if (converseVar.eventKey is pfkey) /* PF key was pressed*/

    COMMAREA.CATOAP = " "; /* Clear TO application*/

  end


end // end XSEPS-EXIT

// transfer to the requested appl
Function XSEXIT()



   /* *************************************************************/
      /* this statement group passes the 'commarea' record to*/
      /* the security checking application ('mn0s'). the security*/
      /* application then validates the 'causerid' and the*/
      /* 'catoap' fields within the 'commarea' record.  it then*/
      /* sets the 'casecrc' return code field based upon its*/
      /* validation and then returns control back to the state-*/
      /* ment group.  if 'commarea.casecrc' = 0 (security check*/
      /* ok) then update the appropriate application fields and*/
      /* transfer ('xfer') to the requested application.*/
      /* if 'commarea.casecrc' ne 0 (security check failed) then*/
      /* control will be return to where the statement group was*/
      /* called from and the 'commarea.camsg' (message field)*/
      /* will contain a description as to why the transfer could*/
      /* not occur.*/
   /* *************************************************************/

  try
    call "MN0S" (COMMAREA) {isNoRefresh = yes};
  end
  if (COMMAREA.CASECRC == 0
   && sysVar.errorCode == "00000000")
    if (COMMAREA.CACURSYS == COMMAREA.CATOSYS)
      if (COMMAREA.CACURSYS == "MN")
        COMMAREA.CAFROMAP = COMMAREA.CACURRAP;
        COMMAREA.CACURRAP = COMMAREA.CATOAP;
        COMMAREA.CATOAP = " ";
        sysVar.transferName = COMMAREA.CACURRAP;
        transfer to transaction sysVar.transferName passing COMMAREA;
      else
        VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
        VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
        sysLib.commit();
        VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
        
        COMMAREA.CAFROMAP = COMMAREA.CACURRAP;
        COMMAREA.CACURRAP = COMMAREA.CATOAP;
        COMMAREA.CATOAP = " ";
        sysVar.transferName = COMMAREA.CACURRAP;
        transfer to program sysVar.transferName passing COMMAREA;
      end
    else
      COMMAREA.CAFROMAP = COMMAREA.CACURRAP;
      COMMAREA.CACURRAP = COMMAREA.CATOAP;
      COMMAREA.CATOAP = " ";
      sysVar.transferName = COMMAREA.CACURRAP;
      transfer to transaction sysVar.transferName passing COMMAREA;
    end
  end


      /* check for bad csp system return code*/

  if (COMMAREA.CASECRC == 0
   && sysVar.errorCode != "00000000")
    COMMAREA.CAMSG = "BAD SYSTEM RETURN CODE FROM SECURITY MODULE";
  end



end // end XSEXIT

// Exit to another application
Function XSFBS01()
   /* ------------------------------------------------------------*/
   /* Set the application to be invoked for PF1,pf4 or PF5.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf1) /* PF1 was pressed*/

    COMMAREA.CATOAP = "GD01"; /* Indicate Goal Documentation*/

  end

  if (converseVar.eventKey is pf4) /* PF4 was pressed*/

    COMMAREA.CATOAP = "MN0M"; /* Indicate Master Menu*/

  end


  if (converseVar.eventKey is pf5) /* PF5 was pressed*/

    COMMAREA.CATOAP = "FY0M"; /* Production Menu*/

  end


   /* ------------------------------------------------------------*/
   /* Save the application user area in the COMMAREA.*/
   /* ------------------------------------------------------------*/

  if (COMMAREA.CATOSYS == "FB") /* Transfer within same system*/

    COMMAREA.CAUSERA = FBWREC.FBWGROUP; /* Save user area*/
  else
    COMMAREA.CAUSERA = " "; /* Clear user area*/

  end

   /* ------------------------------------------------------------*/
   /* Transfer control to the specified application.*/
   /* ------------------------------------------------------------*/

  XSEXIT(); /* Exit to another application*/

   /* ------------------------------------------------------------*/
   /* If transfer failed, return an error to the calling process.*/
   /* ------------------------------------------------------------*/


  if (COMMAREA.CASECRC == 3 /* Application not found*/
   || COMMAREA.CASECRC == 4) /* or transfer not allowed*/

    converseLib.validationFailed(103); /* Indicate not allowed*/

  else
    converseLib.validationFailed(1); /* Indicate system error*/

  end


end // end XSFBS01

// Exit to another application
Function XSFD001()
   /* ------------------------------------------------------------*/
   /* Set the application to be invoked for PF1 or PF4.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf1) /* PF1 was pressed*/
    COMMAREA.CATOAP = "GD01"; /* Indicate Goal Documentation*/
  end

  if (converseVar.eventKey is pf4) /* PF4 was pressed*/
    COMMAREA.CATOAP = "MN0M"; /* Indicate Master Menu*/
  end

   /* ------------------------------------------------------------*/
   /* Save the application user area in the COMMAREA.*/
   /* ------------------------------------------------------------*/

  if (COMMAREA.CATOSYS == "FD") /* Transfer within same system*/

    COMMAREA.CAUSERA = FDWREC.CAUSERA; /* Save user area*/
  else
    COMMAREA.CAUSERA = " "; /* Clear user area*/

  end

   /* ------------------------------------------------------------*/
   /* Transfer control to the specified application.*/
   /* ------------------------------------------------------------*/

  XSEXIT(); /* Exit to another application*/

   /* ------------------------------------------------------------*/
   /* If transfer failed, return an error to the calling process.*/
   /* ------------------------------------------------------------*/

  if (COMMAREA.CASECRC == 3 /* Application not found*/
   || COMMAREA.CASECRC == 4) /* or transfer not allowed*/

    converseLib.validationFailed(6); /* Indicate not allowed*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/

  end


end // end XSFD001

// summarize vfhcat01 quantities
Function XSFFS-FF5500()

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* This subroutine will access the Footwear Category History*/
   /* table using product type code and summarizes the quantity*/
   /* fields in the table for the date range specified by the*/
   /* calling process.  The type group code is moved to the type*/
   /* code.*/

   /* The product type group code, the product category code,*/
   /* the life cycle code, the quality code, the order type group*/
   /* code, and the production national account flag code must*/
   /* be specified by the calling process in FH3REC.*/

   /* The range beginning month and the range ending month must*/
   /* be specified by the calling process in FFFREC.*/

   /* The name of the calling process must be move to TA1PGMNM*/
   /* in TA1REC, for Error Diagnosis Reporting.*/

   /* *** Code the following before this is executed:         ****/
   /* ***                                                     ****/
   /* ***   FH3REC.XPRCD:    The product type group code or   ****/
   /* ***                    '*' to select codes 01 and 02.   ****/
   /* ***                                                     ****/
   /* ***   FH3REC.XPCCD:    The product category code.       ****/
   /* ***                                                     ****/
   /* ***   FH3REC.XLCCD:    The life cycle code.             ****/
   /* ***                                                     ****/
   /* ***   FH3REC.XQACD:    The quality code.                ****/
   /* ***                                                     ****/
   /* ***   FH3REC.YSMXOT:   The order type group code or     ****/
   /* ***                    '*' to select all codes.         ****/
   /* ***                                                     ****/
   /* ***   FH3REC.FH1PNAC:  The national account flag or     ****/
   /* ***                    '*' to select all flags.         ****/
   /* ***                                                     ****/
   /* ***   FFFREC.FFFBEGMO: The range beginning month.       ****/
   /* ***                                                     ****/
   /* ***   FFFREC.FFFENDMO: The range ending month.          ****/
   /* ***                                                     ****/
   /* ***   TA1REC.TA1PGMNM: The name of the calling process, ****/
   /* ***                    for Error Diagnosis Reporting.   ****/

   /* The subroutine will return summarized quantities in FH3REC.*/

   /* This subroutine will do any required Error Diagnosis*/
   /* Reporting to TA0020.  The calling process does not need to*/
   /* do any Error Diagnosis Reporting.*/

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* ------------------------------------------------------------*/
   /* Call the subroutine to summarize the selected quantities.*/
   /* ------------------------------------------------------------*/

  try
    call "FF5500" (FFFREC, SQLCA, FH3REC, TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes};
  end

   /* ------------------------------------------------------------*/
   /* If call was successful, return to the calling process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* If data not available, indicate data in use by another.*/
   /* ------------------------------------------------------------*/

  FFWREC.XXXMODID = "X50"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    converseLib.validationFailed(47); /* Data in use by another*/

    exit stack; /* Exit to display map*/

  end

   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/

     /* NEXT SENTENCE*/

  else

    TA1REC.TA1TYPE = "APPL"; /* Type of error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    TA1REC.TA1LOC = "XSFFS SUM VFHCAT01 QUANTITIES";
    TAEREC.TAEDESC1 = "SUBROUTINE FF5500 CALL WAS NOT SUCCESSFUL";
    TAEREC.TAEDESC2 = sysVar.errorCode; /* CSP return code*/

  end

  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback(); /* Roll back all changes*/

  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

  converseLib.validationFailed(1); /* System error occurred*/

  exit stack; /* Exit to display map*/


end // end XSFFS-FF5500

// fetch dfhist.vctshp01 rec
Function XSFFS-FF5520()

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* This subroutine will access the Footwear Category Shipments*/
   /* Table using product type group code and summarize the*/
   /* quantity fields in the table for the date range specified*/
   /* by the calling process.*/

   /* The product type group code, the product category code, the*/
   /* life cycle code, the quality code, and the order type group*/
   /* code must be specified by the calling process in FH6REC.*/

   /* The range beginning month and the range ending month must*/
   /* be specified by the calling process in FFFREC.*/

   /* The name of the calling process must be move to TA1PGMNM*/
   /* in TA1REC, for Error Diagnosis Reporting.*/

   /* *** Code the following before this is executed:         ****/
   /* ***                                                     ****/
   /* ***   FH6REC.XPRCD:    The product type group code or   ****/
   /* ***                    '*' to select codes 01 and 02.   ****/
   /* ***                                                     ****/
   /* ***   FH6REC.XPCCD:    The product category code.       ****/
   /* ***                                                     ****/
   /* ***   FH6REC.XLCCD:    The life cycle code.             ****/
   /* ***                                                     ****/
   /* ***   FH6REC.XQACD:    The quality code.                ****/
   /* ***                                                     ****/
   /* ***   FH6REC.YSMXOT:   The order type group code or     ****/
   /* ***                    '*' to select all codes.         ****/
   /* ***                                                     ****/
   /* ***   FFFREC.FFFBEGMO: The range beginning month.       ****/
   /* ***                                                     ****/
   /* ***   FFFREC.FFFENDMO: The range ending month.          ****/
   /* ***                                                     ****/
   /* ***   TA1REC.TA1PGMNM: The name of the calling process, ****/
   /* ***                    for Error Diagnosis Reporting.   ****/

   /* The subroutine will return summarized quantities in FH6REC.*/

   /* This subroutine will do any required Error Diagnosis*/
   /* Reporting to TA0020.  The calling process does not need to*/
   /* do any Error Diagnosis Reporting.*/

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* ------------------------------------------------------------*/
   /* Call the subroutine to summarize the selected quantities.*/
   /* ------------------------------------------------------------*/

  try
    call "FF5520" (FFFREC, SQLCA, FH6REC, TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes};
  end

   /* ------------------------------------------------------------*/
   /* If call was successful, return to the calling process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* If data not available, indicate data in use by another.*/
   /* ------------------------------------------------------------*/

  FFWREC.XXXMODID = "X52"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    converseLib.validationFailed(47); /* Data in use by another*/

    exit stack; /* Exit to display map*/

  end

   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/

     /* NEXT SENTENCE*/

  else

    TA1REC.TA1TYPE = "APPL"; /* Type of error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    TA1REC.TA1LOC = "XSFFS-FF5520 SUM VCTSHP01 QUANTITIES";
    TAEREC.TAEDESC1 = "SUBROUTINE FF5520 CALL WAS NOT SUCCESSFUL";
    TAEREC.TAEDESC2 = sysVar.errorCode; /* CSP return code*/

  end

  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback(); /* Roll back all changes*/

  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

  converseLib.validationFailed(1); /* System error occurred*/

  exit stack; /* Exit to display map*/


end // end XSFFS-FF5520

// obtain nd mo sls from vlnshp
Function XSFFS-FF5550()
   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* This subroutine will access the Footwear Line Shipments*/
   /* Table using product line code and summarizes the quantity*/
   /* fields in the table for the date range specified by the*/
   /* calling process.*/

   /* The the product type code, the product line code, the*/
   /* life cycle code, the quality code, and the order type group*/
   /* code must be specified by the calling process in FHAREC.*/

   /* The range beginning month and the range ending month must*/
   /* be specified by the calling process in FFFREC.*/

   /* The name of the calling process must be move to TA1PGMNM*/
   /* in TA1REC, for Error Diagnosis Reporting.*/

   /* *** Code the following before this is executed:         ****/
   /* ***                                                     ****/
   /* ***   FHAREC.XPRCD:    The product type code or '*' to  ****/
   /* ***                    select codes 01 and 02.          ****/
   /* ***                                                     ****/
   /* ***   FHAREC.XPLCD:    The product line code.           ****/
   /* ***                                                     ****/
   /* ***   FHAREC.XLCCD:    The life cycle code or           ****/
   /* ***                    '*' to select codes 10 and 20.   ****/
   /* ***                                                     ****/
   /* ***   FHAREC.XQACD:    The quality code or              ****/
   /* ***                    '*' to select codes 01 and 02.   ****/
   /* ***                                                     ****/
   /* ***   FHAREC.YSMXOT:   The order type group code or     ****/
   /* ***                    '*' to select all codes.         ****/
   /* ***                                                     ****/
   /* ***   FFFREC.FFFBEGMO: The range beginning month.       ****/
   /* ***                                                     ****/
   /* ***   FFFREC.FFFENDMO: The range ending month.          ****/
   /* ***                                                     ****/
   /* ***   TA1REC.TA1PGMNM: The name of the calling process, ****/
   /* ***                    for Error Diagnosis Reporting.   ****/

   /* The subroutine will return summarized quantities in FHAREC.*/

   /* This subroutine will do any required Error Diagnosis*/
   /* Reporting to TA0020.  The calling process does not need to*/
   /* do any Error Diagnosis Reporting.*/

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* ------------------------------------------------------------*/
   /* Call the subroutine to summarize the selected quantities.*/
   /* ------------------------------------------------------------*/

  try
    call "FF5550" (FFFREC, SQLCA, FHAREC, TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes};
  end

   /* ------------------------------------------------------------*/
   /* If call was successful, return to the calling process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* If data not available, indicate data in use by another.*/
   /* ------------------------------------------------------------*/

  FFWREC.XXXMODID = "X55"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    converseLib.validationFailed(47); /* Data in use by another*/

    exit stack; /* Exit to display map*/

  end

   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that an unexpected error has occurred.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/

     /* NEXT SENTENCE*/

  else

    TA1REC.TA1TYPE = "APPL"; /* Type of error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    TA1REC.TA1LOC = "XSFFS SUM VLNSHP01 QUANTITIES";
    TAEREC.TAEDESC1 = "SUBROUTINE FF5550 CALL WAS NOT SUCCESSFUL";
    TAEREC.TAEDESC2 = sysVar.errorCode; /* CSP return code*/

  end

  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback(); /* Roll back all changes*/

  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

  converseLib.validationFailed(1); /* Unexpected error occurred*/

  exit stack; /* Exit to display map*/


end // end XSFFS-FF5550

// Summarize VOQSTY01 quantities
Function XSFFS-FF5570()

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* This subroutine will access the Footwear History Open Quantity*/
   /* Table and summarize the quantity fields either by style/color*/
   /* or style group for the date range specified by the calling*/
   /* process.*/

   /* The below for the specific fields that need to be formatted*/
   /* for this call.*/

   /* The range beginning month and the range ending month must*/
   /* be specified by the calling process in FFFREC.*/

   /* The name of the calling process must be move to TA1PGMNM*/
   /* in TA1REC, for Error Diagnosis Reporting.*/

   /* *** Code the following before this is executed:         ****/
    /* ***                                                     ****/
   /* ***   fh1rec.SY1STNBR  The style number or style group  ****/
   /* ***                    number                           ****/
   /* ***                                                     ****/
   /* ***   fh1rec.SY2CLRID  The color code                   ****/
   /* ***                                                     ****/
   /* ***   fh1rec.XDMCD:    The product type group code or   ****/
   /* ***                    '*' or dim cd                    ****/
   /* ***                                                     ****/
   /* ***   fh1rec.XDVCD:    The product category code.       ****/
   /* ***                                                     ****/
   /* ***   fh1rec.XLCCD:    The life cycle code.             ****/
   /* ***                                                     ****/
   /* ***   fh1rec.XQACD:    The quality code.                ****/
   /* ***                                                     ****/
   /* ***   fh1rec.YSMXOT:   The order type group code or     ****/
   /* ***                    '*' to select all codes.         ****/
   /* ***                                                     ****/
   /* ***   fh1rec.FH1PNAC   The national account flag        ****/
   /* ***                                                     ****/
   /* ***   FFFREC.FFFBEGMO: The range beginning month.       ****/
   /* ***                                                     ****/
   /* ***   FFFREC.FFFENDMO: The range ending month.          ****/
   /* ***                                                     ****/
   /* ***   TA1REC.TA1PGMNM: The name of the calling process, ****/
   /* ***                    for Error Diagnosis Reporting.   ****/

   /* The subroutine will return summarized quantities in fh1rec.*/

   /* This subroutine will do any required Error Diagnosis*/
   /* Reporting to TA0020.  The calling process does not need to*/
   /* do any Error Diagnosis Reporting.*/

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* ------------------------------------------------------------*/
   /* Sum quantities from dfhist.voqsty01.*/
   /* ------------------------------------------------------------*/

  try
    call "FF5570" (FFFREC, SQLCA, FH1REC) {isNoRefresh = yes, isExternal = yes};
  end /* Sum quantities*/

   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/

    if (SQLCA.VAGen_SQLCODE == 0 /* Normal return code*/
     || SQLCA.VAGen_SQLCODE == -305) /* or no rows selected*/
      if (SQLCA.VAGen_SQLCODE == -305)
        FH1REC.FH1PAQTY = 0; /* initialize pre-alloc qty*/
        FH1REC.FH1ALQTY = 0; /* initialize alloc qty*/
      end

      return; /* Return to previous process*/

    end

  end

   /* ------------------------------------------------------------*/
   /* If data not available, indicate data in use by another.*/
   /* ------------------------------------------------------------*/

  FFWREC.XXXMODID = "X57"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    converseLib.validationFailed(47); /* Data in use by another*/

    exit stack; /* Exit to display map*/

  end

   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that an unexpected error has occurred.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/

     /* NEXT SENTENCE*/

  else

    TA1REC.TA1TYPE = "APPL"; /* Type of error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    TA1REC.TA1LOC = "XSFFS SUM VOQSTY01 QUANTITIES";
    TAEREC.TAEDESC1 = "SUBROUTINE FF5570 CALL WAS NOT SUCCESSFUL";
    TAEREC.TAEDESC2 = sysVar.errorCode; /* CSP return code*/

  end

  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback(); /* Roll back all changes*/

  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

  converseLib.validationFailed(1); /* Unexpected error occurred*/

  exit stack; /* Exit to display map*/


end // end XSFFS-FF5570

// close csr for dfbuy.vcmppg01
Function XSFFS-VCMPPG01-C2()
   /* ------------------------------------------------------------*/
   /* Close the selected set of table rows.*/
   /* ------------------------------------------------------------*/

  try
    call "VCMPPG01" ("C2", SQLCA, VCMPPG01) {isNoRefresh = yes, isExternal = yes};
  end

   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/
    return; /* Return to previous process*/
  end

   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  FFWREC.XXXMODID = "VCM"; /* Module identification*/
  converseLib.validationFailed(01); /* Indicate system error*/

  TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "CLOSE SELECTED SET OF TABLE ROWS";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FFWREC.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFBUY   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCMPPG01"; /* Table view name*/
  TA1REC.TA1TBLKE = VCMPPG01.VCMPPG01-GROUP; /* table key*/

  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end XSFFS-VCMPPG01-C2

// fetch dfbuy.vcmppg01 record
Function XSFFS-VCMPPG01-N2()
   /* ------------------------------------------------------------*/
   /* Fetch first record from dfbuy.vcmppg01.*/
   /* ------------------------------------------------------------*/

  try
    call "VCMPPG01" ("N2", SQLCA, VCMPPG01) {isNoRefresh = yes, isExternal = yes};
  end

   /* ------------------------------------------------------------*/
   /* If successful or not found, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/
    if (SQLCA.VAGen_SQLCODE == 0 /* Normal return code*/
     || SQLCA.VAGen_SQLCODE == 100) /* or row not found*/
      return; /* Return to previous process*/
    end
  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL Commarea*/

  FFWREC.XXXMODID = "VCM"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/
    converseLib.validationFailed(47); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(01); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "FETCH THE TABLE ROW";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FFWREC.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFBUY   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCMPPG01"; /* Table view name*/
  TA1REC.TA1TBLKE = VCMPPG01.VCMPPG01-GROUP; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end XSFFS-VCMPPG01-N2

// decl csr for dfbuy.vcmppg01
Function XSFFS-VCMPPG01-S2()
   /* *******************************************************************/

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* This subroutine accesses the Footwear Buy table using a specific*/
   /* product, wild cards the factory code, and formats the high and*/
   /* low buy months into the po date range format.*/

   /* The product, factory, gpc, and buy months must be specified*/
   /* in the calling process.*/

   /* The name of the calling process must be move to TA1PGMNM*/
   /* in TA1REC, for Error Diagnosis Reporting.*/

   /* *** Code the following before this is executed:         ****/
   /* ***                                                     ****/
   /* ***   vcmppg01.xgpcd:    '02' for footwear products only****/
   /* ***                                                     ****/
   /* ***   vcmppg01.sy1stnbr: style number                   ****/
   /* ***                                                     ****/
   /* ***   vcmppg01.sy2clrid: color code id                  ****/
   /* ***                                                     ****/
   /* ***   vcmppg01.xdmcd:    dimension code                 ****/
   /* ***                                                     ****/
   /* ***   vcmppg01.fy1fctyc: factory code = '****'          ****/
   /* ***                                                     ****/
   /* ***   vcmppg01.pc-po-id-mo-rng: lo-buymo (ccyypmdm)     ****/
   /* ***                                                     ****/
   /* ***   vcmppg01.zzzsdt: hi-buymo (ccyypmdm)              ****/
   /* ***                                                     ****/
   /* ***   TA1REC.TA1PGMNM: The name of the calling process, ****/
   /* ***                    for Error Diagnosis Reporting.   ****/

   /* This subroutine will do any required Error Diagnosis*/
   /* Reporting to TA0020.  The calling process does not need to*/
   /* do any Error Diagnosis Reporting.*/

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/
   /* **************************************************************/

   /* ------------------------------------------------------------*/
   /* Declare and open a cursor for dfbuy.vcmppg01.*/
   /* ------------------------------------------------------------*/

  try
    call "VCMPPG01" ("S2", SQLCA, VCMPPG01) {isNoRefresh = yes, isExternal = yes};
  end

   /* ------------------------------------------------------------*/
   /* If successful or not found, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Normal return code*/
      return; /* Return to previous process*/
    end
  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL Commarea*/

  FFWREC.XXXMODID = "VCM"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/
    converseLib.validationFailed(47); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(01); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "DECLARE VCMPPG01 CSR";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FFWREC.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFBUY   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCMPPG01"; /* Table view name*/
  TA1REC.TA1TBLKE = VCMPPG01.VCMPPG01-GROUP; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end XSFFS-VCMPPG01-S2

// Exit to another application
Function XSFFS01()
   /* ------------------------------------------------------------*/
   /* If modified data exists, return a message to the user*/
   /* asking if the modified data is to be saved before exiting.*/
   /* ------------------------------------------------------------*/

  if (FFWREC.FFWMODSW == "Y") /* Modified data exists*/

    FFWREC.FFWMODSW = "N"; /* Modified data exit switch*/

    FFWREC.XXXMODID = "X01"; /* Module identification*/
    converseLib.validationFailed(157); /* Should changes be saved*/

  else

    /* ------------------------------------------------------------*/
     /* Otherwise, set application to be invoked for PF1 or PF5.*/
    /* ------------------------------------------------------------*/

    if (converseVar.eventKey is pf1) /* PF1 was pressed*/
      COMMAREA.CATOAP = "GD01"; /* Indicate Goal Documentation*/
    end

    if (converseVar.eventKey is pf5) /* PF5 was pressed*/
      COMMAREA.CATOAP = "FY0M"; /* Indicate Production Menu*/
    end

    /* ------------------------------------------------------------*/
     /* Save the application user area in the COMMAREA.*/
    /* ------------------------------------------------------------*/

    if (COMMAREA.CATOSYS == "FF" /* Same system*/
     || COMMAREA.CATOSYS == "FE" /* or alternate system*/
     || COMMAREA.CATOSYS == "FG") /* or alternate system*/

      COMMAREA.CAUSERA = FFWREC.CAUSERA; /* Save user area*/
    else
      COMMAREA.CAUSERA = " "; /* Clear user area*/

    end

    /* ------------------------------------------------------------*/
     /* Transfer control to the specified application.*/
    /* ------------------------------------------------------------*/

    XSEXIT(); /* Exit to another application*/

    /* ------------------------------------------------------------*/
     /* If transfer failed, return an error to the calling process.*/
    /* ------------------------------------------------------------*/

    FFWREC.XXXMODID = "X01"; /* Module identification*/

    if (COMMAREA.CASECRC == 3 /* Application not found*/
     || COMMAREA.CASECRC == 4) /* or transfer not allowed*/

      converseLib.validationFailed(25); /* Not allowed to access*/
    else
      converseLib.validationFailed(1); /* Unexpected error occurred*/

    end

  end

   /* ------------------------------------------------------------*/
   /* Reestablish the COMMAREA application and item fields.*/
   /* ------------------------------------------------------------*/

  COMMAREA.CAEZSG3 = "0"; /* Force zero third character*/
  COMMAREA.CACURRAP = COMMAREA.CAEZSAP; /* CURR application*/

  if (converseVar.eventKey is pfkey) /* PF key was pressed*/

    COMMAREA.CATOAP = " "; /* Clear TO application*/

    if (converseVar.eventKey is pf1) /* PF1 was pressed*/
      COMMAREA.CAITEM = " "; /* Clear map name from item*/
    end

  end


end // end XSFFS01

// Translate units to thousands
Function XSFFS10()

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* This subroutine translates a nine-byte numeric field in*/
   /* exact units to a five-byte character field in thousands*/
   /* representation.*/

   /* The number to be translated is passed in FFXREC.FFXNUMB.*/
   /* The number is rounded to the nearest hundred.  Leading*/
   /* and trailing zeros are removed and any required negative*/
   /* sign (-) or decimal point(.) is inserted.  The number,*/
   /* in thousands representation, is returned to the calling*/
   /* process in FFXREC.FFXCHAR.  The rounded number, in units,*/
   /* is returned to the calling process in FFXREC.FFXROUND.*/

   /* *** Code the following before this is executed:         ****/
   /* ***                                                     ****/
   /* ***  FFXREC.FFXNUMB: The number to be translated.       ****/
   /* ***                  This number may not be less than   ****/
   /* ***                  -9999999 or greater than 99999999. ****/

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* ------------------------------------------------------------*/
   /* Initialize the subroutine return code.*/
   /* ------------------------------------------------------------*/

  FFXREC.FFXRTNCD = "0"; /* Subroutine return code*/

   /* ------------------------------------------------------------*/
   /* Move the number to be translated to the work area.*/
   /* ------------------------------------------------------------*/

  FFXREC.FFXROUND = FFXREC.FFXNUMB; /* Translation work number*/

   /* ------------------------------------------------------------*/
   /* Post error diagnosis if number is out of allowable bounds.*/
   /* ------------------------------------------------------------*/

  if (FFXREC.FFXROUND < -9999999 /* Number is too small*/
   || FFXREC.FFXROUND > 99999999) /* or number is too large*/

    FFXREC.FFXCHAR = "*****"; /* Translation character field*/

    TA1REC.TA1FUNC = "POST"; /* Termination function*/
    TA1REC.TA1TYPE = "APPL"; /* Type of error*/
    TA1REC.TA1LOC = "NUMBER OUT OF ALLOWABLE BOUNDS";
    TA1REC.TA1PGMNM = "XSFFS10 "; /* Process name*/
    TAEREC.TAEDESC1 = FFXREC.FFXGROUP; /* Subroutine parameters*/

    call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* Round number to fit into the five character output field.*/
   /* ------------------------------------------------------------*/

  FFXREC.FFXROUND = mathLib.round(FFXREC.FFXROUND / 100, -mathLib.decimals(FFXREC.FFXROUND)); /* Round to hundreds*/

  if (FFXREC.FFXROUND < -99999) /* Less than minimum*/
    FFXREC.FFXROUND = -99999; /* Default to minimum*/
  end

  if (FFXREC.FFXROUND > 999999) /* Greater than maximum*/
    FFXREC.FFXROUND = 999999; /* Default to maximum*/
  end

  FFXREC.FFXROUND = FFXREC.FFXROUND * 100; /* Convert back to units*/

   /* ------------------------------------------------------------*/
   /* If too small to round, indicate an insignificant number.*/
   /* ------------------------------------------------------------*/

  if (FFXREC.FFXROUND == 0 /* Rounded number is zero*/
   && FFXREC.FFXNUMB != 0) /* and real number not zero*/

    FFXREC.FFXROUND = FFXREC.FFXNUMB; /* Return real number*/

    if (FFXREC.FFXNUMB < 0) /* Negative number*/

      FFXREC.FFXCHAR = "   -*"; /* Insignificant negative number*/
    else
      FFXREC.FFXCHAR = "    *"; /* Insignificant positive number*/

    end

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* Count the number of significant units positions.*/
   /* ------------------------------------------------------------*/

  FFXREC.FFXSIGN = 0; /* Significant units*/
  FFXREC.FFXINPIX = 1; /* Input byte index*/

  while (FFXREC.FFXINPIX <= 6) /* Until end of units*/

    if (FFXREC.XXXEDN2[FFXINPIX] != 0 /* Significant digit*/
     || FFXREC.FFXSIGN > 0)           /* or significance found*/

      FFXREC.FFXSIGN = FFXREC.FFXSIGN + 1; /* Significant units*/

    end

    FFXREC.FFXINPIX = FFXREC.FFXINPIX + 1; /* Input byte index*/

  end

   /* ------------------------------------------------------------*/
   /* Initialize character field, index and counter to be used.*/
   /* ------------------------------------------------------------*/

  FFXREC.FFXCHAR = "     "; /* Translation character field*/

  FFXREC.FFXINPIX = 9; /* Input byte index*/
  FFXREC.FFXOUTIX = 5; /* Output byte index*/
  FFXREC.FFXDECCT = 3; /* Decimals count*/
  FFXREC.FFXDIGCT = 0; /* Digits count*/

  if (FFXREC.FFXROUND < 0) /* Negative number*/

    if (FFXREC.FFXSIGN > 2) /* More than two significant units*/

      FFXREC.FFXINPIX = 6; /* Input byte index*/
      FFXREC.FFXDECCT = 0; /* Decimals count*/

    end

  else

    if (FFXREC.FFXSIGN > 3) /* More than three significant units*/

      FFXREC.FFXINPIX = 6; /* Input byte index*/
      FFXREC.FFXDECCT = 0; /* Decimals count*/

    end

  end

   /* ------------------------------------------------------------*/
   /* Move any significant decimal positions to the output area.*/
   /* ------------------------------------------------------------*/

  while (FFXREC.FFXDECCT > 0 /* Until end of decimals*/
   && FFXREC.FFXROUND != 0) /* and result not zero*/

    if (FFXREC.XXXEDN2[FFXINPIX] != 0 /* Significant digit*/
     || FFXREC.FFXDIGCT > 0           /* or digits counted*/
     || FFXREC.FFXDECCT == 1)         /* or tenths position*/

      if (FFXREC.FFXINPIX == 9 /* Low order digit*/
       && FFXREC.FFXROUND < 0) /* and negative number*/

        FFXREC.XXXEDN1[FFXOUTIX] = FFXREC.XXXEDN2[FFXINPIX] * -1;
      else
        FFXREC.XXXEDN1[FFXOUTIX] = FFXREC.XXXEDN2[FFXINPIX];

      end

      FFXREC.FFXDIGCT = FFXREC.FFXDIGCT + 1; /* Digits count*/
      FFXREC.FFXOUTIX = FFXREC.FFXOUTIX - 1; /* Output byte index*/

    end

    FFXREC.FFXDECCT = FFXREC.FFXDECCT - 1; /* Decimals count*/
    FFXREC.FFXINPIX = FFXREC.FFXINPIX - 1; /* Input byte index*/

  end

   /* ------------------------------------------------------------*/
   /* Insert any required decimal point.*/
   /* ------------------------------------------------------------*/

  if (FFXREC.FFXDIGCT > 0) /* Decimals translated*/

    FFXREC.XXXCHAR[FFXOUTIX] = "."; /* Decimal point*/

    FFXREC.FFXOUTIX = FFXREC.FFXOUTIX - 1; /* Output byte index*/

  end

   /* ------------------------------------------------------------*/
   /* Move any significant units positions to the output area.*/
   /* ------------------------------------------------------------*/

  while (FFXREC.FFXSIGN > 0) /* Until end of input*/

    FFXREC.XXXEDN1[FFXOUTIX] = FFXREC.XXXEDN2[FFXINPIX];

    FFXREC.FFXINPIX = FFXREC.FFXINPIX - 1; /* Input byte index*/
    FFXREC.FFXOUTIX = FFXREC.FFXOUTIX - 1; /* Output byte index*/
    FFXREC.FFXSIGN = FFXREC.FFXSIGN - 1; /* Significant units*/

  end

   /* ------------------------------------------------------------*/
   /* Insert a negative sign if a negative number.*/
   /* ------------------------------------------------------------*/

  if (FFXREC.FFXROUND < 0) /* Negative number*/

    FFXREC.XXXCHAR[FFXOUTIX] = "-"; /* Negative sign*/

    FFXREC.FFXOUTIX = FFXREC.FFXOUTIX - 1; /* Output byte index*/

  end


end // end XSFFS10

// Translate thousands to units
Function XSFFS11()

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* This subroutine translates a five-byte character field in*/
   /* thousands representation to a nine-byte numeric field in*/
   /* exact units.*/

   /* The number to be translated is passed in FFXREC.FFXCHAR.*/
   /* The number is verified for acceptable numeric syntax.  Any*/
   /* sign (+ or -), decimal point (.) or space is resolved and*/
   /* the result is converted to thousands.  The number is*/
   /* returned to the calling process in FFXREC.FFXNUMB.*/

   /* If any error is found during translation, it is indicated*/
   /* by the completion code in FFXREC.FFXRTNCD.*/

   /* *** Code the following before this is executed:         ****/
   /* ***                                                     ****/
   /* ***   FFXREC.FFXCHAR: The number to be translated.      ****/
   /* ***                   A maximum of one decimal place    ****/
   /* ***                   may be specified in this number.  ****/

   /* The subroutine will return the completion code in FFXRTNCD.*/

   /* ***   FFXREC.FFXRTNCD                                   ****/
   /* ***   ---------------                                   ****/
   /* ***   '0' = Normal return                               ****/
   /* ***   '1' = Imbedded space was found                    ****/
   /* ***   '2' = Too many decimal places                     ****/
   /* ***   '3' = Field is not numeric                        ****/

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* ------------------------------------------------------------*/
   /* Initialize the return code, index and counter to be used.*/
   /* ------------------------------------------------------------*/

  FFXREC.FFXRTNCD = "0"; /* Subroutine return code*/

  FFXREC.FFXINPIX = 1; /* Input byte index*/
  FFXREC.FFXDIGCT = 0; /* Digits count*/

   /* ------------------------------------------------------------*/
   /* Find any decimal point that was entered.*/
   /* ------------------------------------------------------------*/

  while (FFXREC.FFXINPIX <= 5 /* Until end of input*/
   && FFXREC.XXXCHAR[FFXINPIX] != ".") /* or decimal point found*/

    FFXREC.FFXINPIX = FFXREC.FFXINPIX + 1; /* Input byte index*/

  end

   /* ------------------------------------------------------------*/
   /* Bypass any decimal point that was entered.*/
   /* ------------------------------------------------------------*/

  if (FFXREC.FFXINPIX <= 5 /* Not end of input*/
   && FFXREC.XXXCHAR[FFXINPIX] == ".") /* and decimal point found*/

    FFXREC.FFXINPIX = FFXREC.FFXINPIX + 1; /* Input byte index*/

  end

   /* ------------------------------------------------------------*/
   /* Count the number of decimals following the decimal point.*/
   /* ------------------------------------------------------------*/

  while (FFXREC.FFXINPIX <= 5 /* Until end of input*/
   && FFXREC.XXXCHAR[FFXINPIX] != " ") /* or trailing space found*/

    FFXREC.FFXDIGCT = FFXREC.FFXDIGCT + 1; /* Digits count*/

    FFXREC.FFXINPIX = FFXREC.FFXINPIX + 1; /* Input byte index*/

  end

   /* ------------------------------------------------------------*/
   /* Indicate error if trailing positions are not spaces.*/
   /* ------------------------------------------------------------*/

  while (FFXREC.FFXINPIX <= 5) /* Until end of input*/

    if (FFXREC.XXXCHAR[FFXINPIX] == " ") /* Trailing space*/

      FFXREC.FFXINPIX = FFXREC.FFXINPIX + 1; /* Input byte index*/

    else

      FFXREC.FFXRTNCD = "1"; /* Indicate imbedded space*/

      return; /* Return to previous process*/

    end

  end

   /* ------------------------------------------------------------*/
   /* Indicate error if more than one decimal place was entered.*/
   /* ------------------------------------------------------------*/

  if (FFXREC.FFXDIGCT > 1) /* Too many decimal places*/

    FFXREC.FFXRTNCD = "2"; /* Indicate too many decimals*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* Initialize the work field, index and counter to be used.*/
   /* ------------------------------------------------------------*/

  FFXREC.FFXROUND = 0; /* Translation work field*/

  FFXREC.FFXINPIX = 5; /* Input byte index*/
  FFXREC.FFXOUTIX = 9; /* Output byte index*/
  FFXREC.FFXDECCT = 3; /* Decimals count*/
  FFXREC.FFXSIGN = 1; /* Result field sign*/

   /* ------------------------------------------------------------*/
   /* Move any decimal positions entered to the output area.*/
   /* ------------------------------------------------------------*/

  while (FFXREC.FFXINPIX > 0 /* Until end of input*/
   && FFXREC.FFXDECCT > 0) /* or end of decimals*/

    if (FFXREC.XXXCHAR[FFXINPIX] == " ") /* Blank character*/

      FFXREC.FFXINPIX = FFXREC.FFXINPIX - 1; /* Input byte index*/

    else

      if (FFXREC.FFXDECCT > FFXREC.FFXDIGCT) /* Position not entered*/

        FFXREC.XXXEDN2[FFXOUTIX] = 0; /* Default decimal position*/

      else

        if (FFXREC.XXXCHAR[FFXINPIX] < "0" /* Less than 0*/
         || FFXREC.XXXCHAR[FFXINPIX] > "9") /* or greater than 9*/

          FFXREC.FFXRTNCD = "3"; /* Indicate field not numeric*/

          return; /* Return to previous process*/

        end

        FFXREC.XXXEDN2[FFXOUTIX] = FFXREC.XXXEDN1[FFXINPIX];

        FFXREC.FFXINPIX = FFXREC.FFXINPIX - 1; /* Input byte index*/

      end

      FFXREC.FFXDECCT = FFXREC.FFXDECCT - 1; /* Decimals count*/
      FFXREC.FFXOUTIX = FFXREC.FFXOUTIX - 1; /* Output byte index*/

    end

  end

   /* ------------------------------------------------------------*/
   /* Bypass any decimal point that was entered.*/
   /* ------------------------------------------------------------*/

  if (FFXREC.FFXINPIX > 0 /* Not end of input*/
   && FFXREC.XXXCHAR[FFXINPIX] == ".") /* and decimal point found*/

    FFXREC.FFXINPIX = FFXREC.FFXINPIX - 1; /* Input byte index*/

  end

   /* ------------------------------------------------------------*/
   /* Move any units positions entered to the output area.*/
   /* ------------------------------------------------------------*/

  while (FFXREC.FFXINPIX > 0             /* Until end of input*/
   && FFXREC.XXXCHAR[FFXINPIX] != " " /* or leading space found*/
   && FFXREC.XXXCHAR[FFXINPIX] != "+" /* or positive sign found*/
   && FFXREC.XXXCHAR[FFXINPIX] != "-") /* or negative sign found*/

    if (FFXREC.XXXCHAR[FFXINPIX] < "0" /* Less than 0*/
     || FFXREC.XXXCHAR[FFXINPIX] > "9") /* or greater than 9*/

      FFXREC.FFXRTNCD = "3"; /* Indicate field not numeric*/

      return; /* Return to previous process*/

    end

    FFXREC.XXXEDN2[FFXOUTIX] = FFXREC.XXXEDN1[FFXINPIX];

    FFXREC.FFXINPIX = FFXREC.FFXINPIX - 1; /* Input byte index*/
    FFXREC.FFXOUTIX = FFXREC.FFXOUTIX - 1; /* Output byte index*/

  end

   /* ------------------------------------------------------------*/
   /* Indicate a negative number if a negative sign was found.*/
   /* ------------------------------------------------------------*/

  if (FFXREC.FFXINPIX > 0) /* Not end of input*/

    if (FFXREC.XXXCHAR[FFXINPIX] == "-") /* Negative sign found*/
      FFXREC.FFXSIGN = -1; /* Result field sign*/
    end

    FFXREC.FFXINPIX = FFXREC.FFXINPIX - 1; /* Input byte index*/

  end

   /* ------------------------------------------------------------*/
   /* Indicate error if leading positions are not spaces.*/
   /* ------------------------------------------------------------*/

  while (FFXREC.FFXINPIX > 0) /* Until end of input*/

    if (FFXREC.XXXCHAR[FFXINPIX] == " ") /* Leading space*/

      FFXREC.FFXINPIX = FFXREC.FFXINPIX - 1; /* Input byte index*/

    else

      FFXREC.FFXRTNCD = "1"; /* Indicate imbedded space*/

      return; /* Return to previous process*/

    end

  end

   /* ------------------------------------------------------------*/
   /* Calculate the resulting number into the return field.*/
   /* ------------------------------------------------------------*/

  FFXREC.FFXNUMB = FFXREC.FFXROUND * FFXREC.FFXSIGN;


end // end XSFFS11

// Translate units to millions
Function XSFFS12()

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* This subroutine translates a nine-byte numeric field in*/
   /* exact units to a four-byte character field in millions*/
   /* representation.*/

   /* The number to be translated is passed in FFXREC.FFXNUMB.*/
   /* The number is rounded to nearest hundred-thousand.  Leading*/
   /* and trailing zeros are removed and any required negative*/
   /* sign (-) or decimal point(.) is inserted.  The number,*/
   /* in millions representation, is returned to the calling*/
   /* process in FFXREC.FFXCHAR.  The rounded number, in units,*/
   /* is returned to the calling process in FFXREC.FFXROUND.*/

   /* *** Code the following before this is executed:         ****/
   /* ***                                                     ****/
   /* ***  FFXREC.FFXNUMB: The number to be translated.       ****/
   /* ***                  This number may not be less than   ****/
   /* ***                  -999999999 or greater 999999999.   ****/

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* ------------------------------------------------------------*/
   /* Initialize the subroutine return code.*/
   /* ------------------------------------------------------------*/

  FFXREC.FFXRTNCD = "0"; /* Subroutine return code*/

   /* ------------------------------------------------------------*/
   /* Move the number to be translated to the work area.*/
   /* ------------------------------------------------------------*/

  FFXREC.FFXROUND = FFXREC.FFXNUMB; /* Translation work number*/

   /* ------------------------------------------------------------*/
   /* Indicate error if the number is out of allowable bounds.*/
   /* ------------------------------------------------------------*/

  if (FFXREC.FFXROUND < -999999999 /* Number is too small*/
   || FFXREC.FFXROUND > 999999999) /* or number is too large*/

    FFXREC.FFXCHAR = "****"; /* Translation character field*/

    TA1REC.TA1FUNC = "POST"; /* Termination function*/
    TA1REC.TA1TYPE = "APPL"; /* Type of error*/
    TA1REC.TA1LOC = "NUMBER OUT OF ALLOWABLE BOUNDS";
    TA1REC.TA1PGMNM = "XSFFS12 "; /* Process name*/
    TAEREC.TAEDESC1 = FFXREC.FFXGROUP; /* Subroutine parameters*/

    call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* Round number to fit into the four character output field.*/
   /* ------------------------------------------------------------*/

  FFXREC.FFXROUND = mathLib.round(FFXREC.FFXROUND / 100000, -mathLib.decimals(FFXREC.FFXROUND));
                                   /* Round to hundred-thousands*/

  if (FFXREC.FFXROUND < -9999) /* Less than minimum*/
    FFXREC.FFXROUND = -9999; /* Default to minimum*/
  end

  if (FFXREC.FFXROUND > 9999) /* Greater than maximum*/
    FFXREC.FFXROUND = 9999; /* Default to maximum*/
  end

  FFXREC.FFXROUND = FFXREC.FFXROUND * 100000; /* Convert back to units*/

   /* ------------------------------------------------------------*/
   /* If too small to round, indicate an insignificant number.*/
   /* ------------------------------------------------------------*/

  if (FFXREC.FFXROUND == 0 /* Rounded number is zero*/
   && FFXREC.FFXNUMB != 0) /* and real number not zero*/

    FFXREC.FFXROUND = FFXREC.FFXNUMB; /* Return real number*/

    if (FFXREC.FFXNUMB < 0) /* Negative number*/

      FFXREC.FFXCHAR = "  -*"; /* Insignificant negative number*/
    else
      FFXREC.FFXCHAR = "   *"; /* Insignificant positive number*/

    end

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* Count the number of significant units positions.*/
   /* ------------------------------------------------------------*/

  FFXREC.FFXSIGN = 0; /* Significant units*/
  FFXREC.FFXINPIX = 1; /* Input byte index*/

  while (FFXREC.FFXINPIX <= 3) /* Until end of units*/

    if (FFXREC.XXXEDN2[FFXINPIX] != 0 /* Significant digit*/
     || FFXREC.FFXSIGN > 0)           /* or significance found*/

      FFXREC.FFXSIGN = FFXREC.FFXSIGN + 1; /* Significant units*/

    end

    FFXREC.FFXINPIX = FFXREC.FFXINPIX + 1; /* Input byte index*/

  end

   /* ------------------------------------------------------------*/
   /* Initialize character field, index and counter to be used.*/
   /* ------------------------------------------------------------*/

  FFXREC.FFXCHAR = "    "; /* Translation character field*/

  FFXREC.FFXINPIX = 6; /* Input byte index*/
  FFXREC.FFXOUTIX = 4; /* Output byte index*/
  FFXREC.FFXDECCT = 3; /* Decimals count*/
  FFXREC.FFXDIGCT = 0; /* Digits count*/

  if (FFXREC.FFXROUND < 0) /* Negative number*/

    if (FFXREC.FFXSIGN > 1) /* More than one significant unit*/

      FFXREC.FFXINPIX = 3; /* Input byte index*/
      FFXREC.FFXDECCT = 0; /* Decimals count*/

    end

  else

    if (FFXREC.FFXSIGN > 2) /* More than two significant units*/

      FFXREC.FFXINPIX = 3; /* Input byte index*/
      FFXREC.FFXDECCT = 0; /* Decimals count*/

    end

  end

   /* ------------------------------------------------------------*/
   /* Move any significant decimal positions to the output area.*/
   /* ------------------------------------------------------------*/

  while (FFXREC.FFXDECCT > 0 /* Until end of decimals*/
   && FFXREC.FFXROUND != 0) /* and result not zero*/

    if (FFXREC.XXXEDN2[FFXINPIX] != 0 /* Significant digit*/
     || FFXREC.FFXDIGCT > 0           /* or digits counted*/
     || FFXREC.FFXDECCT == 1)         /* or tenths position*/

      if (FFXREC.FFXINPIX == 9 /* Low order digit*/
       && FFXREC.FFXROUND < 0) /* and negative number*/

        FFXREC.XXXEDN1[FFXOUTIX] = FFXREC.XXXEDN2[FFXINPIX] * -1;
      else
        FFXREC.XXXEDN1[FFXOUTIX] = FFXREC.XXXEDN2[FFXINPIX];

      end

      FFXREC.FFXDIGCT = FFXREC.FFXDIGCT + 1; /* Digits count*/
      FFXREC.FFXOUTIX = FFXREC.FFXOUTIX - 1; /* Output byte index*/

    end

    FFXREC.FFXDECCT = FFXREC.FFXDECCT - 1; /* Decimals count*/
    FFXREC.FFXINPIX = FFXREC.FFXINPIX - 1; /* Input byte index*/

  end

   /* ------------------------------------------------------------*/
   /* Insert any required decimal point.*/
   /* ------------------------------------------------------------*/

  if (FFXREC.FFXDIGCT > 0) /* Decimals translated*/

    FFXREC.XXXCHAR[FFXOUTIX] = "."; /* Decimal point*/

    FFXREC.FFXOUTIX = FFXREC.FFXOUTIX - 1; /* Output byte index*/

  end

   /* ------------------------------------------------------------*/
   /* Move any significant units positions to the output area.*/
   /* ------------------------------------------------------------*/

  while (FFXREC.FFXSIGN > 0) /* Until end of input*/

    FFXREC.XXXEDN1[FFXOUTIX] = FFXREC.XXXEDN2[FFXINPIX];

    FFXREC.FFXINPIX = FFXREC.FFXINPIX - 1; /* Input byte index*/
    FFXREC.FFXOUTIX = FFXREC.FFXOUTIX - 1; /* Output byte index*/
    FFXREC.FFXSIGN = FFXREC.FFXSIGN - 1; /* Significant units*/

  end

   /* ------------------------------------------------------------*/
   /* Insert a negative sign if a negative number.*/
   /* ------------------------------------------------------------*/

  if (FFXREC.FFXROUND < 0) /* Negative number*/

    FFXREC.XXXCHAR[FFXOUTIX] = "-"; /* Negative sign*/

    FFXREC.FFXOUTIX = FFXREC.FFXOUTIX - 1; /* Output byte index*/

  end


end // end XSFFS12

// Translate units to thousands
Function XSFFS14()

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* This subroutine translates a nine-byte numeric field in*/
   /* exact units to a four-byte character field in thousands*/
   /* representation.*/

   /* The number to be translated is passed in FFXREC.FFXNUMB.*/
   /* The number is rounded to the nearest thousand.  Leading*/
   /* and trailing zeros are removed and any required negative*/
   /* sign (-) or decimal point(.) is inserted.  The number,*/
   /* in thousands representation, is returned to the calling*/
   /* process in FFXREC.FFXCHAR.  The rounded number, in units,*/
   /* is returned to the calling process in FFXREC.FFXROUND.*/

   /* *** Code the following before this is executed:         ****/
   /* ***                                                     ****/
   /* ***  FFXREC.FFXNUMB: The number to be translated.       ****/
   /* ***                  This number may not be less than   ****/
   /* ***                  -999999 or greater than 9999999.   ****/

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* ------------------------------------------------------------*/
   /* Initialize the subroutine return code.*/
   /* ------------------------------------------------------------*/

  FFXREC.FFXRTNCD = "0"; /* Subroutine return code*/

   /* ------------------------------------------------------------*/
   /* Move the number to be translated to the work area.*/
   /* ------------------------------------------------------------*/

  FFXREC.FFXROUND = FFXREC.FFXNUMB; /* Translation work number*/

   /* ------------------------------------------------------------*/
   /* Post error diagnosis if number is out of allowable bounds.*/
   /* ------------------------------------------------------------*/

  if (FFXREC.FFXROUND < -999999 /* Number is too small*/
   || FFXREC.FFXROUND > 9999999) /* or number is too large*/

    FFXREC.FFXCHAR = "****"; /* Translation character field*/

    TA1REC.TA1FUNC = "POST"; /* Termination function*/
    TA1REC.TA1TYPE = "APPL"; /* Type of error*/
    TA1REC.TA1LOC = "NUMBER OUT OF ALLOWABLE BOUNDS";
    TA1REC.TA1PGMNM = "XSFFS14 "; /* Process name*/
    TAEREC.TAEDESC1 = FFXREC.FFXGROUP; /* Subroutine parameters*/

    call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* Round number to fit into the four character output field.*/
   /* ------------------------------------------------------------*/

  FFXREC.FFXROUND = mathLib.round(FFXREC.FFXROUND / 1000, -mathLib.decimals(FFXREC.FFXROUND)); /* Round to thousand*/

  if (FFXREC.FFXROUND < -9999) /* Less than minimum*/
    FFXREC.FFXROUND = -9999; /* Default to minimum*/
  end

  if (FFXREC.FFXROUND > 99999) /* Greater than maximum*/
    FFXREC.FFXROUND = 99999; /* Default to maximum*/
  end

  FFXREC.FFXROUND = FFXREC.FFXROUND * 1000; /* Convert back to units*/

   /* ------------------------------------------------------------*/
   /* If too small to round, indicate an insignificant number.*/
   /* ------------------------------------------------------------*/

  if (FFXREC.FFXROUND > -1000 /* Rounded number GT -1000*/
   && FFXREC.FFXROUND < 1000  /* and rounded number LT 1000*/
   && FFXREC.FFXNUMB != 0)    /* and real number not zero*/

    FFXREC.FFXROUND = FFXREC.FFXNUMB; /* Return real number*/

    if (FFXREC.FFXNUMB < 0) /* Negative number*/

      FFXREC.FFXCHAR = "  -*"; /* Insignificant negative number*/
    else
      FFXREC.FFXCHAR = "   *"; /* Insignificant positive number*/

    end

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* Count the number of significant units positions.*/
   /* ------------------------------------------------------------*/

  FFXREC.FFXSIGN = 0; /* Significant units*/
  FFXREC.FFXINPIX = 3; /* Input byte index*/

  while (FFXREC.FFXINPIX <= 6) /* Until end of units*/

    if (FFXREC.XXXEDN2[FFXINPIX] != 0 /* Significant digit*/
     || FFXREC.FFXSIGN > 0)           /* or significance found*/

      FFXREC.FFXSIGN = FFXREC.FFXSIGN + 1; /* Significant units*/

    end

    FFXREC.FFXINPIX = FFXREC.FFXINPIX + 1; /* Input byte index*/

  end

   /* ------------------------------------------------------------*/
   /* Initialize character field, index and counter to be used.*/
   /* ------------------------------------------------------------*/

  FFXREC.FFXCHAR = "    "; /* Translation character field*/

  FFXREC.FFXINPIX = 6; /* Input byte index*/
  FFXREC.FFXOUTIX = 4; /* Output byte index*/
  FFXREC.FFXDECCT = 0; /* Decimals count*/
  FFXREC.FFXDIGCT = 0; /* Digits count*/

   /* ------------------------------------------------------------*/
   /* Move any significant units positions to the output area.*/
   /* ------------------------------------------------------------*/

  while (FFXREC.FFXSIGN > 0) /* Until end of input*/

    FFXREC.XXXEDN1[FFXOUTIX] = FFXREC.XXXEDN2[FFXINPIX];

    FFXREC.FFXINPIX = FFXREC.FFXINPIX - 1; /* Input byte index*/
    FFXREC.FFXOUTIX = FFXREC.FFXOUTIX - 1; /* Output byte index*/
    FFXREC.FFXSIGN = FFXREC.FFXSIGN - 1; /* Significant units*/

  end

   /* ------------------------------------------------------------*/
   /* Insert a negative sign if a negative number.*/
   /* ------------------------------------------------------------*/

  if (FFXREC.FFXROUND < 0) /* Negative number*/

    FFXREC.XXXCHAR[FFXOUTIX] = "-"; /* Negative sign*/

    FFXREC.FFXOUTIX = FFXREC.FFXOUTIX - 1; /* Output byte index*/

  end


end // end XSFFS14

// Translate thousands to units
Function XSFFS15()

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* This subroutine translates a four-byte character field in*/
   /* thousands representation to a nine-byte numeric field in*/
   /* exact units.*/

   /* The number to be translated is passed in FFXREC.FFXCHAR.*/
   /* The number is verified for acceptable numeric syntax.  Any*/
   /* sign (+ or -), decimal point (.) or space is resolved and*/
   /* the result is converted to thousands.  The number is*/
   /* returned to the calling process in FFXREC.FFXNUMB.*/

   /* If any error is found during translation, it is indicated*/
   /* by the completion code in FFXREC.FFXRTNCD.*/

   /* *** Code the following before this is executed:         ****/
   /* ***                                                     ****/
   /* ***   FFXREC.FFXCHAR: The number to be translated.      ****/
   /* ***                   No decimal places may be          ****/
   /* ***                   specified in this number.         ****/

   /* The subroutine will return the completion code in FFXRTNCD.*/

   /* ***   FFXREC.FFXRTNCD                                   ****/
   /* ***   ---------------                                   ****/
   /* ***   '0' = Normal return                               ****/
   /* ***   '1' = Imbedded space was found                    ****/
   /* ***   '2' = Too many decimal places                     ****/
   /* ***   '3' = Field is not numeric                        ****/

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* ------------------------------------------------------------*/
   /* Initialize the return code, index and counter to be used.*/
   /* ------------------------------------------------------------*/

  FFXREC.FFXRTNCD = "0"; /* Subroutine return code*/

  FFXREC.FFXINPIX = 1; /* Input byte index*/
  FFXREC.FFXDIGCT = 0; /* Digits count*/

   /* ------------------------------------------------------------*/
   /* Find any decimal point that was entered.*/
   /* ------------------------------------------------------------*/

  while (FFXREC.FFXINPIX <= 4 /* Until end of input*/
   && FFXREC.XXXCHAR[FFXINPIX] != ".") /* or decimal point found*/

    FFXREC.FFXINPIX = FFXREC.FFXINPIX + 1; /* Input byte index*/

  end

   /* ------------------------------------------------------------*/
   /* Bypass any decimal point that was entered.*/
   /* ------------------------------------------------------------*/

  if (FFXREC.FFXINPIX <= 4 /* Not end of input*/
   && FFXREC.XXXCHAR[FFXINPIX] == ".") /* and decimal point found*/

    FFXREC.FFXINPIX = FFXREC.FFXINPIX + 1; /* Input byte index*/

  end

   /* ------------------------------------------------------------*/
   /* Count the number of decimals following the decimal point.*/
   /* ------------------------------------------------------------*/

  while (FFXREC.FFXINPIX <= 4 /* Until end of input*/
   && FFXREC.XXXCHAR[FFXINPIX] != " ") /* or trailing space found*/

    FFXREC.FFXDIGCT = FFXREC.FFXDIGCT + 1; /* Digits count*/

    FFXREC.FFXINPIX = FFXREC.FFXINPIX + 1; /* Input byte index*/

  end

   /* ------------------------------------------------------------*/
   /* Indicate error if trailing positions are not spaces.*/
   /* ------------------------------------------------------------*/

  while (FFXREC.FFXINPIX <= 4) /* Until end of input*/

    if (FFXREC.XXXCHAR[FFXINPIX] == " ") /* Trailing space*/

      FFXREC.FFXINPIX = FFXREC.FFXINPIX + 1; /* Input byte index*/

    else

      FFXREC.FFXRTNCD = "1"; /* Indicate imbedded space*/

      return; /* Return to previous process*/

    end

  end

   /* ------------------------------------------------------------*/
   /* Indicate error if any decimal places were entered.*/
   /* ------------------------------------------------------------*/

  if (FFXREC.FFXDIGCT > 0) /* Too many decimal places*/

    FFXREC.FFXRTNCD = "2"; /* Indicate too many decimals*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* Initialize the work field, index and counter to be used.*/
   /* ------------------------------------------------------------*/

  FFXREC.FFXROUND = 0; /* Translation work field*/

  FFXREC.FFXINPIX = 4; /* Input byte index*/
  FFXREC.FFXOUTIX = 6; /* Output byte index*/
  FFXREC.FFXDECCT = 0; /* Decimals count*/
  FFXREC.FFXSIGN = 1; /* Result field sign*/

   /* ------------------------------------------------------------*/
   /* Bypass any decimal point that was entered.*/
   /* ------------------------------------------------------------*/

  if (FFXREC.FFXINPIX > 0 /* Not end of input*/
   && FFXREC.XXXCHAR[FFXINPIX] == ".") /* and decimal point found*/

    FFXREC.FFXINPIX = FFXREC.FFXINPIX - 1; /* Input byte index*/

  end

   /* ------------------------------------------------------------*/
   /* Move any units positions entered to the output area.*/
   /* ------------------------------------------------------------*/

  while (FFXREC.FFXINPIX > 0             /* Until end of input*/
   && FFXREC.XXXCHAR[FFXINPIX] != " " /* or leading space found*/
   && FFXREC.XXXCHAR[FFXINPIX] != "+" /* or positive sign found*/
   && FFXREC.XXXCHAR[FFXINPIX] != "-") /* or negative sign found*/

    if (FFXREC.XXXCHAR[FFXINPIX] < "0" /* Less than 0*/
     || FFXREC.XXXCHAR[FFXINPIX] > "9") /* or greater than 9*/

      FFXREC.FFXRTNCD = "3"; /* Indicate field not numeric*/

      return; /* Return to previous process*/

    end

    FFXREC.XXXEDN2[FFXOUTIX] = FFXREC.XXXEDN1[FFXINPIX];

    FFXREC.FFXINPIX = FFXREC.FFXINPIX - 1; /* Input byte index*/
    FFXREC.FFXOUTIX = FFXREC.FFXOUTIX - 1; /* Output byte index*/

  end

   /* ------------------------------------------------------------*/
   /* Indicate a negative number if a negative sign was found.*/
   /* ------------------------------------------------------------*/

  if (FFXREC.FFXINPIX > 0) /* Not end of input*/

    if (FFXREC.XXXCHAR[FFXINPIX] == "-") /* Negative sign found*/
      FFXREC.FFXSIGN = -1; /* Result field sign*/
    end

    FFXREC.FFXINPIX = FFXREC.FFXINPIX - 1; /* Input byte index*/

  end

   /* ------------------------------------------------------------*/
   /* Indicate error if leading positions are not spaces.*/
   /* ------------------------------------------------------------*/

  while (FFXREC.FFXINPIX > 0) /* Until end of input*/

    if (FFXREC.XXXCHAR[FFXINPIX] == " ") /* Leading space*/

      FFXREC.FFXINPIX = FFXREC.FFXINPIX - 1; /* Input byte index*/

    else

      FFXREC.FFXRTNCD = "1"; /* Indicate imbedded space*/

      return; /* Return to previous process*/

    end

  end

   /* ------------------------------------------------------------*/
   /* Calculate the resulting number into the return field.*/
   /* ------------------------------------------------------------*/

  FFXREC.FFXNUMB = FFXREC.FFXROUND * FFXREC.FFXSIGN;


end // end XSFFS15

// Get first division group row
Function XSFFS20()

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* This subroutine accesses the Summary Codes Lists Table*/
   /* and returns the first row found for a division group code.*/
   /* It may be used to verify a division group code and/or*/
   /* obtain the division group abbreviation.*/

   /* The division group must be specified by the calling process*/
   /* in YSMREC.*/

   /* The name of the calling process must be moved to TA1PGMNM*/
   /* in TA1REC, for Error Diagnosis Reporting.*/

   /* *** Code the following before this is executed:         ****/
   /* ***                                                     ****/
   /* ***   YSMREC.YSMSUMCD: Division group code.             ****/
   /* ***                                                     ****/
   /* ***   TA1REC.TA1PGMNM: The name of the calling process, ****/
   /* ***                    for Error Diagnosis Reporting.   ****/

   /* This subroutine will return the DB2 return code in*/
   /* SQLCA.SQLCODE and, if a normal return, the table row*/
   /* in YSMREC.*/

   /* *** Check the following after this is executed:         ****/
   /* ***                                                     ****/
   /* ***   SQLCA.SQLCODE                                     ****/
   /* ***   -------------                                     ****/
   /* ***     0  = Normal return                              ****/
   /* ***   100  = Table row not found                        ****/

   /* This subroutine will do any required Error Diagnosis*/
   /* Reporting to TA0020.  The calling process must check the*/
   /* return code and take the appropriate action relating to*/
   /* its terminal output.  The calling process does not need to*/
   /* do any Error Diagnosis Reporting.*/

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* ------------------------------------------------------------*/
   /* Select the set of rows from Summary Codes Lists Table.*/
   /* ------------------------------------------------------------*/

  YSMREC.YSMTBLPF = "XDV"; /* Table prefix*/
  YSMREC.YSMSYSPF = "FF"; /* System prefix*/
  YSMREC.YSMSUMID = -1; /* Summary identification*/
  YSMREC.YSMSRCVL = "****"; /* Source code value*/

  try
    call "IO2640" ("S1", SQLCA, YSMREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select table set*/

   /* ------------------------------------------------------------*/
   /* If successful, continue to fetch the first selected row.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/

     /* NEXT SENTENCE               ; Next sentence*/

  else

    /* ------------------------------------------------------------*/
     /* If data not available, post an error message and return.*/
     /* Otherwise, indicate that a system error has occurred.*/
    /* ------------------------------------------------------------*/

    TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
    TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

    TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
    TA1REC.TA1LOC = "XSFFS20 SELECT DIVISION CODE SET";
    TA1REC.TA1DBASE = "DCORP   "; /* Data base name*/
    TA1REC.TA1TBLVU = "VSUMCD01"; /* Table view name*/
    TA1REC.TA1TBLKE = YSMREC.YSMGRP; /* Table key*/

    if (sysVar.errorCode == "00000000" /* Call successful*/
     && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

      TA1REC.TA1FUNC = "POST"; /* Termination function*/
      call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

      converseLib.validationFailed(47); /* Data in use by another*/

    else

      TA1REC.TA1FUNC = "RETN"; /* Termination function*/
      call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

      converseLib.validationFailed(1); /* System error occurred*/

    end

    FFWREC.XXXMODID = "X20"; /* Module identification*/

    exit stack; /* Exit to display map*/

  end

   /* ------------------------------------------------------------*/
   /* Fetch the first row from Summary Codes Lists Table.*/
   /* ------------------------------------------------------------*/

  try
    call "IO2640" ("N1", SQLCA, YSMREC) {isNoRefresh = yes, isExternal = yes};
  end /* Fetch table row*/

   /* ------------------------------------------------------------*/
   /* Save the SQL commarea from the fetch.*/
   /* ------------------------------------------------------------*/

  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Commarea from fetch*/

   /* ------------------------------------------------------------*/
   /* If successful or row not found, continue to close the set.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/

     /* NEXT SENTENCE               ; Next sentence*/

  else

    if (sysVar.errorCode == "00000000" /* Call successful*/
     && SQLCA.VAGen_SQLCODE == 100)    /* and row not found*/

      YSMREC.YSMSMDSC = "??????"; /* Default abbreviation*/

    else

      /* ------------------------------------------------------------*/
       /* If data not available, post an error message and return.*/
       /* Otherwise, indicate that a system error has occurred.*/
      /* ------------------------------------------------------------*/

      TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/

      TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
      TA1REC.TA1LOC = "XSFFS20 FETCH FIRST DIVISION CODE";
      TA1REC.TA1DBASE = "DCORP   "; /* Data base name*/
      TA1REC.TA1TBLVU = "VSUMCD01"; /* Table view name*/
      TA1REC.TA1TBLKE = YSMREC.YSMGRP; /* Table key*/

      if (sysVar.errorCode == "00000000" /* Call successful*/
       && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

        TA1REC.TA1FUNC = "POST"; /* Termination function*/
        call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes};
                                   /* Error diagnosis routine*/

        converseLib.validationFailed(47); /* Data in use by another*/

      else

        TA1REC.TA1FUNC = "RETN"; /* Termination function*/
        call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

        converseLib.validationFailed(1); /* System error occurred*/

      end

      FFWREC.XXXMODID = "X20"; /* Module identification*/

      exit stack; /* Exit to display map*/

    end

  end

   /* ------------------------------------------------------------*/
   /* Close the set of rows from Production Style/Color Table.*/
   /* ------------------------------------------------------------*/

  try
    call "IO2640" ("C1", SQLCA, YSMREC) {isNoRefresh = yes, isExternal = yes};
  end /* Close table set*/

   /* ------------------------------------------------------------*/
   /* If successful, restore SQLCA and return to calling process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/

    SQLCA.SQLCAREC = TAEREC.SQLCAREC; /* Commarea from fetch*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "XSFFS20 CLOSE DIVISION CODE SET";
  TA1REC.TA1DBASE = "DCORP   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VSUMCD01"; /* Table view name*/
  TA1REC.TA1TBLKE = YSMREC.YSMGRP; /* Table key*/

  TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

  FFWREC.XXXMODID = "X20"; /* Module identification*/
  converseLib.validationFailed(1); /* System error occurred*/

  exit stack; /* Exit to display map*/


end // end XSFFS20

// Get the first style group row
Function XSFFS22()

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* This subroutine accesses the Footwear Forecast Style Table*/
   /* and returns the first row found for a style group number.*/
   /* It may be used to verify a style group number and/or obtain*/
   /* the style group abbreviation.*/

   /* The style group must be specified by the calling process*/
   /* in FF3REC.*/

   /* The name of the calling process must be moved to TA1PGMNM*/
   /* in TA1REC, for Error Diagnosis Reporting.*/

   /* *** Code the following before this is executed:         ****/
   /* ***                                                     ****/
   /* ***   FF3REC.SYBSTGNB: Style group number.              ****/
   /* ***                                                     ****/
   /* ***   TA1REC.TA1PGMNM: The name of the calling process, ****/
   /* ***                    for Error Diagnosis Reporting.   ****/

   /* This subroutine will return the DB2 return code in*/
   /* SQLCA.SQLCODE and, if a normal return, the table row*/
   /* in FF3REC.*/

   /* *** Check the following after this is executed:         ****/
   /* ***                                                     ****/
   /* ***   SQLCA.SQLCODE                                     ****/
   /* ***   -------------                                     ****/
   /* ***     0  = Normal return                              ****/
   /* ***   100  = Table row not found                        ****/

   /* This subroutine will do any required Error Diagnosis*/
   /* Reporting to TA0020.  The calling process must check the*/
   /* return code and take the appropriate action relating to*/
   /* its terminal output.  The calling process does not need to*/
   /* do any Error Diagnosis Reporting.*/

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* ------------------------------------------------------------*/
   /* Select the set of rows from Footwear Forecast Style Table.*/
   /* ------------------------------------------------------------*/

  try
    call "IO3990" ("S1", SQLCA, FF3REC) {isNoRefresh = yes, isExternal = yes};
  end /* Select table set*/

   /* ------------------------------------------------------------*/
   /* If successful, continue to fetch the first selected row.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/

     /* NEXT SENTENCE               ; Next sentence*/

  else

    /* ------------------------------------------------------------*/
     /* If data not available, post an error message and return.*/
     /* Otherwise, indicate that a system error has occurred.*/
    /* ------------------------------------------------------------*/

    TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
    TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

    TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
    TA1REC.TA1LOC = "XSFFS22 SELECT STYLE GROUP SET";
    TA1REC.TA1DBASE = "DFCAST  "; /* Data base name*/
    TA1REC.TA1TBLVU = "VFFSTY01"; /* Table view name*/
    TA1REC.TA1TBLKE = FF3REC.FF3KEY2; /* Table key*/

    if (sysVar.errorCode == "00000000" /* Call successful*/
     && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

      TA1REC.TA1FUNC = "POST"; /* Termination function*/
      call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

      converseLib.validationFailed(47); /* Data in use by another*/

    else

      TA1REC.TA1FUNC = "RETN"; /* Termination function*/
      call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

      converseLib.validationFailed(1); /* System error occurred*/

    end

    FFWREC.XXXMODID = "X22"; /* Module identification*/

    exit stack; /* Exit to display map*/

  end

   /* ------------------------------------------------------------*/
   /* Fetch the first row from the Footwear Forecast Style Table.*/
   /* ------------------------------------------------------------*/

  try
    call "IO3990" ("N1", SQLCA, FF3REC) {isNoRefresh = yes, isExternal = yes};
  end /* Fetch table row*/

   /* ------------------------------------------------------------*/
   /* Save the SQL commarea from the fetch.*/
   /* ------------------------------------------------------------*/

  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Commarea from fetch*/

   /* ------------------------------------------------------------*/
   /* If successful or row not found, continue to close the set.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/

     /* NEXT SENTENCE               ; Next sentence*/

  else

    if (sysVar.errorCode == "00000000" /* Call successful*/
     && SQLCA.VAGen_SQLCODE == 100)    /* and row not found*/

      FF3REC.SYBSTGNM = "??????"; /* Default style group name*/

    else

      /* ------------------------------------------------------------*/
       /* If data not available, post an error message and return.*/
       /* Otherwise, indicate that a system error has occurred.*/
      /* ------------------------------------------------------------*/

      TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/

      TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
      TA1REC.TA1LOC = "XSFFS22 FETCH FIRST STYLE GROUP";
      TA1REC.TA1DBASE = "DFCAST  "; /* Data base name*/
      TA1REC.TA1TBLVU = "VFFSTY01"; /* Table view name*/
      TA1REC.TA1TBLKE = FF3REC.FF3KEY2; /* Table key*/

      if (sysVar.errorCode == "00000000" /* Call successful*/
       && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

        TA1REC.TA1FUNC = "POST"; /* Termination function*/
        call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes};
                                   /* Error diagnosis routine*/

        converseLib.validationFailed(47); /* Data in use by another*/

      else

        TA1REC.TA1FUNC = "RETN"; /* Termination function*/
        call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

        converseLib.validationFailed(1); /* System error occurred*/

      end

      FFWREC.XXXMODID = "X22"; /* Module identification*/

      exit stack; /* Exit to display map*/

    end

  end

   /* ------------------------------------------------------------*/
   /* Close the set of rows from Production Style/Color Table.*/
   /* ------------------------------------------------------------*/

  try
    call "IO3990" ("C1", SQLCA, FF3REC) {isNoRefresh = yes, isExternal = yes};
  end /* Close table set*/

   /* ------------------------------------------------------------*/
   /* If successful, restore SQLCA and return to calling process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/

    /* ------------------------------------------------------------*/
     /* Restore the SQL commarea from the fetch.*/
    /* ------------------------------------------------------------*/

    SQLCA.SQLCAREC = TAEREC.SQLCAREC; /* Commarea from fetch*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "XSFFS22 CLOSE STYLE GROUP SET";
  TA1REC.TA1DBASE = "DFCAST  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VFFSTY01"; /* Table view name*/
  TA1REC.TA1TBLKE = FF3REC.FF3KEY2; /* Table key*/

  TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

  FFWREC.XXXMODID = "X22"; /* Module identification*/
  converseLib.validationFailed(1); /* System error occurred*/

  exit stack; /* Exit to display map*/


end // end XSFFS22

// Edit the date range
Function XSFFS30()

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* This subroutine will edit the beginning and ending dates*/
   /* of a range in YYMM format and return the dates in CCYYMM*/
   /* format, along with an array containing each individual*/
   /* month in the range.*/

   /* If this subroutine is invoked by short range application,*/
   /* the range check against the current month should be*/
   /* bypassed. Only non-zero date checking and valid date*/
   /* checking should be used.*/

   /* The beginning month should not be less than the current*/
   /* month plus the number of month passed over and greater*/
   /* than the current plus 30 months. The ending month should*/
   /* not be less than the beginning month, greater than the*/
   /* beginning plus 11 months (optional) and greater than the*/
   /* current plus 30 months.*/

   /* The name of the calling process must be moved to TA1PGMNM*/
   /* in TA1REC, for Error Diagnosis Reporting.*/

   /* *** Code the following before this is executed:         ****/
   /* ***                                                     ****/
   /* ***  FFZREC.FFZMONTH:                                   ****/
   /* ***      The minimum number of months in the future     ****/
   /* ***      that the range must begin.                     ****/
   /* ***                                                     ****/
   /* ***  FFZREC.FFZCHK12:                                   ****/
   /* ***      Specify 'N' if range not limited to 12 months. ****/
   /* ***                                                     ****/
   /* ***  FFZREC.FFZSRANG:                                   ****/
   /* ***      Specify 'Y' if invoked by short range program. ****/
   /* ***                                                     ****/
   /* ***  FFZREC.FFZBYYMM, FFZREC.FFZEYYMM:                  ****/
   /* ***      The range to be edited must be in YYMM format. ****/
   /* ***                                                     ****/
   /* ***  TA1REC.TA1PGMNM: The name of the calling process,  ****/
   /* ***                   for Error Diagnosis Reporting.    ****/

   /* If any error is found during editing, it is indicated by*/
   /* the completion code in FFZREC.FFZBEGRC and FFZREC.FFZENDRC.*/
   /* If no error is found, the converted dates will be returned*/
   /* in FFZREC.FFZBEGMO, FFZREC.FFZENDMO and FFZREC.FFZINDMO.*/

   /* *** Both return codes must indicate normal return.      ****/
   /* ***                                                     ****/
   /* ***   FFZREC.FFZBEGRC, FFZREC.FFZENDRC:                 ****/
   /* ***      '0' = Normal return                            ****/
   /* ***      '1' = No date in the field                     ****/
   /* ***      '2' = Invalid date entered                     ****/
   /* ***      '3' = Date out of range                        ****/
   /* ***                                                     ****/
   /* ***  FFZREC.FFZBEGMO, FFZREC.FFZENDMO:                  ****/
   /* ***      The dates will be returned in CCYYMM format.   ****/
   /* ***                                                     ****/
   /* ***  FFZREC.FFZNUMMO, FFZREC.FFZINDMO:                  ****/
   /* ***      The number of months in the range and each     ****/
   /* ***      individual month.  Not returned if CHK12 = N.  ****/

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* ---------  --------  --------  -------------------------------*/
   /* control     date     name        description*/
   /* ---------  --------  --------  -------------------------------*/
   /* ff1117    04/24/92   JJUCH     Enlarge the legal range to*/
   /* current date + 3 years.*/
   /* ----------------------------------------------------------------------*/

   /* ------------------------------------------------------------*/
   /* Initialize the return codes and return dates.*/
   /* ------------------------------------------------------------*/

  FFZREC.FFZBEGRC = "0"; /* Beginning date return code*/
  FFZREC.FFZENDRC = "0"; /* Ending date return code*/

  FFZREC.FFZNUMMO = 0; /* Number of months in range*/
  move 0 to FFZREC.FFZINDMO[1] for all; /* Individual month in range*/

   /* ------------------------------------------------------------*/
   /* Indicate error if the date is zero.*/
   /* ------------------------------------------------------------*/

  if (FFZREC.FFZBEGMO == 0 /* Beginning date missing*/
   || FFZREC.FFZENDMO == 0) /* or ending date missing*/

    if (FFZREC.FFZBEGMO == 0) /* Beginning date missing*/
      FFZREC.FFZBEGRC = "1"; /* Indicate no beginning date*/
    end

    if (FFZREC.FFZENDMO == 0) /* Ending date missing*/
      FFZREC.FFZENDRC = "1"; /* Indicate no ending date*/
    end

    return; /* Return to calling process*/

  end

   /* ------------------------------------------------------------*/
   /* Convert format of beginning month from YYMM to CCYYMM.*/
   /* ------------------------------------------------------------*/

  set TA2REC empty; /* clear row storage area*/

  TA2REC.TA2DTOPT = "GREGGREG"; /* option*/
  TA2REC.TA2GRTYP = "E"; /* type*/
  TA2REC.TA2GRGDD = 01; /* dd to be validated*/

  TA2REC.TA2GRGYM = FFZREC.FFZBYYMM; /* Beginning yymm to be validatd*/

  try
    call "TA0040" (TA2REC) {isNoRefresh = yes, isExternal = yes};
  end /* date routine*/

   /* ------------------------------------------------------------*/
   /* Indicate error if the date doesn't pass the verification.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && TA2REC.TA2RTNCD < 888)         /* and subroutine completed*/

    if (TA2REC.TA2RTNCD == 0) /* Normal return code*/

      FFZREC.FFZBEGMO = TA2REC.TA2GRCYM; /* Convert beginning month*/
    else
      FFZREC.FFZBEGRC = "2"; /* Indicate invalid date entered*/

    end

  else

    TAEREC.TAEDESC1 = sysVar.errorCode;
    TAEREC.TAEDESC2 = TA2REC.TA2GROUP;

    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    TA1REC.TA1TYPE = "APPL"; /* Type of error*/
    TA1REC.TA1LOC = "XSFFS30 EDIT THE BEGINNING MONTH";

    call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

    FFWREC.XXXMODID = "X30"; /* Module identification*/
    converseLib.validationFailed(1); /* System error occurred*/

    exit stack; /* exit to display map*/

  end

   /* ------------------------------------------------------------*/
   /* Convert format of ending month from YYMM to CCYYMM.*/
   /* ------------------------------------------------------------*/

  TA2REC.TA2CENT = 0; /* Initialize century field*/
  TA2REC.TA2GRGYM = FFZREC.FFZEYYMM; /* Ending yymm to be validated*/

  try
    call "TA0040" (TA2REC) {isNoRefresh = yes, isExternal = yes};
  end /* date routine*/

   /* ------------------------------------------------------------*/
   /* Indicate error if the date doesn't pass the verification.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && TA2REC.TA2RTNCD < 888)         /* and subroutine completed*/

    if (TA2REC.TA2RTNCD == 0) /* Normal return code*/

      FFZREC.FFZENDMO = TA2REC.TA2GRCYM; /* Convert ending month*/
    else
      FFZREC.FFZENDRC = "2"; /* Indicate invalid date entered*/

    end

  else

    TAEREC.TAEDESC1 = sysVar.errorCode;
    TAEREC.TAEDESC2 = TA2REC.TA2GROUP;

    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    TA1REC.TA1TYPE = "APPL"; /* Type of error*/
    TA1REC.TA1LOC = "XSFFS30 EDIT THE ENDING MONTH";

    call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

    FFWREC.XXXMODID = "X30"; /* Module identification*/
    converseLib.validationFailed(1); /* System error occurred*/

    exit stack; /* exit to display map*/

  end

   /* ------------------------------------------------------------*/
   /* If an error was found, return to the calling process.*/
   /* ------------------------------------------------------------*/

  if (FFZREC.FFZBEGRC == "2" /* Invalid beginning date*/
   || FFZREC.FFZENDRC == "2") /* or invalid ending date*/

    return; /* Return to calling process*/

  end


   /* -------------------------------------------------------*/
   /* Obtain the current date*/
   /* -------------------------------------------------------*/

  XX0XS01(); /* Obtain the current date*/

   /* ------------------------------------------------------------*/
   /* Check if the calling program is a short range application.*/
   /* If it is, bypass the checking against the current date.*/
   /* ------------------------------------------------------------*/

  if (FFZREC.FFZSRANG == "Y")

    FFZREC.FFZWEND = FFZREC.FFZBEGMO + 11; /* Beginning plus 11 months*/

    if (FFZREC.FFZWEMM > 12) /* month field over 12*/

      FFZREC.FFZWEMM = FFZREC.FFZWEMM - 12;
      FFZREC.FFZWEYY = FFZREC.FFZWEYY + 1;

    end

    if (FFZREC.FFZENDMO < FFZREC.FFZBEGMO /* less than beginning mo.*/
     || FFZREC.FFZENDMO > FFZREC.FFZWEND) /* Over 12 months*/
      FFZREC.FFZENDRC = "3"; /* Indicate invalid date*/
    end

  else

    /* ------------------------------------------------------------*/
     /* Obtain the qualified range which will be used to verify*/
     /* the dates passed over.*/
    /* ------------------------------------------------------------*/

    FFZREC.FFZWBEG = XX0XW01.XX0XWCYM + FFZREC.FFZMONTH;

    if (FFZREC.FFZWBMM > 12) /* month field over 12*/

      FFZREC.FFZWBMM = FFZREC.FFZWBMM - 12;
      FFZREC.FFZWBYY = FFZREC.FFZWBYY + 1;

    end

    FFZREC.FFZWEND = FFZREC.FFZBEGMO + 11; /* Beginning plus 11 months*/

    if (FFZREC.FFZWEMM > 12) /* month field over 12*/

      FFZREC.FFZWEMM = FFZREC.FFZWEMM - 12;
      FFZREC.FFZWEYY = FFZREC.FFZWEYY + 1;

    end

    FFZREC.FFZWRNG = XX0XW01.XX0XWCYM; /* Initialize range field*/
    FFZREC.FFZWRYY = FFZREC.FFZWRYY + 3; /* Current year plus 3 years*/
    if (FFZREC.FFZWRMM == 1)
      FFZREC.FFZWRMM = 12;
      FFZREC.FFZWRYY = FFZREC.FFZWRYY - 1;
    else
      FFZREC.FFZWRMM = FFZREC.FFZWRMM - 1;
    end

    /* ------------------------------------------------------------*/
     /* Indicate error if the date is out of allowable bounds.*/
    /* ------------------------------------------------------------*/

    if (FFZREC.FFZBEGMO < FFZREC.FFZWBEG /* Less than valid starting mo.*/
     || FFZREC.FFZBEGMO > FFZREC.FFZWRNG) /* or Greater than valid rang*/

      FFZREC.FFZBEGRC = "3"; /* Indicate invalid date*/

    end

    if (FFZREC.FFZENDMO < FFZREC.FFZBEGMO /* less than beginning mo.*/
     || FFZREC.FFZENDMO > FFZREC.FFZWRNG) /* or greater than valid range*/

      FFZREC.FFZENDRC = "3"; /* Indicate invalid date*/

    end

    if (FFZREC.FFZCHK12 == "N") /* Check 12 month limit*/

       /* NEXT SENTENCE*/

    else

      if (FFZREC.FFZENDMO > FFZREC.FFZWEND) /* Over 12 months*/
        FFZREC.FFZENDRC = "3"; /* Indicate invalid date*/
      end

    end

  end

   /* ------------------------------------------------------------*/
   /* If an error was found, return to the calling process.*/
   /* ------------------------------------------------------------*/

  if (FFZREC.FFZBEGRC == "3" /* Beginning date out of range*/
   || FFZREC.FFZENDRC == "3") /* or ending date out of range*/

    return; /* Return to calling process*/

  end

   /* ------------------------------------------------------------*/
   /* If range may exceed 12 months, return to calling process.*/
   /* ------------------------------------------------------------*/

  if (FFZREC.FFZCHK12 == "N") /* Check 12 month limit*/
    return; /* Return to calling process*/
  end

   /* ------------------------------------------------------------*/
   /* Format the array with the individual months in the range.*/
   /* ------------------------------------------------------------*/

  FFZREC.FFZWBEG = FFZREC.FFZBEGMO; /* Beginning month*/

  while (FFZREC.FFZWBEG <= FFZREC.FFZENDMO) /* Until end of range*/

    FFZREC.FFZNUMMO = FFZREC.FFZNUMMO + 1; /* Number of months*/

    FFZREC.FFZINDMO[FFZNUMMO] = FFZREC.FFZWBEG; /* Individual month*/

    FFZREC.FFZWBMM = FFZREC.FFZWBMM + 1; /* Increment month*/

    if (FFZREC.FFZWBMM > 12) /* Month greater than 12*/

      FFZREC.FFZWBMM = FFZREC.FFZWBMM - 12; /* Decrement month*/
      FFZREC.FFZWBYY = FFZREC.FFZWBYY + 1; /* Increment year*/

    end

  end


end // end XSFFS30

// Edit the date range
Function XSFFS35()

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* This subroutine will edit the beginning and ending dates*/
   /* of a range in YYMM format and return the dates in CCYYMM*/
   /* format, along with an array containing each individual*/
   /* month in the range.*/

   /* This subroutine is invoked by production forecast*/
   /* applications only.*/

   /* The beginning month should not be less than the future*/
   /* cut off month plus the number of month passed over and*/
   /* greater than the current plus 30 months. The ending month*/
   /* should not be less than the beginning month, greater than*/
   /* the beginning plus 11 months (optional) and greater than*/
   /* the current plus 30 months.*/

   /* The name of the calling process must be moved to TA1PGMNM*/
   /* in TA1REC, for Error Diagnosis Reporting.*/

   /* *** Code the following before this is executed:         ****/
   /* ***                                                     ****/
   /* ***  FFZREC.FFZMONTH:                                   ****/
   /* ***      The minimum number of months in the future     ****/
   /* ***      that the range must begin.                     ****/
   /* ***                                                     ****/
   /* ***  FFZREC.FFZCHK12:                                   ****/
   /* ***      Specify 'N' if range not limited to 12 months. ****/
   /* ***                                                     ****/
   /* ***  FFZREC.FFZSRANG:                                   ****/
   /* ***      Specify 'N'.                                   ****/
   /* ***                                                     ****/
   /* ***  FFZREC.FFZBYYMM, FFZREC.FFZEYYMM:                  ****/
   /* ***      The range to be edited must be in YYMM format. ****/
   /* ***                                                     ****/
   /* ***  TA1REC.TA1PGMNM: The name of the calling process,  ****/
   /* ***                   for Error Diagnosis Reporting.    ****/

   /* If any error is found during editing, it is indicated by*/
   /* the completion code in FFZREC.FFZBEGRC and FFZREC.FFZENDRC.*/
   /* If no error is found, the converted dates will be returned*/
   /* in FFZREC.FFZBEGMO, FFZREC.FFZENDMO and FFZREC.FFZINDMO.*/

   /* *** Both return codes must indicate normal return.      ****/
   /* ***                                                     ****/
   /* ***   FFZREC.FFZBEGRC, FFZREC.FFZENDRC:                 ****/
   /* ***      '0' = Normal return                            ****/
   /* ***      '1' = No date in the field                     ****/
   /* ***      '2' = Invalid date entered                     ****/
   /* ***      '3' = Date out of range                        ****/
   /* ***                                                     ****/
   /* ***  FFZREC.FFZBEGMO, FFZREC.FFZENDMO:                  ****/
   /* ***      The dates will be returned in CCYYMM format.   ****/
   /* ***                                                     ****/
   /* ***  FFZREC.FFZNUMMO, FFZREC.FFZINDMO:                  ****/
   /* ***      The number of months in the range and each     ****/
   /* ***      individual month.  Not returned if CHK12 = N.  ****/

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* ---------  --------  --------  -------------------------------*/
   /* control     date     name        description*/
   /* ---------  --------  --------  -------------------------------*/
   /* ff1117    04/24/92   JJUCH     Enlarge the legal range to*/
   /* current date + 3 years.*/
   /* ----------------------------------------------------------------------*/

   /* ------------------------------------------------------------*/
   /* Initialize the return codes and return dates.*/
   /* ------------------------------------------------------------*/

  FFZREC.FFZBEGRC = "0"; /* Beginning date return code*/
  FFZREC.FFZENDRC = "0"; /* Ending date return code*/

  FFZREC.FFZNUMMO = 0; /* Number of months in range*/
  move 0 to FFZREC.FFZINDMO[1] for all; /* Individual month in range*/

   /* ------------------------------------------------------------*/
   /* Indicate error if the date is zero.*/
   /* ------------------------------------------------------------*/

  if (FFZREC.FFZBEGMO == 0 /* Beginning date missing*/
   || FFZREC.FFZENDMO == 0) /* or ending date missing*/

    if (FFZREC.FFZBEGMO == 0) /* Beginning date missing*/
      FFZREC.FFZBEGRC = "1"; /* Indicate no beginning date*/
    end

    if (FFZREC.FFZENDMO == 0) /* Ending date missing*/
      FFZREC.FFZENDRC = "1"; /* Indicate no ending date*/
    end

    return; /* Return to calling process*/

  end

   /* ------------------------------------------------------------*/
   /* Convert format of beginning month from YYMM to CCYYMM.*/
   /* ------------------------------------------------------------*/

  set TA2REC empty; /* clear row storage area*/

  TA2REC.TA2DTOPT = "GREGGREG"; /* option*/
  TA2REC.TA2GRTYP = "E"; /* type*/
  TA2REC.TA2GRGDD = 01; /* dd to be validated*/

  TA2REC.TA2GRGYM = FFZREC.FFZBYYMM; /* Beginning yymm to be validatd*/

  try
    call "TA0040" (TA2REC) {isNoRefresh = yes, isExternal = yes};
  end /* date routine*/

   /* ------------------------------------------------------------*/
   /* Indicate error if the date doesn't pass the verification.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && TA2REC.TA2RTNCD < 888)         /* and subroutine completed*/

    if (TA2REC.TA2RTNCD == 0) /* Normal return code*/

      FFZREC.FFZBEGMO = TA2REC.TA2GRCYM; /* Convert beginning month*/
    else
      FFZREC.FFZBEGRC = "2"; /* Indicate invalid date entered*/

    end

  else

    TAEREC.TAEDESC1 = sysVar.errorCode;
    TAEREC.TAEDESC2 = TA2REC.TA2GROUP;

    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    TA1REC.TA1TYPE = "APPL"; /* Type of error*/
    TA1REC.TA1LOC = "XSFFS35 EDIT THE BEGINNING MONTH";

    call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

    FFWREC.XXXMODID = "X35"; /* Module identification*/
    converseLib.validationFailed(1); /* System error occurred*/

    exit stack; /* exit to display map*/

  end

   /* ------------------------------------------------------------*/
   /* Convert format of ending month from YYMM to CCYYMM.*/
   /* ------------------------------------------------------------*/

  TA2REC.TA2CENT = 0; /* Initialize century field*/
  TA2REC.TA2GRGYM = FFZREC.FFZEYYMM; /* Ending yymm to be validated*/

  try
    call "TA0040" (TA2REC) {isNoRefresh = yes, isExternal = yes};
  end /* date routine*/

   /* ------------------------------------------------------------*/
   /* Indicate error if the date doesn't pass the verification.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && TA2REC.TA2RTNCD < 888)         /* and subroutine completed*/

    if (TA2REC.TA2RTNCD == 0) /* Normal return code*/

      FFZREC.FFZENDMO = TA2REC.TA2GRCYM; /* Convert ending month*/
    else
      FFZREC.FFZENDRC = "2"; /* Indicate invalid date entered*/

    end

  else

    TAEREC.TAEDESC1 = sysVar.errorCode;
    TAEREC.TAEDESC2 = TA2REC.TA2GROUP;

    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    TA1REC.TA1TYPE = "APPL"; /* Type of error*/
    TA1REC.TA1LOC = "XSFFS35 EDIT THE ENDING MONTH";

    call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

    FFWREC.XXXMODID = "X35"; /* Module identification*/
    converseLib.validationFailed(1); /* System error occurred*/

    exit stack; /* exit to display map*/

  end

   /* ------------------------------------------------------------*/
   /* If an error was found, return to the calling process.*/
   /* ------------------------------------------------------------*/

  if (FFZREC.FFZBEGRC == "2" /* Invalid beginning date*/
   || FFZREC.FFZENDRC == "2") /* or invalid ending date*/

    return; /* Return to calling process*/

  end

   /* -------------------------------------------------------*/
   /* Obtain the future cut off date*/
   /* -------------------------------------------------------*/

  set FF1REC empty; /* Clear row storage area*/

  try
    call "IO3660" ("S ", SQLCA, FF1REC) {isNoRefresh = yes, isExternal = yes};
  end /* Select set*/

   /* ------------------------------------------------------------*/
   /* If successful return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Normal return code*/

       /* Next sentence*/

    end
  else

    /* ------------------------------------------------------------*/
     /* indicate that a system error has occurred.*/
    /* ------------------------------------------------------------*/

    TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
    TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL Commarea*/

    FFWREC.XXXMODID = "X35"; /* Module identification*/

    if (sysVar.errorCode == "00000000" /* Call successful*/
     && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

      converseLib.validationFailed(47); /* Indicate not available*/
      TA1REC.TA1FUNC = "POST"; /* Termination function*/

    else

      converseLib.validationFailed(1); /* Indicate system error*/
      TA1REC.TA1FUNC = "RETN"; /* Termination function*/


    end

    TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
    TA1REC.TA1LOC = "SELECT DFCAST.VFFCTL01 ROW";
    TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
    TA1REC.TA1PGMNO = FFWREC.XXXMODID; /* Program number*/
    TA1REC.TA1DBASE = "DFCAST  "; /* Data base name*/
    TA1REC.TA1TBLVU = "VFFCTL01"; /* Table view name*/
    TA1REC.TA1TBLKE = FF1REC.FF1GROUP; /* Table key*/

    call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    exit stack; /* exit to display map*/

  end

   /* -------------------------------------------------------*/
   /* Obtain the current date*/
   /* -------------------------------------------------------*/

  XX0XS01(); /* Obtain the current date*/

   /* ------------------------------------------------------------*/
   /* Obtain the qualified range which will be used to verify*/
   /* the dates passed over.*/
   /* ------------------------------------------------------------*/

  FFZREC.FFZWBEG = FF1REC.FF1FUTDT / 100 + FFZREC.FFZMONTH;

  if (FFZREC.FFZWBMM > 12) /* month field over 12*/

    FFZREC.FFZWBMM = FFZREC.FFZWBMM - 12;
    FFZREC.FFZWBYY = FFZREC.FFZWBYY + 1;

  end

  FFZREC.FFZWEND = FFZREC.FFZBEGMO + 11; /* Beginning plus 11 months*/

  if (FFZREC.FFZWEMM > 12) /* month field over 12*/

    FFZREC.FFZWEMM = FFZREC.FFZWEMM - 12;
    FFZREC.FFZWEYY = FFZREC.FFZWEYY + 1;

  end

  FFZREC.FFZWRNG = XX0XW01.XX0XWCYM; /* Initialize range field*/
  FFZREC.FFZWRYY = FFZREC.FFZWRYY + 3; /* Current year plus 3 years*/
  if (FFZREC.FFZWRMM == 1)
    FFZREC.FFZWRMM = 12;
    FFZREC.FFZWRYY = FFZREC.FFZWRYY - 1;
  else
    FFZREC.FFZWRMM = FFZREC.FFZWRMM - 1;
  end

   /* ------------------------------------------------------------*/
   /* Indicate error if the date is out of allowable bounds.*/
   /* ------------------------------------------------------------*/

  if (FFZREC.FFZBEGMO < FFZREC.FFZWBEG /* Less than valid starting mo.*/
   || FFZREC.FFZBEGMO > FFZREC.FFZWRNG) /* or Greater than valid rang*/

    FFZREC.FFZBEGRC = "3"; /* Indicate invalid date*/

  end

  if (FFZREC.FFZENDMO < FFZREC.FFZBEGMO /* less than beginning mo.*/
   || FFZREC.FFZENDMO > FFZREC.FFZWRNG) /* or greater than valid range*/

    FFZREC.FFZENDRC = "3"; /* Indicate invalid date*/

  end

  if (FFZREC.FFZCHK12 == "N") /* Check 12 month limit*/

     /* NEXT SENTENCE*/

  else

    if (FFZREC.FFZENDMO > FFZREC.FFZWEND) /* Over 12 months*/
      FFZREC.FFZENDRC = "3"; /* Indicate invalid date*/
    end

  end

   /* ------------------------------------------------------------*/
   /* If an error was found, return to the calling process.*/
   /* ------------------------------------------------------------*/

  if (FFZREC.FFZBEGRC == "3" /* Beginning date out of range*/
   || FFZREC.FFZENDRC == "3") /* or ending date out of range*/

    return; /* Return to calling process*/

  end

   /* ------------------------------------------------------------*/
   /* If range may exceed 12 months, return to calling process.*/
   /* ------------------------------------------------------------*/

  if (FFZREC.FFZCHK12 == "N") /* Check 12 month limit*/
    return; /* Return to calling process*/
  end

   /* ------------------------------------------------------------*/
   /* Format the array with the individual months in the range.*/
   /* ------------------------------------------------------------*/

  FFZREC.FFZWBEG = FFZREC.FFZBEGMO; /* Beginning month*/

  while (FFZREC.FFZWBEG <= FFZREC.FFZENDMO) /* Until end of range*/

    FFZREC.FFZNUMMO = FFZREC.FFZNUMMO + 1; /* Number of months*/

    FFZREC.FFZINDMO[FFZNUMMO] = FFZREC.FFZWBEG; /* Individual month*/

    FFZREC.FFZWBMM = FFZREC.FFZWBMM + 1; /* Increment month*/

    if (FFZREC.FFZWBMM > 12) /* Month greater than 12*/

      FFZREC.FFZWBMM = FFZREC.FFZWBMM - 12; /* Decrement month*/
      FFZREC.FFZWBYY = FFZREC.FFZWBYY + 1; /* Increment year*/

    end

  end


end // end XSFFS35

// Summarize VFHCAT01 quantities
Function XSFFS50()

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* This subroutine will access the Footwear Category History*/
   /* Table using product type group code and summarize the*/
   /* quantity fields in the table for the date range specified*/
   /* by the calling process.*/

   /* The product type group code, the product category code,*/
   /* the life cycle code, the quality code, the order type group*/
   /* code, and the production national account flag code must*/
   /* be specified by the calling process in FH3REC.*/

   /* The range beginning month and the range ending month must*/
   /* be specified by the calling process in FFFREC.*/

   /* The name of the calling process must be move to TA1PGMNM*/
   /* in TA1REC, for Error Diagnosis Reporting.*/

   /* *** Code the following before this is executed:         ****/
   /* ***                                                     ****/
   /* ***   FH3REC.XPRCD:    The product type group code or   ****/
   /* ***                    '*' to select codes 01 and 02.   ****/
   /* ***                                                     ****/
   /* ***   FH3REC.XPCCD:    The product category code.       ****/
   /* ***                                                     ****/
   /* ***   FH3REC.XLCCD:    The life cycle code.             ****/
   /* ***                                                     ****/
   /* ***   FH3REC.XQACD:    The quality code.                ****/
   /* ***                                                     ****/
   /* ***   FH3REC.YSMXOT:   The order type group code or     ****/
   /* ***                    '*' to select all codes.         ****/
   /* ***                                                     ****/
   /* ***   FH3REC.FH1PNAC:  The national account flag or     ****/
   /* ***                    '*' to select all flags.         ****/
   /* ***                                                     ****/
   /* ***   FFFREC.FFFBEGMO: The range beginning month.       ****/
   /* ***                                                     ****/
   /* ***   FFFREC.FFFENDMO: The range ending month.          ****/
   /* ***                                                     ****/
   /* ***   TA1REC.TA1PGMNM: The name of the calling process, ****/
   /* ***                    for Error Diagnosis Reporting.   ****/

   /* The subroutine will return summarized quantities in FH3REC.*/

   /* This subroutine will do any required Error Diagnosis*/
   /* Reporting to TA0020.  The calling process does not need to*/
   /* do any Error Diagnosis Reporting.*/

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* ------------------------------------------------------------*/
   /* Call the subroutine to summarize the selected quantities.*/
   /* ------------------------------------------------------------*/

  FFFREC.FFFFUNCD = "SS"; /* Function code*/

  try
    call "FF5500" (FFFREC, SQLCA, FH3REC, TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes};
  end

   /* ------------------------------------------------------------*/
   /* If call was successful, return to the calling process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* If data not available, indicate data in use by another.*/
   /* ------------------------------------------------------------*/

  FFWREC.XXXMODID = "X50"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    converseLib.validationFailed(47); /* Data in use by another*/

    exit stack; /* Exit to display map*/

  end

   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/

     /* NEXT SENTENCE*/

  else

    TA1REC.TA1TYPE = "APPL"; /* Type of error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    TA1REC.TA1LOC = "XSFFS50 SUM VFHCAT01 QUANTITIES";
    TAEREC.TAEDESC1 = "SUBROUTINE FF5500 CALL WAS NOT SUCCESSFUL";
    TAEREC.TAEDESC2 = sysVar.errorCode; /* CSP return code*/

  end

  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback(); /* Roll back all changes*/

  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

  converseLib.validationFailed(1); /* System error occurred*/

  exit stack; /* Exit to display map*/


end // end XSFFS50

// Summarize VFHLIN01 quantities
Function XSFFS51()

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* This subroutine will access the Footwear Line History*/
   /* Table using product type group code and summarize the*/
   /* quantity fields in the table for the date range specified*/
   /* by the calling process.*/

   /* The the product type group code, the product line code,*/
   /* the life cycle code, the quality code, the order type group*/
   /* code, and the production national account flag must be*/
   /* specified by the calling process in FH4REC.*/

   /* The range beginning month and the range ending month must*/
   /* be specified by the calling process in FFFREC.*/

   /* The name of the calling process must be move to TA1PGMNM*/
   /* in TA1REC, for Error Diagnosis Reporting.*/

   /* *** Code the following before this is executed:         ****/
   /* ***                                                     ****/
   /* ***   FH4REC.XPRCD:    The product type group code or   ****/
   /* ***                    '*' to select codes 01 and 02.   ****/
   /* ***                                                     ****/
   /* ***   FH4REC.XPLCD:    The product line code.           ****/
   /* ***                                                     ****/
   /* ***   FH4REC.XLCCD:    The life cycle code or           ****/
   /* ***                    '*' to select codes 10 and 20.   ****/
   /* ***                                                     ****/
   /* ***   FH4REC.XQACD:    The quality code or              ****/
   /* ***                    '*' to select codes 01 and 02.   ****/
   /* ***                                                     ****/
   /* ***   FH4REC.YSMXOT:   The order type group code or     ****/
   /* ***                    '*' to select all codes.         ****/
   /* ***                                                     ****/
   /* ***   FH4REC.FH1PNAC:  The national account flag or     ****/
   /* ***                    '*' to select all flags.         ****/
   /* ***                                                     ****/
   /* ***   FFFREC.FFFBEGMO: The range beginning month.       ****/
   /* ***                                                     ****/
   /* ***   FFFREC.FFFENDMO: The range ending month.          ****/
   /* ***                                                     ****/
   /* ***   TA1REC.TA1PGMNM: The name of the calling process, ****/
   /* ***                    for Error Diagnosis Reporting.   ****/

   /* The subroutine will return summarized quantities in FH4REC.*/

   /* This subroutine will do any required Error Diagnosis*/
   /* Reporting to TA0020.  The calling process does not need to*/
   /* do any Error Diagnosis Reporting.*/

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* ------------------------------------------------------------*/
   /* Call the subroutine to summarize the selected quantities.*/
   /* ------------------------------------------------------------*/

  FFFREC.FFFFUNCD = "SS"; /* Function code*/

  try
    call "FF5510" (FFFREC, SQLCA, FH4REC, TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes};
  end

   /* ------------------------------------------------------------*/
   /* If call was successful, return to the calling process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* If data not available, indicate data in use by another.*/
   /* ------------------------------------------------------------*/

  FFWREC.XXXMODID = "X51"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    converseLib.validationFailed(47); /* Data in use by another*/

    exit stack; /* Exit to display map*/

  end

   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/

     /* NEXT SENTENCE*/

  else

    TA1REC.TA1TYPE = "APPL"; /* Type of error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    TA1REC.TA1LOC = "XSFFS51 SUM VFHLIN01 QUANTITIES";
    TAEREC.TAEDESC1 = "SUBROUTINE FF5510 CALL WAS NOT SUCCESSFUL";
    TAEREC.TAEDESC2 = sysVar.errorCode; /* CSP return code*/

  end

  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback(); /* Roll back all changes*/

  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

  converseLib.validationFailed(1); /* System error occurred*/

  exit stack; /* Exit to display map*/


end // end XSFFS51

// Summarize VCTSHP01 quantities
Function XSFFS52()

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* This subroutine will access the Footwear Category Shipments*/
   /* Table using product type group code and summarize the*/
   /* quantity fields in the table for the date range specified*/
   /* by the calling process.*/

   /* The product type group code, the product category code, the*/
   /* life cycle code, the quality code, and the order type group*/
   /* code must be specified by the calling process in FH6REC.*/

   /* The range beginning month and the range ending month must*/
   /* be specified by the calling process in FFFREC.*/

   /* The name of the calling process must be move to TA1PGMNM*/
   /* in TA1REC, for Error Diagnosis Reporting.*/

   /* *** Code the following before this is executed:         ****/
   /* ***                                                     ****/
   /* ***   FH6REC.XPRCD:    The product type group code or   ****/
   /* ***                    '*' to select codes 01 and 02.   ****/
   /* ***                                                     ****/
   /* ***   FH6REC.XPCCD:    The product category code.       ****/
   /* ***                                                     ****/
   /* ***   FH6REC.XLCCD:    The life cycle code.             ****/
   /* ***                                                     ****/
   /* ***   FH6REC.XQACD:    The quality code.                ****/
   /* ***                                                     ****/
   /* ***   FH6REC.YSMXOT:   The order type group code or     ****/
   /* ***                    '*' to select all codes.         ****/
   /* ***                                                     ****/
   /* ***   FFFREC.FFFBEGMO: The range beginning month.       ****/
   /* ***                                                     ****/
   /* ***   FFFREC.FFFENDMO: The range ending month.          ****/
   /* ***                                                     ****/
   /* ***   TA1REC.TA1PGMNM: The name of the calling process, ****/
   /* ***                    for Error Diagnosis Reporting.   ****/

   /* The subroutine will return summarized quantities in FH6REC.*/

   /* This subroutine will do any required Error Diagnosis*/
   /* Reporting to TA0020.  The calling process does not need to*/
   /* do any Error Diagnosis Reporting.*/

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* ------------------------------------------------------------*/
   /* Call the subroutine to summarize the selected quantities.*/
   /* ------------------------------------------------------------*/

  FFFREC.FFFFUNCD = "SS"; /* Function code*/

  try
    call "FF5520" (FFFREC, SQLCA, FH6REC, TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes};
  end

   /* ------------------------------------------------------------*/
   /* If call was successful, return to the calling process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* If data not available, indicate data in use by another.*/
   /* ------------------------------------------------------------*/

  FFWREC.XXXMODID = "X52"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    converseLib.validationFailed(47); /* Data in use by another*/

    exit stack; /* Exit to display map*/

  end

   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/

     /* NEXT SENTENCE*/

  else

    TA1REC.TA1TYPE = "APPL"; /* Type of error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    TA1REC.TA1LOC = "XSFFS52 SUM VCTSHP01 QUANTITIES";
    TAEREC.TAEDESC1 = "SUBROUTINE FF5520 CALL WAS NOT SUCCESSFUL";
    TAEREC.TAEDESC2 = sysVar.errorCode; /* CSP return code*/

  end

  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback(); /* Roll back all changes*/

  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

  converseLib.validationFailed(1); /* System error occurred*/

  exit stack; /* Exit to display map*/


end // end XSFFS52

// Summarize VFHSTY01 quantities
Function XSFFS53()

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* This subroutine will access the Footwear Style/Color*/
   /* History Table using style or style group and summarize the*/
   /* quantity fields in the table for the date range specified*/
   /* by the calling process.*/

   /* The style number, the color identification, the dimension*/
   /* code, the life cycle code, the quality code, the order type*/
   /* group code, and the production national account flag must*/
   /* be specified by the calling process in FH2REC.*/

   /* The function code, range beginning month, and range ending*/
   /* month must be specified by the calling process in FFFREC.*/

   /* The name of the calling process must be move to TA1PGMNM*/
   /* in TA1REC, for Error Diagnosis Reporting.*/

   /* *** Code the following before this is executed:         ****/
   /* ***                                                     ****/
   /* ***   FH2REC.SY1STNBR: The style number -OR-            ****/
   /* ***                    the style group number.          ****/
   /* ***                                                     ****/
   /* ***   FH2REC.SY2CLRID: The color identification,        ****/
   /* ***                    if summarizing by style number.  ****/
   /* ***                                                     ****/
   /* ***   FH2REC.XDMCD:    The dimension code,              ****/
   /* ***                    if summarizing by style number.  ****/
   /* ***                    -OR-                             ****/
   /* ***                    The product type group code,     ****/
   /* ***                    if summarizing by style group.   ****/
   /* ***                                                     ****/
   /* ***   FH2REC.XLCCD:    The life cycle code.             ****/
   /* ***                                                     ****/
   /* ***   FH2REC.XQACD:    The quality code.                ****/
   /* ***                                                     ****/
   /* ***   FH2REC.YSMXOT:   The order type group code or     ****/
   /* ***                    '*' to select all codes.         ****/
   /* ***                                                     ****/
   /* ***   FH2REC.FH1PNAC:  The national account flag or     ****/
   /* ***                    '*' to select all flags.         ****/
   /* ***                                                     ****/
   /* ***   FFFREC.FFFFUNCD: The function code.               ****/
   /* ***                    'SG' to sum by style group.      ****/
   /* ***                    'SS' to sum by style number.     ****/
   /* ***                                                     ****/
   /* ***   FFFREC.FFFBEGMO: The range beginning month.       ****/
   /* ***                                                     ****/
   /* ***   FFFREC.FFFENDMO: The range ending month.          ****/
   /* ***                                                     ****/
   /* ***   TA1REC.TA1PGMNM: The name of the calling process, ****/
   /* ***                    for Error Diagnosis Reporting.   ****/

   /* The subroutine will return summarized quantities in FH2REC.*/

   /* This subroutine will do any required Error Diagnosis*/
   /* Reporting to TA0020.  The calling process does not need to*/
   /* do any Error Diagnosis Reporting.*/

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* ------------------------------------------------------------*/
   /* Call the subroutine to summarize the selected quantities.*/
   /* ------------------------------------------------------------*/

  try
    call "FF5530" (FFFREC, SQLCA, FH2REC, TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes};
  end

   /* ------------------------------------------------------------*/
   /* If call was successful, return to the calling process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* If data not available, indicate data in use by another.*/
   /* ------------------------------------------------------------*/

  FFWREC.XXXMODID = "X53"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    converseLib.validationFailed(47); /* Data in use by another*/

    exit stack; /* Exit to display map*/

  end

   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/

     /* NEXT SENTENCE*/

  else

    TA1REC.TA1TYPE = "APPL"; /* Type of error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    TA1REC.TA1LOC = "XSFFS53 SUM VFHSTY01 QUANTITIES";
    TAEREC.TAEDESC1 = "SUBROUTINE FF5530 CALL WAS NOT SUCCESSFUL";
    TAEREC.TAEDESC2 = sysVar.errorCode; /* CSP return code*/

  end

  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback(); /* Roll back all changes*/

  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

  converseLib.validationFailed(1); /* System error occurred*/

  exit stack; /* Exit to display map*/


end // end XSFFS53

// Summarize VSYSHP01 quantities
Function XSFFS54()

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* This subroutine will access the Footwear Style/Color*/
   /* Shipments Table using style or style group and summarize*/
   /* the quantities in the table for the date range specified*/
   /* by the calling process.*/

   /* The style number, the color identification, the dimension*/
   /* code, the life cycle code, the quality code, the product*/
   /* type group code, the order type group code, and the*/
   /* production national account flag must be specified by the*/
   /* calling process in FH5REC.*/

   /* The function code, range beginning month, and range ending*/
   /* month must be specified by the calling process in FFFREC.*/

   /* The name of the calling process must be move to TA1PGMNM*/
   /* in TA1REC, for Error Diagnosis Reporting.*/

   /* *** Code the following before this is executed:         ****/
   /* ***                                                     ****/
   /* ***   FH5REC.SY1STNBR: The style number -OR-            ****/
   /* ***                    the style group number.          ****/
   /* ***                                                     ****/
   /* ***   FH5REC.SY2CLRID: The color identification,        ****/
   /* ***                    if summarizing by style number.  ****/
   /* ***                                                     ****/
   /* ***   FH5REC.XDMCD:    The dimension code,              ****/
   /* ***                    if summarizing by style number.  ****/
   /* ***                                                     ****/
   /* ***   FH5REC.XPRCD:    This field is not used           ****/
   /* ***                    if summarizing by style number.  ****/
   /* ***                    -OR-                             ****/
   /* ***                    The product type group code,     ****/
   /* ***                    if summarizing by style group.   ****/
   /* ***                                                     ****/
   /* ***   FH5REC.XLCCD:    The life cycle code.             ****/
   /* ***                                                     ****/
   /* ***   FH5REC.XQACD:    The quality code.                ****/
   /* ***                                                     ****/
   /* ***   FH5REC.YSMXOT:   The order type group code or     ****/
   /* ***                    '*' to select all codes.         ****/
   /* ***                                                     ****/
   /* ***   FH5REC.FH1PNAC:  The national account flag or     ****/
   /* ***                    '*' to select all flags.         ****/
   /* ***                                                     ****/
   /* ***   FFFREC.FFFFUNCD: The function code.               ****/
   /* ***                    'SG' to sum by style group.      ****/
   /* ***                    'SS' to sum by style number.     ****/
   /* ***                                                     ****/
   /* ***   FFFREC.FFFBEGMO: The range beginning month.       ****/
   /* ***                                                     ****/
   /* ***   FFFREC.FFFENDMO: The range ending month.          ****/
   /* ***                                                     ****/
   /* ***   TA1REC.TA1PGMNM: The name of the calling process, ****/
   /* ***                    for Error Diagnosis Reporting.   ****/

   /* The subroutine will return summarized quantities in FH5REC.*/

   /* This subroutine will do any required Error Diagnosis*/
   /* Reporting to TA0020.  The calling process does not need to*/
   /* do any Error Diagnosis Reporting.*/

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* ------------------------------------------------------------*/
   /* Call the subroutine to summarize the selected quantities.*/
   /* ------------------------------------------------------------*/

  try
    call "FF5540" (FFFREC, SQLCA, FH5REC, TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes};
  end

   /* ------------------------------------------------------------*/
   /* If call was successful, return to the calling process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* If data not available, indicate data in use by another.*/
   /* ------------------------------------------------------------*/

  FFWREC.XXXMODID = "X54"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    converseLib.validationFailed(47); /* Data in use by another*/

    exit stack; /* Exit to display map*/

  end

   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/

     /* NEXT SENTENCE*/

  else

    TA1REC.TA1TYPE = "APPL"; /* Type of error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    TA1REC.TA1LOC = "XSFFS54 SUM VSYSHP01 QUANTITIES";
    TAEREC.TAEDESC1 = "SUBROUTINE FF5540 CALL WAS NOT SUCCESSFUL";
    TAEREC.TAEDESC2 = sysVar.errorCode; /* CSP return code*/

  end

  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback(); /* Roll back all changes*/

  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

  converseLib.validationFailed(1); /* System error occurred*/

  exit stack; /* Exit to display map*/


end // end XSFFS54

// Summarize VLNSHP01 quantities
Function XSFFS55()

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* This subroutine will access the Footwear Line Shipments*/
   /* Table using product line code and summarizes the quantity*/
   /* fields in the table for the date range specified by the*/
   /* calling process.*/

   /* The the product type group code, the product line code, the*/
   /* life cycle code, the quality code, and the order type group*/
   /* code must be specified by the calling process in FHAREC.*/

   /* The range beginning month and the range ending month must*/
   /* be specified by the calling process in FFFREC.*/

   /* The name of the calling process must be move to TA1PGMNM*/
   /* in TA1REC, for Error Diagnosis Reporting.*/

   /* *** Code the following before this is executed:         ****/
   /* ***                                                     ****/
   /* ***   FHAREC.XPRCD:    The product type group code or   ****/
   /* ***                    '*' to select codes 01 and 02.   ****/
   /* ***                                                     ****/
   /* ***   FHAREC.XPLCD:    The product line code.           ****/
   /* ***                                                     ****/
   /* ***   FHAREC.XLCCD:    The life cycle code or           ****/
   /* ***                    '*' to select codes 10 and 20.   ****/
   /* ***                                                     ****/
   /* ***   FHAREC.XQACD:    The quality code or              ****/
   /* ***                    '*' to select codes 01 and 02.   ****/
   /* ***                                                     ****/
   /* ***   FHAREC.YSMXOT:   The order type group code or     ****/
   /* ***                    '*' to select all codes.         ****/
   /* ***                                                     ****/
   /* ***   FFFREC.FFFBEGMO: The range beginning month.       ****/
   /* ***                                                     ****/
   /* ***   FFFREC.FFFENDMO: The range ending month.          ****/
   /* ***                                                     ****/
   /* ***   TA1REC.TA1PGMNM: The name of the calling process, ****/
   /* ***                    for Error Diagnosis Reporting.   ****/

   /* The subroutine will return summarized quantities in FHAREC.*/

   /* This subroutine will do any required Error Diagnosis*/
   /* Reporting to TA0020.  The calling process does not need to*/
   /* do any Error Diagnosis Reporting.*/

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* ------------------------------------------------------------*/
   /* Call the subroutine to summarize the selected quantities.*/
   /* ------------------------------------------------------------*/

  FFFREC.FFFFUNCD = "SS"; /* Function code*/

  try
    call "FF5550" (FFFREC, SQLCA, FHAREC, TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes};
  end

   /* ------------------------------------------------------------*/
   /* If call was successful, return to the calling process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* If data not available, indicate data in use by another.*/
   /* ------------------------------------------------------------*/

  FFWREC.XXXMODID = "X55"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    converseLib.validationFailed(47); /* Data in use by another*/

    exit stack; /* Exit to display map*/

  end

   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that an unexpected error has occurred.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/

     /* NEXT SENTENCE*/

  else

    TA1REC.TA1TYPE = "APPL"; /* Type of error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    TA1REC.TA1LOC = "XSFFS55 SUM VLNSHP01 QUANTITIES";
    TAEREC.TAEDESC1 = "SUBROUTINE FF5550 CALL WAS NOT SUCCESSFUL";
    TAEREC.TAEDESC2 = sysVar.errorCode; /* CSP return code*/

  end

  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback(); /* Roll back all changes*/

  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

  converseLib.validationFailed(1); /* Unexpected error occurred*/

  exit stack; /* Exit to display map*/


end // end XSFFS55

// Obtain DPRODG.VSYCLR01 row
Function XSFFS56()

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* This subroutine will access the Production Style/Color*/
   /* Table using style group and obtain the active styles for*/
   /* date range specified by the calling process.*/

   /* The style group number and the product type group code*/
   /* must be specified by the calling process in PG2REC.*/

   /* The function code, range beginning month, and range ending*/
   /* month must be specified by the calling process in FFFREC.*/

   /* The name of the calling process must be move to TA1PGMNM*/
   /* in TA1REC, for Error Diagnosis Reporting.*/

   /* *** Code the following before this is executed:         ****/
   /* ***                                                     ****/
   /* ***   PG2REC.SYBSTGNB: The style group number.          ****/
   /* ***                                                     ****/
   /* ***   PG2REC.XPRCD:    The product type group code or   ****/
   /* ***                    '*' to select all codes.         ****/
   /* ***                                                     ****/
   /* ***   FFFREC.FFFFUNCD: The function code.               ****/
   /* ***                    'S1' to open the cursor.         ****/
   /* ***                    'N1' to fetch the next row.      ****/
   /* ***                    'C1' to close the cursor.        ****/
   /* ***                                                     ****/
   /* ***   FFFREC.FFFBEGMO: The range beginning month.       ****/
   /* ***                                                     ****/
   /* ***   FFFREC.FFFENDMO: The range ending month.          ****/
   /* ***                                                     ****/
   /* ***   TA1REC.TA1PGMNM: The name of the calling process, ****/
   /* ***                    for Error Diagnosis Reporting.   ****/

   /* The subroutine will return the style information in PG2REC.*/

   /* This subroutine will do any required Error Diagnosis*/
   /* Reporting to TA0020.  The calling process does not need to*/
   /* do any Error Diagnosis Reporting.*/

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* ------------------------------------------------------------*/
   /* Call the subroutine to obtain selected style information.*/
   /* ------------------------------------------------------------*/

  try
    call "FF5560" (FFFREC, SQLCA, PG2REC, TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes};
  end

   /* ------------------------------------------------------------*/
   /* If call was successful, return to the calling process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/

    if (SQLCA.VAGen_SQLCODE == 0 /* Normal return*/
     || SQLCA.VAGen_SQLCODE == +100) /* or end of cursor*/

      return; /* Return to previous process*/

    end

  end

   /* ------------------------------------------------------------*/
   /* If data not available, indicate data in use by another.*/
   /* ------------------------------------------------------------*/

  FFWREC.XXXMODID = "X56"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    converseLib.validationFailed(47); /* Data in use by another*/

    exit stack; /* Exit to display map*/

  end

   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/

     /* NEXT SENTENCE*/

  else

    TA1REC.TA1TYPE = "APPL"; /* Type of error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    TA1REC.TA1LOC = "XSFFS54 SUM VSYSHP01 QUANTITIES";
    TAEREC.TAEDESC1 = "SUBROUTINE FF5540 CALL WAS NOT SUCCESSFUL";
    TAEREC.TAEDESC2 = sysVar.errorCode; /* CSP return code*/

  end

  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback(); /* Roll back all changes*/

  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

  converseLib.validationFailed(1); /* System error occurred*/

  exit stack; /* Exit to display map*/


end // end XSFFS56

// Explode style/color by month
Function XSFFS58()

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* This subroutine calls the Footwear Forecasting Explode*/
   /* Style/Color Worksheet By Month Subroutine.*/

   /* The worksheet number, the beginning and ending months and*/
   /* the current date and time must be specified by the calling*/
   /* process in FFYREC.*/

   /* The name of the calling process must be move to TA1PGMNM*/
   /* in TA1REC, for Error Diagnosis Reporting.*/

   /* *** Code the following before this is executed:         ****/
   /* ***                                                     ****/
   /* ***   FFYREC.FFYLEVEL: The level used to identify the   ****/
   /* ***                    style/colors to be exploded.     ****/
   /* ***                    1-Category; 2-Style group.       ****/
   /* ***                                                     ****/
   /* ***   FFYREC.FFEWSNBR: The worksheet number.            ****/
   /* ***                                                     ****/
   /* ***   FFYREC.YPGCD:    The product type group code,     ****/
   /* ***                    if FFYLEVEL is equal to 1.       ****/
   /* ***                                                     ****/
   /* ***   FFYREC.XPCCD:    The product category code,       ****/
   /* ***                    if FFYLEVEL is equal to 1.       ****/
   /* ***                                                     ****/
   /* ***   FFYREC.SYBSTGNB: The product style group number,  ****/
   /* ***                    if FFYLEVEL is equal to 2.       ****/
   /* ***                                                     ****/
   /* ***   FFYREC.ZZZSDT:   The current date.                ****/
   /* ***                                                     ****/
   /* ***   FFYREC.ZZZSTM:   The current time.                ****/
   /* ***                                                     ****/
   /* ***   TA1REC.TA1PGMNM: The name of the calling process, ****/
   /* ***                    for Error Diagnosis Reporting.   ****/

   /* This subroutine will do any required Error Diagnosis*/
   /* Reporting to TA0020.  The calling process does not need to*/
   /* do any Error Diagnosis Reporting.*/

   /* This subroutine will return the CSP return code in EZERT8,*/
   /* the subroutine Subroutine return code in FFYREC.FFYRTNCD.*/

   /* *** Both return codes must indicate normal return.      ****/
   /* ***                                                     ****/
   /* ***   EZERT8                                            ****/
   /* ***   ------                                            ****/
   /* ***   '00000000' = Normal return                        ****/
   /* ***   OTHER      = Unexpected error has occurred        ****/
   /* ***                                                     ****/
   /* ***   FFYREC.FFYRTNCD                                   ****/
   /* ***   ---------------                                   ****/
   /* ***   '0' = Normal return                               ****/
   /* ***   '1' = Calling parameters missing or invalid       ****/
   /* ***   '2' = Unexpected DB2 error has occurred           ****/
   /* ***   '3' = Subroutine error                            ****/
   /* ***                                                     ****/
   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* ------------------------------------------------------------*/
   /* Call the Explode Style/Color Worksheet By Month Subroutine.*/
   /* ------------------------------------------------------------*/

  try
    call "FF5800" (FFYREC, SQLCA, TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes};
  end

   /* ------------------------------------------------------------*/
   /* If call was successful, return to the calling process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && FFYREC.FFYRTNCD == "0")        /* and normal return*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* If the record abready exist, indicate the explosion has*/
   /* been done once.*/
   /* ------------------------------------------------------------*/

   /* MOVE 'X58' TO FFWREC.XXXMODID   ; Module identification*/

   /* IF EZERT8 EQ '00000000'         ; Call successful*/
    /* AND FFYREC.FFYRTNCD EQ '2'    ; and unexpected DB2 error*/
    /* AND SQLCA.SQLCODE EQ -803     ; and duplicate recorcd*/
    /* ;*/
    /* MOVE 294 TO EZEMNO;*/

    /* EZERTN                        ; Return to previous process*/

   /* END ;*/


   /* ------------------------------------------------------------*/
   /* If data not available, indicate data in use by another.*/
   /* ------------------------------------------------------------*/

  FFWREC.XXXMODID = "X58"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && FFYREC.FFYRTNCD == "2"         /* and unexpected DB2 error*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    converseLib.validationFailed(47); /* Data in use by another*/

    exit stack; /* Exit to display map*/

  end

   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/

     /* NEXT SENTENCE*/

  else

    TA1REC.TA1TYPE = "APPL"; /* Type of error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    TA1REC.TA1LOC = "XSFFS58 EXPLODE STYLE/COLOR";
    TAEREC.TAEDESC1 = "SUBROUTINE FF5800 CALL WAS NOT SUCCESSFUL";
    TAEREC.TAEDESC2 = sysVar.errorCode; /* CSP return code*/

  end

  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback(); /* Roll back all changes*/

  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

  converseLib.validationFailed(1); /* System error occurred*/

  exit stack; /* Exit to display map*/


end // end XSFFS58

// Update month master forecast
Function XSFFS59()

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* This subroutine calls the Footwear Forecasting Update*/
   /* Month master Forecast Subroutine.*/

   /* This subroutine will update the master by category and*/
   /* master by type group tables by using the inforamtions*/
   /* provided.*/

   /* The month range, worksheet number, level indicator,*/
   /* country code, division group code, type group code,*/
   /* category code and style group code (optional) need to*/
   /* be passed to this subroutine.*/

   /* *** Code the following before this is executed:         ****/
   /* ***                                                     ****/
   /* ***   FFSREC.FFABEGMO: Beginning month of the range     ****/
   /* ***                                                     ****/
   /* ***   FFSREC.FFAENDMO: Ending month of the range        ****/
   /* ***                                                     ****/
   /* ***   FFSREC.FFEWSNBR: Worksheet number                 ****/
   /* ***                                                     ****/
   /* ***   FFSREC.FFSLEVEL: Level indicator                  ****/
   /* ***                    The value could be 'CAT',        ****/
   /* ***                    'GRP' or 'CLR'.                  ****/
   /* ***                                                     ****/
   /* ***   FFSREC.XCTCD   : Country code                     ****/
   /* ***                                                     ****/
   /* ***   FFSREC.YSMXDV  : Division group code              ****/
   /* ***                                                     ****/
   /* ***   FFSREC.YPGCD   : Type group code                  ****/
   /* ***                                                     ****/
   /* ***   FFSREC.XPCCD   : Category code                    ****/
   /* ***                                                     ****/
   /* ***   FFSREC.SYBSTGNB: Style group number (optional)    ****/
   /* ***                                                     ****/
   /* ***   TA1REC.TA1PGMNM: The name of the calling process, ****/
   /* ***                    for Error Diagnosis Reporting.   ****/

   /* This subroutine will return the CSP return code in EZERT8,*/
   /* the subroutine Subroutine return code in FFSREC.FFSRTNCD.*/

   /* *** Both return codes must indicate normal return.      ****/
   /* ***                                                     ****/
   /* ***   EZERT8                                            ****/
   /* ***   ------                                            ****/
   /* ***   '00000000' = Normal return                        ****/
   /* ***   OTHER      = Unexpected error has occurred        ****/
   /* ***                                                     ****/
   /* ***   FFSREC.FFSRTNCD                                   ****/
   /* ***   ---------------                                   ****/
   /* ***   '0' = Normal return                               ****/
   /* ***   '1' = Unexpected DB2 error has occurred           ****/
   /* ***   '2' = Calling parameters missing or invalid       ****/
   /* ***                                                     ****/
   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* ------------------------------------------------------------*/
   /* Call the Update month master tables Subroutine.*/
   /* ------------------------------------------------------------*/

  try
    call "FF5900" (FFSREC, SQLCA, TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes};
  end

   /* ------------------------------------------------------------*/
   /* If successful, return to the calling process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/

    if (FFSREC.FFSRTNCD == "0") /* Normal return code*/
      return; /* Return to previous process*/
    end

  end

   /* ------------------------------------------------------------*/
   /* Determine whether a DB2 or an APPL error has occurred.*/
   /* ------------------------------------------------------------*/

  FFWREC.XXXMODID = "X59"; /* Module identification*/


  if (sysVar.errorCode == "00000000" /* Call successful*/
   && FFSREC.FFSRTNCD == "1"         /* and unexpected DB2 error*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    converseLib.validationFailed(47); /* Data in use by another*/

    exit stack; /* Exit to display map*/

  end

   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/

     /* NEXT SENTENCE*/

  else

    TA1REC.TA1TYPE = "APPL"; /* Type of error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    TA1REC.TA1LOC = "XSFFS59 UPDATE MONTH MASTER";
    TAEREC.TAEDESC1 = "SUBROUTINE FF5900 CALL WAS NOT SUCCESSFUL";
    TAEREC.TAEDESC2 = sysVar.errorCode; /* CSP return code*/

  end

  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback(); /* Roll back all changes*/

  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

  converseLib.validationFailed(1); /* System error occurred*/

  exit stack; /* Exit to display map*/


end // end XSFFS59

// Replicate forecast worksheets
Function XSFFS60()

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* This subroutine calls the Footwear Forecasting Replicate*/
   /* Forecast Worksheets Subroutine.*/

   /* The old worksheet number, the new worksheet number, the*/
   /* level to be replicated, the applicable product line, type*/
   /* group and category (according to the level specified) and*/
   /* the current date and time must be specified by the calling*/
   /* process in FFVREC.*/

   /* The name of the calling process must be moved to TA1PGMNM*/
   /* in TA1REC, for Error Diagnosis Reporting.*/

   /* *** Code the following before this is executed:         ****/
   /* ***                                                     ****/
   /* ***   FFVREC.FFVLEVEL: The lowest level to replicate.   ****/
   /* ***                    2-Type; 3-Category.              ****/
   /* ***                                                     ****/
   /* ***   FFVREC.FFEWSNBR: The old worksheet number.        ****/
   /* ***                                                     ****/
   /* ***   FFVREC.FF1WSNBR: The new worksheet number.        ****/
   /* ***                                                     ****/
   /* ***   FFVREC.XPLCD:    The product line code of the     ****/
   /* ***                    worksheet to be excluded.        ****/
   /* ***                                                     ****/
   /* ***   FFVREC.YPGCD:    The product type group code of   ****/
   /* ***                    the worksheet to be excluded.    ****/
   /* ***                                                     ****/
   /* ***   FFVREC.ZZZSDT:   The current date.                ****/
   /* ***                                                     ****/
   /* ***   FFVREC.ZZZSTM:   The current time.                ****/
   /* ***                                                     ****/
   /* ***   TA1REC.TA1PGMNM: The name of the calling process, ****/
   /* ***                    for Error Diagnosis Reporting.   ****/

   /* This subroutine will do any required Error Diagnosis*/
   /* Reporting to TA0020.  The calling process does not need to*/
   /* do any Error Diagnosis Reporting.*/

   /* This subroutine will return the CSP return code in EZERT8,*/
   /* the subroutine Subroutine return code in FFVREC.FFVRTNCD.*/

   /* *** Both return codes must indicate normal return.      ****/
   /* ***                                                     ****/
   /* ***   EZERT8                                            ****/
   /* ***   ------                                            ****/
   /* ***   '00000000' = Normal return                        ****/
   /* ***   OTHER      = Unexpected error has occurred        ****/
   /* ***                                                     ****/
   /* ***   FFVREC.FFVRTNCD                                   ****/
   /* ***   ---------------                                   ****/
   /* ***   '0' = Normal return                               ****/
   /* ***   '1' = Calling parameters missing or invalid       ****/
   /* ***   '2' = Unexpected DB2 error has occurred           ****/
   /* ***                                                     ****/
   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* ------------------------------------------------------------*/
   /* Call the Replicate Forecast Worksheets Subroutine.*/
   /* ------------------------------------------------------------*/

  try
    call "FF6000" (FFVREC, SQLCA, TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes};
  end

   /* ------------------------------------------------------------*/
   /* If call was successful, return to the calling process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && FFVREC.FFVRTNCD == "0")        /* and normal return*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* If data not available, indicate data in use by another.*/
   /* ------------------------------------------------------------*/

  FFWREC.XXXMODID = "X60"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && FFVREC.FFVRTNCD == "2"         /* and unexpected DB2 error*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    converseLib.validationFailed(47); /* Data in use by another*/

    exit stack; /* Exit to display map*/

  end

   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/

     /* NEXT SENTENCE*/

  else

    TA1REC.TA1TYPE = "APPL"; /* Type of error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    TA1REC.TA1LOC = "XSFFS60 REPLICATE WORKSHEETS";
    TAEREC.TAEDESC1 = "SUBROUTINE FF6000 CALL WAS NOT SUCCESSFUL";
    TAEREC.TAEDESC2 = sysVar.errorCode; /* CSP return code*/

  end

  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback(); /* Roll back all changes*/

  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

  converseLib.validationFailed(1); /* System error occurred*/

  exit stack; /* Exit to display map*/


end // end XSFFS60

// Purge any excess worksheets
Function XSFFS61()

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* This subroutine calls the Footwear Forecasting Purge Excess*/
   /* Worksheets Subroutine.*/

   /* The division group code, the foreign country code, the*/
   /* range beginning month and the range ending month must be*/
   /* specified by the calling process in FFEREC.*/

   /* The name of the calling process must be move to TA1PGMNM*/
   /* in TA1REC, for Error Diagnosis Reporting.*/

   /* *** Code the following before this is executed:         ****/
   /* ***                                                     ****/
   /* ***   FFEREC.YSMXDV:   The division group code.         ****/
   /* ***                                                     ****/
   /* ***   FFEREC.XCTCD:    The foreign country code.        ****/
   /* ***                                                     ****/
   /* ***   FFEREC.FFABEGMO: The range beginning month.       ****/
   /* ***                                                     ****/
   /* ***   FFEREC.FFAENDMO: The range ending month.          ****/
   /* ***                                                     ****/
   /* ***   TA1REC.TA1PGMNM: The name of the calling process, ****/
   /* ***                    for Error Diagnosis Reporting.   ****/

   /* This subroutine will do any required Error Diagnosis*/
   /* Reporting to TA0020.  The calling process does not need to*/
   /* do any Error Diagnosis Reporting.*/

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* ------------------------------------------------------------*/
   /* Call the Purge Excess Worksheets Subroutine.*/
   /* ------------------------------------------------------------*/

  try
    call "FF6100" (FFEREC, SQLCA, TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes};
  end

   /* ------------------------------------------------------------*/
   /* If call was successful, return to the calling process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* If data not available, indicate data in use by another.*/
   /* ------------------------------------------------------------*/

  FFWREC.XXXMODID = "X61"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    converseLib.validationFailed(47); /* Data in use by another*/

    exit stack; /* Exit to display map*/

  end

   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/

     /* NEXT SENTENCE*/

  else

    TA1REC.TA1TYPE = "APPL"; /* Type of error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    TA1REC.TA1LOC = "XSFFS61 PURGE EXCESS WORKSHEETS";
    TAEREC.TAEDESC1 = "SUBROUTINE FF6100 CALL WAS NOT SUCCESSFUL";
    TAEREC.TAEDESC2 = sysVar.errorCode; /* CSP return code*/

  end

  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback(); /* Roll back all changes*/

  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

  converseLib.validationFailed(1); /* System error occurred*/

  exit stack; /* Exit to display map*/


end // end XSFFS61

// Update Footwear Forecasting
Function XSFFS62()

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* ** THIS SUBROUTINE IS INTENDED FOR PG SYSTEM USE ONLY ***/

   /* This subroutine will update the Footwear Forecasting*/
   /* Month Master, Short Range Worksheet, Long Range Worksheet,*/
   /* Maximum Price By Style Group, and Product Style/Color*/
   /* tables when a style development product is changed.*/

   /* This subroutine should be invoked immediately after the*/
   /* style development product has been updated in the table.*/

   /* The updated table row, containing the current column*/
   /* contents, is passed to this subroutine as a parameter.*/

   /* The name of the calling process must be moved to TA1PGMNM*/
   /* in TA1REC, for Error Diagnosis Reporting.*/

   /* *** Code the following before this is executed:         ****/
   /* ***                                                     ****/
   /* ***  TA1REC.TA1PGMNM: The name of the calling process,  ****/
   /* ***                   for Error Diagnosis Reporting.    ****/

   /* This subroutine will do any required Error Diagnosis*/
   /* Reporting to TA0020.  The calling process does not need to*/
   /* do any Error Diagnosis Reporting.*/

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* ------------------------------------------------------------*/
   /* Call the subroutine to update Footwear Forecasting tables.*/
   /* ------------------------------------------------------------*/

  try
    call "FF6250" (SQLCA, PG4REC, TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes};
  end

   /* ------------------------------------------------------------*/
   /* If call was successful, return to the calling process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/

    if (SQLCA.VAGen_SQLCODE == 0) /* Normal return*/
      return; /* Return to previous process*/
    end

    /* ------------------------------------------------------------*/
     /* If row not found, indicate error.*/
    /* ------------------------------------------------------------*/

    if (SQLCA.VAGen_SQLCODE == +100) /* Row not found*/

      VGVar.handleSysLibraryErrors = 0;
      sysLib.rollback(); /* Roll back all changes*/

      PGXREC.XXXMODID = "X62"; /* Module identification*/
      TA1REC.TA1FUNC = "RETN"; /* Termination function*/
      converseLib.validationFailed(11); /* Not found*/

      call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

      exit stack; /* Exit to display map*/

    end

  end

   /* ------------------------------------------------------------*/
   /* If data not available, indicate data in use by another.*/
   /* ------------------------------------------------------------*/

  PGXREC.XXXMODID = "X62"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    converseLib.validationFailed(47); /* Data in use by another*/

    exit stack; /* Exit to display map*/

  end

   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that an unexpected error has occurred.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/

     /* NEXT SENTENCE*/

  else

    TA1REC.TA1TYPE = "APPL"; /* Type of error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    TA1REC.TA1LOC = "XSFFS62 UPDATE FOOTWEAR FORECAST";
    TAEREC.TAEDESC1 = "SUBROUTINE FF6250 CALL WAS NOT SUCCESSFUL";
    TAEREC.TAEDESC2 = sysVar.errorCode; /* CSP return code*/

  end

  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback(); /* Roll back all changes*/

  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

  converseLib.validationFailed(1); /* Unexpected error occurred*/

  exit stack; /* Exit to display map*/


end // end XSFFS62

// Obtain DPRODG.VSYdvl01 row
Function XSFFS65()

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* This subroutine will access the Production Style Development*/
   /* Table using style group and obtain the active style devl for*/
   /* date range specified by the calling process.*/

   /* The style group number and the product type group code*/
   /* must be specified by the calling process in PG4REC.*/

   /* The function code, range beginning month, and range ending*/
   /* month must be specified by the calling process in FFFREC.*/

   /* The name of the calling process must be move to TA1PGMNM*/
   /* in TA1REC, for Error Diagnosis Reporting.*/

   /* *** Code the following before this is executed:         ****/
   /* ***                                                     ****/
   /* ***   PG4REC.SYBSTGNB: The style group number.          ****/
   /* ***                                                     ****/
   /* ***   PG4REC.XPRCD:    The product type group code or   ****/
   /* ***                    '*' to select all codes.         ****/
   /* ***                                                     ****/
   /* ***   FFFREC.FFFFUNCD: The function code.               ****/
   /* ***                    'S1' to open the cursor.         ****/
   /* ***                    'N1' to fetch the next row.      ****/
   /* ***                    'C1' to close the cursor.        ****/
   /* ***                                                     ****/
   /* ***   FFFREC.FFFBEGMO: The range beginning month.       ****/
   /* ***                                                     ****/
   /* ***   FFFREC.FFFENDMO: The range ending month.          ****/
   /* ***                                                     ****/
   /* ***   TA1REC.TA1PGMNM: The name of the calling process, ****/
   /* ***                    for Error Diagnosis Reporting.   ****/

   /* The subroutine will return the style information in PG2REC.*/

   /* This subroutine will do any required Error Diagnosis*/
   /* Reporting to TA0020.  The calling process does not need to*/
   /* do any Error Diagnosis Reporting.*/

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* ------------------------------------------------------------*/
   /* Call the subroutine to obtain selected style information.*/
   /* ------------------------------------------------------------*/

  try
    call "FF5580" (FFFREC, SQLCA, PG4REC, TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes};
  end

   /* ------------------------------------------------------------*/
   /* If call was successful, return to the calling process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/

    if (SQLCA.VAGen_SQLCODE == 0 /* Normal return*/
     || SQLCA.VAGen_SQLCODE == +100) /* or end of cursor*/

      return; /* Return to previous process*/

    end

  end

   /* ------------------------------------------------------------*/
   /* If data not available, indicate data in use by another.*/
   /* ------------------------------------------------------------*/

  FFWREC.XXXMODID = "X65"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    converseLib.validationFailed(47); /* Data in use by another*/

    exit stack; /* Exit to display map*/

  end

   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/

     /* NEXT SENTENCE*/

  else

    TA1REC.TA1TYPE = "APPL"; /* Type of error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    TA1REC.TA1LOC = "XSFFS65 ACCESS VSYDVL01 TABLE";
    TAEREC.TAEDESC1 = "SUBROUTINE FF5580 CALL WAS NOT SUCCESSFUL";
    TAEREC.TAEDESC2 = sysVar.errorCode; /* CSP return code*/

  end

  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback(); /* Roll back all changes*/

  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

  converseLib.validationFailed(1); /* System error occurred*/

  exit stack; /* Exit to display map*/


end // end XSFFS65

// Exit to another application
Function XSFHS-EXIT()
   /* ------------------------------------------------------------*/
   /* Set the application to be invoked for PF1 or PF5.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf1) /* PF1 was pressed*/
    COMMAREA.CATOAP = "GD01"; /* Goal Documentation*/
  end

  if (converseVar.eventKey is pf5) /* PF5 was pressed*/
    COMMAREA.CATOAP = "MN0M"; /* Master Menu*/
  end

   /* ------------------------------------------------------------*/
   /* Save the system work record in the COMMAREA user area.*/
   /* ------------------------------------------------------------*/

  if (COMMAREA.CATOSYS == COMMAREA.CACURSYS) /* Same system*/

    COMMAREA.CAUSERA = FHWREC.CAUSERA; /* Save work record*/
  else
    COMMAREA.CAUSERA = " "; /* Clear user area*/

  end

   /* ------------------------------------------------------------*/
   /* Transfer control to the specified application.*/
   /* ------------------------------------------------------------*/

  XSEXIT(); /* Exit to another application*/

  FHWREC.XXX-MSG-LOC-ID = "XSEXIT"; /* Message location*/

   /* ------------------------------------------------------------*/
   /* Reestablish the COMMAREA application and item fields.*/
   /* ------------------------------------------------------------*/

  COMMAREA.CAEZSG3 = "0"; /* Force zero third character*/
  COMMAREA.CACURRAP = COMMAREA.CAEZSAP; /* Current application*/

  if (converseVar.eventKey is pfkey) /* PF key was pressed*/

    COMMAREA.CATOAP = " "; /* Clear TO application*/

    if (converseVar.eventKey is pf1) /* PF1 was pressed*/
      COMMAREA.CAITEM = " "; /* Clear map name from item*/
    end

  end


end // end XSFHS-EXIT

// Exit to another application
Function XSFKS01()
   /* ------------------------------------------------------------*/
   /* Set the application to be invoked for PF1 or PF4.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf1) /* PF1 was pressed*/
    COMMAREA.CATOAP = "GD01"; /* Indicate Goal Documentation*/
  end

  if (converseVar.eventKey is pf4) /* PF4 was pressed*/
    COMMAREA.CATOAP = "MN0M"; /* Indicate Master Menu*/
  end

   /* ------------------------------------------------------------*/
   /* Save the application user area in the COMMAREA.*/
   /* ------------------------------------------------------------*/

  if (COMMAREA.CATOSYS == "FK" /* FK system*/
   || COMMAREA.CATOSYS == "FM") /* FM system*/

    FKWREC.FKW-UPDATE-FUNCTION = COMMAREA.CAITEM; /* Map function*/
    COMMAREA.CAITEM = "   "; /* re-initialize item field*/
    COMMAREA.CAUSERA = FKWREC.CAUSERA; /* Save user area*/
  else
    COMMAREA.CAUSERA = " "; /* Clear user area*/

  end

   /* ------------------------------------------------------------*/
   /* Transfer control to the specified application.*/
   /* ------------------------------------------------------------*/

  XSEXIT(); /* Exit to another application*/

   /* ------------------------------------------------------------*/
   /* Reestablish the COMMAREA application and item fields.*/
   /* ------------------------------------------------------------*/

  COMMAREA.CAEZSG3 = "0"; /* Force zero third character*/
  COMMAREA.CACURRAP = COMMAREA.CAEZSAP; /* CURR application*/

  if (converseVar.eventKey is pfkey) /* PF key was pressed*/

    COMMAREA.CATOAP = " "; /* Clear TO application*/

    if (converseVar.eventKey is pf1) /* PF1 was pressed*/
      COMMAREA.CAITEM = " "; /* Clear map name from item*/
    end

  end


end // end XSFKS01

// Exit to another application
Function XSFLS01()
   /* ------------------------------------------------------------*/
   /* Set the application to be invoked for PF1,pf4 or PF5.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf1) /* PF1 was pressed*/

    COMMAREA.CATOAP = "GD01"; /* Indicate Goal Documentation*/

  end

  if (converseVar.eventKey is pf4) /* PF4 was pressed*/

    COMMAREA.CATOAP = "MN0M"; /* Indicate Master Menu*/

  end


  if (converseVar.eventKey is pf5) /* PF5 was pressed*/

    COMMAREA.CATOAP = "FY0M"; /* Production Menu*/

  end


   /* ------------------------------------------------------------*/
   /* Save the application user area in the COMMAREA.*/
   /* ------------------------------------------------------------*/

  if (COMMAREA.CATOSYS == "FL") /* Transfer within same system*/

    COMMAREA.CAUSERA = FLWREC.CAUSERA; /* Save user area*/
  else
    COMMAREA.CAUSERA = " "; /* Clear user area*/

  end

   /* ------------------------------------------------------------*/
   /* Transfer control to the specified application.*/
   /* ------------------------------------------------------------*/

  XSEXIT(); /* Exit to another application*/

   /* ------------------------------------------------------------*/
   /* If transfer failed, return an error to the calling process.*/
   /* ------------------------------------------------------------*/

  FLWREC.XXXMODID = "XS1"; /* Module identification*/

  if (COMMAREA.CASECRC == 3 /* Application not found*/
   || COMMAREA.CASECRC == 4) /* or transfer not allowed*/

    converseLib.validationFailed(103); /* Indicate not allowed*/

  else
    converseLib.validationFailed(1); /* Indicate system error*/

  end


end // end XSFLS01

// FQ common exit routine
Function XSFQS01()
   /* ------------------------------------------------------------*/
   /* If modified data exists, return a message to the user*/
   /* asking if the modified data is to be saved before exiting.*/
   /* ------------------------------------------------------------*/

  if (FQWREC.FQWMODSW == "Y") /* Modified data exists*/

    FQWREC.FQWMODSW = "N"; /* Modified data exit switch*/

    FQWREC.XXXMODID = "X01"; /* Module identification*/
    converseLib.validationFailed(11); /* Should changes be saved*/

  else

    /* ------------------------------------------------------------*/
     /* Otherwise, set application to be invoked for PF1, PF4, PF5.*/
    /* ------------------------------------------------------------*/

    if (converseVar.eventKey is pf1) /* PF1 was pressed*/
      COMMAREA.CATOAP = "GD01"; /* Indicate Goal Documentation*/
    end

    if (converseVar.eventKey is pf4) /* PF4 was pressed*/
      COMMAREA.CATOAP = "MN0M"; /* Indicate Production Menu*/
    end

    if (converseVar.eventKey is pf5) /* PF5 was pressed*/
      COMMAREA.CATOAP = "FQ0M"; /* Indicate Production Menu*/
    end

    /* ------------------------------------------------------------*/
     /* Save the application user area in the COMMAREA.*/
    /* ------------------------------------------------------------*/

    if (COMMAREA.CATOSYS == "FQ") /* Same system*/

      COMMAREA.CAUSERA = FQWREC.CAUSERA; /* Save user area*/
    else

      COMMAREA.CAUSERA = " "; /* Clear user area*/
    end

    /* ------------------------------------------------------------*/
     /* Transfer control to the specified application.*/
    /* ------------------------------------------------------------*/

    XSEXIT(); /* Exit to another application*/

    /* ------------------------------------------------------------*/
     /* If transfer failed, return an error to the calling process.*/
    /* ------------------------------------------------------------*/

    FQWREC.XXXMODID = "X01"; /* Module identification*/

    if (COMMAREA.CASECRC == 3 /* Application not found*/
     || COMMAREA.CASECRC == 4) /* or transfer not allowed*/

      converseLib.validationFailed(6); /* Not allowed to access*/
    else
      converseLib.validationFailed(1); /* Unexpected error occurred*/

    end

  end

   /* ------------------------------------------------------------*/
   /* Reestablish the COMMAREA application and item fields.*/
   /* ------------------------------------------------------------*/

  COMMAREA.CAEZSG3 = "0"; /* Force zero third character*/
  COMMAREA.CACURRAP = COMMAREA.CAEZSAP; /* CURR application*/

  if (converseVar.eventKey is pfkey) /* PF key was pressed*/

    COMMAREA.CATOAP = " "; /* Clear TO application*/

    if (converseVar.eventKey is pf1) /* PF1 was pressed*/
      COMMAREA.CAITEM = " "; /* Clear map name from item*/
    end

  end


end // end XSFQS01

// FQ date range subroutine edit
Function XSFQS05()

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* This subroutine will edit the beginning and ending dates of*/
   /* a range in YYMMMM format and return the dates in CCYYMMMM*/
   /* format, along with an array of each individual month*/
   /* in the range, if requested.  MMMM contain the production*/
   /* month and delivery month.*/

     /* * Qualified range is within the # of years requested,*/
       /* calculated from the current date.*/
     /* * If both start and end dates are 0 (wild card), the*/
       /* selected range will cover the # of years requested,*/
       /* from the current date and back.*/
     /* * If the start date is 0 and the end date is not, the*/
       /* range will be from the qualified start date, # of years*/
       /* from the current date, to the selected end date.*/
     /* * If the end date is 0 and the start date is not, the*/
       /* range will go from the selected start date to the*/
       /* current date.*/


   /* INPUT VALIDATION:*/
   /* ***                                                     ****/
   /* ***  Year must be between 57-99 and 00-20. Months must  ****/
   /* ***  not be greater than 12.                            ****/
   /* ***                                                     ****/
   /* ***  The delivery month should always be 2 greater than ****/
   /* ***  the production month, except for promo products    ****/
   /* ***  which have prod month of 1 and delivery 12.        ****/
   /* ***                                                     ****/
   /* ***  The beginning and ending month must be within the  ****/
   /* ***  qualified range, and the ending month cannot be    ****/
   /* ***  greater than the beginning month.                  ****/

   /* REQUIREMENTS:*/

   /* The calling appl must have FQZREC&TA1REC&TA2REC named in*/
   /* its record list.  The name of the calling process must be*/
   /* moved to TA1PGMNM in TA1REC, for Error Diagnosis Reporting.*/

   /* *** Code the following before this is executed:         ****/
   /* ***                                                     ****/
   /* ***  FQZREC.FQZNUMYR:                                   ****/
   /* ***      Number of years selected to extract data       ****/
   /* ***                                                     ****/
   /* ***  FQZREC.FQZCHK24:                                   ****/
   /* ***      Can be ' ', 'N', or 'Y'. Code 'Y' to obtain    ****/
   /* ***      individual months in the selected range.       ****/
   /* ***                                                     ****/
   /* ***  FQZREC.FQZBEGRG, FQZREC.FQZENDRG:                  ****/
   /* ***      The range to be edited must be in YYMMMM form. ****/
   /* ***                                                     ****/
   /* ***  TA1REC.TA1PGMNM: The name of the calling process,  ****/
   /* ***                   for Error Diagnosis Reporting.    ****/
   /* ***                                                     ****/

   /* RESULTS:*/

   /* If any error is found during editing, it is indicated by*/
   /* the completion code in FQZREC.FQZBEGRC and FQZREC.FQZENDRC.*/
   /* If no error is found, the converted dates will be returned*/
   /* in FQZREC.FQZBEGMO, FQZREC.FQZENDMO and FQZREC.FQZINDMO.*/

   /* *** Both return codes must indicate normal return.      ****/
   /* ***                                                     ****/
   /* ***   FQZREC.FQZBEGRC, FQZREC.FQZENDRC:                 ****/
   /* ***      '0' = Normal return                            ****/
   /* ***      '1' = Invalid date entered                     ****/
   /* ***      '2' = Date out of range                        ****/
   /* ***                                                     ****/
   /* ***  FQZREC.FQZBCYMM, FQZREC.FQZECYMM:                  ****/
   /* ***      The dates will be returned in CCYYMMMM format. ****/
   /* ***                                                     ****/
   /* ***  FQZREC.FQZNUMMO, FQZREC.FQZINDMO:                  ****/
   /* ***      The number of months in the range and each     ****/
   /* ***      individual month. Not returned if CHK24 not =Y ****/

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* ------------------------------------------------------------*/
   /* Initialize the return codes and return dates.*/
   /* ------------------------------------------------------------*/

  FQZREC.FQZBEGRC = "0"; /* Beginning date return code*/
  FQZREC.FQZENDRC = "0"; /* Ending date return code*/

  FQZREC.FQZNUMMO = 0; /* Number of months in range*/
  move 0 to FQZREC.FQZINDMO[1] for all; /* Individual month in range*/

   /* -------------------------------------------------------*/
   /* Obtain the current date and establish the qualified end*/
   /* boundary in form YYMMMM, which will be used to translate*/
   /* wild card (0) date entries.*/
   /* -------------------------------------------------------*/

  XX0XS01(); /* Obtain the current date*/

  FQZREC.FQZCURYY = XX0XW01.XX0XWYY; /* Calculate end bound*/
  FQZREC.FQZCURM2 = XX0XW01.XX0XWMM; /* YYMMMM*/
  if (FQZREC.FQZCURM2 < 3)
    FQZREC.FQZCURM1 = FQZREC.FQZCURM2 - 2 + 12;
    FQZREC.FQZCURYY = FQZREC.FQZCURYY - 1;
  else
    FQZREC.FQZCURM1 = FQZREC.FQZCURM2 - 2;
  end

   /* ------------------------------------------------------------*/
   /* Years must be between 57-99 and 00-20.*/
   /* Months must not be greater than 12.*/
   /* ------------------------------------------------------------*/

  if (FQZREC.FQZBEGRG != 0)
    if (FQZREC.FQZBEGYY < 57 /* Beginning between 57-99*/
     && FQZREC.FQZBEGYY > 20) /* and 00-20*/
      FQZREC.FQZBEGRC = "1"; /* Indicate invalid date*/
    end

    if (FQZREC.FQZBEGM1 > 12 /* Beginning M1 > 12*/
     || FQZREC.FQZBEGM2 > 12) /* Beginning M2 > 12*/
      FQZREC.FQZBEGRC = "1"; /* Indicate invalid date*/
    end
  end

  if (FQZREC.FQZENDRG != 0)
    if (FQZREC.FQZENDYY < 57 /* Beginning between 57-99*/
     && FQZREC.FQZENDYY > 20) /* and 00-20*/
      FQZREC.FQZENDRC = "1"; /* Indicate invalid date*/
    end

    if (FQZREC.FQZENDM1 > 12 /* Beginning M1 > 12*/
     || FQZREC.FQZENDM2 > 12) /* Beginning M2 > 12*/
      FQZREC.FQZENDRC = "1"; /* Indicate invalid date*/
    end
  end

  if (FQZREC.FQZBEGRC == "1"
   || FQZREC.FQZENDRC == "1")
    return; /* Return to calling process*/
  end

   /* -------------------------------------------------------*/
   /* If number of years not sent, default to 2 years.*/
   /* -------------------------------------------------------*/
  if (FQZREC.FQZNUMYR == 0) /* If number is zero*/
    FQZREC.FQZNUMYR = 2; /* Default to 2*/
  end

   /* -------------------------------------------------------*/
   /* Translation of wild card dates.*/
   /* -------------------------------------------------------*/

  if (FQZREC.FQZBEGRG == 0) /* If beginning range is 0*/

    if (FQZREC.FQZENDRG == 0) /* and ending range is 0*/
      FQZREC.FQZENDRG = FQZREC.FQZCURRG; /* Set ending range*/
    end /* to current YYMMMM*/

    if (FQZREC.FQZCURM1 == 12) /* Calculate start range=back 2 years*/
      FQZREC.FQZBEGYY = FQZREC.FQZCURYY - FQZREC.FQZNUMYR + 1;
      if (FQZREC.FQZBEGYY < 0) /* To handle year 2000*/
        FQZREC.FQZBEGYY = 99 + FQZREC.FQZBEGYY + 1; /* Set year to 1999*/
      end
      FQZREC.FQZBEGM1 = 1;
      FQZREC.FQZBEGM2 = FQZREC.FQZCURM2 + 1;
    else
      FQZREC.FQZBEGYY = FQZREC.FQZCURYY - FQZREC.FQZNUMYR;
      if (FQZREC.FQZBEGYY < 0) /* To handle year 2000*/
        FQZREC.FQZBEGYY = 99 + FQZREC.FQZBEGYY + 1; /* Set year to 1999*/
      end
      FQZREC.FQZBEGM1 = FQZREC.FQZCURM1 + 1;
      FQZREC.FQZBEGM2 = FQZREC.FQZCURM2 + 1;
      if (FQZREC.FQZBEGM2 > 12)
        FQZREC.FQZBEGM2 = 1;
      end
    end

  else /* ; If begin range is not 0*/
    if (FQZREC.FQZENDRG > 0) /* and end range is not 0*/
      FQZREC.FQZWORK = FQZREC.FQZENDYY - FQZREC.FQZBEGYY;
      if (FQZREC.FQZWORK > FQZREC.FQZNUMYR)
                                   /* Check if range is within range?*/
        FQZREC.FQZBEGRC = "2";
        return;
      end
    else /* If end range is 0*/
                         /* Set end range to current date*/
      FQZREC.FQZENDRG = FQZREC.FQZCURRG;
    end
            /* Set end date to current date if it is > current date*/
    /* F FQZREC.FQZENDRG GT FQZREC.FQZCURRG; If ENDRG > CURRG*/
     /* MOVE FQZREC.FQZCURRG TO FQZREC.FQZENDRG; Set ENDRG to CURRG*/
    /* ND ;*/

  end
   /* ------------------------------------------------------------*/
   /* Indicate error if the delivery month is not 2 greater than*/
   /* the production month.*/
   /* Except for promotional products with production month of 1*/
   /* and delivery 12. (added 06/24/93 mhuynh).*/
   /* ------------------------------------------------------------*/

  if (FQZREC.FQZBEGM1 > FQZREC.FQZBEGM2) /* Beginning month*/
    FQZREC.FQZWORK = FQZREC.FQZBEGM1 - 12 + 2; /* Production month*/
  else
    if (FQZREC.FQZBEGM1 == 1
     && FQZREC.FQZBEGM2 == 12)
      FQZREC.FQZWORK = 12;
    else
      FQZREC.FQZWORK = FQZREC.FQZBEGM1 + 2; /* Production month*/
    end
  end

  if (FQZREC.FQZWORK != FQZREC.FQZBEGM2)
    FQZREC.FQZBEGRC = "1"; /* Indicate invalid date*/
  end

  if (FQZREC.FQZENDM1 > FQZREC.FQZENDM2) /* Ending month*/
    FQZREC.FQZWORK = FQZREC.FQZENDM1 - 12 + 2; /* Production month*/
  else
    if (FQZREC.FQZENDM1 == 1
     && FQZREC.FQZENDM2 == 12)
      FQZREC.FQZWORK = 12;
    else
      FQZREC.FQZWORK = FQZREC.FQZENDM1 + 2; /* Production month*/
    end
  end

  if (FQZREC.FQZWORK != FQZREC.FQZENDM2)
    FQZREC.FQZENDRC = "1"; /* Indicate invalid date*/
  end

  if (FQZREC.FQZBEGRC == "1"
   || FQZREC.FQZENDRC == "1")
    return; /* Return to calling process*/
  end


   /* ------------------------------------------------------------*/
   /* Convert format of beginning month from YYMMMM to CCYYMMMM.*/
   /* ------------------------------------------------------------*/

  set TA2REC empty; /* clear row storage area*/

  TA2REC.TA2DTOPT = "GREGGREG"; /* option*/
  TA2REC.TA2GRTYP = "E"; /* type*/
  TA2REC.TA2GRGDD = 01; /* dd to be validated*/

  TA2REC.TA2GRGYM = FQZREC.FQZBEGYM; /* Beginning yymm to be validatd*/

  try
    call "TA0040" (TA2REC) {isNoRefresh = yes, isExternal = yes};
  end /* date routine*/

   /* ------------------------------------------------------------*/
   /* Indicate error if the date doesn't pass the verification.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && TA2REC.TA2RTNCD < 888)         /* and subroutine completed*/

    if (TA2REC.TA2RTNCD == 0) /* Normal return code*/

      FQZREC.FQZBCYM = TA2REC.TA2GRCYM; /* Convert beginning month*/
      FQZREC.FQZBMM2 = FQZREC.FQZBEGM2;

    else
      FQZREC.FQZBEGRC = "1"; /* Indicate invalid date entered*/

    end

  else

    TAEREC.TAEDESC1 = sysVar.errorCode;
    TAEREC.TAEDESC2 = TA2REC.TA2GROUP;

    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    TA1REC.TA1TYPE = "APPL"; /* Type of error*/
    TA1REC.TA1LOC = "XSFQS05 EDIT THE BEGINNING MONTH";

    call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

    FQWREC.XXXMODID = "X05"; /* Module identification*/
    converseLib.validationFailed(1); /* System error occurred*/

    exit stack; /* exit to display map*/

  end

   /* ------------------------------------------------------------*/
   /* Convert format of ending month from YYMM to CCYYMM.*/
   /* ------------------------------------------------------------*/

  TA2REC.TA2CENT = 0; /* Initialize century field*/
  TA2REC.TA2GRGYM = FQZREC.FQZENDYM; /* Ending yymm to be validated*/

  try
    call "TA0040" (TA2REC) {isNoRefresh = yes, isExternal = yes};
  end /* date routine*/

   /* ------------------------------------------------------------*/
   /* Indicate error if the date doesn't pass the verification.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && TA2REC.TA2RTNCD < 888)         /* and subroutine completed*/

    if (TA2REC.TA2RTNCD == 0) /* Normal return code*/

      FQZREC.FQZECYM = TA2REC.TA2GRCYM; /* Convert ending month*/
      FQZREC.FQZEMM2 = FQZREC.FQZENDM2;
    else
      FQZREC.FQZENDRC = "2"; /* Indicate invalid date entered*/

    end

  else

    TAEREC.TAEDESC1 = sysVar.errorCode;
    TAEREC.TAEDESC2 = TA2REC.TA2GROUP;

    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    TA1REC.TA1TYPE = "APPL"; /* Type of error*/
    TA1REC.TA1LOC = "XSFQS05 EDIT THE ENDING MONTH";

    call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

    FQWREC.XXXMODID = "X05"; /* Module identification*/
    converseLib.validationFailed(1); /* System error occurred*/

    exit stack; /* exit to display map*/

  end

   /* ------------------------------------------------------------*/
   /* If an error was found, return to the calling process.*/
   /* ------------------------------------------------------------*/

  if (FQZREC.FQZBEGRC == "1" /* Invalid beginning date*/
   || FQZREC.FQZENDRC == "1") /* or invalid ending date*/

    return; /* Return to calling process*/

  end

   /* ------------------------------------------------------------*/
   /* Establish the qualified range in form CCYYMMMM which will*/
   /* be used to verify the dates passed over.*/
   /* ------------------------------------------------------------*/

  FQZREC.FQZWE2MM = XX0XW01.XX0XWMM; /* End 2nd month*/
  FQZREC.FQZWECYM = XX0XW01.XX0XWCYM; /* End CCYYMM*/
  FQZREC.FQZWE1MM = FQZREC.FQZWE2MM - 2; /* End 1st month*/
  if (FQZREC.FQZWE1MM <= 0) /* If month field over 12*/
    FQZREC.FQZWE1MM = FQZREC.FQZWE2MM + 12 - 2;
    FQZREC.FQZWEYY = FQZREC.FQZWEYY - 1;
  end

  if (FQZREC.FQZWE1MM == 12) /* Calculate Begin CCYYMMMM*/
    FQZREC.FQZWBYY = FQZREC.FQZWEYY - FQZREC.FQZNUMYR + 1;
    FQZREC.FQZWB1MM = 1;
    FQZREC.FQZWB2MM = FQZREC.FQZWE2MM + 1;
  else
    FQZREC.FQZWBYY = FQZREC.FQZWEYY - FQZREC.FQZNUMYR;
    FQZREC.FQZWB1MM = FQZREC.FQZWE1MM + 1;
    FQZREC.FQZWB2MM = FQZREC.FQZWE2MM + 1;
    if (FQZREC.FQZWB2MM > 12)
      FQZREC.FQZWB2MM = 1;
    end
  end


   /* ------------------------------------------------------------*/
   /* Indicate error if the date is out of allowable bounds,*/
   /* or the beginning date is greater than the ending date.*/
   /* ------------------------------------------------------------*/

  if (FQZREC.FQZBCYMM < FQZREC.FQZWBEG) /* Less than valid starting mo.*/

    FQZREC.FQZBEGRC = "2"; /* Indicate invalid date*/

  end

  if (FQZREC.FQZECYMM > FQZREC.FQZWEND) /* greater than valid end mo.*/

    FQZREC.FQZENDRC = "2"; /* Indicate invalid date*/

  end

  if (FQZREC.FQZBCYMM > FQZREC.FQZECYMM) /* greater than valid end mo.*/

    FQZREC.FQZBEGRC = "2"; /* Indicate invalid date*/

  end


   /* ------------------------------------------------------------*/
   /* If an error was found, return to the calling process.*/
   /* ------------------------------------------------------------*/

  if (FQZREC.FQZBEGRC == "2" /* Beginning date out of range*/
   || FQZREC.FQZENDRC == "2") /* or ending date out of range*/

    return; /* Return to calling process*/

  end

   /* ------------------------------------------------------------*/
   /* If obtain date switch is not 'on', return.*/
   /* ------------------------------------------------------------*/

  if (FQZREC.FQZCHK24 != "Y") /* Switch not equal 'Y'*/

    return; /* Return to calling process*/

  end

   /* ------------------------------------------------------------*/
   /* Format the array with the individual months in the range.*/
   /* ------------------------------------------------------------*/

  FQZREC.FQZWBEG = FQZREC.FQZBCYMM; /* Beginning month*/

  while (FQZREC.FQZWBEG <= FQZREC.FQZECYMM) /* Until end of range*/

    FQZREC.FQZNUMMO = FQZREC.FQZNUMMO + 1; /* Number of months*/

    FQZREC.FQZINDMO[FQZNUMMO] = FQZREC.FQZWBEG; /* Individual month*/

    FQZREC.FQZWB1MM = FQZREC.FQZWB1MM + 1; /* Increment month*/
    FQZREC.FQZWB2MM = FQZREC.FQZWB2MM + 1; /* Increment month*/

    if (FQZREC.FQZWB1MM > 12) /* Month greater than 12*/

      FQZREC.FQZWB1MM = FQZREC.FQZWB1MM - 12; /* Decrement month*/
      FQZREC.FQZWBYY = FQZREC.FQZWBYY + 1; /* Increment year*/

    end

    if (FQZREC.FQZWB2MM > 12) /* Month greater than 12*/

      FQZREC.FQZWB2MM = FQZREC.FQZWB2MM - 12; /* Decrement month*/

    end

  end


end // end XSFQS05

// Exit to another application
Function XSFY001()
   /* ------------------------------------------------------------*/
   /* Set the application to be invoked for PF1 or PF4.*/
   /* Set the application to be invoked for PF3 if in FY0A.*/
   /* Save the application user area in the COMMAREA.*/
   /* Transfer control to the specified application.*/
   /* If transfer failed, return an error to the calling process.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf1) /* PF1 was pressed*/

    COMMAREA.CATOAP = "GD01"; /* Indicate Goal Documentation*/

  end

  if (converseVar.eventKey is pf3 /* PF3 was pressed*/
   && COMMAREA.CACURRAP == "FY0A") /* and Factory Menu*/

    COMMAREA.CATOAP = "FY0M"; /* Indicate Production Menu*/

  end

  if (converseVar.eventKey is pf3 /* PF3 was pressed*/
   && COMMAREA.CACURRAP == "FY0M") /* and Production Menu*/

    COMMAREA.CATOAP = "MN0M"; /* Indicate Master Menu*/

  end

  if (converseVar.eventKey is pf4) /* PF4 was pressed*/

    COMMAREA.CATOAP = "MN0M"; /* Indicate Master Menu*/

  end

  if (COMMAREA.CATOSYS == "FY") /* Transfer within Factory*/

    COMMAREA.CAUSERA = FYWREC.CAUSERA; /* Save user area*/
  else
    COMMAREA.CAUSERA = " "; /* Clear user area*/

  end

  COMMAREA.CAFROMAP = COMMAREA.CACURRAP; /* From application*/
  XSEXIT(); /* Exit to another application*/

  COMMAREA.CAITEM = " "; /* Clear any application data*/

  if (COMMAREA.CASECRC == 3 /* Application not found*/
   || COMMAREA.CASECRC == 4) /* or transfer not allowed*/

    converseLib.validationFailed(6); /* Indicate not allowed*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/

  end


end // end XSFY001

// edit Tran ID (P)ass/(F)ail
Function XSGD010()

     /* *********************************************************/
     /* *         Validates transaction id for                 **/
     /* *         Goal Documentation subsystem                 **/
     /* *                                                      **/
     /* *   Locate the transaction id on the tran link table,  **/
     /* * if found, the edit is passed, if not found, the edit **/
     /* * is failed.  The row number is left intact in EZETST  **/
     /* * for access to the member name and logically previous **/
     /* * Tran - ID.                                           **/
     /* *********************************************************/

     /* convert map names, tables names, etc to proper*/
     /* goal doc "xgettrn" ids.*/

     /* ids     meaning*/
     /* xxVW    Overviews*/
     /* xxSC    Screen Info.*/
     /* xxRE    Reports*/
     /* xxAP    Appendix*/
     /* xxEX    Exception Processing*/
     /* xxTB    Table Info.*/
     /* where 'xx' in ids field is equal to 'system id'*/


  if (GDWREC.GDW-ITEM-POSN5 == "M") /* if csm map name*/
    GDW-TID-POSN3 = "SC"; /* set id to 'xxSC'*/
  end


  if (GDWREC.GDWTID in XGETBL.XGETTRN)
    XSGD012();
  else
    XSGD014();
  end
  return;

     /* *********************************************************/
     /* *       What logically happens after find.             **/
     /* *                                                      **/
     /* *        IF EZETST EQ 0;                               **/
     /* *           MOVE 'F' TO GDWSWORK.GDWEDIT;              **/
     /* *        ELSE ;                                        **/
     /* *           MOVE 'P' TO GDWSWORK.GDWEDIT;              **/
     /* *        END ;                                         **/
     /* *********************************************************/



end // end XSGD010

// found item on TLT.
Function XSGD012()

     /* *********************************************************/
     /* *   This statement group does the following:           **/
     /* * Found item on transaction link table.              . **/
     /* *     set pass flag & set gd2tran value                **/
     /* * ----  fix: 02-12-93   vcowan -----                   **/
     /* *********************************************************/

  GDWREC.GDWEDIT = "P";
  GD2REC.GD2TRAN = XGETBL.XGETTID[sysVar.arrayIndex];
  return;



end // end XSGD012

// tran not found on TLT
Function XSGD014()

     /* **********************************************************/
     /* *    This statement group does the following:           **/
     /* *Tran not found on transaction link table. set fail flag**/
     /* **********************************************************/

  GDWREC.GDWEDIT = "F";

  if (GDWREC.GDW-TID-POSN1 == "U") /* if european csp trans*/
    GD2REC.GD2TRAN = "GD09";
  else
    GD2REC.GD2TRAN = "GD06";
  end

  return;



end // end XSGD014

// transfer to application failed
Function XSGD040()

     /* **********************************************************/
     /* *         Fast path transfer failed message.            **/
     /* **********************************************************/

  GD3REC.GD3PEND1 = "TRANSFER TO APPLICATION FA"; /* set up error*/
  GD3REC.GD3PEND2 = "ILED.  VERIFY THAT NAME IS"; /* message.*/
  GD3REC.GD3PEND3 = "CORRECT AND TRY AGAIN.    ";

  return;



end // end XSGD040

// Link to GD00 or GD01.
Function XSGD092()

     /* *********************************************************/
     /* * This Statement group does the following depending on **/
     /* * whether the Item field entry is to display menu or   **/
     /* * text.                                                **/
     /* *                                                      **/
     /* *     The menu option is validated by searching the    **/
     /* * TLT, if it is not found, then it is an invalid help  **/
     /* * option. Or if it is found, and the second column of  **/
     /* * the TLT is '    MENU' then a transfer to gd00 is done**/
     /* * IF the second column of the TLT does not indicate a  **/
     /* * menu then GD01 is invoked.                           **/
     /* *                                                      **/
     /* *      Messages are placed in GDWSWORK.GDWPEND so that **/
     /* * the calling application can move them to the correct **/
     /* * map's EZEMSG field.                                  **/
     /* *********************************************************/

    /* The tran code must be in gdwswork.gdwtid.*/

  GDWREC.GDWITEM = COMMAREA.CAITEM;
  GDWREC.GDWTID = GDWREC.GDWITID;

   /* mOVE GDWREC.GDWRECGP TO COMMAREA.CAUSERA;*/

  XSGD010(); /* finds tran code on table.*/

  if (GDWREC.GDWEDIT == "P") /* tran code found on TLT*/

    GDWREC.GDWUTID = GDWREC.GDWFMAPP;
    COMMAREA.CAITEM = GDWREC.GDWITEM;
    COMMAREA.CATOAP = "GD00"; /* always go thru menu tran*/
    COMMAREA.CAUSERA = GDWREC.GDWRECGP;

    XSEXIT();

    XSGD040(); /* transfer failed, format message.*/
    return; /* return to appl to display message.*/

  else /* not on table, must be outside of help system.*/

    GD3REC.GD3PEND1 = "INVALID HELP OPTION.  PLEA"; /* set up error*/
    GD3REC.GD3PEND2 = "E VERIFY THAT NAME IS CORR"; /* message.*/
    GD3REC.GD3PEND3 = "ECT AND TRY AGAIN.        ";

    return; /* return to appl to display message.*/
  end



end // end XSGD092

// edit Tran ID (P)ass/(F)ail
Function XSGDG10()

     /* *********************************************************/
     /* *         Validates transaction id for                 **/
     /* *         Goal Documentation subsystem                 **/
     /* *                                                      **/
     /* *   Locate the transaction id on the CSP  table,       **/
     /* * if found, the edit is passed, if not found, the edit **/
     /* * is failed.  The row number is left intact in EZETST  **/
     /* * for access to the member name and logically previous **/
     /* * Tran - ID.                                           **/
     /* *********************************************************/


  if (GDWREC.GDWICSP in XGLTBL.XGLTCOD)
    XSGDG12();
  else
    XSGDG14();
  end
  return;

     /* *********************************************************/
     /* *       What logically happens after find.             **/
     /* *                                                      **/
     /* *        IF EZETST EQ 0;                               **/
     /* *           MOVE 'F' TO GDWSWORK.GDWEDIT;              **/
     /* *        ELSE ;                                        **/
     /* *           MOVE 'P' TO GDWSWORK.GDWEDIT;              **/
     /* *        END ;                                         **/
     /* *********************************************************/



end // end XSGDG10

// found item on csp table.
Function XSGDG12()

     /* *********************************************************/
     /* *   This statement group does the following:           **/
     /* * Found item on CSP appl. link table. Set pass flag.   **/
     /* *********************************************************/

  GDWREC.GDWEDIT = "P";

  return;



end // end XSGDG12

// tran not found on CSP table.
Function XSGDG14()

     /* **********************************************************/
     /* *    This statement group does the following:           **/
     /* *Tran not found on CSP appl. link table. set fail flag  **/
     /* **********************************************************/

  GDWREC.GDWEDIT = "F";

  return;



end // end XSGDG14

// Move message field to map
Function XSGDG22()

     /* *********************************************************/
     /* *       This statement group does the following:       **/
     /* * Move and clear pending message field, set ring bell. **/
     /* *********************************************************/

  XMGDM002.VAGen_EZEMSG = GD3REC.GD3PEND;
  GD3REC.GD3PEND = " ";

   /* SET XMGDM002 ALARM;*/
  return;



end // end XSGDG22

// find csp code on gd0gt table
Function XSGDG90()

     /* *********************************************************/
     /* *       This Statement group does the following        **/
     /* *   Takes the tran code entered by the user on the     **/
     /* *  item field and searchs the CSP application table    **/
     /* *  GD0GT for the application which displays the CSP    **/
     /* *  table which has been requested. If the tran code    **/
     /* *  is found the user is transfered to the required     **/
     /* *  application. If the tran code is invalid, a nasty   **/
     /* *  gram is returned requesting correction.             **/
     /* *                                                      **/
     /* *      Messages are placed in GDWSWORK.GDWPEND so that **/
     /* * the calling application can move them to the correct **/
     /* * map's EZEMSG field.                                  **/
     /* *********************************************************/

            /* The tran code must be in gdwswork.gdwtid.*/

  GDWREC.GDWITEM = COMMAREA.CAITEM;
  GDWREC.GDWTID = GDWREC.GDWITID;

  XSGDG10(); /* finds csp code on table.*/


  if (GDWREC.GDWEDIT == "P") /* tran code found on GD0GwT1.*/

    GDWREC.GDWUTID = GDWREC.GDWFMAPP;
    COMMAREA.CAITEM = GDWREC.GDWITEM;
    COMMAREA.CATOAP = XGLTBL.XGLTAPP[sysVar.arrayIndex];

    if (COMMAREA.CATOAP == "KM0Q")
      COMMAREA.CAITEM = 2;
    end

    XSEXIT();

    XSGD040(); /* transfer failed, format message.*/
    return; /* return to appl to display message.*/

  else /* not on table, must be outside of CSP system.*/

    GD3REC.GD3PEND1 = "INVALID CSP  OPTION. PLEAS"; /* set up error*/
    GD3REC.GD3PEND2 = "E VERIFY THAT NAME IS CORR"; /* message.*/
    GD3REC.GD3PEND3 = "ECT AND TRY AGAIN.        ";

    return; /* return to appl to display message.*/

  end



end // end XSGDG90

// inquiry : setaside hdr : 0
Function XSINAI0()


   /* ************************************************************/
   /* *** select unique row of:  setaside hdr                 ****/
   /* *** using the std module:  IO0940                       ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   +100 = not found                                  ****/
   /* ***   -811 = duplicates found                           ****/
   /* ***          note: do NOT clear screen                  ****/
   /* ***     <0 = db/severe error (&-911)                    ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** select unique row                                   ****/
   /* ************************************************************/

  call "IO0940" ("S ", SQLCA, INAREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -811)
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSINAI0 ";
  TA1REC.TA1LOCAT[1] = "IO0940  ";
  TA1REC.TA1LOCAT[3] = "SELECT  ";
  TA1REC.TA1LOCAT[4] = "UNIQUE  ";
  TA1REC.TA1DBASE = "DINVNT  ";
  TA1REC.TA1TBLVU = "VASHDR01";
  TA1REC.TA1TBLKE = INAREC.INADATA;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSINAI0

// Call IN8020 Subroutine
Function XSINS-CALL-IN8020()
   /* ------------------------------------------------------------------*/
   /* - -       S U B R O U T I N E   D E S C R I P T I O N         - -*/
   /* ------------------------------------------------------------------*/
   /*  */
   /* This subroutine allows for access to product databases based*/
   /* on input parameters it receives in INGREC.  It will also*/
   /* calculate unit price or unit cost of an inventory item if*/
   /* requested by the process code. (See IN8020 for process codes).*/
   /*  */
   /* The calling program must check the return code.*/
   /* - For non-fatal return code (except 0000), the calling*/
   /* program is required to do a POST.*/
   /* - For a DB2 deadlock (8000), the calling program may try*/
   /* to call IN8020 again up to a certain number of times.*/
   /* It is the calling program's responsibility to display an*/
   /* appropriate message when the limit is exceeded.*/
   /* - For fatal return code, the ABEND screen gets displayed.*/
   /*  */
   /* For a list of possible return codes, please see the source*/
   /* code for IN8020, the list will be maintained there only.*/
   /* IN8020 will populate INGREC.ING-RETURN-CD.*/
   /*  */
   /* EZERT8*/
   /* ------*/
   /* '00000000' = Normal Return*/
   /* OTHER      = Unexpected Error Has Occurred*/
   /*  */

  try
    call "IN8020" (INGREC) {isNoRefresh = yes, isExternal = yes};
  end /* Call subroutine*/

   /* ------------------------------------------------------------------*/
   /* If successful call, check IN8020 return code.*/
   /* Otherwise, an unexpected error has occurred, call TA0020.*/
   /* ------------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/

    /* ------------------------------------------------------------------*/
    /* If the return code category is 'No Error' or 'Warning' or 'Error'*/
    /* or DB2 deadlock, return to previous process/statement group.*/
    /* ------------------------------------------------------------------*/

    if (INGREC.ING-RETURN-CD >= 0000
     && INGREC.ING-RETURN-CD <= 2300)
      return;
    end

    if (INGREC.ING-RETURN-CD == 8000)
      return;
    end

    /* ------------------------------------------------------------------*/
    /* When the return code is fatal, call TA0020.*/
    /* ------------------------------------------------------------------*/

    TA1REC.TA1-GROUP = INGREC.TA1-GROUP;
    TAEREC.SQLCAREC = INGREC.SQLCAREC;

    /* ------------------------------------------------------------------*/
    /* When DB2 error, roll back any update done in IN8020.*/
    /* ------------------------------------------------------------------*/

    if (INGREC.ING-RETURN-CD > 8000
     && INGREC.ING-RETURN-CD <= 8999) /* DB2 error*/
      VGVar.handleSysLibraryErrors = 0;
      sysLib.rollback(); /* Roll back all changes*/
    end

  else
    TA1REC.TA1TYPE = "APPL"; /* Error type*/
    TA1REC.TA1FUNC = "RETN"; /* Error function*/
    TA1REC.TA1MAP = sysVar.errorCode; /* CSP error code*/
    TAEREC.TAEDESC1 = "ERROR OCCURRED-BAD CSP CALL TO IN8020"; /* Error message*/
    TAEREC.TAEDESC2 = INGREC.ING-GROUP;
                                   /* Called subr. parms*/
  end

  call "TA0020" (TA1REC, TAEREC) {isExternal = yes};

  COMMAREA.CAMSG = "FATAL ERROR OCCURRED IN PRODUCT ACCESS SUBR";

  exit stack;
end // end XSINS-CALL-IN8020

// Call IN8000 Rules Subprogram
Function XSINS-PROCESS-RULE()
   /* ------------------------------------------------------------------*/
   /* - - S U B R O U T I N E   D E S C R I P T I O N   - -*/
   /* ------------------------------------------------------------------*/
   /*  */
   /* This subroutine obtains distribution systems processing rule*/
   /* table entries by calling subprogram IN8000.*/
   /*  */
   /* The rule sets are defined by a rule type, they are:*/
   /* 1.  WHSECODE*/
   /* 2.  BASEORDTYP*/
   /* 3.  BRANDCODE*/
   /* 4.  BRANDORDER*/
   /* 5.  DIVISNCODE*/
   /* 6.  SALESOFCID*/
   /* 7.  THEATEROPR*/
   /* 8.  PGMSPECFIC*/
   /*  */
   /* Each rule type has an associated table of data.  IN8000 will*/
   /* retrieve hard coded values from these tables and return them*/
   /* back to the calling program.*/
   /*  */
   /* This subroutine uses the following CSP records.*/
   /* INRREC   - Used in call to IN8000, is redefined for*/
   /* rule type specific record requirements.*/
   /* INRREC01 - Use for rule type BRANDCODE calls.*/
   /* INRREC02 - Use for rule type WHSECODE calls.*/
   /* INRREC03 - Use for rule type LIFECYCLAL calls.*/
   /* INRREC04 - Use for rule type DNSBDATE calls.*/
   /* INRREC05 - Use for rule type BASEORDTYP calls.*/
   /* INRREC06 - Use for rule type DIVISNCODE calls.*/
   /* INRREC07 - Use for rule type SALESOFCID calls.*/
   /*  */
   /* This subroutine will return the CSP return code in EZERT8,*/
   /* and the subroutine's return code in INRREC.INR-RETURN-CODE.*/
   /*  */
   /* This subroutine will do any required error diagnosis*/
   /* reporting using TA0020.  The calling application must check the*/
   /* return codes and take the appropriate action relating to its*/
   /* function and expected result.*/
   /*  */
   /* *******************************************************/
   /* ***     Return Codes Defined                       ****/
   /* *******************************************************/
   /* ***   EZERT8                                       ****/
   /* ***   ------                                       ****/
   /* ***   '00000000' = Normal Return                   ****/
   /* ***   OTHER      = Unexpected Error Has Occurred   ****/
   /* ***                                                ****/
   /* ***   INRREC.INR-RETURN-CODE                       ****/
   /* ***   ----------------------                       ****/
   /* ***   '0' = Normal Return, Entry Found             ****/
   /* ***   '1' = Normal Return, No Entry Found          ****/
   /* ***   OTHER = Unexpected Error Has Occurred        ****/
   /* *******************************************************/
   /*  */
   /* The following is an example of how to make the WHSECODE rule*/
   /* type call.  Note: when IN8000 finds a matching table entry*/
   /* the subscript for that entry is put in INRREC.INR-SEARCH-SUB.*/
   /*  */
   /*  */
   /* SET INRREC EMPTY;*/
   /*  */
   /* MOVE CALLING-PROCESS                 TO  TA1REC.TA1PGMNM;*/
   /* MOVE CALLING-PROCESS-DESCRIPTION     TO  TA1REC.TA1LOCAT;*/
   /*  */
   /* MOVE 'WHSECODE'   TO  INRREC.INR-RULE-TYPE;*/
   /* MOVE XWH-WHSE-CD  TO  INRREC02.XWH-WHSE-CD;*/
   /* MOVE 'Y'          TO  INRREC02.INR-SEARCH-FL;*/
   /* ;*/
   /* XSINS-PROCESS-RULE;    /* CALL IN8000*/
   /* ;*/
   /* IF INRREC.INR-RETURN-CODE EQ 0;*/
   /* IF INRREC02.INR-XOW-ALTER-FL(INRREC.INR-SEARCH-SUB) EQ 'Y';*/
   /* MOVE INRREC02.XOW-OWN-GRP-CD(INRREC.INR-SEARCH-SUB)*/
   /* TO CALLING-PGM-XOW;*/
   /* ELSE;*/
   /* MOVE CALLING-PGM-DEFAULT-XOW TO CALLING-PGM-XOW;*/
   /* END;*/
   /* ELSE;*/
   /* IF INRREC.INR-RETURN-CODE EQ 1;*/
   /*  */
   /* ISSUE ERROR MESSAGE PER APPLICATION, NO ENTRY FOUND*/
   /*  */
   /* END;*/
   /* END;*/
   /*  */
   /* ------------------------------------------------------------------*/
   /* - - S U B R O U T I N E   D E S C R I P T I O N   - -*/
   /* ------------------------------------------------------------------*/
   /*  */

  try
    call "IN8000" (INRREC) {isNoRefresh = yes, isExternal = yes};
  end /* Call subroutine*/

   /* ------------------------------------------------------------------*/
   /* If successful, return to previous process/statement group.*/
   /* Otherwise, an unexpected error has occurred, call TA0020.*/
   /* ------------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/
    if (INRREC.INR-RETURN-CODE == 0) /* Normal return code*/
      return; /* Return*/
    else
      if (INRREC.INR-RETURN-CODE > 1) /* Unexpected error*/
        TA1REC.TA1TYPE = "APPL"; /* Error type*/
        TA1REC.TA1FUNC = "RETN"; /* Error function*/
        TA1REC.TA1MAP = sysVar.errorCode; /* CSP error code*/
        TAEREC.TAEDESC1 = "ERROR OCCURRED-IN8000 RET-CD GT 1"; /* Error message*/
        TAEREC.TAEDESC2 = INRREC.INR-PARAMETERS; /* Called subr. parms*/
        call "TA0020" (TA1REC, TAEREC) {isExternal = yes};
      end
    end
  else
    TA1REC.TA1TYPE = "APPL"; /* Error type*/
    TA1REC.TA1FUNC = "RETN"; /* Error function*/
    TA1REC.TA1MAP = sysVar.errorCode; /* CSP error code*/
    TAEREC.TAEDESC1 = "ERROR OCCURRED-BAD CSP CALL TO IN8000"; /* Error message*/
    TAEREC.TAEDESC2 = INRREC.INR-PARAMETERS; /* Called subr. parms*/
    call "TA0020" (TA1REC, TAEREC) {isExternal = yes};
  end

  return; /* Return*/
end // end XSINS-PROCESS-RULE

// CALL IN8000 TO GET THEATEROPR
Function XSINS-THEATEROPR()
  set INRREC empty; /* initialize record*/
  INRREC.INR-RULE-TYPE = "THEATEROPR"; /* rule type*/

  try
    call "IN8000" (INRREC) {isNoRefresh = yes, isExternal = yes};
  end /* call in8000*/

   /* If successful, return to previous process/statement group.*/
   /* otherwise, an unexpected error has occurred, call TA0020.*/

  if (sysVar.errorCode == "00000000") /* call sucessful*/
    if (INRREC.INR-RETURN-CODE == 0) /* normal return code*/
      return; /* return to previous process*/
    else
      if (INRREC.INR-RETURN-CODE > 1) /* unexpected error*/
        TA1REC.TA1TYPE = "APPL"; /* error type*/
        TA1REC.TA1FUNC = "RETN"; /* error function*/
        TA1REC.TA1MAP = sysVar.errorCode; /* csp error code*/
        TAEREC.TAEDESC1 = "ERROR OCCURRED IN8000 RET CD GT 1"; /* error message*/
        TAEREC.TAEDESC2 = INRREC.INR-PARAMETERS; /* called subr. parms*/
        call "TA0020" (TA1REC, TAEREC) {isExternal = yes};
      end
    end
  else
    TA1REC.TA1TYPE = "APPL"; /* error type*/
    TA1REC.TA1FUNC = "RETN"; /* error function*/
    TA1REC.TA1MAP = sysVar.errorCode; /* csp error code*/
    TAEREC.TAEDESC1 = "ERROR OCCURRED, BAD CSP CALL TO IN8000"; /* error message*/
    TAEREC.TAEDESC2 = INRREC.INR-PARAMETERS; /* called subr. parms*/
    call "TA0020" (TA1REC, TAEREC) {isExternal = yes};
  end

end // end XSINS-THEATEROPR

// Call IN9060 upd inv db subrtn
Function XSINS-UPD-INV-ITEM()
   /* ------------------------------------------------------------------*/
   /* - -       S U B R O U T I N E   D E S C R I P T I O N         - -*/
   /* ------------------------------------------------------------------*/
   /*  */
   /* This subroutine updates inventory header and item databases*/
   /* based upon the input parameters (INFREC).  It also updates*/
   /* inventory audit header and item databases.*/
   /*  */
   /* The calling program must check the return code.  For non-fatal*/
   /* - For non-fatal return code (except 0000), the calling*/
   /* program is required to do a POST for now.*/
   /* - For a DB2 deadlock (8000), the calling program may try*/
   /* to call IN9060 again up to a certain number of times.*/
   /* It is the calling program responsibility to display an*/
   /* appropriate message when the limit is exceeded.*/
   /* - For fatal return code, the ABEND screen gets displayed.*/
   /*  */
   /* Below is list of all the possible return codes:*/
   /*  */
   /* EZERT8*/
   /* ------*/
   /* '00000000' = Normal Return*/
   /* OTHER      = Unexpected Error Has Occurred*/
   /*  */
   /* INFREC.INF-RETURN-CODE (IN9060 return codes)*/
   /* ----------------------*/
   /* Code    Category    Desciption*/
   /* ----    --------    ----------*/
   /* 0000    No error    No errors encountered*/
   /*  */
   /* 0110    Warning     IN_RSRV_FL not set for reservation*/
   /* 0120    Warning     IN-ALOC_FL not set for allocation*/
   /* 0130    Warning     XIR_TRN_RSN_SET_FL not set for setaside*/
   /* 0140    Warning     CHG-QTYs all zero, no updates processed*/
   /* 0200    Warning     Inv header missing for inv item*/
   /* 0210    Warning     Input ZZ-CHNG-HHMM not possibly populated*/
   /* 0220    Warning     Input ZZ-CHNG-PGM-ID not populated*/
   /* 0230    Warning     IN8000 call not successful*/
   /* 0300    Warning     Negative IN_ON_HAND_QTY*/
   /* 0310    Warning     Negative IN_RSRV_QTY*/
   /* 0320    Warning     Negative IN_ALOC_QTY*/
   /* 0330    Warning     Negative IN_SET_ASIDE-QTY*/
   /* 0340    Warning     Negative IN_XFER_OUT_QTY*/
   /* 0350    Warning     Negative IN_XFER_IN_QTY*/
   /* 0360    Warning     Negative net inventory quantity*/
   /* 0400    Warning     Sign of CHG-QTY does not match process cd*/
   /*  */
   /* 2010    Error       Invalid XIT-XIR code combination for adj*/
   /*  */
   /* 6020    Fatal       Input IN-RCV-DT not populated*/
   /* 6030    Fatal       Input IN-SHP-DT not populated*/
   /* 7010    FataL       Required inv item db entry not found*/
   /* 7020    Fatal       Not found on select from XITTBL*/
   /* 7030    Fatal       Not found on select from XIRTBL*/
   /* 8000    Fatal       DB2 deadlock*/
   /* 8010    Fatal       DB2 error (see WERRDIAG and SQLCA)*/
   /* 9010    Fatal       Invalid IN9060 process code*/
   /* 9020    Fatal       Invalid XIF code*/
   /* 9030    Fatal       ZZ date and time fields not populated*/
   /* 9040    Fatal       Intervening update happened, ZZ change*/
   /* count has been updated*/

  try
    call "IN9060" (INFREC) {isNoRefresh = yes, isExternal = yes};
  end /* Call subroutine*/

   /* ------------------------------------------------------------------*/
   /* If successful call, check IN9060 return code.*/
   /* Otherwise, an unexpected error has occurred, call TA0020.*/
   /* ------------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/

    /* ------------------------------------------------------------------*/
    /* If the return code category is 'No Error' or 'Warning' or 'Error'*/
    /* or DB2 deadlock, return to previous process/statement group.*/
    /* ------------------------------------------------------------------*/

    if (INFREC.INF-RETURN-CODE >= 0000
     && INFREC.INF-RETURN-CODE <= 2999)
      return;
    end

    if (INFREC.INF-RETURN-CODE == 8000)
      return;
    end

    /* ------------------------------------------------------------------*/
    /* When the return code is fatal, call TA0020.*/
    /* ------------------------------------------------------------------*/

    TA1REC.TA1-GROUP = INFREC.TA1-GROUP;
    TAEREC.SQLCAREC = INFREC.SQLCAREC;

    /* ------------------------------------------------------------------*/
    /* When DB2 error, roll back any update done in IN9060.*/
    /* ------------------------------------------------------------------*/

    if (INFREC.INF-RETURN-CODE > 8000
     && INFREC.INF-RETURN-CODE <= 8999) /* DB2 error*/
      VGVar.handleSysLibraryErrors = 0;
      sysLib.rollback(); /* Roll back all changes*/
    end

  else
    TA1REC.TA1TYPE = "APPL"; /* Error type*/
    TA1REC.TA1FUNC = "RETN"; /* Error function*/
    TA1REC.TA1MAP = sysVar.errorCode; /* CSP error code*/
    TAEREC.TAEDESC1 = "ERROR OCCURRED-BAD CSP CALL TO IN9060"; /* Error message*/
    TAEREC.TAEDESC2 = INFREC.INF-GROUP;
                                   /* Called subr. parms*/
  end

  call "TA0020" (TA1REC, TAEREC) {isExternal = yes};

  COMMAREA.CAMSG = "FATAL ERROR OCCURRED IN INV DB UPD SUBROUTINE";

  exit stack;
end // end XSINS-UPD-INV-ITEM

// Abort routine
Function XSIVS02()



      /* *********************************************************/
      /* * online abort routine for invoice system              **/
      /* *********************************************************/

  TA1REC.TA1TYPE = "DB2"; /* abend type*/
  TA1REC.TA1FUNC = "RETN"; /* abend func*/
  set ERRSQLCA empty; /* clear area*/
  move SQLCA to ERRSQLCA withV60Compat; /* save orig sqlca*/
  VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
  VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
  sysLib.rollback();
  VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
   /* synpoint rollback*/
  try
    call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
  end /* ABEND MOD*/
  COMMAREA.CAUSERA = " "; /* clear user commarea*/
  XSPF4(); /* master menu*/
  exit program; /* master menu failure*/



   /* *************************************************************/
end // end XSIVS02

// Clear IVXREC invoice fields
Function XSIVSCX()

     /* ***   This statement group takes care of clearing   ****/
     /* *** the fields on the ivxrec specific to an invoice ****/
     /* *** This is called by iv0xsen before passing to the ****/
     /* *** next selected invoice                           ****/


  IVXREC.KUKPCOID = 0;

  IVXREC.IV0IVCDT = 0;
  IVXREC.XOBCD = "  ";
  IVXREC.SP1ID = "    ";
  IVXREC.XGPCD = "  ";
  IVXREC.XOCCD = "  ";
  IVXREC.KUCCOID = 0;
  IVXREC.KUMSTRID = 0;
  IVXREC.XNXCD = 0;
  IVXREC.KUCCONM = " ";
  IVXREC.XSOCD = "  ";
  IVXREC.OP1CUPO = " ";
  IVXREC.OP1CUOID = 0;
  IVXREC.OP1NORID = 0;
  IVXREC.SM1AGYID = " ";
  IVXREC.SM4REPID = 0;


end // end XSIVSCX

// Enter Key Pressed from Detail
Function XSIVSEN()

     /* ***   this statement group handles the case where  ****/
     /* *** the enter key was pressed on an invoice inquiry****/
     /* *** screen, and the type indicates that there may  ****/
     /* *** be additional selections from the Selection    ****/
     /* *** List.  This program searches the invoice array,****/
     /* *** and if any selections remain, passes control as****/
     /* *** the main menu option dictates. The cafromap    ****/
     /* *** value should already be set from the 'calling' ****/
     /* *** application.                                   ****/

     /* set index, and save old invoice*/

  IVYREC.IVYSUB = IVXREC.IVXIASST; /* set to array start point*/
  IVYREC.IVYIVCN = IVXREC.IV0IVCID; /* save invoice #*/
  IVXREC.IV0IVCID = 0; /* then 0 for next*/
  IVYREC.IVYSUB1 = 0; /* used to indicate if old was found*/

  IVXREC.IVXLOC = "XIVSEN"; /* move module name to work field*/
  XPIV002(); /* read temp storage*/

     /* if user selections, set current to V, then check for next*/

  while (IVYREC.IVYSUB <= IVXREC.IVXIATMX) /* loop thru array*/
    if (IVGREC.IVGIASFL[IVYSUB] == "S")
      if (IVGREC.IVGIAIVC[IVYSUB] == IVYREC.IVYIVCN)
        IVGREC.IVGIASFL[IVYSUB] = "V";
        IVXREC.IVXIAIDX = IVYREC.IVYSUB; /* save index for fun*/
        IVYREC.IVYSUB1 = 1;
        IVYREC.IVYSUB = IVYREC.IVYSUB + 1;
      else
        IVXREC.IV0IVCID = IVGREC.IVGIAIVC[IVYSUB];
        IVYREC.IVYSUB = IVXREC.IVXIATMX + 1; /* end loop*/
      end
    else
      IVYREC.IVYSUB = IVYREC.IVYSUB + 1; /* continue loop*/
    end
  end

     /* if didn't find old to mark yet, try again*/

  if (IVYREC.IVYSUB1 == 0)
    IVYREC.IVYSUB = 1;
    while (IVYREC.IVYSUB < IVXREC.IVXIATMX) /* loop thru array*/
      if (IVGREC.IVGIASFL[IVYSUB] == "S"
       && IVGREC.IVGIAIVC[IVYSUB] == IVYREC.IVYIVCN)
        IVGREC.IVGIASFL[IVYSUB] = "V";
        IVYREC.IVYSUB = IVYREC.IVYSUB + 1;
      else
        IVYREC.IVYSUB = IVYREC.IVYSUB + 1;
      end
    end
  end

  if (IVXREC.IVXWGQIX > 0) /* ;if temp storage record exists*/
    XPIV004(); /* ;  update temp storage*/
  end

   /* clear ivxrec of values for old invoice, and*/
   /* set up commarea for whereever we're going*/
  XSIVSCX();

  COMMAREA.CAUSERA = IVXREC.IVXGROUP;

     /* pass to iv0e if no selections remain*/

  if (IVXREC.IV0IVCID == 0)
    COMMAREA.CATOAP = "IV0E";
    XSEXIT();
    converseLib.validationFailed(15);
    return;
  end

     /* pass to the next screen as dictated by the main*/
     /* menu option*/

  if (IVXREC.IVXOPTN == 1
   || IVXREC.IVXOPTN == 2
   || IVXREC.IVXOPTN == 6)
    COMMAREA.CATOAP = "IV0G";
    XSEXIT(); /* transfer to Header 1*/
    converseLib.validationFailed(15); /* transfer failed*/
    return;
  else
    if (IVXREC.IVXOPTN == 3
     || IVXREC.IVXOPTN == 4)
      COMMAREA.CATOAP = "IV0N";
      XSEXIT(); /* transfer to Prod Summ & Detail*/
      converseLib.validationFailed(15); /* transfer failed*/
      return;
    else
      if (IVXREC.IVXOPTN == 7)
        COMMAREA.CATOAP = "IV0H";
        XSEXIT(); /* transfer to Comm & Pymt Terms*/
        converseLib.validationFailed(15); /* transfer failed*/
        return;
      else
        if (IVXREC.IVXOPTN == 8)
          COMMAREA.CATOAP = "IV0I";
          XSEXIT(); /* transfer to Address*/
          converseLib.validationFailed(15); /* transfer failed*/
          return;
        else
          if (IVXREC.IVXOPTN == 9)
            COMMAREA.CATOAP = "IV0J";
            XSEXIT(); /* transfer to Msgs & Instrs*/
            converseLib.validationFailed(15); /* transfer failed*/
            return;
          end
        end
      end
    end
  end



end // end XSIVSEN

// lookup Header and Company
Function XSIVSFH()
    /* ****      This statement group is used to retrieve  *****/
    /* ****      the invoice header index and company      *****/
    /* ****      records when have a new invoice.          *****/

   /* 03-27-91 bcourt Hold KUCSKIND for use in IV0NSDC.*/
   /* 03/13/92 lgross Move cu-prt-xref-fl to ivxrec.  Will be used*/
   /* to decide if lookup cust prod id or use nike prod id*/

     /* blank records before read*/

  set SQLCA empty;
  set IV0REC empty;

    /* set up keys for read of header index*/

  IV0REC.IV0IVCID = IVXREC.IV0IVCID;
  IVYREC.IVYIVCN = IVXREC.IV0IVCID;
  IV0REC.IV0PARTN = IVYREC.IV0PARTN;

  call "IO1110" ("S ", SQLCA, IV0REC) {isNoRefresh = yes};
  if (SQLCA.VAGen_SQLCODE == 0)
     /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      IVXREC.IVXMSSNB = 43;
      return;
    else
      TA1REC.TA1PGMNM = IVYREC.IVYMTXT; /* 1-26-88*/
      TA1REC.TA1MAP = "IV0?"; /* 1-26-88*/
      TA1REC.TA1DBASE = "DINVC   ";
      TA1REC.TA1TBLVU = "VIVHDX01";
      TA1REC.TA1TBLKE = IV0REC.IV0KEY;
      TA1REC.TA1LOCAT[3] = "XSIVSFH";
      TA1REC.TA1LOCAT[4] = "IO1110";
      XSIVS02();
    end
  end


  IVXREC.IV0IVCDT = IV0REC.IV0IVCDT;
  IVXREC.KUCCOID = IV0REC.KUCCOID;
  IVXREC.KUMSTRID = IV0REC.KUMSTRID;
  IVXREC.XNXCD = IV0REC.XNXCD;
  IVXREC.XOBCD = IV0REC.XOBCD;
  IVXREC.XSOCD = IV0REC.XSOCD; /* sales office code*/
  if (IVXREC.XSOCD in XSOTBL.XSOCD)
    IVXREC.XSOABRV = XSOTBL.XSOABRV[sysVar.arrayIndex]; /* sales office abrev*/
  end
  IVXREC.OP1CUOID = IV0REC.OP1CUOID;
  IVXREC.OP1NORID = IV0REC.OP1NORID;
  IVXREC.XGPCD = IV0REC.XGPCD;
  IVXREC.SM1AGYID = IV0REC.SM1AGYID;
  IVXREC.SM4REPID = IV0REC.SM4REPID;

     /* blank kucrec*/

  set KUCREC empty;

   /* look up company record to get name*/

  KUCREC.KUCCOID = IVXREC.KUCCOID;

  set SQLCA empty;

  call "IO0240" ("S ", SQLCA, KUCREC) {isNoRefresh = yes};
  if (SQLCA.VAGen_SQLCODE == 0)
     /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE != 0)
      TA1REC.TA1PGMNM = IVYREC.IVYMTXT; /* 1-26-88*/
      TA1REC.TA1MAP = "IV0?"; /* 1-26-88*/
      TA1REC.TA1DBASE = "DCUST   ";
      TA1REC.TA1TBLVU = "VCMPNY01";
      TA1REC.TA1TBLKE = KUCREC.KUCGRP;
      TA1REC.TA1LOCAT[3] = "XSIVSFH";
      TA1REC.TA1LOCAT[4] = "IO0240";
      XSIVS02();
    end
  end

  IVXREC.KUCCONM = KUCREC.KUCCONM;
  IVXREC.XLBCD = KUCREC.XLBCD;
  IVXREC.KUCSKIND = KUCREC.KUCSKIND; /* 3-27-91 add field*/
  IVXREC.CU-PRT-XREF-FL = KUCREC.CU-PRT-XREF-FL;
  if (KUCREC.KUCSKIND == "P")
    IVXREC.KUKPCOID = KUCREC.KUKPCOID; /* used in iv0nsdc*/
  end


end // end XSIVSFH

// reset for Fast Path
Function XSIVSFP()
    /* ****      This statement group is used to retrieve  *****/
    /* ****      the invoice header index and company      *****/
    /* ****      records when a screen has been entered    *****/
    /* ****      thru fast path and the fields in ivxrec   *****/
    /* ****      need to be set                            *****/

    /* blank user area*/

  COMMAREA.CAUSERA = " ";

    /* clear ivxrec, and set option and type flags*/

  set IVXREC empty; /* clear record*/
  IVXREC.IVXINIT = "IV0"; /* set init flag*/
  IVXREC.IVXTYPFL = "I"; /* set type to individual*/
  IVXREC.IVXOPTN = 1; /* set option to 1 - default option*/

     /* since have entered an invoice number, set typ flag to 'I'*/

  IVXREC.IVXTYPFL = "I";

    /* set up keys for read of header index*/

  XSIVSIT(); /* verify commarea.caitem is numeric*/

  IVYREC.IVYIVCN = COMMAREA.CAITEM; /* move to numeric item*/
  IVXREC.IV0IVCID = IVYREC.IVYIVCN; /* set ivxrec field*/

     /* iv0xsfh routine will do header index and company lookup*/

  XSIVSFH();


end // end XSIVSFP

// vALIDATE CAITEM NUMERIC
Function XSIVSIT()


   /* *************************************************************/
   /* ****  V A L I D A T E     C A I T E M     N U M E R I C *****/
   /* ****                                                    *****/
   /* **** loop thru all digits in commarea.caitem field and  *****/
   /* **** check that each one is ( GE 0 ) and ( LE 9 ). also *****/
   /* **** make sure there are no imbedded blanks. leading    *****/
   /* **** and trailing blanks are okay.                      *****/
   /* 09/23/93  lgross changed chek from 0 and 9 to '0' and   *****/
   /* '9' to avoid conflict of checking      *****/
   /* character against numeric             *****/
   /* *************************************************************/


   /* ***** find first no-blank character ******/
  IVYREC.IVYSUB4 = 1; /* initialize subscript to 1*/
  while (IVYREC.IVYSUB4 <= 20 /* loop thru character array*/
   && COMMAREA.CAITMLTR[IVYSUB4] == " ") /* leading blanks okay*/
    IVYREC.IVYSUB4 = IVYREC.IVYSUB4 + 1; /* inciment subscript*/
  end /* end of "while" loop*/

   /* *************************************************************/
   /* **** at this point, if ivysub4 LE 20,the first no-blank *****/
   /* **** character has been found                           *****/
   /* *************************************************************/
   /* **** but if ivysub4 eq 21, then entire caitem is blank.  ****/
   /* **** this code added 10-27-87 to handle fastpath in from ****/
   /* **** non-invoice system.  previous sgrp changed to check ****/
   /* **** for commarea.from-system ne commarea.current-system,****/
   /* **** in which case we execute this sgrp.        10-27-87 ****/
   /* *************************************************************/

  if (IVYREC.IVYSUB4 == 21) /* entire field is blank*/
    IVXREC.IVXMSSNB = 45; /* bad data in fastpath item field*/
    IVXREC.IVXINIT = "IV0";
    COMMAREA.CAUSERA = IVXREC.IVXGROUP;
    COMMAREA.CATOAP = "IV0A";
    XSEXIT();
    XSPF4();
    exit program;
  end

   /* *************** check each digit for numeric ****************/
  while (IVYREC.IVYSUB4 <= 20
   && COMMAREA.CAITMLTR[IVYSUB4] != " ")
    if (COMMAREA.CAITMLTR[IVYSUB4] >= "0"
     && COMMAREA.CAITMLTR[IVYSUB4] <= "9")
      /* next sentence*/
    else
      IVXREC.IVXMSSNB = 45;
      IVXREC.IVXINIT = "IV0";
      COMMAREA.CAUSERA = IVXREC.IVXGROUP;
      COMMAREA.CATOAP = "IV0A";
      XSEXIT();
      XSPF4();
      exit program;
    end
    IVYREC.IVYSUB4 = IVYREC.IVYSUB4 + 1;
  end

   /* *************************************************************/
   /* **** at this point the first blank has been incountered *****/
   /* **** following 1 or more numeric charaters -or- the end *****/
   /* **** of the character array has been reached. now make  *****/
   /* **** sure that any remaining characters in the array    *****/
   /* **** are blanks.                                        *****/
   /* *************************************************************/

  while (IVYREC.IVYSUB4 <= 20)
    if (COMMAREA.CAITMLTR[IVYSUB4] != " ")
      IVXREC.IVXMSSNB = 45;
      IVXREC.IVXINIT = "IV0";
      COMMAREA.CAUSERA = IVXREC.IVXGROUP;
      COMMAREA.CATOAP = "IV0A";
      XSEXIT();
      XSPF4();
      exit program;
    else
      IVYREC.IVYSUB4 = IVYREC.IVYSUB4 + 1;
    end
  end


   /* *************************************************************/
   /* **** at this point the content of commarea.caitem is    *****/
   /* **** varified as a valid numeric.                       *****/
   /* *************************************************************/





end // end XSIVSIT

// EDIT SALESMAN DATA
Function XSIVSN2()


   /* *************************************************************/
   /* *****  G E T    S A L E S M A N    D A T A             ******/
   /* *************************************************************/


  call "IO0160" ("S3", SQLCA, SM5REC) {isNoRefresh = yes, isExternal = yes}; /* call io mod for sel set*/

  if (SQLCA.VAGen_SQLCODE == 0) /* if return code okay*/

    call "IO0160" ("N3", SQLCA, SM5REC) {isNoRefresh = yes, isExternal = yes}; /* call io mod for info*/

    if (SQLCA.VAGen_SQLCODE == 100) /* if row not found*/
      IVZREC.IVZRTNCD = SQLCA.VAGen_SQLCODE; /* save return code*/
    else
      if (SQLCA.VAGen_SQLCODE == 0) /* if other error*/
        /* NEXT SENTENCE*/
      else
        /* *****************************************************/
        /* *****  THIS IS DBII ERROR PROCESSING CODE      ******/
        /* *****************************************************/
        TA1REC.TA1DBASE = "DSLSMN";
        TA1REC.TA1TBLVU = "VRAGCY01";
        TA1REC.TA1TBLKE = SM5REC.SM1AGYID;
        TA1REC.TA1LOCAT[3] = "XSIVN02";
        TA1REC.TA1LOCAT[4] = "IO0160";
        TA1REC.TA1TYPE = "DB2"; /* abend type*/
        TA1REC.TA1FUNC = "RETN"; /* abend func*/
        set ERRSQLCA empty; /* clear area*/
        move SQLCA to ERRSQLCA withV60Compat; /* save orig sqlca*/
        VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
        VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
        sysLib.rollback();
        VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
         /* synpoint rollback*/
        try
          call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
        end /* abend module*/
        COMMAREA.CAUSERA = " "; /* clear user commarea*/
        XSPF4(); /* master menu*/
        exit program; /* master menu failure*/
        /* *****************************************************/
      end
    end
    call "IO0160" ("C3", SQLCA, SM5REC) {isNoRefresh = yes, isExternal = yes}; /* call for close cursor*/
  else
    /* *****************************************************/
    /* *****  THIS IS DBII ERROR PROCESSING CODE      ******/
    /* *****************************************************/
    TA1REC.TA1DBASE = "DSLSMN";
    TA1REC.TA1TBLVU = "VRAGCY01";
    TA1REC.TA1TBLKE = SM5REC.SM1AGYID;
    TA1REC.TA1LOCAT[3] = "XSIVSN2";
    TA1REC.TA1LOCAT[4] = "IO0160";
    TA1REC.TA1TYPE = "DB2"; /* abend type*/
    TA1REC.TA1FUNC = "RETN"; /* abend func*/
    set ERRSQLCA empty; /* clear area*/
    move SQLCA to ERRSQLCA withV60Compat; /* save orig sqlca*/
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.rollback();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
     /* synpoint rollback*/
    try
      call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
    end /* abend module*/
    COMMAREA.CAUSERA = " "; /* clear user commarea*/
    XSPF4(); /* master menu*/
    exit program; /* master menu failure*/
    /* *****************************************************/
  end





end // end XSIVSN2

// READ SALESMAN ROW
Function XSIVSN4()


   /* *************************************************************/
   /* *****  G E T    S A L E S M A N    D A T A    A N D    ******/
   /* *****          R E F O R M A T     N A M E             ******/
   /* *************************************************************/


  set IVZREC empty;
  IVZREC.IVZFNAME = " "; /* initialize full-name to spaces*/

  XSIVSN2(); /* get salesrep data*/
  SQLCA.VAGen_SQLCODE = IVZREC.IVZRTNCD; /* return return code to sqlca*/

  if (SQLCA.VAGen_SQLCODE == 100) /* if row not found*/
    IVZREC.IVZFNAME = "******* REP/AGENCY NOT FOUND ******";
  else
    if (SQLCA.VAGen_SQLCODE == 0) /* if other error*/
      XSIVSN5();
      XSIVSN6(); /* reformat rep name*/
      if (SM5REC.XXXSTAT == "I")
        /* ***** show rep as inactive **************/
        IVZREC.IVZRED = IVZREC.IVZFNAME;
        IVZREC.IVZLITER = "(INACTIVE)";
        IVZREC.IVZFNAME = IVZREC.IVZRED;
        /* *****************************************/
      else
        /* next sentence*/
      end
    else
      /* next sentence (if not 0 or 100 program will never get here)*/
    end
  end





end // end XSIVSN4

// validate sales rep.
Function XSIVSN5()
   /* this routine will validate the sales rep. by*/
   /* using the data in the sm4rec.*/

  call "IO0020" ("S ", SQLCA, SM4REC) {isNoRefresh = yes};
  if (SQLCA.VAGen_SQLCODE != 0
   && SQLCA.VAGen_SQLCODE != 100)
    TA1REC.TA1TYPE = "DB2 ";
    TA1REC.TA1FUNC = "RETN";
    TA1REC.TA1LOCAT[3] = "XSIVSN5";
    TA1REC.TA1LOCAT[4] = "IO0020";
    TA1REC.TA1DBASE = "DSLSMN";
    TA1REC.TA1TBLVU = "VREPS001";
    IVYREC.IVYNUMB = SM4REC.SM4REPID;
    TA1REC.TA1TBLKE = IVYREC.IVYNUMB;
    set ERRSQLCA empty;
    move SQLCA to ERRSQLCA withV60Compat;
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.rollback();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
    
    try
      call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
    end
    COMMAREA.CAUSERA = " ";
    XSPF4();
    exit program;
  end
end // end XSIVSN5

// REMORMAT SALESMAN NAME
Function XSIVSN6()


   /* *************************************************************/
   /* *****  R E F O R M A T    S A L E S M A N    N A M E   ******/
   /* *************************************************************/


  IVZREC.IVZFNAME = " ";
   /* ********** find last character in last name ***********/
  IVZREC.IVZNAME = " ";
  IVZREC.IVZNAME = SM4REC.XXXLSTNM;
  IVZREC.IVZ3IDX = 25;
  while (IVZREC.IVZ3IDX >= 1
   && IVZREC.IVZCHA[IVZ3IDX] == " ")
    IVZREC.IVZ3IDX = IVZREC.IVZ3IDX - 1;
  end
   /* ********** last character is in position 'iv0sw3dx' *********/

   /* ********** move last name to full name field ***********/
  IVZREC.IVZ2IDX = 1;
  while (IVZREC.IVZ2IDX <= IVZREC.IVZ3IDX)
    IVZREC.IVZFCHA[IVZ2IDX] = IVZREC.IVZCHA[IVZ2IDX];
    IVZREC.IVZ2IDX = IVZREC.IVZ2IDX + 1;
  end
  IVZREC.IVZFCHA[IVZ2IDX] = ",";
  IVZREC.IVZ2IDX = IVZREC.IVZ2IDX + 1;

   /* ********** find last character in first name ***********/
  IVZREC.IVZNAME = " ";
  IVZREC.IVZNAME = SM4REC.XXXFSTNM;
  IVZREC.IVZ3IDX = 25;
  while (IVZREC.IVZ3IDX >= 1
   && IVZREC.IVZCHA[IVZ3IDX] == " ")
    IVZREC.IVZ3IDX = IVZREC.IVZ3IDX - 1;
  end
   /* ********** last character is in position 'iv0sw3dx' *********/

   /* ********** move first name to full name field ***********/
  IVZREC.IVZ4IDX = 1;
  while (IVZREC.IVZ4IDX <= IVZREC.IVZ3IDX
   && IVZREC.IVZ2IDX <= 35)
    IVZREC.IVZFCHA[IVZ2IDX] = IVZREC.IVZCHA[IVZ4IDX];
    IVZREC.IVZ2IDX = IVZREC.IVZ2IDX + 1;
    IVZREC.IVZ4IDX = IVZREC.IVZ4IDX + 1;
  end
  if (IVZREC.IVZ2IDX <= 35)
    IVZREC.IVZFCHA[IVZ2IDX] = " ";
    IVZREC.IVZ2IDX = IVZREC.IVZ2IDX + 1;
  end

   /* ********** move middle initial to full name field ***********/
  if (IVZREC.IVZ2IDX <= 35)
    IVZREC.IVZFCHA[IVZ2IDX] = SM4REC.XXXMDINT;
    IVZREC.IVZ2IDX = IVZREC.IVZ2IDX + 1;
  end





end // end XSIVSN6

// check if xfer outside of 'IV'
Function XSIVXF()
   /* *************************************************************/
   /* *****    validate option/item pair      11-12-87       ******/
   /* *************************************************************/

  if (COMMAREA.CATOAP == " ") /* item requires option  11-12-87*/
    if (COMMAREA.CAITEM != " ")
      converseLib.validationFailed(45); /* item data invalid*/
    end
  end


   /* *************************************************************/
   /* *****    Check if transfer outside of "IV" system.     ******/
   /* *****    If so..... purge ts record if neccessary      ******/
   /* *****               move spaces to causera.            ******/
   /* *****    If not.... must have item field.    11-12-87  ******/
   /* *************************************************************/

  if (COMMAREA.CATOSYS != COMMAREA.CACURSYS)
    if (IVXREC.IVXWGQIX != 0) /* if 'ivg' temp storage record exists*/
      XPIV003(); /* purge temp storage*/
      IVXREC.IVXWGQIX = 0; /* initialize index*/
    end
    if (IVXREC.IVXWFQIX != 0) /* if 'iv0d' temp storage record exists*/
      XPIV005(); /* purge temp storage*/
      IVXREC.IVXWFQIX = 0; /* initialize index*/
    end
    COMMAREA.CAUSERA = " ";
  else
    COMMAREA.CAUSERA = IVXREC.IVXGROUP; /* 11-12-87 pass data*/
    if (COMMAREA.CAITEM == " ") /* 11-12-87 no item entered*/
      if (COMMAREA.CATOAP == "IV0D")
        if (IVXREC.IVXOP1CO != 0) /* use exising order, if any*/
          IVYREC.IVYNUMB = IVXREC.IVXOP1CO;
          COMMAREA.CAITEM = IVYREC.IVYNUMB;
        else
          converseLib.validationFailed(51);
                                   /* ord reqd for xfer in ivc inq 11-12-87*/
        end
      else
        if (COMMAREA.CATOAP == "IV0E") /* 11-12-87 ivc list not allowed*/
          converseLib.validationFailed(52); /* 11-12-87 can't fastpath to iv0e,go to iv0a*/
        else
          if (COMMAREA.CATOAP == "IV0A" /* 11-12-87 menu o.k.*/
           || COMMAREA.CATOAP == "IV0M" /* 11-12-87 system menu o.k.*/
           || COMMAREA.CATOAP == "IV0S") /* 11-12-87 sales rep override o.k.*/
            /* next sentence*/
          else
            if (IVXREC.IV0IVCID != 0) /* use exising ivc, if any*/
              IVYREC.IVYNUMB = IVXREC.IV0IVCID;
              COMMAREA.CAITEM = IVYREC.IVYNUMB;
            else
              converseLib.validationFailed(49);
                                   /* ivc reqd for xfer in ivc inq 11-12-87*/
            end
          end
        end
      end
    end
  end


end // end XSIVXF

// edit option entered by user
Function XSKFS-CHK-SECURITY()


      /* this statement group is the common KF system security check.*/
      /*  */
      /* The security table KFATBL is searched for the user name.*/
      /* If the user is found, the security level is checked and access*/
      /* is either confirmed or denied.*/
      /* If the user is not found, access is denied.*/
      /* A flag is set in the common working storage record to indicate*/
      /* that security has been checked.*/


  sysVar.arrayIndex = 0;

  if (COMMAREA.CAUSERID in KFATBL.XXX-USER-ID) /* user in table*/
    KFWREC.KFW-SCRTY-LVL-CD = KFATBL.KFA-SCRTY-LVL-CD[sysVar.arrayIndex];
    KFWREC.KFW-USER-SM-SAGCY-ID = KFATBL.SM-SAGCY-ID[sysVar.arrayIndex];
    KFWREC.KFW-USER-SM-SREP-ID = KFATBL.SM-SREP-ID[sysVar.arrayIndex];

    if (KFATBL.KFA-SCRTY-LVL-CD[sysVar.arrayIndex] == "0") /* access not allowed*/
      KFWREC.KFW-ACCESS-IND = "N"; /* access denied*/
      converseLib.validationFailed(6);
    end

    if (KFATBL.KFA-SCRTY-LVL-CD[sysVar.arrayIndex] == "1") /* access to all*/
      KFWREC.KFW-ACCESS-IND = "Y"; /* access OK*/
    end

    if (KFATBL.KFA-SCRTY-LVL-CD[sysVar.arrayIndex] == "2") /* access to agcy only*/
      if (KFATBL.SM-SAGCY-ID[sysVar.arrayIndex] == KFWREC.SM-SAGCY-ID)
        KFWREC.KFW-ACCESS-IND = "Y"; /* access OK*/
      else
        KFWREC.KFW-ACCESS-IND = "N"; /* access denied*/
        converseLib.validationFailed(6);
      end
    end

    if (KFATBL.KFA-SCRTY-LVL-CD[sysVar.arrayIndex] == "3") /* access to rep only*/
      if (KFATBL.SM-SREP-ID[sysVar.arrayIndex] == KFWREC.SM-SREP-ID)
        KFWREC.KFW-ACCESS-IND = "Y"; /* access OK*/
      else
        KFWREC.KFW-ACCESS-IND = "N"; /* access denied*/
        converseLib.validationFailed(6);
      end
    end

    if (KFATBL.KFA-SCRTY-LVL-CD[sysVar.arrayIndex] == "4") /* access to agcy/rep*/
      if (KFATBL.SM-SAGCY-ID[sysVar.arrayIndex] == KFWREC.SM-SAGCY-ID)
        if (KFATBL.SM-SREP-ID[sysVar.arrayIndex] == KFWREC.SM-SREP-ID)
          KFWREC.KFW-ACCESS-IND = "Y"; /* access OK*/
        else
          KFWREC.KFW-ACCESS-IND = "N"; /* access denied*/
          converseLib.validationFailed(32);
        end
      else
        KFWREC.KFW-ACCESS-IND = "N"; /* access denied*/
        converseLib.validationFailed(6);
      end
    end

  else /* user not in table*/
    KFWREC.KFW-SCRTY-LVL-CD = 0;
    KFWREC.KFW-USER-SM-SAGCY-ID = " ";
    KFWREC.KFW-USER-SM-SREP-ID = 0;
    KFWREC.KFW-ACCESS-IND = "N"; /* access denied*/
    converseLib.validationFailed(6); /* not authorized*/
  end

  KFWREC.KFW-SCRTY-CHCKD-IND = "Y"; /* security checked*/

end // end XSKFS-CHK-SECURITY

// error abort routine
Function XSKO001()


  TA1REC.TA1TYPE = "DB2";
  TA1REC.TA1FUNC = "RETN";
  move SQLCA to ERRSQLCA withV60Compat;
  call "TA0020" (TA1REC, ERRSQLCA) {isNoRefresh = yes, isExternal = yes};
  VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
  VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
  sysLib.rollback();
  VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
  
  COMMAREA.CATOAP = "KO0A";
  XSEXIT();
  exit program;


end // end XSKO001

// Exit to another application
Function XSKS-S0001()
  /* ------------------------------------------------------------*/
  /* Set the application to be invoked for PF1 or PF4.*/
  /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf1) /* PF1 was pressed*/
    COMMAREA.CATOAP = "GD01"; /* Indicate Goal Documentation*/
  end

  if (converseVar.eventKey is pf4) /* PF4 was pressed*/
    COMMAREA.CATOAP = "MN0M"; /* Indicate Master Menu*/
  end

  /* ------------------------------------------------------------*/
  /* Save the application user area in the COMMAREA.*/
  /* ------------------------------------------------------------*/

  if (COMMAREA.CATOSYS == COMMAREA.CACURSYS) /* Same system*/

    COMMAREA.CAUSERA = KSWREC.CAUSERA; /* Save user area*/
  else
    COMMAREA.CAUSERA = " "; /* Clear user area*/

  end

  /* ------------------------------------------------------------*/
  /* Transfer control to the specified application.*/
  /* ------------------------------------------------------------*/

  XSEXIT(); /* Exit to another application*/

  /* ------------------------------------------------------------*/
  /* Reestablish the COMMAREA application and item fields.*/
  /* ------------------------------------------------------------*/

  COMMAREA.CAEZSG3 = "0"; /* Force zero third character*/
  COMMAREA.CACURRAP = COMMAREA.CAEZSAP; /* CURR application*/

  if (converseVar.eventKey is pfkey) /* PF key was pressed*/

    COMMAREA.CATOAP = " "; /* Clear TO application*/

    if (converseVar.eventKey is pf1) /* PF1 was pressed*/
      COMMAREA.CAITEM = " "; /* Clear map name from item*/
    end

  end

  /* ------------------------------------------------------------*/
  /* Indicate error if transfer failed.*/
  /* ------------------------------------------------------------*/

  if (COMMAREA.CASECRC == 3 /* Application not found*/
   || COMMAREA.CASECRC == 4) /* or transfer not allowed*/

    converseLib.validationFailed(6); /* Indicate not allowed*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/

  end


end // end XSKS-S0001

// Call TA0020-DB2 Return
Function XSKUS-DB2-RETN()
  /* GET XSSM003*/



             /* Call TA0020 for DB2 Fatal Error*/
             /* Return to Main Menu*/



  TA1REC.TA1TYPE = "DB2";
  TA1REC.TA1FUNC = "RETN";
  set ERRSQLCA empty;
  move SQLCA to ERRSQLCA withV60Compat;
  VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
  VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
  sysLib.rollback();
  VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
  
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
  XSPF4();


end // end XSKUS-DB2-RETN

// set level flags to all n's
Function XSMNSXA()




        /* *****************************************************/
        /* *                                                  **/
        /* *    If any of the flags are set to a 'N' then     **/
        /* *    all associated level flags must also be set   **/
        /* *    to 'N'.                                       **/
        /* *                                                  **/
        /* *****************************************************/

  if (MN1REC.MN1ADDFL == "N")
    MN1REC.MN1ADDTB = "NNNNNNNNNN";
  end


  if (MN1REC.MN1CHGFL == "N")
    MN1REC.MN1CHGTB = "NNNNNNNNNN";
  end


  if (MN1REC.MN1DELFL == "N")
    MN1REC.MN1DELTB = "NNNNNNNNNN";
  end


  if (MN1REC.MN1INQFL == "N")
    MN1REC.MN1INQTB = "NNNNNNNNNN";
  end




end // end XSMNSXA

// Determine map mode for claim
Function XSNKS-MAP-MODE()
   /* -----------------------------------------------------------*/
     /* Set map mode for claim*/

     /* note - this statement group assumes a valid claim id in*/
     /* NKWREC.  Zero will indicate a new claim an will*/
     /* set the map to a maintenance mode.*/

   /* -----------------------------------------------------------*/

  NLXREC.NLXCPROC = "XSNKS-MAP-MODE";

  if (NKWREC.NL-CLM-ID == 0)
    NKWREC.NKW-MAP-MODE = "M";
    return;
  end

  if (NKWREC.ZCS-CLM-STAT-CD == "VD")
    NKWREC.NKW-MAP-MODE = "I";
    return;
  end

  if (NKWREC.ZCS-CLM-STAT-CD in NK1TBL.ZCS-CLM-STAT-CD)
    NKWREC.NKW-MAP-MODE-ROW = NK1TBL.NK1-GROUP[sysVar.arrayIndex];
  end
  if (COMMAREA.CACLVL[4] == "Y")
    NKWREC.NKW-MAP-MODE = NKW-MAP-MODE-FL[4];
  else
    if (COMMAREA.CACLVL[3] == "Y")
      NKWREC.NKW-MAP-MODE = NKW-MAP-MODE-FL[3];
    else
      if (COMMAREA.CACLVL[2] == "Y")
        NKWREC.NKW-MAP-MODE = NKW-MAP-MODE-FL[2];
      else
        if (COMMAREA.CACLVL[1] == "Y")
          NKWREC.NKW-MAP-MODE = NKW-MAP-MODE-FL[1];
        else
          NKWREC.NKW-MAP-MODE = "I";
        end
      end
    end
  end

end // end XSNKS-MAP-MODE

// Determine map mode for claim
Function XSNKS-SEL-VSUMCD01()
   /* -----------------------------------------------------------*/
     /* Select first claim type from Dcorp.Vsumcd01*/
   /* -----------------------------------------------------------*/

  NLXREC.NLXCPROC = "XSNKS-SEL-VSUMCD01";

  YSMREC.YSMTBLPF = "ZCR";
  YSMREC.YSMSYSPF = "NL";
  YSMREC.YSMSUMID = 1;
  YSMREC.YSMSUMCD = NKWREC.XXX-SUM-ZCR-CD;
  if (NKWREC.ZCR-CLM-RSN-CD > " ")
    YSMREC.YSMSRCVL = NKWREC.ZCR-CLM-RSN-CD;
  else
    YSMREC.YSMSRCVL = "****";
  end

  call "IO2640" ("S1", SQLCA, YSMREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE != 0)
    TA1REC.TA1DBASE = "DCORP";
    TA1REC.TA1TBLVU = "VSUMCD01";
    TA1REC.TA1TBLKE = YSMREC.YSMGRP;
    XPNL005();
  end

  call "IO2640" ("N1", SQLCA, YSMREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0
   || SQLCA.VAGen_SQLCODE == 100)
    NKWREC.XXX-SUM-ZCR-DESC = YSMREC.YSMSMDSC;
  else
    TA1REC.TA1DBASE = "DCORP";
    TA1REC.TA1TBLVU = "VSUMCD01";
    TA1REC.TA1TBLKE = YSMREC.YSMGRP;
    XPNL005();
  end

  call "IO2640" ("C1", SQLCA, YSMREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE != 0)
    TA1REC.TA1DBASE = "DCORP";
    TA1REC.TA1TBLVU = "VSUMCD01";
    TA1REC.TA1TBLKE = YSMREC.YSMGRP;
    XPNL005();
  end
end // end XSNKS-SEL-VSUMCD01

// Update claims header
Function XSNKS-SET-VNCHDR01()
   /* -----------------------------------------------------------*/
     /* Update the claim header.*/
   /* -----------------------------------------------------------*/

  NLXREC.NLXCPROC = "XSNKS-SET-VNCHDR01";

  call "IO6460" ("U ", SQLCA, VNCHDR01) {isNoRefresh = yes, isExternal = yes}; /* Select unique*/

  if (SQLCA.VAGen_SQLCODE == 0)
    converseLib.validationFailed(294); /* claim was restatused*/
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      converseLib.validationFailed(155); /* database has changed*/
    else
      XPNL005(); /* common abend routine*/
    end
  end

end // end XSNKS-SET-VNCHDR01

// Determine map mode for claim
Function XSNKS-SET-XGPCD()
  /* ************************************************************************/
  /* This will get the GPC code associated to a product related claim*/
  /* ************************************************************************/

  NLXREC.NLXCPROC = "XSNKS-SET-XGPCD";

  if (NKWREC.NL-CLM-ID == 0) /* if no claim id, return*/
    return;
  end

  set VNCIVX01 empty;
  VNCIVX01.NL-CLM-ID = NKWREC.NL-CLM-ID;

  /* ************************************************************************/
  /* Get first invoice id from the cross reference*/
  /* ************************************************************************/

  call "IO6510" ("S2", SQLCA, VNCIVX01) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE != 0)
    TA1REC.TA1DBASE = "DNILO";
    TA1REC.TA1TBLVU = "VNCIVX01";
    XPNL005();
  end

  /* ************************************************************************/
  /* fetch the invoice id from the cross reference*/
  /* ************************************************************************/

  call "IO6510" ("N2", SQLCA, VNCIVX01) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0
   || SQLCA.VAGen_SQLCODE == 100)
  /* next senetence*/
  else
    TA1REC.TA1DBASE = "DNILO";
    TA1REC.TA1TBLVU = "VNCIVX01";
    XPNL005();
  end

  /* ************************************************************************/
  /* close cursor for cross reference*/
  /* ************************************************************************/

  call "IO6510" ("C2", SQLCA, VNCIVX01) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE != 0)
    TA1REC.TA1DBASE = "DNILO";
    TA1REC.TA1TBLVU = "VNCIVX01";
    XPNL005();
  end

  if (VNCIVX01.ZDTCD != "PI")
    return;
  end

  /* ************************************************************************/
  /* Select first invoice item for gpc code*/
  /* ************************************************************************/

  VPIITM01.NIDIVCID = VNCIVX01.NIDIVCID;
  VPIITM01.SY1STNBR = "******";
  VPIITM01.SY2CLRID = "***";
  VPIITM01.XDMCD = "**";
  VPIITM01.XGPCD = "**";
  VPIITM01.XQACD = "**";

   /* open cursor on - VNCSTY01*/

  call "IO4480" ("S1", SQLCA, VPIITM01) {isNoRefresh = yes, isExternal = yes}; /* read long address*/

  if (SQLCA.VAGen_SQLCODE == 0) /* if a good return,*/
    /* next sentence*/
  else
    TA1REC.TA1DBASE = "DNILO";
    TA1REC.TA1TBLVU = "VPIITM01";
    XPNL005(); /* abort routine*/
  end

  call "IO4480" ("N1", SQLCA, VPIITM01) {isNoRefresh = yes, isExternal = yes}; /* read long address*/
  if (SQLCA.VAGen_SQLCODE == 0) /* if a good return,*/
    NKWREC.XGPCD = VPIITM01.XGPCD;
  else
    if (SQLCA.VAGen_SQLCODE == 100) /* if a good return,*/
        /* next sentence*/
    else
      TA1REC.TA1DBASE = "DNILO";
      TA1REC.TA1TBLVU = "VPIITM01";
      XPNL005(); /* abort routine*/
    end
  end

  call "IO4480" ("C1", SQLCA, VPIITM01) {isNoRefresh = yes, isExternal = yes}; /* read long address*/

  if (SQLCA.VAGen_SQLCODE == 0) /* if a good return,*/
    /* next sentence*/
  else
    TA1REC.TA1DBASE = "DNILO";
    TA1REC.TA1TBLVU = "VPIITM01";
    XPNL005(); /* abort routine*/
  end
end // end XSNKS-SET-XGPCD

// Select Unique DCORP.VZCF0001
Function XSNLS-S-VZFC0001()
   /* *****************************************************/
   /* Select Unique DCORP.VZFC0001*/
   /* *****************************************************/

  NLXREC.NLXCPROC = "XSNLS-S-VZFC0001";

  VZFC0001.ZFC-CRCY-CD = VPIHDR01.ZFCCD;

  call "DC0060" ("S ", SQLCA, VZFC0001) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    NIWREC.ZFCDESC = VZFC0001.ZFC-CRCY-DESC;
  else
    if (SQLCA.VAGen_SQLCODE == 100) /* Row Not Found*/
      TA1REC.TA1TYPE = "DB2";
      TA1REC.TA1PGMNM = COMMAREA.CACURRAP;
      TA1REC.TA1LOC = NLXREC.NLXCPROC;
      TA1REC.TA1FUNC = "POST";
      call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
      converseLib.validationFailed(344); /* Currency Code Not Found*/
    else
      if (SQLCA.VAGen_SQLCODE == -911) /* Data Base Busy*/
        TA1REC.TA1FUNC = "POST";
        call "TA0020" (TA1REC, SQLCA) {isExternal = yes};
        converseLib.validationFailed(4);
      else
        TA1REC.TA1LOCAT[2] = "S  ";
        TA1REC.TA1LOCAT[3] = "DC0060 ";
        TA1REC.TA1DBASE = "DCORP ";
        TA1REC.TA1TBLVU = "VZFC0001";
        XPNL005();
      end
    end
  end

end // end XSNLS-S-VZFC0001

// transfer to the help system
Function XSNLS01()

   /* ************************************************************/
                  /* NIL HELP ROUTINE*/
      /* this statement group is to call the online documenta-*/
      /* tion system, 'gd01'.  (the 'help' system)*/
   /* ************************************************************/

  COMMAREA.CATOAP = "GD01";
  COMMAREA.CAITEM = NLXREC.NLXCSCRN;

  XSEXIT();

end // end XSNLS01

// fast Path OPTION not available
Function XSNOWAY()

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* This subroutine is intended for use by applications that*/
   /* may only be transferred to from specific applications.*/

   /* The application must check COMMAREA.CAFROMAP to determine*/
   /* whether control was received from an allowable application.*/
   /* If not from an allowable application, the transferred to*/
   /* application should invoke this subroutine.*/

   /* A message will be displayed to the user indicating that the*/
   /* transfer is not allowed.  Control will be returned to the*/
   /* application that initiated the transfer.*/

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* ------------------------------------------------------------*/
   /* Write the error to the Error Diagnosis Reporting Facility.*/
   /* ------------------------------------------------------------*/

  TAEREC.TAEDESC1 = "YOU CANNOT TRANSFER TO THIS APPLICATION FROM";
  TAEREC.TAEDESC2 = COMMAREA.CAFROMAP; /* FROM application*/

  TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  TA1REC.TA1TYPE = "APPL"; /* Type of error*/
  TA1REC.TA1LOC = "FAST PATH OPTION NOT AVAILABLE";
  TA1REC.TA1PGMNM = COMMAREA.CACURRAP; /* Application name*/
  TA1REC.TA1MAP = "XSNOWAY"; /* Subroutine name*/
  TA1REC.TA1FYICD = "FYI"; /* Indicate FYI*/

  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis*/

   /* ------------------------------------------------------------*/
   /* Exit to the application that transferred control.*/
   /* ------------------------------------------------------------*/

  COMMAREA.CACURRAP = "MN0M"; /* Current application*/
  COMMAREA.CATOAP = COMMAREA.CAFROMAP; /* From application*/

  XSEXIT(); /* Exit to another application*/

   /* ------------------------------------------------------------*/
   /* Abnormally terminate the transaction if the exit failed.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1FUNC = "ABND"; /* Termination function*/
  TA1REC.TA1LOC = "RETURN TO FROM APPLICATION FAILED";
  TA1REC.TA1FYICD = "   "; /* Clear FYI indicator*/

  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis*/


end // end XSNOWAY

// OB SYSTEM - CALL TO SY2000
Function XSOB-CALL-SY2000()

     /* Get the Product/Region record*/

  set SQLCA empty;
  set WSY2000 empty;

  WSY2000.XGP-GPC-CD = SYCREC.XGPCD;
  WSY2000.SY-STY-NBR = SYCREC.SY1STNBR;
  WSY2000.SY-COLR-CD-ID = SYCREC.SY2CLRID;
  WSY2000.XDM-DIM-CD = SYCREC.XDMCD;

   /* Added if statement below to allow call to SY2000 for*/
   /* domestic orders product - kramse - 3/22/99*/

  if (OB1REC.XDZ-DATA-DIST-CD == "CA")
    WSY2000.XDR-PROD-REG-CD = "05";
  else
    WSY2000.XDR-PROD-REG-CD = "01";
  end

  WSY2000.WSY2000-OPTION-CODE = "S ";
  WSY2000.WSY2000-SUB-OPTION-CODE = "O";
  WSY2000.WSY2000-RETURN-CODE = 90;

  call "SY2000" (WSY2000) {isNoRefresh = yes, isExternal = yes};

   /* Product/Region record is found*/
   /* Overlay those fields common to both records*/

  if (WSY2000.WSY2000-RETURN-CODE == 0)
    SYCREC.XGPCD = WSY2000.XGP-GPC-CD;
    SYCREC.SY1STNBR = WSY2000.SY-STY-NBR;
    SYCREC.SY2CLRID = WSY2000.SY-COLR-CD-ID;
    SYCREC.XDMCD = WSY2000.XDM-DIM-CD;
    SYCREC.PG1SC4CD = WSY2000.PG-SCHED-SPCLT-CD;
    SYCREC.PG1FCTCD = WSY2000.PG-FCST-CD;
    SYCREC.XSECD = WSY2000.XSE-SESN-CD;
    SYCREC.XSNYR = WSY2000.XSN-SESN-YR-RNG;
    SYCREC.SY2POFBD = WSY2000.SY-PROP-OFFER-BDT;
    SYCREC.SY2POFXD = WSY2000.SY-PROP-OFFER-XDT;
    SYCREC.SY2FOFBD = WSY2000.SY-FUTR-OFFER-BDT;
    SYCREC.SY2FOFXD = WSY2000.SY-FUTR-OFFER-XDT;
    SYCREC.XLCCD1 = WSY2000.XLC-LIFE-CYC-CD[1];
    SYCREC.XLCCD2 = WSY2000.XLC-LIFE-CYC-CD[2];
    SYCREC.XLCCD3 = WSY2000.XLC-LIFE-CYC-CD[3];
    SYCREC.XLCCD4 = WSY2000.XLC-LIFE-CYC-CD[4];
    SYCREC.SY2CEDT1 = WSY2000.SY-LIFE-CYC-EDT[1];
    SYCREC.SY2CEDT2 = WSY2000.SY-LIFE-CYC-EDT[2];
    SYCREC.SY2CEDT3 = WSY2000.SY-LIFE-CYC-EDT[3];
    SYCREC.SY2CEDT4 = WSY2000.SY-LIFE-CYC-EDT[4];
    SYCREC.XPRCD = WSY2000.XPR-PROD-TYP-CD;
    SYCREC.XPLCD = WSY2000.XPL-PROD-LN-CD;
    SYCREC.XPCCD = WSY2000.XPC-PROD-CAT-CD;
    SYCREC.SY2FDSMO = WSY2000.SY-FRST-DOM-SLS-MO;
    SYCREC.SY2PDCMO = WSY2000.SY-PROJ-DOM-CLS-MO;
    SYCREC.SY2SSCIN = WSY2000.SY-SFTY-STKCLS-IND;
    SYCREC.OPZHMIND = WSY2000.OP-HMDL-HOT-FL;
    SYCREC.SY2ALNOR = WSY2000.SY-ALW-NEW-ORD-FL;
    SYCREC.XWHCD[1] = WSY2000.XWH-WHSE-CD[1];
    SYCREC.XWHCD[2] = WSY2000.XWH-WHSE-CD[2];
    SYCREC.XWHCD[3] = WSY2000.XWH-WHSE-CD[3];
    SYCREC.XWHCD[4] = WSY2000.XWH-WHSE-CD[4];
    SYCREC.XWHCD[5] = WSY2000.XWH-WHSE-CD[5];
    SYCREC.XWHCD[6] = WSY2000.XWH-WHSE-CD[6];
    SYCREC.SY2RPRDI = WSY2000.SY-RSTR-XSO-IND;
    SYCREC.SY2BOSWI = WSY2000.SY-BO-SW;
    SYCREC.SY2BOEDT = WSY2000.SY-BO-SW-EDT;
  else

    /* Database DPROD.VSYREG02 is busy*/

    if (WSY2000.WSY2000-RETURN-CODE == 98)
      /* next sentence*/
    else

      /* Record is not found*/

      if (WSY2000.WSY2000-RETURN-CODE == 02)
        /* next sentence*/
      else

        /* Bad return code*/

        TA1REC.TA1TYPE = "APPL";
        TA1REC.TA1FUNC = "POST";
        XSOBW01.XSOBW-WSY2000-GPC-CD = SYCREC.XGPCD;
        XSOBW01.XSOBW-WSY2000-STY-NBR = SYCREC.SY1STNBR;
        XSOBW01.XSOBW-WSY2000-COLR-CD = SYCREC.SY2CLRID;
        XSOBW01.XSOBW-WSY2000-DIM-CD = SYCREC.XDMCD;
        XSOBW01.XSOBW-WSY2000-PROD-REG-CD = WSY2000.XDR-PROD-REG-CD;
        XSOBW01.XSOBW-WSY2000-RETURN-CD = WSY2000.WSY2000-RETURN-CODE;
        TAEREC.TAEDESC1 = XSOBW-WSY2000-POST-1;
        TAEREC.TAEDESC2 = "CALL TO SY2000 - BAD RETURN CODE";
        TA1REC.TA1DBASE = "DPROD";
        TA1REC.TA1TBLVU = "SYREG02";
        try
          call "TA0020" (TA1REC, TAEREC) {isExternal = yes};
        end
      end
    end
  end
end // end XSOB-CALL-SY2000

// DELETE/INSERT OB1REC
Function XSOB-UPD-VOCHDR01()

   /* BUILD OCD ORDER CHANGE REASON FROM DORDER ORDER HEADER*/


  set VOCHDR01 empty;

  VOCHDR01.OP1PARTN = OB1REC.OP1PARTN;
  VOCHDR01.OP1CUOID = OB1REC.OP1CUOID;
  VOCHDR01.OP1NORID = OB1REC.OP1NORID;
  VOCHDR01.SOCD-APPL-SRC-CD = "OB";

   /* DO A SELECT TO SEE IF ROW EXISTS*/

  call "VOCHDR01" ("S ", SQLCA, VOCHDR01) {isNoRefresh = yes, isExternal = yes};
  if (SQLCA.VAGen_SQLCODE == 0)

   /* IF THE ORDER IS BEING CANCELLED CHANGE THE DELT-FL TO 'Y'*/
   /* OTHERWISE, CHANGE IT TO SPACE.*/

    if (OB1REC.YOBCD == "XL")
      VOCHDR01.SOCD-ORD-DELT-FL = "Y";
    else
      VOCHDR01.SOCD-ORD-DELT-FL = " ";
    end

   /* UPDATE VOCHDR01*/

    VOCHDR01.ZZZCHGDT = XX0XW01.XX0XWDAT;
    VOCHDR01.ZZZCHGTM = XX0XW01.XX0XWTIM;
    call "VOCHDR01" ("U ", SQLCA, VOCHDR01) {isNoRefresh = yes, isExternal = yes};
  end

end // end XSOB-UPD-VOCHDR01

// DELETE/INSERT OB1REC
Function XSOB-UPD-VOCITM01()

   /* BUILD OCD ORDER CHANGE REASON FROM DORDER ORDER HEADER*/


  set VOCITM01 empty;

  VOCITM01.OP1PARTN = OB1REC.OP1PARTN;
  VOCITM01.OP1CUOID = OB1REC.OP1CUOID;
  VOCITM01.OP1NORID = OB1REC.OP1NORID;
  VOCITM01.SOCD-APPL-SRC-CD = "OB";
  VOCITM01.OP2LNINB = OBWREC.OBWLNINB;

   /* DO A SELECT TO SEE IF ROW EXISTS*/

  call "VOCITM01" ("S ", SQLCA, VOCITM01) {isNoRefresh = yes, isExternal = yes};
  if (SQLCA.VAGen_SQLCODE == 100)
        /* NEXT SENTENCE*/
  else
    if (SQLCA.VAGen_SQLCODE == 0)
      VOCITM01.SOCD-ITM-DELT-FL = "Y";
      VOCITM01.ZZZCHGDT = XX0XW01.XX0XWDAT;
      VOCITM01.ZZZCHGTM = XX0XW01.XX0XWTIM;
      call "VOCITM01" ("U ", SQLCA, VOCITM01) {isNoRefresh = yes, isExternal = yes};
    end
  end

end // end XSOB-UPD-VOCITM01

// APPLY CUST DEFAULTS
Function XSOB001()
   /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * **/
   /* / BUILD PASSING RECORD FOR OB1650 FROM OBAREC (TEMP STORAGE)*/
   /* / CALL OB1650*/
   /* / PROCESS RETURN CODES*/
   /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * **/

  set OBCDREC empty;

  OBCDREC.OP1PARTN = OBAREC.OP1PARTN[OBWTSF1S];
  OBCDREC.OP1CUOID = OBAREC.OBACUOID[OBWTSF1S];
  OBCDREC.OP1NORID = OBAREC.OBANORID[OBWTSF1S];
  OBCDREC.OBCD-CALLING-PGM = "OB0A";
  OBCDREC.ZZZCHGDT = OBWREC.ZZZCHGDT;
  OBCDREC.ZZZCHGTM = OBWREC.ZZZCHGTM;

  OBCDREC.OBCD-RETURN-CD = 99;

  call "OB1650" (OBCDREC) {isNoRefresh = yes, isExternal = yes};

  TA1REC.TA1LOCAT[2] = "OB1650";
  TA1REC.TA1LOCAT[3] = "XSOB001 ";
  TAEREC.TAEDESC1 = "OB1650 RETURN CODE IS ";
  TAEREC.TAEDESC2 = OBCDREC.OBCD-RETURN-CD;

  if (OBCDREC.OBCD-RETURN-CD == 0)
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.commit();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
    
  else
    if (OBCDREC.OBCD-RETURN-CD == 1)
  /* HEADER NOT FOUND - when it should have been*/
      OBWREC.CAMSG = OBCDREC.OBCD-RETURN-MSG;
      VGVar.handleSysLibraryErrors = 0;
      sysLib.rollback(); /* rollback updates since last commit*/
      XSOBENR(); /* appl retn - go to main menu*/
    else
      if (OBCDREC.OBCD-RETURN-CD == 2)
  /* DEADLOCK OR TIMEOUT ON DORDER.VNXTIO01*/
        OBWREC.CAMSG = "ORDERS DATABASE BUSY - PLEASE TRY AGAIN ";
        XSOBAPR(); /* post, rollback, restart appl*/
      else
        if (OBCDREC.OBCD-RETURN-CD == 3)
   /* DATABASE DEADLOCK - DATABASE BUSY TRY AGAIN*/
          OBWREC.CAMSG = "DATABASE BUSY - PLEASE TRY AGAIN ";
          XSOBAPR(); /* post, rollback, restart appl*/
        else
          if (OBCDREC.OBCD-RETURN-CD == 4)
  /* OTHER DATABASE PROBLEM - ABEND W/ROLLBACK*/
            VGVar.handleSysLibraryErrors = 0;
            sysLib.rollback(); /* rollback updates to last commit*/
            XSOBENR(); /* appl retn - go to main menu*/
          else
            if (OBCDREC.OBCD-RETURN-CD == 5)
  /* application error      - ABEND W/ROLLBACK*/
              VGVar.handleSysLibraryErrors = 0;
              sysLib.rollback(); /* rollback updates to last commit*/
              XSOBENR(); /* appl retn - go to main menu*/
            else
              if (OBCDREC.OBCD-RETURN-CD == 99)
  /* CALL TO OB1650 DIDN'T WORK*/
                VGVar.handleSysLibraryErrors = 0;
                sysLib.rollback(); /* rollback updates to last commit*/
                XSOBENR(); /* appl retn - go to main menu*/
              else
  /* MAJOR PROBLEM WITH OB1650*/
                VGVar.handleSysLibraryErrors = 0;
                sysLib.rollback(); /* rollback updates to last commit*/
                XSOBENR(); /* appl retn - go to main menu*/
              end
            end
          end
        end
      end
    end
  end




end // end XSOB001

// EDIT AN ORDER
Function XSOB002()
  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **/
  /* BUILD PASSING RECORD FOR OB1680 FROM OBAREC (temp storage)*/
  /* CALL OB1680*/
  /* PROCESS RETURN CODES*/
  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **/

  set OBLEREC empty;
  OBLEREC.OBLE-EDIT-OPTION = "2";
  OBLEREC.OP1PARTN = OBAREC.OP1PARTN[OBWTSF1S];
  OBLEREC.OP1CUOID = OBAREC.OBACUOID[OBWTSF1S];
  OBLEREC.OP1NORID = OBAREC.OBANORID[OBWTSF1S];

  OBLEREC.OP2LNINB = 0;

  OBLEREC.ZZZCHGDT = OBWREC.ZZZCHGDT;
  OBLEREC.ZZZCHGTM = OBWREC.ZZZCHGTM;
  OBLEREC.OBLE-RETURN-CD = 99;

  call "OB1680" (OBLEREC) {isNoRefresh = yes, isExternal = yes};

  TA1REC.TA1LOCAT[2] = "OB1680";
  TA1REC.TA1LOCAT[3] = "XSOB002 ";
  TA1REC.TA1LOCAT[4] = "        ";
  TAEREC.TAEDESC1 = "OB1680 RETURN CODE IS ";
  TAEREC.TAEDESC2 = OBLEREC.OBLE-RETURN-CD;

  if (OBLEREC.OBLE-RETURN-CD == 0)
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.commit();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
    
  else
    if (OBLEREC.OBLE-RETURN-CD == 1)
  /* HEADER NOT FOUND - when it should have been*/
      OBWREC.CAMSG = OBLEREC.OBLE-RETURN-MSG;
      VGVar.handleSysLibraryErrors = 0;
      sysLib.rollback(); /* rollback updates since last commit*/
      XSOBENR(); /* appl retn - go to main menu*/
    else
      if (OBLEREC.OBLE-RETURN-CD == 2)
   /* NOT FOUND ON UPDATE - ORDER UPDATED BY BATCH OR ANOTHER CSR*/
        OBWREC.CAMSG = "ORDER UPDATED BY BATCH SYSTEM OR ANOTHER CSR - PLEASE REVIEW";
        XSOBAPR(); /* post, rollback, restart appl*/
      else
        if (OBLEREC.OBLE-RETURN-CD == 3)
  /* DATABASE DEADLOCK - DATABASE BUSY TRY AGAIN*/
          OBWREC.CAMSG = "DATABASE BUSY - PLEASE TRY AGAIN ";
          XSOBAPR(); /* post, rollback, restart appl*/
        else
          if (OBLEREC.OBLE-RETURN-CD == 4)
  /* OTHER DATABASE PROBLEM - ABEND W/ROLLBACK*/
            VGVar.handleSysLibraryErrors = 0;
            sysLib.rollback(); /* rollback updates to last commit*/
            XSOBENR(); /* appl retn - go to main menu*/
          else
            if (OBLEREC.OBLE-RETURN-CD == 5)
  /* DEADLOCK IN SUBPROGRAM CALLED FROM OB1680- BUSY TRY AGAIN*/
              OBWREC.CAMSG = "DATABASE BUSY - PLEASE TRY AGAIN ";
              XSOBAPR(); /* post, rollback, restart appl*/
            else
              if (OBLEREC.OBLE-RETURN-CD == 6)
  /* SUBPROGRAM CALLED FROM OB1680 FAILED*/
                VGVar.handleSysLibraryErrors = 0;
                sysLib.rollback(); /* rollback updates to last commit*/
                XSOBENR(); /* appl retn - go to main menu*/
              else
                if (OBLEREC.OBLE-RETURN-CD == 99)
  /* CALL TO OB1680 DIDN'T WORK*/
                  VGVar.handleSysLibraryErrors = 0;
                  sysLib.rollback(); /* rollback updates to last commit*/
                  XSOBENR(); /* appl retn - go to main menu*/
                else
  /* MAJOR PROBLEM WITH OB1680*/
                  VGVar.handleSysLibraryErrors = 0;
                  sysLib.rollback(); /* rollback updates to last commit*/
                  XSOBENR(); /* appl retn - go to main menu*/
                end
              end
            end
          end
        end
      end
    end
  end





end // end XSOB002

// INSERT CSR HOLD MSG
Function XSOB003()

   /* insert the hold message*/


  set OBKREC empty;
  set OB7REC empty;
  set SQLCA empty;

  OB7REC.OP1PARTN = OBAREC.OP1PARTN[OBWTSF1S]; /* format part char*/
  OB7REC.OP1CUOID = OBAREC.OBACUOID[OBWTSF1S]; /* format cust ord id*/
  OB7REC.OP1NORID = OBAREC.OBANORID[OBWTSF1S]; /* format nike ord id*/

  OB7REC.OP2LNINB = 0; /* format line item nbr*/
  OB7REC.OB6MSGNB = "281"; /* format message number*/
  OB7REC.OB7MSGTP = "H"; /* format message type*/
  OB7REC.OB7MSGRF = " "; /* format message released flag*/

  OB7REC.ZZZSDT = OBWREC.ZZZCHGDT; /* setup date*/
  OB7REC.ZZZSTM = OBWREC.ZZZCHGTM; /* setup time*/

  OB7REC.ZZZCHGDT = 0; /* init change date*/
  OB7REC.ZZZCHGTM = 0; /* init change time*/
  OB7REC.ZZZCHGCT = 0; /* init change count*/


  OBKREC.OBKTASK = "A";

  call "IO5210" (OBKREC, SQLCA, OB7REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0 /* good return*/
   || SQLCA.VAGen_SQLCODE == 100) /* or not found*/
     /* next sentence*/
  else
    if (SQLCA.VAGen_SQLCODE == -803) /* already exists*/
      OBKREC.OBKTASK = "S";
      call "IO5210" (OBKREC, SQLCA, OB7REC) {isNoRefresh = yes, isExternal = yes};
      OB7REC.OB7MSGRF = " "; /* unrelease the hold*/
      OBKREC.OBKTASK = "U";
      call "IO5210" (OBKREC, SQLCA, OB7REC) {isNoRefresh = yes, isExternal = yes};
      if (SQLCA.VAGen_SQLCODE == 0 /* good return*/
       || SQLCA.VAGen_SQLCODE == 100) /* or not found*/
        /* next sentence*/
      else
        TA1REC.TA1DBASE = "DORDB"; /* database name*/
        TA1REC.TA1TBLVU = "VOBMSG01"; /* table view*/
        TA1REC.TA1LOCAT[1] = "U"; /* calling option*/
        TA1REC.TA1LOCAT[2] = "IO5210"; /* i/o mod name*/
        TA1REC.TA1LOCAT[3] = "XSOB003"; /* statement group*/
        if (SQLCA.VAGen_SQLCODE == -911)
          XSOBS04(); /* post and restart*/
        else
          XSOBEDC(); /* abort routine - no reset done*/
        end
      end
    else
      TA1REC.TA1DBASE = "DORDB"; /* database name*/
      TA1REC.TA1TBLVU = "VOBMSG01"; /* table view*/
      TA1REC.TA1LOCAT[1] = "A"; /* calling option*/
      TA1REC.TA1LOCAT[2] = "IO5210"; /* i/o mod name*/
      TA1REC.TA1LOCAT[3] = "XSOB003"; /* statement group*/
      if (SQLCA.VAGen_SQLCODE == -911)
        XSOBS04(); /* post and restart*/
      else
        XSOBEDC(); /* abort routine - no reset done*/
      end
    end
  end


   /* Read the current order header.*/

  set OB1REC empty;
  set OBFREC empty;
  set SQLCA empty;


  OB1REC.OP1CUOID = OBAREC.OBACUOID[OBWTSF1S];
  OB1REC.OP1NORID = OBAREC.OBANORID[OBWTSF1S];
  OB1REC.OP1PARTN = OBAREC.OP1PARTN[OBWTSF1S];

  OBFREC.OBFTASK = "S ";

  call "IO5160" (OBFREC, SQLCA, OB1REC) {isNoRefresh = yes, isExternal = yes}; /* i/o mod-select scan*/

   /* check db2 return code*/

  if (SQLCA.VAGen_SQLCODE == 0) /* check for good rc*/
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DORDB   "; /* data base name*/
    TA1REC.TA1TBLVU = "VOBHDR01"; /* table view*/
    TA1REC.TA1LOCAT[1] = "S       "; /* calling option*/
    TA1REC.TA1LOCAT[2] = "IO5160  "; /* i/o mod name*/
    TA1REC.TA1LOCAT[3] = "XSOB003 "; /* statement group*/
    if (SQLCA.VAGen_SQLCODE == -911)
      XSOBS04();
    else
      XSOBEDC(); /* abort routine - no reset done*/
    end
  end



   /* update order header*/

  OB1REC.YOBCD = "CK";
  OB1REC.OB1HLDFL = "Y"; /* set hold flag*/

  OB1REC.ZZZCHGDT = OBWREC.ZZZCHGDT;
  OB1REC.ZZZCHGTM = OBWREC.ZZZCHGTM;

  set OBFREC empty;
  set SQLCA empty;

  OBFREC.OBFTASK = "U ";

  call "IO5160" (OBFREC, SQLCA, OB1REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.commit();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
    
  else
    if (SQLCA.VAGen_SQLCODE == 100)
      VGVar.handleSysLibraryErrors = 0;
      sysLib.rollback();
      OBWREC.CAMSG = "THE ORDER HAS BEEN MODIFIED BY ANOTHER SERVICE REP";
      XSOBP00();
    else
      TA1REC.TA1DBASE = "DORDB   "; /* data base name*/
      TA1REC.TA1TBLVU = "VOBHDR01"; /* table view*/
      TA1REC.TA1LOCAT[1] = "U       "; /* calling option*/
      TA1REC.TA1LOCAT[2] = "IO5160  "; /* i/omod*/
      TA1REC.TA1LOCAT[3] = "OB0MS63 "; /* statement group*/
      TA1REC.TA1LOCAT[4] = "        "; /* statement group*/
      if (SQLCA.VAGen_SQLCODE == -911)
        XSOBS04();
      else
        XSOBEDC();
      end
    end
  end




end // end XSOB003

// non-db2 post with rollback
Function XSOBAPR()
   /* Non-DB2*/
   /* Post, rollback, and xfr to appl beginning*/

   /* The following fields will be filled in by the calling*/
   /* statement group before entering this routine.*/

   /* ta1locat(1)     = transaction type  ie: 'ss' 'sn'*/
   /* ta1locat(2)     = i/o mod name*/
   /* ta1locat(3)     = calling statement group name*/
   /* ta1locat(4)     = programmers option (extra key data)*/
   /* taerec.taedesc1 = programmers option (additional key data)*/
   /* taerec.taedesc2 = messages*/
   /* ta1map          = appl's mapname*/

   /* Return code processing will also be handled by the*/
   /* calling statement group.*/

  TA1REC.TA1TYPE = "APPL";
  TA1REC.TA1FUNC = "POST";
  TA1PGMNM = COMMAREA.CACURRAP; /* current application*/
  TA1REC.TA1TBLKE = OBWREC.OBWSYSKE; /* move system key*/
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback(); /* rollback updates*/
  try
    call "TA0020" (TA1REC, TAEREC) {isExternal = yes};
  end
  XSOBP00(); /* xfr to appl beginning*/

end // end XSOBAPR

// db2 to map date conversion
Function XSOBDCM()
   /* Convert db2 date to mmddyy*/

   /* the calling stmt group must move the database date*/
   /* to OBWREC.OBWDT8 before enterning this routine*/

  OBWREC.OBWDT6Y = OBWREC.OBWDT8Y;
  OBWREC.OBWDT6M = OBWREC.OBWDT8M;
  OBWREC.OBWDT6D = OBWREC.OBWDT8D;

   /* the calling stmt group needs to move*/
   /* OBWREC.OBWDT6 to the requested map field.*/

end // end XSOBDCM

// map to db date convert
Function XSOBDED()
   /* Edit MMDDYY date*/

   /* move the map date to OBWREC.OBWDT6 before entering*/
   /* this routine*/
   /* the calling stmt grp must handle the return code*/
   /* processing*/

  set TA2REC empty;
  TA2REC.TA2GRGA = OBWREC.OBWDT6;
  TA2REC.TA2DTOPT = "GREGGREG";
  TA2REC.TA2GRTYP = "A";
  call "TA0040" (TA2REC) {isNoRefresh = yes, isExternal = yes};

end // end XSOBDED

// MMDDYY To Comp - no validate
Function XSOBDMC()
    /* convert MMDDYY date to comp (DB2 date)*/



   /* the calling stmt group must move the MMDDYY date*/
   /* to OBWREC.OBWDT6 before entering this routine*/

  if (OBWREC.OBWDT6 == 0)
    OBWREC.OBWDT8 = 0;
    return;
  end


  OBWREC.OBWDT8Y = OBWREC.OBWDT6Y;
  OBWREC.OBWDT8M = OBWREC.OBWDT6M;
  OBWREC.OBWDT8D = OBWREC.OBWDT6D;

  if (OBWREC.OBWDT6Y <= 51)
    OBWREC.OBWDT8C = 20;
  else
    OBWREC.OBWDT8C = 19;
  end

   /* the calling stmt group needs to move*/
   /* OBWREC.OBWDT8 to the comp date field.*/

end // end XSOBDMC

// db2 retn routine no rollback
Function XSOBEDC()
    /* DB2 return no rollback - will xfer to main menu*/


    /* This stmt grp will NOT rollback any updates since the last*/
    /* commit, converse or dxfr/xfer.*/

   /* the following fields will be filled in by the*/
   /* calling stmt group before entering this routine*/
     /* ta1locat(1) = transaction type  ie: 'ss' 'sn'*/
     /* ta1locat(2) = i/o mod name*/
     /* ta1locat(3) = calling stmt group name*/
     /* ta1locat(4) = programmers option(extra key data)*/
     /* ta1rec.ta1dbase = data base name (DORDB, etc..)*/
     /* ta1rec.ta1tblvu = data base view (VOBHDR01, etc..)*/
     /* ta1map = appl's mapname and should be initialized*/
              /* in the programs init process.*/



  set ERRSQLCA empty;
  move SQLCA to ERRSQLCA withV60Compat;
  TA1REC.TA1TYPE = "DB2";
  TA1REC.TA1FUNC = "RETN";
  TA1PGMNM = COMMAREA.CACURRAP; /* current application*/
  TA1REC.TA1TBLKE = OBWREC.OBWSYSKE; /* move system key*/
  VGVar.handleSysLibraryErrors = 0;
  sysLib.commit(); /* to close cursors*/
  try
    call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
  end
  XSOBP04(); /* master menu*/
  exit program; /* master menu failure*/


end // end XSOBEDC

// db2 post routine ta0020
Function XSOBEDP()
         /* DB2 Post routine*/


   /* the following fields will be filled in by the*/
   /* calling stmt group before entering this routine*/
     /* ta1locat(1) = transaction type  ie: 'ss' 'sn'*/
     /* ta1locat(2) = i/o mod name*/
     /* ta1locat(3) = calling stmt group name*/
     /* ta1locat(4) = programmers option(extra key data)*/
     /* ta1rec.ta1dbase = data base name (DORDB, etc..)*/
     /* ta1rec.ta1tblvu = data base view (VOBHDR01, etc..)*/
     /* ta1map = appl's mapname and should be initialized*/
              /* in the programs init process.*/
   /* return code processing will also be handled by the*/
   /* calling stmt group.*/

  set ERRSQLCA empty;
  move SQLCA to ERRSQLCA withV60Compat;
  TA1REC.TA1TYPE = "DB2";
  TA1REC.TA1FUNC = "POST";
  TA1PGMNM = COMMAREA.CACURRAP; /* current application*/
  TA1REC.TA1TBLKE = OBWREC.OBWSYSKE; /* move system key*/
  try
    call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
  end

end // end XSOBEDP

// db2 retn routine with rollback
Function XSOBEDR()
    /* DB2 return with rollback - will dxfr to main menu*/


    /* This stmt grp will rollback all updates since the last*/
    /* commit, converse or dxfr/xfer.*/

   /* the following fields will be filled in by the*/
   /* calling stmt group before entering this routine*/
     /* ta1locat(1) = transaction type  ie: 'ss' 'sn'*/
     /* ta1locat(2) = i/o mod name*/
     /* ta1locat(3) = calling stmt group name*/
     /* ta1locat(4) = programmers option(extra key data)*/
     /* ta1rec.ta1dbase = data base name (DORDB, etc..)*/
     /* ta1rec.ta1tblvu = data base view (VOBHDR01, etc..)*/
     /* ta1map = appl's mapname and should be initialized*/
              /* in the programs init process.*/



  set ERRSQLCA empty;
  move SQLCA to ERRSQLCA withV60Compat;
  TA1REC.TA1TYPE = "DB2";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = COMMAREA.CACURRAP; /* current application*/
  TA1REC.TA1TBLKE = OBWREC.OBWSYSKE; /* move key*/
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback(); /* rollback*/
  try
    call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
  end
  XSOBP04(); /* master menu*/
  exit program; /* master menu failure*/


end // end XSOBEDR

// non-db2 post routine ta0020
Function XSOBENP()
       /* Non-DB2 post routine*/


   /* the following fields will be filled in by the*/
   /* calling stmt group before entering this routine*/
     /* ta1locat(1) = transaction type  ie: 'ss' 'sn'*/
     /* ta1locat(2) = i/o mod name*/
     /* ta1locat(3) = calling stmt group name*/
     /* ta1locat(4) = programmers option(extra key data)*/
     /* taerec.taedesc1 = programmers opiton (additional key data*/
     /* taerec.taedesc2 = messages*/
     /* ta1map = appl's mapname and should be initilized*/
              /* in the programs init process.*/
   /* return code processing will also be handled by the*/
   /* calling stmt group.*/

  TA1REC.TA1TYPE = "APPL";
  TA1REC.TA1FUNC = "POST";
  TA1PGMNM = COMMAREA.CACURRAP; /* current application*/
  TA1REC.TA1TBLKE = OBWREC.OBWSYSKE; /* move system key*/
  try
    call "TA0020" (TA1REC, TAEREC) {isExternal = yes};
  end

end // end XSOBENP

// non db2 retn routine no rolbk
Function XSOBENR()
    /* Non-DB2 return no rollback - will xfer to main menu*/


    /* this routine to be used when there are no updates*/

   /* the following fields will be filled in by the*/
   /* calling stmt group before entering this routine*/
     /* ta1locat(1) = transaction type  ie: 'ss' 'sn'*/
     /* ta1locat(2) = i/o mod name*/
     /* ta1locat(3) = calling stmt group name*/
     /* ta1locat(4) = programmers option(extra key data)*/
     /* ta1map = appl's mapname and should be initialized*/
              /* in the programs init process.*/
     /* taerec.taedesc1 = programmers opiton (additional key data*/
     /* taerec.taedesc2 = messages*/
   /* return code processing will also be handled by the*/
   /* calling stmt group.*/



  TA1REC.TA1TYPE = "APPL";
  TA1REC.TA1FUNC = "RETN";
  TA1PGMNM = COMMAREA.CACURRAP; /* current application*/
  TA1REC.TA1TBLKE = OBWREC.OBWSYSKE; /* move key*/
  VGVar.handleSysLibraryErrors = 0;
  sysLib.commit(); /* to close cursors*/
  try
    call "TA0020" (TA1REC, TAEREC) {isExternal = yes};
  end
  XSOBP04(); /* master menu*/
  exit program; /* master menu failure*/


end // end XSOBENR

// OB SYSTEM - dxfr to self
Function XSOBP00()

   /* Application will transfer to itself*/

  COMMAREA.CAUSERA = OBWREC.OBWGROUP;

  sysVar.transferName = COMMAREA.CACURRAP;
  transfer to program sysVar.transferName passing COMMAREA;

end // end XSOBP00

// OB SYSTEM - HANDLE PF1
Function XSOBP01()

   /* Transfer to OM0Gr - List Change Maint Rsn Codes*/


  COMMAREA.CACURRAP = "OM0G";
  transfer to program "OM0G" passing COMMAREA;



end // end XSOBP01

// OB SYSTEM - HANDLE PF3
Function XSOBP03()

    /* Transfer to Order Batch - Order Select*/

   /* purge some temp storage first*/

  XSOBT2P(); /* purge errors*/
  XSOBT3P(); /* purge holds*/
  XSOBT4P(); /* purge items*/
  XSOBT5P(); /* purge comments*/
  XSOBT6P(); /* purge cust xref*/


  COMMAREA.CATOAP = "OB0B";
  XSEXIT();

end // end XSOBP03

// OB SYSTEM - HANDLE PF4
Function XSOBP04()

   /* Transfer control to the Main Menu.*/

   /* purge all temp storage first*/

  XSOBT1P(); /* purge orders*/
  XSOBT2P(); /* purge errors*/
  XSOBT3P(); /* purge holds*/
  XSOBT4P(); /* purge items*/
  XSOBT5P(); /* purge comments*/
  XSOBT6P(); /* purge cust xref*/


  XSPF4();



end // end XSOBP04

// OB SYSTEM - HANDLE PF5
Function XSOBP05()

   /* Transfer to Order Batch - Product Header*/



  COMMAREA.CATOAP = "OB0G";
  XSEXIT();

end // end XSOBP05

// OB SYSTEM - HANDLE PF6
Function XSOBP06()

   /* Transfer to Order Batch - Customer Information*/



  COMMAREA.CATOAP = "OB0C";
  XSEXIT();

end // end XSOBP06

// OB SYSTEM - HANDLE PF9
Function XSOBP09()

   /* Transfer to Order Batch - Product Summery*/



  COMMAREA.CATOAP = "OB0F";
  XSEXIT();

end // end XSOBP09

// OB SYSTEM - HANDLE PF10
Function XSOBP10()

   /* Transfer to Order Batch - Product Detail Availability*/



  COMMAREA.CATOAP = "OB0H";
  XSEXIT();

end // end XSOBP10

// OB SYSTEM - HANDLE PF10
Function XSOBP11()

   /* Transfer to Order Batch - cust xref summary*/



  COMMAREA.CATOAP = "OB0U";
  XSEXIT();

end // end XSOBP11

// OB SYSTEM - HANDLE PF13
Function XSOBP13()

   /* Transfer to Order Batch - Header*/



  COMMAREA.CATOAP = "OB0D";
  XSEXIT();

end // end XSOBP13

// OB SYSTEM - HANDLE PF14
Function XSOBP14()

   /* Transfer to Order Batch - Misc Header*/



  COMMAREA.CATOAP = "OB0E";
  XSEXIT();

end // end XSOBP14

// OB SYSTEM - HANDLE PF15
Function XSOBP15()

   /* Transfer to Order Batch - Special Instructions*/



  COMMAREA.CATOAP = "OB0J";
  XSEXIT();

end // end XSOBP15

// OB SYSTEM - HANDLE PF16
Function XSOBP16()

   /* Transfer to Order Batch - Customer Addresses*/



  COMMAREA.CATOAP = "OB0I";
  XSEXIT();

end // end XSOBP16

// OB SYSTEM - HANDLE PF17
Function XSOBP17()

   /* Transfer to Order Batch - Order Errors*/



  COMMAREA.CATOAP = "OB0L";
  XSEXIT();

end // end XSOBP17

// OB SYSTEM - HANDLE PF18
Function XSOBP18()

   /* Transfer to Order Batch - Order Comments*/



  COMMAREA.CATOAP = "OB0K";
  XSEXIT();

end // end XSOBP18

// OB SYSTEM - HANDLE PF19
Function XSOBP19()

   /* Transfer to Order Batch - Order Hold/Release*/



  COMMAREA.CATOAP = "OB0M";
  XSEXIT();

end // end XSOBP19

// OB SYSTEM - HANDLE PF20
Function XSOBP20()

   /* Transfer to Order Batch - Add Product*/


  if (OB1REC.YOBCD == "CA" /* cleared availability*/
   || OB1REC.YOBCD == "LD" /* lost demand reported*/
   || OB1REC.YOBCD == "PD") /* postponed demand reported*/
    converseLib.validationFailed(164); /* order status doesn't allow changes*/
    OBWREC.OBWERRFL = "Y";
  else
    COMMAREA.CATOAP = "OB0N";
    XSEXIT();
  end

end // end XSOBP20

// OB SYSTEM - HANDLE PF21
Function XSOBP21()

   /* Transfer to Prepack screen*/



  COMMAREA.CATOAP = "OB01";
  XSEXIT();

end // end XSOBP21

// OB SYSTEM - HANDLE PF22
Function XSOBP22()

   /* Transfer to Order Batch - Product Detail Prices*/



  COMMAREA.CATOAP = "OB0P";
  XSEXIT();

end // end XSOBP22

// OB SYSTEM - HANDLE PF23
Function XSOBP23()

   /* call Order Batch - Cancel and Record Lost Demand*/



   /* MOVE 'OB0Q' TO COMMAREA.CATOAP;*/
   /* XSEXIT;*/

   /* call to OB0Q has been disabled*/
   /* display message*/

  converseLib.validationFailed(239);
  OBWREC.OBWERRFL = "Y";


end // end XSOBP23

// OB SYSTEM - HANDLE PF24
Function XSOBP24()

   /* call Order Batch - Cancel Order/Product*/



  call "OB0R" (OBWREC) {isNoRefresh = yes};

  XSOBS03(); /* reread order header*/

  if (OB1REC.YOBCD == "XL"
   || OB1REC.YOBCD == "FA")
    /* / continue*/
  else
    OBW-EDIT-FUNCTION = "2";
    XSOBS-ONLINE-EDIT();
  end



end // end XSOBP24

// OB SYSTEM - dxfr to from ap
Function XSOBP99()

   /* Application will transfer to from application*/

  COMMAREA.CAUSERA = OBWREC.OBWGROUP;

  COMMAREA.CATOAP = COMMAREA.CAFROMAP;
  XSEXIT();

end // end XSOBP99

// LOAD TEMP STORAGE OBAREC
Function XSOBS-ADD-NEW-OBA()

  OBWREC.OP1NORID = OBLEREC.OBLE-NEW-NIKE-ORD-ID; /* set obwrec to*/
  OBWREC.OBWNOID = OBLEREC.OBLE-NEW-NIKE-ORD-ID; /* new sub order*/

  XSOBS03(); /* read the order*/

  OBWREC.OBWSUB = OBWREC.OBWTSF1P; /* save the current page*/
  OBWREC.OBWTSF1P = OBWREC.OBWTSF1M; /* read the last page*/

  XSOBT1R(); /* read temp storage current page*/


   /* find an empty row*/

  sysVar.arrayIndex = 1; /* init subscript*/
  while (sysVar.arrayIndex <= 12 /* still within page*/
   && OBAREC.OBACUOID[sysVar.arrayIndex] != 0) /* row is used*/
    sysVar.arrayIndex = sysVar.arrayIndex + 1; /* increment subscript*/
  end

   /* If there is a no slot available in the last page,*/
   /* then you will be adding a new record, so empty the*/
   /* record, init the subscript, load the obarec, and add*/
   /* the new record.  Otherwise, just load the obarec and*/
   /* do an update.*/

  if (sysVar.arrayIndex == 13) /* need to add new page*/
    set OBAREC empty; /* clear for new page*/
    XSOBT1W(); /* add temp storage record*/
    sysVar.arrayIndex = 1; /* set subscript to first line*/
  end


   /* build temp storage row for the new suborder*/

  OBAREC.OBAORDER[sysVar.arrayIndex] = OBWREC.OBWORDER; /* formatted order*/
  OBAREC.OP1PARTN[sysVar.arrayIndex] = OB1REC.OP1PARTN; /* partial load flag*/
  OBAREC.OB1PARLF[sysVar.arrayIndex] = OB1REC.OB1PARLF; /* partial load flag*/
  OBAREC.SP1ID[sysVar.arrayIndex] = OB1REC.SP1ID; /* sales program*/
  OBAREC.XOBCD[sysVar.arrayIndex] = OB1REC.XOBCD; /* base ot code*/

  OBWREC.OBWDT8 = OB1REC.OP1CUNDT; /* reformat need date*/
  XSOBDCM(); /* db2 date to map date*/
  OBAREC.OBACUNDT[sysVar.arrayIndex] = OBWREC.OBWDT6;
                                   /* reformatted need date*/

  if (OB1REC.YOBCD == "DL")
    OBAREC.OBAMSEL[sysVar.arrayIndex] = "*";
  else
    OBAREC.OBAMSEL[sysVar.arrayIndex] = "U";
  end

  OBAREC.YOBCD[sysVar.arrayIndex] = OB1REC.YOBCD; /* yob code*/

  OBAREC.OB1ERRFL[sysVar.arrayIndex] = OB1REC.OB1ERRFL; /* error flag*/
  OBAREC.OBAFILL[sysVar.arrayIndex] = "/"; /* slash*/
  OBAREC.OB1HLDFL[sysVar.arrayIndex] = OB1REC.OB1HLDFL; /* hold flag*/

  OBAREC.OBACUST[sysVar.arrayIndex] = OBWREC.OBWCUST; /* formatted cust*/
  OBAREC.KUMSTSNM[sysVar.arrayIndex] = "NEW SUBORDER";

  XSOBT1U(); /* update temp storage*/


   /* Read order temp storage record for current order*/
   /* and decide which one to display*/

  OBWREC.OBWTSF1P = OBWREC.OBWSUB; /* restore current page*/
  XSOBT1R();

  if (OBAREC.OBAMSEL[OBWTSF1S] == "*") /* deleted or loaded order*/
    /* set temp storage, obwrec and ob1rec to display new suborder*/
    OBWREC.OBWTSF1P = OBWREC.OBWTSF1M; /* restore last page*/
    OBWREC.OBWTSF1S = sysVar.arrayIndex; /* and subscript for new order*/
    OBWREC.YOBCD = OB1REC.YOBCD; /* yob code*/
    /* obwrec contains the new order*/
  else
    /* set temp storage, obwrec and ob1rec to display original order*/
    OBWREC.OP1NORID = OBLEREC.OP1NORID; /* set obwrec to*/
    OBWREC.OBWNOID = OBLEREC.OP1NORID; /* original suborder*/
    /* temp storage is already set to the original order*/
  end



end // end XSOBS-ADD-NEW-OBA

// CALL FULL EDIT - OB1670
Function XSOBS-FULL-EDIT()
  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **/
  /* BUILD PASSING RECORD FOR OB1670*/
  /* CALL OB1670*/
  /* PROCESS RETURN CODES*/
  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **/

  set OBFEREC empty;
  OBFEREC.OBFE-EDIT-OPTION = OBWREC.OBW-EDIT-FUNCTION;
  OBFEREC.OP1PARTN = OB1REC.OP1PARTN;
  OBFEREC.OP1CUOID = OB1REC.OP1CUOID;
  if (OBWREC.OBW-CHG-ALL-SUBORDS-FL == "Y")
    OBFEREC.OP1NORID = 0;
    OBWREC.OBW-CHG-ALL-SUBORDS-FL = "N";
  else
    OBFEREC.OP1NORID = OB1REC.OP1NORID;
  end
  if (COMMAREA.CACURRAP == "OB0G"
   || COMMAREA.CACURRAP == "OB0H")
    OBFEREC.OP2LNINB = OBWREC.OBWLNINB;
  else
    OBFEREC.OP2LNINB = 0;
  end
  OBFEREC.ZZZCHGDT = OBWREC.ZZZCHGDT;
  OBFEREC.ZZZCHGTM = OBWREC.ZZZCHGTM;
  OBFEREC.OBFE-APPLY-DEFAULTS-FL = OBWREC.OBW-APPLY-DEFAULTS-FL;
  OBFEREC.OBFE-OBWTSF1P = OBWREC.OBWTSF1P;
  OBFEREC.OBFE-OBWTSF1S = OBWREC.OBWTSF1S;
  OBFEREC.OBFE-OBWTSF1M = OBWREC.OBWTSF1M;
  OBFEREC.OBFE-RETURN-CD = 99;

  call "OB1670" (OBFEREC) {isNoRefresh = yes, isExternal = yes};

  TA1REC.TA1LOCAT[2] = "OB1670";
  TA1REC.TA1LOCAT[3] = "XSOBS-FU";
  TA1REC.TA1LOCAT[4] = "LL-EDIT ";
  TAEREC.TAEDESC1 = "OB1670 RETURN CODE IS ";
  TAEREC.TAEDESC2 = OBFEREC.OBFE-RETURN-CD;

  if (OBFEREC.OBFE-RETURN-CD == 0)
    /* continue at the end of this if statement*/
  else
    if (OBFEREC.OBFE-RETURN-CD == 1)
  /* HEADER NOT FOUND - when it should have been*/
      OBWREC.CAMSG = OBFEREC.OBFE-RETURN-MSG;
      VGVar.handleSysLibraryErrors = 0;
      sysLib.rollback(); /* rollback updates since last commit*/
      XSOBENR(); /* appl retn - go to main menu*/
    else
      if (OBFEREC.OBFE-RETURN-CD == 2)
  /* NOT FOUND ON UPDATE - ORDER UPDATED BY BATCH OR ANOTHER CSR*/
        OBWREC.CAMSG = "ORDER UPDATED BY BATCH SYSTEM OR ANOTHER CSR -PLEASE REVIEW";
        XSOBAPR(); /* post, rollback, restart appl*/
      else
        if (OBFEREC.OBFE-RETURN-CD == 3)
  /* DATABASE DEADLOCK - DATABASE BUSY TRY AGAIN*/
          OBWREC.CAMSG = "DATABASE BUSY - PLEASE TRY AGAIN";
          XSOBAPR(); /* post, rollback, restart appl*/
        else
          if (OBFEREC.OBFE-RETURN-CD == 4)
  /* OTHER DATABASE PROBLEM - ABEND W/ROLLBACK*/
            VGVar.handleSysLibraryErrors = 0;
            sysLib.rollback(); /* rollback updates to last commit*/
            XSOBENR(); /* appl retn - go to main menu*/
          else
            if (OBFEREC.OBFE-RETURN-CD == 5)
  /* DEADLOCK IN SUBPROGRAM CALLED FROM OB1670- BUSY TRY AGAIN*/
              OBWREC.CAMSG = "DATABASE BUSY - PLEASE TRY AGAIN";
              XSOBAPR(); /* post, rollback, restart appl*/
            else
              if (OBFEREC.OBFE-RETURN-CD == 6)
  /* SUBPROGRAM CALLED FROM OB1670 FAILED*/
                VGVar.handleSysLibraryErrors = 0;
                sysLib.rollback(); /* rollback updates to last commit*/
                XSOBENR(); /* appl retn - go to main menu*/
              else
                if (OBFEREC.OBFE-RETURN-CD == 99)
  /* CALL TO OB1670 DIDN'T WORK*/
                  VGVar.handleSysLibraryErrors = 0;
                  sysLib.rollback(); /* rollback updates to last commit*/
                  XSOBENR(); /* appl retn - go to main menu*/
                else
  /* MAJOR PROBLEM WITH OB1670*/
                  VGVar.handleSysLibraryErrors = 0;
                  sysLib.rollback(); /* rollback updates to last commit*/
                  XSOBENR(); /* appl retn - go to main menu*/
                end
              end
            end
          end
        end
      end
    end
  end

   /* return code from OB1670 was good so update obwrec*/
   /* the OBAREC temp storage was updated in OB1670*/

   /* format new order number in OBWREC*/

  if (OBFEREC.OBFE-NEW-CUST-ORD-ID != 0)
    OBWREC.OP1CUOID = OBFEREC.OBFE-NEW-CUST-ORD-ID; /* db2 ord id*/
    OBWREC.OP1PARTN = OBFEREC.OBFE-NEW-ORD-PART-CHAR;
  end
  if (OBFEREC.OBFE-NEW-NIKE-ORD-ID != 0)
    OBWREC.OP1NORID = OBFEREC.OBFE-NEW-NIKE-ORD-ID;
  end

   /* now format displayed order number in OBWREC*/

  if (OBFEREC.OBFE-NEW-CUST-ORD-ID != 0
   || OBFEREC.OBFE-NEW-NIKE-ORD-ID != 0)
    OBWREC.OBWCUOID = OBWREC.OP1CUOID;
    OBWREC.OBWNOID = OBWREC.OP1NORID;
    OBWREC.OBWFMT = OBWREC.OBWORDER;
    XSOBS06();
    OBWREC.OBWORDER = OBWREC.OBWFMT;
  end

   /* re-read ob1rec*/
  XSOBS03();

   /* now update the remaining OBWREC fields for the order*/

  OBWREC.OBW-GET-ERRORS-FL = "Y";
  OBWREC.OBW-GET-HOLDS-FL = "Y";
  OBWREC.OBW-GET-ITEMS-FL = "Y";

   /* obrrec temp storage info - current page, subscript, max page*/

  if (OBWREC.OBWTSF1M != OBFEREC.OBFE-OBWTSF1M)
    OBWREC.OBWTSF1M = OBFEREC.OBFE-OBWTSF1M;
  end

  if (OBWREC.OBWTSF1S != OBFEREC.OBFE-OBWTSF1S)
    OBWREC.OBWTSF1S = OBFEREC.OBFE-OBWTSF1S;
  end

  if (OBWREC.OBWTSF1P != OBFEREC.OBFE-OBWTSF1P)
    OBWREC.OBWTSF1P = OBFEREC.OBFE-OBWTSF1P;
  end

  XSOBT1R(); /* read current temp storage fro*/
                                   /* selected orders*/

   /* the order status*/

  if (OBWREC.CAMSG == " ")
    if (OBFEREC.YOBCD == "CK")
      OBWREC.CAMSG = "ORDER EDIT SUCCESSFUL - PLEASE CHECK FOR NEW ERRORS/HOLDS";
    end
    if (OBFEREC.YOBCD == "CL")
      OBWREC.CAMSG = "ORDER EDIT SUCCESSFUL - ORDER HAS CLEARED";
    end
    if (OBFEREC.YOBCD == "DL")
      OBWREC.CAMSG = "ALL PRODUCTS HAVE MOVED TO A NEW SUBORDER/ORDER";
      OBFEREC.YOBCD = OB1REC.YOBCD;
    end
  end


  if (OBFEREC.YOBCD != OBWREC.YOBCD)
    if (OBWREC.YOBCD == "FA"
     || OBWREC.YOBCD == "LP"
     || OBWREC.YOBCD == "PD")
      if (OBFEREC.YOBCD == "CL")
         /* next sentence - keep the 'fa' status*/
      else
        OBWREC.YOBCD = OBFEREC.YOBCD;
      end
    else
      OBWREC.YOBCD = OBFEREC.YOBCD;
    end
  end



end // end XSOBS-FULL-EDIT

// CALL LIMITED EDIT - OB1680
Function XSOBS-LIMITED-EDIT()
  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **/
  /* BUILD PASSING RECORD FOR OB1680*/
  /* CALL OB1680*/
  /* PROCESS RETURN CODES*/
  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **/

  set OBLEREC empty;
  OBLEREC.OBLE-EDIT-OPTION = OBWREC.OBW-EDIT-FUNCTION;
  OBLEREC.OP1PARTN = OB1REC.OP1PARTN;
  OBLEREC.OP1CUOID = OB1REC.OP1CUOID;
  OBLEREC.OP1NORID = OB1REC.OP1NORID;

  if (OBWREC.OBW-EDIT-FUNCTION == "5") /* EDIT ONE LINE ITEM*/
    OBLEREC.OP2LNINB = OBWREC.OBWLNINB;
  else
    OBLEREC.OP2LNINB = 0;
  end

  OBLEREC.ZZZCHGDT = OBWREC.ZZZCHGDT;
  OBLEREC.ZZZCHGTM = OBWREC.ZZZCHGTM;
  OBLEREC.OBLE-RETURN-CD = 99;

  call "OB1680" (OBLEREC) {isNoRefresh = yes, isExternal = yes};

  TA1REC.TA1LOCAT[2] = "OB1680";
  TA1REC.TA1LOCAT[3] = "XSOBS-LI";
  TA1REC.TA1LOCAT[4] = "MITED-ED";
  TAEREC.TAEDESC1 = "OB1680 RETURN CODE IS ";
  TAEREC.TAEDESC2 = OBLEREC.OBLE-RETURN-CD;

  if (OBLEREC.OBLE-RETURN-CD == 0)
    XSOBS-UPD-OBA-EDIT(); /* update temp storage row*/
    OBWREC.OBW-GET-ERRORS-FL = "Y";
    OBWREC.OBW-GET-HOLDS-FL = "Y";
    if (OBLEREC.OBLE-EDIT-OPTION == "2")
      OBWREC.OBW-GET-ITEMS-FL = "Y";
    end

    if (OBWREC.CAMSG == " ")
      if (OBLEREC.YOBCD == "CK")
        OBWREC.CAMSG = " ORDER EDIT SUCCESSFUL - PLEASE CHECK FOR NEW ERRORS/HOLDS";
      end
      if (OBLEREC.YOBCD == "CL")
        OBWREC.CAMSG = " ORDER EDIT SUCCESSFUL - ORDER HAS CLEARED";
      end
      if (OBLEREC.YOBCD == "DL"
       || OBLEREC.OBLE-NEW-NIKE-ORD-ID > 0)
        OBWREC.CAMSG = "ITEM(S) HAVE MOVED TO A NEW SUBORDER/ORDER";
      end
    end

    if (OBWREC.YOBCD != OBLEREC.YOBCD)
      if (OBWREC.YOBCD == "FA"
       || OBWREC.YOBCD == "LP"
       || OBWREC.YOBCD == "PD")
        if (OBLEREC.YOBCD == "CL"
        ) /* next sentence  - keep the 'fa' status*/
        else
          OBWREC.YOBCD = OBLEREC.YOBCD;
        end
      else
        OBWREC.YOBCD = OBLEREC.YOBCD;
      end
    end
  else
    if (OBLEREC.OBLE-RETURN-CD == 1)
  /* HEADER NOT FOUND - when it should have been*/
      OBWREC.CAMSG = OBLEREC.OBLE-RETURN-MSG;
      VGVar.handleSysLibraryErrors = 0;
      sysLib.rollback(); /* rollback updates since last commit*/
      XSOBENR(); /* appl retn - go to main menu*/
    else
      if (OBLEREC.OBLE-RETURN-CD == 2)
  /* NOT FOUND ON UPDATE - ORDER UPDATED BY BATCH OR ANOTHER CSR*/
        OBWREC.CAMSG = "ORDER UPDATED BY BATCH SYSTEM OR ANOTHER CSR - PLEASE REVIEW";
        XSOBAPR(); /* post, rollback, restart appl*/
      else
        if (OBLEREC.OBLE-RETURN-CD == 3)
  /* DATABASE DEADLOCK - DATABASE BUSY TRY AGAIN*/
          OBWREC.CAMSG = "DATABASE BUSY - PLEASE TRY AGAIN ";
          XSOBAPR(); /* post, rollback, restart appl*/
        else
          if (OBLEREC.OBLE-RETURN-CD == 4)
  /* OTHER DATABASE PROBLEM - ABEND W/ROLLBACK*/
            VGVar.handleSysLibraryErrors = 0;
            sysLib.rollback(); /* rollback updates to last commit*/
            XSOBENR(); /* appl retn - go to main menu*/
          else
            if (OBLEREC.OBLE-RETURN-CD == 5)
  /* DEADLOCK IN SUBPROGRAM CALLED FROM OB1680- BUSY TRY AGAIN*/
              OBWREC.CAMSG = "DATABASE BUSY - PLEASE TRY AGAIN ";
              XSOBAPR(); /* post, rollback, restart appl*/
            else
              if (OBLEREC.OBLE-RETURN-CD == 6)
  /* SUBPROGRAM CALLED FROM OB1680 FAILED*/
                VGVar.handleSysLibraryErrors = 0;
                sysLib.rollback(); /* rollback updates to last commit*/
                XSOBENR(); /* appl retn - go to main menu*/
              else
                if (OBLEREC.OBLE-RETURN-CD == 99)
  /* CALL TO OB1680 DIDN'T WORK*/
                  VGVar.handleSysLibraryErrors = 0;
                  sysLib.rollback(); /* rollback updates to last commit*/
                  XSOBENR(); /* appl retn - go to main menu*/
                else
  /* MAJOR PROBLEM WITH OB1680*/
                  VGVar.handleSysLibraryErrors = 0;
                  sysLib.rollback(); /* rollback updates to last commit*/
                  XSOBENR(); /* appl retn - go to main menu*/
                end
              end
            end
          end
        end
      end
    end
  end

    /* deal with suborder split from ob1rec*/

  if (OBLEREC.OBLE-NEW-NIKE-ORD-ID > 0)
    XSOBS-ADD-NEW-OBA(); /* add new suborder to temp storage*/
  end



end // end XSOBS-LIMITED-EDIT

// prepare for relational edit
Function XSOBS-ONLINE-EDIT()
  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **/
  /* This statement group calls one of two edit subprograms*/
  /* depending on the edit function. The edit function is*/
  /* determined and placed in OBWREC by each Airspeed APPL*/
  /* that needs to do relational edits. Before using this*/
  /* statement group fill in the TA1REC.ta1map with the calling*/
  /* APPL mapname, and ta1re.ta1llocat (1) with the statement group*/
  /* used to call this statement group. Any abends, rollbacks*/
  /* etc. will be done in xsobs-full-edit or xsob-limited edit*/
  /* depending on the edit option. See OBFEREC or OBLEREC for*/
  /* return code info.*/
  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **/


  if (OBWREC.OBW-EDIT-FUNCTION == "1")
    XSOBS-FULL-EDIT(); /* edit entire order (all subs)*/
  else
    XSOBS-LIMITED-EDIT(); /* edit suborder header/items*/
  end

  VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
  VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
  sysLib.commit();
  VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
   /* commit all work done from edits*/

  OBWREC.OBW-EDIT-FUNCTION = " ";

end // end XSOBS-ONLINE-EDIT

// LOAD TEMP STORAGE OBAREC
Function XSOBS-UPD-OBA-EDIT()




  XSOBT1R(); /* read temp storage current page*/

   /* obwrec.obwcuoid is the same as ob1rec.op1cuoid, num instead of comp*/
   /* obwrec.obwnoid is the same as ob1rec.op1norid, num instead of comp*/
   /* check to see if the values are different. if they are then update*/
   /* the original order first then update the new or existing order.*/
   /* the original suborder is in obwrec op1cuoid and op1norid*/

  if (OBAREC.OBACUOID[OBWTSF1S] == OBWREC.OBWCUOID
   && OBAREC.OBANORID[OBWTSF1S] == OBWREC.OBWNOID)
    /* next sentence*/
  else
    OBWREC.OP1NORID = OBAREC.OBANORID[OBWTSF1S];
    OBWREC.OP1CUOID = OBAREC.OBACUOID[OBWTSF1S];
    OBWREC.OP1PARTN = OBAREC.OP1PARTN[OBWTSF1S];
  end

  XSOBS03(); /* read the original order*/
  OBAREC.OB1PARLF[OBWTSF1S] = OB1REC.OB1PARLF; /* partial load flag*/
  OBAREC.SP1ID[OBWTSF1S] = OB1REC.SP1ID; /* sales program*/
  OBAREC.XOBCD[OBWTSF1S] = OB1REC.XOBCD; /* base ot code*/

  OBWREC.OBWDT8 = OB1REC.OP1CUNDT; /* reformat need date*/
  XSOBDCM(); /* db2 date to map date*/
  OBAREC.OBACUNDT[OBWTSF1S] = OBWREC.OBWDT6;
                                   /* reformatted need date*/

  if (OB1REC.YOBCD == "DL")
    OBAREC.OBAMSEL[OBWTSF1S] = "*";
  else
    OBAREC.OBAMSEL[OBWTSF1S] = "U";
  end

  OBAREC.YOBCD[OBWTSF1S] = OB1REC.YOBCD; /* yob code*/

  OBAREC.OB1ERRFL[OBWTSF1S] = OB1REC.OB1ERRFL; /* error flag*/
  OBAREC.OBAFILL[OBWTSF1S] = "/"; /* slash*/
  OBAREC.OB1HLDFL[OBWTSF1S] = OB1REC.OB1HLDFL; /* hold flag*/

  OBAREC.OBACUST[OBWTSF1S] = OBWREC.OBWCUST; /* formatted cust*/

  XSOBT1U(); /* update temp storage*/




   /* now update temp storage for the new or existing suborder*/

  if (OBAREC.OBACUOID[OBWTSF1S] == OBWREC.OBWCUOID
   && OBAREC.OBANORID[OBWTSF1S] == OBWREC.OBWNOID)
    /* next sentence there was no split*/
  else /* find the new/existing suborder in*/
                                   /* temp storage*/
    sysVar.arrayIndex = OBWREC.OBWTSF1S; /* save orig subscript*/
    OBWREC.OBWSUB = OBWREC.OBWTSF1P; /* save orig page*/

    OBWREC.OBWTSF1P = OBWREC.OBWTSF1M; /* start with last page*/

    while (OBWREC.OBWTSF1P > 0)

      XSOBT1R(); /* read temp storage page*/
      OBWREC.OBWTSF1S = 12; /* start on last line of page*/

      while (OBWREC.OBWTSF1S > 0)
        if (OBAREC.OBACUOID[OBWTSF1S] == OBWREC.OBWCUOID
         && OBAREC.OBANORID[OBWTSF1S] == OBWREC.OBWNOID)
                                  /* found new/existing order so get the*/
                                   /* suborder and update temp storage*/
          OBWREC.OP1CUOID = OBWREC.OBWCUOID;
          OBWREC.OP1NORID = OBWREC.OBWNOID;
          OBWREC.OBWFMT = OBWREC.OBWORDER;
          OBWREC.OP1PARTN = OBWREC.OBWDGT[9];
          XSOBS03(); /* read the new/existing order*/

          OBAREC.OB1PARLF[OBWTSF1S] = OB1REC.OB1PARLF;
                                   /* partial load flag*/
          OBAREC.SP1ID[OBWTSF1S] = OB1REC.SP1ID; /* sales program*/
          OBAREC.XOBCD[OBWTSF1S] = OB1REC.XOBCD; /* base ot code*/

          OBWREC.OBWDT8 = OB1REC.OP1CUNDT; /* reformat need date*/
          XSOBDCM(); /* db2 date to map date*/
          OBAREC.OBACUNDT[OBWTSF1S] = OBWREC.OBWDT6;
                                   /* reformatted need date*/

          if (OB1REC.YOBCD == "DL")
            OBAREC.OBAMSEL[OBWTSF1S] = "*";
          else
            OBAREC.OBAMSEL[OBWTSF1S] = "U";
          end

          OBAREC.YOBCD[OBWTSF1S] = OB1REC.YOBCD; /* yob code*/

          OBAREC.OB1ERRFL[OBWTSF1S] = OB1REC.OB1ERRFL; /* error flag*/
          OBAREC.OBAFILL[OBWTSF1S] = "/"; /* slash*/
          OBAREC.OB1HLDFL[OBWTSF1S] = OB1REC.OB1HLDFL; /* hold flag*/

          OBAREC.OBACUST[OBWTSF1S] = OBWREC.OBWCUST; /* formatted cust*/

          XSOBT1U(); /* update temp storage*/

          OBWREC.OBWTSF1P = 0; /* done - get out of both while*/
          OBWREC.OBWTSF1S = 0; /* statements*/
        else
          OBWREC.OBWTSF1S = OBWREC.OBWTSF1S - 1;
        end
      end
      OBWREC.OBWTSF1P = OBWREC.OBWTSF1P - 1;
    end
    /* restore temp storage to the original page and subscript*/
    OBWREC.OBWTSF1S = sysVar.arrayIndex; /* /original subscript*/
    OBWREC.OBWTSF1P = OBWREC.OBWSUB; /* original page*/
    XSOBT1R(); /* read temp storage page*/
    OBWREC.OBWCUOID = OBAREC.OBACUOID[OBWTSF1S];
    OBWREC.OP1CUOID = OBAREC.OBACUOID[OBWTSF1S];
    OBWREC.OBWNOID = OBAREC.OBANORID[OBWTSF1S];
    OBWREC.OP1NORID = OBAREC.OBANORID[OBWTSF1S];
    OBWREC.OP1PARTN = OBAREC.OP1PARTN[OBWTSF1S]; /* get part char*/
  end





end // end XSOBS-UPD-OBA-EDIT

// o/e system security
Function XSOBS01()



      /* *********************************************************/
      /* * retrieve o/b commarea and check order batch security **/
      /* *********************************************************/


  OBWREC.OBWGROUP = COMMAREA.CAUSERA; /* get o/b commarea*/


  if (OBWREC.OBWINIT != "OB0") /* check o/b security*/
    transfer to program "OB0A" passing COMMAREA; /* dxfr if not properly initialized*/
    exit program;
  end



   /* *************************************************************/
end // end XSOBS01

// see if batch edit is running
Function XSOBS02()

   /* see if batch edit program is running*/
   /* if it is then issue message and DXFR to OB0B*/
   /* (but keep the original code to get out if the part char*/
   /* is set to Y so that we can use that in emergencies)*/

  set OB8REC empty;
  set SQLCA empty;

  OB8REC.XXXPGMNO = "OB1050";

  call "IO5220" ("S ", SQLCA, OB8REC) {isNoRefresh = yes, isExternal = yes}; /* i/o mod-select scan*/

   /* check db2 return code*/

  if (SQLCA.VAGen_SQLCODE == 0) /* check for good rc*/
    if (OB8REC.OP1PARTN == "Y")
      OBWREC.CAMSG = "BATCH PROCESS IS RUNNING, PLEASE WAIT";
      COMMAREA.CAUSERA = OBWREC.OBWGROUP;
      transfer to program "OB0A" passing COMMAREA; /* dxfr to OB0A*/
    else
      if (OB8REC.OP1CUOID == OBWREC.OP1CUOID)
        OBWREC.CAMSG = "BATCH EDIT IS EDITING ORDER, TRY AGAIN";
        XSOBS10(); /* update temp storage*/
        COMMAREA.CAUSERA = OBWREC.OBWGROUP;
        XSOBP03(); /* dxfr to OB0B*/
      else
       /* everything is ok*/
      end
    end
  else
    TA1REC.TA1DBASE = "DORDB   "; /* data base name*/
    TA1REC.TA1TBLVU = "VOBPGM01"; /* table view*/
    TA1REC.TA1LOCAT[1] = "S       "; /* calling option*/
    TA1REC.TA1LOCAT[2] = "IO5220  "; /* i/o mod name*/
    TA1REC.TA1LOCAT[3] = "XSOBS02 "; /* statement group*/
    TA1REC.TA1LOCAT[4] = OB8REC.XXXPGMNO; /* key to record*/
    if (SQLCA.VAGen_SQLCODE == -911)
      XSOBS04(); /* -911 processing, no rollback*/
    else
      XSOBEDC(); /* abort routine - no reset done*/
    end
  end


end // end XSOBS02

// read current order header
Function XSOBS03()
   /* Read the current order header.*/

  set OB1REC empty;
  set OBFREC empty;
  set SQLCA empty;


  OB1REC.OP1CUOID = OBWREC.OP1CUOID;
  OB1REC.OP1NORID = OBWREC.OP1NORID;
  OB1REC.OP1PARTN = OBWREC.OP1PARTN;

  OBFREC.OBFTASK = "S ";

  call "IO5160" (OBFREC, SQLCA, OB1REC) {isNoRefresh = yes, isExternal = yes}; /* i/o mod-select scan*/

   /* check db2 return code*/

  if (SQLCA.VAGen_SQLCODE == 0) /* check for good rc*/
     /* next sentence*/
  else
    TA1REC.TA1DBASE = "DORDB   "; /* data base name*/
    TA1REC.TA1TBLVU = "VOBHDR01"; /* table view*/
    TA1REC.TA1LOCAT[1] = "S       "; /* calling option*/
    TA1REC.TA1LOCAT[2] = "IO5160  "; /* i/o mod name*/
    TA1REC.TA1LOCAT[3] = "XSOBS03 "; /* statement group*/
    if (SQLCA.VAGen_SQLCODE == -911)
      XSOBS04();
    else
      XSOBEDC(); /* abort routine - no reset done*/
    end
  end

   /* if the status has changed to CK or CL etc since this order*/
   /* was selected initially it means the batch edit has edited*/
   /* it while the CSR was in the order; in that case, want to*/
   /* start over in ob0b and reset the status back to NC again and*/
   /* repull the information (without this it is possible for the CSR*/
   /* to make changes to the order and the status not get set to*/
   /* edit it again, or suddenly the CSR can't change the order*/
   /* and they don't know why (if CL)*/

   /* THE FOLLOWING IS BEING REMOVED, SINCE IT'S NOW POSSIBLE FOR*/
   /* AN ORDER WITH A 'NC' STATUS TO BE SELECTED. THIS CODE MEANT*/
   /* SOMETHING BEFORE THE ONLINE EDITS WERE INSTALLED.*/

   /* :IF COMMAREA.CACURRAP EQ 'OB0B';       /* not applicable in ob0b*/
     /* next sentence*/
   /* ELSE;*/
   /* IF OBWREC.YOBCD = 'NC';*/
    /* IF OB1REC.YOBCD = 'CK'*/
    /* OR OB1REC.YOBCD = 'CL'*/
    /* OR OB1REC.YOBCD = 'CA'*/
    /* OR OB1REC.YOBCD = 'FA'*/
    /* OR OB1REC.YOBCD = 'DW'*/
    /* OR OB1REC.YOBCD = 'DP'*/
    /* OR OB1REC.YOBCD = 'DL'*/
    /* OR OB1REC.YOBCD = 'LD';*/
      /* MOVE 'BATCH EDIT IS EDITING ORDER, TRY AGAIN' TO OBWREC.CAMSG;*/
      /* MOVE OBWREC.OBWGROUP TO COMMAREA.CAUSERA;*/
      /* XSOBS10;                            /* update temp storage*/
      /* XSOBP03;                            /* transfer to OB0B*/
    /* END;*/
   /* END;*/
   /* END;*/


end // end XSOBS03

// -911 processing - no rollback
Function XSOBS04()
   /* process -911 return code - ta1rec data must be*/
   /* filled in by the caller. This statement group*/
   /* doesn't rollback previous updates.*/


  XSOBEDP(); /* post and come back here*/
  if (OBWREC.OBWER911 == "Y") /* -911 occured after a converse*/
    OBWREC.CAMSG = "DATABASE BUSY - REENTER CHANGES AND TRY AGAIN";
  end
  XSOBP00(); /* restart application*/


end // end XSOBS04

// -911 processing - rollback
Function XSOBS05()
   /* process -911 return code - ta1rec data must be*/
   /* filled in by the caller. This statement group*/
   /* will rollback previous updates.*/


  XSOBEDP(); /* post and come back here*/
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback(); /* rollback*/
  if (OBWREC.OBWER911 == "Y") /* -911 occured after a converse*/
    OBWREC.CAMSG = "DATABASE BUSY - REENTER CHANGES AND TRY AGAIN";
  end
  XSOBP00(); /* restart application*/


end // end XSOBS05

// remove leading zeroes
Function XSOBS06()

     /* remove leading zeros from customer or order to display*/

  OBWREC.OBWSUB = 1; /* init sub*/

  while (OBWREC.OBWSUB <= 16 /* end of nbr*/
   && OBWREC.OBWDGT[OBWSUB] == "0") /* digits still = 0*/
    if (OBWREC.OBWDGT[OBWSUB] == "0")
      OBWREC.OBWDGT[OBWSUB] = " "; /* suppress 0*/
    end
    OBWREC.OBWSUB = OBWREC.OBWSUB + 1;
  end

end // end XSOBS06

// add leading zeroes for call
Function XSOBS07()

     /* add leading zeros from customer or order to use*/
     /* as keys to call database records*/

  OBWREC.OBWSUB = 1; /* init sub*/

  while (OBWREC.OBWSUB <= 16 /* end of nbr*/
   && OBWREC.OBWDGT[OBWSUB] == " ") /* digits still = ' '*/
    if (OBWREC.OBWDGT[OBWSUB] == " ")
      OBWREC.OBWDGT[OBWSUB] = "0"; /* move 0*/
    end
    OBWREC.OBWSUB = OBWREC.OBWSUB + 1;
  end

end // end XSOBS07

// update temp storage - OB1REC
Function XSOBS10()

  XSOBT1R(); /* read temp storage*/

  OBAREC.OBAMSEL[OBWTSF1S] = "C"; /* 'changed' to select cd*/
  OBAREC.YOBCD[OBWTSF1S] = OB1REC.YOBCD; /* update the status*/

  XSOBT1U(); /* update temp storage*/

end // end XSOBS10

// purge temp storage 1 - orders
Function XSOBT1P()



   /* purge temporary storage 1*/

  TA5REC.TA5APPID = "OBF1"; /* appl identification*/
  TA5REC.TA5FNCCD = "P"; /* function code*/
  call "TA0050" (OBAREC, TA5REC) {isNoRefresh = yes, isExternal = yes}; /* temp storage subroutine*/

  if (TA5REC.TA5RTNCD == 0)
    OBWREC.OBWTSF1P = 1;
    OBWREC.OBWTSF1S = 1;
    OBWREC.OBWTSF1M = 1;
  else
    TA1REC.TA1LOCAT[1] = "PRGE TS1";
    TA1REC.TA1LOCAT[2] = "TA0050"; /* io mod called*/
    TA1REC.TA1LOCAT[3] = TA5REC.TA5RTNCD; /* return code*/
    TA1REC.TA1TBLKE = OBAREC.OBATSROW[1]; /* first row, first rec*/
    TAEREC.TAEDESC1 = TA5REC.TA5DATA; /* subroutine parms*/
    XSOBENP(); /* post,  no rollback, non db2*/


  end
end // end XSOBT1P

// read temp storage 1 - orders
Function XSOBT1R()



   /* read temporary storage 1*/

  set OBAREC empty;

  TA5REC.TA5APPID = "OBF1"; /* appl identification*/
  TA5REC.TA5FNCCD = "R"; /* function code*/
  TA5REC.TA5TSQIX = OBWREC.OBWTSF1P; /* current page*/
  OBAREC.OBATSLEN = 700; /* length of record*/

  call "TA0050" (OBAREC, TA5REC) {isNoRefresh = yes, isExternal = yes}; /* temp storage subroutine*/

  if (TA5REC.TA5RTNCD == 0)
    /* next sentence*/
  else
    TA1REC.TA1LOCAT[1] = "READ TS1";
    TA1REC.TA1LOCAT[2] = "TA0050"; /* io mod called*/
    TA1REC.TA1LOCAT[3] = TA5REC.TA5RTNCD; /* return code*/
    TA1REC.TA1TBLKE = OBAREC.OBATSROW[1]; /* first row, first rec*/
    TAEREC.TAEDESC1 = TA5REC.TA5DATA; /* subroutine parms*/
    XSOBENP(); /* post, no rollback, non db2 diags*/


  end
end // end XSOBT1R

// update temp storage 1 - orders
Function XSOBT1U()



   /* update temporary storage 1*/

  TA5REC.TA5APPID = "OBF1"; /* appl identification*/
  TA5REC.TA5FNCCD = "U"; /* function code*/
  TA5REC.TA5TSQIX = OBWREC.OBWTSF1P; /* current page*/
  OBAREC.OBATSLEN = 700; /* length of record*/

  call "TA0050" (OBAREC, TA5REC) {isNoRefresh = yes, isExternal = yes}; /* temp storage subroutine*/

  if (TA5REC.TA5RTNCD == 0)
    /* next sentence*/
  else
    TA1REC.TA1LOCAT[1] = "UPD TS1";
    TA1REC.TA1LOCAT[2] = "TA0050"; /* io mod called*/
    TA1REC.TA1LOCAT[3] = TA5REC.TA5RTNCD; /* return code*/
    TA1REC.TA1TBLKE = OBAREC.OBATSROW[1]; /* first row, first rec*/
    TAEREC.TAEDESC1 = TA5REC.TA5DATA; /* subroutine parms*/
    XSOBENP(); /* post, no rollback, non db2*/


  end
end // end XSOBT1U

// write temp storage 1 -orders
Function XSOBT1W()



   /* write temporary storage 1*/

  TA5REC.TA5APPID = "OBF1"; /* appl identification*/
  TA5REC.TA5FNCCD = "A"; /* function code*/
  OBAREC.OBATSLEN = 700; /* length of record*/

  call "TA0050" (OBAREC, TA5REC) {isNoRefresh = yes, isExternal = yes}; /* temp storage subroutine*/

  if (TA5REC.TA5RTNCD == 0)
    OBWREC.OBWTSF1M = TA5REC.TA5TSQIX;
  else
    TA1REC.TA1LOCAT[1] = "ADD TS1";
    TA1REC.TA1LOCAT[2] = "TA0050"; /* io mod called*/
    TA1REC.TA1LOCAT[3] = TA5REC.TA5RTNCD; /* return code*/
    TA1REC.TA1TBLKE = OBAREC.OBATSROW[1]; /* first row, first rec*/
    TAEREC.TAEDESC1 = TA5REC.TA5DATA; /* subroutine parms*/
    XSOBENP(); /* post, no rollback, non db2*/


  end
end // end XSOBT1W

// update corrected errors
Function XSOBT2C()
     /* change the current select option to 'U'pdated when*/
     /* the prior application is OB0L - Order Errors and*/
     /* something was updated*/

  XSOBT2R();

  if (COMMAREA.CAFROMAP == "OB0L"
   && OBWREC.OBWTSF2S > 0)
    if (OBBREC.XXXPGMNO[OBWTSF2S] == COMMAREA.CACURRAP)
      OBBREC.OBBMSEL[OBWTSF2S] = "U";
      XSOBT2U();
    end
  end
end // end XSOBT2C

// purge temp storage 2 -errors
Function XSOBT2P()



   /* purge temporary storage 2*/

  TA5REC.TA5APPID = "OBF2"; /* appl identification*/
  TA5REC.TA5FNCCD = "P"; /* function code*/
  call "TA0050" (OBBREC, TA5REC) {isNoRefresh = yes, isExternal = yes}; /* temp storage subroutine*/

  if (TA5REC.TA5RTNCD == 0)
    OBWREC.OBWTSF2P = 1;
    OBWREC.OBWTSF2S = 1;
    OBWREC.OBWTSF2M = 1;
  else
    TA1REC.TA1LOCAT[1] = "PRGE TS2";
    TA1REC.TA1LOCAT[2] = "TA0050"; /* io mod called*/
    TA1REC.TA1LOCAT[3] = TA5REC.TA5RTNCD; /* return code*/
    TAEREC.TAEDESC1 = TA5REC.TA5DATA; /* subroutine parms*/
    XSOBENP(); /* post,  no rollback, non db2 diags*/


  end
end // end XSOBT2P

// read temp storage 2 - errors
Function XSOBT2R()



   /* read temporary storage 2*/

  set OBBREC empty;

  TA5REC.TA5APPID = "OBF2"; /* appl identification*/
  TA5REC.TA5FNCCD = "R"; /* function code*/
  TA5REC.TA5TSQIX = OBWREC.OBWTSF2P; /* current page*/
  OBBREC.OBBTSLEN = 873; /* length of record*/

  call "TA0050" (OBBREC, TA5REC) {isNoRefresh = yes, isExternal = yes}; /* temp storage subroutine*/

  if (TA5REC.TA5RTNCD == 0)
    /* next sentence*/
  else
    TA1REC.TA1LOCAT[1] = "READ TS2";
    TA1REC.TA1LOCAT[2] = "TA0050"; /* io mod called*/
    TA1REC.TA1LOCAT[3] = TA5REC.TA5RTNCD; /* return code*/
    TAEREC.TAEDESC1 = TA5REC.TA5DATA; /* subroutine parms*/
    XSOBENP(); /* post, no rollback, non db2 diags*/


  end
end // end XSOBT2R

// update temp storage 2 - errors
Function XSOBT2U()



   /* update temporary storage 2*/

  TA5REC.TA5APPID = "OBF2"; /* appl identification*/
  TA5REC.TA5FNCCD = "U"; /* function code*/
  TA5REC.TA5TSQIX = OBWREC.OBWTSF2P; /* current page*/
  OBBREC.OBBTSLEN = 873; /* length of record*/

  call "TA0050" (OBBREC, TA5REC) {isNoRefresh = yes, isExternal = yes}; /* temp storage subroutine*/

  if (TA5REC.TA5RTNCD == 0)
    /* next sentence*/
  else
    TA1REC.TA1LOCAT[1] = "UPD TS2";
    TA1REC.TA1LOCAT[2] = "TA0050"; /* io mod called*/
    TA1REC.TA1LOCAT[3] = TA5REC.TA5RTNCD; /* return code*/
    TAEREC.TAEDESC1 = TA5REC.TA5DATA; /* subroutine parms*/
    XSOBENP(); /* post, no rollback, non db2 diags*/


  end
end // end XSOBT2U

// write temp storage 2 - errors
Function XSOBT2W()



   /* write temporary storage 2*/

  TA5REC.TA5APPID = "OBF2"; /* appl identification*/
  TA5REC.TA5FNCCD = "A"; /* function code*/
  OBBREC.OBBTSLEN = 873; /* length of record*/

  call "TA0050" (OBBREC, TA5REC) {isNoRefresh = yes, isExternal = yes}; /* temp storage subroutine*/

  if (TA5REC.TA5RTNCD == 0)
    OBWREC.OBWTSF2M = TA5REC.TA5TSQIX;
  else
    TA1REC.TA1LOCAT[1] = "ADD TS2";
    TA1REC.TA1LOCAT[2] = "TA0050"; /* io mod called*/
    TA1REC.TA1LOCAT[3] = TA5REC.TA5RTNCD; /* return code*/
    TAEREC.TAEDESC1 = TA5REC.TA5DATA; /* subroutine parms*/
    XSOBENP(); /* post, no rollback, non db2 diags*/


  end
end // end XSOBT2W

// purge temp storage 3 - holds
Function XSOBT3P()



   /* purge temporary storage 3*/

  TA5REC.TA5APPID = "OBF3"; /* appl identification*/
  TA5REC.TA5FNCCD = "P"; /* function code*/

  call "TA0050" (OBCREC, TA5REC) {isNoRefresh = yes, isExternal = yes}; /* temp storage subroutine*/

  if (TA5REC.TA5RTNCD == 0)
    OBWREC.OBWTSF3P = 1;
    OBWREC.OBWTSF3S = 1;
    OBWREC.OBWTSF3M = 1;
  else
    TA1REC.TA1LOCAT[1] = "PRGE TS3";
    TA1REC.TA1LOCAT[2] = "TA0050"; /* io mod called*/
    TA1REC.TA1LOCAT[3] = TA5REC.TA5RTNCD; /* return code*/
    TAEREC.TAEDESC1 = TA5REC.TA5DATA; /* subroutine parms*/
    XSOBENP(); /* post,  no rollback, non db2 diags*/


  end
end // end XSOBT3P

// write temp storage 3 - holds
Function XSOBT3W()



   /* write temporary storage 3*/

  TA5REC.TA5APPID = "OBF3"; /* appl identification*/
  TA5REC.TA5FNCCD = "A"; /* function code*/
  OBCREC.OBCTSLEN = 884; /* length of record*/

  call "TA0050" (OBCREC, TA5REC) {isNoRefresh = yes, isExternal = yes}; /* temp storage subroutine*/

  if (TA5REC.TA5RTNCD == 0)
    OBWREC.OBWTSF3M = TA5REC.TA5TSQIX;
  else
    TA1REC.TA1LOCAT[1] = "ADD TS3";
    TA1REC.TA1LOCAT[2] = "TA0050"; /* io mod called*/
    TA1REC.TA1LOCAT[3] = TA5REC.TA5RTNCD; /* return code*/
    TAEREC.TAEDESC1 = TA5REC.TA5DATA; /* subroutine parms*/
    XSOBENP(); /* post, no rollback, non db2 diags*/


  end
end // end XSOBT3W

// purge temp storage 4 - items
Function XSOBT4P()



   /* purge temporary storage 4*/

  TA5REC.TA5APPID = "OBF4"; /* appl identification*/
  TA5REC.TA5FNCCD = "P"; /* function code*/

  call "TA0050" (OBDREC, TA5REC) {isNoRefresh = yes, isExternal = yes}; /* temp storage subroutine*/

  if (TA5REC.TA5RTNCD == 0)
    OBWREC.OBWTSF4P = 1;
    OBWREC.OBWTSF4S = 1;
    OBWREC.OBWTSF4M = 1;
  else
    TA1REC.TA1LOCAT[1] = "PRGE TS4";
    TA1REC.TA1LOCAT[2] = "TA0050"; /* io mod called*/
    TA1REC.TA1LOCAT[3] = TA5REC.TA5RTNCD; /* return code*/
    TAEREC.TAEDESC1 = TA5REC.TA5DATA; /* subroutine parms*/
    XSOBENP(); /* post,  no rollback, non db2 diags*/


  end
end // end XSOBT4P

// read temp storage 4 - items
Function XSOBT4R()



   /* read temporary storage 4*/

  set OBDREC empty;

  TA5REC.TA5APPID = "OBF4"; /* appl identification*/
  TA5REC.TA5FNCCD = "R"; /* function code*/
  TA5REC.TA5TSQIX = OBWREC.OBWTSF4P; /* current page*/
  OBDREC.OBDTSLEN = 604; /* length of record*/

  call "TA0050" (OBDREC, TA5REC) {isNoRefresh = yes, isExternal = yes}; /* temp storage subroutine*/

  if (TA5REC.TA5RTNCD == 0)
    /* next sentence*/
  else
    TA1REC.TA1LOCAT[1] = "READ TS4";
    TA1REC.TA1LOCAT[2] = "TA0050"; /* io mod called*/
    TA1REC.TA1LOCAT[3] = TA5REC.TA5RTNCD; /* return code*/
    TAEREC.TAEDESC1 = TA5REC.TA5DATA; /* subroutine parms*/
    XSOBENP(); /* post, no rollback, non db2 diags*/


  end
end // end XSOBT4R

// update temp storage 4 - items
Function XSOBT4U()



   /* update temporary storage 4*/

  TA5REC.TA5APPID = "OBF4"; /* appl identification*/
  TA5REC.TA5FNCCD = "U"; /* function code*/
  TA5REC.TA5TSQIX = OBWREC.OBWTSF4P; /* current page*/
  OBDREC.OBDTSLEN = 604; /* length of record*/

  call "TA0050" (OBDREC, TA5REC) {isNoRefresh = yes, isExternal = yes}; /* temp storage subroutine*/

  if (TA5REC.TA5RTNCD == 0)
    /* next sentence*/
  else
    TA1REC.TA1LOCAT[1] = "UPD TS4";
    TA1REC.TA1LOCAT[2] = "TA0050"; /* io mod called*/
    TA1REC.TA1LOCAT[3] = TA5REC.TA5RTNCD; /* return code*/
    TAEREC.TAEDESC1 = TA5REC.TA5DATA; /* subroutine parms*/
    XSOBENP(); /* post, no rollback, non db2 diags*/


  end
end // end XSOBT4U

// write temp storage 4 - items
Function XSOBT4W()



   /* write temporary storage 4*/

  TA5REC.TA5APPID = "OBF4"; /* appl identification*/
  TA5REC.TA5FNCCD = "A"; /* function code*/
  OBDREC.OBDTSLEN = 604; /* length of record*/

  call "TA0050" (OBDREC, TA5REC) {isNoRefresh = yes, isExternal = yes}; /* temp storage subroutine*/

  if (TA5REC.TA5RTNCD == 0)
    OBWREC.OBWTSF4M = TA5REC.TA5TSQIX;
  else
    TA1REC.TA1LOCAT[1] = "ADD TS4";
    TA1REC.TA1LOCAT[2] = "TA0050"; /* io mod called*/
    TA1REC.TA1LOCAT[3] = TA5REC.TA5RTNCD; /* return code*/
    TAEREC.TAEDESC1 = TA5REC.TA5DATA; /* subroutine parms*/
    XSOBENP(); /* post, no rollback, non db2 diags*/


  end
end // end XSOBT4W

// purge temp storage 5 - comnts
Function XSOBT5P()



   /* purge temporary storage 5*/

  TA5REC.TA5APPID = "OBF5"; /* appl identification*/
  TA5REC.TA5FNCCD = "P"; /* function code*/

  call "TA0050" (OBEREC, TA5REC) {isNoRefresh = yes, isExternal = yes}; /* temp storage subroutine*/

  if (TA5REC.TA5RTNCD == 0)
    OBWREC.OBWTSF5P = 1;
    OBWREC.OBWTSF5S = 1;
    OBWREC.OBWTSF5M = 1;
  else
    TA1REC.TA1LOCAT[1] = "PRGE TS5";
    TA1REC.TA1LOCAT[2] = "TA0050"; /* io mod called*/
    TA1REC.TA1LOCAT[3] = TA5REC.TA5RTNCD; /* return code*/
    TAEREC.TAEDESC1 = TA5REC.TA5DATA; /* subroutine parms*/
    XSOBENP(); /* post,  no rollback, non db2 diags*/


  end
end // end XSOBT5P

// purge temp storage (OBF6)
Function XSOBT6P()



   /* purge temporary storage 6*/

  TA5REC.TA5APPID = "OBF6"; /* appl identification*/
  TA5REC.TA5FNCCD = "P"; /* function code*/

  call "TA0050" (OBDREC, TA5REC) {isNoRefresh = yes, isExternal = yes}; /* temp storage subroutine*/

  if (TA5REC.TA5RTNCD == 0)
    OBWREC.OBWTSF6P = 1;
    OBWREC.OBWTSF6S = 1;
    OBWREC.OBWTSF6M = 1;
  else
    TA1REC.TA1LOCAT[1] = "PRGE TS6";
    TA1REC.TA1LOCAT[2] = "TA0050"; /* io mod called*/
    TA1REC.TA1LOCAT[3] = TA5REC.TA5RTNCD; /* return code*/
    TAEREC.TAEDESC1 = TA5REC.TA5DATA; /* subroutine parms*/
    XSOBENP(); /* post,  no rollback, non db2 diags*/
  end

end // end XSOBT6P

// read temp storage (OBF6)
Function XSOBT6R()


   /* read temporary storage 6*/

  set OBVREC empty;

  TA5REC.TA5APPID = "OBF6"; /* appl identification*/
  TA5REC.TA5FNCCD = "R"; /* function code*/
  TA5REC.TA5TSQIX = OBWREC.OBWTSF6P; /* current page*/
  OBVREC.OBVTSLEN = 873; /* length of record*/

  call "TA0050" (OBVREC, TA5REC) {isNoRefresh = yes, isExternal = yes}; /* temp storage subroutine*/

  if (TA5REC.TA5RTNCD == 0)
    /* next sentence*/
  else
    TA1REC.TA1LOCAT[1] = "READ TS6";
    TA1REC.TA1LOCAT[2] = "TA0050"; /* io mod called*/
    TA1REC.TA1LOCAT[3] = TA5REC.TA5RTNCD; /* return code*/
    TAEREC.TAEDESC1 = TA5REC.TA5DATA; /* subroutine parms*/
    XSOBENP(); /* post, no rollback, non db2 diags*/

  end

end // end XSOBT6R

// update temp storage (OBF6)
Function XSOBT6U()


   /* update temporary storage 6*/

  TA5REC.TA5APPID = "OBF6"; /* appl identification*/
  TA5REC.TA5FNCCD = "U"; /* function code*/
  TA5REC.TA5TSQIX = OBWREC.OBWTSF6P; /* current page*/
  OBDREC.OBDTSLEN = 873; /* length of record*/

  call "TA0050" (OBVREC, TA5REC) {isNoRefresh = yes, isExternal = yes}; /* temp storage subroutine*/

  if (TA5REC.TA5RTNCD == 0)
    /* next sentence*/
  else
    TA1REC.TA1LOCAT[1] = "UPD TS6";
    TA1REC.TA1LOCAT[2] = "TA0050"; /* io mod called*/
    TA1REC.TA1LOCAT[3] = TA5REC.TA5RTNCD; /* return code*/
    TAEREC.TAEDESC1 = TA5REC.TA5DATA; /* subroutine parms*/
    XSOBENP(); /* post, no rollback, non db2 diags*/
  end

end // end XSOBT6U

// error rtn for OP6410
Function XSOMS-OP6410-ERRTN()
   /* ************************************************/
   /* *                                             **/
   /* *    Error routine for calls to OP6410        **/
   /* *                                             **/
   /* ************************************************/
   /* ;*/
  set TAEREC empty;

    /* TA1REC - Data is displayed and written to error log*/


  TA1REC.TA1TYPE = "APPL"; /* abend type*/
  TA1REC.TA1FUNC = "RETN"; /* abend func*/
  TA1REC.TA1DBASE = OP10REC.OP10-RETURN-DBASE; /* data base*/
  TA1REC.TA1TBLVU = OP10REC.OP10-RETURN-TBLVU; /* table view*/
  TA1REC.TA1TBLKE = OP10REC.OP10-RETURN-KEY; /* key*/

   /* TAEREC - Data is only displayed on screen*/


  TAEREC.TAEDESC1 = "BAD RETURN FROM OP6410 - RETURN CODE";
  if (OP10REC.OP10-RETURN-CODE == "01")
    TAEREC.TAEDESC2 = "01 - INVALID COUNTRY CODE";
  else
    if (OP10REC.OP10-RETURN-CODE == "03")
      TAEREC.TAEDESC2 = "03 - DEADLOCK OCCURED";
    else
      if (OP10REC.OP10-RETURN-CODE == "04")
        TAEREC.TAEDESC2 = "04 - FATAL ERROR IN OP6410";
      else
        if (OP10REC.OP10-RETURN-CODE == "05")
          TAEREC.TAEDESC2 = "05 - INVALID APPLICATION NAME";
        else
          if (OP10REC.OP10-RETURN-CODE == "06")
            TAEREC.TAEDESC2 = "06 - ROW NOT FOUND";
          else
            TAEREC.TAEDESC2 = "UNKNOWN ERROR";
          end
        end
      end
    end
  end


  VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
  VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
  sysLib.rollback();
  VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
   /* syncpoint rollback*/
  try
    call "TA0020" (TA1REC, TAEREC) {isExternal = yes};
  end /* abend module*/
  COMMAREA.CA-USER-WORKAREA-4K = " ";
  COMMAREA.CACURRAP = "OM0M";
  transfer to program "OM0M" passing COMMAREA;
end // end XSOMS-OP6410-ERRTN

// error message display
Function XSOMS-OP6410-PSRTN()

    /* *******************************************************/
    /* online post routine for OM system                    */
    /* *******************************************************/
    /* This routine is executed when the return code from the*/
    /* NIKEBOTH-OP6410 is '03'. It posts the errors          */
    /* appropriately                                         */
    /* *******************************************************/

  TA1REC.TA1TYPE = "DB2"; /* abend type*/
  TA1REC.TA1FUNC = "POST"; /* abend func*/
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1DBASE = OP10REC.OP10-RETURN-DBASE;
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1DBASE = OP10REC.OP10-RETURN-DBASE;
  TA1REC.TA1TBLVU = OP10REC.OP10-RETURN-TBLVU;
  TA1REC.TA1TBLKE = OP10REC.OP10-RETURN-KEY;
  set ERRSQLCA empty; /* clear area*/
  move SQLCA to ERRSQLCA withV60Compat; /* save orig sqlca*/
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes}; /* abend module*/

end // end XSOMS-OP6410-PSRTN

// o/m system security
Function XSOMS01()



      /* *********************************************************/
      /* * retrieve o/m commarea and check order maint security **/
      /* *********************************************************/


  OMWREC.OMWSGRP = COMMAREA.CA-USER-WORKAREA-4K; /* get o/m commarea*/


  if (OMWREC.OMWINIT != "OM0") /* check o/m security*/
    transfer to program "OM0M" passing COMMAREA; /* xfer if not properly initialized*/
    exit program;
  end



   /* *************************************************************/
end // end XSOMS01

// o/e system security
Function XSOMS05()



      /* *********************************************************/
      /* * retrieve o/e commarea and check order entry security **/
      /* *********************************************************/


  OMWREC.OMWSGRP = COMMAREA.CA-USER-WORKAREA-4K; /* get o/e commarea*/


  if (OMWREC.OMWINIT != "OM0") /* check o/e security*/
    transfer to program "OM0M" passing COMMAREA; /* xfer if not properly initialized*/
    exit program;
  end



   /* *************************************************************/
end // end XSOMS05

// OP6410 Error routine
Function XSOPS-OP6410-ERRTN()
   /* TT#4654  RSHAIK  03/15/2000*/
            /* ********************************************************/
             /* * error routine for calls to op6410                   **/
             /* ********************************************************/

  set TAEREC empty;
   /* TA1REC  - Data is displayed and written to error log*/
  TA1REC.TA1TYPE = "APPL"; /* abend type*/
  TA1REC.TA1FUNC = "RETN"; /* abend func*/
  TA1REC.TA1DBASE = OP10REC.OP10-RETURN-DBASE; /* data base*/
  TA1REC.TA1TBLVU = OP10REC.OP10-RETURN-TBLVU; /* table view*/
  TA1REC.TA1TBLKE = OP10REC.OP10-RETURN-KEY; /* key*/

    /* TAEREC - Data is only displayed on screen*/

  TAEREC.TAEDESC1 = "BAD RETURN FROM OP6410 - RETURN CODE";
  if (OP10REC.OP10-RETURN-CODE == "03")
    TAEREC.TAEDESC2 = "03 - DEAD LOCK OCCURED";
  else
    if (OP10REC.OP10-RETURN-CODE == "04")
      TAEREC.TAEDESC2 = "04 - FATAL ERROR";
    else
      if (OP10REC.OP10-RETURN-CODE == "05")
        TAEREC.TAEDESC2 = "05 - INVALID PASSING APPL";
      else
        if (OP10REC.OP10-RETURN-CODE == "06")
          TAEREC.TAEDESC2 = "06 - ROW NOT FOUND";
        else
          TAEREC.TAEDESC2 = "UNKNOWN ERROR";
        end
      end
    end
  end
  VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
  VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
  sysLib.rollback();
  VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
  
  try
    call "TA0020" (TA1REC, TAEREC) {isExternal = yes};
  end /* abend module*/
  COMMAREA.CA-USER-WORKAREA-4K = " "; /* clear user commarea*/
  XSPF4(); /* master menu*/
  exit program; /* master menu failure*/

end // end XSOPS-OP6410-ERRTN

// o/e system security
Function XSOPS01()



      /* *********************************************************/
      /* * retrieve o/e commarea and check order entry security **/
      /* *********************************************************/


  OPWREC.OPWSGRP = COMMAREA.CA-USER-WORKAREA-4K; /* get o/e commarea*/


  if (OPWREC.OPWINIT != "OP0") /* check o/e security*/
    transfer to program "OP0A" passing COMMAREA; /* xfer if not properly initialized*/
    exit program;
  end



   /* *************************************************************/
end // end XSOPS01

// abort routine
Function XSOPS02()



      /* *********************************************************/
      /* * online abort routine for op system                   **/
      /* *********************************************************/

  TA1REC.TA1TYPE = "DB2"; /* abend type*/
  TA1REC.TA1FUNC = "RETN"; /* abend func*/
  set ERRSQLCA empty; /* clear area*/
  move SQLCA to ERRSQLCA withV60Compat; /* save orig sqlca*/
  VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
  VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
  sysLib.rollback();
  VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
   /* synpoint rollback*/
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes}; /* abend module*/
  COMMAREA.CA-USER-WORKAREA-4K = " "; /* clear user commarea*/
  XSPF4(); /* master menu*/
  exit program; /* master menu failure*/



   /* *************************************************************/
end // end XSOPS02

// Exit to another application
Function XSOZ-S0001()
  /* ------------------------------------------------------------*/
  /* Set the application to be invoked for PF1 or PF4.*/
  /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf1) /* PF1 was pressed*/
    COMMAREA.CATOAP = "GD00"; /* Indicate Goal Documentation*/
  end

  if (converseVar.eventKey is pf4) /* PF4 was pressed*/
    COMMAREA.CATOAP = "MN0M"; /* Indicate Master Menu*/
  end

  /* ------------------------------------------------------------*/
  /* Save the application user area in the COMMAREA.*/
  /* ------------------------------------------------------------*/

  if (COMMAREA.CATOSYS == COMMAREA.CACURSYS) /* Same system*/

    COMMAREA.CAUSERA = OZWREC.CAUSERA; /* Save user area*/
  else
    COMMAREA.CAUSERA = " "; /* Clear user area*/

  end

  /* ------------------------------------------------------------*/
  /* Transfer control to the specified application.*/
  /* ------------------------------------------------------------*/

  XSEXIT(); /* Exit to another application*/

  /* ------------------------------------------------------------*/
  /* Reestablish the COMMAREA application and item fields.*/
  /* ------------------------------------------------------------*/

  COMMAREA.CAEZSG3 = "0"; /* Force zero third character*/
  COMMAREA.CACURRAP = COMMAREA.CAEZSAP; /* CURR application*/

  if (converseVar.eventKey is pfkey) /* PF key was pressed*/

    COMMAREA.CATOAP = " "; /* Clear TO application*/

    if (converseVar.eventKey is pf1) /* PF1 was pressed*/
      COMMAREA.CAITEM = " "; /* Clear map name from item*/
    end

  end

  /* ------------------------------------------------------------*/
  /* Indicate error if transfer failed.*/
  /* ------------------------------------------------------------*/

  if (COMMAREA.CASECRC == 3 /* Application not found*/
   || COMMAREA.CASECRC == 4) /* or transfer not allowed*/

    converseLib.validationFailed(6); /* Indicate not allowed*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/

  end


end // end XSOZ-S0001

// Exit to another application
Function XSPAS01()
   /* ------------------------------------------------------------*/
   /* Set the application to be invoked for PF1 or PF4.*/
   /* Set the application to be invoked for PF3 if in pa0m.*/
   /* Save the application user area in the COMMAREA.*/
   /* Transfer control to the specified application.*/
   /* If transfer failed, return an error to the calling process.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf1) /* PF1 was pressed*/

    COMMAREA.CATOAP = "GD00"; /* Indicate Goal Documentation*/

  end

  if (converseVar.eventKey is pf3) /* PF3 was pressed*/
    if (COMMAREA.CACURRAP == "PA0M") /* and Order Adjustments Menu*/

      COMMAREA.CATOAP = "FY0M"; /* Indicate Production Menu*/

    else
      if (PAWREC.PAWDRVR > " ")
       /* MOVE 'PA0E' TO COMMAREA.CATOAP;    /* LISTS RETURN TO 'E'*/
        COMMAREA.CATOAP = PAWREC.PAWDRVR; /* GO BACK TO LIST SCREEN*/
        PAWREC.PAWDRVR = " ";
      else
        COMMAREA.CATOAP = "PA0M"; /* NON LISTS TO 'PA' MENU*/
      end

    end

  end

  if (converseVar.eventKey is pf4) /* PF4 was pressed*/

    COMMAREA.CATOAP = "MN0M"; /* Indicate Master Menu*/

  end

  if (COMMAREA.CATOSYS == "PA") /* Transfer within Order Adjustments*/

    COMMAREA.CAUSERA = PAWREC.CAUSERA; /* Save user area*/
  else
    COMMAREA.CAUSERA = " "; /* Clear user area*/

  end

  COMMAREA.CAFROMAP = COMMAREA.CACURRAP; /* From application*/
  XSEXIT(); /* Exit to another application*/

  COMMAREA.CAITEM = " "; /* Clear any application data*/

  if (COMMAREA.CASECRC == 3 /* Application not found*/
   || COMMAREA.CASECRC == 4) /* or transfer not allowed*/

    converseLib.validationFailed(6); /* Indicate not allowed*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/

  end


end // end XSPAS01

// Common pf12 processing
Function XSPAS04()
   /* ------------------------------------------------------------*/
   /* This procedure is to be performed whenever pf12 is pressed.*/
   /* It will determine whether or not the current application*/
   /* is to exit to a driver application or remain where it is.*/
   /* ------------------------------------------------------------*/

  if (PAWREC.PAWDRVR > " ") /* IS THERE A LIST?*/
    PAWREC.PAWOAIDX = PAWREC.PAWOAIDX + 1; /* Add 1 to o/a index*/

    if (PAWREC.PAWOAIDX > 25 /* If out of bounds*/
     || PAWREC.PA1OANBR[PAWOAIDX] == 0) /* or no more o/a's*/
      PAWREC.PAWOANBR = 0; /* Clear current o/a nbr field*/
      PAWREC.XXXMODID = "S04"; /* error routine*/
      PAWREC.XXXMSGNO = 48; /* no more o/a's*/
      COMMAREA.CATOAP = PAWREC.PAWDRVR;
      PAWREC.PAWDRVR = " ";
      COMMAREA.CAUSERA = PAWREC.CAUSERA;
      XSEXIT(); /* Go to it*/
      return;

    else
      PAWREC.PAWOANBR = PAWREC.PA1OANBR[PAWOAIDX]; /* Current number*/

    end

  else
    PAWREC.PAWOANBR = 0;
  end

  COMMAREA.CAUSERA = PAWREC.CAUSERA;
  COMMAREA.CATOAP = COMMAREA.CACURRAP; /* Set the catoap*/
  XSEXIT(); /* Go to it*/
  PAWREC.XXXMODID = "S04"; /* error routine*/
  converseLib.validationFailed(6); /* Set error message*/



end // end XSPAS04

// select set for dmodel.vfmodm01
Function XSPAS06()
   /* ------------------------------------------------------------*/
   /* SELECT SET FOR DMODEL.VFMODM01*/
   /* ------------------------------------------------------------*/


   /* ------------------------------------------------------------*/
   /* Select and open the cursor for the set to be formatted.*/
   /* ------------------------------------------------------------*/

   /* ------------------------------------------------------------*/
   /* Select the requested set of rows from the table.*/
   /* ------------------------------------------------------------*/

  /*  */
  /* *************************** Y2K OUT BEGIN ****************************/
  /*  */
  /* CALL IO3110 PAKREC,SQLCA,PT5REC (NOMAPS,NONCSP,REPLY; /* Select set*/
  /*  */
  /* *************************** Y2K OUT END ******************************/
  /*  */
  /*  */
  /* *************************** Y2K IN BEGIN *****************************/
  /*  */
  try
    call "VFBASM04" (PAKREC, SQLCA, PT5REC) {isNoRefresh = yes, isExternal = yes};
  end /* Select set*/
  /*  */
  /* *************************** Y2K IN END *******************************/
  /*  */

   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/
    if (SQLCA.VAGen_SQLCODE == 0 /* and normal return code*/
     || SQLCA.VAGen_SQLCODE == 100)

      return; /* Return to previous process*/

    end
  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  PAWREC.XXXMODID = "S06"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(10); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/


  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "SELECT SET OF TABLE ROWS";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = PAWREC.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DMODEL  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VFBASM01"; /* Table view name*/
  TA1REC.TA1TBLKE = PT5REC.PT5KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/


  exit stack; /* Exit to display map*/


end // end XSPAS06

// FETCH ROW FROM DMODEL.VFMODM01
Function XSPAS07()
   /* ------------------------------------------------------------*/
   /* FETCH A ROW FROM DMODEL.VFMODM01*/
   /* ------------------------------------------------------------*/


  /* *************************** Y2K OUT BEGIN *****************************/
  /*  */
  /* CALL IO3110 'N1',SQLCA,PT5REC (NOMAPS,NONCSP,REPLY; /* Select set*/
  /*  */
  /* *************************** Y2K OUT END *******************************/
  /*  */
  /*  */
  /* *************************** Y2K IN BEGIN *****************************/
  /*  */
  try
    call "VFBASM04" ("N1", SQLCA, PT5REC) {isNoRefresh = yes, isExternal = yes};
  end /* Select set*/
  /*  */
  /* *************************** Y2K IN END *******************************/

   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/
    if (SQLCA.VAGen_SQLCODE == 0 /* and normal return code*/
     || SQLCA.VAGen_SQLCODE == 100)

      return; /* Return to previous process*/

    end
  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  PAWREC.XXXMODID = "S06"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(10); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/


  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "SELECT SET OF TABLE ROWS";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = PAWREC.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DMODEL  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VFBASM01"; /* Table view name*/
  TA1REC.TA1TBLKE = PT5REC.PT5KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/


  exit stack; /* Exit to display map*/


end // end XSPAS07

// CLOSE SET FOR DMODEL.VFMODM01
Function XSPAS08()
   /* ------------------------------------------------------------*/
   /* CLOSE       FROM DMODEL.VFMODM01*/
   /* ------------------------------------------------------------*/

  /* *************************** Y2K OUT BEGIN ****************************/
  /*  */
  /* CALL IO3110 'C1',SQLCA,PT5REC (NOMAPS,NONCSP,REPLY; /* Select set*/
  /*  */
  /* *************************** Y2K OUT END ******************************/
  /*  */
  /*  */
  /* *************************** Y2K IN BEGIN *****************************/
  /*  */
  try
    call "VFBASM04" ("C1", SQLCA, PT5REC) {isNoRefresh = yes, isExternal = yes};
  end /* Select set*/
  /*  */
  /* *************************** Y2K IN END *******************************/
  /*  */

   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/
    if (SQLCA.VAGen_SQLCODE == 0) /* and normal return code*/

      return; /* Return to previous process*/

    end
  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  PAWREC.XXXMODID = "S08"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(10); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/


  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "SELECT SET OF TABLE ROWS";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = PAWREC.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DMODEL  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VFBASM01"; /* Table view name*/
  TA1REC.TA1TBLKE = PT5REC.PT5KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/


  exit stack; /* Exit to display map*/


end // end XSPAS08

// Close  (C3) Set       VCPLHDJ4
Function XSPCS-VCPLHDJ4-C7()
   /* ------------------------------------------------------------*/
   /* Close the selected set of table rows.*/
   /* ------------------------------------------------------------*/

  call "VCPLHDJ4" ("C7", SQLCA, VCPLHDJ4);
   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  PC5REC.XXXPRCNM = "XSPCS23"; /* Module identification*/
  converseLib.validationFailed(10); /* Indicate system error*/

  TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "CLOSE SELECTED SET OF TABLE ROWS";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNM = "XSPCS23"; /* Program number*/
  TA1REC.TA1DBASE = "DTRANS  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCPLHDJ4"; /* Table view name*/

  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


   /* **                                                        ***/
   /* ********************** End of XSPCS23 ***********************/
end // end XSPCS-VCPLHDJ4-C7

// Fetch  (N3) Next row  VCPLHDJ4
Function XSPCS-VCPLHDJ4-N7()
   /* ------------------------------------------------------------*/
   /* Fetch the next row to display from the table.*/
   /* ------------------------------------------------------------*/

  try
    call "VCPLHDJ4" ("N7", SQLCA, VCPLHDJ4) {isNoRefresh = yes, isExternal = yes};
  end /* Fetch next row*/

   /* ------------------------------------------------------------*/
   /* If successful, accumulate the  "Total Shipped Quantites"*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/

    if (SQLCA.VAGen_SQLCODE == 0) /* Normal return code*/

      return; /* Return to previous process*/

    end

    /* ------------------------------------------------------------*/
     /* If end of selected set, indicate end of cursor.*/
    /* ------------------------------------------------------------*/

    if (SQLCA.VAGen_SQLCODE == 100) /* End of selected set*/

      PC5REC.PC5WSWT = "Y"; /* Indicate end of temp cursor "CPLHD"*/

      return; /* Return to previous process*/

    end

  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  PC5REC.XXXPRCNM = "XSPCS22"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "FETCH NEXT TABLE ROW";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNM = "XSPCS22"; /* Program number*/
  TA1REC.TA1DBASE = "DTRANS  "; /* ===> Data base name*/
  TA1REC.TA1TBLVU = "VCPLHDJ4"; /* ===> Table view name*/


  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


   /* **                                                        ***/
   /* ********************** End of XSPCS22 ***********************/
end // end XSPCS-VCPLHDJ4-N7

// Select (S3) Set/Open  VCPLHDJ4
Function XSPCS-VCPLHDJ4-S7()
   /* ------------------------------------------------------------*/
   /* Select the requested set of rows from the table.*/
   /* ------------------------------------------------------------*/

  call "VCPLHDJ4" ("S7", SQLCA, VCPLHDJ4);
   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  PC5REC.XXXPRCNM = "XSPCS21"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/


  end


  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "SELECT SET OF TABLE ROWS";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNM = PC5REC.XXXPRCNM; /* Program number*/
  TA1REC.TA1DBASE = "DTRANS  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCPLHDJ4"; /* Table view name*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


   /* **                                                        ***/
   /* ********************** End of XSPCS21 ***********************/
end // end XSPCS-VCPLHDJ4-S7

// Close  (C8) Set       VFYPO002
Function XSPCS-VFYPO002-C8()
   /* ------------------------------------------------------------*/
   /* Close cursor for VFYPO002*/
   /* ------------------------------------------------------------*/

  try
    call "VFYPO002" ("C8", SQLCA, VFYPO002) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/
    return;
  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  end

  PC5REC.XXXPRCNM = "XSPCS73"; /* ===> process identification*/

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "XSPCS73"; /* Process name*/
  TA1REC.TA1LOC = "CLOSE CURSOR            ";
  TA1REC.TA1DBASE = "DPRODC  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VFYPO002"; /* Table view name*/
  TA1REC.TA1TBLKE = VFYPO002.VFYPO002-KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack;

   /* **                                                        ***/
   /* ********************** End of XSPCS73 ***********************/
end // end XSPCS-VFYPO002-C8

// Fetch  (N8) Next row  VFYPO002
Function XSPCS-VFYPO002-N8()
   /* ------------------------------------------------------------*/
   /* If row not found return to previous process.*/
   /* If any other, indicate system error.*/
   /* ------------------------------------------------------------*/

  try
    call "VFYPO002" ("N8", SQLCA, VFYPO002) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Row found*/
      return;
    end
    if (SQLCA.VAGen_SQLCODE == 100) /* Row not found*/
      PC5REC.PC5WSWT = "Y"; /* Indicate temp cursor at EOF*/
      return;
    end

  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  end

  PC5REC.XXXPRCNM = "XSPCS72";

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "XSPCS72"; /* Process name*/
  TA1REC.TA1LOC = "FETCH ROW               ";
  TA1REC.TA1DBASE = "DPRODC  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VFYPO002"; /* Table view name*/
  TA1REC.TA1TBLKE = VFYPO002.VFYPO002-KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack;


   /* **                                                        ***/
   /* ********************** End of XSPCS72 ***********************/
end // end XSPCS-VFYPO002-N8

// Select (S8) Set/Open  VFYPO002
Function XSPCS-VFYPO002-S8()
   /* ------------------------------------------------------------*/
    /* Call on the Select Set Open cursor*/
   /* ------------------------------------------------------------*/

  try
    call "VFYPO002" ("S8", SQLCA, VFYPO002) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/
    return;
  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  end

  PC5REC.XXXPRCNM = "XSPCS71"; /* Process name*/

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "XSPCS71"; /* Process name*/
  TA1REC.TA1LOC = "DECLARE CURSOR          ";
  TA1REC.TA1DBASE = "DPRODC  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VFYPO002"; /* Table view name*/
  TA1REC.TA1TBLKE = VFYPO002.VFYPO002-KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack;


   /* **                                                        ***/
   /* ********************** End of XSPCS71 ***********************/
end // end XSPCS-VFYPO002-S8

// Close  (CH) Set       VPOITM05
Function XSPCS-VPOITM05-CH()
   /* ------------------------------------------------------------*/
   /* Close the selected set of table rows.*/
   /* ------------------------------------------------------------*/

  if (PC5REC.XGPCD == "02")
    PCYREC.PCYFUNC = "CI";
  else
    PCYREC.PCYFUNC = "CH";
  end

  try
    call "VPOITM05" (PCYREC, SQLCA, VPOITM05) {isNoRefresh = yes, isExternal = yes};
  end /* Close table*/

   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback(); /* ===> roll back all changes*/

  PC5REC.XXXPRCNM = "XSPCSCH"; /* Module identification*/
  converseLib.validationFailed(10); /* Indicate system error*/

  TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "CLOSE SELECTED SET OF TABLE ROWS";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNM = "XSPCSCH"; /* Program number*/
  TA1REC.TA1DBASE = "DPRODC  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VPOITM05"; /* Table view name*/

  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


   /* **                                                        ***/
   /* ********************** End of XSPCS84 ***********************/
end // end XSPCS-VPOITM05-CH

// Fetch  (NH) Next row  VPOITM05
Function XSPCS-VPOITM05-NH()
   /* ------------------------------------------------------------*/
   /* Fetch the next row to display from the table.*/
   /* ------------------------------------------------------------*/

  if (PC5REC.XGPCD == "02")
    PCYREC.PCYFUNC = "NI";
  else
    PCYREC.PCYFUNC = "NH";
  end

  try
    call "VPOITM05" (PCYREC, SQLCA, VPOITM05) {isNoRefresh = yes, isExternal = yes};
  end /* Fetch next*/

   /* ------------------------------------------------------------*/
   /* If successful, check for multiple styles*/
                /* , save the data in pcwrec storage.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/

    if (SQLCA.VAGen_SQLCODE == 0) /* Normal return code*/

      return;

    end

    /* ------------------------------------------------------------*/
     /* If end of selected set, indicate end of cursor.*/
    /* ------------------------------------------------------------*/

    if (SQLCA.VAGen_SQLCODE == 100) /* End of selected set*/


      PC5REC.PC5WSWT = "Y"; /* Indicate end of cursor*/

      return; /* Return to previous process*/

    end

  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/
  PC5REC.XXXPRCNM = "XSPCSNH"; /* Module identification*/

  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback(); /* ===> rollback all changes*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/


  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "FETCH NEXT TABLE ROW";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNM = "XSPCS82"; /* Program number*/
  TA1REC.TA1DBASE = "DPRODC  "; /* ===> Data base name*/
  TA1REC.TA1TBLVU = "VPOITM01"; /* ===> Table view name*/

  TA1REC.TA1TBLKE = VPOITM05.VPOITM05-KEY; /* ===>Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


   /* **                                                        ***/
   /* ********************** End of XSPCS82 ***********************/
end // end XSPCS-VPOITM05-NH

// Select (SH) Set/Open  VPOITM05
Function XSPCS-VPOITM05-SH()
   /* ------------------------------------------------------------*/
   /* Select the requested set of rows from the table.*/
   /* ------------------------------------------------------------*/

  if (PC5REC.XGPCD == "02")
    PCYREC.PCYFUNC = "SI";
  else
    PCYREC.PCYFUNC = "SH";
  end

  try
    call "VPOITM05" (PCYREC, SQLCA, VPOITM05) {isNoRefresh = yes, isExternal = yes};
  end /* Select table*/

   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/


  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  PC5REC.XXXPRCNM = "XSPCS81"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/


  end


  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "SELECT SET OF TABLE ROWS";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNM = "XSPCSSH"; /* Program number*/
  TA1REC.TA1DBASE = "DPRODC  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VPOITM05"; /* Table view name*/
  TA1REC.TA1TBLKE = VPOITM05.VPOITM05-KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


   /* **                                                        ***/
   /* ********************** End of XSPCS81 ***********************/
end // end XSPCS-VPOITM05-SH

// Exit to another application
Function XSPCS01()
   /* ------------------------------------------------------------*/
   /* Set the application to be invoked for PF1 or PF4.*/
   /* Set the application to be invoked for PF3 if in PC0A.*/
   /* Save the application user area in the COMMAREA.*/
   /* Transfer control to the specified application.*/
   /* If transfer failed, return an error to the calling process.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf1) /* PF1 was pressed*/

    COMMAREA.CATOAP = "GD00"; /* Indicate Goal Documentation*/

  end

  if (converseVar.eventKey is pf3 /* PF3 was pressed*/
   && COMMAREA.CACURRAP == "PC0A") /* and Production Order Menu*/

    COMMAREA.CATOAP = "FY0M"; /* Indicate Production Menu*/

  end

  if (converseVar.eventKey is pf3 /* PF3 was pressed*/
   && COMMAREA.CACURRAP == "FY0M") /* and Production Menu*/

    COMMAREA.CATOAP = "MN0M"; /* Indicate Master Menu*/

  end

  if (converseVar.eventKey is pf3 /* PF3 was pressed*/
   && COMMAREA.CACURRAP == "PC0X") /* and Production report menu*/

    COMMAREA.CATOAP = "PC0A"; /* Indicate production menu*/

  end

  if (converseVar.eventKey is pf4) /* PF4 was pressed*/

    COMMAREA.CATOAP = "MN0M"; /* Indicate Master Menu*/

  end

  if (converseVar.eventKey is pf5) /* PF5 was pressed*/

    COMMAREA.CATOAP = "FY0M"; /* Indicate production menu*/

  end

  if (COMMAREA.CATOSYS == "PC" /* Transfer within Production Order*/
   || COMMAREA.CATOSYS == "PB" /* Transfer within Production Order*/
   || COMMAREA.CATOSYS == "LC" /* Transfer within Production Order*/
   || COMMAREA.CATOSYS == "TS") /* Transfer to transportation*/
    COMMAREA.CAUSERA = PCWREC.CAUSERA; /* Save user area*/
  else
    COMMAREA.CAUSERA = " "; /* Clear user area*/

  end

  COMMAREA.CAFROMAP = COMMAREA.CACURRAP; /* From application*/
  XSEXIT(); /* Exit to another application*/

  COMMAREA.CAITEM = " "; /* Clear any application data*/

  if (COMMAREA.CASECRC == 3 /* Application not found*/
   || COMMAREA.CASECRC == 4) /* or transfer not allowed*/

    converseLib.validationFailed(6); /* Indicate not allowed*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/

  end


end // end XSPCS01

// Validate The Division Group
Function XSPCS02()

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* This subroutine accesses the Division Group Table*/
   /* and returns the first row found for a Division Group code.*/

   /* YSMSUMCD must be specified by the calling process*/
   /* in YSMREC.  The name of the calling process must be moved*/
   /* to TA1PGMNM in TA1REC, for Error Diagnosis Reporting.*/

   /* This subroutine will return the CSP return code in EZERT8,*/
   /* the DB2 return code in SQLCA.SQLCODE and, if a normal*/
   /* return, the table row in YSMREC.*/

   /* This subroutine will do any required Error Diagnosis*/
   /* Reporting to TA0020.  The calling process must check the*/
   /* return codes and take the appropriate action relating to*/
   /* its terminal output.  The calling process does not need to*/
   /* do any Error Diagnosis Reporting.*/

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* ------------------------------------------------------------*/
   /* Select the set of rows from Division Group Table.*/
   /* ------------------------------------------------------------*/

  YSMREC.YSMTBLPF = "XDV";
  YSMREC.YSMSYSPF = "FF";
  YSMREC.YSMSUMID = 1;
  YSMREC.YSMSRCVL = "****";

  try
    call "IO2640" ("S1", SQLCA, YSMREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select table set*/

   /* ------------------------------------------------------------*/
   /* If successful, continue to fetch the first selected row.*/
   /* If data not available, post an error message and return.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/

     /* NEXT SENTENCE               ; Next sentence*/

  else

    TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
    TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

    TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
    TA1REC.TA1LOC = "XSPC002 SELECT DIVISION GROUP SET";
    TA1REC.TA1DBASE = "DCORP  "; /* Data base name*/
    TA1REC.TA1TBLVU = "VSUMCD01"; /* Table view name*/
    TA1REC.TA1TBLKE = YSMREC.YSMGRP; /* Table key*/

    if (sysVar.errorCode == "00000000" /* Call successful*/
     && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

      TA1REC.TA1FUNC = "POST"; /* Termination function*/
      call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    else

      TA1REC.TA1FUNC = "RETN"; /* Termination function*/
      call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

    end

    sysVar.errorCode = TA1REC.TA1MAP; /* CSP return code*/
    SQLCA.SQLCAREC = TAEREC.SQLCAREC; /* SQL commarea*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* Fetch the first row from Division Group Table.*/
   /* ------------------------------------------------------------*/

  try
    call "IO2640" ("N1", SQLCA, YSMREC) {isNoRefresh = yes, isExternal = yes};
  end /* Fetch table row*/

   /* ------------------------------------------------------------*/
   /* Save the CSP return code and SQL commarea from the fetch.*/
   /* If successful or row not found, continue to close the set.*/
   /* If data not available, post an error message and return.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/

     /* NEXT SENTENCE               ; Next sentence*/

  else

    if (sysVar.errorCode == "00000000" /* Call successful*/
     && SQLCA.VAGen_SQLCODE == 100)    /* and row not found*/

       /* NEXT SENTENCE               ; Next sentence*/

    else

      TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
      TA1REC.TA1LOC = "XSPC002 FETCH FIRST DIVISION GROUP";
      TA1REC.TA1DBASE = "DCORP  "; /* Data base name*/
      TA1REC.TA1TBLVU = "VSUMCD01"; /* Table view name*/
      TA1REC.TA1TBLKE = YSMREC.YSMGRP; /* Table key*/

      if (sysVar.errorCode == "00000000" /* Call successful*/
       && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

        TA1REC.TA1FUNC = "POST"; /* Termination function*/
        call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes};
                                   /* Error diagnosis routine*/

      else

        TA1REC.TA1FUNC = "RETN"; /* Termination function*/
        call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

      end

      sysVar.errorCode = TA1REC.TA1MAP; /* CSP return code*/
      SQLCA.SQLCAREC = TAEREC.SQLCAREC; /* SQL commarea*/

      return; /* Return to previous process*/

    end

  end

   /* ------------------------------------------------------------*/
   /* Close the set of rows from Division Group Table.*/
   /* ------------------------------------------------------------*/

  try
    call "IO2640" ("C1", SQLCA, YSMREC) {isNoRefresh = yes, isExternal = yes};
  end /* Close table set*/

   /* ------------------------------------------------------------*/
   /* If successful, continue to return to the calling process.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/

     /* NEXT SENTENCE               ; Next sentence*/

  else

    TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
    TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

    TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
    TA1REC.TA1LOC = "XSPC002 CLOSE DIVISION GROUP SET";
    TA1REC.TA1DBASE = "DCORP  "; /* Data base name*/
    TA1REC.TA1TBLVU = "VSUMCD01"; /* Table view name*/
    TA1REC.TA1TBLKE = YSMREC.YSMGRP; /* Table key*/

    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

  end

   /* ------------------------------------------------------------*/
   /* Restore the CSP return code and SQL commarea.*/
   /* ------------------------------------------------------------*/

  sysVar.errorCode = TA1REC.TA1MAP; /* CSP return code*/
  SQLCA.SQLCAREC = TAEREC.SQLCAREC; /* SQL commarea*/


end // end XSPCS02

// get fob prices routine
Function XSPCS04()
   /* ------------------------------------------------------------*/

                    /* X S P C 0 0 4*/

    /* This statement group will be called to obtain the FOB*/
    /* prices.  The key fields used in FY4REC and FYCREC to*/
    /* access the DFCTY.VFYFOB01 table and in VFCTY003 to*/
    /* access the DFCTY.VFCTY003 table should be passed in the*/
    /* PCOREC. VFCTY003, VFCTY003 and PCOREC must be added to your*/
    /* application record list.*/
      /* The following fields must be moved to the PCOREC:*/
          /* xgpcd*/
          /* fy1fctyc*/
          /* sy1stnbr*/
          /* sy2clrid*/
          /* xdmcd*/
          /* xqacd*/
          /* xsdcd*/
          /* xumcd*/
          /* xpgcd*/
          /* xsecd*/
          /* pc3poidt*/
          /* xsnyr*/
          /* pc3crdt*/

    /* If the price is found the PCOREC.PCORECPF (price*/
    /* flag) will be set to 'y'.  If the price is not*/
    /* found it will be set to 'n'. This flag can be used*/
    /* by your application as part of your FOB price*/
    /* processing logic.*/

    /* The FOB price (either regular or B grade) will be*/
    /* returned in the PCOREC.FY4fOBPR array.*/

    /* Any bad DB2 return codes will be handled by the*/
    /* executed statement groups.*/

    /* 01/30/92 default xpg-pkg-typ to '00' (xspcs52)*/
    /* 06/23/92 lsutto   round b-grade price calc*/
    /* 04/26/93 lsutto   look for i-seg specific fob first,*/
                         /* then look for iseg '000' price.*/
                        /* (change is really in xspcs52)*/

   /* ------------------------------------------------------------*/

  PCOREC.PCORECPF = "N"; /* Price found flag*/

   /* ------------------------------------------------------------*/
   /* Check to see if the quality code is an '02' B grade*/
   /* and get the FOB price.  Otherwise get the price based*/
   /* upon the spec code.*/
   /* ------------------------------------------------------------*/




  if (PCOREC.XQACD == "02")

    XSPCS51(); /* Get B grade price*/

  else

    XSPCS52(); /* Get Regular grade price*/

  end

  if (PCOREC.PCORECPF == "N") /* No price found*/
    move 0 to PCOREC.FY4FOBPR[1] for all; /* Set pcorec price array to zeros*/
    return;
  end


   /* ------------------------------------------------------------*/
   /* Overlay the fob prices with the Sceener cost if available*/
   /* ------------------------------------------------------------*/

  if (PCOREC.XGPCD == "03" /* ===> Apparel*/
   && FY4REC.FY4SCNCS > 0) /* ===> Screener cost present*/
    move FY4REC.FY4SCNCS to FY4REC.FY4FOBPR[1] for 40;
  end

   /* ------------------------------------------------------------*/
   /* If inline move prices from the VFCTY003 to the PCOREC.*/
   /* if B grade compute the price.*/
   /* ------------------------------------------------------------*/

  PCOREC.PCORECIX = 1; /* Initialize index*/

  while (PCOREC.PCORECIX <= 40)

    if (PCOREC.PCORECBF == "Y") /* Compute the B grade price*/
      if (FY4REC.FY4FOBPR[PCORECIX] != 0)
        PCOREC.PCORECPC = VFCTY003.FY1BGDPC / 100;
        PCOREC.PCORECPR = FY4REC.FY4FOBPR[PCORECIX]                                              * PCOREC.PCORECPC + .005;
        PCOREC.FY4FOBPR[PCORECIX] = PCOREC.PCORECPR;
      end
    else
      PCOREC.FY4FOBPR[PCORECIX] = FY4REC.FY4FOBPR[PCORECIX];
    end

    PCOREC.PCORECIX = PCOREC.PCORECIX + 1;

  end


end // end XSPCS04

// calc. (ETAL,RTS,ETA Dates)
Function XSPCS05()
   /* ------------------------------------------------------------*/

   /* X S P C 0 0 5*/

    /* This process will be called to obtain the follwing*/
    /* dates:*/
          /* RTS (requested time of shipment)*/
          /* ETA (estimated time of arrival - for PO items)*/
          /* ETAL (Estimated time of arrival)*/

    /* The following records should be included in your*/
    /* application records list:*/
          /* PCPREC  (Data passed to and from the subroutine)*/
          /* TA2REC  (Used for date calculations)*/
          /* VPRDCU03(Customer xref record)*/
          /* VFCTY003  (Factory record)*/
          /* TSEREC  (Transit time)*/

    /* In addition the XWHTBL table needs to be added to*/
    /* the application list.*/

    /* The following fields needed for the date calculations*/
    /* should be passed in the PCPREC:*/

     /* XGPCD*/
     /* XWHCD*/
     /* PC2CUXID*/
     /* FY1FCTYC*/
     /* YMTCD*/
     /* PCPPOIDT*/
     /* PC6RTADT*/
     /* PC6ETSDT*/
     /* PC6ETALF*/
     /* PC4ORTYP*/

    /* The following fields will be returned following*/
    /* execution of the date calculation process and*/
    /* associated statement groups.*/

    /* PCPREC.PCPRTSDT  = RTS  date (RTA - ETT - MADD - PADD)*/
    /* PCPREC.PCPMRTS   = RTS  date (MMDDYY)*/

    /* PCPREC.PCPETADT  = ETA  date (ETS + MADD + ETT)*/
    /* PCPREC.PCPMETA   = ETA  date (MMDDYY)*/

    /* PCPREC.PCPETALD  = ETAL date (ETA + PADD)*/
    /* PCPREC.PCPMETAL  = ETAL date (MMDDYY)*/

    /* Any bad DB2 return codes will be handled by the*/
    /* executed statement groups.*/

   /* ------------------------------------------------------------*/
   /* Obtain the MADD (manufacturers adjustment departure days*/
       /* from the factory system).*/
   /* ------------------------------------------------------------*/

  set VFCTY003 empty; /* Initialize record*/

  VFCTY003.XGPCD = PCPREC.XGPCD; /* GPC code*/
  VFCTY003.FY1FCTYC = PCPREC.FY1FCTYC; /* Factory code*/

  XSPCS57(); /* Get the factory row*/

   /* ------------------------------------------------------------*/
   /* ZERO OUT MADD FOR FOOTWEAR, FROM 20001012 ONWARDS*/
   /* ------------------------------------------------------------*/

  if (VFCTY003.FY-FCTY-TYP-CD == "F" || 
  VFCTY003.FY-FCTY-TYP-CD == "FJ")
    if (PCPREC.PCPPOIDT >= 20001012)
      VFCTY003.FY1MADD = 0;
    end
  end

   /* ------------------------------------------------------------*/
   /* Obtain the ETT (estimated transit time) from the*/
       /* Dtrans.Vttime01 table using the location code from*/
       /* either the warehouse or customer xref table.*/
   /* ------------------------------------------------------------*/

  set TSEREC empty; /* Initialize record*/

  if (PCPREC.XWHCD != " ") /* If warehouse code present*/

    if (PCPREC.XWHCD in XWHTBL.XWHCD)
      TSEREC.TSEDEST = XWHTBL.TSCLOCCD[sysVar.arrayIndex];
    end /* Location*/
    if (sysVar.arrayIndex != 0) /* Warehouse found in table*/
      TSEREC.TSEORIG = VFCTY003.TSCLOCCD; /* Factory of origin*/
      TSEREC.YMTCD = PCPREC.YMTCD; /* Trans mode*/

      XSPCS58(); /* Get travel days*/

    end
  else /**/
    set VPRDCU03 empty; /* Initialize cust xref record*/
    VPRDCU03.XGPCD = PCPREC.XGPCD;
    VPRDCU03.PC2CUXID = PCPREC.PC2CUXID;

    XSPCS59(); /* Obtain customer xref record*/

    if (SQLCA.VAGen_SQLCODE == 0) /* Customer xref found*/
      TSEREC.TSEDEST = VPRDCU03.TSCLOCCD; /* Location*/
      TSEREC.TSEORIG = VFCTY003.TSCLOCCD; /* Factory of origin*/
      TSEREC.YMTCD = PCPREC.YMTCD; /* Trans mode*/

      XSPCS58(); /* Get travel days*/

    end
  end

  if (PCPREC.PC4ORTYP == "ST")
    TSEREC.TSETRNTM = 0; /* Transit travel time is zero for "ST"*/
  end

   /* ------------------------------------------------------------*/
   /* Calculate the RTS (requested time of shipment) date*/
         /* RTS =  RTA - ETT - MADD - PADD*/
   /* ------------------------------------------------------------*/

  if (PCPREC.PC6RTADT != 0)

    set TA2REC empty; /* Initialize record*/

    TA2REC.TA2DYAOD = TSEREC.TSETRNTM + VFCTY003.FY1MADD; /* trv + madd*/
    if (PCPREC.XWHCD != " " /* padd*/
     && sysVar.arrayIndex != 0)
      TA2REC.TA2DYAOD = TA2REC.TA2DYAOD + XWHTBL.XWHPAD[sysVar.arrayIndex];
    else
      TA2REC.TA2DYAOD = TA2REC.TA2DYAOD + VPRDCU03.PO-DIR-SHP-ADJ-DY;
    end
    TA2REC.TA2DYAOD = TA2REC.TA2DYAOD * -1; /* reverse the sign*/
    TA2REC.TA2GRGGN = PCPREC.PC6RTADT; /* RTA date*/

    XSPCS60(); /* Calculate date (- Or +) days*/

    PCPREC.PCPRTSDT = TA2REC.TA2GRGGN; /* Date (ccyymmdd)*/
    PCPREC.PCPMRTS = TA2REC.TA2GRGA; /* Map display date (mmddyy)*/
  end

   /* ------------------------------------------------------------*/
   /* Calculate the ETA (estimated time of arrival) date*/
         /* ETA  = ETS + MADD + ETT*/
   /* ------------------------------------------------------------*/

  set TA2REC empty;

  TA2REC.TA2DYAOD = VFCTY003.FY1MADD + TSEREC.TSETRNTM; /* Offset days*/

  TA2REC.TA2GRGGN = PCPREC.PC6ETSDT; /* ETS date*/

  XSPCS60(); /* Calculate date (- Or +) days*/

  PCPREC.PCPETADT = TA2REC.TA2GRGGN; /* ETA date*/
  PCPREC.PCPMETA = TA2REC.TA2GRGA; /* Map display date (mmddyy)*/

   /* ------------------------------------------------------------*/
   /* Calculate the ETAL (estimated time of allocation) date*/
         /* ETAL = ETA + PADD*/

   /* for GPC = "02" and order type = "FT","OR","S1","S4","ST"*/
       /* a different set of processing needs to be performed*/
   /* ------------------------------------------------------------*/

  if (PCPREC.XGPCD == "02"
   && PCPREC.PC6ETSDT == 0)

    if (PCPREC.PC4ORTYP == "FT" /* ===> INLINE*/
     || PCPREC.PC4ORTYP == "OR" /* ===> OVERRUN*/
     || PCPREC.PC4ORTYP == "S1" /* ===> SIDE 1 - first quality*/
     || PCPREC.PC4ORTYP == "S4" /* ===> SIDE 1 - overrun*/
     || PCPREC.PC4ORTYP == "ST") /* ===> Stock Transfer*/
      XSPCS06(); /* ===> calculate ETAL date for*/
                                   /* specified O.T.*/
    else
      XSPCS07(); /* ===> calc. ETAL date normally*/
    end

  else
    XSPCS07(); /* ===> calculate ETAL date normally*/
  end

  /* ------------------------------------------------------------*/
   /* Convert ETAL to the first of the next month for apparel*/
   /* if the day falls between  the 25th and the 1st.*/
   /* dhales- change 9/23/93 change to between the 20th and 1st*/

   /* PCA383   ASUNDA   FOR DIRECT SHIPMENTS IN APPAREL, THE ETAL*/
   /* (04/29/97)        DATE IS NOT DEFAULTED TO THE FIRST OF THE*/
   /* /* NEXT MONTH IF THE ACTUAL DAY FALLS BETWEEN*/
   /* 21ST AND THE 1ST.*/
   /*  */
   /* PCA999   KGRAHA   SAME AS ABOVE FOR 'BA' PO'S.*/
   /* (04/22/99)*/
   /* pca999   vsanka    removed the  date conversion logic*/
   /* (09/24/99)          to default ETAL to 1st of next month.*/
   /* ------------------------------------------------------------------*/

  PCPREC.PCPETAL = PCPREC.PCPETALD; /* move etal to work etal*/
   /* IF PCPREC.XGPCD = '03';*/

   /* IF (PCPREC.PC4ORTYP NE 'MM') AND*/
     /* (PCPREC.PC4ORTYP NE 'MD') AND*/
     /* (PCPREC.PC4ORTYP NE 'DS') AND*/
     /* (PCPREC.PC4ORTYP NE 'DC') AND*/
     /* (PCPREC.PC4ORTYP NE 'BA');*/

     /* IF PCPREC.PCPETLDD GE 21;*/
       /* IF PCPREC.PCPETLMM = 12;   /* if etal month = december*/
         /* IF PCPREC.PCPETLYY = 99; /* if etal year = 99*/
                                  /* PCPREC.PCPETLCC = PCPREC.PCPETLCC +*/
                                   /* 1;/* increment the century*/
         /* END;*/
         /* MOVE 1 TO PCPREC.PCPETLMM;/* default etal month to january*/
         /* MOVE 1 TO PCPREC.PCPETLDD;/* default etal day to the 1st*/
                                  /* PCPREC.PCPETLYY = PCPREC.PCPETLYY +*/
                                   /* 1;/* add 1 to the etal year*/
       /* ELSE;*/
         /* MOVE 1 TO PCPREC.PCPETLDD;/* default etal day to the 1st*/
                                  /* PCPREC.PCPETLMM = PCPREC.PCPETLMM +*/
                                   /* 1;/* add 1 to the etal month*/
       /* END;*/

  PCPREC.PCPETALD = PCPREC.PCPETAL; /* move work ETAL to ETAL*/

  set TA2REC empty;
  TA2REC.TA2DYAOD = 0;
  TA2REC.TA2GRGGN = PCPREC.PCPETALD; /* ETAL Date*/

  XSPCS60(); /* Calculate date (- Or +) days*/

  PCPREC.PCPMETAL = TA2REC.TA2GRGA; /* Map display date (mmddyy)*/

     /* END;*/
   /* END;*/
   /* END;*/

end // end XSPCS05

// calc. ETAL w/  default flag
Function XSPCS06()
   /* ------------------------------------------------------------*/

   /* Calculate the ETAL*/

          /* ETAL (Estimated time of arrival)*/
           /* for  GPC = "02", P.O. TYPE ="FT","OR","S1","S4","ST"*/
            /* and ETS date being blank*/

   /* ------------------------------------------------------------*/


   /* ========> Build the buy month field CCYYMM from P.O. ID Date*/

  PCPREC.PCPBUYCC = PCPREC.PCPPOPCC;
  PCPREC.PCPBUYYY = PCPREC.PCPPOPYY;
  PCPREC.PCPBUYMM = PCPREC.PCPPODMM; /* ===> use delivery month*/

  if (PCPREC.PCPPODMM < PCPREC.PCPPOPMM) /* ===> delivery mm > prod mm*/
    PCPREC.PCPBUYYY = PCPREC.PCPBUYYY + 1;
    if (PCPREC.PCPPOPYY == 99)
      PCPREC.PCPBUYCC = PCPREC.PCPBUYCC + 1;
    end
  end

   /* =========> Using the Buy Month Field CCYYMM*/
   /* ---------> calculate the ETAL date*/

  set TA2REC empty;

  PCPREC.PCPETLYY = PCPREC.PCPBUYYY; /* ===> use buy year*/
  PCPREC.PCPETLMM = PCPREC.PCPBUYMM; /* ===> use delivery month*/

  if (PCPREC.PCPETLMM == 12)
    PCPREC.PCPETLMM = 1;
    if (PCPREC.PCPETLYY == 99)
      PCPREC.PCPETLYY = 0;
      PCPREC.PCPETLCC = PCPREC.PCPETLCC + 1;
    else
      PCPREC.PCPETLYY = PCPREC.PCPETLYY + 1;
    end
  else
    PCPREC.PCPETLMM = PCPREC.PCPETLMM + 1;
  end

  if (PCPREC.PC4ORTYP == "ST") /* ===> do last day of the current buy*/
                                   /* month date*/
    TA2REC.TA2DYAOD = -1;
    PCPREC.PCPETLDD = 1;
  else
    if (PCPREC.PC6ETALF == "Y") /* ===> do 15th day of the next buy*/
                                   /* month date*/
      TA2REC.TA2DYAOD = 0;
      PCPREC.PCPETLDD = 15;
    else /* ===> do last day of the current buy*/
                                   /* month date*/
      TA2REC.TA2DYAOD = -1;
      PCPREC.PCPETLDD = 1;
    end
  end

  PCPREC.PCPETALD = PCPREC.PCPETAL; /* move work ETAL to ETAL*/
  TA2REC.TA2GRGGN = PCPREC.PCPETALD; /* ETAL Date*/


  XSPCS60(); /* Calculate date (- Or +) days*/

  PCPREC.PCPETALD = TA2REC.TA2GRGGN; /* ETAL date*/
  PCPREC.PCPMETAL = TA2REC.TA2GRGA; /* Map display date (mmddyy)*/

end // end XSPCS06

// calc. ETAL w/o default flag
Function XSPCS07()
   /* /* ------------------------------------------------------------*/

   /* Calculate the ETAL (estimated time of allocation) date*/
         /* ETAL = ETA + PADD*/

          /* ETAL (Estimated time of arrival)*/
           /* for other than GPC = "02", P.O. TYPE ="FT"*/


   /* ------------------------------------------------------------*/

  if (PCPREC.XWHCD != " " /* If warehouse code*/
   && sysVar.arrayIndex != 0) /* And warehouse in table*/

    set TA2REC empty; /* Initialize record*/
    if (PCPREC.XGPCD == "03")
      if (PCPREC.XWHCD == "51" && 
      VFCTY003.PC-XCT-ORIG-CD == " ")
        if (VFCTY003.XCTCD == "USA")
          TA2REC.TA2DYAOD = 2; /* Padd days*/
        else
          TA2REC.TA2DYAOD = XWHTBL.XWHPAD[sysVar.arrayIndex]; /* Padd days*/
        end
      else
        if (PCPREC.XWHCD == "51" && 
        VFCTY003.PC-XCT-ORIG-CD == "USA")
          TA2REC.TA2DYAOD = 2; /* Padd days*/
        else
          TA2REC.TA2DYAOD = XWHTBL.XWHPAD[sysVar.arrayIndex]; /* Padd days*/
        end
      end
    else
      TA2REC.TA2DYAOD = XWHTBL.XWHPAD[sysVar.arrayIndex]; /* Padd days*/
    end

  else

    set TA2REC empty; /* Initialize record*/
    TA2REC.TA2DYAOD = VPRDCU03.PO-DIR-SHP-ADJ-DY;

  end

  if (PCPREC.PC6ETSDT == 0) /* no ETS date*/
    TA2REC.TA2GRGGN = PCPREC.PC6RTADT; /* RTA date*/
  else /* ets date*/
    TA2REC.TA2GRGGN = PCPREC.PCPETADT; /* ETA date*/
  end

  XSPCS60(); /* Calculate date (- Or +) days*/

  PCPREC.PCPETALD = TA2REC.TA2GRGGN; /* ETAL date*/
  PCPREC.PCPMETAL = TA2REC.TA2GRGA; /* Map display date (mmddyy)*/

end // end XSPCS07

// Select (S2) Set/Open  VPOITM05
Function XSPCS11()
   /* ------------------------------------------------------------*/
   /* Select the requested set of rows from the table.*/
   /* ------------------------------------------------------------*/
  PCYREC.PCYFUNC = "S2";
  try
    call "VPOITM05" (PCYREC, SQLCA, VPOITM05) {isNoRefresh = yes, isExternal = yes};
  end /* Select table*/

   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback(); /* ===> Roll Back all changes*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  PC8REC.XXXPRCNM = "XSPCS11"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/


  end


  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "SELECT SET OF TABLE ROWS";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNM = "XSPCS11"; /* Program number*/
  TA1REC.TA1DBASE = "DPRODC  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VPOITM05"; /* Table view name*/
  TA1REC.TA1TBLKE = VPOITM05.VPOITM05-KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/


  exit stack; /* Exit to display map*/


   /* **                                                        ***/
   /* ********************** End of XSPCS11 ***********************/
end // end XSPCS11

// Fetch  (N2) Next row  VPOITM05
Function XSPCS12()
   /* ------------------------------------------------------------*/
   /* Fetch the next row to display from the table.*/
   /* ------------------------------------------------------------*/
  PCYREC.PCYFUNC = "N2";
  try
    call "VPOITM05" (PCYREC, SQLCA, VPOITM05) {isNoRefresh = yes, isExternal = yes};
  end /* Fetch next*/

   /* ------------------------------------------------------------*/
   /* If successful, check for multiple styles*/
                /* , save the data in pcwrec storage.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/

    if (SQLCA.VAGen_SQLCODE == 0) /* Normal return code*/

      return;

    end

    /* ------------------------------------------------------------*/
     /* If end of selected set, indicate end of cursor.*/
    /* ------------------------------------------------------------*/

    if (SQLCA.VAGen_SQLCODE == 100) /* End of selected set*/


      PC8REC.PC8WSWT = "Y"; /* Indicate end of cursor*/

      return; /* Return to previous process*/

    end

  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback(); /* ===> rollback all changes*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/
  PC8REC.XXXPRCNM = "XSPCS12"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/


  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "FETCH NEXT TABLE ROW";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNM = "XSPCS12"; /* Program number*/
  TA1REC.TA1DBASE = "DPRODC  "; /* ===> Data base name*/
  TA1REC.TA1TBLVU = "VPOITM05"; /* ===> Table view name*/

  TA1REC.TA1TBLKE = VPOITM05.VPOITM05-KEY; /* ===>Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


   /* **                                                        ***/
   /* ********************** End of XSPCS12 ***********************/
end // end XSPCS12

// Close  (C2) Set       VPOITM05
Function XSPCS13()
   /* ------------------------------------------------------------*/
   /* Close the selected set of table rows.*/
   /* ------------------------------------------------------------*/

  PCYREC.PCYFUNC = "C2";
  try
    call "VPOITM05" (PCYREC, SQLCA, VPOITM05) {isNoRefresh = yes, isExternal = yes};
  end /* Close table*/

   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/


  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback(); /* ===> roll back all changes*/

  PC8REC.XXXPRCNM = "XSPCS13"; /* Module identification*/
  converseLib.validationFailed(10); /* Indicate system error*/
  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "CLOSE SELECTED SET OF TABLE ROWS";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNM = "XSPCS13"; /* Program number*/
  TA1REC.TA1DBASE = "DPRODC  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VPOITM05"; /* Table view name*/

  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/


  exit stack; /* Exit to display map*/


   /* **                                                        ***/
   /* ********************** End of XSPCS13 ***********************/
end // end XSPCS13

// Select (S ) Unique    VPOHDR02
Function XSPCS14()
   /* ------------------------------------------------------------*/
   /* Select the P.O. Header table row*/
   /* ------------------------------------------------------------*/

  PCYREC.PCYFUNC = "S ";
  try
    call "VPOHDR02" (PCYREC, SQLCA, VPOHDR02) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000") /* Successful call*/

    if (SQLCA.VAGen_SQLCODE == 0) /* Row found*/
      return; /* Return to previous process*/
    end

    if (SQLCA.VAGen_SQLCODE == 100) /* Row found*/
      PC8REC.XXXPRCNM = "XSPCS14"; /* Process name*/
      converseLib.validationFailed(12); /* Updated by Another*/
      VGVar.handleSysLibraryErrors = 0;
      sysLib.rollback(); /* ===> roll back all changes*/
      return; /* Return to previous process*/
    end

  end

  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback(); /* ===> roll back all changes*/

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  end

  PC8REC.XXXPRCNM = "XSPCS14"; /* Process name*/
  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "XSPCS14"; /* Process name*/
  TA1REC.TA1DBASE = "DPRODC. "; /* Data base name*/
  TA1REC.TA1TBLVU = "VPOHDR02"; /* Table view name*/
  TA1REC.TA1LOC = "SELECT UNIQUE P.O. HEADER ROW";
  TA1REC.TA1TBLKE = VPOHDR02.VPOHDR02-KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack;

   /* **                                                        ***/
   /* ********************** End of XSPCS14 ***********************/
end // end XSPCS14

// Update (U ) Header    VPOHDR02
Function XSPCS15()
   /* ------------------------------------------------------------*/
   /* Update the P.O. Header table row*/
   /* ------------------------------------------------------------*/

  PCYREC.PCYFUNC = "U ";
  try
    call "VPOHDR02" (PCYREC, SQLCA, VPOHDR02) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000") /* Successful call*/

    if (SQLCA.VAGen_SQLCODE == 0) /* Row found*/
      return; /* Return to previous process*/
    end

    if (SQLCA.VAGen_SQLCODE == 100) /* Row found*/
      PC8REC.XXXPRCNM = "XSPCS15"; /* Process name*/
      converseLib.validationFailed(12); /* Indicate system error*/
      VGVar.handleSysLibraryErrors = 0;
      sysLib.rollback(); /* ===> roll back all changes*/
      return; /* Return to previous process*/
    end

  end

  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback(); /* ===> roll back all changes*/

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  end

  PC8REC.XXXPRCNM = "XSPCS15"; /* Process name*/
  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "XSPCS15"; /* Process name*/
  TA1REC.TA1DBASE = "DPRODC. "; /* Data base name*/
  TA1REC.TA1TBLVU = "VPOHDR02"; /* Table view name*/
  TA1REC.TA1LOC = "UPDATE P.O. HEADER ROW";
  TA1REC.TA1TBLKE = VPOHDR02.VPOHDR02-KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack;

   /* **                                                        ***/
   /* ********************** End of XSPCS15 ***********************/
end // end XSPCS15

// Insert (A ) Audit     VPOAHD02
Function XSPCS16()
   /* ------------------------------------------------------------*/
    /* Load and Insert Header Audit row*/
   /* ------------------------------------------------------------*/


  VPOAHD02.XGPCD = VPOHDR02.XGPCD; /* Gpc code*/
  VPOAHD02.PO-REG-CD = VPOHDR02.PO-REG-CD; /* P.O. REGION CODE*/
  VPOAHD02.PC3PONBR = VPOHDR02.PC3PONBR; /* P.O. number*/
  VPOAHD02.PC3POIDT = VPOHDR02.PC3POIDT; /* P.O. id*/
  VPOAHD02.FY1FCTYC = VPOHDR02.FY1FCTYC; /* P.O. Factory code*/
  VPOAHD02.PCFSECD = VPOHDR02.PCFSECD; /* Apparel season code*/
  VPOAHD02.PC3BUYMO = VPOHDR02.PC3BUYMO; /* Apparel buy month*/
  VPOAHD02.PC4ORTYP = VPOHDR02.PC4ORTYP; /* P.O. type code*/

  VPOAHD02.XXXPGUID = COMMAREA.CAUSERID; /* User id.*/
  VPOAHD02.YACCD = PC8REC.YACCD; /* Audit comment code*/

  if (PC8REC.XGPCD == "02") /* GPC Code 'FOOTWEAR'*/
    VPOAHD02.YOACD = "02"; /* PO STATUS - PO HEADER*/
  end

  if (PC8REC.XGPCD == "03") /* GPC Code 'APPAREL'*/
    if (VPOAHD02.PCIAFTA == "CX") /* Status of cancel*/
      VPOAHD02.YOACD = "50"; /* PO STATUS - PO HEADER*/
    else
      VPOAHD02.YOACD = "79"; /* PO STATUS - PO HEADER*/
    end
  end

  XSPCSA8(); /* set change and oa memo flags*/

  VPOAHD02.ZZZSDT = XX0XW01.XX0XWDAT; /* Set up date*/
  VPOAHD02.ZZZCHGDT = XX0XW01.XX0XWDAT; /* Change date*/
  VPOAHD02.ZZZCHGTM = XX0XW01.XX0XWTIM; /* Change time*/


  try
    call "VPOAHD02" ("A ", SQLCA, VPOAHD02) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/


  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Row found*/

      return; /* Return to previous process*/

    end
  end

  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback(); /* ===> roll back all changes*/

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  end

  PC8REC.XXXPRCNM = "XSPCS16"; /* Process name*/
  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "XSPCS16"; /* Process name*/
  TA1REC.TA1DBASE = "DPRODC. "; /* Data base name*/
  TA1REC.TA1TBLVU = "VPOAHD02"; /* Table view name*/
  TA1REC.TA1LOC = "INSERT P.O. HEADER AUDIT ROW";
  TA1REC.TA1TBLKE = VPOAHD02.VPOAHD02-KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack;

   /* **                                                        ***/
   /* ********************** End of XSPCS16 ***********************/
end // end XSPCS16

// Get/process container data
Function XSPCS30()
   /* ------------------------------------------------------------*/
    /* Get all size order QTYs that have been shipped*/
    /* for the associated CPLHDR02 row selected*/
    /* if the container status indicater is valid*/
   /* ------------------------------------------------------------*/

  XSPCS31(); /* Declare cursor for VCNTNR01*/

  XSPCS32(); /* Fetch first VCNTNR01 row*/
   /* ---------------------------------===> Prime read*/

  while (PC5REC.PC5WSW1 == "N") /* ===> until end of temp cursor (VCNTNR01)*/

    if (PC5REC.PC5ERFL == "Y") /* ===> include hard errors*/
      if (TSHREC.TSHSTAT == "IT" /* ===> container status indicator*/
       || TSHREC.TSHSTAT == "ER" 
       || TSHREC.TSHSTAT == "CC" 
       || TSHREC.TSHSTAT == "CR" 
       || TSHREC.TSHSTAT == "RC")

        XSPCS40(); /* Get shipped QTYs in VCPLIT01 table*/

      end
      /* -------------------------------===> Driving read*/
    else /* ===> do not include hard errors*/
      if (TSHREC.TSHSTAT == "IT" /* ===> container status indicator*/
       || TSHREC.TSHSTAT == "CC" 
       || TSHREC.TSHSTAT == "RC")

        XSPCS40(); /* Get shipped QTYs in VCPLIT01 table*/

      end
    end

    XSPCS32(); /* Fetch next VCNTNR01 row*/
    /* -------------------------------===> Driving read*/

  end

  XSPCS33(); /* Close VCNTNR01 cursor*/


   /* **                                                        ***/
   /* ********************** End of XSPCS30 ***********************/
end // end XSPCS30

// Select (S1) Set/Open  VCNTNR01
Function XSPCS31()
   /* ------------------------------------------------------------*/
   /* initialize and set up for D.B. call on DTRANS.VCNTNR01*/
   /* ------------------------------------------------------------*/

  PC5REC.PC5WSW1 = "N"; /* Set temp cursor EOF*/

  set TSHREC empty;

  TSHREC.TSFSHPID = VCPLHDJ4.TS-NIKE-SHP-ID; /* Nike ship ID*/

   /* ------------------------------------------------------------*/
   /* Declare cursor for DTRANS.VCNTNR01*/
   /* ------------------------------------------------------------*/


  try
    call "IO2590" ("S1", SQLCA, TSHREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/
    return;
  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  end

  PC5REC.XXXPRCNM = "XSPCS31";
  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "XSPCS31"; /* Process name*/
  TA1REC.TA1LOC = "DECLARE CURSOR          ";
  TA1REC.TA1DBASE = "DTRANS  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCNTNR01"; /* Table view name*/
  TA1REC.TA1TBLKE = TSHREC.TSHKEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack;

   /* **                                                        ***/
   /* ********************** End of XSPCS31 ***********************/
end // end XSPCS31

// Fetch  (N1) Next row  VCNTNR01
Function XSPCS32()
   /* ------------------------------------------------------------*/
   /* If row not found, return to prev. with EOF Cursor set.*/
   /* If any other, indicate system error.*/
   /* ------------------------------------------------------------*/

  try
    call "IO2590" ("N1", SQLCA, TSHREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Row found*/
      return;
    end
    if (SQLCA.VAGen_SQLCODE == 100) /* Row not found*/
      PC5REC.PC5WSW1 = "Y"; /* Indicate temp cursor at EOF*/
      return;
    end

  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  end

  PC5REC.XXXPRCNM = "XSPCS32";
  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "XSPCS32"; /* Process name*/
  TA1REC.TA1LOC = "FETCH ROW               ";
  TA1REC.TA1DBASE = "DTRANS  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCNTNR01"; /* Table view name*/
  TA1REC.TA1TBLKE = TSHREC.TSHKEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack;


   /* **                                                        ***/
   /* ********************** End of XSPCS32 ***********************/
end // end XSPCS32

// Close  (C1) Set       VCNTNR01
Function XSPCS33()
   /* ------------------------------------------------------------*/
   /* Close cursor for DTRANS.VCNTNR01*/
   /* ------------------------------------------------------------*/

  try
    call "IO2590" ("C1", SQLCA, TSHREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/
    return;
  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  end

  PC5REC.XXXPRCNM = "XSPCS33";
  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "XSPCS33"; /* Process name*/
  TA1REC.TA1LOC = "CLOSE CURSOR            ";
  TA1REC.TA1DBASE = "DTRANS  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCNTNR01"; /* Table view name*/
  TA1REC.TA1TBLKE = TSHREC.TSHKEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack;


   /* **                                                        ***/
   /* ********************** End of XSPCS33 ***********************/
end // end XSPCS33

// Get Shipped on-order size QTYs
Function XSPCS40()
   /* ------------------------------------------------------------*/
    /* Get all size order QTYs that have been shipped*/
    /* for the associated VCPLHDJ4 & VCNTNR01 row in process.*/
   /* ------------------------------------------------------------*/

  XSPCS41(); /* Declare cursor for VCPLIT01*/

  XSPCS42(); /* Fetch first VCPLIT01 row*/
   /* ---------------------------------===> Prime read*/

  while (PC5REC.PC5WSW2 == "N") /* ===> until EOF temp cursor (VCPLIT01)*/

    PC5REC.PC5WIXT = TSOREC.SY5SZID; /* ===> set temp index*/

    /* TSOREC.TSOSHPQT ;===>carton units shipped*/

    if (TSHREC.TSHSTAT == "RC"
     || VCPLHDJ4.TS-CPL-STAT-CD == "RC")
      PC5REC.PC5SRCV[PC5WIXT] = PC5REC.PC5SRCV[PC5WIXT] + TSOREC.TSOSHPQT;
      PC5REC.PC5TSRCV = PC5REC.PC5TSRCV + TSOREC.TSOSHPQT;
    else /* status = it,er,cc or cr*/
      PC5REC.PC5SHIP[PC5WIXT] = PC5REC.PC5SHIP[PC5WIXT] + TSOREC.TSOSHPQT;
      PC5REC.PC5TSHIP = PC5REC.PC5TSHIP + TSOREC.TSOSHPQT;
    end

    XSPCS42(); /* Fetch next VCPLIT01 row*/
    /* -------------------------------===> Driving read*/

  end

  XSPCS43(); /* close VCPLIT01 cursor*/


   /* **                                                        ***/
   /* ********************** End of XSPCS40 ***********************/
end // end XSPCS40

// Select (S3) Set/Open  VCPLIT01
Function XSPCS41()
   /* ------------------------------------------------------------*/
   /* initialize and set up for D.B. call on DTRANS.VCPLIT01*/
   /* ------------------------------------------------------------*/

  PC5REC.PC5WSW2 = "N"; /* Set temp cursor EOF VCPLIT01*/

  set TSOREC empty;

  TSOREC.TSFSHPID = TSHREC.TSFSHPID; /* Nike ship ID*/
  TSOREC.TSHNKCN = TSHREC.TSHNKCN; /* Nike Carton number*/
  TSOREC.TSIPLNBR = VCPLHDJ4.TS-NIKE-PL-NBR; /* Nike plan number*/

   /* ------------------------------------------------------------*/
   /* Declare cursor for DTRANS.VCPLIT01*/
   /* ------------------------------------------------------------*/


  try
    call "IO2580" ("S3", SQLCA, TSOREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/
    return;
  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  end

  PC5REC.XXXPRCNM = "XSPCS41";
  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "XSPCS41"; /* Process name*/
  TA1REC.TA1LOC = "DECLARE CURSOR          ";
  TA1REC.TA1DBASE = "DTRANS  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCPLIT01"; /* Table view name*/
  TA1REC.TA1TBLKE = TSOREC.TSOKEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack;

   /* **                                                        ***/
   /* ********************** End of XSPCS41 ***********************/
end // end XSPCS41

// Fetch  (N3) Next row  VCPLIT01
Function XSPCS42()
   /* ------------------------------------------------------------*/
   /* If row not found return to previous process.*/
   /* If any other, indicate system error.*/
   /* ------------------------------------------------------------*/

  try
    call "IO2580" ("N3", SQLCA, TSOREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Row found*/
      return;
    end
    if (SQLCA.VAGen_SQLCODE == 100) /* Row not found*/
      PC5REC.PC5WSW2 = "Y"; /* Indicate temp cursor at EOF*/
      return;
    end

  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  end

  PC5REC.XXXPRCNM = "XSPCS42";
  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "XSPCS42"; /* Process name*/
  TA1REC.TA1LOC = "FETCH ROW               ";
  TA1REC.TA1DBASE = "DTRANS  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCPLIT01"; /* Table view name*/
  TA1REC.TA1TBLKE = TSOREC.TSOKEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack;


   /* **                                                        ***/
   /* ********************** End of XSPCS42 ***********************/
end // end XSPCS42

// Close  (C3) Set       VCPLIT01
Function XSPCS43()
   /* ------------------------------------------------------------*/
   /* Close cursor for vcplit01*/
   /* ------------------------------------------------------------*/

  try
    call "IO2580" ("C3", SQLCA, TSOREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/
    return;
  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  end

  PC5REC.XXXPRCNM = "XSPCS43";
  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "XSPCS43"; /* Process name*/
  TA1REC.TA1LOC = "CLOSE CURSOR            ";
  TA1REC.TA1DBASE = "DTRANS  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCPLIT01"; /* Table view name*/
  TA1REC.TA1TBLKE = TSOREC.TSOKEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack;


   /* **                                                        ***/
   /* ********************** End of XSPCS43 ***********************/
end // end XSPCS43

// GET B grade FOB price
Function XSPCS51()

   /* ------------------------------------------------------------*/
   /* Initialize the record.*/
   /* ------------------------------------------------------------*/

  set FY4REC empty;
  set FYCREC empty;

  FY4REC.XGPCD = PCOREC.XGPCD;
  FY4REC.FY1FCTYC = PCOREC.FY1FCTYC;
  FY4REC.SY1STNBR = PCOREC.SY1STNBR;
  FY4REC.SY2CLRID = PCOREC.SY2CLRID;
  FY4REC.XDMCD = PCOREC.XDMCD;
  FY4REC.XQACD = "*"; /* Wildcard quality code*/
  FY4REC.PC2INSEG = "*";
  FY4REC.XUMCD = PCOREC.XUMCD;
  FY4REC.XPGCD = "*";
  FY4REC.XSECD = PCOREC.XSECD;
  FY4REC.FY4SMDCT = 1;

  FY4REC.XSNYR = PCOREC.PCFSEYR;
  FY4REC.XXXSTAT = "A";

  if (PCOREC.XGPCD == "01"
   || PCOREC.XGPCD == "03"
   || PCOREC.XGPCD == "07")
    FYCREC.FYC1DATE = PCOREC.PC3CRDT;
  else
    if (PCOREC.XGPCD == "02")
      PCOREC.PCORECDT = PCOREC.PC3POIDT;
      PCOREC.PCORECDD = 01;
      FYCREC.FYC1DATE = PCOREC.PCORECDT;
    end
  end

   /* ----------------------------------------------------------------*/
   /* TRY TO FIND A CURRENT A-GRADE PRICE USING SCAN-5 ON IOMOD IO3000*/
   /* ----------------------------------------------------------------*/

  PCOREC.PCORECCF = "N"; /* Price cursor flag set to no*/
  PCOREC.PCORECBF = "N"; /* Compute B grade price flag set to no*/

  FYCREC.FYCFNC = "S5";
  XSPCS53(); /* Declare cursor for vfyfob01*/

  FYCREC.FYCFNC = "N5";
  XSPCS54(); /* Fetch first row*/

   /* ------------------------------------------------------------*/
   /* Fetch rows until end of cursor and the quality code from*/
   /* the map or the quality code of 01 is found.*/
   /* ------------------------------------------------------------*/


  while (PCOREC.PCORECCF == "N" /* End of cursor found set to no*/
   && PCOREC.PCORECPF == "N") /* Price found flag set to no*/

    /* ------------------------------------------------------------*/
      /* Determine it a price is valid, through a series of checks*/
    /* ------------------------------------------------------------*/

    if (FY4REC.XQACD == PCOREC.XQACD
     || FY4REC.XQACD == "01")
      /* ===>and ===>*/
      if (FY4REC.PC2INSEG == PCOREC.PC2INSEG
       || FY4REC.PC2INSEG == "000")
        /* ===>and ===>*/
        if (FY4REC.XPGCD == PCOREC.XPGCD
         || FY4REC.XPGCD == "00")

          PCOREC.PCORECPF = "Y"; /* ===> set Price found flag*/

        else /* ===>*/

          XSPCS54(); /* ===> Fetch next row*/

        end /* ===> Package condition check*/

      else /* ===>*/

        XSPCS54(); /* ===> Fetch next row*/

      end /* ===> ISEQ condition check*/

    else /* ===>*/

      XSPCS54(); /* ===> Fetch next row*/

    end /* ===> Quality code condition check*/

  end /* ===> while statement*/


  FYCREC.FYCFNC = "C5";
  XSPCS55(); /* Close cursor*/


   /* ----------------------------------------------------------------*/
   /* IF THAT DOSENT WORK TRY TO FIND THE LATEST GOOD A-GRADE PRICE*/
   /* USING SCAN-2 SELECT IN IOMOD IO3000*/
   /* ----------------------------------------------------------------*/

  if (PCOREC.PCORECPF == "N") /* Price NOT found*/

    PCOREC.PCORECCF = "N"; /* Price cursor flag set to no*/
    PCOREC.PCORECBF = "N"; /* Compute B grade price flag set to no*/

    FYCREC.FYCFNC = "S3";
    XSPCS53(); /* Declare cursor for vfyfob01*/

    FYCREC.FYCFNC = "N3";
    XSPCS54(); /* Fetch first row*/

   /* ------------------------------------------------------------*/
    /* Fetch rows until end of cursor and the quality code from*/
    /* the map or the quality code of 01 is found.*/
   /* ------------------------------------------------------------*/


    while (PCOREC.PCORECCF == "N" /* End of cursor found set to no*/
     && PCOREC.PCORECPF == "N") /* Price found flag set to no*/

     /* ------------------------------------------------------------*/
      /* Determine it a price is valid, through a series of checks*/
     /* ------------------------------------------------------------*/

      if (FY4REC.XQACD == PCOREC.XQACD
       || FY4REC.XQACD == "01")
       /* ===>and ===>*/
        if (FY4REC.PC2INSEG == PCOREC.PC2INSEG
         || FY4REC.PC2INSEG == "000")
         /* ===>and ===>*/
          if (FY4REC.XPGCD == PCOREC.XPGCD
           || FY4REC.XPGCD == "00")

            PCOREC.PCORECPF = "Y"; /* ===> set Price found flag*/

          else /* ===>*/

            XSPCS54(); /* ===> Fetch next row*/

          end /* ===> Package condition check*/

        else /* ===>*/

          XSPCS54(); /* ===> Fetch next row*/

        end /* ===> ISEQ condition check*/

      else /* ===>*/

        XSPCS54(); /* ===> Fetch next row*/

      end /* ===> Quality code condition check*/

    end /* ===> while statement*/


    FYCREC.FYCFNC = "C3";
    XSPCS55(); /* Close cursor*/

  end

  if (PCOREC.PCORECPF == "Y" /* Price found*/
   && FY4REC.XQACD == "01")  /* For an 01 quality*/

    set VFCTY003 empty; /* Initialize record*/
    VFCTY003.XGPCD = PCOREC.XGPCD;
    VFCTY003.FY1FCTYC = PCOREC.FY1FCTYC;

    XSPCS56(); /* Obtain factory row*/

    if (SQLCA.VAGen_SQLCODE == 100)
      PCOREC.PCORECPF = "N"; /* Price found flag set to no*/
    else
      PCOREC.PCORECBF = "Y"; /* Compute B grade is yes*/
    end

  end

end // end XSPCS51

// GET regular grade price
Function XSPCS52()

   /* ------------------------------------------------------------*/
   /* Initialize the record.*/
   /* ------------------------------------------------------------*/

  set FY4REC empty;
  set FYCREC empty;


  FY4REC.XGPCD = PCOREC.XGPCD;
  FY4REC.FY1FCTYC = PCOREC.FY1FCTYC;
  FY4REC.SY1STNBR = PCOREC.SY1STNBR;
  FY4REC.SY2CLRID = PCOREC.SY2CLRID;
  FY4REC.XDMCD = PCOREC.XDMCD;
  FY4REC.XQACD = PCOREC.XQACD;
  FY4REC.PC2INSEG = PCOREC.PC2INSEG; /* no wildcrd 4/26/93 lsutto*/
  FY4REC.XUMCD = PCOREC.XUMCD;
  FY4REC.XPGCD = "*"; /* WILDCARD pkg typ.*/
  FY4REC.XSECD = PCOREC.XSECD;
  FY4REC.FY4SMDCT = 1;

  FY4REC.XSNYR = PCOREC.PCFSEYR;
  FY4REC.XXXSTAT = "A";

  if (PCOREC.XGPCD == "01"
   || PCOREC.XGPCD == "03"
   || PCOREC.XGPCD == "07")
    FYCREC.FYC1DATE = PCOREC.PC3CRDT;
  else
    if (PCOREC.XGPCD == "02")
      PCOREC.PCORECDT = PCOREC.PC3POIDT;
      PCOREC.PCORECDD = 01;
      FYCREC.FYC1DATE = PCOREC.PCORECDT;
    end
  end


  PCOREC.PCORECCF = "N"; /* Set end of cursor flag to no*/

  FYCREC.FYCFNC = "S5";
  XSPCS53(); /* Declare cursor for vfyfob01*/

  FYCREC.FYCFNC = "N5";
  XSPCS54(); /* Fetch first row*/

  if (SQLCA.VAGen_SQLCODE == 100) /* /specific iseg not found*/

    FYCREC.FYCFNC = "C5";
    XSPCS55(); /* Close cursor*/
    set FY4REC empty;
    set FYCREC empty;
    FY4REC.XGPCD = PCOREC.XGPCD;
    FY4REC.FY1FCTYC = PCOREC.FY1FCTYC;
    FY4REC.SY1STNBR = PCOREC.SY1STNBR;
    FY4REC.SY2CLRID = PCOREC.SY2CLRID;
    FY4REC.XDMCD = PCOREC.XDMCD;
    FY4REC.XQACD = PCOREC.XQACD;
    FY4REC.PC2INSEG = "000"; /* now try iseg '000'*/
    FY4REC.XUMCD = PCOREC.XUMCD;
    FY4REC.XPGCD = "*"; /* WILDCARD pkg typ.*/
    FY4REC.XSECD = PCOREC.XSECD;
    FY4REC.FY4SMDCT = 1;
    FY4REC.XSNYR = PCOREC.PCFSEYR;
    FY4REC.XXXSTAT = "A";
    if (PCOREC.XGPCD == "01"
     || PCOREC.XGPCD == "03"
     || PCOREC.XGPCD == "07")
      FYCREC.FYC1DATE = PCOREC.PC3CRDT;
    else
      if (PCOREC.XGPCD == "02")
        PCOREC.PCORECDT = PCOREC.PC3POIDT;
        PCOREC.PCORECDD = 01;
        FYCREC.FYC1DATE = PCOREC.PCORECDT;
      end
    end

    PCOREC.PCORECCF = "N"; /* Set end of cursor flag to no*/
    FYCREC.FYCFNC = "S5";
    XSPCS53(); /* Declare cursor for vfyfob01*/
    FYCREC.FYCFNC = "N5";
    XSPCS54(); /* Fetch first row*/
  end /* /then go on from here*/
   /* ------------------------------------------------------------*/
   /* Fetch rows until end of cursor and the spec code from*/
   /* the map or the spec code of 000 is found.*/
   /* ------------------------------------------------------------*/


  while (PCOREC.PCORECCF == "N" /* End of cursor found set to no*/
   && PCOREC.PCORECPF == "N") /* Price found flag set to no*/

    if (FY4REC.PC2INSEG == PCOREC.PC2INSEG
     || FY4REC.PC2INSEG == "000")
      /* ===>and ===>*/
      if (FY4REC.XPGCD == PCOREC.XPGCD
       || FY4REC.XPGCD == "00")

        PCOREC.PCORECPF = "Y"; /* ===> set Price found flag*/

      else /* ===>*/

        XSPCS54(); /* ===> Fetch next row*/

      end /* ===> Package condition check*/

    else /* ===>*/

      XSPCS54(); /* ===> Fetch next row*/

    end /* ===> ISEQ condition check*/

  end

  FYCREC.FYCFNC = "C5";

  XSPCS55(); /* Close cursor*/

end // end XSPCS52

// Declare cursor for VFYFOB01
Function XSPCS53()

   /* ------------------------------------------------------------*/
   /* Declare cursor for vfyfbob01*/
   /* ------------------------------------------------------------*/

  try
    call "IO3000" (FYCREC, SQLCA, FY4REC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/
    return;
  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "XSPCS53"; /* Process name*/
  TA1REC.TA1LOC = "DECLARE CURSOR          ";
  TA1REC.TA1DBASE = "DFCTY   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VFYFOB01"; /* Table view name*/
  TA1REC.TA1TBLKE = FY4REC.FY4KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack;

end // end XSPCS53

// Fetch VFYFOB01 row
Function XSPCS54()

   /* ------------------------------------------------------------*/
   /* Select a table row.*/
   /* If row not found return a message to the user.*/
   /* If any other, indicate system error.*/
   /* ------------------------------------------------------------*/

  try
    call "IO3000" (FYCREC, SQLCA, FY4REC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Row found*/
      return;
    end
    if (SQLCA.VAGen_SQLCODE == 100) /* Row not found*/
      PCOREC.PCORECCF = "Y"; /* set end of cursor flag to 'y'*/
      return;
    end

  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "XSPCS54"; /* Process name*/
  TA1REC.TA1LOC = "FETCH ROW               ";
  TA1REC.TA1DBASE = "DFCTY   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VFYFOB01"; /* Table view name*/
  TA1REC.TA1TBLKE = FY4REC.FY4KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack;

end // end XSPCS54

// Close cursor for Vfyfob01
Function XSPCS55()

   /* ------------------------------------------------------------*/
   /* Close cursor for vfyfbob01*/
   /* ------------------------------------------------------------*/

  try
    call "IO3000" (FYCREC, SQLCA, FY4REC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/
    return;
  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "XSPCS55"; /* Process name*/
  TA1REC.TA1LOC = "CLOSE CURSOR            ";
  TA1REC.TA1DBASE = "DFCTY   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VFYFOB01"; /* Table view name*/
  TA1REC.TA1TBLKE = FY4REC.FY4KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack;

end // end XSPCS55

// OBtain factory table
Function XSPCS56()


   /* ------------------------------------------------------------*/
   /* Select a unique row.*/
   /* If not available, return an error message to the user.*/
   /* If any other, indicate system error.*/
   /* ------------------------------------------------------------*/

  try
    call "VFCTY003" ("S ", SQLCA, VFCTY003) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0 /* Row found*/
     || SQLCA.VAGen_SQLCODE == 100) /* Row not found*/

      return; /* Return to previous process*/

    end
  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "XSPCS56"; /* Process name*/
  TA1REC.TA1LOC = "SELECT UNIQUE ROW       ";
  TA1REC.TA1DBASE = "DFCTY   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VFCTY003"; /* Table view name*/
  TA1REC.TA1TBLKE = VFCTY003.VFCTY003-KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/


  exit stack;

end // end XSPCS56

// Select unique DFCTY.VFCTY003
Function XSPCS57()

   /* ------------------------------------------------------------*/
   /* Select a unique row.*/
   /* If row not found return a message to the user.*/
   /* If any other, indicate system error.*/
   /* ------------------------------------------------------------*/

  try
    call "VFCTY003" ("S ", SQLCA, VFCTY003) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == 0)      /* Row found*/
    return; /* Return to previous process*/
  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "XSPCS57"; /* Process name*/
  TA1REC.TA1LOC = "SELECT UNIQUE ROW       ";
  TA1REC.TA1DBASE = "DFCTY   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VFCTY003"; /* Table view name*/
  TA1REC.TA1TBLKE = VFCTY003.VFCTY003-KEY; /* Error key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack;

end // end XSPCS57

// Select unique DTRANS.VTTIME01
Function XSPCS58()

   /* ------------------------------------------------------------*/
   /* Select a unique row.*/
   /* If row not found return a message to the user.*/
   /* If any other, indicate system error.*/
   /* ------------------------------------------------------------*/

  try
    call "IO2360" ("S ", SQLCA, TSEREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0 /* Row found*/
     || SQLCA.VAGen_SQLCODE == 100) /* Row not found*/
      return; /* Return to previous process*/
    end

  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  end

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "XSPCS08"; /* Process name*/
  TA1REC.TA1LOC = "SELECT UNIQUE ROW       ";
  TA1REC.TA1DBASE = "DTRANS  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VTTIME01"; /* Table view name*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack;

end // end XSPCS58

// Get unique customer xref
Function XSPCS59()

   /* ------------------------------------------------------------*/
   /* Get the location code from the customer xref table.*/
   /* ------------------------------------------------------------*/

  try
    call "VPRDCU03" ("S ", SQLCA, VPRDCU03) {isNoRefresh = yes, isExternal = yes};
  end

   /* ------------------------------------------------------------*/
   /* If successful, return to previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/
    if (SQLCA.VAGen_SQLCODE == 0 /* Normal return code*/
     || SQLCA.VAGen_SQLCODE == 100) /* Row not found*/

      return; /* Return to previous process*/

    end
  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/


  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/

    converseLib.validationFailed(11); /* 'resources unavailable'*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(10); /* 'error - please nofity programming'*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/


  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "FETCH NEXT TABLE ROW";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = "XSPCS09"; /* Program number*/
  TA1REC.TA1DBASE = "DPRODC  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VPRDCU03"; /* Table view name*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/

end // end XSPCS59

// Calculate (- Or +) days
Function XSPCS60()
   /* ------------------------------------------------------------*/
   /* Use the called module TA0040 to validate & convert dates.*/
   /* ------------------------------------------------------------*/

  TA2REC.TA2GRTYP = "G"; /* Type*/
  TA2REC.TA2DTOPT = "GREGGREG"; /* Validate and get all greg formats*/

   /* ------------------------------------------------------------*/
   /* Call TA0040*/
   /* ------------------------------------------------------------*/

  try
    call "TA0040" (TA2REC) {isNoRefresh = yes, isExternal = yes};
  end /* Date routine*/

   /* ------------------------------------------------------------*/
   /* If unsuccesful call, indicate a system error has occurred.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/
    return;
  else
    TAEREC.TAEDESC1 = sysVar.errorCode; /* CSP return code*/
    TAEREC.TAEDESC2 = TA2REC.TA2GRGG; /* date sent to validate*/

    converseLib.validationFailed(01); /* Indicate system error*/

    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    TA1REC.TA1TYPE = "APPL"; /* Type of error*/
    TA1REC.TA1LOC = "CALL TO TA0040 TO CALC DATE  ";
    TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
    TA1REC.TA1PGMNO = "XSPCS60"; /* Program number*/
    TA1REC.TA1MAPAP = COMMAREA.CACURRAP; /* Map application*/

    call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

    exit stack; /* Exit to display map*/
  end

end // end XSPCS60

// Select (S1) Set/Open  VFYPO001
Function XSPCS71()
   /* ------------------------------------------------------------*/
    /* Call on the Select Set Open cursor*/
   /* ------------------------------------------------------------*/

  try
    call "VFYPO002" ("S1", SQLCA, VFYPO002) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/
    return;
  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  end

  PC5REC.XXXPRCNM = "XSPCS71"; /* Process name*/

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "XSPCS71"; /* Process name*/
  TA1REC.TA1LOC = "DECLARE CURSOR          ";
  TA1REC.TA1DBASE = "DPRODC  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VFYPO002"; /* Table view name*/
  TA1REC.TA1TBLKE = VFYPO002.VFYPO002-KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack;


   /* **                                                        ***/
   /* ********************** End of XSPCS71 ***********************/
end // end XSPCS71

// Fetch  (N1) Next row  VFYPO001
Function XSPCS72()
   /* ------------------------------------------------------------*/
   /* If row not found return to previous process.*/
   /* If any other, indicate system error.*/
   /* ------------------------------------------------------------*/

  try
    call "VFYPO002" ("N1", SQLCA, VFYPO002) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Row found*/
      return;
    end
    if (SQLCA.VAGen_SQLCODE == 100) /* Row not found*/
      PC5REC.PC5WSWT = "Y"; /* Indicate temp cursor at EOF*/
      return;
    end

  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  end

  PC5REC.XXXPRCNM = "XSPCS72";

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "XSPCS72"; /* Process name*/
  TA1REC.TA1LOC = "FETCH ROW               ";
  TA1REC.TA1DBASE = "DPRODC  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VFYPO002"; /* Table view name*/
  TA1REC.TA1TBLKE = VFYPO002.VFYPO002-KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack;


   /* **                                                        ***/
   /* ********************** End of XSPCS72 ***********************/
end // end XSPCS72

// Close  (C1) Set       VFYPO001
Function XSPCS73()
   /* ------------------------------------------------------------*/
   /* Close cursor for VFYPO002*/
   /* ------------------------------------------------------------*/

  try
    call "VFYPO002" ("C1", SQLCA, VFYPO002) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/
    return;
  end

  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  end

  PC5REC.XXXPRCNM = "XSPCS73"; /* ===> process identification*/

  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "XSPCS73"; /* Process name*/
  TA1REC.TA1LOC = "CLOSE CURSOR            ";
  TA1REC.TA1DBASE = "DPRODC  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VFYPO002"; /* Table view name*/
  TA1REC.TA1TBLKE = VFYPO002.VFYPO002-KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack;

   /* **                                                        ***/
   /* ********************** End of XSPCS73 ***********************/
end // end XSPCS73

// accumulate the size QTYs
Function XSPCS74()
   /* ------------------------------------------------------------*/
   /* If there is size quanitities in the size quantity array*/
   /* accumulate them  by size position.*/
   /* ---> Three size arrays and totals are calc. in this loop*/
        /* 1. for both receiving status codes of (10,11,13)*/
        /* 2. for      receiving status code  of (10)*/
        /* 3. for      receiving status code  of (12)*/
   /* ------------------------------------------------------------*/

  PC5REC.PC5WIXT = 1; /* Initialize general index*/

  while (PC5REC.PC5WIXT <= 40)

    if (VFYPO002.PCMRCPTQ[PC5WIXT] != 0)

      PC5REC.PC5WRCV = VFYPO002.PCMRCPTQ[PC5WIXT];

      if (VFYPO002.YRSCD == "10" /* ===> receiving status code (good)*/
       || VFYPO002.YRSCD == "11" /* ===> receiving status code (good)*/
       || VFYPO002.YRSCD == "13") /* ===> receiving status code (good)*/
        PC5REC.PC5RECV[PC5WIXT] = PC5REC.PC5RECV[PC5WIXT] + PC5REC.PC5WRCV;
        PC5REC.PC5TRECV = PC5REC.PC5TRECV + PC5REC.PC5WRCV;
      end

      if (VFYPO002.YRSCD == "10") /* ===> receiving status code (good)*/
        PC5REC.PC5RCV10[PC5WIXT] = PC5REC.PC5RCV10[PC5WIXT] + PC5REC.PC5WRCV;
        PC5REC.PC5TRV10 = PC5REC.PC5TRV10 + PC5REC.PC5WRCV;
      end

      if (VFYPO002.YRSCD == "12") /* ===> receiving status code (error)*/
        PC5REC.PC5RCV12[PC5WIXT] = PC5REC.PC5RCV12[PC5WIXT] + PC5REC.PC5WRCV;
        PC5REC.PC5TRV12 = PC5REC.PC5TRV12 + PC5REC.PC5WRCV;
      end

    end

    PC5REC.PC5WIXT = PC5REC.PC5WIXT + 1;

  end /* ===>while more sizes*/

   /* **                                                        ***/
   /* ********************** End of XSPCS74 ***********************/
end // end XSPCS74

// Select (S7) Set/Open  VPOITM05
Function XSPCS81()
   /* ------------------------------------------------------------*/
   /* Select the requested set of rows from the table.*/
   /* ------------------------------------------------------------*/

  if (PC5REC.XGPCD == "02")
    PCYREC.PCYFUNC = "S8";
  else
    PCYREC.PCYFUNC = "S7";
  end

  try
    call "VPOITM05" (PCYREC, SQLCA, VPOITM05) {isNoRefresh = yes, isExternal = yes};
  end /* Select table*/

   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/


  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  PC5REC.XXXPRCNM = "XSPCS81"; /* Module identification*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/


  end


  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "SELECT SET OF TABLE ROWS";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNM = "XSPCS81"; /* Program number*/
  TA1REC.TA1DBASE = "DPRODC  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VPOITM05"; /* Table view name*/
  TA1REC.TA1TBLKE = VPOITM05.VPOITM05-KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


   /* **                                                        ***/
   /* ********************** End of XSPCS81 ***********************/
end // end XSPCS81

// Fetch  (N7) Next row  VPOITM05
Function XSPCS82()
   /* ------------------------------------------------------------*/
   /* Fetch the next row to display from the table.*/
   /* ------------------------------------------------------------*/

  if (PC5REC.XGPCD == "02")
    PCYREC.PCYFUNC = "N8";
  else
    PCYREC.PCYFUNC = "N7";
  end

  try
    call "VPOITM05" (PCYREC, SQLCA, VPOITM05) {isNoRefresh = yes, isExternal = yes};
  end /* Fetch next*/

   /* ------------------------------------------------------------*/
   /* If successful, check for multiple styles*/
                /* , save the data in pcwrec storage.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/

    if (SQLCA.VAGen_SQLCODE == 0) /* Normal return code*/

      return;

    end

    /* ------------------------------------------------------------*/
     /* If end of selected set, indicate end of cursor.*/
    /* ------------------------------------------------------------*/

    if (SQLCA.VAGen_SQLCODE == 100) /* End of selected set*/


      PC5REC.PC5WSWT = "Y"; /* Indicate end of cursor*/

      return; /* Return to previous process*/

    end

  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/
  PC5REC.XXXPRCNM = "XSPCS82"; /* Module identification*/

  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback(); /* ===> rollback all changes*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/


  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "FETCH NEXT TABLE ROW";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNM = "XSPCS82"; /* Program number*/
  TA1REC.TA1DBASE = "DPRODC  "; /* ===> Data base name*/
  TA1REC.TA1TBLVU = "VPOITM05"; /* ===> Table view name*/

  TA1REC.TA1TBLKE = VPOITM05.VPOITM05-KEY; /* ===>Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


   /* **                                                        ***/
   /* ********************** End of XSPCS82 ***********************/
end // end XSPCS82

// Select (S ) Unique    VPOSIZ02
Function XSPCS83()
   /* ------------------------------------------------------------*/
   /* Initialize the key information for select call*/
   /* ------------------------------------------------------------*/

  set VPOSIZ02 empty; /* ====> row storage area*/


  VPOSIZ02.PO-REG-CD = VPOITM05.PO-REG-CD;
  VPOSIZ02.XGPCD = VPOITM05.XGPCD;
  VPOSIZ02.PC3PONBR = VPOITM05.PC3PONBR;
  VPOSIZ02.PC6ITMNB = VPOITM05.PC6ITMNB; /* ===> current item seq nb;*/

   /* ------------------------------------------------------------*/
   /* Select unique row from the P.O. Size Table.*/
   /* ------------------------------------------------------------*/

  try
    call "VPOSIZ02" ("S ", SQLCA, VPOSIZ02) {isNoRefresh = yes, isExternal = yes};
  end

   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/

    if (SQLCA.VAGen_SQLCODE == 0 /* and normal return code*/
     || SQLCA.VAGen_SQLCODE == 100) /* and normal return code*/

      return; /* Return to previous process*/

    end

  end

  PC5REC.XXXPRCNM = "XSPCS83"; /* Module identification*/


   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(11); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/


  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "SELECT UNIQUE SIZE TABLE ROW";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNM = "XSPCS83"; /* Program number*/
  TA1REC.TA1DBASE = "DPRODC  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VPOSIZ02"; /* Table view name*/
  TA1REC.TA1TBLKE = VPOSIZ02.VPOSIZ02-KEY; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/

   /* **                                                        ***/
   /* ********************** End of XSPCS83 ***********************/
end // end XSPCS83

// Close  (C7) Set       VPOITM05
Function XSPCS84()
   /* ------------------------------------------------------------*/
   /* Close the selected set of table rows.*/
   /* ------------------------------------------------------------*/

  if (PC5REC.XGPCD == "02")
    PCYREC.PCYFUNC = "C8";
  else
    PCYREC.PCYFUNC = "C7";
  end

  try
    call "VPOITM05" (PCYREC, SQLCA, VPOITM05) {isNoRefresh = yes, isExternal = yes};
  end /* Close table*/

   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback(); /* ===> roll back all changes*/

  PC5REC.XXXPRCNM = "XSPCS84"; /* Module identification*/
  converseLib.validationFailed(10); /* Indicate system error*/

  TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "CLOSE SELECTED SET OF TABLE ROWS";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNM = "XSPCS84"; /* Program number*/
  TA1REC.TA1DBASE = "DPRODC  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VPOITM05"; /* Table view name*/

  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


   /* **                                                        ***/
   /* ********************** End of XSPCS84 ***********************/
end // end XSPCS84

// Update oa and change memo flag
Function XSPCSA8()
   /* ------------------------------------------------------------*/
   /* Determine if the Change memo flag is set and load the*/
   /* appropriate change memo flag accordingly*/
    /* same for oa memo*/
   /* ------------------------------------------------------------*/


  if (VPOAHD02.YOACD in YOATBL.YOACD) /* ===> Code is in table*/

    if (YOATBL.YOACMFL[sysVar.arrayIndex] == "Y") /* ===> change memo flag*/
      VPOAHD02.PCJMEMO = " ";
    else
      VPOAHD02.PCJMEMO = "N";
    end

    if (YOATBL.YOAADJFL[sysVar.arrayIndex] == "Y") /* ===> oa memo flag*/
      VPOAHD02.PCJOAPRT = " ";
    else
      VPOAHD02.PCJOAPRT = "N";
    end

  else /* ===> code not in table*/

    converseLib.validationFailed(139); /* Indicate missing or invalid*/

    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback(); /* ===> rollback all changes*/

    exit stack;

  end


   /* **                                                        ***/
   /* ********************** End of xspcsa8 ***********************/
end // end XSPCSA8

// transfer to the help system
Function XSPF1()



   /* ************************************************************/
      /* this statement group is to call the online documenta-*/
      /* tion system, 'gd00'.  (the 'help' system)*/
   /* ************************************************************/

  COMMAREA.CATOAP = "GD00";
  XSEXIT();




end // end XSPF1

// transfer to the main menu
Function XSPF4()



   /* ************************************************************/
      /* transfer control to the main menu.*/
   /* ************************************************************/

  COMMAREA.CATOAP = "MN0M";
  XSEXIT();




end // end XSPF4

// Exit to another application
Function XSPG002()
   /* ------------------------------------------------------------*/
   /* Set the application to be invoked for PF1 or PF4.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf1) /* PF1 was pressed*/

    COMMAREA.CATOAP = "GD01"; /* Indicate Goal Documentation*/

  else
    if (converseVar.eventKey is pf4) /* PF4 was pressed*/

      COMMAREA.CATOAP = "MN0M"; /* Indicate Master Menu*/

    else

      /* ------------------------------------------------------------*/
       /* Set the application to be invoked for PF3 if in main menu.*/
      /* ------------------------------------------------------------*/

      if (converseVar.eventKey is pf3 /* PF3 was pressed*/
       || converseVar.eventKey is pf5) /* PF5 was pressed*/
        COMMAREA.CATOAP = "FY0M"; /* Indicate Master Menu*/
      end
    end
  end

   /* ------------------------------------------------------------*/
   /* Save the application user area in the COMMAREA.*/
   /* ------------------------------------------------------------*/

  COMMAREA.CAFRMSYS = "PG"; /* comming from pg system*/
  COMMAREA.CAUSERA = " "; /* Clear user area*/

  if (COMMAREA.CATOSYS == "PG") /* Transfer within same system*/
    COMMAREA.CAUSERA = PGXREC.CAUSERA;
  else
    /* NEXT SENTENCE*/
  end

   /* ------------------------------------------------------------*/
   /* Transfer control to the specified application.*/
   /* ------------------------------------------------------------*/

  COMMAREA.CAFROMAP = COMMAREA.CACURRAP; /* From application*/
  XSEXIT(); /* Exit to another application*/

   /* ------------------------------------------------------------*/
   /* If transfer failed, return an error to the calling process.*/
   /* ------------------------------------------------------------*/

  COMMAREA.CAITEM = " "; /* Clear any application data*/

  if (COMMAREA.CASECRC == 3 /* Application not found*/
   || COMMAREA.CASECRC == 4) /* or transfer not allowed*/

    converseLib.validationFailed(6); /* Indicate not allowed*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/

  end


end // end XSPG002

// Get style from DPRODG.VSYCLR01
Function XSPG201()

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* This subroutine accesses the Production Style/Color Table*/
   /* and returns the first row found for a GPC/Style number.*/

   /* XGPCD and SY1STNBR must be specified by the calling process*/
   /* in PG2REC.  The name of the calling process must be moved*/
   /* to TA1PGMNM in TA1REC, for Error Diagnosis Reporting.*/

   /* This subroutine will return the CSP return code in EZERT8,*/
   /* the DB2 return code in SQLCA.SQLCODE and, if a normal*/
   /* return, the table row in PG2REC.*/

   /* This subroutine will do any required Error Diagnosis*/
   /* Reporting to TA0020.  The calling process must check the*/
   /* return codes and take the appropriate action relating to*/
   /* its terminal output.  The calling process does not need to*/
   /* do any Error Diagnosis Reporting.*/

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* ------------------------------------------------------------*/
   /* Select the set of rows from Production Style/Color Table.*/
   /* ------------------------------------------------------------*/

  try
    call "IO3120" ("SS", SQLCA, PG2REC) {isNoRefresh = yes, isExternal = yes};
  end /* Select table set*/

   /* ------------------------------------------------------------*/
   /* If successful, continue to fetch the first selected row.*/
   /* If data not available, post an error message and return.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/

     /* NEXT SENTENCE               ; Next sentence*/

  else

    TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
    TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

    TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
    TA1REC.TA1LOC = "XSPG201 SELECT STYLE NUMBER SET";
    TA1REC.TA1DBASE = "DPRODG  "; /* Data base name*/
    TA1REC.TA1TBLVU = "VSYCLR01"; /* Table view name*/
    TA1REC.TA1TBLKE = PG2REC.PG2KEY; /* Table key*/

    if (sysVar.errorCode == "00000000" /* Call successful*/
     && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

      TA1REC.TA1FUNC = "POST"; /* Termination function*/
      call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    else

      TA1REC.TA1FUNC = "RETN"; /* Termination function*/
      call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

    end

    sysVar.errorCode = TA1REC.TA1MAP; /* CSP return code*/
    SQLCA.SQLCAREC = TAEREC.SQLCAREC; /* SQL commarea*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* Fetch the first row from Production Style/Color Table.*/
   /* ------------------------------------------------------------*/

  try
    call "IO3120" ("SN", SQLCA, PG2REC) {isNoRefresh = yes, isExternal = yes};
  end /* Fetch table row*/

   /* ------------------------------------------------------------*/
   /* Save the CSP return code and SQL commarea from the fetch.*/
   /* If successful or row not found, continue to close the set.*/
   /* If data not available, post an error message and return.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/

     /* NEXT SENTENCE               ; Next sentence*/

  else

    if (sysVar.errorCode == "00000000" /* Call successful*/
     && SQLCA.VAGen_SQLCODE == 100)    /* and row not found*/

       /* NEXT SENTENCE               ; Next sentence*/

    else

      TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
      TA1REC.TA1LOC = "XSPG201 FETCH FIRST STYLE NUMBER";
      TA1REC.TA1DBASE = "DPRODG  "; /* Data base name*/
      TA1REC.TA1TBLVU = "VSYCLR01"; /* Table view name*/
      TA1REC.TA1TBLKE = PG2REC.PG2KEY; /* Table key*/

      if (sysVar.errorCode == "00000000" /* Call successful*/
       && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

        TA1REC.TA1FUNC = "POST"; /* Termination function*/
        call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes};
                                   /* Error diagnosis routine*/

      else

        TA1REC.TA1FUNC = "RETN"; /* Termination function*/
        call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

      end

      sysVar.errorCode = TA1REC.TA1MAP; /* CSP return code*/
      SQLCA.SQLCAREC = TAEREC.SQLCAREC; /* SQL commarea*/

      return; /* Return to previous process*/

    end

  end

   /* ------------------------------------------------------------*/
   /* Close the set of rows from Production Style/Color Table.*/
   /* ------------------------------------------------------------*/

  try
    call "IO3120" ("CS", SQLCA, PG2REC) {isNoRefresh = yes, isExternal = yes};
  end /* Close table set*/

   /* ------------------------------------------------------------*/
   /* If successful, continue to return to the calling process.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/

     /* NEXT SENTENCE               ; Next sentence*/

  else

    TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
    TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

    TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
    TA1REC.TA1LOC = "XSPG201 CLOSE STYLE NUMBER SET";
    TA1REC.TA1DBASE = "DPRODG  "; /* Data base name*/
    TA1REC.TA1TBLVU = "VSYCLR01"; /* Table view name*/
    TA1REC.TA1TBLKE = PG2REC.PG2KEY; /* Table key*/

    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

  end

   /* ------------------------------------------------------------*/
   /* Restore the CSP return code and SQL commarea.*/
   /* ------------------------------------------------------------*/

  sysVar.errorCode = TA1REC.TA1MAP; /* CSP return code*/
  SQLCA.SQLCAREC = TAEREC.SQLCAREC; /* SQL commarea*/


end // end XSPG201

// Select row in DPRODG.VSYCLR01
Function XSPG202()

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* This subroutine accesses the Production Style/Color Table*/
   /* and returns the row for a GPC/Style/Color/Dimension.*/

   /* XGPCD, SY1STNBR, SY2CLRID and XDMCD must be specified by*/
   /* the calling process in PG2REC.  The name of the calling*/
   /* process must be moved to TA1PGMNM in TA1REC, for Error*/
   /* Diagnosis Reporting.*/

   /* This subroutine will return the CSP return code in EZERT8,*/
   /* the DB2 return code in SQLCA.SQLCODE and, if a normal*/
   /* return, the table row in PG2REC.*/

   /* This subroutine will do any required Error Diagnosis*/
   /* Reporting to TA0020.  The calling process must check the*/
   /* return codes and take the appropriate action relating to*/
   /* its terminal output.  The calling process does not need to*/
   /* do any Error Diagnosis Reporting.*/

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* ------------------------------------------------------------*/
   /* Select the row from Production Style/Color Table.*/
   /* ------------------------------------------------------------*/

  try
    call "IO3120" ("S ", SQLCA, PG2REC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

   /* ------------------------------------------------------------*/
   /* If successful or row not found, return to calling process.*/
   /* If data not available, post an error message and return.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/

    if (SQLCA.VAGen_SQLCODE == 0 /* Normal return code*/
     || SQLCA.VAGen_SQLCODE == 100) /* or row not found*/

      return; /* Return to previous process*/

    end

  end

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "XSPG202 SELECT STYLE/COLOR ROW";
  TA1REC.TA1DBASE = "DPRODG  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VSYCLR01"; /* Table view name*/
  TA1REC.TA1TBLKE = PG2REC.PG2KEY; /* Table key*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    TA1REC.TA1FUNC = "POST"; /* Termination function*/
    call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  else

    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

  end

  sysVar.errorCode = TA1REC.TA1MAP; /* CSP return code*/
  SQLCA.SQLCAREC = TAEREC.SQLCAREC; /* SQL commarea*/


end // end XSPG202

// Size description translation
Function XSPG301()

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* This subroutine accesses the Production Style/Color and the*/
   /* Product Scale Tables and returns the Size Identification,*/
   /* Size Description and Division Code for all valid sizes of a*/
   /* GPC/Style/Color/Dimension.*/

   /* *** Code the following before this is executed:         ****/
   /* ***                                                     ****/
   /* ***   PG3REC.PG3FUNCD: PC = all valid sizes             ****/
   /* ***                    IE = int. sz id to desc.         ****/
   /* ***                    EI = desc. to int. sz id         ****/
   /* ***                                                     ****/
   /* ***   PG3REC.PG3DATFM: C = compressed (first blank or   ****/
   /* ***                        zero is end of data)         ****/
   /* ***                    N = not compressed (positional)  ****/
   /* ***                                                     ****/
   /* ***   PG3REC.PG3XDVCD: Highest division code to return. ****/
   /* ***                    Valid codes are '01','02','03'.  ****/
   /* ***                    Blank defaults to all divisions. ****/
   /* ***                                                     ****/
   /* ***   TA1REC.TA1PGMNM: The name of the calling process, ****/
   /* ***                    for Error Diagnosis Reporting.   ****/

   /* This subroutine will return the CSP return code in EZERT8,*/
   /* the Size Translation Subroutine return code in PG3RETCD*/
   /* and, if a normal return, the size information in PG3SIZES.*/

   /* *** Both return codes must indicate normal return.      ****/
   /* ***                                                     ****/
   /* ***   EZERT8                                            ****/
   /* ***   ------                                            ****/
   /* ***   '00000000' = Normal return                        ****/
   /* ***   OTHER      = Unexpected error has occurred        ****/
   /* ***                                                     ****/
   /* ***   PG3REC.PG3RETCD                                   ****/
   /* ***   ---------------                                   ****/
   /* ***   '00'  = Normal return                             ****/
   /* ***   '09'  = Data in use by another application        ****/
   /* ***   OTHER = Unexpected error has occurred             ****/

   /* This subroutine will do any required Error Diagnosis*/
   /* Reporting to TA0020.  The calling process must check the*/
   /* return codes and take the appropriate action relating to*/
   /* its terminal output.  The calling process does not need to*/
   /* do any Error Diagnosis Reporting.*/

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

   /* ------------------------------------------------------------*/
   /* Obtain size descriptions from Size Translation Subroutine.*/
   /* ------------------------------------------------------------*/

  try
    call "PG1050" (SQLCA, PG3REC) {isNoRefresh = yes, isExternal = yes};
  end /* Size translation*/

   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && PG3REC.PG3RETCD == "00")       /* and normal return*/

    return; /* Return to previous process*/

  end
  if (sysVar.errorCode == "00000000"
   && SQLCA.VAGen_SQLCODE == 100)

   /* MOVE 114 TO EZEMNO;*/
    return;

  end

   /* ------------------------------------------------------------*/
   /* If data not available, post an error message and return.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && PG3REC.PG3RETCD == "09")       /* and resource not available*/

    TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
    TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

    TA1REC.TA1FUNC = "POST"; /* Termination function*/
    TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
    TA1REC.TA1DBASE = "DPRODG  "; /* Data base name*/
    TA1REC.TA1TBLVU = "VSYCLR01"; /* Table view name*/
    TA1REC.TA1LOC = "XSPG301 DESCRIPTION TRANSLATION";
    TA1REC.TA1TBLKE = PG3REC.PG3KEY; /* Table key*/

    call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  else

    if (sysVar.errorCode == "00000000" /* Call successful*/
     && PG3REC.PG3RETCD == "99")       /* and negative SQL error*/

      TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
      TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

      TA1REC.TA1FUNC = "RETN"; /* Termination function*/
      TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
      TA1REC.TA1DBASE = "DPRODG  "; /* Data base name*/
      TA1REC.TA1TBLVU = "VSYCLR01"; /* Table view name*/
      TA1REC.TA1TBLKE = PG3REC.PG3KEY; /* Table key*/
      TA1REC.TA1LOC = "XSPG301 DESCRIPTION TRANSLATION";

      call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

    else

      TAEREC.TAEDESC1 = sysVar.errorCode; /* CSP return code*/
      TAEREC.TAEDESC2 = PG3REC.PG3GROUP; /* Subroutine parameters*/

      TA1REC.TA1FUNC = "RETN"; /* Termination function*/
      TA1REC.TA1TYPE = "APPL"; /* Type of error*/
      TA1REC.TA1LOC = "XSPG301 DESCRIPTION TRANSLATION";

      call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

    end

  end


end // end XSPG301

// Select date of last month end
Function XSPIS-IO5950()
   /* ------------------------------------------------------------*/
   /* Select the date of the last month end run.*/
   /* ------------------------------------------------------------*/


  try
    call "IO5950" ("S ", SQLCA, PIGREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select record*/

   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that an unexpected error has occurred.*/
   /* ------------------------------------------------------------*/

  TAEREC.TAEDESC1 = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    converseLib.validationFailed(11); /* Data in use by another*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/

  else

    converseLib.validationFailed(10); /* Unexpected error occurred*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/

  end

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "SELECT ROW      ";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = "S-IO"; /* Program number*/
  TA1REC.TA1DBASE = "DPAIRC  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VPIPGM01"; /* Table view name*/
  TA1REC.TA1TBLKE = PIGREC.XXXPGMNO; /* Table key*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end XSPIS-IO5950

// Get todays date
Function XSPIS-TA0040()
   /* ------------------------------------------------------------*/
   /* Get todays date*/
   /* ------------------------------------------------------------*/


  try
    call "TA0040" (TA2REC) {isNoRefresh = yes, isExternal = yes};
  end /* get date*/

   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/
    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TAEREC.TAEDESC1 = sysVar.errorCode; /* CSP return code*/
  TAEREC.TAEDESC2 = TA2REC.TA2GROUP; /* /Subroutine parameters*/

  TA1REC.TA1PGMNO = "S-TA"; /* Module identification*/
  converseLib.validationFailed(10); /* Unexpected error occured*/

  TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  TA1REC.TA1TYPE = "APPL"; /* Type of error*/
  TA1REC.TA1LOC = "GETDATE "; /* Parameter*/
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = "S01 "; /* Program number*/

  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

  exit stack; /* Exit to display map*/


end // end XSPIS-TA0040

// Exit to another application
Function XSPIS01()
   /* ------------------------------------------------------------*/
   /* Set the application to be invoked for PF1 or PF4.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf1) /* PF1 was pressed*/
    COMMAREA.CATOAP = "GD01"; /* Indicate Goal Documentation*/
  end

  if (converseVar.eventKey is pf4) /* PF4 was pressed*/
    COMMAREA.CATOAP = "MN0M"; /* Indicate Master Menu*/
  end

   /* ------------------------------------------------------------*/
   /* Save the application user area in the COMMAREA.*/
   /* ------------------------------------------------------------*/

  if (COMMAREA.CATOSYS == COMMAREA.CACURSYS) /* Same system*/

    COMMAREA.CAUSERA = PIWREC.CAUSERA; /* Save user area*/
  else
    COMMAREA.CAUSERA = " "; /* Clear user area*/

  end

   /* ------------------------------------------------------------*/
   /* Transfer control to the specified application.*/
   /* ------------------------------------------------------------*/

  XSEXIT(); /* Exit to another application*/

   /* ------------------------------------------------------------*/
   /* Reestablish the COMMAREA application and item fields.*/
   /* ------------------------------------------------------------*/

  COMMAREA.CAEZSG3 = "0"; /* Force zero third character*/
  COMMAREA.CACURRAP = COMMAREA.CAEZSAP; /* CURR application*/

  if (converseVar.eventKey is pfkey) /* PF key was pressed*/

    COMMAREA.CATOAP = " "; /* Clear TO application*/

    if (converseVar.eventKey is pf1) /* PF1 was pressed*/
      COMMAREA.CAITEM = " "; /* Clear map name from item*/
    end

  end


end // end XSPIS01

// OB SYSTEM - CALL TO SY2000
Function XSPK-CALL-SY2000()

     /* Get the Product/Region record*/

  set SQLCA empty;
  set WSY2000 empty;

  WSY2000.XGP-GPC-CD = PKNREC.XGPCD;
  WSY2000.SY-STY-NBR = PKNREC.SY1STNBR;
  WSY2000.SY-COLR-CD-ID = PKNREC.SY2CLRID;
  WSY2000.XDM-DIM-CD = PKNREC.XDMCD;
  WSY2000.XDR-PROD-REG-CD = "05";
  WSY2000.WSY2000-OPTION-CODE = "S ";
  WSY2000.WSY2000-SUB-OPTION-CODE = "O";

  call "SY2000" (WSY2000) {isNoRefresh = yes, isExternal = yes};

   /* Product/Region record is found*/
   /* Overlay those fields common to both records*/

  if (WSY2000.WSY2000-RETURN-CODE == 0)
    PKNREC.XPRCD = WSY2000.XPR-PROD-TYP-CD;
    PKNREC.XLCCD1 = WSY2000.XLC-LIFE-CYC-CD[1];
    PKNREC.XLCCD2 = WSY2000.XLC-LIFE-CYC-CD[2];
    PKNREC.XLCCD3 = WSY2000.XLC-LIFE-CYC-CD[3];
    PKNREC.XLCCD4 = WSY2000.XLC-LIFE-CYC-CD[4];
    PKNREC.SY2CEDT1 = WSY2000.SY-LIFE-CYC-EDT[1];
    PKNREC.SY2CEDT2 = WSY2000.SY-LIFE-CYC-EDT[2];
    PKNREC.SY2CEDT3 = WSY2000.SY-LIFE-CYC-EDT[3];
    PKNREC.SY2CEDT4 = WSY2000.SY-LIFE-CYC-EDT[4];
  else

    /* Database DPROD.VSYREG02 is busy*/

    if (WSY2000.WSY2000-RETURN-CODE == 98)
      /* next sentence*/
    else

      /* Record is not found*/

      if (WSY2000.WSY2000-RETURN-CODE == 02)
        /* next sentence*/
      else

        /* Bad return code*/

        TA1REC.TA1TYPE = "APPL";
        TA1REC.TA1FUNC = "POST";
        XSPKW01.XSPKW-WSY2000-GPC-CD = PKNREC.XGPCD;
        XSPKW01.XSPKW-WSY2000-STY-NBR = PKNREC.SY1STNBR;
        XSPKW01.XSPKW-WSY2000-COLR-CD = PKNREC.SY2CLRID;
        XSPKW01.XSPKW-WSY2000-DIM-CD = PKNREC.XDMCD;
        XSPKW01.XSPKW-WSY2000-PROD-REG-CD = WSY2000.XDR-PROD-REG-CD;
        XSPKW01.XSPKW-WSY2000-RETURN-CD = WSY2000.WSY2000-RETURN-CODE;
        TAEREC.TAEDESC1 = XSPKW-WSY2000-POST-1;
        TAEREC.TAEDESC2 = "CALL TO SY2000 - BAD RETURN CODE";
        TA1REC.TA1DBASE = "DPROD";
        TA1REC.TA1TBLVU = "SYREG02";
        try
          call "TA0020" (TA1REC, TAEREC) {isExternal = yes};
        end
      end
    end
  end
end // end XSPK-CALL-SY2000

// close : location : 0
Function XSPK4C3()


   /* ************************************************************/
   /* *** close select set of: destination table              ****/
   /* *** using the standard i/o processing version #0        ****/
   /* *** note: sqlcq.sqlcode used re: can't "set" ezesqcod   ****/
   /* *** setup the following just before this is executed:   ****/
   /* ***   TA1REC.TA1LOCAT(2) = what executes this sgrp      ****/
   /* ***   TA1REC.TA1MAP      = what map this data is from   ****/
   /* *** code the action for the following return codes:     ****/
   /* ***      0 = successful - continue                      ****/
   /* ***   -507 = cursor already closed - return 0           ****/
   /* ***     <0 = db/severe error - contact programming msg  ****/
   /* ***          note: clear screen & put keys back         ****/
   /* ***          note: TA0020 will have been executed       ****/
   /* ***                within this sgrp for <0 only         ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** close select set (if prior to EOF)                  ****/
   /* ************************************************************/

  PWIREC.PWIFUNC = "C3";
  call "IO1720" (PWIREC, SQLCA, PK4REC) {isNoRefresh = yes, isExternal = yes}; /* <=== close select set*/

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -501)
    SQLCA.VAGen_SQLCODE = 0;
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSPK4C0 ";
  TA1REC.TA1LOCAT[1] = "IO1720  ";
  TA1REC.TA1LOCAT[3] = "CLOSE   ";
  TA1REC.TA1LOCAT[4] = "SETINQ  ";
  TA1REC.TA1DBASE = "DPICK   ";
  TA1REC.TA1TBLVU = "VPOOLH01";
  TA1REC.TA1TBLKE = PK4REC.PK4KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
  XSPF4();

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSPK4C3

// inquiry : location : 0
Function XSPK4I0()


   /* ************************************************************/
   /* *** select unique row from: destination table           ****/
   /* *** using the standard i/o processing version #0        ****/
   /* *** note: second fetch used to detect duplicate rows    ****/
   /* *** note: sqlcq.sqlcode used re: can't "set" ezesqcod   ****/
   /* *** note: IO process(s) do all rec/row moves so that    ****/
   /* ***       the final result will be in the record        ****/
   /* *** setup the following just before this is executed:   ****/
   /* ***   TA1REC.TA1LOCAT(2) = what executes this sgrp      ****/
   /* ***   TA1REC.TA1MAP      = what map this data is from   ****/
   /* *** code the action for the following return codes:     ****/
   /* ***      0 = successful - continue                      ****/
   /* ***   +100 = not found - setup not fnd error/msg        ****/
   /* ***   -911 = deadlock - setup try again error/msg       ****/
   /* ***   -811 = duplicates found - contact programming msg ****/
   /* ***          note: do NOT clear screen                  ****/
   /* ***     <0 = db/severe error - contact programming msg  ****/
   /* ***          note: clear screen & put keys back         ****/
   /* ***          note: TA0020 will have been executed       ****/
   /* ***                within this sgrp for <0 only         ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** select row with unique key                          ****/
   /* ************************************************************/

  PWIREC.PWIFUNC = "S ";
  call "IO1720" (PWIREC, SQLCA, PK4REC) {isNoRefresh = yes, isExternal = yes}; /* <=== select unique*/

  if (SQLCA.VAGen_SQLCODE == -911)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -811) /* duplicate*/
    XSPK4S3();
    XSPK4C3();
  end

  if (SQLCA.VAGen_SQLCODE < 0)
    TA1REC.TA1TYPE = "DB2 ";
    TA1REC.TA1FUNC = "RETN";
    TA1REC.TA1PGMNM = "XSPK4I0 ";
    TA1REC.TA1LOCAT[1] = "IO1720  ";
    TA1REC.TA1LOCAT[3] = "SELECT  ";
    TA1REC.TA1LOCAT[4] = "SET     ";
    TA1REC.TA1DBASE = "DPICK   ";
    TA1REC.TA1TBLVU = "VPOOLH01";
    TA1REC.TA1TBLKE = PK4REC.PK4KEY;
    move SQLCA to ERRSQLCA withV60Compat;
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback();
    call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
    XSPF4();
  end

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSPK4I0

// setinq : location : 0
Function XSPK4S3()


   /* ************************************************************/
   /* *** select set of rows from: destination table          ****/
   /* *** using the standard i/o processing version #0        ****/
   /* *** note: sqlcq.sqlcode used re: can't "set" ezesqcod   ****/
   /* *** note: +100 - not found can't be detected until the  ****/
   /* ***       first fetch is executed                       ****/
   /* *** setup the following just before this is executed:   ****/
   /* ***   TA1REC.TA1LOCAT(2) = what executes this sgrp      ****/
   /* ***   TA1REC.TA1MAP      = what map this data is from   ****/
   /* *** code the action for the following return codes:     ****/
   /* ***      0 = successful - continue                      ****/
   /* ***   +100 = none found - setup not fnd error/msg       ****/
   /* ***   -911 = deadlock - setup try again error/msg       ****/
   /* ***     <0 = db/severe error - contact programming msg  ****/
   /* ***          note: clear screen & put keys back         ****/
   /* ***          note: TA0020 will have been executed       ****/
   /* ***                within this sgrp for <0 only         ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** select set with unique key                          ****/
   /* ************************************************************/

  PWIREC.PWIFUNC = "S3";
  call "IO1720" (PWIREC, SQLCA, PK4REC) {isNoRefresh = yes, isExternal = yes}; /* <=== select set row*/

  if (SQLCA.VAGen_SQLCODE == -911)
    return;
  end

  if (SQLCA.VAGen_SQLCODE < 0)
    TA1REC.TA1TYPE = "DB2 ";
    TA1REC.TA1FUNC = "RETN";
    TA1REC.TA1PGMNM = "XSPK4S0 ";
    TA1REC.TA1LOCAT[1] = "IO1720  ";
    TA1REC.TA1LOCAT[3] = "SELECT  ";
    TA1REC.TA1LOCAT[4] = "SET     ";
    TA1REC.TA1DBASE = "DPICK   ";
    TA1REC.TA1TBLVU = "VPOOLH01";
    TA1REC.TA1TBLKE = PK4REC.PK4KEY;
    move SQLCA to ERRSQLCA withV60Compat;
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback();
    call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
    XSPF4();
  end

   /* ************************************************************/
   /* *** scan/retrieve/fetch first row                       ****/
   /* *** in order to detect not found (+100)                 ****/
   /* *** note: CSP closes cursor at end of set (+100)        ****/
   /* *** note: any loop processing must use this first row   ****/
   /* ***       and fetch the next row at the end of the loop ****/
   /* ************************************************************/

  call "IO1720" ("N3", SQLCA, PK4REC) {isNoRefresh = yes, isExternal = yes}; /* <=== select set row*/

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSPK4S3 ";
  TA1REC.TA1LOCAT[1] = "IO1720  ";
  TA1REC.TA1LOCAT[3] = "FIRST   ";
  TA1REC.TA1LOCAT[4] = "FETCH   ";
  TA1REC.TA1DBASE = "DPICK   ";
  TA1REC.TA1TBLVU = "VPOOLH01";
  TA1REC.TA1TBLKE = PK4REC.PK4KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
  XSPF4();

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSPK4S3

// close : location : 0
Function XSPK9C1()


   /* ************************************************************/
   /* *** close select set of: destination table              ****/
   /* *** using the standard i/o processing version #0        ****/
   /* *** note: sqlcq.sqlcode used re: can't "set" ezesqcod   ****/
   /* *** setup the following just before this is executed:   ****/
   /* ***   TA1REC.TA1LOCAT(2) = what executes this sgrp      ****/
   /* ***   TA1REC.TA1MAP      = what map this data is from   ****/
   /* *** code the action for the following return codes:     ****/
   /* ***      0 = successful - continue                      ****/
   /* ***   -507 = cursor already closed - return 0           ****/
   /* ***     <0 = db/severe error - contact programming msg  ****/
   /* ***          note: clear screen & put keys back         ****/
   /* ***          note: TA0020 will have been executed       ****/
   /* ***                within this sgrp for <0 only         ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** close select set (if prior to EOF)                  ****/
   /* ************************************************************/

  call "IO1790" ("C1", SQLCA, PK9REC) {isNoRefresh = yes, isExternal = yes}; /* <=== close select set*/

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -501)
    SQLCA.VAGen_SQLCODE = 0;
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSPK9C0 ";
  TA1REC.TA1LOCAT[1] = "IO1790  ";
  TA1REC.TA1LOCAT[3] = "CLOSE   ";
  TA1REC.TA1LOCAT[4] = "SETINQ  ";
  TA1REC.TA1DBASE = "DPICK   ";
  TA1REC.TA1TBLVU = "VCUHLD01";
  TA1REC.TA1TBLKE = PK9REC.PK9KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
  XSPF4();

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSPK9C1

// fetch : location : 0
Function XSPK9F1()


   /* ************************************************************/
   /* *** fetch next row from: destination table              ****/
   /* *** using the standard i/o processing version #0        ****/
   /* *** note: sqlcq.sqlcode used re: can't "set" ezesqcod   ****/
   /* *** note: +100 - not found was detected as part of the  ****/
   /* ***       select set previously executed                ****/
   /* *** setup the following just before this is executed:   ****/
   /* ***   TA1REC.TA1LOCAT(2) = what executes this sgrp      ****/
   /* ***   TA1REC.TA1MAP      = what map this data is from   ****/
   /* *** code the action for the following return codes:     ****/
   /* ***      0 = successful - continue                      ****/
   /* ***   +100 = EOF                                        ****/
   /* ***     <0 = db/severe error - contact programming msg  ****/
   /* ***          note: clear screen & put keys back         ****/
   /* ***          note: TA0020 will have been executed       ****/
   /* ***                within this sgrp for <0 only         ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** scan/retrieve/fetch next row                        ****/
   /* *** note: CSP closes cursor at end of set (+100)        ****/
   /* ************************************************************/

  call "IO1790" ("N1", SQLCA, PK9REC) {isNoRefresh = yes, isExternal = yes}; /* <=== select next row*/

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSPK9F0 ";
  TA1REC.TA1LOCAT[1] = "IO1790  ";
  TA1REC.TA1LOCAT[3] = "FETCH   ";
  TA1REC.TA1LOCAT[4] = "NEXT    ";
  TA1REC.TA1DBASE = "DPICK   ";
  TA1REC.TA1TBLVU = "VCUHLD01";
  TA1REC.TA1TBLKE = PK9REC.PK9KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
  XSPF4();

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSPK9F1

// setinq : location : 0
Function XSPK9S1()


   /* ************************************************************/
   /* *** select set of rows from: destination table          ****/
   /* *** using the standard i/o processing version #0        ****/
   /* *** note: sqlcq.sqlcode used re: can't "set" ezesqcod   ****/
   /* *** note: +100 - not found can't be detected until the  ****/
   /* ***       first fetch is executed                       ****/
   /* *** setup the following just before this is executed:   ****/
   /* ***   TA1REC.TA1LOCAT(2) = what executes this sgrp      ****/
   /* ***   TA1REC.TA1MAP      = what map this data is from   ****/
   /* *** code the action for the following return codes:     ****/
   /* ***      0 = successful - continue                      ****/
   /* ***   +100 = none found - setup not fnd error/msg       ****/
   /* ***   -911 = deadlock - setup try again error/msg       ****/
   /* ***     <0 = db/severe error - contact programming msg  ****/
   /* ***          note: clear screen & put keys back         ****/
   /* ***          note: TA0020 will have been executed       ****/
   /* ***                within this sgrp for <0 only         ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** select set with unique key                          ****/
   /* ************************************************************/

  call "IO1790" ("S1", SQLCA, PK9REC) {isNoRefresh = yes, isExternal = yes}; /* <=== select set row*/

  if (SQLCA.VAGen_SQLCODE == -911)
    return;
  end

  if (SQLCA.VAGen_SQLCODE < 0)
    TA1REC.TA1TYPE = "DB2 ";
    TA1REC.TA1FUNC = "RETN";
    TA1REC.TA1PGMNM = "XSPK9S0 ";
    TA1REC.TA1LOCAT[1] = "IO1790  ";
    TA1REC.TA1LOCAT[3] = "SELECT  ";
    TA1REC.TA1LOCAT[4] = "SET     ";
    TA1REC.TA1DBASE = "DPICK   ";
    TA1REC.TA1TBLVU = "VCUHLD01";
    TA1REC.TA1TBLKE = PK9REC.PK9KEY;
    move SQLCA to ERRSQLCA withV60Compat;
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback();
    call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
    XSPF4();
  end

   /* ************************************************************/
   /* *** scan/retrieve/fetch first row                       ****/
   /* *** in order to detect not found (+100)                 ****/
   /* *** note: CSP closes cursor at end of set (+100)        ****/
   /* *** note: any loop processing must use this first row   ****/
   /* ***       and fetch the next row at the end of the loop ****/
   /* ************************************************************/

  call "IO1790" ("N1", SQLCA, PK9REC) {isNoRefresh = yes, isExternal = yes}; /* <=== select set row*/

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSPKBS3 ";
  TA1REC.TA1LOCAT[1] = "IO1790  ";
  TA1REC.TA1LOCAT[3] = "FIRST   ";
  TA1REC.TA1LOCAT[4] = "FETCH   ";
  TA1REC.TA1DBASE = "DPICK   ";
  TA1REC.TA1TBLVU = "VCUHLD01";
  TA1REC.TA1TBLKE = PK9REC.PK9KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
  XSPF4();

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSPK9S1

// close : location : 0
Function XSPKBC1()


   /* ************************************************************/
   /* *** close select set of: destination table              ****/
   /* *** using the standard i/o processing version #0        ****/
   /* *** note: sqlcq.sqlcode used re: can't "set" ezesqcod   ****/
   /* *** setup the following just before this is executed:   ****/
   /* ***   TA1REC.TA1LOCAT(2) = what executes this sgrp      ****/
   /* ***   TA1REC.TA1MAP      = what map this data is from   ****/
   /* *** code the action for the following return codes:     ****/
   /* ***      0 = successful - continue                      ****/
   /* ***   -507 = cursor already closed - return 0           ****/
   /* ***     <0 = db/severe error - contact programming msg  ****/
   /* ***          note: clear screen & put keys back         ****/
   /* ***          note: TA0020 will have been executed       ****/
   /* ***                within this sgrp for <0 only         ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** close select set (if prior to EOF)                  ****/
   /* ************************************************************/

  call "IO1770" ("C1", SQLCA, PKBREC) {isNoRefresh = yes, isExternal = yes}; /* <=== close select set*/

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -501)
    SQLCA.VAGen_SQLCODE = 0;
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSPKBC0 ";
  TA1REC.TA1LOCAT[1] = "IO1770  ";
  TA1REC.TA1LOCAT[3] = "CLOSE   ";
  TA1REC.TA1LOCAT[4] = "SETINQ  ";
  TA1REC.TA1DBASE = "DPICK   ";
  TA1REC.TA1TBLVU = "VORHLD01";
  TA1REC.TA1TBLKE = PKBREC.PKBKEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
  XSPF4();

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSPKBC1

// fetch : location : 0
Function XSPKBF1()


   /* ************************************************************/
   /* *** fetch next row from: destination table              ****/
   /* *** using the standard i/o processing version #0        ****/
   /* *** note: sqlcq.sqlcode used re: can't "set" ezesqcod   ****/
   /* *** note: +100 - not found was detected as part of the  ****/
   /* ***       select set previously executed                ****/
   /* *** setup the following just before this is executed:   ****/
   /* ***   TA1REC.TA1LOCAT(2) = what executes this sgrp      ****/
   /* ***   TA1REC.TA1MAP      = what map this data is from   ****/
   /* *** code the action for the following return codes:     ****/
   /* ***      0 = successful - continue                      ****/
   /* ***   +100 = EOF                                        ****/
   /* ***     <0 = db/severe error - contact programming msg  ****/
   /* ***          note: clear screen & put keys back         ****/
   /* ***          note: TA0020 will have been executed       ****/
   /* ***                within this sgrp for <0 only         ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** scan/retrieve/fetch next row                        ****/
   /* *** note: CSP closes cursor at end of set (+100)        ****/
   /* ************************************************************/

  call "IO1770" ("N1", SQLCA, PKBREC) {isNoRefresh = yes, isExternal = yes}; /* <=== select next row*/

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSPKBF0 ";
  TA1REC.TA1LOCAT[1] = "IO1770  ";
  TA1REC.TA1LOCAT[3] = "FETCH   ";
  TA1REC.TA1LOCAT[4] = "NEXT    ";
  TA1REC.TA1DBASE = "DPICK   ";
  TA1REC.TA1TBLVU = "VORHLD01";
  TA1REC.TA1TBLKE = PKBREC.PKBKEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
  XSPF4();

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSPKBF1

// setinq : location : 0
Function XSPKBS1()


   /* ************************************************************/
   /* *** select set of rows from: destination table          ****/
   /* *** using the standard i/o processing version #0        ****/
   /* *** note: sqlcq.sqlcode used re: can't "set" ezesqcod   ****/
   /* *** note: +100 - not found can't be detected until the  ****/
   /* ***       first fetch is executed                       ****/
   /* *** setup the following just before this is executed:   ****/
   /* ***   TA1REC.TA1LOCAT(2) = what executes this sgrp      ****/
   /* ***   TA1REC.TA1MAP      = what map this data is from   ****/
   /* *** code the action for the following return codes:     ****/
   /* ***      0 = successful - continue                      ****/
   /* ***   +100 = none found - setup not fnd error/msg       ****/
   /* ***   -911 = deadlock - setup try again error/msg       ****/
   /* ***     <0 = db/severe error - contact programming msg  ****/
   /* ***          note: clear screen & put keys back         ****/
   /* ***          note: TA0020 will have been executed       ****/
   /* ***                within this sgrp for <0 only         ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** select set with unique key                          ****/
   /* ************************************************************/

  call "IO1770" ("S1", SQLCA, PKBREC) {isNoRefresh = yes, isExternal = yes}; /* <=== select set row*/

  if (SQLCA.VAGen_SQLCODE == -911)
    return;
  end

  if (SQLCA.VAGen_SQLCODE < 0)
    TA1REC.TA1TYPE = "DB2 ";
    TA1REC.TA1FUNC = "RETN";
    TA1REC.TA1PGMNM = "XSPKBS0 ";
    TA1REC.TA1LOCAT[1] = "IO1770  ";
    TA1REC.TA1LOCAT[3] = "SELECT  ";
    TA1REC.TA1LOCAT[4] = "SET     ";
    TA1REC.TA1DBASE = "DPICK   ";
    TA1REC.TA1TBLVU = "VORHLD01";
    TA1REC.TA1TBLKE = PKBREC.PKBKEY;
    move SQLCA to ERRSQLCA withV60Compat;
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback();
    call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
    XSPF4();
  end

   /* ************************************************************/
   /* *** scan/retrieve/fetch first row                       ****/
   /* *** in order to detect not found (+100)                 ****/
   /* *** note: CSP closes cursor at end of set (+100)        ****/
   /* *** note: any loop processing must use this first row   ****/
   /* ***       and fetch the next row at the end of the loop ****/
   /* ************************************************************/

  call "IO1770" ("N1", SQLCA, PKBREC) {isNoRefresh = yes, isExternal = yes}; /* <=== select set row*/

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSPKBS3 ";
  TA1REC.TA1LOCAT[1] = "IO1770  ";
  TA1REC.TA1LOCAT[3] = "FIRST   ";
  TA1REC.TA1LOCAT[4] = "FETCH   ";
  TA1REC.TA1DBASE = "DPICK   ";
  TA1REC.TA1TBLVU = "VORHLD01";
  TA1REC.TA1TBLKE = PKBREC.PKBKEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
  XSPF4();

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSPKBS1

// close : location : 0
Function XSPKDC1()


   /* ************************************************************/
   /* *** close select set of: destination table              ****/
   /* *** using the standard i/o processing version #0        ****/
   /* *** note: sqlcq.sqlcode used re: can't "set" ezesqcod   ****/
   /* *** setup the following just before this is executed:   ****/
   /* ***   TA1REC.TA1LOCAT(2) = what executes this sgrp      ****/
   /* ***   TA1REC.TA1MAP      = what map this data is from   ****/
   /* *** code the action for the following return codes:     ****/
   /* ***      0 = successful - continue                      ****/
   /* ***   -501 = cursor already closed - return 0           ****/
   /* ***   -507 must be used if native sql is being used.    ****/
   /* ***     <0 = db/severe error - contact programming msg  ****/
   /* ***          note: clear screen & put keys back         ****/
   /* ***          note: TA0020 will have been executed       ****/
   /* ***                within this sgrp for <0 only         ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** close select set (if prior to EOF)                  ****/
   /* ************************************************************/

  call "IO1890" ("C1", SQLCA, PKDREC) {isNoRefresh = yes}; /* <=== close select set*/

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -501)
    SQLCA.VAGen_SQLCODE = 0;
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSPKDC0 ";
  TA1REC.TA1LOCAT[1] = "IO1890  ";
  TA1REC.TA1LOCAT[3] = "CLOSE   ";
  TA1REC.TA1LOCAT[4] = "SETINQ  ";
  TA1REC.TA1DBASE = "DPICK   ";
  TA1REC.TA1TBLVU = "VPKCTL01";
  TA1REC.TA1TBLKE = PKDREC.PKDKEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA);
  XSPF4();

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSPKDC1

// inquiry : location : 0
Function XSPKDI0()


   /* ************************************************************/
   /* *** select unique row from: destination table           ****/
   /* *** using the standard i/o processing version #0        ****/
   /* *** note: second fetch used to detect duplicate rows    ****/
   /* *** note: sqlcq.sqlcode used re: can't "set" ezesqcod   ****/
   /* *** note: IO process(s) do all rec/row moves so that    ****/
   /* ***       the final result will be in the record        ****/
   /* *** setup the following just before this is executed:   ****/
   /* ***   TA1REC.TA1LOCAT(2) = what executes this sgrp      ****/
   /* ***   TA1REC.TA1MAP      = what map this data is from   ****/
   /* *** code the action for the following return codes:     ****/
   /* ***      0 = successful - continue                      ****/
   /* ***   +100 = not found - setup not fnd error/msg        ****/
   /* ***   -911 = deadlock - setup try again error/msg       ****/
   /* ***   -811 = duplicates found - contact programming msg ****/
   /* ***          note: do NOT clear screen                  ****/
   /* ***     <0 = db/severe error - contact programming msg  ****/
   /* ***          note: clear screen & put keys back         ****/
   /* ***          note: TA0020 will have been executed       ****/
   /* ***                within this sgrp for <0 only         ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** select row with unique key                          ****/
   /* ************************************************************/

  call "IO1890" ("S ", SQLCA, PKDREC) {isNoRefresh = yes}; /* <=== select unique*/

  if (SQLCA.VAGen_SQLCODE == -911)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -811) /* duplicate*/
    XSPKDS1();
    XSPKDC1();
  end

  if (SQLCA.VAGen_SQLCODE < 0)
    TA1REC.TA1TYPE = "DB2 ";
    TA1REC.TA1FUNC = "RETN";
    TA1REC.TA1PGMNM = "XSPKDI0 ";
    TA1REC.TA1LOCAT[1] = "IO1890  ";
    TA1REC.TA1LOCAT[3] = "SELECT  ";
    TA1REC.TA1LOCAT[4] = "SET     ";
    TA1REC.TA1DBASE = "DPICK   ";
    TA1REC.TA1TBLVU = "VPKCTL01";
    TA1REC.TA1TBLKE = PKDREC.PKDKEY;
    move SQLCA to ERRSQLCA withV60Compat;
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback();
    call "TA0020" (TA1REC, ERRSQLCA);
    XSPF4();
  end

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSPKDI0

// setinq : location : 0
Function XSPKDS1()


   /* ************************************************************/
   /* *** select set of rows from: destination table          ****/
   /* *** using the standard i/o processing version #0        ****/
   /* *** note: sqlcq.sqlcode used re: can't "set" ezesqcod   ****/
   /* *** note: +100 - not found can't be detected until the  ****/
   /* ***       first fetch is executed                       ****/
   /* *** setup the following just before this is executed:   ****/
   /* ***   TA1REC.TA1LOCAT(2) = what executes this sgrp      ****/
   /* ***   TA1REC.TA1MAP      = what map this data is from   ****/
   /* *** code the action for the following return codes:     ****/
   /* ***      0 = successful - continue                      ****/
   /* ***   +100 = none found - setup not fnd error/msg       ****/
   /* ***   -911 = deadlock - setup try again error/msg       ****/
   /* ***     <0 = db/severe error - contact programming msg  ****/
   /* ***          note: clear screen & put keys back         ****/
   /* ***          note: TA0020 will have been executed       ****/
   /* ***                within this sgrp for <0 only         ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** select set with unique key                          ****/
   /* ************************************************************/

  call "IO1890" ("S1", SQLCA, PKDREC) {isNoRefresh = yes}; /* <=== select set row*/

  if (SQLCA.VAGen_SQLCODE == -911)
    return;
  end

  if (SQLCA.VAGen_SQLCODE < 0)
    TA1REC.TA1TYPE = "DB2 ";
    TA1REC.TA1FUNC = "RETN";
    TA1REC.TA1PGMNM = "XSPKDS0 ";
    TA1REC.TA1LOCAT[1] = "IO1890  ";
    TA1REC.TA1LOCAT[3] = "SELECT  ";
    TA1REC.TA1LOCAT[4] = "SET     ";
    TA1REC.TA1DBASE = "DPICK   ";
    TA1REC.TA1TBLVU = "VPKCTL01";
    TA1REC.TA1TBLKE = PKDREC.PKDKEY;
    move SQLCA to ERRSQLCA withV60Compat;
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback();
    call "TA0020" (TA1REC, ERRSQLCA);
    XSPF4();
  end

   /* ************************************************************/
   /* *** scan/retrieve/fetch first row                       ****/
   /* *** in order to detect not found (+100)                 ****/
   /* *** note: CSP closes cursor at end of set (+100)        ****/
   /* *** note: any loop processing must use this first row   ****/
   /* ***       and fetch the next row at the end of the loop ****/
   /* ************************************************************/

  call "IO1890" ("N1", SQLCA, PKDREC) {isNoRefresh = yes}; /* <=== select set row*/

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSPKDS0 ";
  TA1REC.TA1LOCAT[1] = "IO1890  ";
  TA1REC.TA1LOCAT[3] = "FIRST   ";
  TA1REC.TA1LOCAT[4] = "FETCH   ";
  TA1REC.TA1DBASE = "DPICK   ";
  TA1REC.TA1TBLVU = "VPKCTL01";
  TA1REC.TA1TBLKE = PKDREC.PKDKEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA);
  XSPF4();

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSPKDS1

// add : location : 0
Function XSPKHA0()


   /* ************************************************************/
   /* *** add unique row in: destination table                ****/
   /* *** using the std i/o processing version #0             ****/
   /* *** note: sqlcq.sqlcode used re: can't "set" ezesqcod   ****/
   /* *** note: IO process(s) do all row/rec moves so that    ****/
   /* ***       the final result will be in the record        ****/
   /* *** setup the following just before this is executed:   ****/
   /* ***   TA1REC.TA1LOCAT(2) = what executes this sgrp      ****/
   /* ***   TA1REC.TA1MAP      = what map this data is from   ****/
   /* *** code the action for the following return codes:     ****/
   /* ***      0 = successful - continue                      ****/
   /* ***   -803 = adding duplicate row - setup dupl row msg  ****/
   /* ***   -911 = deadlock - try again msg                   ****/
   /* ***     <0 = db/severe error - contact programming msg  ****/
   /* ***          note: clear screen & put keys back         ****/
   /* ***          note: TA0020 will have been executed       ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** select unique row for inquiry                       ****/
   /* *** note: 0 return code results in the -803             ****/
   /* ************************************************************/

  call "IO1740" ("S ", SQLCA, PKHREC) {isNoRefresh = yes, isExternal = yes}; /* <=== select unique row*/

  if (SQLCA.VAGen_SQLCODE == 0)
    SQLCA.VAGen_SQLCODE = -803;
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -911)
    return;
  end

  if (SQLCA.VAGen_SQLCODE < 0)
    TA1REC.TA1TYPE = "DB2 ";
    TA1REC.TA1FUNC = "RETN";
    TA1REC.TA1PGMNM = "XSPKHA0 ";
    TA1REC.TA1LOCAT[1] = "IO1740  ";
    TA1REC.TA1LOCAT[3] = "ADD     ";
    TA1REC.TA1LOCAT[4] = "UNIQUE  ";
    TA1REC.TA1DBASE = "DPICK   ";
    TA1REC.TA1TBLVU = "VSELOR01";
    TA1REC.TA1TBLKE = PKHREC.PKHKEY;
    move SQLCA to ERRSQLCA withV60Compat;
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback();
    call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
    XSPF4();
  end

   /* ************************************************************/
   /* *** insert row                                          ****/
   /* *** note: IO process initializes zzzchgct to 0          ****/
   /* ************************************************************/

  call "IO1740" ("A ", SQLCA, PKHREC) {isNoRefresh = yes, isExternal = yes}; /* <=== add row*/

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -911)
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSPKHA0 ";
  TA1REC.TA1LOCAT[1] = "IO1740  ";
  TA1REC.TA1LOCAT[3] = "ADD     ";
  TA1REC.TA1LOCAT[4] = "ROW     ";
  TA1REC.TA1DBASE = "DPICK   ";
  TA1REC.TA1TBLVU = "VSELOR01";
  TA1REC.TA1TBLKE = PKHREC.PKHKEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
  XSPF4();

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/

end // end XSPKHA0

// close : location : 0
Function XSPKHC1()


   /* ************************************************************/
   /* *** close select set of: destination table              ****/
   /* *** using the standard i/o processing version #0        ****/
   /* *** note: sqlcq.sqlcode used re: can't "set" ezesqcod   ****/
   /* *** setup the following just before this is executed:   ****/
   /* ***   TA1REC.TA1LOCAT(2) = what executes this sgrp      ****/
   /* ***   TA1REC.TA1MAP      = what map this data is from   ****/
   /* *** code the action for the following return codes:     ****/
   /* ***      0 = successful - continue                      ****/
   /* ***   -507 = cursor already closed - return 0           ****/
   /* ***     <0 = db/severe error - contact programming msg  ****/
   /* ***          note: clear screen & put keys back         ****/
   /* ***          note: TA0020 will have been executed       ****/
   /* ***                within this sgrp for <0 only         ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** close select set (if prior to EOF)                  ****/
   /* ************************************************************/

  call "IO1740" ("C1", SQLCA, PKHREC) {isNoRefresh = yes, isExternal = yes}; /* <=== close select set*/

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -501)
    SQLCA.VAGen_SQLCODE = 0;
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSPK3C0 ";
  TA1REC.TA1LOCAT[1] = "IO1740  ";
  TA1REC.TA1LOCAT[3] = "CLOSE   ";
  TA1REC.TA1LOCAT[4] = "SETINQ  ";
  TA1REC.TA1DBASE = "DPICK   ";
  TA1REC.TA1TBLVU = "VSELOR01";
  TA1REC.TA1TBLKE = PKHREC.PKHKEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
  XSPF4();

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSPKHC1

// delete : location : 0
Function XSPKHD0()


   /* ************************************************************/
   /* *** delete unique row in: destination table             ****/
   /* *** using the standard i/o processing version #0        ****/
   /* *** note: sqlcq.sqlcode used re: can't "set" ezesqcod   ****/
   /* *** note: IO process(s) do all rec/row moves so that    ****/
   /* ***       the final result will be in the record        ****/
   /* *** setup the following just before this is executed:   ****/
   /* ***   TA1REC.TA1LOCAT(2) = what executes this sgrp      ****/
   /* ***   TA1REC.TA1MAP      = what map this data is from   ****/
   /* *** code the action for the following return codes:     ****/
   /* ***      0 = successful - continue                      ****/
   /* ***   +100 = concurrent update - return with msg re:    ****/
   /* ***          deleted since last read (blank out rec)    ****/
   /* ***          updated since last read (new data in rec)  ****/
   /* ***   -911 = deadlock - setup try again error/msg       ****/
   /* ***     <0 = db/severe error - contact programming msg  ****/
   /* ***          note: clear screen & put keys back         ****/
   /* ***          note: TA0020 will have been executed       ****/
   /* ***                within this sgrp for <0 only         ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** delete unique row                                   ****/
   /* ************************************************************/

  call "IO1740" ("D ", SQLCA, PKHREC) {isNoRefresh = yes, isExternal = yes}; /* <=== select unique row*/


  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSPKHD0 ";
  TA1REC.TA1LOCAT[1] = "IO1740  ";
  TA1REC.TA1LOCAT[3] = "DELETE  ";
  TA1REC.TA1LOCAT[4] = "ROW     ";
  TA1REC.TA1DBASE = "DPICK   ";
  TA1REC.TA1TBLVU = "VSELOR01";
  TA1REC.TA1TBLKE = PKHREC.PKHKEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA);
  XSPF4();

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSPKHD0

// fetch : location : 0
Function XSPKHF1()


   /* ************************************************************/
   /* *** fetch next row from: destination table              ****/
   /* *** using the standard i/o processing version #0        ****/
   /* *** note: sqlcq.sqlcode used re: can't "set" ezesqcod   ****/
   /* *** note: +100 - not found was detected as part of the  ****/
   /* ***       select set previously executed                ****/
   /* *** setup the following just before this is executed:   ****/
   /* ***   TA1REC.TA1LOCAT(2) = what executes this sgrp      ****/
   /* ***   TA1REC.TA1MAP      = what map this data is from   ****/
   /* *** code the action for the following return codes:     ****/
   /* ***      0 = successful - continue                      ****/
   /* ***   +100 = EOF                                        ****/
   /* ***     <0 = db/severe error - contact programming msg  ****/
   /* ***          note: clear screen & put keys back         ****/
   /* ***          note: TA0020 will have been executed       ****/
   /* ***                within this sgrp for <0 only         ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** scan/retrieve/fetch next row                        ****/
   /* *** note: CSP closes cursor at end of set (+100)        ****/
   /* ************************************************************/

  call "IO1740" ("N1", SQLCA, PKHREC) {isNoRefresh = yes, isExternal = yes}; /* <=== select next row*/

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSPKHF0 ";
  TA1REC.TA1LOCAT[1] = "IO1740  ";
  TA1REC.TA1LOCAT[3] = "FETCH   ";
  TA1REC.TA1LOCAT[4] = "NEXT    ";
  TA1REC.TA1DBASE = "DPICK   ";
  TA1REC.TA1TBLVU = "VSELOR01";
  TA1REC.TA1TBLKE = PKHREC.PKHKEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
  XSPF4();

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSPKHF1

// inquiry : location : 0
Function XSPKHI0()


   /* ************************************************************/
   /* *** select unique row from: destination table           ****/
   /* *** using the standard i/o processing version #0        ****/
   /* *** note: second fetch used to detect duplicate rows    ****/
   /* *** note: sqlcq.sqlcode used re: can't "set" ezesqcod   ****/
   /* *** note: IO process(s) do all rec/row moves so that    ****/
   /* ***       the final result will be in the record        ****/
   /* *** setup the following just before this is executed:   ****/
   /* ***   TA1REC.TA1LOCAT(2) = what executes this sgrp      ****/
   /* ***   TA1REC.TA1MAP      = what map this data is from   ****/
   /* *** code the action for the following return codes:     ****/
   /* ***      0 = successful - continue                      ****/
   /* ***   +100 = not found - setup not fnd error/msg        ****/
   /* ***   -911 = deadlock - setup try again error/msg       ****/
   /* ***   -811 = duplicates found - contact programming msg ****/
   /* ***          note: do NOT clear screen                  ****/
   /* ***     <0 = db/severe error - contact programming msg  ****/
   /* ***          note: clear screen & put keys back         ****/
   /* ***          note: TA0020 will have been executed       ****/
   /* ***                within this sgrp for <0 only         ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** select row with unique key                          ****/
   /* ************************************************************/

  call "IO1740" ("S ", SQLCA, PKHREC) {isNoRefresh = yes, isExternal = yes}; /* <=== select unique*/

  if (SQLCA.VAGen_SQLCODE == -911)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -811) /* duplicate*/
    XSPKHS1();
    XSPKHC1();
  end

  if (SQLCA.VAGen_SQLCODE < 0)
    TA1REC.TA1TYPE = "DB2 ";
    TA1REC.TA1FUNC = "RETN";
    TA1REC.TA1PGMNM = "XSPKHI0 ";
    TA1REC.TA1LOCAT[1] = "IO1740  ";
    TA1REC.TA1LOCAT[3] = "SELECT  ";
    TA1REC.TA1LOCAT[4] = "SET     ";
    TA1REC.TA1DBASE = "DPICK   ";
    TA1REC.TA1TBLVU = "VSELOR01";
    TA1REC.TA1TBLKE = PKHREC.PKHKEY;
    move SQLCA to ERRSQLCA withV60Compat;
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback();
    call "TA0020" (TA1REC, ERRSQLCA);
    XSPF4();
  end

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSPKHI0

// replace : location : 0
Function XSPKHR0()


   /* ************************************************************/
   /* *** replace unique row in: destination table            ****/
   /* *** using the standard i/o processing version #0        ****/
   /* *** note: sqlcq.sqlcode used re: can't "set" ezesqcod   ****/
   /* *** note: IO process(s) do all rec/row moves so that    ****/
   /* ***       the final result will be in the record        ****/
   /* *** setup the following just before this is executed:   ****/
   /* ***   TA1REC.TA1LOCAT(2) = what executes this sgrp      ****/
   /* ***   TA1REC.TA1MAP      = what map this data is from   ****/
   /* *** code the action for the following return codes:     ****/
   /* ***      0 = successful - continue                      ****/
   /* ***   +100 = concurrent update - return with msg re:    ****/
   /* ***          deleted since last read (blank out rec)    ****/
   /* ***          updated since last read (new data in rec)  ****/
   /* ***   -911 = deadlock - setup try again error/msg       ****/
   /* ***     <0 = db/severe error - contact programming msg  ****/
   /* ***          note: clear screen & put keys back         ****/
   /* ***          note: TA0020 will have been executed       ****/
   /* ***                within this sgrp for <0 only         ****/
   /* ************************************************************/


   /* ************************************************************/
   /* *** replace row                                         ****/
   /* *** note: IO process increments zzzchgct by +1 and uses ****/
   /* ***       current data & time for zzzchgdt & zzzchgtm   ****/
   /* ************************************************************/

  call "IO1740" ("U ", SQLCA, PKHREC) {isNoRefresh = yes, isExternal = yes}; /* <=== select unique row*/


  if (SQLCA.VAGen_SQLCODE == 0
   || SQLCA.VAGen_SQLCODE == 100
   || SQLCA.VAGen_SQLCODE == -911)
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSPKHR0 ";
  TA1REC.TA1LOCAT[1] = "IO1740  ";
  TA1REC.TA1LOCAT[3] = "REPLACE ";
  TA1REC.TA1LOCAT[4] = "ROW     ";
  TA1REC.TA1DBASE = "DPICK   ";
  TA1REC.TA1TBLVU = "VSELOR01";
  TA1REC.TA1TBLKE = PKHREC.PKHKEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
  XSPF4();

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSPKHR0

// setinq : location : 0
Function XSPKHS1()


   /* ************************************************************/
   /* *** select set of rows from: destination table          ****/
   /* *** using the standard i/o processing version #0        ****/
   /* *** note: sqlcq.sqlcode used re: can't "set" ezesqcod   ****/
   /* *** note: +100 - not found can't be detected until the  ****/
   /* ***       first fetch is executed                       ****/
   /* *** setup the following just before this is executed:   ****/
   /* ***   TA1REC.TA1LOCAT(2) = what executes this sgrp      ****/
   /* ***   TA1REC.TA1MAP      = what map this data is from   ****/
   /* *** code the action for the following return codes:     ****/
   /* ***      0 = successful - continue                      ****/
   /* ***   +100 = none found - setup not fnd error/msg       ****/
   /* ***   -911 = deadlock - setup try again error/msg       ****/
   /* ***     <0 = db/severe error - contact programming msg  ****/
   /* ***          note: clear screen & put keys back         ****/
   /* ***          note: TA0020 will have been executed       ****/
   /* ***                within this sgrp for <0 only         ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** select set with unique key                          ****/
   /* ************************************************************/

  call "IO1740" ("S1", SQLCA, PKHREC) {isNoRefresh = yes, isExternal = yes}; /* <=== select set row*/

  if (SQLCA.VAGen_SQLCODE == -911)
    return;
  end

  if (SQLCA.VAGen_SQLCODE < 0)
    TA1REC.TA1TYPE = "DB2 ";
    TA1REC.TA1FUNC = "RETN";
    TA1REC.TA1PGMNM = "XSPKHS0 ";
    TA1REC.TA1LOCAT[1] = "IO1740  ";
    TA1REC.TA1LOCAT[3] = "SELECT  ";
    TA1REC.TA1LOCAT[4] = "SET     ";
    TA1REC.TA1DBASE = "DPICK   ";
    TA1REC.TA1TBLVU = "VSELOR01";
    TA1REC.TA1TBLKE = PKHREC.PKHKEY;
    move SQLCA to ERRSQLCA withV60Compat;
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback();
    call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
    XSPF4();
  end

   /* ************************************************************/
   /* *** scan/retrieve/fetch first row                       ****/
   /* *** in order to detect not found (+100)                 ****/
   /* *** note: CSP closes cursor at end of set (+100)        ****/
   /* *** note: any loop processing must use this first row   ****/
   /* ***       and fetch the next row at the end of the loop ****/
   /* ************************************************************/

  call "IO1740" ("N1", SQLCA, PKHREC) {isNoRefresh = yes, isExternal = yes}; /* <=== select set row*/

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSTF2S0 ";
  TA1REC.TA1LOCAT[1] = "IO1740  ";
  TA1REC.TA1LOCAT[3] = "FIRST   ";
  TA1REC.TA1LOCAT[4] = "FETCH   ";
  TA1REC.TA1DBASE = "DPICK   ";
  TA1REC.TA1TBLVU = "VSELOR01";
  TA1REC.TA1TBLKE = PKHREC.PKHKEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
  XSPF4();

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSPKHS1

// Sel Item/siz frm DB1000/IO1660
Function XSPKS-SELCT-ITM-SZ()
   /*  */
   /* This statement is created to have the option to retrieve a line item*/
   /* from the DORDER.VOSIZE01 table (for facilities not interfacing*/
   /* with SAP yet) or from the DORDER.VOPPKI01 (for when a warehouse is*/
   /* interacting with SAP).  When the item data is from the VOPPKI01*/
   /* table, it needs to populate OP3REC (VOSIZE01 copybook) to minimize*/
   /* the changes to the main program.*/
   /*  */
   /* Note that this process uses the warehouse code from the warehouse*/
   /* table and so before this routine is added to the program, make sure*/
   /* it contains XX0XW03 copybook.*/
   /*  */
   /* DLVRUSA CHANGES BEGIN*/
   /* Changed the condition for the USA - NSC Go live*/
   /* IF XX0XW03.XWHCD NE '42';     /* If not Canada warehouse*/
   /*  */
  if (XX0XW03.XWHCD == "04" /* IF WAREHOUSE = 04,07,09,42,51*/
   || XX0XW03.XWHCD == "07" 
   || XX0XW03.XWHCD == "09" 
   || XX0XW03.XWHCD == "42" 
   || XX0XW03.XWHCD == "51")

    set OPIREC empty;

    OPIREC.XWHCD = XX0XW03.XWHCD;
    OPIREC.OP1PARTN = OP3REC.OP1PARTN;
    OPIREC.OP1CUOID = OP3REC.OP1CUOID;
    OPIREC.OP1NORID = OP3REC.OP1NORID;
    OPIREC.OP2LNINB = OP3REC.OP2LNINB;

    try
      call "IO1660" ("S ", SQLCA, OPIREC) {isNoRefresh = yes, isExternal = yes};
    end
                                  /* Select VOPPKI01*/

    if (sysVar.errorCode == "00000000"
     && SQLCA.VAGen_SQLCODE == +0) /* Found*/

      set OP3REC empty;

        /* Populate OP3REC with OPIREC*/

      OP3REC.OP1PARTN = OPIREC.OP1PARTN;
      OP3REC.OP1CUOID = OPIREC.OP1CUOID;
      OP3REC.OP1NORID = OPIREC.OP1NORID;
      OP3REC.OP2LNINB = OPIREC.OP2LNINB;
      OP3REC.OP2CPLNB = OPIREC.OP2CPLNB;
      OP3REC.XGPCD = OPIREC.XGPCD;
      OP3REC.SY1STNBR = OPIREC.SY1STNBR;
      OP3REC.SY2CLRID = OPIREC.SY2CLRID;
      OP3REC.XDMCD = OPIREC.XDMCD;
      OP3REC.KUIPRDID = OPIREC.KUIPRDID;
      OP3REC.XUMCD = OPIREC.XUMCD;
      OP3REC.XOWCD = OPIREC.XOWCD;
      OP3REC.OP2PRDSF = " ";
      OP3REC.OP2SSTYN = " ";
      OP3REC.OP2SCLCD = " ";
      OP3REC.OP2SDMCD = " ";
      OP3REC.OP2SUBQT = +0;
      OP3REC.OPRBNOID = +0;
      OP3REC.OP2TDRWQ = +0;
      OP3REC.OP2CGPCD = OPIREC.OP2CGPCD;
      OP3REC.OP2KSTYF = " ";
      OP3REC.OP2GTSZF = " ";
      OP3REC.XEGCD = OPIREC.XEGCD;
      OP3REC.PC2INSEG = OPIREC.PC2INSEG;
      OP3REC.XPGCD = OPIREC.XPGCD;
      OP3REC.XBK-BK-SESN-CD = " ";
      OP3REC.OP-BK-YR = +0;
      OP3REC.OP-BK-MO = +0;
      OP3REC.OP2MSCDP = +0;
      OP3REC.OP2PGRPF = " ";
      OP3REC.OP2FSTFL = " ";
      OP3REC.XQACD = OPIREC.XQACD;
      OP3REC.OP2LNIST = " ";
      OP3REC.OP2LNSDT = +0;
      OP3REC.XBRCD = " ";
      OP3REC.XDNCD = " ";
      OP3REC.XRSCD = " ";
      OP3REC.XAFCD = " ";
      OP3REC.OP1ALFDT = +0;
      OP3REC.OP1BOFL = " ";
      OP3REC.XHDCD[1] = OPIREC.XHDCD[1];
      OP3REC.XHDCD[2] = OPIREC.XHDCD[2];
      OP3REC.XHDCD[3] = OPIREC.XHDCD[3];
      OP3REC.XHDCD[4] = OPIREC.XHDCD[4];
      OP3REC.XHDCD[5] = OPIREC.XHDCD[5];
      OP3REC.XHDCHG = +0;
      OP3REC.OP2HCHGO = " ";
      OP3REC.PWRLBCD[1] = OPIREC.PWRLBCD[1];
      OP3REC.PWRLBCD[2] = OPIREC.PWRLBCD[2];
      OP3REC.OP-CUST-LABL-PRTFL = OPIREC.OP-CUST-LABL-PRTFL;
      OP3REC.XOMCD = " ";
      OP3REC.XMTCD = " ";
      OP3REC.OP2OMQTY = +0;
      OP3REC.OP2OMDT = +0;
      OP3REC.OP1MTREP = +0;
      OP3REC.OP2GBLOF = " ";
      OP3REC.OP2PRCOF = " ";
      OP3REC.OP2PRCVF = " ";
      OP3REC.OP2TOBKQ = +0;
      OP3REC.OP2TORGQ = +0;
      OP3REC.OP2TONOQ = +0;
      OP3REC.OP2TALCQ = +0;
      OP3REC.OP2TOHRQ = +0;
      OP3REC.OP2TWIPQ = +0;
      OP3REC.OP2TSHPQ = +0;
      OP3REC.OP2TCNLQ = +0;
      OP3REC.OP2AUPRC = OPIREC.OP2AUPRC;
      OP3REC.OP2LNIVL = +0;
      OP3REC.OP2NSIZE = +0;
      OP3REC.XDZ-DATA-DIST-CD = " ";
      OP3REC.ZZ-CS400-CHNG-DT = +0;
      OP3REC.ZZ-CS400-CHNG-HHMM = +0;
      OP3REC.ZZ-DS400-CHNG-DT = +0;
      OP3REC.ZZ-DS400-CHNG-HHMM = +0;
      OP3REC.ZZZSDT = +0;
      OP3REC.ZZZSTM = +0;
      OP3REC.ZZZCHGDT = +0;
      OP3REC.ZZZCHGTM = +0;
      OP3REC.ZZZCHGCT = +0;

      XX0XW03.SZ-IDX = 1;

      while (XX0XW03.SZ-IDX <= 40)

        if (OPIREC.OP3ALQT[SZ-IDX] > 0)

          OP3REC.OP3SZAFL[SZ-IDX] = "Y";
          OP3REC.OP3ALQT[SZ-IDX] = OPIREC.OP3ALQT[SZ-IDX];
          OP3REC.SY5PRCUN[SZ-IDX] = OPIREC.OP2AUPRC;
          OP3REC.OP3PRCOF[SZ-IDX] = " ";
          OP3REC.OP3ORGQT[SZ-IDX] = +0;
          OP3REC.OP3ONOQT[SZ-IDX] = +0;
        end

        XX0XW03.SZ-IDX = XX0XW03.SZ-IDX + 1;
      end

    end

  else

    call "DB1000" (OP8REC, OP3REC, OPBREC) {isNoRefresh = yes, isExternal = yes};
                                  /* Select VITEM001 and VOSIZE01*/

  end

   /*  */
   /* DLVRUSA CHANGES END*/

end // end XSPKS-SELCT-ITM-SZ

// Select order fr VORHDR/VOPPKH
Function XSPKS-SELECT-ORDER()
   /*  */
   /* This statement is created to have the option to retrieve an order*/
   /* from the DORDER.VORHDR01 table (for facilities not interfacing*/
   /* with SAP yet) or from the DORDER.VOPPKH01 (for when a warehouse is*/
   /* interacting with SAP).  When the item data is from the VOPPKH01*/
   /* table, it needs to populate OP1REC (VORHDR01 copybook) to minimize*/
   /* the changes to the main program.*/
   /*  */
   /* Note that this process uses the common working record containing the*/
   /* warehouse code and so before this routine is added to the program,*/
   /* make sure it contains XX0XW03 copybook and that it is being*/
   /* populated with the correct warehouse code.*/
   /*  */
   /* DLVRUSA CHANGES BEGIN*/
   /* Changed the condition for the USA - NSC Go live*/
   /*  */
   /* IF XX0XW03.XWHCD NE '42';     /* If not Canada warehouse*/
   /*  */
  if (XX0XW03.XWHCD == "04" /* IF WAREHOUSE = 04,07,09,42,51*/
   || XX0XW03.XWHCD == "07" 
   || XX0XW03.XWHCD == "09" 
   || XX0XW03.XWHCD == "42" 
   || XX0XW03.XWHCD == "51")

    set OPHREC empty;

    OPHREC.XWHCD = OP1REC.XWHCD;
    OPHREC.OP1PARTN = OP1REC.OP1PARTN;
    OPHREC.OP1CUOID = OP1REC.OP1CUOID;
    OPHREC.OP1NORID = OP1REC.OP1NORID;

    try
      call "IO1650" ("S ", SQLCA, OPHREC) {isNoRefresh = yes, isExternal = yes};
    end
                                  /* Select VOPPKH01*/

    if (sysVar.errorCode == "00000000"
     && SQLCA.VAGen_SQLCODE == +0) /* Found*/

      set OP1REC empty;

        /* Populate OP1REC with OPHREC*/

      OP1REC.OP1PARTN = OPHREC.OP1PARTN;
      OP1REC.OP1CUOID = OPHREC.OP1CUOID;
      OP1REC.OP1NORID = OPHREC.OP1NORID;
      OP1REC.OB1XREFN = " ";
      OP1REC.KUCCOID = OPHREC.KUCCOID;
      OP1REC.KUMSTRID = OPHREC.KUMSTRID;
      OP1REC.XNXCD = OPHREC.XNXCD;
      OP1REC.XGPCD = OPHREC.XGPCD;
      OP1REC.OP1CMPNB = +0;
      OP1REC.OP1CUPO = OPHREC.OP1CUPO;
      OP1REC.OP1PORMF = " ";
      OP1REC.OP1ORDBY = " ";
      OP1REC.OP1TBREP = OPHREC.OP1TBREP;
      OP1REC.XDVCD = OPHREC.XDVCD;
      OP1REC.XBCCD = OPHREC.XBCCD;
      OP1REC.XSOCD = OPHREC.XSOCD;
      OP1REC.XOTCD = OPHREC.XOTCD;
      OP1REC.XOBCD = OPHREC.XOBCD;
      OP1REC.XOCCD = OPHREC.XOCCD;
      OP1REC.SP1ID = " ";
      OP1REC.SP6MDISC = +0;
      OP1REC.XWHCD = OPHREC.XWHCD;
      OP1REC.OP1OWHMF = " ";
      OP1REC.OP1CUNDT = OPHREC.OP1CUNDT;
      OP1REC.OP-ORIG-NEED-DT = +0;
      OP1REC.XOSCD = " ";
      OP1REC.OP1OSADT = +0;
      OP1REC.OP1TDOF = " ";
      OP1REC.XTDPCT = +0;
      OP1REC.OP1TDFCP = +0;
      OP1REC.OP1TDBKP = +0;
      OP1REC.OP1PTOF = " ";
      OP1REC.XPTCD = " ";
      OP1REC.OP1AAOF = " ";
      OP1REC.XAAPCT = +0;
      OP1REC.OP1AAFCP = +0;
      OP1REC.OP1AABKP = +0;
      OP1REC.OP1COPOF = " ";
      OP1REC.XCPPCT = +0;
      OP1REC.OP1DFAOF = " ";
      OP1REC.XDAPCT = +0;
      OP1REC.XDSCD = OPHREC.XDSCD;
      OP1REC.OP-DIRSHP-DSCT-PCT = +0;
      OP1REC.SM1AGYID = OPHREC.SM1AGYID;
      OP1REC.SM4REPID = OPHREC.SM4REPID;
      OP1REC.OP-SREP-OVRD-FL = " ";
      OP1REC.OP1SWORD = +0;
      OP1REC.XBDCD = " ";
      OP1REC.OP1BLKID = +0;
      OP1REC.OP1NDRAW = +0;
      OP1REC.OP1COGID = +0;
      OP1REC.OP1BLAID = +0;
      OP1REC.OP1SGPAO = OPHREC.OP1SGPAO;
      OP1REC.OP1SHAID = OPHREC.KUMSHAID;
      OP1REC.OP1ODSKF = " ";
      OP1REC.OP1ENTDT = +0;
      OP1REC.OP1ORCDT = +0;
      OP1REC.OP1ENREP = +0;
      OP1REC.OP1CALDT = +0;
      OP1REC.OP-SND-CNFM-FL = " ";
      OP1REC.OP1DSBDT = OPHREC.OP1DSBDT;
      OP1REC.OP1DSADT = OPHREC.OP1DSADT;
      OP1REC.DN-PROD-INTR-DT = OPHREC.DN-PROD-INTR-DT;
      OP1REC.OP1NTMAL = OPHREC.OP1NTMAL;
      OP1REC.OP1ALSEQ = +0;
      OP1REC.OP1OALSQ = +0;
      OP1REC.OP1LALDT = +0;
      OP1REC.OP1DABDT = +0;
      OP1REC.OP1DRBDT = +0;
      OP1REC.XACCD = " ";
      /* MOVE OPHREC.XACCD TO OP1REC.XACCD*/
      OP1REC.OP1ASGCO = " ";
      OP1REC.XAHCD = " ";
      OP1REC.OP1ALHDT = +0;
      OP1REC.OP1PAHCD = " ";
      OP1REC.OP1ALRDT = +0;
      OP1REC.XAFCD = " ";
      OP1REC.OP1ALFDT = +0;
      OP1REC.KUNMAPCT = +0;
      OP1REC.OP1RSVF = " ";
      OP1REC.OP1WIPIN = " ";
      OP1REC.OP1EXPDF = OPHREC.OP1EXPDF;
      OP1REC.KUNNOSFL = " ";
      OP1REC.OP1ASHDF = " ";
      OP1REC.OP1ACNLF = " ";
      OP1REC.OP1SMSCF = " ";
      OP1REC.OP1TIERF = " ";
      OP1REC.OP1TLVLN = +0;
      OP1REC.OP1CPODT = +0;
      OP1REC.OP1BOFL = " ";
      OP1REC.XCHCD = " ";
      OP1REC.XCSCD = " ";
      OP1REC.OP1CSADT = +0;
      OP1REC.OP1CSATM = +0;
      OP1REC.OP1CRLMP = " ";
      OP1REC.OP1CRLMR = " ";
      OP1REC.OP1PCSCD = " ";
      OP1REC.OP1PCSDT = +0;
      OP1REC.OP1PCSTM = +0;
      OP1REC.OP1CCKOQ = +0;
      OP1REC.OP1CKAMT = +0;
      OP1REC.OP1DCHLD = +0;
      OP1REC.KUCVNDFL = " ";
      OP1REC.OP1VAUDT = +0;
      OP1REC.OP1VAUNB = " ";
      OP1REC.OP-LST-CR-CK-CO-ID = +0;
      OP1REC.XPACD = OPHREC.XPACD;
      OP1REC.KUFMIXBL = OPHREC.KUFMIXBL;
      OP1REC.KUCUNTCS = OPHREC.KUCUNTCS;
      OP1REC.XPKCD = OPHREC.XPKCD;
      OP1REC.XPPCD = OPHREC.XPPCD;
      OP1REC.TF1CARCD = OPHREC.TF1CARCD;
      OP1REC.OP1SSHPO = " ";
      OP1REC.OP1ECADT = +0;
      OP1REC.OP1ECANM = " ";
      OP1REC.OP1IVADT = +0;
      OP1REC.OP1PCNDT = +0;
      OP1REC.OP1CFMDT = +0;
      OP1REC.OP1IPIND = " ";
      OP1REC.OP1FTIND = OPHREC.OP1FTIND;
      OP1REC.OP1SHAMT = +0;
      OP1REC.OP1IFAMT = +0;
      OP1REC.XMDCD = " ";
      OP1REC.ZFC-CRCY-CD = OPHREC.ZFC-CRCY-CD;
      OP1REC.OP1OVALU = +0;
      OP1REC.OP1OTUNT = +0;
      OP1REC.OP1ALCQF = " ";
      OP1REC.OP1RSVQF = " ";
      OP1REC.OP1SHPQF = " ";
      OP1REC.OP1OSRID = +0;
      OP1REC.OP1ORADT = +0;
      OP1REC.XOMCD = " ";
      OP1REC.OP1OMDT = +0;
      OP1REC.OP1MTREP = +0;
      OP1REC.OP1SPLBF = OPHREC.OP1SPLBF;
      OP1REC.OP1SPINF = OPHREC.OP1SPINF;
      OP1REC.OP1SPHDF = OPHREC.OP1SPHDF;
      OP1REC.OP1OMCMF = " ";
      OP1REC.OP11TMSF = OPHREC.OP11TMSF;
      OP1REC.OP11TMBF = " ";
      OP1REC.XID-IVC-DIST-CD = OPHREC.XID-IVC-DIST-CD;
      OP1REC.DN-ORD-DIST-IND = " ";
      OP1REC.XDZ-DATA-DIST-CD = " ";
      OP1REC.ZZ-CS400-CHNG-DT = +0;
      OP1REC.ZZ-CS400-CHNG-HHMM = +0;
      OP1REC.ZZ-DS400-CHNG-DT = +0;
      OP1REC.ZZ-DS400-CHNG-HHMM = +0;
      OP1REC.ZZZSDT = +0;
      OP1REC.ZZZSTM = +0;
      OP1REC.ZZZCHGDT = +0;
      OP1REC.ZZZCHGTM = +0;
      OP1REC.ZZZCHGCT = +0;

    end

  else

    try
      call "IO0430" ("S ", SQLCA, OP1REC) {isNoRefresh = yes, isExternal = yes};
    end
                                  /* Select VORHDR01*/

  end

   /*  */
   /* DLVRUSA CHANGES END*/

end // end XSPKS-SELECT-ORDER

// exit to another application
Function XSPKS01()
   /* ------------------------------------------------------------*/
   /* Set the application to be invoked for PF1 or PF4.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf1) /* PF1 was pressed*/
    COMMAREA.CATOAP = "GD00"; /* Indicate Goal Documentation*/
  end

  if (converseVar.eventKey is pf4) /* PF4 was pressed*/
    COMMAREA.CATOAP = "MN0M"; /* Indicate Master Menu*/
  end

   /* ------------------------------------------------------------*/
   /* Save the application user area in the COMMAREA.*/
   /* ------------------------------------------------------------*/

  if (COMMAREA.CATOSYS == "PK" /* Same system*/
   || COMMAREA.CATOSYS == "PW") /* or alternate system*/

    COMMAREA.CAUSERA = PKWREC.PKWGRPLV; /* Save user area*/
  else
    COMMAREA.CAUSERA = " "; /* Clear user area*/

  end

   /* ------------------------------------------------------------*/
   /* Transfer control to the specified application.*/
   /* ------------------------------------------------------------*/

  XSEXIT(); /* Exit to another application*/

   /* ------------------------------------------------------------*/
   /* Reestablish the COMMAREA application and item fields.*/
   /* ------------------------------------------------------------*/

  COMMAREA.CAEZSG3 = "0"; /* Force zero third character*/
  COMMAREA.CACURRAP = COMMAREA.CAEZSAP; /* CURR application*/

  if (converseVar.eventKey is pfkey) /* PF key was pressed*/

    COMMAREA.CATOAP = " "; /* Clear TO application*/

    if (converseVar.eventKey is pf1) /* PF1 was pressed*/
      COMMAREA.CAITEM = " "; /* Clear map name from item*/
    end

  end


end // end XSPKS01

// Exit to another application
Function XSPT001()
   /* ------------------------------------------------------------*/
   /* Set the application to be invoked for PF1 or PF4.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf1) /* PF1 was pressed*/
    COMMAREA.CATOAP = "GD01"; /* Indicate Goal Documentation*/
  end

  if (converseVar.eventKey is pf4) /* PF4 was pressed*/
    COMMAREA.CATOAP = "MN0M"; /* Indicate Master Menu*/
  end

   /* ------------------------------------------------------------*/
   /* Save the application user area in the COMMAREA.*/
   /* ------------------------------------------------------------*/

  if (COMMAREA.CATOSYS == "PT") /* Transfer within same system*/

    COMMAREA.CAUSERA = PTWREC.CAUSERA; /* Save user area*/
  else
    COMMAREA.CAUSERA = " "; /* Clear user area*/

  end

   /* ------------------------------------------------------------*/
   /* Transfer control to the specified application.*/
   /* ------------------------------------------------------------*/

  XSEXIT(); /* Exit to another application*/

   /* ------------------------------------------------------------*/
   /* If transfer failed, return an error to the calling process.*/
   /* ------------------------------------------------------------*/

  if (COMMAREA.CASECRC == 3 /* Application not found*/
   || COMMAREA.CASECRC == 4) /* or transfer not allowed*/

    converseLib.validationFailed(6); /* Indicate not allowed*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/

  end


end // end XSPT001

// INIT     PV Common Rtn Fields
Function XSPVS01()

   /* *************************************************************/
   /* ***        Initialize Certain Fields used by             ****/
   /* **              the PV Common Routines                    ***/
   /* ***                                                      ****/
   /* *************************************************************/

   /* Retrieve Passed Record*/
  PVUREC.PVUGROUP = COMMAREA.CAUSERA;

  PVUREC.PVUERNBR = 0;
  PVUREC.PVUERGEN = 1;
  PVUREC.PVUERVND = 2;
  PVUREC.PVUERIVC = 3;
  PVUREC.PVUERKEY = 4;
  PVUREC.PVUINQRY = "N";
  PVUREC.PVUALLWD = "Y";
  PVUREC.PVUENDOA = "N";
  PVUREC.PVUSCRDL = "N";
  PVUREC.PVUERROR[PVUERGEN] = " ";
  PVUREC.PVUERROR[PVUERVND] = "Y";
  PVUREC.PVUERROR[PVUERIVC] = "Y";
  PVUREC.PVUERROR[PVUERKEY] = "Y";

  XSPVS56(); /* Set Memo Amount Limits*/

  set PVAREC empty; /* Clear Invoice Header Record*/
  set PVBREC empty; /* Clear Invoice Line Item Record*/
  set PVOREC empty; /* Clear Vendor Record*/
  set PVYREC empty; /* Clear IO Function Record*/
  set TA1REC empty; /* Clear Error Diagnostic Record*/
  set SQLCA empty; /* Clear SQL Communication Area*/
  set ERRSQLCA empty; /* Clear SQL Communication Area*/

  return; /* Last Statement*/


   /* ***  End of XSPVS01  ****/
end // end XSPVS01

// TRANSFER to Code Inquiry
Function XSPVS51()

   /* *************************************************************/
   /* ***                                                      ****/
   /* **        Transfer Control To Code Inquiry                ***/
   /* ***                                                      ****/
   /* *************************************************************/

  COMMAREA.CATOAP = "PV0G";
  PVUREC.PVUCHOIC = 7;
  COMMAREA.CAUSERA = PVUREC.PVUGROUP;
  XSEXIT();

  return; /* Last Statement*/


   /* ***  End of XSPVS51  ****/

end // end XSPVS51

// ABEND    DB2 Routine
Function XSPVS52()

   /* *************************************************************/
   /* ***   This routine is used by the PVxx applications      ****/
   /* **       to handle all DB2 related fatal errors.          ***/
   /* ***                                                      ****/
   /* *************************************************************/

  TA1REC.TA1TYPE = "DB2";
  TA1REC.TA1FUNC = "RETN";
  move SQLCA to ERRSQLCA withV60Compat;
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

  XSPVS53(); /* Fatal Error routine*/

  return; /* Last Statement*/


   /* ***  End of XSPVS52  ****/
end // end XSPVS52

// FATAL ER Application Routine
Function XSPVS53()

   /* *************************************************************/
   /* ***                                                      ****/
   /* **       Set the flags to end the application.            ***/
   /* ***                                                      ****/
   /* *************************************************************/

  PVUREC.PVUALLWD = "N"; /* Allowed or not allowed to continue*/
  PVUREC.PVUENDOA = "Y"; /* End of application flag*/
  PVUREC.PVUERROR[PVUERGEN] = "Y"; /* General Error Flag*/

  return; /* Last Statement*/


   /* ***  End of XSPVS53  ****/
end // end XSPVS53

// CREATE   VFORCE01 Entry
Function XSPVS54()

   /* *************************************************************/
   /* ***                                                      ****/
   /* **        Create VFORCE01 Entry                           ***/
   /* ***                                                      ****/
   /* *************************************************************/

  PVUREC.PVBLNINB = 0;
  PVUREC.PVXERNBR = 0;
  PVYREC.PVYFNC = "A ";
  PVUREC.PVUCNTR1 = 1;
  while (PVXREC.PVXERNBR[PVUCNTR1] > 0)
    sysVar.arrayIndex = PVXREC.PVXERNBR[PVUCNTR1];
    if (COMMAREA.CACURRAP == "PV0D")
      sysVar.arrayIndex = PVDTBL.PVDXFACD[sysVar.arrayIndex];
    else
      sysVar.arrayIndex = PVFTBL.PVDXFACD[sysVar.arrayIndex];
      if (PVXREC.PVXACTAM[PVUCNTR1] < 0)
        sysVar.arrayIndex = sysVar.arrayIndex + 1;
      end
    end

    set PVLREC empty;
    move PVUREC to PVLREC withV60Compat;
    PVLREC.PVBLNINB = PVXREC.PVBLNINB[PVUCNTR1];
    PVLREC.XFAIND = XFATBL.XFAIND[sysVar.arrayIndex];
    PVLREC.XFACD = XFATBL.XFACD[sysVar.arrayIndex];
    PVLREC.PVLFRAMT = PVXREC.PVXACTAM[PVUCNTR1];
    if (COMMAREA.CACURRAP == "PV0D"
     && PVXREC.PVXQDIFF[PVUCNTR1] != 0)
      if (PVXREC.PVXERNBR[PVUCNTR1] == 18)
        PVLREC.PVLFRAMT = PVXREC.PVXPDIFF[PVUCNTR1];
      else
        PVLREC.PVLFRAMT = PVXREC.PVXQDIFF[PVUCNTR1];
      end
    end
    PVLREC.XXXUSID1 = COMMAREA.CAUSERID;
    PVLREC.ZZZSDT = TA2REC.TA2GRGGN;
    PVLREC.ZZZCHGDT = TA2REC.TA2GRGGN;
    PVLREC.ZZZCHGTM = TA2REC.TA2TIMHM;
    if (PVZREC.PVZNORCV == "Y"
     && PVLREC.XFACD == "08")
       /* next sentence*/
    else
      if (PVXREC.PVBLNINB[PVUCNTR1] == PVUREC.PVBLNINB
       && PVXREC.PVXERNBR[PVUCNTR1] == PVUREC.PVXERNBR)
         /* next sentence*/
      else
        XPPV440(); /* Insert PVLREC*/
      end
    end
    PVUREC.PVBLNINB = PVXREC.PVBLNINB[PVUCNTR1];
    PVUREC.PVXERNBR = PVXREC.PVXERNBR[PVUCNTR1];
    PVUREC.PVUCNTR1 = PVUREC.PVUCNTR1 + 1;
  end

  return; /* Last Statement*/


   /* ***  End of XSPVS54  ****/
end // end XSPVS54

// TRANSFER to Invoice Inquiry
Function XSPVS55()

   /* *************************************************************/
   /* ***                                                      ****/
   /* **        Transfer Control To Invoice Inquiry             ***/
   /* ***                                                      ****/
   /* *************************************************************/

  COMMAREA.CATOAP = "PV0I";
  XSEXIT();

  return; /* Last Statement*/


   /* ***  End of XSPVS55  ****/
end // end XSPVS55

// SET      Memo Amount Limit
Function XSPVS56()
   /* 02-28-00 JKUNDU THE ADJUSTMENT MEMO LIMITS HAVE BEEN CHANGED*/
   /* TO <-1000.00 OR >1000.00 ON USER REQUESTS.*/
   /* 03-06-00 JKUNDU THE NEW ADJUSTMENT MEMO LIMITS WILL BE EFFECTIVE*/
   /* WHILE CREATING ADJUSTMENTS THROUGH PV0D.*/

   /* *************************************************************/
   /* ***                                                      ****/
   /* **    SET Memo Amount Limit                               ***/
   /* ***                                                      ****/
   /* *************************************************************/

  PVUREC.PVULIMT1 = 0; /* Set Adjustment Memo Limit*/
  PVUREC.PVULIMT2 = 0;

  if (COMMAREA.CACLVL[1] == "Y")
    PVUREC.PVULIMT1 = -500.00;
    PVUREC.PVULIMT2 = 500.00;
  end

  if (COMMAREA.CACLVL[2] == "Y")
    PVUREC.PVULIMT1 = -9999999999999.99;
    PVUREC.PVULIMT2 = 9999999999999.99;
  end

   /* JKUNDU CHANGES BEGIN 02/28/00*/
   /* MOVE -9999999999999.99 TO PVUREC.PVULIMT1;*/
   /* MOVE 9999999999999.99 TO PVUREC.PVULIMT2;*/
  if (COMMAREA.CACURRAP == "PV0D")
    PVUREC.PVULIMT1 = 1000.00;
    PVUREC.PVULIMT2 = -1000.00;
  else
    PVUREC.PVULIMT1 = -9999999999999.99;
    PVUREC.PVULIMT2 = 9999999999999.99;
  end
   /* JKUNDU CHANGES END   02/28/00*/

  return; /* Last Statement*/


   /* ***  End of XSPVS56  ****/
end // end XSPVS56

// DELIVER  a Message
Function XSPVS57()

   /* *************************************************************/
   /* ***                                                      ****/
   /* **           Deliver the message to the user.             ***/
   /* ***                                                      ****/
   /* *************************************************************/

  if (COMMAREA.CASECRC == 0) /* Check if there's a Security Error*/
    PVUREC.CAMSG = " ";
    if (PVUREC.PVUERNBR > 0) /* If none, display our own message*/
      if (PVUREC.PVUERNBR == 9999)
        converseLib.validationFailed();
      else
        converseLib.validationFailed(PVUREC.PVUERNBR);
      end
      PVUREC.PVUERNBR = 0; /* Reset Error Message Field*/
    end
  else
    PVUREC.CAMSG = COMMAREA.CAMSG;
    COMMAREA.CASECRC = 0; /* Reset Security Error*/
  end

  return; /* Last Statement*/


   /* ***  End of XSPVS57  ****/
end // end XSPVS57

// FORMAT   Next Invoice Number
Function XSPVS58()

   /* *************************************************************/
   /* ***                                                      ****/
   /* **           Format Next Invoice Number                   ***/
   /* ***                                                      ****/
   /* *************************************************************/

  PVUREC.PVUNEXTI = PVFREC.PVFNXIVC;
  PVUREC.PVUNEXTI = PVUREC.PVUNEXTI + 1;
  PVFREC.PVFNXIVC = PVUREC.PVUNEXTI;
  PVUREC.PVUINVCA = "A";
  PVUREC.PVUINVCE = PVUREC.PVAIVCID;
  PVUREC.PVUCNTR1 = 0;
  PVUREC.PVUCNTR2 = 0;
  while (PVUREC.PVUCNTR1 < 16)
    PVUREC.PVUCNTR1 = PVUREC.PVUCNTR1 + 1;
    if (PVUREC.PVUINVCO[PVUCNTR1] == "0"
     && PVUREC.PVUCNTR2 == 0)
       /* next sentence*/
    else
      if (PVUREC.PVUINVCO[PVUCNTR1] == " ")
         /* next sentence*/
      else
        PVUREC.PVUCNTR2 = PVUREC.PVUCNTR2 + 1;
        PVUREC.PVUINVCO[PVUCNTR2] = PVUREC.PVUINVCO[PVUCNTR1];
      end
    end
    if (PVUREC.PVUCNTR1 == PVUREC.PVUCNTR2)
       /* next sentence*/
    else
      PVUREC.PVUINVCO[PVUCNTR1] = " ";
    end
  end
  PVUREC.PVAIVCID = PVUREC.PVUINVCE;

  return; /* Last Statement*/


   /* ***  End of XSPVS58  ****/
end // end XSPVS58

// PV APPL  Common Exit Routine
Function XSPVS60()
   /* 02/28/00 JKUNDU - WHILE CUURENT APPLICATION IS PV0D TRANSFER*/
                     /* SHOULD GO TO PV0B IF PF KEY = PF3.*/
   /* *************************************************************/
   /* ***                                                      ****/
   /* **        Go Back to Calling Application                  ***/
   /* ***                                                      ****/
   /* *************************************************************/

  if (converseVar.eventKey is pf3)
    if (COMMAREA.CACURRAP == "PV0D")
      COMMAREA.CATOAP = "PV0B";
    else
      COMMAREA.CATOAP = "PV0M";
    end
  else
    if (converseVar.eventKey is pf13)
      COMMAREA.CATOAP = "PV0A";
    else
      if (converseVar.eventKey is pf14)
        COMMAREA.CATOAP = "PV0G";
        PVUREC.PVUCHOIC = 2;
        COMMAREA.CAUSERA = PVUREC.PVUGROUP;
      else
        COMMAREA.CATOAP = COMMAREA.CAFROMAP;
        if (COMMAREA.CAFROMAP == "PV0D"
         || COMMAREA.CAFROMAP == "PV0E")
          COMMAREA.CAFROMAP = "PV0A";
        end
      end
    end
  end

  if (COMMAREA.CATOAP == " ")
     /* next sentence*/
  else
    XSEXIT();
  end

  return; /* Last Statement*/


   /* ***  End of XSPVS60  ****/
end // end XSPVS60

// SAVE     PVA Keys in COMMAREA
Function XSPVS96()

   /* *************************************************************/
   /* ***                                                      ****/
   /* **     Save PVAREC Keys in PVUREC/COMMAREA.CAUSERA        ***/
   /* ***                                                      ****/
   /* *************************************************************/

  PVUREC.PVURCRD1 = "PVAREC";
  PVUREC.PVURCRD3 = "PVOREC";
  move PVAREC to PVUREC withV60Compat;
  if (PVUREC.PVCAETYP == " ")
    PVUREC.PVCAETYP = "0";
  end
  COMMAREA.CAUSERA = PVUREC.PVUGROUP;

  return; /* Last Statement*/


   /* ***  End of XSPVS96  ****/
end // end XSPVS96

// SAVE     PVO Keys in COMMAREA
Function XSPVS97()

   /* *************************************************************/
   /* ***                                                      ****/
   /* **     Save PVBREC Keys in PVUREC/COMMAREA.CAUSERA        ***/
   /* ***                                                      ****/
   /* *************************************************************/

  PVUREC.PVURCRD2 = "PVBREC";
  PVUREC.PVURCRD6 = "      ";
  move PVBREC to PVUREC withV60Compat;
  COMMAREA.CAUSERA = PVUREC.PVUGROUP;

  return; /* Last Statement*/


   /* ***  End of XSPVS97  ****/
end // end XSPVS97

// SAVE     PVO Keys in COMMAREA
Function XSPVS98()

   /* *************************************************************/
   /* ***                                                      ****/
   /* **     Save PVOREC Keys in PVUREC/COMMAREA.CAUSERA        ***/
   /* ***                                                      ****/
   /* *************************************************************/

  PVUREC.PVURCRD3 = "PVOREC";
  move PVOREC to PVUREC withV60Compat;
  COMMAREA.CAUSERA = PVUREC.PVUGROUP;

  return; /* Last Statement*/


   /* ***  End of XSPVS98  ****/
end // end XSPVS98

// close : location : 0
Function XSPWBC1()


   /* ************************************************************/
   /* *** close select set of: destination table              ****/
   /* *** using the standard i/o processing version #0        ****/
   /* *** note: sqlcq.sqlcode used re: can't "set" ezesqcod   ****/
   /* *** setup the following just before this is executed:   ****/
   /* ***   TA1REC.TA1LOCAT(2) = what executes this sgrp      ****/
   /* ***   TA1REC.TA1MAP      = what map this data is from   ****/
   /* *** code the action for the following return codes:     ****/
   /* ***      0 = successful - continue                      ****/
   /* ***   -507 = cursor already closed - return 0           ****/
   /* ***     <0 = db/severe error - contact programming msg  ****/
   /* ***          note: clear screen & put keys back         ****/
   /* ***          note: TA0020 will have been executed       ****/
   /* ***                within this sgrp for <0 only         ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** close select set (if prior to EOF)                  ****/
   /* ************************************************************/

  call "IO2170" ("C1", SQLCA, PWBREC) {isNoRefresh = yes, isExternal = yes}; /* <=== close select set*/

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -501)
    SQLCA.VAGen_SQLCODE = 0;
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSPK3C0 ";
  TA1REC.TA1LOCAT[1] = "IO2170  ";
  TA1REC.TA1LOCAT[3] = "CLOSE   ";
  TA1REC.TA1LOCAT[4] = "SETINQ  ";
  TA1REC.TA1DBASE = "DPICK   ";
  TA1REC.TA1TBLVU = "VZNSUB01";
  TA1REC.TA1TBLKE = PWBREC.PWBKEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
  XSPF4();

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSPWBC1

// fetch : location : 0
Function XSPWBF1()


   /* ************************************************************/
   /* *** fetch next row from: destination table              ****/
   /* *** using the standard i/o processing version #0        ****/
   /* *** note: sqlcq.sqlcode used re: can't "set" ezesqcod   ****/
   /* *** note: +100 - not found was detected as part of the  ****/
   /* ***       select set previously executed                ****/
   /* *** setup the following just before this is executed:   ****/
   /* ***   TA1REC.TA1LOCAT(2) = what executes this sgrp      ****/
   /* ***   TA1REC.TA1MAP      = what map this data is from   ****/
   /* *** code the action for the following return codes:     ****/
   /* ***      0 = successful - continue                      ****/
   /* ***   +100 = EOF                                        ****/
   /* ***     <0 = db/severe error - contact programming msg  ****/
   /* ***          note: clear screen & put keys back         ****/
   /* ***          note: TA0020 will have been executed       ****/
   /* ***                within this sgrp for <0 only         ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** scan/retrieve/fetch next row                        ****/
   /* *** note: CSP closes cursor at end of set (+100)        ****/
   /* ************************************************************/

  call "IO2170" ("N1", SQLCA, PWBREC) {isNoRefresh = yes, isExternal = yes}; /* <=== select next row*/

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSPWBF0 ";
  TA1REC.TA1LOCAT[1] = "IO2170  ";
  TA1REC.TA1LOCAT[3] = "FETCH   ";
  TA1REC.TA1LOCAT[4] = "NEXT    ";
  TA1REC.TA1DBASE = "DPICK   ";
  TA1REC.TA1TBLVU = "VZNSUM01";
  TA1REC.TA1TBLKE = PWBREC.PWBKEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
  XSPF4();

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSPWBF1

// setinq : location : 0
Function XSPWBS1()


   /* ************************************************************/
   /* *** select set of rows from: destination table          ****/
   /* *** using the standard i/o processing version #0        ****/
   /* *** note: sqlcq.sqlcode used re: can't "set" ezesqcod   ****/
   /* *** note: +100 - not found can't be detected until the  ****/
   /* ***       first fetch is executed                       ****/
   /* *** setup the following just before this is executed:   ****/
   /* ***   TA1REC.TA1LOCAT(2) = what executes this sgrp      ****/
   /* ***   TA1REC.TA1MAP      = what map this data is from   ****/
   /* *** code the action for the following return codes:     ****/
   /* ***      0 = successful - continue                      ****/
   /* ***   +100 = none found - setup not fnd error/msg       ****/
   /* ***   -911 = deadlock - setup try again error/msg       ****/
   /* ***     <0 = db/severe error - contact programming msg  ****/
   /* ***          note: clear screen & put keys back         ****/
   /* ***          note: TA0020 will have been executed       ****/
   /* ***                within this sgrp for <0 only         ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** select set with unique key                          ****/
   /* ************************************************************/

  call "IO2170" ("S1", SQLCA, PWBREC) {isNoRefresh = yes, isExternal = yes}; /* <=== select set row*/

  if (SQLCA.VAGen_SQLCODE == -911)
    return;
  end

  if (SQLCA.VAGen_SQLCODE < 0)
    TA1REC.TA1TYPE = "DB2 ";
    TA1REC.TA1FUNC = "RETN";
    TA1REC.TA1PGMNM = "XSPKHS0 ";
    TA1REC.TA1LOCAT[1] = "IO2170  ";
    TA1REC.TA1LOCAT[3] = "SELECT  ";
    TA1REC.TA1LOCAT[4] = "SET     ";
    TA1REC.TA1DBASE = "DPICK   ";
    TA1REC.TA1TBLVU = "VZNSUM01";
    TA1REC.TA1TBLKE = PWBREC.PWBKEY;
    move SQLCA to ERRSQLCA withV60Compat;
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback();
    call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
    XSPF4();
  end

   /* ************************************************************/
   /* *** scan/retrieve/fetch first row                       ****/
   /* *** in order to detect not found (+100)                 ****/
   /* *** note: CSP closes cursor at end of set (+100)        ****/
   /* *** note: any loop processing must use this first row   ****/
   /* ***       and fetch the next row at the end of the loop ****/
   /* ************************************************************/

  call "IO2170" ("N1", SQLCA, PWBREC) {isNoRefresh = yes, isExternal = yes}; /* <=== select set row*/

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSPWBS0 ";
  TA1REC.TA1LOCAT[1] = "IO2170  ";
  TA1REC.TA1LOCAT[3] = "FIRST   ";
  TA1REC.TA1LOCAT[4] = "FETCH   ";
  TA1REC.TA1DBASE = "DPICK   ";
  TA1REC.TA1TBLVU = "VZNSUM01";
  TA1REC.TA1TBLKE = PWBREC.PWBKEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
  XSPF4();

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSPWBS1

// pf3 logic to rtrn to frmt menu
Function XSSAS01()




   /* common statement group for use with a pf3. this works with*/
   /* the parameter array to note where we left off in order to*/
   /* have the calling format screen continue properly.*/


  SAWREC.SAWGROUP = COMMAREA.CAUSERA; /* refresh ws record*/

  SAAREC.SAASUB = 1;

  while (SAAREC.SAASUB <= 10) /* find first found selected parm*/
    if (SAWREC.SAWPRMLP[SAASUB] == "S") /* if found it*/
      SAWREC.SAWPRMLP[SAASUB] = "X"; /* mark for proper return*/
      SAAREC.SAASUB = 11; /* exit loop*/
    else
      SAAREC.SAASUB = SAAREC.SAASUB + 1;
    end
  end






end // end XSSAS01

// pf3 logic to rtrn to frmt menu
Function XSSAS02()




   /* common statement group for use with a pf3. this works with*/
   /* the sub-parameter array to note where we left off in order*/
   /* for the calling program to continue properly.*/


  SAWREC.SAWGROUP = COMMAREA.CAUSERA; /* refresh ws record*/

  SAAREC.SAASUB = 1;

  while (SAAREC.SAASUB <= 12) /* find first found selected parm*/
    if (SAWREC.SAWSPMLP[SAASUB] == "S") /* if found it*/
      SAWREC.SAWSPMLP[SAASUB] = "X"; /* mark for proper return*/
      SAAREC.SAASUB = 13; /* exit loop*/
    else
      SAAREC.SAASUB = SAAREC.SAASUB + 1;
    end
  end






end // end XSSAS02

// Setting segmented trans id
Function XSSEGTR()



   /* ************************************************************/
      /* This statement group is used for setting the cics     **/
      /* start tran id to the name of the application actually **/
      /* in execution.....                                     **/
          /* n o t e: this stmntgrp is only to be used for     **/
      /* "segmented" applications, and must be placed where    **/
      /* the commarea.cacurrap indicates the correct trans     **/
      /* actually in execution....                             **/
              /* 11-88 jw                                      **/
   /* ************************************************************/



  COMMAREA.CAEZSAP = sysVar.transactionID;
                                   /* move current appl id to ca w/s*/
  COMMAREA.CAEZSG4 = COMMAREA.CACURAP4;
                                   /* move 4th pos to ca w/s ezsegtr*/
  sysVar.transactionID = COMMAREA.CAEZSAP; /* set ezesegtr to appl trans id*/

end // end XSSEGTR

// OB SYSTEM - CALL TO SY2000
Function XSSL-CALL-SY2000()

     /* Get the Product/Region record*/

  set SQLCA empty;
  set WSY2000 empty;

  WSY2000.XGP-GPC-CD = PKNREC.XGPCD;
  WSY2000.SY-STY-NBR = PKNREC.SY1STNBR;
  WSY2000.SY-COLR-CD-ID = PKNREC.SY2CLRID;
  WSY2000.XDM-DIM-CD = PKNREC.XDMCD;
  WSY2000.XDR-PROD-REG-CD = "05";
  WSY2000.WSY2000-OPTION-CODE = "S ";
  WSY2000.WSY2000-SUB-OPTION-CODE = "O";

  call "SY2000" (WSY2000) {isNoRefresh = yes, isExternal = yes};

   /* Product/Region record is found*/
   /* Overlay those fields common to both records*/

  if (WSY2000.WSY2000-RETURN-CODE == 0)
    PKNREC.XPRCD = WSY2000.XPR-PROD-TYP-CD;
    PKNREC.XLCCD1 = WSY2000.XLC-LIFE-CYC-CD[1];
    PKNREC.XLCCD2 = WSY2000.XLC-LIFE-CYC-CD[2];
    PKNREC.XLCCD3 = WSY2000.XLC-LIFE-CYC-CD[3];
    PKNREC.XLCCD4 = WSY2000.XLC-LIFE-CYC-CD[4];
    PKNREC.SY2CEDT1 = WSY2000.SY-LIFE-CYC-EDT[1];
    PKNREC.SY2CEDT2 = WSY2000.SY-LIFE-CYC-EDT[2];
    PKNREC.SY2CEDT3 = WSY2000.SY-LIFE-CYC-EDT[3];
    PKNREC.SY2CEDT4 = WSY2000.SY-LIFE-CYC-EDT[4];
  else

    /* Database DPROD.VSYREG02 is busy*/

    if (WSY2000.WSY2000-RETURN-CODE == 98)
      /* next sentence*/
    else

      /* Record is not found*/

      if (WSY2000.WSY2000-RETURN-CODE == 02)
        /* next sentence*/
      else

        /* Bad return code*/

        TA1REC.TA1TYPE = "APPL";
        TA1REC.TA1FUNC = "POST";
        XSSLW01.XSSLW-WSY2000-GPC-CD = PKNREC.XGPCD;
        XSSLW01.XSSLW-WSY2000-STY-NBR = PKNREC.SY1STNBR;
        XSSLW01.XSSLW-WSY2000-COLR-CD = PKNREC.SY2CLRID;
        XSSLW01.XSSLW-WSY2000-DIM-CD = PKNREC.XDMCD;
        XSSLW01.XSSLW-WSY2000-PROD-REG-CD = WSY2000.XDR-PROD-REG-CD;
        XSSLW01.XSSLW-WSY2000-RETURN-CD = WSY2000.WSY2000-RETURN-CODE;
        TAEREC.TAEDESC1 = XSSLW-WSY2000-POST-1;
        TAEREC.TAEDESC2 = "CALL TO SY2000 - BAD RETURN CODE";
        TA1REC.TA1DBASE = "DPROD";
        TA1REC.TA1TBLVU = "SYREG02";
        try
          call "TA0020" (TA1REC, TAEREC) {isExternal = yes};
        end
      end
    end
  end
end // end XSSL-CALL-SY2000

// Exit to another application
Function XSSL001()
   /* ------------------------------------------------------------*/
   /* Set the application to be invoked for PF1 or PF4.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf1) /* PF1 was pressed*/

    COMMAREA.CATOAP = "GD00"; /* Indicate Goal Documentation*/

  end

  if (converseVar.eventKey is pf4) /* PF4 was pressed*/

    COMMAREA.CATOAP = "MN0M"; /* Indicate Master Menu*/

  end

   /* ------------------------------------------------------------*/
   /* Set the application to be invoked for PF3 if in main menu.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf3 /* PF3 was pressed*/
   && COMMAREA.CACURRAP == "SL0M") /* and main application menu*/

    COMMAREA.CATOAP = "MN0M"; /* Indicate Master Menu*/

  end

   /* ------------------------------------------------------------*/
   /* Save the application user area in the COMMAREA.*/
   /* ------------------------------------------------------------*/

  if (COMMAREA.CATOSYS == "SL" /* Transfer within same system*/
   || COMMAREA.CATOSYS == "SW") /* another valid sl prefix id*/

    COMMAREA.CAUSERA = SLWREC.SLWGROUP; /* Save user area*/
  else
    COMMAREA.CAUSERA = " "; /* Clear user area*/

  end

   /* ------------------------------------------------------------*/
   /* Transfer control to the specified application.*/
   /* ------------------------------------------------------------*/

  XSEXIT(); /* Exit to another application*/

   /* ------------------------------------------------------------*/
   /* Reestablish the COMMAREA application and item fields.*/
   /* ------------------------------------------------------------*/

  COMMAREA.CAEZSG3 = "0"; /* Force zero third character*/
  COMMAREA.CACURRAP = COMMAREA.CAEZSAP; /* CURR application*/

  if (converseVar.eventKey is pfkey) /* PF key was pressed*/

    COMMAREA.CATOAP = " "; /* Clear TO application*/

    if (converseVar.eventKey is pf1) /* PF1 was pressed*/
      COMMAREA.CAITEM = " "; /* Clear map name from item*/
    end

  end


end // end XSSL001

// inquiry : rcv log hdr : 0
Function XSSL1I0()


   /* ************************************************************/
   /* *** select unique row from:  receiving log hdr          ****/
   /* *** using the std module:  IO1570                       ****/
   /* *** note: use slvrec to pass function & date ranges     ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   +100 = not found                                  ****/
   /* ***   -811 = duplicates found                           ****/
   /* ***          note: do NOT clear screen                  ****/
   /* ***   -911 = deadlock - resource unavailable            ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** select unique row                                   ****/
   /* ************************************************************/

  SLVREC.SLVFNC = "S ";

  call "IO1570" (SLVREC, SQLCA, SL1REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -811)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -911)
    TA1REC.TA1FUNC = "POST";
  else
    TA1REC.TA1FUNC = "RETN";
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1PGMNM = "XSSL1I0 ";
  TA1REC.TA1LOCAT[1] = "IO1570  ";
  TA1REC.TA1LOCAT[3] = "SELECT  ";
  TA1REC.TA1LOCAT[4] = "UNIQUE  ";
  TA1REC.TA1DBASE = "DSTLOC  ";
  TA1REC.TA1TBLVU = "VRLHDR01";
  TA1REC.TA1TBLKE = SL1REC.SL1KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSL1I0

// inquiry : area/zone : 0
Function XSSL4I0()


   /* ************************************************************/
   /* *** select unique row from:  area/zone                  ****/
   /* *** using the std module:  IO1480                       ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   +100 = not found                                  ****/
   /* ***   -811 = duplicates found                           ****/
   /* ***          note: do NOT clear screen                  ****/
   /* ***   -911 = deadlock - resource unavailable            ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** select unique row                                   ****/
   /* ************************************************************/

  call "IO1480" ("S ", SQLCA, SL4REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -811)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -911)
    TA1REC.TA1FUNC = "POST";
  else
    TA1REC.TA1FUNC = "RETN";
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1PGMNM = "XSSL4I0 ";
  TA1REC.TA1LOCAT[1] = "IO1480  ";
  TA1REC.TA1LOCAT[3] = "SELECT  ";
  TA1REC.TA1LOCAT[4] = "UNIQUE  ";
  TA1REC.TA1DBASE = "DSTLOC  ";
  TA1REC.TA1TBLVU = "VAZONE01";
  TA1REC.TA1TBLKE = SL4REC.SL4KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSL4I0

// close : location : 1
Function XSSL5C1()


   /* ************************************************************/
   /* *** close select set of:  location table                ****/
   /* *** using the std module:  IO1490                       ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   -501 = cursor already closed = return 0           ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** close select set (if prior to EOF)                  ****/
   /* ************************************************************/

  call "IO1490" ("C1", SQLCA, SL5REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -501)
    SQLCA.VAGen_SQLCODE = 0;
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSSL5C1 ";
  TA1REC.TA1LOCAT[1] = "IO1490  ";
  TA1REC.TA1LOCAT[3] = "CLOSE   ";
  TA1REC.TA1LOCAT[4] = "SETINQ  ";
  TA1REC.TA1DBASE = "DSTLOC  ";
  TA1REC.TA1TBLVU = "VLOCAT01";
  TA1REC.TA1TBLKE = SL5REC.SL5KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSL5C1

// fetch : location : 1
Function XSSL5F1()


   /* ************************************************************/
   /* *** fetch next row from:  location                      ****/
   /* *** using the std module:  IO1490                       ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   +100 = EOF (first +100 = not fnd, was detected as ****/
   /* ***          part of the select set w/first fetch)      ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** scan/retrieve/fetch next row                        ****/
   /* *** note: CSP closes cursor at end of set (+100)        ****/
   /* ************************************************************/

  call "IO1490" ("N1", SQLCA, SL5REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
    XSSL5C1(); /* <=== std close cursor*/
    if (SQLCA.VAGen_SQLCODE == 0)
      SQLCA.VAGen_SQLCODE = +100;
    end
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSSL5F1 ";
  TA1REC.TA1LOCAT[1] = "IO1490  ";
  TA1REC.TA1LOCAT[3] = "FETCH   ";
  TA1REC.TA1LOCAT[4] = "NEXT    ";
  TA1REC.TA1DBASE = "DSTLOC  ";
  TA1REC.TA1TBLVU = "VLOCAT01";
  TA1REC.TA1TBLKE = SL5REC.SL5KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSL5F1

// inquiry : location : 0
Function XSSL5I0()


   /* ************************************************************/
   /* *** select unique row from:  location table             ****/
   /* *** using the std module:  IO1490                       ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   +100 = not found                                  ****/
   /* ***   -811 = duplicates found                           ****/
   /* ***          note: do NOT clear screen                  ****/
   /* ***   -911 = deadlock - resource unavailable            ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** select unique row                                   ****/
   /* ************************************************************/

  call "IO1490" ("S ", SQLCA, SL5REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -811)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -911)
    TA1REC.TA1FUNC = "POST";
  else
    TA1REC.TA1FUNC = "RETN";
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1PGMNM = "XSSL5I0 ";
  TA1REC.TA1LOCAT[1] = "IO1490  ";
  TA1REC.TA1LOCAT[3] = "SELECT  ";
  TA1REC.TA1LOCAT[4] = "UNIQUE  ";
  TA1REC.TA1DBASE = "DSTLOC  ";
  TA1REC.TA1TBLVU = "VLOCAT01";
  TA1REC.TA1TBLKE = SL5REC.SL5KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSL5I0

// replace : location : 0
Function XSSL5R0()


   /* ************************************************************/
   /* *** replace unique row in:  location                    ****/
   /* *** using the std module:  IO1490                       ****/
   /* *** note: use slvrec to pass function & date ranges     ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   +100 = concurrent update - re:                    ****/
   /* ***          deleted since last read (rec blanked out)  ****/
   /* ***          updated since last read (new data in rec)  ****/
   /* ***   -911 = deadlock - resource unavailable            ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** replace row                                         ****/
   /* *** note: IO process increments record zzzchgct by +1   ****/
   /* ***       but ID's row to update by the old zzzchgct    ****/
   /* ************************************************************/

  SL5REC.ZZZCHGDT = X2CREC.X2CCURDT;
  SL5REC.ZZZCHGTM = X3CREC.X3CCURST;

  call "IO1490" ("U ", SQLCA, SL5REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
     /* ************************************************************/
     /* *** select the original row without a change count      ****/
     /* *** note: select unique does NOT use zzzchgct           ****/
     /* *** note: this puts current version of data in record   ****/
     /* ***       or blank out record layout = deleted          ****/
     /* ************************************************************/
    XSSL5I0(); /* <=== select unique row*/
    if (SQLCA.VAGen_SQLCODE == 0)
      SQLCA.VAGen_SQLCODE = +100;
      return;
    end
    if (SQLCA.VAGen_SQLCODE == +100)
      SL5REC.SL5DATA = " ";
      return;
    end
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -911)
    TA1REC.TA1FUNC = "POST";
  else
    TA1REC.TA1FUNC = "RETN";
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1PGMNM = "XSSL5R0 ";
  TA1REC.TA1LOCAT[1] = "IO1490  ";
  TA1REC.TA1LOCAT[3] = "REPLACE ";
  TA1REC.TA1LOCAT[4] = "ROW     ";
  TA1REC.TA1DBASE = "DSTLOC  ";
  TA1REC.TA1TBLVU = "VLOCAT01";
  TA1REC.TA1TBLKE = SL5REC.SL5KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSL5R0

// setinq : location : 1
Function XSSL5S1()


   /* ************************************************************/
   /* *** select set of rows from:  location                  ****/
   /* *** using the std module:  IO1490                       ****/
   /* *** note: use slvrec to pass function & date ranges     ****/
   /* *** note: the 1st fetch will be in the record layout    ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   +100 = none fnd on 1st fetch                      ****/
   /* ***          (+100 = EOF detected in fetch next only)   ****/
   /* ***   -911 = deadlock - resource unavailable            ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** select set with unique field values for:            ****/
   /* ***   xwhcd                                             ****/
   /* ***   xarcd                                             ****/
   /* *** the following may be used with a wild card (*):     ****/
   /* ***   sl4zone                                           ****/
   /* ***   yltcd                                             ****/
   /* ***   ylscd                                             ****/
   /* *** the order by for this select set is:                ****/
   /* ***   xwhcd                                             ****/
   /* ***   xarcd                                             ****/
   /* ***   sl4zone                                           ****/
   /* ***   sl5loctn                                          ****/
   /* ***   yspcd                                             ****/
   /* ************************************************************/

  call "IO1490" ("S1", SQLCA, SL5REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE < 0)
    if (SQLCA.VAGen_SQLCODE == -911)
      TA1REC.TA1FUNC = "POST";
    else
      TA1REC.TA1FUNC = "RETN";
    end
    TA1REC.TA1TYPE = "DB2 ";
    TA1REC.TA1PGMNM = "XSSL5S1 ";
    TA1REC.TA1LOCAT[1] = "IO1490  ";
    TA1REC.TA1LOCAT[3] = "SELECT  ";
    TA1REC.TA1LOCAT[4] = "SET     ";
    TA1REC.TA1DBASE = "DSTLOC  ";
    TA1REC.TA1TBLVU = "VLOCAT01";
    TA1REC.TA1TBLKE = SL5REC.SL5KEY;
    move SQLCA to ERRSQLCA withV60Compat;
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback();
    call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
    return;
  end

   /* ************************************************************/
   /* *** scan/retrieve/fetch first row                       ****/
   /* *** in order to detect not found (+100)                 ****/
   /* *** note: CSP closes cursor at end of set (+100)        ****/
   /* *** note: any loop processing must use this first row   ****/
   /* ***       and fetch the next row at the end of the loop ****/
   /* *** note: fetch handles return code correctly           ****/
   /* ************************************************************/

  XSSL5F1(); /* <=== fetch first row*/

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSL5S1

// update : location : 1
Function XSSL5U1()


   /* ************************************************************/
   /* *** get unique row for update of:  location             ****/
   /* *** using the std module:  IO1490                       ****/
   /* *** note: IO process DOES move data to record           ****/
   /* ***       therefore, at this time (w/IO modules)        ****/
   /* ***       this will execute the std select unique sgrp  ****/
   /* ***       and                                           ****/
   /* ***       this sgrp should be used/executed so that     ****/
   /* ***       future conversion to native CSP DB2 will      ****/
   /* ***       only have to change/add code in this sgrp     ****/
   /* ***       and regenerate all applications               ****/
   /* *** note: use slvrec to pass function & date ranges     ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   +100 = not found (does not use zzzchgct)          ****/
   /* ***   -911 = deadlock - resource unavailable            ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

  XSSL5I0(); /* <=== std select unique*/

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSL5U1

// 'c4' close for prod/loc db
Function XSSL6C4()


   /* ************************************************************/
   /* *** close select set of:  product location table        ****/
   /* *** using the std module:  IO1470                       ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   -501 = cursor already closed = return 0           ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** close select set (if prior to EOF)                  ****/
   /* ************************************************************/

  call "IO1470" ("C4", SQLCA, SL6REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -501)
    SQLCA.VAGen_SQLCODE = 0;
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSSL6C4 ";
  TA1REC.TA1LOCAT[1] = "IO1470  ";
  TA1REC.TA1LOCAT[3] = "CLOSE   ";
  TA1REC.TA1LOCAT[4] = "SETINQ  ";
  TA1REC.TA1DBASE = "DSTLOC  ";
  TA1REC.TA1TBLVU = "VSYLOC01";
  TA1REC.TA1TBLKE = SL6REC.SL6KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSL6C4

// 'f4' fetch to prod/loc db
Function XSSL6F4()


   /* ************************************************************/
   /* *** fetch next row from:  product location              ****/
   /* *** using the std module:  IO1470                       ****/
   /* *** note: use slvrec to pass function & date ranges     ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   +100 = EOF (first +100 = not fnd, was detected as ****/
   /* ***          part of the select set w/first fetch)      ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** scan/retrieve/fetch next row                        ****/
   /* *** note: CSP closes cursor at end of set (+100)        ****/
   /* ***       but w/these io mods the sgrp will close       ****/
   /* ************************************************************/

  call "IO1470" ("N4", SQLCA, SL6REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
    XSSL6C4(); /* <=== std close cursor*/
    if (SQLCA.VAGen_SQLCODE == 0)
      SQLCA.VAGen_SQLCODE = +100;
    end
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSSL6F4 ";
  TA1REC.TA1LOCAT[1] = "IO1470  ";
  TA1REC.TA1LOCAT[3] = "FETCH   ";
  TA1REC.TA1LOCAT[4] = "NEXT    ";
  TA1REC.TA1DBASE = "DSTLOC  ";
  TA1REC.TA1TBLVU = "VSYLOC01";
  TA1REC.TA1TBLKE = SL6REC.SL6KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSL6F4

// 's4' scan on prod/loc db
Function XSSL6S4()


   /* ************************************************************/
   /* *** select set of rows from:  product location          ****/
   /* *** using the std module:  IO1470                       ****/
   /* *** note: use slvrec to pass function & date ranges     ****/
   /* *** note: the 1st fetch will be in the record layout    ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   +100 = none fnd on 1st fetch                      ****/
   /* ***          (+100 = EOF detected in fetch next only)   ****/
   /* ***   -911 = deadlock - resource unavailable            ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** select set with unique field values for:            ****/
   /* ***   xwhcd                                             ****/
   /* ***   xarcd                                             ****/
   /* ***   sl4zone                                           ****/
   /* ***   sl5loctn                                          ****/
   /* *** the following may be used with a wild card (*):     ****/
   /* ***   sl2palet                                          ****/
   /* ***   sl2case                                           ****/
   /* *** the order by for this select set is:                ****/
   /* ***   xwhcd                                             ****/
   /* ***   xarcd                                             ****/
   /* ***   sl4zone                                           ****/
   /* ***   sl5loctn                                          ****/
   /* ***   xgpcd                                             ****/
   /* ***   sy1stnbr                                          ****/
   /* ***   sy2clrid                                          ****/
   /* ***   xdmcd                                             ****/
   /* ***   xqacd                                             ****/
   /* ***   xsdcd                                             ****/
   /* ***   xsacd                                             ****/
   /* ***   xpgcd                                             ****/
   /* ***   xumcd                                             ****/
   /* ***   xowcd                                             ****/
   /* ***   xslcd                                             ****/
   /* ***   sl2palet                                          ****/
   /* ***   sl2case                                           ****/
   /* ***   sy5szid                                           ****/
   /* ************************************************************/

  call "IO1470" ("S4", SQLCA, SL6REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE < 0)
    if (SQLCA.VAGen_SQLCODE == -911)
      TA1REC.TA1FUNC = "POST";
    else
      TA1REC.TA1FUNC = "RETN";
    end
    TA1REC.TA1TYPE = "DB2 ";
    TA1REC.TA1PGMNM = "XSSL6S4 ";
    TA1REC.TA1LOCAT[1] = "IO1470  ";
    TA1REC.TA1LOCAT[3] = "SELECT  ";
    TA1REC.TA1LOCAT[4] = "SET     ";
    TA1REC.TA1DBASE = "DSTLOC  ";
    TA1REC.TA1TBLVU = "VSYLOC01";
    TA1REC.TA1TBLKE = SL6REC.SL6KEY;
    move SQLCA to ERRSQLCA withV60Compat;
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback();
    call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
    return;
  end

   /* ************************************************************/
   /* *** scan/retrieve/fetch first row                       ****/
   /* *** in order to detect not found (+100)                 ****/
   /* *** note: CSP closes cursor at end of set (+100)        ****/
   /* *** note: any loop processing must use this first row   ****/
   /* ***       and fetch the next row at the end of the loop ****/
   /* *** note: fetch handles return code correctly           ****/
   /* ************************************************************/

  XSSL6F4(); /* <=== fetch first row*/

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSL6S4

// close : prod loc asgmnt : 7
Function XSSL7C7()


   /* ************************************************************/
   /* *** close select set of:  product location assignment   ****/
   /* *** using the std module:  IO1550                       ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   -501 = cursor already closed = return 0           ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** close select set (if prior to EOF)                  ****/
   /* ************************************************************/

  SLVREC.SLVFNC = "C7";

  call "IO1550" (SLVREC, SQLCA, SL7REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -501)
    SQLCA.VAGen_SQLCODE = 0;
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSSL7C7 ";
  TA1REC.TA1LOCAT[1] = "IO1550  ";
  TA1REC.TA1LOCAT[3] = "CLOSE   ";
  TA1REC.TA1LOCAT[4] = "SETINQ  ";
  TA1REC.TA1DBASE = "DSTLOC  ";
  TA1REC.TA1TBLVU = "VSYASG01";
  TA1REC.TA1TBLKE = SL7REC.SL7KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSL7C7

// close : prod loc asgmnt : 8
Function XSSL7C8()


   /* ************************************************************/
   /* *** close select set of:  product location assignment   ****/
   /* *** using the std module:  IO1550                       ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   -501 = cursor already closed = return 0           ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** close select set (if prior to EOF)                  ****/
   /* ************************************************************/

  SLVREC.SLVFNC = "C8";

  call "IO1550" (SLVREC, SQLCA, SL7REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -501)
    SQLCA.VAGen_SQLCODE = 0;
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSSL7C8 ";
  TA1REC.TA1LOCAT[1] = "IO1550  ";
  TA1REC.TA1LOCAT[3] = "CLOSE   ";
  TA1REC.TA1LOCAT[4] = "SETINQ  ";
  TA1REC.TA1DBASE = "DSTLOC  ";
  TA1REC.TA1TBLVU = "VSYASG01";
  TA1REC.TA1TBLKE = SL7REC.SL7KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSL7C8

// fetch : prod loc asgmnt : 7
Function XSSL7F7()


   /* ************************************************************/
   /* *** fetch next row from:  product location assignment   ****/
   /* *** using the std module:  IO1550                       ****/
   /* *** note: use slvrec to pass function & date ranges     ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   +100 = EOF (first +100 = not fnd, was detected as ****/
   /* ***          part of the select set w/first fetch)      ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** scan/retrieve/fetch next row                        ****/
   /* *** note: CSP closes cursor at end of set (+100)        ****/
   /* ***       but w/these io mods the sgrp will close       ****/
   /* ************************************************************/

  SLVREC.SLVFNC = "N7";

  call "IO1550" (SLVREC, SQLCA, SL7REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
    XSSL7C7(); /* <=== std close cursor*/
    if (SQLCA.VAGen_SQLCODE == 0)
      SQLCA.VAGen_SQLCODE = +100;
    end
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSSL7F7 ";
  TA1REC.TA1LOCAT[1] = "IO1550  ";
  TA1REC.TA1LOCAT[3] = "FETCH   ";
  TA1REC.TA1LOCAT[4] = "NEXT    ";
  TA1REC.TA1DBASE = "DSTLOC  ";
  TA1REC.TA1TBLVU = "VSYASG01";
  TA1REC.TA1TBLKE = SL7REC.SL7KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSL7F7

// fetch : prod loc asgmnt : 8
Function XSSL7F8()


   /* ************************************************************/
   /* *** fetch next row from:  product location assignment   ****/
   /* *** using the std module:  IO1550                       ****/
   /* *** note: use slvrec to pass function & date ranges     ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   +100 = EOF (first +100 = not fnd, was detected as ****/
   /* ***          part of the select set w/first fetch)      ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** scan/retrieve/fetch next row                        ****/
   /* *** note: CSP closes cursor at end of set (+100)        ****/
   /* ***       but w/these io mods the sgrp will close       ****/
   /* ************************************************************/

  SLVREC.SLVFNC = "N8";

  call "IO1550" (SLVREC, SQLCA, SL7REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
    XSSL7C8(); /* <=== std close cursor*/
    if (SQLCA.VAGen_SQLCODE == 0)
      SQLCA.VAGen_SQLCODE = +100;
    end
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSSL7F8 ";
  TA1REC.TA1LOCAT[1] = "IO1550  ";
  TA1REC.TA1LOCAT[3] = "FETCH   ";
  TA1REC.TA1LOCAT[4] = "NEXT    ";
  TA1REC.TA1DBASE = "DSTLOC  ";
  TA1REC.TA1TBLVU = "VSYASG01";
  TA1REC.TA1TBLKE = SL7REC.SL7KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSL7F8

// setinq : prod loc asgmnt : 7
Function XSSL7S7()


   /* ************************************************************/
   /* *** select set of rows from:  product assignment        ****/
   /* *** using the std module:  IO1550                       ****/
   /* *** note: use slvrec to pass function & date ranges     ****/
   /* *** note: the 1st fetch will be in the record layout    ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   +100 = none fnd on 1st fetch                      ****/
   /* ***          (+100 = EOF detected in fetch next only)   ****/
   /* ***   -911 = deadlock - resource unavailable            ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** select set with unique field values for:            ****/
   /* ***   xwhcd                                             ****/
   /* ***   xarcd                                             ****/
   /* ***   sl4zone                                           ****/
   /* ***   sl5loctn                                          ****/
   /* ***   xgpcd                                             ****/
   /* ***   sy1stnbr                                          ****/
   /* ***   sy2clrid                                          ****/
   /* ***   xdmcd                                             ****/
   /* ***   xqacd                                             ****/
   /* ***   xsdcd                                             ****/
   /* ***   xsacd                                             ****/
   /* ***   xpgcd                                             ****/
   /* ***   xumcd                                             ****/
   /* ***   xowcd                                             ****/
   /* *** the following may be used with a wild card (*):     ****/
   /* ***   sy5szid                                           ****/
   /* ***   sl7effdt                                          ****/
   /* ***   xxxstat                                           ****/
   /* *** the order by for this select set is:                ****/
   /* ***   xwhcd                                             ****/
   /* ***   xarcd                                             ****/
   /* ***   sl4zone                                           ****/
   /* ***   sl5loctn                                          ****/
   /* ***   xgpcd                                             ****/
   /* ***   sy1stnbr                                          ****/
   /* ***   sy2clrid                                          ****/
   /* ***   xdmcd                                             ****/
   /* ***   xqacd                                             ****/
   /* ***   xsdcd                                             ****/
   /* ***   xsacd                                             ****/
   /* ***   xpgcd                                             ****/
   /* ***   xumcd                                             ****/
   /* ***   xowcd                                             ****/
   /* ***   sy5szid                                           ****/
   /* ***   sl7effdt (descending)                             ****/
   /* ***   xxxstat                                           ****/
   /* ************************************************************/

  SLVREC.SLVFNC = "S7";

  call "IO1550" (SLVREC, SQLCA, SL7REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE < 0)
    if (SQLCA.VAGen_SQLCODE == -911)
      TA1REC.TA1FUNC = "POST";
    else
      TA1REC.TA1FUNC = "RETN";
    end
    TA1REC.TA1TYPE = "DB2 ";
    TA1REC.TA1PGMNM = "XSSL7S7 ";
    TA1REC.TA1LOCAT[1] = "IO1550  ";
    TA1REC.TA1LOCAT[3] = "SELECT  ";
    TA1REC.TA1LOCAT[4] = "SET     ";
    TA1REC.TA1DBASE = "DSTLOC  ";
    TA1REC.TA1TBLVU = "VSYASG01";
    TA1REC.TA1TBLKE = SL7REC.SL7KEY;
    move SQLCA to ERRSQLCA withV60Compat;
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback();
    call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
    return;
  end

   /* ************************************************************/
   /* *** scan/retrieve/fetch first row                       ****/
   /* *** in order to detect not found (+100)                 ****/
   /* *** note: CSP closes cursor at end of set (+100)        ****/
   /* *** note: any loop processing must use this first row   ****/
   /* ***       and fetch the next row at the end of the loop ****/
   /* *** note: fetch handles return code correctly           ****/
   /* ************************************************************/

  XSSL7F7(); /* <=== fetch first row*/

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSL7S7

// setinq : prod loc asgmnt : 8
Function XSSL7S8()


   /* ************************************************************/
   /* *** select set of rows from:  product assignment        ****/
   /* *** using the std module:  IO1550                       ****/
   /* *** note: use slvrec to pass function & date ranges     ****/
   /* *** note: the 1st fetch will be in the record layout    ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   +100 = none fnd on 1st fetch                      ****/
   /* ***          (+100 = EOF detected in fetch next only)   ****/
   /* ***   -911 = deadlock - resource unavailable            ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** as of 9/30/87 = needs revision                      ****/
   /* *** select set with unique field values for:            ****/
   /* ***   xwhcd                                             ****/
   /* ***   xarcd                                             ****/
   /* ***   sl4zone                                           ****/
   /* ***   sl5loctn                                          ****/
   /* ***   xgpcd                                             ****/
   /* ***   sy1stnbr                                          ****/
   /* ***   sy2clrid                                          ****/
   /* ***   xdmcd                                             ****/
   /* ***   xqacd                                             ****/
   /* ***   xsdcd                                             ****/
   /* ***   xsacd                                             ****/
   /* ***   xpgcd                                             ****/
   /* ***   xumcd                                             ****/
   /* ***   xowcd                                             ****/
   /* *** the following may be used with a wild card (*):     ****/
   /* ***   sy5szid                                           ****/
   /* ***   sl7effdt                                          ****/
   /* ***   xxxstat                                           ****/
   /* *** the order by for this select set is:                ****/
   /* ***   xwhcd                                             ****/
   /* ***   xarcd                                             ****/
   /* ***   sl4zone                                           ****/
   /* ***   sl5loctn                                          ****/
   /* ***   xgpcd                                             ****/
   /* ***   sy1stnbr                                          ****/
   /* ***   sy2clrid                                          ****/
   /* ***   xdmcd                                             ****/
   /* ***   xqacd                                             ****/
   /* ***   xsdcd                                             ****/
   /* ***   xsacd                                             ****/
   /* ***   xpgcd                                             ****/
   /* ***   xumcd                                             ****/
   /* ***   xowcd                                             ****/
   /* ***   sy5szid                                           ****/
   /* ***   sl7effdt (descending)                             ****/
   /* ***   xxxstat                                           ****/
   /* ************************************************************/

  SLVREC.SLVFNC = "S8";

  call "IO1550" (SLVREC, SQLCA, SL7REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE < 0)
    if (SQLCA.VAGen_SQLCODE == -911)
      TA1REC.TA1FUNC = "POST";
    else
      TA1REC.TA1FUNC = "RETN";
    end
    TA1REC.TA1TYPE = "DB2 ";
    TA1REC.TA1PGMNM = "XSSL7S8 ";
    TA1REC.TA1LOCAT[1] = "IO1550  ";
    TA1REC.TA1LOCAT[3] = "SELECT  ";
    TA1REC.TA1LOCAT[4] = "SET     ";
    TA1REC.TA1DBASE = "DSTLOC  ";
    TA1REC.TA1TBLVU = "VSYASG01";
    TA1REC.TA1TBLKE = SL7REC.SL7KEY;
    move SQLCA to ERRSQLCA withV60Compat;
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback();
    call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
    return;
  end

   /* ************************************************************/
   /* *** scan/retrieve/fetch first row                       ****/
   /* *** in order to detect not found (+100)                 ****/
   /* *** note: CSP closes cursor at end of set (+100)        ****/
   /* *** note: any loop processing must use this first row   ****/
   /* ***       and fetch the next row at the end of the loop ****/
   /* *** note: fetch handles return code correctly           ****/
   /* ************************************************************/

  XSSL7F8(); /* <=== fetch first row*/

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSL7S8

// close : w.o. 'l' hdr : 1
Function XSSL8C1()


   /* ************************************************************/
   /* *** close select set of:  w.o. 'l' hdr                  ****/
   /* *** using the std module:  IO1510                       ****/
   /* *** note: use slvrec to pass function & date ranges     ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   -501 = cursor already closed = return 0           ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** close select set (if prior to EOF)                  ****/
   /* ************************************************************/

  SLVREC.SLVFNC = "C1";

  call "IO1510" (SLVREC, SQLCA, SL8REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -501)
    SQLCA.VAGen_SQLCODE = 0;
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSSL8C1 ";
  TA1REC.TA1LOCAT[1] = "IO1510  ";
  TA1REC.TA1LOCAT[3] = "CLOSE   ";
  TA1REC.TA1LOCAT[4] = "SETINQ  ";
  TA1REC.TA1DBASE = "DSTLOC  ";
  TA1REC.TA1TBLVU = "VWOLHD01";
  TA1REC.TA1TBLKE = SL8REC.SL8KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSL8C1

// close : w.o. 'l' hdr : 2
Function XSSL8C2()


   /* ************************************************************/
   /* *** close select set of:  w.o. 'l' hdr                  ****/
   /* *** using the std module:  IO1510                       ****/
   /* *** note: use slvrec to pass function & date ranges     ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   -501 = cursor already closed = return 0           ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** close select set (if prior to EOF)                  ****/
   /* ************************************************************/

  SLVREC.SLVFNC = "C2";

  call "IO1510" (SLVREC, SQLCA, SL8REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -501)
    SQLCA.VAGen_SQLCODE = 0;
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSSL8C2 ";
  TA1REC.TA1LOCAT[1] = "IO1510  ";
  TA1REC.TA1LOCAT[3] = "CLOSE   ";
  TA1REC.TA1LOCAT[4] = "SETINQ  ";
  TA1REC.TA1DBASE = "DSTLOC  ";
  TA1REC.TA1TBLVU = "VWOLHD01";
  TA1REC.TA1TBLKE = SL8REC.SL8KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSL8C2

// close : w.o. 'l' hdr : 5
Function XSSL8C5()


   /* ************************************************************/
   /* *** close select set of:  w.o. 'l' hdr                  ****/
   /* *** using the std module:  IO1510                       ****/
   /* *** note: use slvrec to pass function & date ranges     ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   -501 = cursor already closed = return 0           ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** close select set (if prior to EOF)                  ****/
   /* ************************************************************/

  SLVREC.SLVFNC = "C5";

  call "IO1510" (SLVREC, SQLCA, SL8REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -501)
    SQLCA.VAGen_SQLCODE = 0;
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSSL8C5 ";
  TA1REC.TA1LOCAT[1] = "IO1510  ";
  TA1REC.TA1LOCAT[3] = "CLOSE   ";
  TA1REC.TA1LOCAT[4] = "SETINQ  ";
  TA1REC.TA1DBASE = "DSTLOC  ";
  TA1REC.TA1TBLVU = "VWOLHD01";
  TA1REC.TA1TBLKE = SL8REC.SL8KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSL8C5

// fetch : w.o. 'l' hdr : 1
Function XSSL8F1()


   /* ************************************************************/
   /* *** fetch next row from:  w.o. 'l' hdr                  ****/
   /* *** using the std module:  IO1510                       ****/
   /* *** note: use slvrec to pass function & date ranges     ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   +100 = EOF (first +100 = not fnd, was detected as ****/
   /* ***          part of the select set w/first fetch)      ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** scan/retrieve/fetch next row                        ****/
   /* *** note: CSP closes cursor at end of set (+100)        ****/
   /* ***       but w/these io mods the sgrp will close       ****/
   /* ************************************************************/

  SLVREC.SLVFNC = "N1";

  call "IO1510" (SLVREC, SQLCA, SL8REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
    move SL8REC to SL8REC withV60Compat;
    move SLVREC to SLVREC withV60Compat;

    XSSL8C1(); /* <=== std close cursor*/
    if (SQLCA.VAGen_SQLCODE == 0)
      SQLCA.VAGen_SQLCODE = +100;
    end
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSSL8F1 ";
  TA1REC.TA1LOCAT[1] = "IO1510  ";
  TA1REC.TA1LOCAT[3] = "FETCH   ";
  TA1REC.TA1LOCAT[4] = "NEXT    ";
  TA1REC.TA1DBASE = "DSTLOC  ";
  TA1REC.TA1TBLVU = "VWOLHD01";
  TA1REC.TA1TBLKE = SL8REC.SL8KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSL8F1

// fetch : w.o. 'l' hdr : 2
Function XSSL8F2()


   /* ************************************************************/
   /* *** fetch next row from:  w.o. 'l' hdr                  ****/
   /* *** using the std module:  IO1510                       ****/
   /* *** note: use slvrec to pass function & date ranges     ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   +100 = EOF (first +100 = not fnd, was detected as ****/
   /* ***          part of the select set w/first fetch)      ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** scan/retrieve/fetch next row                        ****/
   /* *** note: CSP closes cursor at end of set (+100)        ****/
   /* ***       but w/these io mods the sgrp will close       ****/
   /* ************************************************************/

  SLVREC.SLVFNC = "N2";

  call "IO1510" (SLVREC, SQLCA, SL8REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
    XSSL8C2(); /* <=== std close cursor*/
    if (SQLCA.VAGen_SQLCODE == 0)
      SQLCA.VAGen_SQLCODE = +100;
    end
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSSL8F2 ";
  TA1REC.TA1LOCAT[1] = "IO1510  ";
  TA1REC.TA1LOCAT[3] = "FETCH   ";
  TA1REC.TA1LOCAT[4] = "NEXT    ";
  TA1REC.TA1DBASE = "DSTLOC  ";
  TA1REC.TA1TBLVU = "VWOLHD01";
  TA1REC.TA1TBLKE = SL8REC.SL8KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSL8F2

// fetch : w.o. 'l' hdr : 5
Function XSSL8F5()


   /* ************************************************************/
   /* *** fetch next row from:  w.o. 'l' hdr                  ****/
   /* *** using the std module:  IO1510                       ****/
   /* *** note: use slvrec to pass function & date ranges     ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   +100 = EOF (first +100 = not fnd, was detected as ****/
   /* ***          part of the select set w/first fetch)      ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** scan/retrieve/fetch next row                        ****/
   /* *** note: CSP closes cursor at end of set (+100)        ****/
   /* ***       but w/these io mods the sgrp will close       ****/
   /* ************************************************************/

  SLVREC.SLVFNC = "N5";

  call "IO1510" (SLVREC, SQLCA, SL8REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
    XSSL8C5(); /* <=== std close cursor*/
    if (SQLCA.VAGen_SQLCODE == 0)
      SQLCA.VAGen_SQLCODE = +100;
    end
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSSL8F5 ";
  TA1REC.TA1LOCAT[1] = "IO1510  ";
  TA1REC.TA1LOCAT[3] = "FETCH   ";
  TA1REC.TA1LOCAT[4] = "NEXT    ";
  TA1REC.TA1DBASE = "DSTLOC  ";
  TA1REC.TA1TBLVU = "VWOLHD01";
  TA1REC.TA1TBLKE = SL8REC.SL8KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSL8F5

// inquiry : w.o. 'l' hdr : 0
Function XSSL8I0()


   /* ************************************************************/
   /* *** select unique row from:  w.o. 'l' hdr               ****/
   /* *** using the std module:  IO1510                       ****/
   /* *** note: use slvrec to pass function & date ranges     ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   +100 = not found                                  ****/
   /* ***   -811 = duplicates found                           ****/
   /* ***          note: do NOT clear screen                  ****/
   /* ***   -911 = deadlock - resource unavailable            ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** select unique row                                   ****/
   /* ************************************************************/

  SLVREC.SLVFNC = "S ";

  call "IO1510" (SLVREC, SQLCA, SL8REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -911)
    TA1REC.TA1FUNC = "POST";
  else
    TA1REC.TA1FUNC = "RETN";
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1PGMNM = "XSSL8I0 ";
  TA1REC.TA1LOCAT[1] = "IO1510  ";
  TA1REC.TA1LOCAT[3] = "SELECT  ";
  TA1REC.TA1LOCAT[4] = "UNIQUE  ";
  TA1REC.TA1DBASE = "DSTLOC  ";
  TA1REC.TA1TBLVU = "VWOLHD01";
  TA1REC.TA1TBLKE = SL8REC.SL8KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSL8I0

// setinq : w.o. 'l' hdr : 1
Function XSSL8S1()


   /* ************************************************************/
   /* *** select set of rows from:  w.o. 'l' hdr              ****/
   /* *** using the std module:  IO1510                       ****/
   /* *** note: use slvrec to pass function & date ranges     ****/
   /* *** note: the 1st fetch will be in the record layout    ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   +100 = none fnd on 1st fetch                      ****/
   /* ***          (+100 = EOF detected in fetch next only)   ****/
   /* ***   -911 = deadlock - resource unavailable            ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** select set with unique field values for:            ****/
   /* ***   xwhcd                                             ****/
   /* ***   xarcd                                             ****/
   /* ***   sl4zone                                           ****/
   /* *** the following may be used with a wild card (*):     ****/
   /* ***   sl5loctn                                          ****/
   /* ***   ywtcd                                             ****/
   /* ***   xxxstat                                           ****/
   /* *** the following must have a range passed:             ****/
   /* ***   zzzsdt                                            ****/
   /* *** the order by for this select set is:                ****/
   /* ***   xwhcd                                             ****/
   /* ***   sl8frar                                           ****/
   /* ***   sl8frzn                                           ****/
   /* ***   sl8frlc                                           ****/
   /* ***   zzzsdt                                            ****/
   /* ************************************************************/

  SLVREC.SLVFNC = "S1";

  call "IO1510" (SLVREC, SQLCA, SL8REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE < 0)
    if (SQLCA.VAGen_SQLCODE == -911)
      TA1REC.TA1FUNC = "POST";
    else
      TA1REC.TA1FUNC = "RETN";
    end
    TA1REC.TA1TYPE = "DB2 ";
    TA1REC.TA1PGMNM = "XSSL8S1 ";
    TA1REC.TA1LOCAT[1] = "IO1510  ";
    TA1REC.TA1LOCAT[3] = "SELECT  ";
    TA1REC.TA1LOCAT[4] = "SET     ";
    TA1REC.TA1DBASE = "DSTLOC  ";
    TA1REC.TA1TBLVU = "VWOLHD01";
    TA1REC.TA1TBLKE = SL8REC.SL8KEY;
    move SQLCA to ERRSQLCA withV60Compat;
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback();
    call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
    return;
  end

   /* ************************************************************/
   /* *** scan/retrieve/fetch first row                       ****/
   /* *** in order to detect not found (+100)                 ****/
   /* *** note: CSP closes cursor at end of set (+100)        ****/
   /* *** note: any loop processing must use this first row   ****/
   /* ***       and fetch the next row at the end of the loop ****/
   /* *** note: fetch handles return code correctly           ****/
   /* ************************************************************/

  XSSL8F1(); /* <=== fetch first row*/

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSL8S1

// setinq : w.o. 'l' hdr : 2
Function XSSL8S2()


   /* ************************************************************/
   /* *** select set of rows from:  w.o. 'l' hdr              ****/
   /* *** using the std module:  IO1510                       ****/
   /* *** note: use slvrec to pass function & date ranges     ****/
   /* *** note: the 1st fetch will be in the record layout    ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   +100 = none fnd on 1st fetch                      ****/
   /* ***          (+100 = EOF detected in fetch next only)   ****/
   /* ***   -911 = deadlock - resource unavailable            ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** select set with unique field values for:            ****/
   /* ***   xwhcd                                             ****/
   /* ***   xarcd                                             ****/
   /* ***   sl4zone                                           ****/
   /* *** the following may be used with a wild card (*):     ****/
   /* ***   sl5loctn                                          ****/
   /* ***   ywtcd                                             ****/
   /* ***   xxxstat                                           ****/
   /* *** the following must have a range passed:             ****/
   /* ***   zzzsdt                                            ****/
   /* *** the order by for this select set is:                ****/
   /* ***   xwhcd                                             ****/
   /* ***   sl8toar                                           ****/
   /* ***   sl8tozn                                           ****/
   /* ***   sl8tolc                                           ****/
   /* ***   zzzsdt                                            ****/
   /* ************************************************************/

  SLVREC.SLVFNC = "S2";

  call "IO1510" (SLVREC, SQLCA, SL8REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE < 0)
    if (SQLCA.VAGen_SQLCODE == -911)
      TA1REC.TA1FUNC = "POST";
    else
      TA1REC.TA1FUNC = "RETN";
    end
    TA1REC.TA1TYPE = "DB2 ";
    TA1REC.TA1PGMNM = "XSSL8S2 ";
    TA1REC.TA1LOCAT[1] = "IO1510  ";
    TA1REC.TA1LOCAT[3] = "SELECT  ";
    TA1REC.TA1LOCAT[4] = "SET     ";
    TA1REC.TA1DBASE = "DSTLOC  ";
    TA1REC.TA1TBLVU = "VWOLHD01";
    TA1REC.TA1TBLKE = SL8REC.SL8KEY;
    move SQLCA to ERRSQLCA withV60Compat;
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback();
    call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
    return;
  end

   /* ************************************************************/
   /* *** scan/retrieve/fetch first row                       ****/
   /* *** in order to detect not found (+100)                 ****/
   /* *** note: CSP closes cursor at end of set (+100)        ****/
   /* *** note: any loop processing must use this first row   ****/
   /* ***       and fetch the next row at the end of the loop ****/
   /* *** note: fetch handles return code correctly           ****/
   /* ************************************************************/

  XSSL8F2(); /* <=== fetch first row*/

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSL8S2

// setinq : w.o. 'l' hdr : 5
Function XSSL8S5()


   /* ************************************************************/
   /* *** select set of rows from:  w.o. 'l' hdr              ****/
   /* *** using the std module:  IO1510                       ****/
   /* *** note: use slvrec to pass function & date ranges     ****/
   /* *** note: the 1st fetch will be in the record layout    ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   +100 = none fnd on 1st fetch                      ****/
   /* ***          (+100 = EOF detected in fetch next only)   ****/
   /* ***   -911 = deadlock - resource unavailable            ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** select set with unique field values for:            ****/
   /* ***   xwhcd                                             ****/
   /* ***   xarcd                                             ****/
   /* ***   sl4zone                                           ****/
   /* *** the following may be used with a wild card (*):     ****/
   /* ***   sl5loctn                                          ****/
   /* ***   ywtcd                                             ****/
   /* ***   xxxstat                                           ****/
   /* *** the following must have a range passed:             ****/
   /* ***   zzzsdt                                            ****/
   /* *** the order by for this select set is:                ****/
   /* ***   xwhcd                                             ****/
   /* ***   sl8frar                                           ****/
   /* ***   sl8frzn                                           ****/
   /* ***   sl8frlc                                           ****/
   /* ***   zzzsdt                                            ****/
   /* ************************************************************/

  SLVREC.SLVFNC = "S5";

  call "IO1510" (SLVREC, SQLCA, SL8REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE < 0)
    if (SQLCA.VAGen_SQLCODE == -911)
      TA1REC.TA1FUNC = "POST";
    else
      TA1REC.TA1FUNC = "RETN";
    end
    TA1REC.TA1TYPE = "DB2 ";
    TA1REC.TA1PGMNM = "XSSL8S5 ";
    TA1REC.TA1LOCAT[1] = "IO1510  ";
    TA1REC.TA1LOCAT[3] = "SELECT  ";
    TA1REC.TA1LOCAT[4] = "SET     ";
    TA1REC.TA1DBASE = "DSTLOC  ";
    TA1REC.TA1TBLVU = "VWOLHD01";
    TA1REC.TA1TBLKE = SL8REC.SL8KEY;
    move SQLCA to ERRSQLCA withV60Compat;
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback();
    call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
    return;
  end

   /* ************************************************************/
   /* *** scan/retrieve/fetch first row                       ****/
   /* *** in order to detect not found (+100)                 ****/
   /* *** note: CSP closes cursor at end of set (+100)        ****/
   /* *** note: any loop processing must use this first row   ****/
   /* ***       and fetch the next row at the end of the loop ****/
   /* *** note: fetch handles return code correctly           ****/
   /* ************************************************************/

  XSSL8F5(); /* <=== fetch first row*/

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSL8S5

// close : w.o. 'l' itm : 1
Function XSSL9C1()


   /* ************************************************************/
   /* *** close select set of:  w.o. 'l' itm                  ****/
   /* *** using the std module:  IO1520                       ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   -501 = cursor already closed = return 0           ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** close select set (if prior to EOF)                  ****/
   /* ************************************************************/

  call "IO1520" ("C1", SQLCA, SL9REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -501)
    SQLCA.VAGen_SQLCODE = 0;
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSSL9C1 ";
  TA1REC.TA1LOCAT[1] = "IO1520  ";
  TA1REC.TA1LOCAT[3] = "CLOSE   ";
  TA1REC.TA1LOCAT[4] = "SETINQ  ";
  TA1REC.TA1DBASE = "DSTLOC  ";
  TA1REC.TA1TBLVU = "VWOLIT01";
  TA1REC.TA1TBLKE = SL9REC.SL9KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSL9C1

// fetch : w.o. 'l' itm : 1
Function XSSL9F1()


   /* ************************************************************/
   /* *** fetch next row from:  w.o. 'l' itm                  ****/
   /* *** using the std module:  IO1520                       ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   +100 = EOF (first +100 = not fnd, was detected as ****/
   /* ***          part of the select set w/first fetch)      ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** scan/retrieve/fetch next row                        ****/
   /* *** note: CSP closes cursor at end of set (+100)        ****/
   /* ***       but w/these io mods the sgrp will close       ****/
   /* ************************************************************/

  call "IO1520" ("N1", SQLCA, SL9REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
    XSSL9C1(); /* <=== std close cursor*/
    if (SQLCA.VAGen_SQLCODE == 0)
      SQLCA.VAGen_SQLCODE = +100;
    end
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSSL9F1 ";
  TA1REC.TA1LOCAT[1] = "IO1520  ";
  TA1REC.TA1LOCAT[3] = "FETCH   ";
  TA1REC.TA1LOCAT[4] = "NEXT    ";
  TA1REC.TA1DBASE = "DSTLOC  ";
  TA1REC.TA1TBLVU = "VWOLIT01";
  TA1REC.TA1TBLKE = SL9REC.SL9KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSL9F1

// setinq : w.o. 'l' itm : 1
Function XSSL9S1()


   /* ************************************************************/
   /* *** select set of rows from:  w.o. 'l' itm              ****/
   /* *** using the std module:  IO1520                       ****/
   /* *** note: the 1st fetch will be in the record layout    ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   +100 = none fnd on 1st fetch                      ****/
   /* ***          (+100 = EOF detected in fetch next only)   ****/
   /* ***   -911 = deadlock - resource unavailable            ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** select set with unique field values for:            ****/
   /* ***   xwhcd                                             ****/
   /* ***   sl8wonbr                                          ****/
   /* *** the following may be used with a wild card (*):     ****/
   /* ***   none                                              ****/
   /* *** the order by for this select set is:                ****/
   /* ***   xwhcd                                             ****/
   /* ***   sl8wonbr                                          ****/
   /* ***   sy5szid                                           ****/
   /* ************************************************************/

  call "IO1520" ("S1", SQLCA, SL9REC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE < 0)
    if (SQLCA.VAGen_SQLCODE == -911)
      TA1REC.TA1FUNC = "POST";
    else
      TA1REC.TA1FUNC = "RETN";
    end
    TA1REC.TA1TYPE = "DB2 ";
    TA1REC.TA1PGMNM = "XSSL9S1 ";
    TA1REC.TA1LOCAT[1] = "IO1520  ";
    TA1REC.TA1LOCAT[3] = "SELECT  ";
    TA1REC.TA1LOCAT[4] = "SET     ";
    TA1REC.TA1DBASE = "DSTLOC  ";
    TA1REC.TA1TBLVU = "VWOLIT01";
    TA1REC.TA1TBLKE = SL9REC.SL9KEY;
    move SQLCA to ERRSQLCA withV60Compat;
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback();
    call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
    return;
  end

   /* ************************************************************/
   /* *** scan/retrieve/fetch first row                       ****/
   /* *** in order to detect not found (+100)                 ****/
   /* *** note: CSP closes cursor at end of set (+100)        ****/
   /* *** note: any loop processing must use this first row   ****/
   /* ***       and fetch the next row at the end of the loop ****/
   /* *** note: fetch handles return code correctly           ****/
   /* ************************************************************/

  XSSL9F1(); /* <=== fetch first row*/

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSL9S1

// close : w.o. 'm' hdr : 5
Function XSSLBC5()


   /* ************************************************************/
   /* *** close select set of:  w.o. 'm' hdr                  ****/
   /* *** using the std module:  IO1530                       ****/
   /* *** note: use slvrec to pass function & date ranges     ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   -501 = cursor already closed = return 0           ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** close select set (if prior to EOF)                  ****/
   /* ************************************************************/

  SLVREC.SLVFNC = "C5";

  call "IO1530" (SLVREC, SQLCA, SLBREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -501)
    SQLCA.VAGen_SQLCODE = 0;
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSSLBC5 ";
  TA1REC.TA1LOCAT[1] = "IO1530  ";
  TA1REC.TA1LOCAT[3] = "CLOSE   ";
  TA1REC.TA1LOCAT[4] = "SETINQ  ";
  TA1REC.TA1DBASE = "DSTLOC  ";
  TA1REC.TA1TBLVU = "VWOMHD01";
  TA1REC.TA1TBLKE = SLBREC.SLBKEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSLBC5

// fetch : w.o. 'm' hdr : 5
Function XSSLBF5()


   /* ************************************************************/
   /* *** fetch next row from:  w.o. 'm' hdr                  ****/
   /* *** using the std module:  IO1530                       ****/
   /* *** note: use slvrec to pass function & date ranges     ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   +100 = EOF (first +100 = not fnd, was detected as ****/
   /* ***          part of the select set w/first fetch)      ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** scan/retrieve/fetch next row                        ****/
   /* *** note: CSP closes cursor at end of set (+100)        ****/
   /* ***       but w/these io mods the sgrp will close       ****/
   /* ************************************************************/

  SLVREC.SLVFNC = "N5";

  call "IO1530" (SLVREC, SQLCA, SLBREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
    XSSLBC5(); /* <=== std close cursor*/
    if (SQLCA.VAGen_SQLCODE == 0)
      SQLCA.VAGen_SQLCODE = +100;
    end
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSSLBF5 ";
  TA1REC.TA1LOCAT[1] = "IO1530  ";
  TA1REC.TA1LOCAT[3] = "FETCH   ";
  TA1REC.TA1LOCAT[4] = "NEXT    ";
  TA1REC.TA1DBASE = "DSTLOC  ";
  TA1REC.TA1TBLVU = "VWOMHD01";
  TA1REC.TA1TBLKE = SLBREC.SLBKEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSLBF5

// inquiry : w.o. 'm' hdr : 0
Function XSSLBI0()


   /* ************************************************************/
   /* *** select unique row from:  w.o. 'm' hdr               ****/
   /* *** using the std module:  IO1530                       ****/
   /* *** note: use slvrec to pass function & date ranges     ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   +100 = not found                                  ****/
   /* ***   -811 = duplicates found                           ****/
   /* ***          note: do NOT clear screen                  ****/
   /* ***   -911 = deadlock - resource unavailable            ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** select unique row                                   ****/
   /* ************************************************************/

  SLVREC.SLVFNC = "S ";

  call "IO1530" (SLVREC, SQLCA, SLBREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -911)
    TA1REC.TA1FUNC = "POST";
  else
    TA1REC.TA1FUNC = "RETN";
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1PGMNM = "XSSLBI0 ";
  TA1REC.TA1LOCAT[1] = "IO1530  ";
  TA1REC.TA1LOCAT[3] = "SELECT  ";
  TA1REC.TA1LOCAT[4] = "UNIQUE  ";
  TA1REC.TA1DBASE = "DSTLOC  ";
  TA1REC.TA1TBLVU = "VWOMHD01";
  TA1REC.TA1TBLKE = SLBREC.SLBKEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSLBI0

// setinq : w.o. 'm' hdr : 5
Function XSSLBS5()


   /* ************************************************************/
   /* *** select set of rows from:  w.o. 'm' hdr              ****/
   /* *** using the std module:  IO1530                       ****/
   /* *** note: use slvrec to pass function & date ranges     ****/
   /* *** note: the 1st fetch will be in the record layout    ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   +100 = none fnd on 1st fetch                      ****/
   /* ***          (+100 = EOF detected in fetch next only)   ****/
   /* ***   -911 = deadlock - resource unavailable            ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** select set with unique field values for:            ****/
   /* ***   sl8wogrp                                          ****/
   /* ***   xwhcd                                             ****/
   /* *** the following may be used with a wild card (*):     ****/
   /* ***   none                                              ****/
   /* *** the following must have a range passed:             ****/
   /* ***   none                                              ****/
   /* *** the order by for this select set is:                ****/
   /* ***   sl8wogrp                                          ****/
   /* ***   xwhcd                                             ****/
   /* ***   sl8wonbr                                          ****/
   /* ************************************************************/

  SLVREC.SLVFNC = "S5";

  call "IO1530" (SLVREC, SQLCA, SLBREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE < 0)
    if (SQLCA.VAGen_SQLCODE == -911)
      TA1REC.TA1FUNC = "POST";
    else
      TA1REC.TA1FUNC = "RETN";
    end
    TA1REC.TA1TYPE = "DB2 ";
    TA1REC.TA1PGMNM = "XSSLBS5 ";
    TA1REC.TA1LOCAT[1] = "IO1530  ";
    TA1REC.TA1LOCAT[3] = "SELECT  ";
    TA1REC.TA1LOCAT[4] = "SET     ";
    TA1REC.TA1DBASE = "DSTLOC  ";
    TA1REC.TA1TBLVU = "VWOMHD01";
    TA1REC.TA1TBLKE = SLBREC.SLBKEY;
    move SQLCA to ERRSQLCA withV60Compat;
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback();
    call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
    return;
  end

   /* ************************************************************/
   /* *** scan/retrieve/fetch first row                       ****/
   /* *** in order to detect not found (+100)                 ****/
   /* *** note: CSP closes cursor at end of set (+100)        ****/
   /* *** note: any loop processing must use this first row   ****/
   /* ***       and fetch the next row at the end of the loop ****/
   /* *** note: fetch handles return code correctly           ****/
   /* ************************************************************/

  XSSLBF5(); /* <=== fetch first row*/

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSLBS5

// close : w.o. 'm' itm : 1
Function XSSLCC1()


   /* ************************************************************/
   /* *** close select set of:  w.o. 'm' itm                  ****/
   /* *** using the std module:  IO1540                       ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   -501 = cursor already closed = return 0           ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** close select set (if prior to EOF)                  ****/
   /* ************************************************************/

  call "IO1540" ("C1", SQLCA, SLCREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -501)
    SQLCA.VAGen_SQLCODE = 0;
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSSLCC1 ";
  TA1REC.TA1LOCAT[1] = "IO1540  ";
  TA1REC.TA1LOCAT[3] = "CLOSE   ";
  TA1REC.TA1LOCAT[4] = "SETINQ  ";
  TA1REC.TA1DBASE = "DSTLOC  ";
  TA1REC.TA1TBLVU = "VWOMIT01";
  TA1REC.TA1TBLKE = SLCREC.SLCKEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSLCC1

// fetch : w.o. 'm' itm : 1
Function XSSLCF1()


   /* ************************************************************/
   /* *** fetch next row from:  w.o. 'm' itm                  ****/
   /* *** using the std module:  IO1540                       ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   +100 = EOF (first +100 = not fnd, was detected as ****/
   /* ***          part of the select set w/first fetch)      ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** scan/retrieve/fetch next row                        ****/
   /* *** note: CSP closes cursor at end of set (+100)        ****/
   /* ***       but w/these io mods the sgrp will close       ****/
   /* ************************************************************/

  call "IO1540" ("N1", SQLCA, SLCREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
    XSSLCC1(); /* <=== std close cursor*/
    if (SQLCA.VAGen_SQLCODE == 0)
      SQLCA.VAGen_SQLCODE = +100;
    end
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSSLCF1 ";
  TA1REC.TA1LOCAT[1] = "IO1540  ";
  TA1REC.TA1LOCAT[3] = "FETCH   ";
  TA1REC.TA1LOCAT[4] = "NEXT    ";
  TA1REC.TA1DBASE = "DSTLOC  ";
  TA1REC.TA1TBLVU = "VWOMIT01";
  TA1REC.TA1TBLKE = SLCREC.SLCKEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSLCF1

// setinq : w.o. 'm' itm : 1
Function XSSLCS1()


   /* ************************************************************/
   /* *** select set of rows from:  w.o. 'm' itm              ****/
   /* *** using the std module:  IO1540                       ****/
   /* *** note: the 1st fetch will be in the record layout    ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   +100 = none fnd on 1st fetch                      ****/
   /* ***          (+100 = EOF detected in fetch next only)   ****/
   /* ***   -911 = deadlock - resource unavailable            ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** select set with unique field values for:            ****/
   /* ***   xwhcd                                             ****/
   /* ***   sl8wonbr                                          ****/
   /* *** the following may be used with a wild card (*):     ****/
   /* ***   none                                              ****/
   /* *** the order by for this select set is:                ****/
   /* ***   xwhcd                                             ****/
   /* ***   sl8wonbr                                          ****/
   /* ***   sy5szid                                           ****/
   /* ************************************************************/

  call "IO1540" ("S1", SQLCA, SLCREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE < 0)
    if (SQLCA.VAGen_SQLCODE == -911)
      TA1REC.TA1FUNC = "POST";
    else
      TA1REC.TA1FUNC = "RETN";
    end
    TA1REC.TA1TYPE = "DB2 ";
    TA1REC.TA1PGMNM = "XSSLCS1 ";
    TA1REC.TA1LOCAT[1] = "IO1540  ";
    TA1REC.TA1LOCAT[3] = "SELECT  ";
    TA1REC.TA1LOCAT[4] = "SET     ";
    TA1REC.TA1DBASE = "DSTLOC  ";
    TA1REC.TA1TBLVU = "VWOMIT01";
    TA1REC.TA1TBLKE = SLCREC.SLCKEY;
    move SQLCA to ERRSQLCA withV60Compat;
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback();
    call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
    return;
  end

   /* ************************************************************/
   /* *** scan/retrieve/fetch first row                       ****/
   /* *** in order to detect not found (+100)                 ****/
   /* *** note: CSP closes cursor at end of set (+100)        ****/
   /* *** note: any loop processing must use this first row   ****/
   /* ***       and fetch the next row at the end of the loop ****/
   /* *** note: fetch handles return code correctly           ****/
   /* ************************************************************/

  XSSLCF1(); /* <=== fetch first row*/

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSLCS1

// add : prod location : a
Function XSSLS-A-VSYLOC02()


   /* ************************************************************/
   /* *** add unique row to:  product location view 2         ****/
   /* *** using the std module:  vsyloc02                     ****/
   /* *** note: use slvrec to pass function & date ranges     ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   -803 = adding duplicate row                       ****/
   /* ***   -911 = deadlock - resource unavailable            ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** select unique row                                   ****/
   /* *** note: 0 return code means record already exists     ****/
   /* ***       = setup -803 return code                      ****/
   /* ************************************************************/

   /* <=== select unique row*/
  XSSLS-SA-VSYLOC02();
  if (SQLCA.VAGen_SQLCODE == 0)
    SQLCA.VAGen_SQLCODE = -803;
    return;
  end

  if (SQLCA.VAGen_SQLCODE < 0)
    return;
  end

   /* ************************************************************/
   /* *** insert row (previous +100 = doesn't exist)          ****/
   /* *** note: IO process initializes zzzchgct to 0          ****/
   /* ************************************************************/

  VSYLOC02.ZZZCHGDT = X2CREC.X2CCURDT;
  VSYLOC02.ZZZCHGTM = X3CREC.X3CCURST;

  call "VSYLOC02" ("A ", SQLCA, VSYLOC02) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -911)
    TA1REC.TA1FUNC = "POST";
  else
    TA1REC.TA1FUNC = "RETN";
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1PGMNM = "XSSLOCA ";
  TA1REC.TA1LOCAT[1] = "VSYLOC02";
  TA1REC.TA1LOCAT[3] = "ADD     ";
  TA1REC.TA1LOCAT[4] = "ROW     ";
  TA1REC.TA1DBASE = "DSTLOC  ";
  TA1REC.TA1TBLVU = "VSYLOC02";
  TA1REC.TA1TBLKE = VSYLOC02.VSYLOC02-KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSLS-A-VSYLOC02

// close : prod location : C1
Function XSSLS-C1-VSYLOC02()


   /* ************************************************************/
   /* *** close select set of:  product location table        ****/
   /* *** using the std module:  VSYLOC02                     ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   -501 = cursor already closed = return 0           ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** close select set (if prior to EOF)                  ****/
   /* ************************************************************/

  call "VSYLOC02" ("C1", SQLCA, VSYLOC02) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -501)
    SQLCA.VAGen_SQLCODE = 0;
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSSLOCC1";
  TA1REC.TA1LOCAT[1] = "VSYLOC02";
  TA1REC.TA1LOCAT[3] = "CLOSE   ";
  TA1REC.TA1LOCAT[4] = "SETINQ  ";
  TA1REC.TA1DBASE = "DSTLOC  ";
  TA1REC.TA1TBLVU = "VSYLOC02";
  TA1REC.TA1TBLKE = VSYLOC02.VSYLOC02-KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSLS-C1-VSYLOC02

// close : prod location : c3
Function XSSLS-C3-VSYLOC02()


   /* ************************************************************/
   /* *** close select set of:  product location table        ****/
   /* *** using the std module:  VSYLOC02                     ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   -501 = cursor already closed = return 0           ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** close select set (if prior to EOF)                  ****/
   /* ************************************************************/

  call "VSYLOC02" ("C3", SQLCA, VSYLOC02) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -501)
    SQLCA.VAGen_SQLCODE = 0;
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSSLOCC3";
  TA1REC.TA1LOCAT[1] = "VSYLOC02";
  TA1REC.TA1LOCAT[3] = "CLOSE   ";
  TA1REC.TA1LOCAT[4] = "SETINQ  ";
  TA1REC.TA1DBASE = "DSTLOC  ";
  TA1REC.TA1TBLVU = "VSYLOC02";
  TA1REC.TA1TBLKE = VSYLOC02.VSYLOC02-KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSLS-C3-VSYLOC02

// close : product location : c4
Function XSSLS-C4-VSYLOC02()


   /* ************************************************************/
   /* *** close select set of:  product location table        ****/
   /* *** using the std module:  vsyloc02                     ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   -501 = cursor already closed = return 0           ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** close select set (if prior to EOF)                  ****/
   /* ************************************************************/

  call "VSYLOC02" ("C4", SQLCA, VSYLOC02) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -501)
    SQLCA.VAGen_SQLCODE = 0;
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSSLOCC4";
  TA1REC.TA1LOCAT[1] = "VSYLOC02";
  TA1REC.TA1LOCAT[3] = "CLOSE   ";
  TA1REC.TA1LOCAT[4] = "SETINQ  ";
  TA1REC.TA1DBASE = "DSTLOC  ";
  TA1REC.TA1TBLVU = "VSYLOC02";
  TA1REC.TA1TBLKE = VSYLOC02.VSYLOC02-KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSLS-C4-VSYLOC02

// close : prod location : c5
Function XSSLS-C5-VSYLOC02()


   /* ************************************************************/
   /* *** close select set of:  product location table        ****/
   /* *** using the std module:  VSYLOC02                     ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   -501 = cursor already closed = return 0           ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** close select set (if prior to EOF)                  ****/
   /* ************************************************************/

  call "VSYLOC02" ("C5", SQLCA, VSYLOC02) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -501)
    SQLCA.VAGen_SQLCODE = 0;
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSSLOCC5";
  TA1REC.TA1LOCAT[1] = "VSYLOC02";
  TA1REC.TA1LOCAT[3] = "CLOSE   ";
  TA1REC.TA1LOCAT[4] = "SETINQ  ";
  TA1REC.TA1DBASE = "DSTLOC  ";
  TA1REC.TA1TBLVU = "VSYLOC02";
  TA1REC.TA1TBLKE = VSYLOC02.VSYLOC02-KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSLS-C5-VSYLOC02

// delete : prod location : da
Function XSSLS-DA-VSYLOC02()


   /* ************************************************************/
   /* *** delete unique row in:  product location table       ****/
   /* *** using the std module:  VSYLOC02                     ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   +100 = deleted since last read                    ****/
   /* ***   -911 = deadlock - resource unavailable            ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** delete row                                          ****/
   /* ************************************************************/

  call "VSYLOC02" ("DA", SQLCA, VSYLOC02) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100
   || SQLCA.VAGen_SQLCODE == -911)
    TA1REC.TA1FUNC = "POST";
  else
    TA1REC.TA1FUNC = "RETN";
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1PGMNM = "XSSLOCDA";
  TA1REC.TA1LOCAT[1] = "VSYLOC02";
  TA1REC.TA1LOCAT[3] = "DELETE  ";
  TA1REC.TA1LOCAT[4] = "ROW     ";
  TA1REC.TA1DBASE = "DSTLOC  ";
  TA1REC.TA1TBLVU = "VSYLOC02";
  TA1REC.TA1TBLKE = VSYLOC02.VSYLOC02-KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSLS-DA-VSYLOC02

// obtain current date (ccyymmss)
Function XSSLS-DATE2JULIAN()


   /* ************************************************************/
   /* *** use ta0040 to obtain the current date including CC  ****/
   /* ************************************************************/

  set TA2REC empty;

  TA2REC.TA2DTOPT = "GREGJUL ";
  TA2REC.TA2GRTYP = "G";
  TA2REC.TA2GRGGN = SW1REC.SW1CURDT;
  TA2REC.TA2DYAOD = 0;

  call "TA0040" (TA2REC) {isNoRefresh = yes, isExternal = yes};

  if (TA2REC.TA2RTNCD == 0)
    SW1REC.SW1JULNN = TA2REC.TA2JULNN;
    return;
  end

   /* ************************************************************/
   /* *** since ta0020 will not check 'gregjul ' return code  ****/
   /* *** and we must prevent further processing,             ****/
   /* *** call ta0020 to display error and return to main menu****/
   /* ************************************************************/

  set TA1REC empty;

  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1TYPE = "APPL";
  TA1REC.TA1PGMNM = "XSSLS-DJ";
  TA1REC.TA1LOC = "TA0040 - GET CURRENT DATE";
  SQLCA.SQLCAREC = TA2REC.TA2RTNCD;
  call "TA0020" (TA1REC, SQLCA) {isExternal = yes};

  XSPF4();

  exit program;

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSLS-DATE2JULIAN

// fetch : prod location : 1
Function XSSLS-N1-VSYLOC02()


   /* ************************************************************/
   /* *** fetch next row from:  STYLE LOCATION TABLE          ****/
   /* *** using the std module:  VSYLOC02                     ****/
   /* *** note: use slvrec to pass function & date ranges     ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   +100 = EOF (first +100 = not fnd, was detected as ****/
   /* ***          part of the select set w/first fetch)      ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** scan/retrieve/fetch next row                        ****/
   /* *** note: CSP closes cursor at end of set (+100)        ****/
   /* ***       but w/these io mods the sgrp will close       ****/
   /* ************************************************************/

  call "VSYLOC02" ("N1", SQLCA, VSYLOC02) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
    XSSLS-C1-VSYLOC02(); /* <=== std close cursor*/
    if (SQLCA.VAGen_SQLCODE == 0)
      SQLCA.VAGen_SQLCODE = +100;
    end
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSSY02N1";
  TA1REC.TA1LOCAT[1] = "VSYLOC02";
  TA1REC.TA1LOCAT[3] = "FETCH   ";
  TA1REC.TA1LOCAT[4] = "NEXT    ";
  TA1REC.TA1DBASE = "DSTLOC  ";
  TA1REC.TA1TBLVU = "VSYLOC02";
  TA1REC.TA1TBLKE = VSYLOC02.VSYLOC02-KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSLS-N1-VSYLOC02

// fetch : prod location : n3
Function XSSLS-N3-VSYLOC02()


   /* ************************************************************/
   /* *** fetch next row from:  product location              ****/
   /* *** using the std module:  VSYLOC02                     ****/
   /* *** note: use slvrec to pass function & date ranges     ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   +100 = EOF (first +100 = not fnd, was detected as ****/
   /* ***          part of the select set w/first fetch)      ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** scan/retrieve/fetch next row                        ****/
   /* *** note: CSP closes cursor at end of set (+100)        ****/
   /* ***       but w/these io mods the sgrp will close       ****/
   /* ************************************************************/

  call "VSYLOC02" ("N3", SQLCA, VSYLOC02) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
    XSSLS-C3-VSYLOC02(); /* <=== std close cursor*/
    if (SQLCA.VAGen_SQLCODE == 0)
      SQLCA.VAGen_SQLCODE = +100;
    end
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSSLOCN3";
  TA1REC.TA1LOCAT[1] = "VSYLOC02";
  TA1REC.TA1LOCAT[3] = "FETCH   ";
  TA1REC.TA1LOCAT[4] = "NEXT    ";
  TA1REC.TA1DBASE = "DSTLOC  ";
  TA1REC.TA1TBLVU = "VSYLOC02";
  TA1REC.TA1TBLKE = VSYLOC02.VSYLOC02-KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSLS-N3-VSYLOC02

// fetch : prod location : n4
Function XSSLS-N4-VSYLOC02()


   /* ************************************************************/
   /* *** fetch next row from:  product location              ****/
   /* *** using the std module:  VSYLOC02                     ****/
   /* *** note: use slvrec to pass function & date ranges     ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   +100 = EOF (first +100 = not fnd, was detected as ****/
   /* ***          part of the select set w/first fetch)      ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** scan/retrieve/fetch next row                        ****/
   /* *** note: CSP closes cursor at end of set (+100)        ****/
   /* ***       but w/these io mods the sgrp will close       ****/
   /* ************************************************************/

  call "VSYLOC02" ("N4", SQLCA, VSYLOC02) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
    XSSLS-C4-VSYLOC02(); /* <=== std close cursor*/
    if (SQLCA.VAGen_SQLCODE == 0)
      SQLCA.VAGen_SQLCODE = +100;
    end
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSSLOCN4";
  TA1REC.TA1LOCAT[1] = "VSYLOC02";
  TA1REC.TA1LOCAT[3] = "FETCH   ";
  TA1REC.TA1LOCAT[4] = "NEXT    ";
  TA1REC.TA1DBASE = "DSTLOC  ";
  TA1REC.TA1TBLVU = "VSYLOC02";
  TA1REC.TA1TBLKE = VSYLOC02.VSYLOC02-KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSLS-N4-VSYLOC02

// fetch : prod location : n5
Function XSSLS-N5-VSYLOC02()


   /* ************************************************************/
   /* *** fetch next row from:  product location              ****/
   /* *** using the std module:  VSYLOC02                     ****/
   /* *** note: use slvrec to pass function & date ranges     ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   +100 = EOF (first +100 = not fnd, was detected as ****/
   /* ***          part of the select set w/first fetch)      ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** scan/retrieve/fetch next row                        ****/
   /* *** note: CSP closes cursor at end of set (+100)        ****/
   /* ***       but w/these io mods the sgrp will close       ****/
   /* ************************************************************/

  call "VSYLOC02" ("N5", SQLCA, VSYLOC02) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
    XSSLS-C5-VSYLOC02(); /* <=== std close cursor*/
    if (SQLCA.VAGen_SQLCODE == 0)
      SQLCA.VAGen_SQLCODE = +100;
    end
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSSLOCN5";
  TA1REC.TA1LOCAT[1] = "VSYLOC02";
  TA1REC.TA1LOCAT[3] = "FETCH   ";
  TA1REC.TA1LOCAT[4] = "NEXT    ";
  TA1REC.TA1DBASE = "DSTLOC  ";
  TA1REC.TA1TBLVU = "VSYLOC02";
  TA1REC.TA1TBLKE = VSYLOC02.VSYLOC02-KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSLS-N5-VSYLOC02

// select : prod location : s
Function XSSLS-S-VSYLOC02()


   /* ************************************************************/
   /* *** select unique row from:  product location           ****/
   /* *** using the std module:  VSYLOC02                     ****/
   /* *** note: use slvrec to pass function & date ranges     ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   +100 = not found                                  ****/
   /* ***   -811 = duplicates found                           ****/
   /* ***          note: do NOT clear screen                  ****/
   /* ***   -911 = deadlock - resource unavailable            ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** select unique row                                   ****/
   /* ************************************************************/

  call "VSYLOC02" ("S ", SQLCA, VSYLOC02) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -811)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -911)
    TA1REC.TA1FUNC = "POST";
  else
    TA1REC.TA1FUNC = "RETN";
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1PGMNM = "XSSLOCS ";
  TA1REC.TA1LOCAT[1] = "VSYLOC02";
  TA1REC.TA1LOCAT[3] = "SELECT  ";
  TA1REC.TA1LOCAT[4] = "UNIQUE  ";
  TA1REC.TA1DBASE = "DSTLOC  ";
  TA1REC.TA1TBLVU = "VSYLOC02";
  TA1REC.TA1TBLKE = VSYLOC02.VSYLOC02-KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSLS-S-VSYLOC02

// inquiry : w.o. 'l' hdr : 0
Function XSSLS-S-VWOLHD02()


   /* ************************************************************/
   /* *** select unique row from:  w.o. 'l' hdr               ****/
   /* *** using the std module:  VWOLHD02                     ****/
   /* *** note: use slvrec to pass function & date ranges     ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   +100 = not found                                  ****/
   /* ***   -811 = duplicates found                           ****/
   /* ***          note: do NOT clear screen                  ****/
   /* ***   -911 = deadlock - resource unavailable            ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** select unique row                                   ****/
   /* ************************************************************/

  SLVREC.SLVFNC = "S ";

  call "VWOLHD02" (SLVREC, SQLCA, VWOLHD02) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -911)
    TA1REC.TA1FUNC = "POST";
  else
    TA1REC.TA1FUNC = "RETN";
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1PGMNM = "XSWHD02S";
  TA1REC.TA1LOCAT[1] = "VWOLHD02";
  TA1REC.TA1LOCAT[3] = "SELECT  ";
  TA1REC.TA1LOCAT[4] = "UNIQUE  ";
  TA1REC.TA1DBASE = "DSTLOC  ";
  TA1REC.TA1TBLVU = "VWOLHD02";
  TA1REC.TA1TBLKE = VWOLHD02.WOLHD02-KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSLS-S-VWOLHD02

// setinq : prod location : 1
Function XSSLS-S1-VSYLOC02()


   /* ************************************************************/
   /* *** select set of rows from:  product/location          ****/
   /* *** using the std module:  VSYLOC02                     ****/
   /* *** note: the 1st fetch will be in the record layout    ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   +100 = none fnd on 1st fetch                      ****/
   /* ***          (+100 = EOF detected in fetch next only)   ****/
   /* ***   -911 = deadlock - resource unavailable            ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** select set with unique field values for:            ****/
   /* ***   xwhcd                                             ****/
   /* ***   xarcd                                             ****/
   /* ***   sl2zone                                           ****/
   /* ***   sl4loctn                                          ****/
   /* *** the following may be used with a wild card (*):     ****/
   /* ***   xgpcd                                             ****/
   /* ***   sy1stnbr                                          ****/
   /* ***   sy2clrid                                          ****/
   /* ***   xdmcd                                             ****/
   /* ***   xqacd                                             ****/
   /* ***   xsdcd                                             ****/
   /* ***   xsacd                                             ****/
   /* ***   xpgcd                                             ****/
   /* ***   xumcd                                             ****/
   /* ***   xowcd                                             ****/
   /* ***   xslcd                                             ****/
   /* ***   sl2palet                                          ****/
   /* ***   sl2case                                           ****/
   /* *** the order by for this select set is:                ****/
   /* ***   xwhcd                                             ****/
   /* ***   xarcd                                             ****/
   /* ***   sl2zone                                           ****/
   /* ***   sl4loctn                                          ****/
   /* ***   xgpcd                                             ****/
   /* ***   sy1stnbr                                          ****/
   /* ***   sy2clrid                                          ****/
   /* ***   xdmcd                                             ****/
   /* ***   xqacd                                             ****/
   /* ***   xsdcd                                             ****/
   /* ***   xsacd                                             ****/
   /* ***   xpgcd                                             ****/
   /* ***   xumcd                                             ****/
   /* ***   xowcd                                             ****/
   /* ***   xslcd                                             ****/
   /* ***   sy5szid                                           ****/
   /* ************************************************************/

  call "VSYLOC02" ("S1", SQLCA, VSYLOC02) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE < 0)
    if (SQLCA.VAGen_SQLCODE == -911)
      TA1REC.TA1FUNC = "POST";
    else
      TA1REC.TA1FUNC = "RETN";
    end
    TA1REC.TA1TYPE = "DB2 ";
    TA1REC.TA1PGMNM = "XSSY02S1";
    TA1REC.TA1LOCAT[1] = "VSYLOC02";
    TA1REC.TA1LOCAT[3] = "SELECT  ";
    TA1REC.TA1LOCAT[4] = "SET     ";
    TA1REC.TA1DBASE = "DSTLOC  ";
    TA1REC.TA1TBLVU = "VSYLOC02";
    TA1REC.TA1TBLKE = VSYLOC02.VSYLOC02-KEY;
    move SQLCA to ERRSQLCA withV60Compat;
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback();
    call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
    return;
  end

   /* ************************************************************/
   /* *** scan/retrieve/fetch first row                       ****/
   /* *** in order to detect not found (+100)                 ****/
   /* *** note: CSP closes cursor at end of set (+100)        ****/
   /* *** note: any loop processing must use this first row   ****/
   /* ***       and fetch the next row at the end of the loop ****/
   /* *** note: fetch handles return code correctly           ****/
   /* ************************************************************/

  XSSLS-N1-VSYLOC02(); /* <=== fetch first row*/

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSLS-S1-VSYLOC02

// select : prod location : s3
Function XSSLS-S3-VSYLOC02()


   /* ************************************************************/
   /* *** select set of rows from:  product location          ****/
   /* *** using the std module:  VSYLOC02                     ****/
   /* *** note: use slvrec to pass function & date ranges     ****/
   /* *** note: the 1st fetch will be in the record layout    ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   +100 = none fnd on 1st fetch                      ****/
   /* ***          (+100 = EOF detected in fetch next only)   ****/
   /* ***   -911 = deadlock - resource unavailable            ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** select set with unique field values for:            ****/
   /* ***   xwhcd                                             ****/
   /* ***   xarcd                                             ****/
   /* ***   sl4zone                                           ****/
   /* ***   sl5loctn                                          ****/
   /* *** the following may be used with a wild card (*):     ****/
   /* ***   sl2palet                                          ****/
   /* ***   sl2case                                           ****/
   /* *** the order by for this select set is:                ****/
   /* ***   xwhcd                                             ****/
   /* ***   xarcd                                             ****/
   /* ***   sl4zone                                           ****/
   /* ***   sl5loctn                                          ****/
   /* ***   sl2palet                                          ****/
   /* ***   sl2case                                           ****/
   /* ***   xgpcd                                             ****/
   /* ***   sy1stnbr                                          ****/
   /* ***   sy2clrid                                          ****/
   /* ***   xdmcd                                             ****/
   /* ***   xqacd                                             ****/
   /* ***   xsdcd                                             ****/
   /* ***   xsacd                                             ****/
   /* ***   xpgcd                                             ****/
   /* ***   xumcd                                             ****/
   /* ***   xowcd                                             ****/
   /* ***   xslcd                                             ****/
   /* ***   sy5szid                                           ****/
   /* ************************************************************/

  call "VSYLOC02" ("S3", SQLCA, VSYLOC02) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE < 0)
    if (SQLCA.VAGen_SQLCODE == -911)
      TA1REC.TA1FUNC = "POST";
    else
      TA1REC.TA1FUNC = "RETN";
    end
    TA1REC.TA1TYPE = "DB2 ";
    TA1REC.TA1PGMNM = "XSSLOCS3";
    TA1REC.TA1LOCAT[1] = "VSYLOC02";
    TA1REC.TA1LOCAT[3] = "SELECT  ";
    TA1REC.TA1LOCAT[4] = "SET     ";
    TA1REC.TA1DBASE = "DSTLOC  ";
    TA1REC.TA1TBLVU = "VSYLOC02";
    TA1REC.TA1TBLKE = VSYLOC02.VSYLOC02-KEY;
    move SQLCA to ERRSQLCA withV60Compat;
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback();
    call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
    return;
  end

   /* ************************************************************/
   /* *** scan/retrieve/fetch first row                       ****/
   /* *** in order to detect not found (+100)                 ****/
   /* *** note: CSP closes cursor at end of set (+100)        ****/
   /* *** note: any loop processing must use this first row   ****/
   /* ***       and fetch the next row at the end of the loop ****/
   /* *** note: fetch handles return code correctly           ****/
   /* ************************************************************/

  XSSLS-N3-VSYLOC02(); /* <=== fetch first row*/

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSLS-S3-VSYLOC02

// select : prod location : s4
Function XSSLS-S4-VSYLOC02()


   /* ************************************************************/
   /* *** select set of rows from:  product location          ****/
   /* *** using the std module:  VSYLOC02                     ****/
   /* *** note: use slvrec to pass function & date ranges     ****/
   /* *** note: the 1st fetch will be in the record layout    ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   +100 = none fnd on 1st fetch                      ****/
   /* ***          (+100 = EOF detected in fetch next only)   ****/
   /* ***   -911 = deadlock - resource unavailable            ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** select set with unique field values for:            ****/
   /* ***   xwhcd                                             ****/
   /* ***   xarcd                                             ****/
   /* ***   sl4zone                                           ****/
   /* ***   sl5loctn                                          ****/
   /* *** the following may be used with a wild card (*):     ****/
   /* ***   sl2palet                                          ****/
   /* ***   sl2case                                           ****/
   /* *** the order by for this select set is:                ****/
   /* ***   xwhcd                                             ****/
   /* ***   xarcd                                             ****/
   /* ***   sl4zone                                           ****/
   /* ***   sl5loctn                                          ****/
   /* ***   xgpcd                                             ****/
   /* ***   sy1stnbr                                          ****/
   /* ***   sy2clrid                                          ****/
   /* ***   xdmcd                                             ****/
   /* ***   xqacd                                             ****/
   /* ***   xsdcd                                             ****/
   /* ***   xsacd                                             ****/
   /* ***   xpgcd                                             ****/
   /* ***   xumcd                                             ****/
   /* ***   xowcd                                             ****/
   /* ***   xslcd                                             ****/
   /* ***   sl2palet                                          ****/
   /* ***   sl2case                                           ****/
   /* ***   sy5szid                                           ****/
   /* ************************************************************/

  call "VSYLOC02" ("S4", SQLCA, VSYLOC02) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE < 0)
    if (SQLCA.VAGen_SQLCODE == -911)
      TA1REC.TA1FUNC = "POST";
    else
      TA1REC.TA1FUNC = "RETN";
    end
    TA1REC.TA1TYPE = "DB2 ";
    TA1REC.TA1PGMNM = "XSSL0CS4";
    TA1REC.TA1LOCAT[1] = "VSYLOC02";
    TA1REC.TA1LOCAT[3] = "SELECT  ";
    TA1REC.TA1LOCAT[4] = "SET     ";
    TA1REC.TA1DBASE = "DSTLOC  ";
    TA1REC.TA1TBLVU = "VSYLOC02";
    TA1REC.TA1TBLKE = VSYLOC02.VSYLOC02-KEY;
    move SQLCA to ERRSQLCA withV60Compat;
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback();
    call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
    return;
  end

   /* ************************************************************/
   /* *** scan/retrieve/fetch first row                       ****/
   /* *** in order to detect not found (+100)                 ****/
   /* *** note: CSP closes cursor at end of set (+100)        ****/
   /* *** note: any loop processing must use this first row   ****/
   /* ***       and fetch the next row at the end of the loop ****/
   /* *** note: fetch handles return code correctly           ****/
   /* ************************************************************/

  XSSLS-N4-VSYLOC02(); /* <=== fetch first row*/

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSLS-S4-VSYLOC02

// select : prod location : s5
Function XSSLS-S5-VSYLOC02()


   /* ************************************************************/
   /* *** select set of rows from:  product/location          ****/
   /* *** using the std module:  VSYLOC02                     ****/
   /* *** note: the 1st fetch will be in the record layout    ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   +100 = none fnd on 1st fetch                      ****/
   /* ***          (+100 = EOF detected in fetch next only)   ****/
   /* ***   -911 = deadlock - resource unavailable            ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** select set with unique field values for:            ****/
   /* ***   xwhcd                                             ****/
   /* ***   xarcd                                             ****/
   /* ***   sl2zone                                           ****/
   /* ***   sl4loctn                                          ****/
   /* *** the following may be used with a wild card (*):     ****/
   /* ***   xgpcd                                             ****/
   /* ***   sy1stnbr                                          ****/
   /* ***   sy2clrid                                          ****/
   /* ***   xdmcd                                             ****/
   /* ***   xqacd                                             ****/
   /* ***   xsdcd                                             ****/
   /* ***   xsacd                                             ****/
   /* ***   xpgcd                                             ****/
   /* ***   xumcd                                             ****/
   /* ***   xowcd                                             ****/
   /* ***   xslcd                                             ****/
   /* ***   sl2palet                                          ****/
   /* ***   sl2case                                           ****/
   /* *** the order by for this select set is:                ****/
   /* ***   xwhcd                                             ****/
   /* ***   xarcd                                             ****/
   /* ***   sl2zone                                           ****/
   /* ***   sl4loctn                                          ****/
   /* ***   xgpcd                                             ****/
   /* ***   sy1stnbr                                          ****/
   /* ***   sy2clrid                                          ****/
   /* ***   xdmcd                                             ****/
   /* ***   xqacd                                             ****/
   /* ***   xsdcd                                             ****/
   /* ***   xsacd                                             ****/
   /* ***   xpgcd                                             ****/
   /* ***   xumcd                                             ****/
   /* ***   xowcd                                             ****/
   /* ***   xslcd                                             ****/
   /* ***   sy5szid                                           ****/
   /* ************************************************************/

  call "VSYLOC02" ("S5", SQLCA, VSYLOC02) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE < 0)
    if (SQLCA.VAGen_SQLCODE == -911)
      TA1REC.TA1FUNC = "POST";
    else
      TA1REC.TA1FUNC = "RETN";
    end
    TA1REC.TA1TYPE = "DB2 ";
    TA1REC.TA1PGMNM = "XSSLOCS5";
    TA1REC.TA1LOCAT[1] = "VSYLOC02";
    TA1REC.TA1LOCAT[3] = "SELECT  ";
    TA1REC.TA1LOCAT[4] = "SET     ";
    TA1REC.TA1DBASE = "DSTLOC  ";
    TA1REC.TA1TBLVU = "VSYLOC02";
    TA1REC.TA1TBLKE = VSYLOC02.VSYLOC02-KEY;
    move SQLCA to ERRSQLCA withV60Compat;
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback();
    call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
    return;
  end

   /* ************************************************************/
   /* *** scan/retrieve/fetch first row                       ****/
   /* *** in order to detect not found (+100)                 ****/
   /* *** note: CSP closes cursor at end of set (+100)        ****/
   /* *** note: any loop processing must use this first row   ****/
   /* ***       and fetch the next row at the end of the loop ****/
   /* *** note: fetch handles return code correctly           ****/
   /* ************************************************************/

  XSSLS-N5-VSYLOC02(); /* <=== fetch first row*/

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSLS-S5-VSYLOC02

// select : prod location : sa
Function XSSLS-SA-VSYLOC02()


   /* ************************************************************/
   /* *** select unique row from:  product location           ****/
   /* *** using the std module:  VSYLOC02                     ****/
   /* *** note: use slvrec to pass function & date ranges     ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   +100 = not found                                  ****/
   /* ***   -811 = duplicates found                           ****/
   /* ***          note: do NOT clear screen                  ****/
   /* ***   -911 = deadlock - resource unavailable            ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** select unique row                                   ****/
   /* ************************************************************/

  call "VSYLOC02" ("SA", SQLCA, VSYLOC02) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -811)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -911)
    TA1REC.TA1FUNC = "POST";
  else
    TA1REC.TA1FUNC = "RETN";
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1PGMNM = "XSSLOCSA";
  TA1REC.TA1LOCAT[1] = "VSYLOC02";
  TA1REC.TA1LOCAT[3] = "SELECT  ";
  TA1REC.TA1LOCAT[4] = "UNIQUE  ";
  TA1REC.TA1DBASE = "DSTLOC  ";
  TA1REC.TA1TBLVU = "VSYLOC02";
  TA1REC.TA1TBLKE = VSYLOC02.VSYLOC02-KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSLS-SA-VSYLOC02

// update : prod location : u
Function XSSLS-U-VSYLOC02()


   /* ************************************************************/
   /* *** update unique row in:  product location             ****/
   /* *** using the std module:  VSYLOC02                     ****/
   /* *** note: use slvrec to pass function & date ranges     ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   +100 = concurrent update - re:                    ****/
   /* ***          deleted since last read (rec blanked out)  ****/
   /* ***          updated since last read (new data in rec)  ****/
   /* ***   -911 = deadlock - resource unavailable            ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** replace row                                         ****/
   /* *** note: IO process increments record zzzchgct by +1   ****/
   /* ***       but ID's row to update by the old zzzchgct    ****/
   /* ************************************************************/

  VSYLOC02.ZZZCHGDT = X2CREC.X2CCURDT;
  VSYLOC02.ZZZCHGTM = X3CREC.X3CCURST;

  call "VSYLOC02" ("U ", SQLCA, VSYLOC02) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
     /* ************************************************************/
     /* *** select the original row without a change count      ****/
     /* *** note: select unique does NOT use zzzchgct           ****/
     /* *** note: this puts current version of data in record   ****/
     /* ***       or blank out record layout = deleted          ****/
     /* ************************************************************/
    XSSLS-S-VSYLOC02(); /* <=== select unique row*/
    if (SQLCA.VAGen_SQLCODE == 0)
      SQLCA.VAGen_SQLCODE = +100;
      return;
    end
    if (SQLCA.VAGen_SQLCODE == +100)
      VSYLOC02.VSYLOC02-DATA = " ";
      return;
    end
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -911)
    TA1REC.TA1FUNC = "POST";
  else
    TA1REC.TA1FUNC = "RETN";
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1PGMNM = "XSSLOCU ";
  TA1REC.TA1LOCAT[1] = "VSYLOC02";
  TA1REC.TA1LOCAT[3] = "UPDATE  ";
  TA1REC.TA1LOCAT[4] = "ROW     ";
  TA1REC.TA1DBASE = "DSTLOC  ";
  TA1REC.TA1TBLVU = "VSYLOC02";
  TA1REC.TA1TBLKE = VSYLOC02.VSYLOC02-KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSLS-U-VSYLOC02

// update : prod location : ua
Function XSSLS-UA-VSYLOC02()


   /* ************************************************************/
   /* *** update unique row in:  product location             ****/
   /* *** using the std module:  VSYLOC02                     ****/
   /* *** note: use slvrec to pass function & date ranges     ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   +100 = concurrent update - re:                    ****/
   /* ***          deleted since last read (rec blanked out)  ****/
   /* ***          updated since last read (new data in rec)  ****/
   /* ***   -911 = deadlock - resource unavailable            ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** replace row                                         ****/
   /* *** note: IO process increments record zzzchgct by +1   ****/
   /* ***       but ID's row to update by the old zzzchgct    ****/
   /* ************************************************************/

  VSYLOC02.ZZZCHGDT = X2CREC.X2CCURDT;
  VSYLOC02.ZZZCHGTM = X3CREC.X3CCURST;

  call "VSYLOC02" ("UA", SQLCA, VSYLOC02) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
     /* ************************************************************/
     /* *** select the original row without a change count      ****/
     /* *** note: select unique does NOT use zzzchgct           ****/
     /* *** note: this puts current version of data in record   ****/
     /* ***       or blank out record layout = deleted          ****/
     /* ************************************************************/
    XSSLS-S1-VSYLOC02(); /* <=== select unique row*/
    if (SQLCA.VAGen_SQLCODE == 0)
      SQLCA.VAGen_SQLCODE = +100;
      return;
    end
    if (SQLCA.VAGen_SQLCODE == +100)
      VSYLOC02.VSYLOC02-DATA = " ";
      return;
    end
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -911)
    TA1REC.TA1FUNC = "POST";
  else
    TA1REC.TA1FUNC = "RETN";
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1PGMNM = "XSSLOCUA";
  TA1REC.TA1LOCAT[1] = "VSYLOC02";
  TA1REC.TA1LOCAT[3] = "REPLACE ";
  TA1REC.TA1LOCAT[4] = "ROW     ";
  TA1REC.TA1DBASE = "DSTLOC  ";
  TA1REC.TA1TBLVU = "VSYLOC02";
  TA1REC.TA1TBLKE = VSYLOC02.VSYLOC02-KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSLS-UA-VSYLOC02

// PO ID/Type PO# utliity
Function XSSLS10()
   /* - - - - - - - - - - - - - XSSLS10 - - - - - - - - - - - -*/

   /* - -   S U B R O U T I N E   D E S C R I P T I O N   - -*/

      /* This module is called by several functions in the*/
      /* Memphis Apparel/Stock Locate system.  Using the*/
      /* function code and either GPC/PO Number or PO ID/Type,*/
      /* this routine converts one to the other. It also sets*/
      /* a flag to indicate when multiple PO Numbers exist for*/
      /* a single PO ID.*/
   /* - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
   /* This subroutine will return the data in SWVREC.*/

   /* This subroutine will do any required Error Diagnosis*/
   /* Reporting to TA0020.  The calling process does not need to*/
   /* do any Error Diagnosis Reporting.*/
   /* - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
   /* *** Code the following before this is executed:*/
   /* ****/
   /* ***  TA1REC.TA1PGMNM: The name of the calling process,*/
   /* ***                    for Error Diagnosis Reporting.*/
   /* ****/
   /* ***  SWVREC.SWVWFNC   The function to perform*/
   /* ****/
   /* ***        'ID'  PO Number/G.P.C. conversion to PO ID/Type*/
   /* ***        'NO'  PO Id/Type conversion to PO Number*/
   /* ***        'T1'  Convert PO ID/Type to its elements(gpc:02)*/
   /* ***        'T2'  Convert elements into PO ID/Type*/
   /* ****/
   /* ****/
   /* ***  SWVREC.XGPCD     Required for option 'ID'*/
   /* ***  SWVREC.PC3PONBR*/
   /* ****/
   /* ***  SWVREC.XGPCD     Required for option 'NO'*/
   /* ***  SWVREC.SWVWPOID  (Note: If SWVWPOF = "Y" multiple PO's*/
   /* ***  SWVREC.PC4ORTYP         were found for poid/type)*/
   /* ****/
   /* ***  SWVREC.XGPCD     Required for option 'T1'*/
   /* ***  SWVREC.SWVWPOID*/
   /* ****/
   /* ***  SWVREC.XGPCD     Required for option 'T2'*/
   /* ***  SWVREC.PC3POIDT*/
   /* ***  SWVREC.PCFSECD*/
   /* ***  SWVREC.FY1FCTYC*/

   /* -----------------------------------------------------------*/

      /* The following information will be returned from this*/
      /* routine to the calling application via the SWVrec:*/

      /* Description         Field Name  Options & comments*/
      /* ------------------  ----------  ---------------------*/
      /* Return Code         SWVWRTN     All Options*/
      /* Multiple PO Flag    SWVWPOF     Option "NO" Only if*/
                                      /* Mult POs found for PO ID*/
      /* PO ID               SWVWPOID    Options: "ID" & "T1"*/
      /* PO Type             PC4ORTYP    Options: "ID"*/
      /* Factory Code        FY1FCTYC    Options: "NO" & "ID"*/
      /* Season Code         PCFSECD     Options: "NO"*/
      /* Formatted PO No     PC3PONBR    Options "ID"*/
      /* Unformatted PO No   SWVWPON     Options "ID" & "NO"*/

   /* ------------------------------------------------------------*/
   /* PO CONVERSION ROUTINE RETURN CODES (SWVW01.SWVWRTN)*/

   /* When returning to main application, check the return code*/
   /* from this called routine in order to ensure data integrity*/
   /* and avoid uncontrolled abends.*/

   /* The following is a list of return codes from this process;*/

      /* 00  Successful Return*/
      /* 01  Invalid Conversion Function (Valid Fnctns = NO, ID)*/
      /* 02  Invalid or missing GPC code*/
      /* 03  Missing SWVWPOIDT*/
      /* 04  Missing Element for options "T1","T2"*/
      /* 05  PO # not found on database*/
      /* 06  PC3POIDT eq zero*/
      /* 07  Missing PC4ORTYP*/
      /* 08  Factory code missing from SWVWPOIDT*/
      /* 09  Bad Delivery Month1 (SWVPOIDT)*/
      /* 10  Bad Delivery Month2 (SWVPOIDT)*/
      /* 11  Bad Year (SWVPOIDT)*/
      /* 12  Multiple Existing POs (Also, SWVWPOF will be 'Y')*/
      /* 98  -911 SQL Error has occurred*/
      /* 99  Fatal DB2/SQL Error Has Occurred*/

   /* ============================================================*/

  try
    call "SW0V" (SQLCA, SWVREC) {isNoRefresh = yes};
  end

   /* ------------------------------------------------------------*/
   /* If successful, return to calling process.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode == "00000000") /* Call successful*/
    if (SQLCA.VAGen_SQLCODE == 0   /* Normal return code*/
     || SQLCA.VAGen_SQLCODE == 100 /* or not found*/
     || SQLCA.VAGen_SQLCODE == -811) /* or More than one PO found*/
      return; /* Return to previous process*/
    end
  end

   /* ------------------------------------------------------------*/
   /* If data not available, post an error message and return.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/

  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/

  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "XSSLS10 TRANSLATE PO/ID";

  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/

    TA1REC.TA1FUNC = "POST"; /* Termination function*/
    call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/

    converseLib.validationFailed(47); /* Data in use by another*/

  else

    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/

    converseLib.validationFailed(1); /* System error occurred*/

  end

  SLWREC.XXXLOCID = "X10"; /* Module identification*/

  exit stack; /* Exit to display map*/


end // end XSSLS10

// purge tsqs
Function XSSLSPQ()


   /* ************************************************************/
   /* *** purge both the summary and detail tsq using ta0050  ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** purge summary tsq                                   ****/
   /* ************************************************************/

  TA5REC.TA5APPID = SLWREC.SLWSUMQU;
  TA5REC.TA5FNCCD = "P";

  call "TA0050" ("0001 ", TA5REC) {isNoRefresh = yes, isExternal = yes};

  if (TA5REC.TA5RTNCD == 0
   || TA5REC.TA5RTNCD == 4)
     /* ** next sentence ***/
  else
    SLWREC.SLWERRSW = "Y";
    SLWREC.XXXLOCID = "SPQA";
    SLWREC.SLWMSGNO = 0001; /* <--- severe error msg*/
     /* ** note: do not ezertn ***/
  end

   /* ************************************************************/
   /* *** if the detail tsq ID is greater than spaces,        ****/
   /* *** purge detail tsq (even if error above)              ****/
   /* ************************************************************/

  if (SLWREC.SLWDETQU > " ")
     /* ** next sentence ***/
  else
    return;
  end

  TA5REC.TA5APPID = SLWREC.SLWDETQU;
  TA5REC.TA5FNCCD = "P";

  call "TA0050" ("0001 ", TA5REC) {isNoRefresh = yes, isExternal = yes};

  if (TA5REC.TA5RTNCD == 0
   || TA5REC.TA5RTNCD == 4)
     /* ** next sentence ***/
  else
    SLWREC.SLWERRSW = "Y";
    SLWREC.XXXLOCID = "SPQB";
    SLWREC.SLWMSGNO = 0001; /* <--- severe error msg*/
  end

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSLSPQ

// validate receiving log hdr
Function XSSLSV1()


   /* ************************************************************/
   /* *** receiving log hdr must exist                        ****/
   /* ************************************************************/

  SLWREC.SLWVERSW = "N";

  XSSL1I0(); /* <=== select receiving log hdr*/

  if (SQLCA.VAGen_SQLCODE == 0)
     /* ** next sentence ***/
  else
    SLWREC.SLWVERSW = "Y";
    if (SQLCA.VAGen_SQLCODE == +100)
      SLWREC.XXXLOCID = "SV1A";
      SLWREC.SLWMSGNO = 0012; /* <--- not on db msg*/
      return;
    end
    if (SQLCA.VAGen_SQLCODE == -911)
      SLWREC.SLWSKYSW = "N";
      SLWREC.XXXLOCID = "SV1B";
      SLWREC.SLWMSGNO = 0031; /* <--- try again msg*/
      return;
    end
    if (SQLCA.VAGen_SQLCODE == -811)
      SLWREC.XXXLOCID = "SV1C";
      SLWREC.SLWMSGNO = 0001; /* <--- dupl rows/severe error msg*/
      return;
    end
    SLWREC.XXXLOCID = "SV1D";
    SLWREC.SLWMSGNO = 0001; /* <--- severe error msg*/
    return;
  end

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSLSV1

// abort routine
Function XSSM003()



             /* abort routine*/




  TA1REC.TA1TYPE = "DB2";
  TA1REC.TA1FUNC = "ABND";
  set ERRSQLCA empty;
  move SQLCA to ERRSQLCA withV60Compat;
  VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
  VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
  sysLib.rollback();
  VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
  
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};


end // end XSSM003

// cnv chr to num
Function XSSMS-CHR-TO-NUM()
   /* **********************************************************************/
   /* XSSMS-CHR-TO-NUM*/
   /* This routine is called by XSSMS-NUM-CHK to validate and convert*/
   /* a character format number to its numeric format.*/
   /* **********************************************************************/

  if (SMWREC.SMW-NUM-CHK-LEN < 2
   || SMWREC.SMW-NUM-CHK-LEN > 9)
    SMWREC.SMW-NUM-CHK-ERR = "Y";
    return;
  end

   /* validate each character for 1 thru 9 or space*/

  SMW-NUM-CHK-PTRC = 1;
  while (SMW-NUM-CHK-PTRC <= SMW-NUM-CHK-LEN)
    if (SMW-NUM-CHK-CHAR[SMW-NUM-CHK-PTRC] >= 0
     && SMW-NUM-CHK-CHAR[SMW-NUM-CHK-PTRC] <= 9)
       /* okay*/
    else
      if (SMW-NUM-CHK-CHAR[SMW-NUM-CHK-PTRC] != " ")
        SMWREC.SMW-NUM-CHK-ERR = "Y";
        return;
      end
    end
    SMW-NUM-CHK-PTRC = SMW-NUM-CHK-PTRC + 1;
  end

   /* right justify and pad with leading zeros*/

  move SMW-NUM-CHK-LEN to SMW-NUM-CHK-PTRC withV60Compat;
  SMW-NUM-CHK-PTRN = 9;
  while (SMW-NUM-CHK-PTRN > 0)
    if (SMW-NUM-CHK-PTRC > 0)
      if (SMW-NUM-CHK-CHAR[SMW-NUM-CHK-PTRC] == " ") /* do not move blanks*/
        SMW-NUM-CHK-PTRC = SMW-NUM-CHK-PTRC - 1;
      else /* move the digit*/
        SMW-NUM-CHK-DIGIT[SMW-NUM-CHK-PTRN] = SMW-NUM-CHK-CHAR[SMW-NUM-CHK-PTRC];
        SMW-NUM-CHK-PTRC = SMW-NUM-CHK-PTRC - 1;
        SMW-NUM-CHK-PTRN = SMW-NUM-CHK-PTRN - 1;
      end
    else
      SMW-NUM-CHK-DIGIT[SMW-NUM-CHK-PTRN] = "0";
      SMW-NUM-CHK-PTRN = SMW-NUM-CHK-PTRN - 1;
    end
  end

end // end XSSMS-CHR-TO-NUM

// CONVERT NBR FORMAT MAIN SGRP
Function XSSMS-NUM-CHK()
   /* **********************************************************************/
   /* XSSMS-NUM-CHK*/
   /* This routine converts a passed character field into a numeric field,*/
   /* and validates for nonnumeric characters.  This routine can also*/
   /* convert numeric fields into 'suppress leading zeros' character*/
   /* field and right justified.*/
   /*  */
   /* smwrec.smw-num-chk-func      'numtochr' - converts num to char*/
   /* 'chrtonum' - converts char to num*/
   /* w/ numeric validation*/
   /* smwrec.smw-num-chk-len       2 thru 9   - number of digits*/
   /* smwrec.smw-num-chk-err       'y' or 'n' - returned value*/
   /* smwrec.smw-num-chk-pad       '0' or ' ' - leading pad character*/
   /* smwrec.smw-num-chk-word                 - character format*/
   /* smwrec.smw-num-chk-nbr                  - display numeric format*/
   /* **********************************************************************/

  SMWREC.SMW-NUM-CHK-ERR = "N";

  if (SMWREC.SMW-NUM-CHK-FUNC == "CHRTONUM")
    XSSMS-CHR-TO-NUM(); /* check for non-numeric chars and convert to numeric*/
    if (SMWREC.SMW-NUM-CHK-ERR == "N")
      XSSMS-NUM-TO-CHR(); /* convert back to char /w desired leading pad char*/
    end
  else
    if (SMWREC.SMW-NUM-CHK-FUNC == "NUMTOCHR")
      XSSMS-NUM-TO-CHR(); /* convert from numeric to character display number*/
    else
      SMWREC.SMW-NUM-CHK-ERR = "Y";
    end
  end

end // end XSSMS-NUM-CHK

// cnv num to chr
Function XSSMS-NUM-TO-CHR()
   /* **********************************************************************/
   /* XSSMS-NUM-TO-CHR*/
   /* This routine is called by XSSMS-NUM-CHK to validate and convert*/
   /* a numeric format number to character format.*/
   /* **********************************************************************/

  if (SMWREC.SMW-NUM-CHK-LEN < 2 /* number must have 2 to 9 digits*/
   || SMWREC.SMW-NUM-CHK-LEN > 9)
    SMWREC.SMW-NUM-CHK-ERR = "Y";
    return;
  end
                                        /* must have valid pad char option*/
  if (SMWREC.SMW-NUM-CHK-PAD != " " /* blank leading zeros*/
   && SMWREC.SMW-NUM-CHK-PAD != "0") /* display leading zeros*/
    SMWREC.SMW-NUM-CHK-ERR = "Y";
    return;
  end

   /* if passed number is zero and pad option is '0', move zeros to*/
   /* output field and return*/

  if (SMWREC.SMW-NUM-CHK-NBR == 0
   && SMWREC.SMW-NUM-CHK-PAD == "0")
    SMWREC.SMW-NUM-CHK-WORD = "000000000";
    return;
  end

   /* move requested length of the number to char format*/

  move SMW-NUM-CHK-LEN to SMW-NUM-CHK-PTRC withV60Compat;
  SMW-NUM-CHK-PTRN = 9;
  while (SMW-NUM-CHK-PTRC > 0)
    SMW-NUM-CHK-CHAR[SMW-NUM-CHK-PTRC] = SMW-NUM-CHK-DIGIT[SMW-NUM-CHK-PTRN];
    SMW-NUM-CHK-PTRC = SMW-NUM-CHK-PTRC - 1;
    SMW-NUM-CHK-PTRN = SMW-NUM-CHK-PTRN - 1;
  end

   /* At this point, the  number in character display format is already*/
   /* passed /w zeros.  If desired pad character is ' ', do the following*/
   /* routine,  else return.*/

  if (SMWREC.SMW-NUM-CHK-PAD == "0")
    return;
  end

   /* pad leading zeros with spaces*/

  SMW-NUM-CHK-PTRC = 1;
  while (SMW-NUM-CHK-PTRC < SMW-NUM-CHK-LEN) /* replace all zeros*/
    if (SMW-NUM-CHK-CHAR[SMW-NUM-CHK-PTRC] == "0") /* with a blank from*/
      SMW-NUM-CHK-CHAR[SMW-NUM-CHK-PTRC] = " "; /* left to right*/
      SMW-NUM-CHK-PTRC = SMW-NUM-CHK-PTRC + 1; /* until a non zero*/
    else /* digit is found*/
      return; /* except for the*/
    end /* last digit*/
  end

end // end XSSMS-NUM-TO-CHR

// Exit to another application
Function XSSRS-EXIT()
   /* ------------------------------------------------------------*/
   /* Set the application to be invoked for PF1 or PF4.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf1) /* PF1 was pressed*/
    COMMAREA.CATOAP = "GD01"; /* Goal Documentation*/
  end

  if (converseVar.eventKey is pf4) /* PF4 was pressed*/
    COMMAREA.CATOAP = "MN0M"; /* Main Menu*/
  end

   /* ------------------------------------------------------------*/
   /* Set the application to be invoked for other PF keys.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf13) /* PF13 was pressed*/
    COMMAREA.CATOAP = "SR0B"; /* TO prepare schedule*/
  end

  if (converseVar.eventKey is pf14) /* PF14 was pressed*/
    COMMAREA.CATOAP = "SR0C"; /* TO correct order*/
  end

  if (converseVar.eventKey is pf15) /* PF15 was pressed*/
    COMMAREA.CATOAP = "SR0G"; /* TO balance schedule*/
  end

  if (converseVar.eventKey is pf16) /* PF16 was pressed*/
    COMMAREA.CATOAP = "SR0H"; /* TO build dir ship*/
  end

  if (converseVar.eventKey is pf17) /* PF17 was pressed*/
    COMMAREA.CATOAP = "SR0J"; /* TO inquire sched by order*/
  end

  if (converseVar.eventKey is pf18) /* PF18 was pressed*/
    COMMAREA.CATOAP = "SR0K"; /* TO inquire schedule*/
  end

  if (converseVar.eventKey is pf20) /* PF20 was pressed*/
    COMMAREA.CATOAP = "SR0M"; /* TO correct product*/
  end

   /* ------------------------------------------------------------*/
   /* Save the system work record in the COMMAREA user area.*/
   /* ------------------------------------------------------------*/

  if (COMMAREA.CATOSYS == COMMAREA.CACURSYS) /* Same system*/

    COMMAREA.CAUSERA = SRWREC.CAUSERA; /* Save work record*/
  else
    COMMAREA.CAUSERA = " "; /* Clear user area*/

  end

   /* ------------------------------------------------------------*/
   /* Transfer control to the specified application.*/
   /* ------------------------------------------------------------*/

  XSEXIT(); /* Exit to another application*/

  SRWREC.XXXERRID = "XSEXIT"; /* Message location*/

   /* ------------------------------------------------------------*/
   /* Reestablish the COMMAREA application and item fields.*/
   /* ------------------------------------------------------------*/

  COMMAREA.CAEZSG3 = "0"; /* Force zero third character*/
  COMMAREA.CACURRAP = COMMAREA.CAEZSAP; /* Current application*/

  if (converseVar.eventKey is pfkey) /* PF key was pressed*/

    COMMAREA.CATOAP = " "; /* Clear TO application*/

    if (converseVar.eventKey is pf1) /* PF1 was pressed*/
      COMMAREA.CAITEM = " "; /* Clear map name from item*/
    end

  end


end // end XSSRS-EXIT

// Exit to another application
Function XSSRS01()
   /* ------------------------------------------------------------*/
   /* If ENTER was pressed, return to the previous process.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is enter) /* ENTER was pressed*/
    return; /* Return to previous process*/
  end

   /* ------------------------------------------------------------*/
   /* If PA2 was pressed, exit to display the map.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pa2) /* PA2 was pressed*/
    exit stack; /* Exit to display the map*/
  end

   /* ------------------------------------------------------------*/
   /* Set the application to be invoked for PF1 or PF4.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf1) /* PF1 was pressed*/
    COMMAREA.CATOAP = "GD01"; /* Goal Documentation*/
  end

  if (converseVar.eventKey is pf4) /* PF4 was pressed*/
    COMMAREA.CATOAP = "MN0M"; /* Master Menu*/
  end

   /* ------------------------------------------------------------*/
   /* Set the application to be invoked for SR defined keys.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf3) /* PF3 was pressed*/
    COMMAREA.CATOAP = "SR0A"; /* Ship/Rec menu*/
  end


  if (converseVar.eventKey is pf13) /* PF13 was pressed*/
    COMMAREA.CATOAP = "SR0B"; /* Prepare schedule*/
  end

  if (converseVar.eventKey is pf14) /* PF14 was pressed*/
    COMMAREA.CATOAP = "SR0C"; /* Correct order header*/
  end

  if (converseVar.eventKey is pf15) /* PF15 was pressed*/
    COMMAREA.CATOAP = "SR0G"; /* Balance schedule*/
  end

  if (converseVar.eventKey is pf16) /* PF16 was pressed*/
    COMMAREA.CATOAP = "SR0H"; /* Build schedule from orders*/
  end

  if (converseVar.eventKey is pf17) /* PF17 was pressed*/
    COMMAREA.CATOAP = "SR0J"; /* Inquire on schedule by order*/
  end

  if (converseVar.eventKey is pf18) /* PF18 was pressed*/
    COMMAREA.CATOAP = "SR0K"; /* Inquire by schedule*/
  end

  if (converseVar.eventKey is pf19) /* PF19 was pressed*/
    COMMAREA.CATOAP = "    "; /* SR0L deinstalled*/
  end

  if (converseVar.eventKey is pf20) /* PF20 was pressed*/
    COMMAREA.CATOAP = "SR0M"; /* Correct product*/
  end

  if (converseVar.eventKey is pf21) /* PF21 was pressed*/
    COMMAREA.CATOAP = "    "; /* SR0N deinstalled*/
  end

   /* ------------------------------------------------------------*/
   /* If TO application was not set, indicate invalid PA/PF key.*/
   /* ------------------------------------------------------------*/

  if (COMMAREA.CATOAP == " ") /* TO application blank*/

    SRWREC.XXXERRID = "XSSRS01"; /* Error identification*/
    converseLib.validationFailed(12); /* (PA/PF) key pressed is invalid*/

    return; /* Return to previous process*/

  end

   /* ------------------------------------------------------------*/
   /* Save the application user area in the COMMAREA.*/
   /* ------------------------------------------------------------*/

  if (COMMAREA.CATOSYS == COMMAREA.CACURSYS) /* Same system*/

    COMMAREA.CAUSERA = SRWREC.CAUSERA; /* Save user area*/
  else
    COMMAREA.CAUSERA = " "; /* Clear user area*/

  end

   /* ------------------------------------------------------------*/
   /* Transfer control to the specified application.*/
   /* ------------------------------------------------------------*/

  XSEXIT(); /* Exit to another application*/

   /* ------------------------------------------------------------*/
   /* Reestablish the COMMAREA application and item fields.*/
   /* ------------------------------------------------------------*/

  COMMAREA.CAEZSG3 = "0"; /* Force zero third character*/
  COMMAREA.CACURRAP = COMMAREA.CAEZSAP; /* CURR application*/

  if (converseVar.eventKey is pfkey) /* PF key was pressed*/

    COMMAREA.CATOAP = " "; /* Clear TO application*/

    if (converseVar.eventKey is pf1) /* PF1 was pressed*/
      COMMAREA.CAITEM = " "; /* Clear map name from item*/
    end

  end

  SRWREC.XXXERRID = "XSSRS01"; /* Error identification*/
  SRWREC.SRWMSG = COMMAREA.CAMSG; /* Message text*/


end // end XSSRS01

// Call MN0V sub-program
Function XSSY008-CALL-MN0V()

   /* ************************************************************/
   /* *** Call the MN0V CSP sub-program to retrieve region    ****/
   /* *** information for userid.                             ****/
   /* *** return codes:                                       ****/
   /* ***   0000 = successful                                 ****/
   /* ***   0100 = end of scan                                ****/
   /* ***   1010 = not found                                  ****/
   /* ***   1020 = system error                               ****/
   /* ***   2010 = invalid system prefix                      ****/
   /* ***   2020 = invalid tran Id                            ****/
   /* ***   3010 = invalid function code                      ****/
   /* ***          note: TA0020 will be executed for all      ****/
   /* ***                errors except the first three.       ****/
   /* ************************************************************/

  try
    call "MN0V" (COMMAREA, MNVREC) {isNoRefresh = yes};
  end

  if (sysVar.errorCode == "00000000") /* No Calling problem*/
    if (MNVREC.MNV-RTN-CODE == 0000
     || MNVREC.MNV-RTN-CODE == 0100
     || MNVREC.MNV-RTN-CODE == 1010)
      return;
    end
  else
    TA1REC.TA1LOCAT[2] = sysVar.errorCode;
    MNVREC.MNV-RTN-CODE = 9999;
  end

  converseLib.validationFailed(215); /* CICS Error determining region*/
  TA1REC.TA1TYPE = "APPL";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSSY008 ";
  TA1REC.TA1LOCAT[1] = "MN0V    ";
  TAEREC.TAEDESC1 = MNVREC.MNV-GROUP;
  TAEREC.TAEDESC2 = " ";
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, TAEREC) {isExternal = yes};

end // end XSSY008-CALL-MN0V

// inquiry:(style)color view 2:0
Function XSSYCI0()


   /* ************************************************************/
   /* *** select unique row/view: combined style & color view ****/
   /* *** using the std module:  IO0560                       ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   +100 = not found                                  ****/
   /* ***   -811 = duplicates found                           ****/
   /* ***          note: do NOT clear screen                  ****/
   /* ***     <0 = db/severe error (&-911)                    ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** select unique row                                   ****/
   /* ************************************************************/

  call "IO0560" ("S ", SQLCA, SYCREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -811)
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSSYCI0 ";
  TA1REC.TA1LOCAT[1] = "IO0560  ";
  TA1REC.TA1LOCAT[3] = "SELECT  ";
  TA1REC.TA1LOCAT[4] = "UNIQUE  ";
  TA1REC.TA1DBASE = "DPROD   ";
  TA1REC.TA1TBLVU = "VCOLOR02";
  TA1REC.TA1TBLKE = SYCREC.SYCKEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSYCI0

// inquiry : sz xlate : 1
Function XSSYPI1()


   /* ************************************************************/
   /* *** obtain the desired size description/size id (no.)   ****/
   /* *** using the std module:  SY1120                       ****/
   /* *** code the following before this is executed:         ****/
   /* ***   TA1REC.TA1LOCAT(2) = what executes this sgrp      ****/
   /* ***   TA1REC.TA1MAP      = what map this data is from   ****/
   /* ***   note: or setup during init. & use a comment       ****/
   /* ***   SYPREC.SYPFC:   PC = all valid sizes              ****/
   /* ***                   IE = int. sz id to desc.          ****/
   /* ***                   EI = desc. to int. sz id          ****/
   /* ***   SYPREC.SYPCMPSW: c = compressed (first blank or   ****/
   /* ***                        zero is end of data)         ****/
   /* ***                    N = not compressed (positional)  ****/
   /* *** code the action for the following return codes:     ****/
   /* *** note: check the SYPREC.SYPRC (NOT sqlcode)          ****/
   /* ***      0 = successful                                 ****/
   /* ***      9 = deadlock                                   ****/
   /* ***     10 = not found                                  ****/
   /* ***  other = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** call sy1120                                         ****/
   /* *** note: func & compress sw setup prior to this sgrp   ****/
   /* ************************************************************/

  call "SY1120" (SQLCA, SYPREC) {isNoRefresh = yes, isExternal = yes};

  if (SYPREC.SYPRC <= 5)
    return;
  end

  if (SYPREC.SYPRC == 9)
    return;
  end

  if (SYPREC.SYPRC == 10)
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSSYPI0 ";
  TA1REC.TA1LOCAT[1] = "SY1120  ";
  TA1REC.TA1LOCAT[3] = SYPREC.SYPRCX;
  TA1REC.TA1LOCAT[4] = "SZ XLATE";
  TA1REC.TA1DBASE = "MULTIPLE";
  TA1REC.TA1TBLVU = "DB VIEWS";
  TA1REC.TA1TBLKE = SYPREC.SYPKEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSSYPI1

// Call application to submit JCL
Function XSTA0P()
   /* ------------------------------------------------------------*/
   /* Call the Background Job Request Subroutine application.*/
   /* ------------------------------------------------------------*/

  XPTA0P();


end // end XSTA0P

// Exit to another application
Function XSTAS-EXIT()
   /* ------------------------------------------------------------*/
   /* Set the application to be invoked for PF1 or PF4.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf1) /* PF1 was pressed*/
    COMMAREA.CATOAP = "GD01"; /* Goal Documentation*/
  end

  if (converseVar.eventKey is pf4) /* PF4 was pressed*/
    COMMAREA.CATOAP = "MN0M"; /* Master Menu*/
  end

   /* ------------------------------------------------------------*/
   /* Save the system work record in the COMMAREA user area.*/
   /* ------------------------------------------------------------*/

  if (COMMAREA.CATOSYS == COMMAREA.CACURSYS) /* Same system*/

    COMMAREA.CAUSERA = TAWREC.CAUSERA; /* Save work record*/
  else
    COMMAREA.CAUSERA = " "; /* Clear user area*/

  end

   /* ------------------------------------------------------------*/
   /* Transfer control to the specified application.*/
   /* ------------------------------------------------------------*/

  XSEXIT(); /* Exit to another application*/

  TAWREC.XXX-MSG-LOC-ID = "XSEXIT"; /* Message location*/

   /* ------------------------------------------------------------*/
   /* Reestablish the COMMAREA application and item fields.*/
   /* ------------------------------------------------------------*/

  COMMAREA.CAEZSG3 = "0"; /* Force zero third character*/
  COMMAREA.CACURRAP = COMMAREA.CAEZSAP; /* Current application*/

  if (converseVar.eventKey is pfkey) /* PF key was pressed*/

    COMMAREA.CATOAP = " "; /* Clear TO application*/

    if (converseVar.eventKey is pf1) /* PF1 was pressed*/
      COMMAREA.CAITEM = " "; /* Clear map name from item*/
    end

  end


end // end XSTAS-EXIT

// Select security row
Function XSTAS-IO7020-S()
   /* ------------------------------------------------------------*/
   /* Select security row.*/
   /* ------------------------------------------------------------*/

  try
    call "IO7020" ("S ", SQLCA, VSECUR01) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/

   /* ------------------------------------------------------------*/
   /* If the call was successful, return to the previous process,*/
   /* Otherwise change sqlcode to non-zero before returning.*/
   /* ------------------------------------------------------------*/

  if (sysVar.errorCode != "00000000") /* Call successful*/

    SQLCA.VAGen_SQLCODE = -1; /* Non-zero return*/

  end


end // end XSTAS-IO7020-S

// Check security table
Function XSTAS-SECURITY()
   /* ------------------------------------------------------------*/
   /* This checks the user against the security table to see if*/
   /* they have access to the IMDS system.*/
   /* ------------------------------------------------------------*/

  COMMAREA.CAITEM = " "; /* Clear passed data.*/

  if (COMMAREA.CAADDFL == "Y")

    TAWREC.XXX-SCRTY-USER-ID = COMMAREA.CAUSERID;
                                  /* Set default user to causerid.*/
    exit stack; /* Don't search table for match.*/

  end

   /* ------------------------------------------------------------*/
   /* Get user id and search table for match.*/
   /* ------------------------------------------------------------*/

  set VSECUR01 empty;

  VSECUR01.XXX-SCRTY-USER-ID = COMMAREA.CAUSERID;
  VSECUR01.XXX-RPT-FIL-ID = "SECURITY";

  XSTAS-IO7020-S();

  if (SQLCA.VAGen_SQLCODE == 0)

    TAWREC.XXX-SCRTY-USER-ID = COMMAREA.CAUSERID;
     /* Set default user to causerid.*/
  else

    /* ----------------------------------------------------------*/
    /* Exit to main menu.*/
    /* ----------------------------------------------------------*/

    COMMAREA.CATOAP = "MN0M";

    COMMAREA.CAMSG = " IMDS SECURITY ERROR -  CALL HELP HOTLINE ";
     /* Send error message to main menu on way out.*/

    XSTAS-EXIT(); /* Exit to Main Menu*/

  end


end // end XSTAS-SECURITY

// close : location : 0
Function XSTF2C0()


   /* ************************************************************/
   /* *** close select set of: destination table              ****/
   /* *** using the standard i/o processing version #0        ****/
   /* *** note: sqlcq.sqlcode used re: can't "set" ezesqcod   ****/
   /* *** setup the following just before this is executed:   ****/
   /* ***   TA1REC.TA1LOCAT(2) = what executes this sgrp      ****/
   /* ***   TA1REC.TA1MAP      = what map this data is from   ****/
   /* *** code the action for the following return codes:     ****/
   /* ***      0 = successful - continue                      ****/
   /* ***   -501 = cursor already closed - return 0           ****/
   /* ***          note:  use -507 if using native sql        ****/
   /* ***     <0 = db/severe error - contact programming msg  ****/
   /* ***          note: clear screen & put keys back         ****/
   /* ***          note: TA0020 will have been executed       ****/
   /* ***                within this sgrp for <0 only         ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** close select set (if prior to EOF)                  ****/
   /* ************************************************************/

  call "IO1210" ("CS", SQLCA, TF2REC) {isNoRefresh = yes, isExternal = yes}; /* <=== close select set*/

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -501)
    SQLCA.VAGen_SQLCODE = 0;
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSTF2C0 ";
  TA1REC.TA1LOCAT[1] = "IO1210  ";
  TA1REC.TA1LOCAT[3] = "CLOSE   ";
  TA1REC.TA1LOCAT[4] = "SETINQ  ";
  TA1REC.TA1DBASE = "DPICK   ";
  TA1REC.TA1TBLVU = "VDESTN01";
  TA1REC.TA1TBLKE = TF2REC.TF2KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
  XSPF4();

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSTF2C0

// inquiry : location : 0
Function XSTF2I0()


   /* ************************************************************/
   /* *** select unique row from: destination table           ****/
   /* *** using the standard i/o processing version #0        ****/
   /* *** note: second fetch used to detect duplicate rows    ****/
   /* *** note: sqlcq.sqlcode used re: can't "set" ezesqcod   ****/
   /* *** note: IO process(s) do all rec/row moves so that    ****/
   /* ***       the final result will be in the record        ****/
   /* *** setup the following just before this is executed:   ****/
   /* ***   TA1REC.TA1LOCAT(2) = what executes this sgrp      ****/
   /* ***   TA1REC.TA1MAP      = what map this data is from   ****/
   /* *** code the action for the following return codes:     ****/
   /* ***      0 = successful - continue                      ****/
   /* ***   +100 = not found - setup not fnd error/msg        ****/
   /* ***   -911 = deadlock - setup try again error/msg       ****/
   /* ***   -811 = duplicates found - contact programming msg ****/
   /* ***          note: do NOT clear screen                  ****/
   /* ***     <0 = db/severe error - contact programming msg  ****/
   /* ***          note: clear screen & put keys back         ****/
   /* ***          note: TA0020 will have been executed       ****/
   /* ***                within this sgrp for <0 only         ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** select row with unique key                          ****/
   /* ************************************************************/

  call "IO1210" ("S ", SQLCA, TF2REC) {isNoRefresh = yes, isExternal = yes}; /* <=== select unique*/

  if (SQLCA.VAGen_SQLCODE == -911)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -811) /* duplicate*/
    XSTF2S0();
    XSTF2C0();
  end

  if (SQLCA.VAGen_SQLCODE < 0)
    TA1REC.TA1TYPE = "DB2 ";
    TA1REC.TA1FUNC = "RETN";
    TA1REC.TA1PGMNM = "XSTF2I0 ";
    TA1REC.TA1LOCAT[1] = "IO1210  ";
    TA1REC.TA1LOCAT[3] = "SELECT  ";
    TA1REC.TA1LOCAT[4] = "SET     ";
    TA1REC.TA1DBASE = "DPICK   ";
    TA1REC.TA1TBLVU = "VDESTN01";
    TA1REC.TA1TBLKE = TF2REC.TF2KEY;
    move SQLCA to ERRSQLCA withV60Compat;
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback();
    call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
    XSPF4();
  end

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSTF2I0

// setinq : location : 0
Function XSTF2S0()


   /* ************************************************************/
   /* *** select set of rows from: destination table          ****/
   /* *** using the standard i/o processing version #0        ****/
   /* *** note: sqlcq.sqlcode used re: can't "set" ezesqcod   ****/
   /* *** note: +100 - not found can't be detected until the  ****/
   /* ***       first fetch is executed                       ****/
   /* *** setup the following just before this is executed:   ****/
   /* ***   TA1REC.TA1LOCAT(2) = what executes this sgrp      ****/
   /* ***   TA1REC.TA1MAP      = what map this data is from   ****/
   /* *** code the action for the following return codes:     ****/
   /* ***      0 = successful - continue                      ****/
   /* ***   +100 = none found - setup not fnd error/msg       ****/
   /* ***   -911 = deadlock - setup try again error/msg       ****/
   /* ***     <0 = db/severe error - contact programming msg  ****/
   /* ***          note: clear screen & put keys back         ****/
   /* ***          note: TA0020 will have been executed       ****/
   /* ***                within this sgrp for <0 only         ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** select set with unique key                          ****/
   /* ************************************************************/

  call "IO1210" ("SS", SQLCA, TF2REC) {isNoRefresh = yes, isExternal = yes}; /* <=== select set row*/

  if (SQLCA.VAGen_SQLCODE == -911)
    return;
  end

  if (SQLCA.VAGen_SQLCODE < 0)
    TA1REC.TA1TYPE = "DB2 ";
    TA1REC.TA1FUNC = "RETN";
    TA1REC.TA1PGMNM = "XSTF2S0 ";
    TA1REC.TA1LOCAT[1] = "IO1210  ";
    TA1REC.TA1LOCAT[3] = "SELECT  ";
    TA1REC.TA1LOCAT[4] = "SET     ";
    TA1REC.TA1DBASE = "DPICK   ";
    TA1REC.TA1TBLVU = "VDESTN01";
    TA1REC.TA1TBLKE = TF2REC.TF2KEY;
    move SQLCA to ERRSQLCA withV60Compat;
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback();
    call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
    XSPF4();
  end

   /* ************************************************************/
   /* *** scan/retrieve/fetch first row                       ****/
   /* *** in order to detect not found (+100)                 ****/
   /* *** note: CSP closes cursor at end of set (+100)        ****/
   /* *** note: any loop processing must use this first row   ****/
   /* ***       and fetch the next row at the end of the loop ****/
   /* ************************************************************/

  call "IO1210" ("SN", SQLCA, TF2REC) {isNoRefresh = yes, isExternal = yes}; /* <=== select set row*/

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "XSTF2S0 ";
  TA1REC.TA1LOCAT[1] = "IO1210  ";
  TA1REC.TA1LOCAT[3] = "FIRST   ";
  TA1REC.TA1LOCAT[4] = "FETCH   ";
  TA1REC.TA1DBASE = "DPICK   ";
  TA1REC.TA1TBLVU = "VDESTN01";
  TA1REC.TA1TBLKE = TF2REC.TF2KEY;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};
  XSPF4();

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSTF2S0

// add : location : 0
Function XSTFCA0()


   /* ************************************************************/
   /* *** add unique row in: destination audit table          ****/
   /* *** using the std i/o processing version #0             ****/
   /* *** note: sqlcq.sqlcode used re: can't "set" ezesqcod   ****/
   /* *** note: IO process(s) do all row/rec moves so that    ****/
   /* ***       the final result will be in the record        ****/
   /* *** setup the following just before this is executed:   ****/
   /* ***   TA1REC.TA1LOCAT(2) = what executes this sgrp      ****/
   /* ***   TA1REC.TA1MAP      = what map this data is from   ****/
   /* *** code the action for the following return codes:     ****/
   /* ***      0 = successful - continue                      ****/
   /* ***   -803 = adding duplicate row - setup dupl row msg  ****/
   /* ***   -911 = deadlock - try again msg                   ****/
   /* ***     <0 = db/severe error - contact programming msg  ****/
   /* ***          note: clear screen & put keys back         ****/
   /* ***          note: TA0020 will have been executed       ****/
   /* ************************************************************/


   /* ************************************************************/
   /* *** insert row                                          ****/
   /* *** note: IO process initializes zzzchgct to 0          ****/
   /* ************************************************************/

  call "IO1630" ("A ", SQLCA, TFCREC) {isNoRefresh = yes, isExternal = yes}; /* <=== add a row*/

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -911)
    return;
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1PGMNM = "TF0F    ";
  TA1REC.TA1LOCAT[1] = "XSTFCA0 ";
  TA1REC.TA1LOCAT[3] = "ADD     ";
  TA1REC.TA1LOCAT[4] = "ROW     ";
  TA1REC.TA1DBASE = "DPICK   ";
  TA1REC.TA1TBLVU = "VTFAUD01";
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSTFCA0

// check traffic security
Function XSTFS01()



      /* *********************************************************/
      /* * retrieve traffic commarea and check security         **/
      /* *********************************************************/


  TFWREC.TFWGRPLV = COMMAREA.CAUSERA; /* get traffic commarea*/


  if (TFWREC.TFWSYSIN != "TF0") /* check traffic security*/
    set TFWREC empty; /* clear working storage record*/
    TFWREC.TFWSYSIN = "TF0"; /* set sysinit field*/
    if (COMMAREA.CAADDFL == "Y" /* update ok?*/
     || COMMAREA.CACHGFL == "Y" /* update ok?*/
     || COMMAREA.CADLVL[10] == "Y") /* update ok?*/
      TFWREC.TFWUPDFL = "Y"; /* set update enabled field*/
    else
      TFWREC.TFWUPDFL = "N"; /* set update disabled field*/
    end
    if (TFWREC.XWHCD <= " ") /* warehouse missing*/
      TFWREC.XWHCD = COMMAREA.XWHCD; /* set warehouse code*/
    end
    COMMAREA.CAUSERA = TFWREC.TFWGRPLV; /* restore commarea*/
  end



   /* *************************************************************/
end // end XSTFS01

// Cnvt Store Id Alpha to Numeric
Function XSTFS02()
   /* *************************************************************/
   /* *     XSTFS02 - Convert Store Id from Alpha to Numeric     **/
   /* *               This routine will convert a store id of    **/
   /* *               'ALL ' or ' ALL' to -1 otherwise it will   **/
   /* *               right justify the numbers into the numeric **/
   /* *               field TFASTRN.  The flag TFAPFL9 will      **/
   /* *               be set to 'E' if anything other than 0     **/
   /* *               thru 9 is found in the input (error).      **/
   /* *     NOTE - THIS ROUTINE WILL USE AND TRASH THE           **/
   /* *            SUBSCRIPTS TFAWSUB9 AND TFAWSUB8              **/
   /* *            AND THE FLAG TFAPFL9                          **/
   /* *************************************************************/

  TFAREC.TFAPFL9 = "N"; /* reset error flag*/
  TFAREC.TFASTRN = 0; /* zero store number*/
  if (TFAREC.TFASTRA == "ALL "
   || TFAREC.TFASTRA == " ALL"
   || TFAREC.TFASTRA == "    ")
    TFAREC.TFASTRN = -1;
    TFAREC.TFASTRA = "ALL ";
  else
    TFAREC.TFAWSUB9 = 4;
    TFAREC.TFAWSUB8 = 4;
    while (TFAREC.TFAWSUB9 > 0
     && TFAREC.TFAPFL9 != "E")
      if (TFAREC.TFASTRC[TFAWSUB9] == " ")
        /* next sentence*/
      else
        if (TFAREC.TFASTRC[TFAWSUB9] < "0"
         || TFAREC.TFASTRC[TFAWSUB9] > "9")
          TFAREC.TFAPFL9 = "E"; /* got bad data here*/
        else
          TFAREC.TFASTRNC[TFAWSUB8] = TFAREC.TFASTRC[TFAWSUB9];
          TFAREC.TFAWSUB8 = TFAREC.TFAWSUB8 - 1;
        end
      end
      TFAREC.TFAWSUB9 = TFAREC.TFAWSUB9 - 1;
    end
  end

end // end XSTFS02

// compress alpha field for brows
Function XSTFS04()
   /* *************************************************************/
   /* *     XSTFS04 - Compress alpha field for browse usage.     **/
   /* *     NOTE - THIS ROUTINE WILL USE AND TRASH THE           **/
   /* *            SUBSCRIPTS TFAWSUB9 AND TFAWSUB8              **/
   /* *************************************************************/

  TFAREC.TFARSLT = " "; /* clear result field*/
  TFAREC.TFAWSUB9 = 1; /* init result index*/
  TFAREC.TFAWSUB8 = 1; /* init primary index*/

  while (TFAREC.TFAWSUB8 <= 30 /* not end of array*/
   && TFAREC.TFAWSUB9 <= 10) /* not end of array*/
    if (TFAREC.TFACMPRC[TFAWSUB8] >= "A"
     && TFAREC.TFACMPRC[TFAWSUB8] <= "I")
      TFAREC.TFARSLTC[TFAWSUB9] = TFAREC.TFACMPRC[TFAWSUB8];
      TFAWSUB8 = TFAWSUB8 + 1; /* update primary index*/
      TFAWSUB9 = TFAWSUB9 + 1; /* update result index*/
    else
      if (TFAREC.TFACMPRC[TFAWSUB8] >= "J"
       && TFAREC.TFACMPRC[TFAWSUB8] <= "R")
        TFAREC.TFARSLTC[TFAWSUB9] = TFAREC.TFACMPRC[TFAWSUB8];
        TFAWSUB8 = TFAWSUB8 + 1; /* update primary index*/
        TFAWSUB9 = TFAWSUB9 + 1; /* update result index*/
      else
        if (TFAREC.TFACMPRC[TFAWSUB8] >= "S"
         && TFAREC.TFACMPRC[TFAWSUB8] <= "Z")
          TFAREC.TFARSLTC[TFAWSUB9] = TFAREC.TFACMPRC[TFAWSUB8];
          TFAWSUB8 = TFAWSUB8 + 1; /* update primary index*/
          TFAWSUB9 = TFAWSUB9 + 1; /* update result index*/
        else
          if (TFAREC.TFACMPRC[TFAWSUB8] >= "0"
           && TFAREC.TFACMPRC[TFAWSUB8] <= "9")
            TFAREC.TFARSLTC[TFAWSUB9] = TFAREC.TFACMPRC[TFAWSUB8];
            TFAWSUB8 = TFAWSUB8 + 1; /* update primary index*/
            TFAWSUB9 = TFAWSUB9 + 1; /* update result index*/
          else
            TFAWSUB8 = TFAWSUB8 + 1; /* update primary index*/
          end
        end
      end
    end
  end

end // end XSTFS04

// Exit to another application
Function XSTIS-EXIT()
   /* ------------------------------------------------------------*/
   /* Save the system work record in the COMMAREA user area.*/
   /* ------------------------------------------------------------*/

  if (COMMAREA.CATOSYS == COMMAREA.CACURSYS) /* Same system*/

    COMMAREA.CAUSERA = TIWREC.CAUSERA; /* Save work record*/
  else
    COMMAREA.CAUSERA = " "; /* Clear user area*/

  end

   /* ------------------------------------------------------------*/
   /* Transfer control to the specified application.*/
   /* ------------------------------------------------------------*/

  XSEXIT(); /* Exit to another application*/

  TIWREC.XXX-MSG-LOC-ID = "XSEXIT"; /* Message location*/

   /* ------------------------------------------------------------*/
   /* Reestablish the COMMAREA application and item fields.*/
   /* ------------------------------------------------------------*/

  COMMAREA.CAEZSG3 = "0"; /* Force zero third character*/
  COMMAREA.CACURRAP = COMMAREA.CAEZSAP; /* Current application*/

  if (converseVar.eventKey is pfkey) /* PF key was pressed*/

    COMMAREA.CATOAP = " "; /* Clear TO application*/

    if (converseVar.eventKey is pf1) /* PF1 was pressed*/
      COMMAREA.CAITEM = " "; /* Clear map name from item*/
    end

  end


end // end XSTIS-EXIT

// Exit to another application
Function XSTSS01()
   /* ------------------------------------------------------------*/
   /* Set the application to be invoked for PF1 or PF4.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf1) /* PF1 was pressed*/
    COMMAREA.CATOAP = "GD01"; /* Indicate Goal Documentation*/
  end

  if (converseVar.eventKey is pf4) /* PF4 was pressed*/
    COMMAREA.CATOAP = "MN0M"; /* Indicate Master Menu*/
  end

   /* ------------------------------------------------------------*/
   /* Set the application to be invoked for PF3 if in main menu.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf3 /* PF3 was pressed*/
   && COMMAREA.CACURRAP == "TS0A") /* and main application menu*/

    COMMAREA.CATOAP = "MN0M"; /* Indicate Master Menu*/

  end

   /* ------------------------------------------------------------*/
   /* Save the application user area in the COMMAREA.*/
   /* ------------------------------------------------------------*/

  if (COMMAREA.CATOSYS == "TS" /* Transfer within same system*/
   || COMMAREA.CATOSYS == "TR") /* Transfer within same system*/

    COMMAREA.CAUSERA = TSWREC.CAUSERA; /* Save user area*/

  else

    if (COMMAREA.CATOSYS == "PC") /* Transfer to PC system*/

       /* NEXT SENTENCE*/
    else
      COMMAREA.CAUSERA = " "; /* Clear user area*/

    end

  end

   /* ------------------------------------------------------------*/
   /* Transfer control to the specified application.*/
   /* ------------------------------------------------------------*/

  XSEXIT(); /* Exit to another application*/

   /* ------------------------------------------------------------*/
   /* If transfer failed, return an error to the calling process.*/
   /* ------------------------------------------------------------*/

  if (COMMAREA.CASECRC == 3 /* Application not found*/
   || COMMAREA.CASECRC == 4) /* or transfer not allowed*/

    converseLib.validationFailed(6); /* Cannot access application*/
  else
    converseLib.validationFailed(10); /* Unexpected error occurred*/

  end

   /* ------------------------------------------------------------*/
   /* Reestablish the COMMAREA application and item fields.*/
   /* ------------------------------------------------------------*/

  COMMAREA.CAEZSG3 = "0"; /* Force zero third character*/
  COMMAREA.CACURRAP = COMMAREA.CAEZSAP; /* CURR application*/

  if (converseVar.eventKey is pfkey) /* PF key was pressed*/

    COMMAREA.CATOAP = " "; /* Clear TO application*/

    if (converseVar.eventKey is pf1) /* PF1 was pressed*/
      COMMAREA.CAITEM = " "; /* Clear map name from item*/
    end

  end


end // end XSTSS01

// Exit to another application
Function XSTSS02()
   /* ------------------------------------------------------------*/
   /* Set the application to be invoked for PF1 or PF4.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf1) /* PF1 was pressed*/
    COMMAREA.CATOAP = "GD01"; /* Indicate Goal Documentation*/
  end

  if (converseVar.eventKey is pf4) /* PF4 was pressed*/
    COMMAREA.CATOAP = "MN0M"; /* Indicate Master Menu*/
  end

   /* ------------------------------------------------------------*/
   /* Save the application user area in the COMMAREA.*/
   /* ------------------------------------------------------------*/

  if (COMMAREA.CATOSYS == COMMAREA.CACURSYS) /* Same system*/

    COMMAREA.CAUSERA = TSWREC.CAUSERA; /* Save user area*/
  else
    COMMAREA.CAUSERA = " "; /* Clear user area*/

  end

   /* ------------------------------------------------------------*/
   /* Transfer control to the specified application.*/
   /* ------------------------------------------------------------*/

  XSEXIT(); /* Exit to another application*/

   /* ------------------------------------------------------------*/
   /* If transfer failed, return an error to the calling process.*/
   /* ------------------------------------------------------------*/

  if (COMMAREA.CASECRC == 3 /* Application not found*/
   || COMMAREA.CASECRC == 4) /* or transfer not allowed*/

    TSWREC.XXXMODID = "X01"; /* Module identification*/

    converseLib.validationFailed(6); /* Indicate not allowed*/
  else
    converseLib.validationFailed(10); /* Indicate system error*/

  end

   /* ------------------------------------------------------------*/
   /* Clear the COMMAREA "TO Application" and "Item" fields.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pfkey) /* PF key was pressed*/

    COMMAREA.CATOAP = " "; /* Clear TO application*/

    if (converseVar.eventKey is pf1) /* PF1 was pressed*/
      COMMAREA.CAITEM = " "; /* Clear map name from item*/
    end

  end


end // end XSTSS02

// Exit to another application
Function XSTYS-EXIT()
   /* ------------------------------------------------------------*/
   /* Set the application to be invoked for PF1 or PF4.*/
   /* ------------------------------------------------------------*/

  if (converseVar.eventKey is pf1) /* PF1 was pressed*/
    COMMAREA.CATOAP = "GD00"; /* Goal Documentation*/
  end

  if (converseVar.eventKey is pf4) /* PF4 was pressed*/
    COMMAREA.CATOAP = "MN0M"; /* Master Menu*/
  end

   /* ------------------------------------------------------------*/
   /* Save the system work record in the COMMAREA user area.*/
   /* ------------------------------------------------------------*/

  if (COMMAREA.CATOSYS == COMMAREA.CACURSYS) /* Same system*/

    COMMAREA.CAUSERA = TYWREC.CAUSERA; /* Save work record*/
  else
    COMMAREA.CAUSERA = " "; /* Clear user area*/

  end

   /* ------------------------------------------------------------*/
   /* Transfer control to the specified application.*/
   /* ------------------------------------------------------------*/

  XSEXIT(); /* Exit to another application*/

  TYWREC.XXX-MSG-LOC-ID = "XSEXIT"; /* Message location*/

   /* ------------------------------------------------------------*/
   /* Reestablish the COMMAREA application and item fields.*/
   /* ------------------------------------------------------------*/

  COMMAREA.CAEZSG3 = "0"; /* Force zero third character*/
  COMMAREA.CACURRAP = COMMAREA.CAEZSAP; /* Current application*/

  if (converseVar.eventKey is pfkey) /* PF key was pressed*/

    COMMAREA.CATOAP = " "; /* Clear TO application*/

    if (converseVar.eventKey is pf1) /* PF1 was pressed*/
      COMMAREA.CAITEM = " "; /* Clear map name from item*/
    end

  end


end // end XSTYS-EXIT

// obtain current date (ccyymmss)
Function XSX2CDT()


   /* ************************************************************/
   /* *** use ta0040 to obtain the current date including CC  ****/
   /* ************************************************************/

  set TA2REC empty;

  TA2REC.TA2DTOPT = "GETDATE ";
  TA2REC.TA2GRTYP = "G";

  call "TA0040" (TA2REC) {isNoRefresh = yes, isExternal = yes};

  if (TA2REC.TA2RTNCD == 0)
    X2CREC.X2CCURDT = TA2REC.TA2GRGGN;
    return;
  end

   /* ************************************************************/
   /* *** since ta0020 will not check 'getdate ' return code  ****/
   /* *** and we must prevent further processing,             ****/
   /* *** call ta0020 to display error and return to main menu****/
   /* ************************************************************/

  set TA1REC empty;

  TA1REC.TA1FUNC = "RETN";
  TA1REC.TA1TYPE = "APPL";
  TA1REC.TA1PGMNM = "XSX2CDT ";
  TA1REC.TA1LOC = "TA0040 - GET CURRENT DATE";
  SQLCA.SQLCAREC = TA2REC.TA2RTNCD;
  call "TA0020" (TA1REC, SQLCA) {isExternal = yes};

  XSPF4();

  exit program;

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSX2CDT

// obtain current time (hhmmss)
Function XSX3CTM()


   /* ************************************************************/
   /* *** move CSP's time to ws fld with colons               ****/
   /* *** move corresponding flds to HHMMSS flds              ****/
   /* *** note: flds defined for use of HHMM also             ****/
   /* ************************************************************/

  X3CREC.X3CTIME = VGVar.currentFormattedTime;

  X3CREC.X3CCURHH = X3CREC.X3CTIMHH;
  X3CREC.X3CCURMM = X3CREC.X3CTIMMM;
  X3CREC.X3CCURSS = X3CREC.X3CTIMSS;

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSX3CTM

// trans status query utility
Function XSXC470()
   /* ****************************************************/
   /* * THIS STATEMENT GROUP RETURNS TRANSACTION STATUS **/
   /* * BY CALLING CICS PROGRAM XC0470 AND GIVING THE   **/
   /* * APPLICATION ID YOU WILL BE TRANSFERRING TO..    **/
   /* * THE PARAMETER RECORD USED BY THIS ROUTINE IS THE**/
   /* * UT3REC.  RETURN CODE VALUES ARE AS FOLLOWS...   **/
   /* *    0 = transaction enabled                      **/
   /* *    1 = transaction disabled in CICS             **/
   /* *    2 = transaction not defined in CICS PCT Tble **/
   /* *    3 = OPEN, not used by XC0470                 **/
   /* *    4 = PGM not in LOADLIB or Disabled in CICS   **/
   /* *    9 = internal error                           **/
   /* *-------------------------------------------------**/
   /* * (REQUIRED CODING FOR ALL WHO USE THIS ROUTINE)  **/
   /* * before calling this statement group, you must   **/
   /* * 1)set ut3rec empty, 2)move the name of the appl **/
   /* * you are transferring to to ut3rec.catoap and    **/
   /* * 3)place ut3rec in your appl table & record list.**/
   /* *-------------------------------------------------**/
   /* * (ADDITIONAL CODING FOR ALL WHO USE XSEXIT)      **/
   /* * if you are using xsexit, you need to insure     **/
   /* * that code is provided to display the message in **/
   /* * the 'commarea.camsg' data item on your screen   **/
   /* * after the xsexit statement in your application  **/
   /* * if commarea.casecrc is not equal to zero.       **/
   /* *-------------------------------------------------**/
   /* *(ADDITIONAL CODING FOR ALL WHO DO NOT USE XSEXIT)**/
   /* * if you do not use xsexit, but perform xfer or   **/
   /* * dxfr yourself, you will need to move the name   **/
   /* * of the process or statement group in control at **/
   /* * the time XSXC470 is called to commarea.xxxprcnm.**/
   /* * next, check commarea.casecrc for non-zero.  if  **/
   /* * so, move commare.camsg to a screen to display it**/
   /* ****************************************************/
   /* MAINTENANCE HISTORY*/
   /*  */
   /* DATE   USERID  COMMENTS*/
   /* 12/07/89 jwood   orig specs*/
   /* 07/23/93 jcambp  added mnw-is-it-eze test logic*/
   /* 10/18/93 vcowan  Corrected ERROR Statement Descriptions*/
   /* per pgm xc0470*/
   /* 03/17/94 vcowan  logic chg: if ut3retcd =(1, 2, or 4)*/
   /* and ezesegtr = 'eze', then bypass*/
   /* production error checking.  When*/
   /* AD TESTING, ezesegtr = 'eze'.*/
   /* 09/24/97 vcowan  Correction: comment for error code 4*/
   /* ... see above*/
   /* ****************************************************/


  call "XC0470" (UT3REC) {isNoRefresh = yes, isExternal = yes};

  MNWREC.MNW-EZESEGTR = sysVar.transactionID;
  if (UT3REC.UT3RETCD == "0"
   || (UT3REC.UT3RETCD == "1" && MNWREC.MNW-IS-IT-EZE == "EZE")
   || (UT3REC.UT3RETCD == "2" && MNWREC.MNW-IS-IT-EZE == "EZE")
   || (UT3REC.UT3RETCD == "4" && MNWREC.MNW-IS-IT-EZE == "EZE"))
    COMMAREA.CAMSG = " ";
    COMMAREA.CASECRC = 0;
  else
    COMMAREA.CASECRC = 4;
    COMMAREA.CAMSGA = "UNABLE TO TRANSFER TO ";
    COMMAREA.CAMTOAP = UT3REC.CATOAP;
    if (UT3REC.UT3RETCD == "1")
      COMMAREA.CAMSGNO = "1I";
      COMMAREA.CAMSGB = ", TRANSACTION DISABLED IN CICS, CALL HOTLINE";
    else
      if (UT3REC.UT3RETCD == "2")
        COMMAREA.CAMSGNO = "2A";
        COMMAREA.CAMSGB = ", TRANSACTION NOT IN CICS PCT TABLE, CALL HOTLINE";
      else
        if (UT3REC.UT3RETCD == "3")
          COMMAREA.CAMSGNO = "3A";
          COMMAREA.CAMSGB = ", SYSTEM ERROR, CALL HOTLINE";
        else
          if (UT3REC.UT3RETCD == "4")
            COMMAREA.CAMSGNO = "4A";
            COMMAREA.CAMSGB = ", PGM NOT FOUND OR DISABLED IN CICS, CALL HOTLINE";
          else
            COMMAREA.CAMSGNO = " A";
            COMMAREA.CAMSGB = ", SYSTEM ERROR, CALL HOTLINE";
          end
        end
      end
    end
  end
end // end XSXC470

// x4crec - translate byte value
Function XSXLATE()


   /* ************************************************************/
   /* *** if find character found, translate to fill          ****/
   /* ************************************************************/

  if (X4CREC.X4CBYT[X4CCTR] == X4CREC.X4CFND)
    X4CREC.X4CBYT[X4CCTR] = X4CREC.X4CFIL;
  end

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSXLATE

// add : qmf parm row : 0
Function XSXZZA0()


   /* ************************************************************/
   /* *** add unique row to:  qmf parm row                    ****/
   /* *** using the std module:  IO1000                       ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   -803 = adding duplicate row                       ****/
   /* ***   -911 = deadlock - resource unavailable            ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** select unique row                                   ****/
   /* *** note: 0 return code means record already exists     ****/
   /* ***       = setup -803 return code                      ****/
   /* ************************************************************/

  XSXZZI0(); /* <=== select unique row*/

  if (SQLCA.VAGen_SQLCODE == +100)
     /* ** next sentence ***/
  else
    if (SQLCA.VAGen_SQLCODE == 0)
      SQLCA.VAGen_SQLCODE = -803;
      return;
    end
    return;
  end

   /* ************************************************************/
   /* *** insert row (previous +100 = doesn't exist)          ****/
   /* *** note: IO process initializes zzzchgct to 0          ****/
   /* ************************************************************/

  XZZREC.ZZZSDT = X2CREC.X2CCURDT;
  XZZREC.ZZZSTM = X3CREC.X3CCURST;

  call "IO1000" ("A ", SQLCA, XZZREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -911)
    TA1REC.TA1FUNC = "POST";
  else
    TA1REC.TA1FUNC = "RETN";
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1PGMNM = "XSXZZA0 ";
  TA1REC.TA1LOCAT[1] = "IO1000  ";
  TA1REC.TA1LOCAT[3] = "ADD     ";
  TA1REC.TA1LOCAT[4] = "ROW     ";
  TA1REC.TA1DBASE = "DCORP   ";
  TA1REC.TA1TBLVU = "VPARM101";
  TA1REC.TA1TBLKE = XZZREC.XZZKEYGP;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSXZZA0

// delete : qmf parm row : 0
Function XSXZZD0()


   /* ************************************************************/
   /* *** delete unique row in:  receiving log itm            ****/
   /* *** using the std module:  IO1000                       ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   +100 = not fnd                                    ****/
   /* ***   -911 = deadlock - resource unavailable            ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** delete row                                          ****/
   /* ************************************************************/

  call "IO1000" ("D ", SQLCA, XZZREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -911)
    TA1REC.TA1FUNC = "POST";
  else
    TA1REC.TA1FUNC = "RETN";
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1PGMNM = "XSXZZD0 ";
  TA1REC.TA1LOCAT[1] = "IO1000  ";
  TA1REC.TA1LOCAT[3] = "DELETE  ";
  TA1REC.TA1LOCAT[4] = "ROW     ";
  TA1REC.TA1DBASE = "DCORP   ";
  TA1REC.TA1TBLVU = "VPARM101";
  TA1REC.TA1TBLKE = XZZREC.XZZKEYGP;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSXZZD0

// inquiry : qmf parm row : 0
Function XSXZZI0()


   /* ************************************************************/
   /* *** select unique row from:  qmf parm row               ****/
   /* *** using the std module:  IO1000                       ****/
   /* *** return codes:                                       ****/
   /* ***      0 = successful                                 ****/
   /* ***   +100 = not found                                  ****/
   /* ***   -811 = duplicates found                           ****/
   /* ***   -911 = deadlock - resource unavailable            ****/
   /* ***     <0 = db/severe error                            ****/
   /* ***          note: TA0020 will be executed              ****/
   /* ************************************************************/

   /* ************************************************************/
   /* *** select unique row                                   ****/
   /* ************************************************************/

  call "IO1000" ("S ", SQLCA, XZZREC) {isNoRefresh = yes, isExternal = yes};

  if (SQLCA.VAGen_SQLCODE == 0)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == +100)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -811)
    return;
  end

  if (SQLCA.VAGen_SQLCODE == -911)
    TA1REC.TA1FUNC = "POST";
  else
    TA1REC.TA1FUNC = "RETN";
  end

  TA1REC.TA1TYPE = "DB2 ";
  TA1REC.TA1PGMNM = "XSXZZI0 ";
  TA1REC.TA1LOCAT[1] = "IO1000  ";
  TA1REC.TA1LOCAT[3] = "SELECT  ";
  TA1REC.TA1LOCAT[4] = "UNIQUE  ";
  TA1REC.TA1DBASE = "DCORP   ";
  TA1REC.TA1TBLVU = "VPARM101";
  TA1REC.TA1TBLKE = XZZREC.XZZQRYID;
  move SQLCA to ERRSQLCA withV60Compat;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  call "TA0020" (TA1REC, ERRSQLCA) {isExternal = yes};

   /* ************************************************************/
   /* *** end of STATEMENT GROUP                              ****/
   /* ************************************************************/


end // end XSXZZI0

// convert system date and time
Function XX0XS01()

     /* convert system date to yyyymmdd*/

  XX0XW01.XX0XWZDT = VGVar.currentShortGregorianDate; /* get system date*/

   /* IF statement added to handle year 2000 thru 2052*/
   /* 12-28-95  vcowan  software enginnering group*/
   /* 04-18-96  vcowan  installed into all LPARS*/

  if (XX0XW01.XX0XWZYY < 57) /* check year*/
    XX0XW01.XX0XW19 = 20; /* century*/
  else
    XX0XW01.XX0XW19 = 19; /* century*/
  end

  XX0XW01.XX0XWYY = XX0XW01.XX0XWZYY; /* year*/
  XX0XW01.XX0XWMM = XX0XW01.XX0XWZMM; /* month*/
  XX0XW01.XX0XWDD = XX0XW01.XX0XWZDD; /* day*/

     /* convert system time to hhmm, hhmmss*/

  XX0XW01.XX0XWZTM = VGVar.currentFormattedTime; /* get system time*/
  XX0XW01.XX0XWHR = XX0XW01.XX0XWZHR; /* hours*/
  XX0XW01.XX0XWHRS = XX0XW01.XX0XWZHR; /* hours*/
  XX0XW01.XX0XWMIN = XX0XW01.XX0XWZMN; /* minutes*/
  XX0XW01.XX0XWMNS = XX0XW01.XX0XWZMN; /* minutes*/
  XX0XW01.XX0XWSEC = XX0XW01.XX0XWZSC; /* seconds*/

end // end XX0XS01

