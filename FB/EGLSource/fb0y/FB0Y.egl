package fb0y;

import corpcom2.XX0XW01;
import corpcom2.XX0XW02;
import corpcom3.XPFB001;
import corpcom4.XSFBS01;
import corpcom4.XSPG202;
import corpcom4.XSPG301;
import corpcom4.XX0XS01;
import corpcom5.COMMAREA;
import corpcom5.ERRSQLCA;
import corpcom6.SQLCA;
import corpcom7.XXXMSGNO;
import corpx1.XDMCD;
import corpx1.XWHTBL;
import corpx2.XPGCD;
import corpx2.XQACD;
import corpx2.XUMCD;
import corpx2.XWHCD;
import fb.common.FB7REC;
import fb.common.FB7RTADT;
import fb.common.FB7RTAPC;
import fb.common.FB8BUYDT;
import fb.common.FB9REC;
import fb.common.FBEREC;
import fb.common.FBFREC;
import fb.common.FBLREC;
import fb.common.FBMREC;
import fb.common.FBWREC;
import fb.common.FBXREC;
import fy.common.FY1FCTYC;
import fy.common.FY2MFGPC;
import pc.common.PC2INSEG;
import pg.common.PG1REC;
import pg.common.PG2REC;
import pg.common.PG3REC;
import sy.common.SY1SSTNM;
import sy.common.SY1STNBR;
import sy.common.SY2CLRAB;
import sy.common.SY2CLRID;
import ta.common.TA1REC;
import ta.common.TA1TBLKE;
import ta.common.TA2REC;
import ta.common.TA5REC;
import ta.common.TA6REC;
import ta.common.TAEREC;
//*** PROGRAM=FB0Y ****
// This program is part of the footwear buy system.
// This application provides the capability of moving
// quantities by size from one RTA date to another RTA date for
// a specific warehouse and product.  Product,warehouse, "from'
// and 'to' RTA dates are selected in FB02 or FB0x and passed
// to this application through the commarea or entered by the
// user.  The application selects the size information from the
// RTA/size/region RTA table and stores the data in temporary
// storage.  After the data is stored in temporary storage, the
// application retrieves and formats the data from temporary
// storage and displays the map.  The user has the option of
// moving any size quantities from the 'from' RTA date to the
// 'to' rta date size quantities.  After all desired changes
// have been made, the user presses enter.  The application
// then makes the desired adjustments, recalculates the total
// size quantities fro each RTA date and redisplays the map.
// Whenever an update occurs, the RTA/Size/Region quantity
// to buy and merged quantity to buy tables are updated.
// 
// PF10 and PF11 are provided to shift left and right to view
// all sizes.  In addition, the number of sizes to be scrolled
// may be entered.  The default is ten.
// 
// The user may exit to any allowed application via fast path
// or PF keys.
// 
//   DATE      NAME    DESCRIPTION OF CHANGE
// --------   ------   ----------------------------------------
// 11/14/89   CPROGM   Created.
// 08/27/90   jalle1   Check for contention due to merge before
//                     update any db2 tables (dhermm request)
// 10/09/91   jalle1   oct '91 tbl chgs - fix fb0yw04 to
//                     = length of fb7rec.
// 03/18/93   ldeluh   Use units per case from syclr for round
//                     ing instead of hardcoded 6.
// 08/27/93   ldeluh   Change some iomod calls for csp v4.
// 12/02/94   PMAINW   RE-COMPILE FOR TABLE CHANGE (VFSCTL01)
// CONTROL   DATE    NAME  DESCRIPTION OF CHANGE
// ------- -------- ------ ------------------------------------
// Y2KFIX  01/09/97 WSQUIR MODIFICATIONS MADE TO: FB0YS11
// *********************
Program FB0Y type textUIProgram //VAGen Info - main text program
  {
  includeReferencedFunctions = yes, allowUnqualifiedItemReferences = yes, 
  throwNrfEofExceptions = yes, handleHardIOErrors = no, V60ExceptionCompatibility = yes, 
  I4GLItemsNullable = no, textLiteralDefaultIsString = no, localSQLScope = yes, 
  msgTablePrefix = "FF00", inputRecord = COMMAREA, segmented = yes
  }

  // Data Declarations
  COMMAREA COMMAREA ; // record
  ERRSQLCA ERRSQLCA; // record
  FB0YW00 FB0YW00; // record
  FB0YW01 FB0YW01; // record
  FB0YW02 FB0YW02; // record
  FB0YW03 FB0YW03; // record
  FB0YW04 FB0YW04; // record
  FB7REC FB7REC; // record
  FB9REC FB9REC; // record
  FBEREC FBEREC; // record
  FBFREC FBFREC; // record
  FBLREC FBLREC; // record
  FBMREC FBMREC; // record
  FBWREC FBWREC; // record
  FBXREC FBXREC; // record
  PG1REC PG1REC; // record
  PG2REC PG2REC; // record
  PG3REC PG3REC; // record
  SQLCA SQLCA; // record
  TA1REC TA1REC; // record
  TA2REC TA2REC; // record
  TA5REC TA5REC; // record
  TA6REC TA6REC; // record
  TAEREC TAEREC; // record
  XX0XW01 XX0XW01; // record
  XX0XW02 XX0XW02; // record

  // VAGen Info - items needed for migration
  VAGen_EZESYS char(8);
  VAGen_EZEREPLY num(1);
  VAGen_EZE_WAIT_TIME bin(9,2);
  VAGen_EZE_ITEMLEN int;

  // Use Declarations
  use XWHTBL; // table
  use FB0YM.FB0YM010 // form
   {
    pfKeyEquate = no
  };

  function main()
    // VAGen Info - initialization needed for migration
    VAGen_EZESYS = VGLib.getVAGSysType();
    XPFB001: XPFB001();
    goto FB0Y001;
    FB0Y001: FB0Y001();
     /* ------------------------------------------------------------*/
     /* Flow to converse the RTA maintenance - size qty moves*/
     /* ------------------------------------------------------------*/
    ;
    goto FB0Y002; /* Converse RTA main size qty moves*/
    ;
    ;
    FB0Y002: FB0Y002();
    goto FB0Y002;
  end // end main
end // end FB0Y

// footwear forecasting main menu
Function FB0Y001()
  ;
   /* ---------------------------------------------------------*/
   /* If entry is from the footwear buy system move the*/
   /* fill area in the FBWREC to the FBXREC*/
   /* ---------------------------------------------------------*/
  ;
  if (COMMAREA.CAFROMAP == "FB0A"
   || COMMAREA.CAFROMAP == "FB0B"
   || COMMAREA.CAFROMAP == "FB0C"
   || COMMAREA.CAFROMAP == "FB0D"
   || COMMAREA.CAFROMAP == "FB0E"
   || COMMAREA.CAFROMAP == "FB0G"
   || COMMAREA.CAFROMAP == "FB0I"
   || COMMAREA.CAFROMAP == "FB0J"
   || COMMAREA.CAFROMAP == "FB0K"
   || COMMAREA.CAFROMAP == "FB0L"
   || COMMAREA.CAFROMAP == "FB0N"
   || COMMAREA.CAFROMAP == "FB0O"
   || COMMAREA.CAFROMAP == "FB0P"
   || COMMAREA.CAFRMSYS != "FB")
    set FBWREC empty;
    set FBXREC empty;
    FBWREC.FBWFILL = FBXREC.FBXGROUP;
  else
    FBXREC.FBXGROUP = FBWREC.FBWFILL;
  end
  ;
  ;
   /* ---------------------------------------------------------*/
   /* Initialize the work record and the map storage record.*/
   /* Set obtain data flag to yes.*/
   /* ---------------------------------------------------------*/
  ;
  set FB0YW00 empty; /* Working storage record*/
  set FB0YW01 empty; /* Map storage for map heading data*/
  set FB0YW02 empty; /* From data storage*/
  set FB0YW03 empty; /* To data storage*/
  set FB0YW04 empty; /* Merged qty storage*/
  ;
  set FB0YM010 empty;
  ;
  set SQLCA empty;
  set TAEREC empty; /* Error diagnosis information*/
  set TA1REC empty; /* Error diagnosis parameters*/
  FB0YW01.FB0YWSZS = 10; /* Default size screen scroll*/
  FB0YW00.FB0YWCSI = 1; /* current size index*/
  FB0YW00.FB0YWFSI = 1; /* last size index*/
  FB0YW00.FB0YWLSI = 40; /* last size index*/
  ;
   /* ---------------------------------------------------------*/
   /* If data has been passed in the FBXREC than load the*/
   /* data to display storage--and set the obtain data flag*/
   /* to yes.*/
   /* ---------------------------------------------------------*/
  ;
  if (FBXREC.SY1STNBR[1] != " ") /* Data has been passed*/
    FB0YW00.FB0YWRDF = "Y"; /* Request for data flag*/
    FB0YW01.SY1STNBR = FBXREC.SY1STNBR[1];
    FB0YW00.SY1STNBR = FBXREC.SY1STNBR[1];
    FB0YW01.SY2CLRID = FBXREC.SY2CLRID[1];
    FB0YW00.SY2CLRID = FBXREC.SY2CLRID[1];
    FB0YW01.XDMCD = FBXREC.XDMCD[1];
    FB0YW00.XDMCD = FBXREC.XDMCD[1];
    FB0YW01.XWHCD = FBXREC.XWHCD1[1];
    FB0YW00.FB8BUYDT = FBXREC.FB8BUYDT;
    FB0YW02.FB7RTADT = FBXREC.FBXFRMDT;
    FB0YW01.FB0YWFRT = FBXREC.FBXFRMDT;
    FB0YW00.FB0YWFDT = FBXREC.FBXFRMDT;
    FB0YW00.FB0YWRYY = FB0YW00.FB0YWFYY;
    FB0YW00.FB0YWRMM = FB0YW00.FB0YWFMM;
    FB0YW00.FB0YWRDD = FB0YW00.FB0YWFDD;
    FB0YW02.FB0YWFRD = FB0YW00.FB0YWRTA;
    ;
    FB0YW03.FB7RTADT = FBXREC.FBXTODT;
    FB0YW01.FB0YWTRT = FBXREC.FBXTODT;
    FB0YW00.FB0YWFDT = FBXREC.FBXTODT;
    FB0YW00.FB0YWRYY = FB0YW00.FB0YWFYY;
    FB0YW00.FB0YWRMM = FB0YW00.FB0YWFMM;
    FB0YW00.FB0YWRDD = FB0YW00.FB0YWFDD;
    FB0YW03.FB0YWTRD = FB0YW00.FB0YWRTA;
    set PG2REC empty; /* Initialize style color record*/
    ;
    PG2REC.SY1STNBR = FBXREC.SY1STNBR[1];
    PG2REC.SY2CLRID = FBXREC.SY2CLRID[1];
    PG2REC.XDMCD = FBXREC.XDMCD[1];
    PG2REC.XGPCD = "02";
    ;
    XSPG202(); /* Obtain style color table row*/
    ;
    if (SQLCA.VAGen_SQLCODE == 0)
      FB0YW01.SY1SSTNM = PG2REC.SY1SSTNM;
      FB0YW01.SY2CLRAB = PG2REC.SY2CLRAB;
    end
  else
    FB0YM010.SY2CLRID = "00 ";
    FB0YW01.SY2CLRID = "00 ";
    FB0YM010.XDMCD = "00";
    FB0YW01.XDMCD = "00";
    ;
    set FB0YM010.FB0YMTRD protect;
    set FB0YM010.FB0YMSZS protect;
    FB0YW00.FB0YWFPF = "Y"; /* Fastpath flag*/
    converseLib.validationFailed(327); /* ; can't fastpath to application*/
    return;
    ;
  end
  ;
   /* ---------------------------------------------------------*/
   /* Get autoload flag for scheduler.*/
   /* ---------------------------------------------------------*/
  ;
  FB0YW00.FB0YWISF = "N"; /* Invalid scheduler flag*/
  ;
  FB0YS08(); /* Obtain Vsuser01 row*/
  ;
  FB0YS09(); /* Obtain VFsctl01 row*/
  ;
  if (FB0YW00.FB0YWISF == "Y")
    converseLib.validationFailed(62);
  end
  ;
end // end FB0Y001

// Footwear products to buy
Function FB0Y002()
  ;
   /* ------------------------------------------------------------*/
   /* This is the main process used to display a map.  Processing*/
   /* always returns to the top of this process and falls through*/
   /* subordinate processes until an error is found or a valid*/
   /* request is processed.  Processing sequence is as follows:*/
  ;
   /* 1) Obtain data to disply*/
   /* 2) Format the map output area and display the map.*/
   /* 3) Check the attention identifier used to respond.*/
   /* 4) Reset highlighted fields to normal intensity.*/
   /* 5) Verify the data that was entered.*/
   /* 6) Process a valid input request.*/
  ;
   /* In all subordinate processes, "EZEFLO" is used to exit to*/
   /* redisplay the map when an error is found.  This is done to*/
   /* minimize the coding effort required to skip subsequent*/
   /* processing under error conditions.*/
   /* ------------------------------------------------------------*/
  ;
  ;
  FB0Y100(); /* Obtain data to display*/
  ;
  FB0Y200(); /* Format and display the map*/
  ;
  FB0Y300(); /* Check attention identifier*/
  ;
  FB0Y400(); /* Reset fields to normal intensity*/
  ;
  FB0Y500(); /* Verify the entered data*/
  ;
  FB0Y600(); /* Process valid input request*/
  ;
end // end FB0Y002

// Obtain data to display
Function FB0Y100()
  ;
  ;
   /* ------------------------------------------------------------*/
   /* If an error was found or data not requested return to*/
   /* previous process.*/
   /* ------------------------------------------------------------*/
  ;
  if (FB0YW00.FB0YWRDF != "Y" /* Data not requested*/
   || converseVar.validationMsgNum != 0) /* Error found*/
    return;
  end
  ;
  move "N" to FB0YW00.FB0YWZHD[1] for all; /* Init size has data array to no*/
  move " " to FB0YW01.FB0YWSZD[1] for all; /* Init size description array*/
  FB0YW01.FB0YWFAA = 0; /* adjust amount*/
  ;
   /* ------------------------------------------------------------*/
   /* Get the from RTA row from the DFBUY.VRTQTB01 table.*/
   /* ------------------------------------------------------------*/
  ;
  set FBFREC empty; /* Initialize record*/
  ;
  FBFREC.SY1STNBR = FB0YW01.SY1STNBR;
  FBFREC.SY2CLRID = FB0YW01.SY2CLRID;
  FBFREC.XDMCD = FB0YW01.XDMCD;
  FBFREC.FB8BUYDT = FB0YW00.FB8BUYDT;
  FBFREC.FB7RTADT = FB0YW01.FB0YWFRT;
  FBFREC.XWHCD = FB0YW01.XWHCD;
  FBFREC.PC2CUXID = " ";
  ;
  ;
  FB0Y110(); /* Fetch unique DFBUY.VRTQTB01*/
  ;
  if (SQLCA.VAGen_SQLCODE == 100) /* Row not found*/
    FB0YW00.XXXMSGNO = 18; /* No data to display*/
    FB0YM010.XXXPRCNM = "FB0Y100";
    return;
  end
  ;
  FB0YW01.XQACD = FBFREC.XQACD;
  FB0YW01.XPGCD = FBFREC.XPGCD;
  FB0YW01.XUMCD = FBFREC.XUMCD;
  FB0YW01.PC2INSEG = FBFREC.PC2INSEG;
  ;
   /* ------------------------------------------------------------*/
   /* move FBFREC size qty array to the working storage from*/
   /* record current qty array and from adjust qty array*/
   /* ------------------------------------------------------------*/
  ;
  set FB0YW02 empty;
  ;
  move FBFREC.FB7QTB to FB0YW02.FB0YWFCQ[1] for all;
  move FBFREC.FB7QTB to FB0YW02.FB0YWFAQ[1] for all;
  FB0YW02.FB7RTADT = FBFREC.FB7RTADT;
  FB0YW02.FB7RTAPC = FBFREC.FB7RTAPC;
  FB0YW00.FB0YWFDT = FBFREC.FB7RTADT;
  FB0YW00.FB0YWRYY = FB0YW00.FB0YWFYY;
  FB0YW00.FB0YWRMM = FB0YW00.FB0YWFMM;
  FB0YW00.FB0YWRDD = FB0YW00.FB0YWFDD;
  FB0YW02.FB0YWFRD = FB0YW00.FB0YWRTA;
  FB0YW02.FB0YWFRC = FBFREC.FBFGROUP;
  ;
   /* ------------------------------------------------------------*/
   /* accumulate all of the size quantities into the from row*/
   /* total quantity.  Also set the working storage flag*/
   /* indicating the size has data.*/
   /* ------------------------------------------------------------*/
  ;
  FB0YW00.FB0YWIX1 = 1;
  ;
  while (FB0YW00.FB0YWIX1 <= 40)
    if (FBFREC.FB7QTB[FB0YWIX1] != 0)
      FB0YW00.FB0YWZHD[FB0YWIX1] = "Y"; /* size has data*/
    end
    FB0YW02.FB0YWFTQ = FB0YW02.FB0YWFTQ + FBFREC.FB7QTB[FB0YWIX1];
    FB0YW02.FB0YWFCT = FB0YW02.FB0YWFCT + FBFREC.FB7QTB[FB0YWIX1];
    FB0YW02.FB0YWFAT = FB0YW02.FB0YWFAT + FBFREC.FB7QTB[FB0YWIX1];
    FB0YW00.FB0YWIX1 = FB0YW00.FB0YWIX1 + 1;
  end
  ;
  ;
  ;
   /* ------------------------------------------------------------*/
   /* If the to RTA row was not passed in the FBXREC--display*/
   /* a message and ezertn to display map.*/
   /* ------------------------------------------------------------*/
  ;
  if (FB0YW01.FB0YWTRT == 0)
    FB0YW00.XXXMSGNO = 309;
    set FB0YM010.FB0YMTRD cursor;
  end
  ;
   /* ------------------------------------------------------------*/
   /* Get the to RTA row from the DFBUY.VRTQTB01 table.*/
   /* ------------------------------------------------------------*/
  ;
  set FBFREC empty; /* Initialize record*/
  ;
  if (FB0YW01.FB0YWTRT != 0)
    ;
    FBFREC.SY1STNBR = FB0YW01.SY1STNBR;
    FBFREC.SY2CLRID = FB0YW01.SY2CLRID;
    FBFREC.XDMCD = FB0YW01.XDMCD;
    FBFREC.FB8BUYDT = FB0YW00.FB8BUYDT;
    FBFREC.FB7RTADT = FB0YW01.FB0YWTRT;
    FBFREC.XWHCD = FB0YW01.XWHCD;
    FBFREC.PC2CUXID = " ";
    ;
    ;
    FB0Y110(); /* Fetch unique DFbuy.Vrtqtb01*/
    ;
    if (SQLCA.VAGen_SQLCODE == 100) /* Row not found*/
      FB0YM010.FB0YMTRD = FB0YW00.FB0YWTRD;
      FB0YW00.XXXMSGNO = 310; /* To row doesn't exist*/
      set FB0YM010.FB0YMTRD cursor;
    end
  end
   /* ------------------------------------------------------------*/
   /* move FBFREC size qty array to the working storage from*/
   /* record current qty array.*/
   /* ------------------------------------------------------------*/
  ;
  set FB0YW03 empty;
  ;
  if (SQLCA.VAGen_SQLCODE == 0)
    move FBFREC.FB7QTB to FB0YW03.FB0YWTCQ[1] for all;
    move FBFREC.FB7QTB to FB0YW03.FB0YWTAQ[1] for all;
    FB0YW03.FB7RTAPC = FBFREC.FB7RTAPC;
    FB0YW03.FB7RTADT = FBFREC.FB7RTADT;
    FB0YW00.FB0YWFDT = FBFREC.FB7RTADT;
    FB0YW00.FB0YWRYY = FB0YW00.FB0YWFYY;
    FB0YW00.FB0YWRMM = FB0YW00.FB0YWFMM;
    FB0YW00.FB0YWRDD = FB0YW00.FB0YWFDD;
    FB0YW03.FB0YWTRD = FB0YW00.FB0YWRTA;
    FB0YW03.FB0YWTRC = FBFREC.FBFGROUP;
    ;
    /* ------------------------------------------------------------*/
     /* accumulate all of the size quantities into the to row*/
     /* total quantity.  Also set the working storage flag*/
     /* indicating the size has data.*/
    /* ------------------------------------------------------------*/
    ;
    FB0YW00.FB0YWIX1 = 1;
    ;
    while (FB0YW00.FB0YWIX1 <= 40)
      if (FBFREC.FB7QTB[FB0YWIX1] != 0)
        FB0YW00.FB0YWZHD[FB0YWIX1] = "Y"; /* size has data*/
      end
      FB0YW03.FB0YWTTQ = FB0YW03.FB0YWTTQ + FBFREC.FB7QTB[FB0YWIX1];
      FB0YW03.FB0YWTAT = FB0YW03.FB0YWTAT + FBFREC.FB7QTB[FB0YWIX1];
      FB0YW03.FB0YWTCT = FB0YW03.FB0YWTCT + FBFREC.FB7QTB[FB0YWIX1];
      FB0YW00.FB0YWIX1 = FB0YW00.FB0YWIX1 + 1;
    end
  end
  ;
   /* ------------------------------------------------------------*/
   /* Get the round flag on the frozen bottom line table*/
   /* ------------------------------------------------------------*/
  ;
  FB0YS11();
  ;
   /* ------------------------------------------------------------*/
   /* Get the size descriptions for the product*/
   /* ------------------------------------------------------------*/
  ;
  FB0Y120(); /* Get the size description*/
  ;
   /* ------------------------------------------------------------*/
   /* Based upon whether a size has data or a description for*/
   /* this product set the first and last size index fields*/
   /* ------------------------------------------------------------*/
  ;
   /* Find first size index*/
  ;
  FB0YW00.FB0YWIX1 = 1;
  ;
  while (FB0YW00.FB0YWIX1 <= 40)
    ;
    if (FB0YW00.FB0YWZHD[FB0YWIX1] == "Y") /* Size has data or desc*/
      FB0YW00.FB0YWFSI = FB0YW00.FB0YWIX1;
      FB0YW00.FB0YWIX1 = 41;
    end
    FB0YW00.FB0YWIX1 = FB0YW00.FB0YWIX1 + 1;
  end
  ;
  ;
   /* Find last size index*/
  ;
  FB0YW00.FB0YWIX1 = FB0YW00.FB0YWFSI;
  ;
  while (FB0YW00.FB0YWIX1 <= 40)
    ;
    if (FB0YW00.FB0YWZHD[FB0YWIX1] == "Y") /* Size has data or desc*/
      FB0YW00.FB0YWLSI = FB0YW00.FB0YWIX1;
    end
    FB0YW00.FB0YWIX1 = FB0YW00.FB0YWIX1 + 1;
  end
  ;
  ;
   /* Calculate number of size buckets to display*/
  ;
  FB0YW00.FB0YWSZB = FB0YW00.FB0YWLSI - FB0YW00.FB0YWFSI;
  ;
  FB0YW00.FB0YWCSI = FB0YW00.FB0YWFSI; /* Current size index*/
  ;
   /* ------------------------------------------------------------*/
   /* compute the total RTA quantity*/
   /* 1. add the from and the to total quantities*/
   /* 2. add the from and the to percents*/
   /* divide #1 by #2*/
   /* ------------------------------------------------------------*/
  ;
  FB0YW00.FB0YWWF1 = FB0YW02.FB0YWFTQ + FB0YW03.FB0YWTTQ;
  FB0YW00.FB0YWWD1 = FB0YW02.FB7RTAPC + FB0YW03.FB7RTAPC;
  FB0YW00.FB0YWWD1 = FB0YW00.FB0YWWD1 / 100;
  FB0YW00.FB0YWUQT = FB0YW00.FB0YWWF1 / FB0YW00.FB0YWWD1;
  ;
  if (FBLREC.FBKRDFL == "N")
    FB0YW00.FB0YWTRQ = FB0YW00.FB0YWUQT;
  else
      /* Round to nearest multiple of 6*/
    ;
    FB0YW00.FB0YWDIV = FB0YW00.FB0YWUQT / 6;
    ;
    if (FB0YW00.FB0YWREM > .50)
      FB0YW00.FB0YWDIV = FB0YW00.FB0YWDIV + 1;
    end
    ;
    FB0YW00.FB0YWTRQ = FB0YW00.FB0YWINT * 6;
  end
  ;
   /* ------------------------------------------------------------*/
   /* Obtain the control record to get the tolerance qty.*/
   /* ------------------------------------------------------------*/
  ;
  FB0YS10(); /* Get control row*/
  ;
  FB0YW00.FB0YWRDF = "N"; /* Data not requested*/
  ;
  ;
  ;
end // end FB0Y100

// Obtain Unique VRTQTB01 row
Function FB0Y110()
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Obtain unique DFBUY.VRTQTB01*/
   /* ------------------------------------------------------------*/
  ;
  try
    call "IO4620" ("S ", SQLCA, FBFREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/
  ;
  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0 /* and normal return code*/
     || SQLCA.VAGen_SQLCODE == 100) /* row not found*/
      return;
    end
    return;
  end
  ;
  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(19); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(01); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end
  ;
  ;
  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "FB0Y110"; /* Process name*/
  TA1REC.TA1LOC = "OBTAIN UNIQUE           ";
  TA1REC.TA1DBASE = "DFBUY   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VRTQTB01"; /* Table view name*/
  ;
  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/
  ;
  FB0YM010.XXXPRCNM = "FB0Y110";
  exit stack;
  ;
end // end FB0Y110

// Get size descriptions
Function FB0Y120()
  ;
   /* ---------------------------------------------------------*/
   /* Initialize the record and format the key*/
   /* ---------------------------------------------------------*/
  ;
  set PG3REC empty;
  ;
  PG3REC.XGPCD = "02";
  PG3REC.SY1STNBR = FB0YW01.SY1STNBR;
  PG3REC.SY2CLRID = FB0YW01.SY2CLRID;
  PG3REC.XDMCD = FB0YW01.XDMCD;
  PG3REC.XQACD = "**"; /* Get either A or B grade sizes*/
  PG3REC.PG3FUNCD = "PC";
  PG3REC.PG3DATFM = "N";
  PG3REC.PG3XDVCD = PG2REC.XDVCD1;
  ;
  XSPG301(); /* Get valid sizes*/
  ;
  ;
   /* ---------------------------------------------------------*/
   /* Load size descriptions to table in storage*/
   /* ---------------------------------------------------------*/
  ;
  FB0YW00.FB0YWIX1 = 1; /* Initialize index*/
  ;
  while (FB0YW00.FB0YWIX1 <= 40) /* Check all 40 sizes*/
    ;
    if (PG3REC.SY4IDDSC[FB0YWIX1] != " ")
      FB0YW01.FB0YWSZD[FB0YWIX1] = PG3REC.SY4IDDSC[FB0YWIX1];
      FB0YW00.FB0YWZHD[FB0YWIX1] = "Y"; /* Size has desc or data flag*/
    end
    FB0YW00.FB0YWIX1 = FB0YW00.FB0YWIX1 + 1;
  end
  ;
  ;
end // end FB0Y120

// Format and display map 1
Function FB0Y200()
  ;
  ;
  if (converseVar.validationMsgNum != 0)
    set FB0YM010 alarm; /* Indicate sound alarm*/
  end
  ;
   /* -----------------------------------------------------------*/
   /* If no data found clear the map.*/
   /* set adjusted fields protected and dark*/
   /* -----------------------------------------------------------*/
  ;
  if (FB0YW00.XXXMSGNO == 18) /* No data to display*/
    ;
    set FB0YM010 initial;
    FB0YW00.FB0YWIXM = 1;
    while (FB0YW00.FB0YWIXM <= 10)
      set FB0YM010.FB0YMFAJ[FB0YWIXM] skip, invisible;
      FB0YW00.FB0YWIXM = FB0YW00.FB0YWIXM + 1;
    end
  end
  ;
   /* -----------------------------------------------------------*/
   /* If size scroll requested reload data*/
   /* -----------------------------------------------------------*/
  ;
  if (FB0YW00.FB0YWSSR == "Y") /* Size scroll requested*/
    FB0YW00.FB0YWSSR = "N";
    set FB0YM010 initial;
    ;
    FB0Y210(); /* Format map 1 data*/
    ;
  end
  ;
   /* -----------------------------------------------------------*/
   /* If map is not formatted--format heading data*/
   /* -----------------------------------------------------------*/
  ;
  if (FB0YM010.XXXCURDT == 0) /* Map not formatted*/
    ;
    FB0Y210(); /* Format map 1 data*/
    ;
  end
  ;
  FB0YM010.XXXCURDT = VGVar.currentShortGregorianDate; /* Current date*/
  ;
   /* -----------------------------------------------------------*/
   /* Position cursor if no errors*/
   /* -----------------------------------------------------------*/
  ;
  if (FB0YW00.XXXMSGNO != 0) /* Contains informational message*/
    if (FB0YW00.XXXMSGNO == 9999)
      converseLib.validationFailed();
    else
      converseLib.validationFailed(FB0YW00.XXXMSGNO);
    end
  end
  ;
  if (converseVar.validationMsgNum == 0)
    set FB0YM010.FB0YMFAJ[1] cursor;
  end
  ;
   /* -----------------------------------------------------------*/
   /* If the to RTA date was not found--and data has been*/
   /* loaded for the from--all of the adjust fields should*/
   /* be protected.*/
   /* -----------------------------------------------------------*/
  ;
  if (FB0YW00.XXXMSGNO == 310) /* To row not found*/
    set FB0YM010.FB0YMSZS protect;
    FB0YM010.FB0YMTRD = FB0YW00.FB0YWTRD;
    FB0YW00.FB0YWIXM = 1; /* map size index*/
    ;
    while (FB0YW00.FB0YWIXM <= 10) /* Max sizes on map*/
      set FB0YM010.FB0YMFAJ[FB0YWIXM] initialAttributes;
      FB0YW00.FB0YWIXM = FB0YW00.FB0YWIXM + 1;
    end
  end
  ;
  ;
  ;
  ;
  FB0YM010.XXXPRCNM = "FB0Y"; /* Process number*/
  ;
  converse FB0YM010 ;
  ;
   /* -----------------------------------------------------------*/
   /* Clear the message fields*/
   /* -----------------------------------------------------------*/
  ;
  FB0YW00.XXXMSGNO = 0; /* Message number*/
  FB0YM010.XXXPRCNM = "FB0Y"; /* Process number*/
  ;
end // end FB0Y200

// Format map 1 data
Function FB0Y210()
  ;
   /* ------------------------------------------------------------*/
   /* Move map header from fb0yw01 display storage to the map*/
   /* fields.*/
   /* ------------------------------------------------------------*/
  ;
  ;
  FB0YM010.SY1STNBR = FB0YW01.SY1STNBR;
  FB0YM010.SY2CLRID = FB0YW01.SY2CLRID;
  FB0YM010.XDMCD = FB0YW01.XDMCD;
  FB0YM010.SY1SSTNM = FB0YW01.SY1SSTNM;
  FB0YM010.SY2CLRAB = FB0YW01.SY2CLRAB;
  ;
  FB0YM010.XQACD = FB0YW01.XQACD;
  FB0YM010.PC2INSEG = FB0YW01.PC2INSEG;
  FB0YM010.XPGCD = FB0YW01.XPGCD;
  FB0YM010.XUMCD = FB0YW01.XUMCD;
  FB0YM010.XWHCD = FB0YW01.XWHCD;
  FB0YM010.FB0YMSZS = FB0YW01.FB0YWSZS;
  if (FB0YW02.FB0YWFRD != 0)
    FB0YM010.FB0YMFRD = FB0YW02.FB0YWFRD;
  end
  if (FB0YW03.FB0YWTRD != 0)
    FB0YM010.FB0YMTRD = FB0YW03.FB0YWTRD;
  end
  ;
  ;
  if (FB0YW00.XXXMSGNO == 18) /* No data to display*/
    return;
  end
  ;
   /* ------------------------------------------------------------*/
   /* load size descriptions to map*/
   /* ------------------------------------------------------------*/
  ;
  if (FB0YW01.SY1STNBR != " ")
    ;
    FB0YW00.FB0YWIXM = 1; /* Init map index*/
    FB0YW00.FB0YWIX1 = FB0YW00.FB0YWCSI; /* Current size index*/
    ;
    while (FB0YW00.FB0YWIXM <= 10
     && FB0YW00.FB0YWIX1 <= FB0YW00.FB0YWLSI) /* Last size*/
      if (FB0YW00.FB0YWZHD[FB0YWIX1] == "Y") /* size has data*/
        FB0YM010.FB0YMSZD[FB0YWIXM] = FB0YW01.FB0YWSZD[FB0YWIX1];
        FB0YW00.FB0YWIXM = FB0YW00.FB0YWIXM + 1;
      end
      FB0YW00.FB0YWIX1 = FB0YW00.FB0YWIX1 + 1;
    end
    while (FB0YW00.FB0YWIXM <= 10)
      set FB0YM010.FB0YMSZD[FB0YWIXM] skip, invisible;
      FB0YW00.FB0YWIXM = FB0YW00.FB0YWIXM + 1;
    end
  end
  ;
   /* ------------------------------------------------------------*/
   /* load from RTA data to the map*/
   /* ------------------------------------------------------------*/
  ;
  FB0YM010.FB0YMFCT = FB0YW02.FB0YWFCT;
  ;
  if (FB0YW02.FB0YWFAT != 0)
    FB0YM010.FB0YMFAT = FB0YW02.FB0YWFAT;
  end
  ;
  ;
   /* ------------------------------------------------------------*/
   /* load to RTA data to the map*/
   /* ------------------------------------------------------------*/
  ;
  FB0YM010.FB0YMTCT = FB0YW03.FB0YWTCT;
  ;
  if (FB0YW03.FB0YWTAT != 0)
    FB0YM010.FB0YMTAT = FB0YW03.FB0YWTAT;
  end
  ;
   /* ------------------------------------------------------------*/
   /* Use the current size index as the starting point*/
   /* for loading the sizes quantities to the map.*/
   /* Do not allow entry in the adjust quantity field if the*/
   /* size has no data (either size description or quantity).*/
   /* ------------------------------------------------------------*/
  ;
  if (FB0YM010.SY1STNBR != " ")
    FB0YW00.FB0YWIX1 = FB0YW00.FB0YWCSI; /* Current size*/
    FB0YW00.FB0YWIXM = 1; /* map size index*/
    ;
    ;
    while (FB0YW00.FB0YWIXM <= 10 /* Max sizes on map*/
     && FB0YW00.FB0YWIX1 <= FB0YW00.FB0YWLSI) /* Last size*/
      if (FB0YW00.FB0YWZHD[FB0YWIX1] == "Y") /* size has data*/
        set FB0YM010.FB0YMFAJ[FB0YWIXM] normal;
        if (FB0YW02.FB0YWFCQ[FB0YWIX1] != 0)
          FB0YM010.FB0YMFCQ[FB0YWIXM] = FB0YW02.FB0YWFCQ[FB0YWIX1];
        end
        if (FB0YW02.FB0YWFAJ[FB0YWIX1] != 0)
          FB0YM010.FB0YMFAJ[FB0YWIXM] = FB0YW02.FB0YWFAJ[FB0YWIX1];
        end
        if (FB0YW02.FB0YWFAQ[FB0YWIX1] != 0)
          FB0YM010.FB0YMFAQ[FB0YWIXM] = FB0YW02.FB0YWFAQ[FB0YWIX1];
        end
        if (FB0YW03.FB0YWTCQ[FB0YWIX1] != 0)
          FB0YM010.FB0YMTCQ[FB0YWIXM] = FB0YW03.FB0YWTCQ[FB0YWIX1];
        end
        if (FB0YW03.FB0YWTAQ[FB0YWIX1] != 0)
          FB0YM010.FB0YMTAQ[FB0YWIXM] = FB0YW03.FB0YWTAQ[FB0YWIX1];
        end
        FB0YW00.FB0YWIXM = FB0YW00.FB0YWIXM + 1;
      else
        set FB0YM010.FB0YMFAJ[FB0YWIXM] initialAttributes;
      end
      FB0YW00.FB0YWIX1 = FB0YW00.FB0YWIX1 + 1;
    end
  end
  ;
  FB0YM010.FB0YMFAA = FB0YW01.FB0YWFAA;
  ;
  ;
  ;
end // end FB0Y210

// Check attention ID
Function FB0Y300()
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Clear Map on PA2*/
   /* ------------------------------------------------------------*/
  ;
  if (converseVar.eventKey is pa2) /* PA2 was pressed*/
    set FB0YM010 empty; /* Clear the map fields*/
    FB0YM010.XXXPRCNM = "FB0Y";
    FB0YW00.FB0YWRDF = "Y"; /* Request reload of data*/
    FB0YW00.FB0YWQAF = "N"; /* Qty adjusted*/
    set FB0YM010.FB0YMTAT initialAttributes;
    set FB0YM010.FB0YMFAT initialAttributes;
    exit stack; /* Exit to redisplay map*/
  end
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Validate scroll request if  PF10 or PF11*/
   /* ------------------------------------------------------------*/
  ;
  if (converseVar.eventKey is pf10 /* Scroll left requested*/
   || converseVar.eventKey is pf11) /* Scroll right requested*/
    ;
    FB0Y310(); /* Validate scroll request*/
    ;
    return; /* Exit to next process*/
  end
  ;
   /* ------------------------------------------------------------*/
   /* If FAST PATH was requested, transfer to application.*/
   /* ------------------------------------------------------------*/
  ;
  if (FB0YM010.CATOAP > " ") /* FAST PATH was requested*/
    if (converseVar.eventKey is enter) /* ENTER was pressed*/
      ;
      ;
      COMMAREA.CATOAP = FB0YM010.CATOAP; /* TO application*/
      COMMAREA.CAITEM = FB0YM010.CAITEM; /* TO application key*/
      XSFBS01();
      set FB0YM010.CATOAP cursor, bold;
      exit stack;
    else
      FB0YM010.XXXPRCNM = "FB0Y300"; /* Module identification*/
      converseLib.validationFailed(36); /* Enter must be used for fast path*/
      exit stack;
    end
  end
  ;
   /* ------------------------------------------------------------*/
   /* On PF1 transfer to GD01(Help screen)*/
   /* ------------------------------------------------------------*/
  ;
  if (converseVar.eventKey is pf1) /* Help screen requested*/
    ;
    COMMAREA.CATOAP = "GD01"; /* TO application*/
    COMMAREA.CAITEM = " "; /* TO application key*/
    XSFBS01();
    FB0YM010.XXXPRCNM = "FB0Y300"; /* Module identification*/
    exit stack;
  end
  ;
   /* ------------------------------------------------------------*/
   /* On PF4 transfer to MN0N (Master menu)*/
   /* ------------------------------------------------------------*/
  ;
  if (converseVar.eventKey is pf4) /* Menu screen requested*/
    ;
    set FBXREC empty;
    set FBWREC empty;
    FBWREC.FBWFILL = FBXREC.FBXGROUP;
    COMMAREA.CAITEM = " "; /* TO application key*/
    XSFBS01();
    FB0YM010.XXXPRCNM = "FB0Y300"; /* Module identification*/
    exit stack;
  end
  ;
   /* ------------------------------------------------------------*/
   /* Continue processing if following keys are pressed*/
   /* ------------------------------------------------------------*/
  ;
  if (converseVar.eventKey is enter
   || converseVar.eventKey is pf9)
    return;
  end
  ;
   /* ------------------------------------------------------------*/
   /* Clear screen if PA1 or PA3 and exit to display map.*/
   /* ------------------------------------------------------------*/
  ;
  if (converseVar.eventKey is pa1 /* PA1 pressed*/
   || converseVar.eventKey is pa3) /* PA3 pressed*/
    set FB0YM010 initial; /* Clear the map fields*/
    exit stack; /* Exit to redisplay map*/
  end
  ;
   /* ------------------------------------------------------------*/
   /* On PF3  transfer to FB0U*/
   /* ------------------------------------------------------------*/
  ;
  if (converseVar.eventKey is pf3) /* FB0U requested*/
    ;
    FBXREC.FBXFRMDT = 0;
    FBXREC.FBXTODT = 0;
    FBXREC.XWHCD1[1] = " ";
    FBWREC.FBWFILL = FBXREC.FBXGROUP;
    COMMAREA.CATOAP = "FB0W"; /* TO application*/
    COMMAREA.CAITEM = " "; /* TO application key*/
    XSFBS01();
    FB0YM010.XXXPRCNM = "FB0Y300"; /* Module identification*/
    exit stack;
  end
  ;
   /* ------------------------------------------------------------*/
   /* On PF13 transfer to FB0W*/
   /* ------------------------------------------------------------*/
  ;
  if (converseVar.eventKey is pf13) /* FB0W requested*/
    ;
    FBXREC.FBXFRMDT = 0;
    FBXREC.FBXTODT = 0;
    FBXREC.XWHCD1[1] = " ";
    FBWREC.FBWFILL = FBXREC.FBXGROUP;
    COMMAREA.CATOAP = "FB0W"; /* TO application*/
    COMMAREA.CAITEM = " "; /* TO application key*/
    XSFBS01();
    FB0YM010.XXXPRCNM = "FB0Y300"; /* Module identification*/
    exit stack;
  end
  ;
   /* ------------------------------------------------------------*/
   /* At this point an invalid PF key has been pressed.*/
   /* ------------------------------------------------------------*/
  ;
  ;
  FB0YM010.XXXPRCNM = "FB0Y300";
  converseLib.validationFailed(03); /* PF key not supported on this screen*/
  exit stack;
  ;
  ;
  ;
end // end FB0Y300

// Validate scroll request
Function FB0Y310()
  ;
   /* ------------------------------------------------------------*/
   /* Validate that size scroll is positive and not greater than*/
   /* 40*/
   /* ------------------------------------------------------------*/
  ;
  if (FB0YM010.FB0YMSZS < 1
   || FB0YM010.FB0YMSZS > 40)
    set FB0YM010.FB0YMSZS cursor, bold;
    converseLib.validationFailed(10); /* Invalid value*/
    exit stack;
  end
  ;
   /* ------------------------------------------------------------*/
   /* If scroll left was requested, ensure that sizes exist.*/
   /* ------------------------------------------------------------*/
  ;
  if (converseVar.eventKey is pf10) /* Scroll left request*/
    FB0YW00.FB0YWWF1 = FB0YWCSI - FB0YM010.FB0YMSZS;
    FB0YW00.FB0YWWF2 = FB0YWCSI - 1;
    ;
    if (FB0YW00.FB0YWWF1 < FB0YW00.FB0YWFSI
     && FB0YW00.FB0YWWF2 < FB0YW00.FB0YWFSI)
      converseLib.validationFailed(23); /* No more columns to left to display*/
      FB0YM010.XXXPRCNM = "FB0Y310"; /* Module identification*/
    end
  end
  ;
  ;
   /* ------------------------------------------------------------*/
   /* If scroll right was requested, ensure that sizes exist.*/
   /* ------------------------------------------------------------*/
  ;
  if (converseVar.eventKey is pf11) /* Scroll right request*/
    FB0YW00.FB0YWWF1 = FB0YWCSI + FB0YM010.FB0YMSZS;
    ;
    if (FB0YW00.FB0YWWF1 > FB0YW00.FB0YWLSI) /* last size index*/
      converseLib.validationFailed(24); /* No more columns to right to display*/
      FB0YM010.XXXPRCNM = "FB0Y310"; /* Module identification*/
    end
  end
  ;
  if (converseVar.validationMsgNum != 0) /* Errors were found*/
    exit stack;
  end
  ;
  ;
  ;
end // end FB0Y310

// Reset highlighted fields
Function FB0Y400()
  ;
   /* ----------------------------------------------------*/
   /* Set enterable fields normal*/
   /* ----------------------------------------------------*/
  ;
  set FB0YM010.FB0YMTRD normal;
  set FB0YM010.FB0YMSZS normal;
  ;
   /* ----------------------------------------------------*/
   /* Set adjust quantity to normal--only where there is*/
   /* either sizes or quantities.*/
   /* ----------------------------------------------------*/
  ;
  if (FB0YW01.SY1STNBR != " ")
    FB0YW00.FB0YWIX1 = FB0YW00.FB0YWCSI; /* Current size*/
    FB0YW00.FB0YWIXM = 1;
    ;
    while (FB0YW00.FB0YWIXM <= 10
     && FB0YW00.FB0YWIX1 <= 40)
      if (FB0YW00.FB0YWZHD[FB0YWIX1] == "Y") /* Size has data*/
        set FB0YM010.FB0YMFAJ[FB0YWIXM] normal;
        FB0YW00.FB0YWIXM = FB0YW00.FB0YWIXM + 1;
        FB0YW00.FB0YWIX1 = FB0YW00.FB0YWIX1 + 1;
      else
        set FB0YM010.FB0YMFAJ[FB0YWIXM] initialAttributes;
        FB0YW00.FB0YWIX1 = FB0YW00.FB0YWIX1 + 1;
      end
    end
  end
  ;
  set FB0YM010.FB0YMFAT initialAttributes;
  set FB0YM010.FB0YMTAT initialAttributes;
  ;
  ;
end // end FB0Y400

// Verify entered data
Function FB0Y500()
  ;
  FB0YM010.XXXPRCNM = "FB0Y500";
  ;
   /* ----------------------------------------------------*/
   /* If invalid scheduler display message and ezeflo*/
   /* ----------------------------------------------------*/
  ;
  if (FB0YW00.FB0YWISF == "Y")
    converseLib.validationFailed(62); /* Do not allow updates*/
    exit stack;
  end
  ;
   /* ----------------------------------------------------*/
   /* If fastpathed into application display message and*/
   /* ezeflo.*/
   /* ----------------------------------------------------*/
  ;
  if (FB0YW00.FB0YWFPF == "Y")
    converseLib.validationFailed(327); /* Fastpath invalid etc*/
    exit stack;
  end
  ;
   /* ----------------------------------------------------*/
   /* Check for db2 contention due to merge.*/
   /* ----------------------------------------------------*/
  ;
  FB0Y505(); /* check for contention*/
  ;
   /* ----------------------------------------------------*/
   /* If updates requested do not allow if the scheduler*/
   /* code is equal 'y'.*/
   /* ----------------------------------------------------*/
  ;
  if (converseVar.eventKey is pf9)
    if (FBMREC.FBMALAFL == "Y")
      converseLib.validationFailed(322); /* Do not allow updates*/
      exit stack;
    end
  end
   /* ----------------------------------------------------*/
   /* If RTA dates entered (ie changed) verify that no*/
   /* adjustment quantities have been changed.  Also verify*/
   /* that no transfer PFkeys have been pressed, and that*/
   /* the size scroll has not been entered. If not then*/
   /* perform process to validate the date fields.*/
   /* ----------------------------------------------------*/
  ;
  FB0YM010.XXXPRCNM = "FB0Y500";
  ;
  FB0YW00.FB0YWKFC = "N"; /* Key fields were changed*/
  FB0YM010.XXXPRCNM = "FB0Y500";
  ;
  if (FB0YM010.FB0YMTRD != 0) /* to RTA date exists*/
    ;
    ;
    if (FB0YM010.FB0YMTRD != FB0YW03.FB0YWTRD)
      FB0YW00.FB0YWKFC = "Y"; /* Key fields were changed*/
      FB0YW00.FB0YWIXM = 1;
      while (FB0YW00.FB0YWIXM <= 10)
        FB0YW00.FB0YWIX1 = 1;
        while (FB0YW00.FB0YWIX1 <= 40)
          if (FB0YM010.FB0YMSZD[FB0YWIXM] == FB0YW01.FB0YWSZD[FB0YWIX1])
            if (FB0YW02.FB0YWFAJ[FB0YWIX1] != FB0YM010.FB0YMFAJ[FB0YWIXM])
              set FB0YM010.FB0YMFAJ[FB0YWIXM] cursor, bold;
              converseLib.validationFailed(130); /* Cannot modify key and data info etc*/
            end
            FB0YW00.FB0YWIX1 = 41;
          end
          FB0YW00.FB0YWIX1 = FB0YW00.FB0YWIX1 + 1;
        end
        FB0YW00.FB0YWIXM = FB0YW00.FB0YWIXM + 1;
      end
      if (converseVar.validationMsgNum != 0)
        exit stack;
      end
      FB0Y510(); /* Edit key fields*/
    end
    ;
  else
    if (FB0YM010.FB0YMTRD == 0) /* No to RTA date entered*/
      set FB0YM010.FB0YMTRD cursor, bold;
      converseLib.validationFailed(8); /* Required field enter a valid value*/
    end
    ;
    if (converseVar.validationMsgNum != 0)
      exit stack;
    end
  end
  ;
  ;
  ;
   /* ----------------------------------------------------*/
   /* If key fields have changed, verify enter*/
   /* key was pressed.if not indicate error otherwise*/
   /* set request for data flag to 'y' and ezeflo to*/
   /* obtain data.*/
   /* ----------------------------------------------------*/
  ;
  if (FB0YW00.FB0YWKFC == "Y") /* Key fields were changed*/
    if (converseVar.eventKey is enter)
      set FB0YM010 empty;
      set FB0YW04 empty;
      move " " to FB0YW01.FB0YWSZD[1] for all;
      FB0YW00.FB0YWRDF = "Y"; /* request data flag to yes*/
      FB0YW00.FB0YWQAF = "N"; /* quantity adjusted flag*/
      FB0YW01.FB0YWSZS = 10;
      exit stack;
    else
      set FB0YM010.FB0YMFRD cursor, bold;
      set FB0YM010.FB0YMTRD cursor, bold;
      converseLib.validationFailed(111); /* Data cannot be changed with this*/
                                   /* function*/
      exit stack;
    end
  end
  ;
   /* ----------------------------------------------------*/
   /* If adjustment quantities have changed*/
   /* verify scroll or enter key was pressed.*/
   /* Verify that the quantities entered*/
   /* are a multiple of units per case from syclr.*/
   /* ----------------------------------------------------*/
  ;
  FB0YW00.FB0YWIXM = 10;
  ;
  while (FB0YW00.FB0YWIXM >= 1)
    FB0YW00.FB0YWIX1 = 1;
    while (FB0YW00.FB0YWIX1 <= 40)
      if (FB0YM010.FB0YMSZD[FB0YWIXM] == FB0YW01.FB0YWSZD[FB0YWIX1])
        if (FB0YW02.FB0YWFAJ[FB0YWIX1] != FB0YM010.FB0YMFAJ[FB0YWIXM])
          if (converseVar.eventKey is pf10
           || converseVar.eventKey is pf11
           || converseVar.eventKey is enter
           || converseVar.eventKey is pf9)
             /* Next sentence*/
          else
            converseLib.validationFailed(111); /* display data can't be changed etc.*/
          end
          if (FBLREC.FBKRDFL == "Y")
            FB0YW00.FB0YWWF1 = FB0YM010.FB0YMFAJ[FB0YWIXM];
            if (PG2REC.SY1UNPCS == 0)
              PG2REC.SY1UNPCS = 12; /* default value*/
            end
            FB0YW00.FB0YWWF2 = FB0YW00.FB0YWWF1             % PG2REC.SY1UNPCS; /* Gets remainder*/
            if (FB0YW00.FB0YWWF2 == 0)
              FB0YW00.FB0YWQAF = "Y"; /* quantities adjusted*/
            else
              if (PG2REC.SY1UNPCS == 12) /* rounding factor is 12*/
                converseLib.validationFailed(471); /* not rounded to 12*/
                set FB0YM010.FB0YMFAJ[FB0YWIXM] cursor, bold;
              else
                if (PG2REC.SY1UNPCS == 24) /* rounding factor is 24*/
                  converseLib.validationFailed(472); /* not rounded to 24*/
                  set FB0YM010.FB0YMFAJ[FB0YWIXM] cursor, bold;
                else
                  if (PG2REC.SY1UNPCS == 48) /* rounding factor is 48*/
                    converseLib.validationFailed(473); /* not rounded to 48*/
                    set FB0YM010.FB0YMFAJ[FB0YWIXM] cursor, bold;
                  else
                    converseLib.validationFailed(474); /* none of above & not pass*/
                    set FB0YM010.FB0YMFAJ[FB0YWIXM] cursor, bold;
                  end
                end
              end
            end
          else
            FB0YW00.FB0YWQAF = "Y"; /* quantities adjusted*/
          end
        end
        FB0YW00.FB0YWIX1 = 41;
      end
      FB0YW00.FB0YWIX1 = FB0YW00.FB0YWIX1 + 1;
    end
    FB0YW00.FB0YWIXM = FB0YW00.FB0YWIXM - 1;
  end
  ;
  ;
   /* ----------------------------------------------------*/
   /* If adjustment quantities have changed*/
   /* verify that the adjusted quantity entered will not*/
   /* create a negative amount on the from or to*/
   /* quantities.*/
   /* ----------------------------------------------------*/
  ;
  if (FB0YW00.FB0YWQAF == "Y") /* Quantities adjusted*/
    FB0YW00.FB0YWIXM = 10;
    ;
    while (FB0YW00.FB0YWIXM >= 1)
      FB0YW00.FB0YWIX1 = 1;
      while (FB0YW00.FB0YWIX1 <= 40)
        if (FB0YM010.FB0YMSZD[FB0YWIXM] == FB0YW01.FB0YWSZD[FB0YWIX1])
          if (FB0YW02.FB0YWFAJ[FB0YWIX1] != FB0YM010.FB0YMFAJ[FB0YWIXM])
            FB0YW00.FB0YWWF2 = FB0YM010.FB0YMFAJ[FB0YWIXM];
            if (FB0YW00.FB0YWWF2 < 0)
              FB0YW00.FB0YWWF1 = FB0YM010.FB0YMFCQ[FB0YWIXM];
              FB0YW00.FB0YWWF3 = FB0YW00.FB0YWWF1 + FB0YW00.FB0YWWF2;
              if (FB0YW00.FB0YWWF3 < 0)
                set FB0YM010.FB0YMFAJ[FB0YWIXM] cursor, bold;
                converseLib.validationFailed(252); /* sum cannot be negative*/
              end
            else
              FB0YW00.FB0YWWF1 = FB0YM010.FB0YMTCQ[FB0YWIXM];
              FB0YW00.FB0YWWF3 = FB0YW00.FB0YWWF1 - FB0YW00.FB0YWWF2;
              if (FB0YW00.FB0YWWF3 < 0)
                set FB0YM010.FB0YMFAJ[FB0YWIXM] cursor, bold;
                converseLib.validationFailed(252); /* sum cannot be negative*/
              end
            end
          end
          FB0YW00.FB0YWIX1 = 41;
        end
        FB0YW00.FB0YWIX1 = FB0YW00.FB0YWIX1 + 1;
      end
      FB0YW00.FB0YWIXM = FB0YW00.FB0YWIXM - 1;
    end
  end
  ;
  if (converseVar.validationMsgNum != 0)
    exit stack;
  end
  ;
  FB0YM010.XXXPRCNM = " ";
   /* ----------------------------------------------------*/
   /* If adjustment quantities have changed and there*/
   /* are no errors--load the adjusted fields to display*/
   /* storage.*/
   /* ----------------------------------------------------*/
  ;
  if (FB0YW00.FB0YWQAF == "Y") /* Quantities adjusted*/
    FB0YW00.FB0YWIXM = 1;
    while (FB0YW00.FB0YWIXM <= 10)
      FB0YW00.FB0YWIX1 = 1;
      while (FB0YW00.FB0YWIX1 <= 40)
        if (FB0YM010.FB0YMSZD[FB0YWIXM] == FB0YW01.FB0YWSZD[FB0YWIX1])
          FB0YW02.FB0YWFAJ[FB0YWIX1] = FB0YM010.FB0YMFAJ[FB0YWIXM];
          FB0YW00.FB0YWIX1 = 41;
        end
        FB0YW00.FB0YWIX1 = FB0YW00.FB0YWIX1 + 1;
      end
      FB0YW00.FB0YWIXM = FB0YW00.FB0YWIXM + 1;
      ;
    end
    FB0YW01.FB0YWFAA = 0; /* adjust amount*/
    FB0YW00.FB0YWIX1 = 1;
    while (FB0YW00.FB0YWIX1 <= 40)
      FB0YW00.FB0YWWF1 = FB0YW02.FB0YWFAJ[FB0YWIX1];
      FB0YW01.FB0YWFAA = FB0YW01.FB0YWFAA + FB0YW00.FB0YWWF1;
      FB0YW00.FB0YWIX1 = FB0YW00.FB0YWIX1 + 1;
    end
    FB0YM010.FB0YMFAA = FB0YW01.FB0YWFAA;
    FB0YW00.XXXMSGNO = 98; /* Press PF9 to update*/
  end
  ;
  ;
   /* ----------------------------------------------------*/
   /* If PF9 check for a tolerance level.*/
   /* ----------------------------------------------------*/
  ;
  if (converseVar.eventKey is pf9)
    if (FB0YW02.FB0YWFAT < FB9REC.FB9BTQTY
     && FB0YW02.FB0YWFAT != 0)
      converseLib.validationFailed(336); /* qty below tolerance--no updates*/
                                   /* allowed*/
      set FB0YM010.FB0YMFAT bold;
      FB0YW00.XXXMSGNO = " ";
      exit stack;
    end
    ;
    if (FB0YW03.FB0YWTAT < FB9REC.FB9BTQTY
     && FB0YW03.FB0YWTAT != 0)
      converseLib.validationFailed(336); /* qty below tolerance--no updates*/
                                   /* allowed*/
      set FB0YM010.FB0YMTAT bold;
      FB0YW00.XXXMSGNO = " ";
      exit stack;
    end
  end
  ;
  ;
end // end FB0Y500

// check for merge contention
Function FB0Y505()
   /* ------------------------------------------------------------*/
   /* build key*/
   /* ------------------------------------------------------------*/
  ;
  set FBEREC empty;
  ;
  FBEREC.XXXPGMNB = "FB120D"; /* program nbr*/
  ;
   /* ------------------------------------------------------------*/
   /* select row*/
   /* ------------------------------------------------------------*/
  ;
  try
    call "IO3440" ("S ", SQLCA, FBEREC) {isNoRefresh = yes, isExternal = yes};
  end /* select row*/
  ;
  if (sysVar.errorCode == "00000000") /* Call successful*/
    ;
    if (SQLCA.VAGen_SQLCODE == 0) /* normal return code*/
      if (FBEREC.FBEMDLPF == "Y") /* contention with merge*/
        converseLib.validationFailed(371); /* merge is being run*/
        exit stack; /* return to process*/
      end
    else
      ;
      ;
      /* ------------------------------------------------------------*/
       /* If data not available, return an error message to the user.*/
       /* Otherwise, indicate that a system error has occurred.*/
      /* ------------------------------------------------------------*/
      ;
      TA1REC.TA1LOC = "CHECK MERGE CONTENTION";
      TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
      TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL Commarea*/
      ;
      if (SQLCA.VAGen_SQLCODE == -911) /* resource not available*/
        converseLib.validationFailed(11); /* Indicate not available*/
        TA1REC.TA1FUNC = "POST"; /* Termination function*/
      else
        converseLib.validationFailed(10); /* Indicate system error*/
        TA1REC.TA1FUNC = "RETN"; /* Termination function*/
        converseLib.clearScreen();
         /* Clear screen before display*/
      end
      ;
      TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
      TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
      TA1REC.TA1DBASE = "DFBUY   "; /* Data base name*/
      TA1REC.TA1TBLVU = "VFBPGM01"; /* Table view name*/
      TA1REC.TA1TBLKE = FBEREC.FBEGROUP; /* Table key*/
      TA1REC.TA1LOC = "SELECT UNIQUE";
      call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/
      exit stack;
    end
  end
  ;
  ;
end // end FB0Y505

// Verify key fields
Function FB0Y510()
  ;
   /* ----------------------------------------------------*/
   /* Validate the RTA month date using TA0040 subroutine.*/
   /* ----------------------------------------------------*/
  ;
  FB0YM010.XXXPRCNM = "FB0Y510";
  ;
  ;
  if (FB0YM010.FB0YMTRD == 0)
    set FB0YM010.FB0YMTRD cursor, bold;
    converseLib.validationFailed(08);
  else
    if (FB0YM010.FB0YMTRD != FB0YW03.FB0YWTRD) /* TO RTA date changed*/
      FB0YW00.FB0YWKFC = "Y"; /* Key fields changed*/
      ;
      set TA2REC empty; /* Initialize record*/
      ;
      TA2REC.TA2GRGAN = FB0YM010.FB0YMTRD;
      ;
      FB0YS02(); /* Call Ta0040 to validate date*/
      ;
      if (TA2RTNCD == 0) /* Successful return code from TA0040*/
        FB0YW03.FB0YWTRD = FB0YM010.FB0YMTRD;
        FB0YW00.FB0YWTRD = FB0YM010.FB0YMTRD;
        FB0YW03.FB7RTADT = TA2REC.TA2GRGGN;
        FB0YW01.FB0YWTRT = TA2REC.TA2GRGGN; /* to date*/
      else
        set FB0YM010.FB0YMTRD cursor, bold;
        converseLib.validationFailed(17); /* Invalid date entered*/
      end
      ;
    end
  end
  ;
  ;
   /* ----------------------------------------------------*/
   /* Validate that rta from and to dates are not the*/
   /* same.*/
   /* ----------------------------------------------------*/
  if (FB0YM010.FB0YMTRD == FB0YM010.FB0YMFRD)
    if (FB0YM010.FB0YMTRD != 0
     && FB0YM010.FB0YMFRD != 0)
      set FB0YM010.FB0YMTRD bold;
      set FB0YM010.FB0YMFRD cursor, bold;
      converseLib.validationFailed(253); /* from and to dates cannot be the same*/
    end
  end
  ;
  ;
  if (converseVar.validationMsgNum != 0)
    exit stack;
  end
  ;
  FB0YM010.XXXPRCNM = " ";
  ;
  ;
  ;
end // end FB0Y510

// Process valid input
Function FB0Y600()
  ;
   /* ----------------------------------------------------*/
   /* If enter has been pressed and quantites have been*/
   /* adjusted--do calculations.*/
   /* ----------------------------------------------------*/
  ;
  if (converseVar.eventKey is enter /* enter and*/
   || converseVar.eventKey is pf10  
   || converseVar.eventKey is pf11)
    if (FB0YW00.FB0YWQAF == "Y") /* Quantities have been adjusted*/
      FB0Y610(); /* calculate adjusted quantities*/
    end
  end
  ;
  if (converseVar.eventKey is enter)
    exit stack;
  end
   /* ----------------------------------------------------*/
   /* If PF10 or PF11 has been pressed increment or*/
   /* decrement the sizes requested and return to*/
   /* reload size data and display map.*/
   /* ----------------------------------------------------*/
  ;
  if (converseVar.eventKey is pf10)
    FB0YW00.FB0YWSSR = "Y"; /* Scroll request*/
    FB0YW00.FB0YWCSI = FB0YW00.FB0YWCSI - FB0YM010.FB0YMSZS;
    FB0YW00.XXXMSGNO = 15; /* Scroll left successful*/
    FB0YW01.FB0YWSZS = FB0YM010.FB0YMSZS;
    return;
  end
  ;
  if (converseVar.eventKey is pf11)
    FB0YW00.FB0YWSSR = "Y"; /* Scroll request*/
    FB0YW00.FB0YWCSI = FB0YW00.FB0YWCSI + FB0YM010.FB0YMSZS;
    FB0YW00.XXXMSGNO = 14; /* Scroll right successful*/
    FB0YW01.FB0YWSZS = FB0YM010.FB0YMSZS;
    return;
  end
  ;
  ;
   /* ----------------------------------------------------*/
   /* If PF9 has been pressed and adjustment have been*/
   /* entered update the RTA rows and the merged qty rows.*/
   /* If no adjustments were entered display message and*/
   /* ezeflo to display map.*/
   /* ----------------------------------------------------*/
  ;
  if (converseVar.eventKey is pf9) /* Update requested*/
    if (FB0YW00.FB0YWQAF == "Y") /* Quantities have been adjusted*/
      ;
      FB0Y620(); /* Update RTA rows*/
      ;
      FB0Y630(); /* Update merged row*/
      ;
      VGVar.handleSysLibraryErrors = 0;
      sysLib.commit(); /* Commit database change*/
      ;
      FB0YW00.XXXMSGNO = 32; /* Update successful*/
      set FB0YM010 initial;
      set FB0YW02 empty;
      set FB0YW03 empty;
      set FB0YW04 empty;
      FB0YW00.FB0YWRDF = "Y"; /* Reload data*/
      FB0YW00.FB0YWQAF = "N"; /* qty adjusted flag*/
    else
      converseLib.validationFailed(66); /* No data to update*/
    end
  end
  ;
end // end FB0Y600

// Calculate adjusted quantities
Function FB0Y610()
  ;
   /* ----------------------------------------------------*/
   /* Obtain the control record to get the tolerance*/
   /* qty.*/
   /* ----------------------------------------------------*/
  ;
  FB0YS10();
  ;
   /* ----------------------------------------------------*/
   /* calculate the from adjusted quantities for the from*/
   /* and to RTA dates.*/
   /* ----------------------------------------------------*/
  ;
  FB0YW00.FB0YWIXM = 1;
  ;
  while (FB0YW00.FB0YWIXM <= 10)
    FB0YW00.FB0YWWF1 = FB0YM010.FB0YMFAJ[FB0YWIXM];
    FB0YW00.FB0YWWF2 = FB0YM010.FB0YMFCQ[FB0YWIXM];
    FB0YW00.FB0YWWF3 = FB0YM010.FB0YMTCQ[FB0YWIXM];
    FB0YM010.FB0YMFAQ[FB0YWIXM] = FB0YW00.FB0YWWF1 + FB0YW00.FB0YWWF2;
    FB0YM010.FB0YMTAQ[FB0YWIXM] = FB0YW00.FB0YWWF3 - FB0YW00.FB0YWWF1;
    FB0YW00.FB0YWIX1 = 1;
    while (FB0YW00.FB0YWIX1 <= 40)
      if (FB0YM010.FB0YMSZD[FB0YWIXM] == FB0YW01.FB0YWSZD[FB0YWIX1])
        FB0YW02.FB0YWFAQ[FB0YWIX1] = FB0YM010.FB0YMFAQ[FB0YWIXM];
        FB0YW03.FB0YWTAQ[FB0YWIX1] = FB0YM010.FB0YMTAQ[FB0YWIXM];
        FB0YW00.FB0YWIX1 = 99;
      end
      FB0YW00.FB0YWIX1 = FB0YW00.FB0YWIX1 + 1;
    end
    FB0YW00.FB0YWIXM = FB0YW00.FB0YWIXM + 1;
  end
  ;
   /* ----------------------------------------------------*/
   /* Sum the from and to adjusted quantites.*/
   /* ----------------------------------------------------*/
  ;
  FB0YW02.FB0YWFAT = 0;
  FB0YW03.FB0YWTAT = 0;
  ;
  FB0YW00.FB0YWIX1 = 1;
  ;
  while (FB0YW00.FB0YWIX1 <= 40)
    FB0YW02.FB0YWFAT = FB0YW02.FB0YWFAT + FB0YW02.FB0YWFAQ[FB0YWIX1];
    FB0YW03.FB0YWTAT = FB0YW03.FB0YWTAT + FB0YW03.FB0YWTAQ[FB0YWIX1];
    FB0YW00.FB0YWIX1 = FB0YW00.FB0YWIX1 + 1;
  end
  ;
  FB0YM010.FB0YMFAT = FB0YW02.FB0YWFAT;
  FB0YM010.FB0YMTAT = FB0YW03.FB0YWTAT;
  ;
  ;
  ;
end // end FB0Y610

// Update RTA rows
Function FB0Y620()
  ;
  ;
  ;
   /* ----------------------------------------------------*/
   /* Calculate the new from RTA percent and move the*/
   /* new percent and the from adjusted quantities to*/
   /* the FBFREC and do the update.*/
   /* ----------------------------------------------------*/
  ;
   /* Move the saved record from record to the FBFREC*/
  ;
  FBFREC.FBFGROUP = FB0YW02.FB0YWFRC;
  ;
  FBFREC.FB7RTAPC = mathLib.round(FB0YW02.FB0YWFAT / FB0YW00.FB0YWTRQ, -mathLib.decimals(FBFREC.FB7RTAPC));
  FBFREC.FB7RTAPC = FBFREC.FB7RTAPC * 100;
  ;
  move FB0YW02.FB0YWFAQ to FBFREC.FB7QTB[1] for all;
  ;
  FB0Y621(); /* Update VRTQTB01*/
  ;
   /* ----------------------------------------------------*/
   /* Calculate the new to RTA percent and move the*/
   /* new percent and the to adjusted quantities to*/
   /* the FBFREC and do the update.*/
   /* ----------------------------------------------------*/
  ;
   /* Move the saved record from record to the FBFREC*/
  ;
  FBFREC.FBFGROUP = FB0YW03.FB0YWTRC;
  ;
  FBFREC.FB7RTAPC = mathLib.round(FB0YW03.FB0YWTAT / FB0YW00.FB0YWTRQ, -mathLib.decimals(FBFREC.FB7RTAPC));
  FBFREC.FB7RTAPC = FBFREC.FB7RTAPC * 100;
  ;
  move FB0YW03.FB0YWTAQ to FBFREC.FB7QTB[1] for all;
  ;
  FB0Y621(); /* Update VRTQTB01*/
  ;
  ;
end // end FB0Y620

// Update VRTQTB01 row
Function FB0Y621()
  ;
  ;
  ;
   /* ------------------------------------------------------------*/
   /* This module updates a table row.*/
   /* It will return and document system errors if unexpected*/
   /* return codes are found.*/
   /* ------------------------------------------------------------*/
  ;
  XX0XS01();
  FBFREC.ZZZCHGDT = XX0XW01.XX0XWDAT;
  FBFREC.ZZZCHGTM = XX0XW01.XX0XWTIM;
  ;
  ;
  ;
  try
    call "IO4620" ("U ", SQLCA, FBFREC) {isNoRefresh = yes, isExternal = yes};
  end /* Delete table row*/
  ;
  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Expected return codes*/
      ;
      return; /* Return to previous process*/
      ;
    end
    if (SQLCA.VAGen_SQLCODE == 100) /* Row not found*/
      VGVar.handleSysLibraryErrors = 0;
      sysLib.rollback(); /* Rollback if bad return code*/
      FB0YW00.XXXMSGNO = 20; /* Record has been updated etc.*/
      set FB0YM010 empty;
      set FB0YW02 empty;
      set FB0YW03 empty;
      set FB0YW04 empty;
      FB0YW00.FB0YWRDF = "Y"; /* request for data*/
      FB0YW00.FB0YWQAF = "N"; /* quantities adjusted flag*/
      exit stack;
    end
  end
  ;
  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(19); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(01); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
     /* Clear screen before redisplay*/
  end
  ;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback(); /* Rollback if bad return code*/
  ;
  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "FB0Y621 "; /* Process name*/
  TA1REC.TA1LOC = "UPDATE TABLE ROW";
  TA1REC.TA1DBASE = "DFBUY   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VRTQTB01"; /* Table view name*/
  ;
  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/
  ;
  FB0YM010.XXXPRCNM = "FB0Y621"; /* Process name*/
  ;
  exit stack;
  ;
  ;
end // end FB0Y621

// Update merged qty rows
Function FB0Y630()
  ;
  ;
  ;
   /* ----------------------------------------------------*/
   /* Obtain all of the factory record for the from*/
   /* RTA date and save in the FB0YW04 record.*/
   /* ----------------------------------------------------*/
  ;
  set FB0YW04 empty;
  set FB7REC empty;
  ;
  FB7REC.SY1STNBR = FB0YW01.SY1STNBR;
  FB7REC.SY2CLRID = FB0YW01.SY2CLRID;
  FB7REC.XDMCD = FB0YW01.XDMCD;
  FB7REC.FB7RTADT = FB0YW02.FB7RTADT;
  FB7REC.FB8BUYDT = FB0YW00.FB8BUYDT;
  FB7REC.XWHCD = FB0YW01.XWHCD;
  FB7REC.PC2CUXID = " ";
  ;
  FB0YS03(); /* Open cursor for VMFBUY01*/
  ;
  FB0YS04(); /* Fetch VMFBUY01 row*/
  ;
  FB0YW00.FB0YWIX1 = 0;
  ;
  while (FB0YW00.FB0YWMQC == "N" /* While more rows*/
   && FB0YW00.FB0YWIX1 <= 5) /* and max of 5 factories*/
    FB0YW00.FB0YWIX1 = FB0YW00.FB0YWIX1 + 1;
    FB0YW04.XWHCD[FB0YWIX1] = FB7REC.XWHCD;
    FB0YW04.FY2MFGPC[FB0YWIX1] = FB7REC.FY2MFGPC;
    FB0YW04.FY1FCTYC[FB0YWIX1] = FB7REC.FY1FCTYC;
    FB0YW04.FB0YWRCD[FB0YWIX1] = FB7REC.FB7GROUP;
    ;
    FB0YS04(); /* Fetch VMFBUY01 row*/
    ;
  end
  ;
  FB0YS05(); /* Close VMFBUY01 cursor*/
  ;
  if (FB0YW00.FB0YWIX1 == 0)
    FB0YW00.XXXMSGNO = 244;
                                   /* No factory from rows for this product*/
  else
    ;
    FB0Y631(); /* Calculate new from merged qty*/
    ;
  end
  ;
  ;
   /* ----------------------------------------------------*/
   /* Obtain all of the factory record for the to*/
   /* RTA date and save in the FB0YW04 record.*/
   /* ----------------------------------------------------*/
  ;
  set FB0YW04 empty;
  set FB7REC empty;
  ;
  FB7REC.SY1STNBR = FB0YW01.SY1STNBR;
  FB7REC.SY2CLRID = FB0YW01.SY2CLRID;
  FB7REC.XDMCD = FB0YW01.XDMCD;
  FB7REC.FB7RTADT = FB0YW03.FB7RTADT;
  FB7REC.FB8BUYDT = FB0YW00.FB8BUYDT;
  FB7REC.XWHCD = FB0YW01.XWHCD;
  FB7REC.PC2CUXID = " ";
  ;
  FB0YS03(); /* Open cursor for VMFBUY01*/
  ;
  FB0YS04(); /* Fetch VMFBUY01 row*/
  ;
  FB0YW00.FB0YWIX1 = 0;
  ;
  while (FB0YW00.FB0YWMQC == "N" /* while more rows*/
   && FB0YW00.FB0YWIX1 <= 5) /* and max of 5 factories*/
    FB0YW00.FB0YWIX1 = FB0YW00.FB0YWIX1 + 1;
    FB0YW04.XWHCD[FB0YWIX1] = FB7REC.XWHCD;
    FB0YW04.FY2MFGPC[FB0YWIX1] = FB7REC.FY2MFGPC;
    FB0YW04.FY1FCTYC[FB0YWIX1] = FB7REC.FY1FCTYC;
    FB0YW04.FB0YWRCD[FB0YWIX1] = FB7REC.FB7GROUP;
    ;
    FB0YS04(); /* Fetch VMFBUY01 row*/
    ;
  end
  ;
  FB0YS05(); /* Close VMFBUY01 cursor*/
  ;
  if (FB0YW00.FB0YWIX1 == 0)
    FB0YW00.XXXMSGNO = 245; /* No factory to rows for this product*/
  else
    FB0Y632(); /* Calculate new to merged qty*/
  end
  ;
  ;
end // end FB0Y630

// Calc new from merged qty
Function FB0Y631()
  ;
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Calculate the new factory size quantities--use the new from*/
   /* RTA size quantities (the fb0yw02 record adjust quantities.*/
      /* New factory size qty = factory % * new rta size qty*/
      /* Save the rounded and unrounded new factory size qty.*/
      /* Round the new factory size qty to the nearest multiple*/
      /* of units per case from syclr.*/
      /* Calculate the difference between the rounded and*/
      /* unrounded factory size qty and save the variance.*/
      /* Keep track of the highest variance (stored in*/
      /* fb0ywhva) and the record index for that*/
      /* variance.  Any differences between the RTA size qty*/
      /* and the total factory size quantities must be reconciled*/
      /* by modifying the size field on the record with the*/
      /* largest variance.*/
   /* ------------------------------------------------------------*/
  ;
  FB0YW00.FB0YWIX1 = 1; /* factory array index*/
  ;
  while (FB0YW00.FB0YWIX1 <= 5) /* While max number of factories*/
    ;
    if (FB0YW04.FY1FCTYC[FB0YWIX1] != " ") /* If there is a factory*/
      FB0YW00.FB0YWIX2 = 1; /* ; Calculate new size quantities*/
      ;
      while (FB0YW00.FB0YWIX2 <= 40)
        ;
        if (FB0YW02.FB0YWFAQ[FB0YWIX2] != 0) /* There is an RTA size qty*/
          ;
           /* Unrounded qty = new size qty  x factory percent*/
          ;
          FB0YW00.FY2MFGPC = FB0YW04.FY2MFGPC[FB0YWIX1] / 100;
          ;
          FB0YW00.FB0YWNUQ = FB0YW02.FB0YWFAQ[FB0YWIX2] * FB0YW00.FY2MFGPC;
          ;
          FB0YS15(); /* Round size qty by case*/
          ;
           /* calculate variance  (unrounded - rounded bucket)*/
           /* if negative reverse sign.*/
          ;
          FB0YW00.FB0YWWD1 = FB0YW00.FB0YWNUQ; /* decimal work field*/
          FB0YW00.FB0YWWD2 = FB0YW00.FB0YWNRQ; /* decimal work field*/
          FB0YW00.FB0YWWD3 = FB0YW00.FB0YWWD1 - FB0YW00.FB0YWWD2;
          ;
          if (FB0YW00.FB0YWWD3 < 0)
            FB0YW00.FB0YWWD3 = FB0YW00.FB0YWWD3 * -1;
          end
          ;
           /* If the current variance is > than highest, move it*/
           /* to highest and move the factory index value to a*/
           /* saved field.*/
          if (FB0YW00.FB0YWWD3 > FB0YW04.FB0YWHVA[FB0YWIX2])
            FB0YW04.FB0YWHVA[FB0YWIX2] = FB0YW00.FB0YWWD3;
            FB0YW04.FB0YWHVI[FB0YWIX2] = FB0YW00.FB0YWIX1;
          end
          if (FB0YW00.FB0YWIX1 == 1) /* factory 1*/
            FB0YW04.FB0YW1NS[FB0YWIX2] = FB0YW00.FB0YWNRQ;
          end
          if (FB0YW00.FB0YWIX1 == 2) /* factory 2*/
            FB0YW04.FB0YW2NS[FB0YWIX2] = FB0YW00.FB0YWNRQ;
          end
          if (FB0YW00.FB0YWIX1 == 3) /* factory 3*/
            FB0YW04.FB0YW3NS[FB0YWIX2] = FB0YW00.FB0YWNRQ;
          end
          if (FB0YW00.FB0YWIX1 == 4) /* factory 4*/
            FB0YW04.FB0YW4NS[FB0YWIX2] = FB0YW00.FB0YWNRQ;
          end
          if (FB0YW00.FB0YWIX1 == 5) /* factory 5*/
            FB0YW04.FB0YW5NS[FB0YWIX2] = FB0YW00.FB0YWNRQ;
          end
        end
        ;
        FB0YW00.FB0YWIX2 = FB0YW00.FB0YWIX2 + 1;
      end
    end
    FB0YW00.FB0YWIX1 = FB0YW00.FB0YWIX1 + 1;
  end
  ;
   /* ----------------------------------------------------*/
   /* Add all of the factory rounded size quantities into*/
   /* a working storage array. Compare the total with*/
   /* the RTA total from quantity.  If there is a*/
   /* difference due to rounding adjust based upon the*/
   /* factory size with the highest variance.*/
   /* ----------------------------------------------------*/
  ;
  FB0YW00.FB0YWIX2 = 1;
  ;
  while (FB0YW00.FB0YWIX2 <= 40)
    ;
    FB0YW00.FB0YWWF1 = 0;
    FB0YW00.FB0YWWF1 = FB0YW00.FB0YWWF1 + FB0YW04.FB0YW1NS[FB0YWIX2];
    FB0YW00.FB0YWWF1 = FB0YW00.FB0YWWF1 + FB0YW04.FB0YW2NS[FB0YWIX2];
    FB0YW00.FB0YWWF1 = FB0YW00.FB0YWWF1 + FB0YW04.FB0YW3NS[FB0YWIX2];
    FB0YW00.FB0YWWF1 = FB0YW00.FB0YWWF1 + FB0YW04.FB0YW4NS[FB0YWIX2];
    FB0YW00.FB0YWWF1 = FB0YW00.FB0YWWF1 + FB0YW04.FB0YW5NS[FB0YWIX2];
    FB0YW04.FB0YWNMQ[FB0YWIX2] = FB0YW00.FB0YWWF1;
    FB0YW00.FB0YWIX2 = FB0YW00.FB0YWIX2 + 1;
  end
  ;
  ;
   /* ----------------------------------------------------*/
   /* Compare the total factory qty for each size with*/
   /* the RTA from row quantities, and adjust if a*/
   /* difference.*/
   /* ----------------------------------------------------*/
  ;
  FB0YW00.FB0YWIX1 = 1;
  ;
  while (FB0YW00.FB0YWIX1 <= 40)
    ;
    ;
    if (FB0YW04.FB0YWNMQ[FB0YWIX1] != FB0YW02.FB0YWFAQ[FB0YWIX1])
      FB0YW00.FB0YWWF1 = FB0YW02.FB0YWFAQ[FB0YWIX1];
      FB0YW00.FB0YWWF2 = FB0YW04.FB0YWNMQ[FB0YWIX1];
      FB0YW00.FB0YWWF3 = FB0YW00.FB0YWWF1 - FB0YW00.FB0YWWF2;
      if (FB0YW04.FB0YWHVI[FB0YWIX1] == 1) /* fcty 1 highest variance*/
        FB0YW04.FB0YW1NS[FB0YWIX1] = FB0YW04.FB0YW1NS[FB0YWIX1] + FB0YWWF3;
      end
      if (FB0YW04.FB0YWHVI[FB0YWIX1] == 2) /* fcty 2 highest variancw*/
        FB0YW04.FB0YW2NS[FB0YWIX1] = FB0YW04.FB0YW2NS[FB0YWIX1] + FB0YWWF3;
      end
      if (FB0YW04.FB0YWHVI[FB0YWIX1] == 3) /* fcty 3 highest variance*/
        FB0YW04.FB0YW3NS[FB0YWIX1] = FB0YW04.FB0YW3NS[FB0YWIX1] + FB0YWWF3;
      end
      if (FB0YW04.FB0YWHVI[FB0YWIX1] == 4) /* fcty 4 highest variance*/
        FB0YW04.FB0YW4NS[FB0YWIX1] = FB0YW04.FB0YW4NS[FB0YWIX1] + FB0YWWF3;
      end
      if (FB0YW04.FB0YWHVI[FB0YWIX1] == 5) /* fcty 5 highest variancw*/
        FB0YW04.FB0YW5NS[FB0YWIX2] = FB0YW04.FB0YW5NS[FB0YWIX2] + FB0YWWF3;
      end
    end
    FB0YW00.FB0YWIX1 = FB0YW00.FB0YWIX1 + 1;
  end
  ;
   /* ----------------------------------------------------*/
   /* update all of the factory rows from the from the*/
   /* saved FB7REC in the working storage FB0yw04 record.*/
   /* ----------------------------------------------------*/
  ;
  FB0YS06(); /* UPdate merged qty tables.*/
end // end FB0Y631

// Calc new to merged qty
Function FB0Y632()
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Calculate the new factory size quantities--use the new to*/
   /* RTA size quantities (the fb0yw03 record adjust quantities.*/
      /* New factory size qty = factory % * new rta size qty*/
      /* Save the rounded and unrounded new factory size qty.*/
      /* Round the new factory size qty to the nearest multiple*/
      /* of units per case from syclr.*/
      /* Calculate the difference between the rounded and*/
      /* unrounded factory size qty and save the variance.*/
      /* Keep track of the highest variance (stored in*/
      /* fb0ywhva) and the record index for that*/
      /* variance.  Any differences between the RTA size qty*/
      /* and the total factory size quantities must be reconciled*/
      /* by modifying the size field on the record with the*/
      /* largest variance.*/
   /* ------------------------------------------------------------*/
  ;
  FB0YW00.FB0YWIX1 = 1; /* factory array index*/
  ;
  while (FB0YW00.FB0YWIX1 <= 5) /* While max number of factories*/
    ;
    if (FB0YW04.FY1FCTYC[FB0YWIX1] != " ") /* If there is a factory*/
      FB0YW00.FB0YWIX2 = 1; /* ; Calculate new size quantities*/
      ;
      while (FB0YW00.FB0YWIX2 <= 40)
        ;
        if (FB0YW03.FB0YWTAQ[FB0YWIX2] != 0) /* There is an RTA size qty*/
          ;
           /* Unrounded qty = new size qty  x factory percent*/
          ;
          FB0YW00.FY2MFGPC = FB0YW04.FY2MFGPC[FB0YWIX1] / 100;
          ;
          FB0YW00.FB0YWNUQ = FB0YW03.FB0YWTAQ[FB0YWIX2] * FB0YW00.FY2MFGPC;
          ;
          FB0YS15(); /* Round size qty by case*/
          ;
           /* calculate variance  (unrounded - rounded bucket)*/
           /* if negative reverse sign.*/
          ;
          FB0YW00.FB0YWWD1 = FB0YW00.FB0YWNUQ; /* decimal work field*/
          FB0YW00.FB0YWWD2 = FB0YW00.FB0YWNRQ; /* decimal work field*/
          FB0YW00.FB0YWWD3 = FB0YW00.FB0YWWD1 - FB0YW00.FB0YWWD2;
          ;
          if (FB0YW00.FB0YWWD3 < 0)
            FB0YW00.FB0YWWD3 = FB0YW00.FB0YWWD3 * -1;
          end
          ;
           /* If the current variance is > than highest, move it*/
           /* to highest and move the factory index value to a*/
           /* saved field.*/
          if (FB0YW00.FB0YWWD3 > FB0YW04.FB0YWHVA[FB0YWIX2])
            FB0YW04.FB0YWHVA[FB0YWIX2] = FB0YW00.FB0YWWD3;
            FB0YW04.FB0YWHVI[FB0YWIX2] = FB0YW00.FB0YWIX1;
          end
          if (FB0YW00.FB0YWIX1 == 1) /* factory 1*/
            FB0YW04.FB0YW1NS[FB0YWIX2] = FB0YW00.FB0YWNRQ;
          end
          if (FB0YW00.FB0YWIX1 == 2) /* factory 2*/
            FB0YW04.FB0YW2NS[FB0YWIX2] = FB0YW00.FB0YWNRQ;
          end
          if (FB0YW00.FB0YWIX1 == 3) /* factory 3*/
            FB0YW04.FB0YW3NS[FB0YWIX2] = FB0YW00.FB0YWNRQ;
          end
          if (FB0YW00.FB0YWIX1 == 4) /* factory 4*/
            FB0YW04.FB0YW4NS[FB0YWIX2] = FB0YW00.FB0YWNRQ;
          end
          if (FB0YW00.FB0YWIX1 == 5) /* factory 5*/
            FB0YW04.FB0YW5NS[FB0YWIX2] = FB0YW00.FB0YWNRQ;
          end
        end
        FB0YW00.FB0YWIX2 = FB0YW00.FB0YWIX2 + 1;
      end
    end
    FB0YW00.FB0YWIX1 = FB0YW00.FB0YWIX1 + 1;
  end
  ;
   /* ----------------------------------------------------*/
   /* Add all of the factory rounded size quantities into*/
   /* a working storage array. Compare the total with*/
   /* the RTA total to quantity.  If there is a*/
   /* difference due to rounding adjust based upon the*/
   /* factory size with the highest variance.*/
   /* ----------------------------------------------------*/
  ;
  FB0YW00.FB0YWIX2 = 1;
  ;
  while (FB0YW00.FB0YWIX2 <= 40)
    ;
    FB0YW00.FB0YWWF1 = 0;
    FB0YW00.FB0YWWF1 = FB0YW00.FB0YWWF1 + FB0YW04.FB0YW1NS[FB0YWIX2];
    FB0YW00.FB0YWWF1 = FB0YW00.FB0YWWF1 + FB0YW04.FB0YW2NS[FB0YWIX2];
    FB0YW00.FB0YWWF1 = FB0YW00.FB0YWWF1 + FB0YW04.FB0YW3NS[FB0YWIX2];
    FB0YW00.FB0YWWF1 = FB0YW00.FB0YWWF1 + FB0YW04.FB0YW4NS[FB0YWIX2];
    FB0YW00.FB0YWWF1 = FB0YW00.FB0YWWF1 + FB0YW04.FB0YW5NS[FB0YWIX2];
    FB0YW04.FB0YWNMQ[FB0YWIX2] = FB0YW00.FB0YWWF1;
    FB0YW00.FB0YWIX2 = FB0YW00.FB0YWIX2 + 1;
  end
  ;
  ;
   /* ----------------------------------------------------*/
   /* Compare the total factory qty for each size with*/
   /* the RTA from row quantities, and adjust if a*/
   /* difference.*/
   /* ----------------------------------------------------*/
  ;
  FB0YW00.FB0YWIX1 = 1;
  ;
  while (FB0YW00.FB0YWIX1 <= 40)
    ;
    ;
    if (FB0YW04.FB0YWNMQ[FB0YWIX1] != FB0YW03.FB0YWTAQ[FB0YWIX1])
      FB0YW00.FB0YWWF1 = FB0YW03.FB0YWTAQ[FB0YWIX1];
      FB0YW00.FB0YWWF2 = FB0YW04.FB0YWNMQ[FB0YWIX1];
      FB0YW00.FB0YWWF3 = FB0YW00.FB0YWWF1 - FB0YW00.FB0YWWF2;
      if (FB0YW04.FB0YWHVI[FB0YWIX1] == 1) /* fcty 1 highest variance*/
        FB0YW04.FB0YW1NS[FB0YWIX1] = FB0YW04.FB0YW1NS[FB0YWIX1] + FB0YWWF3;
      end
      if (FB0YW04.FB0YWHVI[FB0YWIX1] == 2) /* fcty 2 highest variancw*/
        FB0YW04.FB0YW2NS[FB0YWIX1] = FB0YW04.FB0YW2NS[FB0YWIX1] + FB0YWWF3;
      end
      if (FB0YW04.FB0YWHVI[FB0YWIX1] == 3) /* fcty 3 highest variance*/
        FB0YW04.FB0YW3NS[FB0YWIX1] = FB0YW04.FB0YW3NS[FB0YWIX1] + FB0YWWF3;
      end
      if (FB0YW04.FB0YWHVI[FB0YWIX1] == 4) /* fcty 4 highest variance*/
        FB0YW04.FB0YW4NS[FB0YWIX1] = FB0YW04.FB0YW4NS[FB0YWIX1] + FB0YWWF3;
      end
      if (FB0YW04.FB0YWHVI[FB0YWIX1] == 5) /* fcty 5 highest variancw*/
        FB0YW04.FB0YW5NS[FB0YWIX1] = FB0YW04.FB0YW5NS[FB0YWIX1] + FB0YWWF3;
      end
    end
    FB0YW00.FB0YWIX1 = FB0YW00.FB0YWIX1 + 1;
  end
  ;
   /* ----------------------------------------------------*/
   /* update all of the factory rows from the from the*/
   /* saved FB7REC in the working storage FB0yw04 record.*/
   /* ----------------------------------------------------*/
  ;
  FB0YS06(); /* Update all factories processed*/
  ;
  ;
end // end FB0Y632

// Validate RTA Dates
Function FB0YS02()
  ;
  ;
  TA2REC.TA2GRTYP = "A"; /* gregorian mmddyy*/
  ;
  TA2REC.TA2DTOPT = "GREGGREG"; /* Validate and get greg formats*/
  ;
  try
    call "TA0040" (TA2REC) {isNoRefresh = yes, isExternal = yes};
  end /* date routine*/
  ;
  if (sysVar.errorCode == "00000000") /* Call successful*/
    return;
  else
    TAEREC.TAEDESC1 = sysVar.errorCode; /* CSP return code*/
    TAEREC.TAEDESC2 = TA2REC.TA2GRGG; /* date sent to validate*/
    ;
    FB0YM010.XXXPRCNM = "FB0YS02"; /* Module identification*/
    converseLib.validationFailed(01); /* Indicate system error*/
    ;
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    TA1REC.TA1TYPE = "APPL"; /* Type of error*/
    TA1REC.TA1LOC = "CALL TO TA0040 TO EDIT DATE  ";
    TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
    TA1REC.TA1PGMNO = FB0YM010.XXXPRCNM; /* Program number*/
    TA1REC.TA1MAPAP = COMMAREA.CACURRAP; /* Map application*/
    TA1REC.TA1MAPNO = "M010"; /* Map number*/
    ;
    call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/
    ;
    exit stack; /* Exit to display map*/
  end
  ;
  ;
  ;
  ;
end // end FB0YS02

// Open DFBUY.VMFBUY01 cursor
Function FB0YS03()
  ;
   /* ------------------------------------------------------------*/
   /* Declare cursor for DFBUY.VMFBUY01*/
   /* ------------------------------------------------------------*/
  ;
  FB0YW00.FB0YWMQC = "N"; /* Set merged qty cursor to no*/
  ;
  ;
  try
    call "IO3490" ("S1", SQLCA, FB7REC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/
  ;
  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/
    return;
  end
  ;
  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(19); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(01); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end
  ;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback(); /* Rollback if bad return code*/
  ;
  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "FB0YS03"; /* Process name*/
  TA1REC.TA1LOC = "DECLARE CURSOR          ";
  TA1REC.TA1DBASE = "DFBUY   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VMFBUY01"; /* Table view name*/
  ;
  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/
  ;
  FB0YM010.XXXPRCNM = "FB0YS03";
  exit stack;
  ;
end // end FB0YS03

// Fetch DFBUY.VMFBUY01 row
Function FB0YS04()
  ;
   /* ------------------------------------------------------------*/
   /* If row not found return to previous process.*/
   /* If any other, indicate system error.*/
   /* ------------------------------------------------------------*/
  ;
  ;
  try
    call "IO3490" ("N1", SQLCA, FB7REC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/
  ;
  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Row found*/
      return;
    end
    if (SQLCA.VAGen_SQLCODE == 100) /* Row not found*/
      FB0YW00.FB0YWMQC = "Y"; /* Indicate cursor at EOF*/
      return;
    end
    ;
  end
  ;
  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(19); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(01); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end
  ;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback(); /* Rollback if back return code*/
  ;
  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "FB0YS04"; /* Process name*/
  TA1REC.TA1LOC = "FETCH ROW               ";
  TA1REC.TA1DBASE = "DFBUY   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VMFBUY01"; /* Table view name*/
  ;
  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/
  ;
  FB0YM010.XXXPRCNM = "FB0YS04";
  exit stack;
  ;
end // end FB0YS04

// Close DFBUY.VFMBUY01 cursor
Function FB0YS05()
  ;
   /* ------------------------------------------------------------*/
   /* Close cursor for dfbuy.vmfbuy01*/
   /* ------------------------------------------------------------*/
  ;
  try
    call "IO3490" ("C1", SQLCA, FB7REC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/
  ;
  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/
    return;
  end
  ;
  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(19); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(01); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end
  ;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback(); /* Rollback if bad return code*/
  ;
  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "FB0YS05"; /* Process name*/
  TA1REC.TA1LOC = "CLOSE CURSOR            ";
  TA1REC.TA1DBASE = "DFBUY   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VFMBUY01"; /* Table view name*/
  ;
  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/
  ;
  FB0YM010.XXXPRCNM = "FB0YS05";
  exit stack;
  ;
end // end FB0YS05

// Update all factories processed
Function FB0YS06()
  ;
   /* ----------------------------------------------------*/
   /* Update all of the factory rows from the*/
   /* saved FB7REC in the working storage FB0yw04 record.*/
   /* ----------------------------------------------------*/
  ;
  ;
  FB0YW00.FB0YWIX1 = 1;
  ;
  while (FB0YW00.FB0YWIX1 <= 5) /* Max nbr of factories*/
    ;
    if (FB0YW04.FY1FCTYC[FB0YWIX1] != " ")
      set FB7REC empty;
      FB7REC.FB7GROUP = FB0YW04.FB0YWRCD[FB0YWIX1];
      if (FB0YW00.FB0YWIX1 == 1) /* Update  fcty 1*/
        move FB0YW04.FB0YW1NS to FB7REC.FB7QTB[1] for all;
        FB0YS07(); /* Update Merged qty table*/
      end
      if (FB0YW00.FB0YWIX1 == 2) /* Update  fcty 2*/
        move FB0YW04.FB0YW2NS to FB7REC.FB7QTB[1] for all;
        FB0YS07(); /* Update Merged qty table*/
      end
      if (FB0YW00.FB0YWIX1 == 3) /* Update fcty 3*/
        move FB0YW04.FB0YW3NS to FB7REC.FB7QTB[1] for all;
        FB0YS07(); /* Update Merged qty table*/
      end
      if (FB0YW00.FB0YWIX1 == 4) /* Update fcty 4*/
        move FB0YW04.FB0YW4NS to FB7REC.FB7QTB[1] for all;
        FB0YS07(); /* Update Merged qty table*/
      end
      if (FB0YW00.FB0YWIX1 == 5) /* Update fcty 5*/
        move FB0YW04.FB0YW5NS to FB7REC.FB7QTB[1] for all;
        FB0YS07(); /* Update Merged qty table*/
      end
    end
    FB0YW00.FB0YWIX1 = FB0YW00.FB0YWIX1 + 1;
  end
  ;
  ;
  ;
end // end FB0YS06

// Update merged qty tables
Function FB0YS07()
  ;
   /* ------------------------------------------------------------*/
   /* This module updates a table row.*/
   /* It will return and document system errors if unexpected*/
   /* return codes are found.*/
   /* ------------------------------------------------------------*/
  ;
  XX0XS01();
  FB7REC.ZZZCHGDT = XX0XW01.XX0XWDAT;
  FB7REC.ZZZCHGTM = XX0XW01.XX0XWTIM;
  ;
  ;
  ;
  try
    call "IO3490" ("U ", SQLCA, FB7REC) {isNoRefresh = yes, isExternal = yes};
  end /* Delete table row*/
  ;
  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Expected return codes*/
      ;
      return; /* Return to previous process*/
      ;
    end
    if (SQLCA.VAGen_SQLCODE == 100) /* row not found*/
      VGVar.handleSysLibraryErrors = 0;
      sysLib.rollback(); /* Rollback if bad return code*/
      FB0YW00.XXXMSGNO = 20; /* Record has been updated etc.*/
      set FB0YM010 empty;
      set FB0YW02 empty;
      set FB0YW03 empty;
      set FB0YW04 empty;
      FB0YW00.FB0YWRDF = "Y"; /* request for data*/
      FB0YW00.FB0YWQAF = "N"; /* quantities adjusted flag*/
      exit stack;
    end
  end
  ;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback();
  ;
  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(19); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(01); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
     /* Clear screen before redisplay*/
  end
  ;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback(); /* Rollback if bad return code*/
  ;
  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "FB0YS07 "; /* Process name*/
  TA1REC.TA1LOC = "UPDATE TABLE ROW";
  TA1REC.TA1DBASE = "DFBUY   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VMFBUY01"; /* Table view name*/
  ;
  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/
  ;
  FB0YM010.XXXPRCNM = "FB0YS07"; /* Process name*/
  ;
  exit stack;
  ;
  ;
end // end FB0YS07

// OBtain VSUSER01 row
Function FB0YS08()
  ;
  ;
   /* -------------------------------------------------*/
    /* Format key*/
   /* -------------------------------------------------*/
  ;
  set PG1REC empty;
  ;
  PG1REC.XGPCD = "02"; /* Footwear*/
  PG1REC.PG1SC4CD = "**"; /* Scheduler code*/
  PG1REC.PG1FCTCD = "**"; /* Forecast code*/
  if (FBXREC.CAUSERID != " ")
    PG1REC.XXXUSER = FBXREC.CAUSERID; /* User id*/
  else
    PG1REC.XXXUSER = COMMAREA.CAUSERID; /* User id*/
  end
  ;
  try
    call "IO1200" ("SA", SQLCA, PG1REC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/
  ;
  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Row found*/
      return;
    end
    if (SQLCA.VAGen_SQLCODE == 100) /* Row found*/
      FB0YW00.FB0YWISF = "Y";
      return;
    end
  end
  ;
  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(19); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(01); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end
  ;
  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "FB0YS08"; /* Process name*/
  TA1REC.TA1LOC = "FETCH SCHEDULER CODE    ";
  TA1REC.TA1DBASE = "DPRODG  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VSUSER01"; /* Table view name*/
  ;
  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/
  ;
  FB0YM010.XXXPRCNM = "FB0YS08";
  exit stack;
  ;
  ;
  ;
end // end FB0YS08

// Obtain VFSCTL01 row
Function FB0YS09()
  ;
   /* -------------------------------------------------*/
   /* Initialize record--and format key*/
  ;
   /* -------------------------------------------------*/
  ;
  set FBMREC empty;
  FBMREC.PG1SC4CD = PG1REC.PG1SC4CD;
  ;
  try
    call "IO4670" ("S ", SQLCA, FBMREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/
  ;
  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Row found*/
      return;
    end
    if (SQLCA.VAGen_SQLCODE == 100) /* Row found*/
      FB0YW00.FB0YWISF = "Y"; /* Invalid scheduler flag*/
      return;
    end
    ;
  end
  ;
  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(19); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(01); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end
  ;
  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "FB0YS09"; /* Process name*/
  TA1REC.TA1LOC = "FETCH FOOTWEAR SCHEDULER";
  TA1REC.TA1DBASE = "DFBUY   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VFSCTL01"; /* Table view name*/
  ;
  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/
  ;
  FB0YM010.XXXPRCNM = "FB0YS09";
  exit stack;
  ;
  ;
end // end FB0YS09

// Obtain control record
Function FB0YS10()
  ;
  ;
  set FB9REC empty;
  ;
  try
    call "IO3650" ("S ", SQLCA, FB9REC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/
  ;
  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == 0)      /* Row found*/
    return;
  end
  ;
  ;
  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(19); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(01); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end
  ;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback(); /* Rollback if bad return code*/
  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "FB0YS10"; /* Process name*/
  TA1REC.TA1LOC = "FETCH CONTROL RECORD    ";
  TA1REC.TA1DBASE = "DFBUY   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VFMCTL01"; /* Table view name*/
  ;
  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/
  ;
  FB0YM010.XXXPRCNM = "FB0YS10";
  exit stack;
  ;
  ;
end // end FB0YS10

// Get VFBLAV01 row
Function FB0YS11()
  ;
  ;
  set FBLREC empty;
  FBLREC.SY1STNBR = FB0YW01.SY1STNBR;
  FBLREC.SY2CLRID = FB0YW01.SY2CLRID;
  FBLREC.XDMCD = FB0YW01.XDMCD;
  FBLREC.XQACD = "01";
  FBLREC.XPGCD = "00";
  FBLREC.XUMCD = "01";
  FBLREC.XWHCD = "02";
  ;
  FBLREC.FB8BUYDT = FB0YW00.FB8BUYDT;
  ;
  /*  */
  /* ******************************* Y2K OUT BEGIN **************************/
  /*  */
  /* CALL IO4680 'S ',SQLCA,FBLREC (NOMAPS,NONCSP,REPLY; /* Select row*/
  /*  */
  /* ******************************* Y2K OUT END ****************************/
  /*  */
  /*  */
  /* ******************************* Y2K IN BEGIN ***************************/
  /*  */
  try
    call "VFBLAV02" ("S ", SQLCA, FBLREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/
  /*  */
  /* ******************************* Y2K IN END *****************************/
  /*  */
  ;
  if (sysVar.errorCode == "00000000") /* Successful call*/
    if (SQLCA.VAGen_SQLCODE == 0 /* Row found*/
     || SQLCA.VAGen_SQLCODE == 100) /* Row not found*/
      return;
    end
  end
  ;
  ;
  if (sysVar.errorCode == "00000000" /* Successful call*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    converseLib.validationFailed(19); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
  else
    converseLib.validationFailed(01); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
    
  end
  ;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback(); /* Rollback if bad return code*/
  TA1REC.TA1MAP = sysVar.errorCode; /* Csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* Sql comm. area*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1PGMNM = "FB0YS11"; /* Process name*/
  TA1REC.TA1LOC = "FETCH CONTROL RECORD    ";
  TA1REC.TA1DBASE = "DFBUY   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VFBLAV01"; /* Table view name*/
  ;
  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/
  ;
  FB0YM010.XXXPRCNM = "FB0YS11";
  exit stack;
  ;
  ;
end // end FB0YS11

// Round size qty by case
Function FB0YS15()
  ;
  if (PG2REC.SY1UNPCS == 0)
    PG2REC.SY1UNPCS = 12; /* Default value*/
  end
  ;
  FB0YW00.FB0YWDIV = FB0YW00.FB0YWNUQ / PG2REC.SY1UNPCS;
  ;
  if (FB0YW00.FB0YWREM == 0)
    FB0YW00.FB0YWNRQ = FB0YW00.FB0YWNUQ;
  else
    FB0YW00.FB0YW-DECRMT-CNTR = 0;
    while (FB0YW00.FB0YWREM != 0)
      FB0YW00.FB0YWNUQ = FB0YW00.FB0YWNUQ - 1; /* Decrement qty*/
      FB0YW00.FB0YW-DECRMT-CNTR = FB0YW00.FB0YW-DECRMT-CNTR + 1;
      FB0YW00.FB0YWDIV = FB0YW00.FB0YWNUQ / PG2REC.SY1UNPCS;
    end
    ;
    if (FB0YW00.FB0YW-DECRMT-CNTR > 5)
      FB0YW00.FB0YWNUQ = FB0YW00.FB0YWNUQ + PG2REC.SY1UNPCS;
    end
    FB0YW00.FB0YWNRQ = FB0YW00.FB0YWNUQ;
  end
  ;
  ;
end // end FB0YS15

//*** RECORD=FB0YW00 ****
// ---------------------------
// Application Working Storage
// ---------------------------
// ***********************
Record FB0YW00 type basicRecord
  5 * char(836) ; 
    10 FB0YWRDF FB0YWRDF ; 
    10 FB0YWTSP FB0YWTSP ; 
    10 FB0YWMQC FB0YWMQC ; 
    10 FB0YWKFC FB0YWKFC ; 
    10 FB0YWSSR FB0YWSSR ; 
    10 FB0YWUDF FB0YWUDF ; 
    10 FB0YWQAF FB0YWQAF ; 
    10 FB0YWISF FB0YWISF ; 
    10 FB0YWFPF FB0YWFPF ; 
    10 FB0YWTRQ FB0YWTRQ ; 
    10 SY1STNBR SY1STNBR ; 
    10 SY2CLRID SY2CLRID ; 
    10 XDMCD XDMCD ; 
    10 FB0YWBDT FB0YWBDT ; 
    10 FB0YWTRD FB0YWTRD ; 
    10 * char(1) ; 
    10 FB0YWFDT FB0YWFDT ; 
      15 FB0YWFCR FB0YWFCR ; 
      15 FB0YWFYM FB0YWFYM ; 
        20 FB0YWFYY FB0YWFYY ; 
        20 FB0YWFMM FB0YWFMM ; 
      15 FB0YWFDD FB0YWFDD ; 
    10 FB0YWRTA FB0YWRTA ; 
      15 FB0YWRMM FB0YWRMM ; 
      15 FB0YWRDD FB0YWRDD ; 
      15 FB0YWRYY FB0YWRYY ; 
    10 FB0YWSDT FB0YWSDT ; 
      15 FB0YWSYY FB0YWSYY ; 
      15 FB0YWSMM FB0YWSMM ; 
      15 FB0YWSDD FB0YWSDD ; 
    10 FB8BUYDT FB8BUYDT ; 
    10 TA1TBLKE TA1TBLKE ; 
    10 FB0YWIXM FB0YWIXM ; 
    10 FB0YWIX1 FB0YWIX1 ; 
    10 FB0YWIX2 FB0YWIX2 ; 
    10 FB0YWIX3 FB0YWIX3 ; 
    10 FB0YWIX4 FB0YWIX4 ; 
    10 FB0YWFSI FB0YWFSI ; 
    10 FB0YWLSI FB0YWLSI ; 
    10 FB0YWSZB FB0YWSZB ; 
    10 FB0YWCSI FB0YWCSI ; 
    10 FB0YWSTI FB0YWSTI ; 
    10 FB0YWZHD FB0YWZHD [40] ; 
    10 FB0YWNUQ FB0YWNUQ ; 
    10 FB0YWNRQ FB0YWNRQ ; 
    10 FY2MFGPC FY2MFGPC ; 
    10 * char(1) ; 
    10 FB0YWWF1 FB0YWWF1 ; 
    10 FB0YWWF2 FB0YWWF2 ; 
    10 FB0YWWF3 FB0YWWF3 ; 
    10 FB0YWWF4 FB0YWWF4 ; 
    10 FB0YWWD1 FB0YWWD1 ; 
    10 FB0YWWD2 FB0YWWD2 ; 
    10 FB0YWWD3 FB0YWWD3 ; 
    10 FB0YWUQT FB0YWUQT ; 
    10 FB0YWDIV FB0YWDIV ; 
      15 FB0YWINT FB0YWINT ; 
      15 FB0YWREM FB0YWREM ; 
    10 * char(1) ; 
    10 FB0YWFSN FB0YWFSN [50] ; 
    10 FB0YWLSN FB0YWLSN [50] ; 
    10 XXXMSGNO XXXMSGNO ; 
    10 FB0YW-DECRMT-CNTR FB0YW-DECRMT-CNTR ; 
end // end FB0YW00

//*** RECORD=FB0YW01 ****
// Fb0ym010 map heading storage record
// ***********************
Record FB0YW01 type basicRecord
  5 * char(261) ; 
    10 SY1STNBR SY1STNBR ; 
    10 SY2CLRID SY2CLRID ; 
    10 XDMCD XDMCD ; 
    10 SY1SSTNM SY1SSTNM ; 
    10 SY2CLRAB SY2CLRAB ; 
    10 XQACD XQACD ; 
    10 PC2INSEG PC2INSEG ; 
    10 XPGCD XPGCD ; 
    10 XUMCD XUMCD ; 
    10 XWHCD XWHCD ; 
    10 FB0YWFRT FB0YWFRT ; 
    10 FB0YWTRT FB0YWTRT ; 
    10 FB0YWFAA FB0YWFAA ; 
    10 FB0YWSZS FB0YWSZS ; 
    10 FB0YWSZD FB0YWSZD [40] ; 
end // end FB0YW01

//*** RECORD=FB0YW02 ****
// This record is used to define the rta from map data
// ***********************
Record FB0YW02 type basicRecord
  5 FB0YW02R FB0YW02R ; 
    10 FB0YWFRD FB0YWFRD ; 
    10 FB7RTADT FB7RTADT ; 
    10 FB7RTAPC FB7RTAPC ; 
    10 FB0YWFCQ FB0YWFCQ [40] ; 
    10 FB0YWFAJ FB0YWFAJ [40] ; 
    10 FB0YWFAQ FB0YWFAQ [40] ; 
    10 FB0YWFCT FB0YWFCT ; 
    10 FB0YWFAT FB0YWFAT ; 
    10 FB0YWFTQ FB0YWFTQ ; 
    10 FB0YWFRC FB0YWFRC ; 
end // end FB0YW02

//*** RECORD=FB0YW03 ****
// This record is used to define the rta to map data
// ***********************
Record FB0YW03 type basicRecord
  5 FB0YW03R FB0YW03R ; 
    10 FB0YWTRD FB0YWTRD ; 
    10 FB7RTADT FB7RTADT ; 
    10 FB7RTAPC FB7RTAPC ; 
    10 FB0YWTCQ FB0YWTCQ [40] ; 
    10 FB0YWTAQ FB0YWTAQ [40] ; 
    10 FB0YWTCT FB0YWTCT ; 
    10 FB0YWTAT FB0YWTAT ; 
    10 FB0YWTTQ FB0YWTTQ ; 
    10 FB0YWTRC FB0YWTRC ; 
end // end FB0YW03

//*** RECORD=FB0YW04 ****
// FB0y merged qty to buy table record
// ***********************
Record FB0YW04 type basicRecord
  5 FB0YW04G FB0YW04G ; 
    10 FB0YW1NS FB0YW1NS [40] ; 
    10 FB0YW2NS FB0YW2NS [40] ; 
    10 FB0YW3NS FB0YW3NS [40] ; 
    10 FB0YW4NS FB0YW4NS [40] ; 
    10 FB0YW5NS FB0YW5NS [40] ; 
    10 FB0YWHVI FB0YWHVI [40] ; 
    10 FB0YWHVA FB0YWHVA [40] ; 
    10 FB0YWNUQ FB0YWNUQ ; 
    10 FB0YWNRQ FB0YWNRQ ; 
    10 FB0YWNMQ FB0YWNMQ [40] ; 
    10 FB0YW04R FB0YW04R [5] ; 
      15 FY1FCTYC FY1FCTYC ; 
      15 XWHCD XWHCD ; 
      15 FY2MFGPC FY2MFGPC ; 
      15 FB0YWRCD FB0YWRCD ; 
end // end FB0YW04

// Decrement counter
DataItem FB0YW-DECRMT-CNTR num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

DataItem FB0YW02R char(746)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem FB0YW03R char(586)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem FB0YW04G char(2530)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem FB0YW04R char(264)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Factory 1 new size array
DataItem FB0YW1NS int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Factory 2 new size array
DataItem FB0YW2NS int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Factory 3 new size array
DataItem FB0YW3NS int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Factory 4 new size array
DataItem FB0YW4NS int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Factory 5 new size array
DataItem FB0YW5NS int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// buy date
DataItem FB0YWBDT num(8)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// current size index
DataItem FB0YWCSI smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// quantity divide
DataItem FB0YWDIV num(7,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// from adjusted amount
DataItem FB0YWFAA int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// from adjusted array
DataItem FB0YWFAJ int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// from adjusted quantity array
DataItem FB0YWFAQ int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// from adjusted total
DataItem FB0YWFAT int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// from current quantity array
DataItem FB0YWFCQ int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Reformat century
DataItem FB0YWFCR num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// from current total
DataItem FB0YWFCT int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Reformat day
DataItem FB0YWFDD num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Reformat date CCYYmmdd
DataItem FB0YWFDT num(8)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Reformat month
DataItem FB0YWFMM num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Fast path flag
DataItem FB0YWFPF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// FBFrec copy
DataItem FB0YWFRC char(241)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// from RTA date
DataItem FB0YWFRD num(6)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// from rta date
DataItem FB0YWFRT int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// First size index
DataItem FB0YWFSI smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

DataItem FB0YWFSN char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// from total quantity
DataItem FB0YWFTQ int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Reformat date yymm
DataItem FB0YWFYM num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Reformat year
DataItem FB0YWFYY num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// saved highest variance
DataItem FB0YWHVA decimal(7,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// High variance size index
DataItem FB0YWHVI num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// integer number
DataItem FB0YWINT num(5)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Invalid scheduler flag
DataItem FB0YWISF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// General index 1
DataItem FB0YWIX1 smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// General index 2
DataItem FB0YWIX2 smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// General index 3
DataItem FB0YWIX3 smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// General index 4
DataItem FB0YWIX4 smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Map index
DataItem FB0YWIXM smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Key fields changed flag
DataItem FB0YWKFC char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// last size index
DataItem FB0YWLSI smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

DataItem FB0YWLSN char(6)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// merged qty cursor flag
DataItem FB0YWMQC char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// new from rta size quantities
DataItem FB0YWNMQ int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// new qty by size (rounded)
DataItem FB0YWNRQ decimal(9,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// new qty by size (unrounded)
DataItem FB0YWNUQ decimal(9,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// quantities adjusted flag
DataItem FB0YWQAF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// FB7REC copy
DataItem FB0YWRCD char(255)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// rta day
DataItem FB0YWRDD num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Request for data flag
DataItem FB0YWRDF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// remainted
DataItem FB0YWREM num(2,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// rta month
DataItem FB0YWRMM num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Reformat rta date
DataItem FB0YWRTA num(6)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// rta year
DataItem FB0YWRYY num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// System day
DataItem FB0YWSDD num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// System date
DataItem FB0YWSDT num(6)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// System month
DataItem FB0YWSMM num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// size scroll requested flag
DataItem FB0YWSSR char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// style index
DataItem FB0YWSTI smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// System year
DataItem FB0YWSYY num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// size buckets for display
DataItem FB0YWSZB smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// size description
DataItem FB0YWSZD char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Size scroll
DataItem FB0YWSZS num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// to adjusted quantity array
DataItem FB0YWTAQ int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// to adjusted total
DataItem FB0YWTAT int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// to current quantity array
DataItem FB0YWTCQ int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// to current total
DataItem FB0YWTCT int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// FBFREC copy
DataItem FB0YWTRC char(241)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// to RTA date
DataItem FB0YWTRD num(6)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// total RTA quantity
DataItem FB0YWTRQ int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// to rta date
DataItem FB0YWTRT int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Increment and decrement page
DataItem FB0YWTSP num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// to total quantity
DataItem FB0YWTTQ int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// UPdate flag
DataItem FB0YWUDF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// unrounded qty
DataItem FB0YWUQT num(9,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// work decimal field
DataItem FB0YWWD1 num(5,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// work decimal field
DataItem FB0YWWD2 num(5,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// work decimal field
DataItem FB0YWWD3 num(5,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// work field 1
DataItem FB0YWWF1 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// work field 2
DataItem FB0YWWF2 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// work field 3
DataItem FB0YWWF3 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// work field 4
DataItem FB0YWWF4 int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// size has data flag
DataItem FB0YWZHD char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

