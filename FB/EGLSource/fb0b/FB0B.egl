package fb0b;

import corpcom2.XX0XW01;
import corpcom2.YSMREC;
import corpcom3.XPFB001;
import corpcom3.XPTA0P;
import corpcom4.XSEXIT;
import corpcom4.XX0XS01;
import corpcom5.COMMAREA;
import corpcom6.SQLCA;
import corpx1.XDVCD;
import corpx1.XDVDESC;
import corpx1.XGPCD;
import corpx1.XWHTBL;
import corpx2.XPCCD;
import corpx2.XPCKEY;
import corpx2.XPCSDESC;
import corpx2.XPRABRV;
import corpx2.XPRCD;
import corpx2.XSUABRV;
import corpx2.XSUCD;
import corpx2.XWHABRV;
import corpx2.XWHCD;
import corpy2.YPPCD;
import corpy2.YPPDESC;
import corpy2.YSMXOT;
import fb.common.FB1CMNT;
import fb.common.FB1DUMNB;
import fb.common.FB1INCDS;
import fb.common.FB1REC;
import fb.common.FB4REC;
import fb.common.FB5REC;
import fb.common.FB6REC;
import fb.common.FBWREC;
import ta.common.TA1REC;
import ta.common.TA3REC;
import ta.common.TA5REC;
import ta.common.TA6REC;
import ta.common.TAEREC;
//*** PROGRAM=FB0B ****
// This application is used in conjuction with FB0A which
// inserts selection parameters into a DB2 table and submits
// the demand history extract that uses those parameters. In
// the case where the user wants the orders from certain ware-
// houses combined with other warehouses, this application is
// invoked.
// Upon entry it displays the selection criteria that will be
// used in extracting orders from the demand history data base
// to create a size distribution curve.  The user will enter
// the warehouses that need to be combined and hit PF9 (update)
// The application then submits the extract job along with the
// combined warehouse parameters.
// 
//   DATE      NAME          DESCRIPTION OF CHANGE
// --------   ------         --------------------------
// 04/02/89   W.DISHM        New application.
// 06/10/92   JMCLAU         June table changes. add
//                           xdv-div-cd1-3 and xgp-gpc-cd1-8.
// 07/08/92   JMCLAU         FB-284 Modify jcl tables to
// 07/08/92   JMCLAU         FB-284 Modify jcl tables to
//                           run cobol 2 application fb107d.
// 03/30/93   LDELUH         Allow actual DRS region codes
//                           for "from" region not just "00".
// 07/31/96   RTRAN          Hockey - Changed map to allow from
//                           three warehouses to ten warehouses
//                           Modified processes to coordinate
//                           the new changes.
// 12/26/96   RTRAN          Changed program to validate more
//                           than 10 warehouses, and combine
//                           directship correctly.
// *********************
Program FB0B type textUIProgram //VAGen Info - main text program
  {
  includeReferencedFunctions = yes, allowUnqualifiedItemReferences = yes, 
  throwNrfEofExceptions = yes, handleHardIOErrors = no, V60ExceptionCompatibility = yes, 
  I4GLItemsNullable = no, textLiteralDefaultIsString = no, localSQLScope = yes, 
  msgTablePrefix = "FF00", inputRecord = COMMAREA, segmented = yes
  }

  // Data Declarations
  COMMAREA COMMAREA ; // record
  FB0BW00 FB0BW00; // record
  FB0BW01 FB0BW01; // record
  FB0BW02 FB0BW02; // record
  FB0BW03 FB0BW03; // record
  FB1REC FB1REC; // record
  FB4REC FB4REC; // record
  FB5REC FB5REC; // record
  FB6REC FB6REC; // record
  FBWREC FBWREC; // record
  SQLCA SQLCA; // record
  TA1REC TA1REC; // record
  TA3REC TA3REC; // record
  TA5REC TA5REC; // record
  TA6REC TA6REC; // record
  TAEREC TAEREC; // record
  XX0XW01 XX0XW01; // record
  YSMREC YSMREC; // record

  // VAGen Info - items needed for migration
  VAGen_EZESYS char(8);
  VAGen_EZEREPLY num(1);
  VAGen_EZE_WAIT_TIME bin(9,2);
  VAGen_EZE_ITEMLEN int;

  // Use Declarations
  use FB0BT01 {deleteAfterUse = yes}; // table
  use FB0BT02 {deleteAfterUse = yes}; // table
  use XWHTBL {deleteAfterUse = yes}; // table
  use FB0BM.FB0BM010 // form
   {
    pfKeyEquate = no
  };

  function main()
    // VAGen Info - initialization needed for migration
    VAGen_EZESYS = VGLib.getVAGSysType();
    XPFB001: XPFB001();
     /* ------------------------------------------------------------*/
     /* Initialize working storage and map output areas.*/
     /* Flow to converse the main process.*/
     /* ------------------------------------------------------------*/
    ;
    set FB0BW00 empty; /* Initialize working storage*/
    set FB0BW01 empty; /* Initialize map storage area*/
    set FB0BW02 empty; /* Initialize JCL parms*/
    set FB0BM010 initial; /* M010 input/output*/
    set SQLCA empty; /* Sql communication area*/
    set TAEREC empty; /* Error diagnosis information*/
    set TA1REC empty; /* Error diagnosis parameters*/
    set TA6REC empty; /* Xptaop work record*/
    set XX0XW01 empty; /* Date/time subroutine parameters*/
    ;
    FB0BW00.FB0BWDSW = "Y"; /* Display data flag*/
    FB0BW00.FB0BWPRF = "Y"; /* Processing flag*/
    ;
    if (COMMAREA.CAFROMAP != "FB0A") /* Not from selection parameters*/
      FB0BW00.FB0BWDSW = "N"; /* Obtain data flag*/
      FB0BW00.FB0BWPRF = "N"; /* Set processing flagto no*/
      converseLib.validationFailed(92); /* Cannot fastpath to this aplication*/
    else
      ;
      if (FBWREC.FB1INSEQ == 0)
        FB0BW00.FB0BWDSW = "N"; /* Obtain data flag*/
        FB0BW00.FB0BWPRF = "N"; /* Set processing flag to no*/
        converseLib.validationFailed(93); /* No selection parameters*/
      end
    end
    ;
    goto FB0B001; /* Converse main process*/
    ;
    ;
    FB0B001: FB0B001();
     /* ------------------------------------------------------------*/
     /* Flow to converse the footware combine regions process.*/
     /* ------------------------------------------------------------*/
    ;
    goto FB0B001; /* Converse combine regions*/
    ;
    ;
  end // end main
end // end FB0B

// Combine regions
Function FB0B001()
   /* ------------------------------------------------------------*/
   /* This is the main process used to display a map.  Processing*/
   /* always returns to the top of this process and falls through*/
   /* subordinate processes until an error is found or a valid*/
   /* request is processed.  Processing sequence is as follows:*/
  ;
   /* 1) display appropriate map.*/
   /* 2) Check the attention identifier used to respond.*/
   /* 3) Reset highlighted fields to normal intensity.*/
   /* 4) Verify the data that was entered.*/
   /* 5) Process a valid input request.*/
  ;
   /* In all subordinate processes, "EZEFLO" is used to exit to*/
   /* redisplay the map when an error is found.  This is done to*/
   /* minimize the coding effort required to skip subsequent*/
   /* processing under error conditions.*/
   /* ------------------------------------------------------------*/
  ;
  FB0B100(); /* Obtain data to display*/
  ;
  FB0B200(); /* Format and display the map*/
  ;
  FB0B300(); /* Check attention identifier*/
  ;
  FB0B400(); /* Reset fields to normal intensity*/
  ;
  FB0B500(); /* Verify the entered data*/
  ;
  FB0B600(); /* Process valid input request*/
  ;
  ;
end // end FB0B001

// Obtain data to display
Function FB0B100()
   /* ------------------------------------------------------------*/
   /* If an error was found or no data was requested return to*/
   /* the previous process.*/
   /* ------------------------------------------------------------*/
  ;
  if (FB0BW00.FB0BWDSW == "N" /* data not requested*/
   || converseVar.validationMsgNum != 0) /* Error found*/
    return;
  end
  ;
  FB0BS09(); /* Load summary code array*/
  ;
   /* ------------------------------------------------------------*/
   /* Obtain selection criteria data*/
   /* ------------------------------------------------------------*/
  ;
  FB0B110(); /* Get vselhd01 row*/
  ;
  ;
  FB0B130(); /* Get vseldt01 data*/
  ;
  ;
  FB0B150(); /* Get warehouse codes and descriptions*/
  ;
  ;
  FB0BW00.FB0BWDSW = "N"; /* display data switch*/
  ;
  ;
  ;
end // end FB0B100

// Get vselhd01 row
Function FB0B110()
   /* ------------------------------------------------------------*/
   /* Initialize the storage areas and record key*/
   /* ------------------------------------------------------------*/
  ;
  ;
  set FB1REC empty; /* Clear row storage area*/
  ;
  FB1REC.FB1INSEQ = FBWREC.FB1INSEQ; /* internal seq nbr*/
  ;
   /* ------------------------------------------------------------*/
   /* Select the requested row from the table.*/
   /* ------------------------------------------------------------*/
  ;
  try
    call "IO3030" ("S ", SQLCA, FB1REC) {isNoRefresh = yes, isExternal = yes};
  end /* Select table row*/
  ;
   /* ------------------------------------------------------------*/
   /* If successful, save the data in display storage and return*/
   /* to the previous process.*/
   /* ------------------------------------------------------------*/
  ;
  if (sysVar.errorCode == "00000000") /* Call successful*/
    ;
    if (SQLCA.VAGen_SQLCODE == 0) /* Normal return code*/
      ;
      FB0BW01.FB1CMNT = FB1REC.FB1CMNT; /* Comments*/
      FB0BW01.FB1INCDS = FB1REC.FB1INCDS;
      FB0BW01.XDVCD = FB1REC.XDVCD; /* Division code*/
      FB0BW00.FB0BWSQN = FB1REC.FB1INSEQ; /* Sequence number*/
      ;
      return; /* Return to previous process*/
      ;
    end
    ;
  end
  ;
   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* if data not found abort the applicaton otherwiseindicated*/
   /* that a system error has occured*/
   /* ------------------------------------------------------------*/
  ;
  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/
  ;
  FB0BM010.XXXMODID = "110"; /* Module identification*/
  ;
  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    ;
    converseLib.validationFailed(19); /* 'Resources unavailabe'*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
    ;
  else
    converseLib.clearScreen();
     /* Clear screen before display*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.validationFailed(01); /* 'error - please notify programming'*/
    ;
    ;
  end
  ;
  ;
  ;
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "FETCH VSELHD01 ROW  ";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FB0BM010.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFBUY   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VSELHD01"; /* Table view name*/
  TA1REC.TA1TBLKE = FB1REC.FB1KEY; /* Table key*/
  ;
  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/
  ;
  exit stack; /* Exit to display map*/
  ;
  ;
end // end FB0B110

// GET vseldt01 data
Function FB0B130()
  ;
   /* ------------------------------------------------------------*/
   /* IO to select and open vseldt01*/
   /* ------------------------------------------------------------*/
  ;
  FB0B131(); /* Open cursor for vseldt01*/
  ;
   /* ------------------------------------------------------------*/
   /* Fetch the first vseldt01 row*/
   /* ------------------------------------------------------------*/
  ;
  FB0B132(); /* Get first vseldt01 row*/
  ;
   /* ------------------------------------------------------------*/
   /* if there are no rows in the set it is a fatal error.*/
   /* ------------------------------------------------------------*/
  ;
  if (FB0BW00.FB0BWDCF == "Y") /* end of cursor on first fetch*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    TA1REC.TA1TYPE = "APPL"; /* Type of error*/
    TA1REC.TA1LOC = "FIRST FETCH ON VSELDT01 TBL ";
    TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
    TA1REC.TA1PGMNO = "130"; /* Program number*/
    TAEREC.TAEDESC2 = "VSELHD01 ROW EXISTS WITH NO DATE ROW";
    ;
    call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/
    ;
    COMMAREA.CATOAP = "FY0M"; /* To application*/
    XSEXIT();
    FB0BM010.VAGen_EZEMSG = COMMAREA.CAMSG; /* If bad transfer*/
    converseLib.validationFailed(); /* Bypass additional processing*/
    exit stack;
    ;
  end
  ;
   /* ------------------------------------------------------------*/
   /* The map can display only two sets of need dates,*/
   /* consequently only two sets of dates will be retrieved.*/
   /* ------------------------------------------------------------*/
  ;
  FB0BW00.FB0BWDTC = 0; /* Initialize date counter*/
  FB0BW00.FB0BWIX1 = 0; /* Initialize index (moves date to map)*/
  FB0BW00.FB0BWIX2 = 0; /* Initialize index (moves order/type/*/
                                   /* group code to map)*/
  ;
  ;
  while (FB0BW00.FB0BWDCF != "Y" /* Not end of set*/
   && FB0BW00.FB0BWDTC < 2) /* and no more than two dates retrieved*/
    ;
    FB0B133(); /* Get need dates*/
    ;
  end
  ;
  ;
   /* ------------------------------------------------------------*/
   /* IO to close vseldt01 set*/
   /* ------------------------------------------------------------*/
  FB0B134(); /* Close cursor for vseldt01*/
end // end FB0B130

// open cursor vseldt01
Function FB0B131()
   /* ------------------------------------------------------------*/
   /* Initialize the storage areas and indicators to be used*/
   /* ------------------------------------------------------------*/
  ;
  set FB5REC empty; /* clear row storage area*/
  FB0BW00.FB0BWDCF = "N"; /* End of vseldt01 flag*/
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Format the key with fbwrec sequence number*/
   /* ------------------------------------------------------------*/
  ;
  FB5REC.FB1INSEQ = FBWREC.FB1INSEQ;
  ;
   /* ------------------------------------------------------------*/
   /* Select the requested set of rows from the table.*/
   /* ------------------------------------------------------------*/
  ;
  try
    call "IO3040" ("S1", SQLCA, FB5REC) {isNoRefresh = yes, isExternal = yes};
  end /* Select table set*/
  ;
   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/
  ;
  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/
    ;
    return; /* Return to previous process*/
    ;
  end
  ;
   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/
  ;
  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/
  ;
  FB0BM010.XXXMODID = "131"; /* Module identification*/
  ;
  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/
    ;
    converseLib.validationFailed(19); /* 'Resources unavailable'*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
    ;
  else
    ;
    converseLib.validationFailed(01); /* 'Error - Please nofity programming'*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    ;
    converseLib.clearScreen();
     /* Clear screen before display*/
    ;
  end
  ;
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "IO TO OPEN DFBUY.VSELDT01";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FB0BM010.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFBUY   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VSELDT01"; /* Table view name*/
  TA1REC.TA1TBLKE = FB5REC.FB5KEY; /* Table key*/
  ;
  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/
  ;
  exit stack; /* Exit to display map*/
  ;
  ;
  ;
end // end FB0B131

// Get next vseldt01 row
Function FB0B132()
   /* ------------------------------------------------------------*/
   /* Fetch the next row to display from the table.*/
   /* ------------------------------------------------------------*/
  ;
  try
    call "IO3040" ("N1", SQLCA, FB5REC) {isNoRefresh = yes, isExternal = yes};
  end /* Fetch next row*/
  ;
   /* ------------------------------------------------------------*/
   /* If successful, return to previous process.*/
   /* ------------------------------------------------------------*/
  ;
  if (sysVar.errorCode == "00000000") /* Call successful*/
    ;
    if (SQLCA.VAGen_SQLCODE == 0) /* Normal return code*/
      ;
      return; /* Return to previous process*/
      ;
    end
    ;
    /* ------------------------------------------------------------*/
     /* If end of selected set, indicate end of cursor.*/
    /* ------------------------------------------------------------*/
    ;
    if (SQLCA.VAGen_SQLCODE == 100) /* End of selected set*/
      ;
      FB0BW00.FB0BWDCF = "Y"; /* Indicate  end of cursor*/
      ;
      return; /* Return to previous process*/
      ;
    end
    ;
  end
  ;
   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/
  ;
  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/
  ;
  FB0BM010.XXXMODID = "132"; /* Module identification*/
  ;
  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    ;
    converseLib.validationFailed(19); /* 'resources unavailable'*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
    ;
  else
    ;
    converseLib.validationFailed(01); /* 'error - please nofity programming'*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    ;
    converseLib.clearScreen();
     /* Clear screen before display*/
    ;
  end
  ;
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "FETCH NEXT TABLE ROW";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FB0BM010.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFBUY   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VSELDT01"; /* Table view name*/
  TA1REC.TA1TBLKE = FB5REC.FB5KEY; /* Table key*/
  ;
  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/
  ;
  exit stack; /* Exit to display map*/
  ;
  ;
end // end FB0B132

// Get need dates
Function FB0B133()
  ;
   /* ------------------------------------------------------------*/
   /* Move the dates from the record to working storage to format*/
   /* and then move the formated month and year to the map*/
   /* storage fields.*/
   /* ------------------------------------------------------------*/
  ;
  FB0BW00.FB0BWIX1 = FB0BW00.FB0BWIX1 + 1; /* Increment date index*/
  ;
  FB0BW00.FB0BWFDT = FB5REC.FB5TODT; /* TO date*/
  FB0BW01.FB0BWTOM[FB0BWIX1] = FB0BW00.FB0BWFMM; /* To month*/
  FB0BW01.FB0BWTOY[FB0BWIX1] = FB0BW00.FB0BWFYY; /* To year*/
  FB0BW00.FB0BWFDT = FB5REC.FB5FRMDT; /* From date*/
  FB0BW01.FB0BWFRM[FB0BWIX1] = FB0BW00.FB0BWFMM; /* From month*/
  FB0BW01.FB0BWFRY[FB0BWIX1] = FB0BW00.FB0BWFYY; /* From year*/
  ;
  FB0BW00.FB0BWDTC = FB0BW00.FB0BWDTC + 1; /* Increment date counter*/
  ;
  if (FB0BW00.FB0BWDTC == 2) /* Second set of dates*/
    FB0BW00.FB0BWIX2 = 3; /* Set group code index to 3*/
  end
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Save the from date in working storage and use it for*/
   /* comparing the next retrieved from date.  Up to 3 order*/
   /* type group codes for a date can be displayed on the map*/
   /* so a maximum of 3 duplicate date records can be retrieved.*/
   /* ------------------------------------------------------------*/
  ;
  FB0BW00.FB0BWFRD = FB5REC.FB5FRMDT; /* save current date*/
  FB0BW00.FB0BWOTC = 0; /* Initialize order type group counter*/
  ;
  while (FB0BW00.FB0BWDCF != "Y"             /* Not end of set and*/
   && FB5REC.FB5FRMDT == FB0BW00.FB0BWFRD /* Current from date equal prior*/
   && FB0BW00.FB0BWOTC < 3) /* and number of group codes < 3*/
    ;
    FB0B13A();
                                   /* Get order type group codes for a date*/
  end
  ;
  while (FB0BW00.FB0BWDCF != "Y" /* Not end of set and*/
   && FB5REC.FB5FRMDT == FB0BW00.FB0BWFRD) /* Current from date equal prior*/
    ;
    FB0B132(); /* Fetch next vseldt01 row*/
    ;
  end
end // end FB0B133

// Close vseldt01 cursor
Function FB0B134()
   /* ------------------------------------------------------------*/
   /* Close the selected set of table rows.*/
   /* ------------------------------------------------------------*/
  ;
  try
    call "IO3040" ("C1", SQLCA, FB5REC) {isNoRefresh = yes, isExternal = yes};
  end /* Close table set*/
  ;
   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/
  ;
  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/
    ;
    return; /* Return to previous process*/
    ;
  end
  ;
   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/
  ;
  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/
  ;
  FB0BM010.XXXMODID = "134"; /* Module identification*/
  converseLib.validationFailed(01); /* 'Error - Please nofity programming'*/
  ;
  TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "CLOSE VSELDT01 TABLE ROWS";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FB0BM010.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFBUY    "; /* Data base name*/
  TA1REC.TA1TBLVU = "VSELDT01"; /* Table view name*/
  ;
  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/
  ;
  exit stack; /* Exit to display map*/
  ;
  ;
end // end FB0B134

// Get order/etc codes for dates
Function FB0B13A()
  ;
   /* ------------------------------------------------------------*/
   /* Increment the order type group index and move the order*/
   /* type group field to display storage.*/
   /* ------------------------------------------------------------*/
  ;
  FB0BW00.FB0BWIX2 = FB0BW00.FB0BWIX2 + 1; /* Increment order etc index*/
  ;
  ;
  FB0BW01.YSMXOT[FB0BWIX2] = FB5REC.YSMXOT;
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Increment the order type group counter*/
   /* ------------------------------------------------------------*/
  ;
  FB0BW00.FB0BWOTC = FB0BW00.FB0BWOTC + 1;
  ;
   /* ------------------------------------------------------------*/
   /* Fetch the next vseldt01 row.*/
   /* ------------------------------------------------------------*/
  ;
  FB0B132(); /* Fetch vseldt01 row*/
  ;
end // end FB0B13A

// Get warehouse codes and desc
Function FB0B150()
   /* -------------------------------------------------------*/
   /* Get the codes and descriptions to move to*/
   /* display storage.  The warehouses are to be displayed*/
   /* on the map in ascending order.*/
   /* --------------------------------------------------------*/
  ;
  FB0BW00.FB0BWIXM = 1; /* Initialize map index*/
  FB0BW00.FB0BWIX1 = 1;
  ;
  while (XWHTBL.XWHCD[FB0BWIX1] != "99"
  )
    if (XWHTBL.XXXSTAT[FB0BWIX1] == "A")
      while (FB0BW00.FB0BWIXM < 11)
        if (XWHTBL.XWHCD[FB0BWIX1] == FB0BW01.XWHCD[FB0BWIXM])
          FB0BW01.XWHABRV[FB0BWIXM] = XWHTBL.XWHABRV[FB0BWIX1];
          FB0BW00.FB0BWIXM = 11; /* Initialize map index*/
        end
        FB0BW00.FB0BWIXM = FB0BW00.FB0BWIXM + 1;
      end
    end
    FB0BW00.FB0BWIX1 = FB0BW00.FB0BWIX1 + 1;
    FB0BW00.FB0BWIXM = 1; /* Initialize map index*/
    ;
  end
  ;
   /* -------------------------------------------------------*/
   /* If no warehouses found --highlight first warehouse*/
   /* code field on the map and display an error message.*/
   /* --------------------------------------------------------*/
  ;
  if (FB0BW00.FB0BWIXM == 0) /* No warehouses found on table*/
    set FB0BM010.XWHCD[1] cursor, modified, bold;
    FB0BM010.XXXMODID = "150"; /* module identification*/
    converseLib.validationFailed(18); /* No data to display*/
    return; /* Return to caller*/
  end
  ;
   /* -------------------------------------------------------*/
   /* If the direct ship flag on the vselhd01 record is*/
   /* 'y', obtain the description for the direct ship from*/
   /* the warehouse table.*/
   /* --------------------------------------------------------*/
  ;
  if (FB1REC.FB1INCDS == "Y")
    ;
    FB0BW01.XWHCD[11] = "  "; /* Direct ship warehouse code*/
    ;
    if (FB0BW01.XWHCD[11] in XWHTBL.XWHCD)
      FB0BW01.XWHABRV[11] = XWHTBL.XWHABRV[sysVar.arrayIndex];
    end
    ;
    FB0BW01.XWHCD[11] = "00"; /* Display zeros instead of spaces.*/
    ;
    ;
  end
  ;
end // end FB0B150

// Format data & Converse map
Function FB0B200()
  ;
  if (converseVar.validationMsgNum != 0)
    set FB0BM010 alarm; /* Indicate sound alarm*/
  end
  ;
   /* ------------------------------------------------------------*/
   /* If map is not formatted, format the data to be displayed.*/
   /* ------------------------------------------------------------*/
  ;
  if (FB0BM010.XXXCURDT == 0 /* Map is not formatted*/
   && FB0BW00.FB0BWPRF == "Y") /* Processing flag = 'y'*/
    FB0B210(); /* Format the data*/
  end
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Format the current date and any FAST PATH information.*/
   /* ------------------------------------------------------------*/
  ;
  FB0BM010.XXXCURDT = VGVar.currentShortGregorianDate; /* Current date*/
  FB0BM010.CATOAP = COMMAREA.CATOAP; /* TO application*/
  FB0BM010.CAITEM = COMMAREA.CAITEM; /* Application data*/
  ;
  ;
  ;
  converse FB0BM010 ;
  ;
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Clear the message fields and save fast path information*/
   /* ------------------------------------------------------------*/
  ;
  FBWREC.XXXMSGNO = 0; /* Message number*/
  FB0BM010.XXXMODID = " "; /* Module identification*/
  COMMAREA.CATOAP = FB0BM010.CATOAP; /* To application*/
  COMMAREA.CAITEM = FB0BM010.CAITEM; /* Application data*/
  ;
end // end FB0B200

// Format Map data
Function FB0B210()
   /* ------------------------------------------------------------*/
   /* Move map selection criteria data from fb0bw01 display*/
   /* storage record to the map fields.*/
   /* ------------------------------------------------------------*/
  ;
  FB0BM010.FB1CMNT = FB0BW01.FB1CMNT; /* Comments*/
  FB0BM010.FB1INCDS = FB0BW01.FB1INCDS; /* Direct ship code*/
  ;
   /* ------------------------------------------------------------*/
   /* Move the from and to need dates to the map*/
   /* ------------------------------------------------------------*/
  ;
  FB0BW00.FB0BWIX1 = 1; /* Initialize index*/
  ;
  while (FB0BW00.FB0BWIX1 <= 2)
    FB0BM010.FB0BMFRM[FB0BWIX1] = FB0BW01.FB0BWFRM[FB0BWIX1];
    FB0BM010.FB0BMFRY[FB0BWIX1] = FB0BW01.FB0BWFRY[FB0BWIX1];
    FB0BM010.FB0BMTOM[FB0BWIX1] = FB0BW01.FB0BWTOM[FB0BWIX1];
    FB0BM010.FB0BMTOY[FB0BWIX1] = FB0BW01.FB0BWTOY[FB0BWIX1];
    FB0BW00.FB0BWIX1 = FB0BW00.FB0BWIX1 + 1;
  end
  ;
   /* ------------------------------------------------------------*/
   /* Move the Order type group codes to the map*/
   /* ------------------------------------------------------------*/
  ;
  FB0BW00.FB0BWIX1 = 1; /* Initialize index*/
  ;
  while (FB0BW00.FB0BWIX1 <= 6)
    FB0BM010.YSMXOT[FB0BWIX1] = FB0BW01.YSMXOT[FB0BWIX1];
    FB0BW00.FB0BWIX1 = FB0BW00.FB0BWIX1 + 1;
  end
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Move the warehouse codes and description to the map*/
   /* ------------------------------------------------------------*/
  ;
  FB0BW00.FB0BWIX1 = 1; /* Initialize index*/
  ;
  while (FB0BW00.FB0BWIX1 <= 11)
    if (FB0BW01.XWHCD[FB0BWIX1] != " ")
      FB0BM010.XWHCD[FB0BWIX1] = FB0BW01.XWHCD[FB0BWIX1];
      FB0BM010.XWHABRV[FB0BWIX1] = FB0BW01.XWHABRV[FB0BWIX1];
    else
      if (FB0BW00.FB0BWIX1 == 4)
        FB0BW00.FB0BWIX3 = +1;
        set FB0BM010.FB0BM4EQ invisible, protect;
        while (FB0BW00.FB0BWIX3 <= 4)
          set FB0BM010.FB0BM4WH[FB0BWIX3] invisible, protect;
          FB0BW00.FB0BWIX3 = FB0BW00.FB0BWIX3 + 1;
        end
      end
      if (FB0BW00.FB0BWIX1 == 5)
        FB0BW00.FB0BWIX3 = +1;
        set FB0BM010.FB0BM5EQ invisible, protect;
        while (FB0BW00.FB0BWIX3 <= 4)
          set FB0BM010.FB0BM5WH[FB0BWIX3] invisible, protect;
          FB0BW00.FB0BWIX3 = FB0BW00.FB0BWIX3 + 1;
        end
      end
      if (FB0BW00.FB0BWIX1 == 6)
        FB0BW00.FB0BWIX3 = +1;
        set FB0BM010.FB0BM6EQ invisible, protect;
        while (FB0BW00.FB0BWIX3 <= 4)
          set FB0BM010.FB0BM6WH[FB0BWIX3] invisible, protect;
          FB0BW00.FB0BWIX3 = FB0BW00.FB0BWIX3 + 1;
        end
      end
      if (FB0BW00.FB0BWIX1 == 7)
        FB0BW00.FB0BWIX3 = +1;
        set FB0BM010.FB0BM7EQ invisible, protect;
        while (FB0BW00.FB0BWIX3 <= 4)
          set FB0BM010.FB0BM7WH[FB0BWIX3] invisible, protect;
          FB0BW00.FB0BWIX3 = FB0BW00.FB0BWIX3 + 1;
        end
      end
      if (FB0BW00.FB0BWIX1 == 8)
        FB0BW00.FB0BWIX3 = +1;
        set FB0BM010.FB0BM8EQ invisible, protect;
        while (FB0BW00.FB0BWIX3 <= 4)
          set FB0BM010.FB0BM8WH[FB0BWIX3] invisible, protect;
          FB0BW00.FB0BWIX3 = FB0BW00.FB0BWIX3 + 1;
        end
      end
      if (FB0BW00.FB0BWIX1 == 9)
        FB0BW00.FB0BWIX3 = +1;
        set FB0BM010.FB0BM9EQ invisible, protect;
        while (FB0BW00.FB0BWIX3 <= 4)
          set FB0BM010.FB0BM9WH[FB0BWIX3] invisible, protect;
          FB0BW00.FB0BWIX3 = FB0BW00.FB0BWIX3 + 1;
        end
      end
      if (FB0BW00.FB0BWIX1 == 10)
        FB0BW00.FB0BWIX3 = +1;
        set FB0BM010.FB0BM10EQ invisible, protect;
        while (FB0BW00.FB0BWIX3 <= 4)
          set FB0BM010.FB0BM10WH[FB0BWIX3] invisible, protect;
          FB0BW00.FB0BWIX3 = FB0BW00.FB0BWIX3 + 1;
        end
      end
    end
    FB0BW00.FB0BWIX1 = FB0BW00.FB0BWIX1 + 1;
  end
  ;
end // end FB0B210

// check attention identifiers
Function FB0B300()
  ;
   /* ------------------------------------------------------------*/
   /* if there was no internal sequence number passed then*/
   /* display an error message.*/
   /* ------------------------------------------------------------*/
  ;
  if (FB0BW00.FB0BWPRF == "N") /* No processing to be done*/
    if (converseVar.eventKey is pf1
     || converseVar.eventKey is pf3
     || converseVar.eventKey is pf5
     || FB0BM010.CATOAP > " ") /* FAST PATH was requested*/
       /* next sentence*/
    else
      converseLib.validationFailed(93);
      FB0BM010.XXXMODID = "300"; /* Module identification*/
      exit stack;
    end
  end
  ;
   /* ------------------------------------------------------------*/
   /* When checking any of the valid PF keys, process module*/
   /* Fb0b310 will be called to determine if the selection*/
   /* criteria data should be deleted prior to transfering to*/
   /* the requested application. The selection rows should not*/
   /* be deleted with  enter, PF9 or Pf 12.*/
   /* ------------------------------------------------------------*/
  ;
   /* ------------------------------------------------------------*/
   /* If FAST PATH was requested, transfer to application.*/
   /* ------------------------------------------------------------*/
  ;
  if (FB0BM010.CATOAP > " ") /* FAST PATH was requested*/
    if (converseVar.eventKey is enter) /* ENTER was pressed*/
      COMMAREA.CATOAP = FB0BM010.CATOAP; /* TO application*/
      COMMAREA.CAITEM = FB0BM010.CAITEM; /* TO application key*/
      FB0B310();
    else
      FB0BM010.XXXMODID = "300"; /* Module identification*/
      converseLib.validationFailed(40); /* Enter must be used for fast path*/
      exit stack;
    end
  end
  ;
   /* ------------------------------------------------------------*/
   /* If CANCEL was requested, restart from the top.*/
   /* ------------------------------------------------------------*/
  ;
  if (converseVar.eventKey is pa2) /* PA2 was pressed*/
    COMMAREA.CATOAP = "FB0B"; /* TO application*/
    COMMAREA.CAITEM = " "; /* Application data*/
    XSEXIT();
    FB0BM010.VAGen_EZEMSG = COMMAREA.CAMSG; /* If bad transfer*/
    converseLib.validationFailed();
    exit stack;
  end
  ;
  ;
  if (converseVar.eventKey is enter /* Enter was pressed*/
   || converseVar.eventKey is pf9)  /* Update requested*/
    return; /* Return to previous process*/
    ;
  end
  ;
  if (converseVar.eventKey is pa1
   || converseVar.eventKey is pa3)
    ;
    converseLib.clearScreen();
     /* Clear screen before display*/
  end
  ;
   /* ------------------------------------------------------------*/
   /* Handle pf-keys*/
   /* ------------------------------------------------------------*/
  ;
  if (converseVar.eventKey is pf12) /* Transfer to FB0A*/
    COMMAREA.CATOAP = "FB0A"; /* To application*/
    COMMAREA.CAITEM = " "; /* Application find code*/
    XSEXIT();
    FB0BM010.VAGen_EZEMSG = COMMAREA.CAMSG; /* If bad transfer*/
  end
  ;
  ;
  if (converseVar.eventKey is pf1) /* PF1 was pressed*/
    FB0B310();
    COMMAREA.CATOAP = "GD01"; /* To application*/
    COMMAREA.CAITEM = "FB0BM010"; /* Application find code*/
  end
  ;
  if (converseVar.eventKey is pf5) /* pf5 was pressed*/
    COMMAREA.CATOAP = "FY0M"; /* TO application*/
    COMMAREA.CAITEM = " ";
    FB0B310();
  end
  ;
  if (converseVar.eventKey is pf3) /* PF3 was pressed*/
    ;
    COMMAREA.CATOAP = "FB0M"; /* TO application*/
    FB0B310();
  end
  ;
  ;
  ;
  if (converseVar.eventKey is pf14) /* Size percent maintenance selection*/
    ;
    COMMAREA.CATOAP = "FB0C"; /* TO application*/
    COMMAREA.CAITEM = " ";
    FB0B310(); /* Validate scroll request*/
  end
  ;
  ;
   /* ------------------------------------------------------------*/
   /* If this point has been reached, an invalid pf-keys was hit.*/
   /* ------------------------------------------------------------*/
  ;
  FB0BM010.XXXMODID = "300"; /* Module identification*/
  converseLib.validationFailed(3);
  exit stack; /* Return to show error message*/
end // end FB0B300

// Delete selection parms & trans
Function FB0B310()
   /* ------------------------------------------------------------*/
   /* If the vselhd01 status is = '1' then all the selection*/
   /* criteria rows for the fbwrec internal sequence number*/
   /* should be deleted prior to executing the requested*/
   /* transfer.*/
   /* ------------------------------------------------------------*/
  ;
  if (FB1REC.FB1CRVST == "1")
    ;
    FB0B311(); /* Delete vselhd01 row*/
    ;
    FB0B313(); /* Delete vselst01 row*/
    ;
    FB0B314(); /* Delete vseldt01 row*/
    ;
  end
  ;
  XSEXIT();
  FB0BM010.VAGen_EZEMSG = COMMAREA.CAMSG; /* If bad transfer*/
  converseLib.validationFailed(); /* Prevent additional processing*/
  exit stack;
  ;
end // end FB0B310

// Delete vselhd01 rows
Function FB0B311()
  set FB1REC empty;
  FB1REC.FB1INSEQ = FBWREC.FB1INSEQ;
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Delete the row from dfcast.vselhd01 table.*/
   /* ------------------------------------------------------------*/
  ;
  try
    call "IO3030" ("D ", SQLCA, FB1REC) {isNoRefresh = yes, isExternal = yes};
  end
  ;
   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/
  ;
  if (sysVar.errorCode == "00000000") /* Call successful*/
    ;
    if (SQLCA.VAGen_SQLCODE == 0 /* Normal return code*/
     || SQLCA.VAGen_SQLCODE == 100) /* Not found*/
      return; /* Return to previous process*/
    end
    ;
  end
  ;
   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/
  ;
  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/
  ;
  FB0BM010.XXXMODID = "311"; /* Module identification*/
  ;
  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/
    ;
    converseLib.validationFailed(19); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
    ;
  else
    ;
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback(); /* Back out current db2 unit of work*/
    converseLib.validationFailed(1); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    ;
    converseLib.clearScreen();
     /* Clear screen before display*/
    ;
  end
  ;
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "DELETE VSELHD01 ROWS          ";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FB0BM010.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFCAST  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VSELHD01"; /* Table view name*/
  TA1REC.TA1TBLKE = FB1REC.FB1KEY; /* Table key*/
  ;
  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/
  ;
  exit stack; /* Exit to display map*/
  ;
  ;
end // end FB0B311

// Delete vselst01 rows
Function FB0B313()
  set FB6REC empty;
  FB6REC.FB1INSEQ = FBWREC.FB1INSEQ;
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Delete the row from dfcast.vselst01 table.*/
   /* ------------------------------------------------------------*/
  ;
  try
    call "IO3060" ("D ", SQLCA, FB6REC) {isNoRefresh = yes, isExternal = yes};
  end
  ;
   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/
  ;
  if (sysVar.errorCode == "00000000") /* Call successful*/
    ;
    if (SQLCA.VAGen_SQLCODE == 0 /* Normal return code*/
     || SQLCA.VAGen_SQLCODE == 100) /* Not found*/
      return; /* Return to previous process*/
    end
    ;
  end
  ;
   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/
  ;
  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/
  ;
  FB0BM010.XXXMODID = "313"; /* Module identification*/
  ;
  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/
    ;
    converseLib.validationFailed(19); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
    ;
  else
    ;
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback(); /* Back out current db2 unit of work*/
    converseLib.validationFailed(1); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    ;
    converseLib.clearScreen();
     /* Clear screen before display*/
    ;
  end
  ;
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "DELETE VSELST01 ROWS          ";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FB0BM010.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFCAST  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VSELST01"; /* Table view name*/
  TA1REC.TA1TBLKE = FB6REC.FB6KEY; /* Table key*/
  ;
  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/
  ;
  exit stack; /* Exit to display map*/
  ;
  ;
end // end FB0B313

// Delete vseldt01 rows
Function FB0B314()
  set FB5REC empty;
  FB5REC.FB1INSEQ = FBWREC.FB1INSEQ;
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Delete the row from dfcast.vseldt01 table.*/
   /* ------------------------------------------------------------*/
  ;
  try
    call "IO3040" ("D ", SQLCA, FB5REC) {isNoRefresh = yes, isExternal = yes};
  end
  ;
   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/
  ;
  if (sysVar.errorCode == "00000000") /* Call successful*/
    ;
    if (SQLCA.VAGen_SQLCODE == 0 /* Normal return code*/
     || SQLCA.VAGen_SQLCODE == 100) /* Not found*/
      return; /* Return to previous process*/
    end
    ;
  end
  ;
   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/
  ;
  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/
  ;
  FB0BM010.XXXMODID = "314"; /* Module identification*/
  ;
  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/
    ;
    converseLib.validationFailed(19); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
    ;
  else
    ;
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback(); /* Back out current db2 unit of work*/
    converseLib.validationFailed(1); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    ;
    converseLib.clearScreen();
     /* Clear screen before display*/
    ;
  end
  ;
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "DELETE VSELDT01 ROWS          ";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FB0BM010.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFCAST  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VSELDT01"; /* Table view name*/
  TA1REC.TA1TBLKE = FB5REC.FB5KEY; /* Table key*/
  ;
  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/
  ;
  exit stack; /* Exit to display map*/
  ;
  ;
end // end FB0B314

// Reset highlighted fields
Function FB0B400()
  ;
  FB0BW00.FB0BWIX1 = +1; /* Initialize index*/
  while (FB0BW00.FB0BWIX1 <= 4)
    set FB0BM010.FB0BM1WH[FB0BWIX1] normal;
    FB0BW00.FB0BWIX1 = FB0BW00.FB0BWIX1 + 1;
  end
  ;
  FB0BW00.FB0BWIX1 = +1; /* Initialize index*/
  while (FB0BW00.FB0BWIX1 <= 4)
    set FB0BM010.FB0BM2WH[FB0BWIX1] normal;
    FB0BW00.FB0BWIX1 = FB0BW00.FB0BWIX1 + 1;
  end
  ;
  FB0BW00.FB0BWIX1 = +1; /* Initialize index*/
  while (FB0BW00.FB0BWIX1 <= 4)
    set FB0BM010.FB0BM3WH[FB0BWIX1] normal;
    FB0BW00.FB0BWIX1 = FB0BW00.FB0BWIX1 + 1;
  end
  ;
  FB0BW00.FB0BWIX1 = +1; /* Initialize index*/
  while (FB0BW00.FB0BWIX1 <= 4)
    set FB0BM010.FB0BM4WH[FB0BWIX1] normal;
    FB0BW00.FB0BWIX1 = FB0BW00.FB0BWIX1 + 1;
  end
  ;
  FB0BW00.FB0BWIX1 = +1; /* Initialize index*/
  while (FB0BW00.FB0BWIX1 <= 4)
    set FB0BM010.FB0BM5WH[FB0BWIX1] normal;
    FB0BW00.FB0BWIX1 = FB0BW00.FB0BWIX1 + 1;
  end
  ;
  FB0BW00.FB0BWIX1 = +1; /* Initialize index*/
  while (FB0BW00.FB0BWIX1 <= 4)
    set FB0BM010.FB0BM6WH[FB0BWIX1] normal;
    FB0BW00.FB0BWIX1 = FB0BW00.FB0BWIX1 + 1;
  end
  ;
  ;
  FB0BW00.FB0BWIX1 = +1; /* Initialize index*/
  while (FB0BW00.FB0BWIX1 <= 4)
    set FB0BM010.FB0BM7WH[FB0BWIX1] normal;
    FB0BW00.FB0BWIX1 = FB0BW00.FB0BWIX1 + 1;
  end
  ;
  FB0BW00.FB0BWIX1 = +1; /* Initialize index*/
  while (FB0BW00.FB0BWIX1 <= 4)
    set FB0BM010.FB0BM8WH[FB0BWIX1] normal;
    FB0BW00.FB0BWIX1 = FB0BW00.FB0BWIX1 + 1;
  end
  ;
  FB0BW00.FB0BWIX1 = +1; /* Initialize index*/
  while (FB0BW00.FB0BWIX1 <= 4)
    set FB0BM010.FB0BM9WH[FB0BWIX1] normal;
    FB0BW00.FB0BWIX1 = FB0BW00.FB0BWIX1 + 1;
  end
  ;
  FB0BW00.FB0BWIX1 = +1; /* Initialize index*/
  while (FB0BW00.FB0BWIX1 <= 4)
    set FB0BM010.FB0BM10WH[FB0BWIX1] normal;
    FB0BW00.FB0BWIX1 = FB0BW00.FB0BWIX1 + 1;
  end
  ;
  /* ***********************************************************/
  /* THE FOLLOWING LOGICS WILL VALIDATE THE WAREHOUSE CODES, **/
  /* IF THERE ARE MORE THAN THREE WAREHOUSE CODES ARE ENTERED**/
  /* AN ERROR MESSSAGE WILL BE DISPLAY.  HOWEVER, THE MAP    **/
  /* WILL BE PROTECTED DARK IF THERE IS NO WAREHOUSE AVAIL-  **/
  /* ABLE(10 WAREHOUSES ARE MAXIMUM).                        **/
  /* ***********************************************************/
  ;
  FB0BW00.FB0BWIX1 = +1; /* Initialize index*/
  ;
  while (FB0BW00.FB0BWIX1 <= 11)
    ;
    if (FB0BW01.XWHCD[FB0BWIX1] == " ")
      if (FB0BW00.FB0BWIX1 == 1)
        FB0BW00.FB0BWIX3 = +1; /* Initialize index*/
        set FB0BM010.FB0BM1EQ invisible, protect;
        while (FB0BW00.FB0BWIX3 <= 4)
          set FB0BM010.FB0BM1WH[FB0BWIX3] invisible, protect;
          FB0BW00.FB0BWIX3 = FB0BW00.FB0BWIX3 + 1;
        end
      end
    else
      if (FB0BW00.FB0BWIX1 == 1)
        if (converseVar.eventKey is pf9)
          FB0BW00.FB0BWIX3 = +1; /* Initialize index*/
          while (FB0BW00.FB0BWIX3 <= 4)
            if (FB0BM010.FB0BM1WH[FB0BWIX3] != " ")
              FB0BW00.FB0BWIX3 = FB0BW00.FB0BWIX3 + 1;
              if (FB0BWIX3 == 5)
                set FB0BM010.FB0BM1WH[1] cursor, bold;
              end
            else
              FB0BW00.FB0BWIX3 = FB0BW00.FB0BWIX3 + 1;
            end
          end
        else /* if not pf9 is pressed*/
          set FB0BM010.FB0BM1WH[1] cursor;
          set FB0BM010.FB0BM1WH[1] normal;
        end
      end
    end
  /* ***********************************************************/
    if (FB0BW01.XWHCD[FB0BWIX1] == " ")
      if (FB0BW00.FB0BWIX1 == 2)
        FB0BW00.FB0BWIX3 = +1; /* Initialize index*/
        set FB0BM010.FB0BM2EQ invisible, protect;
        while (FB0BW00.FB0BWIX3 <= 4)
          set FB0BM010.FB0BM2WH[FB0BWIX3] invisible, protect;
          FB0BW00.FB0BWIX3 = FB0BW00.FB0BWIX3 + 1;
        end
      end
    else
      if (FB0BW00.FB0BWIX1 == 2)
        if (converseVar.eventKey is pf9)
          FB0BW00.FB0BWIX3 = +1; /* Initialize index*/
          while (FB0BW00.FB0BWIX3 <= 4)
            if (FB0BM010.FB0BM2WH[FB0BWIX3] != " ")
              FB0BW00.FB0BWIX3 = FB0BW00.FB0BWIX3 + 1;
              if (FB0BWIX3 == 5)
                set FB0BM010.FB0BM2WH[1] cursor, bold;
              end
            else
              FB0BW00.FB0BWIX3 = FB0BW00.FB0BWIX3 + 1;
            end
          end
        else /* if not pf9 is pressed*/
          set FB0BM010.FB0BM1WH[1] cursor;
          set FB0BM010.FB0BM2WH[1] normal;
        end
      end
    end
  /* ***********************************************************/
    if (FB0BW01.XWHCD[FB0BWIX1] == " ")
      if (FB0BW00.FB0BWIX1 == 3)
        FB0BW00.FB0BWIX3 = +1; /* Initialize index*/
        set FB0BM010.FB0BM3EQ invisible, protect;
        while (FB0BW00.FB0BWIX3 <= 4)
          set FB0BM010.FB0BM3WH[FB0BWIX3] invisible, protect;
          FB0BW00.FB0BWIX3 = FB0BW00.FB0BWIX3 + 1;
        end
      end
    else
      if (FB0BW00.FB0BWIX1 == 3)
        if (converseVar.eventKey is pf9)
          FB0BW00.FB0BWIX3 = +1; /* Initialize index*/
          while (FB0BW00.FB0BWIX3 <= 4)
            if (FB0BM010.FB0BM3WH[FB0BWIX3] != " ")
              FB0BW00.FB0BWIX3 = FB0BW00.FB0BWIX3 + 1;
              if (FB0BWIX3 == 5)
                set FB0BM010.FB0BM3WH[1] cursor, bold;
              end
            else
              FB0BW00.FB0BWIX3 = FB0BW00.FB0BWIX3 + 1;
            end
          end
        else /* if not pf9 is pressed*/
          set FB0BM010.FB0BM1WH[1] cursor;
          set FB0BM010.FB0BM3WH[1] normal;
        end
      end
    end
  /* ***********************************************************/
    if (FB0BW01.XWHCD[FB0BWIX1] == " ")
      if (FB0BW00.FB0BWIX1 == 4)
        FB0BW00.FB0BWIX3 = +1; /* Initialize index*/
        set FB0BM010.FB0BM4EQ invisible, protect;
        while (FB0BW00.FB0BWIX3 <= 4)
          set FB0BM010.FB0BM4WH[FB0BWIX3] invisible, protect;
          FB0BW00.FB0BWIX3 = FB0BW00.FB0BWIX3 + 1;
        end
      end
    else
      if (FB0BW00.FB0BWIX1 == 4)
        if (converseVar.eventKey is pf9)
          FB0BW00.FB0BWIX3 = +1; /* Initialize index*/
          while (FB0BW00.FB0BWIX3 <= 4)
            if (FB0BM010.FB0BM4WH[FB0BWIX3] != " ")
              FB0BW00.FB0BWIX3 = FB0BW00.FB0BWIX3 + 1;
              if (FB0BWIX3 == 5)
                set FB0BM010.FB0BM4WH[1] cursor, bold;
              end
            else
              FB0BW00.FB0BWIX3 = FB0BW00.FB0BWIX3 + 1;
            end
          end
        else /* if not pf9 is pressed*/
          set FB0BM010.FB0BM1WH[1] cursor;
          set FB0BM010.FB0BM4WH[1] normal;
        end
      end
    end
  /* ***********************************************************/
    if (FB0BW01.XWHCD[FB0BWIX1] == " ")
      if (FB0BW00.FB0BWIX1 == 5)
        FB0BW00.FB0BWIX3 = +1; /* Initialize index*/
        set FB0BM010.FB0BM5EQ invisible, protect;
        while (FB0BW00.FB0BWIX3 <= 4)
          set FB0BM010.FB0BM5WH[FB0BWIX3] invisible, protect;
          FB0BW00.FB0BWIX3 = FB0BW00.FB0BWIX3 + 1;
        end
      end
    else
      if (FB0BW00.FB0BWIX1 == 5)
        if (converseVar.eventKey is pf9)
          FB0BW00.FB0BWIX3 = +1; /* Initialize index*/
          while (FB0BW00.FB0BWIX3 <= 4)
            if (FB0BM010.FB0BM5WH[FB0BWIX3] != " ")
              FB0BW00.FB0BWIX3 = FB0BW00.FB0BWIX3 + 1;
              if (FB0BWIX3 == 5)
                set FB0BM010.FB0BM5WH[1] cursor, bold;
              end
            else
              FB0BW00.FB0BWIX3 = FB0BW00.FB0BWIX3 + 1;
            end
          end
        else /* if not pf9 is pressed*/
          set FB0BM010.FB0BM1WH[1] cursor;
          set FB0BM010.FB0BM5WH[1] normal;
        end
      end
    end
  /* ***********************************************************/
    if (FB0BW01.XWHCD[FB0BWIX1] == " ")
      if (FB0BW00.FB0BWIX1 == 6)
        FB0BW00.FB0BWIX3 = +1; /* Initialize index*/
        set FB0BM010.FB0BM6EQ invisible, protect;
        while (FB0BW00.FB0BWIX3 <= 4)
          set FB0BM010.FB0BM6WH[FB0BWIX3] invisible, protect;
          FB0BW00.FB0BWIX3 = FB0BW00.FB0BWIX3 + 1;
        end
      end
    else
      if (FB0BW00.FB0BWIX1 == 6)
        if (converseVar.eventKey is pf9)
          FB0BW00.FB0BWIX3 = +1; /* Initialize index*/
          while (FB0BW00.FB0BWIX3 <= 4)
            if (FB0BM010.FB0BM6WH[FB0BWIX3] != " ")
              FB0BW00.FB0BWIX3 = FB0BW00.FB0BWIX3 + 1;
              if (FB0BWIX3 == 5)
                set FB0BM010.FB0BM6WH[1] cursor, bold;
              end
            else
              FB0BW00.FB0BWIX3 = FB0BW00.FB0BWIX3 + 1;
            end
          end
        else /* if not pf9 is pressed*/
          set FB0BM010.FB0BM1WH[1] cursor;
          set FB0BM010.FB0BM6WH[1] normal;
        end
      end
    end
  /* ***********************************************************/
    if (FB0BW01.XWHCD[FB0BWIX1] == " ")
      if (FB0BW00.FB0BWIX1 == 7)
        FB0BW00.FB0BWIX3 = +1; /* Initialize index*/
        set FB0BM010.FB0BM7EQ invisible, protect;
        while (FB0BW00.FB0BWIX3 <= 4)
          set FB0BM010.FB0BM7WH[FB0BWIX3] invisible, protect;
          FB0BW00.FB0BWIX3 = FB0BW00.FB0BWIX3 + 1;
        end
      end
    else
      if (FB0BW00.FB0BWIX1 == 7)
        if (converseVar.eventKey is pf9)
          FB0BW00.FB0BWIX3 = +1; /* Initialize index*/
          while (FB0BW00.FB0BWIX3 <= 4)
            if (FB0BM010.FB0BM7WH[FB0BWIX3] != " ")
              FB0BW00.FB0BWIX3 = FB0BW00.FB0BWIX3 + 1;
              if (FB0BWIX3 == 5)
                set FB0BM010.FB0BM7WH[1] cursor, bold;
              end
            else
              FB0BW00.FB0BWIX3 = FB0BW00.FB0BWIX3 + 1;
            end
          end
        else /* if not pf9 is pressed*/
          set FB0BM010.FB0BM1WH[1] cursor;
          set FB0BM010.FB0BM7WH[1] normal;
        end
      end
    end
  /* ***********************************************************/
    if (FB0BW01.XWHCD[FB0BWIX1] == " ")
      if (FB0BW00.FB0BWIX1 == 8)
        FB0BW00.FB0BWIX3 = +1; /* Initialize index*/
        set FB0BM010.FB0BM8EQ invisible, protect;
        while (FB0BW00.FB0BWIX3 <= 4)
          set FB0BM010.FB0BM8WH[FB0BWIX3] invisible, protect;
          FB0BW00.FB0BWIX3 = FB0BW00.FB0BWIX3 + 1;
        end
      end
    else
      if (FB0BW00.FB0BWIX1 == 8)
        if (converseVar.eventKey is pf9)
          FB0BW00.FB0BWIX3 = +1; /* Initialize index*/
          while (FB0BW00.FB0BWIX3 <= 4)
            if (FB0BM010.FB0BM8WH[FB0BWIX3] != " ")
              FB0BW00.FB0BWIX3 = FB0BW00.FB0BWIX3 + 1;
              if (FB0BWIX3 == 5)
                set FB0BM010.FB0BM8WH[1] cursor, bold;
              end
            else
              FB0BW00.FB0BWIX3 = FB0BW00.FB0BWIX3 + 1;
            end
          end
        else /* if not pf9 is pressed*/
          set FB0BM010.FB0BM1WH[1] cursor;
          set FB0BM010.FB0BM8WH[1] normal;
        end
      end
    end
  /* ***********************************************************/
    if (FB0BW01.XWHCD[FB0BWIX1] == " ")
      if (FB0BW00.FB0BWIX1 == 9)
        FB0BW00.FB0BWIX3 = +1; /* Initialize index*/
        set FB0BM010.FB0BM9EQ invisible, protect;
        while (FB0BW00.FB0BWIX3 <= 4)
          set FB0BM010.FB0BM9WH[FB0BWIX3] invisible, protect;
          FB0BW00.FB0BWIX3 = FB0BW00.FB0BWIX3 + 1;
        end
      end
    else
      if (FB0BW00.FB0BWIX1 == 9)
        if (converseVar.eventKey is pf9)
          FB0BW00.FB0BWIX3 = +1; /* Initialize index*/
          while (FB0BW00.FB0BWIX3 <= 4)
            if (FB0BM010.FB0BM9WH[FB0BWIX3] != " ")
              FB0BW00.FB0BWIX3 = FB0BW00.FB0BWIX3 + 1;
              if (FB0BWIX3 == 5)
                set FB0BM010.FB0BM9WH[1] cursor, bold;
              end
            else
              FB0BW00.FB0BWIX3 = FB0BW00.FB0BWIX3 + 1;
            end
          end
        else /* if not pf9 is pressed*/
          set FB0BM010.FB0BM1WH[1] cursor;
          set FB0BM010.FB0BM9WH[1] normal;
        end
      end
    end
  /* ***********************************************************/
    if (FB0BW01.XWHCD[FB0BWIX1] == " ")
      if (FB0BW00.FB0BWIX1 == 10)
        FB0BW00.FB0BWIX3 = +1; /* Initialize index*/
        set FB0BM010.FB0BM10EQ invisible, protect;
        while (FB0BW00.FB0BWIX3 <= 4)
          set FB0BM010.FB0BM10WH[FB0BWIX3] invisible, protect;
          FB0BW00.FB0BWIX3 = FB0BW00.FB0BWIX3 + 1;
        end
      end
    else
      if (FB0BW00.FB0BWIX1 == 10)
        if (converseVar.eventKey is pf9)
          FB0BW00.FB0BWIX3 = +1; /* Initialize index*/
          while (FB0BW00.FB0BWIX3 <= 4)
            if (FB0BM010.FB0BM10WH[FB0BWIX3] != " ")
              FB0BW00.FB0BWIX3 = FB0BW00.FB0BWIX3 + 1;
              if (FB0BWIX3 == 5)
                set FB0BM010.FB0BM10WH[1] cursor, bold;
              end
            else
              FB0BW00.FB0BWIX3 = FB0BW00.FB0BWIX3 + 1;
            end
          end
        else /* if not pf9 is pressed*/
          set FB0BM010.FB0BM1WH[1] cursor;
          set FB0BM010.FB0BM10WH[1] normal;
        end
      end
    end
    ;
    FB0BW00.FB0BWIX1 = FB0BW00.FB0BWIX1 + 1;
  end
end // end FB0B400

// Verify entered data
Function FB0B500()
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Edit for warehouses entered twice on the same line.*/
   /* Edit from the bottom of the map and right to left.*/
   /* ------------------------------------------------------------*/
  ;
   /* ------------------------------------------------------------*/
   /* Warehouse 10 edit*/
   /* ------------------------------------------------------------*/
  ;
  FB0BW00.FB0BWIXM = +4; /* Initialize map index*/
  ;
  while (FB0BW00.FB0BWIXM >= 1)
    if (FB0BM010.FB0BM10WH[FB0BWIXM] != " ") /* Warehouse entered*/
      FB0BW00.FB0BWIX1 = +1; /* Initialize second index*/
      while (FB0BW00.FB0BWIX1 <= 4)
        if (FB0BM010.FB0BM10WH[FB0BWIXM] == FB0BM010.FB0BM10WH[FB0BWIX1]
         && FB0BW00.FB0BWIXM != FB0BW00.FB0BWIX1)
          set FB0BM010.FB0BM10WH[FB0BWIXM] cursor, bold;
          converseLib.validationFailed(95); /* Duplicate region requested*/
        end
        FB0BW00.FB0BWIX1 = FB0BW00.FB0BWIX1 + 1;
      end
    end
    FB0BW00.FB0BWIXM = FB0BW00.FB0BWIXM - 1;
  end
  ;
   /* ------------------------------------------------------------*/
   /* Warehouse 9 edit*/
   /* ------------------------------------------------------------*/
  ;
  FB0BW00.FB0BWIXM = +4; /* Initialize map index*/
  ;
  while (FB0BW00.FB0BWIXM >= 1)
    if (FB0BM010.FB0BM9WH[FB0BWIXM] != " ") /* Warehouse entered*/
      FB0BW00.FB0BWIX1 = +1; /* Initialize second index*/
      while (FB0BW00.FB0BWIX1 <= 4)
        if (FB0BM010.FB0BM9WH[FB0BWIXM] == FB0BM010.FB0BM9WH[FB0BWIX1]
         && FB0BW00.FB0BWIXM != FB0BW00.FB0BWIX1)
          set FB0BM010.FB0BM9WH[FB0BWIXM] cursor, bold;
          converseLib.validationFailed(95); /* Duplicate region requested*/
        end
        FB0BW00.FB0BWIX1 = FB0BW00.FB0BWIX1 + 1;
      end
    end
    FB0BW00.FB0BWIXM = FB0BW00.FB0BWIXM - 1;
  end
  ;
   /* ------------------------------------------------------------*/
   /* Warehouse 8 edit*/
   /* ------------------------------------------------------------*/
  ;
  FB0BW00.FB0BWIXM = +4; /* Initialize map index*/
  ;
  while (FB0BW00.FB0BWIXM >= 1)
    if (FB0BM010.FB0BM8WH[FB0BWIXM] != " ") /* Warehouse entered*/
      FB0BW00.FB0BWIX1 = +1; /* Initialize second index*/
      while (FB0BW00.FB0BWIX1 <= 4)
        if (FB0BM010.FB0BM8WH[FB0BWIXM] == FB0BM010.FB0BM8WH[FB0BWIX1]
         && FB0BW00.FB0BWIXM != FB0BW00.FB0BWIX1)
          set FB0BM010.FB0BM8WH[FB0BWIXM] cursor, bold;
          converseLib.validationFailed(95); /* Duplicate region requested*/
        end
        FB0BW00.FB0BWIX1 = FB0BW00.FB0BWIX1 + 1;
      end
    end
    FB0BW00.FB0BWIXM = FB0BW00.FB0BWIXM - 1;
  end
  ;
   /* ------------------------------------------------------------*/
   /* Warehouse 7 edit*/
   /* ------------------------------------------------------------*/
  ;
  FB0BW00.FB0BWIXM = +4; /* Initialize map index*/
  ;
  while (FB0BW00.FB0BWIXM >= 1)
    if (FB0BM010.FB0BM7WH[FB0BWIXM] != " ") /* Warehouse entered*/
      FB0BW00.FB0BWIX1 = +1; /* Initialize second index*/
      while (FB0BW00.FB0BWIX1 <= 4)
        if (FB0BM010.FB0BM7WH[FB0BWIXM] == FB0BM010.FB0BM7WH[FB0BWIX1]
         && FB0BW00.FB0BWIXM != FB0BW00.FB0BWIX1)
          set FB0BM010.FB0BM7WH[FB0BWIXM] cursor, bold;
          converseLib.validationFailed(95); /* Duplicate region requested*/
        end
        FB0BW00.FB0BWIX1 = FB0BW00.FB0BWIX1 + 1;
      end
    end
    FB0BW00.FB0BWIXM = FB0BW00.FB0BWIXM - 1;
  end
  ;
   /* ------------------------------------------------------------*/
   /* Warehouse 6 edit*/
   /* ------------------------------------------------------------*/
  ;
  FB0BW00.FB0BWIXM = +4; /* Initialize map index*/
  ;
  while (FB0BW00.FB0BWIXM >= 1)
    if (FB0BM010.FB0BM6WH[FB0BWIXM] != " ") /* Warehouse entered*/
      FB0BW00.FB0BWIX1 = +1; /* Initialize second index*/
      while (FB0BW00.FB0BWIX1 <= 4)
        if (FB0BM010.FB0BM6WH[FB0BWIXM] == FB0BM010.FB0BM6WH[FB0BWIX1]
         && FB0BW00.FB0BWIXM != FB0BW00.FB0BWIX1)
          set FB0BM010.FB0BM6WH[FB0BWIXM] cursor, bold;
          converseLib.validationFailed(95); /* Duplicate region requested*/
        end
        FB0BW00.FB0BWIX1 = FB0BW00.FB0BWIX1 + 1;
      end
    end
    FB0BW00.FB0BWIXM = FB0BW00.FB0BWIXM - 1;
  end
  ;
   /* ------------------------------------------------------------*/
   /* Warehouse 5 edit*/
   /* ------------------------------------------------------------*/
  ;
  FB0BW00.FB0BWIXM = +4; /* Initialize map index*/
  ;
  while (FB0BW00.FB0BWIXM >= 1)
    if (FB0BM010.FB0BM5WH[FB0BWIXM] != " ") /* Warehouse entered*/
      FB0BW00.FB0BWIX1 = +1; /* Initialize second index*/
      while (FB0BW00.FB0BWIX1 <= 4)
        if (FB0BM010.FB0BM5WH[FB0BWIXM] == FB0BM010.FB0BM5WH[FB0BWIX1]
         && FB0BW00.FB0BWIXM != FB0BW00.FB0BWIX1)
          set FB0BM010.FB0BM5WH[FB0BWIXM] cursor, bold;
          converseLib.validationFailed(95); /* Duplicate region requested*/
        end
        FB0BW00.FB0BWIX1 = FB0BW00.FB0BWIX1 + 1;
      end
    end
    FB0BW00.FB0BWIXM = FB0BW00.FB0BWIXM - 1;
  end
  ;
   /* ------------------------------------------------------------*/
   /* Warehouse 4 edit*/
   /* ------------------------------------------------------------*/
  ;
  FB0BW00.FB0BWIXM = +4; /* Initialize map index*/
  ;
  while (FB0BW00.FB0BWIXM >= 1)
    if (FB0BM010.FB0BM4WH[FB0BWIXM] != " ") /* Warehouse entered*/
      FB0BW00.FB0BWIX1 = +1; /* Initialize second index*/
      while (FB0BW00.FB0BWIX1 <= 4)
        if (FB0BM010.FB0BM4WH[FB0BWIXM] == FB0BM010.FB0BM4WH[FB0BWIX1]
         && FB0BW00.FB0BWIXM != FB0BW00.FB0BWIX1)
          set FB0BM010.FB0BM4WH[FB0BWIXM] cursor, bold;
          converseLib.validationFailed(95); /* Duplicate region requested*/
        end
        FB0BW00.FB0BWIX1 = FB0BW00.FB0BWIX1 + 1;
      end
    end
    FB0BW00.FB0BWIXM = FB0BW00.FB0BWIXM - 1;
  end
  ;
   /* ------------------------------------------------------------*/
   /* Warehouse 3 edit*/
   /* ------------------------------------------------------------*/
  ;
  FB0BW00.FB0BWIXM = +4; /* Initialize map index*/
  ;
  while (FB0BW00.FB0BWIXM >= 1)
    if (FB0BM010.FB0BM3WH[FB0BWIXM] != " ") /* Warehouse entered*/
      FB0BW00.FB0BWIX1 = +1; /* Initialize second index*/
      while (FB0BW00.FB0BWIX1 <= 4)
        if (FB0BM010.FB0BM3WH[FB0BWIXM] == FB0BM010.FB0BM3WH[FB0BWIX1]
         && FB0BW00.FB0BWIXM != FB0BW00.FB0BWIX1)
          set FB0BM010.FB0BM3WH[FB0BWIXM] cursor, bold;
          converseLib.validationFailed(95); /* Duplicate region requested*/
        end
        FB0BW00.FB0BWIX1 = FB0BW00.FB0BWIX1 + 1;
      end
    end
    FB0BW00.FB0BWIXM = FB0BW00.FB0BWIXM - 1;
  end
  ;
   /* ------------------------------------------------------------*/
   /* Warehouse 2 edit*/
   /* ------------------------------------------------------------*/
  ;
  FB0BW00.FB0BWIXM = +4; /* Initialize map index*/
  ;
  while (FB0BW00.FB0BWIXM >= 1)
    if (FB0BM010.FB0BM2WH[FB0BWIXM] != " ") /* Warehouse entered*/
      FB0BW00.FB0BWIX1 = +1; /* Initialize second index*/
      while (FB0BW00.FB0BWIX1 <= 4)
        if (FB0BM010.FB0BM2WH[FB0BWIXM] == FB0BM010.FB0BM2WH[FB0BWIX1]
         && FB0BW00.FB0BWIXM != FB0BW00.FB0BWIX1)
          set FB0BM010.FB0BM2WH[FB0BWIXM] cursor, bold;
          converseLib.validationFailed(95); /* Duplicate region requested*/
        end
        FB0BW00.FB0BWIX1 = FB0BW00.FB0BWIX1 + 1;
      end
    end
    FB0BW00.FB0BWIXM = FB0BW00.FB0BWIXM - 1;
  end
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Warehouse 1 edit*/
   /* ------------------------------------------------------------*/
  ;
  FB0BW00.FB0BWIXM = +4; /* Initialize map index*/
  ;
  while (FB0BW00.FB0BWIXM >= 1)
    if (FB0BM010.FB0BM1WH[FB0BWIXM] != " ") /* Warehouse entered*/
      FB0BW00.FB0BWIX1 = +1; /* Initialize second index*/
      while (FB0BW00.FB0BWIX1 <= 4)
        if (FB0BM010.FB0BM1WH[FB0BWIXM] == FB0BM010.FB0BM1WH[FB0BWIX1]
         && FB0BW00.FB0BWIXM != FB0BW00.FB0BWIX1)
          set FB0BM010.FB0BM1WH[FB0BWIXM] cursor, bold;
          converseLib.validationFailed(95); /* Duplicate region requested*/
        end
        FB0BW00.FB0BWIX1 = FB0BW00.FB0BWIX1 + 1;
      end
    end
    FB0BW00.FB0BWIXM = FB0BW00.FB0BWIXM - 1;
  end
  ;
   /* ------------------------------------------------------------*/
   /* Regions requested for combining must match one of the*/
   /* regions obtained from the warehouse table.*/
   /* ------------------------------------------------------------*/
  ;
   /* ------------------------------------------------------------*/
   /* Warehouse 10 edit*/
   /* ------------------------------------------------------------*/
  ;
  FB0BW00.FB0BWIXM = +4; /* Initialize map index*/
  ;
  while (FB0BW00.FB0BWIXM >= 1)
    if (FB0BM010.FB0BM10WH[FB0BWIXM] != " ") /* Warehouse entered*/
      FB0BW00.FB0BWIX1 = +1; /* Initialize second index*/
      FB0BW00.FB0BWRMF = "N"; /* Set region match flag to no*/
      while (FB0BW00.FB0BWIX1 <= 11
       && FB0BW00.FB0BWRMF == "N")
        if (FB0BM010.FB0BM10WH[FB0BWIXM] == FB0BW01.XWHCD[FB0BWIX1])
          FB0BW00.FB0BWRMF = "Y"; /* Region match found*/
        end
        FB0BW00.FB0BWIX1 = FB0BW00.FB0BWIX1 + 1;
      end
      if (FB0BW00.FB0BWRMF == "N")
        converseLib.validationFailed(94); /* Copy from warehouse must be entered*/
        set FB0BM010.FB0BM10WH[FB0BWIXM] cursor, bold; /* Highlight error*/
      end
    end
    FB0BW00.FB0BWIXM = FB0BW00.FB0BWIXM - 1;
  end
  ;
   /* ------------------------------------------------------------*/
   /* Warehouse 9 edit*/
   /* ------------------------------------------------------------*/
  ;
  FB0BW00.FB0BWIXM = +4; /* Initialize map index*/
  ;
  while (FB0BW00.FB0BWIXM >= 1)
    if (FB0BM010.FB0BM9WH[FB0BWIXM] != " ") /* Warehouse entered*/
      FB0BW00.FB0BWIX1 = +1; /* Initialize second index*/
      FB0BW00.FB0BWRMF = "N"; /* Set region match flag to no*/
      while (FB0BW00.FB0BWIX1 <= 11
       && FB0BW00.FB0BWRMF == "N")
        if (FB0BM010.FB0BM9WH[FB0BWIXM] == FB0BW01.XWHCD[FB0BWIX1])
          FB0BW00.FB0BWRMF = "Y"; /* Region match found*/
        end
        FB0BW00.FB0BWIX1 = FB0BW00.FB0BWIX1 + 1;
      end
      if (FB0BW00.FB0BWRMF == "N")
        converseLib.validationFailed(94); /* Copy from warehouse must be entered*/
        set FB0BM010.FB0BM9WH[FB0BWIXM] cursor, bold; /* Highlight error*/
      end
    end
    FB0BW00.FB0BWIXM = FB0BW00.FB0BWIXM - 1;
  end
  ;
   /* ------------------------------------------------------------*/
   /* Warehouse 8 edit*/
   /* ------------------------------------------------------------*/
  ;
  FB0BW00.FB0BWIXM = +4; /* Initialize map index*/
  ;
  while (FB0BW00.FB0BWIXM >= 1)
    if (FB0BM010.FB0BM8WH[FB0BWIXM] != " ") /* Warehouse entered*/
      FB0BW00.FB0BWIX1 = +1; /* Initialize second index*/
      FB0BW00.FB0BWRMF = "N"; /* Set region match flag to no*/
      while (FB0BW00.FB0BWIX1 <= 11
       && FB0BW00.FB0BWRMF == "N")
        if (FB0BM010.FB0BM8WH[FB0BWIXM] == FB0BW01.XWHCD[FB0BWIX1])
          FB0BW00.FB0BWRMF = "Y"; /* Region match found*/
        end
        FB0BW00.FB0BWIX1 = FB0BW00.FB0BWIX1 + 1;
      end
      if (FB0BW00.FB0BWRMF == "N")
        converseLib.validationFailed(94); /* Copy from warehouse must be entered*/
        set FB0BM010.FB0BM8WH[FB0BWIXM] cursor, bold; /* Highlight error*/
      end
    end
    FB0BW00.FB0BWIXM = FB0BW00.FB0BWIXM - 1;
  end
  ;
   /* ------------------------------------------------------------*/
   /* Warehouse 7 edit*/
   /* ------------------------------------------------------------*/
  ;
  FB0BW00.FB0BWIXM = +4; /* Initialize map index*/
  ;
  while (FB0BW00.FB0BWIXM >= 1)
    if (FB0BM010.FB0BM7WH[FB0BWIXM] != " ") /* Warehouse entered*/
      FB0BW00.FB0BWIX1 = +1; /* Initialize second index*/
      FB0BW00.FB0BWRMF = "N"; /* Set region match flag to no*/
      while (FB0BW00.FB0BWIX1 <= 11
       && FB0BW00.FB0BWRMF == "N")
        if (FB0BM010.FB0BM7WH[FB0BWIXM] == FB0BW01.XWHCD[FB0BWIX1])
          FB0BW00.FB0BWRMF = "Y"; /* Region match found*/
        end
        FB0BW00.FB0BWIX1 = FB0BW00.FB0BWIX1 + 1;
      end
      if (FB0BW00.FB0BWRMF == "N")
        converseLib.validationFailed(94); /* Copy from warehouse must be entered*/
        set FB0BM010.FB0BM7WH[FB0BWIXM] cursor, bold; /* Highlight error*/
      end
    end
    FB0BW00.FB0BWIXM = FB0BW00.FB0BWIXM - 1;
  end
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Warehouse 6 edit*/
   /* ------------------------------------------------------------*/
  ;
  FB0BW00.FB0BWIXM = +4; /* Initialize map index*/
  ;
  while (FB0BW00.FB0BWIXM >= 1)
    if (FB0BM010.FB0BM6WH[FB0BWIXM] != " ") /* Warehouse entered*/
      FB0BW00.FB0BWIX1 = +1; /* Initialize second index*/
      FB0BW00.FB0BWRMF = "N"; /* Set region match flag to no*/
      while (FB0BW00.FB0BWIX1 <= 11
       && FB0BW00.FB0BWRMF == "N")
        if (FB0BM010.FB0BM6WH[FB0BWIXM] == FB0BW01.XWHCD[FB0BWIX1])
          FB0BW00.FB0BWRMF = "Y"; /* Region match found*/
        end
        FB0BW00.FB0BWIX1 = FB0BW00.FB0BWIX1 + 1;
      end
      if (FB0BW00.FB0BWRMF == "N")
        converseLib.validationFailed(94); /* Copy from warehouse must be entered*/
        set FB0BM010.FB0BM6WH[FB0BWIXM] cursor, bold; /* Highlight error*/
      end
    end
    FB0BW00.FB0BWIXM = FB0BW00.FB0BWIXM - 1;
  end
  ;
   /* ------------------------------------------------------------*/
   /* Warehouse 5 edit*/
   /* ------------------------------------------------------------*/
  ;
  ;
  FB0BW00.FB0BWIXM = +4; /* Initialize map index*/
  ;
  while (FB0BW00.FB0BWIXM >= 1)
    if (FB0BM010.FB0BM5WH[FB0BWIXM] != " ") /* Warehouse entered*/
      FB0BW00.FB0BWIX1 = +1; /* Initialize second index*/
      FB0BW00.FB0BWRMF = "N"; /* Set region match flag to no*/
      while (FB0BW00.FB0BWIX1 <= 11
       && FB0BW00.FB0BWRMF == "N")
        if (FB0BM010.FB0BM5WH[FB0BWIXM] == FB0BW01.XWHCD[FB0BWIX1])
          FB0BW00.FB0BWRMF = "Y"; /* Region match found*/
        end
        FB0BW00.FB0BWIX1 = FB0BW00.FB0BWIX1 + 1;
      end
      if (FB0BW00.FB0BWRMF == "N")
        converseLib.validationFailed(94); /* Copy from warehouse must be entered*/
        set FB0BM010.FB0BM5WH[FB0BWIXM] cursor, bold; /* Highlight error*/
      end
    end
    FB0BW00.FB0BWIXM = FB0BW00.FB0BWIXM - 1;
  end
  ;
   /* ------------------------------------------------------------*/
   /* Warehouse 4 edit*/
   /* ------------------------------------------------------------*/
  ;
  FB0BW00.FB0BWIXM = +4; /* Initialize map index*/
  ;
  while (FB0BW00.FB0BWIXM >= 1)
    if (FB0BM010.FB0BM4WH[FB0BWIXM] != " ") /* Warehouse entered*/
      FB0BW00.FB0BWIX1 = +1; /* Initialize second index*/
      FB0BW00.FB0BWRMF = "N"; /* Set region match flag to no*/
      while (FB0BW00.FB0BWIX1 <= 11
       && FB0BW00.FB0BWRMF == "N")
        if (FB0BM010.FB0BM4WH[FB0BWIXM] == FB0BW01.XWHCD[FB0BWIX1])
          FB0BW00.FB0BWRMF = "Y"; /* Region match found*/
        end
        FB0BW00.FB0BWIX1 = FB0BW00.FB0BWIX1 + 1;
      end
      if (FB0BW00.FB0BWRMF == "N")
        converseLib.validationFailed(94); /* Copy from warehouse must be entered*/
        set FB0BM010.FB0BM4WH[FB0BWIXM] cursor, bold; /* Highlight error*/
      end
    end
    FB0BW00.FB0BWIXM = FB0BW00.FB0BWIXM - 1;
  end
  ;
   /* ------------------------------------------------------------*/
   /* Warehouse 3 edit*/
   /* ------------------------------------------------------------*/
  ;
  FB0BW00.FB0BWIXM = +4; /* Initialize map index*/
  ;
  while (FB0BW00.FB0BWIXM >= 1)
    if (FB0BM010.FB0BM3WH[FB0BWIXM] != " ") /* Warehouse entered*/
      FB0BW00.FB0BWIX1 = +1; /* Initialize second index*/
      FB0BW00.FB0BWRMF = "N"; /* Set region match flag to no*/
      while (FB0BW00.FB0BWIX1 <= 11
       && FB0BW00.FB0BWRMF == "N")
        if (FB0BM010.FB0BM3WH[FB0BWIXM] == FB0BW01.XWHCD[FB0BWIX1])
          FB0BW00.FB0BWRMF = "Y"; /* Region match found*/
        end
        FB0BW00.FB0BWIX1 = FB0BW00.FB0BWIX1 + 1;
      end
      if (FB0BW00.FB0BWRMF == "N")
        converseLib.validationFailed(94); /* Copy from warehouse must be entered*/
        set FB0BM010.FB0BM3WH[FB0BWIXM] cursor, bold; /* Highlight error*/
      end
    end
    FB0BW00.FB0BWIXM = FB0BW00.FB0BWIXM - 1;
  end
  ;
   /* ------------------------------------------------------------*/
   /* Warehouse 2 edit*/
   /* ------------------------------------------------------------*/
  ;
  FB0BW00.FB0BWIXM = +4; /* Initialize map index*/
  ;
  while (FB0BW00.FB0BWIXM >= 1)
    if (FB0BM010.FB0BM2WH[FB0BWIXM] != " ") /* Warehouse entered*/
      FB0BW00.FB0BWIX1 = +1; /* Initialize second index*/
      FB0BW00.FB0BWRMF = "N"; /* Set region match flag to no*/
      while (FB0BW00.FB0BWIX1 <= 11
       && FB0BW00.FB0BWRMF == "N")
        if (FB0BM010.FB0BM2WH[FB0BWIXM] == FB0BW01.XWHCD[FB0BWIX1])
          FB0BW00.FB0BWRMF = "Y"; /* Region match found*/
        end
        FB0BW00.FB0BWIX1 = FB0BW00.FB0BWIX1 + 1;
      end
      if (FB0BW00.FB0BWRMF == "N")
        converseLib.validationFailed(94); /* Copy from warehouse must be entered*/
        set FB0BM010.FB0BM2WH[FB0BWIXM] cursor, bold; /* Highlight error*/
      end
    end
    FB0BW00.FB0BWIXM = FB0BW00.FB0BWIXM - 1;
  end
  ;
   /* ------------------------------------------------------------*/
   /* Warehouse 1 edit*/
   /* ------------------------------------------------------------*/
  ;
  FB0BW00.FB0BWIXM = +4; /* Initialize map index*/
  ;
  while (FB0BW00.FB0BWIXM >= 1)
    if (FB0BM010.FB0BM1WH[FB0BWIXM] != " ") /* Warehouse entered*/
      FB0BW00.FB0BWIX1 = +1; /* Initialize second index*/
      FB0BW00.FB0BWRMF = "N"; /* Set region match flag to no*/
      while (FB0BW00.FB0BWIX1 <= 11
       && FB0BW00.FB0BWRMF == "N")
        if (FB0BM010.FB0BM1WH[FB0BWIXM] == FB0BW01.XWHCD[FB0BWIX1])
          FB0BW00.FB0BWRMF = "Y"; /* Region match found*/
        end
        FB0BW00.FB0BWIX1 = FB0BW00.FB0BWIX1 + 1;
      end
      if (FB0BW00.FB0BWRMF == "N")
        converseLib.validationFailed(94); /* Copy from warehouse must be entered*/
        set FB0BM010.FB0BM1WH[FB0BWIXM] cursor, bold; /* Highlight error*/
      end
    end
    FB0BW00.FB0BWIXM = FB0BW00.FB0BWIXM - 1;
  end
  ;
  ;
   /* ------------------------------------------------------------*/
   /* If any errors ezeflo to display map*/
   /* ------------------------------------------------------------*/
  ;
  ;
  if (converseVar.validationMsgNum != 0)
    exit stack;
  end
  ;
  ;
end // end FB0B500

// Process valid input request
Function FB0B600()
  ;
   /* ------------------------------------------------------------*/
   /* This process should only be performed when PF9 update*/
   /* has been selected.*/
   /* ------------------------------------------------------------*/
  ;
  if (converseVar.eventKey is pf9 /* Update*/
  )                               /* NEXT SENTENCE*/
  else
    return;
  end
  ;
   /* ------------------------------------------------------------*/
   /* Load the entered warehouses from the screen into the jcl*/
   /* parm statements in the fb0bw02 record.*/
   /* ------------------------------------------------------------*/
  ;
  set FB0BW02 empty; /* Initialize parm record*/
  ;
   /* ------------------------------------------------------------*/
   /* Load the first warehouse data*/
   /* ------------------------------------------------------------*/
  ;
  FB0BW00.FB0BWIXM = +1; /* Initialize index*/
  FB0BW00.FB0BWIX1 = +1; /* Initialize work index*/
  FB0BW00.FB0BWIX3 = +0; /* Initialize warehouse index*/
  ;
  while (FB0BW00.FB0BWIXM <= 4)
    if (FB0BM010.FB0BM1WH[FB0BWIXM] != " ")
      FB0BW02.FB0BW1WH[FB0BWIX1] = FB0BM010.FB0BM1WH[FB0BWIXM];
      FB0BW00.FB0BWIX1 = FB0BW00.FB0BWIX1 + 1;
    end
    FB0BW00.FB0BWIXM = FB0BW00.FB0BWIXM + 1;
  end
  ;
  if (FB0BM010.XWHCD[1] != " "
   && FB0BM010.FB0BM1WH[1] != " ")
    FB0BW00.FB0BWIX3 = FB0BW00.FB0BWIX3 + 1;
  end
  ;
   /* ------------------------------------------------------------*/
   /* Load the second warehouse data*/
   /* ------------------------------------------------------------*/
  ;
  FB0BW00.FB0BWIXM = +1; /* Initialize index*/
  FB0BW00.FB0BWIX1 = +1; /* Initialize work index*/
  ;
  while (FB0BW00.FB0BWIXM <= 4)
    if (FB0BM010.FB0BM2WH[FB0BWIXM] != " ")
      FB0BW02.FB0BW2WH[FB0BWIX1] = FB0BM010.FB0BM2WH[FB0BWIXM];
      FB0BW00.FB0BWIX1 = FB0BW00.FB0BWIX1 + 1;
    end
    FB0BW00.FB0BWIXM = FB0BW00.FB0BWIXM + 1;
  end
  ;
  if (FB0BM010.XWHCD[2] != " "
   && FB0BM010.FB0BM2WH[1] != " ")
    FB0BW00.FB0BWIX3 = FB0BW00.FB0BWIX3 + 1;
  end
  ;
   /* ------------------------------------------------------------*/
   /* Load the third warehouse data*/
   /* ------------------------------------------------------------*/
  ;
  FB0BW00.FB0BWIXM = +1; /* Initialize index*/
  FB0BW00.FB0BWIX1 = +1; /* Initialize work index*/
  ;
  while (FB0BW00.FB0BWIXM <= 4)
    if (FB0BM010.FB0BM3WH[FB0BWIXM] != " ")
      FB0BW02.FB0BW3WH[FB0BWIX1] = FB0BM010.FB0BM3WH[FB0BWIXM];
      FB0BW00.FB0BWIX1 = FB0BW00.FB0BWIX1 + 1;
    end
    FB0BW00.FB0BWIXM = FB0BW00.FB0BWIXM + 1;
  end
  ;
  if (FB0BM010.XWHCD[3] != " "
   && FB0BM010.FB0BM3WH[1] != " ")
    FB0BW00.FB0BWIX3 = FB0BW00.FB0BWIX3 + 1;
  end
  ;
   /* ------------------------------------------------------------*/
   /* Load the fourth warehouse data*/
   /* ------------------------------------------------------------*/
  ;
  FB0BW00.FB0BWIXM = +1; /* Initialize index*/
  FB0BW00.FB0BWIX1 = +1; /* Initialize work index*/
  ;
  while (FB0BW00.FB0BWIXM <= 4)
    if (FB0BM010.FB0BM4WH[FB0BWIXM] != " ")
      FB0BW02.FB0BW4WH[FB0BWIX1] = FB0BM010.FB0BM4WH[FB0BWIXM];
      FB0BW00.FB0BWIX1 = FB0BW00.FB0BWIX1 + 1;
    end
    FB0BW00.FB0BWIXM = FB0BW00.FB0BWIXM + 1;
  end
  ;
  if (FB0BM010.XWHCD[4] != " "
   && FB0BM010.FB0BM4WH[1] != " ")
    FB0BW00.FB0BWIX3 = FB0BW00.FB0BWIX3 + 1;
  end
  ;
   /* ------------------------------------------------------------*/
   /* Load the fifth warehouse data*/
   /* ------------------------------------------------------------*/
  ;
  FB0BW00.FB0BWIXM = +1; /* Initialize index*/
  FB0BW00.FB0BWIX1 = +1; /* Initialize work index*/
  ;
  while (FB0BW00.FB0BWIXM <= 4)
    if (FB0BM010.FB0BM5WH[FB0BWIXM] != " ")
      FB0BW02.FB0BW5WH[FB0BWIX1] = FB0BM010.FB0BM5WH[FB0BWIXM];
      FB0BW00.FB0BWIX1 = FB0BW00.FB0BWIX1 + 1;
    end
    FB0BW00.FB0BWIXM = FB0BW00.FB0BWIXM + 1;
  end
  ;
  if (FB0BM010.XWHCD[5] != " "
   && FB0BM010.FB0BM5WH[1] != " ")
    FB0BW00.FB0BWIX3 = FB0BW00.FB0BWIX3 + 1;
  end
  ;
   /* ------------------------------------------------------------*/
   /* Load the sixth warehouse data*/
   /* ------------------------------------------------------------*/
  ;
  FB0BW00.FB0BWIXM = +1; /* Initialize index*/
  FB0BW00.FB0BWIX1 = +1; /* Initialize work index*/
  ;
  while (FB0BW00.FB0BWIXM <= 4)
    if (FB0BM010.FB0BM6WH[FB0BWIXM] != " ")
      FB0BW02.FB0BW6WH[FB0BWIX1] = FB0BM010.FB0BM6WH[FB0BWIXM];
      FB0BW00.FB0BWIX1 = FB0BW00.FB0BWIX1 + 1;
    end
    FB0BW00.FB0BWIXM = FB0BW00.FB0BWIXM + 1;
  end
  ;
  if (FB0BM010.XWHCD[6] != " "
   && FB0BM010.FB0BM6WH[1] != " ")
    FB0BW00.FB0BWIX3 = FB0BW00.FB0BWIX3 + 1;
  end
  ;
   /* ------------------------------------------------------------*/
   /* Load the seventh warehouse data*/
   /* ------------------------------------------------------------*/
  ;
  FB0BW00.FB0BWIXM = +1; /* Initialize index*/
  FB0BW00.FB0BWIX1 = +1; /* Initialize work index*/
  ;
  while (FB0BW00.FB0BWIXM <= 4)
    if (FB0BM010.FB0BM7WH[FB0BWIXM] != " ")
      FB0BW02.FB0BW7WH[FB0BWIX1] = FB0BM010.FB0BM7WH[FB0BWIXM];
      FB0BW00.FB0BWIX1 = FB0BW00.FB0BWIX1 + 1;
    end
    FB0BW00.FB0BWIXM = FB0BW00.FB0BWIXM + 1;
  end
  ;
  if (FB0BM010.XWHCD[7] != " "
   && FB0BM010.FB0BM7WH[1] != " ")
    FB0BW00.FB0BWIX3 = FB0BW00.FB0BWIX3 + 1;
  end
  ;
   /* ------------------------------------------------------------*/
   /* Load the eighth warehouse data*/
   /* ------------------------------------------------------------*/
  ;
  FB0BW00.FB0BWIXM = +1; /* Initialize index*/
  FB0BW00.FB0BWIX1 = +1; /* Initialize work index*/
  ;
  while (FB0BW00.FB0BWIXM <= 4)
    if (FB0BM010.FB0BM8WH[FB0BWIXM] != " ")
      FB0BW02.FB0BW8WH[FB0BWIX1] = FB0BM010.FB0BM8WH[FB0BWIXM];
      FB0BW00.FB0BWIX1 = FB0BW00.FB0BWIX1 + 1;
    end
    FB0BW00.FB0BWIXM = FB0BW00.FB0BWIXM + 1;
  end
  ;
  if (FB0BM010.XWHCD[8] != " "
   && FB0BM010.FB0BM8WH[1] != " ")
    FB0BW00.FB0BWIX3 = FB0BW00.FB0BWIX3 + 1;
  end
  ;
   /* ------------------------------------------------------------*/
   /* Load the ninth warehouse data*/
   /* ------------------------------------------------------------*/
  ;
  FB0BW00.FB0BWIXM = +1; /* Initialize index*/
  FB0BW00.FB0BWIX1 = +1; /* Initialize work index*/
  ;
  while (FB0BW00.FB0BWIXM <= 4)
    if (FB0BM010.FB0BM9WH[FB0BWIXM] != " ")
      FB0BW02.FB0BW9WH[FB0BWIX1] = FB0BM010.FB0BM9WH[FB0BWIXM];
      FB0BW00.FB0BWIX1 = FB0BW00.FB0BWIX1 + 1;
    end
    FB0BW00.FB0BWIXM = FB0BW00.FB0BWIXM + 1;
  end
  ;
  if (FB0BM010.XWHCD[9] != " "
   && FB0BM010.FB0BM9WH[1] != " ")
    FB0BW00.FB0BWIX3 = FB0BW00.FB0BWIX3 + 1;
  end
  ;
   /* ------------------------------------------------------------*/
   /* Load the tenth warehouse data*/
   /* ------------------------------------------------------------*/
  ;
  FB0BW00.FB0BWIXM = +1; /* Initialize index*/
  FB0BW00.FB0BWIX1 = +1; /* Initialize work index*/
  ;
  while (FB0BW00.FB0BWIXM <= 4)
    if (FB0BM010.FB0BM10WH[FB0BWIXM] != " ")
      FB0BW02.FB0BW10WH[FB0BWIX1] = FB0BM010.FB0BM10WH[FB0BWIXM];
      FB0BW00.FB0BWIX1 = FB0BW00.FB0BWIX1 + 1;
    end
    FB0BW00.FB0BWIXM = FB0BW00.FB0BWIXM + 1;
  end
  ;
  if (FB0BM010.XWHCD[10] != " "
   && FB0BM010.FB0BM10WH[1] != " ")
    FB0BW00.FB0BWIX3 = FB0BW00.FB0BWIX3 + 1;
  end
  ;
   /* ------------------------------------------------------------*/
   /* If there are more than three warehouse codes have been*/
   /* entered then perform error message.*/
   /* ------------------------------------------------------------*/
  ;
  if (FB0BW00.FB0BWIX3 > 3)
    converseLib.validationFailed(511);
    XXXMODID = "600";
    exit stack;
  end
   /* ------------------------------------------------------------*/
   /* If no data was entered in any of the warehouses it is an*/
   /* error.*/
   /* ------------------------------------------------------------*/
  ;
  if (FB0BW02.FB0BW1WH == " "
   && FB0BW02.FB0BW2WH == " "
   && FB0BW02.FB0BW3WH == " "
   && FB0BW02.FB0BW4WH == " "
   && FB0BW02.FB0BW5WH == " "
   && FB0BW02.FB0BW6WH == " "
   && FB0BW02.FB0BW7WH == " "
   && FB0BW02.FB0BW8WH == " "
   && FB0BW02.FB0BW9WH == " "
   && FB0BW02.FB0BW10WH == " ")
    ;
    converseLib.validationFailed(66);
    XXXMODID = "600";
    exit stack;
    ;
  end
  ;
  ;
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Call sub-routine to find which environment*/
   /* the program is executing in, development*/
   /* or production.*/
   /* ------------------------------------------------------------*/
  TA3REC.TA3OPTN = "ALLFLDS";
  try
    call "TA0230" (TA3REC) {isNoRefresh = yes, isExternal = yes};
  end
  ;
  if (sysVar.errorCode == "00000000") /* Call successful*/
    if (TA3REC.TA3RGNID == "03") /* if on production system*/
      FB0B605(); /* format production jcl*/
    else
      FB0B607(); /* format development jcl*/
    end
  end
  ;
  ;
  ;
  ;
  ;
  ;
   /* ------------------------------------------------------------*/
   /* UPdate the vselhd01 row*/
   /* ------------------------------------------------------------*/
  ;
  ;
  if (FB1REC.FB1CRVST == "1")
    ;
    FB0B620(); /* Update the vselhd01 row*/
    ;
  end
  ;
   /* ------------------------------------------------------------*/
   /* Submit the JCL and parameters for batch execution.*/
   /* ------------------------------------------------------------*/
  ;
  FB0B630(); /* Submit the JCL*/
  ;
   /* ------------------------------------------------------------*/
   /* Display results of print request.*/
   /* ------------------------------------------------------------*/
  ;
  ;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.commit();
  ;
  set FB0BM010 empty; /* 010 input/output area*/
  FB0BM010.XXXCURDT = VGVar.currentShortGregorianDate; /* Move date to map*/
  ;
   /* Format an information message to display in ezemsg*/
  ;
  FB0BW00.FB0BW1LT = "** SIZE PERCENT CALCULATION ";
  FB0BW00.FB0BW2LT = "SUBMITTED, YOUR DUMMY NBR IS: ";
  FB0BW00.FB1DUMNB = FBWREC.FB1DUMNB; /* Dummy curve number*/
  FB0BW00.FB0BWDUM = FB0BW00.FB1DUMNB;
  FB0BM010.VAGen_EZEMSG = FB0BW00.FB0BWMSG; /* Message to message area*/
  FB0B400(); /* reset map*/
  set FB0BM010.CATOAP cursor; /* set cursor*/
  set FBWREC empty; /* Initialize record*/
  COMMAREA.CAUSERA = FBWREC.FBWGROUP; /* Move to commarea*/
  ;
  ;
  ;
end // end FB0B600

// Format production jcl
Function FB0B605()
   /* ------------------------------------------------------------*/
   /* Initialize the work areas and indexes to be used.*/
   /* ------------------------------------------------------------*/
  ;
  set TA6REC empty; /* Subroutine work area*/
  ;
  FB0BW00.FB0BWIXT = 1; /* Initialize table index*/
  TA6REC.TA6INDEX = 1; /* Initialize parameters index*/
  TA6REC.TA6MSGSW = "N"; /* No on-line notify message*/
  FB0BW00.FB0BWIX1 = 1; /* Initialize fb0bw02 parm index*/
  ;
   /* ------------------------------------------------------------*/
   /* Format JCL and parameters into the subroutine work area.*/
   /* ------------------------------------------------------------*/
  ;
  while (FB0BW00.FB0BWIXT > 0) /* Until end of table*/
    ;
    ;
    if (FB0BT02.TARTYPE[FB0BWIXT] == "P") /* Parameters statement*/
      ;
      /* ------------------------------------------------------------*/
       /* Format region parameters*/
      /* ------------------------------------------------------------*/
      ;
      TA6REC.TARTYPE[TA6INDEX] = FB0BT02.TARTYPE[FB0BWIXT]; /* Type*/
      ;
      FB0B610();
      ;
    else
      /* ------------------------------------------------------------*/
       /* Format the Job Control Language statement from the table.*/
      /* ------------------------------------------------------------*/
      ;
      TA6REC.TARJCL[TA6INDEX] = FB0BT02.TARJCL[FB0BWIXT]; /* JCL*/
      TA6REC.TARTYPE[TA6INDEX] = FB0BT02.TARTYPE[FB0BWIXT]; /* Type*/
      ;
      TA6REC.TA6INDEX = TA6REC.TA6INDEX + 1; /* Increment parms index*/
      ;
    end
    ;
    /* ------------------------------------------------------------*/
     /* If not end of table, increment the table index.*/
    /* ------------------------------------------------------------*/
    ;
    if (FB0BT02.TARJCL[FB0BWIXT] == "/*EOF") /* End of table*/
      ;
      FB0BW00.FB0BWIXT = 0; /* Indicate end of table*/
      ;
    else
      ;
      FB0BW00.FB0BWIXT = FB0BW00.FB0BWIXT + 1; /* Increment table index*/
      ;
    end
    ;
  end
  ;
end // end FB0B605

// Format development jcl
Function FB0B607()
   /* ------------------------------------------------------------*/
   /* Initialize the work areas and indexes to be used.*/
   /* ------------------------------------------------------------*/
  ;
  set TA6REC empty; /* Subroutine work area*/
  ;
  FB0BW00.FB0BWIXT = 1; /* Initialize table index*/
  TA6REC.TA6INDEX = 1; /* Initialize parameters index*/
  TA6REC.TA6MSGSW = "N"; /* No on-line notify message*/
  FB0BW00.FB0BWIX1 = 1; /* Initialize fb0bw02 parm index*/
  ;
   /* ------------------------------------------------------------*/
   /* Format JCL and parameters into the subroutine work area.*/
   /* ------------------------------------------------------------*/
  ;
  while (FB0BW00.FB0BWIXT > 0) /* Until end of table*/
    ;
    ;
    if (FB0BT01.TARTYPE[FB0BWIXT] == "P") /* Parameters statement*/
      ;
      /* ------------------------------------------------------------*/
       /* Format region parameters*/
      /* ------------------------------------------------------------*/
      ;
      TA6REC.TARTYPE[TA6INDEX] = FB0BT01.TARTYPE[FB0BWIXT]; /* Type*/
      ;
      FB0B610();
      ;
    else
      /* ------------------------------------------------------------*/
       /* Format the Job Control Language statement from the table.*/
      /* ------------------------------------------------------------*/
      ;
      TA6REC.TARJCL[TA6INDEX] = FB0BT01.TARJCL[FB0BWIXT]; /* JCL*/
      TA6REC.TARTYPE[TA6INDEX] = FB0BT01.TARTYPE[FB0BWIXT]; /* Type*/
      ;
      TA6REC.TA6INDEX = TA6REC.TA6INDEX + 1; /* Increment parms index*/
      ;
    end
    ;
    /* ------------------------------------------------------------*/
     /* If not end of table, increment the table index.*/
    /* ------------------------------------------------------------*/
    ;
    if (FB0BT01.TARJCL[FB0BWIXT] == "/*EOF") /* End of table*/
      ;
      FB0BW00.FB0BWIXT = 0; /* Indicate end of table*/
      ;
    else
      ;
      FB0BW00.FB0BWIXT = FB0BW00.FB0BWIXT + 1; /* Increment table index*/
      ;
    end
    ;
  end
  ;
end // end FB0B607

// Format region parameters
Function FB0B610()
   /* ------------------------------------------------------------*/
   /* Format region parameters---Use field fb0bw00.fb0bwix1 to*/
   /* determine which fb0bw02 parms to move.*/
   /* ------------------------------------------------------------*/
  ;
  if (FB0BW00.FB0BWIX1 == 1)
    TA6REC.TARJCL[TA6INDEX] = FB0BW00.FB0BWSQN; /* jcl*/
  end
  ;
  if (FB0BW00.FB0BWIX1 == 2)
    ;
    FB0BW03.FB0BWW1 = FB0BM010.XWHCD[1];
    FB0BW03.FB0BWW2 = FB0BM010.FB0BM1WH[1];
    FB0BW03.FB0BWW3 = FB0BM010.FB0BM1WH[2];
    FB0BW03.FB0BWW4 = FB0BM010.FB0BM1WH[3];
    FB0BW03.FB0BWW5 = FB0BM010.FB0BM1WH[4];
    TA6REC.TARJCL[TA6INDEX] = FB0BW03.FB0BWWG; /* JCL*/
  end
  ;
  if (FB0BW00.FB0BWIX1 == 3)
    ;
    FB0BW03.FB0BWW1 = FB0BM010.XWHCD[2];
    FB0BW03.FB0BWW2 = FB0BM010.FB0BM2WH[1];
    FB0BW03.FB0BWW3 = FB0BM010.FB0BM2WH[2];
    FB0BW03.FB0BWW4 = FB0BM010.FB0BM2WH[3];
    FB0BW03.FB0BWW5 = FB0BM010.FB0BM2WH[4];
    TA6REC.TARJCL[TA6INDEX] = FB0BW03.FB0BWWG; /* JCL*/
  end
  ;
  if (FB0BW00.FB0BWIX1 == 4)
    ;
    FB0BW03.FB0BWW1 = FB0BM010.XWHCD[3];
    FB0BW03.FB0BWW2 = FB0BM010.FB0BM3WH[1];
    FB0BW03.FB0BWW3 = FB0BM010.FB0BM3WH[2];
    FB0BW03.FB0BWW4 = FB0BM010.FB0BM3WH[3];
    FB0BW03.FB0BWW5 = FB0BM010.FB0BM3WH[4];
    TA6REC.TARJCL[TA6INDEX] = FB0BW03.FB0BWWG; /* JCL*/
  end
  ;
  if (FB0BW00.FB0BWIX1 == 5)
    ;
    FB0BW03.FB0BWW1 = FB0BM010.XWHCD[4];
    FB0BW03.FB0BWW2 = FB0BM010.FB0BM4WH[1];
    FB0BW03.FB0BWW3 = FB0BM010.FB0BM4WH[2];
    FB0BW03.FB0BWW4 = FB0BM010.FB0BM4WH[3];
    FB0BW03.FB0BWW5 = FB0BM010.FB0BM4WH[4];
    TA6REC.TARJCL[TA6INDEX] = FB0BW03.FB0BWWG; /* JCL*/
  end
  ;
  if (FB0BW00.FB0BWIX1 == 6)
    ;
    FB0BW03.FB0BWW1 = FB0BM010.XWHCD[5];
    FB0BW03.FB0BWW2 = FB0BM010.FB0BM5WH[1];
    FB0BW03.FB0BWW3 = FB0BM010.FB0BM5WH[2];
    FB0BW03.FB0BWW4 = FB0BM010.FB0BM5WH[3];
    FB0BW03.FB0BWW5 = FB0BM010.FB0BM5WH[4];
    TA6REC.TARJCL[TA6INDEX] = FB0BW03.FB0BWWG; /* JCL*/
  end
  ;
  if (FB0BW00.FB0BWIX1 == 7)
    ;
    FB0BW03.FB0BWW1 = FB0BM010.XWHCD[6];
    FB0BW03.FB0BWW2 = FB0BM010.FB0BM6WH[1];
    FB0BW03.FB0BWW3 = FB0BM010.FB0BM6WH[2];
    FB0BW03.FB0BWW4 = FB0BM010.FB0BM6WH[3];
    FB0BW03.FB0BWW5 = FB0BM010.FB0BM6WH[4];
    TA6REC.TARJCL[TA6INDEX] = FB0BW03.FB0BWWG; /* JCL*/
  end
  ;
  if (FB0BW00.FB0BWIX1 == 8)
    ;
    FB0BW03.FB0BWW1 = FB0BM010.XWHCD[7];
    FB0BW03.FB0BWW2 = FB0BM010.FB0BM7WH[1];
    FB0BW03.FB0BWW3 = FB0BM010.FB0BM7WH[2];
    FB0BW03.FB0BWW4 = FB0BM010.FB0BM7WH[3];
    FB0BW03.FB0BWW5 = FB0BM010.FB0BM7WH[4];
    TA6REC.TARJCL[TA6INDEX] = FB0BW03.FB0BWWG; /* JCL*/
  end
  ;
  if (FB0BW00.FB0BWIX1 == 9)
    ;
    FB0BW03.FB0BWW1 = FB0BM010.XWHCD[8];
    FB0BW03.FB0BWW2 = FB0BM010.FB0BM8WH[1];
    FB0BW03.FB0BWW3 = FB0BM010.FB0BM8WH[2];
    FB0BW03.FB0BWW4 = FB0BM010.FB0BM8WH[3];
    FB0BW03.FB0BWW5 = FB0BM010.FB0BM8WH[4];
    TA6REC.TARJCL[TA6INDEX] = FB0BW03.FB0BWWG; /* JCL*/
  end
  ;
  if (FB0BW00.FB0BWIX1 == 10)
    ;
    FB0BW03.FB0BWW1 = FB0BM010.XWHCD[9];
    FB0BW03.FB0BWW2 = FB0BM010.FB0BM9WH[1];
    FB0BW03.FB0BWW3 = FB0BM010.FB0BM9WH[2];
    FB0BW03.FB0BWW4 = FB0BM010.FB0BM9WH[3];
    FB0BW03.FB0BWW5 = FB0BM010.FB0BM9WH[4];
    TA6REC.TARJCL[TA6INDEX] = FB0BW03.FB0BWWG; /* JCL*/
  end
  ;
  if (FB0BW00.FB0BWIX1 == 11)
    ;
    FB0BW03.FB0BWW1 = FB0BM010.XWHCD[10];
    FB0BW03.FB0BWW2 = FB0BM010.FB0BM10WH[1];
    FB0BW03.FB0BWW3 = FB0BM010.FB0BM10WH[2];
    FB0BW03.FB0BWW4 = FB0BM010.FB0BM10WH[3];
    FB0BW03.FB0BWW5 = FB0BM010.FB0BM10WH[4];
    TA6REC.TARJCL[TA6INDEX] = FB0BW03.FB0BWWG; /* JCL*/
  end
  ;
  /* ****************************************************/
  /* BUILD THE PARAMETER INTO COMMENTS FOR REFERENCES **/
  /* ****************************************************/
  ;
  FB0BW03.FB0BWAS = "//*"; /* Put the parm into*/
                                   /* comments*/
  if (FB0BW00.FB0BWIX1 == 12)
    FB0BW03.FB0BWG = FB0BW00.FB0BWSQN;
    TA6REC.TARJCL[TA6INDEX] = FB0BW03.FB0BWCMT; /* JCL*/
  end
  ;
  if (FB0BW00.FB0BWIX1 == 13)
    ;
    FB0BW03.FB0BWW1 = FB0BM010.XWHCD[1];
    FB0BW03.FB0BWW2 = FB0BM010.FB0BM1WH[1];
    FB0BW03.FB0BWW3 = FB0BM010.FB0BM1WH[2];
    FB0BW03.FB0BWW4 = FB0BM010.FB0BM1WH[3];
    FB0BW03.FB0BWW5 = FB0BM010.FB0BM1WH[4];
    FB0BW03.FB0BWG = FB0BW03.FB0BWWG; /* Group level for warehoses*/
    TA6REC.TARJCL[TA6INDEX] = FB0BW03.FB0BWCMT; /* JCL parm comment*/
  end
  ;
  if (FB0BW00.FB0BWIX1 == 14)
    ;
    FB0BW03.FB0BWW1 = FB0BM010.XWHCD[2];
    FB0BW03.FB0BWW2 = FB0BM010.FB0BM2WH[1];
    FB0BW03.FB0BWW3 = FB0BM010.FB0BM2WH[2];
    FB0BW03.FB0BWW4 = FB0BM010.FB0BM2WH[3];
    FB0BW03.FB0BWW5 = FB0BM010.FB0BM2WH[4];
    FB0BW03.FB0BWG = FB0BW03.FB0BWWG; /* Group level for warehoses*/
    TA6REC.TARJCL[TA6INDEX] = FB0BW03.FB0BWCMT; /* JCL parm comment*/
  end
  ;
  if (FB0BW00.FB0BWIX1 == 15)
    ;
    FB0BW03.FB0BWW1 = FB0BM010.XWHCD[3];
    FB0BW03.FB0BWW2 = FB0BM010.FB0BM3WH[1];
    FB0BW03.FB0BWW3 = FB0BM010.FB0BM3WH[2];
    FB0BW03.FB0BWW4 = FB0BM010.FB0BM3WH[3];
    FB0BW03.FB0BWW5 = FB0BM010.FB0BM3WH[4];
    FB0BW03.FB0BWG = FB0BW03.FB0BWWG; /* Group level for warehoses*/
    TA6REC.TARJCL[TA6INDEX] = FB0BW03.FB0BWCMT; /* JCL parm comment*/
  end
  ;
  if (FB0BW00.FB0BWIX1 == 16)
    ;
    FB0BW03.FB0BWW1 = FB0BM010.XWHCD[4];
    FB0BW03.FB0BWW2 = FB0BM010.FB0BM4WH[1];
    FB0BW03.FB0BWW3 = FB0BM010.FB0BM4WH[2];
    FB0BW03.FB0BWW4 = FB0BM010.FB0BM4WH[3];
    FB0BW03.FB0BWW5 = FB0BM010.FB0BM4WH[4];
    FB0BW03.FB0BWG = FB0BW03.FB0BWWG; /* Group level for warehoses*/
    TA6REC.TARJCL[TA6INDEX] = FB0BW03.FB0BWCMT; /* JCL parm comment*/
  end
  ;
  if (FB0BW00.FB0BWIX1 == 17)
    ;
    FB0BW03.FB0BWW1 = FB0BM010.XWHCD[5];
    FB0BW03.FB0BWW2 = FB0BM010.FB0BM5WH[1];
    FB0BW03.FB0BWW3 = FB0BM010.FB0BM5WH[2];
    FB0BW03.FB0BWW4 = FB0BM010.FB0BM5WH[3];
    FB0BW03.FB0BWW5 = FB0BM010.FB0BM5WH[4];
    FB0BW03.FB0BWG = FB0BW03.FB0BWWG; /* Group level for warehoses*/
    TA6REC.TARJCL[TA6INDEX] = FB0BW03.FB0BWCMT; /* JCL parm comment*/
  end
  ;
  if (FB0BW00.FB0BWIX1 == 18)
    ;
    FB0BW03.FB0BWW1 = FB0BM010.XWHCD[6];
    FB0BW03.FB0BWW2 = FB0BM010.FB0BM6WH[1];
    FB0BW03.FB0BWW3 = FB0BM010.FB0BM6WH[2];
    FB0BW03.FB0BWW4 = FB0BM010.FB0BM6WH[3];
    FB0BW03.FB0BWW5 = FB0BM010.FB0BM6WH[4];
    FB0BW03.FB0BWG = FB0BW03.FB0BWWG; /* Group level for warehoses*/
    TA6REC.TARJCL[TA6INDEX] = FB0BW03.FB0BWCMT; /* JCL parm comment*/
  end
  ;
  if (FB0BW00.FB0BWIX1 == 19)
    ;
    FB0BW03.FB0BWW1 = FB0BM010.XWHCD[7];
    FB0BW03.FB0BWW2 = FB0BM010.FB0BM7WH[1];
    FB0BW03.FB0BWW3 = FB0BM010.FB0BM7WH[2];
    FB0BW03.FB0BWW4 = FB0BM010.FB0BM7WH[3];
    FB0BW03.FB0BWW5 = FB0BM010.FB0BM7WH[4];
    FB0BW03.FB0BWG = FB0BW03.FB0BWWG; /* Group level for warehoses*/
    TA6REC.TARJCL[TA6INDEX] = FB0BW03.FB0BWCMT; /* JCL parm comment*/
  end
  ;
  if (FB0BW00.FB0BWIX1 == 20)
    ;
    FB0BW03.FB0BWW1 = FB0BM010.XWHCD[8];
    FB0BW03.FB0BWW2 = FB0BM010.FB0BM8WH[1];
    FB0BW03.FB0BWW3 = FB0BM010.FB0BM8WH[2];
    FB0BW03.FB0BWW4 = FB0BM010.FB0BM8WH[3];
    FB0BW03.FB0BWW5 = FB0BM010.FB0BM8WH[4];
    FB0BW03.FB0BWG = FB0BW03.FB0BWWG; /* Group level for warehoses*/
    TA6REC.TARJCL[TA6INDEX] = FB0BW03.FB0BWCMT; /* JCL parm comment*/
  end
  ;
  if (FB0BW00.FB0BWIX1 == 21)
    ;
    FB0BW03.FB0BWW1 = FB0BM010.XWHCD[9];
    FB0BW03.FB0BWW2 = FB0BM010.FB0BM9WH[1];
    FB0BW03.FB0BWW3 = FB0BM010.FB0BM9WH[2];
    FB0BW03.FB0BWW4 = FB0BM010.FB0BM9WH[3];
    FB0BW03.FB0BWW5 = FB0BM010.FB0BM9WH[4];
    FB0BW03.FB0BWG = FB0BW03.FB0BWWG; /* Group level for warehoses*/
    TA6REC.TARJCL[TA6INDEX] = FB0BW03.FB0BWCMT; /* JCL parm comment*/
  end
  ;
  if (FB0BW00.FB0BWIX1 == 22)
    ;
    FB0BW03.FB0BWW1 = FB0BM010.XWHCD[10];
    FB0BW03.FB0BWW2 = FB0BM010.FB0BM10WH[1];
    FB0BW03.FB0BWW3 = FB0BM010.FB0BM10WH[2];
    FB0BW03.FB0BWW4 = FB0BM010.FB0BM10WH[3];
    FB0BW03.FB0BWW5 = FB0BM010.FB0BM10WH[4];
    FB0BW03.FB0BWG = FB0BW03.FB0BWWG; /* Group level for warehoses*/
    TA6REC.TARJCL[TA6INDEX] = FB0BW03.FB0BWCMT; /* JCL parm comment*/
  end
  ;
  TA6REC.TA6INDEX = TA6REC.TA6INDEX + 1; /* Increment parms index*/
  FB0BW00.FB0BWIX1 = FB0BW00.FB0BWIX1 + 1; /* Increment fb0bw02 index*/
  ;
  ;
end // end FB0B610

// Update vselhd01 row
Function FB0B620()
  ;
   /* ------------------------------------------------------------*/
   /* Update the field on the report in storage.*/
   /* ------------------------------------------------------------*/
  ;
  ;
  FB1REC.FB1CRVST = "2"; /* Update status code*/
  ;
   /* ------------------------------------------------------------*/
   /* Format the change date and time*/
   /* ------------------------------------------------------------*/
  ;
  XX0XS01();
  FB1REC.ZZZCHGDT = XX0XW01.XX0XWDAT; /* Change date*/
  FB1REC.ZZZCHGTM = XX0XW01.XX0XWTIM; /* Change time*/
  ;
   /* ------------------------------------------------------------*/
   /* Select vselhd01 row for update*/
   /* ------------------------------------------------------------*/
  ;
  try
    call "IO3030" ("U ", SQLCA, FB1REC) {isNoRefresh = yes, isExternal = yes};
  end /* update row*/
  ;
   /* ------------------------------------------------------------*/
   /* If successful, return to calling process.*/
   /* ------------------------------------------------------------*/
  ;
  if (sysVar.errorCode == "00000000") /* Call successful*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Normal return code*/
      return; /* Return to previous process*/
    end
    /* ------------------------------------------------------------*/
     /* If row not found, indicate the data was updated by another*/
    /* ------------------------------------------------------------*/
    if (SQLCA.VAGen_SQLCODE == +100) /* database updated by another user*/
      set FB0BM010 initial; /* M010 input/output*/
      VGVar.handleSysLibraryErrors = 0;
      sysLib.rollback(); /* rollback changes made by user*/
      FB0BM010.XXXMODID = "620"; /* Module identification*/
      converseLib.validationFailed(46); /* 'database updated by another user'*/
      exit stack; /* Exit to display map*/
    end
  end
  ;
   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user,*/
   /* Otherwise, indicate that a system error has occured.*/
   /* ------------------------------------------------------------*/
  ;
  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/
  FB0BM010.XXXMODID = "620"; /* Module identification*/
  ;
  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* database currently in use*/
    ;
    converseLib.validationFailed(57); /* 'database currently in use'*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
    ;
  else
    ;
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback(); /* rollback changes made by user*/
    converseLib.validationFailed(48); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Terminate function*/
    converseLib.clearScreen();
     /* Clear screen before display*/
  end
  ;
  ;
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "UPDATE TABLE ROW";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FB0BM010.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFBUY   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VSELHD01"; /* Table view name*/
  TA1REC.TA1TBLKE = FB1REC.FB1KEY; /* Table key*/
  ;
  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/
  ;
  exit stack; /* Exit to display map*/
  ;
  ;
  ;
end // end FB0B620

// Submit job to internal reader
Function FB0B630()
   /* ------------------------------------------------------------*/
   /* Submit the JCL and parameters for batch execution.*/
   /* ------------------------------------------------------------*/
  ;
  TA6REC.TA6SUBSW = "Y"; /* Tailor and submit JCL*/
  ;
  while (TA6REC.TA6RTNCD < "0") /* Until subroutine completed*/
    XPTA0P(); /* Print Request Subroutine*/
  end
  ;
   /* ------------------------------------------------------------*/
   /* If a successful, return to the previous process.*/
   /* ------------------------------------------------------------*/
  ;
  if (sysVar.errorCode == "00000000" /* Call successful*/
   && TA6REC.TA6RTNCD == "0")        /* and normal return*/
    ;
    return; /* Return to previous process*/
    ;
  end
  ;
   /* ------------------------------------------------------------*/
   /* If user cancelled request, indicate user cancelled.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/
  ;
  if (sysVar.errorCode == "00000000" /* Call successful*/
   && TA6REC.TA6RTNCD == "1")        /* and user cancelled request*/
    ;
    converseLib.validationFailed(86); /* Indicate user cancelled*/
    FB0BM010.XXXMODID = "630"; /* module identification*/
  else
    converseLib.validationFailed(01); /* Indicate system error*/
    XXXMODID = "630"; /* module identification*/
    ;
  end
  ;
  exit stack; /* Exit to display map*/
  ;
  ;
end // end FB0B630

// load sum code array
Function FB0BS09()
  set YSMREC empty; /* initialize record*/
  YSMREC.YSMTBLPF = "XWH";
  YSMREC.YSMSYSPF = "FB";
  YSMREC.YSMSUMID = 1;
  YSMREC.YSMSUMCD = "01";
  YSMSRCVL = "****";
  FB0BS10(); /* declare cursor*/
  FB0BW00.FB0BWIX1 = 1; /* first row*/
  ;
  while (FB0BW00.FB0BWIX1 <= +10
   && SQLCA.VAGen_SQLCODE != 100)
    FB0BS11(); /* fetch row*/
    FB0BW00.FB0BWIX1 = FB0BW00.FB0BWIX1 + 1; /* next row*/
  end
  ;
  if (FB0BW00.FB0BWIX1 <= +10)
    FB0BS12(); /* close cursor*/
    return; /* return to calling process*/
  end
  ;
   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/
  ;
  ;
  if (FB0BW00.FB0BWIX1 > +10)
    FB0BM010.XXXMODID = "S25"; /* Module identification*/
    converseLib.validationFailed(10); /* Indicate system error*/
    ;
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    TA1REC.TA1TYPE = "APPL"; /* Type of error*/
    TA1REC.TA1LOC = "MORE THAN 10 WAREHOUSES SUMCD01 ";
    TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
    TA1REC.TA1PGMNO = FB0BM010.XXXMODID; /* Program number*/
    TA1REC.TA1MAPAP = COMMAREA.CACURRAP; /* Map application*/
    TA1REC.TA1MAPNO = "M010"; /* Map number*/
  /* MOVE 'N' TO FB0BW00.FB0BWRDS;    /* dont request data*/
    ;
    call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/
    ;
    exit stack; /* Exit to display map*/
  end
  ;
end // end FB0BS09

// declare cursor DCORP.VSUMCD01
Function FB0BS10()
   /* ------------------------------------------------------------*/
   /* Select the set to display from the table.*/
   /* ------------------------------------------------------------*/
  ;
  try
    call "IO2640" ("S1", SQLCA, YSMREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select set*/
  ;
   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/
  ;
  if (sysVar.errorCode == "00000000") /* Call successful*/
    ;
    if (SQLCA.VAGen_SQLCODE == 0) /* Normal return code*/
      return; /* Return to previous process*/
    end
    ;
  end
  ;
   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/
  ;
  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL Commarea*/
  ;
  FB0BM010.XXXMODID = "S10"; /* Module identification*/
  ;
  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/
    ;
    converseLib.validationFailed(47); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
    ;
  else
    ;
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    ;
    converseLib.clearScreen();
     /* Clear screen before display*/
    ;
  end
  ;
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "SELECT SET          ";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FB0BM010.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DCORP   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VSUMCD01"; /* Table view name*/
  TA1REC.TA1TBLKE = YSMGRP; /* Table key*/
  ;
  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/
  /* MOVE 'N' TO FB0BW00.FB0BWRDS;    /* dont request data*/
  exit stack; /* Exit to display map*/
  ;
  ;
end // end FB0BS10

// fetch row DCORP.VSUMCD01
Function FB0BS11()
   /* ------------------------------------------------------------*/
   /* Select the row to display from the table.*/
   /* ------------------------------------------------------------*/
  ;
  try
    call "IO2640" ("N1", SQLCA, YSMREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/
  ;
   /* ------------------------------------------------------------*/
   /* If successful or not found,*/
   /* ------------------------------------------------------------*/
  ;
  if (sysVar.errorCode == "00000000") /* Call successful*/
    ;
    if (SQLCA.VAGen_SQLCODE == 0) /* Normal return code*/
      FB0BW01.XWHCD[FB0BWIX1] = YSMREC.YSMSRCVL;
      return; /* Return to previous process*/
    end
    ;
    if (SQLCA.VAGen_SQLCODE == 100) /* row not found*/
      return; /* Return to previous process*/
    end
    ;
  end
  ;
   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/
  ;
  if (sysVar.errorCode != "00000000" /* bad return*/
   || SQLCA.VAGen_SQLCODE != 0)      /* not normal sql code*/
    TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
    TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL Commarea*/
    ;
    FB0BM010.XXXMODID = "S11"; /* Module identification*/
    ;
    if (sysVar.errorCode == "00000000" /* Call successful*/
     && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/
      ;
      converseLib.validationFailed(11); /* Indicate not available*/
      TA1REC.TA1FUNC = "POST"; /* Termination function*/
      ;
    else
      ;
      converseLib.validationFailed(10); /* Indicate system error*/
      TA1REC.TA1FUNC = "RETN"; /* Termination function*/
      ;
      converseLib.clearScreen();
       /* Clear screen before display*/
      ;
    end
    ;
    TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
    TA1REC.TA1LOC = "SELECT NEXT ROW     ";
    TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
    TA1REC.TA1PGMNO = FB0BM010.XXXMODID; /* Program number*/
    TA1REC.TA1DBASE = "DCORP   "; /* Data base name*/
    TA1REC.TA1TBLVU = "VSUMCD01"; /* Table view name*/
    TA1REC.TA1TBLKE = YSMGRP; /* Table key*/
    ;
    call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/
    ;
  /* MOVE 'N' TO FB0BW00.FB0TWRDS;  /* don't request data*/
    exit stack; /* Exit to display map*/
  end
  ;
  ;
end // end FB0BS11

// close cursor DCORP.VSUMCD01
Function FB0BS12()
   /* ------------------------------------------------------------*/
   /* Close the cursor*/
   /* ------------------------------------------------------------*/
  ;
  try
    call "IO2640" ("C1", SQLCA, YSMREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select set*/
  ;
   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/
  ;
  if (sysVar.errorCode == "00000000") /* Call successful*/
    ;
    if (SQLCA.VAGen_SQLCODE == 0) /* Normal return code*/
      return; /* Return to previous process*/
    end
    ;
  end
  ;
   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/
  ;
  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL Commarea*/
  ;
  FB0BM010.XXXMODID = "S12"; /* Module identification*/
  ;
  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/
    ;
    converseLib.validationFailed(47); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
    ;
  else
    ;
    converseLib.validationFailed(10); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    ;
    converseLib.clearScreen();
     /* Clear screen before display*/
    ;
  end
  ;
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "CLOSE SUMCD CURSOR  ";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FB0BM010.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DCORP   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VSUMCD01"; /* Table view name*/
  TA1REC.TA1TBLKE = YSMGRP; /* Table key*/
  ;
  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/
  /* MOVE 'N' TO FB0BW00.FB0TWRDS;    /* dont request data*/
  exit stack; /* Exit to display map*/
  ;
  ;
end // end FB0BS12

//*** RECORD=FB0BW00 ****
// ---------------------------
// Application Working Storage
// ---------------------------
// ***********************
Record FB0BW00 type basicRecord
  5 * char(120) ; 
    10 FB0BWDSW FB0BWDSW ; 
    10 FB0BWDCF FB0BWDCF ; 
    10 FB0BWPRF FB0BWPRF ; 
    10 FB0BWRMF FB0BWRMF ; 
    10 XGPCD XGPCD ; 
    10 XWHCD XWHCD ; 
    10 XWHABRV XWHABRV ; 
    10 FB0BWFDT FB0BWFDT ; 
      15 FB0BWFCT FB0BWFCT ; 
      15 FB0BWFYY FB0BWFYY ; 
      15 FB0BWFMM FB0BWFMM ; 
      15 FB0BWFDD FB0BWFDD ; 
    10 FB0BWDTC FB0BWDTC ; 
    10 FB0BWOTC FB0BWOTC ; 
    10 FB0BWFRD FB0BWFRD ; 
    10 FB0BWIXM FB0BWIXM ; 
    10 FB0BWIX1 FB0BWIX1 ; 
    10 FB0BWIX2 FB0BWIX2 ; 
    10 FB0BWIX3 FB0BWIX3 ; 
    10 FB0BWIXT FB0BWIXT ; 
      15 FB1DUMNB FB1DUMNB ; 
    10 FB0BWMSG FB0BWMSG ; 
      15 FB0BW1LT FB0BW1LT ; 
      15 FB0BW2LT FB0BW2LT ; 
      15 FB0BWDUM FB0BWDUM ; 
    10 FB0BWSQN FB0BWSQN ; 
end // end FB0BW00

//*** RECORD=FB0BW01 ****
// ----------------------------------------
// Map 010 display storage for heading data
// ----------------------------------------
// ***********************
Record FB0BW01 type basicRecord
  10 FB0BWFRM FB0BWFRM [2] ; 
  10 FB0BWFRY FB0BWFRY [2] ; 
  10 FB0BWTOM FB0BWTOM [2] ; 
  10 FB0BWTOY FB0BWTOY [2] ; 
  10 YSMXOT YSMXOT [6] ; 
  10 FB1CMNT FB1CMNT ; 
  10 FB1INCDS FB1INCDS ; 
  10 XPCKEY XPCKEY ; 
    15 XPCCD XPCCD ; 
    15 XGPCD XGPCD ; 
  10 XPCSDESC XPCSDESC ; 
  10 XSUCD XSUCD ; 
  10 XSUABRV XSUABRV ; 
  10 YPPCD YPPCD ; 
  10 YPPDESC YPPDESC ; 
  10 XPRCD XPRCD ; 
  10 XPRABRV XPRABRV ; 
  10 XDVCD XDVCD ; 
  10 XDVDESC XDVDESC ; 
  10 XWHCD XWHCD [11] ; 
  10 XWHABRV XWHABRV [11] ; 
end // end FB0BW01

//*** RECORD=FB0BW02 ****
// ----------------------------
// JCL parm storage.
// ----------------------------
// ***********************
Record FB0BW02 type basicRecord
  5 FB0BWJP1 FB0BWJP1 ; 
    10 FB0BW1WH FB0BW1WH [4] ; 
    10 * char(72) ; 
  5 FB0BWJP2 FB0BWJP2 ; 
    10 FB0BW2WH FB0BW2WH [4] ; 
    10 * char(72) ; 
  5 FB0BWJP3 FB0BWJP3 ; 
    10 FB0BW3WH FB0BW3WH [4] ; 
    10 * char(72) ; 
  5 FB0BWJP4 FB0BWJP4 ; 
    10 FB0BW4WH FB0BW4WH [4] ; 
    10 * char(72) ; 
  5 FB0BWJP5 FB0BWJP5 ; 
    10 FB0BW5WH FB0BW5WH [4] ; 
    10 * char(72) ; 
  5 FB0BWJP6 FB0BWJP6 ; 
    10 FB0BW6WH FB0BW6WH [4] ; 
    10 * char(72) ; 
  5 FB0BWJP7 FB0BWJP7 ; 
    10 FB0BW7WH FB0BW7WH [4] ; 
    10 * char(72) ; 
  5 FB0BWJP8 FB0BWJP8 ; 
    10 FB0BW8WH FB0BW8WH [4] ; 
    10 * char(72) ; 
  5 FB0BWJP9 FB0BWJP9 ; 
    10 FB0BW9WH FB0BW9WH [4] ; 
    10 * char(72) ; 
  5 FB0BWJP10 FB0BWJP10 ; 
    10 FB0BW10WH FB0BW10WH [4] ; 
    10 * char(72) ; 
end // end FB0BW02

//*** RECORD=FB0BW03 ****
// ----------------------------
// JCL parm storage.
// ----------------------------
// ***********************
Record FB0BW03 type basicRecord
  5 FB0BWWG FB0BWWG ; 
    10 FB0BWW1 FB0BWW1 ; 
    10 FB0BWW2 FB0BWW2 ; 
    10 FB0BWW3 FB0BWW3 ; 
    10 FB0BWW4 FB0BWW4 ; 
    10 FB0BWW5 FB0BWW5 ; 
    10 * char(70) ; 
  5 FB0BWCMT FB0BWCMT ; 
    10 FB0BWAS FB0BWAS ; 
    10 FB0BWG FB0BWG ; 
end // end FB0BW03

// Warehouse 10 entered data
DataItem FB0BW10WH char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Job submit literal 1
DataItem FB0BW1LT char(28)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Warehouse 1 entered data
DataItem FB0BW1WH char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Job submit literal 2
DataItem FB0BW2LT char(30)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Warehouse 2 entered data
DataItem FB0BW2WH char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Warehouse 3 entered data
DataItem FB0BW3WH char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Warehouse 4 entered data
DataItem FB0BW4WH char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Warehouse 5 entered data
DataItem FB0BW5WH char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Warehouse 6 entered data
DataItem FB0BW6WH char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Warehouse 7 entered data
DataItem FB0BW7WH char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Warehouse 8 entered data
DataItem FB0BW8WH char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Warehouse 9 entered data
DataItem FB0BW9WH char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// contains '//*'
DataItem FB0BWAS char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Jcl comment line
DataItem FB0BWCMT char(80)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Vseldt01 cursor flag
DataItem FB0BWDCF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Display data flag
DataItem FB0BWDSW char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Date counter
DataItem FB0BWDTC smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Display dummy nbr
DataItem FB0BWDUM num(6)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Map reformat century
DataItem FB0BWFCT num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Map reformat day
DataItem FB0BWFDD num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Map reformat date field
DataItem FB0BWFDT num(8)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Map reformat month
DataItem FB0BWFMM num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Save fb5rec from date
DataItem FB0BWFRD int {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// From need date
DataItem FB0BWFRM char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// From need year
DataItem FB0BWFRY char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Map reformat year
DataItem FB0BWFYY num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// group level parm
DataItem FB0BWG char(77)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// General index 1
DataItem FB0BWIX1 smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// General index 2
DataItem FB0BWIX2 smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// General index 2
DataItem FB0BWIX3 smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Map index
DataItem FB0BWIXM smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Table index
DataItem FB0BWIXT smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Parm JCL statement one
DataItem FB0BWJP1 char(80)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Parm JCL statement three
DataItem FB0BWJP10 char(80)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Parm JCL statement two
DataItem FB0BWJP2 char(80)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Parm JCL statement three
DataItem FB0BWJP3 char(80)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Parm JCL statement one
DataItem FB0BWJP4 char(80)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Parm JCL statement two
DataItem FB0BWJP5 char(80)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Parm JCL statement three
DataItem FB0BWJP6 char(80)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Parm JCL statement one
DataItem FB0BWJP7 char(80)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Parm JCL statement two
DataItem FB0BWJP8 char(80)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Parm JCL statement three
DataItem FB0BWJP9 char(80)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Job submit message
DataItem FB0BWMSG char(64)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Order type group counter
DataItem FB0BWOTC num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Processing flag
DataItem FB0BWPRF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Region match flag
DataItem FB0BWRMF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Numeric curve number
DataItem FB0BWSQN num(10)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// To need month
DataItem FB0BWTOM char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// To need year
DataItem FB0BWTOY char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Recieving whs 1
DataItem FB0BWW1 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Sending whs 1
DataItem FB0BWW2 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Sending whs 2
DataItem FB0BWW3 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Sending whs 3
DataItem FB0BWW4 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Sending whs 4
DataItem FB0BWW5 char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Parm JCL statement one
DataItem FB0BWWG char(80)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

