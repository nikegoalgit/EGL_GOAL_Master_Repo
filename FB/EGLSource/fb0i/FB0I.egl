package fb0i;

import corpcom2.XX0XW01;
import corpcom2.XX0XW02;
import corpcom2.YSMREC;
import corpcom3.XPFB001;
import corpcom4.XSFBS01;
import corpcom4.XSPG202;
import corpcom4.XX0XS01;
import corpcom5.COMMAREA;
import corpcom6.SQLCA;
import corpx1.XDMCD;
import corpx1.XGPCD;
import corpx1.XWHTBL;
import corpx2.XPGCD;
import corpx2.XQACD;
import corpx2.XSACD;
import corpx2.XUMCD;
import corpx2.XWHCD;
import corpz3.ZZZCHGCT;
import corpz3.ZZZCHGDT;
import corpz3.ZZZCHGTM;
import corpz3.ZZZSDT;
import fb.common.FB1INSEQ;
import fb.common.FB1REC;
import fb.common.FB4CRVNB;
import fb.common.FB4DMQTY;
import fb.common.FB4GROUP;
import fb.common.FB4KEY;
import fb.common.FB4QTYLK;
import fb.common.FB4REC;
import fb.common.FB4RGPCT;
import fb.common.FB4STDFL;
import fb.common.FB4SZPCT;
import fb.common.FB5FRMDT;
import fb.common.FB5REC;
import fb.common.FB5TODT;
import fb.common.FB6REC;
import fb.common.FBWREC;
import ff.common.FF00ENU;
import pc.common.PC2INSEG;
import pg.common.PG2REC;
import sy.common.SY1STNBR;
import sy.common.SY2CLRID;
import ta.common.TA1REC;
import ta.common.TAEREC;
//*** PROGRAM=FB0I ****
// This application allows the user to copy a size curve from
// one region to another. The 'copy from' warehouse is keyed
// in on the left of the screen and the 'copy to' warehouses
// are displayed on the right.
// 
// If the curve already exists, a message will be displayed and
// the user may update by pressing pf9, or change the selection
// code.
// 
// The user may exit to any allowed application, via Fast Path
// or PF key.
// 
// 
// -------  --------  ------  ---------------------------------
// CONTROL    DATE     NAME   DESCRIPTION OF CHANGE
// -------  --------  ------  ---------------------------------
//          03/30/89  cnewma  New application.
// fb9995   10/02/93  pmainw  fix commarea problem - cspv4.
// FBnnnn   12/23/96  sverma  Remove hardcoded warehouses and
//                            get them from DCORP.VSUMCD01 upto
//                            max of 10 and add the validation
//                            than no more than 3 diff curves
//                            for a given seq. no. are created.
//                            in case of dummy or in case of
//                            assigned curve where Style+Color
//                            +Dim is the key.
// *********************
Program FB0I type textUIProgram //VAGen Info - main text program
  {
  includeReferencedFunctions = yes, allowUnqualifiedItemReferences = yes, 
  throwNrfEofExceptions = yes, handleHardIOErrors = no, V60ExceptionCompatibility = yes, 
  I4GLItemsNullable = no, textLiteralDefaultIsString = no, localSQLScope = yes, 
  msgTablePrefix = "FF00", inputRecord = COMMAREA, segmented = yes
  }

  // Data Declarations
  COMMAREA COMMAREA ; // record
  FB0IW00 FB0IW00; // record
  FB0IW01 FB0IW01; // record
  FB0IW02 FB0IW02; // record
  FB0IW03 FB0IW03; // record
  FB0IW04 FB0IW04; // record
  FB1REC FB1REC; // record
  FB4REC FB4REC; // record
  FB5REC FB5REC; // record
  FB6REC FB6REC; // record
  FBWREC FBWREC; // record
  PG2REC PG2REC; // record
  SQLCA SQLCA; // record
  TA1REC TA1REC; // record
  TAEREC TAEREC; // record
  XX0XW01 XX0XW01; // record
  XX0XW02 XX0XW02; // record
  YSMREC YSMREC; // record

  // VAGen Info - items needed for migration
  VAGen_EZESYS char(8);
  VAGen_EZEREPLY num(1);
  VAGen_EZE_WAIT_TIME bin(9,2);
  VAGen_EZE_ITEMLEN int;

  // Use Declarations
  use XWHTBL {deleteAfterUse = yes}; // table
  use FB0IM.FB0IM010 // form
   {
    pfKeyEquate = no
  };

  function main()
    // VAGen Info - initialization needed for migration
    VAGen_EZESYS = VGLib.getVAGSysType();
    XPFB001: XPFB001();
     /* ------------------------------------------------------------*/
     /* Initialize working storage and display storage areas.*/
     /* ------------------------------------------------------------*/
    ;
    set FB0IM010 initial; /* M010 input/output*/
    set FB0IW00 empty; /* Working storage*/
    set FB0IW01 empty; /* M010 display storage*/
    set FB0IW02 empty; /* fb4rec working storage*/
    set FB0IW03 empty; /* fb4rec working storage*/
    set FB0IW04 empty; /* fb4rec working storage*/
    set SQLCA empty; /* SQL communication area*/
    set TAEREC empty; /* Error diagnosis information*/
    set TA1REC empty; /* Error diagnosis parameters*/
    set XX0XW01 empty; /* Date/time subroutine parameters*/
    FB0IW00.FB0INDX1 = 10; /* store the max array value for this*/
                                     /* map*/
    FB0IW00.FB0INDX1 = 10; /* store the max array value for this*/
                                     /* map*/
     /* for select codes*/
    FB0IW00.FB0INDX2 = 11; /* store the max array value for this*/
                                     /* map*/
     /* for warehouse codes. Note in the map the WH code is a value one*/
     /* more than select code.this move is done to avoid hardcoding of*/
     /* array in the code.*/
     /* ------------------------------------------------------------*/
     /* Check input data to determine if requested curve is a*/
     /* product curve or a user curve. If no product key is avail-*/
     /* able and the curve is not a user curve, display an error*/
     /* message.*/
     /* ------------------------------------------------------------*/
    ;
    FB0IW00.XGPCD = COMMAREA.XGPCD; /* GPC code*/
    if (FBWREC.XGPCD != "  "    /* gpc code*/
     && FBWREC.SY1STNBR != "  " /* style number*/
     && FBWREC.SY2CLRID != "  " /* color id*/
     && FBWREC.XDMCD != "  "    /* dimension code*/
     && FBWREC.XQACD != "  "    /* quality code*/
     && FBWREC.PC2INSEG != "  " /* spec difference code*/
     && FBWREC.XSACD != "  "    /* shade code*/
     && FBWREC.XPGCD != "  "    /* packaging type code*/
     && FBWREC.XUMCD != "  "    /* unit of measure code*/
     && FBWREC.FB1INSEQ != 0)   /* fb internal seq nbr not 0*/
      FB0IW00.FB0IWSPR = "P"; /* display product/user sw*/
    else
      if (FBWREC.FB1INSEQ != 0) /* fb internal seq nbr not 0*/
        FB0IW00.FB0IWSDR = "Y"; /* data requested switch*/
        FB0IW00.FB0IWSPR = "U"; /* display product/user sw*/
      else
        FB0IW00.FB0IWSDR = "N"; /* data requested switch*/
        set FB0IM010.SY1STNBR bold; /* highlight*/
        converseLib.validationFailed(42); /* no product data*/
      end
    end
    ;
    FB0IW00.FB1INSEQ = FBWREC.FB1INSEQ; /* save sequence number*/
    ;
     /* ------------------------------------------------------------*/
     /* Flow to converse the main process used to display a map.*/
     /* ------------------------------------------------------------*/
    ;
    goto FB0I001; /* Converse the main process*/
    ;
    ;
    FB0I001: FB0I001();
     /* ------------------------------------------------------------*/
     /* Flow to converse the main process used to display a map.*/
     /* ------------------------------------------------------------*/
    ;
    goto FB0I001; /* Converse the main process*/
    ;
    ;
  end // end main
end // end FB0I

// Inquire/maintain a table row
Function FB0I001()
   /* ------------------------------------------------------------*/
   /* This is the main process used to display a map.  Processing*/
   /* always returns to the top of this process and falls through*/
   /* subordinate processes until an error is found or a valid*/
   /* request is processed.  Processing sequence is as follows:*/
  ;
   /* 1) Obtain the data to display.*/
   /* 2) Format the map output area and display the map.*/
   /* 3) Check the attention identifier used to respond.*/
   /* 4) Reset highlighted fields to normal intensity.*/
   /* 5) Verify the data that was entered.*/
   /* 6) Process a valid input request.*/
  ;
   /* In all subordinate processes, "EZEFLO" is used to exit to*/
   /* redisplay the map when an error is found.  This is done to*/
   /* minimize the coding effort required to skip subsequent*/
   /* processing under error conditions.*/
   /* ------------------------------------------------------------*/
  ;
  FB0I100(); /* Obtain the data to display*/
  ;
  FB0I200(); /* Format and display the map*/
  ;
  FB0I300(); /* Check attention identifier*/
  ;
  FB0I400(); /* Reset fields to normal intensity*/
  ;
  FB0I500(); /* Verify the entered data*/
  ;
  FB0I600(); /* Process valid input request*/
  ;
  ;
end // end FB0I001

// Obtain the data to display
Function FB0I100()
   /* ------------------------------------------------------------*/
   /* If data was not requested or an error was found, return to*/
   /* the previous process.*/
   /* ------------------------------------------------------------*/
  ;
  if (FB0IW00.FB0IWSDR == "N" /* Data was not requested*/
   || converseVar.validationMsgNum != 0) /* or an error was found*/
    return; /* Return to previous process*/
  end
  ;
   /* ------------------------------------------------------------*/
   /* get selection criteria*/
   /* ------------------------------------------------------------*/
  ;
  FB0I110(); /* get selection criteria*/
  ;
   /* ------------------------------------------------------------*/
   /* get curve data*/
   /* ------------------------------------------------------------*/
  ;
  FB0I120(); /* get curve data*/
  ;
   /* ------------------------------------------------------------*/
   /* If a product passed in commarea*/
   /* get product descriptions*/
   /* ------------------------------------------------------------*/
  ;
  if (FB0IW00.FB0IWSPR == "P") /* product passed*/
    FB0I130(); /* get product descriptions*/
  end
  ;
   /* ------------------------------------------------------------*/
   /* move 'to' warehouses to map*/
   /* ------------------------------------------------------------*/
  ;
  FB0I140(); /* move 'to' warehouses to map*/
  ;
  ;
end // end FB0I100

// get selection criteria
Function FB0I110()
   /* ------------------------------------------------------------*/
   /* move style data to map*/
   /* ------------------------------------------------------------*/
  ;
  FB0IM010.SY1STNBR = FBWREC.SY1STNBR; /* style number*/
  FB0IM010.SY2CLRID = FBWREC.SY2CLRID; /* color id*/
  FB0IM010.XDMCD = FBWREC.XDMCD; /* dimension code*/
  ;
   /* ------------------------------------------------------------*/
   /* obtain header data*/
   /* ------------------------------------------------------------*/
  ;
  FB0I111(); /* Obtain header data*/
  ;
   /* ------------------------------------------------------------*/
   /* obtain need dates*/
   /* ------------------------------------------------------------*/
  ;
   /* ------------------------------------------------------------*/
   /* Select and set cursor from table  - vseldt01*/
   /* ------------------------------------------------------------*/
  ;
  FB0I112(); /* Select and set cursor*/
  ;
   /* ------------------------------------------------------------*/
   /* Get the next row to display from the table - vseldt01*/
   /* ------------------------------------------------------------*/
  ;
  while (FB0IW00.FB0IWDCF != "Y")
    FB0I113(); /* Get next table row*/
  end
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Close the cursor from table   - vseldt01*/
   /* ------------------------------------------------------------*/
  ;
  FB0I114(); /* close cursor*/
  ;
  ;
end // end FB0I110

// obtain header data
Function FB0I111()
   /* ------------------------------------------------------------*/
   /* Initialize row storage area*/
   /* Format record key*/
   /* ------------------------------------------------------------*/
  ;
  set FB1REC empty; /* Initialize row storage*/
  ;
  FB1REC.FB1INSEQ = FB0IW00.FB1INSEQ; /* initialize seq nbr*/
  ;
   /* ------------------------------------------------------------*/
   /* Select requested row from table - vselhd01*/
   /* ------------------------------------------------------------*/
  ;
  try
    call "IO3030" ("S ", SQLCA, FB1REC) {isNoRefresh = yes, isExternal = yes};
  end /* select table row*/
  ;
   /* ------------------------------------------------------------*/
   /* If sucessful, save the data in display storage and return*/
   /* to the previous process.*/
   /* ------------------------------------------------------------*/
  ;
  if (sysVar.errorCode == "00000000") /* call successful*/
    ;
    if (SQLCA.VAGen_SQLCODE == 0) /* normal return code*/
      ;
      FB0IM010.FB1CMNT = FB1REC.FB1CMNT; /* comments*/
      if (FB0IW00.FB0IWSPR == "U")
        FB0IM010.FB0IMCDS = "DUMMY NBR:"; /* dummy number desc*/
        FB0IM010.FB4CRVNB = FB1REC.FB1DUMNB; /* dummy number*/
      else
        FB0IM010.FB0IMCDS = "CURVE NBR:"; /* curve number desc*/
      end
      ;
      return;
    end
  end
  ;
   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* If data not found, abort the application; otherwise, indi-*/
   /* cate that a system error has occurred.*/
   /* ------------------------------------------------------------*/
  ;
  ;
  if (sysVar.errorCode == "00000000") /* call successful*/
    if (SQLCA.VAGen_SQLCODE == 100) /* row not found*/
      converseLib.validationFailed(11); /* 'RECORD NOT ON DATABASE'*/
      ;
    else
      ;
      if (SQLCA.VAGen_SQLCODE == -911) /* resource not available*/
        ;
        converseLib.validationFailed(19); /* 'RESOURCES UNAVAILABLE'*/
        FB0IW00.FB0IWRNA = "Y"; /* set switch*/
        TA1REC.TA1FUNC = "POST"; /* termination function*/
        ;
      else
        TA1REC.TA1FUNC = "RETN"; /* termination function*/
        converseLib.validationFailed(01); /* 'ERROR - PLEASE NOTIFY PROGRAMMING'*/
      end
    end
  end
  ;
  TA1REC.TA1MAP = sysVar.errorCode; /* csp return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* sql commarea*/
  FB0IM010.XXXMODID = "111"; /* module identification*/
  converseLib.validationFailed(01); /* 'error - please nofity programming'*/
  TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  converseLib.clearScreen();
   /* Clear screen before display*/
  TA1REC.TA1TYPE = "DB2 "; /* type of error*/
  TA1REC.TA1LOC = "GET VSELHD01 ROW ";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* program application*/
  TA1REC.TA1PGMNO = FB0IM010.XXXMODID; /* program number*/
  TA1REC.TA1DBASE = "DFBUY   "; /* data base name*/
  TA1REC.TA1TBLVU = "VSELHD01"; /* table view name*/
  TA1REC.TA1TBLKE = FB1REC.FB1KEY; /* table key*/
  ;
  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* error diagnosis routine*/
  ;
  exit stack; /* exit to display map*/
  ;
  ;
end // end FB0I111

// select set date table cursor
Function FB0I112()
   /* ------------------------------------------------------------*/
   /* Initialize the storage areas and indicators to be used*/
   /* ------------------------------------------------------------*/
  ;
  set FB5REC empty; /* clear row storage area*/
  FB0IW00.FB0IWDCF = "N"; /* End of vseldt01 flag*/
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Format the key with saved sequence number from vcurve01 or*/
   /* vselhd01.*/
   /* ------------------------------------------------------------*/
  ;
  FB5REC.FB1INSEQ = FB0IW00.FB1INSEQ;
  ;
   /* ------------------------------------------------------------*/
   /* Select the requested set of rows from the table vseldt01*/
   /* ------------------------------------------------------------*/
  ;
  try
    call "IO3040" ("S1", SQLCA, FB5REC) {isNoRefresh = yes, isExternal = yes};
  end /* Select table set*/
  ;
   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/
  ;
  if (sysVar.errorCode == "00000000") /* Call successful*/
    if (SQLCA.VAGen_SQLCODE == 0) /* and normal return code*/
      ;
      return; /* Return to previous process*/
    end
    ;
  end
  ;
   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/
  ;
  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/
  ;
  FB0IM010.XXXMODID = "112"; /* Module identification*/
  ;
  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/
    ;
    FB0IW00.FB0IWSDR = "Y"; /* set switch*/
    FB0IW00.FB0IWRNA = "Y"; /* set switch*/
    converseLib.validationFailed(19); /* 'Resources unavailable'*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
    ;
  else
    ;
    converseLib.validationFailed(01); /* 'Error - Please nofity programming'*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    ;
    converseLib.clearScreen();
     /* Clear screen before display*/
    ;
  end
  ;
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "OPEN VSELDT01 CURSOR";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FB0IM010.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFBUY   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VSELDT01"; /* Table view name*/
  TA1REC.TA1TBLKE = FB5REC.FB5KEY; /* Table key*/
  ;
  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/
  ;
  exit stack; /* Exit to display map*/
  ;
  ;
end // end FB0I112

// get next row date table
Function FB0I113()
   /* ------------------------------------------------------------*/
   /* Fetch the next row to display from the table.*/
   /* ------------------------------------------------------------*/
  ;
  try
    call "IO3040" ("N1", SQLCA, FB5REC) {isNoRefresh = yes, isExternal = yes};
  end /* Fetch next row*/
  ;
   /* ------------------------------------------------------------*/
   /* If successful, return to calling process.*/
   /* ------------------------------------------------------------*/
  ;
  if (sysVar.errorCode == "00000000") /* Call successful*/
    ;
    if (SQLCA.VAGen_SQLCODE == 0) /* Normal return code*/
      ;
      FB0IW01.FB0IWFDT = FB5REC.FB5FRMDT; /* save from date*/
      FB0IW01.FB0IWTDT = FB5REC.FB5TODT; /* save to date*/
      FB0IM010.FB0IMMM1 = FB0IW01.FB0IWFMM; /* from month*/
      FB0IM010.FB0IMYY1 = FB0IW01.FB0IWFYY; /* from year*/
      FB0IM010.FB0IMMM2 = FB0IW01.FB0IWTMM; /* to month*/
      FB0IM010.FB0IMYY2 = FB0IW01.FB0IWTYY; /* to year*/
    else
      if (SQLCA.VAGen_SQLCODE == 100) /* row not found*/
        FB0IW00.FB0IWDCF = "Y"; /* indicate end of cursor*/
      end
    end
    ;
    return; /* Return to previous process*/
    ;
  end
  ;
   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/
  ;
  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/
  ;
  FB0IM010.XXXMODID = "113"; /* Module identification*/
  ;
  if (sysVar.errorCode == "00000000") /* Call successful*/
    if (SQLCA.VAGen_SQLCODE == -911) /* Resource not available*/
      ;
      converseLib.validationFailed(19); /* 'resources unavailable'*/
      FB0IW00.FB0IWSDR = "Y"; /* set switch*/
      FB0IW00.FB0IWRNA = "Y"; /* set switch*/
      TA1REC.TA1FUNC = "POST"; /* Termination function*/
      ;
    else
      ;
      converseLib.validationFailed(01); /* 'error - please nofity programming'*/
      TA1REC.TA1FUNC = "RETN"; /* Termination function*/
      ;
      converseLib.clearScreen();
       /* Clear screen before display*/
      ;
    end
  end
  ;
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "FETCH NEXT TABLE ROW";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FB0IM010.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFBUY   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VSELDT01"; /* Table view name*/
  TA1REC.TA1TBLKE = FB4REC.FB4KEY; /* Table key*/
  ;
  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/
  ;
  exit stack; /* Exit to display map*/
  ;
  ;
end // end FB0I113

// close date table cursor
Function FB0I114()
   /* ------------------------------------------------------------*/
   /* Close the selected set of table rows.*/
   /* ------------------------------------------------------------*/
  ;
  try
    call "IO3040" ("C1", SQLCA, FB5REC) {isNoRefresh = yes, isExternal = yes};
  end /* Close table set*/
  ;
   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/
  ;
  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/
    ;
    return; /* Return to previous process*/
    ;
  end
  ;
   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/
  ;
  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/
  ;
  FB0IM010.XXXMODID = "114"; /* Module identification*/
  converseLib.validationFailed(01); /* 'Error - Please nofity programming'*/
  ;
  TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "CLOSE VSELDT01 TABLE ROWS";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FB0IM010.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFBUY    "; /* Data base name*/
  TA1REC.TA1TBLVU = "VSELDT01"; /* Table view name*/
  ;
  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/
  ;
  exit stack; /* Exit to display map*/
  ;
  ;
end // end FB0I114

// get curve data
Function FB0I120()
   /* ------------------------------------------------------------*/
   /* Clear row storage area*/
   /* ------------------------------------------------------------*/
  ;
  set FB4REC empty; /* clear row storage area*/
  ;
   /* ------------------------------------------------------------*/
   /* Format the product curve key*/
   /* ------------------------------------------------------------*/
  ;
  FB4REC.FB1INSEQ = FBWREC.FB1INSEQ; /* sequence number*/
  FB4REC.FB4CRVNB = FBWREC.FB4CRVNB; /* Curve number*/
  FB4REC.XGPCD = FBWREC.XGPCD; /* product group code*/
  FB4REC.SY1STNBR = FBWREC.SY1STNBR; /* style number*/
  FB4REC.SY2CLRID = FBWREC.SY2CLRID; /* color*/
  FB4REC.XDMCD = FBWREC.XDMCD; /* dimension*/
  FB4REC.XQACD = FBWREC.XQACD; /* quality code*/
  FB4REC.PC2INSEG = FBWREC.PC2INSEG; /* spec difference code*/
  FB4REC.XSACD = FBWREC.XSACD; /* shade code*/
  FB4REC.XPGCD = FBWREC.XPGCD; /* packaging type code*/
  FB4REC.XUMCD = FBWREC.XUMCD; /* unit of measure code*/
  ;
   /* ------------------------------------------------------------*/
   /* IO to select and open vcurve01*/
   /* ------------------------------------------------------------*/
  ;
  FB0I121(); /* Select set vcurve01 cursor*/
  ;
   /* ------------------------------------------------------------*/
   /* Select next vcurve01 row*/
   /* ------------------------------------------------------------*/
  ;
  FB0IW00.FB0IWIXM = 0; /* initialize index*/
  ;
  while (FB0IW00.FB0IWDCF != "Y") /* Until end vcurve01 cursor*/
    FB0I122(); /* Fetch next vcurve01 rows*/
  end
  ;
   /* ------------------------------------------------------------*/
   /* If no data to display, return a message to the user.*/
   /* Abort application.*/
   /* ------------------------------------------------------------*/
  ;
  if (FB0IW00.FB0IWIXM <= 0) /* No vcurve01 data available*/
    ;
    TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
    TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/
    FB0IM010.XXXMODID = "120"; /* Module identification*/
    converseLib.validationFailed(01); /* 'error - please nofity programming'*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    converseLib.clearScreen();
     /* Clear screen before display*/
    TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
    TA1REC.TA1LOC = "TABLE ROW NOT FOUND ";
    TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
    TA1REC.TA1PGMNO = FB0IM010.XXXMODID; /* Program number*/
    TA1REC.TA1DBASE = "DFBUY   "; /* Data base name*/
    TA1REC.TA1TBLVU = "VCURVE01"; /* Table view name*/
    TA1REC.TA1TBLKE = FB4REC.FB4KEY; /* Table key*/
    ;
    call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/
    ;
    exit stack; /* Exit to display map*/
  end
  ;
   /* ------------------------------------------------------------*/
   /* IO to close vcurve01 set*/
   /* ------------------------------------------------------------*/
  ;
  FB0I123(); /* close vcurve01 cursor*/
  ;
  ;
end // end FB0I120

// select set curve table cursor
Function FB0I121()
  FB0IW00.FB0IWDCF = "N"; /* end of vcurve01 flag*/
   /* ------------------------------------------------------------*/
   /* select set the vcurve01 cursor.*/
   /* ------------------------------------------------------------*/
  ;
  try
    call "IO3020" ("S2", SQLCA, FB4REC) {isNoRefresh = yes, isExternal = yes};
  end /* Fetch next row*/
  ;
   /* ------------------------------------------------------------*/
   /* If successful, return to calling process.*/
   /* ------------------------------------------------------------*/
  ;
  if (sysVar.errorCode == "00000000") /* Call successful*/
    ;
    if (SQLCA.VAGen_SQLCODE == 0) /* Normal return code*/
      FB0IWIXM = 0;
      ;
      return; /* Return to previous process*/
      ;
    end
  end
  ;
   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the*/
   /* user. Otherwise, indicate a system error has occured.*/
   /* ------------------------------------------------------------*/
  ;
  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/
  ;
  FB0IM010.XXXMODID = "121"; /* Module identification*/
  ;
  if (sysVar.errorCode == "00000000" /* call sucessful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* Resource not available*/
    ;
    converseLib.validationFailed(19); /* 'resources unavailable'*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
    ;
  else
    ;
    converseLib.validationFailed(01); /* 'error - please nofity programming'*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    ;
    converseLib.clearScreen();
     /* Clear screen before display*/
    ;
  end
  ;
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "FETCH NEXT TABLE ROW";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FB0IM010.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFBUY   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCURVE01"; /* Table view name*/
  TA1REC.TA1TBLKE = FB4REC.FB4KEY; /* Table key*/
  ;
  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/
  ;
  exit stack; /* Exit to display map*/
  ;
  ;
end // end FB0I121

// get next row curve table
Function FB0I122()
   /* ------------------------------------------------------------*/
   /* The vcurve01 set is ordered descending by change date so*/
   /* the most current date will be the first row for an*/
   /* internal sequence number.  However each sequence number*/
   /* can have up to 3 rows. Consequently the sequence numbers*/
   /* must be saved in the working storage record and if a*/
   /* duplicate is obtained it is bypassed.*/
   /* ------------------------------------------------------------*/
  ;
   /* ------------------------------------------------------------*/
   /* Fetch the next row to display from the table.*/
   /* ------------------------------------------------------------*/
  ;
  try
    call "IO3020" ("N2", SQLCA, FB4REC) {isNoRefresh = yes, isExternal = yes};
  end /* Fetch next row*/
  ;
   /* ------------------------------------------------------------*/
   /* If successful, return to calling process.*/
   /* ------------------------------------------------------------*/
  ;
  if (sysVar.errorCode == "00000000") /* Call successful*/
    ;
    if (SQLCA.VAGen_SQLCODE == 0) /* Normal return code*/
      FB0IW00.FB0IWIXM = FB0IW00.FB0IWIXM + 1; /* increment index*/
      FB0IW00.FB1INSEQ = FB4REC.FB1INSEQ; /* sequence number*/
      FB0IW01.XWHCD[FB0IWIXM] = FB4REC.XWHCD; /* warehouse code*/
      FB0I124();
                                   /* move curve records to working storage*/
      if (FB0IW00.FB0IWSPR == "P")
        FB0IM010.FB4CRVNB = FB4REC.FB4CRVNB; /* curve number*/
      end
      return; /* Return to previous process*/
      ;
    end
    ;
    /* ------------------------------------------------------------*/
     /* If end of selected set, indicate end of cursor.*/
    /* ------------------------------------------------------------*/
    ;
    if (SQLCA.VAGen_SQLCODE == 100) /* End of selected set*/
      ;
      FB0IW00.FB0IWDCF = "Y"; /* Indicate vcurve01 end of cursor*/
      ;
      return; /* Return to previous process*/
      ;
    end
    ;
  end
  ;
   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/
  ;
  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/
  ;
  FB0IM010.XXXMODID = "122"; /* Module identification*/
  ;
  if (sysVar.errorCode == "00000000") /* Call successful*/
    if (SQLCA.VAGen_SQLCODE == -911) /* Resource not available*/
      ;
      converseLib.validationFailed(19); /* 'resources unavailable'*/
      TA1REC.TA1FUNC = "POST"; /* Termination function*/
      ;
    else
      ;
      converseLib.validationFailed(01); /* 'error - please nofity programming'*/
      TA1REC.TA1FUNC = "RETN"; /* Termination function*/
      ;
      converseLib.clearScreen();
       /* Clear screen before display*/
      ;
    end
  end
  ;
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "FETCH NEXT TABLE ROW";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FB0IM010.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFBUY   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCURVE01"; /* Table view name*/
  TA1REC.TA1TBLKE = FB4REC.FB4KEY; /* Table key*/
  ;
  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/
  ;
  exit stack; /* Exit to display map*/
  ;
  ;
end // end FB0I122

// close curve table cursor
Function FB0I123()
   /* ------------------------------------------------------------*/
   /* Close the selected set of table rows.*/
   /* ------------------------------------------------------------*/
  ;
  try
    call "IO3020" ("C2", SQLCA, FB4REC) {isNoRefresh = yes, isExternal = yes};
  end /* Close table set*/
  ;
   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/
  ;
  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/
    ;
    return; /* Return to previous process*/
    ;
  end
  ;
   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/
  ;
  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/
  ;
  FB0IM010.XXXMODID = "123"; /* Module identification*/
  converseLib.validationFailed(01); /* 'Error - Please nofity programming'*/
  ;
  TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "CLOSE VCURVE01 CURSOR";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FB0IM010.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFBUY    "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCURVE01"; /* Table view name*/
  ;
  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/
  ;
  exit stack; /* Exit to display map*/
  ;
  ;
end // end FB0I123

// move curve records to ws
Function FB0I124()
   /* ------------------------------------------------------------*/
   /* move curve records to working storage*/
   /* ------------------------------------------------------------*/
  ;
  if (FB0IWIXM == 1)
    FB0IW02.FB4GROUP = FB4REC.FB4GROUP;
  else
    if (FB0IWIXM == 2)
      FB0IW03.FB4GROUP = FB4REC.FB4GROUP;
    else
      if (FB0IWIXM == 3)
        FB0IW04.FB4GROUP = FB4REC.FB4GROUP;
      end
    end
  end
  FB0IW00.FB0INOFC = FB0IWIXM;
  ;
end // end FB0I124

// get product descriptions
Function FB0I130()
   /* ------------------------------------------------------------*/
   /* Obtain style and color description*/
   /* ------------------------------------------------------------*/
  ;
   /* ------------------------------------------------------------*/
   /* clear row storage area*/
   /* format key*/
   /* ------------------------------------------------------------*/
  ;
  set PG2REC empty;
  ;
  PG2REC.XGPCD = FB4REC.XGPCD; /* gpc*/
  PG2REC.SY1STNBR = FB4REC.SY1STNBR; /* style number*/
  PG2REC.SY2CLRID = FB4REC.SY2CLRID; /* color id*/
  PG2REC.XDMCD = FB4REC.XDMCD; /* dimension code*/
  ;
  XSPG202();
  ;
  if (sysVar.errorCode == "00000000") /* Call successful*/
    ;
    if (SQLCA.VAGen_SQLCODE == 0) /* Normal return code*/
      FB0IM010.SY2CLRAB = PG2REC.SY2CLRAB; /* color desc*/
      FB0IM010.SY1STYNM = PG2REC.SY1SSTNM; /* style name*/
      ;
      return; /* Return to previous process*/
      ;
    else
      if (SQLCA.VAGen_SQLCODE == 100) /* row not found*/
        FB0IM010.SY2CLRAB = "UNKNOWN "; /* color desc*/
        FB0IM010.SY1STYNM = "UNKNOWN "; /* style name*/
        return;
      end
    end
  end
  ;
  ;
end // end FB0I130

// Move 'to' warehouses to map
Function FB0I140()
  FB0IW00.FB0IWIX1 = 2;
  while (FB0IW00.FB0IWIX1 <= FB0IW00.FB0INDX2)
    set FB0IM010.XWHCD[FB0IWIX1] protect; /* set field protect*/
    FB0IW00.FB0IWIX1 = FB0IW00.FB0IWIX1 + 1;
  end
  FB0IS01(); /* declare cursor and open cursor for*/
                                   /* valid warehouses in vsumcd01*/
  FB0IWIX2 = 1;
  FB0IWIX1 = 2; /* the to field starts as index 2*/
  FB0IWIXN = 0; /* the to field starts as index 2*/
  FB0IS02(); /* fetch the cursor for all*/
                                   /* valid warehouses in vsumcd01*/
  FB0IW00.FB0IMORERECS = "Y";
  while (FB0IW00.FB0IMORERECS == "Y" && FB0IW00.FB0IWIX1 <= 11)
    if (YSMREC.XXXSTAT == "A") /* ACTIVE WAREHOUSE IN DCORP.VSUMCD01*/
      if (YSMREC.YSMSRCVL in XWHTBL.XWHCD)
                                   /* WH CODE IN INTERNAL TABLE XWHTBL*/
        if (XWHTBL.XXXSTAT[sysVar.arrayIndex] == "A")
                                   /* CHECK TO MAKE SURE THAT THE XWHTBL*/
          /* ENTRY IS ALSO ACTIVE*/
          FB0IM010.XWHCD[FB0IWIX1] = YSMREC.YSMSRCVL;
          if (YSMREC.YSMSRCVL in XWHTBL.XWHCD)
            FB0IM010.XWHABRV[FB0IWIX1] = XWHTBL.XWHABRV[sysVar.arrayIndex];
          end
          if (FB0IM010.XWHABRV[FB0IWIXM] == " ") /* description not found*/
            FB0IM010.XWHABRV[FB0IWIXM] = "UNKNOWN";
          end
        end
      end
    end
    FB0IW00.FB0IWIX2 = FB0IW00.FB0IWIX2 + 1;
    FB0IS02(); /* fetch the cursor*/
    FB0IW00.FB0IWIX1 = FB0IW00.FB0IWIX1 + 1;
  end
  FB0IW00.FB0IWIX2 = FB0INDX2 + 1; /* equals 12, as fb0indx2 = 11*/
  if (FB0IW00.FB0IWIX1 == FB0IW00.FB0IWIX2
   && FB0IW00.FB0IMORERECS == "Y")
    converseLib.validationFailed(514); /* valid warehouses exceeded 10*/
    exit stack;
  end
  FB0IS03(); /* close the cursor*/
end // end FB0I140

// Format and converse the map
Function FB0I200()
   /* ------------------------------------------------------------*/
   /* Format the current date and any FAST PATH information.*/
   /* ------------------------------------------------------------*/
  ;
  FB0IM010.XXXCURDT = VGVar.currentShortGregorianDate; /* Current date*/
  FB0IM010.CATOAP = COMMAREA.CATOAP; /* TO application*/
  FB0IM010.CAITEM = COMMAREA.CAITEM; /* Application data*/
  ;
   /* ------------------------------------------------------------*/
   /* If a message to display, indicate sound audible alarm.*/
   /* ------------------------------------------------------------*/
  ;
  if (converseVar.validationMsgNum != 0) /* Message to display*/
    set FB0IM010 alarm; /* Indicate sound alarm*/
  end
  converse FB0IM010 ;
  ;
  set FB0IM010.XWHCD[1] cursor;
   /* ------------------------------------------------------------*/
   /* Clear the message fields and save FAST PATH information.*/
   /* ------------------------------------------------------------*/
  ;
  FB0IM010.XXXMODID = " "; /* Module identification*/
  COMMAREA.CATOAP = FB0IM010.CATOAP; /* TO application*/
  COMMAREA.CAITEM = FB0IM010.CAITEM; /* Application data*/
  ;
  ;
end // end FB0I200

// Check attention identifier
Function FB0I300()
   /* ------------------------------------------------------------*/
   /* reset request for data switch*/
   /* ------------------------------------------------------------*/
  ;
  FB0IW00.FB0IWSDR = "Y"; /* reset switch*/
  ;
   /* ------------------------------------------------------------*/
   /* If FAST PATH was requested, transfer to the application.*/
   /* ------------------------------------------------------------*/
  ;
  if (COMMAREA.CATOAP > " ") /* FAST PATH was requested*/
    ;
    if (converseVar.eventKey is enter) /* ENTER was pressed*/
      ;
      XSFBS01();
      ;
    else
      ;
      converseLib.validationFailed(44); /* 'exit to application unsuccessful'*/
      FB0IM010.XXXMODID = "300"; /* module identification*/
      ;
    end
    ;
    /* ------------------------------------------------------------*/
     /* If transfer failed, display returned error message.*/
    /* ------------------------------------------------------------*/
    ;
    FB0IM010.XXXMODID = "300"; /* Module identification*/
    set FB0IM010.CATOAP cursor, bold; /* Highlight*/
    converseLib.validationFailed(44); /* 'exit to application unsuccessful'*/
    ;
    exit stack; /* Exit to display map*/
    ;
  end
  ;
   /* ------------------------------------------------------------*/
   /* If CANCEL was requested, clear the map fields and exit.*/
   /* ------------------------------------------------------------*/
  ;
  if (converseVar.eventKey is pa2) /* PA2 was pressed*/
    ;
    COMMAREA.CATOAP = "FB0I"; /* selection criteria*/
    XSFBS01();
    FB0IM010.VAGen_EZEMSG = COMMAREA.CAMSG; /* if bad transfer*/
    exit stack; /* return to show error msg*/
    ;
  end
  ;
   /* ------------------------------------------------------------*/
   /* If HELP, exit to the previous level, or exit to the Master*/
   /* Menu was requested, exit to another application.*/
   /* ------------------------------------------------------------*/
  ;
  if (converseVar.eventKey is pf1) /* PF1 was pressed*/
    COMMAREA.CAITEM = "FB0IM010"; /* Application find code*/
    COMMAREA.CATOAP = "GD01"; /* size/maint sel*/
    XSFBS01(); /* Exit to another application*/
    FB0IM010.VAGen_EZEMSG = COMMAREA.CAMSG; /* if bad transfer*/
    exit stack; /* return to show error msg*/
  else
    ;
    if (converseVar.eventKey is pf3) /* PF3 was pressed*/
      COMMAREA.CATOAP = "FB0C"; /* size/maint sel*/
      XSFBS01();
      FB0IM010.VAGen_EZEMSG = COMMAREA.CAMSG; /* if bad transfer*/
      exit stack; /* return to show error msg*/
    else
      ;
      if (converseVar.eventKey is pf5) /* PF5 was pressed*/
        COMMAREA.CATOAP = "FY0M"; /* prod menu*/
        XSFBS01();
        FB0IM010.VAGen_EZEMSG = COMMAREA.CAMSG; /* if bad transfer*/
        exit stack; /* return to show error msg*/
      end
    end
  end
  ;
  if (converseVar.eventKey is pf12) /* PF12 was pressed*/
    COMMAREA.CATOAP = "FB0K"; /* selection criteria*/
    XSFBS01();
    FB0IM010.VAGen_EZEMSG = COMMAREA.CAMSG; /* if bad transfer*/
    exit stack; /* return to show error msg*/
  end
  ;
  if (converseVar.eventKey is pf13) /* PF13 was pressed*/
    COMMAREA.CATOAP = "FB0J"; /* size percent maintenance*/
    XSFBS01();
    FB0IM010.VAGen_EZEMSG = COMMAREA.CAMSG; /* if bad transfer*/
    exit stack; /* return to show error msg*/
  end
  ;
  if (converseVar.eventKey is pf15) /* PF15 was pressed*/
    COMMAREA.CATOAP = "FB0L"; /* region percent maintenance*/
    XSFBS01();
    FB0IM010.VAGen_EZEMSG = COMMAREA.CAMSG; /* if bad transfer*/
    exit stack; /* return to show error msg*/
  end
  ;
  if (converseVar.eventKey is pf19) /* PF19 was pressed*/
    COMMAREA.CATOAP = "FB0E"; /* assign to products*/
    XSFBS01();
    FB0IM010.VAGen_EZEMSG = COMMAREA.CAMSG; /* if bad transfer*/
    exit stack; /* return to show error msg*/
  end
  ;
  if (converseVar.eventKey is pf9) /* pf9 was pressed*/
    FB0IW00.FB0IWSDR = "Y"; /* set data request switch to 'y'*/
    return;
  end
  ;
  if (converseVar.eventKey is enter) /* enter was pressed*/
    if (FB0IW00.FB0IWRNA == "Y"
    ) /* OR FB0IW00.FB0IWRNA = ' ';*/
       /* next sentence*/
    else
      FB0IW00.FB0IWSDR = "N";
                                   /* set data request switch to 'n'*/
    end
    return;
  end
  ;
  FB0IM010.XXXMODID = "300"; /* Module identification*/
  converseLib.validationFailed(3); /* 'pf key not supported'*/
  exit stack; /* return to show error msg*/
  ;
  ;
end // end FB0I300

// Reset highlighted fields
Function FB0I400()
   /* ------------------------------------------------------------*/
   /* Reset field attributes to normal intensity.*/
   /* ------------------------------------------------------------*/
  ;
  FB0IW00.FB0IWIX1 = 1; /* initialize index*/
  ;
  while (FB0IW00.FB0IWIX1 <= FB0IW00.FB0IWIXN)
    if (FB0IW00.FB0IWIX1 <= FB0IW00.FB0INDX1) /* should not exceed 10*/
      /* as it does when warehouses exceed 10*/
      set FB0IM010.FB0IMSEL[FB0IWIX1] initialAttributes; /* selection fields*/
    end
    FB0IW00.FB0IWIX1 = FB0IW00.FB0IWIX1 + 1;
  end
  FB0IW00.FB0IWIX1 = FB0IW00.FB0IWIXN + 1; /* no of fields*/
   /* to be protected beyond no of warehouses fetched, note wixn has the*/
   /* no of warehouses fetched*/
  if (FB0IW00.FB0IWIXN != 0) /* in case no warehouse fetched*/
    while (FB0IW00.FB0IWIX1 <= FB0IW00.FB0INDX1)
      set FB0IM010.FB0IMSEL[FB0IWIX1] invisible, protect;
      FB0IW00.FB0IWIX1 = FB0IW00.FB0IWIX1 + 1;
    end
  end
  ;
  set FB0IM010.XWHCD[1] initialAttributes; /* 'copy from' warehouse code*/
  set FB0IM010.CATOAP initialAttributes; /* Commarea TO application*/
  set FB0IM010.CAITEM initialAttributes; /* Commarea application data*/
end // end FB0I400

// Verify the entered data
Function FB0I500()
  /* Do not do any processing if warehouses exceed 10*/
  if (FB0IW00.FB0IMORERECS == "Y")
    converseLib.validationFailed(514); /* wh cd exceeded 10 in vsumcd01*/
    exit stack;
  end
   /* ------------------------------------------------------------*/
   /* Verify the entered data*/
   /* ------------------------------------------------------------*/
  ;
  FB0IW00.FB0IWUDR = "N"; /* reset update requested switch*/
  FB0IW00.FB0IWWEQ = "N"; /* reset warehouse equal switch*/
  ;
   /* ------------------------------------------------------------*/
   /* if a curve is to be copied, verify the curve does not*/
   /* already exist. If it does, display warning message the*/
   /* first time through and update curve the second time.*/
   /* If the curve doesn't exist, it may be added.*/
   /* ------------------------------------------------------------*/
  ;
  FB0IW00.FB0IWIX1 = FB0IW00.FB0INDX1; /* initialize index*/
   /* fb0indx1 = 10 throughout*/
  while (FB0IW00.FB0IWIX1 > 0)
    if (FB0IM010.FB0IMSEL[FB0IWIX1] == "C") /* copy to requested*/
      FB0I510(); /* verify curve existence*/
    end
    FB0IW00.FB0IWIX1 = FB0IW00.FB0IWIX1 - 1; /* decrement index*/
  end
  ;
   /* ------------------------------------------------------------*/
   /* verify selection field is either 'c' or ' '*/
   /* ------------------------------------------------------------*/
  ;
  FB0IW00.FB0IWIX1 = FB0IW00.FB0INDX1; /* initialize index*/
  ;
  while (FB0IW00.FB0IWIX1 > 0)
    if (FB0IM010.FB0IMSEL[FB0IWIX1] == "C" /* copy to requested*/
     || FB0IM010.FB0IMSEL[FB0IWIX1] == " ") /* no request*/
      /* next sentence*/
    else
      FB0IM010.XXXMODID = "500"; /* module identification*/
      converseLib.validationFailed(10); /* invalid selection code*/
      set FB0IM010.FB0IMSEL[FB0IWIX1] cursor, bold; /* set cursor*/
    end
    FB0IW00.FB0IWIX1 = FB0IW00.FB0IWIX1 - 1; /* decrement index*/
  end
  ;
   /* ------------------------------------------------------------*/
   /* obtain 'copy from' warehouse description from xwhtbl*/
   /* If description not on table, move 'unknown'*/
   /* ------------------------------------------------------------*/
  ;
  FB0IM010.XWHABRV[1] = " "; /* initialize field*/
  ;
  if (FB0IM010.XWHCD[1] in XWHTBL.XWHCD)
    FB0IM010.XWHABRV[1] = XWHTBL.XWHABRV[sysVar.arrayIndex];
  end
  ;
  if (FB0IM010.XWHABRV[1] == " ") /* description not found*/
    FB0IM010.XWHABRV[1] = "UNKNOWN";
  end
  ;
   /* ------------------------------------------------------------*/
   /* verify the selected 'copy to' warehouse is not the same*/
   /* as the 'copy from' warehouse.*/
   /* ------------------------------------------------------------*/
  ;
  FB0IW00.FB0IWIX1 = FB0IW00.FB0INDX1; /* initialize index*/
  FB0IW00.FB0IWIX2 = FB0IW00.FB0INDX2; /* initialize index*/
  ;
  while (FB0IW00.FB0IWIX1 > 0)
    if (FB0IM010.FB0IMSEL[FB0IWIX1] == "C") /* copy to requested*/
      if (FB0IM010.XWHCD[1] == FB0IM010.XWHCD[FB0IWIX2])
        FB0IM010.XXXMODID = "500"; /* module identification*/
        converseLib.validationFailed(90); /* 'a curve cannot be copied to itself'*/
        set FB0IM010.FB0IMSEL[FB0IWIX1] cursor, bold; /* set cursor*/
      else
        FB0IW00.FB0IWUDR = "Y"; /* update requested*/
      end
    end
    FB0IW00.FB0IWIX1 = FB0IW00.FB0IWIX1 - 1; /* decrement index*/
    FB0IW00.FB0IWIX2 = FB0IW00.FB0IWIX2 - 1; /* decrement index*/
  end
  ;
   /* ------------------------------------------------------------*/
   /* verify the warehouse in 'copy from' field exists*/
   /* if any selection codes = 'c'*/
   /* ------------------------------------------------------------*/
  ;
  FB0IW00.FB0IWIX1 = FB0IW00.FB0INDX1; /* initialize index*/
  ;
  while (FB0IW00.FB0IWIX1 > 0)
    if (FB0IM010.FB0IMSEL[FB0IWIX1] == "C") /* copy to requested*/
      if (FB0IM010.XWHCD[1] == " ")
        FB0IM010.XXXMODID = "500"; /* module identification*/
        converseLib.validationFailed(94); /* invalid selection code*/
        set FB0IM010.XWHCD[1] cursor, bold; /* set cursor*/
      end
    end
    FB0IW00.FB0IWIX1 = FB0IW00.FB0IWIX1 - 1; /* decrement index*/
  end
  ;
   /* ------------------------------------------------------------*/
   /* if 'copy from' warehouse code not entered, return to*/
   /* previous process*/
   /* ------------------------------------------------------------*/
  ;
  if (FB0IM010.XWHCD[1] == " ")
                                   /* no 'copy from' warehouse code entered*/
    FB0IM010.XWHABRV[1] = " "; /* reset warehouse abbreviation*/
    return;
  end
  ;
   /* ------------------------------------------------------------*/
   /* verify the warehouse in 'copy from' field, exists on*/
   /* curve table*/
   /* ------------------------------------------------------------*/
  ;
  FB0IW00.FB0IWIX1 = 1; /* initialize index*/
  ;
  while (FB0IW00.FB0IWIX1 <= FB0IW00.FB0INDX2) /* == 11*/
    if (FB0IM010.XWHCD[1] == FB0IW01.XWHCD[FB0IWIX1])
      FB0IW00.FB0IWWEQ = "Y"; /* warehouse found*/
    end
    FB0IW00.FB0IWIX1 = FB0IW00.FB0IWIX1 + 1; /* increment index*/
  end
  ;
  if (FB0IW00.FB0IWWEQ != "Y") /* warehouse not found*/
    FB0IM010.XXXMODID = "500"; /* module identification*/
    converseLib.validationFailed(89); /* curve does not exist*/
    set FB0IM010.XWHCD[1] cursor, bold; /* highlight field*/
  end
  ;

  ;
end // end FB0I500

// Verify curve exsistence
Function FB0I510()
   /* ------------------------------------------------------------*/
   /* verify if the curve exists*/
   /* ------------------------------------------------------------*/
  ;
  FB0IW00.FB0IWIX2 = 1; /* initialize index*/
  ;
  FB0IW00.FB0IWIX3 = FB0IW00.FB0IWIX1 + 1; /* set index*/
  ;
  while (FB0IW00.FB0IWIX2 <= FB0IW00.FB0INDX1)
    ;
    /* ------------------------------------------------------------*/
     /* if warning message already displayed to user, there is*/
     /* no need to re-verify the curve exists.*/
    /* ----------------------------------------------------------*/
    ;
    if (FB0IM010.XWHCD[FB0IWIX3] == FB0IW01.XWHCD[FB0IWIX2])
      if (FB0IW01.FB0IWCEX[FB0IWIX2] == "1") /* warning previously displayed*/
        FB0IW01.FB0IWCEX[FB0IWIX2] = "Y"; /* reset switch*/
        return; /* return to previous process*/
      else
        FB0IM010.XXXMODID = "510"; /* module identification*/
        converseLib.validationFailed(91); /* 'curve already exists'*/
        set FB0IM010.FB0IMSEL[FB0IWIX1] cursor, bold; /* set cursor*/
        FB0IW01.FB0IWCEX[FB0IWIX2] = "1"; /* set switch*/
        return;
      end
    end
    FB0IW00.FB0IWIX2 = FB0IW00.FB0IWIX2 + 1;
  end
  ;
  ;
end // end FB0I510

// Process valid input request
Function FB0I600()
  if (converseVar.validationMsgNum == 0 || 
  converseVar.validationMsgNum == 91 || 
  converseVar.validationMsgNum == 98)
  else
    exit stack; /* redisplay map*/
  end
  /* **********************************************************************/
  /* this check is to send message 515 when enter is pressed and      **/
  /* bypass 98 message no.**/
  /* **********************************************************************/
  FB0IW00.FB0IWIX1 = 1; /* initialize index*/
  FB0IW00.FB0IFIRSTTIME = "Y"; /* initialize index*/
  FB0IW00.FB0INOOFADD = FB0IW00.FB0INOFC; /* initialize index*/
  while (FB0IW00.FB0IWIX1 <= FB0IW00.FB0INDX1) /* =10*/
    if (FB0IM010.FB0IMSEL[FB0IWIX1] == "C")
      if (FB0IW00.FB0IFIRSTTIME == "Y")
        set FB0IM010.FB0IMSEL[FB0IWIX1] cursor;
        FB0IW00.FB0IFIRSTTIME = "N"; /* initialize index*/
      end
      FB0IW00.FB0IWUPW = "N"; /* set switch*/
      ;
      FB0IW00.FB0IWIX2 = 1; /* initialize index*/
      ;
      FB0IW00.FB0IWIX3 = FB0IW00.FB0IWIX1 + 1; /* set index*/
      ;
      while (FB0IW00.FB0IWIX2 <= FB0IW00.FB0INDX2)
        if (FB0IW01.XWHCD[FB0IWIX2] == FB0IM010.XWHCD[FB0IWIX3])
          FB0IW00.FB0IWUPW = "Y";
        end /* set warehouse found for update switch*/
        FB0IW00.FB0IWIX2 = FB0IW00.FB0IWIX2 + 1; /* set index*/
      end
      if (FB0IW00.FB0IWUPW == "N")
        FB0IW00.FB0INOOFADD = FB0IW00.FB0INOOFADD + 1;
      end
    end
    FB0IW00.FB0IWIX1 = FB0IW00.FB0IWIX1 + 1; /* set index*/
  end
  if (FB0IW00.FB0INOFC >= 3
   && FB0IW00.FB0IWUPW == "N"
   && FB0IW00.FB0IWUDR == "Y")
    ;
    converseLib.validationFailed(515); /* no of curves exceeds 3*/
  end
  if (FB0IW00.FB0INOOFADD >= 4)
    converseLib.validationFailed(515); /* no of curves exceeds 3*/
  end
   /* ------------------------------------------------------------*/
   /* If update not requested or an error has occured, redisplay*/
   /* the map.*/
   /* ------------------------------------------------------------*/
  ;
  if (converseVar.validationMsgNum != 0) /* error occured*/
    exit stack; /* redisplay map*/
  end
  ;
  if (converseVar.eventKey not pf9) /* PF9 not pressed*/
    if (FB0IW00.FB0IWUDR == "Y") /* update requested*/
      converseLib.validationFailed(98); /* 'press PF9 to update'*/
      FB0IM010.XXXMODID = "600"; /* module identification*/
      exit stack;
    end
  end
  ;
   /* ------------------------------------------------------------*/
   /* For each warehouse with a selection = 'c' (copy to)*/
   /* determine update type.*/
   /* ------------------------------------------------------------*/
  ;
  FB0IW00.FB0IWIX1 = 1; /* initialize index*/
  ;
  while (FB0IW00.FB0IWIX1 <= FB0IW00.FB0INDX1)
    if (FB0IM010.FB0IMSEL[FB0IWIX1] == "C")
      FB0I610(); /* determine update type*/
    end
    FB0IW00.FB0IWIX1 = FB0IW00.FB0IWIX1 + 1; /* increment index*/
  end
  ;
  ;
end // end FB0I600

// determine update type
Function FB0I610()
   /* ------------------------------------------------------------*/
   /* Call statement group to obtain current date and time*/
   /* ------------------------------------------------------------*/
  XX0XS01();
  ;
   /* ------------------------------------------------------------*/
   /* if curve exists, update the modified fields*/
   /* if not, add a new row to the table*/
   /* ------------------------------------------------------------*/
  ;
  FB0IW00.FB0IWUPW = "N"; /* set switch*/
  ;
  FB0IW00.FB0IWIX2 = 1; /* initialize index*/
  ;
  FB0IW00.FB0IWIX3 = FB0IW00.FB0IWIX1 + 1; /* set index*/
  ;
  while (FB0IW00.FB0IWIX2 <= FB0IW00.FB0INDX2) /* =11*/
    if (FB0IW01.XWHCD[FB0IWIX2] == FB0IM010.XWHCD[FB0IWIX3])
      FB0IW00.FB0IWUPW = "Y";
                                   /* set warehouse found for update switch*/
      if (FB0IW01.FB0IWCEX[FB0IWIX2] == "Y"
      )
        FB0I611(); /* Update table row*/
        converseLib.validationFailed(32); /* 'update successful'*/
        /* ------------------------------------------------------------*/
         /* Commit all changes to protected resources.*/
        /* ------------------------------------------------------------*/
        ;
        VGVar.handleSysLibraryErrors = 1;
        sysLib.commit(); /* Commit all changes*/
        ;
        FB0IM010.FB0IMSEL[FB0IWIX1] = " "; /* reset selection field*/
        /* ------------------------------------------------------------*/
         /* move record to working storage*/
        /* ------------------------------------------------------------*/
        FB0IW01.FB0IWCEX[FB0IWIX1] = "N"; /* reset switch*/
        ;
        if (FB4REC.XWHCD == FB0IW02.XWHCD) /* warhouse codes equal*/
          FB0IW02.FB4GROUP = FB4REC.FB4GROUP; /* move record*/
        else
          if (FB4REC.XWHCD == FB0IW03.XWHCD) /* warehouse codes equal*/
            FB0IW03.FB4GROUP = FB4REC.FB4GROUP; /* move record*/
          else
            if (FB4REC.XWHCD == FB0IW04.XWHCD) /* warehouse codes equal*/
              FB0IW04.FB4GROUP = FB4REC.FB4GROUP; /* move record*/
            end
          end
        end
        /* ELSE;*/
        /* MOVE 515 TO EZEMNO;*/
      end
    end
    FB0IW00.FB0IWIX2 = FB0IW00.FB0IWIX2 + 1; /* increment index*/
  end
  ;
  if (FB0IW00.FB0IWUPW == "N"
   && FB0IW00.FB0INOFC <= 2)
    ;
    FB0I612(); /* add table row*/
    FB0IW00.FB0INOFC = FB0IW00.FB0INOFC + 1;
    converseLib.validationFailed(32); /* 'update successful'*/
    /* ------------------------------------------------------------*/
     /* Commit all changes to protected resources.*/
    /* ------------------------------------------------------------*/
    ;
    VGVar.handleSysLibraryErrors = 1;
    sysLib.commit(); /* Commit all changes*/
    ;
    FB0IM010.FB0IMSEL[FB0IWIX1] = " "; /* reset selection field*/
    ;
    FB0IW00.FB0IWIX4 = 1; /* initialize index*/
    while (FB0IW00.FB0IWIX4 <= FB0IW00.FB0INDX2) /* =11*/
      if (FB0IW01.XWHCD[FB0IWIX4] == " ") /* warehouse code blank*/
         /* move warehouse code that was added to storage*/
        FB0IW01.XWHCD[FB0IWIX4] = FB0IM010.XWHCD[FB0IWIX2];
        FB0IW00.FB0IWIX4 = FB0IW00.FB0INDX2 + 1; /* set wix4 to 12*/
      end
      FB0IW00.FB0IWIX4 = FB0IW00.FB0IWIX4 + 1;
    end
  else
    if (FB0IW00.FB0IWUPW == "N" && FB0INOFC == 3) /* ecord was to be added not*/
                                   /* updated*/
      /* MOVE 515 TO EZEMNO;          /* no of curves exceeded 3*/
    end
  end
  ;
  ;
end // end FB0I610

// Update the table row
Function FB0I611()
   /* ------------------------------------------------------------*/
   /* Format the key*/
   /* ------------------------------------------------------------*/
  ;
  set FB4REC empty; /* clear row storage area*/
  ;
   /* ------------------------------------------------------------*/
   /* Format the data from the map in the table row.*/
   /* ------------------------------------------------------------*/
  ;
  FB4REC.ZZZCHGDT = XX0XW01.XX0XWDAT; /* Change date*/
  FB4REC.ZZZCHGTM = XX0XW01.XX0XWTIM; /* Change time*/
  ;
  FB0I613(); /* move key and change count*/
  ;
  FB0I614(); /* move pcts, qtys, flags, and crv nbr*/
  ;
   /* ------------------------------------------------------------*/
   /* Update vcurve01 row*/
   /* ------------------------------------------------------------*/
  ;
  try
    call "IO3020" ("U ", SQLCA, FB4REC) {isNoRefresh = yes, isExternal = yes};
  end /* update row*/
  ;
   /* ------------------------------------------------------------*/
   /* If successful, return to calling process.*/
   /* ------------------------------------------------------------*/
  ;
  if (sysVar.errorCode == "00000000") /* Call successful*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Normal return code*/
      return; /* Return to previous process*/
    else
      if (SQLCA.VAGen_SQLCODE == +100) /* database updated by another user*/
        VGVar.handleSysLibraryErrors = 0;
        sysLib.rollback(); /* rollback changes made by user*/
        FB0IM010.XXXMODID = "611"; /* Module identification*/
        converseLib.validationFailed(46); /* 'database updated by another user'*/
        exit stack; /* Exit to display map*/
      else
        if (SQLCA.VAGen_SQLCODE == -911) /* database currently in use*/
          FB0IM010.XXXMODID = "611"; /* Module identification*/
          converseLib.validationFailed(57); /* 'database currently in use'*/
          TA1REC.TA1FUNC = "POST"; /* Termination function*/
          ;
        else
          VGVar.handleSysLibraryErrors = 0;
          sysLib.rollback(); /* rollback changes made by user*/
          converseLib.validationFailed(48); /* 'fatal data base error'*/
        end
      end
    end
  end
  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/
  FB0IM010.XXXMODID = "611"; /* Module identification*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "UPDATE TABLE ROW";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FB0IM010.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFBUY   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCURVE01"; /* Table view name*/
  TA1REC.TA1TBLKE = FB4REC.FB4KEY; /* Table key*/
  ;
  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/
  ;
  exit stack; /* Exit to display map*/
  ;
  ;
end // end FB0I611

// Add table row
Function FB0I612()
   /* ------------------------------------------------------------*/
   /* Format the key*/
   /* ------------------------------------------------------------*/
  ;
  set FB4REC empty; /* clear row storage area*/
  ;
   /* ------------------------------------------------------------*/
   /* Format the data from the map in the table row.*/
   /* ------------------------------------------------------------*/
  ;
  FB0I615(); /* move fb4rec*/
  ;
  FB4REC.ZZZCHGDT = XX0XW01.XX0XWDAT; /* Change date*/
  FB4REC.ZZZCHGTM = XX0XW01.XX0XWTIM; /* Change time*/
  ;
  FB0IW00.FB0IWIX2 = FB0IW00.FB0IWIX1 + 1;
  FB4REC.XWHCD = FB0IM010.XWHCD[FB0IWIX2]; /* warehouse code*/
  FB4REC.FB4RGPCT = 0; /* region percent*/
  FB4REC.ZZZCHGCT = 0; /* Change count*/
  ;
   /* ------------------------------------------------------------*/
   /* move record to working storage*/
   /* ------------------------------------------------------------*/
  ;
  if (FB0IW02.XWHCD == " ")
    FB0IW02.FB4GROUP = FB4REC.FB4GROUP;
  else
    if (FB0IW03.XWHCD == " ")
      FB0IW03.FB4GROUP = FB4REC.FB4GROUP;
    else
      if (FB0IW04.XWHCD == " ")
        FB0IW04.FB4GROUP = FB4REC.FB4GROUP;
      end
    end
  end
  ;
   /* ------------------------------------------------------------*/
   /* Add vcurve01 row*/
   /* ------------------------------------------------------------*/
  ;
  try
    call "IO3020" ("A ", SQLCA, FB4REC) {isNoRefresh = yes, isExternal = yes};
  end /* update row*/
  ;
   /* ------------------------------------------------------------*/
   /* If successful, return to calling process.*/
   /* ------------------------------------------------------------*/
  ;
  if (sysVar.errorCode == "00000000") /* Call successful*/
    if (SQLCA.VAGen_SQLCODE == 0) /* Normal return code*/
      return; /* Return to previous process*/
    else
      if (SQLCA.VAGen_SQLCODE == -911) /* database currently in use*/
        FB0IM010.XXXMODID = "612"; /* Module identification*/
        converseLib.validationFailed(57); /* 'database currently in use'*/
        TA1REC.TA1FUNC = "POST"; /* Termination function*/
        ;
      else
        VGVar.handleSysLibraryErrors = 0;
        sysLib.rollback(); /* rollback changes made by user*/
        converseLib.validationFailed(48); /* 'fatal data base error'*/
      end
    end
  end
  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/
  FB0IM010.XXXMODID = "612"; /* Module identification*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "UPDATE TABLE ROW";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FB0IM010.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFBUY   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCURVE01"; /* Table view name*/
  TA1REC.TA1TBLKE = FB4REC.FB4KEY; /* Table key*/
  ;
  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/
  ;
  exit stack; /* Exit to display map*/
  ;
  ;
end // end FB0I612

// move warehouse fields
Function FB0I613()
   /* ------------------------------------------------------------*/
   /* move warehouse fields*/
   /* ------------------------------------------------------------*/
  FB0IWIX3 = FB0IWIX1 + 1;
  if (FB0IM010.XWHCD[FB0IWIX3] == FB0IW02.XWHCD)
    /* F FB0IWIX1 = 1;*/
    FB4REC.FB4KEY = FB0IW02.FB4KEY; /* record key*/
    FB4REC.XWHCD = FB0IW02.XWHCD; /* warehouse code*/
    FB4REC.FB4RGPCT = FB0IW02.FB4RGPCT; /* region percent*/
    FB4REC.ZZZCHGCT = FB0IW02.ZZZCHGCT; /* change count*/
  else
    if (FB0IM010.XWHCD[FB0IWIX3] == FB0IW03.XWHCD)
      /* IF FB0IWIX1 = 2;*/
      FB4REC.FB4KEY = FB0IW03.FB4KEY; /* record key*/
      FB4REC.XWHCD = FB0IW03.XWHCD; /* warehouse code*/
      FB4REC.FB4RGPCT = FB0IW03.FB4RGPCT; /* region percent*/
      FB4REC.ZZZCHGCT = FB0IW03.ZZZCHGCT; /* change count*/
    else
      if (FB0IM010.XWHCD[FB0IWIX3] == FB0IW04.XWHCD)
        /* IF FB0IWIX1 = 3;*/
        FB4REC.FB4KEY = FB0IW04.FB4KEY; /* record key*/
        FB4REC.XWHCD = FB0IW04.XWHCD; /* warehouse code*/
        FB4REC.FB4RGPCT = FB0IW04.FB4RGPCT; /* region percent*/
        FB4REC.ZZZCHGCT = FB0IW04.ZZZCHGCT; /* change count*/
      end
    end
  end
  ;
  ;
end // end FB0I613

// move percents and quantities
Function FB0I614()
   /* ------------------------------------------------------------*/
   /* move percents and quantitys*/
   /* ------------------------------------------------------------*/
  ;
  FB0IW00.FB0IWIX2 = 1; /* initialize index*/
  ;
  if (FB0IM010.XWHCD[1] == FB0IW02.XWHCD)
    FB4REC.FB4CRVNB = FB0IW02.FB4CRVNB; /* curve number*/
    FB4REC.FB4STDFL = FB0IW02.FB4STDFL; /* standard curve flag*/
    FB4REC.ZZZSDT = FB0IW02.ZZZSDT; /* start date*/
    FB4REC.FB4QTYLK = FB0IW02.FB4QTYLK; /* quantity flag*/
    while (FB0IW00.FB0IWIX2 <= 40)
      FB4REC.FB4SZPCT[FB0IWIX2] = FB0IW02.FB4SZPCT[FB0IWIX2];
      FB4REC.FB4DMQTY[FB0IWIX2] = FB0IW02.FB4DMQTY[FB0IWIX2];
      FB0IW00.FB0IWIX2 = FB0IW00.FB0IWIX2 + 1;
    end
  else
    if (FB0IM010.XWHCD[1] == FB0IW03.XWHCD)
      FB4REC.FB4CRVNB = FB0IW03.FB4CRVNB; /* curve number*/
      FB4REC.FB4STDFL = FB0IW03.FB4STDFL; /* standard curve flag*/
      FB4REC.ZZZSDT = FB0IW03.ZZZSDT; /* start date*/
      FB4REC.FB4QTYLK = FB0IW03.FB4QTYLK; /* quantity flag*/
      while (FB0IW00.FB0IWIX2 <= 40)
        FB4REC.FB4SZPCT[FB0IWIX2] = FB0IW03.FB4SZPCT[FB0IWIX2];
        FB4REC.FB4DMQTY[FB0IWIX2] = FB0IW03.FB4DMQTY[FB0IWIX2];
        FB0IW00.FB0IWIX2 = FB0IW00.FB0IWIX2 + 1;
      end
    else
      if (FB0IM010.XWHCD[1] == FB0IW04.XWHCD)
        FB4REC.FB4CRVNB = FB0IW04.FB4CRVNB; /* curve number*/
        FB4REC.FB4STDFL = FB0IW04.FB4STDFL; /* standard curve flag*/
        FB4REC.ZZZSDT = FB0IW04.ZZZSDT; /* start date*/
        FB4REC.FB4QTYLK = FB0IW04.FB4QTYLK; /* quantity flag*/
        while (FB0IW00.FB0IWIX2 <= 40)
          FB4REC.FB4SZPCT[FB0IWIX2] = FB0IW04.FB4SZPCT[FB0IWIX2];
          FB4REC.FB4DMQTY[FB0IWIX2] = FB0IW04.FB4DMQTY[FB0IWIX2];
          FB0IW00.FB0IWIX2 = FB0IW00.FB0IWIX2 + 1;
        end
      end
    end
  end
  ;
  ;
end // end FB0I614

// Move curve record
Function FB0I615()
   /* ------------------------------------------------------------*/
   /* move fb4rec*/
   /* ------------------------------------------------------------*/
  ;
  if (FB0IM010.XWHCD[1] == FB0IW02.XWHCD)
    FB4REC.FB4GROUP = FB0IW02.FB4GROUP;
  else
    if (FB0IM010.XWHCD[1] == FB0IW03.XWHCD)
      FB4REC.FB4GROUP = FB0IW03.FB4GROUP;
    else
      if (FB0IM010.XWHCD[1] == FB0IW04.XWHCD)
        FB4REC.FB4GROUP = FB0IW04.FB4GROUP;
      end
    end
  end
  ;
  ;
end // end FB0I615

// Declare and Open crsr Vsumcd01
Function FB0IS01()
  set YSMREC empty;
  YSMREC.YSMTBLPF = "XWH";
  YSMREC.YSMSYSPF = "FB";
  YSMREC.YSMSUMID = 1;
  YSMREC.YSMSUMCD = "01";
  YSMREC.YSMSRCVL = "****";
  ;
   /* ------------------------------------------------------------*/
   /* DECLARE CURSOR AND OPEN CURSOR FOR THE TABLE DCORP.VSUMCD01*/
   /* ------------------------------------------------------------*/
  ;
  try
    call "IO2640" ("S1", SQLCA, YSMREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/
  ;
   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/
  ;
  if (sysVar.errorCode == "00000000") /* Call successful*/
    if (SQLCA.VAGen_SQLCODE == 0 /* normal return code*/
     || SQLCA.VAGen_SQLCODE == 100) /* OR NOT FOUND*/
      ;
      return; /* Return to previous process*/
      ;
    end
  end
  ;
   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/
  ;
  FB0IM010.XXXMODID = "S01"; /* Module identification*/
  ;
  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/
    ;
    converseLib.validationFailed(11); /* 'Resources unavailable'*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
    ;
  else
    ;
    converseLib.validationFailed(10); /* 'Error - Please nofity programming'*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    ;
    converseLib.clearScreen();
     /* Clear screen before display*/
    ;
  end
  ;
  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "DECL CURSR DCORP.VSUMCD01";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = "FB0I140"; /* Program number*/
  TA1REC.TA1DBASE = "DCORP   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VSUMCD01"; /* Table view name*/
  TA1REC.TA1TBLKE = YSMREC.YSMGRP; /* Formatted error key*/
  ;
  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/
  ;
  exit stack; /* EXIT TO DISPLAY MAP*/
  ;
  ;
end // end FB0IS01

// Fetch the cursor and get WH cn
Function FB0IS02()
   /* ------------------------------------------------------------*/
   /* FETCH  NEXT row from the table DCORP.VSUMCD01*/
   /* ------------------------------------------------------------*/
  set YSMREC empty;
  ;
  try
    call "IO2640" ("N1", SQLCA, YSMREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/
  ;
   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/
  ;
  if (sysVar.errorCode == "00000000") /* Call successful*/
    if (SQLCA.VAGen_SQLCODE == 0) /* normal return code*/
      FB0IW00.FB0IWIXN = FB0IW00.FB0IWIXN + 1;
                                   /* counter for no of warehouses*/
      return; /* Return to previous process*/
    else
      if (SQLCA.VAGen_SQLCODE == 100) /* OR NOT FOUND*/
        FB0IW00.FB0IMORERECS = "N";
        while (FB0IWIX2 <= FB0INDX1)
          set FB0IMSEL[FB0IWIX2] invisible, protect;
          FB0IWIX2 = FB0IWIX2 + 1;
        end
        return; /* Return to previous process*/
        ;
      end
    end
  end
  ;
   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/
  ;
  FB0IM010.XXXMODID = "S02"; /* Module identification*/
  ;
  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/
    ;
    converseLib.validationFailed(11); /* 'Resources unavailable'*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
    ;
  else
    ;
    converseLib.validationFailed(10); /* 'Error - Please nofity programming'*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    ;
    converseLib.clearScreen();
     /* Clear screen before display*/
    ;
  end
  ;
  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "FETCH WHSE DCORP.VSUMCD01";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = "FB0I140"; /* Program number*/
  TA1REC.TA1DBASE = "DCORP   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VSUMCD01"; /* Table view name*/
  TA1REC.TA1TBLKE = YSMREC.YSMGRP; /* Formatted error key*/
  ;
  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/
  ;
  exit stack; /* EXIT TO DISPLAY MAP*/
  ;
  ;
end // end FB0IS02

// Close the cursor
Function FB0IS03()
   /* ------------------------------------------------------------*/
   /* CLOSE cursor on the table DCORP.VSUMCD01*/
   /* ------------------------------------------------------------*/
  ;
  try
    call "IO2640" ("C1", SQLCA, YSMREC) {isNoRefresh = yes, isExternal = yes};
  end /* Select row*/
  ;
   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/
  ;
  if (sysVar.errorCode == "00000000") /* Call successful*/
    if (SQLCA.VAGen_SQLCODE == 0 /* normal return code*/
    )                           
      return; /* Return to previous process*/
      ;
    end
  end
  ;
   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/
  ;
  FB0IM010.XXXMODID = "S03"; /* Module identification*/
  ;
  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/
    ;
    converseLib.validationFailed(11); /* 'Resources unavailable'*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
    ;
  else
    ;
    converseLib.validationFailed(10); /* 'Error - Please nofity programming'*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    ;
    converseLib.clearScreen();
     /* Clear screen before display*/
    ;
  end
  ;
  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "CLOSE CRSR DCORP.VSUMCD01";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = "FB0I140"; /* Program number*/
  TA1REC.TA1DBASE = "DCORP   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VSUMCD01"; /* Table view name*/
  TA1REC.TA1TBLKE = YSMREC.YSMGRP; /* Formatted error key*/
  ;
  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/
  ;
  exit stack; /* EXIT TO DISPLAY MAP*/
  ;
  ;
end // end FB0IS03

//*** RECORD=FB0IW00 ****
// ----------------------------
// Application working storage.
// ----------------------------
// ***********************
Record FB0IW00 type basicRecord
  10 FB0IWSDR FB0IWSDR ; 
  10 FB0IWSPR FB0IWSPR ; 
  10 FB0IWUPW FB0IWUPW ; 
  10 FB0IWRNA FB0IWRNA ; 
  10 FB0IWUDR FB0IWUDR ; 
  10 XGPCD XGPCD ; 
  10 XWHCD XWHCD ; 
  10 FB0IWIXM FB0IWIXM ; 
  10 FB0IWIX1 FB0IWIX1 ; 
  10 FB0IWIX2 FB0IWIX2 ; 
  10 FB0IWIX3 FB0IWIX3 ; 
  10 FB0IWIX4 FB0IWIX4 ; 
  10 FB0IWIX5 FB0IWIX5 ; 
  10 FB0IWIXN FB0IWIXN ; 
  10 FB0INDX1 FB0INDX1 ; 
  10 FB0INDX2 FB0INDX2 ; 
  10 FB0INOFC FB0INOFC ; 
  10 FB1INSEQ FB1INSEQ ; 
  10 FB0IWDCF FB0IWDCF ; 
  10 FB0IWWEQ FB0IWWEQ ; 
  10 FB0IMORERECS FB0IMORERECS ; 
  10 FB0IFIRSTTIME FB0IFIRSTTIME ; 
  10 FB0INOOFADD FB0INOOFADD ; 
end // end FB0IW00

//*** RECORD=FB0IW01 ****
// ----    header display storage
// ***********************
Record FB0IW01 type basicRecord
  10 XWHCD XWHCD [11] ; 
  10 FB0IWCEX FB0IWCEX [11] ; 
  10 FB5FRMDT FB5FRMDT ; 
  10 FB0IWFDT FB0IWFDT ; 
    15 FB0IWF3 FB0IWF3 ; 
    15 FB0IWFYY FB0IWFYY ; 
    15 FB0IWFMM FB0IWFMM ; 
    15 FB0IWFDD FB0IWFDD ; 
  10 FB5TODT FB5TODT ; 
  10 FB0IWTDT FB0IWTDT ; 
    15 FB0IWT3 FB0IWT3 ; 
    15 FB0IWTYY FB0IWTYY ; 
    15 FB0IWTMM FB0IWTMM ; 
    15 FB0IWTDD FB0IWTDD ; 
end // end FB0IW01

//*** RECORD=FB0IW02 ****
// ****************** selection parameters ********************
// 
// DB2 TABLE VIEW:      dfcast.vcurve01
// 
// COPYLIB MEMBER:      DCL00542
// 
// I/O MODULE:          IO3020
// 
// KEY TO DB2 TABLE:    fb1inseq, xgpcd, sy1stnbr, sy2clrid,
//                     xdmcd, xqacd, xsdcd, xsacd, xpgcd, xumcd
// MAINTENANCE LOG:
// 
// CONTROL    DATE     NAME   DESCRIPTION OF CHANGE
// -------  --------  ------  ---------------------------------
//          12/27/88  wdishm  New record definition.
// ***********************
Record FB0IW02 type basicRecord
  5 FB4GROUP FB4GROUP ; 
    10 FB4KEY FB4KEY ; 
      15 FB1INSEQ FB1INSEQ ; 
      15 XGPCD XGPCD ; 
      15 SY1STNBR SY1STNBR ; 
      15 SY2CLRID SY2CLRID ; 
      15 XDMCD XDMCD ; 
      15 XQACD XQACD ; 
      15 PC2INSEG PC2INSEG ; 
      15 XSACD XSACD ; 
      15 XPGCD XPGCD ; 
      15 XUMCD XUMCD ; 
    10 FB4CRVNB FB4CRVNB ; 
    10 FB4STDFL FB4STDFL ; 
    10 XWHCD XWHCD ; 
    10 FB4QTYLK FB4QTYLK ; 
    10 FB4RGPCT FB4RGPCT ; 
    10 FB4DMQTY FB4DMQTY [40] ; 
    10 FB4SZPCT FB4SZPCT [40] ; 
    10 ZZZSDT ZZZSDT ; 
    10 ZZZCHGDT ZZZCHGDT ; 
    10 ZZZCHGTM ZZZCHGTM ; 
    10 ZZZCHGCT ZZZCHGCT ; 
end // end FB0IW02

//*** RECORD=FB0IW03 ****
// ****************** selection parameters ********************
// 
// DB2 TABLE VIEW:      dfcast.vcurve01
// 
// COPYLIB MEMBER:      DCL00542
// 
// I/O MODULE:          IO3020
// 
// KEY TO DB2 TABLE:    fb1inseq, xgpcd, sy1stnbr, sy2clrid,
//                     xdmcd, xqacd, xsdcd, xsacd, xpgcd, xumcd
// MAINTENANCE LOG:
// 
// CONTROL    DATE     NAME   DESCRIPTION OF CHANGE
// -------  --------  ------  ---------------------------------
//          12/27/88  wdishm  New record definition.
// ***********************
Record FB0IW03 type basicRecord
  5 FB4GROUP FB4GROUP ; 
    10 FB4KEY FB4KEY ; 
      15 FB1INSEQ FB1INSEQ ; 
      15 XGPCD XGPCD ; 
      15 SY1STNBR SY1STNBR ; 
      15 SY2CLRID SY2CLRID ; 
      15 XDMCD XDMCD ; 
      15 XQACD XQACD ; 
      15 PC2INSEG PC2INSEG ; 
      15 XSACD XSACD ; 
      15 XPGCD XPGCD ; 
      15 XUMCD XUMCD ; 
    10 FB4CRVNB FB4CRVNB ; 
    10 FB4STDFL FB4STDFL ; 
    10 XWHCD XWHCD ; 
    10 FB4QTYLK FB4QTYLK ; 
    10 FB4RGPCT FB4RGPCT ; 
    10 FB4DMQTY FB4DMQTY [40] ; 
    10 FB4SZPCT FB4SZPCT [40] ; 
    10 ZZZSDT ZZZSDT ; 
    10 ZZZCHGDT ZZZCHGDT ; 
    10 ZZZCHGTM ZZZCHGTM ; 
    10 ZZZCHGCT ZZZCHGCT ; 
end // end FB0IW03

//*** RECORD=FB0IW04 ****
// ****************** selection parameters ********************
// 
// DB2 TABLE VIEW:      dfcast.vcurve01
// 
// COPYLIB MEMBER:      DCL00542
// 
// I/O MODULE:          IO3020
// 
// KEY TO DB2 TABLE:    fb1inseq, xgpcd, sy1stnbr, sy2clrid,
//                     xdmcd, xqacd, xsdcd, xsacd, xpgcd, xumcd
// MAINTENANCE LOG:
// 
// CONTROL    DATE     NAME   DESCRIPTION OF CHANGE
// -------  --------  ------  ---------------------------------
//          12/27/88  wdishm  New record definition.
// ***********************
Record FB0IW04 type basicRecord
  5 FB4GROUP FB4GROUP ; 
    10 FB4KEY FB4KEY ; 
      15 FB1INSEQ FB1INSEQ ; 
      15 XGPCD XGPCD ; 
      15 SY1STNBR SY1STNBR ; 
      15 SY2CLRID SY2CLRID ; 
      15 XDMCD XDMCD ; 
      15 XQACD XQACD ; 
      15 PC2INSEG PC2INSEG ; 
      15 XSACD XSACD ; 
      15 XPGCD XPGCD ; 
      15 XUMCD XUMCD ; 
    10 FB4CRVNB FB4CRVNB ; 
    10 FB4STDFL FB4STDFL ; 
    10 XWHCD XWHCD ; 
    10 FB4QTYLK FB4QTYLK ; 
    10 FB4RGPCT FB4RGPCT ; 
    10 FB4DMQTY FB4DMQTY [40] ; 
    10 FB4SZPCT FB4SZPCT [40] ; 
    10 ZZZSDT ZZZSDT ; 
    10 ZZZCHGDT ZZZCHGDT ; 
    10 ZZZCHGTM ZZZCHGTM ; 
    10 ZZZCHGCT ZZZCHGCT ; 
end // end FB0IW04

DataItem FB0IFIRSTTIME char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Flag for VSUMCD01
DataItem FB0IMORERECS char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// index four for stored fields
DataItem FB0INDX1 smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// index four for stored fields
DataItem FB0INDX2 smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// No of curves for stored fields
DataItem FB0INOFC smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// No of curves for stored fields
DataItem FB0INOOFADD smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// warehouse curve exists
DataItem FB0IWCEX char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// flag for vcurve01
DataItem FB0IWDCF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// leading zero and century
DataItem FB0IWF3 num(3)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// from date day
DataItem FB0IWFDD num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// from work date
DataItem FB0IWFDT num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// from date month
DataItem FB0IWFMM num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// from date year
DataItem FB0IWFYY num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// index one for stored fields
DataItem FB0IWIX1 smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// index two for stored fields
DataItem FB0IWIX2 smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// index three for stored fields
DataItem FB0IWIX3 smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// index four for stored fields
DataItem FB0IWIX4 smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// index five for stored fields
DataItem FB0IWIX5 smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// index for stored fields
DataItem FB0IWIXM smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// index four for stored fields
DataItem FB0IWIXN smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// resources unavailable switch
DataItem FB0IWRNA char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Request for data switch
DataItem FB0IWSDR char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// processing switch
DataItem FB0IWSPR char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// leading zero and century
DataItem FB0IWT3 num(3)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// to date day
DataItem FB0IWTDD num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// to work date
DataItem FB0IWTDT num(9)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// to date month
DataItem FB0IWTMM num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// to date year
DataItem FB0IWTYY num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// update requested switch
DataItem FB0IWUDR char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Update Warehouse switch
DataItem FB0IWUPW char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// warehouse equal flag
DataItem FB0IWWEQ char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

