package fb0j;

import corpcom2.XX0XW01;
import corpcom2.XX0XW02;
import corpcom3.XPFB001;
import corpcom4.XSEXIT;
import corpcom4.XSPG202;
import corpcom4.XSPG301;
import corpcom4.XX0XS01;
import corpcom5.COMMAREA;
import corpcom6.SQLCA;
import corpx1.XDVCD;
import corpx1.XWHTBL;
import fb.common.FB0JW02;
import fb.common.FB0JW03;
import fb.common.FB0JW04;
import fb.common.FB0JW05;
import fb.common.FB1REC;
import fb.common.FB4QTYLK;
import fb.common.FB4REC;
import fb.common.FB5REC;
import fb.common.FB6REC;
import fb.common.FBWREC;
import fb.common.FBZREC;
import pg.common.PG2REC;
import pg.common.PG3REC;
import sy.common.SY4REC;
import ta.common.TA1REC;
import ta.common.TAEREC;
//*** PROGRAM=FB0J ****
// Maintains the Size Percent table.
// 
// Processing will differ depending on the 'from' application.
// 
// If transferring from outside the Footwear Buy system, no key
// will have been passed and processing will be limitted to
// exiting the program.
// 
// If the 'from' application is within the Footwear Buy system,
// a key will have been passed and the associated curve can be
// maintained.
// 
// If the 'from' application is fb0e (assign to product)
// and an error has occurred while assigning the curve,  the
// invalid sizes are highlighted and the user can correct them,
// then control is passed back to fb0e.
// 
// Curves will be maintained for one warehouse at a time.  To
// page to the next warehouse the user will hit enter.  To
// bring up a specific warehouse the user types in the
// warehouse and hits enter.
// 
// 
// 
// 
// 
// 
// 
// 
// 
// -------  --------  ------  ---------------------------------
// CONTROL    DATE     NAME   DESCRIPTION OF CHANGE
// -------  --------  ------  ---------------------------------
//          01/23/89  pmainw  New application.
// FB-281   06/25/92  pmainw  handle size scale '01' and '13'.
// FB-306   01/01/93  jmclau  enlarge size percent field on
//                            map so 100.00 can be displayed.
//          10/26/94  jalle1  Check for duplicate standards.
// YR2000   12/03/97  rgilli  Y2K MODIFICATIONS MADE TO:
//                            Re-generated to include new
//                            version of XX0XS01.
// *********************
Program FB0J type textUIProgram //VAGen Info - main text program
  {
  includeReferencedFunctions = yes, allowUnqualifiedItemReferences = yes, 
  throwNrfEofExceptions = yes, handleHardIOErrors = no, V60ExceptionCompatibility = yes, 
  I4GLItemsNullable = no, textLiteralDefaultIsString = no, localSQLScope = yes, 
  msgTablePrefix = "FF00", inputRecord = COMMAREA, segmented = yes
  }

  // Data Declarations
  COMMAREA COMMAREA ; // record
  FB0JW01 FB0JW01; // record
  FB0JW02 FB0JW02; // record
  FB0JW03 FB0JW03; // record
  FB0JW04 FB0JW04; // record
  FB0JW05 FB0JW05; // record
  FB1REC FB1REC; // record
  FB4REC FB4REC; // record
  FB5REC FB5REC; // record
  FB6REC FB6REC; // record
  FBWREC FBWREC; // record
  FBZREC FBZREC; // record
  PG2REC PG2REC; // record
  PG3REC PG3REC; // record
  SQLCA SQLCA; // record
  SY4REC SY4REC; // record
  TA1REC TA1REC; // record
  TAEREC TAEREC; // record
  XX0XW01 XX0XW01; // record
  XX0XW02 XX0XW02; // record

  // VAGen Info - items needed for migration
  VAGen_EZESYS char(8);
  VAGen_EZEREPLY num(1);
  VAGen_EZE_WAIT_TIME bin(9,2);
  VAGen_EZE_ITEMLEN int;

  // Use Declarations
  use XWHTBL {deleteAfterUse = yes}; // table
  use FB0JM.FB0JM010 // form
   {
    pfKeyEquate = no
  };

  function main()
    // VAGen Info - initialization needed for migration
    VAGen_EZESYS = VGLib.getVAGSysType();
    XPFB001: XPFB001();
     /* ------------------------------------------------------------*/
     /* Initialize working storage and display storage areas.*/
     /* ------------------------------------------------------------*/
    ;
    set FB0JM010 initial; /* M001 input/output*/
    set FB0JW01 empty; /* M001 display storage*/
    set FB0JW02 empty; /* fbwrec redefine*/
    set FB0JW03 empty; /* size array first whse*/
    set FB0JW04 empty; /* size array second whse*/
    set FB0JW05 empty; /* size array third whse*/
    set SQLCA empty; /* SQL communication area*/
    set TAEREC empty; /* Error diagnosis information*/
    set TA1REC empty; /* Error diagnosis parameters*/
    set XX0XW01 empty; /* Date/time subroutine parameters*/
    FB0JW01.FB0JWMAX = 3; /* Maximum nbr of warehouses*/
    ;
    FB0JW01.FB0JWUNP = 1; /* Column to unprotect*/
    FB0JW01.FB0JW-DUP-STD-FL = "N"; /* Duplicate standard flag*/
    ;
     /* ------------------------------------------------------------*/
     /* Identify the type of processing and set up the appropriate*/
     /* working storage records.*/
     /* ------------------------------------------------------------*/
    ;
    if (FBWREC.XGPCD != "  "        /* gen product class*/
     && FBWREC.SY1STNBR != "      " /* style number*/
     && FBWREC.SY2CLRID != "   "    /* color*/
     && FBWREC.XDMCD != "  "        /* dimension*/
     && FBWREC.XQACD != "  "        /* quality*/
     && FBWREC.PC2INSEG != "  "     /* spec difference*/
     && FBWREC.XSACD != "  "        /* shade*/
     && FBWREC.XPGCD != "  "        /* package type*/
     && FBWREC.XUMCD != "  "        /* unit of measure*/
     && FBWREC.FB1INSEQ != 0        /* fb-intrn-seq-nbr*/
     && FBWREC.FBWFILL != " "       /* area passed from fb0e*/
     && COMMAREA.CAFROMAP == "FB0E") /* comming from 'assign to product'*/
      FB0JW01.FB0JWPSW = "IP"; /* invalid product curve*/
      FB0JW01.FB0JWDSW = "Y"; /* display data switch*/
      FB0JW02.FB0JWGR0 = FBWREC.FBWFILL; /* area passed from fb0e*/
    else
      if (FBWREC.XGPCD == "  "        /* gen product class*/
       && FBWREC.SY1STNBR == "      " /* style number*/
       && FBWREC.SY2CLRID == "   "    /* color*/
       && FBWREC.XDMCD == "  "        /* dimension*/
       && FBWREC.XQACD == "  "        /* quality*/
       && FBWREC.PC2INSEG == "  "     /* spec difference*/
       && FBWREC.XSACD == "  "        /* shade*/
       && FBWREC.XPGCD == "  "        /* package type*/
       && FBWREC.XUMCD == "  "        /* unit of measure*/
       && FBWREC.FB1INSEQ != 0        /* fb-intrn-seq-nbr*/
       && FBWREC.FBWFILL != " "       /* area passed from fb0e*/
       && COMMAREA.CAFROMAP == "FB0E") /* comming from 'assign to product'*/
        FB0JW01.FB0JWPSW = "IU"; /* invalid user curve*/
        FB0JW01.FB0JWDSW = "Y"; /* display data switch*/
        FB0JW02.FB0JWGR0 = FBWREC.FBWFILL; /* area passed from fb0e*/
      else
        if (FBWREC.XGPCD != "  "        /* gen product class*/
         && FBWREC.SY1STNBR != "      " /* style number*/
         && FBWREC.SY2CLRID != "   "    /* color*/
         && FBWREC.XDMCD != "  "        /* dimension*/
         && FBWREC.XQACD != "  "        /* quality*/
         && FBWREC.PC2INSEG != "  "     /* spec difference*/
         && FBWREC.XSACD != "  "        /* shade*/
         && FBWREC.XPGCD != "  "        /* package type*/
         && FBWREC.XUMCD != "  "        /* unit of measure*/
         && FBWREC.FB1INSEQ != 0)       /* fb-intrn-seq-nbr*/
          FB0JW01.FB0JWPSW = "DP"; /* display product curve*/
          FB0JW01.FB0JWDSW = "Y"; /* display data switch*/
        else
          if (FBWREC.XGPCD == "  "        /* gen product class*/
           && FBWREC.SY1STNBR == "      " /* style number*/
           && FBWREC.SY2CLRID == "   "    /* color*/
           && FBWREC.XDMCD == "  "        /* dimension*/
           && FBWREC.XQACD == "  "        /* quality*/
           && FBWREC.PC2INSEG == "  "     /* spec difference*/
           && FBWREC.XSACD == "  "        /* shade*/
           && FBWREC.XPGCD == "  "        /* package type*/
           && FBWREC.XUMCD == "  "        /* unit of measure*/
           && FBWREC.FB1INSEQ != 0)       /* fb-intrn-seq-nbr*/
            FB0JW01.FB0JWPSW = "DU"; /* display user curve*/
            FB0JW01.FB0JWDSW = "Y"; /* display data switch*/
          else
            FB0JW01.FB0JWPSW = "NO"; /* nothing to display*/
            FB0JW01.FB0JWDSW = " "; /* display data switch*/
            converseLib.validationFailed(42); /* No data to display*/
          end
        end
      end
    end
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
     /* ------------------------------------------------------------*/
     /* Flow to converse the main process used to display a map.*/
     /* ------------------------------------------------------------*/
    ;
    goto FB0J001; /* Converse the main process*/
    ;
    FB0J001: FB0J001();
     /* ------------------------------------------------------------*/
     /* Flow to converse the main process used to display a map.*/
     /* ------------------------------------------------------------*/
    ;
    goto FB0J001; /* Converse the main process*/
    ;
    ;
  end // end main
end // end FB0J

// Main process - maint. size%
Function FB0J001()
   /* ------------------------------------------------------------*/
   /* This is the main process used to display a map.  Processing*/
   /* always returns to the top of this process and falls through*/
   /* subordinate processes until an error is found or a valid*/
   /* request is processed.  Processing sequence is as follows:*/
  ;
   /* 1) Obtain the data to display.*/
   /* 2) Format the map output area and display the map.*/
   /* 3) Check the attention identifier used to respond.*/
   /* 4) Reset highlighted fields to normal intensity.*/
   /* 5) Verify the data that was entered.*/
   /* 6) Process a valid input request.*/
  ;
   /* In all subordinate processes, "EZEFLO" is used to exit to*/
   /* redisplay the map when an error is found.  This is done to*/
   /* minimize the coding effort required to skip subsequent*/
   /* processing under error conditions.*/
   /* ------------------------------------------------------------*/
  ;
  FB0J100(); /* Obtain the data to display*/
  ;
  FB0J200(); /* Format and display the map*/
  ;
  FB0J300(); /* Check attention identifier*/
  ;
  FB0J400(); /* Reset fields to normal intensity*/
  ;
  FB0J500(); /* Verify the entered data*/
  ;
  FB0J600(); /* Process valid input request*/
  ;
  ;
end // end FB0J001

// Obtain the data to display
Function FB0J100()
  ;
   /* ------------------------------------------------------------*/
   /* Set up display data according to processing type.*/
   /* ------------------------------------------------------------*/
  ;
  if (FB0JW01.FB0JWDSW == "Y") /* display data switch*/
    ;
    FB0J110(); /* Get selection criteria*/
    ;
    FB0JW01.FB0JWUNP = 1; /* column to unprotect*/
    ;
    if (FB0JW01.FB0JWPSW == "DP") /* display product curve*/
      FB0J130(); /* Get product description*/
      FB0J140(); /* Get product curve*/
    end
    if (FB0JW01.FB0JWPSW == "IP") /* invalid product curve*/
      FB0J130(); /* Get product description*/
      FB0J150(); /* Edit assigned to product curve*/
    end
    if (FB0JW01.FB0JWPSW == "IU") /* invalid user curve*/
      FB0J150(); /* Edit assigned to product curve*/
    end
    if (FB0JW01.FB0JWPSW == "DU") /* display user curve*/
      FB0J160(); /* Get user curve*/
    end
    FB0J165(); /* Calculate total quantity all regions*/
  else
    ;
    if (FB0JW01.FB0JWDSW == "N") /* display data switch = next whse*/
      FB0J170(); /* Get next warehouse*/
    else
      if (FB0JW01.FB0JWDSW == "W") /* display data switch = entered whse*/
        FB0J180(); /* Get entered warhouse*/
      end
    end
  end
  ;
  FB0JW01.FB0JWDSW = " "; /* display data switch*/
end // end FB0J100

// Get selection criteria
Function FB0J110()
   /* ------------------------------------------------------------*/
   /* This process will do a select on vselht01.*/
   /* A not found condition on vselhd01 will be fatal.*/
  ;
   /* Next this process will do a select set on vseldt01,*/
   /* then do a select next to obtain the first row and finally*/
   /* close the set.  A not found on the select next will be*/
   /* fatal.*/
   /* ------------------------------------------------------------*/
  ;
  ;
  ;
  FB0J112(); /* Get vselhd01 row*/
  ;
  if (converseVar.validationMsgNum == 32) /* Update successful*/
    return; /* No need to get protected*/
  end /* data a second time*/
  ;
  ;
  if (converseVar.validationMsgNum == 0) /* Good return code*/
    FB0J114(); /* Select set vseldt01*/
    if (converseVar.validationMsgNum == 0) /* Good return code*/
      FB0J116(); /* Select next vseldt01 row*/
      if (converseVar.validationMsgNum == 0) /* Good return code*/
        FB0J118(); /* Close set vseldt01*/
      end
    end
  end
end // end FB0J110

// Get vselhd01 row
Function FB0J112()
   /* ------------------------------------------------------------*/
   /* Initialize the storage areas and record key*/
   /* ------------------------------------------------------------*/
  ;
  ;
  set FB1REC empty; /* Clear row storage area*/
  ;
  FB1REC.FB1INSEQ = FBWREC.FB1INSEQ; /* internal seq nbr*/
  ;
   /* ------------------------------------------------------------*/
   /* Select the requested row from the table.*/
   /* ------------------------------------------------------------*/
  ;
  try
    call "IO3030" ("S ", SQLCA, FB1REC) {isNoRefresh = yes, isExternal = yes};
  end /* Select table row*/
  ;
   /* ------------------------------------------------------------*/
   /* If successful, save the data in display storage and return*/
   /* to the previous process.*/
   /* ------------------------------------------------------------*/
  ;
  if (sysVar.errorCode == "00000000") /* Call successful*/
    ;
    if (SQLCA.VAGen_SQLCODE == 0) /* Normal return code*/
      ;
      FB0JM010.FB1CMNT = FB1REC.FB1CMNT; /* comments*/
      if (FB0JW01.FB0JWPSW == "IU" /* invalid user curve*/
       || FB0JW01.FB0JWPSW == "DU") /* display user curve*/
        FB0JM010.FB4CRVNB = FB1REC.FB1DUMNB; /* Dummy number*/
        FB0JM010.FB0JMLIT = "DUMMY NBR:"; /* Dummy number field name*/
      end
      ;
      return; /* Return to previous process*/
      ;
    end
    ;
  end
  ;
   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* if data not found abort the applicaton otherwiseindicated*/
   /* that a system error has occured*/
   /* ------------------------------------------------------------*/
  ;
  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/
  ;
  FB0JM010.XXXMODID = "112"; /* Module identification*/
  ;
  if (sysVar.errorCode == "00000000") /* Call successful*/
    if (SQLCA.VAGen_SQLCODE == -911) /* Resource not available*/
      ;
      converseLib.validationFailed(19); /* 'Resources unavailabe'*/
      TA1REC.TA1FUNC = "POST"; /* Termination function*/
      ;
    else
      TA1REC.TA1FUNC = "RETN"; /* Termination function*/
      ;
      if (SQLCA.VAGen_SQLCODE == 100) /* Row not found*/
        converseLib.validationFailed(11); /* 'Record not on database'*/
      else
        converseLib.validationFailed(01); /* 'error - please notify programming'*/
      end
    end
    ;
  end
  ;
  converseLib.clearScreen();
   /* Clear screen before display*/
  ;
  ;
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "FETCH VSELHD01 ROW  ";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FB0JM010.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFBUY   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VSELHD01"; /* Table view name*/
  TA1REC.TA1TBLKE = FB1REC.FB1KEY; /* Table key*/
  ;
  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/
  ;
  ;
  ;
end // end FB0J112

// Select set vseldt01
Function FB0J114()
   /* ------------------------------------------------------------*/
   /* Initialize the storage areas and indicators to be used*/
   /* ------------------------------------------------------------*/
  ;
  set FB5REC empty; /* clear row storage area*/
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Format the key with saved sequence number from fbwrec.*/
   /* ------------------------------------------------------------*/
  ;
  FB5REC.FB1INSEQ = FBWREC.FB1INSEQ;
  ;
   /* ------------------------------------------------------------*/
   /* Select the requested set of rows from the table.*/
   /* ------------------------------------------------------------*/
  ;
  try
    call "IO3040" ("S1", SQLCA, FB5REC) {isNoRefresh = yes, isExternal = yes};
  end /* Select table set*/
  ;
   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/
  ;
  if (sysVar.errorCode == "00000000") /* Call successful*/
    if (SQLCA.VAGen_SQLCODE == 0) /* and normal return code*/
      ;
      return; /* Return to previous process*/
    end
    ;
  end
  ;
   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/
  ;
  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/
  ;
  FB0JM010.XXXMODID = "114"; /* Module identification*/
  ;
  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/
    ;
    converseLib.validationFailed(19); /* 'Resources unavailable'*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
    ;
  else
    ;
    converseLib.validationFailed(01); /* 'Error - Please nofity programming'*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    ;
    converseLib.clearScreen();
     /* Clear screen before display*/
    ;
  end
  ;
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "IO TO OPEN DFBUY.VSELDT01";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FB0JM010.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFBUY   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VSELDT01"; /* Table view name*/
  TA1REC.TA1TBLKE = FB5REC.FB5KEY; /* Table key*/
  ;
  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/
  ;
  ;
  ;
  ;
end // end FB0J114

// Select next vseldt01 row
Function FB0J116()
   /* ------------------------------------------------------------*/
   /* Select the next row to display from the table.*/
   /* ------------------------------------------------------------*/
  ;
  try
    call "IO3040" ("N1", SQLCA, FB5REC) {isNoRefresh = yes, isExternal = yes};
  end /* Fetch next row*/
  ;
   /* ------------------------------------------------------------*/
   /* If successful, return to previous process.*/
   /* ------------------------------------------------------------*/
  ;
  if (sysVar.errorCode == "00000000") /* Call successful*/
    ;
    if (SQLCA.VAGen_SQLCODE == 0) /* Normal return code*/
      ;
      XX0XW01.XX0XWDAT = FB5REC.FB5FRMDT;
      FB0JM010.FB0JMYY1 = XX0XW01.XX0XWYY;
      FB0JM010.FB0JMMM1 = XX0XW01.XX0XWMM;
      XX0XW01.XX0XWDAT = FB5REC.FB5TODT;
      FB0JM010.FB0JMYY2 = XX0XW01.XX0XWYY;
      FB0JM010.FB0JMMM2 = XX0XW01.XX0XWMM;
      return; /* Return to previous process*/
      ;
    end
    ;
    /* ------------------------------------------------------------*/
     /* If end of selected set, indicate end of cursor.*/
    /* ------------------------------------------------------------*/
    ;
    if (SQLCA.VAGen_SQLCODE == 100) /* End of selected set*/
      converseLib.validationFailed(22); /* No data to display*/
      ;
      return; /* Return to previous process*/
      ;
    end
    ;
  end
  ;
   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/
  ;
  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/
  ;
  FB0JM010.XXXMODID = "116"; /* Module identification*/
  ;
  if (SQLCA.VAGen_SQLCODE == -911) /* Resource not available*/
    ;
    converseLib.validationFailed(19); /* 'resources unavailable'*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
    ;
  else
    ;
    converseLib.validationFailed(01); /* 'error - please nofity programming'*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    ;
    converseLib.clearScreen();
     /* Clear screen before display*/
    ;
  end
  ;
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "FETCH NEXT TABLE ROW";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FB0JM010.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFBUY   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VSELDT01"; /* Table view name*/
  TA1REC.TA1TBLKE = FB5REC.FB5KEY; /* Table key*/
  ;
  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/
  ;
  ;
  ;
end // end FB0J116

// Close set vseldt01
Function FB0J118()
   /* ------------------------------------------------------------*/
   /* Close the selected set of table rows for vseldt01*/
   /* ------------------------------------------------------------*/
  ;
  try
    call "IO3040" ("C1", SQLCA, FB5REC) {isNoRefresh = yes, isExternal = yes};
  end /* Close table set*/
  ;
   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/
  ;
  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/
    ;
    return; /* Return to previous process*/
    ;
  end
  ;
   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/
  ;
  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/
  ;
  FB0JM010.XXXMODID = "118"; /* Module identification*/
  converseLib.validationFailed(01); /* 'Error - Please nofity programming'*/
  ;
  TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "CLOSE VSELDT01 TABLE ROWS";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FB0JM010.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFBUY    "; /* Data base name*/
  TA1REC.TA1TBLVU = "VSELDT01"; /* Table view name*/
  ;
  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/
  ;
  ;
  ;
end // end FB0J118

// Get product description
Function FB0J130()
  ;
  ;
  if (converseVar.validationMsgNum == 32) /* Update successful*/
    return; /* No need to get header*/
  end /* data a second time*/
  ;
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Clear row storage areas, format the key*/
   /* ------------------------------------------------------------*/
  ;
  ;
  set PG2REC empty; /* Clear row storage area*/
  ;
  FB0JM010.SY1STNBR = FBWREC.SY1STNBR; /* Style*/
  FB0JM010.SY2CLRID = FBWREC.SY2CLRID; /* Color*/
  FB0JM010.XDMCD = FBWREC.XDMCD; /* Dimension*/
  PG2REC.XGPCD = FBWREC.XGPCD; /* GPC*/
  PG2REC.SY1STNBR = FBWREC.SY1STNBR; /* Style*/
  PG2REC.SY2CLRID = FBWREC.SY2CLRID; /* Color*/
  PG2REC.XDMCD = FBWREC.XDMCD; /* Dimension*/
  FB0JM010.XXXMODID = "130"; /* Module identification*/
  ;
  XSPG202(); /* Get style and color descriptions*/
  ;
  if (sysVar.errorCode == "00000000") /* Call successful*/
    ;
    if (SQLCA.VAGen_SQLCODE == 0) /* Normal return code*/
      ;
      FB0JM010.SY1STYNM = PG2REC.SY1STYNM; /* Style description*/
      FB0JM010.SY2CLRAB = PG2REC.SY2CLRAB; /* Color description*/
      ;
      FB0JW01.XDVCD = PG2REC.XDVCD1; /* save div for size lookup*/
      ;
    end
  end
end // end FB0J130

// Get product curve
Function FB0J140()
   /* ------------------------------------------------------------*/
  ;
   /* This process will do a select set on vcurve01,*/
   /* then do a select next until end of set and finally*/
   /* close the set.  A not found on the select next will be*/
   /* fatal.*/
   /* ------------------------------------------------------------*/
  ;
  ;
  ;
  set SQLCA empty; /* To set sqlcode to zero*/
  ;
  FB0J142(); /* Select set vcurve01*/
  ;
  FB0JW01.FB0JWWHS = 0; /* Warehouse count*/
  while (SQLCA.VAGen_SQLCODE == 0 /* Good return code*/
   && FB0JW01.FB0JWWHS < FB0JW01.FB0JWMAX) /* whse cnt < or = max whse*/
    FB0J144(); /* Select next vcurve01 row*/
  end
  ;
  if (SQLCA.VAGen_SQLCODE == 0 /* Good return code*/
   || SQLCA.VAGen_SQLCODE == 100) /* End of cursor*/
    FB0J146(); /* Close set vcurve01*/
  else
    return;
  end
  ;
  set PG3REC empty;
  ;
  PG3REC.PG3XDVCD = FB0JW01.XDVCD; /* division code*/
  ;
  PG3REC.XGPCD = FBWREC.XGPCD;
  PG3REC.SY1STNBR = FBWREC.SY1STNBR;
  PG3REC.SY2CLRID = FBWREC.SY2CLRID;
  PG3REC.XDMCD = FBWREC.XDMCD;
  PG3REC.XQACD = FBWREC.XQACD;
  PG3REC.PG3FUNCD = "PC";
  PG3REC.PG3DATFM = "N";
  ;
  ;
  XSPG301(); /* Get valid sizes*/
  ;
  ;
  FB0J147(); /* Find the map display offset*/
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Move the valid sizes to the map.*/
   /* If no valid sizes, display error message to user*/
   /* ------------------------------------------------------------*/
  ;
  FB0JW01.FB0JWIX1 = 1; /* General index 1*/
  FB0JW01.FB0JWSFS = "N"; /* initialize size found switch*/
  ;
  while (FB0JW01.FB0JWIX2 <= 40) /* Max mbr of sizes*/
    FB0JM010.SY4IDDSC[FB0JWIX1] = PG3REC.SY4IDDSC[FB0JWIX2];
    if (PG3REC.SY4IDDSC[FB0JWIX2] != " ") /* size desc present*/
      FB0JW01.FB0JWSFS = "Y"; /* set size found switch*/
    end
    FB0JW01.FB0JWIX1 = FB0JW01.FB0JWIX1 + 1; /* increment size index*/
    FB0JW01.FB0JWIX2 = FB0JW01.FB0JWIX2 + 1; /* increment offset sz index*/
  end
  ;
  if (FB0JW01.FB0JWSFS == "N") /* no valid sizes found*/
    FB0JW01.FB0JWDSW = " "; /* set display data switch to space*/
    converseLib.validationFailed(78); /* no valid sizes only pf1, pf3, pf4 valid*/
    FB0JM010.XXXMODID = "140"; /* module identification*/
    exit stack;
  end
  ;
  ;
  ;
  if (FB0JW01.FB0JWCUR == " " /* no warehouse code stored move 1st*/
   /* whse*/
   || FB0JW01.FB0JWCUR == FB0JW03.XWHCD) /* move first warehouse*/
    FB0J148(); /* Move pct & qty to map*/
  else
    FB0J149(); /* move pct & qty to map*/
  end
  ;
  ;
  ;
  FB0J143(); /* Highlight invalid qtys & percent*/
  ;
  ;
  ;
  FB0J145(); /* calc total percent & variance*/
  ;
  ;
  ;
  ;
  ;
  if (converseVar.validationMsgNum == 0 /* Good return code*/
   || converseVar.validationMsgNum == 32) /* Update successful*/
    FB0JW01.FB0JWIX1 = 40; /* General index 1*/
    while (FB0JW01.FB0JWIX1 >= 1) /* Looping from the bottom up*/
      if (FB0JM010.FB4SZPCT[FB0JWIX1] != 0 /* Size percent*/
       || FB0JM010.FB4DMQTY[FB0JWIX1] != 0 /* Demand quantity*/
       || FB0JM010.SY4IDDSC[FB0JWIX1] != "     ") /* Size description*/
        set FB0JM010.FB4SZPCT[FB0JWIX1] cursor; /* Size percent*/
      end
      FB0JW01.FB0JWIX1 = FB0JW01.FB0JWIX1 - 1; /* decrement size index*/
    end
  end
  ;
  ;
  ;
  ;
  if (FB0JM010.FB0JMTPR != 100) /* Total percent*/
    FB0JM010.XXXMODID = "140"; /* Module identification*/
    if (converseVar.eventKey is pf9)
      converseLib.validationFailed(45); /* total percent must equal 100 for update*/
    else
      converseLib.validationFailed(159); /* total percent must equal 100*/
    end
  end
  ;
  ;
end // end FB0J140

// Get warehouse description
Function FB0J141()
  ;
  FB0JW01.FB0JWCUR = FB0JM010.XWHCD; /* Current warehouse*/
  if (FB0JM010.XWHCD in XWHTBL.XWHCD)
    FB0JM010.XWHABRV = XWHTBL.XWHABRV[sysVar.arrayIndex];
  end
  ;
  if (sysVar.arrayIndex == 0) /* Table entry not found*/
    FB0JM010.XWHABRV = " ";
    set FB0JM010.XWHCD cursor, modified, bold;
    FB0JM010.XXXMODID = "14A"; /* module identification*/
    converseLib.validationFailed(10); /* Indicate invalid warehouse*/
    return; /* Return to caller*/
    ;
  end
  ;
  if (XWHTBL.XXXSTAT[sysVar.arrayIndex] != "A") /* Not active warehouse status*/
    FB0JM010.XWHABRV = " ";
    ;
    set FB0JM010.XWHCD cursor, modified, bold;
    FB0JM010.XXXMODID = "14A"; /* module identification*/
    converseLib.validationFailed(9); /* Indicate inactive warehouse*/
    return; /* Return to caller*/
    ;
  end
  ;
  ;
end // end FB0J141

// Select set vcurve01
Function FB0J142()
   /* ------------------------------------------------------------*/
   /* Initialize the storage areas and indicators to be used*/
   /* ------------------------------------------------------------*/
  ;
  set FB4REC empty; /* clear row storage area*/
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Format the key with saved sequence number from fbwrec.*/
   /* ------------------------------------------------------------*/
  ;
  FB4REC.FB1INSEQ = FBWREC.FB1INSEQ;
  FB4REC.XGPCD = FBWREC.XGPCD; /* product group code*/
  FB4REC.SY1STNBR = FBWREC.SY1STNBR; /* style number*/
  FB4REC.SY2CLRID = FBWREC.SY2CLRID; /* color*/
  FB4REC.XDMCD = FBWREC.XDMCD; /* dimension*/
  FB4REC.XQACD = FBWREC.XQACD; /* quality code*/
  FB4REC.PC2INSEG = FBWREC.PC2INSEG; /* spec difference*/
  FB4REC.XSACD = FBWREC.XSACD; /* shade*/
  FB4REC.XPGCD = FBWREC.XPGCD; /* package type*/
  FB4REC.XUMCD = FBWREC.XUMCD; /* unit of measure*/
  ;
  FB4REC.FB4CRVNB = FBWREC.FB4CRVNB; /* curve number*/
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Select the requested set of rows from the table.*/
   /* ------------------------------------------------------------*/
  ;
  try
    call "IO3020" ("S2", SQLCA, FB4REC) {isNoRefresh = yes, isExternal = yes};
  end /* Select table set*/
  ;
   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/
  ;
  if (sysVar.errorCode == "00000000") /* Call successful*/
    if (SQLCA.VAGen_SQLCODE == 0) /* and normal return code*/
      ;
      return; /* Return to previous process*/
    end
    ;
  end
  ;
   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/
  ;
  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/
  ;
  FB0JM010.XXXMODID = "142"; /* Module identification*/
  ;
  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/
    ;
    converseLib.validationFailed(19); /* 'Resources unavailable'*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
    ;
  else
    ;
    converseLib.validationFailed(01); /* 'Error - Please nofity programming'*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    ;
    converseLib.clearScreen();
     /* Clear screen before display*/
    ;
  end
  ;
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "IO TO OPEN DFBUY.VCURVE01";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FB0JM010.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFBUY   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCURVE01"; /* Table view name*/
  TA1REC.TA1TBLKE = FB4REC.FB4KEY; /* Table key*/
  ;
  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/
  ;
  ;
  ;
  ;
end // end FB0J142

// Highlight invalid qty & pct
Function FB0J143()
   /* ------------------------------------------------------------*/
   /* Highlight invalid percents and quantities.*/
   /* ------------------------------------------------------------*/
  ;
  ;
  ;
  if (FB0JW01.FB0JWCUR == FB0JW03.XWHCD) /* if 1st whse displayed*/
    FB0JW01.FB4QTYLK = FB0JW03.FB4QTYLK; /* Quantity lock flag*/
  end
  if (FB0JW01.FB0JWCUR == FB0JW04.XWHCD) /* if 2nd whse displayed*/
    FB0JW01.FB4QTYLK = FB0JW04.FB4QTYLK; /* Quantity lock flag*/
  end
  if (FB0JW01.FB0JWCUR == FB0JW05.XWHCD) /* if 3rd whse displayed*/
    FB0JW01.FB4QTYLK = FB0JW05.FB4QTYLK; /* Quantity lock flag*/
  end
  ;
  ;
  FB0JW01.FB0JWIX1 = 40; /* General index 1*/
  while (FB0JW01.FB0JWIX1 >= 1) /* Looping from the bottom up*/
    FB0JW01.FB0JWSZP = "N"; /* Size percent error switch*/
    FB0JW01.FB0JWSZQ = "N"; /* Size quantity error switch*/
    if (FB0JW01.FB4QTYLK != "Y")
      if (FB0JM010.FB4DMQTY[FB0JWIX1] != 0 /* Quantity exists*/
       && FB0JM010.SY4IDDSC[FB0JWIX1] == " ") /* for an invalid size*/
        FB0JW01.FB0JWSZQ = "Y"; /* Size quantity error switch*/
        converseLib.validationFailed(49); /* Quantity exists for an invalid size*/
      end
      if (FB0JM010.FB4DMQTY[FB0JWIX1] == 0   /* No quantity*/
       && FB0JM010.SY4IDDSC[FB0JWIX1] != " " /* Size is valid*/
       && FB0JW01.FB0JWPSW != "DU")          /* Not display user curve*/
        FB0JW01.FB0JWSZQ = "Y"; /* Size quantity error switch*/
        if (converseVar.validationMsgNum == 32 /* Update successful*/
         || converseVar.validationMsgNum == 68 /* Updated*/
         || converseVar.validationMsgNum == 67) /* Updated*/
          converseLib.validationFailed(68); /* updated -  No qty for a valid size*/
        else
          converseLib.validationFailed(50); /* No quantity for a valid size*/
        end
      end
    end
    if (FB0JM010.FB4SZPCT[FB0JWIX1] != 0 /* Percent exists*/
     && FB0JM010.SY4IDDSC[FB0JWIX1] == " ") /* for an invalid size*/
      FB0JW01.FB0JWSZP = "Y"; /* Size percent error switch*/
      converseLib.validationFailed(51); /* Percent exists for an invalid size*/
    end
    if (FB0JM010.FB4SZPCT[FB0JWIX1] == 0   /* No percent*/
     && FB0JM010.SY4IDDSC[FB0JWIX1] != " " /* Size is valid*/
     && FB0JW01.FB0JWPSW != "DU")          /* Not display user curve*/
      FB0JW01.FB0JWSZP = "Y"; /* Size percent error switch*/
      ;
      if (converseVar.validationMsgNum == 32 /* Update successful*/
       || converseVar.validationMsgNum == 68 /* Updated*/
       || converseVar.validationMsgNum == 67) /* Updated*/
        converseLib.validationFailed(67); /* updated -  No % for a valid size*/
      else
        converseLib.validationFailed(52); /* No percent for a valid size*/
      end
    end
    /* ------------------------------------------------------------*/
     /* Highlight errors, Protect fields in other two columns*/
    /* ------------------------------------------------------------*/
    if (FB0JW01.FB0JWUNP == 1) /* Column to unprotect*/
      if (FB0JW01.FB0JWIX1 > 14)
        if (FB0JW01.FB0JWSZP == "Y") /* Size percent error switch*/
          set FB0JM010.FB4SZPCT[FB0JWIX1] protect, bold;
        else
          set FB0JM010.FB4SZPCT[FB0JWIX1] protect; /* Size percent*/
        end
        if (FB0JW01.FB0JWSZQ == "Y") /* Size quantity error switch*/
          set FB0JM010.FB4DMQTY[FB0JWIX1] protect, bold;
        else
          set FB0JM010.FB4DMQTY[FB0JWIX1] protect; /* Size quantity*/
        end
      else
        if (FB0JW01.FB0JWSZQ == "Y") /* Size quantity error switch*/
          set FB0JM010.FB4DMQTY[FB0JWIX1] cursor, modified, bold;
        else
          if (FB0JW01.FB4QTYLK == "Y") /* Size quantity lock switch*/
            set FB0JM010.FB4DMQTY[FB0JWIX1] protect;
          end
        end
        if (FB0JW01.FB0JWSZP == "Y") /* Size percent error switch*/
          set FB0JM010.FB4SZPCT[FB0JWIX1] cursor, modified, bold;
        end
      end
    end
    ;
    if (FB0JW01.FB0JWUNP == 2) /* Column to unprotect*/
      if (FB0JW01.FB0JWIX1 <= 14
       || FB0JW01.FB0JWIX1 > 28)
        if (FB0JW01.FB0JWSZP == "Y") /* Size percent error switch*/
          set FB0JM010.FB4SZPCT[FB0JWIX1] protect, bold;
        else
          set FB0JM010.FB4SZPCT[FB0JWIX1] protect; /* Size percent*/
        end
        if (FB0JW01.FB0JWSZQ == "Y") /* Size quantity error switch*/
          set FB0JM010.FB4DMQTY[FB0JWIX1] protect, bold;
        else
          set FB0JM010.FB4DMQTY[FB0JWIX1] protect; /* Size quantity*/
        end
      else
        if (FB0JW01.FB0JWSZQ == "Y") /* Size quantity error switch*/
          set FB0JM010.FB4DMQTY[FB0JWIX1] cursor, modified, bold;
        else
          if (FB0JW01.FB4QTYLK == "Y") /* Size quantity lock switch*/
            set FB0JM010.FB4DMQTY[FB0JWIX1] protect;
          end
        end
        if (FB0JW01.FB0JWSZP == "Y") /* Size percent error switch*/
          set FB0JM010.FB4SZPCT[FB0JWIX1] cursor, modified, bold;
        end
      end
    end
    ;
    if (FB0JW01.FB0JWUNP == 3) /* Column to unprotect*/
      if (FB0JW01.FB0JWIX1 <= 28)
        if (FB0JW01.FB0JWSZP == "Y") /* Size percent error switch*/
          set FB0JM010.FB4SZPCT[FB0JWIX1] protect, bold;
        else
          set FB0JM010.FB4SZPCT[FB0JWIX1] protect; /* Size percent*/
        end
        if (FB0JW01.FB0JWSZQ == "Y") /* Size quantity error switch*/
          set FB0JM010.FB4DMQTY[FB0JWIX1] protect, bold;
        else
          set FB0JM010.FB4DMQTY[FB0JWIX1] protect; /* Size quantity*/
        end
      else
        if (FB0JW01.FB0JWSZQ == "Y") /* Size quantity error switch*/
          set FB0JM010.FB4DMQTY[FB0JWIX1] cursor, modified, bold;
        else
          if (FB0JW01.FB4QTYLK == "Y") /* Size quantity lock switch*/
            set FB0JM010.FB4DMQTY[FB0JWIX1] protect;
          end
        end
        if (FB0JW01.FB0JWSZP == "Y") /* Size percent error switch*/
          set FB0JM010.FB4SZPCT[FB0JWIX1] cursor, modified, bold;
        end
      end
    end
    ;
    /* ------------------------------------------------------------*/
     /* Darken map where no data is displayed*/
    /* ------------------------------------------------------------*/
    ;
    if (FB0JM010.SY4IDDSC[FB0JWIX1] == " " /* no size description*/
     && FB0JM010.FB4SZPCT[FB0JWIX1] == 0   /* no size percent*/
     && FB0JM010.FB4DMQTY[FB0JWIX1] == 0)  /* no size quantity*/
      set FB0JM010.FB4SZPCT[FB0JWIX1] protect, invisible; /* protect percent*/
      set FB0JM010.FB4DMQTY[FB0JWIX1] protect, invisible; /* protect quantity*/
    end
    ;
    FB0JW01.FB0JWIX1 = FB0JW01.FB0JWIX1 - 1; /* decrement size index*/
  end
end // end FB0J143

// Get next vcurve01 row
Function FB0J144()
   /* ------------------------------------------------------------*/
   /* Select the next row to display from the table.*/
   /* ------------------------------------------------------------*/
  ;
  try
    call "IO3020" ("N2", SQLCA, FB4REC) {isNoRefresh = yes, isExternal = yes};
  end /* Fetch next row*/
  ;
   /* ------------------------------------------------------------*/
   /* If successful, move record to working storage*/
                  /* return to previous process.*/
   /* ------------------------------------------------------------*/
  ;
  if (sysVar.errorCode == "00000000") /* Call successful*/
    ;
    if (SQLCA.VAGen_SQLCODE == 100) /* End of cursor*/
      return;
    end
    ;
    if (SQLCA.VAGen_SQLCODE == 0) /* Normal return code*/
      ;
      FB0JW01.FB0JWIX1 = 1; /* General index 1*/
      if (FB0JW01.FB0JWWHS == 0) /* Warehouse count*/
        FB0JW01.FB0JWWHS = FB0JW01.FB0JWWHS + 1; /* increment whse count*/
        FB0JW03.XWHCD = FB4REC.XWHCD; /* Warehouse code*/
        FB0JW03.FB4RGPCT = FB4REC.FB4RGPCT; /* Region percent*/
        FB0JW03.FB4STDFL = FB4REC.FB4STDFL; /* Standard curve flag*/
        FB0JW03.FB4QTYLK = FB4REC.FB4QTYLK;
                                   /* Protect quantities flag*/
        FB0JW03.FB4CRVNB = FB4REC.FB4CRVNB; /* Curve number*/
        FB0JW03.ZZZCHGCT = FB4REC.ZZZCHGCT; /* Change count*/
        FB0JW03.ZZZSDT = FB4REC.ZZZSDT; /* Setup date*/
        while (FB0JW01.FB0JWIX1 <= 40) /* Max mbr of sizes*/
          FB0JW03.FB4DMQTY[FB0JWIX1] = FB4REC.FB4DMQTY[FB0JWIX1];
          FB0JW03.FB4SZPCT[FB0JWIX1] = FB4REC.FB4SZPCT[FB0JWIX1];
          FB0JW01.FB0JWIX1 = FB0JW01.FB0JWIX1 + 1; /* increment size index*/
        end
        return; /* Return to previous process*/
      else
        if (FB0JW01.FB0JWWHS == 1) /* Warehouse count*/
          FB0JW01.FB0JWWHS = FB0JW01.FB0JWWHS + 1; /* increment whse count*/
          FB0JW04.XWHCD = FB4REC.XWHCD; /* Warehouse code*/
          FB0JW04.FB4RGPCT = FB4REC.FB4RGPCT; /* Region percent*/
          FB0JW04.FB4STDFL = FB4REC.FB4STDFL; /* Standard curve flag*/
          FB0JW04.FB4QTYLK = FB4REC.FB4QTYLK; /* Protect quantities flag*/
          FB0JW04.FB4CRVNB = FB4REC.FB4CRVNB; /* Curve number*/
          FB0JW04.ZZZCHGCT = FB4REC.ZZZCHGCT; /* Change count*/
          FB0JW04.ZZZSDT = FB4REC.ZZZSDT; /* Setup date*/
          while (FB0JW01.FB0JWIX1 <= 40) /* Max mbr of sizes*/
            FB0JW04.FB4DMQTY[FB0JWIX1] = FB4REC.FB4DMQTY[FB0JWIX1];
            FB0JW04.FB4SZPCT[FB0JWIX1] = FB4REC.FB4SZPCT[FB0JWIX1];
            FB0JW01.FB0JWIX1 = FB0JW01.FB0JWIX1 + 1;
                                   /* increment size index*/
          end
          return; /* Return to previous process*/
        else
          if (FB0JW01.FB0JWWHS == 2) /* Warehouse count*/
            FB0JW01.FB0JWWHS = FB0JW01.FB0JWWHS + 1;
                                   /* increment whse count*/
            FB0JW05.XWHCD = FB4REC.XWHCD; /* Warehouse code*/
            FB0JW05.FB4RGPCT = FB4REC.FB4RGPCT; /* Region percent*/
            FB0JW05.FB4STDFL = FB4REC.FB4STDFL;
                                   /* Standard curve flag*/
            FB0JW05.FB4QTYLK = FB4REC.FB4QTYLK; /* Protect quantities flag*/
            FB0JW05.FB4CRVNB = FB4REC.FB4CRVNB; /* Curve number*/
            FB0JW05.ZZZCHGCT = FB4REC.ZZZCHGCT; /* Change count*/
            FB0JW05.ZZZSDT = FB4REC.ZZZSDT; /* Setup date*/
            while (FB0JW01.FB0JWIX1 <= 40) /* Max mbr of sizes*/
              FB0JW05.FB4DMQTY[FB0JWIX1] = FB4REC.FB4DMQTY[FB0JWIX1];
              FB0JW05.FB4SZPCT[FB0JWIX1] = FB4REC.FB4SZPCT[FB0JWIX1];
              FB0JW01.FB0JWIX1 = FB0JW01.FB0JWIX1 + 1; /* increment size index*/
            end
            return; /* Return to previous process*/
          else
             /* next sentence*/
          end
        end
      end
    end
    ;
    ;
  end
  ;
   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/
  ;
  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/
  ;
  FB0JM010.XXXMODID = "144"; /* Module identification*/
  ;
  if (SQLCA.VAGen_SQLCODE == -911) /* Resource not available*/
    ;
    converseLib.validationFailed(19); /* 'resources unavailable'*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
    ;
  else
    ;
    converseLib.validationFailed(01); /* 'error - please nofity programming'*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    ;
    converseLib.clearScreen();
     /* Clear screen before display*/
    ;
  end
  ;
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "FETCH NEXT TABLE ROW";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FB0JM010.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFBUY  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCURVE01"; /* Table view name*/
  TA1REC.TA1TBLKE = FB4REC.FB4KEY; /* Table key*/
  ;
  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/
  ;
  ;
  ;
end // end FB0J144

// Calculate total & variance
Function FB0J145()
   /* ------------------------------------------------------------*/
   /* Calculate total percent and variance.*/
   /* ------------------------------------------------------------*/
  FB0JW01.FB0JWIX1 = 1; /* General index 1*/
  FB0JM010.FB0JMTPR = 0; /* Total percent*/
  FB0JM010.FB0JMTQT = 0; /* Total quantity*/
  FB0JM010.FB0JMVAR = 0; /* Variance*/
  while (FB0JW01.FB0JWIX1 <= 40) /* Max mbr of sizes*/
    FB0JM010.FB0JMTPR = FB0JM010.FB0JMTPR + FB0JM010.FB4SZPCT[FB0JWIX1];
    FB0JM010.FB0JMTQT = FB0JM010.FB0JMTQT + FB0JM010.FB4DMQTY[FB0JWIX1];
    FB0JW01.FB0JWIX1 = FB0JW01.FB0JWIX1 + 1; /* increment size index*/
  end
  ;
  FB0JM010.FB0JMVAR = FB0JM010.FB0JMTPR - 100;
  ;
  ;
  ;
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Calculate total quantity for all regions*/
   /* ------------------------------------------------------------*/
  FB0JM010.FB0JMGTQ = FB0JM010.FB0JMTQT; /* move map total to total*/
  ;
  FB0JW01.FB0JWIX1 = 1; /* General index 1*/
  ;
  while (FB0JW01.FB0JWIX1 <= 40) /* Max mbr of sizes*/
    if (FB0JW01.FB0JWCUR == FB0JW03.XWHCD) /* if 1st whse displayed*/
      FB0JM010.FB0JMGTQ = FB0JM010.FB0JMGTQ + FB0JW04.FB4DMQTY[FB0JWIX1];
      FB0JM010.FB0JMGTQ = FB0JM010.FB0JMGTQ + FB0JW05.FB4DMQTY[FB0JWIX1];
    end
    if (FB0JW01.FB0JWCUR == FB0JW04.XWHCD) /* if 2nd whse displayed*/
      FB0JM010.FB0JMGTQ = FB0JM010.FB0JMGTQ + FB0JW03.FB4DMQTY[FB0JWIX1];
      FB0JM010.FB0JMGTQ = FB0JM010.FB0JMGTQ + FB0JW05.FB4DMQTY[FB0JWIX1];
    end
    if (FB0JW01.FB0JWCUR == FB0JW05.XWHCD) /* if 3rd whse displayed*/
      FB0JM010.FB0JMGTQ = FB0JM010.FB0JMGTQ + FB0JW03.FB4DMQTY[FB0JWIX1];
      FB0JM010.FB0JMGTQ = FB0JM010.FB0JMGTQ + FB0JW04.FB4DMQTY[FB0JWIX1];
    end
    FB0JW01.FB0JWIX1 = FB0JW01.FB0JWIX1 + 1; /* increment size index*/
  end
end // end FB0J145

// Close set vcurve01
Function FB0J146()
   /* ------------------------------------------------------------*/
   /* Close the selected set of table rows for vcurve01*/
   /* ------------------------------------------------------------*/
  ;
  try
    call "IO3020" ("C2", SQLCA, FB4REC) {isNoRefresh = yes, isExternal = yes};
  end /* Close table set*/
  ;
   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/
  ;
  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/
    ;
    return; /* Return to previous process*/
    ;
  end
  ;
   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/
  ;
  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/
  ;
  FB0JM010.XXXMODID = "146"; /* Module identification*/
  converseLib.validationFailed(01); /* 'Error - Please nofity programming'*/
  ;
  TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "CLOSE VCURVE01 TABLE ROWS";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FB0JM010.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFBUY   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCURVE01"; /* Table view name*/
  ;
  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/
  ;
  ;
  ;
end // end FB0J146

// Find the map display offset
Function FB0J147()
   /* ------------------------------------------------------------*/
   /* This process will set the index before moving sizes to the*/
   /* map so that there is not a gap (empty size buckets) before*/
   /* the first size is displayed.*/
   /* ------------------------------------------------------------*/
  ;
  FB0JW01.FB0JWIX2 = 1; /* General index 2*/
  ;
  while (FB0JW01.FB0JWIX2 <= 40) /* Max mbr of sizes*/
    if (PG3REC.SY4IDDSC[FB0JWIX2] != " " /* size desc present*/
     || FB0JW03.FB4DMQTY[FB0JWIX2] != 0  /* damand qty - whs 1*/
     || FB0JW03.FB4SZPCT[FB0JWIX2] != 0  /* percent - whs 1*/
     || FB0JW04.FB4DMQTY[FB0JWIX2] != 0  /* damand qty - whs 2*/
     || FB0JW04.FB4SZPCT[FB0JWIX2] != 0  /* percent - whs 2*/
     || FB0JW05.FB4DMQTY[FB0JWIX2] != 0  /* damand qty - whs 3*/
     || FB0JW05.FB4SZPCT[FB0JWIX2] != 0) /* percent - whs 3*/
      FB0JW01.FB0JWOFF = FB0JW01.FB0JWIX2; /* size display offset*/
      return;
    end
    FB0JW01.FB0JWIX2 = FB0JW01.FB0JWIX2 + 1; /* increment offset sz index*/
  end
  ;
end // end FB0J147

// Move pcts & qtys to map
Function FB0J148()
   /* ------------------------------------------------------------*/
    /* The first warehouses curve will be moved to the map*/
   /* ------------------------------------------------------------*/
  ;
  FB0JW01.FB0JWIX1 = 1; /* General index 1*/
  FB0JW01.FB0JWIX2 = FB0JW01.FB0JWOFF; /* General index 2*/
  FB0JM010.XWHCD = FB0JW03.XWHCD; /* Warehouse code*/
  FB0JM010.FB4STDFL = FB0JW03.FB4STDFL; /* Standard curve flag*/
  ;
  ;
  if (FB0JW01.FB0JWPSW == "IU" /* invalid user curve*/
   || FB0JW01.FB0JWPSW == "DU" /* display user curve*/
   || FB0JM010.FB4STDFL == "Y") /* Standard curve flag*/
    set FB0JM010.FB4STDFL protect; /* Cannot change std-fl from 'y' to 'n'*/
  end
  ;
  if (FB0JW01.FB0JWPSW == "DP" /* display product curve*/
   || FB0JW01.FB0JWPSW == "IP") /* invalid product curve*/
    FB0JM010.FB4CRVNB = FB0JW03.FB4CRVNB; /* Curve number*/
  end
  ;
  FB0J141(); /* get warehouse description*/
  ;
  ;
  while (FB0JW01.FB0JWIX2 <= 40) /* Max mbr of sizes*/
    FB0JM010.FB4DMQTY[FB0JWIX1] = FB0JW03.FB4DMQTY[FB0JWIX2];
    FB0JM010.FB4SZPCT[FB0JWIX1] = FB0JW03.FB4SZPCT[FB0JWIX2];
    if (FB0JW03.FB4QTYLK == "Y")
      set FB0JM010.FB4DMQTY[FB0JWIX1] protect;
    end
    FB0JW01.FB0JWIX1 = FB0JW01.FB0JWIX1 + 1; /* increment size index*/
    FB0JW01.FB0JWIX2 = FB0JW01.FB0JWIX2 + 1; /* increment size offset index*/
  end
end // end FB0J148

// Get entered warehouse
Function FB0J149()
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Move the curve to the map for the warehouse entered*/
   /* ------------------------------------------------------------*/
  FB0JW01.FB0JWIX2 = FB0JW01.FB0JWOFF; /* size display offset*/
  if (FB0JM010.XWHCD == FB0JW04.XWHCD /* Warehouse code*/
   && FB0JM010.XWHCD != "  ")        
    FB0J141(); /* get warehouse description*/
    FB0JW01.FB0JWIX1 = 1; /* General index 1*/
    while (FB0JW01.FB0JWIX2 <= 40) /* Max mbr of sizes*/
      if (FB0JW04.FB4QTYLK == "Y")
        set FB0JM010.FB4DMQTY[FB0JWIX1] protect;
      else
        set FB0JM010.FB4DMQTY[FB0JWIX1] initialAttributes;
      end
      FB0JM010.FB4DMQTY[FB0JWIX1] = FB0JW04.FB4DMQTY[FB0JWIX2];
      FB0JM010.FB4SZPCT[FB0JWIX1] = FB0JW04.FB4SZPCT[FB0JWIX2];
      FB0JW01.FB0JWIX1 = FB0JW01.FB0JWIX1 + 1; /* increment size index*/
      FB0JW01.FB0JWIX2 = FB0JW01.FB0JWIX2 + 1; /* increment size offset index*/
    end
  else
    ;
    if (FB0JM010.XWHCD == FB0JW05.XWHCD /* Warehouse code*/
     && FB0JM010.XWHCD != "  ")        
      FB0J141(); /* get warehouse description*/
      FB0JW01.FB0JWIX1 = 1; /* General index 1*/
      while (FB0JW01.FB0JWIX2 <= 40) /* Max mbr of sizes*/
        if (FB0JW05.FB4QTYLK == "Y")
          set FB0JM010.FB4DMQTY[FB0JWIX1] protect;
        else
          set FB0JM010.FB4DMQTY[FB0JWIX1] initialAttributes;
        end
        FB0JM010.FB4DMQTY[FB0JWIX1] = FB0JW05.FB4DMQTY[FB0JWIX2];
        FB0JM010.FB4SZPCT[FB0JWIX1] = FB0JW05.FB4SZPCT[FB0JWIX2];
        FB0JW01.FB0JWIX1 = FB0JW01.FB0JWIX1 + 1; /* increment size index*/
        FB0JW01.FB0JWIX2 = FB0JW01.FB0JWIX2 + 1; /* increment size offset index*/
      end
    else
      converseLib.validationFailed(18); /* Indicate invalid warehouse*/
      set FB0JM010.XWHCD cursor, modified, bold;
      FB0JM010.XXXMODID = "149"; /* module identification*/
      return; /* Return to caller*/
    end
  end
  ;
  ;
end // end FB0J149

// Edit assigned to product crv
Function FB0J150()
   /* ------------------------------------------------------------*/
   /* In this case we have come from fb0e (assign to products)*/
   /* which tries to assign the curve to a product.  Size in the*/
   /* curve were invalid for the product.  The curve will be*/
   /* edited/maintenanced using sizes from the assigned to*/
   /* product.  Ultimately,  control will be passed back to fb0e,*/
   /* along with updated curves in fbwrec.*/
   /* ------------------------------------------------------------*/
  ;
  ;
  FB0JW03.FB0JWGRP = FB0JW02.FB0JWGP1; /* working storage 1st whse*/
  if (FB0JW03.XWHCD != " ") /* Passed curve for 1st warehouse*/
    FB0JW01.FB0JWWHS = 1; /* warehouse count*/
    FB0JM010.XWHCD = FB0JW03.XWHCD; /* Warehouse code*/
    FB0J141(); /* get warehouse description*/
  end
  ;
  ;
  FB0JW04.FB0JWGRP = FB0JW02.FB0JWGP2; /* working storage 2nd whse*/
  if (FB0JW04.XWHCD != " ") /* Passed curve for 2nd warehouse*/
    FB0JW01.FB0JWWHS = 2; /* warehouse count*/
  end
  ;
  ;
  FB0JW05.FB0JWGRP = FB0JW02.FB0JWGP3; /* working storage 3nd whse*/
  if (FB0JW05.XWHCD != " ") /* Passed curve for 3rd warehouse*/
    FB0JW01.FB0JWWHS = 3; /* warehouse count*/
  end
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Obtain the division code for the product passed from*/
   /* FB0E*/
   /* ------------------------------------------------------------*/
  ;
  set PG2REC empty; /* Clear row storage area*/
  ;
  PG2REC.XGPCD = COMMAREA.XGPCD;
  PG2REC.SY1STNBR = FB0JW02.SY1STNBR[1];
  PG2REC.SY2CLRID = FB0JW02.SY2CLRID[1];
  PG2REC.XDMCD = FB0JW02.XDMCD[1];
  ;
  XSPG202(); /* Get style and color descriptions*/
  ;
  if (sysVar.errorCode == "00000000") /* Call successful*/
    ;
    if (SQLCA.VAGen_SQLCODE == 0) /* Normal return code*/
      ;
      FB0JW01.XDVCD = PG2REC.XDVCD1; /* save div for size lookup*/
      ;
    end
  end
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Obtain the size description for the product passed from*/
   /* FB0E*/
   /* ------------------------------------------------------------*/
  ;
  set PG3REC empty;
  PG3REC.XGPCD = COMMAREA.XGPCD;
  PG3REC.SY1STNBR = FB0JW02.SY1STNBR[1];
  PG3REC.SY2CLRID = FB0JW02.SY2CLRID[1];
  PG3REC.XDMCD = FB0JW02.XDMCD[1];
  ;
  PG3REC.PG3XDVCD = FB0JW01.XDVCD; /* division code*/
  ;
   /* ------------------------------------------------------------*/
   /* Default quality code to 0*/
   /* ------------------------------------------------------------*/
  ;
  PG3REC.XQACD = "01";
  PG3REC.PG3FUNCD = "PC";
  PG3REC.PG3DATFM = "N";
  ;
  ;
  XSPG301(); /* Get valid sizes*/
  ;
  ;
  FB0J147(); /* Find the map display offset*/
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Move the valid sizes to the map.*/
   /* ------------------------------------------------------------*/
  FB0JW01.FB0JWIX1 = 1; /* General index 1*/
  while (FB0JW01.FB0JWIX2 <= 40) /* Max mbr of sizes*/
    FB0JM010.SY4IDDSC[FB0JWIX1] = PG3REC.SY4IDDSC[FB0JWIX2];
    FB0JW01.FB0JWIX1 = FB0JW01.FB0JWIX1 + 1; /* increment size index*/
    FB0JW01.FB0JWIX2 = FB0JW01.FB0JWIX2 + 1; /* increment offset sz index*/
  end
  ;
  ;
  ;
  FB0J148();
                                   /* Move percents & quantities to the map*/
  ;
  ;
  ;
  FB0J143(); /* Highlight invalid qtys & percent*/
  ;
  ;
  ;
  FB0J145(); /* calc total percent & variance*/
  ;
  ;
  ;
  ;
  if (converseVar.validationMsgNum == 0 /* Good return code*/
   || converseVar.validationMsgNum == 32) /* Update successful*/
    FB0JW01.FB0JWIX1 = 40; /* General index 1*/
    while (FB0JW01.FB0JWIX1 >= 1) /* Looping from the bottom up*/
      if (FB0JM010.FB4SZPCT[FB0JWIX1] != 0 /* Size percent*/
       || FB0JM010.FB4DMQTY[FB0JWIX1] != 0 /* Demand quantity*/
       || FB0JM010.SY4IDDSC[FB0JWIX1] != "     ") /* Size description*/
        set FB0JM010.FB4SZPCT[FB0JWIX1] cursor; /* Size percent*/
      end
      FB0JW01.FB0JWIX1 = FB0JW01.FB0JWIX1 - 1; /* decrement size index*/
    end
  end
  ;
  ;
  ;
  ;
  if (FB0JM010.FB0JMTPR != 100) /* Total percent*/
    FB0JM010.XXXMODID = "150"; /* Module identification*/
    if (converseVar.eventKey is pf9)
      converseLib.validationFailed(45); /* total percent must equal 100 for update*/
    else
      converseLib.validationFailed(159); /* total percent must equal 100*/
    end
  end
  ;
  ;
end // end FB0J150

// Get sizes using size scale cd
Function FB0J152()
   /* ------------------------------------------------------------*/
   /* Initialize the storage areas and record key*/
   /* ------------------------------------------------------------*/
  ;
  ;
  set SY4REC empty; /* Clear row storage area*/
  ;
  SY4REC.SY4SZSCL = FB1REC.SY4SZSCL; /* sy_sz_scl_cd*/
  ;
   /* ------------------------------------------------------------*/
   /* Select the requested row from the table.*/
   /* ------------------------------------------------------------*/
  ;
  try
    call "IO0040" ("S ", SQLCA, SY4REC) {isNoRefresh = yes, isExternal = yes};
  end /* Select table row*/
  ;
   /* ------------------------------------------------------------*/
   /* If successful, save the data in display storage and return*/
   /* to the previous process.*/
   /* ------------------------------------------------------------*/
  ;
  if (sysVar.errorCode == "00000000") /* Call successful*/
    ;
    if (SQLCA.VAGen_SQLCODE == 0) /* Normal return code*/
      ;
      return; /* Return to previous process*/
      ;
    end
    ;
  end
  ;
   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* if data not found abort the applicaton otherwiseindicated*/
   /* that a system error has occured*/
   /* ------------------------------------------------------------*/
  ;
  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/
  ;
  FB0JM010.XXXMODID = "152"; /* Module identification*/
  ;
  if (sysVar.errorCode == "00000000") /* Call successful*/
    if (SQLCA.VAGen_SQLCODE == -911) /* Resource not available*/
      ;
      converseLib.validationFailed(19); /* 'Resources unavailabe'*/
      TA1REC.TA1FUNC = "POST"; /* Termination function*/
      ;
    else
      TA1REC.TA1FUNC = "RETN"; /* Termination function*/
      ;
      if (SQLCA.VAGen_SQLCODE == 100) /* Row not found*/
        converseLib.validationFailed(11); /* 'Record not on database'*/
      else
        converseLib.validationFailed(01); /* 'error - please notify programming'*/
      end
    end
    ;
  end
  ;
  converseLib.clearScreen();
   /* Clear screen before display*/
  ;
  ;
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "FETCH VSCALE01 ROW  ";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FB0JM010.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DPROD   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VSCALE01"; /* Table view name*/
  TA1REC.TA1TBLKE = SY4REC.SY4SZSCL; /* Table key*/
  ;
  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/
  ;
  ;
  ;
end // end FB0J152

// Get user curve
Function FB0J160()
   /* ------------------------------------------------------------*/
  ;
   /* This process will do a select set on vcurve01,*/
   /* then do a select next until end of set and finally*/
   /* close the set.  A not found on the select next will be*/
   /* fatal.*/
   /* ------------------------------------------------------------*/
  ;
  ;
  set SQLCA empty; /* To set sqlcode to zero*/
  ;
  FB0J142(); /* Select set vcurve01*/
  ;
  FB0JW01.FB0JWWHS = 0; /* Warehouse count*/
  while (SQLCA.VAGen_SQLCODE == 0 /* Good return code*/
   && FB0JW01.FB0JWWHS < FB0JW01.FB0JWMAX) /* whse cnt < or = max whse*/
    FB0J144(); /* Select next vcurve01 row*/
  end
  ;
  if (SQLCA.VAGen_SQLCODE == 0 /* Good return code*/
   || SQLCA.VAGen_SQLCODE == 100) /* End of cursor*/
    FB0J146(); /* Close set vcurve01*/
  else
    return;
  end
  ;
  ;
  ;
  FB0J152(); /* Get valid sizes using size scale*/
  ;
  ;
  FB0J147(); /* Find the map display offset*/
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Move the valid sizes to the map.*/
   /* ------------------------------------------------------------*/
  FB0JW01.FB0JWIX1 = 1; /* General index 1*/
  while (FB0JW01.FB0JWIX2 <= 40) /* Max mbr of sizes*/
    FB0JM010.SY4IDDSC[FB0JWIX1] = SY4REC.SY4IDDSC[FB0JWIX2];
    FB0JW01.FB0JWIX1 = FB0JW01.FB0JWIX1 + 1; /* increment size index*/
    FB0JW01.FB0JWIX2 = FB0JW01.FB0JWIX2 + 1; /* increment offset sz index*/
  end
  ;
  ;
  FB0J148(); /* Move pct & qty to map*/
  ;
  ;
  ;
  FB0J143(); /* Highlight invalid qtys & percent*/
  ;
  ;
  ;
  FB0J145(); /* calc total percent & variance*/
  ;
  ;
  ;
  ;
  if (converseVar.validationMsgNum == 0 /* Good return code*/
   || converseVar.validationMsgNum == 32) /* Update successful*/
    FB0JW01.FB0JWIX1 = 40; /* General index 1*/
    while (FB0JW01.FB0JWIX1 >= 1) /* Looping from the bottom up*/
      if (FB0JM010.FB4SZPCT[FB0JWIX1] != 0 /* Size percent*/
       || FB0JM010.FB4DMQTY[FB0JWIX1] != 0 /* Demand quantity*/
       || FB0JM010.SY4IDDSC[FB0JWIX1] != "     ") /* Size description*/
        set FB0JM010.FB4SZPCT[FB0JWIX1] cursor; /* Size percent*/
      end
      FB0JW01.FB0JWIX1 = FB0JW01.FB0JWIX1 - 1; /* decrement size index*/
    end
  end
  ;
  ;
  ;
  ;
  if (FB0JM010.FB0JMTPR != 100) /* Total percent*/
    FB0JM010.XXXMODID = "160"; /* Module identification*/
    if (converseVar.eventKey is pf9)
      converseLib.validationFailed(45); /* total percent must equal 100 for update*/
    else
      converseLib.validationFailed(159); /* total percent must equal 100*/
    end
  end
  ;
  ;
end // end FB0J160

// Calc total qty all regions
Function FB0J165()
  ;
  FB0JM010.FB0JMGTQ = 0; /* Total qty all regions*/
  ;
  FB0JW01.FB0JWIX1 = 1; /* General index 1*/
  ;
  while (FB0JW01.FB0JWIX1 <= 40) /* Max mbr of sizes*/
    FB0JM010.FB0JMGTQ = FB0JM010.FB0JMGTQ + FB0JW03.FB4DMQTY[FB0JWIX1];
    FB0JM010.FB0JMGTQ = FB0JM010.FB0JMGTQ + FB0JW04.FB4DMQTY[FB0JWIX1];
    FB0JM010.FB0JMGTQ = FB0JM010.FB0JMGTQ + FB0JW05.FB4DMQTY[FB0JWIX1];
    FB0JW01.FB0JWIX1 = FB0JW01.FB0JWIX1 + 1; /* increment size index*/
  end
end // end FB0J165

// Get next warehouse
Function FB0J170()
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Move the next warehouses curve to the map*/
   /* ------------------------------------------------------------*/
  ;
  FB0JW01.FB0JWIX2 = FB0JW01.FB0JWOFF; /* size display offset*/
  if (FB0JW01.FB0JWWHS == 3) /* warehouse count*/
    if (FB0JM010.XWHCD == FB0JW03.XWHCD) /* Warehouse code*/
      FB0JM010.XWHCD = FB0JW04.XWHCD; /* Warehouse code*/
      FB0J141(); /* get warehouse description*/
      FB0JW01.FB0JWIX1 = 1; /* General index 1*/
      while (FB0JW01.FB0JWIX2 <= 40) /* Max mbr of sizes*/
        if (FB0JW04.FB4QTYLK == "Y")
          set FB0JM010.FB4DMQTY[FB0JWIX1] protect;
        else
          set FB0JM010.FB4DMQTY[FB0JWIX1] initialAttributes;
        end
        FB0JM010.FB4DMQTY[FB0JWIX1] = FB0JW04.FB4DMQTY[FB0JWIX2];
        FB0JM010.FB4SZPCT[FB0JWIX1] = FB0JW04.FB4SZPCT[FB0JWIX2];
        FB0JW01.FB0JWIX1 = FB0JW01.FB0JWIX1 + 1; /* increment size index*/
        FB0JW01.FB0JWIX2 = FB0JW01.FB0JWIX2 + 1; /* increment size offset index*/
      end
    else
      if (FB0JM010.XWHCD == FB0JW04.XWHCD) /* Warehouse code*/
        FB0JM010.XWHCD = FB0JW05.XWHCD; /* Warehouse code*/
        FB0J141(); /* get warehouse description*/
        FB0JW01.FB0JWIX1 = 1; /* General index 1*/
        while (FB0JW01.FB0JWIX2 <= 40) /* Max mbr of sizes*/
          if (FB0JW05.FB4QTYLK == "Y")
            set FB0JM010.FB4DMQTY[FB0JWIX1] protect;
          else
            set FB0JM010.FB4DMQTY[FB0JWIX1] initialAttributes;
          end
          FB0JM010.FB4DMQTY[FB0JWIX1] = FB0JW05.FB4DMQTY[FB0JWIX2];
          FB0JM010.FB4SZPCT[FB0JWIX1] = FB0JW05.FB4SZPCT[FB0JWIX2];
          FB0JW01.FB0JWIX1 = FB0JW01.FB0JWIX1 + 1; /* increment size index*/
          FB0JW01.FB0JWIX2 = FB0JW01.FB0JWIX2 + 1; /* increment size offset index*/
        end
      else
        ;
        if (FB0JM010.XWHCD == FB0JW05.XWHCD) /* Warehouse code*/
          FB0JM010.XWHCD = FB0JW03.XWHCD; /* Warehouse code*/
          FB0J141(); /* get warehouse description*/
          FB0JW01.FB0JWIX1 = 1; /* General index 1*/
          while (FB0JW01.FB0JWIX2 <= 40) /* Max mbr of sizes*/
            if (FB0JW03.FB4QTYLK == "Y")
              set FB0JM010.FB4DMQTY[FB0JWIX1] protect;
            else
              set FB0JM010.FB4DMQTY[FB0JWIX1] initialAttributes;
            end
            FB0JM010.FB4DMQTY[FB0JWIX1] = FB0JW03.FB4DMQTY[FB0JWIX2];
            FB0JM010.FB4SZPCT[FB0JWIX1] = FB0JW03.FB4SZPCT[FB0JWIX2];
            FB0JW01.FB0JWIX1 = FB0JW01.FB0JWIX1 + 1;
                                   /* increment size index*/
            FB0JW01.FB0JWIX2 = FB0JW01.FB0JWIX2 + 1; /* increment size offset index*/
          end
        end
      end
    end
  end
  ;
  ;
  if (FB0JW01.FB0JWWHS == 2) /* warehouse count*/
    if (FB0JM010.XWHCD == FB0JW03.XWHCD) /* Warehouse code*/
      FB0JM010.XWHCD = FB0JW04.XWHCD; /* Warehouse code*/
      FB0J141(); /* get warehouse description*/
      FB0JW01.FB0JWIX1 = 1; /* General index 1*/
      while (FB0JW01.FB0JWIX2 <= 40) /* Max mbr of sizes*/
        if (FB0JW04.FB4QTYLK == "Y")
          set FB0JM010.FB4DMQTY[FB0JWIX1] protect;
        else
          set FB0JM010.FB4DMQTY[FB0JWIX1] initialAttributes;
        end
        FB0JM010.FB4DMQTY[FB0JWIX1] = FB0JW04.FB4DMQTY[FB0JWIX2];
        FB0JM010.FB4SZPCT[FB0JWIX1] = FB0JW04.FB4SZPCT[FB0JWIX2];
        FB0JW01.FB0JWIX1 = FB0JW01.FB0JWIX1 + 1; /* increment size index*/
        FB0JW01.FB0JWIX2 = FB0JW01.FB0JWIX2 + 1; /* increment size offset index*/
      end
    else
      if (FB0JM010.XWHCD == FB0JW04.XWHCD) /* Warehouse code*/
        FB0JM010.XWHCD = FB0JW03.XWHCD; /* Warehouse code*/
        FB0J141(); /* get warehouse description*/
        FB0JW01.FB0JWIX1 = 1; /* General index 1*/
        while (FB0JW01.FB0JWIX2 <= 40) /* Max mbr of sizes*/
          if (FB0JW03.FB4QTYLK == "Y")
            set FB0JM010.FB4DMQTY[FB0JWIX1] protect;
          else
            set FB0JM010.FB4DMQTY[FB0JWIX1] initialAttributes;
          end
          FB0JM010.FB4DMQTY[FB0JWIX1] = FB0JW03.FB4DMQTY[FB0JWIX2];
          FB0JM010.FB4SZPCT[FB0JWIX1] = FB0JW03.FB4SZPCT[FB0JWIX2];
          FB0JW01.FB0JWIX1 = FB0JW01.FB0JWIX1 + 1; /* increment size index*/
          FB0JW01.FB0JWIX2 = FB0JW01.FB0JWIX2 + 1; /* increment size offset index*/
        end
      end
    end
  end
  ;
  ;
  ;
  ;
  ;
   /* ------------------------------------------------------------*/
   /* position cursor depending on which column is unprotected*/
   /* ------------------------------------------------------------*/
  ;
  if (FB0JW01.FB0JWUNP == 1) /* Unprotect the first column*/
    FB0JW01.FB0JWIX1 = 14; /* General index 1*/
    while (FB0JW01.FB0JWIX1 >= 1) /* Looping from the bottom up*/
      if (FB0JM010.FB4DMQTY[FB0JWIX1] != 0
       || FB0JM010.FB4SZPCT[FB0JWIX1] != 0
       || FB0JM010.SY4IDDSC[FB0JWIX1] != " ")
        set FB0JM010.FB4SZPCT[FB0JWIX1] cursor, initialAttributes;
      end
      FB0JW01.FB0JWIX1 = FB0JW01.FB0JWIX1 - 1; /* decrement size index*/
    end
  else
    if (FB0JW01.FB0JWUNP == 2) /* Unprotect the second column*/
      set FB0JM010.FB4SZPCT[15] cursor; /* Size percent*/
    else
      if (FB0JW01.FB0JWUNP == 3) /* Unprotect the third column*/
        set FB0JM010.FB4SZPCT[29] cursor; /* Size percent*/
      end
    end
  end
  ;
  ;
  ;
  FB0J143(); /* Highlight invalid qtys & percent*/
  ;
  ;
  ;
  FB0J145(); /* calc total percent & variance*/
  ;
  ;
  ;
  ;
  ;
  ;
  if (FB0JM010.FB0JMTPR != 100) /* Total percent*/
    FB0JM010.XXXMODID = "170"; /* Module identification*/
    if (converseVar.eventKey is pf9)
      converseLib.validationFailed(45); /* total percent must equal 100 for update*/
    else
      converseLib.validationFailed(159); /* total percent must equal 100*/
    end
  end
  ;
  ;
end // end FB0J170

// Get entered warehouse
Function FB0J180()
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Move the curve to the map for the warehouse entered*/
   /* ------------------------------------------------------------*/
  FB0JW01.FB0JWIX2 = FB0JW01.FB0JWOFF; /* size display offset*/
  if (FB0JM010.XWHCD == FB0JW03.XWHCD /* Warehouse code*/
   && FB0JM010.XWHCD != "  ")        
    FB0J141(); /* get warehouse description*/
    FB0JW01.FB0JWIX1 = 1; /* General index 1*/
    while (FB0JW01.FB0JWIX2 <= 40) /* Max mbr of sizes*/
      if (FB0JW03.FB4QTYLK == "Y")
        set FB0JM010.FB4DMQTY[FB0JWIX1] protect;
      else
        set FB0JM010.FB4DMQTY[FB0JWIX1] initialAttributes;
      end
      FB0JM010.FB4DMQTY[FB0JWIX1] = FB0JW03.FB4DMQTY[FB0JWIX2];
      FB0JM010.FB4SZPCT[FB0JWIX1] = FB0JW03.FB4SZPCT[FB0JWIX2];
      FB0JW01.FB0JWIX1 = FB0JW01.FB0JWIX1 + 1; /* increment size index*/
      FB0JW01.FB0JWIX2 = FB0JW01.FB0JWIX2 + 1; /* increment size offset index*/
    end
  else
    if (FB0JM010.XWHCD == FB0JW04.XWHCD /* Warehouse code*/
     && FB0JM010.XWHCD != "  ")        
      FB0J141(); /* get warehouse description*/
      FB0JW01.FB0JWIX1 = 1; /* General index 1*/
      while (FB0JW01.FB0JWIX2 <= 40) /* Max mbr of sizes*/
        if (FB0JW04.FB4QTYLK == "Y")
          set FB0JM010.FB4DMQTY[FB0JWIX1] protect;
        else
          set FB0JM010.FB4DMQTY[FB0JWIX1] initialAttributes;
        end
        FB0JM010.FB4DMQTY[FB0JWIX1] = FB0JW04.FB4DMQTY[FB0JWIX2];
        FB0JM010.FB4SZPCT[FB0JWIX1] = FB0JW04.FB4SZPCT[FB0JWIX2];
        FB0JW01.FB0JWIX1 = FB0JW01.FB0JWIX1 + 1; /* increment size index*/
        FB0JW01.FB0JWIX2 = FB0JW01.FB0JWIX2 + 1; /* increment size offset index*/
      end
    else
      ;
      if (FB0JM010.XWHCD == FB0JW05.XWHCD /* Warehouse code*/
       && FB0JM010.XWHCD != "  ")        
        FB0J141(); /* get warehouse description*/
        FB0JW01.FB0JWIX1 = 1; /* General index 1*/
        while (FB0JW01.FB0JWIX2 <= 40) /* Max mbr of sizes*/
          if (FB0JW05.FB4QTYLK == "Y")
            set FB0JM010.FB4DMQTY[FB0JWIX1] protect;
          else
            set FB0JM010.FB4DMQTY[FB0JWIX1] initialAttributes;
          end
          FB0JM010.FB4DMQTY[FB0JWIX1] = FB0JW05.FB4DMQTY[FB0JWIX2];
          FB0JM010.FB4SZPCT[FB0JWIX1] = FB0JW05.FB4SZPCT[FB0JWIX2];
          FB0JW01.FB0JWIX1 = FB0JW01.FB0JWIX1 + 1; /* increment size index*/
          FB0JW01.FB0JWIX2 = FB0JW01.FB0JWIX2 + 1; /* increment size offset index*/
        end
      else
        converseLib.validationFailed(18); /* Indicate invalid warehouse*/
        set FB0JM010.XWHCD cursor, modified, bold;
        FB0JM010.XWHABRV = " ";
        FB0JM010.XXXMODID = "180"; /* module identification*/
        FB0JW01.FB0JWIX1 = 1; /* General index 1*/
        while (FB0JW01.FB0JWIX1 <= 40) /* Max mbr of sizes*/
          set FB0JM010.FB4DMQTY[FB0JWIX1] protect, invisible;
          set FB0JM010.FB4SZPCT[FB0JWIX1] protect, invisible;
          FB0JW01.FB0JWIX1 = FB0JW01.FB0JWIX1 + 1; /* increment size index*/
        end
        return; /* Return to caller*/
      end
    end
  end
  ;
  ;
  ;
  ;
   /* ------------------------------------------------------------*/
   /* position cursor depending on which column is unprotected*/
   /* ------------------------------------------------------------*/
  ;
  if (FB0JW01.FB0JWUNP == 1) /* Unprotect the first column*/
    FB0JW01.FB0JWIX1 = 14; /* General index 1*/
    while (FB0JW01.FB0JWIX1 >= 1) /* Looping from the bottom up*/
      if (FB0JM010.FB4DMQTY[FB0JWIX1] != 0
       || FB0JM010.FB4SZPCT[FB0JWIX1] != 0
       || FB0JM010.SY4IDDSC[FB0JWIX1] != " ")
        set FB0JM010.FB4SZPCT[FB0JWIX1] cursor, initialAttributes;
      end
      FB0JW01.FB0JWIX1 = FB0JW01.FB0JWIX1 - 1; /* decrement size index*/
    end
  else
    if (FB0JW01.FB0JWUNP == 2) /* Unprotect the second column*/
      set FB0JM010.FB4SZPCT[15] cursor; /* Size percent*/
    else
      if (FB0JW01.FB0JWUNP == 3) /* Unprotect the third column*/
        set FB0JM010.FB4SZPCT[29] cursor; /* Size percent*/
      end
    end
  end
  ;
  ;
  ;
  ;
  FB0J143(); /* Highlight invalid qtys & percent*/
  ;
  ;
  ;
  ;
  FB0J145(); /* calc total percent & variance*/
  ;
  ;
  ;
  ;
  ;
  if (FB0JM010.FB0JMTPR != 100) /* Total percent*/
    FB0JM010.XXXMODID = "180"; /* Module identification*/
    if (converseVar.eventKey is pf9)
      converseLib.validationFailed(45); /* total percent must equal 100 for update*/
    else
      converseLib.validationFailed(159); /* total percent must equal 100*/
    end
  end
  ;
  ;
end // end FB0J180

// Format and converse the map
Function FB0J200()
   /* ------------------------------------------------------------*/
   /* Format the current date and any FAST PATH information.*/
   /* ------------------------------------------------------------*/
  ;
  FB0JM010.XXXCURDT = VGVar.currentShortGregorianDate; /* Current date*/
  ;
  ;
  converse FB0JM010 ;
  if (SQLCA.VAGen_SQLCODE == -911)
    FB0JW01.FB0JWDSW = "Y";
    exit stack;
  end
end // end FB0J200

// Check attention identifier
Function FB0J300()
  FB0JM010.XXXMODID = "300"; /* Module identification*/
  ;
  ;
   /* ------------------------------------------------------------*/
   /* If duplicate std curves were found, only allow pf1,3,5*/
   /* ------------------------------------------------------------*/
  ;
  if (FB0JW01.FB0JW-DUP-STD-FL == "Y" /* Duplicates found*/
   && converseVar.eventKey not pf1    /* Help screen*/
   && converseVar.eventKey not pf3    /* Exit*/
   && converseVar.eventKey not pf5)   /* Exit to prod menu*/
    converseLib.validationFailed(503); /* only pf1,3,5 are valid*/
    exit stack;
  end
  ;
   /* ------------------------------------------------------------*/
   /* If no key was passed to this program*/
      /* only pf1, pf3 and pf5 will be allowed.*/
   /* ------------------------------------------------------------*/
  if (FB0JW01.FB0JWPSW == "NO"     /* No key was passed*/
   && converseVar.eventKey not pf1 /* Help screen*/
   && converseVar.eventKey not pf3 /* Exit*/
   && converseVar.eventKey not pf5) /* Exit to prod menu*/
    converseLib.validationFailed(42); /* no data to display*/
    exit stack;
  end
  ;
  ;
   /* ------------------------------------------------------------*/
   /* If no valid sizes found*/
      /* only pf1, pf3 and pf5 will be allowed.*/
   /* ------------------------------------------------------------*/
  if (FB0JW01.FB0JWSFS == "N"      /* No valid sizes found*/
   && converseVar.eventKey not pf1 /* Help screen*/
   && converseVar.eventKey not pf3 /* Exit*/
   && converseVar.eventKey not pf5) /* Exit to prod menu*/
    converseLib.validationFailed(78); /* no data to display*/
    exit stack;
  end
  ;
  ;
   /* ------------------------------------------------------------*/
   /* If CANCEL was requested, restart from the top.*/
   /* ------------------------------------------------------------*/
  ;
  if (converseVar.eventKey is pa2) /* PA2 was pressed*/
    COMMAREA.CATOAP = "FB0J"; /* TO application*/
    COMMAREA.CAITEM = " "; /* Application data*/
    XSEXIT(); /* Exit to self*/
    FB0JM010.VAGen_EZEMSG = COMMAREA.CAMSG; /* if bad transfer*/
    exit stack; /* return to show error msg*/
  end
  ;
   /* ------------------------------------------------------------*/
   /* If FAST PATH was requested, transfer to the application.*/
   /* ------------------------------------------------------------*/
  ;
  if (FB0JM010.CATOAP > " " /* FAST PATH was requested*/
   && FB0JW01.FB0JWPSW != "NO") /* key was passed*/
    if (converseVar.eventKey is enter) /* ENTER was pressed*/
      FBWREC.FBWFILL = " ";
      COMMAREA.CAUSERA = FBWREC.FBWGROUP;
      COMMAREA.CATOAP = FB0JM010.CATOAP; /* TO application*/
      COMMAREA.CAITEM = FB0JM010.CAITEM; /* TO application key*/
      XSEXIT(); /* Exit to another application*/
      FB0JM010.VAGen_EZEMSG = COMMAREA.CAMSG; /* if bad transfer*/
      exit stack; /* return to show error msg*/
    else
      converseLib.validationFailed(40); /* Enter must be used for fast path*/
      return;
    end
  end
  ;
  ;
   /* ------------------------------------------------------------*/
   /* If transferring to an application that uses the current*/
   /* curve and data has been modified,  display a message saying*/
   /* updates will be lost.  also, set the override flag so that*/
   /* if they still want to transfer, they will the next time*/
   /* around.*/
   /* ------------------------------------------------------------*/
  if (FB0JW01.FB0JWWM1 == "Y" /* Warehouse 1 was modified*/
   || FB0JW01.FB0JWWM2 == "Y" /* Warehouse 2 was modified*/
   || FB0JW01.FB0JWWM3 == "Y") /* Warehouse 3 was modified*/
    if (converseVar.eventKey is pf15 /* Region percent maintenance*/
     || converseVar.eventKey is pf16 /* Copy a region*/
     || converseVar.eventKey is pf19 /* Assign to product*/
     || converseVar.eventKey is pf12) /* Selection criteria*/
      if (FB0JW01.FB0JWXFL != "O") /* Not override transfer edit*/
        FB0JW01.FB0JWXFL = "O"; /* Override transfer edit*/
        converseLib.validationFailed(157); /* Updates will be lost*/
        exit stack;
      end
    end
  end
  if (converseVar.eventKey is enter /* Enter was hit*/
   || converseVar.eventKey is pf9)  /* Update*/
    FB0JW01.FB0JWXFL = " "; /* Not override transfer edit*/
  end
  ;
  ;
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Handle pf-keys*/
   /* ------------------------------------------------------------*/
  ;
  if (converseVar.eventKey is pf1) /* PF1 was pressed*/
    COMMAREA.CAITEM = "FB0JM010"; /* Application data*/
    COMMAREA.CATOAP = "GD01"; /* TO application*/
    XSEXIT(); /* exit to production menu*/
    FB0JM010.VAGen_EZEMSG = COMMAREA.CAMSG; /* if bad transfer*/
    exit stack; /* return to show error msg*/
  end
  ;
  if (converseVar.eventKey is pf5) /* pf5 was pressed*/
    COMMAREA.CATOAP = "FY0M"; /* TO application*/
    COMMAREA.CAITEM = " "; /* Application data*/
    XSEXIT(); /* exit to production menu*/
    FB0JM010.VAGen_EZEMSG = COMMAREA.CAMSG; /* if bad transfer*/
    exit stack; /* return to show error msg*/
  end
  ;
  if (converseVar.eventKey is pf3) /* PF3 was pressed*/
    if (FB0JW01.FB0JWPSW != "IP" /* Not invalid product curve*/
     && FB0JW01.FB0JWPSW != "IU") /* Not invalid user curve*/
      COMMAREA.CATOAP = "FB0C"; /* TO application*/
      COMMAREA.CAITEM = " "; /* Application data*/
      XSEXIT(); /* exit to Size maint. select*/
      FB0JM010.VAGen_EZEMSG = COMMAREA.CAMSG; /* if bad transfer*/
      exit stack; /* return to show error msg*/
    else
      return;
    end
  end
  ;
  if (converseVar.eventKey is pf9 /* PF9 was pressed (update)*/
   || converseVar.eventKey is enter) /* enter was pressed*/
    FB0JM010.XXXMODID = "   "; /* Module identification*/
    return;
  end
  ;
  if (converseVar.eventKey is pf12) /* PF12 was pressed*/
    COMMAREA.CATOAP = "FB0K"; /* TO application*/
    COMMAREA.CAITEM = " "; /* Application data*/
    XSEXIT(); /* exit to Selection criteria*/
    FB0JM010.VAGen_EZEMSG = COMMAREA.CAMSG; /* if bad transfer*/
    exit stack; /* return to show error msg*/
  end
  ;
  if (converseVar.eventKey is pf15) /* PF15 was pressed*/
    COMMAREA.CATOAP = "FB0L"; /* TO application*/
    COMMAREA.CAITEM = " "; /* Application data*/
    XSEXIT(); /* exit to Region percent maint.*/
    FB0JM010.VAGen_EZEMSG = COMMAREA.CAMSG; /* if bad transfer*/
    exit stack; /* return to show error msg*/
  end
  ;
  if (converseVar.eventKey is pf20) /* PF20 was pressed*/
    FB0J310(); /* set column to be unprotected*/
    return;
                                   /* return to show next column*/
  end
  ;
  if (converseVar.eventKey is pf16) /* PF16 was pressed*/
    COMMAREA.CATOAP = "FB0I"; /* TO application*/
    COMMAREA.CAITEM = " "; /* Application data*/
    XSEXIT(); /* exit to Copy a region*/
    FB0JM010.VAGen_EZEMSG = COMMAREA.CAMSG; /* if bad transfer*/
    exit stack; /* return to show error msg*/
  end
  ;
  if (converseVar.eventKey is pf17) /* PF17 was pressed (delete)*/
    FB0JM010.XXXMODID = "   "; /* Module identification*/
    return;
  end
  ;
  if (converseVar.eventKey is pf19) /* PF19 was pressed*/
    if (FB0JW01.FB0JWPSW != "IP"
     && FB0JW01.FB0JWPSW != "UP")
      FBWREC.FBWFILL = " ";
      COMMAREA.CAUSERA = FBWREC.FBWGROUP;
      COMMAREA.CATOAP = "FB0E"; /* TO application*/
      COMMAREA.CAITEM = " "; /* Application data*/
      XSEXIT(); /* exit to Assign to products*/
      FB0JM010.VAGen_EZEMSG = COMMAREA.CAMSG; /* if bad transfer*/
      exit stack; /* return to show error msg*/
    end
  end
  ;
  ;
   /* ------------------------------------------------------------*/
   /* If this point has been reached, an invalid pf-keys was hit.*/
   /* ------------------------------------------------------------*/
  ;
  converseLib.validationFailed(3);
end // end FB0J300

// Set column to be unprotected
Function FB0J310()
  ;
  ;
  FB0JW01.FB0JWUNP = FB0JW01.FB0JWUNP + 1; /* column to be unprotected*/
  if (FB0JW01.FB0JWUNP == 4)
    FB0JW01.FB0JWUNP = 1;
  else
    if (FB0JW01.FB0JWUNP == 3
     && FB0JM010.FB4DMQTY[29] == 0
     && FB0JM010.FB4DMQTY[30] == 0
     && FB0JM010.FB4DMQTY[31] == 0
     && FB0JM010.FB4DMQTY[32] == 0
     && FB0JM010.FB4DMQTY[33] == 0
     && FB0JM010.FB4DMQTY[34] == 0
     && FB0JM010.FB4DMQTY[35] == 0
     && FB0JM010.FB4DMQTY[36] == 0
     && FB0JM010.FB4DMQTY[37] == 0
     && FB0JM010.FB4DMQTY[38] == 0
     && FB0JM010.FB4DMQTY[39] == 0
     && FB0JM010.FB4DMQTY[40] == 0
     && FB0JM010.FB4SZPCT[29] == 0
     && FB0JM010.FB4SZPCT[30] == 0
     && FB0JM010.FB4SZPCT[31] == 0
     && FB0JM010.FB4SZPCT[32] == 0
     && FB0JM010.FB4SZPCT[33] == 0
     && FB0JM010.FB4SZPCT[34] == 0
     && FB0JM010.FB4SZPCT[35] == 0
     && FB0JM010.FB4SZPCT[36] == 0
     && FB0JM010.FB4SZPCT[37] == 0
     && FB0JM010.FB4SZPCT[38] == 0
     && FB0JM010.FB4SZPCT[39] == 0
     && FB0JM010.FB4SZPCT[40] == 0
     && FB0JM010.SY4IDDSC[29] == " "
     && FB0JM010.SY4IDDSC[30] == " "
     && FB0JM010.SY4IDDSC[31] == " "
     && FB0JM010.SY4IDDSC[32] == " "
     && FB0JM010.SY4IDDSC[33] == " "
     && FB0JM010.SY4IDDSC[34] == " "
     && FB0JM010.SY4IDDSC[35] == " "
     && FB0JM010.SY4IDDSC[36] == " "
     && FB0JM010.SY4IDDSC[37] == " "
     && FB0JM010.SY4IDDSC[38] == " "
     && FB0JM010.SY4IDDSC[39] == " "
     && FB0JM010.SY4IDDSC[40] == " ")
      FB0JW01.FB0JWUNP = 1; /* no third column to maintenance*/
    else
      if (FB0JW01.FB0JWUNP == 2
       && FB0JM010.FB4DMQTY[15] == 0
       && FB0JM010.FB4DMQTY[16] == 0
       && FB0JM010.FB4DMQTY[17] == 0
       && FB0JM010.FB4DMQTY[18] == 0
       && FB0JM010.FB4DMQTY[19] == 0
       && FB0JM010.FB4DMQTY[20] == 0
       && FB0JM010.FB4DMQTY[21] == 0
       && FB0JM010.FB4DMQTY[22] == 0
       && FB0JM010.FB4DMQTY[23] == 0
       && FB0JM010.FB4DMQTY[24] == 0
       && FB0JM010.FB4DMQTY[25] == 0
       && FB0JM010.FB4DMQTY[26] == 0
       && FB0JM010.FB4DMQTY[27] == 0
       && FB0JM010.FB4DMQTY[28] == 0
       && FB0JM010.FB4SZPCT[15] == 0
       && FB0JM010.FB4SZPCT[16] == 0
       && FB0JM010.FB4SZPCT[17] == 0
       && FB0JM010.FB4SZPCT[18] == 0
       && FB0JM010.FB4SZPCT[19] == 0
       && FB0JM010.FB4SZPCT[20] == 0
       && FB0JM010.FB4SZPCT[21] == 0
       && FB0JM010.FB4SZPCT[22] == 0
       && FB0JM010.FB4SZPCT[23] == 0
       && FB0JM010.FB4SZPCT[24] == 0
       && FB0JM010.FB4SZPCT[25] == 0
       && FB0JM010.FB4SZPCT[26] == 0
       && FB0JM010.FB4SZPCT[27] == 0
       && FB0JM010.FB4SZPCT[28] == 0
       && FB0JM010.SY4IDDSC[15] == " "
       && FB0JM010.SY4IDDSC[16] == " "
       && FB0JM010.SY4IDDSC[17] == " "
       && FB0JM010.SY4IDDSC[18] == " "
       && FB0JM010.SY4IDDSC[19] == " "
       && FB0JM010.SY4IDDSC[20] == " "
       && FB0JM010.SY4IDDSC[21] == " "
       && FB0JM010.SY4IDDSC[22] == " "
       && FB0JM010.SY4IDDSC[23] == " "
       && FB0JM010.SY4IDDSC[24] == " "
       && FB0JM010.SY4IDDSC[25] == " "
       && FB0JM010.SY4IDDSC[26] == " "
       && FB0JM010.SY4IDDSC[27] == " "
       && FB0JM010.SY4IDDSC[28] == " ")
        FB0JW01.FB0JWUNP = 1; /* no second column to maintenance*/
      end
    end
  end
end // end FB0J310

// Reset highlighted fields
Function FB0J400()
   /* ------------------------------------------------------------*/
   /* Reset field attributes to normal intensity.*/
   /* ------------------------------------------------------------*/
  ;
  set FB0JM010.SY1STNBR initialAttributes; /* Style number*/
  set FB0JM010.SY2CLRID initialAttributes; /* Color identification*/
  set FB0JM010.FB4STDFL initialAttributes; /* Standard flag*/
  set FB0JM010.XDMCD initialAttributes; /* Dimension code*/
  set FB0JM010.XWHCD initialAttributes; /* Warehouse code*/
  set FB0JM010.CATOAP initialAttributes; /* Commarea TO application*/
  set FB0JM010.CAITEM initialAttributes; /* Commarea application data*/
  ;
  ;
  FB0JW01.FB0JWIX1 = 40; /* General index 1*/
  while (FB0JW01.FB0JWIX1 >= 1) /* Looping from the bottom up*/
    set FB0JM010.FB4DMQTY[FB0JWIX1] initialAttributes; /* Demand quantity*/
    set FB0JM010.FB4SZPCT[FB0JWIX1] initialAttributes; /* Size percent*/
    ;
    if (FB0JW03.XWHCD == FB0JW01.FB0JWCUR /* Current warehouse code*/
     && FB0JW03.FB4QTYLK == "Y")         
      set FB0JM010.FB4DMQTY[FB0JWIX1] protect; /* Qty updates not allowed*/
    end
    if (FB0JW04.XWHCD == FB0JW01.FB0JWCUR /* Current warehouse code*/
     && FB0JW04.FB4QTYLK == "Y")         
      set FB0JM010.FB4DMQTY[FB0JWIX1] protect; /* Qty updates not allowed*/
    end
    if (FB0JW05.XWHCD == FB0JW01.FB0JWCUR /* Current warehouse code*/
     && FB0JW05.FB4QTYLK == "Y")         
      set FB0JM010.FB4DMQTY[FB0JWIX1] protect; /* Qty updates not allowed*/
    end
    /* ------------------------------------------------------------*/
     /* check for size description, percent, and quantity - ckn*/
    /* ------------------------------------------------------------*/
    ;
    if (FB0JM010.SY4IDDSC[FB0JWIX1] == " " /* no size description*/
     && FB0JM010.FB4SZPCT[FB0JWIX1] == 0   /* no size percent*/
     && FB0JM010.FB4DMQTY[FB0JWIX1] == 0)  /* no size quantity*/
      set FB0JM010.FB4SZPCT[FB0JWIX1] protect, invisible; /* protect percent*/
      set FB0JM010.FB4DMQTY[FB0JWIX1] protect, invisible; /* protect quantity*/
    end
    FB0JW01.FB0JWIX1 = FB0JW01.FB0JWIX1 - 1; /* decrement size index*/
  end
  ;
   /* ------------------------------------------------------------*/
   /* position cursor depending on which column is unprotected*/
   /* ------------------------------------------------------------*/
  ;
  if (FB0JW01.FB0JWUNP == 1) /* Unprotect the first column*/
    FB0JW01.FB0JWIX1 = 14; /* General index 1*/
    while (FB0JW01.FB0JWIX1 >= 1) /* Looping from the bottom up*/
      if (FB0JM010.FB4DMQTY[FB0JWIX1] != 0
       || FB0JM010.FB4SZPCT[FB0JWIX1] != 0
       || FB0JM010.SY4IDDSC[FB0JWIX1] != " ")
        set FB0JM010.FB4SZPCT[FB0JWIX1] cursor, initialAttributes;
      end
      FB0JW01.FB0JWIX1 = FB0JW01.FB0JWIX1 - 1; /* decrement size index*/
    end
  else
    if (FB0JW01.FB0JWUNP == 2) /* Unprotect the second column*/
      set FB0JM010.FB4SZPCT[15] cursor; /* Size percent*/
    else
      if (FB0JW01.FB0JWUNP == 3) /* Unprotect the third column*/
        set FB0JM010.FB4SZPCT[29] cursor; /* Size percent*/
      end
    end
  end
end // end FB0J400

// Verify the entered data
Function FB0J500()
  ;
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Get out if an update is pending from a previous update*/
   /* or a delete.*/
   /* ------------------------------------------------------------*/
  ;
  if (FB0JW01.FB0JWUPD == "U" /* An update is pending*/
   || FB0JW01.FB0JWUPD == "D") /* A delete is pending*/
    if (converseVar.eventKey not pf9  /* Update*/
     && converseVar.eventKey not pa2  /* Cancel*/
     && converseVar.eventKey not pf17 /* Delete*/
     && converseVar.eventKey not pf3) /* Transfer to FB0E*/
      FB0JW01.FB0JWUPD = " "; /* Reset update pending switch*/
    end
    return;
  end
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  FB0J510();
                                   /* Check for percent & quantity modified*/
  FB0J560(); /* Save the current map in working storage*/
  if (converseVar.validationMsgNum == 30) /* Cannot update percent & qty*/
                                   /* Percent input ignored*/
    FB0JM010.XWHCD = FB0JW01.FB0JWCUR; /* reset the Warehouse code*/
    FB0J143(); /* Highlight invalid qtys & percent*/
    exit stack;
  end
  ;
  ;
  ;
  ;
  FB0J143(); /* Highlight invalid qtys & percent*/
  ;
  if (FB0JW01.FB0JWPMD == "Y") /* Percents were modified*/
    if (converseVar.validationMsgNum == 49
     /* Error, qty exists for an invalid size*/
     || converseVar.validationMsgNum == 51)
                                   /* Error, pct exists for an invalid size*/
      FB0J145(); /* calc total percent & variance*/
      if (FB0JW01.FB0JWPSW == "DP"
       || FB0JW01.FB0JWPSW == "DU")
        FB0JM010.XWHCD = FB0JW01.FB0JWCUR;
                                   /* reset the Warehouse code*/
        exit stack;
      end
    end
    ;
    ;
    ;
    ;
    FB0J145(); /* calc total percent & variance*/
    ;
    ;
    ;
    ;
    ;
    ;
  else
    if (FB0JW01.FB0JWQMD == "Y") /* Quantities were modified*/
      ;
      ;
      ;
      FB0J143(); /* Highlight invalid qtys & percent*/
      if (converseVar.validationMsgNum == 49
       /* Error, qty exists for an invalid size*/
       || converseVar.validationMsgNum == 51)
                                   /* Error, pct exists for an invalid size*/
        FB0J145(); /* calc total percent & variance*/
        if (FB0JW01.FB0JWPSW == "DP"
         || FB0JW01.FB0JWPSW == "DU")
          FB0JM010.XWHCD = FB0JW01.FB0JWCUR; /* reset the Warehouse code*/
          exit stack;
        end
      end
      ;
      ;
      ;
      ;
      FB0J145(); /* calc total percent & variance*/
      ;
      ;
      ;
    end
  end
  ;
  ;
  ;
  ;
  ;
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Edit standard flag.*/
   /* ------------------------------------------------------------*/
  ;
  if (FB0JM010.FB4STDFL != "Y" /* standard flag*/
   && FB0JM010.FB4STDFL != "N" 
   && FB0JM010.FB4STDFL != " ")
    set FB0JM010.FB4STDFL cursor, modified, bold;
    converseLib.validationFailed(55); /* Standard flag invalid*/
    FB0JM010.XWHCD = FB0JW01.FB0JWCUR; /* reset the Warehouse code*/
    exit stack;
  end
  ;
  ;
  ;
  ;
   /* ------------------------------------------------------------*/
   /* if standard flag is changed to yes*/
      /* move 'y' to standard flags in working storage*/
      /* set flags so that curves get updated.*/
   /* ------------------------------------------------------------*/
  ;
  if (FB0JM010.FB4STDFL == "Y" /* standard flag*/
   && FB0JM010.FB4STDFL != FB0JW03.FB4STDFL)
    FB0JW01.FB0JWSTM = "Y"; /* Standard is modified flag*/
    if (FB0JW01.FB0JWWHS == 3) /* Number of warehouses*/
      FB0JW03.FB4STDFL = "Y"; /* Standard flag whse 1*/
      FB0JW01.FB0JWWM1 = "Y"; /* Warehouse 1 was modified*/
      FB0JW04.FB4STDFL = "Y"; /* Standard flag whse 2*/
      FB0JW01.FB0JWWM2 = "Y"; /* Warehouse 2 was modified*/
      FB0JW05.FB4STDFL = "Y"; /* Standard flag whse 3*/
      FB0JW01.FB0JWWM3 = "Y"; /* Warehouse 3 was modified*/
    else
      if (FB0JW01.FB0JWWHS == 2) /* Number of warehouses*/
        FB0JW03.FB4STDFL = "Y"; /* Standard flag whse 1*/
        FB0JW01.FB0JWWM1 = "Y"; /* Warehouse 1 was modified*/
        FB0JW04.FB4STDFL = "Y"; /* Standard flag whse 2*/
        FB0JW01.FB0JWWM2 = "Y"; /* Warehouse 2 was modified*/
      else
        FB0JW03.FB4STDFL = "Y"; /* Standard flag whse 1*/
        FB0JW01.FB0JWWM1 = "Y"; /* Warehouse 1 was modified*/
      end
    end
  end
  ;
  ;
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Edit size scale code*/
   /* ------------------------------------------------------------*/
  ;
  if (FB0JW01.FB0JWPMD == "IU" /* Invalid user curve*/
   || FB0JW01.FB0JWPMD == "IP") /* Invalid product curve*/
    if (FB1REC.SY4SZSCL != PG2REC.SY4SZSCL) /* Size scale code*/
      converseLib.validationFailed(56); /* Size scale code incompatible*/
      FB0JM010.XWHCD = FB0JW01.FB0JWCUR; /* reset the Warehouse code*/
      exit stack;
    end
  end
  ;
  ;
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Check for total equal to 100*/
   /* ------------------------------------------------------------*/
  ;
  if (FB0JM010.FB0JMTPR != 100) /* Total percent*/
    FB0JM010.XXXMODID = "500"; /* Module identification*/
    FB0JM010.XWHCD = FB0JW01.FB0JWCUR; /* reset the Warehouse code*/
    if (converseVar.eventKey is pf9)
      converseLib.validationFailed(45); /* total percent must equal 100 for update*/
      exit stack;
    else
      converseLib.validationFailed(159); /* total percent must equal 100*/
      exit stack;
    end
  end
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Check for attempt to update when processing*/
   /* invalid curves for fb0e (assign to products)*/
   /* ------------------------------------------------------------*/
  ;
  if (converseVar.eventKey is pf9) /* Update*/
    if (FB0JW01.FB0JWPSW == "IU" /* invalid user curve*/
     || FB0JW01.FB0JWPSW == "IP") /* invalid product curve*/
      converseLib.validationFailed(53); /* Must hit pf3 to return to fb0e (asgn-to)*/
      FB0JM010.XWHCD = FB0JW01.FB0JWCUR; /* reset the Warehouse code*/
      exit stack;
    end
  end
  ;
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Check for displaying entered warehouse.*/
   /* ------------------------------------------------------------*/
  ;
  if (converseVar.validationMsgNum == 0  /* No errors have occurred*/
   || converseVar.validationMsgNum == 52 /* Warning, zero % in valid size*/
   || converseVar.validationMsgNum == 50) /* Warning, zero qty in valid size*/
    if (converseVar.eventKey is enter
     && FB0JM010.XWHCD is modified) /* Warehouse was modified*/
      converseLib.validationFailed(0); /* Clear ezemno for entered warehouse display*/
      /* ------------------------------------------------------------*/
       /* Reset field attributes to normal intensity.*/
      /* ------------------------------------------------------------*/
      FB0JW01.FB0JWIX1 = 40; /* General index 1*/
      while (FB0JW01.FB0JWIX1 >= 1) /* Looping from the bottom up*/
        set FB0JM010.FB4DMQTY[FB0JWIX1] initialAttributes; /* Demand quantity*/
        set FB0JM010.FB4SZPCT[FB0JWIX1] initialAttributes; /* Size percent*/
        FB0JW01.FB0JWIX1 = FB0JW01.FB0JWIX1 - 1; /* decrement size index*/
      end
      FB0JW01.FB0JWDSW = "W"; /* Set to display entered warehouse*/
      exit stack; /* To display the entered warehouse*/
    end
  end
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Check for displaying next warehouse.*/
   /* ------------------------------------------------------------*/
  ;
  if (converseVar.validationMsgNum == 0 /* No errors have occurred*/
   && converseVar.eventKey is enter     
   && FB0JW01.FB0JWPMD == "N"           /* Percents were not modified*/
   && FB0JW01.FB0JWQMD == "N")          /* Quantities were not modified*/
    FB0JW01.FB0JWDSW = "N"; /* Set to display next warehouse*/
    exit stack; /* To display the next warehouse*/
  end
  ;
  ;
end // end FB0J500

// Check for pct & qty modified
Function FB0J510()
   /* ------------------------------------------------------------*/
   /* Check for size percent modified*/
   /* ------------------------------------------------------------*/
  ;
  FB0JW01.FB0JWPMD = "N"; /* Percent was modified fl*/
  FB0JW01.FB0JWQMD = "N"; /* Quantity was modified fl*/
  FB0JW01.FB0JWIX1 = 41 - FB0JW01.FB0JWOFF; /* General index 1 (map)*/
  FB0JW01.FB0JWIX2 = 40; /* General index 2 (ws)*/
  while (FB0JW01.FB0JWIX1 >= 1) /* Looping from the bottom up*/
    if (FB0JW01.FB0JWCUR == FB0JW03.XWHCD /* if 1st whse modified*/
     && FB0JM010.FB4SZPCT[FB0JWIX1] != FB0JW03.FB4SZPCT[FB0JWIX2])
      FB0JW01.FB0JWPMD = "Y"; /* Percent was modified fl*/
      FB0JW01.FB0JWWM1 = "Y"; /* 1st whse modified switch*/
    end
    if (FB0JW01.FB0JWCUR == FB0JW04.XWHCD /* if 2nd whse modified*/
     && FB0JM010.FB4SZPCT[FB0JWIX1] != FB0JW04.FB4SZPCT[FB0JWIX2])
      FB0JW01.FB0JWPMD = "Y"; /* Percent was modified fl*/
      FB0JW01.FB0JWWM2 = "Y"; /* 2nd whse modified switch*/
    end
    if (FB0JW01.FB0JWCUR == FB0JW05.XWHCD /* if 3rd whse modified*/
     && FB0JM010.FB4SZPCT[FB0JWIX1] != FB0JW05.FB4SZPCT[FB0JWIX2])
      FB0JW01.FB0JWPMD = "Y"; /* Percent was modified fl*/
      FB0JW01.FB0JWWM3 = "Y"; /* 3rd whse modified switch*/
    end
    ;
    ;
    FB0JW01.FB0JWIX1 = FB0JW01.FB0JWIX1 - 1; /* decrement size index*/
    FB0JW01.FB0JWIX2 = FB0JW01.FB0JWIX2 - 1; /* decrement size index*/
  end
  ;
  ;
  ;
   /* ------------------------------------------------------------*/
   /* If percents were modified*/
       /* Highlight invalidly modified quantities.*/
   /* ------------------------------------------------------------*/
  ;
  FB0JW01.FB0JWIX1 = 41 - FB0JW01.FB0JWOFF; /* General index 1 (map)*/
  FB0JW01.FB0JWIX2 = 40; /* General index 2 (ws)*/
  while (FB0JW01.FB0JWIX1 >= 1) /* Looping from the bottom up*/
    if (FB0JW01.FB0JWCUR == FB0JW03.XWHCD /* if 1st whse modified*/
     && FB0JM010.FB4DMQTY[FB0JWIX1] != FB0JW03.FB4DMQTY[FB0JWIX2])
      FB0JW01.FB0JWQMD = "Y"; /* Quantity was modified fl*/
      FB0JW01.FB0JWWM1 = "Y"; /* 1st whse modified switch*/
      if (FB0JW01.FB0JWPMD == "Y") /* Percents were modified*/
        set FB0JM010.FB4DMQTY[FB0JWIX1] cursor, modified, bold;
        converseLib.validationFailed(30); /* Cannot update percent & qty*/
      end
    end
    if (FB0JW01.FB0JWCUR == FB0JW04.XWHCD /* if 2nd whse modified*/
     && FB0JM010.FB4DMQTY[FB0JWIX1] != FB0JW04.FB4DMQTY[FB0JWIX2])
      FB0JW01.FB0JWQMD = "Y"; /* Quantity was modified fl*/
      FB0JW01.FB0JWWM2 = "Y"; /* 2nd whse modified switch*/
      if (FB0JW01.FB0JWPMD == "Y") /* Percents were modified*/
        set FB0JM010.FB4DMQTY[FB0JWIX1] cursor, modified, bold;
        converseLib.validationFailed(30); /* Cannot update percent & qty*/
      end
    end
    if (FB0JW01.FB0JWCUR == FB0JW05.XWHCD /* if 3rd whse modified*/
     && FB0JM010.FB4DMQTY[FB0JWIX1] != FB0JW05.FB4DMQTY[FB0JWIX2])
      FB0JW01.FB0JWQMD = "Y"; /* Quantity was modified fl*/
      FB0JW01.FB0JWWM3 = "Y"; /* 3rd whse modified switch*/
      if (FB0JW01.FB0JWPMD == "Y") /* Percents were modified*/
        set FB0JM010.FB4DMQTY[FB0JWIX1] cursor, modified, bold;
        converseLib.validationFailed(30); /* Cannot update percent & qty*/
      end
    end
    FB0JW01.FB0JWIX1 = FB0JW01.FB0JWIX1 - 1; /* decrement size index*/
    FB0JW01.FB0JWIX2 = FB0JW01.FB0JWIX2 - 1; /* decrement size index*/
  end
  ;
  ;
  if (converseVar.validationMsgNum == 30)
    FB0JW01.FB0JWPMD = "N"; /* Percents were not modified*/
  end
  ;
  ;
  if (FB0JW01.FB0JWQMD == "Y") /* Quantity was modified fl*/
    FB0J550(); /* Recalculate percents*/
  end
end // end FB0J510

// Re-calculate percents
Function FB0J550()
  ;
   /* ------------------------------------------------------------*/
   /* Calculate total quantity*/
   /* ------------------------------------------------------------*/
  FB0JW01.FB0JWIX1 = 1; /* General index 1*/
  FB0JM010.FB0JMTQT = 0; /* Total quantity*/
  while (FB0JW01.FB0JWIX1 <= 40) /* Max mbr of sizes*/
    FB0JM010.FB0JMTQT = FB0JM010.FB0JMTQT + FB0JM010.FB4DMQTY[FB0JWIX1];
    FB0JW01.FB0JWIX1 = FB0JW01.FB0JWIX1 + 1; /* increment size index*/
  end
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Calculate size percents = quantity / total quantity*/
   /* ------------------------------------------------------------*/
  FB0JW01.FB0JWIX1 = 1; /* General index 1*/
  while (FB0JW01.FB0JWIX1 <= 40) /* Max mbr of sizes*/
    if (FB0JM010.FB4DMQTY[FB0JWIX1] != 0) /* Don't divide into zero*/
      FB0JW01.FB0JWP4 = FB0JM010.FB4DMQTY[FB0JWIX1] / FB0JM010.FB0JMTQT;
      FB0JW01.FB0JWP4 = FB0JW01.FB0JWP4 * 100; /* To get size percent*/
      FB0JW01.FB0JWP4 = FB0JW01.FB0JWP4 + .05; /* Round to tenths*/
    else
      FB0JW01.FB0JWP4 = 0;
    end
    FB0JM010.FB4SZPCT[FB0JWIX1] = FB0JW01.FB0JWP4; /* Truncate*/
    if (FB0JM010.XWHCD == FB0JW03.XWHCD)
      FB0JW03.FB4SZPCT[FB0JWIX1] = FB0JW01.FB0JWP4; /* Size percent*/
      FB0JW03.FB4DMQTY[FB0JWIX1] = FB0JM010.FB4DMQTY[FB0JWIX1];
    end
    if (FB0JM010.XWHCD == FB0JW04.XWHCD)
      FB0JW04.FB4SZPCT[FB0JWIX1] = FB0JW01.FB0JWP4; /* Size percent*/
      FB0JW04.FB4DMQTY[FB0JWIX1] = FB0JM010.FB4DMQTY[FB0JWIX1];
    end
    if (FB0JM010.XWHCD == FB0JW05.XWHCD)
      FB0JW05.FB4SZPCT[FB0JWIX1] = FB0JW01.FB0JWP4; /* Size percent*/
      FB0JW05.FB4DMQTY[FB0JWIX1] = FB0JM010.FB4DMQTY[FB0JWIX1];
    end
    FB0JW01.FB0JWIX1 = FB0JW01.FB0JWIX1 + 1; /* increment size index*/
  end
  ;
  ;
  ;
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Calculate total percent and variance.*/
   /* ------------------------------------------------------------*/
  FB0JW01.FB0JWIX1 = 1; /* General index 1*/
  FB0JM010.FB0JMTPR = 0; /* Total percent*/
  FB0JM010.FB0JMTQT = 0; /* Total quantity*/
  FB0JM010.FB0JMVAR = 0; /* Variance*/
  while (FB0JW01.FB0JWIX1 <= 40) /* Max mbr of sizes*/
    FB0JM010.FB0JMTPR = FB0JM010.FB0JMTPR + FB0JM010.FB4SZPCT[FB0JWIX1];
    FB0JM010.FB0JMTQT = FB0JM010.FB0JMTQT + FB0JM010.FB4DMQTY[FB0JWIX1];
    FB0JW01.FB0JWIX1 = FB0JW01.FB0JWIX1 + 1; /* increment size index*/
  end
  ;
  FB0JM010.FB0JMVAR = FB0JM010.FB0JMTPR - 100;
  ;
  ;
  ;
  ;
   /* ------------------------------------------------------------*/
   /* After the variance has been determined, the variance will*/
   /* get put into the different size percents based on an*/
   /* algorithm that looks for percents that were the closest*/
   /* to being rounded.*/
   /* ------------------------------------------------------------*/
  if (FB0JM010.FB0JMVAR > 0)
    FB0J552(); /* Distribute positive variance*/
  else
    if (FB0JM010.FB0JMVAR < 0
     && FB0JM010.FB0JMVAR != -100)
      FB0J554(); /* Distribute negative variance*/
    end
  end
  ;
   /* ------------------------------------------------------------*/
   /* Calculate total quantity for all regions*/
   /* ------------------------------------------------------------*/
  FB0JM010.FB0JMGTQ = FB0JM010.FB0JMTQT; /* move map total to total*/
  ;
  FB0JW01.FB0JWIX1 = 1; /* General index 1*/
  ;
  while (FB0JW01.FB0JWIX1 <= 40) /* Max mbr of sizes*/
    if (FB0JW01.FB0JWCUR == FB0JW03.XWHCD) /* if 1st whse displayed*/
      FB0JM010.FB0JMGTQ = FB0JM010.FB0JMGTQ + FB0JW04.FB4DMQTY[FB0JWIX1];
      FB0JM010.FB0JMGTQ = FB0JM010.FB0JMGTQ + FB0JW05.FB4DMQTY[FB0JWIX1];
    end
    if (FB0JW01.FB0JWCUR == FB0JW04.XWHCD) /* if 2nd whse displayed*/
      FB0JM010.FB0JMGTQ = FB0JM010.FB0JMGTQ + FB0JW03.FB4DMQTY[FB0JWIX1];
      FB0JM010.FB0JMGTQ = FB0JM010.FB0JMGTQ + FB0JW05.FB4DMQTY[FB0JWIX1];
    end
    if (FB0JW01.FB0JWCUR == FB0JW05.XWHCD) /* if 3rd whse displayed*/
      FB0JM010.FB0JMGTQ = FB0JM010.FB0JMGTQ + FB0JW03.FB4DMQTY[FB0JWIX1];
      FB0JM010.FB0JMGTQ = FB0JM010.FB0JMGTQ + FB0JW04.FB4DMQTY[FB0JWIX1];
    end
    FB0JW01.FB0JWIX1 = FB0JW01.FB0JWIX1 + 1; /* increment size index*/
  end
  ;
end // end FB0J550

// Distribute positive variance
Function FB0J552()
  ;
  ;
   /* ------------------------------------------------------------*/
   /* After the variance has been determined to be positive, it*/
   /* will get subtracted from the size percents that are the*/
   /* closest to being rounded down.*/
   /* ------------------------------------------------------------*/
  ;
  while (FB0JM010.FB0JMVAR != 0) /* Percent variance total*/
    ;
    FB0JW01.FB0JWIX1 = 1; /* General index 1*/
    FB0JW01.FB0JWIX2 = 0; /* General index 2*/
    FB0JW01.FB0JWRVS = .99999; /* Rounding variance save*/
    FB0JW01.FB0JWRV = 0; /* Rounding variance*/
    FB0JW01.FB0JWPCS = 0; /* Percent save*/
    ;
    ;
    /* ------------------------------------------------------------*/
     /* Calculate size percents = quantity / total quantity (again)*/
    /* ------------------------------------------------------------*/
    while (FB0JW01.FB0JWIX1 <= 40) /* Max nbr of sizes*/
      if (FB0JM010.FB4DMQTY[FB0JWIX1] != 0) /* Don't divide into zero*/
        FB0JW01.FB0JWRV = FB0JM010.FB4DMQTY[FB0JWIX1] / FB0JM010.FB0JMTQT;
        FB0JW01.FB0JWRV = FB0JW01.FB0JWRV * 100; /* To get size percent*/
      else
        FB0JW01.FB0JWRV = 0;
      end
      /* ------------------------------------------------------------*/
       /* Calculate the rounded variance as the actual % - map %*/
      /* ------------------------------------------------------------*/
      FB0JW01.FB0JWRV = FB0JW01.FB0JWRV - FB0JM010.FB4SZPCT[FB0JWIX1];
      if (FB0JW01.FB0JWRVS > FB0JW01.FB0JWRV)
        FB0JW01.FB0JWPCS = FB0JM010.FB4SZPCT[FB0JWIX1]; /* save percent*/
        FB0JW01.FB0JWRVS = FB0JW01.FB0JWRV; /* Save smallest variance*/
        FB0JW01.FB0JWIX2 = FB0JW01.FB0JWIX1; /* save the index*/
                                                    /* of the smallest*/
                                                    /* variance*/
      else
        if (FB0JW01.FB0JWRVS == FB0JW01.FB0JWRV
         && FB0JW01.FB0JWPCS < FB0JM010.FB4SZPCT[FB0JWIX1])
          FB0JW01.FB0JWIX2 = FB0JW01.FB0JWIX1; /* save the index*/
          FB0JW01.FB0JWPCS = FB0JM010.FB4SZPCT[FB0JWIX1]; /* save percent*/
        end
      end
      FB0JW01.FB0JWIX1 = FB0JW01.FB0JWIX1 + 1; /* increment size index*/
    end
    FB0JM010.FB0JMVAR = FB0JM010.FB0JMVAR - .1;
    FB0JM010.FB4SZPCT[FB0JWIX2] = FB0JM010.FB4SZPCT[FB0JWIX2] - .1;
  end
  ;
  ;
  ;
end // end FB0J552

// Distribute negative variance
Function FB0J554()
  ;
  ;
   /* ------------------------------------------------------------*/
   /* After the variance has been determined to be negative, it*/
   /* will get added to the size percents that are the closest*/
   /* to being rounded up.*/
   /* ------------------------------------------------------------*/
  ;
  while (FB0JM010.FB0JMVAR != 0) /* Percent variance total*/
    ;
    FB0JW01.FB0JWIX1 = 1; /* General index 1*/
    FB0JW01.FB0JWIX2 = 0; /* General index 2*/
    FB0JW01.FB0JWRVS = -.99999; /* Rounding variance save*/
    FB0JW01.FB0JWRV = 0; /* Rounding variance*/
    FB0JW01.FB0JWPCS = 0; /* Percent save*/
    ;
    ;
    /* ------------------------------------------------------------*/
     /* Calculate size percents = quantity / total quantity (again)*/
    /* ------------------------------------------------------------*/
    while (FB0JW01.FB0JWIX1 <= 40) /* Max mbr of sizes*/
      if (FB0JM010.FB4DMQTY[FB0JWIX1] != 0) /* Don't divide into zero*/
        FB0JW01.FB0JWRV = FB0JM010.FB4DMQTY[FB0JWIX1] / FB0JM010.FB0JMTQT;
        FB0JW01.FB0JWRV = FB0JW01.FB0JWRV * 100; /* To get size percent*/
      else
        FB0JW01.FB0JWRV = 0;
      end
      /* ------------------------------------------------------------*/
       /* Calculate the rounded variance as the actual % - map %*/
      /* ------------------------------------------------------------*/
      FB0JW01.FB0JWRV = FB0JW01.FB0JWRV - FB0JM010.FB4SZPCT[FB0JWIX1];
      if (FB0JW01.FB0JWRVS < FB0JW01.FB0JWRV)
        FB0JW01.FB0JWRVS = FB0JW01.FB0JWRV; /* Save largest variance*/
        FB0JW01.FB0JWIX2 = FB0JW01.FB0JWIX1; /* save the index*/
                                                    /* of the largest*/
                                                    /* variance*/
        FB0JW01.FB0JWPCS = FB0JM010.FB4SZPCT[FB0JWIX1]; /* save percent*/
      else
        if (FB0JW01.FB0JWRVS == FB0JW01.FB0JWRV
         && FB0JW01.FB0JWPCS < FB0JM010.FB4SZPCT[FB0JWIX1])
          FB0JW01.FB0JWIX2 = FB0JW01.FB0JWIX1; /* save the index*/
          FB0JW01.FB0JWPCS = FB0JM010.FB4SZPCT[FB0JWIX1]; /* save percent*/
        end
      end
      FB0JW01.FB0JWIX1 = FB0JW01.FB0JWIX1 + 1; /* increment size index*/
    end
    FB0JM010.FB0JMVAR = FB0JM010.FB0JMVAR + .1;
    FB0JM010.FB4SZPCT[FB0JWIX2] = FB0JM010.FB4SZPCT[FB0JWIX2] + .1;
  end
  ;
  ;
  ;
end // end FB0J554

// Save map in working storage
Function FB0J560()
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Move the warehouses curve from the map to the appropriate*/
   /* working storage record.*/
   /* ------------------------------------------------------------*/
  ;
  if (FB0JW01.FB0JWCUR == FB0JW03.XWHCD) /* current warehouse code*/
    if (FB0JW01.FB0JWPMD == "Y") /* Percents were modified*/
      FB0JW03.FB4QTYLK = "Y"; /* quantity lock flag*/
    end
    FB0JW01.FB0JWIX1 = 1; /* General index 1*/
    FB0JW01.FB0JWIX2 = 1; /* General index 2*/
    while (FB0JW01.FB0JWIX2 <= 40) /* Max nbr of sizes*/
      if (FB0JW01.FB0JWIX2 < FB0JW01.FB0JWOFF) /* size display offset*/
        FB0JW03.FB4DMQTY[FB0JWIX2] = 0;
        FB0JW03.FB4SZPCT[FB0JWIX2] = 0;
        FB0JW01.FB0JWIX2 = FB0JW01.FB0JWIX2 + 1; /* increment size offset index*/
      else
        FB0JW03.FB4DMQTY[FB0JWIX2] = FB0JM010.FB4DMQTY[FB0JWIX1];
        FB0JW03.FB4SZPCT[FB0JWIX2] = FB0JM010.FB4SZPCT[FB0JWIX1];
        FB0JW01.FB0JWIX1 = FB0JW01.FB0JWIX1 + 1; /* increment size index*/
        FB0JW01.FB0JWIX2 = FB0JW01.FB0JWIX2 + 1; /* increment size offset index*/
      end
    end
  end
  ;
  ;
  ;
  ;
  ;
  if (FB0JW01.FB0JWCUR == FB0JW04.XWHCD) /* current warehouse code*/
    if (FB0JW01.FB0JWPMD == "Y") /* Percents were modified*/
      FB0JW04.FB4QTYLK = "Y"; /* quantity lock flag*/
    end
    FB0JW01.FB0JWIX1 = 1; /* General index 1*/
    FB0JW01.FB0JWIX2 = 1; /* General index 2*/
    while (FB0JW01.FB0JWIX2 <= 40) /* Max nbr of sizes*/
      if (FB0JW01.FB0JWIX2 < FB0JW01.FB0JWOFF) /* size display offset*/
        FB0JW04.FB4DMQTY[FB0JWIX2] = 0;
        FB0JW04.FB4SZPCT[FB0JWIX2] = 0;
        FB0JW01.FB0JWIX2 = FB0JW01.FB0JWIX2 + 1; /* increment size offset index*/
      else
        FB0JW04.FB4DMQTY[FB0JWIX2] = FB0JM010.FB4DMQTY[FB0JWIX1];
        FB0JW04.FB4SZPCT[FB0JWIX2] = FB0JM010.FB4SZPCT[FB0JWIX1];
        FB0JW01.FB0JWIX1 = FB0JW01.FB0JWIX1 + 1; /* increment size index*/
        FB0JW01.FB0JWIX2 = FB0JW01.FB0JWIX2 + 1; /* increment size offset index*/
      end
    end
  end
  ;
  ;
  ;
  ;
  ;
  if (FB0JW01.FB0JWCUR == FB0JW05.XWHCD) /* current warehouse code*/
    if (FB0JW01.FB0JWPMD == "Y") /* Percents were modified*/
      FB0JW05.FB4QTYLK = "Y"; /* quantity lock flag*/
    end
    FB0JW01.FB0JWIX1 = 1; /* General index 1*/
    FB0JW01.FB0JWIX2 = 1; /* General index 2*/
    while (FB0JW01.FB0JWIX2 <= 40) /* Max nbr of sizes*/
      if (FB0JW01.FB0JWIX2 < FB0JW01.FB0JWOFF) /* size display offset*/
        FB0JW05.FB4DMQTY[FB0JWIX2] = 0;
        FB0JW05.FB4SZPCT[FB0JWIX2] = 0;
        FB0JW01.FB0JWIX2 = FB0JW01.FB0JWIX2 + 1; /* increment size offset index*/
      else
        FB0JW05.FB4DMQTY[FB0JWIX2] = FB0JM010.FB4DMQTY[FB0JWIX1];
        FB0JW05.FB4SZPCT[FB0JWIX2] = FB0JM010.FB4SZPCT[FB0JWIX1];
        FB0JW01.FB0JWIX1 = FB0JW01.FB0JWIX1 + 1; /* increment size index*/
        FB0JW01.FB0JWIX2 = FB0JW01.FB0JWIX2 + 1; /* increment size offset index*/
      end
    end
  end
  ;
  ;
  ;
  ;
end // end FB0J560

// Process valid input request
Function FB0J600()
  ;
  FB0JM010.XXXMODID = "600";
  ;
  ;
  ;
   /* ------------------------------------------------------------*/
   /* In this case we have come from fb0e (assign to products)*/
   /* which tries to assign the curve to a product.  Size in the*/
   /* curve were invalid for the product.  The curve has been*/
   /* edited/maintenanced using sizes from the assigned to*/
   /* product.  Now control will be passed back to fb0e,*/
   /* along with updated curves in fbwrec.*/
   /* ------------------------------------------------------------*/
  ;
  if (converseVar.eventKey is pf3) /* Return to previous application*/
    if (FB0JW01.FB0JWPSW == "IU" /* invalid user curve*/
     || FB0JW01.FB0JWPSW == "IP") /* invalid product curve*/
      FB0JW02.FB0JWGP1 = FB0JW03.FB0JWGRP;
                                   /* Size data, 1st warehouse*/
      FB0JW02.FB0JWGP2 = FB0JW04.FB0JWGRP;
                                   /* Size data, 2nd warehouse*/
      FB0JW02.FB0JWGP3 = FB0JW05.FB0JWGRP;
                                   /* Size data, 3rd warehouse*/
      FBWREC.FBWFILL = FB0JW02.FB0JWGR0; /* Area used by fb0e*/
      COMMAREA.CAUSERA = FBWREC.FBWGROUP; /* Common user area*/
      COMMAREA.CATOAP = "FB0E"; /* TO application*/
      COMMAREA.CAITEM = " "; /* Application data*/
      XSEXIT(); /* Exit to fb0e*/
      FB0JM010.VAGen_EZEMSG = COMMAREA.CAMSG; /* if bad transfer*/
      exit stack; /* return to show error msg*/
    end
  end
  ;
  ;
  ;
  ;
  if (converseVar.eventKey is pf9) /* Update*/
    FB0JW01.FB0JWUPD = "U"; /* Update is pending flag*/
    FB0J610(); /* update the data base*/
  end
  ;
  ;
  ;
  ;
  ;
  if (converseVar.eventKey is pf9) /* Update*/
    if (FB0JW01.FB0JWSTM == "Y") /* standard flag was turned on*/
      FB0J620(); /* turn off standard for other curves*/
      if (converseVar.validationMsgNum == 0  /* No errors*/
       || converseVar.validationMsgNum == 50 /* Warning*/
       || converseVar.validationMsgNum == 52) /* Warning*/
        FB0JW01.FB0JWUPD = " "; /* Reset Update is pending flag*/
        FB0JW01.FB0JWWM1 = " "; /* Reset warehouse 1 modified flag*/
        FB0JW01.FB0JWWM2 = " "; /* Reset warehouse 2 modified flag*/
        FB0JW01.FB0JWWM3 = " "; /* Reset warehouse 3 modified flag*/
        FB0JW01.FB0JWSTM = " "; /* Reset standard is modified flag*/
        FB0JW01.FB0JWDSW = "Y";
                                   /* To re-display the updated rows*/
        VGVar.handleSysLibraryErrors = 0;
        sysLib.commit();
        converseLib.validationFailed(32); /* Updated successful*/
        FB0JW01.FB0JWIX1 = 40; /* General index 1*/
        while (FB0JW01.FB0JWIX1 >= 1) /* Looping from the bottom up*/
          set FB0JM010.FB4DMQTY[FB0JWIX1] initialAttributes; /* Demand quantity*/
          set FB0JM010.FB4SZPCT[FB0JWIX1] initialAttributes; /* Size percent*/
          FB0JW01.FB0JWIX1 = FB0JW01.FB0JWIX1 - 1; /* decrement size index*/
        end
        return;
      end
    else
      if (converseVar.validationMsgNum == 0  /* No errors*/
       || converseVar.validationMsgNum == 50 /* Warning*/
       || converseVar.validationMsgNum == 52) /* Warning*/
        FB0JW01.FB0JWUPD = " "; /* Reset Update is pending flag*/
        FB0JW01.FB0JWWM1 = " "; /* Reset warehouse 1 modified flag*/
        FB0JW01.FB0JWWM2 = " "; /* Reset warehouse 2 modified flag*/
        FB0JW01.FB0JWWM3 = " "; /* Reset warehouse 3 modified flag*/
        FB0JW01.FB0JWDSW = "Y";
                                   /* To re-display the updated rows*/
        VGVar.handleSysLibraryErrors = 0;
        sysLib.commit();
        converseLib.validationFailed(32); /* Updated successful*/
        FB0JW01.FB0JWIX1 = 40; /* General index 1*/
        while (FB0JW01.FB0JWIX1 >= 1) /* Looping from the bottom up*/
          set FB0JM010.FB4DMQTY[FB0JWIX1] initialAttributes; /* Demand quantity*/
          set FB0JM010.FB4SZPCT[FB0JWIX1] initialAttributes; /* Size percent*/
          FB0JW01.FB0JWIX1 = FB0JW01.FB0JWIX1 - 1; /* decrement size index*/
        end
        return;
      end
    end
  end
  ;
  ;
  ;
  ;
  if (converseVar.eventKey is pf17) /* Delete*/
    if (FB0JW01.FB0JWUPD == "D") /* A delete is pending*/
      FB0J630(); /* Delete the curve*/
      if (converseVar.validationMsgNum == 0)
        FB0JW01.FB0JWUPD = " "; /* Reset Update is pending flag*/
        set FB0JM010 initial; /* Clear map*/
        VGVar.handleSysLibraryErrors = 0;
        sysLib.commit();
        converseLib.validationFailed(141); /* Updated successful*/
        FB0JW01.FB0JWPSW = "NO"; /* processing switch*/
                                        /* This application no longer*/
                                        /* has anything to maintain*/
      end
    else
      FB0JW01.FB0JWUPD = "D"; /* A delete is pending*/
      converseLib.validationFailed(59); /* Confirm delete message*/
    end
  end
  ;
  ;
end // end FB0J600

// Update
Function FB0J610()
   /* ------------------------------------------------------------*/
   /* Set up fb4rec with fields that are common for each whse*/
   /* ------------------------------------------------------------*/
  ;
  ;
  set FB4REC empty;
  FB4REC.FB1INSEQ = FBWREC.FB1INSEQ;
  FB4REC.XGPCD = FBWREC.XGPCD; /* product group code*/
  FB4REC.SY1STNBR = FBWREC.SY1STNBR; /* style number*/
  FB4REC.SY2CLRID = FBWREC.SY2CLRID; /* color*/
  FB4REC.XDMCD = FBWREC.XDMCD; /* dimension*/
  FB4REC.XQACD = FBWREC.XQACD; /* quality code*/
  FB4REC.PC2INSEG = FBWREC.PC2INSEG; /* spec difference*/
  FB4REC.XSACD = FBWREC.XSACD; /* shade*/
  FB4REC.XPGCD = FBWREC.XPGCD; /* package type*/
  FB4REC.XUMCD = FBWREC.XUMCD; /* unit of measure*/
  XX0XS01(); /* Common date format routine*/
  FB4REC.ZZZCHGDT = XX0XW01.XX0XWDAT; /* Change date*/
  FB4REC.ZZZCHGTM = XX0XW01.XX0XWTIM; /* Change time*/
  ;
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Do an update for each warehouse that has changed.*/
   /* ------------------------------------------------------------*/
  ;
  ;
  if (FB0JW01.FB0JWWM1 == "Y") /* Warehouse 1 was modified*/
    FB4REC.XWHCD = FB0JW03.XWHCD; /* warehouse*/
    FB4REC.FB4CRVNB = FB0JW03.FB4CRVNB; /* curve number*/
    FB4REC.FB4STDFL = FB0JW03.FB4STDFL; /* standard flag*/
    FB4REC.FB4QTYLK = FB0JW03.FB4QTYLK; /* quantity lock flag*/
    FB4REC.FB4RGPCT = FB0JW03.FB4RGPCT; /* region percent*/
    FB4REC.ZZZSDT = FB0JW03.ZZZSDT; /* set up date*/
    FB4REC.ZZZCHGCT = FB0JW03.ZZZCHGCT; /* change count*/
    FB0JW01.FB0JWIX1 = 1; /* General index 1*/
    while (FB0JW01.FB0JWIX1 <= 40) /* Max mbr of sizes*/
      FB4REC.FB4DMQTY[FB0JWIX1] = FB0JW03.FB4DMQTY[FB0JWIX1]; /* dmd qty*/
      FB4REC.FB4SZPCT[FB0JWIX1] = FB0JW03.FB4SZPCT[FB0JWIX1]; /* sz pct*/
      FB0JW01.FB0JWIX1 = FB0JW01.FB0JWIX1 + 1; /* increment size index*/
    end
    ;
    FB0J612(); /* update vcurve01 row*/
    ;
  end
  ;
  ;
  if (FB0JW01.FB0JWWM2 == "Y") /* Warehouse 2 was modified*/
    FB4REC.XWHCD = FB0JW04.XWHCD; /* warehouse*/
    FB4REC.FB4CRVNB = FB0JW04.FB4CRVNB; /* curve number*/
    FB4REC.FB4STDFL = FB0JW04.FB4STDFL; /* standard flag*/
    FB4REC.FB4QTYLK = FB0JW04.FB4QTYLK; /* quantity lock flag*/
    FB4REC.FB4RGPCT = FB0JW04.FB4RGPCT; /* region percent*/
    FB4REC.ZZZSDT = FB0JW04.ZZZSDT; /* set up date*/
    FB4REC.ZZZCHGCT = FB0JW04.ZZZCHGCT; /* change count*/
    FB0JW01.FB0JWIX1 = 1; /* General index 1*/
    while (FB0JW01.FB0JWIX1 <= 40) /* Max mbr of sizes*/
      FB4REC.FB4DMQTY[FB0JWIX1] = FB0JW04.FB4DMQTY[FB0JWIX1]; /* dmd qty*/
      FB4REC.FB4SZPCT[FB0JWIX1] = FB0JW04.FB4SZPCT[FB0JWIX1]; /* sz pct*/
      FB0JW01.FB0JWIX1 = FB0JW01.FB0JWIX1 + 1; /* increment size index*/
    end
    ;
    FB0J612(); /* update vcurve01 row*/
    ;
  end
  ;
  ;
  if (FB0JW01.FB0JWWM3 == "Y") /* Warehouse 3 was modified*/
    FB4REC.XWHCD = FB0JW05.XWHCD; /* warehouse*/
    FB4REC.FB4CRVNB = FB0JW05.FB4CRVNB; /* curve number*/
    FB4REC.FB4STDFL = FB0JW05.FB4STDFL; /* standard flag*/
    FB4REC.FB4QTYLK = FB0JW05.FB4QTYLK; /* quantity lock flag*/
    FB4REC.FB4RGPCT = FB0JW05.FB4RGPCT; /* region percent*/
    FB4REC.ZZZSDT = FB0JW05.ZZZSDT; /* set up date*/
    FB4REC.ZZZCHGCT = FB0JW05.ZZZCHGCT; /* change count*/
    FB0JW01.FB0JWIX1 = 1; /* General index 1*/
    while (FB0JW01.FB0JWIX1 <= 40) /* Max mbr of sizes*/
      FB4REC.FB4DMQTY[FB0JWIX1] = FB0JW05.FB4DMQTY[FB0JWIX1]; /* dmd qty*/
      FB4REC.FB4SZPCT[FB0JWIX1] = FB0JW05.FB4SZPCT[FB0JWIX1]; /* sz pct*/
      FB0JW01.FB0JWIX1 = FB0JW01.FB0JWIX1 + 1; /* increment size index*/
    end
    ;
    FB0J612(); /* update vcurve01 row*/
    ;
  end
  ;
end // end FB0J610

// Update the data base (vcurve01
Function FB0J612()
  ;
   /* ------------------------------------------------------------*/
   /* Update the changed row in the dfbuy.vcurve01 table.*/
   /* ------------------------------------------------------------*/
  ;
  try
    call "IO3020" ("U ", SQLCA, FB4REC) {isNoRefresh = yes, isExternal = yes};
  end /* Update row*/
  ;
   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/
  ;
  if (sysVar.errorCode == "00000000") /* Call successful*/
    ;
    if (SQLCA.VAGen_SQLCODE == 0) /* Normal return code*/
      return; /* Return to previous process*/
    else
      if (SQLCA.VAGen_SQLCODE == 100) /* Not found*/
        VGVar.handleSysLibraryErrors = 0;
        sysLib.rollback(); /* Back out current db2 unit of work*/
        converseLib.validationFailed(20); /* Record has been updated since last displayed*/
        return; /* Return to previous process*/
      end
      ;
    end
  end
  ;
   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/
  ;
  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/
  ;
  FB0JM010.XXXMODID = "612"; /* Module identification*/
  ;
  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/
    ;
    converseLib.validationFailed(19); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
    ;
  else
    ;
    converseLib.validationFailed(1); /* Indicate system error*/
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback(); /* Back out current db2 unit of work*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    ;
    converseLib.clearScreen();
     /* Clear screen before display*/
    ;
  end
  ;
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "UPDATE VCURVE01 ROW           ";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FB0JM010.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFBUY   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCURVE01"; /* Table view name*/
  TA1REC.TA1TBLKE = FB4REC.FB4KEY; /* Table key*/
  ;
  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/
  ;
  exit stack; /* Exit to display map*/
  ;
  ;
end // end FB0J612

// Turn off std fl on other curvs
Function FB0J620()
   /* ------------------------------------------------------------*/
  ;
   /* The standard flag has been turned on for the current curve.*/
   /* This means that the standard flag must be turned off for*/
   /* the previous standard curve.*/
   /* This process will do a select set on vcurve01,*/
   /* then do a select next (with updating) until end of set and*/
   /* finally close the set.*/
   /* ------------------------------------------------------------*/
  ;
  ;
  ;
  ;
  FB0J622(); /* Select set vcurve01*/
  ;
  ;
  ;
  set SQLCA empty; /* To set sqlcode to zero*/
  while (SQLCA.VAGen_SQLCODE == 0) /* Good return code*/
    FB0J624(); /* Select next vcurve01 row*/
  end
  ;
  FB0J626(); /* Close set vcurve01*/
  ;
end // end FB0J620

// Select set vcurve01
Function FB0J622()
   /* ------------------------------------------------------------*/
   /* Initialize the storage areas and indicators to be used*/
   /* ------------------------------------------------------------*/
  ;
  set FB4REC empty; /* clear row storage area*/
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Format the key with saved sequence number from fbwrec.*/
   /* ------------------------------------------------------------*/
  ;
  FB4REC.FB1INSEQ = -1; /* wild card to get all*/
  FB4REC.XGPCD = FBWREC.XGPCD; /* product group code*/
  FB4REC.SY1STNBR = FBWREC.SY1STNBR; /* style number*/
  FB4REC.SY2CLRID = FBWREC.SY2CLRID; /* color*/
  FB4REC.XDMCD = FBWREC.XDMCD; /* dimension*/
  FB4REC.XQACD = FBWREC.XQACD; /* quality code*/
  FB4REC.PC2INSEG = FBWREC.PC2INSEG; /* spec difference*/
  FB4REC.XSACD = FBWREC.XSACD; /* shade*/
  FB4REC.XPGCD = FBWREC.XPGCD; /* package type*/
  FB4REC.XUMCD = FBWREC.XUMCD; /* unit of measure*/
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Select the requested set of rows from the table.*/
   /* ------------------------------------------------------------*/
  ;
  try
    call "IO3020" ("S1", SQLCA, FB4REC) {isNoRefresh = yes, isExternal = yes};
  end /* Select table set*/
  ;
   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/
  ;
  if (sysVar.errorCode == "00000000") /* Call successful*/
    if (SQLCA.VAGen_SQLCODE == 0) /* and normal return code*/
      ;
      return; /* Return to previous process*/
    end
    ;
  end
  ;
   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/
  ;
  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/
  ;
  FB0JM010.XXXMODID = "622"; /* Module identification*/
  ;
  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/
    ;
    converseLib.validationFailed(19); /* 'Resources unavailable'*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
    ;
  else
    ;
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback(); /* Back out current db2 unit of work*/
    converseLib.validationFailed(01); /* 'Error - Please nofity programming'*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    ;
    converseLib.clearScreen();
     /* Clear screen before display*/
    ;
  end
  ;
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "IO TO OPEN DFCAST.VCURVE01";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FB0JM010.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFCAST  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCURVE01"; /* Table view name*/
  TA1REC.TA1TBLKE = FB4REC.FB4KEY; /* Table key*/
  ;
  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/
  ;
  ;
  ;
  ;
end // end FB0J622

// Get next vcurve01 row
Function FB0J624()
   /* ------------------------------------------------------------*/
   /* Select the next row to display from the table.*/
   /* ------------------------------------------------------------*/
  ;
  try
    call "IO3020" ("N1", SQLCA, FB4REC) {isNoRefresh = yes, isExternal = yes};
  end /* Fetch next row*/
  ;
   /* ------------------------------------------------------------*/
   /* If successful,*/
     /* if the curve is not the current one that was just*/
      /* changed to standard= 'y'*/
      /* and the standard flag = 'n'*/
           /* update the standard flag to 'n'.*/
   /* ------------------------------------------------------------*/
  ;
  if (sysVar.errorCode == "00000000") /* Call successful*/
    ;
    if (SQLCA.VAGen_SQLCODE == 100) /* End of cursor*/
      return;
    else
      if (SQLCA.VAGen_SQLCODE == 0) /* Normal return code*/
        ;
        if (FB4REC.FB1INSEQ != FBWREC.FB1INSEQ /* fb-intrn-seq-nbr*/
         && FB4REC.FB4STDFL == "Y")            /* Standard curve flag*/
          FB4REC.FB4STDFL = "N"; /* Standard curve flag*/
          XX0XS01(); /* Common date format routine*/
          FB4REC.ZZZCHGDT = XX0XW01.XX0XWDAT; /* Change date*/
          FB4REC.ZZZCHGTM = XX0XW01.XX0XWTIM; /* Change time*/
          FB0J612(); /* update vcurve01*/
          FB0JS01(); /* check for duplicates*/
        else
          ;
          if (FB4REC.FB1INSEQ == FBWREC.FB1INSEQ /* fb-intrn-seq-nbr*/
           && FB4REC.FB4CRVNB != FBWREC.FB4CRVNB /* fb-sz-pct-crv-nbr*/
           && FB4REC.FB4STDFL == "Y")            /* Standard curve flag*/
            FB4REC.FB4STDFL = "N"; /* Standard curve flag*/
            XX0XS01(); /* Common date format routine*/
            FB4REC.ZZZCHGDT = XX0XW01.XX0XWDAT; /* Change date*/
            FB4REC.ZZZCHGTM = XX0XW01.XX0XWTIM; /* Change time*/
            FB0J612(); /* update vcurve01*/
            FB0JS01(); /* check for duplicates*/
          end
        end
        ;
        return;
      end
    end
    ;
    ;
  end
  ;
   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/
  ;
  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/
  ;
  FB0JM010.XXXMODID = "624"; /* Module identification*/
  ;
  if (SQLCA.VAGen_SQLCODE == -911) /* Resource not available*/
    ;
    converseLib.validationFailed(19); /* 'resources unavailable'*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
    ;
  else
    ;
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback(); /* Back out current db2 unit of work*/
    converseLib.validationFailed(01); /* 'error - please nofity programming'*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    ;
    converseLib.clearScreen();
     /* Clear screen before display*/
    ;
  end
  ;
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "FETCH NEXT TABLE ROW";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FB0JM010.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFBUY   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCURVE01"; /* Table view name*/
  TA1REC.TA1TBLKE = FB4REC.FB4KEY; /* Table key*/
  ;
  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/
  ;
  ;
  ;
end // end FB0J624

// Close set vcurve01
Function FB0J626()
   /* ------------------------------------------------------------*/
   /* Close the selected set of table rows for vcurve01*/
   /* ------------------------------------------------------------*/
  ;
  try
    call "IO3020" ("C1", SQLCA, FB4REC) {isNoRefresh = yes, isExternal = yes};
  end /* Close table set*/
  ;
   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/
  ;
  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* and normal return code*/
    ;
    return; /* Return to previous process*/
    ;
  end
  ;
   /* ------------------------------------------------------------*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/
  ;
  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/
  ;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback(); /* Back out current db2 unit of work*/
  FB0JM010.XXXMODID = "626"; /* Module identification*/
  converseLib.validationFailed(01); /* 'Error - Please nofity programming'*/
  ;
  TA1REC.TA1FUNC = "RETN"; /* Termination function*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "CLOSE VCURVE01 TABLE ROWS";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FB0JM010.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFBUY    "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCURVE01"; /* Table view name*/
  ;
  call "TA0020" (TA1REC, TAEREC) {isExternal = yes}; /* Error diagnosis routine*/
  ;
  ;
  ;
end // end FB0J626

// Delete
Function FB0J630()
  ;
   /* ------------------------------------------------------------*/
   /* Delete the row from dfcast.vcurve01 table.*/
   /* ------------------------------------------------------------*/
  ;
  FB0J632(); /* Delete vcurve01 rows*/
  ;
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Now, see if that was the last curve for the associated*/
   /* selection criteria.  If so, delete the selection criteria.*/
   /* ------------------------------------------------------------*/
  ;
  FB0J633(); /* Select count*/
  ;
  if (FBZREC.FBZSUM1 == 0) /* Last curve has been deleted*/
    FB0J635(); /* Delete vselhd01 row*/
    FB0J636(); /* Delete vseldt01 row*/
    FB0J637(); /* Delete vselst01 row*/
  end
  ;
  ;
  ;
  ;
  if (FB0JW01.FB0JWPSW == "DU" /* display user curve*/
   && FBZREC.FBZSUM1 > 0)      /* Curves still exist for intrn-seq-nbr*/
    FB0J639(); /* Change status to assigned*/
  end
end // end FB0J630

// Delete vcurve01 rows
Function FB0J632()
  set FB4REC empty;
  FB4REC.FB1INSEQ = FBWREC.FB1INSEQ;
  FB4REC.FB4CRVNB = FBWREC.FB4CRVNB;
  FB4REC.XGPCD = FBWREC.XGPCD; /* product group code*/
  FB4REC.SY1STNBR = FBWREC.SY1STNBR; /* style number*/
  FB4REC.SY2CLRID = FBWREC.SY2CLRID; /* color*/
  FB4REC.XDMCD = FBWREC.XDMCD; /* dimension*/
  FB4REC.XQACD = FBWREC.XQACD; /* quality code*/
  FB4REC.PC2INSEG = FBWREC.PC2INSEG; /* spec difference*/
  FB4REC.XSACD = FBWREC.XSACD; /* shade*/
  FB4REC.XPGCD = FBWREC.XPGCD; /* package type*/
  FB4REC.XUMCD = FBWREC.XUMCD; /* unit of measure*/
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Delete the row from dfbuy.vcurve01 table.*/
   /* ------------------------------------------------------------*/
  ;
  try
    call "IO3020" ("D ", SQLCA, FB4REC) {isNoRefresh = yes, isExternal = yes};
  end /* Update row*/
  ;
   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/
  ;
  if (sysVar.errorCode == "00000000") /* Call successful*/
    ;
    if (SQLCA.VAGen_SQLCODE == 0 /* Normal return code*/
     || SQLCA.VAGen_SQLCODE == 100) /* Not found*/
      return; /* Return to previous process*/
    end
    ;
  end
  ;
   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/
  ;
  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/
  ;
  FB0JM010.XXXMODID = "632"; /* Module identification*/
  ;
  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/
    ;
    converseLib.validationFailed(19); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
    ;
  else
    ;
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback(); /* Back out current db2 unit of work*/
    converseLib.validationFailed(1); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    ;
    converseLib.clearScreen();
     /* Clear screen before display*/
    ;
  end
  ;
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "DELETE VCURVE01 ROWS          ";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FB0JM010.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFBUY   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCURVE01"; /* Table view name*/
  TA1REC.TA1TBLKE = FB4REC.FB4KEY; /* Table key*/
  ;
  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/
  ;
  exit stack; /* Exit to display map*/
  ;
  ;
end // end FB0J632

// Select count on vcurve01
Function FB0J633()
  set FB4REC empty;
  set FBZREC empty; /* Record used for select count*/
  FBZREC.FBZFUNC = "SC"; /* Select count function code*/
  FB4REC.FB1INSEQ = FBWREC.FB1INSEQ; /* Fb-intrn-seq-nbr*/
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Select count from dfbuy.vcurve01 table.*/
   /* ------------------------------------------------------------*/
  ;
  try
    call "IO3020" (FBZREC, SQLCA, FB4REC) {isNoRefresh = yes, isExternal = yes};
  end
  ;
   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/
  ;
  if (sysVar.errorCode == "00000000") /* Call successful*/
    ;
    if (SQLCA.VAGen_SQLCODE == 0) /* Normal return code*/
      return; /* Return to previous process*/
    end
    ;
  end
  ;
   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/
  ;
  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/
  ;
  FB0JM010.XXXMODID = "633"; /* Module identification*/
  ;
  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/
    ;
    converseLib.validationFailed(19); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
    ;
  else
    ;
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback(); /* Back out current db2 unit of work*/
    converseLib.validationFailed(1); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    ;
    converseLib.clearScreen();
     /* Clear screen before display*/
    ;
  end
  ;
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "SELECT COUNT VCURVE01 ROWS  ";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FB0JM010.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFBUY   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCURVE01"; /* Table view name*/
  TA1REC.TA1TBLKE = FB4REC.FB4KEY; /* Table key*/
  ;
  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/
  ;
  exit stack; /* Exit to display map*/
  ;
  ;
end // end FB0J633

// Delete vselhd01 rows
Function FB0J635()
  set FB1REC empty;
  FB1REC.FB1INSEQ = FBWREC.FB1INSEQ;
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Delete the row from dfbuy.vselhd01 table.*/
   /* ------------------------------------------------------------*/
  ;
  try
    call "IO3030" ("D ", SQLCA, FB1REC) {isNoRefresh = yes, isExternal = yes};
  end
  ;
   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/
  ;
  if (sysVar.errorCode == "00000000") /* Call successful*/
    ;
    if (SQLCA.VAGen_SQLCODE == 0 /* Normal return code*/
     || SQLCA.VAGen_SQLCODE == 100) /* Not found*/
      return; /* Return to previous process*/
    end
    ;
  end
  ;
   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/
  ;
  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/
  ;
  FB0JM010.XXXMODID = "635"; /* Module identification*/
  ;
  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/
    ;
    converseLib.validationFailed(19); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
    ;
  else
    ;
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback(); /* Back out current db2 unit of work*/
    converseLib.validationFailed(1); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    ;
    converseLib.clearScreen();
     /* Clear screen before display*/
    ;
  end
  ;
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "DELETE VSELHD01 ROWS          ";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FB0JM010.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFBUY  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VSELHD01"; /* Table view name*/
  TA1REC.TA1TBLKE = FB1REC.FB1KEY; /* Table key*/
  ;
  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/
  ;
  exit stack; /* Exit to display map*/
  ;
  ;
end // end FB0J635

// Delete vseldt01 rows
Function FB0J636()
  set FB5REC empty;
  FB5REC.FB1INSEQ = FBWREC.FB1INSEQ;
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Delete the row from dfbuy.vseldt01 table.*/
   /* ------------------------------------------------------------*/
  ;
  try
    call "IO3040" ("D ", SQLCA, FB5REC) {isNoRefresh = yes, isExternal = yes};
  end
  ;
   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/
  ;
  if (sysVar.errorCode == "00000000") /* Call successful*/
    ;
    if (SQLCA.VAGen_SQLCODE == 0 /* Normal return code*/
     || SQLCA.VAGen_SQLCODE == 100) /* Not found*/
      return; /* Return to previous process*/
    end
    ;
  end
  ;
   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/
  ;
  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/
  ;
  FB0JM010.XXXMODID = "636"; /* Module identification*/
  ;
  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/
    ;
    converseLib.validationFailed(19); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
    ;
  else
    ;
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback(); /* Back out current db2 unit of work*/
    converseLib.validationFailed(1); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    ;
    converseLib.clearScreen();
     /* Clear screen before display*/
    ;
  end
  ;
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "DELETE VSELDT01 ROWS          ";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FB0JM010.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFBUY   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VSELDT01"; /* Table view name*/
  TA1REC.TA1TBLKE = FB5REC.FB5KEY; /* Table key*/
  ;
  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/
  ;
  exit stack; /* Exit to display map*/
  ;
  ;
end // end FB0J636

// Delete vselst01 rows
Function FB0J637()
  set FB6REC empty;
  FB6REC.FB1INSEQ = FBWREC.FB1INSEQ;
  ;
  ;
   /* ------------------------------------------------------------*/
   /* Delete the row from dfbuy.vselst01 table.*/
   /* ------------------------------------------------------------*/
  ;
  try
    call "IO3060" ("D ", SQLCA, FB6REC) {isNoRefresh = yes, isExternal = yes};
  end
  ;
   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/
  ;
  if (sysVar.errorCode == "00000000") /* Call successful*/
    ;
    if (SQLCA.VAGen_SQLCODE == 0 /* Normal return code*/
     || SQLCA.VAGen_SQLCODE == 100) /* Not found*/
      return; /* Return to previous process*/
    end
    ;
  end
  ;
   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/
  ;
  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/
  ;
  FB0JM010.XXXMODID = "637"; /* Module identification*/
  ;
  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/
    ;
    converseLib.validationFailed(19); /* Indicate not available*/
    TA1REC.TA1FUNC = "POST"; /* Termination function*/
    ;
  else
    ;
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback(); /* Back out current db2 unit of work*/
    converseLib.validationFailed(1); /* Indicate system error*/
    TA1REC.TA1FUNC = "RETN"; /* Termination function*/
    ;
    converseLib.clearScreen();
     /* Clear screen before display*/
    ;
  end
  ;
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "DELETE VSELST01 ROWS          ";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FB0JM010.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFBUY  "; /* Data base name*/
  TA1REC.TA1TBLVU = "VSELST01"; /* Table view name*/
  TA1REC.TA1TBLKE = FB6REC.FB6KEY; /* Table key*/
  ;
  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/
  ;
  exit stack; /* Exit to display map*/
  ;
  ;
end // end FB0J637

// Update status on vselhd01
Function FB0J639()
   /* ------------------------------------------------------------*/
   /* Update the status on dfbuy.vselhd01 table.*/
   /* ------------------------------------------------------------*/
  ;
  FB1REC.FB1CRVST = "4"; /* set curve status to 'assigned'*/
  try
    call "IO3030" ("U ", SQLCA, FB1REC) {isNoRefresh = yes, isExternal = yes};
  end /* Update row*/
  ;
   /* ------------------------------------------------------------*/
   /* If successful, return to the previous process.*/
   /* ------------------------------------------------------------*/
  ;
  if (sysVar.errorCode == "00000000") /* Call successful*/
    ;
    if (SQLCA.VAGen_SQLCODE == 0) /* Normal return code*/
      return; /* Return to previous process*/
    end
    ;
  end
  ;
   /* ------------------------------------------------------------*/
   /* If data not available, return an error message to the user.*/
   /* Otherwise, indicate that a system error has occurred.*/
   /* ------------------------------------------------------------*/
  ;
  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/
  ;
  FB0JM010.XXXMODID = "639"; /* Module identification*/
  ;
  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 100)    /* Not found*/
    ;
    VGVar.handleSysLibraryErrors = 0;
    sysLib.rollback(); /* Back out current db2 unit of work*/
    converseLib.validationFailed(20); /* Record has been updated*/
    return; /* since last displayed*/
    ;
  else
    if (sysVar.errorCode == "00000000" /* Call successful*/
     && SQLCA.VAGen_SQLCODE == -911)   /* and resource not available*/
      ;
      converseLib.validationFailed(19); /* Indicate not available*/
      TA1REC.TA1FUNC = "POST"; /* Termination function*/
      ;
    else
      ;
      VGVar.handleSysLibraryErrors = 0;
      sysLib.rollback(); /* Back out current db2 unit of work*/
      converseLib.validationFailed(1); /* Indicate system error*/
      TA1REC.TA1FUNC = "RETN"; /* Termination function*/
      ;
      converseLib.clearScreen();
       /* Clear screen before display*/
      ;
    end
  end
  ;
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "UPDATE VSELHD01 ROW           ";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FB0JM010.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFBUY   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VSELHD01"; /* Table view name*/
  TA1REC.TA1TBLKE = FB1REC.FB1KEY; /* Table key*/
  ;
  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/
  ;
  exit stack; /* Exit to display map*/
  ;
  ;
end // end FB0J639

// Check duplicate stds
Function FB0JS01()
   /* ------------------------------------------------------------*/
   /* Verify that a duplicate standard was not just inserted to*/
   /* Dfbuy.Vcurve01.*/
   /* ------------------------------------------------------------*/
  ;
  set FBZREC empty;
  ;
  FBZREC.FBZFUNC = "CC";
  ;
  try
    call "IO3020" (FBZREC, SQLCA, FB4REC) {isNoRefresh = yes, isExternal = yes};
  end /* update row*/
  ;
   /* ------------------------------------------------------------*/
   /* If successful, return to calling process.*/
   /* ------------------------------------------------------------*/
  ;
  if (sysVar.errorCode == "00000000" /* Call successful*/
   && SQLCA.VAGen_SQLCODE == 0)      /* Normal return code*/
    ;
    if (FBZREC.FBZSUM1 <= 1) /* 1 std found - good call*/
      return; /* Return to previous process*/
    else
      ;
      VGVar.handleSysLibraryErrors = 0;
      sysLib.rollback(); /* rollback changes made by user*/
      ;
      converseLib.validationFailed(502); /* Unexpected error - DUP CURVES*/
      ;
      converseLib.clearScreen();
      
      ;
      TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
      TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/
      FB0JM010.XXXMODID = "S01"; /* Module identification*/
      TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
      TA1REC.TA1LOC = "CHECK DUPLICATE STDS";
      TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
      TA1REC.TA1PGMNO = FB0JM010.XXXMODID; /* Program number*/
      TA1REC.TA1DBASE = "DFBUY   "; /* Data base name*/
      TA1REC.TA1TBLVU = "VCURVE01"; /* Table view name*/
      TA1REC.TA1TBLKE = FB4REC.FB4KEY; /* Table key*/
      ;
      call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/
      ;
      set FB0JM010 initial;
      FBWREC.FBWFILL = " ";
      FB0JW01.FB0JW-DUP-STD-FL = "Y"; /* Duplicate standard flag*/
      FB0JW01.FB0JWDSW = " "; /* Display data switch*/
      FB0JW01.FB0JWPSW = "NO";
      exit stack; /* Exit to display map*/
    end
  end
  ;
  VGVar.handleSysLibraryErrors = 0;
  sysLib.rollback(); /* rollback changes made by user*/
  converseLib.validationFailed(1); /* Unexpected error*/
  ;
  converseLib.clearScreen();
  
  ;
  TA1REC.TA1MAP = sysVar.errorCode; /* CSP return code*/
  TAEREC.SQLCAREC = SQLCA.SQLCAREC; /* SQL commarea*/
  FB0JM010.XXXMODID = "S01"; /* Module identification*/
  TA1REC.TA1TYPE = "DB2 "; /* Type of error*/
  TA1REC.TA1LOC = "CHECK DUPLICATE STDS";
  TA1REC.TA1PGMAP = COMMAREA.CACURRAP; /* Program application*/
  TA1REC.TA1PGMNO = FB0JM010.XXXMODID; /* Program number*/
  TA1REC.TA1DBASE = "DFBUY   "; /* Data base name*/
  TA1REC.TA1TBLVU = "VCURVE01"; /* Table view name*/
  TA1REC.TA1TBLKE = FB4REC.FB4KEY; /* Table key*/
  ;
  call "TA0020" (TA1REC, TAEREC) {isNoRefresh = yes, isExternal = yes}; /* Error diagnosis routine*/
  ;
  exit stack; /* Exit to display map*/
  ;
  ;
end // end FB0JS01

//*** RECORD=FB0JW01 ****
// ------------------------
// Map 001 display storage.
// ------------------------
// ***********************
Record FB0JW01 type basicRecord
  5 * char(60) ; 
    10 FB0JWPSW FB0JWPSW ; 
    10 FB0JWUNP FB0JWUNP ; 
    10 FB0JWOFF FB0JWOFF ; 
    10 FB0JWSZP FB0JWSZP ; 
    10 FB0JWSZQ FB0JWSZQ ; 
    10 FB0JWSFS FB0JWSFS ; 
    10 FB0JWDSW FB0JWDSW ; 
    10 FB0JW-DUP-STD-FL FB0JW-DUP-STD-FL ; 
    10 FB0JWMAX FB0JWMAX ; 
    10 FB0JWWHS FB0JWWHS ; 
    10 FB0JWSTM FB0JWSTM ; 
    10 FB0JWWM1 FB0JWWM1 ; 
    10 FB0JWWM2 FB0JWWM2 ; 
    10 FB0JWWM3 FB0JWWM3 ; 
    10 FB0JWXFL FB0JWXFL ; 
    10 FB0JWCUR FB0JWCUR ; 
    10 FB0JWPMD FB0JWPMD ; 
    10 FB0JWQMD FB0JWQMD ; 
    10 FB0JWUPD FB0JWUPD ; 
    10 FB0JWP4 FB0JWP4 ; 
    10 FB0JWPCS FB0JWPCS ; 
    10 FB0JWRV FB0JWRV ; 
    10 FB0JWRVS FB0JWRVS ; 
    10 FB0JWIX1 FB0JWIX1 ; 
    10 FB0JWIX2 FB0JWIX2 ; 
    10 FB4QTYLK FB4QTYLK ; 
    10 XDVCD XDVCD ; 
end // end FB0JW01

// Duplicate standard flag
DataItem FB0JW-DUP-STD-FL char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Current warehouse
DataItem FB0JWCUR char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Display data switch
DataItem FB0JWDSW char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// General index 1
DataItem FB0JWIX1 smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// General index 2
DataItem FB0JWIX2 smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Maximum nbr of warehouses
DataItem FB0JWMAX smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Map offset count
DataItem FB0JWOFF smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Percent work field - 4 dec
DataItem FB0JWP4 num(7,4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Percent save
DataItem FB0JWPCS num(5,2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Percent was modified fl
DataItem FB0JWPMD char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Processing type switch
DataItem FB0JWPSW char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Quantity was modified fl
DataItem FB0JWQMD char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Rounding variance
DataItem FB0JWRV num(8,5)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Rounding variance save
DataItem FB0JWRVS num(8,5)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// size found switch
DataItem FB0JWSFS char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Standard flag was changed
DataItem FB0JWSTM char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// size percent error switch
DataItem FB0JWSZP char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// size quantity error switch
DataItem FB0JWSZQ char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Column to unprotect sw
DataItem FB0JWUNP num(2)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Update is pending flag
DataItem FB0JWUPD char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Warehouse count
DataItem FB0JWWHS smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// Warehouse 1 was modified fl
DataItem FB0JWWM1 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Warehouse 2 was modified fl
DataItem FB0JWWM2 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Warehouse 3 was modified fl
DataItem FB0JWWM3 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// Transfer override flag
DataItem FB0JWXFL char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

