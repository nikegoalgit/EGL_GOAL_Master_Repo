package mn0a;
import corpcom1.*;
import corpcom2.*;
import corpcom4.*;
import corpcom5.*;
import corpcom6.*;
import corpcom7.*;
import corpx1.*;
import corpx2.*;
import corpz3.*;
import mn.common.*;
import ta.common.*;
//*** PROGRAM=MN0A ****
// 
//               menu application security system
// 
//         This application will maintain the application
// records on the menu file.
// 
//         The user and application records are contained
// within the same file.  The break down is as follows...
// 
//         MN1REC - application records.  These are all the
//                  valid applications that can be run.
//                  Associated with each application are
//                  flags to show what capabilites the
//                  application can have.  The capabilities
//                  are add, change, delete and inquiry.
// 
//         MN2REC - User records.  Each valid user will have
//                  a record.
// 
//         MN3REC - User application records.  These records
//                  show all the applications that a user can
//                  access and what capabilities those user's
//                  have within the applications.
// 
// 
// There are 4 functions to this application.
// 
//         Application menu.                    process mn0a001
//                                                      mn0a002
// 
//         Add applications.                    process mn0a010
//                                                      mn0a011
//                                                      mn0a012
//                                                      mn0a013
//                                                      mn0a014
// 
//         Change applications.                 process mn0a020
//                                                      mn0a021
//                                                      mn0a022
//                                                      mn0a023
//                                                      mn0a024
//                                                      mn0a025
//                                                      mn0a026
// 
//          Delete applications.                process mn0a030
//                                                      mn0a031
//                                                      mn0a032
//                                                      mn0a033
//                                                      mn0a034
//                                                      mn0a035
//                                                      mn0a036
// 
//          Inquiry into applications           process mn0a040
//                                                      mn0a041
//                                                      mn0a042
//                                                      mn0a043
//                                                      mn0a044
//                                                      mn0a045
//                                                      mn0a046
//                                                      mn0a047
// 
// 
// ************************************************************
// 
//   Created febuary 27, 1985             dpb
// 
//   maintenance log.
// 
// 
//   open item |    date  | int |          comments
// ------------|----------|-----|------------------------------
//             |06-12-87  |jbw  |logic to allow "&" record
//             |          |     |deletes for user-id of "jwood"
//             |08-14-89  |jbw  |added commits to record updts
//             |09-05-89  |jbw  |FIX FOR NEW MN2REC KEY
//             |07-31-90  |jbw  |ALLOW DWHIT2 TO DELETE &'s
//             |08-01-90  |jbw  |disallow change of &'s
//             |04-04-91  |jbw  |allow NO flags to be set ----
//             |   NOTE: If major flag set to N during CHANGE
//             |   option, all sub-level flags for that major
//             |   grouping will be set to N also......
//             |01-02-92  |jbw  |insure all w/s initialized
//             |   at start of program (mn0a001)...........
//             |12-09-92  |jwood|add mn5tbl, change mn0as1c..
//             |02-22-93  |jcamp|remove ta0060 and make psdo-
//             |          |     |conversational.
// *********************
Program MN0A type textUIProgram //VAGen Info - main text program
  {
  includeReferencedFunctions = yes, allowUnqualifiedItemReferences = yes, 
  throwNrfEofExceptions = yes, handleHardIOErrors = yes, V60ExceptionCompatibility = yes, 
  I4GLItemsNullable = no, textLiteralDefaultIsString = no, localSQLScope = yes, 
  inputRecord = COMMAREA, segmented = yes
  }

  // Data Declarations
  COMMAREA COMMAREA ; // record
  MN0AW1 MN0AW1; // record
  MN0AW2 MN0AW2; // record
  MN0AW3 MN0AW3; // record
  MN0AW4 MN0AW4; // record
  MN0AW5 MN0AW5; // record
  MN0AW6 MN0AW6; // record
  MN0AW7 MN0AW7; // record
  MN0AW8 MN0AW8; // record
  MN1REC MN1REC; // record
  MN2REC MN2REC { redefines = MN1REC } ; // record
  MN3REC MN3REC { redefines = MN1REC } ; // record
  MN4REC MN4REC; // record
  TA5REC TA5REC; // record

  // VAGen Info - items needed for migration
  VAGen_EZESYS char(8);
  VAGen_EZEREPLY num(1);
  VAGen_EZE_WAIT_TIME bin(9,2);
  VAGen_EZE_ITEMLEN int;

  // Use Declarations
  use MN5TBL; // table
  use XSYESNO; // table
  use MN0AM.MN0AM001,  // forms
      MN0AM.MN0AM002, 
      MN0AM.MN0AM003, 
      MN0AM.MN0AM004
   {
    pfKeyEquate = no
  };

  function main()
    // VAGen Info - initialization needed for migration
    VAGen_EZESYS = VGLib.getVAGSysType();
    MN0A001: MN0A001();




     /* **** If a fast path was used to enter this application*/
          /* and something was entered in the item field then*/
          /* branch to appropriate process.*/
          /* The common area item field is broken down into*/
          /* 2 parts.  One being the option seleced and the other*/
          /* the application ID separtated by a space.*/

    MN0AW1.MN0AIT = COMMAREA.CAITEM;

    if (MN0AW1.MN0AIT1 == "1"
     && COMMAREA.CAADDFL == "Y")
      COMMAREA.CAITEM = " ";
      goto MN0A010; /* add applications*/
    else
      if (MN0AW1.MN0AIT1 == "2"
       && COMMAREA.CACHGFL == "Y")
        COMMAREA.CAITEM = " ";
        goto MN0A020; /* change applications*/
      else
        if (MN0AW1.MN0AIT1 == "3"
         && COMMAREA.CADELFL == "Y")
          COMMAREA.CAITEM = " ";
          goto MN0A030; /* delete applications*/
        else
          if (MN0AW1.MN0AIT1 == "4"
           && COMMAREA.CAINQFL == "Y")
            COMMAREA.CAITEM = " ";
            goto MN0A040; /* inquire into applications*/
          end
        end
      end
    end

    goto MN0A002;




    MN0A002: MN0A002();




     /* **** If control was passed back to this process*/
          /* from the common statement groups which handle*/
          /* the special keys, then go back to the top of this*/
          /* process with the error message returned from*/
          /* the statement groups.*/

    if (MN0AW1.MN0AFLG1 == "Y")
      goto MN0A002;
    end


     /* **** Check for an invalid key being entered.*/

    if (converseVar.eventKey is enter)
          /* next sentence*/
    else
      MN0AM001.MNAMSG = "THAT KEY IS NOT SUPPORTED";
      set MN0AM001 alarm;
      goto MN0A002;
    end


     /* **** Branch to the selected process.*/

    if (MN0AM001.MNAOPTN == "1")
      if (COMMAREA.CAADDFL == "Y")
        goto MN0A010;
      else
        MN0AM001.MNAMSG = "YOU DO NOT HAVE ADD CAPABILITIES";
        goto MN0A002;
      end
    end


    if (MN0AM001.MNAOPTN == "2")
      if (COMMAREA.CACHGFL == "Y")
        goto MN0A020;
      else
        MN0AM001.MNAMSG = "YOU DO NOT HAVE CHANGE CAPABILITIES";
        goto MN0A002;
      end
    end


    if (MN0AM001.MNAOPTN == "3")
      if (COMMAREA.CADELFL == "Y")
        goto MN0A030;
      else
        MN0AM001.MNAMSG = "YOU DO NOT HAVE DELETE CAPABILITIES";
        goto MN0A002;
      end
    end


    if (MN0AM001.MNAOPTN == "4")
      if (COMMAREA.CAINQFL == "Y")
        goto MN0A040;
      else
        MN0AM001.MNAMSG = "YOU DO NOT HAVE INQUIRY CAPABILITIES";
        goto MN0A002;
      end
    end


     /* **** At this point a valid option was not selected.*/

    MN0AM001.MNAMSG = "PLEASE ENTER THE OPTION DESIRED";
    set MN0AM001 alarm;
    goto MN0A002;




    MN0A010: MN0A010();




    goto MN0A011;




    MN0A011: MN0A011();




     /* **** If an error was returned from a transfer*/
          /* go back to the top of this process.*/

    if (MN0AW1.MN0AFLG1 == "Y")
      goto MN0A011;
    end


     /* **** Transfer back to the application menu if the PF3*/
          /* or PA2 keys were pressed.*/

    if (converseVar.eventKey is pf3
     || converseVar.eventKey is pa2)
      goto MN0A002;
    end


     /* **** Check for an invalid key being pressed.*/

    if (converseVar.eventKey is enter)
        /* next sentence*/
    else
      MN0AM002.MNAMSG = "THAT KEY IS NOT SUPPORTED";
      set MN0AM002 alarm;
      goto MN0A011;
    end


    goto MN0A012;




    MN0A012: MN0A012();




     /* **** If one of the fields was in error, branch back*/
          /* to the converse with an error message.*/

    if (MN0AW1.MN0AFLG1 == "Y")
      goto MN0A011;
    end


    goto MN0A014;




    MN0A013: MN0A013();




     /* **** If the record exists then send an error message*/
          /* back to the converse to get another application.*/


    if (MN1REC is ioError)
      if (MN1REC is noRecordFound)
              /* next sentence*/
      else
        MN0AM002.MNAMSG = "AN ERROR HAS OCCURED READING THE";
        MN0AM002.VAGen_EZEMSG = "APPLICATION RECORD";
        set MN0AM002 alarm;
        set MN0AM002.MN1APPL cursor, bold;
        goto MN0A011;
      end
    else
      MN0AM002.MNAMSG = "THE APPLICATION ALREADY EXISTS";
      set MN0AM002 alarm;
      set MN0AM002.MN1APPL cursor, bold;
      move MN1REC to MN0AM002 byName;
      goto MN0A011;
    end


    goto MN0A014;




    MN0A014: MN0A014();




     /* **** If the return code from the add process is not good*/
          /* send back an error message.*/

    if (MN1REC is ioError)
      MN0AM002.MNAMSG = "AN ERROR OCCURED ADDING THE APPLICATION";
      set MN0AM002 alarm;
    else
      MN0AM002.MNAMSG = "RECORD HAS BEEN ADDED";
    end


    goto MN0A011;




    MN0A020: MN0A020();




    set MN0AM002 initial;

     /* **** If a fast path was done to enter this option and there*/
          /* is something in the commarea.caitem field then use*/
          /* this as the application id.*/

    if (MN0AW1.MN0AIT3 != " ")
      MN0AM002.MN1APPL = MN0AW1.MN0AIT3;
      MN0AW1.MN0AIT = " ";
      goto MN0A022;
    end


    goto MN0A021;




    MN0A021: MN0A021();





     /* **** Branch back to application menu if the pf3*/
          /* key was pressed.*/

    if (converseVar.eventKey is pf3
     || converseVar.eventKey is pa2)
      goto MN0A002;
    end

     /* **** If an error occured the branch back to the*/
          /* beginning of this process.*/

    if (MN0AW1.MN0AFLG1 == "Y")
      goto MN0A021;
    end


    goto MN0A022;




    MN0A022: MN0A022();




     /* **** branch back to the converse if an error occured.*/

    if (MN0AW1.MN0AFLG1 == "Y")
      goto MN0A021;
    end


    goto MN0A023;




    MN0A023: MN0A023();





     /* **** Branch back to the application menu if the pf3 key was*/
          /* pressed.*/

    if (converseVar.eventKey is pf3)
      goto MN0A002;
    end

     /* **** Branch back to the first converse of this function if*/
          /* the PA2 (abort) key was pressed.*/

    if (converseVar.eventKey is pa2)
      goto MN0A021;
    end


     /* **** If an error occured then branch back to the*/
          /* beginning of this process*/

    if (MN0AW1.MN0AFLG1 == "Y")
      goto MN0A023;
    end


     /* **** Branch back to the inquiry process if the application*/
          /* was changed.*/

    if (MN0AW1.MN0AFLG2 == "Y")
      goto MN0A022;
    end


     /* **** Set the pointer in the file to point to the first*/
          /* user application record for the application id*/
          /* entered.*/

    MN4REC.MN1KEY = " ";
    MN4REC.MN1TYPE1 = "3";
    MN4REC.MN1TYPE2 = "3";
    MN4REC.MN1APPL = MN0AM002.MN1APPL;

    MN0AW1.MN0AFLG3 = "N";

    set MN4REC position;

    goto MN0A024;





    MN0A024: MN0A024();




     /* **** If an error has occured, branch back to the converse.*/

    if (MN0AW1.MN0AFLG1 == "Y")
      goto MN0A023;
    end


     /* **** Get another record if the end of the user application*/
          /* records for the application being changed has not been*/
          /* reached.  If the end of the user appl records has been*/
          /* reached and there was an error with the flags then*/
          /* go back to the converse otherwise update the record.*/

    if (MN0AW1.MN0AFLG2 == "Y")
      goto MN0A024;
    else
      if (MN0AW1.MN0AFLG3 == "Y")
        goto MN0A023;
      else
        goto MN0A025;
      end
    end




    MN0A025: MN0A025();




     /* **** If an error has occured go back to the converse.*/

    if (MN0AW1.MN0AFLG1 == "Y")
      goto MN0A023;
    end


     /* **** replace the record.*/

    goto MN0A026;




    MN0A026: MN0A026();




     /* **** If an error has occured changing the record the*/
          /* go back to the second converse otherwise go back*/
          /* to the first converse.*/

    if (MN0AW1.MN0AFLG1 == "Y")
      goto MN0A023;
    end


    set MN0AM002 initial;
    MN0AM002.MNAMSG = "APPLICATION HAS BEEN CHANGED";

    goto MN0A021;




    MN0A030: MN0A030();




     /* **** if a fast path was used to enter the menu system and*/
          /* an option was entered int the item field of the*/
          /* commarea record, check to see if an application id*/
          /* was entered.  If so branch around the converse and*/
          /* get the application record.*/

    if (MN0AW1.MN0AIT != " "
     && MN0AW1.MN0AIT3 != " ")
      MN0AM002.MN1APPL = MN0AW1.MN0AIT3;
      MN0AW1.MN0AIT = " ";
      goto MN0A032;
    end


    goto MN0A031;




    MN0A031: MN0A031();






     /* **** If the PF3 or PA2 keys were pressed branch back to*/
          /* the application menu.*/

    if (converseVar.eventKey is pf3
     || converseVar.eventKey is pa2)
      goto MN0A002;
    end

     /* **** If the MN0AFLG1 is set to a Y then an error*/
          /* has occured so branch back to the beginning of*/
          /* this process.*/

    if (MN0AW1.MN0AFLG1 == "Y")
      goto MN0A031;
    end

     /* **** check for an invalid key being pressed.*/

    if (converseVar.eventKey is enter)
         /* next sentence*/
    else
      MN0AM002.MNAMSG = "THAT KEY IS NOT SUPPORTED";
      set MN0AM002 alarm;
    end


    goto MN0A032;




    MN0A032: MN0A032();




     /* **** if the MN0AFLG1 is set to a Y then an error has*/
          /* so branch back to the beginning of the converse*/
          /* process.*/

    if (MN0AW1.MN0AFLG1 == "Y")
      goto MN0A031;
    end


    goto MN0A033;




    MN0A033: MN0A033();




     /* **** If the MN0AFLG1 flag is set to a Y then an error*/
          /* has occured so branch back to the beginning of*/
          /* the converse with the correct error message.*/

    if (MN0AW1.MN0AFLG1 == "Y")
      goto MN0A031;
    end


    goto MN0A034;




    MN0A034: MN0A034();




     /* **** IF the MN0AFLG1 flag is set to a Y then an error has*/
          /* occured so branch back to the beginning of this*/
          /* process.*/

    if (MN0AW1.MN0AFLG1 == "Y")
      goto MN0A034;
    end


     /* **** If the MN0AFLG2 flag is set to a Y then the*/
          /* application id was changed to branch back to the*/
          /* process to get the application record.*/

    if (MN0AW1.MN0AFLG2 == "Y")
      goto MN0A032;
    end


     /* **** Branch back to the application menu if the*/
          /* PF3 key was pressed.*/

    if (converseVar.eventKey is pf3)
      goto MN0A002;
    end


     /* **** Branch back to the fisrt converse of this function*/
          /* if the PA2 key was pressed.*/

    if (converseVar.eventKey is pa2)
      MN0AM002.MNAMSG = "DELETE HAS BEEN ABORTED";
      MN0AM002.VAGen_EZEMSG = " ";
      goto MN0A031;
    end


     /* **** Check for an invalid key being pressed.*/

    if (converseVar.eventKey is enter)
       /* next sentence*/
    else
      MN0AM002.MNAMSG = "THAT KEY IS NOT SUPPORTED";
      set MN0AM002 alarm;
      goto MN0A034;
    end


    goto MN0A035;




    MN0A035: MN0A035();




     /* **** If the MN0AFLG1 flag is set then branch back to the*/
          /* previous converse with the error message.*/

    if (MN0AW1.MN0AFLG1 == "Y")
      goto MN0A034;
    end


    goto MN0A036;




    MN0A036: MN0A036();




     /* **** If the MN0AFLG1 flag is set to a Y then an error*/
          /* has occured so branch back to the converse with*/
          /* the apporpriate error message.*/

    if (MN0AW1.MN0AFLG1 == "Y")
      goto MN0A034;
    end


    MN0AM002.MNAMSG = "RECORD HAS BEEN DELETED";
    goto MN0A031;




    MN0A040: MN0A040();




     /* **** If a fast path was done to enter this function and*/
          /* an application id was entered then set the pointer in*/
          /* the file that record otherwise set the pointer to the*/
          /* first record.*/

    MN4REC.MN1KEY = " ";
    MN4REC.MN1TYPE1 = "1";
    MN4REC.MN1TYPE2 = "1";

    if (MN0AW1.MN0AIT3 != " ")
      MN4REC.MN1APPL = MN0AW1.MN0AIT3;
      MN0AW1.MN0AIT = " ";
    end


    set MN4REC position;

    MN0AW1.MN0AIDX = 0;
    MN0AW1.MN0A1KEY = 0;

    goto MN0A041;




    MN0A041: MN0A041();




     /* **** If the screen is not full the get another record.*/

    if (MN0AW1.MN0AFLG1 == "Y")
      goto MN0A041;
    end

    goto MN0A042;




    MN0A042: MN0A042();




     /* **** If there was an error on the screen then*/
          /* go back to the beginning of this process.*/

    if (MN0AW1.MN0AFLG1 == "Y")
      goto MN0A042;
    end


     /* **** Check for the pf3 or pa2 key to be entered.*/

    if (converseVar.eventKey is pf3
     || converseVar.eventKey is pa2)
      goto MN0A002;
    end


     /* **** If the pf8 or pf7 keys were pressed, or an appl id*/
          /* was entered then go back to the scan process to get*/
          /* more application records.*/

    if (MN0AW1.MN0AFLG2 == "Y")
      goto MN0A041;
    end


     /* **** Check for an invalid key being pressed.*/

    if (converseVar.eventKey is enter)
         /* next sentence*/
    else
      MN0AM003.MNAMSG = "THAT KEY IS NOT SUPPORTED";
      set MN0AM003 alarm;
      goto MN0A042;
    end


     /* **** if an application was selected to inquiry on then*/
          /* purge the tsq*/
          /* go to the user application inquiry function.*/

    if (MN0AW1.MN0AFLG3 == "Y")
      MN0AW6.MN0AROW = " ";
      MN4REC.MN1KEY = " ";
      MN4REC.MN1TYPE2 = "3";
      MN4REC.MN1APPL = MN0AM003.MNAAPPL[MN0AIDX];
      set MN4REC position;
      MN0AW2.MN0AW2FL = " ";
      MN0AW6.MN0AW6FL = " ";
      MN0AW2.MN0ALENG = 77;
      MN0AW6.MN0ALENG = 77;
      goto MN0A043;
    end


    goto MN0A042;




    MN0A043: MN0A043();




     /* **** if mn0aflg1 is set then an error has occured so*/
          /* branch back to the converse.*/


    if (MN0AW1.MN0AFLG1 == "Y")
      goto MN0A042;
    end


     /* **** if the mn0aflg2 flag is set the the end of the*/
          /* user application for the applicatin selected*/
          /* was reached so browse the records.*/
          /* The mn0acode field is used to create a new temporary*/
          /* storage area.  If this flag is set to an P at this*/
          /* point, this means that there is no records to browse.*/


    if (MN0AW1.MN0AFLG2 == "Y")
      if (TA5REC.TA5FNCCD == "P")
        MN0AM003.MNAMSG = "THERE ARE NO USERS FOR THIS APPLICATION";
        set MN0AM003 alarm;
        goto MN0A042;
      else
        MN0AW3.MN0AW-TA5DATA = TA5REC.TA5DATA;
        MN0AW3.MN0AW3-FPG = 1;
        MN0AW3.MN0AW3-LPG = MN0AW3.MN0ACNT / 14;
        MN0AW3.MN0AW3-CPG = MN0AW3.MN0AW3-LPG * 14;
        if (MN0AW3.MN0AW3-CPG < MN0AW3.MN0ACNT)
          MN0AW3.MN0AW3-LPG = MN0AW3.MN0AW3-LPG + 1;
        end
        MN0AW1-END-BROWSE = "N";
        MN0AW1-LOAD-MAP = "Y";
        TA5REC.TA5TSQIX = 1;
        goto MN0A047;
      end
    end


     /* **** get the user name to be displayed.*/

    goto MN0A044;




    MN0A044: MN0A044();




     /* **** put the record to temporary storage.*/

    goto MN0A045;




    MN0A045: MN0A045();




     /* **** If an error occured putting the records to temp*/
          /* storage then go back to the last converse.*/

    if (MN0AW1.MN0AFLG1 == "Y")
      goto MN0A042;
    end

     /* **** (5/87 - jw) if user read was error go read next user*/
                      /* appl record*/

    if (MN0AW1.MN0AWEF2 == "Y")
      MN0AW1.MN0AWEF2 = "N";
      goto MN0A043;
    else
      goto MN0A043;
    end

    MN0A046: MN0A046();




     /* **** If an error has occured reading the record then*/
          /* go back to the converse with an error message.*/

    if (MN0AW1.MN0AFLG1 == "Y")
      goto MN0A042;
    end


     /* **** go back to get another record.*/

    goto MN0A043;




    MN0A047: MN0A047();




     /* **** return to the converse.*/

    if (MN0AW1-END-BROWSE == "Y")
      goto MN0A042;
    end

    goto MN0A047;


  end // end main
end // end MN0A

// first time thru logic (FTTL)
Function MN0A001()




        /* ***************************************************/
        /* *                                                **/
        /* *    This is the entry process for the menu      **/
        /* *  security system.                              **/
        /* *                                                **/
        /* ***************************************************/


   /* **** perform the entry statement group.  The function*/
        /* of the statement group is to not allow entry into*/
        /* this application unless the proper logon procedure*/
        /* has been done.*/

  XSENTRY();

  XSSEGTR();

   /* *********************************************************/
   /* *             initialize working storage               **/
   /* *********************************************************/
   /*  */
  set MN0AW1 empty;
  set MN0AW2 empty;
  set MN0AW4 empty;
  set MN0AW5 empty;
  set MN0AW6 empty;
  set MN0AW7 empty;
  set MN0AW8 empty;
  set MN2REC empty;
  set MN3REC empty;
  set TA5REC empty;

  set MN0AM001 initial;
  set MN0AM002 initial;
  set MN0AM003 initial;

end // end MN0A001

// user maintenance menu screen
Function MN0A002()




        /* ************************************************/
        /* *                                             **/
        /* *    This process converses the security menu **/
        /* *  application screen.                        **/
        /* *                                             **/
        /* ************************************************/


   /* **** initialize the screen variables*/

  MN0AM001.MN0AMDT = VGVar.currentShortGregorianDate;
  MN0AM001.MNANAME = "MN0A002";
  converseLib.clearScreen();
  
  MN0AM001.CATOAP = " ";
  MN0AM001.CAITEM = " ";

  MN0AW1.MN0AFLG1 = "N";




  converse MN0AM001 ;





  MN0AM001.MNAMSG = " ";


   /* ****  transfer control the the appropriote application*/
         /* if the keys PF1, pf4, pf3 and pa2 were pressed.*/

  MN0AS0A();
  if (MN0AW1.MN0AFLG1 == "Y")
    exit stack;
  end


   /* **** If anything is entered in the option field*/
        /* then transfer control to that application*/

  MN0AS0B();
  if (MN0AW1.MN0AFLG1 == "Y")
    exit stack;
  end




end // end MN0A002

// FTTL for add appl function
Function MN0A010()




       /* ************************************************/
       /* *                                             **/
       /* *      This is the entry module for the add   **/
       /* *   application function.                     **/
       /* *                                             **/
       /* ************************************************/


   /* **** clear the screen and set all the flags to N.*/

  MN0AS1F();

  set MN0AM002 initial;


   /* **** Set all the flags on the screen to 'n'.*/

  MN0AM002.MN1ADDFL = "N";
  MN0AM002.MN1CHGFL = "N";
  MN0AM002.MN1DELFL = "N";
  MN0AM002.MN1INQFL = "N";

  MN0AW1.MN0AIDX = 1;

  while (MN0AW1.MN0AIDX < 11)
    MN0AM002.MN1ALVL[MN0AIDX] = "N";
    MN0AM002.MN1CLVL[MN0AIDX] = "N";
    MN0AM002.MN1DLVL[MN0AIDX] = "N";
    MN0AM002.MN1ILVL[MN0AIDX] = "N";
    MN0AW1.MN0AIDX = MN0AW1.MN0AIDX + 1;
  end



end // end MN0A010

// get application to add
Function MN0A011()




        /* ************************************************/
        /* *                                             **/
        /* *    This process gets the application to be  **/
        /* *  added.                                     **/
        /* *                                             **/
        /* ************************************************/


   /* **** initialize the screen variables*/

  MN0AM002.MN0AMDT = VGVar.currentShortGregorianDate;
  MN0AM002.MNANAME = "MN0A011";
  MN0AM002.MNAHEAD = "   ADD";

  MN0AW1.MN0AFLG1 = "N";




  converse MN0AM002 ;





  MN0AM002.MNAMSG = " ";
  set MN0AM002.MN1APPL initialAttributes;
  set MN0AM002.MN1NM initialAttributes;
  set MN0AM002.MN1CICS initialAttributes;


   /* ****  transfer control to the appropriate application*/
         /* if the keys PF1, or pf4 were pressed.*/

  MN0AS1A();
  if (MN0AW1.MN0AFLG1 == "Y")
    exit stack;
  end


   /* **** If anything is entered in the option field*/
        /* then transfer control to that application*/

  MN0AS1B();
  if (MN0AW1.MN0AFLG1 == "Y")
    exit stack;
  end




end // end MN0A011

// validate screen entries
Function MN0A012()




       /* ************************************************/
       /* *                                             **/
       /* *      Validate the fields entered on the     **/
       /* *   screen.                                   **/
       /* *                                             **/
       /* ************************************************/

  MN0AW1.MN0AFLG1 = "N";


   /* **** Validate the cics transaction id.*/

  MN0AS1E();

   /* **** Validate the application name.*/

  MN0AS1D();

   /* **** Validate the application.*/

  MN0AS1C();




end // end MN0A012

// get application record
Function MN0A013()




        /* *****************************************************/
        /* *                                                  **/
        /* *      Get the application record.  If it exists   **/
        /* *   then it is an error.                           **/
        /* **/
        /* *****************************************************/


  MN1REC.MN1KEY = " ";
  MN1REC.MN1TYPE1 = "1";
  MN1REC.MN1TYPE2 = "1";
  MN1REC.MN1APPL = MN0AM002.MN1APPL;




  try
    get MN1REC ;
  end




end // end MN0A013

// add application record
Function MN0A014()




        /* *****************************************************/
        /* *                                                  **/
        /* *      add the application record.                 **/
        /* **/
        /* *****************************************************/


  MN1REC.MN1KEY = " ";
  MN1REC.MN1TYPE1 = "1";
  MN1REC.MN1TYPE2 = "1";
  move MN0AM002 to MN1REC byName;


   /* **** If any of the flags are set to a 'N' then*/
        /* all associated level flags must also be set*/
        /* to 'N'.*/

  XSMNSXA();

  if (MN1REC.MN1ADDFL == "N")
    MN1REC.MN1ADDTB = "NNNNNNNNNN";
  end




  try
    add MN1REC ;
  end




   /* **** Clear the screen fields if the record was added.*/

  if (MN1REC is ioError)
     /* next sentence*/
  else
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.commit();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
     /* commit add to vsam file*/
    MN0AS1F();
  end




end // end MN0A014

// FTTL for change process
Function MN0A020()




         /* ****************************************************/
         /* *                                                 **/
         /* *      This is the entry point for the application**/
         /* *   change function.                              **/
         /* *                                                 **/
         /* ****************************************************/




end // end MN0A020

// get application to change
Function MN0A021()




         /* ****************************************************/
         /* *                                                 **/
         /* *      Get the application id for the application **/
         /* *   record to be changed.                         **/
         /* *                                                 **/
         /* ****************************************************/

   /* **** Initialize the screen.*/

  MN0AM002.MNANAME = "MN0A021";
  MN0AM002.MNAHEAD = "CHANGE";
  MN0AM002.MN0AMDT = VGVar.currentShortGregorianDate;
  set MN0AM002.MN1NM protect;
  set MN0AM002.MN1CICS protect;

  set MN0AM002.MN1ADDFL protect;
  set MN0AM002.MN1CHGFL protect;
  set MN0AM002.MN1DELFL protect;
  set MN0AM002.MN1INQFL protect;

  MN0AW1.MN0AIDX = 1;

  while (MN0AW1.MN0AIDX < 11)
    set MN0AM002.MN1ALVL[MN0AIDX] protect;
    set MN0AM002.MN1CLVL[MN0AIDX] protect;
    set MN0AM002.MN1DLVL[MN0AIDX] protect;
    set MN0AM002.MN1ILVL[MN0AIDX] protect;
    MN0AW1.MN0AIDX = MN0AW1.MN0AIDX + 1;
  end


  MN0AW1.MN0AFLG1 = "N";





  converse MN0AM002 ;




  MN0AM002.MNAMSG = " ";
  set MN0AM002.MN1APPL initialAttributes;
  set MN0AM002.MN1NM initialAttributes;
  set MN0AM002.MN1CICS initialAttributes;
  set MN0AM002.CATOAP initialAttributes;

  set MN0AM002.MN1ADDFL initialAttributes;
  set MN0AM002.MN1CHGFL initialAttributes;
  set MN0AM002.MN1DELFL initialAttributes;
  set MN0AM002.MN1INQFL initialAttributes;

  MN0AW1.MN0AIDX = 1;

  while (MN0AW1.MN0AIDX < 11)
    set MN0AM002.MN1ALVL[MN0AIDX] initialAttributes;
    set MN0AM002.MN1CLVL[MN0AIDX] initialAttributes;
    set MN0AM002.MN1DLVL[MN0AIDX] initialAttributes;
    set MN0AM002.MN1ILVL[MN0AIDX] initialAttributes;
    MN0AW1.MN0AIDX = MN0AW1.MN0AIDX + 1;
  end



   /* ****  transfer control the the appropriote application*/
         /* if the keys PF1, or pf4 were pressed.*/

  MN0AS1A();
  if (MN0AW1.MN0AFLG1 == "Y")
    exit stack;
  end


   /* **** If anything is entered in the option field*/
        /* then transfer control to that application*/

  MN0AS1B();
  if (MN0AW1.MN0AFLG1 == "Y")
    exit stack;
  end


   /* **** An application must be entered.*/

  if (converseVar.eventKey is enter
   && MN0AM002.MN1APPL == " ")
    MN0AW1.MN0AFLG1 = "Y";
    MN0AM002.MNAMSG = "APPLICATION ID MUST BE ENTERED";
    set MN0AM002.MN1APPL cursor, bold;
    set MN0AM002 alarm;
    exit stack;
  end

       /* validate appl-id*/

  MN0AS1C();
  if (MN0AW1.MN0AFLG1 == "Y")
    exit stack;
  end

   /* ==================================== check &*/
  if (MN0AW1.MN0ACK1 == "&")
    MN0AM002.MNAMSG = "--- FAST-PATH TO MN0P TO CHANGE PROFILES ---";
    MN0AM002.CATOAP = "MN0P";
    set MN0AM002.MN1APPL cursor, bold;
    set MN0AM002 alarm;
    MN0AW1.MN0AFLG1 = "Y";
    exit stack;
  end
   /* ====================================*/

   /* **** Check for an invalid key being pressed.*/

  if (converseVar.eventKey is enter
   || converseVar.eventKey is pf3
   || converseVar.eventKey is pa2)
      /* next sentence*/
  else
    MN0AW1.MN0AFLG1 = "Y";
    MN0AM002.MNAMSG = "THAT KEY IS NOT SUPPORTED";
    set MN0AM002 alarm;
  end




end // end MN0A021

// get application record
Function MN0A022()




         /* ****************************************************/
         /* *                                                 **/
         /* *      Get the application record.                **/
         /* *                                                 **/
         /* ****************************************************/


   /* **** set up the record key for the read.*/

  MN1REC.MN1KEY = " ";
  MN1REC.MN1TYPE1 = "1";
  MN1REC.MN1TYPE2 = "1";
  MN1REC.MN1APPL = MN0AM002.MN1APPL;

  MN0AW1.MN0AFLG1 = "N";




  try
    get MN1REC ;
  end




   /* **** It is an error if the record could not be read.*/

  if (MN1REC is ioError)
    set MN0AM002.MN1APPL cursor, bold;
    set MN0AM002 alarm;
    MN0AW1.MN0AFLG1 = "Y";
    if (MN1REC is noRecordFound)
      MN0AM002.MNAMSG = "APPLICATION RECORD DOES NOT EXIST";
    else
      MN0AM002.MNAMSG = "AN ERROR HAS OCCURED READING THE";
      MN0AM002.VAGen_EZEMSG = "APPLCATION RECORD";
    end
  else
    move MN1REC to MN0AM002 byName;
  end




end // end MN0A022

// get application to change
Function MN0A023()




         /* ****************************************************/
         /* *                                                 **/
         /* *      Get the changes for the application record.**/
         /* *                                                 **/
         /* ****************************************************/

   /* **** Initialize the screen.*/

  MN0AM002.MNANAME = "MN0A023";
  MN0AM002.MNAHEAD = "CHANGE";
  MN0AM002.MN0AMDT = VGVar.currentShortGregorianDate;

  MN0AW1.MN0AFLG1 = "N";
  MN0AW1.MN0AFLG2 = "N";





  converse MN0AM002 ;




  MN0AM002.MNAMSG = " ";
  set MN0AM002.MN1APPL initialAttributes;
  set MN0AM002.MN1NM initialAttributes;
  set MN0AM002.MN1CICS initialAttributes;
  set MN0AM002.CATOAP initialAttributes;
  set MN0AM002.MN1ADDFL initialAttributes;
  set MN0AM002.MN1CHGFL initialAttributes;
  set MN0AM002.MN1DELFL initialAttributes;
  set MN0AM002.MN1INQFL initialAttributes;

  MN0AW1.MN0AIDX = 1;

  while (MN0AW1.MN0AIDX < 11)
    set MN0AM002.MN1ALVL[MN0AIDX] initialAttributes;
    set MN0AM002.MN1CLVL[MN0AIDX] initialAttributes;
    set MN0AM002.MN1DLVL[MN0AIDX] initialAttributes;
    set MN0AM002.MN1ILVL[MN0AIDX] initialAttributes;
    MN0AW1.MN0AIDX = MN0AW1.MN0AIDX + 1;
  end


   /* ****  transfer control the the appropriote application*/
         /* if the keys PF1, or pf4 were pressed.*/

  MN0AS1A();
  if (MN0AW1.MN0AFLG1 == "Y")
    exit stack;
  end


   /* **** If anything is entered in the option field*/
        /* then transfer control to that application*/

  MN0AS1B();
  if (MN0AW1.MN0AFLG1 == "Y")
    exit stack;
  end


   /* **** Check to see if the application id was changed.*/

  if (converseVar.eventKey is enter
   && MN0AM002.MN1APPL is modified)
    MN0AW1.MN0AFLG2 = "Y";
    exit stack;
  end


   /* **** validate the application name ,cics id and flags.*/

  MN0AS1E();

  MN0AS1D();


   /* **** Check for an abort.*/

  if (converseVar.eventKey is pa2)
    set MN0AM002 initial;
    MN0AM002.MNAMSG = "CHANGE HAS BEEN ABORTED";
    exit stack;
  end



   /* **** Check for an invalid key being pressed.*/

  if (converseVar.eventKey is enter
   || converseVar.eventKey is pf3)
      /* next sentence*/
  else
    MN0AW1.MN0AFLG1 = "Y";
    MN0AM002.MNAMSG = "THAT KEY IS NOT SUPPORTED";
    set MN0AM002 alarm;
  end




end // end MN0A023

// get application dependencies
Function MN0A024()




         /* ****************************************************/
         /* *                                                 **/
         /* *        Read all the user application records for**/
         /* *   the application id entered.  If there exists  **/
         /* *   a Y in any flag on the user application record**/
         /* *   where a N exists on the application record    **/
         /* *   then this is an error condition and the       **/
         /* *   record cannot be changed.                     **/
         /* *                                                 **/
         /* ****************************************************/


  MN0AW1.MN0AFLG1 = "N";
  MN0AW1.MN0AFLG2 = "N";


  MN0AW1.MN0AWEF2 = "N";


  try
    get next MN4REC ;
  end




   /* **** If an error occured reading the file or the type*/
        /* of record changed then replace the record otherwise*/
        /* get another record.*/

  if (MN4REC is ioError)
    if (MN4REC is duplicate)
      if (MN4REC.MN1TYPE1 != "3"
       || MN4REC.MN1TYPE2 != "3"
       || MN4REC.MN1APPL != MN0AM002.MN1APPL)
        exit stack;
      end
    else
      if (MN4REC is endOfFile)
        exit stack;
      else
        MN0AW1.MN0AFLG1 = "Y";
        MN0AM002.MNAMSG = "AN ERROR HAS OCCURED READING THE ";
        MN0AM002.VAGen_EZEMSG = "DEPENDENCIES.  CANNOT CHANGE THE RECORD";
        set MN0AM002 alarm;
        exit stack;
      end
    end
  else
    if (MN4REC.MN1TYPE1 != "3"
     || MN4REC.MN1TYPE2 != "3"
     || MN4REC.MN1APPL != MN0AM002.MN1APPL)
      exit stack;
    end
  end


   /* **** check each flag on the record.  If a flag is set to*/
        /* a Y on the record where a N exists on the screen flags*/
        /* then this is an error and the record cannot be changed*/

  MN0AW1.MN0AMSG1 = "USER ";
  MN0AW1.MN0AMSG3 = " HAS THIS FLAG SET TO A Y";

  MN0AS2C();


  MN0AW1.MN0AIDX = 1;

  while (MN0AW1.MN0AIDX < 11)
    MN0AS2D();
    MN0AW1.MN0AIDX = MN0AW1.MN0AIDX + 1;
  end


   /* **** Set the mn0aflg1 flag to get another record.*/

  MN0AW1.MN0AFLG2 = "Y";




end // end MN0A024

// lock the application record
Function MN0A025()




         /* ****************************************************/
         /* *                                                 **/
         /* *      Lock the application record so it can be   **/
         /* *   changed.                                      **/
         /* *                                                 **/
         /* ****************************************************/

   /* **** initialize the key.*/

  MN1REC.MN1KEY = " ";
  MN1REC.MN1TYPE1 = "1";
  MN1REC.MN1TYPE2 = "1";
  MN1REC.MN1APPL = MN0AM002.MN1APPL;

  MN0AW1.MN0AFLG1 = "N";




  try
    get MN1REC forUpdate ;
  end




   /* **** If there was an error reading the record set the*/
        /* flag to go back to the converse.*/

  if (MN1REC is ioError)
    if (MN1REC is noRecordFound)
      MN0AM002.MNAMSG = "THE APPLICATION RECORD IS NOT ON FILE";
      set MN0AM002.MN1APPL cursor, bold;
      set MN0AM002 alarm;
      MN0AW1.MN0AFLG1 = "Y";
      exit stack;
    else
      MN0AM002.MNAMSG = "AN ERROR HAS OCCURED READING THE";
      MN0AM002.VAGen_EZEMSG = "APPLICATION RECORD";
      set MN0AM002.MN1APPL cursor, bold;
      set MN0AM002 alarm;
      MN0AW1.MN0AFLG1 = "Y";
      exit stack;
    end
  end




end // end MN0A025

// change the application record
Function MN0A026()




         /* ****************************************************/
         /* *                                                 **/
         /* *      Change the application record.             **/
         /* *                                                 **/
         /* ****************************************************/

  MN0AW1.MN0AFLG1 = "N";

  move MN0AM002 to MN1REC byName;


   /* **** If any of the flags are set to a 'N' then*/
        /* all the associated level flags must also be*/
        /* set to 'n'.*/

  XSMNSXA();




  try
    replace MN1REC ;
  end




   /* **** If there was an error changing the record set the*/
        /* flag to go back to the converse.*/

  if (MN1REC is ioError)
    MN0AM002.MNAMSG = "AN ERROR HAS OCCURED CHANGING THE";
    MN0AM002.VAGen_EZEMSG = "APPLICATION RECORD";
    set MN0AM002.MN1APPL cursor, bold;
    set MN0AM002 alarm;
    MN0AW1.MN0AFLG1 = "Y";
    exit stack;
  else
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.commit();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
     /* commit the replace for vsam file*/
  end




end // end MN0A026

// FTTL for delete function
Function MN0A030()




       /* ************************************************/
       /* *                                             **/
       /* *      This is the entry module for the delete**/
       /* *   application function.                     **/
       /* *                                             **/
       /* ************************************************/


   /* **** Clear the screen and set all the fields to a*/
        /* protected status.*/

  MN0AS3C();
  set MN0AM002 initial;

   /* **** Set all the fields on the screen to protect.*/

  set MN0AM002.MN1NM protect;
  set MN0AM002.MN1CICS protect;


  set MN0AM002.MN1ADDFL protect;
  set MN0AM002.MN1CHGFL protect;
  set MN0AM002.MN1DELFL protect;
  set MN0AM002.MN1INQFL protect;

  MN0AW1.MN0AIDX = 1;

  while (MN0AW1.MN0AIDX < 11)
    set MN0AM002.MN1ALVL[MN0AIDX] protect;
    set MN0AM002.MN1CLVL[MN0AIDX] protect;
    set MN0AM002.MN1DLVL[MN0AIDX] protect;
    set MN0AM002.MN1ILVL[MN0AIDX] protect;
    MN0AW1.MN0AIDX = MN0AW1.MN0AIDX + 1;
  end







end // end MN0A030

// get application to delete
Function MN0A031()




        /* ************************************************/
        /* *                                             **/
        /* *    This process gets the application to be  **/
        /* *  deleted.                                   **/
        /* *                                             **/
        /* ************************************************/


   /* **** initialize the screen variables*/

  MN0AM002.MN0AMDT = VGVar.currentShortGregorianDate;
  MN0AM002.MNANAME = "MN0A031";
  MN0AM002.MNAHEAD = "DELETE";

  MN0AW1.MN0AFLG1 = "N";




  converse MN0AM002 ;





  MN0AM002.MNAMSG = " ";
  set MN0AM002.MN1APPL initialAttributes;
  set MN0AM002.MN1NM initialAttributes;
  set MN0AM002.MN1CICS initialAttributes;


   /* ****  transfer control the the appropriote application*/
         /* if the keys PF1, or pf4 were pressed.*/

  MN0AS1A();
  if (MN0AW1.MN0AFLG1 == "Y")
    exit stack;
  end


   /* **** If anything is entered in the option field*/
        /* then transfer control to that application*/

  MN0AS1B();
  if (MN0AW1.MN0AFLG1 == "Y")
    exit stack;
  end


   /* **** The application id must be entered.*/

  if (converseVar.eventKey is enter
   && MN0AM002.MN1APPL == " ")
    MN0AM002.MNAMSG = "APPLICATION MUST BE ENTERED";
    set MN0AM002 alarm;
    set MN0AM002.MN1APPL cursor, bold;
    MN0AW1.MN0AFLG1 = "Y";
    exit stack;
  else
    MN0AS1C();
  end




end // end MN0A031

// get application record
Function MN0A032()




       /* ************************************************/
       /* *                                             **/
       /* *      Get the application record.            **/
       /* *                                             **/
       /* ************************************************/


  MN1REC.MN1KEY = " ";
  MN1REC.MN1TYPE1 = "1";
  MN1REC.MN1TYPE2 = "1";
  move MN0AM002 to MN1REC byName;

  MN0AW1.MN0AFLG1 = "N";





  try
    get MN1REC ;
  end




   /* **** If the record does not exist or there is another*/
        /* error reading the record send back the approprate*/
        /* error message to the converser.*/

  if (MN1REC is ioError)
    MN0AW1.MN0AFLG1 = "Y";
    set MN0AM002 alarm;
    set MN0AM002.MN1APPL cursor, bold;
    MN0AM002.MN1NM = " ";
    MN0AM002.MN1CICS = " ";
    if (MN1REC is noRecordFound)
      MN0AM002.MNAMSG = "THE APPLCATION RECORD DOES NOT EXIST";
    else
      MN0AM002.MNAMSG = "AN ERROR HAS OCCURED READING THE";
      MN0AM002.VAGen_EZEMSG = "APPLICATION RECORD";
    end
  else
    move MN1REC to MN0AM002 byName;
  end




end // end MN0A032

// get application dependencies
Function MN0A033()




       /* ************************************************/
       /* *                                             **/
       /* *      Get the application dependencies.      **/
       /* *  If any user's still have application       **/
       /* *  records then this application cannot be    **/
       /* *  deleted.                                   **/
       /* *                                             **/
       /* ************************************************/


  MN4REC.MN1KEY = " ";
  MN4REC.MN1TYPE1 = "3";
  MN4REC.MN1TYPE2 = "3";
  MN4REC.MN1APPL = MN0AM002.MN1APPL;
  MN0AW1.MN0AAPPL = MN0AM002.MN1APPL;

  set MN4REC position;

  MN0AW1.MN0AFLG1 = "N";





  try
    get next MN4REC ;
  end




   /* **** If there exists user application records for the*/
        /* application being deleted then the application can*/
        /* not be deleted.*/

  if (MN4REC is noRecordFound
   || MN4REC is endOfFile)
    exit stack;
  end


  if (MN4REC is duplicate)
    if (MN0AW1.MN0AAPPL == MN4REC.MN1APPL
     && MN4REC.MN1TYPE2 == "3")
      MN0AW1.MN0AFLG1 = "Y";
      set MN0AM002 alarm;
      set MN0AM002.MN1APPL cursor, bold;
      MN0AM002.MNAMSG = "APPLICATION DEPENDENCIES EXIST, THE";
      MN0AM002.VAGen_EZEMSG = "APPLICATION CANNOT BE DELETED";
      exit stack;
    else
      exit stack;
    end
  end


  if (MN4REC is ioError)
    MN0AM002.MNAMSG = "AN ERROR HAS OCCURED READING THE USER";
    MN0AM002.VAGen_EZEMSG = "APPLICATION RECORD";
    MN0AW1.MN0AFLG1 = "Y";
    set MN0AM002 alarm;
    set MN0AM002.MN1APPL cursor, bold;
    exit stack;
  end


  if (MN0AW1.MN0AAPPL == MN4REC.MN1APPL
   && MN4REC.MN1TYPE2 == "3")
    MN0AW1.MN0AFLG1 = "Y";
    set MN0AM002 alarm;
    set MN0AM002.MN1APPL cursor, bold;
    MN0AM002.MNAMSG = "APPLICATION DEPENDENCIES EXIST, THE";
    MN0AM002.VAGen_EZEMSG = "APPLICATION CANNOT BE DELETED";
    exit stack;
  end




end // end MN0A033

// get delete confermation
Function MN0A034()




        /* ************************************************/
        /* *                                             **/
        /* *    Get the delete confermation.             **/
        /* *                                             **/
        /* ************************************************/


   /* **** initialize the screen variables*/

  MN0AM002.MN0AMDT = VGVar.currentShortGregorianDate;
  MN0AM002.MNANAME = "MN0A034";
  MN0AM002.MNAHEAD = "DELETE";
  set MN0AM002.MN1NM protect;
  set MN0AM002.MN1CICS protect;

  MN0AW1.MN0AFLG1 = "N";
  MN0AW1.MN0AFLG2 = "N";

  MN0AM002.VAGen_EZEMSG = "PRESS ENTER TO DELETE OR PA2 TO ABORT";




  converse MN0AM002 ;





  MN0AM002.MNAMSG = " ";
  set MN0AM002.MN1APPL initialAttributes;


   /* ****  transfer control the the appropriote application*/
         /* if the keys PF1, or pf4 were pressed.*/

  MN0AS1A();
  if (MN0AW1.MN0AFLG1 == "Y")
    exit stack;
  end


   /* **** If anything is entered in the option field*/
        /* then transfer control to that application*/

  MN0AS1B();
  if (MN0AW1.MN0AFLG1 == "Y")
    exit stack;
  end


   /* **** The application id must be entered.*/

  if (converseVar.eventKey is enter
   && MN0AM002.MN1APPL is modified)
    MN0AW1.MN0AFLG2 = "Y";
    exit stack;
  end


   /* **** If the delete is aborted, clear the screen.*/

  if (converseVar.eventKey is pa2)
    MN0AS3C();
  end




end // end MN0A034

// get and lock the appl record
Function MN0A035()




       /* ************************************************/
       /* *                                             **/
       /* *      Get and lock the application record.   **/
       /* *                                             **/
       /* ************************************************/


  MN1REC.MN1KEY = " ";
  MN1REC.MN1TYPE1 = "1";
  MN1REC.MN1TYPE2 = "1";
  move MN0AM002 to MN1REC byName;

  MN0AW1.MN0AFLG1 = "N";





  try
    get MN1REC forUpdate ;
  end




   /* **** If the record does not exist or there is another*/
        /* error reading the record send back the approprate*/
        /* error message to the converser.*/

  if (MN1REC is ioError)
    MN0AW1.MN0AFLG1 = "Y";
    set MN0AM002 alarm;
    set MN0AM002.MN1APPL cursor, bold;
    if (MN1REC is noRecordFound)
      MN0AM002.MNAMSG = "THE APPLCATION RECORD DOES NOT EXIST";
    else
      MN0AM002.MNAMSG = "AN ERROR HAS OCCURED READING THE";
      MN0AM002.VAGen_EZEMSG = "APPLICATION RECORD";
    end
  end




end // end MN0A035

// delete the application record
Function MN0A036()




       /* ************************************************/
       /* *                                             **/
       /* *      Delete the application record.         **/
       /* *                                             **/
       /* ************************************************/


  MN1REC.MN1KEY = " ";
  MN1REC.MN1TYPE1 = "1";
  MN1REC.MN1TYPE2 = "1";
  move MN0AM002 to MN1REC byName;

  MN0AW1.MN0AFLG1 = "N";





  try
    delete MN1REC ;
  end




   /* **** If the record does not exist or there is another*/
        /* error deleting the record send back the approprate*/
        /* error message to the converser.*/

  if (MN1REC is ioError)
    MN0AW1.MN0AFLG1 = "Y";
    set MN0AM002 alarm;
    set MN0AM002.MN1APPL cursor, bold;
    MN0AM002.MNAMSG = "AN ERROR HAS OCCURED DELETING THE";
    MN0AM002.VAGen_EZEMSG = "APPLICATION RECORD";
  else
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.commit();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
     /* commit the delete for vsam dataset*/
    MN0AS3C(); /* clear the screen*/
  end




end // end MN0A036

// FTTL for the inquriy function
Function MN0A040()




         /* ****************************************************/
         /* *                                                 **/
         /* *                                                 **/
         /* *                                                 **/
         /* *                                                 **/
         /* ****************************************************/




end // end MN0A040

// get application records
Function MN0A041()




         /* ****************************************************/
         /* *                                                 **/
         /* *     Sequentially, get 12 application records    **/
         /* *  at a time to be displayed in the next converse.**/
         /* *                                                 **/
         /* ****************************************************/

  MN0AW1.MN0AFLG1 = "N";




  try
    get next MN4REC ;
  end




   /* **** If the end of file has been reached or the type*/
        /* of record has changed or 12 records has been read*/
        /* then converse the screen otherwise put the record*/
        /* to the screen.*/

  if (MN4REC is ioError)
    if (MN4REC is duplicate)
           /* next sentence*/
    else
      exit stack;
    end
    exit stack;
  end


   /* **** If the type of record has changed then exit this*/
        /* process.*/

  if (MN4REC.MN1TYPE1 == "1"
   && MN4REC.MN1TYPE2 == "1")
        /* next sentence*/
  else
    exit stack;
  end



   /* **** put the record to the screen.*/

  MN0AW1.MN0AIDX = MN0AW1.MN0AIDX + 1;
  if (MN0AW1.MN0AIDX <= 12)
    MN0AM003.MNAAPPL[MN0AIDX] = MN4REC.MN1APPL;
    MN0AM003.MNANAME[MN0AIDX] = MN4REC.MN1NM;
    MN0AM003.MNACICS[MN0AIDX] = MN4REC.MN1CICS;
    if (MN4REC.MN1CICS != "****")
      MN0AM003.MNAADD[MN0AIDX] = MN4REC.MN1ADDFL;
      MN0AM003.MNACHG[MN0AIDX] = MN4REC.MN1CHGFL;
      MN0AM003.MNADEL[MN0AIDX] = MN4REC.MN1DELFL;
      MN0AM003.MNAINQ[MN0AIDX] = MN4REC.MN1INQFL;
    end
    MN0AW1.MN0AFLG1 = "Y";
  else
    MN0AW1-NEXT-KEY = MN4REC.MN1APPL;
  end




end // end MN0A041

// display and get applications
Function MN0A042()




        /* ************************************************/
        /* *                                             **/
        /* *    Display the application records.         **/
        /* *                                             **/
        /* ************************************************/


   /* **** initialize the screen variables*/

  MN0AM003.MN0AMDT = VGVar.currentShortGregorianDate;
  MN0AM003.MNAPRCNM = "MN0A042";

  MN0AW1.MN0AFLG1 = "N";
  MN0AW1.MN0AFLG2 = "N";
  MN0AW1.MN0AFLG3 = "N";




  converse MN0AM003 ;





  MN0AM003.MNAMSG = " ";
  set MN0AM003.MN1APPL initialAttributes;


   /* ****  transfer control the the appropriote application*/
         /* if the keys PF1, or pf4 were pressed.*/

  MN0AS4A();
  if (MN0AW1.MN0AFLG1 == "Y")
    exit stack;
  end


   /* **** If anything is entered in the option field*/
        /* then transfer control to that application*/

  MN0AS4B();
  if (MN0AW1.MN0AFLG1 == "Y")
    exit stack;
  end


   /* **** If the pf7 or pf8 keys were pressed then*/
        /* set the pointer in the file to be able to*/
        /* scroll.*/

  MN0AS4C();
  if (MN0AW1.MN0AFLG1 == "Y"
   || MN0AW1.MN0AFLG2 == "Y")
    exit stack;
  end


   /* **** Check to see if an application id was entered.*/
        /* If one was entered then set the pointer in the file*/
        /* to point to that application.*/

  MN0AS4F();
  if (MN0AW1.MN0AFLG1 == "Y"
   || MN0AW1.MN0AFLG2 == "Y")
    exit stack;
  end


   /* **** Check to see if an application was selected to*/
        /* inquiry on.*/

  MN0AS4G();


  if (converseVar.eventKey is pf3
   || converseVar.eventKey is pa2)
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.commit();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
    
  end


end // end MN0A042

// get user application records
Function MN0A043()




         /* ****************************************************/
         /* *                                                 **/
         /* *     Get the user application record to be       **/
         /* *  displayed.                                     **/
         /* *                                                 **/
         /* ****************************************************/


  MN0AW1.MN0AFLG1 = "N";
  MN0AW1.MN0AFLG2 = "N";




  try
    get next MN4REC ;
  end




   /* **** Check the return code from the scan.  If an error has*/
        /* occured the display an error message.  Otherwise get*/
        /* another record.  A dup key is valid since we are*/
        /* reading by alternate key.*/


  if (MN4REC is ioError)
    if (MN4REC is duplicate)
          /* next sentence*/
    else
      if (MN4REC is endOfFile)
        MN0AW1.MN0AFLG2 = "Y";
        exit stack;
      else
        MN0AM003.MNAMSG = "AN ERROR HAS OCCURED READING THE USER";
        MN0AM003.VAGen_EZEMSG = "APPLICATON RECORD";
        MN0AW1.MN0AFLG1 = "Y";
        exit stack;
      end
    end
  end



  if (MN4REC.MN1TYPE1 != "3"
   || MN4REC.MN1TYPE2 != "3"
   || MN4REC.MN1APPL != MN0AM003.MNAAPPL[MN0AIDX])
    MN0AW1.MN0AFLG2 = "Y";
    exit stack;
  end

   /* **** move the flags from the record to the working*/
        /* storage record that will be used for the browse.*/


  MN0AW6.MN0AROWA = MN4REC.MN1ADDFL;
  MN0AW6.MN0AROWC = MN4REC.MN1ADDTB;
  MN0AW6.MN0AROWD = MN4REC.MN1CHGFL;
  MN0AW6.MN0AROWF = MN4REC.MN1CHGTB;
  MN0AW6.MN0AROWG = MN4REC.MN1DELFL;
  MN0AW6.MN0AROWI = MN4REC.MN1DELTB;
  MN0AW6.MN0AROWJ = MN4REC.MN1INQFL;
  MN0AW6.MN0AROWL = MN4REC.MN1INQTB;






end // end MN0A043

// get user name
Function MN0A044()




         /* ****************************************************/
         /* *                                                 **/
         /* *      Get the user name to be displayed along    **/
         /* *   with the user application record.             **/
         /* *                                                 **/
         /* ****************************************************/


  MN2REC.MN1KEY = " ";
  MN2REC.MN1TYPE1 = "2";
  MN2REC.MN1TYPE2 = "2";
  MN2REC.MN1USER = MN4REC.MN1USER;
  MN2REC.MN1APPL = MN2REC.MN1USER;


  MN0AW1.MN0AFLG1 = "N";




  try
    get MN1REC ;
  end




  if (MN1REC is ioError)
    MN0AW2.MN2USRNM = "NO USER NAME AVAILABLE";
    MN0AW1.MN0AWEF2 = "Y";
  else
    MN0AW2.MN2USRNM = MN2REC.MN2USRNM;
    MN0AW1.MN0AWEF2 = "N";
  end




end // end MN0A044

// put record to temp storage
Function MN0A045()
         /* ****************************************************/
         /* *                                                 **/
         /* *     Put the user application record to be       **/
         /* *  displayed to temporary storage.                **/
         /* *                                                 **/
         /* ****************************************************/


  MN0AW1.MN0AFLG1 = "N";

   /* **** Put the record to a working storage record which is*/
        /* formated to be put on the screen.*/

  MN0AW2.MN1USER = MN4REC.MN1USER;
  MN0AW2.MN0AHDR1 = " -  ";
  TA5REC.TA5FNCCD = "A";
  TA5REC.TA5APPID = "MN0A";

   /* **** call the cics module to put the record to the*/
        /* temp storage.*/

  call "TA0050" (MN0AW2, TA5REC) {isNoRefresh = yes, isExternal = yes};
  if (TA5REC.TA5RTNCD == 0)
     /* next sentence*/
  else
    MN0AM003.MNAMSG = "AN INVALID RETURN CODE FROM TA0050";
    MN0AM003.VAGen_EZEMSG = "HAS BEEN RETURNED";
    set MN0AM003 alarm;
    MN0AW1.MN0AFLG1 = "Y";
    exit stack;
  end


   /* **** put the second line of the browse to temp storage.*/

   /* **** call the cics module to put the record to the*/
        /* temp storage.*/

  MN0AW6.MN0AROWB = " - ";
  MN0AW6.MN0AROWE = " - ";
  MN0AW6.MN0AROWH = " - ";
  MN0AW6.MN0AROWK = " - ";

  call "TA0050" (MN0AW6, TA5REC) {isNoRefresh = yes, isExternal = yes};
  if (TA5REC.TA5RTNCD == 0)
     /* next sentence*/
  else
    MN0AM003.MNAMSG = "AN INVALID RETURN CODE FROM TA0050";
    MN0AM003.VAGen_EZEMSG = "HAS BEEN RETURNED";
    set MN0AM003 alarm;
    MN0AW1.MN0AFLG1 = "Y";
    exit stack;
  end

end // end MN0A045

// set pointer to next usr appl
Function MN0A046()




         /* ****************************************************/
         /* *                                                 **/
         /* *     Set the pointer in the file to the next     **/
         /* *  user application record.  Since the user record**/
         /* *  is in the same file as the user application    **/
         /* *  record and we had to get the user name this    **/
         /* *  got rid of the pointer in the file that        **/
         /* *  pointed to the next user application record.   **/
         /* *                                                 **/
         /* ****************************************************/


  move MN3REC to MN4REC withV60Compat;




  try
    get MN1REC ;
  end




   /* **** Check the return code from the inquire. If an error*/
        /* has occured then display an error message.*/


  if (MN1REC is ioError)
    MN0AM003.MNAMSG = "AN ERROR HAS OCCURED READING THE USER";
    MN0AM003.VAGen_EZEMSG = "APPLICATON RECORD";
    MN0AW1.MN0AFLG1 = "Y";
  end




end // end MN0A046

// browse user application recds
Function MN0A047()
         /* ****************************************************/
         /* *                                                 **/
         /* *     Browse the records we added in the previous **/
         /* *  processes.                                     **/
         /* *                                                 **/
         /* ****************************************************/



  MN0A047-010();

  converse MN0AM004 ;

  MN0A047-020();


end // end MN0A047

// load data to map
Function MN0A047-010()
  if (MN0AW1-LOAD-MAP == "N")
    return;
  end

  set MN0AM004 initial;
  MN0AM004.MN0AM-EZEDTE = VGVar.currentShortGregorianDate;
  MN0AM004.MNAAPPL = MN0AM003.MNAAPPL[MN0AIDX];
  MN0AM004.MNANAME = MN0AM003.MNANAME[MN0AIDX];
  MN0AM004.MNAADD = MN0AM003.MNAADD[MN0AIDX];
  MN0AM004.MNACHG = MN0AM003.MNACHG[MN0AIDX];
  MN0AM004.MNADEL = MN0AM003.MNADEL[MN0AIDX];
  MN0AM004.MNAINQ = MN0AM003.MNAINQ[MN0AIDX];
  MN0AM004.MN0AMFPG = MN0AW3.MN0AW3-FPG;
  MN0AM004.MN0AMLPG = MN0AW3.MN0AW3-LPG;

  if (MN0AW3.MN0AW3-FPG <= 1)
    TA5REC.TA5TSQIX = 1;
    MN0AW3.MN0AW3-FPG = 1;
  else
    TA5REC.TA5TSQIX = MN0AW3.MN0AW3-FPG * 14;
    TA5REC.TA5TSQIX = TA5REC.TA5TSQIX - 13;
  end

  MN0AW1.MN0AIDX1 = 0;
  while (MN0AW1.MN0AIDX1 < 7
   && TA5REC.TA5TSQIX < MN0AW3.MN0ACNT)
    TA5REC.TA5FNCCD = "R"; /* Function code*/
    try
      call "TA0050" (MN0AW2, TA5REC) {isNoRefresh = yes, isExternal = yes};
    end
    if (TA5REC.TA5RTNCD == 0) /* and normal return code*/
      MN0AW1.MN0AIDX1 = MN0AW1.MN0AIDX1 + 1;
      MN0AM004.MN0AM-APP-INFO[MN0AIDX1] = MN0AW2.MN0AHDR;
      TA5REC.TA5TSQIX = TA5REC.TA5TSQIX + 1;
      TA5REC.TA5FNCCD = "R"; /* Function code*/
      try
        call "TA0050" (MN0AW6, TA5REC) {isNoRefresh = yes, isExternal = yes};
      end
      MN0AM004.MN0AM-FLG-INFO[MN0AIDX1] = MN0AW6.MN0AROW;
      TA5REC.TA5TSQIX = TA5REC.TA5TSQIX + 1;
    end
  end
  MN0AW1-LOAD-MAP = "N";
end // end MN0A047-010

// process request
Function MN0A047-020()

  set MN0AM004.MN0AMFPG initialAttributes;
  set MN0AM004.MN0AMLPG initialAttributes;
  set MN0AM004.CATOAP initialAttributes;
  set MN0AM004.CAITEM initialAttributes;

  if (converseVar.eventKey is pf3)
    MN0AW1-END-BROWSE = "Y";
    return;
  end

  if (converseVar.eventKey is pf7)
    if (MN0AW3.MN0AW3-FPG == 1)
      MN0AM004.VAGen_EZEMSG = "*** TOP OF DATA ***";
      return;
    else
      MN0AW3.MN0AW3-FPG = MN0AW3.MN0AW3-FPG - 1;
      MN0AW1-LOAD-MAP = "Y";
      return;
    end
  end
  if (converseVar.eventKey is pf8)
    if (MN0AW3.MN0AW3-FPG < MN0AW3.MN0AW3-LPG)
      MN0AW3.MN0AW3-FPG = MN0AW3.MN0AW3-FPG + 1;
      MN0AW1-LOAD-MAP = "Y";
      return;
    else
      MN0AM004.VAGen_EZEMSG = "*** END OF DATA ***";
      set MN0AM004 alarm;
      return;
    end
  end
   /* **** Process the fast path.*/
  if (converseVar.eventKey is enter)
    if (MN0AM004.MN0AMFPG != MN0AW3.MN0AW3-FPG)
      if (MN0AM004.MN0AMFPG <= MN0AW3.MN0AW3-LPG
       && MN0AM004.MN0AMFPG >= 1)
        MN0AW3.MN0AW3-FPG = MN0AM004.MN0AMFPG;
        MN0AW1-LOAD-MAP = "Y";
        return;
      end
      if (MN0AM004.MN0AMFPG > MN0AW3.MN0AW3-LPG)
        MN0AM004.VAGen_EZEMSG = "**** PAGE ENTERED GT MAX PAGE - REENTER";
        set MN0AM004.MN0AMFPG bold, cursor;
        set MN0AM004 alarm;
        return;
      end
      if (MN0AM004.MN0AMFPG < 1)
        MN0AM004.VAGen_EZEMSG = "**** INVALID PAGE NUMBER - REENTER";
        set MN0AM004.MN0AMFPG bold, cursor;
        set MN0AM004 alarm;
        return;
      end
    end
    /* **** Process the fast path.*/
    if (MN0AM004.CATOAP != " ")
      move MN0AM004 to COMMAREA withV60Compat;
      XSEXIT();
      MN0AM004.VAGen_EZEMSG = COMMAREA.CAMSG;
      set MN0AM004 alarm;
      set MN0AM004.CATOAP cursor, bold;
      return;
    end
  end

  MN0AM004.VAGen_EZEMSG = "*** INVALID ENTRY - TRY AGAIN ***";
  set MN0AM004 alarm;

end // end MN0A047-020

// process function keys
Function MN0AS0A()




         /* ***************************************************/
         /* *                                                **/
         /* *        Process the special function keys.      **/
         /* *                                                **/
         /* ***************************************************/



   /* **** Process the PF1 key.*/

  if (converseVar.eventKey is pf1)
    XSPF1();
    MN0AM001.MNAMSG = COMMAREA.CAMSG;
    set MN0AM001 alarm;
    MN0AW1.MN0AFLG1 = "Y";
    return;
  end


   /* **** Process the PF4 key.*/

  if (converseVar.eventKey is pf4)
    XSPF4();
    MN0AM001.MNAMSG = COMMAREA.CAMSG;
    set MN0AM001 alarm;
    MN0AW1.MN0AFLG1 = "Y";
    return;
  end


   /* **** Process the PF3 and pa2 keys.*/

  if (converseVar.eventKey is pf3
   || converseVar.eventKey is pa2)
    COMMAREA.CATOAP = "MN0N";
    XSEXIT();
    MN0AM001.MNAMSG = COMMAREA.CAMSG;
    set MN0AM001 alarm;
    MN0AW1.MN0AFLG1 = "Y";
    return;
  end




end // end MN0AS0A

// process fast path
Function MN0AS0B()




         /* ***************************************************/
         /* *                                                **/
         /* *         Process the fast path.                 **/
         /* *                                                **/
         /* ***************************************************/

   /* **** Process the fast path.*/

  if (converseVar.eventKey is enter
   && MN0AM001.CATOAP != " ")
    move MN0AM001 to COMMAREA withV60Compat;
    XSEXIT();
    MN0AM001.MNAMSG = COMMAREA.CAMSG;
    set MN0AM001 alarm;
    set MN0AM001.CATOAP cursor, bold;
    MN0AW1.MN0AFLG1 = "Y";
    return;
  end




end // end MN0AS0B

// process function keys
Function MN0AS1A()




         /* ***************************************************/
         /* *                                                **/
         /* *        Process the special function keys.      **/
         /* *                                                **/
         /* ***************************************************/



   /* **** Process the PF1 key.*/

  if (converseVar.eventKey is pf1)
    XSPF1();
    MN0AM002.MNAMSG = COMMAREA.CAMSG;
    set MN0AM002 alarm;
    MN0AW1.MN0AFLG1 = "Y";
    return;
  end


   /* **** Process the PF4 key.*/

  if (converseVar.eventKey is pf4)
    XSPF4();
    MN0AM002.MNAMSG = COMMAREA.CAMSG;
    set MN0AM002 alarm;
    MN0AW1.MN0AFLG1 = "Y";
    return;
  end




end // end MN0AS1A

// process fast path
Function MN0AS1B()




         /* ***************************************************/
         /* *                                                **/
         /* *         Process the fast path.                 **/
         /* *                                                **/
         /* ***************************************************/

   /* **** Process the fast path.*/

  if (converseVar.eventKey is enter
   && MN0AM002.CATOAP != " ")
    move MN0AM002 to COMMAREA withV60Compat;
    XSEXIT();
    MN0AM002.MNAMSG = COMMAREA.CAMSG;
    set MN0AM002 alarm;
    set MN0AM002.CATOAP cursor, bold;
    MN0AW1.MN0AFLG1 = "Y";
    return;
  end




end // end MN0AS1B

// validate the applcation id
Function MN0AS1C()




         /* **************************************************/
         /* *                                               **/
         /* *        Validate the application id.           **/
         /* *                                               **/
         /* **************************************************/

   /* **** the field must start with an alpha character.*/
        /* If the field is invalid then set the flag and*/
        /* set the field to be highlighted.*/

  MN0AW1.MN0ACK = MN0AM002.MN1APPL;
  if (MN0AW1.MN0ACK1 >= "A"
   && MN0AW1.MN0ACK1 <= "I")
    /* next sentence*/
  else
    if (MN0AW1.MN0ACK1 >= "J"
     && MN0AW1.MN0ACK1 <= "R")
      /* next sentence*/
    else
      if (MN0AW1.MN0ACK1 >= "S"
       && MN0AW1.MN0ACK1 <= "Z")
        /* next sentence*/
      else
        if (MN0AW1.MN0ACK1 == "&")
          if (COMMAREA.CAUSERID in MN5TBL.CAUSERID)
                                   /* user-id okay for "&" deletes*/
           /* next sentence*/
          else
            MN0AM002.MNAMSG = "USERID CANNOT DELETE A PROFILE";
            MN0AW1.MN0AFLG1 = "Y";
            set MN0AM002 alarm;
            set MN0AM002.MN1APPL cursor;
            set MN0AM002.MN1APPL bold;
          end
        else
         /* next sentence*/
        end
      end
    end
  end




end // end MN0AS1C

// validate the applicatio name
Function MN0AS1D()




         /* ***************************************************/
         /* *                                                **/
         /* *       Validate the application name field.     **/
         /* *                                                **/
         /* ***************************************************/


   /* **** the name field must not be blank.*/

  if (MN0AM002.MN1NM == " ")
    MN0AM002.MNAMSG = "APPLICATION NAME MUST BE ENTERED";
    set MN0AM002 alarm;
    set MN0AM002.MN1NM cursor, bold;
    MN0AW1.MN0AFLG1 = "Y";
  end




end // end MN0AS1D

// validate the cics transaction
Function MN0AS1E()




         /* **************************************************/
         /* *                                               **/
         /* *        Validate the cics transaction id.      **/
         /* *                                               **/
         /* **************************************************/


   /* **** the field must start with an alpha character.*/
        /* If the field is invalid then set the flag and*/
        /* set the field to be highlighted.*/

  MN0AW1.MN0ACK = MN0AM002.MN1CICS;
  if (MN0AW1.MN0ACK1 >= "A"
   && MN0AW1.MN0ACK1 <= "I")
    /* next sentence*/
  else
    if (MN0AW1.MN0ACK1 >= "J"
     && MN0AW1.MN0ACK1 <= "R")
      /* next sentence*/
    else
      if (MN0AW1.MN0ACK1 >= "S"
       && MN0AW1.MN0ACK1 <= "Z")
        /* next sentence*/
      else
        if (MN0AW1.MN0ACK1 == "#") /* tech services prefix*/
          /* next sentence*/
        else
          if (MN0AW1.MN0ACK1 == "&") /* group prefix*/
            /* next sentence*/
          else
            MN0AM002.MNAMSG = "INVALID CICS TRANSACTION ID";
            MN0AW1.MN0AFLG1 = "Y";
            set MN0AM002 alarm;
            set MN0AM002.MN1CICS cursor, bold;
          end
        end
      end
    end
  end




end // end MN0AS1E

// clear screen, set fields to N
Function MN0AS1F()




       /* ************************************************/
       /* *                                             **/
       /* *      Clear the screen fields and set the    **/
       /* *   flags to N.                               **/
       /* *                                             **/
       /* ************************************************/


  set MN0AM002 initial;


   /* **** Set all the flags on the screen to 'n'.*/

  MN0AM002.MN1ADDFL = "N";
  MN0AM002.MN1CHGFL = "N";
  MN0AM002.MN1DELFL = "N";
  MN0AM002.MN1INQFL = "N";

  MN0AW1.MN0AIDX = 1;

  while (MN0AW1.MN0AIDX < 11)
    MN0AM002.MN1ALVL[MN0AIDX] = "N";
    MN0AM002.MN1CLVL[MN0AIDX] = "N";
    MN0AM002.MN1DLVL[MN0AIDX] = "N";
    MN0AM002.MN1ILVL[MN0AIDX] = "N";
    MN0AW1.MN0AIDX = MN0AW1.MN0AIDX + 1;
  end



end // end MN0AS1F

// check for dependencies
Function MN0AS2C()




         /* ****************************************************/
         /* *                                                 **/
         /* *   If there exists                               **/
         /* *   a Y in any flag on the user application record**/
         /* *   where a N exists on the application record    **/
         /* *   then this is an error condition and the       **/
         /* *   record cannot be changed.                     **/
         /* *                                                 **/
         /* ****************************************************/


   /* **** check each flag on the record.  If a flag is set to*/
        /* a Y on the record where a N exists on the screen flags*/
        /* then this is an error and the record cannot be changed*/

  if (MN0AM002.MN1INQFL == "N"
   && MN4REC.MN1INQFL == "Y")
    MN0AW1.MN0AFLG3 = "Y";
    MN0AW1.MN0AMSG2 = MN4REC.MN1USER;
    MN0AM002.MNAMSG = MN0AW1.MN0AMSG;
    set MN0AM002.MN1INQFL cursor, bold;
    set MN0AM002 alarm;
  end


  if (MN0AM002.MN1DELFL == "N"
   && MN4REC.MN1DELFL == "Y")
    MN0AW1.MN0AFLG3 = "Y";
    MN0AW1.MN0AMSG2 = MN4REC.MN1USER;
    MN0AM002.MNAMSG = MN0AW1.MN0AMSG;
    set MN0AM002.MN1DELFL cursor, bold;
    set MN0AM002 alarm;
  end


  if (MN0AM002.MN1CHGFL == "N"
   && MN4REC.MN1CHGFL == "Y")
    MN0AW1.MN0AFLG3 = "Y";
    MN0AW1.MN0AMSG2 = MN4REC.MN1USER;
    MN0AM002.MNAMSG = MN0AW1.MN0AMSG;
    set MN0AM002.MN1CHGFL cursor, bold;
    set MN0AM002 alarm;
  end


  if (MN0AM002.MN1ADDFL == "N"
   && MN4REC.MN1ADDFL == "Y")
    MN0AW1.MN0AFLG3 = "Y";
    MN0AW1.MN0AMSG2 = MN4REC.MN1USER;
    MN0AM002.MNAMSG = MN0AW1.MN0AMSG;
    set MN0AM002.MN1ADDFL cursor, bold;
    set MN0AM002 alarm;
  end




end // end MN0AS2C

// check for level dependencies
Function MN0AS2D()




         /* ****************************************************/
         /* *                                                 **/
         /* *   If there exists                               **/
         /* *   a Y in any flag on the user application record**/
         /* *   where a N exists on the application record    **/
         /* *   then this is an error condition and the       **/
         /* *   record cannot be changed.                     **/
         /* *                                                 **/
         /* ****************************************************/


   /* **** check each flag on the record.  If a flag is set to*/
        /* a Y on the record where a N exists on the screen flags*/
        /* then this is an error and the record cannot be changed*/

  if (MN0AM002.MN1ILVL[MN0AIDX] == "N"
   && MN4REC.MN1ILVL[MN0AIDX] == "Y")
    MN0AW1.MN0AFLG3 = "Y";
    MN0AW1.MN0AMSG2 = MN4REC.MN1USER;
    MN0AM002.MNAMSG = MN0AW1.MN0AMSG;
    set MN0AM002.MN1ILVL[MN0AIDX] cursor, bold;
    set MN0AM002 alarm;
  end


  if (MN0AM002.MN1DLVL[MN0AIDX] == "N"
   && MN4REC.MN1DLVL[MN0AIDX] == "Y")
    MN0AW1.MN0AFLG3 = "Y";
    MN0AW1.MN0AMSG2 = MN4REC.MN1USER;
    MN0AM002.MNAMSG = MN0AW1.MN0AMSG;
    set MN0AM002.MN1DLVL[MN0AIDX] cursor, bold;
    set MN0AM002 alarm;
  end


  if (MN0AM002.MN1CLVL[MN0AIDX] == "N"
   && MN4REC.MN1CLVL[MN0AIDX] == "Y")
    MN0AW1.MN0AFLG3 = "Y";
    MN0AW1.MN0AMSG2 = MN4REC.MN1USER;
    MN0AM002.MNAMSG = MN0AW1.MN0AMSG;
    set MN0AM002.MN1CLVL[MN0AIDX] cursor, bold;
    set MN0AM002 alarm;
  end


  if (MN0AM002.MN1ALVL[MN0AIDX] == "N"
   && MN4REC.MN1ALVL[MN0AIDX] == "Y")
    MN0AW1.MN0AFLG3 = "Y";
    MN0AW1.MN0AMSG2 = MN4REC.MN1USER;
    MN0AM002.MNAMSG = MN0AW1.MN0AMSG;
    set MN0AM002.MN1ALVL[MN0AIDX] cursor, bold;
    set MN0AM002 alarm;
  end




end // end MN0AS2D

// clear screen, set flds protect
Function MN0AS3C()




       /* ************************************************/
       /* *                                             **/
       /* *      Clear the screen and set all the fields**/
       /* *   to a protected status.                    **/
       /* *                                             **/
       /* ************************************************/


  set MN0AM002 initial;

   /* **** Set all the fields on the screen to protect.*/

  set MN0AM002.MN1NM protect;
  set MN0AM002.MN1CICS protect;


  set MN0AM002.MN1ADDFL protect;
  set MN0AM002.MN1CHGFL protect;
  set MN0AM002.MN1DELFL protect;
  set MN0AM002.MN1INQFL protect;

  MN0AW1.MN0AIDX = 1;

  while (MN0AW1.MN0AIDX < 11)
    set MN0AM002.MN1ALVL[MN0AIDX] protect;
    set MN0AM002.MN1CLVL[MN0AIDX] protect;
    set MN0AM002.MN1DLVL[MN0AIDX] protect;
    set MN0AM002.MN1ILVL[MN0AIDX] protect;
    MN0AW1.MN0AIDX = MN0AW1.MN0AIDX + 1;
  end




end // end MN0AS3C

// process function keys
Function MN0AS4A()




         /* ***************************************************/
         /* *                                                **/
         /* *        Process the special function keys.      **/
         /* *                                                **/
         /* ***************************************************/



   /* **** Process the PF1 key.*/

  if (converseVar.eventKey is pf1)
    XSPF1();
    MN0AM003.MNAMSG = COMMAREA.CAMSG;
    set MN0AM003 alarm;
    MN0AW1.MN0AFLG1 = "Y";
    return;
  end


   /* **** Process the PF4 key.*/

  if (converseVar.eventKey is pf4)
    XSPF4();
    MN0AM003.MNAMSG = COMMAREA.CAMSG;
    set MN0AM003 alarm;
    MN0AW1.MN0AFLG1 = "Y";
    return;
  end




end // end MN0AS4A

// process fast path
Function MN0AS4B()




         /* ***************************************************/
         /* *                                                **/
         /* *         Process the fast path.                 **/
         /* *                                                **/
         /* ***************************************************/

   /* **** Process the fast path.*/

  if (converseVar.eventKey is enter
   && MN0AM003.CATOAP != " ")
    move MN0AM003 to COMMAREA withV60Compat;
    XSEXIT();
    MN0AM003.MNAMSG = COMMAREA.CAMSG;
    set MN0AM003 alarm;
    set MN0AM003.CATOAP cursor, bold;
    MN0AW1.MN0AFLG1 = "Y";
    return;
  end




end // end MN0AS4B

// application scrolling
Function MN0AS4C()




          /* ***************************************************/
          /* *                                                **/
          /* *  If the PF7 or PF8 key was pressed then perform**/
          /* *the statement group to handle each one.         **/
          /* *                                                **/
          /* ***************************************************/


   /* **** scroll back*/

  if (converseVar.eventKey is pf7)
    MN0AS4D();
    return;
  end


   /* **** scroll forward*/

  if (converseVar.eventKey is pf8)
    MN0AS4E();
    return;
  end




end // end MN0AS4C

// scroll back
Function MN0AS4D()




       /* ***************************************************/
       /* *                                                **/
       /* *                 SCROLL BACK                    **/
       /* *                                                **/
       /* *    Set the pointer in the MENU FILE to the     **/
       /* *  previous user key in the key table.           **/
       /* *                                                **/
       /* ***************************************************/


   /* **** if the beginning of the table has been reached then*/
        /* set the pointer to the first user record in the file.*/

        /* mn0aflg2 is used to branch back to the scan process*/



  if (MN0AW1.MN0A1KEY < 1)
    MN0AW1.MN0A1KEY = 0;
    MN0AW1.MN0AFLG1 = "Y";
  else
    MN4REC.MN1KEY = " ";
    MN4REC.MN1TYPE1 = "1";
    MN4REC.MN1TYPE2 = "1";
    MN4REC.MN1APPL = MN0AW1.MN0A1TBL[MN0A1KEY];
    MN0AW1.MN0A1KEY = MN0AW1.MN0A1KEY - 1;
    MN0AW1.MN0AIDX = 0;
    set MN0AM003 initial;
    MN0AW1.MN0AFLG2 = "Y";
    set MN4REC position;
  end




end // end MN0AS4D

// scroll forward
Function MN0AS4E()
       /* ***************************************************/
       /* *                                                **/
       /* *                 SCROLL FORWARD                 **/
       /* *                                                **/
       /* *                                                **/
       /* ***************************************************/


   /* **** mn0aflg2 is used to branch back to the scan process.*/
        /* mn0aflg1 is used to branch back to the converse.*/

        /* If the end of file is reached or the record type has*/
        /* changed then we want to keep what is on the screen*/
        /* otherwise save the first record key on the screen.*/
        /* This will be used for scrolling back.*/


  if (MN4REC is ioError)
    if (MN4REC is duplicate)
            /* next sentence*/
    else
      MN0AW1.MN0AFLG1 = "Y";
      return;
    end
  end


  MN0AW1.MN0A1KEY = MN0AW1.MN0A1KEY + 1;
  MN0A1TBL[MN0A1KEY] = MN0AM003.MNAAPPL[1];
  set MN0AM003 initial;
  MN0AW1.MN0AIDX = 0;
  MN0AW1.MN0AFLG2 = "Y";
  MN4REC.MN1KEY = " ";
  MN4REC.MN1TYPE1 = "1";
  MN4REC.MN1TYPE2 = "1";
  MN4REC.MN1APPL = MN0AW1-NEXT-KEY;
  set MN4REC position;

end // end MN0AS4E

// check for appl id entered
Function MN0AS4F()




       /* *******************************************************/
       /* *                                                    **/
       /* *      Check to see if an application id was entered.**/
       /* *   If one was entered then set the pointer in the   **/
       /* *   file to point to that application.               **/
       /* *                                                    **/
       /* *******************************************************/


   /* **** If an appl id was entered then set the pointer in the*/
        /* file to that user.*/

        /* mn0uflg2 is a flag used to branch back to the scan*/
        /* process.*/



  if (converseVar.eventKey is enter)
     /* AND MN0AM003.MN1APPL NE ' ';*/
    MN4REC.MN1KEY = " ";
    MN4REC.MN1TYPE2 = "1";
    MN4REC.MN1APPL = MN0AM003.MN1APPL;
    set MN4REC position;
    if (MN0AM003.MN1APPL != " ")
      MN0AW1.MN0AIDX = 0;
      set MN0AM003 initial;
      MN0AW1.MN0AFLG2 = "Y";
    else
    end
  else
  end




end // end MN0AS4F

// get application to inquiry on
Function MN0AS4G()
         /* ****************************************************/
         /* *                                                 **/
         /* *       Check to see if an application has been   **/
         /* *   selected to inquiry on.                       **/
         /* *                                                 **/
         /* ****************************************************/

   /* **** Check to see if an appl has been selected to inquiry*/
        /* apon.  Loop through each record on the screen looking*/
        /* for one to be selected.If one was selected then set*/
        /* the pointer in the MENU FILE to the first user*/
        /* application record for the appl selected.*/

        /* mn0aw1.mn0aflg3 will be set when a user was selected*/
                        /* to inquiry on.*/

  if (converseVar.eventKey is enter)
  else
    return;
  end

  MN0AW1.MN0AIDX = 1;
  MN0AW1.MN0AFLG3 = "N";

  while (MN0AW1.MN0AIDX < 13
   && MN0AW1.MN0AFLG3 != "Y")
    MN0AS4H();
    if (MN0AW1.MN0AFLG3 != "Y")
      MN0AW1.MN0AIDX = MN0AW1.MN0AIDX + 1;
    end
  end


   /* **** Set the pointer in the MENU FILE if*/
        /* an appl was selected.*/

  if (MN0AW1.MN0AFLG3 == "Y")
    MN0AS4I(); /* purge tsq*/
    MN0AM003.MNASLCT[MN0AIDX] = " ";
    MN4REC.MN1KEY = " ";
    MN4REC.MN1APPL = MN0AM003.MNAAPPL[MN0AIDX];
    MN4REC.MN1TYPE2 = "3";
    set MN4REC position;
  end




end // end MN0AS4G

// search through screen table
Function MN0AS4H()




       /* *******************************************************/
       /* *                                                    **/
       /* *    Check for an S to be entered next to an appl    **/
       /* *  record on the screen.                             **/
       /* *                                                    **/
       /* *******************************************************/


  if (MN0AM003.MNASLCT[MN0AIDX] == "S")
    MN0AW1.MN0AFLG3 = "Y";
  end




end // end MN0AS4H

// purge the temp storage queue
Function MN0AS4I()
   /* ------------------------------------------------------------*/
   /* Initialize the storage areas and indicators to be used.*/
   /* ------------------------------------------------------------*/

  TA5REC.TA5TSQIX = 0; /* Current page number*/
  TA5REC.TA5APPID = "MN0A"; /* Application identification*/
  TA5REC.TA5FNCCD = "P"; /* Function code*/

  try
    call "TA0050" (MN0AW2, TA5REC) {isNoRefresh = yes, isExternal = yes};
  end /* Temporary storage*/

   /* ------------------------------------------------------------*/
   /* If successful, return to previous process.*/
   /* ------------------------------------------------------------*/

  if (TA5REC.TA5RTNCD == 0) /* if normal return code*/
     /* next sentence*/
  else
    MN0AM003.MNAMSG = "AN INVALID RETURN CODE FROM TA0050";
    MN0AM003.VAGen_EZEMSG = "HAS BEEN RETURNED";
    set MN0AM003 alarm;
    MN0AW1.MN0AFLG1 = "Y";
    exit stack;
  end


end // end MN0AS4I

//*** RECORD=MN0AW1 ****
// 
//       ****************************************************
//       *                                                  *
//       *       Working storage record for the MN0A        *
//       *   application.                                   *
//       *                                                  *
//       ****************************************************
// 
// 
//       This record contains all the working storage variables
// that are needed by the application.
// 
// 
// 
// **********************
Record MN0AW1 type basicRecord
  10 MN0AFLG1 MN0AFLG1 ; 
  10 MN0AFLG2 MN0AFLG2 ; 
  10 MN0AFLG3 MN0AFLG3 ; 
  10 MN0AWEF2 MN0AWEF2 ; 
  10 MN0AIT MN0AIT ; 
    20 MN0AIT1 MN0AIT1 ; 
    20 MN0AIT2 MN0AIT2 ; 
    20 MN0AIT3 MN0AIT3 ; 
    20 MN0AIT4 MN0AIT4 ; 
  10 MN0ACK MN0ACK ; 
    20 MN0ACK1 MN0ACK1 ; 
    20 MN0ACK2 MN0ACK2 ; 
  10 MN0AIDX MN0AIDX ; 
  10 MN0AIDX1 MN0AIDX1 ; 
  10 MN0AAPPL MN0AAPPL ; 
  10 MN0A1TBL MN0A1TBL [50] ; 
  10 MN0AW1-NEXT-KEY MN0AW1-NEXT-KEY ; 
  10 MN0AW1-END-BROWSE MN0AW1-END-BROWSE ; 
  10 MN0AW1-LOAD-MAP MN0AW1-LOAD-MAP ; 
  10 MN0A1KEY MN0A1KEY ; 
  10 MN0A2KEY MN0A2KEY ; 
  10 MN0AMSG MN0AMSG ; 
    20 MN0AMSG1 MN0AMSG1 ; 
    20 MN0AMSG2 MN0AMSG2 ; 
    20 MN0AMSG3 MN0AMSG3 ; 
end // end MN0AW1

//*** RECORD=MN0AW2 ****
// 
//        ****************************************************
//        *                                                  *
//        *       Data record passed to TA0050 to be put to  *
//        *   temporary storage.                             *
//        *                                                  *
//        ****************************************************
// 
// 
// 
// 
// **********************
Record MN0AW2 type basicRecord
  10 MN0AW2FL MN0AW2FL ; 
    20 MN0ALENG MN0ALENG ; 
    20 MN0AHDR MN0AHDR ; 
      30 MN1USER MN1USER ; 
      30 MN0AHDR1 MN0AHDR1 ; 
      30 MN2USRNM MN2USRNM ; 
      30 * char(35) ; 
end // end MN0AW2

//*** RECORD=MN0AW3 ****
// 
//         ****************************************************
//         *                                                  *
//         *         This is the working storage record which *
//         *    contains the parameters passed to the cics    *
//         *    called module ta0050.                         *
//         *                                                  *
//         ****************************************************
// 
// 
//         mn0aapid = application id of the application calling
//                    the cics module.
// 
//         mn0acnt  = the count of the item being put in the
//                    queue, this is returned to the csp
//                    program for an 'A', add to the queue.
//                    It is supplied to this module by the csp
//                    application for a read or update.
// 
//         mn0acode = n - new.  This will be used the first
//                              time through to initilalize
//                              the queue.
//                    a - add.   add a record to the queue.
//                    p - purge. Delete the queue.
//                    r - retrieve. Retrieve a record from the
//                                  queue.  This would be used
//                                  with the mn0acnt field.
//                    u - update.   Update a record in the
//                                  queue. Use the mn0acnt
//                                  field with this option.
//         mn0artn  = return code.
//                    0 - good return.
//                    3 - length not numeric or > 395
//                    4 - queue id error. A read or update
//                        was requested and the queue is not
//                        found.
//                    5 - catch all error.
//                    6 - count is not numeric
//                    7 - item error. The temp storage item is
//                        not found.
// 
// 
// **********************
Record MN0AW3 type basicRecord
  10 MN0AW-TA5DATA MN0AW-TA5DATA ; 
    20 MN0AAPID MN0AAPID ; 
    20 MN0ACNT MN0ACNT ; 
    20 MN0ACODE MN0ACODE ; 
    20 MN0ARTN MN0ARTN ; 
  10 MN0AW3-FPG MN0AW3-FPG ; 
  10 MN0AW3-LPG MN0AW3-LPG ; 
  10 MN0AW3-CPG MN0AW3-CPG ; 
end // end MN0AW3

//*** RECORD=MN0AW4 ****
// 
// 
//          ***************************************************
//          *                                                 *
//          *      This working storage record contains all   *
//          *   headers that are required to browse the user  *
//          *   application records.                          *
//          *                                                 *
//          ***************************************************
// 
// 
// 
// 
// **********************
Record MN0AW4 type basicRecord
  10 MN0ANUM MN0ANUM ; 
  10 MN0ALN1 MN0ALN1 ; 
    20 MN0ALN1A MN0ALN1A ; 
    20 MN0ALN1B MN0ALN1B ; 
    20 MN0ALN1C MN0ALN1C ; 
  10 MN0ALN2 MN0ALN2 ; 
  10 MN0ALN3 MN0ALN3 ; 
    20 MN0ALN3A MN0ALN3A ; 
    20 MN0ALN3B MN0ALN3B ; 
    20 MN0ALN3C MN0ALN3C ; 
    20 MN0ALN3D MN0ALN3D ; 
    20 MN0ALN3E MN0ALN3E ; 
    20 MN0ALN3F MN0ALN3F ; 
    20 * char(6) ; 
  10 MN0ALN4 MN0ALN4 ; 
    20 MN0ALN4A MN0ALN4A ; 
    20 MN0ALN4B MN0ALN4B ; 
    20 MN0ALN4C MN0ALN4C ; 
    20 MN0ALN4D MN0ALN4D ; 
    20 MN0ALN4E MN0ALN4E ; 
    20 MN0ALN4F MN0ALN4F ; 
    20 * char(6) ; 
end // end MN0AW4

//*** RECORD=MN0AW5 ****
// 
// 
//       *****************************************************
//       *                                                   *
//       *       This working storage record contains the    *
//       *   column headings for the user application browse *
//       *                                                   *
//       *****************************************************
// 
// 
// 
// **********************
Record MN0AW5 type basicRecord
  10 MN0ALN6 MN0ALN6 ; 
    20 MN0ALN6A MN0ALN6A ; 
    20 MN0ALN6B MN0ALN6B ; 
end // end MN0AW5

//*** RECORD=MN0AW6 ****
// 
//         ****************************************************
//         *                                                  *
//         *       This record contains the user application  *
//         *    level flags that will be passed to TA0050     *
//         *                                                  *
//         ****************************************************
// 
// 
// 
// 
// **********************
Record MN0AW6 type basicRecord
  10 MN0AW6FL MN0AW6FL ; 
    20 MN0ALENG MN0ALENG ; 
    20 * char(9) ; 
    20 MN0AROW MN0AROW ; 
      30 MN0AROWA MN0AROWA ; 
      30 MN0AROWB MN0AROWB ; 
      30 MN0AROWC MN0AROWC ; 
      30 * char(4) ; 
      30 MN0AROWD MN0AROWD ; 
      30 MN0AROWE MN0AROWE ; 
      30 MN0AROWF MN0AROWF ; 
      30 * char(4) ; 
      30 MN0AROWG MN0AROWG ; 
      30 MN0AROWH MN0AROWH ; 
      30 MN0AROWI MN0AROWI ; 
      30 * char(4) ; 
      30 MN0AROWJ MN0AROWJ ; 
      30 MN0AROWK MN0AROWK ; 
      30 MN0AROWL MN0AROWL ; 
end // end MN0AW6

//*** RECORD=MN0AW7 ****
// 
//         ****************************************************
//         *                                                  *
//         *     This is the working storage record which     *
//         *  contains the parameters passed to the cics      *
//         *  called module TA0060.                           *
//         *                                                  *
//         ****************************************************
// 
// 
//         mn0aapid - application id.  Each temporary storage
//                    file has an application id as part of
//                    the file name.  mn0aapid must be the
//                    same application id as the temporary
//                    storage you need to access.
// 
//         mn0artn  - return code.  1 - something was entered
//                                      in the option field.
//                                  2 - A record was selected.
// 
//         mn0apsdt - data record passed back.  If a record
//                    was selected then the record will be
//                    passed back in this field.
// 
// 
// 
// 
// **********************
Record MN0AW7 type basicRecord
  10 MN0APRAM MN0APRAM ; 
    20 MN0AAPID MN0AAPID ; 
    20 MN0ARTN MN0ARTN ; 
    20 CATOAP CATOAP ; 
    20 CAITEM CAITEM ; 
  10 MN0APSDT MN0APSDT ; 
end // end MN0AW7

//*** RECORD=MN0AW8 ****
// 
// 
//       *****************************************************
//       *                                                   *
//       *       This working storage record contains the    *
//       *   column headings for the user application browse *
//       *                                                   *
//       *****************************************************
// 
// 
// 
// **********************
Record MN0AW8 type basicRecord
  10 MN0ALN7 MN0ALN7 ; 
    20 MN0ALN7A MN0ALN7A ; 
    20 MN0ALN7B MN0ALN7B ; 
end // end MN0AW8

// application table index
DataItem MN0A1KEY smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// application key table
DataItem MN0A1TBL char(400)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// user application table index
DataItem MN0A2KEY smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// application id
DataItem MN0AAPID char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// saved application id
DataItem MN0AAPPL char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// used to validate appl id
DataItem MN0ACK char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// used to validate appl id
DataItem MN0ACK1 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// used to validate appl id
DataItem MN0ACK2 char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// count of rows added
DataItem MN0ACNT num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// function to be performed
DataItem MN0ACODE char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// error flag
DataItem MN0AFLG1 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// special branching flag
DataItem MN0AFLG2 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// special branching flag
DataItem MN0AFLG3 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem MN0AHDR char(77)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem MN0AHDR1 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// working storage index
DataItem MN0AIDX smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// working storage index
DataItem MN0AIDX1 smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// commarea item break down
DataItem MN0AIT char(20)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// item part 1
DataItem MN0AIT1 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// item part 2
DataItem MN0AIT2 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// item part 3
DataItem MN0AIT3 char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// item part 4
DataItem MN0AIT4 char(14)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// length of row
DataItem MN0ALENG num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// 1st heading line
DataItem MN0ALN1 char(77)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// 1st half 1st heading line
DataItem MN0ALN1A char(37)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// 2nd half 1st heading line
DataItem MN0ALN1B char(32)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// current date
DataItem MN0ALN1C char(8)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// blank line
DataItem MN0ALN2 char(77)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// 3rd heading line
DataItem MN0ALN3 char(77)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// 3rd heading 1st item
DataItem MN0ALN3A char(9)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// menu application id
DataItem MN0ALN3B char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// 3rd heading 3rd item
DataItem MN0ALN3C char(42)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// menu record add flag
DataItem MN0ALN3D char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// 3rd heading 3rd item
DataItem MN0ALN3E char(14)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// menu record change flag
DataItem MN0ALN3F char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// 4th heading line
DataItem MN0ALN4 char(77)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// 4th heading 1st item
DataItem MN0ALN4A char(9)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// menu application name
DataItem MN0ALN4B char(30)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// 4th heading 3rd item
DataItem MN0ALN4C char(16)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// menu record delete flag
DataItem MN0ALN4D char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// 4th heading 3rd item
DataItem MN0ALN4E char(14)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// menu record inquiry flag
DataItem MN0ALN4F char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// 1st column heading line
DataItem MN0ALN6 char(77)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// 1st column 1st half
DataItem MN0ALN6A char(37)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// 1st column 2nd half
DataItem MN0ALN6B char(40)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// 2nd column heading line
DataItem MN0ALN7 char(77)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// 2nd column 1st half
DataItem MN0ALN7A char(37)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// 2nd column 2nd half
DataItem MN0ALN7B char(40)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// error message
DataItem MN0AMSG char(40)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// first part of error message
DataItem MN0AMSG1 char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// second part of error message
DataItem MN0AMSG2 char(8)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// third part of error message
DataItem MN0AMSG3 char(27)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem MN0ANUM num(1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// pramaters passed back
DataItem MN0APRAM char(29)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// data passed back from browse
DataItem MN0APSDT char(77)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem MN0AROW char(68)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// ADD FLAG
DataItem MN0AROWA char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dash
DataItem MN0AROWB char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// add level flags
DataItem MN0AROWC char(10)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// change flag
DataItem MN0AROWD char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dash
DataItem MN0AROWE char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// change level flags
DataItem MN0AROWF char(10)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// delete flag
DataItem MN0AROWG char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dash
DataItem MN0AROWH char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// delete level flags
DataItem MN0AROWI char(10)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// inquiry flag
DataItem MN0AROWJ char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// dash
DataItem MN0AROWK char(3)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// inquiry level flags
DataItem MN0AROWL char(10)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// return code
DataItem MN0ARTN num(1)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

DataItem MN0AW-TA5DATA char(10)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// end browse indicator
DataItem MN0AW1-END-BROWSE char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// map load indicatior
DataItem MN0AW1-LOAD-MAP char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// next application key
DataItem MN0AW1-NEXT-KEY char(400)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem MN0AW2FL char(81)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

DataItem MN0AW3-CPG num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

DataItem MN0AW3-FPG num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

DataItem MN0AW3-LPG num(4)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

DataItem MN0AW6FL char(81)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// mn0a044 read error flag
DataItem MN0AWEF2 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

