package mn0u;
import corpcom1.*;
import corpcom2.*;
import corpcom4.*;
import corpcom5.*;
import corpcom6.*;
import corpcom7.*;
import corpx1.*;
import corpx2.*;
import corpz3.*;
import in1.common.*;
import mn.common.*;
import ta.common.*;
import ts.common.*;
//*** PROGRAM=MN0U ****
// 
// 
// 
//                  MENU USER SECURITY SYSTEM
// 
// 
//          This application will maintain user and user
//     application records on the MENU file.
// 
//          The user and user application records are contained
//     within the same file.  The break down is as follows...
// 
//           MN1REC - application records.  These are all the
//                    valid applications that can be run.
//                    Associated with each application are
//                    flags to show what capabilities the
//                    application can have.  The capabilities
//                    are add, change, delete and inquiry.
// 
//           MN2REC - User records.  Each valid user will have
//                    a record.
// 
//           MN3REC - User application records.  These records
//                    contains all the appl that a user can
//                    access and what capabilities those user's
//                    have within the applications.
// 
// 
//      There are 5 functions to this application.
// 
//            Application menu.                Process mn0u008
//                                                     mn0u001
// 
//            Option 1 Add user records.       Process mn0u009
//                                                     mn0u002
//                                                     mn0u010
//                                                     mn0u011
//                                                     mn0u012
// 
//            Option 2 Change user records.    Process mn0u013
//                                                     mn0u003
//                                                     mn0u014
//                                                     mn0u015
//                                                     mn0u016
//                                                     mn0u017
// 
//            Option 3 Delete user records.    Process mn0u018
//                                                     mn0u019
//                                                     mn0u020
//                                                     mn0u021
//                                                     mn0u022
//                                                     mn0u050
//                                                     mn0u051
//                                                     mn0u023
//                                                     mn0u024
//                                                     mn0u025
// 
// 
// 
//            Option 4 user inquiry.           Process mn0u026
//                                                     mn0u027
//                                                     mn0u028
//                                                     mn0u041
//                                                     mn0u029
//                                                     mn0u042
//                                                     mn0u043
//                                                     mn0u030
//                                                     mn0u031
// 
//            Option 5 update user             Process mn0u032
//                     application records.            mn0u033
//                                                     mn0u034
//                                                     mn0u035
//                                                     mn0u036
//                                                     mn0u037
//                                                     mn0u038
//                                                     mn0u039
//                                                     mn0u040
// 
// 
// 
//  ***********************************************************
// 
// 
//    Created febuary 2,1985     DPB
// 
//    Maintenance log.
// 
//    Open item |   date  | int |         comments
//  ------------|---------|-----|------------------------------
//  DELETE USER |06/08/87 |JBW  |ADDED 50'S PROCESS GROUPS TO
//              |         |     |ALLOW DELETES OF NON-"&" APPL
//              |         |     |RECORDS WHEN DELETING USER REC
//  add commits |08-14-89 |jbw  |add commit logic to updates
//              |         |     |
//  chg usr key |09-05-89 |jbw  |change mn0u012 to make mn2rec
//              |         |     |key more unique
//  add commit  |09-07-89 |jbw  |add commit to ADD USER process
//              |         |     |key more unique
//  dwhit2 updt |07-31-90 |jbw  |allow dwhit2 to dlte &'s
//              |         |     |
//  flag setting|04-04-92 |jbw  |allow all flags to be set to N
//              |         |     |
//  initializing|01-27-92 |jbw  |init all w/s
//              |         |     |
//  USERID CHECK|12-09-92 |JWOOD|ADD MN5TBL, CHANGE MN0U019...
//              |         |     |
//  psdo-convers|02-28-93 |jcamp|make psdo conversational
//              |         |     |
//  error       |04-22-93 |jcamp|fix error in option 4 scroll
// ************************************************************
// *********************
Program MN0U type textUIProgram //VAGen Info - main text program
  {
  includeReferencedFunctions = yes, allowUnqualifiedItemReferences = yes, 
  throwNrfEofExceptions = yes, handleHardIOErrors = yes, V60ExceptionCompatibility = yes, 
  I4GLItemsNullable = no, textLiteralDefaultIsString = no, localSQLScope = yes, 
  inputRecord = COMMAREA, segmented = yes
  }

  // Data Declarations
  COMMAREA COMMAREA ; // record
  MN0UW1 MN0UW1; // record
  MN0UW2 MN0UW2; // record
  MN0UW3 MN0UW3; // record
  MN0UW4 MN0UW4; // record
  MN1REC MN1REC; // record
  MN2REC MN2REC { redefines = MN1REC } ; // record
  MN3REC MN3REC { redefines = MN1REC } ; // record

  // VAGen Info - items needed for migration
  VAGen_EZESYS char(8);
  VAGen_EZEREPLY num(1);
  VAGen_EZE_WAIT_TIME bin(9,2);
  VAGen_EZE_ITEMLEN int;

  // Use Declarations
  use MN5TBL; // table
  use XSYESNO {deleteAfterUse = yes}; // table
  use XDVTBL {deleteAfterUse = yes}; // table
  use XWHTBL {deleteAfterUse = yes}; // table
  use XSOTBL {deleteAfterUse = yes}; // table
  use XNDTBL {deleteAfterUse = yes}; // table
  use MN0UM.MN0UM001,  // forms
      MN0UM.MN0UM002, 
      MN0UM.MN0UM003, 
      MN0UM.MN0UM004, 
      MN0UM.MN0UM005, 
      MN0UM.MN0UM006, 
      MN0UM.MN0UM007, 
      MN0UM.MN0UM008, 
      MN0UM.MN0UM009
   {
    pfKeyEquate = no
  };

  function main()
    // VAGen Info - initialization needed for migration
    VAGen_EZESYS = VGLib.getVAGSysType();
    MN0U008: MN0U008();




     /* **** If a fast path was used to enter this application*/
          /* and something was entered in the item field then*/
          /* branch to the appropriote process.*/
          /* The common area item field is broken down into*/
          /* 2 parts.  One being the option selected and the other*/
          /* the user id separated by a space.*/


    MN0UIT = COMMAREA.CAITEM;

    if (MN0UW1.MN0UIT1 == "1"
     && COMMAREA.CAADDFL == "Y")
      COMMAREA.CAITEM = " ";
      goto MN0U009;
                                     /* branch to add process*/
    else
      if (MN0UW1.MN0UIT1 == "2"
       && COMMAREA.CACHGFL == "Y")
        COMMAREA.CAITEM = " ";
        goto MN0U013; /* branch to change process*/
      else
        if (MN0UW1.MN0UIT1 == "3"
         && COMMAREA.CADELFL == "Y")
          COMMAREA.CAITEM = " ";
          goto MN0U018; /* branch to delete process*/
        else
          if (MN0UW1.MN0UIT1 == "4"
           && COMMAREA.CAINQFL == "Y")
            COMMAREA.CAITEM = " ";
            goto MN0U026; /* branch to inquiry process*/
          else
            if (MN0UW1.MN0UIT1 == "5"
             && COMMAREA.CAADDFL == "Y"
             && COMMAREA.CACHGFL == "Y"
             && COMMAREA.CADELFL == "Y")
              COMMAREA.CAITEM = " ";
              goto MN0U032;
                                     /* branch to update process*/
            end
          end
        end
      end
    end

    goto MN0U001;




    MN0U001: MN0U001();




     /* **** if control was passed back to this process*/
          /* from the common statement groups which handel*/
          /* the special keys, then go back to the top of*/
          /* this process with the error message returned from*/
          /* the statement group.*/

    if (MN0UW1.MN0UFLG1 == "Y")
      goto MN0U001;
    end



     /* **** Check for invalid key entries.*/
          /* If anything was entered other than a*/
          /* function key branch back to the top*/

    if (converseVar.eventKey is enter)
    else
      MN0UM001.MNAMSG = "INVALID KEY ENTERED -- PLEASE RETRY";
      goto MN0U001;
    end

     /* **** Branch to the appropriote process*/

    if (MN0UM001.MNAPPOPT == 1)
      if (COMMAREA.CAADDFL == "Y")
        goto MN0U002;
      else
        MN0UM001.MNAMSG = "YOU DO NOT HAVE ADD CAPABILITIES";
        set MN0UM001 alarm;
        goto MN0U001;
      end
    end


    if (MN0UM001.MNAPPOPT == 2)
      if (COMMAREA.CACHGFL == "Y")
        goto MN0U013;
      else
        MN0UM001.MNAMSG = "YOU DO NOT HAVE CHANGE CAPABILITIES";
        set MN0UM001 alarm;
        goto MN0U001;
      end
    end


    if (MN0UM001.MNAPPOPT == 3)
      if (COMMAREA.CADELFL == "Y")
        goto MN0U018;
      else
        MN0UM001.MNAMSG = "YOU DO NOT HAVE DELETE CAPABILITIES";
        set MN0UM001 alarm;
        goto MN0U001;
      end
    end


    if (MN0UM001.MNAPPOPT == 4)
      if (COMMAREA.CAINQFL == "Y")
        goto MN0U026;
      else
        MN0UM001.MNAMSG = "YOU DO NOT HAVE INQUIRY CAPABILITIES";
        set MN0UM001 alarm;
        goto MN0U001;
      end
    end


    if (MN0UM001.MNAPPOPT == 5)
      if (COMMAREA.CAADDFL == "Y"
       && COMMAREA.CACHGFL == "Y"
       && COMMAREA.CADELFL == "Y")
        goto MN0U032;
      else
        MN0UM001.MNAMSG = "YOU DO NOT HAVE UPDATE CAPABILITIES";
        set MN0UM001 alarm;
        goto MN0U001;
      end
    end


     /* **** if a valid option was not entered then display an*/
          /* message.*/

    MN0UM001.MNAMSG = "PLEASE ENTER THE OPTION DESIRED";
    set MN0UM001 alarm;

    goto MN0U001;




    MN0U009: MN0U009();




    goto MN0U002;




    MN0U002: MN0U002();
     /* **** if control was passed back to this process*/
          /* from the common statement groups which handle*/
          /* the special keys then go back to the top of this*/
          /* process with the error message returned from the*/
          /* statement groups.*/

    if (MN0UW1.MN0UFLG1 == "Y")
      goto MN0U002;
    end


     /* **** If PF3 was pressed branch back to the*/
          /* application menu.*/

    if (converseVar.eventKey is pf3
     || converseVar.eventKey is pa2)
      set MN0UM002 initial;
      goto MN0U001;
    end


     /* **** if the key pressed was not the enter*/
          /* key, branch to the top of this process*/
          /* with an error message*/

    if (converseVar.eventKey is enter)
    else
      MN0UM002.VAGen_EZEMSG = "THAT KEY IS NOT SUPPORTED";
      goto MN0U002;
    end

    goto MN0U010;




    MN0U010: MN0U010();
     /* GET TEST.MN0U010*/
     /* GET MN0U.MN0U010*/


     /* **** If a screen field was not valid then*/
          /* branch back to the add user screen*/

    if (MN0UW1.MN0UFLG1 == "Y")
      set MN0UM002 alarm;
      goto MN0U002;
    end

    goto MN0U011;




    MN0U011: MN0U011();
     /* **** test the condition of the return code from*/
          /* the inquiry.  If the record already exists then*/
          /* branch back to the screen with an error message*/

    if (MN1REC is ioError)
      if (MN1REC is noRecordFound)
               /* next sentence*/
      else
        MN0UM002.MNAMSG = "AN ERROR HAS OCCURED READING THE ";
        MN0UM002.VAGen_EZEMSG = "MENU FILE ";
        set MN0UM002 alarm;
        goto MN0U002;
      end
    else
      MN0UM002.MNAMSG = "THE RECORD ALREADY EXISTS";
      set MN0UM002 alarm;
      goto MN0U002;
    end

    if (MN0UM002.MN0UMUSC > " ")
      goto MN0U212;
    else
      if (MN0UW1.MN0UCK1 == "&")
        goto MN0U211;
      else
        goto MN0U012;
      end
    end

    MN0U212: MN0U212();
          /* * * check for presence of user-to-copy. * **/
          /* test the condition of the return code from*/
          /* the inquiry.  If the record does not exist then*/
          /* branch back to the screen with an error message*/

    if (MN1REC is ioError)
      if (MN1REC is noRecordFound)
        MN0UM002.MNAMSG = "USER-TO-COPY DOES NOT EXIST";
        set MN0UM002.MN0UMUSC cursor;
        set MN0UM002 alarm;
        goto MN0U002;
      else
        MN0UM002.MNAMSG = "AN ERROR HAS OCCURED READING THE ";
        MN0UM002.VAGen_EZEMSG = "MENU FILE ";
        set MN0UM002 alarm;
        goto MN0U002;
      end
    else
      if (MN0UW1.MN0UCK1 == "&")
        goto MN0U211;
      else
        MN1REC.MN1KEY = " ";
        MN1REC.MN1TYPE1 = "3";
        MN1REC.MN1TYPE2 = "3";
        MN1REC.MN1USER = MN0UM002.MN0UMUSC;
        MN1REC.MN1APPL = " ";
        set MN1REC position;
        goto MN0U213;
      end
    end

    MN0U211: MN0U211();
     /* **** If the record exists then send an error message*/
          /* back to the converse to get another application.*/


    if (MN1REC is ioError)
      if (MN1REC is noRecordFound)
              /* next sentence*/
      else
        MN0UM002.MNAMSG = "AN ERROR HAS OCCURED READING THE";
        MN0UM002.VAGen_EZEMSG = "APPLICATION RECORD";
        set MN0UM002 alarm;
        set MN0UM002.MN1USER cursor, bold;
        goto MN0U002;
      end
    else
      MN0UM002.MNAMSG = "THE APPLICATION ALREADY EXISTS";
      set MN0UM002 alarm;
      set MN0UM002.MN1USER cursor, bold;
      move MN1REC to MN0UM002 byName;
      goto MN0U002;
    end


    if (MN0UM002.MN0UMUSC > " ")
      MN1REC.MN1KEY = " ";
      MN1REC.MN1TYPE1 = "3";
      MN1REC.MN1TYPE2 = "3";
      MN1REC.MN1USER = MN0UM002.MN0UMUSC;
      MN1REC.MN1APPL = " ";
      set MN1REC position;
      goto MN0U213;
    else
      goto MN0U012;
    end

    MN0U213: MN0U213();
    if (MN1REC is noRecordFound)
      goto MN0U012;
    else
      if (MN1REC is ioError)
        MN0UM002.MNAMSG = "ERROR OCCURED READING MENU FILE";
        goto MN0U002;
      else
        if (MN1REC.MN1USER == MN0UM002.MN0UMUSC)
          MN0UW1.MN0USVKY = MN1REC.MN1KEY;
          MN1REC.MN1USER = MN0UM002.MN1USER;
          goto MN0U216;
        else
          goto MN0U012;
        end
      end
    end
    MN0U216: MN0U216();

    if (MN1REC is ioError)
      MN0UM002.MNAMSG = "ERROR ADDING MENU RECORD";
      set MN0UM002 alarm;
      goto MN0U002;
    else
      MN1REC.MN1KEY = MN0UW1.MN0USVKY;
      goto MN0U217;
    end
    MN0U217: MN0U217();

    if (MN1REC is ioError)
      MN0UM002.MNAMSG = "ERROR COPYING PROFILE";
      set MN0UM002 alarm;
      goto MN0U002;
    else
      goto MN0U213;
    end
    MN0U012: MN0U012();
     /* **** Test the return code from the add process.*/
          /* if the return code is an error send an*/
          /* error message back to the screen*/

    if (MN1REC is ioError)
      MN0UM002.MNAMSG = "CANNOT ADD RECORD";
      set MN0UM002 alarm;
      goto MN0U002;
    else
      if (MN0UW1.MN0UCK1 == "&")
        goto MN0U215;
      else
        set MN0UM002 initial;
        MN0UM002.MNAMSG = "RECORD HAS BEEN ADDED";
        goto MN0U002;
      end
    end

    MN0U215: MN0U215();
     /* **** If the return code from the add process is not good*/
          /* send back an error message.*/

    if (MN1REC is ioError)
      MN0UM002.MNAMSG = "AN ERROR OCCURED ADDING THE APPLICATION";
      set MN0UM002 alarm;
      set MN0UM002.MN1USER cursor, bold;
      goto MN0U002;
    else
      MN0UM002.MNAMSG = "RECORDS HAVE BEEN ADDED";
      goto MN0U002;
    end

    MN0U013: MN0U013();
     /* **** If a fast path was done to enter this option and*/
          /* a user id was specified in the commarea item field*/
          /* then branch around the converse process to accept*/
          /* a user id and use the user id passed.  The commarea*/
          /* item field was move to a working storage item*/
          /* previously.*/

    if (MN0UW1.MN0UIT3 != " ")
      MN0UM003.MN1USER = MN0UW1.MN0UIT3;
      MN0UW1.MN0UIT = " ";
      goto MN0U014;
    end

    goto MN0U003;




    MN0U003: MN0U003();
     /* **** if control was passed back to this process*/
          /* from the common satement groups which handle*/
          /* the special keys and fast path then go back to the*/
          /* top of this process with the error message returned*/
          /* from the statement groups.*/

    if (MN0UW1.MN0UFLG1 == "Y")
      set MN0UM003 alarm;
      goto MN0U003;
    end

     /* **** if PF3 was presseed branch back to the*/
          /* application menu.*/

    if (converseVar.eventKey is pf3)
      goto MN0U001;
    end

     /* **** if the key pressed was not the enter key*/
          /* branch back to the top of this process*/
          /* with an error message*/

    if (converseVar.eventKey is enter)
    else
      MN0UM003.MNAMSG = "THAT KEY IS NOT SUPPORTED";
      set MN0UM003 alarm;
      goto MN0U003;
    end

    goto MN0U014;

    MN0U014: MN0U014();
     /* **** if the return code from the update process*/
          /* is an error then branch back to the converse*/
          /* process with an error message so an new user*/
          /* id can be entered.*/

    if (MN1REC is deadLock)
      MN0UM003.MNAMSG = "THE USER RECORD IS LOCKED";
      set MN0UM003.MN1USER cursor, bold;
      set MN0UM003 alarm;
      goto MN0U003;
    else
      if (MN1REC is ioError)
        MN0UW1.MN0UUSR = MN0UM003.MN1USER;
        set MN0UM003 initial;
        MN0UM003.MN1USER = MN0UW1.MN0UUSR;
        MN0UM003.MNAMSG = "USER RECORD NOT ON FILE";
        set MN0UM003.MN1USER cursor, bold;
        set MN0UM003 alarm;
        goto MN0U003;
      end
    end

     /* **** Move the user record to the screen.*/

    MN0UW4.MN1REC-GRP = MN2REC.MN1REC-GRP;
    move MN2REC to MN0UM003 byName;

    goto MN0U015;

    MN0U015: MN0U015();
     /* **** if control was passed back to this process*/
          /* from the common statement groups which handle*/
          /* the special keys and fast path then go back to the*/
          /* top of this process with the error message returned*/
          /* from the statement groups.*/

    if (MN0UW1.MN0UFLG1 == "Y")
      set MN0UM003 alarm;
      goto MN0U003;
    end

     /* **** if the PA2 key was pressed then abort the change.*/

    if (converseVar.eventKey is pa2)
      set MN0UM003 initial;
      MN0UM003.MNAMSG = "CHANGE ABORTED";
      set MN0UM003 alarm;
      goto MN0U003;
    end

     /* **** if pf3 was pressed branch back to the application menu*/

    if (converseVar.eventKey is pf3)
      goto MN0U001;
    end

     /* **** Check for an invalid key being entered.  This is*/
          /* any key that is not the ENTER,PF1,PF4 or PA2.*/

    if (converseVar.eventKey is enter)
    else
      MN0UM003.MNAMSG = "THAT KEY IS NOT SUPPORTED";
      set MN0UM003 alarm;
      goto MN0U015;
    end

     /* **** if the user id field was changed then assume that*/
          /* the user wants to change a different user record*/
          /* so branch back to the first converse of the screen.*/

    if (MN0UM003.MN1USER is modified)
      goto MN0U014;
    end

    goto MN0U016;

    MN0U016: MN0U016();
     /* **** if a screen field was not valid then branch*/
          /* back to the mn0u015 screen*/

    if (MN0UW1.MN0UFLG1 == "Y")
      set MN0UM002 alarm;
      goto MN0U015;
    end

    goto MN0U016-UPDATE;

    MN0U016-UPDATE: MN0U016-UPDATE();

    if (MN1REC is deadLock)
      MN0UM003.VAGen_EZEMSG = "*** THE USER RECORD IS LOCKED - TRY LATER *** ";
      set MN0UM003.MN1USER cursor, bold;
      set MN0UM003 alarm;
      goto MN0U003;
    else
      if (MN1REC is ioError)
        MN0UW1.MN0UUSR = MN0UM003.MN1USER;
        set MN0UM003 initial;
        MN0UM003.MN1USER = MN0UW1.MN0UUSR;
        MN0UM003.VAGen_EZEMSG = "*** VSAM ERROR - CALL TECH SUPPORT ***";
        set MN0UM003.MN1USER cursor, bold;
        set MN0UM003 alarm;
        goto MN0U003;
      else
        if (MN2REC.MN1REC-GRP != MN0UW4.MN1REC-GRP)
          MN0UW1.MN0UUSR = MN0UM003.MN1USER;
          set MN0UM003 initial;
          MN0UM003.MN1USER = MN0UW1.MN0UUSR;
          MN0UM003.VAGen_EZEMSG = "*** SOMEONE UPDATED THE RECORD BEFORE YOU - TRY AGAIN";
          set MN0UM003.MN1USER cursor, bold;
          set MN0UM003 alarm;
          goto MN0U003;
        end
      end
    end


    goto MN0U017;
    MN0U017: MN0U017();
     /* **** if the replace process returned with an error then*/
          /* branch back to the screen with an error message.*/

    if (MN1REC is ioError)
      set MN0UM003 initial;
      MN0UM003.MNAMSG = "CANNOT CHANGE THE RECORD";
      set MN0UM003 alarm;
      goto MN0U003;
    end

     /* **** return to the top of the change function*/

    set MN0UM003 initial;
    MN0UM003.MNAMSG = "RECORD CHANGED";
    goto MN0U003;

    MN0U018: MN0U018();
     /* **** If a fast path was used to enter the menu system and*/
          /* an option was entered in the item field of the*/
          /* commarea record check to see of a user id was also*/
          /* entered.  If so branch to the inquiry screen to get*/
          /* user entered.*/

    if (MN0UW1.MN0UIT != " "
     && MN0UW1.MN0UIT3 != " ")
      MN0UM004.MN1USER = MN0UW1.MN0UIT3;
      MN0UW1.MN0UIT = " ";
      goto MN0U020;
    end

    goto MN0U019;

    MN0U019: MN0U019();




     /* **** if control was passed back to this process*/
          /* from the common statement groups which handLE*/
          /* the special kEYs then go back to the top of this*/
          /* process with the error message returned from the*/
          /* statement groups.*/

    if (MN0UW1.MN0UFLG1 == "Y")
      MN0UW1.MN0UFLG1 = " ";
      goto MN0U019;
    end


     /* **** if the PF3 key was pressed then transfer*/
          /* control to the application menu.*/

    if (converseVar.eventKey is pf3)
      set MN0UM001 initial;
      goto MN0U001;
    end

    if (converseVar.eventKey is pa2)
      set MN0UM001 initial;
      goto MN0U001;
    end


     /* **** if an invalid key was pressed go back to*/
          /* the top of this process.*/

    if (converseVar.eventKey is enter)
     /* next sentence*/
    else
      MN0UM004.VAGen_EZEMSG = "THAT KEY IS NOT SUPPORTED";
      goto MN0U019;
    end

    goto MN0U020;




    MN0U020: MN0U020();




     /* **** if the record could not be read then*/
          /* branch back to the converse of the*/
          /* screen.*/

    if (MN1REC is ioError)
      if (MN1REC is noRecordFound
       && MN0UW1.MN0UWPF6 == "Y")
        /* NEXT SENTENCE*/
      else
        MN0UW1.MN0UUSR = MN0UM004.MN1USER;
        set MN0UM004 initial;
        MN0UM004.MN1USER = MN0UW1.MN0UUSR;
        MN0UM004.MNAMSG = "THE USER IS NOT ON FILE";
        MN0UM004.VAGen_EZEMSG = "PRESS PF6 TO DELETE USER-APPL RECS IF ANY";
        set MN0UM004.MN1USER cursor, bold;
        set MN0UM004 alarm;
        goto MN0U019;
      end
    end

    goto MN0U021;




    MN0U021: MN0U021();




    goto MN0U022;




    MN0U022: MN0U022();
     /* *************************************************************/
        /* - GET UP TO 25 TYPE-3 USER APPL RECORDS FOR USER-ID*/
        /* - SAVE ALL KEYS READ INTO MN0UW1 AREA*/
        /* - WHEN DONE, GO DELETE THE USER APPL RECORDS (IF ANY)*/
     /* *************************************************************/

    if (MN1REC is ioError)
      if (MN1REC is noRecordFound) /* NO RECORD FOUND*/
        MN1REC.MN1KEY = " ";
      else
        if (MN1REC is endOfFile)
          /* next sentence*/
        else
          MN0UM004.MNAMSG = "AN ERROR OCCURRED READING THE USER-APPL ";
          MN0UM004.VAGen_EZEMSG = "RECORDS";
          set MN0UM004 alarm;
          goto MN0U019;
        end
      end
    end

    if (MN0UW1.MN0UWKIX <= 100)
      if (MN1REC is endOfFile)
         /* next sentence*/
      else
        if (MN1REC.MN1USER == MN0UM004.MN1USER
         && MN1REC.MN1TYPE1 == "3")
          MN0UW1.MN0UWKEY[MN0UWKIX] = MN1REC.MN1KEY;
          MN0UW1.MN1REC-GRP[MN0UWKIX] = MN1REC.MN1REC-GRP;
          MN0UW1.MN0UWKIX = MN0UW1.MN0UWKIX + 1;
          goto MN0U022;
        end
      end
    else
      MN0UM004.VAGen_EZEMSG = "TOO MANY APPL RECORDS - CONTACT TECH SUPPORT";
      set MN0UM004 alarm;
      goto MN0U019;
    end

    goto MN0U024;

    MN0U024: MN0U024();




     /* **** if the PA2 key was pressed then abort the delete*/

    if (converseVar.eventKey is pa2)
      MN0UW1.MN0UWDLF = "A";
      goto MN0U018;
    end


     /* **** If the user id was changed then branch back to the*/
          /* inquiry process the get the new user record to delete*/

    if (converseVar.eventKey is enter
     && MN0UM004.MN1USER != MN0UW1.MN0UUSR)
      goto MN0U020;
    end


     /* **** if an invalid key was entered branch back to*/
          /* the beginning of the process*/

    if (converseVar.eventKey is enter)
    else
      MN0UM004.VAGen_EZEMSG = "THAT KEY IS NOT SUPPORTED";
      goto MN0U024;
    end


    if (MN0UW1.MN0UWF25 == "Y")
      goto MN0U018;
    else
      goto MN0U025-DEL-RECS;
    end




    MN0U025-DEL-RECS: MN0U025-DEL-RECS();

    if (MN0UM004.VAGen_EZEMSG == " ")
      goto MN0U018;
    else
      goto MN0U019;
    end
    MN0U026: MN0U026();




    goto MN0U027;




    MN0U027: MN0U027();




     /* **** Branch back to get another record if the screen is not*/
          /* filled or the end of the user records has not been*/
          /* reached.*/

    if (MN1REC is ioError)
    else
      if (MN0UW1.MN0UCTR < 14
       && MN2REC.MN1TYPE1 == "2")
        goto MN0U027;
      end
    end

    goto MN0U028;




    MN0U028: MN0U028();




     /* **** The mn0uflg1 flag is used to branch back to the*/
          /* top of this process.*/

    if (MN0UW1.MN0UFLG1 == "Y")
      goto MN0U028;
    end


     /* **** If the PF3 key was pressed then branch back*/
          /* to the appliation menu.*/

    if (converseVar.eventKey is pf3)
      set MN0UM005 initial;
      goto MN0U001;
    end


     /* **** The mn0uflg2 flag is used to branch back to the*/
          /* scan process.*/

    if (MN0UW1.MN0UFLG2 == "Y")
      goto MN0U027;
    end


     /* **** check for an invalid key being pressed.*/

          /* The mn0uflg3 flag is used to show that a user was*/
          /* selected to inquiry on.  If this flag is set then*/
          /* fall through to the next process*/

    if (converseVar.eventKey is enter
     && MN0UW1.MN0UFLG3 == "Y")
    else
      MN0UM005.MNAMSG = "THAT KEY IS NOT SUPPORTED";
      set MN0UM005 alarm;
      goto MN0U028;
    end


     /* **** save the user id.  This will be used to conrol*/
          /* the reading of the user application records*/

    MN0UW1.MN0ULUSR = MN2REC.MN1USER;
    MN0UW1.MN0UKY3 = 0;
    MN0UW1.MN0UCTR = 0;


     /* **** Set the pointer in the file to point at the first*/
          /* user application record for the user selected.*/

    MN3REC.MN1KEY = " ";
    MN3REC.MN1TYPE1 = "3";
    MN3REC.MN1USER = MN0UM005.MNAUSER[MN0UIDX];
    MN0UW1.MN0UUSR = MN0UM005.MNAUSER[MN0UIDX];
    MN3REC.MN1TYPE2 = "3";

    set MN1REC position;


    converseLib.clearScreen();
    
    goto MN0U041;




    MN0U041: MN0U041();



     /* mn0u029*/



    MN0U029: MN0U029();




     /* **** if the end of the records for the user selected*/
          /* has been reached then go to the converse to*/
          /* display the records.*/

    if (MN0UW1.MN0UFLG1 == "Y")
      goto MN0U031;
    end


    goto MN0U042;




    MN0U042: MN0U042();




    goto MN0U043;




    MN0U043: MN0U043();




    goto MN0U030;




    MN0U030: MN0U030();




      /* **** The mn0uflg1 flag is used to control flow to the*/
           /* top of the converse process.*/

    if (MN0UW1.MN0UFLG1 == "Y")
      goto MN0U031;
    end



     /* **** The screen can hold 6 user application records.*/
          /* If the screen is full then converse the screen*/
          /* otherwise get another record.*/

    if (MN0UW1.MN0UCTR != 7)
      goto MN0U029;
    end

    goto MN0U031;




    MN0U031: MN0U031();




     /* **** Go back to the first converse if the PF3 or PA2 keys*/
          /* were pressed.*/

    if (converseVar.eventKey is pf3
     || converseVar.eventKey is pa2)
      converseLib.clearScreen();
      
      goto MN0U028;
    end


     /* **** The mn0uflg1 flag is used to pass control to the*/
          /* top of this process.*/


    if (MN0UW1.MN0UFLG1 == "Y")
      goto MN0U031;
    end


     /* **** The mn0uflg2 flag is used to pass control to the*/
          /* top of the scan process*/


    if (MN0UW1.MN0UFLG2 == "Y")
      converseLib.clearScreen();
      
      goto MN0U041;
    end


     /* **** Branch back to first screen if the PF3 or PA2*/
          /* keys were pressed.*/


    if (converseVar.eventKey is pf3
     || converseVar.eventKey is pa2)
      converseLib.clearScreen();
      
      goto MN0U028;
    end


     /* **** If an invalid key was entered display an error*/
          /* message an ask for valid input.*/

    if (converseVar.eventKey is enter
     || converseVar.eventKey is pf8
     || converseVar.eventKey is pf7)
    else
      MN0UM009.MNAMSG = "THAT KEY IS NOT SUPPORTED";
      set MN0UM009 alarm;
      goto MN0U031;
    end


    goto MN0U031;




    MN0U032: MN0U032();




     /* **** If a fast was done to enter this option and something*/
          /* was entered in the item field then move this item to*/
          /* the user id and branch to the inquriy otherwise get*/
          /* the user id from the screen.*/

    if (MN0UW1.MN0UIT3 != " ")
      MN0UM007.MN1USER = MN0UW1.MN0UIT3;
      MN0UW1.MN0UIT = " ";
    end

    goto MN0U033;



    MN0U033: MN0U033();




     /* **** If the PF3 key was pressed then branch back to*/
          /* the application menu.*/

    if (converseVar.eventKey is pf3
     || converseVar.eventKey is pa2)
      goto MN0U001;
    end


     /* **** If the flag returned from the statement groups in the*/
          /* after stag is set to a Y then an error occured so*/
          /* go back to the beginning of this process.*/

    if (MN0UW1.MN0UFLG1 == "Y")
      goto MN0U033;
    end

    goto MN0U034;




    MN0U034: MN0U034();




     /* **** If the return code from the inquiry is not good*/
          /* the branch back and get another user.*/


    if (MN1REC is deadLock)
      MN0UM007.MNAMSG = "USER RECORD LOCKED BY ANOTHER USER";
      set MN0UM007.MN1USER cursor, bold;
      set MN0UM007 alarm;
      goto MN0U033;
    end


    if (MN1REC is ioError)
      MN0UM007.MNAMSG = "USER RECORD NOT FOUND";
      set MN0UM007.MN1USER cursor, bold;
      set MN0UM007 alarm;
      goto MN0U033;
    end


     /* **** move the user name to the screen.*/

    MN0UM007.MN2USRNM = MN2REC.MN2USRNM;

    goto MN0U035;




    MN0U035: MN0U035();
    if (MN0UM007.MN1APPL < "A   ")
      goto MN0U036;
    end

     /* **** if the application record is not found then*/
          /* go back to the converse with an error message.*/
          /* The application record must exist in order to*/
          /* add, change or delete a user application record.*/

    if (MN1REC is ioError)
      MN0UM007.MNAMSG = "THE APPLICATION RECORD IS NOT FOUND";
      set MN0UM007.MN1APPL cursor, bold;
      set MN0UM007 alarm;
      goto MN0U033;
    end

    goto MN0U036;




    MN0U036: MN0U036();




     /* **** If there was a problem with the record update and*/
          /* the option selected then branch back to the converse*/
          /* to have the problem resolved.*/

    if (MN0UW1.MN0UFLG1 == "Y")
      goto MN0U033;
    end

    goto MN0U037;




    MN0U037: MN0U037();




     /* **** Branch back to the application menu if PF3 key*/
          /* was pressed.*/

    if (converseVar.eventKey is pf3)
      goto MN0U001;
    end


     /* **** abort the option if the PA2 key is pressed.*/

    if (converseVar.eventKey is pa2)
      MN0UM007.MNAMSG = "OPTION HAS BEEN ABORTED";
      goto MN0U033;
    end


     /* **** if an error was returned from the statement groups*/
          /* in the after section then branch the appropriote*/
          /* process.  If the user id was changed then branch*/
          /* to the process to get the user record.  If the*/
          /* application was changed then get a new application*/
          /* record.*/

    if (MN0UW1.MN0UFLG1 == "Y")
      goto MN0U037;
    end

    if (MN0UW1.MN0UFLG2 == "Y")
      goto MN0U034;
    end

    if (MN0UW1.MN0UFLG3 == "Y")
      goto MN0U035;
    end


     /* **** Check for an invalid key being pressed.*/

    if (converseVar.eventKey is enter)
    else
      MN0UM007.VAGen_EZEMSG = "MN0U037 - THAT KEY IS NOT SUPPORTED";
      set MN0UM007 alarm;
      goto MN0U037;
    end


     /* **** Branch to the appropriate process.*/
    move MN0UM007 to MN3REC byName;

    if (MN0UM007.MNAOPTN == "A")
      goto MN0U038;
    else
      if (MN0UM007.MNAOPTN == "C")
        goto MN0U039-UPDATE;
      else
        if (MN0UM007.MNAOPTN == "D")
          goto MN0U040-UPDATE;
        else
          goto MN0U033;
        end
      end
    end




    MN0U038: MN0U038();




     /* **** Branch back to the beginning of the update function.*/

    goto MN0U033;




    MN0U039-UPDATE: MN0U039-UPDATE();

    if (MN0UW1.MN0UFLG1 == "Y")
      goto MN0U033;
    end

    move MN0UM007 to MN3REC byName;
    MN3REC.MN1KEY = " ";
    MN3REC.MN1TYPE1 = "3";
    MN3REC.MN1TYPE2 = "3";
    MN3REC.MN1USER = MN0UM007.MN1USER;
    MN3REC.MN1APPL = MN0UM007.MN1APPL;
    goto MN0U039-REPLACE;

    MN0U039-REPLACE: MN0U039-REPLACE();




     /* **** Branch back to the beginning of the update function.*/

    goto MN0U033;




    MN0U040-UPDATE: MN0U040-UPDATE();

    if (MN0UW1.MN0UFLG1 == "Y")
      goto MN0U033;
    end

    goto MN0U040-DELETE;

    MN0U040-DELETE: MN0U040-DELETE();




     /* **** Branch back to the beginning of the update funciton.*/

    goto MN0U033;




  end // end main
end // end MN0U

// user maintenance menu screen
Function MN0U001()




        /* ************************************************/
        /* *                                             **/
        /* *    This process converses the security menu **/
        /* *  application screen.                        **/
        /* *                                             **/
        /* ************************************************/


   /* **** initialize the screen variables*/

  MN0UM001.MN0UMDT = VGVar.currentShortGregorianDate;
  MN0UM001.MNANAME = "MN0U001";
  converseLib.clearScreen();
  
  MN0UM001.CATOAP = " ";
  MN0UM001.CAITEM = " ";

  MN0UW1.MN0UFLG1 = "N";




  converse MN0UM001 ;





  MN0UM001.MNAMSG = " ";


   /* ****  transfer control the the appropriote application*/
         /* if the keys PF1, pf4 and pa2 were pressed.*/

  if (converseVar.eventKey is pf1)
    XSPF1();
    MN0UW1.MN0UFLG1 = "Y";
    MN0UM001.MNAMSG = COMMAREA.CAMSG;
  else
    if (converseVar.eventKey is pf4)
      XSPF4();
      MN0UW1.MN0UFLG1 = "Y";
      MN0UM001.MNAMSG = COMMAREA.CAMSG;
    else
      if (converseVar.eventKey is pa2)
        XSPF4();
        MN0UW1.MN0UFLG1 = "Y";
        MN0UM001.MNAMSG = COMMAREA.CAMSG;
      end
    end
  end


   /* **** Return to the main menu if the pf3 key*/
        /* was pressed.*/

  if (converseVar.eventKey is pf3)
    COMMAREA.CATOAP = "MN0N";
    XSEXIT();
    MN0UW1.MN0UFLG1 = "Y";
    MN0UM001.MNAMSG = COMMAREA.CAMSG;
  end



   /* **** If anything is entered in the option field*/
        /* then transfer control to that application*/

  if (MN0UM001.CATOAP != " "
   && converseVar.eventKey is enter)
    move MN0UM001 to COMMAREA byName;
    XSEXIT();
    MN0UW1.MN0UFLG1 = "Y";
    MN0UM001.MNAMSG = COMMAREA.CAMSG;
  end




end // end MN0U001

// add users
Function MN0U002()




         /* ****************************************************/
         /* *                                                 **/
         /* *    This process will accept user id's to be     **/
         /* *  added to the menu file.                        **/
         /* *                                                 **/
         /* ****************************************************/


   /* **** put the process name and date to the screen*/

  MN0UM002.MNANAME = "MN0U002";
  MN0UM002.MN0UMDT = VGVar.currentShortGregorianDate;

  MN0UW1.MN0UFLG1 = "N";




  converse MN0UM002 ;

   /* **** Set the attributes of the fields back*/
        /* to normal.  This will clear any error*/
        /* attributes in case they were set previously*/

  set MN0UM002.MN1USER initialAttributes;
  set MN0UM002.MN1USER cursor;
  set MN0UM002.MN2USRNM initialAttributes;
  set MN0UM002.MN2STAT initialAttributes;
  set MN0UM002.XNDCD initialAttributes;
  set MN0UM002.XWHCD initialAttributes;
  set MN0UM002.XDVCD initialAttributes;
  set MN0UM002.XSOCD initialAttributes;


   /* **** check the keys pf1, pf4 and pa2.*/
        /* if these keys were entered call the common*/
        /* statement group to process them*/

  if (converseVar.eventKey is pf1)
    XSPF1();
    MN0UM002.MNAMSG = COMMAREA.CAMSG;
    MN0UW1.MN0UFLG1 = "Y";
  else
    if (converseVar.eventKey is pf4)
      XSPF4();
      MN0UM002.MNAMSG = COMMAREA.CAMSG;
      MN0UW1.MN0UFLG1 = "Y";
    end
  end


   /* **** Check the fast path.  If anything is*/
        /* in this field and the enter key was*/
        /* pressed the transfer control the the*/
        /* application requested.*/

  if (converseVar.eventKey is enter
   && MN0UM002.CATOAP != " ")
    move MN0UM002 to COMMAREA byName;
    XSEXIT();
    MN0UM002.MNAMSG = COMMAREA.CAMSG;
    MN0UW1.MN0UFLG1 = "Y";
  end




end // end MN0U002

// change users
Function MN0U003()
         /* ****************************************************/
         /* *                                                 **/
         /* *    This process will allow user records to be   **/
         /* *  changed on the menu file.                      **/
         /* *                                                 **/
         /* ****************************************************/

   /* **** get the date and process name to be displayed*/
        /* on the screen.*/

  MN0UM003.MNANAME = "MN0U003";
  MN0UM003.MN0UMDT = VGVar.currentShortGregorianDate;

  set MN0UM003.MN2USRNM protect;
  set MN0UM003.MN2STAT protect;
  set MN0UM003.XNDCD protect;
  set MN0UM003.XWHCD protect;
  set MN0UM003.XDVCD protect;
  set MN0UM003.XSOCD protect;

  MN0UW1.MN0UFLG1 = "N";

  converse MN0UM003 ;

   /* **** clear the message fields so no message is leftover.*/

  MN0UM003.MNAMSG = " ";
  MN0UM003.VAGen_EZEMSG = " ";
  set MN0UM003.CATOAP initialAttributes;
  set MN0UM003.MN1USER initialAttributes;
  set MN0UM003.MN2USRNM initialAttributes;
  set MN0UM003.MN2STAT initialAttributes;
  set MN0UM003.XNDCD initialAttributes;
  set MN0UM003.XWHCD initialAttributes;
  set MN0UM003.XDVCD initialAttributes;
  set MN0UM003.XSOCD initialAttributes;

   /* **** check the keys pf1, pf4 and pa2.*/
        /* if these keys were entered call the*/
        /* common statement group to process them.*/

  if (converseVar.eventKey is pf1)
    XSPF1();
    MN0UM003.MNAMSG = COMMAREA.CAMSG;
    MN0UW1.MN0UFLG1 = "Y";
  else
    if (converseVar.eventKey is pf4)
      XSPF4();
      MN0UM003.MNAMSG = COMMAREA.CAMSG;
      MN0UW1.MN0UFLG1 = "Y";
    else
      if (converseVar.eventKey is pa2)
        COMMAREA.CATOAP = "MN0M";
        XSEXIT();
        MN0UM003.MNAMSG = COMMAREA.CAMSG;
        MN0UW1.MN0UFLG1 = "Y";
      end
    end
  end

   /* **** check the fast path.  If anything is in this*/
        /* field and the enter key was pressed then*/
        /* transfer control to the application requested.*/

  if (converseVar.eventKey is enter
   && MN0UM003.CATOAP != " ")
    move MN0UM003 to COMMAREA byName;
    XSEXIT();
    MN0UM003.MNAMSG = COMMAREA.CAMSG;
    MN0UW1.MN0UFLG1 = "Y";
  end

   /* **** check for &*/

  MN0UW1.MN0UCK = MN0UM003.MN1USER;
  if (MN0UW1.MN0UCK1 == "&")
    MN0UM003.MNAMSG = "---- FAST-PATH TO MN0P TO CHNG PROFILES ----";
    MN0UM003.CATOAP = "MN0P";
    MN0UW1.MN0UFLG1 = "Y";
  end

end // end MN0U003

// first time thru logic (FTTL)
Function MN0U008()




        /* ***************************************************/
        /* *                                                **/
        /* *    This is the entry process for the menu      **/
        /* *  security system.                              **/
        /* *                                                **/
        /* ***************************************************/


   /* **** perform the entry statement group.  The function*/
        /* of the statement group is to not allow entry into*/
        /* this application unless the proper logon procedure*/
        /* has been done.*/

  XSENTRY();

  XSSEGTR();
   /* MOVE 'CSP' TO COMMAREA.CASYSINT;*/
   /* MOVE 'MTHOMP' TO COMMAREA.CAUSERID;*/


  set MN0UW1 empty;
  set MN0UW2 empty;
  set MN2REC empty;
  set MN3REC empty;
  converseLib.clearScreen();
  set MN0UM001 initial;
  converseLib.clearScreen();
  set MN0UM002 initial;
  converseLib.clearScreen();
  set MN0UM003 initial;
  converseLib.clearScreen();
  set MN0UM004 initial;
  converseLib.clearScreen();
  set MN0UM005 initial;
  converseLib.clearScreen();
  set MN0UM006 initial;
  converseLib.clearScreen();
  set MN0UM007 initial;
  converseLib.clearScreen();
  set MN0UM008 initial;
  converseLib.clearScreen();
  set MN0UM009 initial;


end // end MN0U008

// FTTL for add process
Function MN0U009()





        /* ************************************************/
        /* *                                             **/
        /* *    This is the first time thru logic for the**/
        /* *  add process.  As you can see there isn't   **/
        /* *  anything to be done.  But if there was then**/
        /* *  this is the place to do it.                **/
        /* *                                             **/
        /* ************************************************/



end // end MN0U009

// validate screen fields
Function MN0U010()
        /* ***************************************************/
        /* *                                                **/
        /* *    Validate the fields that were entered.      **/
        /* *  The user id must be entered and must start    **/
        /* *  with an alpha character.                      **/
        /* *                                                **/
        /* * * * * * * * * * * * * * * * * * * * * * * * *  **/
        /* * *     note: userid may start with '&'       *  **/
        /* * *           for group processing.           *  **/
        /* * *                                 pmt 9/86  *  **/
        /* * * * * * * * * * * * * * * * * * * * * * * * *  **/
        /* **/
        /* mn0us1a validates the user-id                    **/
        /* mn0us1b validates the user name                  **/
        /* mn0us1c validates the statsus                    **/
        /* mn0us1d validates the dept code                  **/
        /* mn0us1e validates the warehouse code             **/
        /* mn0us1f validates the division code              **/
        /* mn0us1g validates the sales office               **/
        /* ***************************************************/


  MN0UW1.MN0UFLG1 = "N";

  if (MN0UM002.XSOCD != "  ") /* blanks are acceptable as input*/
    MN0US1G();
  end

  if (MN0UM002.XDVCD != "  ") /* blanks are acceptable as input*/
    MN0US1F();
  end

  if (MN0UM002.XWHCD != "  ") /* blanks are acceptable as input*/
    MN0US1E();
  end

  if (MN0UM002.XNDCD != "    ") /* blanks are acceptable as input*/
    MN0US1D();
  end

  MN0US1C();

  MN0US1B();

  MN0US1A();




end // end MN0U010

// reads user from user appl file
Function MN0U011()
        /* ************************************************/
        /* *                                             **/
        /* *    This process gets the user record from   **/
        /* *  MENU FILE.                                 **/
        /* *                                             **/
        /* ************************************************/


  MN2REC.MN1KEY = " ";
  MN2REC.MN1TYPE1 = "2";
  MN2REC.MN1TYPE2 = "2";
  move MN0UM002 to MN2REC withV60Compat;
  MN2REC.MN1APPL = MN2REC.MN1USER;

  try
    get MN1REC ;
  end

end // end MN0U011

// adds users to menu file
Function MN0U012()
        /* ************************************************/
        /* *                                             **/
        /* *    This process addes the user record to the**/
        /* *  MENU FILE.                                 **/
        /* *                                             **/
        /* ************************************************/


  MN2REC.MN1KEY = " ";
  MN2REC.MN1TYPE1 = "2";
  MN2REC.MN1TYPE2 = "2";
  move MN0UM002 to MN2REC withV60Compat;
  MN2REC.MN1APPL = MN2REC.MN1USER;

  try
    add MN1REC ;
  end
  if (MN1REC is ioError)
    /* next sentence*/
  else
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.commit();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
    
  end

end // end MN0U012

// FTTL for change process
Function MN0U013()
        /* ************************************************/
        /* **/
        /* This is the first time thru logic for the   **/
        /* change fuction of the menu security system. **/
        /* **/
        /* clear the screen fields and set the attributes**/
        /* back to their initial state.                  **/
        /* ************************************************/

  set MN0UM003 initial;

end // end MN0U013

// get the user record
Function MN0U014()
        /* ************************************************/
        /* *                                             **/
        /* *    get and save the user record to be       **/
        /* *  changed.                                   **/
        /* *                                             **/
        /* ************************************************/

   /* **** reset any record locks if they exist*/

  VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
  VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
  sysLib.rollback();
  VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value

  MN2REC.MN1KEY = " ";
  MN2REC.MN1TYPE1 = "2";
  MN2REC.MN1TYPE2 = "2";
  move MN0UM003 to MN2REC withV60Compat;
  MN2REC.MN1APPL = MN2REC.MN1USER;

  try
    get MN1REC ;
  end

end // end MN0U014

// display/get user record
Function MN0U015()
        /* ************************************************/
        /* *                                             **/
        /* *    Display and get the user record data to  **/
        /* *  be changed.                                **/
        /* *                                             **/
        /* ************************************************/

   /* **** move the process name to the screen field.*/

  MN0UM003.MNANAME = "MN0U015";

   /* **** move the status description to the screen.*/

  if (MN0UM003.MN2STAT == "A")
    MN0UM003.MNASTATD = "ACTIVE";
  else
    if (MN0UM003.MN2STAT == "I")
      MN0UM003.MNASTATD = "INACTIVE";
    else
      MN0UM003.MNASTATD = " ";
    end
  end

  MN0UW1.MN0UFLG1 = "N";

   /* **** get the warehouse, division and sales office*/
       /* descriptions*/

  if (MN2REC.XNDCD > " ")
    if (MN2REC.XNDCD in XNDTBL.XNDCD)
      MN0UM003.XNDDESC = XNDTBL.XNDDESC[sysVar.arrayIndex];
    end
    if (sysVar.arrayIndex == 0)
      MN0UM003.XNDDESC = "NO DESCRIPTION FOUND";
    end
  end

  if (MN2REC.XWHCD > " ")
    if (MN2REC.XWHCD in XWHTBL.XWHCD)
      MN0UM003.XWHNM = XWHTBL.XWHNM[sysVar.arrayIndex];
    end
    if (sysVar.arrayIndex == 0)
      MN0UM003.XWHNM = "NO DESCRIPTION FOUND";
    end
  end

  if (MN2REC.XDVCD > " ")
    if (MN2REC.XDVCD in XDVTBL.XDVCD)
      MN0UM003.XDVDESC = XDVTBL.XDVDESC[sysVar.arrayIndex];
    end
    if (sysVar.arrayIndex == 0)
      MN0UM003.XDVDESC = "NO DESCRIPTION FOUND";
    end
  end

  if (MN2REC.XDVCD > " ")
    if (MN2REC.XSOCD in XSOTBL.XSOCD)
      MN0UM003.XSONM = XSOTBL.XSONM[sysVar.arrayIndex];
    end
    if (sysVar.arrayIndex == 0)
      MN0UM003.XSONM = "NO DESCRIPTION FOUND";
    end
  end

  converse MN0UM003 ;

   /* **** Clear any leftover messages.*/
  MN0UM003.MNAMSG = " ";
  MN0UM003.VAGen_EZEMSG = " ";
  set MN0UM003.CATOAP initialAttributes;
  set MN0UM003.MN1USER initialAttributes;
  set MN0UM003.MN2USRNM initialAttributes;
  set MN0UM003.MN2STAT initialAttributes;
  set MN0UM003.XNDCD initialAttributes;
  set MN0UM003.XWHCD initialAttributes;
  set MN0UM003.XDVCD initialAttributes;
  set MN0UM003.XSOCD initialAttributes;

   /* **** check the keys pf1, pf4 and pa2.*/
        /* if these keys wer entered call the*/
        /* common statement group to process them.*/

  if (converseVar.eventKey is pf1)
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.rollback();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
    
    XSPF1();
    MN0UM003.MNAMSG = COMMAREA.CAMSG;
    MN0UW1.MN0UFLG1 = "Y";
  else
    if (converseVar.eventKey is pf4)
      VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
      VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
      sysLib.rollback();
      VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
      
      XSPF4();
      MN0UM003.MNAMSG = COMMAREA.CAMSG;
      MN0UW1.MN0UFLG1 = "Y";
    end
  end

  if (converseVar.eventKey is pf3
   || converseVar.eventKey is pa2)
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.rollback();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
    
  end

   /* **** check the fast path.  If anything is in this*/
        /* field and the enter key was pressed then*/
        /* transfer control to the application requested.*/

  if (converseVar.eventKey is enter
   && MN0UM003.CATOAP != " ")
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.rollback();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
    
    move MN0UM003 to COMMAREA byName;
    XSEXIT();
    MN0UM003.MNAMSG = COMMAREA.CAMSG;
    MN0UW1.MN0UFLG1 = "Y";
    set MN0UM003 initial;
    set MN0UM003.CATOAP cursor, bold;
    set MN0UM003 alarm;
  end

end // end MN0U015

// validate screen fields
Function MN0U016()
        /* ***************************************************/
        /* **/
        /* Validate the screen fields            **/
        /* **/
        /* mn0us2a validates the user name                  **/
        /* mn0us2b validates the statsus                    **/
        /* mn0us2c validates the nike department id         **/
        /* mn0us2d validates the warehouse code             **/
        /* mn0us2e validates the division code              **/
        /* mn0us2f validates the sales office               **/
        /* ***************************************************/

  MN0UW1.MN0UFLG1 = "N";

  if (MN0UM003.XSOCD is modified)
    MN0US2F();
  end

  if (MN0UM003.XDVCD is modified)
    MN0US2E();
  end

  if (MN0UM003.XWHCD is modified)
    MN0US2D();
  end

  MN0US2C();

  MN0US2B();

  MN0US2A();

end // end MN0U016

// get the user record
Function MN0U016-UPDATE()
        /* ************************************************/
        /* *                                             **/
        /* *    Get and lock the user record to be       **/
        /* *  changed.                                   **/
        /* *                                             **/
        /* ************************************************/

  VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
  VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
  sysLib.rollback();
  VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
   /* **** reset any record locks*/

  MN2REC.MN1KEY = " ";
  MN2REC.MN1TYPE1 = "2";
  MN2REC.MN1TYPE2 = "2";
  move MN0UM003 to MN2REC withV60Compat;
  MN2REC.MN1APPL = MN2REC.MN1USER;

  try
    get MN1REC forUpdate ;
  end
end // end MN0U016-UPDATE

// replace the user record mn3rec
Function MN0U017()
       /* *****************************************************/
       /* *                                                  **/
       /* *        Replace the user record                   **/
       /* *                                                  **/
       /* *****************************************************/

  MN2REC.MN1TYPE1 = "2";
  MN2REC.MN1TYPE2 = "2";
  move MN0UM003 to MN2REC withV60Compat;
  MN2REC.MN1APPL = MN2REC.MN1USER;

  try
    replace MN1REC ;
  end

  if (MN1REC is ioError)
    /* next sentence*/
  else
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.commit();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
    
  end

end // end MN0U017

// FTTL for delete process
Function MN0U018()
       /* *****************************************************/
       /* *                                                  **/
       /* *    This is the entry point for the delete        **/
       /* *  function.                                       **/
       /* *                                                  **/
       /* *****************************************************/

   /* **** This is the start of the delete function.  User*/
        /* records in the menu file can be deleted from this*/
        /* function,*/

  set MN0UM004 initial;
  move " " to MN0UW1.MN1REC-GRP[1] for 100;
  move " " to MN0UW1.MN0UWKEY[1] for 100;
  MN0UW1.MN0UWKIX = 0;


end // end MN0U018

// delete users
Function MN0U019()




       /* *****************************************************/
       /* *                                                  **/
       /* *   Get the user id to be deleted.                 **/
       /* *                                                  **/
       /* *****************************************************/




   /* **** set the screen variables*/

  MN0UM004.MNANAME = "MN0U019";
  MN0UM004.MN0UMDT = VGVar.currentShortGregorianDate;

  set MN0UM003.MN2USRNM protect;
  set MN0UM003.MN2STAT protect;
  set MN0UM003.XNDCD protect;
  set MN0UM003.XWHCD protect;
  set MN0UM003.XDVCD protect;
  set MN0UM003.XSOCD protect;


  MN0UW1.MN0UFLG1 = "N";

  if (MN0UW1.MN0UWDLF == "A")
    set MN0UM004 initial;
    MN0UM004.MNAMSG = "DELETE FUNCTION ABORTED - NO DELETES DONE";
    MN0UM004.VAGen_EZEMSG = " ";
    MN0UW1.MN0UWF25 = " ";
    MN0UW1.MN0UWDLF = " ";
  end


  if (MN0UW1.MN0UWDLF > " ")
    if (MN0UW1.MN0UWDLF == "1")
      MN0UM004.MNAMSG = "DELETE SUCCESSFUL";
      MN0UM004.VAGen_EZEMSG = "NO USER-APPL RECORDS DELETED";
      MN0UW1.MN0UWF25 = " ";
      MN0UW1.MN0UWDLF = " ";
    else
      if (MN0UW1.MN0UWDLF == "2")
        MN0UM004.MNAMSG = "DELETE PROCESS ENDED";
        MN0UM004.VAGen_EZEMSG = "NO USER RECORDS DELETED";
        MN0UW1.MN0UWF25 = " ";
        MN0UW1.MN0UWDLF = " ";
      else
        if (MN0UW1.MN0UWDLF == "3")
          MN0UM004.MNAMSG = "DELETE PROCESS ENDED";
          MN0UM004.MNAMSG = "NO RECORDS FOUND TO DELETE";
          MN0UW1.MN0UWF25 = " ";
          MN0UW1.MN0UWDLF = " ";
        else
          MN0UM004.MNAMSG = "DELETE SUCCESSFUL";
          MN0UM004.VAGen_EZEMSG = "USER & APPLICATION RECORDS DELETED";
        end
      end
    end
  end

  MN0UW1.MN0UWDLF = " ";

  converse MN0UM004 ;

  MN0UM004.MNAMSG = " ";
  MN0UM004.VAGen_EZEMSG = " ";



   /* **** process the special keys.  If a PF1, PF4*/
        /* or PA2 is pressed then transfer control*/
        /* to the appropriote application.*/

  if (converseVar.eventKey is pf1)
    XSPF1();
    MN0UM004.MNAMSG = COMMAREA.CAMSG;
    MN0UW1.MN0UFLG1 = "Y";
  else
    if (converseVar.eventKey is pf4)
      XSPF4();
      MN0UM004.MNAMSG = COMMAREA.CAMSG;
      MN0UW1.MN0UFLG1 = "Y";
    end
  end


   /* **** process the fast path.  Do not process the fast*/
        /* path if a user was entered to be deleted*/


  if (converseVar.eventKey is enter
   && MN0UM004.CATOAP != " "
   && MN0UM004.MN1USER == " ")
    move MN0UM004 to COMMAREA byName;
    XSEXIT();
    set MN0UM004.CATOAP cursor, bold;
    set MN0UM004 alarm;
    MN0UM004.MNAMSG = COMMAREA.CAMSG;
    MN0UW1.MN0UFLG1 = "Y";
  end

     /* *** EDIT FOR "&" USER KEY - DO NOT ALLOW THEM ****/


  MN0UW1.MN0UCK = MN0UM004.MN1USER;
  if (MN0UW1.MN0UCK1 == "&")
    if (COMMAREA.CAUSERID in MN5TBL.CAUSERID)
      /* next sentence            okay for user to delete "&" recs*/
    else
      MN0UM004.MNAMSG = "YOU CANNOT DELETE A USER WITH PREFIX OF \"&\"";
      MN0UW1.MN0UFLG1 = "Y";
    end
  else
      /* next sentence*/
  end

end // end MN0U019

// read the user rec
Function MN0U020()




       /* *****************************************************/
       /* *                                                  **/
       /* *    Get the user record to be deleted             **/
       /* *                                                  **/
       /* *****************************************************/




   /* **** move the user id entered into the record key field*/
        /* so the correct record can be read.*/

  MN2REC.MN1KEY = " ";
  MN2REC.MN1USER = MN0UM004.MN1USER;
  MN2REC.MN1APPL = MN2REC.MN1USER;

  MN2REC.MN1TYPE1 = "2";
  MN2REC.MN1TYPE2 = "2";




  try
    get MN1REC ;
  end




end // end MN0U020

// display the user record
Function MN0U021()




       /* *****************************************************/
       /* *                                                  **/
       /* *        Display the user record that is to be     **/
       /* *    deleted                                       **/
       /* *                                                  **/
       /* *****************************************************/




   /* **** move the user record to the screen.*/

  move MN2REC to MN0UM004 byName;

  if (MN2REC.XNDCD in XNDTBL.XNDCD)
    MN0UM004.XNDDESC = XNDTBL.XNDDESC[sysVar.arrayIndex];
  end

  if (sysVar.arrayIndex == 0)
    MN0UM004.XNDDESC = "NO DESCRIPTION FOUND";
  end


  if (MN2REC.XWHCD in XWHTBL.XWHCD)
    MN0UM004.XWHNM = XWHTBL.XWHNM[sysVar.arrayIndex];
  end

  if (sysVar.arrayIndex == 0)
    MN0UM004.XWHNM = "NO DESCRIPTION FOUND";
  end


  if (MN2REC.XDVCD in XDVTBL.XDVCD)
    MN0UM004.XDVDESC = XDVTBL.XDVDESC[sysVar.arrayIndex];
  end

  if (sysVar.arrayIndex == 0)
    MN0UM004.XDVDESC = "NO DESCRIPTION FOUND";
  end


  if (MN2REC.XSOCD in XSOTBL.XSOCD)
    MN0UM004.XSONM = XSOTBL.XSONM[sysVar.arrayIndex];
  end

  if (sysVar.arrayIndex == 0)
    MN0UM004.XSONM = "NO DESCRIPTION FOUND";
  end


   /* **** move the correct status description to*/
        /* the screen.*/

  if (MN2REC.MN2STAT == "I")
    MN0UM004.MNASTATD = "INACTIVE";
  else
    if (MN2REC.MN2STAT == "A")
      MN0UM004.MNASTATD = "ACTIVE";
    else
      MN0UM004.MNASTATD = " ";
    end
  end

  MN0UM004.MNANAME = "MN0U021";





  display MN0UM004 ;


  MN1REC.MN1KEY = " ";
  MN0UW1.MN0UWKYG = " ";
  MN1REC.MN1TYPE1 = "3";
  MN1REC.MN1USER = MN0UM004.MN1USER;
  MN1REC.MN1TYPE2 = "3";
  MN0UW1.MN0UWKIX = 1;

  set MN1REC position;


end // end MN0U021

// get the user application rec
Function MN0U022()
   /* *************************************************************/
   /* ***    get all type-3 records with same user name as     ****/
   /* ***  entered upon the screen. save the keys.             ****/
   /* *************************************************************/

  try
    get next MN1REC ;
  end
end // end MN0U022

// get delete confirmation
Function MN0U024()




       /* *****************************************************/
       /* *                                                  **/
       /* *        Accept or reject the user to be deleted   **/
       /* *                                                  **/
       /* *****************************************************/



   /* **** set the screen variables*/

  MN0UM004.MNANAME = "MN0U024";
  MN0UM004.MN0UMDT = VGVar.currentShortGregorianDate;
  MN0UW1.MN0UUSR = MN0UM004.MN1USER;
  MN0UM004.MNAMSG = "PRESS ENTER TO DELETE THE USER RECORD OR";
  MN0UM004.VAGen_EZEMSG = "PA2 TO ABORT THE DELETE";

  MN0UW1.MN0UFLG1 = "N";

  converse MN0UM004 ;

end // end MN0U024

// DELETE USER APPL RECS
Function MN0U025-DEL-APPL()

   /* ***********************************************************/
               /* DELETE THE USER APPL RECORDS*/
   /* ***********************************************************/

  try
    delete MN1REC ;
  end

  if (MN1REC is ioError)
    MN0UM004.MNAMSG = "UNABLE TO DELETE USER RECORD - CALL APPL SUP";
    set MN0UM004 alarm;
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.rollback();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
    
    exit stack;
  end

end // end MN0U025-DEL-APPL

Function MN0U025-DEL-RECS()

  MN0UW1.MN0UWKIX = 1;
  while (MN0UWKIX <= 100
   && MN0UW1.MN1REC-GRP[MN0UWKIX] != " ")
    MN0U025-LOK-APPL();
    MN0UW1.MN0UWKIX = MN0UW1.MN0UWKIX + 1;
  end

  if (MN0UW1.MN0UWKIX > 1)
    MN0UW1.MN0UWDLF = "Y";
  else
    if (MN0UW1.MN0UWKIX == 1)
      MN0UW1.MN0UWDLF = "1";
    else
      MN0UW1.MN0UWDLF = "N";
    end
  end

  MN0U025-LOK-USER();

end // end MN0U025-DEL-RECS

// delete the uSEr record
Function MN0U025-DEL-USER()

       /* *****************************************************/
       /* *                                                  **/
       /* *        Delete the user record                    **/
       /* *                                                  **/
       /* *****************************************************/

  try
    delete MN1REC ;
  end

  if (MN1REC is ioError)
    MN0UM004.MNAMSG = "UNABLE TO LOCK USER RECORD - TRY AGAIN";
    set MN0UM004 alarm;
    exit stack;
  end

end // end MN0U025-DEL-USER

// GET AND LOCK USER APPL RECS
Function MN0U025-LOK-APPL()
   /* *************************************************************/
   /* ***    get AND LOCK USER APPL RECORD                     ****/
   /* *************************************************************/

  set MN1REC empty;
  MN1REC.MN1KEY = MN0UW1.MN0UWKEY[MN0UWKIX];

  try
    get MN1REC forUpdate ;
  end

  if (MN1REC is ioError)
    MN0UM004.MNAMSG = "UNABLE TO LOCK USER RECORD - TRY AGAIN";
    set MN0UM004 alarm;
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.rollback();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
    
    exit stack;
  else
    if (MN1REC.MN1REC-GRP == MN0UW1.MN1REC-GRP[MN0UWKIX])
      MN0U025-DEL-APPL();
    end
  end

end // end MN0U025-LOK-APPL

Function MN0U025-LOK-USER()
       /* *****************************************************/
       /* *                                                  **/
       /* *    Lock the user record to be deleted            **/
       /* *                                                  **/
       /* *****************************************************/

   /* **** move the user id entered into the record key field*/
        /* so the correct record can be read.*/

  set MN1REC empty;
  MN2REC.MN1USER = MN0UM004.MN1USER;
  MN2REC.MN1APPL = MN2REC.MN1USER;

  MN2REC.MN1TYPE1 = "2";
  MN2REC.MN1TYPE2 = "2";

  try
    get MN1REC forUpdate ;
  end

  if (MN1REC is ioError)
    if (MN1REC is noRecordFound)
      if (MN0UW1.MN0UWDLF == "1")
        MN0UW1.MN0UWDLF = "3";
      else
        MN0UW1.MN0UWDLF = "2";
      end
    else
      MN0UM004.MNAMSG = "UNABLE TO LOCK USER RECORD - TRY AGAIN";
      set MN0UM004 alarm;
    end
  else
    MN0U025-DEL-USER();
  end

end // end MN0U025-LOK-USER

// FLLT for inquriy process
Function MN0U026()




       /* *****************************************************/
       /* *                                                  **/
       /* *    This is the entry point for the user applica- **/
       /* *  tion inquiry screen.                            **/
       /* *                                                  **/
       /* *****************************************************/




   /* **** A fast path may have been done to enter this option.*/
        /* If there is a value present in the MN0UIT3 field of*/
        /* the working storage record then a user id was passed*/
        /* in the ITEM field of the COMMAREA record.  Use this*/
        /* user id to position the pointer in the MENU FILE.*/

  if (MN0UW1.MN0UIT3 != " ")
    MN2REC.MN1USER = MN0UW1.MN0UIT3;
  else
    MN2REC.MN1USER = " ";
  end


  MN2REC.MN1TYPE1 = "2";
  set MN1REC position;


   /* **** Set all the indexes and counters to zero.*/

  MN0UW1.MN0UCTR = 0;
  MN0UW1.MN0UIDX = 0;
  MN0UW1.MN0UKY2 = 0;




end // end MN0U026

// get user records
Function MN0U027()
       /* *****************************************************/
       /* *                                                  **/
       /* *    Get 13 user application records.              **/
       /* *                                                  **/
       /* *****************************************************/

  try
    get next MN1REC ;
  end

   /* **** Only 13 records can be displayed on the screen at*/
        /* one time so perform this process 13 time or until*/
        /* the end of the user records has been reached.*/
        /* Move each user record the the screen table.*/

  if (MN1REC is ioError)
    MN0UW1.MN0UW1-NEXT-USER = MN0UM005.MNAUSER[1];
  else
    if (MN0UW1.MN0UCTR == 13)
      MN0UW1.MN0UW1-NEXT-USER = MN2REC.MN1USER;
      MN0UW1.MN0UCTR = MN0UW1.MN0UCTR + 1;
    else
      if (MN2REC.MN1TYPE1 == "2"
       && MN2REC.MN1TYPE2 == "2")
        MN0UW1.MN0UCTR = MN0UW1.MN0UCTR + 1;
        MN0UM005.MNAUSER[MN0UCTR] = MN2REC.MN1USER;
        MN0UM005.MNANAME[MN0UCTR] = MN2REC.MN2USRNM;
        MN0UM005.MNASTAT[MN0UCTR] = MN2REC.MN2STAT;
        MN0UM005.MNADEPT[MN0UCTR] = MN2REC.XNDCD;
        MN0UM005.MNAWHSE[MN0UCTR] = MN2REC.XWHCD;
        MN0UM005.MNADVSN[MN0UCTR] = MN2REC.XDVCD;
        MN0UM005.MNASALES[MN0UCTR] = MN2REC.XSOCD;
        set MN0UM005.MNASLCT[MN0UCTR] normal;
      else
        MN0UM005.VAGen_EZEMSG = "*** END OF LIST ***";
      end
    end
  end






end // end MN0U027

// display user and accept user
Function MN0U028()




       /* *****************************************************/
       /* *                                                  **/
       /* *    Display the user records previously read and  **/
       /* *  accept a new user or a user to inquiry on.      **/
       /* *****************************************************/




   /* **** initialize the screen fields.*/

  MN0UM005.MN0UMDT = VGVar.currentShortGregorianDate;

  MN0UW1.MN0UFLG1 = "N";
  MN0UW1.MN0UFLG2 = "N";
  MN0UW1.MN0UFLG3 = "N";

  converse MN0UM005 ;
   /* **** Clear any leftover message fields and set the*/
        /* attribute of the CATOAP field to normal in case*/
        /* there was a previous error in this field.*/

  MN0UM005.MNAMSG = " ";
  MN0UM005.VAGen_EZEMSG = " ";
  set MN0UM003.CATOAP normal;

  if (converseVar.eventKey is pf3
   || converseVar.eventKey is pa2)
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.commit();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
    
  end

   /* **** Check to see if the function key PF1, PF4 or PA2*/
        /* was pressed.  If one of them was then transfer*/
        /* to the appropriate application.*/

  MN0US4A();
  if (MN0UW1.MN0UFLG1 == "Y")
    exit stack;
  end

   /* **** Check to see if the fast path was chosen.*/

  MN0US4B();
  if (MN0UW1.MN0UFLG1 == "Y")
    exit stack;
  end

   /* **** Set the starting key field if the PF7 or PF8 keys*/
        /* were pressed.  PF7 will scroll back and PF8 will*/
        /* scroll forward.*/

  MN0US4C();
  if (MN0UW1.MN0UFLG1 == "Y"
   || MN0UW1.MN0UFLG2 == "Y"
   || MN0UW1.MN0UFLG3 == "Y")
    exit stack;
  end

   /* **** Check to see if a user id was entered.  If it was then*/
        /* position the pointer in the file to that user.*/

  MN0US4F();
  if (MN0UW1.MN0UFLG1 == "Y"
   || MN0UW1.MN0UFLG2 == "Y"
   || MN0UW1.MN0UFLG3 == "Y")
    exit stack;
  end

   /* **** Check to see if a user was selected to inquiry apon.*/

  MN0US4G();
  if (MN0UW1.MN0UFLG1 == "Y"
   || MN0UW1.MN0UFLG2 == "Y"
   || MN0UW1.MN0UFLG3 == "Y")
    exit stack;
  end

end // end MN0U028

// get user application records
Function MN0U029()




         /* ******************************************************/
         /* *                                                   **/
         /* *    Get the user application record.               **/
         /* *                                                   **/
         /* ******************************************************/


  MN0UW1.MN0UFLG1 = "N";

   /* **** If the end of file has been reached or the user id*/
        /* has changed or the type of record has changed then*/
        /* bypass the display and converse the screen.*/

  if (MN1REC is ioError
   || MN3REC.MN1USER != MN0UW1.MN0UUSR
   || MN3REC.MN1TYPE1 != "3")
    MN0UW1.MN0UFLG1 = "Y";
    exit stack;
  end




  try
    get next MN1REC ;
  end




   /* **** If the end of file has been reached or the user id*/
        /* has changed or the type of record has changed then*/
        /* bypass the display and converse the screen.*/

  if (MN1REC is ioError
   || MN3REC.MN1USER != MN0UW1.MN0UUSR
   || MN3REC.MN1TYPE1 != "3")
    MN0UW1.MN0UFLG1 = "Y";
    exit stack;
  end




end // end MN0U029

// display user application recds
Function MN0U030()
         /* ******************************************************/
         /* *                                                   **/
         /* *    Display the user application record.           **/
         /* *                                                   **/
         /* ******************************************************/

   /* **** If the end of file has been reached or the user id*/
        /* has changed or the type of record has changed then*/
        /* bypass the display and converse the screen.*/

  if (MN1REC is ioError
   || MN3REC.MN1USER != MN0UW1.MN0UUSR
   || MN3REC.MN1TYPE1 != "3")
    MN0UW1.MN0UFLG1 = "Y";
    MN0UW1.MN0UW1-NEXT-MN0UFAPP = MN0UW1.MN0UFAPP;
    exit stack;
  end


  if (MN0UW1.MN0UCTR == 6)
    MN0UW1.MN0UW1-NEXT-MN0UFAPP = MN3REC.MN1APPL;
    MN0UW1.MN0UCTR = MN0UW1.MN0UCTR + 1;
    exit stack;
  else /* move the user app rec to screen*/
    move MN3REC to MN0UM008 byName;
    MN0UW1.MN0UCTR = MN0UW1.MN0UCTR + 1;
        /* save 1st application to be used for scrolling back.*/
    if (MN0UW1.MN0UCTR == 1)
      MN0UW1.MN0UFAPP = MN3REC.MN1APPL;
    end
  end

  MN0UW1.MN0UFLG1 = "N";

  display MN0UM008 ;
end // end MN0U030

// converse usr application recds
Function MN0U031()




         /* ******************************************************/
         /* *                                                   **/
         /* *    Display the user application record.           **/
         /* *                                                   **/
         /* ******************************************************/




  MN0UW1.MN0UFLG1 = "N";
  MN0UW1.MN0UFLG2 = "N";




  converse MN0UM009 ;




   /* **** Clear any leftover message fields and set the*/
        /* attribute of the CATOAP field to normal in case*/
        /* there was a previous error in this field.*/

  MN0UM009.MNAMSG = " ";
  MN0UM009.VAGen_EZEMSG = " ";
  set MN0UM003.CATOAP normal;


   /* **** Check to see if the function key PF1, PF4 or PA2*/
        /* was pressed.  If one of them was, then transfer*/
        /* to the application.*/

  MN0US4I();
  if (MN0UW1.MN0UFLG1 == "Y")
    exit stack;
  end


   /* **** Check to see if the fast path was chosen.*/

  MN0US4J();
  if (MN0UW1.MN0UFLG1 == "Y")
    exit stack;
  end


   /* **** Check for the PF7, scroll back, and PF8,scroll*/
        /* forward, keys to be pressed.*/

  MN0US4K();
  if (MN0UW1.MN0UFLG1 == "Y"
   || MN0UW1.MN0UFLG2 == "Y")
    exit stack;
  end


   /* **** Check to see of the PF3 or PA2 keys were pressed.*/
        /* If one of them was then set the pointer in the file*/
        /* to the last user record read.*/

  if (converseVar.eventKey is pf3
   || converseVar.eventKey is pa2)
    MN2REC.MN1KEY = " ";
    MN2REC.MN1TYPE1 = "2";
    MN2REC.MN1USER = MN0UW1.MN0ULUSR;
    set MN1REC position;
  end




end // end MN0U031

// FLLT for update user appl
Function MN0U032()




         /* **************************************************/
         /* *                                               **/
         /* *   This is the FTTL process for the update     **/
         /* *  user application record function.            **/
         /* *                                               **/
         /* **************************************************/







end // end MN0U032

// get user & appl to change
Function MN0U033()




      /* *******************************************************/
      /* *                                                    **/
      /* *    This process will get the user, application and **/
      /* *  the function that will be performed.  All the     **/
      /* *  fields must be entered to proceed.                **/
      /* *                                                    **/
      /* *******************************************************/


   /* **** Initialize the screen fields.*/

  MN0UM007.MN0UMDT = VGVar.currentShortGregorianDate;
  MN0UM007.MNANAME = "MN0U033";


   /* **** Initialize the error flag.*/

  MN0UW1.MN0UFLG1 = "N";




  converse MN0UM007 ;




   /* **** Clear any leftover error messages and set the fields*/
        /* back to there original state.*/

  MN0UM007.MNAMSG = " ";
  MN0UM007.VAGen_EZEMSG = " ";
  set MN0UM007.MN1USER cursor, normal;
  set MN0UM007.MN1APPL normal;
  set MN0UM007.MNAOPTN normal;
  set MN0UM007.CATOAP normal;


   /* **** Process the functions keys.  The only valid keys are*/
        /* PF1, PF4, PA2 and PF3.  PF3 will be check in the flow*/
        /* section.  If an error occured processing the PF keys*/
        /* control will be returned to this process.  A flag will*/
        /* be set from statement group telling that an error has*/
        /* occured.*/

  if (converseVar.eventKey is pf3
   || converseVar.eventKey is pa2)
    set MN0UM007 initial;
    exit stack;
  end
  MN0US5A();
                                   /* check function keys.*/


   /* **** Process the fast path.  If an error occured then*/
        /* control will be passed back to this process with*/
        /* a flag set.*/

  MN0US5B();
                                   /* check the fast path.*/


   /* **** Verify that all the fields were entered.  The user id*/
        /* application and function must all be entered to*/
        /* proceed.*/

  MN0US5C(); /* verify entry of fields*/




end // end MN0U033

// get user record
Function MN0U034()




        /* ****************************************************/
        /* *                                                 **/
        /* *    This process will inquiry on the user menu   **/
        /* *  record.                                        **/
        /* *                                                 **/
        /* ****************************************************/


   /* **** initialize the user key field.*/

  MN2REC.MN1KEY = " ";
  MN2REC.MN1TYPE1 = "2";
  MN2REC.MN1TYPE2 = "2";
  MN2REC.MN1USER = MN0UM007.MN1USER;
  MN2REC.MN1APPL = MN2REC.MN1USER;

  MN0UW1.MN0UFLG1 = "N";




  try
    get MN1REC ;
  end




end // end MN0U034

// get application record
Function MN0U035()




        /* ****************************************************/
        /* *                                                 **/
        /* *    This process will inquiry on the application **/
        /* *  record.                                        **/
        /* *                                                 **/
        /* ****************************************************/
  if (MN0UM007.MN1APPL < "A   ")
    exit stack;
  end

   /* **** initialize the application key field.*/

  MN1REC.MN1KEY = " ";
  MN1REC.MN1TYPE1 = "1";
  MN1REC.MN1TYPE2 = "1";
  MN1REC.MN1APPL = MN0UM007.MN1APPL;

  MN0UW1.MN0UFLG1 = "N";




  try
    get MN1REC ;
  end




   /* **** If the return code from the inquiry is good then*/
        /* perform a statement group which will set each flag*/
        /* on the screen to an unprotected state when a 'y' is*/
        /* found on a level flag of the application record.*/
        /* This is so that the user cannot change a user flag*/
        /* to 'Y' when the application does not support it.*/

  if (MN1REC is ioError)
  else
    MN0US5D(); /* set screen flags*/
    MN0UM007.MN1NM = MN1REC.MN1NM;
  end




end // end MN0U035

// get and lock user appl record
Function MN0U036()




        /* ****************************************************/
        /* *                                                 **/
        /* *    This process will get and lock the user      **/
        /* *  application record.                            **/
        /* *                                                 **/
        /* ****************************************************/


   /* **** initialize the user key field.*/

  MN3REC.MN1KEY = " ";
  MN3REC.MN1TYPE1 = "3";
  MN3REC.MN1TYPE2 = "3";
  MN3REC.MN1USER = MN0UM007.MN1USER;
  MN3REC.MN1APPL = MN0UM007.MN1APPL;

  MN0UW1.MN0UFLG1 = "N";




  try
    get MN1REC ;
  end




   /* **** Check the return code on the record update.*/
        /* If the option selected was add then a record*/
        /* not found is ok and a record found is an error.*/
        /* Otherwise it is an error if the record does not*/
        /* exist.*/

  if (MN1REC is ioError)
    MN0US5E(); /* record not found*/
  else
    MN0US5F(); /* record found*/
    move MN3REC to MN0UM007 withV60Compat;
  end




end // end MN0U036

// maintanance user appl record
Function MN0U037()




      /* *******************************************************/
      /* *                                                    **/
      /* *    This process will perform the maintenance on    **/
      /* *  the user application record.                      **/
      /* *                                                    **/
      /* *******************************************************/


   /* **** Initialize the screen fields.*/

  MN0UM007.MN0UMDT = VGVar.currentShortGregorianDate;
  MN0UM007.MNANAME = "MN0U037";

  if (MN0UM007.MNAOPTN == "D")
    MN0UM007.MNAMSG = "PRESS ENTER TO DELETE OR PA2 TO ABORT";
  end
  if (MN0UM007.MNAOPTN == "A")
    MN0UM007.MNAMSG = "PRESS ENTER TO ADD RECORD OR PA2 TO ABORT";
  end

   /* **** Initialize the error flag.*/

  MN0UW1.MN0UFLG1 = "N";
  MN0UW1.MN0UFLG2 = "N";
  MN0UW1.MN0UFLG3 = "N";
  MN0UW1.MN0UFLG4 = "N";




  converse MN0UM007 ;




   /* **** Clear any leftover error messages and set the fields*/
        /* back to there original state.*/

  MN0UM007.MNAMSG = " ";
  MN0UM007.VAGen_EZEMSG = " ";
  set MN0UM007.MN1USER cursor, normal;
  set MN0UM007.MN1APPL normal;
  set MN0UM007.MNAOPTN normal;
  set MN0UM007.CATOAP normal;


   /* **** Process the functions keys.  The only valid keys are*/
        /* PF1, PF4,  and PF3.  PF3 will be check in the flow*/
        /* section.  If an error occured processing the PF keys*/
        /* control will be returned to this process.  A flag will*/
        /* be set from statement group telling that an error has*/
        /* occured.*/

  MN0US5G();
                                   /* check function keys.*/



   /* **** Process the fast path.  If an error occured then*/
        /* control will be passed back to this process with*/
        /* a flag set.*/

  MN0US5B();
                                   /* check the fast path.*/


   /* **** Verify that all the fields were entered.  The user id*/
        /* application and function must all be entered to*/
        /* proceed.*/

  MN0US5H(); /* verify entry of fields*/



   /* **** If there was an error or the option is being*/
        /* aborted then unlock the user application record*/
        /* and set the flags to there defined state.*/

  if (converseVar.eventKey is pf3
   || converseVar.eventKey is pa2
   || MN0UW1.MN0UFLG2 == "Y"
   || MN0UW1.MN0UFLG3 == "Y")
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.rollback();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
    
    MN0US5I();
  end




end // end MN0U037

// add user appl record
Function MN0U038()




       /* ******************************************************/
       /* *                                                   **/
       /* *    Add the user application record                **/
       /* *                                                   **/
       /* ******************************************************/


   /* **** If any of the flags are set to 'n' then all the*/
        /* associated level flags must also be set to 'n'.*/

  MN0USXB();




  try
    add MN1REC ;
  end




   /* **** Reset the screen fields.*/

  MN0UW1.MN0UUSR = MN0UM007.MN1USER;
  set MN0UM007 initial;
  MN0UM007.MN1USER = MN0UW1.MN0UUSR;


   /* **** Send back the appropriate message depending on*/
        /* if the record was added successfully.*/

  if (MN1REC is ioError)
    MN0UM007.MNAMSG = "USER APPLICATION RECORD COULD NOT BE ADDED";
    set MN0UM007 alarm;
  else
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.commit();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
    
    set MN0UM007.MNAOPTN cursor;
    MN0UM007.MNAMSG = "RECORD ADDED";
  end




end // end MN0U038

// change the user appl record
Function MN0U039-REPLACE()




       /* ******************************************************/
       /* *                                                   **/
       /* *    change the user application record.            **/
       /* *                                                   **/
       /* ******************************************************/


   /* **** If any of the flags are set to 'n' then all the*/
        /* associated level flags must also be set to 'n'.*/

  MN0USXB();





  try
    replace MN1REC ;
  end




   /* **** Reset the screen fields.*/

  MN0UW1.MN0UUSR = MN0UM007.MN1USER;
  set MN0UM007 initial;
  MN0UM007.MN1USER = MN0UW1.MN0UUSR;


   /* **** Send back the appropriate message depending on*/
        /* if the record was changed successfully.*/

  if (MN1REC is ioError)
    MN0UM007.MNAMSG = "USER APPLICATION RECORD COULD NOT BE CHANGED";
    set MN0UM007 alarm;
  else
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.commit();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
    
    MN0UM007.MNAMSG = "RECORD CHANGED";
  end




end // end MN0U039-REPLACE

// get and lock user appl record
Function MN0U039-UPDATE()
        /* ****************************************************/
        /* *                                                 **/
        /* *    This process will get and lock the user      **/
        /* *  application record.                            **/
        /* *                                                 **/
        /* ****************************************************/


   /* **** initialize the user key field.*/

  MN3REC.MN1KEY = " ";
  MN3REC.MN1TYPE1 = "3";
  MN3REC.MN1TYPE2 = "3";
  MN3REC.MN1USER = MN0UM007.MN1USER;
  MN3REC.MN1APPL = MN0UM007.MN1APPL;

  MN0UW1.MN0UFLG1 = "N";






  try
    get MN1REC forUpdate ;
  end

   /* **** Check the return code on the record update.*/
        /* If the option selected was add then a record*/
        /* not found is ok and a record found is an error.*/
        /* Otherwise it is an error if the record does not*/
        /* exist.*/

  if (MN1REC is ioError)
    MN0US5E(); /* record not found*/
  else
    MN0US5F(); /* record found*/
  end




end // end MN0U039-UPDATE

// delete the user appl record
Function MN0U040-DELETE()




       /* ******************************************************/
       /* *                                                   **/
       /* *    delete the user application record             **/
       /* *                                                   **/
       /* ******************************************************/


  try
    delete MN1REC ;
  end




   /* **** Reset the screen fields.*/

  MN0UW1.MN0UUSR = MN0UM007.MN1USER;
  set MN0UM007 initial;
  MN0UM007.MN1USER = MN0UW1.MN0UUSR;
  set MN0UM007.MNAOPTN cursor;


   /* **** Send back the appropriate message depending on*/
        /* if the record was deleted successfully.*/

  if (MN1REC is ioError)
    MN0UM007.MNAMSG = "USER APPLICATION RECORD COULD NOT BE DELETED";
    set MN0UM007 alarm;
  else
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.commit();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
    
    MN0UM007.MNAMSG = "RECORD DELETED";
  end




end // end MN0U040-DELETE

// get and lock user appl record
Function MN0U040-UPDATE()
        /* ****************************************************/
        /* *                                                 **/
        /* *    This process will get and lock the user      **/
        /* *  application record.                            **/
        /* *                                                 **/
        /* ****************************************************/


   /* **** initialize the user key field.*/

  MN3REC.MN1KEY = " ";
  MN3REC.MN1TYPE1 = "3";
  MN3REC.MN1TYPE2 = "3";
  MN3REC.MN1USER = MN0UM007.MN1USER;
  MN3REC.MN1APPL = MN0UM007.MN1APPL;

  MN0UW1.MN0UFLG1 = "N";




  try
    get MN1REC forUpdate ;
  end
   /* **** Check the return code on the record update.*/
        /* If the option selected was add then a record*/
        /* not found is ok and a record found is an error.*/
        /* Otherwise it is an error if the record does not*/
        /* exist.*/

  if (MN1REC is ioError)
    MN0US5E(); /* record not found*/
  else
    MN0US5F(); /* record found*/
    move MN3REC to MN0UM007 withV60Compat;
  end




end // end MN0U040-UPDATE

// display top portion of screen
Function MN0U041()




       /* *****************************************************/
       /* *                                                  **/
       /* *    Display the top portion of the user application*/
       /* *  screen                                          **/
       /* *****************************************************/




   /* **** initialize the screen fields.*/

  MN0UM006.MN0UMDT = VGVar.currentShortGregorianDate;




  display MN0UM006 ;




end // end MN0U041

// get application name
Function MN0U042()




         /* ******************************************************/
         /* *                                                   **/
         /* *    Get the user application record.               **/
         /* *                                                   **/
         /* ******************************************************/


  MN1REC.MN1TYPE1 = "1";
  MN1REC.MN1USER = " ";
  MN1REC.MN1TYPE2 = "1";
  MN1REC.MN1APPL = MN3REC.MN1APPL;





  try
    get MN1REC ;
  end




  if (MN1REC is ioError)
    MN0UM008.MN1NM = "MENU RECORD NOT FOUND";
  else
    MN0UM008.MN1NM = MN1REC.MN1NM;
  end




end // end MN0U042

// set pointer in file
Function MN0U043()
   /* GET MN0U042*/




         /* ******************************************************/
         /* *                                                   **/
         /* *    Get the user application record.               **/
         /* *                                                   **/
         /* ******************************************************/


  MN1REC.MN1TYPE1 = "3";
  MN1REC.MN1USER = MN0UW1.MN0UUSR;
  MN1REC.MN1TYPE2 = "3";
  MN3REC.MN1APPL = MN1REC.MN1APPL;





  try
    get MN1REC ;
  end




end // end MN0U043

// read grp appl record
Function MN0U211()
        /* *****************************************************/
        /* *                                                  **/
        /* *      Get the application record.  If it exists   **/
        /* *   then it is an error.                           **/
        /* **/
        /* *****************************************************/


  MN1REC.MN1KEY = " ";
  MN1REC.MN1TYPE1 = "1";
  MN1REC.MN1TYPE2 = "1";
  MN1REC.MN1APPL = MN0UM002.MN1USER;

  try
    get MN1REC ;
  end

end // end MN0U211

// read user to copy from menu
Function MN0U212()
        /* ************************************************/
        /* *                                             **/
        /* *   This process gets the user-to-copy record **/
        /* *                                             **/
        /* ************************************************/


  MN2REC.MN1KEY = " ";
  MN2REC.MN1TYPE1 = "2";
  MN2REC.MN1TYPE2 = "2";
  move MN0UM002 to MN2REC withV60Compat;
  MN2REC.MN1USER = MN0UM002.MN0UMUSC;
  MN2REC.MN1APPL = MN2REC.MN1USER;

  try
    get MN1REC ;
  end

end // end MN0U212

// get first user-copy record
Function MN0U213()
      /* scan the menu records for next*/
      /* menu record to be copied to new profile*/
      /* key setup in MN0U211*/

  try
    get next MN1REC ;
  end

end // end MN0U213

// add grp appl record
Function MN0U215()
        /* *****************************************************/
        /* *                                                  **/
        /* *      add the application record.                 **/
        /* **/
        /* *****************************************************/


  MN1REC.MN1KEY = " ";
  MN1REC.MN1TYPE1 = "1";
  MN1REC.MN1TYPE2 = "1";
  MN1REC.MN1APPL = MN0UM002.MN1USER;
  MN1REC.MN1CICS = "****";
  MN1REC.MN1NM = MN0UM002.MN2USRNM;
  MN1REC.MN1ADDFL = "N";
  MN1REC.MN1CHGFL = "N";
  MN1REC.MN1DELFL = "N";
  MN1REC.MN1INQFL = "N";

   /* **** If any of the flags are set to a 'N' then*/
        /* all associated level flags must also be set*/
        /* to 'N'.*/

  XSMNSXA();

  try
    add MN1REC ;
  end

  if (MN1REC is ioError)
    /* next sentence*/
  else
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.commit();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
     /* commit the adds*/
  end

end // end MN0U215

// copy menu record
Function MN0U216()
          /* add menu record for new user*/
      /* menu record to be copied to new profile*/

  try
    add MN1REC ;
  end
end // end MN0U216

// FILE POSITIONING FOR SCAN
Function MN0U217()

  try
    get MN1REC ;
  end

end // end MN0U217

// validate the user id
Function MN0US1A()




         /* **************************************************/
         /* *                                               **/
         /* *        Validate the user id field.            **/
         /* *                                               **/
         /* **************************************************/


   /* **** the field must start with an alpha character.*/
        /* If the field is invalid then set the flag and*/
        /* set the field to be highlighted.*/

  MN0UW1.MN0UCK = MN0UM002.MN1USER;
  if (MN0UW1.MN0UCK1 >= "A"
   && MN0UW1.MN0UCK1 <= "I")
    /* next sentence*/
  else
    if (MN0UW1.MN0UCK1 >= "J"
     && MN0UW1.MN0UCK1 <= "R")
      /* next sentence*/
    else
      if (MN0UW1.MN0UCK1 >= "S"
       && MN0UW1.MN0UCK1 <= "Z")
        /* next sentence*/
      else
        if (MN0UW1.MN0UCK1 == "&")
          if (MN0UW1.MN0UCKL <= " ")
            /* next sentence*/
          else
            MN0UM002.MNAMSG = "MAX LENGTH FOR GROUP IS 4 CHARS";
            MN0UW1.MN0UFLG1 = "Y";
            set MN0UM002.MN1USER cursor;
            set MN0UM002.MN1USER bold;
          end
        else
          if (MN0UW1.MN0UCK1 == "#")
            /* next sentence*/
          else
            MN0UM002.MNAMSG = "INVALID USER ID";
            MN0UW1.MN0UFLG1 = "Y";
            set MN0UM002.MN1USER cursor;
            set MN0UM002.MN1USER bold;
          end
        end
      end
    end
  end



  if (MN0UM002.MN0UMUSC > " ")
    MN0UW1.MN0UCK = MN0UM002.MN0UMUSC;
    if (MN0UW1.MN0UCK1 >= "A"
     && MN0UW1.MN0UCK1 <= "I")
      /* next sentence*/
    else
      if (MN0UW1.MN0UCK1 >= "J"
       && MN0UW1.MN0UCK1 <= "R")
        /* next sentence*/
      else
        if (MN0UW1.MN0UCK1 >= "S"
         && MN0UW1.MN0UCK1 <= "Z")
          /* next sentence*/
        else
          if (MN0UW1.MN0UCK1 == "&")
            if (MN0UW1.MN0UCKL <= " ")
              /* next sentence*/
            else
              MN0UM002.MNAMSG = "MAX LENGTH FOR GROUP IS 4 CHARS";
              MN0UW1.MN0UFLG1 = "Y";
              set MN0UM002.MN0UMUSC cursor;
              set MN0UM002.MN0UMUSC bold;
            end
          else
            if (MN0UW1.MN0UCK1 == "#")
              if (MN0UW1.MN0UCKL <= " ")
                /* next sentence*/
              else
                MN0UM002.MNAMSG = "MAX LENGTH FOR GROUP IS 4 CHARS";
                MN0UW1.MN0UFLG1 = "Y";
                set MN0UM002.MN0UMUSC cursor;
                set MN0UM002.MN0UMUSC bold;
              end
            else
              MN0UM002.MNAMSG = "INVALID USER ID";
              MN0UW1.MN0UFLG1 = "Y";
              set MN0UM002.MN1USER cursor;
              set MN0UM002.MN1USER bold;
            end
          end
        end
      end
    end
  end

  MN0UW1.MN0UCK = MN0UM002.MN1USER;
end // end MN0US1A

// validate the user name
Function MN0US1B()




         /* ***************************************************/
         /* *                                                **/
         /* *       Validate the user name field             **/
         /* *                                                **/
         /* ***************************************************/


   /* **** the name field must not be blank.*/

  if (MN0UM002.MN2USRNM == " ")
    MN0UM002.MNAMSG = "NAME MUST BE ENTERED";
    set MN0UM002.MN2USRNM cursor;
    set MN0UM002.MN2USRNM bold;
    MN0UW1.MN0UFLG1 = "Y";
  end




end // end MN0US1B

// validate the status
Function MN0US1C()




        /* **************************************************/
        /* *                                               **/
        /* *     Validate the status field                 **/
        /* *                                               **/
        /* **************************************************/


   /* **** The field can only be an 'a' or 'i'*/

  if (MN0UM002.MN2STAT != "A"
   && MN0UM002.MN2STAT != "I")
    MN0UM002.MNAMSG = "STATUS FIELD MUST BE I OR A";
    set MN0UM002.MN2STAT cursor;
    set MN0UM002.MN2STAT bold;
    MN0UW1.MN0UFLG1 = "Y";
  end




end // end MN0US1C

// validate the dept code
Function MN0US1D()




       /* *****************************************************/
       /* *                                                  **/
       /* *        Validate the department code              **/
       /* *                                                  **/
       /* *****************************************************/




  if (MN0UM002.XNDCD in XNDTBL.XNDCD)
    MN0UM002.XNDDESC = XNDTBL.XNDDESC[sysVar.arrayIndex];
  end

  if (sysVar.arrayIndex == 0)
    MN0UW1.MN0UFLG1 = "Y";
    MN0UM002.MNAMSG = "INVALID DEPARTMENT CODE";
    set MN0UM002.XNDCD cursor, bold;
    set MN0UM002 alarm;
  end



end // end MN0US1D

// validate the warehouse code
Function MN0US1E()




       /* *****************************************************/
       /* *                                                  **/
       /* *        Validate the warehouse code               **/
       /* *                                                  **/
       /* *****************************************************/


  if (MN0UM002.XWHCD in XWHTBL.XWHCD)
    MN0UM002.XWHNM = XWHTBL.XWHNM[sysVar.arrayIndex];
  end

  if (sysVar.arrayIndex == 0)
    MN0UW1.MN0UFLG1 = "Y";
    MN0UM002.MNAMSG = "INVALID WAREHOUSE CODE";
    set MN0UM002.XWHCD cursor, bold;
    set MN0UM002 alarm;
  end



end // end MN0US1E

// validate the division code
Function MN0US1F()




       /* *****************************************************/
       /* *                                                  **/
       /* *        Validate the division code                **/
       /* *                                                  **/
       /* *****************************************************/


  if (MN0UM002.XDVCD in XDVTBL.XDVCD)
    MN0UM002.XDVDESC = XDVTBL.XDVDESC[sysVar.arrayIndex];
  end

  if (sysVar.arrayIndex == 0)
    MN0UW1.MN0UFLG1 = "Y";
    MN0UM002.MNAMSG = "INVALID DIVISION CODE";
    set MN0UM002.XDVCD cursor, bold;
    set MN0UM002 alarm;
  end



end // end MN0US1F

// validate the sales office
Function MN0US1G()




       /* *****************************************************/
       /* *                                                  **/
       /* *        Validate the sales office                 **/
       /* *                                                  **/
       /* *****************************************************/


  if (MN0UM002.XSOCD in XSOTBL.XSOCD)
    MN0UM002.XSONM = XSOTBL.XSONM[sysVar.arrayIndex];
  end

  if (sysVar.arrayIndex == 0)
    MN0UW1.MN0UFLG1 = "Y";
    MN0UM002.MNAMSG = "INVALID SALES OFFIC CODE";
    set MN0UM002.XSOCD cursor, bold;
    set MN0UM002 alarm;
  end



end // end MN0US1G

// validate the user name
Function MN0US2A()




         /* ***************************************************/
         /* *                                                **/
         /* *            Validate the user name              **/
         /* *                                                **/
         /* ***************************************************/


   /* **** the name file must not be blank.*/

  if (MN0UM003.MN2USRNM == " ")
    MN0UM003.MNAMSG = "NAME MUST BE ENTERED";
    set MN0UM003 alarm;
    set MN0UM003.MN2USRNM cursor;
    set MN0UM003.MN2USRNM bold;
    MN0UW1.MN0UFLG1 = "Y";
  end




end // end MN0US2A

// validate the status
Function MN0US2B()




          /* ***************************************************/
          /* *                                                **/
          /* *         Validate the status field              **/
          /* *                                                **/
          /* ***************************************************/


   /* **** The field can only be an 'a' or 'i'*/

  if (MN0UM003.MN2STAT != "A"
   && MN0UM003.MN2STAT != "I")
    MN0UM003.MNAMSG = "STATUS FIELD MUST BE I OR A";
    set MN0UM003.MN2STAT cursor;
    set MN0UM003.MN2STAT bold;
    set MN0UM003 alarm;
    MN0UW1.MN0UFLG1 = "Y";
  end




end // end MN0US2B

// validate the department code
Function MN0US2C()




       /* *****************************************************/
       /* *                                                  **/
       /* *        Validate the department code              **/
       /* *                                                  **/
       /* *****************************************************/




  if (MN0UM003.XNDCD in XNDTBL.XNDCD)
    MN0UM003.XNDDESC = XNDTBL.XNDDESC[sysVar.arrayIndex];
  end

  if (sysVar.arrayIndex == 0)
    MN0UW1.MN0UFLG1 = "Y";
    MN0UM003.MNAMSG = "INVALID DEPARTMENT CODE";
    set MN0UM003.XNDCD cursor, bold;
    set MN0UM003 alarm;
  end




end // end MN0US2C

// validate the warehouse code
Function MN0US2D()




       /* *****************************************************/
       /* *                                                  **/
       /* *        Validate the warehouse code               **/
       /* *                                                  **/
       /* *****************************************************/


  if (MN0UM003.XWHCD in XWHTBL.XWHCD)
    MN0UM003.XWHNM = XWHTBL.XWHNM[sysVar.arrayIndex];
  end

  if (sysVar.arrayIndex == 0)
    MN0UW1.MN0UFLG1 = "Y";
    MN0UM003.MNAMSG = "INVALID WAREHOUSE CODE";
    set MN0UM003.XWHCD cursor, bold;
    set MN0UM003 alarm;
  end



end // end MN0US2D

// validate the division code
Function MN0US2E()




       /* *****************************************************/
       /* *                                                  **/
       /* *        Validate the division code                **/
       /* *                                                  **/
       /* *****************************************************/


  if (MN0UM003.XDVCD in XDVTBL.XDVCD)
    MN0UM003.XDVDESC = XDVTBL.XDVDESC[sysVar.arrayIndex];
  end

  if (sysVar.arrayIndex == 0)
    MN0UW1.MN0UFLG1 = "Y";
    MN0UM003.MNAMSG = "INVALID DIVISION CODE";
    set MN0UM003.XDVCD cursor, bold;
    set MN0UM003 alarm;
  end



end // end MN0US2E

// validate the sales office
Function MN0US2F()




       /* *****************************************************/
       /* *                                                  **/
       /* *        Validate the sales office                 **/
       /* *                                                  **/
       /* *****************************************************/


  if (MN0UM003.XSOCD in XSOTBL.XSOCD)
    MN0UM003.XSONM = XSOTBL.XSONM[sysVar.arrayIndex];
  end

  if (sysVar.arrayIndex == 0)
    MN0UW1.MN0UFLG1 = "Y";
    MN0UM003.MNAMSG = "INVALID SALES OFFIC CODE";
    set MN0UM003.XSOCD cursor, bold;
    set MN0UM003 alarm;
  end



end // end MN0US2F

// process special function keys
Function MN0US4A()




         /* *****************************************************/
         /* *                                                  **/
         /* *        process the special function keys.        **/
         /* *                                                  **/
         /* *****************************************************/



   /* **** Transfer control to the appropriate application*/
        /* depending on which special key was pressed.*/
        /* Set the error flag to Y if control is passed back*/
        /* to this application.*/


   /* **** go to the help facility.*/

  if (converseVar.eventKey is pf1)
    XSPF1();
    MN0UW1.MN0UFLG1 = "Y";
    MN0UM005.MNAMSG = COMMAREA.CAMSG;
    return;
  end


   /* **** Return to the main menu*/

  if (converseVar.eventKey is pf4
   || converseVar.eventKey is pa2)
    XSPF4();
    MN0UW1.MN0UFLG1 = "Y";
    MN0UM005.MNAMSG = COMMAREA.CAMSG;
    return;
  end




end // end MN0US4A

// process fast path
Function MN0US4B()




         /* ***************************************************/
         /* *                                                **/
         /* *      Process the fast path.                    **/
         /* *                                                **/
         /* ***************************************************/



   /* **** If the error flag is set bypass checking the PF*/
        /* keys. What this means is that an error has already*/
        /* been found previous to this statement group.*/

  if (MN0UW1.MN0UFLG1 == "Y")
    return;
  end


   /* **** Process the fast path.*/

  if (converseVar.eventKey is enter
   && MN0UM005.CATOAP != " ")
    move MN0UM005 to COMMAREA withV60Compat;
    XSEXIT();
    MN0UM005.MNAMSG = COMMAREA.CAMSG;
    set MN0UM005 alarm;
    set MN0UM005.CATOAP cursor, bold;
    MN0UW1.MN0UFLG1 = "Y";
    return;
  end




end // end MN0US4B

// set record key for scrolling
Function MN0US4C()




          /* ***************************************************/
          /* *                                                **/
          /* *  If the PF7 or PF8 key was pressed then perform**/
          /* *the statement group to handle each one.         **/
          /* *                                                **/
          /* ***************************************************/


   /* **** scroll back*/

  if (converseVar.eventKey is pf7)
    MN0US4D();
    return;
  end


   /* **** scroll forward*/

  if (converseVar.eventKey is pf8)
    MN0US4E();
    return;
  end




end // end MN0US4C

// process scroll back
Function MN0US4D()




       /* ***************************************************/
       /* *                                                **/
       /* *                 SCROLL BACK                    **/
       /* *                                                **/
       /* *    Set the pointer in the MENU FILE to the     **/
       /* *  previous user key in the key table.           **/
       /* *                                                **/
       /* ***************************************************/


   /* **** if the beginning of the table has been reached then*/
        /* set the pointer to the first user record in the file.*/

        /* mn0uflg2 is used to branch back to the scan process*/



  if (MN0UW1.MN0UKY2 < 1)
    MN0UW1.MN0UKY2 = 0;
    MN0UW1.MN0UFLG1 = "Y";
  else
    MN2REC.MN1KEY = " ";
    MN2REC.MN1TYPE1 = "2";
    MN2REC.MN1USER = MN0UW2.MN0U2KY[MN0UKY2];
    MN0UW1.MN0UKY2 = MN0UW1.MN0UKY2 - 1;
    MN0UW1.MN0UCTR = 0;
    set MN0UM005 initial;
    MN0UW1.MN0UFLG2 = "Y";
    set MN1REC position;
  end






end // end MN0US4D

// process scroll forward
Function MN0US4E()
   /* ********************************************************/
   /* **/
   /* SCROLL FORWARD                      **/
   /* **/
   /* mn0uflg2 is used to branch back to the scan process. **/
   /* mn0uflg1 is used to branch back to the converse.     **/
   /* If the end of file is reached or the record type has **/
   /* changed then we want to keep what is on the screen   **/
   /* otherwise save the first record key on the screen.   **/
   /* This will be used for scrolling back.                **/
   /* *******************************************************/

  if (MN1REC is ioError
   || MN2REC.MN1TYPE1 != "2")
    MN0UW1.MN0UFLG1 = "Y";
  else
    MN0UW1.MN0UKY2 = MN0UW1.MN0UKY2 + 1;
    MN0U2KY[MN0UKY2] = MNAUSER[1];
    set MN0UM005 initial;
    MN2REC.MN1KEY = " ";
    MN2REC.MN1TYPE1 = "2";
    MN0UW1.MN0UCTR = 0;
    MN0UW1.MN0UFLG2 = "Y";
    MN2REC.MN1USER = MN0UW1.MN0UW1-NEXT-USER;
    set MN1REC position;
  end






end // end MN0US4E

// set pointer to user id entered
Function MN0US4F()




      /* ********************************************************/
      /* *                                                     **/
      /* * If a user id was entered then set the pointer in the**/
      /* * file to that user.                                  **/
      /* *                                                     **/
      /* ********************************************************/

        /* mn0uflg2 is a flag used to branch back to the scan*/
        /* process.*/



  if (converseVar.eventKey is enter
   && MN0UM005.MN1USER != " ")
    MN2REC.MN1KEY = " ";
    MN2REC.MN1TYPE1 = "2";
    MN2REC.MN1USER = MN0UM005.MN1USER;
    set MN1REC position;
    MN0UW1.MN0UCTR = 0;
    set MN0UM005 initial;
    MN0UW1.MN0UFLG2 = "Y";
  end




end // end MN0US4F

// get selected user to inquire i
Function MN0US4G()




       /* *****************************************************/
       /* *                                                  **/
       /* *      Check to see if a user was selected to      **/
       /* *   inquire on.                                    **/
       /* *                                                  **/
       /* *****************************************************/



   /* **** Check to see if a user has been selected to inquiry*/
        /* apon.  Loop through each record on the screen looking*/
        /* for one to be selected.If one was selected then set*/
        /* the pointer in the MENU FILE to the first user*/
        /* application record for the user selected.*/

        /* mn0uw1.mn0uflg3 will be set when a user was selected*/
                        /* to inquiry on.*/


  if (converseVar.eventKey is enter)
  else
    return;
  end


  MN0UW1.MN0UIDX = 1;
  MN0UW1.MN0UFLG3 = "N";

  while (MN0UW1.MN0UIDX < 14
   && MN0UW1.MN0UFLG3 != "Y")
    MN0US4H();
    if (MN0UW1.MN0UFLG3 != "Y")
      MN0UW1.MN0UIDX = MN0UW1.MN0UIDX + 1;
    end
  end


   /* **** Set the pointer in the MENU FILE if*/
        /* a user was selected.*/

  if (MN0UW1.MN0UFLG3 == "Y")
    MN0UM005.MNASLCT[MN0UIDX] = " ";
    MN3REC.MN1KEY = " ";
    MN3REC.MN1USER = MN0UM005.MNAUSER[MN0UIDX];
    MN3REC.MN1TYPE1 = "3";
    set MN1REC position;
    MN0UM006.MN1USER = MN0UM005.MNAUSER[MN0UIDX];
    MN0UM006.MN2USRNM = MN0UM005.MNANAME[MN0UIDX];
    MN0UM006.XNDCD = MN0UM005.MNADEPT[MN0UIDX];
    if (MN0UM005.MNASTAT == "I")
      MN0UM006.MNASTATD = "INACTIVE";
    else
      if (MN0UM005.MNASTAT == "A")
        MN0UM006.MNASTATD = "ACTIVE";
      else
        MN0UM006.MNASTATD = MN0UM005.MNASTAT;
      end
    end
  end




end // end MN0US4G

// look for selected user
Function MN0US4H()




       /* *******************************************************/
       /* *                                                    **/
       /* *    Check for an S to be entered next to a user     **/
       /* *  record on the screen.                             **/
       /* *                                                    **/
       /* *******************************************************/


  if (MN0UM005.MNASLCT[MN0UIDX] == "S")
    MN0UW1.MN0UFLG3 = "Y";
  end




end // end MN0US4H

// process special function keys
Function MN0US4I()




       /* ******************************************************/
       /* *                                                   **/
       /* *    Transfer to the HELP or MAIN MENU applicatons. **/
       /* *                                                   **/
       /* ******************************************************/


   /* **** Transfer control to the appropriate application*/
        /* depending on which special key was pressed.*/
        /* Set the error flag to Y if control is passed back*/
        /* to this application.*/


   /* **** go to the help facility.*/

  if (converseVar.eventKey is pf1)
    XSPF1();
    MN0UW1.MN0UFLG1 = "Y";
    MN0UM009.MNAMSG = COMMAREA.CAMSG;
    return;
  end


   /* **** Return to the main menu*/

  if (converseVar.eventKey is pf4)
    XSPF4();
    MN0UW1.MN0UFLG1 = "Y";
    MN0UM009.MNAMSG = COMMAREA.CAMSG;
    return;
  end




end // end MN0US4I

// process fast path
Function MN0US4J()




        /* ******************************************************/
        /* *                                                   **/
        /* *    Process the fast path from the MN0UM006 screen **/
        /* *                                                   **/
        /* ******************************************************/


   /* **** Process the fast path.*/

  if (converseVar.eventKey is enter
   && MN0UM009.CATOAP != " ")
    move MN0UM009 to COMMAREA withV60Compat;
    XSEXIT();
    MN0UM009.MNAMSG = COMMAREA.CAMSG;
    set MN0UM009 alarm;
    set MN0UM009.CATOAP cursor, bold;
    MN0UW1.MN0UFLG1 = "Y";
    return;
  end




end // end MN0US4J

// set record key for scrolling
Function MN0US4K()




          /* ***************************************************/
          /* *                                                **/
          /* *  If the PF7 or PF8 key was pressed then perform**/
          /* *the statement group to handle each one.         **/
          /* *                                                **/
          /* ***************************************************/


   /* **** scroll back*/

  if (converseVar.eventKey is pf7)
    MN0US4L();
    return;
  end


   /* **** scroll forward*/

  if (converseVar.eventKey is pf8)
    MN0US4M();
    return;
  end




end // end MN0US4K

// process scroll back
Function MN0US4L()




       /* ***************************************************/
       /* *                                                **/
       /* *                 SCROLL BACK                    **/
       /* *                                                **/
       /* *    Set the pointer in the MENU FILE to the     **/
       /* *  previous user key in the key table.           **/
       /* *                                                **/
       /* ***************************************************/


   /* **** if the beginning of the table has been reached then*/
        /* set the pointer to the first user record in the file.*/

        /* mn0uflg2 is used to branch back to the scan process*/



  if (MN0UW1.MN0UKY3 < 1)
    MN0UW1.MN0UKY3 = 0;
    MN0UW1.MN0UFLG1 = "Y";
  else
    MN3REC.MN1TYPE1 = "3";
    MN3REC.MN1USER = MN0UW1.MN0UUSR;
    MN3REC.MN1TYPE2 = "3";
    MN3REC.MN1APPL = MN0UW3.MN0U3KY[MN0UKY3];
    MN0UW1.MN0UKY3 = MN0UW1.MN0UKY3 - 1;
    MN0UW1.MN0UCTR = 0;
    MN0UW1.MN0UFLG2 = "Y";
    set MN1REC position;
  end






end // end MN0US4L

// process scroll forward
Function MN0US4M()
       /* ***************************************************/
       /* *                                                **/
       /* *                 SCROLL FORWARD                 **/
       /* *                                                **/
       /* *                                                **/
       /* ***************************************************/
   /* **** mn0uflg2 is used to branch back to the scan process.*/
        /* mn0uflg1 is used to branch back to the converse.*/
        /* If the end of file is reached or the record type has*/
        /* changed then we want to keep what is on the screen*/

  if (MN1REC is ioError
   || MN3REC.MN1TYPE1 != "3"
   || MN3REC.MN1USER != MN0UW1.MN0UUSR)
    MN0UW1.MN0UFLG1 = "Y";
  else
    MN0UW1.MN0UKY3 = MN0UW1.MN0UKY3 + 1;
    MN0UW3.MN0U3KY[MN0UKY3] = MN0UW1.MN0UFAPP;

    MN0UW1.MN0UCTR = 0;
    MN0UW1.MN0UFLG2 = "Y";
    MN3REC.MN1TYPE1 = "3";
    MN3REC.MN1USER = MN0UW1.MN0UUSR;
    MN3REC.MN1TYPE2 = "3";
    MN3REC.MN1APPL = MN0UW1.MN0UW1-NEXT-MN0UFAPP;
    set MN1REC position;
  end






end // end MN0US4M

// process the function keys
Function MN0US5A()




       /* *******************************************************/
       /* *                                                    **/
       /* *        Process the function kyes.                  **/
       /* *                                                    **/
       /* *******************************************************/



   /* **** If the error flag is set by pass checking the PF*/
        /* keys. What this means is that an error has already*/
        /* been found previous to this statement group.*/

  if (MN0UW1.MN0UFLG1 == "Y")
    return;
  end


   /* **** Process the PF1 key.*/

  if (converseVar.eventKey is pf1)
    XSPF1();
    MN0UM007.MNAMSG = COMMAREA.CAMSG;
    set MN0UM007 alarm;
    MN0UW1.MN0UFLG1 = "Y";
    return;
  end


   /* **** Process the PF4 and PA2 key.*/

  if (converseVar.eventKey is pf4)
    XSPF4();
    MN0UM007.MNAMSG = COMMAREA.CAMSG;
    set MN0UM007 alarm;
    MN0UW1.MN0UFLG1 = "Y";
    return;
  end




end // end MN0US5A

// process the fast path
Function MN0US5B()




          /* ***************************************************/
          /* *                                                **/
          /* *      Process the fast path.                    **/
          /* *                                                **/
          /* ***************************************************/



   /* **** If the error flag is set by pass checking the PF*/
        /* keys. What this means is that an error has already*/
        /* been found previous to this statement group.*/

  if (MN0UW1.MN0UFLG1 == "Y")
    return;
  end


   /* **** Process the fast path.*/

  if (converseVar.eventKey is enter
   && MN0UM007.CATOAP != " ")
    move MN0UM007 to COMMAREA withV60Compat;
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.rollback();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
    
    XSEXIT();
    MN0UM007.MNAMSG = COMMAREA.CAMSG;
    set MN0UM007 alarm;
    set MN0UM007.CATOAP cursor, bold;
    MN0UW1.MN0UFLG1 = "Y";
    return;
  end




end // end MN0US5B

// verify entry of fields
Function MN0US5C()




       /* ****************************************************/
       /* *                                                 **/
       /* *     Validate the fields entered.                **/
       /* *                                                 **/
       /* ****************************************************/



   /* **** If the error flag is set by pass checking the PF*/
        /* keys. What this means is that an error has already*/
        /* been found previous to this statement group.*/

  if (MN0UW1.MN0UFLG1 == "Y")
    return;
  end


   /* **** Check for an invalid key being pressed.*/

  if (converseVar.eventKey is enter)
  else
    MN0UM007.MNAMSG = "MN0US5C - THAT KEY IS NOT SUPPORTED";
    set MN0UM007 alarm;
    MN0UW1.MN0UFLG1 = "Y";
    return;
  end


   /* **** The user id, application and option must all be*/
        /* entered.*/

  if (MN0UM007.MN1USER == " ")
    MN0UM007.MNAMSG = "USER ID MUST BE ENTERED";
    set MN0UM007 alarm;
    set MN0UM007.MN1USER bold;
    MN0UW1.MN0UFLG1 = "Y";
    return;
  end


  if (MN0UM007.MNAOPTN == " ")
    MN0UM007.MNAMSG = "OPTION A,C OR D MUST BE ENTERED";
    set MN0UM007 alarm;
    set MN0UM007.MNAOPTN cursor, bold;
    MN0UW1.MN0UFLG1 = "Y";
    return;
  end

  if (MN0UM007.MNAOPTN == "A"
   || MN0UM007.MNAOPTN == "C"
   || MN0UM007.MNAOPTN == "D")
  else
    MN0UM007.MNAMSG = "OPTION A,C OR D MUST BE ENTERED";
    set MN0UM007 alarm;
    set MN0UM007.MNAOPTN cursor, bold;
    MN0UW1.MN0UFLG1 = "Y";
    return;
  end


  if (MN0UM007.MN1APPL == " ")
    MN0UM007.MNAMSG = "APPLICATION MUST BE ENTERED";
    set MN0UM007 alarm;
    set MN0UM007.MN1APPL cursor, bold;
    MN0UW1.MN0UFLG1 = "Y";
    return;
  end

   /* ======================================================*/
  if (MN0UM007.MNAOPTN == "A")
    MN0UW1.MN1USER = MN0UM007.MN1USER;
    MN0UW1.MN1APPL = MN0UM007.MN1APPL;
    if (MN0UW1.MN0UWU01 == "&")
      if (MN0UW1.MN0UWA01 == "&")
        MN0UM007.MNAMSG = "YOU CANNOT PUT A PROFILE IN A PROFILE";
        set MN0UM007 alarm;
        set MN0UM007.MN1APPL cursor, bold;
        MN0UW1.MN0UFLG1 = "Y";
        return;
      else
        if (MN0UW1.MN0UWU2C == MN0UW1.MN0UWA2C)
          /* next*/
        else
          MN0UM007.MNAMSG = "ONLY APPLS FOR SAME SYSTEM ALLOWED";
          set MN0UM007 alarm;
          set MN0UM007.MN1APPL cursor, bold;
          MN0UW1.MN0UFLG1 = "Y";
          return;
        end
      end
    end
  end


end // end MN0US5C

// set screen flags protected
Function MN0US5D()




        /* *****************************************************/
        /* *                                                  **/
        /* *      Set the screen flangs to a protected state. **/
        /* *                                                  **/
        /* *****************************************************/



   /* **** Go through all the level flags on the application*/
        /* record.  Everytime an 'N' is found set the field*/
        /* on the screen to a protected state.*/

   /* ****   set inquriy fields to unprotect*/

  MN0UW1.MN0UIDX = 0;


  MN0UM007.MN3INQFL = MN1REC.MN1INQFL;
  if (MN1REC.MN1INQFL == "Y")
    set MN0UM007.MN3INQFL cursor, normal;
  end

  while (MN0UW1.MN0UIDX < 10)
    MN0UW1.MN0UIDX = MN0UW1.MN0UIDX + 1;
    MN0UM007.MN3ILVL[MN0UIDX] = "N";
    if (MN1REC.MN1ILVL[MN0UIDX] == "Y")
      set MN0UM007.MN3ILVL[MN0UIDX] normal;
    end
  end


   /* ****   set delete fields to unprotect*/

  MN0UW1.MN0UIDX = 0;

  MN0UM007.MN3DELFL = MN1REC.MN1DELFL;
  if (MN1REC.MN1DELFL == "Y")
    set MN0UM007.MN3DELFL cursor, normal;
  end


  while (MN0UW1.MN0UIDX < 10)
    MN0UW1.MN0UIDX = MN0UW1.MN0UIDX + 1;
    MN0UM007.MN3DLVL[MN0UIDX] = "N";
    if (MN1REC.MN1DLVL[MN0UIDX] == "Y")
      set MN0UM007.MN3DLVL[MN0UIDX] normal;
    end
  end


   /* ****   set change fields to unprotect*/

  MN0UW1.MN0UIDX = 0;

  MN0UM007.MN3CHGFL = MN1REC.MN1CHGFL;
  if (MN1REC.MN1CHGFL == "Y")
    set MN0UM007.MN3CHGFL cursor, normal;
  end


  while (MN0UW1.MN0UIDX < 10)
    MN0UW1.MN0UIDX = MN0UW1.MN0UIDX + 1;
    MN0UM007.MN3CLVL[MN0UIDX] = "N";
    if (MN1REC.MN1CLVL[MN0UIDX] == "Y")
      set MN0UM007.MN3CLVL[MN0UIDX] normal;
    end
  end


   /* ****   set add fields to unprotect*/

  MN0UW1.MN0UIDX = 0;

  MN0UM007.MN3ADDFL = MN1REC.MN1ADDFL;
  if (MN1REC.MN1ADDFL == "Y")
    set MN0UM007.MN3ADDFL cursor, normal;
  end


  while (MN0UW1.MN0UIDX < 10)
    MN0UW1.MN0UIDX = MN0UW1.MN0UIDX + 1;
    MN0UM007.MN3ALVL[MN0UIDX] = "N";
    if (MN1REC.MN1ALVL[MN0UIDX] == "Y")
      set MN0UM007.MN3ALVL[MN0UIDX] normal;
    end
  end

end // end MN0US5D

// user appl rec not found
Function MN0US5E()




        /* *******************************************************/
        /* *                                                    **/
        /* *      If the option selected is a C or D and no     **/
        /* *   user application record was found then this is   **/
        /* *   an error.                                        **/
        /* *                                                    **/
        /* *******************************************************/



   /* **** If the option selected was a C or D then no user*/
        /* application record is an error.*/

  if (MN0UM007.MNAOPTN == "C"
   || MN0UM007.MNAOPTN == "D")
    MN0UM007.MNAMSG = "USER APPLICATION RECORD NOT FOUND";
    set MN0UM007 alarm;
    set MN0UM007.MN1APPL cursor, bold;
    MN0UW1.MN0UFLG1 = "Y";
  end




end // end MN0US5E

// user appl rec found
Function MN0US5F()




        /* *****************************************************/
        /* *                                                  **/
        /* *     If the option selected was an A and a user   **/
        /* *  user application record was found then this is  **/
        /* *  an error.                                       **/
        /* *                                                  **/
        /* *****************************************************/



   /* **** If the option selected was an A then a user*/
        /* application record found is an error.*/

  if (MN0UM007.MNAOPTN == "A")
    MN0UM007.MNAMSG = "USER APPLICATION RECORD ALREADY EXISTS";
    set MN0UM007 alarm;
    set MN0UM007.MN1APPL cursor, bold;
    MN0UW1.MN0UFLG1 = "Y";
  end




end // end MN0US5F

// process the function keys
Function MN0US5G()




        /* ***************************************************/
        /* *                                                **/
        /* *      Process the function keys.                **/
        /* *                                                **/
        /* ***************************************************/



   /* **** If the error flag is set by pass checking the PF*/
        /* keys. What this means is that an error has already*/
        /* been found previous to this statement group.*/

  if (MN0UW1.MN0UFLG1 == "Y")
    return;
  end


   /* **** Process the PF1 key.*/

  if (converseVar.eventKey is pf1)
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.rollback();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
    
    XSPF1();
    MN0UM007.MNAMSG = COMMAREA.CAMSG;
    set MN0UM007 alarm;
    MN0UW1.MN0UFLG1 = "Y";
    return;
  end


   /* **** Process the PF4 key.*/

  if (converseVar.eventKey is pf4)
    VAGen_EZEREPLY = VGVar.handleSysLibraryErrors;	  // save value
    VGVar.handleSysLibraryErrors = 0;		// VAGEN (REPLY option omitted
    sysLib.rollback();
    VGVar.handleSysLibraryErrors = VAGen_EZEREPLY;		//restore value
    
    XSPF4();
    MN0UM007.MNAMSG = COMMAREA.CAMSG;
    set MN0UM007 alarm;
    MN0UW1.MN0UFLG1 = "Y";
    return;
  end




end // end MN0US5G

// verify screen fields
Function MN0US5H()




        /* ****************************************************/
        /* *                                                 **/
        /* *     Verify that screen fields entered.          **/
        /* *                                                 **/
        /* ****************************************************/



   /* **** Check to see if any of the fields have been changed.*/
        /* If they have then set a flag so the control can branch*/
        /* to the appropriate process.*/

        /* FLAGS - mn0uflg1  =  branch (where depends on which*/
                                     /* process it is being used*/
                                     /* in)*/
                /* mn0uflg2  =  branch back to get a new user*/
                             /* record*/
                /* mn0uflg3  =  branch back to get a new*/
                             /* application record*/
                /* mn0uflg4  =  branch back to the first converse*/


  if (MN0UM007.MN1USER is modified
   || MN0UM007.MN1USER == " ")
    if (MN0UM007.MN1USER == " ")
      MN0UW1.MN0UFLG1 = "Y";
      MN0UM007.MNAMSG = "USER ID MUST BE ENTERED";
      set MN0UM007.MN1USER cursor, bold;
      set MN0UM007 alarm;
      return;
    else
      MN0UW1.MN0UFLG2 = "Y";
    end
  end


  if (MN0UM007.MN1APPL is modified
   || MN0UM007.MN1APPL == " ")
    if (MN0UM007.MN1APPL == " ")
      MN0UW1.MN0UFLG1 = "Y";
      MN0UM007.MNAMSG = "APPLICATION ID MUST BE ENTERED";
      set MN0UM007.MN1APPL cursor, bold;
      set MN0UM007 alarm;
      return;
    else
      MN0UW1.MN0UFLG3 = "Y";
    end
  end


  if (MN0UM007.MNAOPTN is modified
   || MN0UM007.MNAOPTN == " ")
    if (MN0UM007.MNAOPTN == "A"
     || MN0UM007.MNAOPTN == "C"
     || MN0UM007.MNAOPTN == "D")
      MN0UW1.MN0UFLG2 = "Y";
    else
      MN0UW1.MN0UFLG1 = "Y";
      MN0UM007.MNAMSG = "OPTION MUST BE A,C OR D";
      set MN0UM007 alarm;
      set MN0UM007.MNAOPTN cursor, bold;
      return;
    end
  end




end // end MN0US5H

// set screen flags protected
Function MN0US5I()




        /* ****************************************************/
        /* *                                                 **/
        /* *      Set the screen flags to their originally   **/
        /* *   defined state.                                **/
        /* *                                                 **/
        /* ****************************************************/



   /* **** Set each of the flags on the screen to there original*/
        /* protected state.*/

  set MN0UM007.MN3ADDFL initialAttributes;
  set MN0UM007.MN3CHGFL initialAttributes;
  set MN0UM007.MN3DELFL initialAttributes;
  set MN0UM007.MN3INQFL initialAttributes;

  MN0UW1.MN0UIDX = 1;

  while (MN0UW1.MN0UIDX < 11)
    set MN0UM007.MN3ALVL[MN0UIDX] initialAttributes;
    set MN0UM007.MN3CLVL[MN0UIDX] initialAttributes;
    set MN0UM007.MN3DLVL[MN0UIDX] initialAttributes;
    set MN0UM007.MN3ILVL[MN0UIDX] initialAttributes;
    MN0UW1.MN0UIDX = MN0UW1.MN0UIDX + 1;
  end

  MN0UW1.MN0UUSR = MN0UM007.MN1USER;
  MN0UW1.MN0UAPPL = MN0UM007.MN1APPL;
  MN0UW1.MN0UOPTN = MN0UM007.MNAOPTN;
  set MN0UM007 initial;
  MN0UM007.MN1USER = MN0UW1.MN0UUSR;
  MN0UM007.MN1APPL = MN0UW1.MN0UAPPL;
  MN0UM007.MNAOPTN = MN0UW1.MN0UOPTN;




end // end MN0US5I

// set level flags to all n's
Function MN0USXB()




        /* *****************************************************/
        /* *                                                  **/
        /* *    If any of the flags are set to a 'N' then     **/
        /* *    all associated level flags must also be set   **/
        /* *    to 'N'.                                       **/
        /* *                                                  **/
        /* *****************************************************/

  if (MN3REC.MN3ADDFL == "N")
    MN3REC.MN3ADDTB = "NNNNNNNNNN";
  end


  if (MN3REC.MN3CHGFL == "N")
    MN3REC.MN3CHGTB = "NNNNNNNNNN";
  end


  if (MN3REC.MN3DELFL == "N")
    MN3REC.MN3DELTB = "NNNNNNNNNN";
  end


  if (MN3REC.MN3INQFL == "N")
    MN3REC.MN3INQTB = "NNNNNNNNNN";
  end




end // end MN0USXB

//*** RECORD=MN0UW1 ****
// ;
// ;
// ;
// ;
// ;         This is a working storage record for the menu user
// ;     application system.
// ;
// ;
// ;
// :   MAINTENANCE LOG
// ;
// ; open item |   date   | int |          comments
// ;-----------|----------|-----|------------------------------
// ;           |          |     |
// ;           |          |     |
// ;           |          |     |
// ;           |          |     |
// ;           |          |     |
// ;           |          |     |
// **********************
Record MN0UW1 type basicRecord
  10 MN0UCK MN0UCK ; 
    20 MN0UCK1 MN0UCK1 ; 
    20 MN0UCK2 MN0UCK2 ; 
      25 * char(3) ; 
      25 MN0UCKL MN0UCKL ; 
  10 MN0UIT MN0UIT ; 
    20 MN0UIT1 MN0UIT1 ; 
    20 MN0UIT2 MN0UIT2 ; 
    20 MN0UIT3 MN0UIT3 ; 
    20 MN0UIT4 MN0UIT4 ; 
  10 MN0UCTR MN0UCTR ; 
  10 MN0UIDX MN0UIDX ; 
  10 MN0UKY2 MN0UKY2 ; 
  10 MN0UKY3 MN0UKY3 ; 
  10 MN0UUSR MN0UUSR ; 
  10 MN0UAPPL MN0UAPPL ; 
  10 MN0UOPTN MN0UOPTN ; 
  10 MN0ULUSR MN0ULUSR ; 
  10 MN0UFAPP MN0UFAPP ; 
  10 MN0UFLG1 MN0UFLG1 ; 
  10 MN0UFLG2 MN0UFLG2 ; 
  10 MN0UFLG3 MN0UFLG3 ; 
  10 MN0UFLG4 MN0UFLG4 ; 
  10 MN0USVKY MN0USVKY ; 
  10 MN0UWDLF MN0UWDLF ; 
  10 MN0UWPF6 MN0UWPF6 ; 
  10 MN0UWF25 MN0UWF25 ; 
  10 MN0UWKIX MN0UWKIX ; 
  10 MN1APPL MN1APPL ; 
    15 MN0UWA2C MN0UWA2C ; 
      20 MN0UWA01 MN0UWA01 ; 
      20 * char(1) ; 
    15 * char(2) ; 
  10 MN1USER MN1USER ; 
    15 MN0UWU01 MN0UWU01 ; 
    15 MN0UWU2C MN0UWU2C ; 
    15 * char(5) ; 
  10 MN0UWKYG MN0UWKYG ; 
    20 MN0UWKEY MN0UWKEY [100] ; 
  10 MN1REC-GRP MN1REC-GRP [100] ; 
  10 * char(1) ; 
  10 MN0UW1-NEXT-USER MN0UW1-NEXT-USER ; 
  10 MN0UW1-NEXT-MN0UFAPP MN0UW1-NEXT-MN0UFAPP ; 
end // end MN0UW1

//*** RECORD=MN0UW2 ****
// ;
// ;
// ;
// ;
// ;         This is a working storage record for the menu user
// ;     application system.
// ;
// ;
// ;
// :   MAINTENANCE LOG
// ;
// ; open item |   date   | int |          comments
// ;-----------|----------|-----|------------------------------
// ;           |          |     |
// ;           |          |     |
// ;           |          |     |
// ;           |          |     |
// ;           |          |     |
// ;           |          |     |
// **********************
Record MN0UW2 type basicRecord
  10 MN0U2KY MN0U2KY [90] ; 
end // end MN0UW2

//*** RECORD=MN0UW3 ****
// ;
// ;
// ;
// ;
// ;         This is a working storage record for the menu user
// ;     application system.
// ;
// ;
// ;
// :   MAINTENANCE LOG
// ;
// ; open item |   date   | int |          comments
// ;-----------|----------|-----|------------------------------
// ;           |          |     |
// ;           |          |     |
// ;           |          |     |
// ;           |          |     |
// ;           |          |     |
// ;           |          |     |
// **********************
Record MN0UW3 type basicRecord
  10 MN0U3KY MN0U3KY [50] ; 
end // end MN0UW3

//*** RECORD=MN0UW4 ****
// user record definition - this record is a redefinition of
//             the mn1rec.  refer to the mn1rec prologue for
//             more explanation.
// **********************
Record MN0UW4 type basicRecord
  5 MN1REC-GRP MN1REC-GRP ; 
    10 MN0UW4-MN1KEY MN0UW4-MN1KEY ; 
      20 MN0UW4-MN1TYPE1 MN0UW4-MN1TYPE1 ; 
      20 MN0UW4-MN1USER MN0UW4-MN1USER ; 
      20 MN0UW4-MN1APKEY MN0UW4-MN1APKEY ; 
        30 MN0UW4-MN1TYPE2 MN0UW4-MN1TYPE2 ; 
        30 MN0UW4-MN1APPL MN0UW4-MN1APPL ; 
    10 MN0UW4-MN2USRNM MN0UW4-MN2USRNM ; 
    10 MN0UW4-XNDCD MN0UW4-XNDCD ; 
    10 MN0UW4-MN2STAT MN0UW4-MN2STAT ; 
    10 MN0UW4-XDVCD MN0UW4-XDVCD ; 
    10 MN0UW4-XWHCD MN0UW4-XWHCD ; 
    10 MN0UW4-XSOCD MN0UW4-XSOCD ; 
    10 * char(45) ; 
end // end MN0UW4

// menu key 2 table
DataItem MN0U2KY char(700)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// menu key 3 table
DataItem MN0U3KY char(200)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// saved application name
DataItem MN0UAPPL char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// userid to validate
DataItem MN0UCK char(8)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// userid to validate 1
DataItem MN0UCK1 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// userid to validate 2-8
DataItem MN0UCK2 char(7)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// userid to validate 5-8
DataItem MN0UCKL char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// working storage counter
DataItem MN0UCTR smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// first appl on the screen
DataItem MN0UFAPP char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// error flag
DataItem MN0UFLG1 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// special branching
DataItem MN0UFLG2 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// special branching
DataItem MN0UFLG3 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// special branching
DataItem MN0UFLG4 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// index to mn0um005 screen
DataItem MN0UIDX smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// common area item break down
DataItem MN0UIT char(20)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// passed option
DataItem MN0UIT1 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler
DataItem MN0UIT2 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// passed user id
DataItem MN0UIT3 char(7)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// filler
DataItem MN0UIT4 char(11)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// index to menu key 2 table
DataItem MN0UKY2 smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// index to menu key 3 table
DataItem MN0UKY3 smallint {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// last user id read
DataItem MN0ULUSR char(7)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// saved option
DataItem MN0UOPTN char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// save mn1key for scan
DataItem MN0USVKY char(14)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// user name used for compare
DataItem MN0UUSR char(7)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// first appl on the screen
DataItem MN0UW1-NEXT-MN0UFAPP char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// next user name for pf8
DataItem MN0UW1-NEXT-USER char(8)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// menu application key
DataItem MN0UW4-MN1APKEY char(5)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// menu application id
DataItem MN0UW4-MN1APPL char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// menu record key
DataItem MN0UW4-MN1KEY char(14)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// menu record type
DataItem MN0UW4-MN1TYPE1 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// menu record type
DataItem MN0UW4-MN1TYPE2 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// menu user id
DataItem MN0UW4-MN1USER char(8)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// menu user status
DataItem MN0UW4-MN2STAT char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// menu user name
DataItem MN0UW4-MN2USRNM char(30)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// XDV_DIV_CD
DataItem MN0UW4-XDVCD char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// XND_NIKE_DEPT_ID
DataItem MN0UW4-XNDCD char(4)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// XSO_SLS_OFC_ID
DataItem MN0UW4-XSOCD char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// XWH_WHSE_CD
DataItem MN0UW4-XWHCD char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// 1st char appl id
DataItem MN0UWA01 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// 1st 2 chars appl id
DataItem MN0UWA2C char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// DELETE PROCESS FLAG
DataItem MN0UWDLF char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// FIRST 25 U-APL REC DONE FLAG
DataItem MN0UWF25 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// SAVED U-APPL KEYS FOR DELETES
DataItem MN0UWKEY char(14)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// SAVED KEY INDEX
DataItem MN0UWKIX num(3)  {
  currency = no, numericSeparator = no, sign = none, align = right, 
  fillCharacter = " ", inputRequired = no
}
end

// SAVE AREA FOR U-APPL KEYS
DataItem MN0UWKYG char(1400)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// PF6 HIT ON DELETE USER FLAG
DataItem MN0UWPF6 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// 1st char user id
DataItem MN0UWU01 char(1)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

// nxt 2 chars user id
DataItem MN0UWU2C char(2)  {
  align = left, fillCharacter = nullFill, inputRequired = no
}
end

